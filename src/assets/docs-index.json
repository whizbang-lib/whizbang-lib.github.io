[
  {
    "slug": "v1.0.0/core-concepts/routing",
    "title": "Routing",
    "category": "Core Concepts",
    "order": 999,
    "description": "# Namespace-Based Routing\n\nWhizbang uses namespace-based routing to determine where messages flow. Commands and events follow distinct routing patterns optimized for their specific use cases.\n\n## Overview\n\nRouting in Whizbang is built on two key principles:\n\n1. **Commands → Shared Inbox**: All commands route to a single shared \"inbox\" topic. Services filter by owned namespaces using routing key patterns.\n2. **Events → Namespace Topics**: Events publish to namespace-specific topics. Services subscribe directly to namespaces they care about.\n\nThis separation provides:\n- **Point-to-point delivery** for commands (exactly one handler)\n- **Pub/sub distribution** for events (multiple subscribers)\n- **Automatic subscription discovery** via source generation\n\n## Command Flow\n\nCommands follow a point-to-point pattern with namespace-based filtering:\n\n```\nBFF sends CreateTenantCommand (namespace: MyApp.Users.Commands)\n    ↓\nBFF Outbox → Broker \"inbox\" topic\n    ↓\n    RoutingKey: \"myapp.users.commands.createtenantcommand\"\n    ↓\nALL services subscribed to \"inbox\" (single shared topic)\n    ↓\nEach service filters by owned namespaces:\n    - User Service owns \"myapp.users.commands\" → RECEIVES\n    - Workflow Service owns \"myapp.workflow.commands\" → FILTERED OUT\n    ↓\nUser Service processes command\n```\n\n### How Command Filtering Works\n\nWhen a service starts, it declares which command namespaces it owns:\n\n```csharp\nservices.Configure<RoutingOptions>(opts => {\n  opts.OwnDomains(\"myapp.users.commands\");\n  opts.OwnDomains(\"myapp.inventory.commands\");\n});\n```\n\nThe `SharedTopicInboxStrategy` builds routing patterns from these namespaces:\n\n```csharp\n// Generated routing patterns:\n// - \"whizbang.core.commands.system.#\"  (always included)\n// - \"myapp.users.commands.#\"\n// - \"myapp.inventory.commands.#\"\n```\n\n**Note**: All services automatically subscribe to system commands (`whizbang.core.commands.system.#`) for framework-level operations.\n\n### Wildcard Namespaces\n\nSupport pattern matching for flexible ownership:\n\n```csharp\n// Own all commands under myapp.orders\nopts.OwnDomains(\"myapp.orders.*\");\n// Converts to pattern: \"myapp.orders.#\"\n```\n\n## Event Flow\n\nEvents follow a pub/sub pattern with namespace-based topics:\n\n```\nUser Service publishes TenantCreatedEvent (namespace: MyApp.Users.Events)\n    ↓\nUser Service Outbox → Broker topic \"myapp.users.events\"\n    ↓\n    RoutingKey: \"tenantcreatedevent\"\n    ↓\nServices subscribed to \"myapp.users.events\":\n    - BFF → RECEIVES\n    - Workflow Service → RECEIVES\n    - Notifications Service → RECEIVES\n```\n\n### Automatic Event Subscription Discovery\n\nEvent subscriptions are **automatically discovered** from your code via source generation:\n\n1. **Perspectives**: Events your service projects\n2. **Receptors**: Events your service handles\n\n```csharp\n// This perspective automatically subscribes to \"myapp.orders.events\"\n[Perspective<OrderSummary>]\npublic class OrderSummaryPerspective : IPerspective<OrderCreatedEvent> {\n  // OrderCreatedEvent is in namespace MyApp.Orders.Events\n}\n\n// This receptor automatically subscribes to \"myapp.payments.events\"\npublic class PaymentReceptor : IReceptor<PaymentCompletedEvent> {\n  // PaymentCompletedEvent is in namespace MyApp.Payments.Events\n}\n```\n\nThe `EventNamespaceRegistryGenerator` source generator extracts these namespaces at compile time:\n\n```csharp\n// Generated code (example)\npublic sealed class GeneratedEventNamespaceRegistry : IEventNamespaceRegistry {\n  public IReadOnlySet<string> GetPerspectiveEventNamespaces() =>\n    new HashSet<string>(StringComparer.OrdinalIgnoreCase) {\n      \"myapp.orders.events\"\n    };\n\n  public IReadOnlySet<string> GetReceptorEventNamespaces() =>\n    new HashSet<string>(StringComparer.OrdinalIgnoreCase) {\n      \"myapp.payments.events\"\n    };\n}\n```\n\n### Manual Event Subscriptions\n\nOverride or supplement auto-discovery with manual subscriptions:\n\n```csharp\nservices.Configure<RoutingOptions>(opts => {\n  // Explicitly subscribe to additional event namespaces\n  opts.SubscribeTo(\"myapp.notifications.events\");\n  opts.SubscribeTo(\"myapp.audit.events\");\n});\n```\n\n## System Commands\n\nAll services automatically subscribe to system commands for framework-level operations:\n\n```csharp\nnamespace Whizbang.Core.Commands.System;\n\n// Rebuild a perspective across all services\npublic record RebuildPerspectiveCommand(\n    string PerspectiveName,\n    long? FromEventId = null\n) : ICommand;\n\n// Clear cached data\npublic record ClearCacheCommand(\n    string? CacheKey = null,\n    string? CacheRegion = null\n) : ICommand;\n\n// Collect diagnostics from all services\npublic record DiagnosticsCommand(\n    DiagnosticType Type,\n    Guid? CorrelationId = null\n) : ICommand;\n\n// Pause message processing (coordinated maintenance)\npublic record PauseProcessingCommand(\n    int? DurationSeconds = null,\n    string? Reason = null\n) : ICommand;\n\n// Resume message processing\npublic record ResumeProcessingCommand(\n    string? Reason = null\n) : ICommand;\n```\n\n### Sending System Commands\n\n```csharp\n// Rebuild a perspective across all services\nawait dispatcher.SendAsync(new RebuildPerspectiveCommand(\"OrderSummary\"));\n\n// Clear all caches\nawait dispatcher.SendAsync(new ClearCacheCommand());\n\n// Pause processing for 5 minutes\nawait dispatcher.SendAsync(new PauseProcessingCommand(\n    DurationSeconds: 300,\n    Reason: \"Scheduled maintenance\"\n));\n```\n\n## Configuration\n\n### Fluent Configuration with WithRouting {#with-routing}\n\nThe recommended approach uses the fluent `WithRouting()` extension method:\n\n```csharp\nservices.AddWhizbang()\n    .WithRouting(routing => {\n        routing\n            .OwnDomains(\"myapp.users.commands\")\n            .SubscribeTo(\"myapp.notifications.events\")\n            .Inbox.UseSharedTopic(\"inbox\");\n    })\n    .WithEFCore<MyDbContext>()\n    .WithDriver.Postgres\n    .AddTransportConsumer();  // Auto-generates subscriptions!\n```\n\nThis approach:\n- **Chains with other Whizbang configuration** - Integrates with EF Core, drivers, and transport setup\n- **Auto-generates subscriptions** - When paired with `AddTransportConsumer()`, subscriptions are created automatically\n- **Type-safe** - All configuration is compile-time verified\n\n### Complete Example\n\n```csharp\n// User Service - handles user commands, subscribes to order events\nservices.AddWhizbang()\n    .WithRouting(routing => {\n        // Commands this service handles\n        routing.OwnDomains(\"myapp.users.commands\");\n\n        // Events are auto-discovered from perspectives/receptors\n        // Manual override (adds to auto-discovered):\n        routing.SubscribeTo(\"myapp.notifications.events\");\n\n        // Inbox strategy\n        routing.Inbox.UseSharedTopic(\"inbox\");\n    })\n    .AddTransportConsumer();\n\n// BFF Service - sends commands, receives events\nservices.AddWhizbang()\n    .WithRouting(routing => {\n        // No OwnDomains (BFF doesn't handle commands directly)\n        // Events auto-discovered from its receptors/perspectives\n        routing.Inbox.UseSharedTopic(\"inbox\");\n    })\n    .AddTransportConsumer();\n```\n\n### Legacy Configuration\n\nFor backwards compatibility, you can still configure routing options directly:\n\n```csharp\nservices.Configure<RoutingOptions>(opts => {\n  opts.OwnDomains(\"myapp.users.commands\");\n  opts.SubscribeTo(\"myapp.notifications.events\");\n});\n```\n\n### Strongly-Typed Configuration\n\nUse the generic overloads for compile-time safety and refactor-friendly configuration:\n\n```csharp\nservices.Configure<RoutingOptions>(opts => {\n  // Strongly-typed: extracts namespace from the type\n  opts.OwnNamespaceOf<CreateUserCommand>()      // \"myapp.users.commands\"\n      .OwnNamespaceOf<UpdateInventoryCommand>() // \"myapp.inventory.commands\"\n      .SubscribeToNamespaceOf<OrderCreatedEvent>()   // \"myapp.orders.events\"\n      .SubscribeToNamespaceOf<PaymentCompletedEvent>(); // \"myapp.payments.events\"\n\n  // Can mix with string-based for wildcards\n  opts.OwnDomains(\"myapp.legacy.*\");\n});\n```\n\n**Benefits:**\n- **Compile-time safety** - Invalid types won't compile\n- **Refactor-friendly** - Rename/move types automatically updates references\n- **IDE navigation** - Ctrl+click to go to type definition\n- **No magic strings** - For known namespaces\n\n### Inbox Strategies\n\nTwo inbox routing strategies are available:\n\n#### SharedTopicInboxStrategy (Default)\n\nAll commands go to a single \"inbox\" topic with namespace-based filtering:\n\n```csharp\nservices.Configure<RoutingOptions>(opts => {\n  opts.Inbox.UseSharedTopic(\"inbox\");  // Default\n});\n```\n\n#### DomainTopicInboxStrategy\n\nEach domain gets its own inbox topic:\n\n```csharp\nservices.Configure<RoutingOptions>(opts => {\n  opts.Inbox.UseDomainTopics(\".in\");\n  // Creates topics: \"myapp.users.in\", \"myapp.orders.in\", etc.\n});\n```\n\n## Domain Topic Provisioning {#domain-topic-provisioning}\n\n:::new\nWhen a service declares domain ownership via `OwnDomains()`, Whizbang automatically provisions the corresponding topics/exchanges on the message broker at worker startup. This ensures the domain owner (publisher) creates infrastructure that subscribers will use.\n:::\n\n### How It Works\n\nAt `TransportConsumerWorker` startup, before creating subscriptions:\n\n1. The worker checks for a registered `IInfrastructureProvisioner`\n2. If present, it calls `ProvisionOwnedDomainsAsync()` with the service's owned domains\n3. The provisioner creates topics/exchanges for each owned domain\n4. Then subscriptions are created as normal\n\n```csharp\n// When you configure:\nservices.AddWhizbang()\n    .WithRouting(routing => {\n        routing.OwnDomains(\"myapp.users\", \"myapp.orders\");\n    })\n    .AddTransportConsumer();\n\n// At startup, these topics are automatically provisioned:\n// - myapp.users (topic/exchange)\n// - myapp.orders (topic/exchange)\n```\n\n### Transport-Specific Behavior\n\n| Transport | Provisioned Resource | Idempotent |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/scoping",
    "title": "Scoping",
    "category": "Core Concepts",
    "order": 999,
    "description": "# Scoping System\n\nWhizbang's scoping system provides flexible multi-tenancy and data isolation through composable filters, enabling tenant, user, organization, and principal-based access patterns.\n\n## Overview\n\nScoping in Whizbang separates data isolation concerns from your domain models:\n\n- **PerspectiveScope** - Metadata stored with each row (TenantId, UserId, etc.)\n- **ScopeFilter** - Composable flags for query filtering\n- **ScopeFilterBuilder** - Builds filter info from flags and context\n- **IScopedLensFactory** - Resolves lenses with scope filters applied\n\n## PerspectiveScope\n\n`PerspectiveScope` is stored in the `scope` column of perspective rows, separate from your data model.\n\n```csharp\npublic record PerspectiveScope {\n  // Standard scope properties\n  public string? TenantId { get; init; }\n  public string? UserId { get; init; }\n  public string? OrganizationId { get; init; }\n  public string? CustomerId { get; init; }\n\n  // Security principal access list\n  public IReadOnlyList<SecurityPrincipalId>? AllowedPrincipals { get; init; }\n\n  // Custom extension properties\n  public IReadOnlyDictionary<string, string?>? Extensions { get; init; }\n\n  // Unified indexer access\n  public string? this[string key] => ...;\n}\n```\n\n### Why Separate from Data?\n\nStoring scope separately from your domain data provides:\n\n1. **Clean domain models** - Your `Order` class doesn't need `TenantId`\n2. **Consistent filtering** - All perspectives filter the same way\n3. **Flexible extensions** - Add custom scope properties without schema changes\n4. **Security isolation** - Scope enforcement happens at infrastructure level\n\n### Accessing Scope Values\n\n```csharp\nvar scope = new PerspectiveScope {\n  TenantId = \"tenant-123\",\n  UserId = \"user-456\",\n  Extensions = new Dictionary<string, string?> {\n    [\"department\"] = \"Engineering\",\n    [\"region\"] = \"us-west\"\n  }\n};\n\n// Via properties\nvar tenant = scope.TenantId;  // \"tenant-123\"\n\n// Via indexer (standard + extensions)\nvar tenant = scope[\"TenantId\"];     // \"tenant-123\"\nvar dept = scope[\"department\"];     // \"Engineering\"\nvar unknown = scope[\"unknown\"];     // null\n```\n\n## Scope Filters\n\n`ScopeFilter` is a flags enum for composable filtering.\n\n```csharp\n[Flags]\npublic enum ScopeFilter {\n  None = 0,           // No filtering (global access)\n  Tenant = 1 << 0,    // Filter by TenantId\n  Organization = 1 << 1,\n  Customer = 1 << 2,\n  User = 1 << 3,      // Filter by UserId\n  Principal = 1 << 4  // Filter by security principal overlap\n}\n```\n\n### Filter Composition\n\nCombine filters with bitwise OR:\n\n```csharp\n// Single filter\nvar tenantOnly = ScopeFilter.Tenant;\n\n// Multiple filters (AND'd together)\nvar tenantAndUser = ScopeFilter.Tenant | ScopeFilter.User;\n\n// Complex combination\nvar complex = ScopeFilter.Tenant | ScopeFilter.Organization | ScopeFilter.Principal;\n```\n\n### Filter Application\n\n| Filter | Generated WHERE |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/security",
    "title": "Security",
    "category": "Core Concepts",
    "order": 999,
    "description": "# Security System\n\nWhizbang provides a comprehensive security system supporting RBAC (Role-Based Access Control) and ABAC (Attribute-Based Access Control) patterns with composable scope filters, permission checks, and security event auditing.\n\n## Overview\n\nThe security system consists of:\n\n- **Permissions** - Type-safe permission identifiers with wildcard matching\n- **Roles** - Named collections of permissions\n- **Scope Context** - Ambient security context for current operation\n- **Security Principals** - Users, groups, and services with hierarchical membership\n- **Scoped Lens Factory** - Permission-aware lens resolution with composable filters\n- **System Events** - Security audit trail (AccessDenied, AccessGranted, etc.)\n\n## Permissions\n\nPermissions use a `resource:action` pattern and support wildcard matching.\n\n```csharp\n// Factory methods for common patterns\nvar readOrders = Permission.Read(\"orders\");      // \"orders:read\"\nvar writeOrders = Permission.Write(\"orders\");    // \"orders:write\"\nvar deleteOrders = Permission.Delete(\"orders\");  // \"orders:delete\"\nvar adminOrders = Permission.Admin(\"orders\");    // \"orders:admin\"\nvar allOrders = Permission.All(\"orders\");        // \"orders:*\"\n\n// Custom permissions\nvar permission = new Permission(\"orders:export\");\n\n// Wildcard matching\nvar allResources = new Permission(\"*:*\");        // Matches everything\nvar allOrderActions = Permission.All(\"orders\");  // Matches orders:*\n```\n\n### Wildcard Rules\n\n| Permission | Matches |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/system-events",
    "title": "System Events",
    "category": "Core Concepts",
    "order": 999,
    "description": "",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/transport-consumer",
    "title": "Transport Consumer",
    "category": "Core Concepts",
    "order": 999,
    "description": "# Transport Consumer\n\nThe transport consumer automatically subscribes to message broker destinations and processes incoming messages. When combined with `WithRouting()`, subscriptions are auto-generated from your routing configuration.\n\n## Overview\n\nThe `AddTransportConsumer()` extension method:\n\n1. **Auto-generates subscriptions** from `RoutingOptions` configured via `WithRouting()`\n2. **Registers `TransportConsumerOptions`** with populated destinations\n3. **Starts `TransportConsumerWorker`** as a hosted service\n\n## Auto-Configuration {#auto-configuration}\n\nThe recommended approach chains `WithRouting()` and `AddTransportConsumer()`:\n\n```csharp\nservices.AddWhizbang()\n    .WithRouting(routing => {\n        routing\n            .OwnDomains(\"myapp.orders.commands\")\n            .SubscribeTo(\"myapp.payments.events\")\n            .Inbox.UseSharedTopic(\"inbox\");\n    })\n    .WithEFCore<OrderDbContext>()\n    .WithDriver.Postgres\n    .AddTransportConsumer();\n```\n\nThis auto-generates subscriptions:\n- **Inbox subscription** from `OwnDomains()` - Filters commands by namespace pattern\n- **Event subscriptions** from `SubscribeTo()` - Subscribes to each namespace topic\n- **Auto-discovered events** from perspectives and receptors\n\n### What Gets Generated\n\nFor the configuration above, `AddTransportConsumer()` generates:\n\n| Destination | Address | Routing Key |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/data/efcore-json-configuration",
    "title": "EF Core 10 JSON Configuration",
    "category": "Data",
    "order": 10,
    "description": "Configuring EF Core 10 with custom JSON converters for JSONB columns",
    "tags": "efcore, json, jsonb, postgresql, npgsql, converters",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/data/schema-migration",
    "title": "Schema Migration",
    "category": "data",
    "order": 999,
    "description": "# Schema Migration\n\nWhizbang provides automatic schema management for perspective tables, with built-in drift detection and safe rename operations. This page covers how Whizbang handles schema changes across deployments.\n\n## Automatic Schema Creation\n\nWhen your application starts, Whizbang automatically creates all required infrastructure tables and perspective tables:\n\n```csharp\n// In your startup code\nawait dbContext.EnsureWhizbangDatabaseInitializedAsync();\n```\n\nThis single call:\n1. Creates infrastructure tables (`wh_inbox`, `wh_outbox`, `wh_event_store`, etc.)\n2. Creates perspective tables for all discovered perspectives\n3. Registers perspectives in the [perspective registry](/docs/v1.0.0/perspectives/registry)\n4. Detects and logs any schema drift\n\n## Schema Drift Detection\n\nSchema drift occurs when your C# perspective definition doesn't match the database table. Whizbang detects this by comparing SHA-256 hashes of the schema definition.\n\n### Detection Flow\n\n```\n┌─────────────────────┐\n│  Compile Time       │\n├─────────────────────┤\n│ Generate schema     │\n│ JSON from C# class  │\n│ Compute SHA-256     │\n│ hash of schema      │\n└─────────┬───────────┘\n          │\n          ▼\n┌─────────────────────┐\n│  Runtime            │\n├─────────────────────┤\n│ Compare hash with   │\n│ stored hash in      │\n│ perspective_registry│\n└─────────┬───────────┘\n          │\n          ▼\n┌─────────────────────┐\n│  If Different       │\n├─────────────────────┤\n│ Log drift warning   │\n│ Update registry     │\n└─────────────────────┘\n```\n\n### What Causes Drift\n\n| Change Type | Example | Drift Detected? |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/guides/implementing-multi-tenancy",
    "title": "Implementing Multi Tenancy",
    "category": "guides",
    "order": 999,
    "description": "",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/lenses/raw-sql",
    "title": "Raw Sql",
    "category": "lenses",
    "order": 999,
    "description": "",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/lenses/vector-search",
    "title": "Vector Search",
    "category": "lenses",
    "order": 999,
    "description": "# Vector Similarity Search\n\nWhizbang supports pgvector similarity queries for semantic search, embeddings, and AI/ML workloads.\n\n## Prerequisites\n\nWhen using `[VectorField]` attributes on your perspective models, you must add the Pgvector.EntityFrameworkCore package:\n\n```xml\n<PackageReference Include=\"Pgvector.EntityFrameworkCore\" Version=\"0.3.0\" />\n```\n\nIf you forget this package, the WHIZ070 diagnostic will guide you:\n\n> WHIZ070: Property 'Embedding' uses [VectorField] but Pgvector.EntityFrameworkCore package is not referenced.\n\n## Defining Vector Fields\n\nAdd `[VectorField]` to properties in your perspective model:\n\n```csharp\npublic class DocumentModel {\n  public Guid Id { get; init; }\n  public string Title { get; init; } = \"\";\n  public string Content { get; init; } = \"\";\n\n  [VectorField(1536)]  // OpenAI ada-002 dimensions\n  public float[]? ContentEmbedding { get; init; }\n\n  [VectorField(1536)]  // For comparison operations\n  public float[]? SummaryEmbedding { get; init; }\n}\n\npublic class UserPreferenceModel {\n  public Guid UserId { get; init; }\n\n  [VectorField(1536)]\n  public float[]? PreferenceEmbedding { get; init; }\n}\n```\n\nThe generator creates pgvector shadow properties with appropriate indexes.\n\n## Usage Patterns\n\nAll methods use **strongly-typed lambda selectors** for compile-time safety.\n\n### Pattern 1: App-Side Vector (Search Query)\n\nUse when the search vector comes from your application (e.g., embedding a user's search query):\n\n```csharp\n// Get embedding from your embedding service (OpenAI, etc.)\nvar searchEmbedding = await embeddingService.EmbedAsync(userSearchQuery);\n\n// Find documents similar to the search query\nvar results = await documentLens.Query\n    .OrderByCosineDistance(m => m.ContentEmbedding, searchEmbedding)\n    .Take(10)\n    .ToListAsync();\n```\n\n**SQL Generated:**\n```sql\nSELECT * FROM documents\nORDER BY content_embedding <=> @p0 ASC\nLIMIT 10\n```\n\n### Pattern 2: Same-Table Column Comparison\n\nUse when comparing two vector columns on the same row (100% SQL, no vector data round-trip):\n\n```csharp\n// Find documents where content differs significantly from summary\n// (potential quality issue - summary doesn't match content)\nvar mismatchedDocs = await documentLens.Query\n    .Where(m => m.ContentEmbedding != null && m.SummaryEmbedding != null)\n    .OrderByCosineDistance(m => m.ContentEmbedding, m => m.SummaryEmbedding)\n    .ThenByDescending(m => m.Data.CreatedAt)  // Most different first, then newest\n    .Take(20)\n    .ToListAsync();\n\n// Find documents where content and summary are similar (well-summarized)\nvar wellSummarized = await documentLens.Query\n    .WithinCosineDistance(m => m.ContentEmbedding, m => m.SummaryEmbedding, threshold: 0.2)\n    .ToListAsync();\n```\n\n**SQL Generated:**\n```sql\n-- No vector data sent to/from C# - all computed in PostgreSQL!\nSELECT * FROM documents\nWHERE content_embedding IS NOT NULL AND summary_embedding IS NOT NULL\nORDER BY content_embedding <=> summary_embedding ASC\nLIMIT 20\n```\n\n### Pattern 3: Cross-Table Comparison (Joins)\n\nUse when comparing vectors from different tables:\n\n```csharp\n// Find documents that match a user's preferences\nvar userId = currentUserId;\n\nvar recommendations = await documentLens.Query\n    .SelectMany(\n        doc => userPreferenceLens.Query.Where(up => up.Data.UserId == userId),\n        (doc, pref) => new { Document = doc, Preference = pref })\n    .OrderByCosineDistance(\n        x => x.Document.Data.ContentEmbedding,    // From documents table\n        x => x.Preference.Data.PreferenceEmbedding)  // From user_preferences table\n    .Select(x => x.Document)\n    .Take(10)\n    .ToListAsync();\n```\n\n**SQL Generated:**\n```sql\nSELECT d.* FROM documents d\nJOIN user_preferences up ON up.user_id = @userId\nORDER BY d.content_embedding <=> up.preference_embedding ASC\nLIMIT 10\n```\n\n### Pattern 4: Filtering by Distance Threshold\n\nUse when you only want results within a certain similarity range:\n\n```csharp\nvar searchEmbedding = await embeddingService.EmbedAsync(userQuery);\n\n// Only return documents with cosine distance < 0.3 (very similar)\nvar closeMatches = await documentLens.Query\n    .WithinCosineDistance(m => m.ContentEmbedding, searchEmbedding, threshold: 0.3)\n    .OrderByCosineDistance(m => m.ContentEmbedding, searchEmbedding)\n    .ToListAsync();\n```\n\n**SQL Generated:**\n```sql\nSELECT * FROM documents\nWHERE content_embedding <=> @p0 < 0.3\nORDER BY content_embedding <=> @p0 ASC\n```\n\n### Pattern 5: Combined Filter + Sort + Project\n\nUse when you need distance/similarity scores in your results:\n\n:::updated\n**Important**: `WithCosineDistance` must be used as the **final projection** before `ToListAsync()`.\nYou cannot chain `.OrderBy(r => r.Distance)` or `.Where(r => r.Distance < x)` after it - use\n`OrderByCosineDistance` and `WithinCosineDistance` for SQL-side operations first.\n:::\n\n```csharp\nvar searchEmbedding = await embeddingService.EmbedAsync(userQuery);\n\n// Filter -> Sort -> Project with scores\nvar results = await documentLens.Query\n    .WithinCosineDistance(m => m.ContentEmbedding, searchEmbedding, threshold: 0.5)\n    .OrderByCosineDistance(m => m.ContentEmbedding, searchEmbedding)\n    .WithCosineDistance(m => m.ContentEmbedding, searchEmbedding)\n    .Take(10)\n    .ToListAsync();\n\nforeach (var result in results) {\n  Console.WriteLine($\"{result.Row.Data.Title}: {result.Similarity:P0} match\");\n  // Output: \"My Document: 95% match\"\n}\n```\n\nReturns `VectorSearchResult<TModel>` with:\n- `Row` - The perspective row\n- `Distance` - Cosine distance (0 = identical, 2 = opposite)\n- `Similarity` - Similarity score (1 = identical, -1 = opposite)\n\n## Query Extension Reference\n\n### Ordering Methods\n\n| Method | PostgreSQL Operator | Use Case |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/perspectives/registry",
    "title": "Registry",
    "category": "perspectives",
    "order": 999,
    "description": "# Perspective Registry\n\nThe perspective registry is a system table that tracks the mapping between your C# perspective types and their corresponding database tables. It enables automatic schema management, drift detection, and safe table renaming across deployments.\n\n## Overview\n\nWhen Whizbang creates perspective tables, it registers metadata about each perspective in the `wh_perspective_registry` table. This enables:\n\n| Feature | Description |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/perspectives/table-naming",
    "title": "Table Naming",
    "category": "perspectives",
    "order": 999,
    "description": "# Perspective Table Naming\n\nWhizbang automatically generates database table names for your perspectives using configurable naming conventions. By default, common suffixes like `Projection`, `Model`, and `Dto` are stripped to create cleaner, shorter table names.\n\n## Default Behavior\n\nWhen you define a perspective, Whizbang converts the class name to snake_case and adds the `wh_per_` prefix:\n\n| C# Class Name | Default Table Name |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/perspectives/temporal",
    "title": "Temporal",
    "category": "perspectives",
    "order": 999,
    "description": "# Temporal Perspectives\n\nTemporal perspectives create append-only logs where each event creates a NEW row rather than updating existing rows. This pattern is ideal for activity feeds, audit logs, and full history tracking.\n\n## Overview\n\n| Pattern | Interface | Storage | Use Case |\n|",
    "tags": [],
    "version": "v1.0.0"
  }
]