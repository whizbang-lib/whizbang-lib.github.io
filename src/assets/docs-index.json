[
  {
    "slug": "v1.0.0/README",
    "title": "Version 0.1.0 - Foundation Release",
    "category": "Implementation",
    "order": 1,
    "description": "The foundation release of Whizbang establishing all core components with comprehensive testing and IDE support",
    "tags": "v0.1.0, foundation, implementation",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/advanced-topics/deployment-strategies",
    "title": "Deployment Strategies",
    "category": "Advanced Topics",
    "order": 7,
    "description": "Deployment patterns - blue-green, canary, rolling updates, feature flags, and rollback strategies",
    "tags": "deployment, blue-green, canary, rolling-update, feature-flags, kubernetes",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/advanced-topics/monitoring",
    "title": "Monitoring & Observability",
    "category": "Advanced Topics",
    "order": 6,
    "description": "Application monitoring - Application Insights, Prometheus, distributed tracing, metrics, and dashboards",
    "tags": "monitoring, observability, application-insights, prometheus, tracing, metrics",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/advanced-topics/multi-tenancy",
    "title": "Multi-Tenancy Patterns",
    "category": "Advanced Topics",
    "order": 4,
    "description": "Multi-tenancy architecture patterns - database-per-tenant, schema-per-tenant, row-level security",
    "tags": "multi-tenancy, saas, database-per-tenant, row-level-security, isolation",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/advanced-topics/native-aot",
    "title": "Native AOT",
    "category": "Advanced Topics",
    "order": 3,
    "description": "Deploy with Native AOT - zero reflection, trim-safe code, and AOT-compatible patterns",
    "tags": "native-aot, aot, reflection, trim-safe, deployment",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/advanced-topics/performance-tuning",
    "title": "Performance Tuning",
    "category": "Advanced Topics",
    "order": 1,
    "description": "Optimize Whizbang performance - zero-allocation patterns, pooling, batching, and profiling",
    "tags": "performance, optimization, profiling, zero-allocation, pooling",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/advanced-topics/scaling",
    "title": "Scaling Patterns",
    "category": "Advanced Topics",
    "order": 8,
    "description": "Horizontal scaling - autoscaling, partitioning, load balancing, and performance under load",
    "tags": "scaling, horizontal-scaling, partitioning, load-balancing, autoscaling, performance",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/advanced-topics/security",
    "title": "Security Best Practices",
    "category": "Advanced Topics",
    "order": 5,
    "description": "Security guidelines - authentication, authorization, encryption, secrets management, OWASP Top 10",
    "tags": "security, authentication, authorization, encryption, owasp, secrets",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/advanced-topics/testing-receptors",
    "title": "Testing Receptors & Perspectives",
    "category": "Advanced Topics",
    "order": 2,
    "description": "Unit testing patterns for receptors and perspectives - mocking, fixtures, and test strategies",
    "tags": "testing, unit-tests, mocking, tunit, fixtures",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/advanced-topics/troubleshooting",
    "title": "Troubleshooting Guide",
    "category": "Advanced Topics",
    "order": 9,
    "description": "Common issues, debugging techniques, diagnostic tools, and solutions",
    "tags": "troubleshooting, debugging, diagnostics, common-issues, solutions",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/architecture/message-lifecycle",
    "title": "Message Lifecycle & Architecture",
    "category": "Architecture",
    "order": 1,
    "description": "Complete guide to message flow through Whizbang - Commands, Events, Work Coordinator, and all the hooks between Dispatcher, Receptors, Perspectives, and Outbox/Inbox",
    "tags": "architecture, message-lifecycle, command-flow, event-flow, work-coordinator, sequence-diagrams",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/attributes/streamkey",
    "title": "StreamKey Attribute",
    "category": "Attributes",
    "order": 999,
    "description": "Marks a property as the stream key for event sourcing and perspective event ordering",
    "tags": [
      "attributes",
      "streamkey",
      "perspectives",
      "event-sourcing",
      "source-generator"
    ],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/components/README",
    "title": "Core Components Overview",
    "category": "Components",
    "order": 1,
    "description": "Overview of all core components in Whizbang v0.1.0",
    "tags": "components, architecture, overview",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/components/dispatcher",
    "title": "Dispatcher Component",
    "category": "Components",
    "order": 2,
    "description": "Core message routing and orchestration with basic handler discovery",
    "tags": "dispatcher, routing, orchestration, mediator, v0.1.0",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/components/drivers",
    "title": "Drivers Component",
    "category": "Components",
    "order": 8,
    "description": "Basic in-memory storage driver for development and testing",
    "tags": "drivers, storage, in-memory, abstraction, v0.1.0",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/components/ledger",
    "title": "Ledger Component",
    "category": "Components",
    "order": 7,
    "description": "In-memory event store with basic append and read operations",
    "tags": "ledger, event-store, events, in-memory, v0.1.0",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/components/lenses",
    "title": "Lenses Component",
    "category": "Components",
    "order": 5,
    "description": "Read-only interfaces for querying data - the query side of Whizbang's CQRS implementation",
    "tags": "lenses, queries, read-model, cqrs, v0.1.0",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/components/perspectives",
    "title": "Perspectives Component",
    "category": "Components",
    "order": 4,
    "description": "Event handlers that update various views of your data - the write side of Whizbang",
    "tags": "perspectives, events, views, write-model, v0.1.0",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/components/policy-engine",
    "title": "Policy Engine Component",
    "category": "Components",
    "order": 6,
    "description": "Cross-cutting concerns as composable policies - retry, timeout, cache, and circuit breaker",
    "tags": "policies, cross-cutting, resilience, caching, v0.1.0",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/components/receptors",
    "title": "Receptors Component",
    "category": "Components",
    "order": 3,
    "description": "Command receivers that make decisions and emit events - the foundation of Whizbang's event-driven architecture",
    "tags": "receptors, commands, events, stateless, v0.1.0",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/components/transports",
    "title": "Transports Component",
    "category": "Components",
    "order": 9,
    "description": "Basic in-process message transport for local development",
    "tags": "transports, messaging, in-process, communication, v0.1.0",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/audit-logging",
    "title": "Audit Logging",
    "category": "Core Concepts",
    "order": 7,
    "description": "Implement compliance-ready audit logging using Whizbang's System Events - capture who changed what, when, and why",
    "tags": "audit, compliance, logging, system-events, perspectives, security, gdpr, sox",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/dispatcher",
    "title": "Dispatcher Deep Dive",
    "category": "Core Concepts",
    "order": 1,
    "description": "Master the Whizbang Dispatcher - three dispatch patterns (SendAsync, LocalInvokeAsync, PublishAsync) for commands, queries, and events",
    "tags": "dispatcher, messaging, commands, events, patterns",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/event-store-query",
    "title": "Event Store Query",
    "category": "Core Concepts",
    "order": 10,
    "description": "Query raw events in the event store with full LINQ support and automatic scope filtering",
    "tags": "events, query, linq, ef-core, multi-tenancy",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/fuzzy-matching",
    "title": "Fuzzy Matching",
    "category": "Core Concepts",
    "order": 999,
    "description": "# MatchStrictness: Fuzzy Type Matching Control\n\nMatchStrictness is a flag enum that controls how type names are compared during fuzzy matching. It enables flexible type matching by allowing you to ignore case, version, assembly, or namespace components.\n\n## Overview\n\n**MatchStrictness** provides:\n- ✅ Flag-based control over type matching behavior\n- ✅ Combinable flags for precise matching rules\n- ✅ Composite presets for common scenarios\n- ✅ Works with both formatted and raw type strings\n- ✅ Used by message association queries and type matching APIs\n\n## Quick Start\n\n### Basic Fuzzy Matching\n\n```csharp\nusing Whizbang.Core;\n\nvar fullType = \"ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts, Version=1.0.0\";\nvar simpleType = \"ProductCreatedEvent\";\n\n// Exact match (default)\nbool exactMatch = TypeMatcher.Matches(fullType, simpleType, MatchStrictness.Exact);\n// Result: false (types don't match exactly)\n\n// Simple name match (ignore namespace, assembly, version)\nbool simpleMatch = TypeMatcher.Matches(fullType, simpleType, MatchStrictness.SimpleName);\n// Result: true (both have \"ProductCreatedEvent\")\n\n// Case-insensitive match\nbool caseMatch = TypeMatcher.Matches(\n    \"ProductCreatedEvent\",\n    \"productcreatedevent\",\n    MatchStrictness.CaseInsensitive\n);\n// Result: true (case ignored)\n```\n\n### Combining Multiple Flags\n\n```csharp\n// Ignore both case AND version\nvar strictness = MatchStrictness.IgnoreCase | MatchStrictness.IgnoreVersion;\n\nbool match = TypeMatcher.Matches(\n    \"MyApp.Events.OrderCreated, MyApp, Version=1.0.0\",\n    \"myapp.events.ordercreated, myapp, version=2.0.0\",\n    strictness\n);\n// Result: true (version and case ignored)\n\n// Ignore namespace and case\nvar flexibleMatch = MatchStrictness.IgnoreNamespace | MatchStrictness.IgnoreCase;\n\nbool matches = TypeMatcher.Matches(\n    \"ECommerce.Events.ProductCreated\",\n    \"productcreated\",\n    flexibleMatch\n);\n// Result: true (namespace and case ignored)\n```\n\n## Individual Flags\n\n### Flag Definitions\n\nEach flag controls a specific transformation applied to type strings before comparison:\n\n| Flag | Value | Description |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/lenses",
    "title": "Lenses Guide",
    "category": "Core Concepts",
    "order": 4,
    "description": "Master Whizbang Lenses - query-optimized repositories for fast, efficient access to read models maintained by Perspectives",
    "tags": "lenses, queries, read-models, repositories, cqrs",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/lifecycle-receptors",
    "title": "Lifecycle Receptors",
    "category": "Core Concepts",
    "order": 10,
    "description": "Complete API reference for lifecycle receptors - [FireAt] attribute, ILifecycleContext injection, compile-time vs runtime registration, and AOT-compatible patterns",
    "tags": "lifecycle, receptors, FireAt, attributes, ILifecycleContext, AOT, source-generators",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/lifecycle-stages",
    "title": "Lifecycle Stages",
    "category": "Core Concepts",
    "order": 9,
    "description": "Complete reference for all 20 lifecycle stages in Whizbang message processing pipeline - timing, guarantees, and use cases",
    "tags": "lifecycle, stages, hooks, message-processing, timing",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/message-context",
    "title": "Message Context & Tracing",
    "category": "Core Concepts",
    "order": 5,
    "description": "Track message flow across distributed systems with MessageId, CorrelationId, and CausationId - automatic distributed tracing built into Whizbang",
    "tags": "message-context, correlation, causation, distributed-tracing, observability",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/message-security",
    "title": "Message Security",
    "category": "Core Concepts",
    "order": 999,
    "description": "# Message Security Context Propagation\n\nWhizbang provides automatic security context establishment for incoming messages, ensuring that security identity flows across service boundaries in distributed systems.\n\n## Overview\n\nWhen messages arrive from external transports (Azure Service Bus, RabbitMQ, etc.), security context must be established **before** any business logic executes. The message security system:\n\n- Extracts security information from message hops, payloads, or transport metadata\n- Populates `IScopeContextAccessor.Current` for scoped services\n- Invokes callbacks for custom service initialization\n- Emits audit events for security compliance\n\n## Architecture\n\n```\nMessage Arrives\n      │\n      ▼\n┌─────────────────────────────────────┐\n│  IMessageSecurityContextProvider    │\n│  (DefaultMessageSecurityContextProvider) │\n└─────────────────────────────────────┘\n      │\n      ▼ Calls extractors in priority order\n┌─────────────────────────────────────┐\n│  ISecurityContextExtractor[]        │\n│  • MessageHopSecurityExtractor (100)│\n│  • JwtPayloadExtractor (200)        │\n│  • TransportMetadataExtractor (300) │\n└─────────────────────────────────────┘\n      │\n      ▼ First successful extraction wins\n┌─────────────────────────────────────┐\n│  ImmutableScopeContext              │\n│  (wraps SecurityExtraction)         │\n└─────────────────────────────────────┘\n      │\n      ├─▶ Populates IScopeContextAccessor.Current\n      │\n      ▼ Invokes callbacks\n┌─────────────────────────────────────┐\n│  ISecurityContextCallback[]         │\n│  • UserContextManagerCallback       │\n│  • AuditLogCallback                 │\n└─────────────────────────────────────┘\n```\n\n## Quick Start\n\n### Registration\n\n```csharp\nservices.AddWhizbangMessageSecurity(options => {\n  // AllowAnonymous defaults to FALSE (least privilege)\n  // Must explicitly opt-in to allow anonymous messages\n  options.AllowAnonymous = false;\n\n  // Exempt specific message types\n  options.ExemptMessageTypes.Add(typeof(HealthCheckMessage));\n  options.ExemptMessageTypes.Add(typeof(SystemDiagnosticMessage));\n\n  // Adjust timeout for slow token validation\n  options.Timeout = TimeSpan.FromSeconds(10);\n});\n\n// Register custom extractors\nservices.AddSecurityExtractor<JdxMessageTokenExtractor>();\n\n// Register callbacks\nservices.AddSecurityContextCallback<UserContextManagerCallback>();\n```\n\n### How It Works\n\nWhen `ServiceBusConsumerWorker` receives a message:\n\n1. Creates DI scope\n2. Calls `IMessageSecurityContextProvider.EstablishContextAsync()`\n3. Provider iterates through extractors in priority order (lower = earlier)\n4. First successful extraction populates `IScopeContextAccessor.Current`\n5. All callbacks are invoked with the established context\n6. Business logic runs with security context available\n\n## Configuration Options\n\n```csharp\npublic sealed class MessageSecurityOptions {\n  // When true, allows messages without security context.\n  // DEFAULT: FALSE (least privilege - must explicitly enable)\n  public bool AllowAnonymous { get; set; }\n\n  // When true, logs security context establishment for audit.\n  // DEFAULT: TRUE\n  public bool EnableAuditLogging { get; set; } = true;\n\n  // When true, extractors should validate tokens/credentials.\n  // DEFAULT: TRUE\n  public bool ValidateCredentials { get; set; } = true;\n\n  // Maximum time to wait for security context establishment.\n  // DEFAULT: 5 seconds\n  public TimeSpan Timeout { get; set; } = TimeSpan.FromSeconds(5);\n\n  // Message types exempt from security requirements.\n  public HashSet<Type> ExemptMessageTypes { get; } = new();\n\n  // When true, propagates security context to cascaded events.\n  // DEFAULT: TRUE\n  public bool PropagateToOutgoingMessages { get; set; } = true;\n}\n```\n\n## Built-in Extractors\n\n### MessageHopSecurityExtractor (Priority: 100)\n\nExtracts security context from the message envelope's hop chain. This is the default extractor for distributed message security propagation.\n\n```csharp\n// Message hops carry SecurityContext through the system\nvar hop = new MessageHop {\n  ServiceInstance = serviceInstance,\n  SecurityContext = new SecurityContext {\n    TenantId = \"tenant-123\",\n    UserId = \"user-456\"\n  }\n};\n\n// MessageHopSecurityExtractor reads this automatically\n```\n\n**When to use**: Messages flowing between Whizbang services that already have security context attached to their hop chain.\n\n## Custom Extractors\n\nCreate custom extractors for different security sources:\n\n```csharp\npublic class JwtPayloadExtractor : ISecurityContextExtractor {\n  public int Priority => 50;  // Runs before MessageHopSecurityExtractor\n\n  public ValueTask<SecurityExtraction?> ExtractAsync(\n    IMessageEnvelope envelope,\n    MessageSecurityOptions options,\n    CancellationToken cancellationToken = default) {\n\n    // Check if payload contains JWT token\n    if (envelope.Payload is not IJdxMessage jdxMessage ||\n        string.IsNullOrEmpty(jdxMessage.Token)) {\n      return ValueTask.FromResult<SecurityExtraction?>(null);\n    }\n\n    // Decode and validate JWT\n    var claims = DecodeJwt(jdxMessage.Token, options.ValidateCredentials);\n\n    return ValueTask.FromResult<SecurityExtraction?>(new SecurityExtraction {\n      Scope = new PerspectiveScope {\n        TenantId = claims[\"tenant_id\"],\n        UserId = claims[\"sub\"]\n      },\n      Roles = claims[\"roles\"]?.Split(',').ToHashSet() ?? new HashSet<string>(),\n      Permissions = new HashSet<Permission>(),\n      SecurityPrincipals = new HashSet<SecurityPrincipalId>(),\n      Claims = claims,\n      Source = \"JwtPayload\"\n    });\n  }\n}\n```\n\n## Security Context Callbacks\n\nCallbacks run **after** security context is established but **before** business logic (receptors) execute. This enables custom service initialization at exactly the right time.\n\n### ISecurityContextCallback Interface\n\n```csharp\npublic interface ISecurityContextCallback {\n  ValueTask OnContextEstablishedAsync(\n    IScopeContext context,\n    IMessageEnvelope envelope,\n    IServiceProvider scopedProvider,\n    CancellationToken cancellationToken = default);\n}\n```\n\n### Callback Execution Points\n\n:::new\nCallbacks are now invoked at ALL security establishment points (v1.0.0)\n:::\n\nCallbacks are invoked at **three key points** in the message processing pipeline:\n\n| Execution Point | Component | When |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/observability",
    "title": "Observability & Message Hops",
    "category": "Core Concepts",
    "order": 6,
    "description": "Understand Whizbang's hop-based observability architecture - MessageEnvelope and MessageHop for distributed tracing and debugging",
    "tags": "observability, message-hops, distributed-tracing, debugging, telemetry",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/perspectives/association-info",
    "title": "Association Info",
    "category": "Core Concepts",
    "order": 999,
    "description": "# PerspectiveAssociationInfo: Strongly-Typed Associations with Delegates\n\nPerspectiveAssociationInfo is a generic record type that provides strongly-typed perspective associations with AOT-compatible delegates to perspective Apply methods. It enables compile-time type safety and performant perspective invocation without reflection.\n\n## Overview\n\n**PerspectiveAssociationInfo&lt;TModel, TEvent&gt;** provides:\n- ✅ Strongly-typed delegate access to perspective Apply methods\n- ✅ Compile-time type safety (no runtime type checks)\n- ✅ AOT-compatible (zero reflection at runtime)\n- ✅ Generated by source generators for all perspectives\n- ✅ Supports generic perspective invocation\n\n## Quick Start\n\n### Getting Typed Associations\n\n```csharp\nusing Whizbang.Core.Generated;\n\n// Get associations for specific model and event types\nvar associations = PerspectiveRegistrationExtensions\n    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(\"ECommerce.BFF.API\");\n\nforeach (var assoc in associations) {\n    Console.WriteLine($\"Perspective: {assoc.TargetName}\");\n    Console.WriteLine($\"Event: {assoc.MessageType}\");\n    Console.WriteLine($\"Service: {assoc.ServiceName}\");\n\n    // Invoke delegate directly\n    var currentModel = new ProductModel();\n    var evt = new ProductCreatedEvent { ProductId = \"prod-123\" };\n    var updatedModel = assoc.ApplyDelegate(currentModel, evt);\n}\n```\n\n### Using Delegates\n\n```csharp\n// Example: Generic perspective applier\npublic TModel ApplyEvent<TModel, TEvent>(\n    TModel model,\n    TEvent evt,\n    string serviceName)\n    where TEvent : IEvent {\n\n    var associations = PerspectiveRegistrationExtensions\n        .GetPerspectiveAssociations<TModel, TEvent>(serviceName);\n\n    // Apply all matching perspectives\n    foreach (var assoc in associations) {\n        model = assoc.ApplyDelegate(model, evt);\n    }\n\n    return model;\n}\n\n// Usage\nvar productModel = new ProductModel();\nvar productEvent = new ProductCreatedEvent { ProductId = \"prod-123\" };\nvar updated = ApplyEvent(productModel, productEvent, \"ECommerce.BFF.API\");\n```\n\n## Record Structure\n\n### Type Definition\n\n```csharp\n/// <summary>\n/// Rich association info with strongly-typed delegate for perspective Apply method.\n/// Provides compile-time type safety and AOT-compatible delegate invocation.\n/// </summary>\n/// <typeparam name=\"TModel\">The model type maintained by the perspective</typeparam>\n/// <typeparam name=\"TEvent\">The event type handled by the perspective</typeparam>\n/// <param name=\"MessageType\">Fully qualified event type name</param>\n/// <param name=\"TargetName\">Name of the perspective class</param>\n/// <param name=\"ServiceName\">Service name (assembly name)</param>\n/// <param name=\"ApplyDelegate\">Strongly-typed delegate to perspective's Apply method</param>\npublic sealed record PerspectiveAssociationInfo<TModel, TEvent>(\n    string MessageType,\n    string TargetName,\n    string ServiceName,\n    Func<TModel, TEvent, TModel> ApplyDelegate\n) where TEvent : IEvent;\n```\n\n### Properties\n\n| Property | Type | Description |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/perspectives/multi-stream",
    "title": "Multi-Stream Perspectives",
    "category": "Core Concepts",
    "order": 1,
    "description": "IGlobalPerspectiveFor pattern for aggregating events across multiple streams using partition keys - inspired by Marten's MultiStreamProjection",
    "tags": "perspectives, multi-stream, global-perspectives, partition-key, cross-stream, aggregation, read-models, marten",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/perspectives/perspective-sync",
    "title": "Perspective Synchronization",
    "category": "Core Concepts",
    "order": 4,
    "description": "Read-your-writes consistency for perspectives - wait for perspective updates before querying to ensure handlers see their own changes",
    "tags": "perspectives, synchronization, read-your-writes, consistency, lenses, sync, awaiter, debugger-aware",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/perspectives/typed-associations",
    "title": "Typed Associations",
    "category": "Core Concepts",
    "order": 999,
    "description": "# GetPerspectiveAssociations: Strongly-Typed Perspective Queries\n\nGetPerspectiveAssociations is a source-generated method that returns strongly-typed perspective associations filtered by model and event type. It provides compile-time type safety and AOT-compatible delegate access to perspective Apply methods.\n\n## Overview\n\n**GetPerspectiveAssociations&lt;TModel, TEvent&gt;** provides:\n- ✅ Type-filtered perspective associations\n- ✅ Compile-time type checking with generic constraints\n- ✅ AOT-compatible delegates (zero reflection)\n- ✅ Empty array for non-matching types\n- ✅ Source-generated for all discovered perspectives\n\n## Quick Start\n\n### Basic Usage\n\n```csharp\nusing Whizbang.Core.Generated;\n\n// Get all perspectives handling ProductCreatedEvent for ProductModel\nvar associations = PerspectiveRegistrationExtensions\n    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(\"ECommerce.BFF.API\");\n\n// Iterate and invoke\nvar model = new ProductModel();\nvar evt = new ProductCreatedEvent { ProductId = \"prod-123\" };\n\nforeach (var assoc in associations) {\n    Console.WriteLine($\"Applying: {assoc.TargetName}\");\n    model = assoc.ApplyDelegate(model, evt);\n}\n\nConsole.WriteLine($\"Final model: {model}\");\n```\n\n### Type Safety\n\n```csharp\n// Compile-time type safety ensures matching types\nvar associations = PerspectiveRegistrationExtensions\n    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);\n\n// Compiler enforces correct types\nvar productModel = new ProductModel();\nvar productEvent = new ProductCreatedEvent();\n\nforeach (var assoc in associations) {\n    // ✅ Types match - compiles\n    productModel = assoc.ApplyDelegate(productModel, productEvent);\n}\n\n// ❌ Won't compile - type mismatch\nvar orderEvent = new OrderCreatedEvent();\nproductModel = assoc.ApplyDelegate(productModel, orderEvent); // Compiler error!\n```\n\n## Method Signature\n\n### Declaration\n\n```csharp\nnamespace Whizbang.Core.Generated;\n\npublic static class PerspectiveRegistrationExtensions {\n    /// <summary>\n    /// Gets strongly-typed perspective associations with AOT-compatible delegates.\n    /// Returns associations only for the specified TModel and TEvent types.\n    /// Uses compile-time type checking - no reflection.\n    /// </summary>\n    /// <typeparam name=\"TModel\">The model type to filter by</typeparam>\n    /// <typeparam name=\"TEvent\">The event type to filter by</typeparam>\n    /// <param name=\"serviceName\">The service name (assembly name)</param>\n    /// <returns>Read-only list of typed perspective associations with delegates</returns>\n    public static IReadOnlyList<PerspectiveAssociationInfo<TModel, TEvent>>\n        GetPerspectiveAssociations<TModel, TEvent>(string serviceName)\n        where TEvent : IEvent;\n}\n```\n\n### Parameters\n\n- **serviceName**: Service name / assembly name (e.g., \"ECommerce.BFF.API\")\n\n### Type Parameters\n\n- **TModel**: Model type maintained by perspectives\n  - No constraints (can be any type)\n  - Must match perspective's `IPerspectiveFor<TModel, TEvent>` first type argument\n\n- **TEvent**: Event type handled by perspectives\n  - Must implement `IEvent` interface\n  - Must match perspective's `IPerspectiveFor<TModel, TEvent>` second type argument\n\n### Return Value\n\n- Returns `IReadOnlyList<PerspectiveAssociationInfo<TModel, TEvent>>`\n- Returns empty list if no perspectives match the specified types\n- Never returns null\n- List is immutable (read-only)\n\n## Generated Code Structure\n\n### How It Works\n\nThe source generator produces compile-time type checks for each perspective:\n\n```csharp\n// Generated method (simplified example)\npublic static IReadOnlyList<PerspectiveAssociationInfo<TModel, TEvent>>\n    GetPerspectiveAssociations<TModel, TEvent>(string serviceName)\n    where TEvent : IEvent {\n\n    // ProductPerspective: IPerspectiveFor<ProductModel, ProductCreatedEvent>\n    if (typeof(TModel) == typeof(ProductModel) &&\n        typeof(TEvent) == typeof(ProductCreatedEvent)) {\n\n        return new[] {\n            new PerspectiveAssociationInfo<TModel, TEvent>(\n                \"ECommerce.Contracts.Events.ProductCreatedEvent\",\n                \"ProductPerspective\",\n                \"ECommerce.BFF.API\",\n                (model, evt) => {\n                    var perspective = new ProductPerspective();\n                    var typedModel = (ProductModel)((object)model);\n                    var typedEvent = (ProductCreatedEvent)((object)evt);\n                    var result = perspective.Apply(typedModel, typedEvent);\n                    return (TModel)((object)result);\n                }\n            )\n        };\n    }\n\n    // OrderPerspective: IPerspectiveFor<OrderModel, OrderCreatedEvent>\n    if (typeof(TModel) == typeof(OrderModel) &&\n        typeof(TEvent) == typeof(OrderCreatedEvent)) {\n\n        return new[] {\n            new PerspectiveAssociationInfo<TModel, TEvent>(\n                \"ECommerce.Contracts.Events.OrderCreatedEvent\",\n                \"OrderPerspective\",\n                \"ECommerce.BFF.API\",\n                (model, evt) => {\n                    var perspective = new OrderPerspective();\n                    var typedModel = (OrderModel)((object)model);\n                    var typedEvent = (OrderCreatedEvent)((object)evt);\n                    var result = perspective.Apply(typedModel, typedEvent);\n                    return (TModel)((object)result);\n                }\n            )\n        };\n    }\n\n    // No match - return empty\n    return Array.Empty<PerspectiveAssociationInfo<TModel, TEvent>>();\n}\n```\n\n### AOT Compatibility\n\nKey features ensuring AOT compatibility:\n\n1. **Compile-time type checking**: Uses `typeof()` comparisons\n2. **Direct instantiation**: Uses `new` keyword (no `Activator.CreateInstance`)\n3. **Direct method calls**: No `MethodInfo.Invoke`\n4. **No reflection**: All types known at compile time\n5. **Trim-safe**: No dynamic type loading\n\n## Common Scenarios\n\n### Scenario 1: Generic Event Processor\n\n**When**: Building a generic event processing pipeline\n\n```csharp\npublic class EventProcessor {\n    private readonly string _serviceName;\n\n    public EventProcessor(string serviceName) {\n        _serviceName = serviceName;\n    }\n\n    public TModel ProcessEvent<TModel, TEvent>(TModel model, TEvent evt)\n        where TEvent : IEvent {\n\n        // Get associations for this model/event combination\n        var associations = PerspectiveRegistrationExtensions\n            .GetPerspectiveAssociations<TModel, TEvent>(_serviceName);\n\n        if (!associations.Any()) {\n            throw new InvalidOperationException(\n                $\"No perspectives found for {typeof(TModel).Name} + {typeof(TEvent).Name}\"\n            );\n        }\n\n        // Apply all matching perspectives\n        foreach (var assoc in associations) {\n            model = assoc.ApplyDelegate(model, evt);\n        }\n\n        return model;\n    }\n}\n\n// Usage\nvar processor = new EventProcessor(\"ECommerce.BFF.API\");\nvar updatedProduct = processor.ProcessEvent(productModel, productCreatedEvent);\nvar updatedOrder = processor.ProcessEvent(orderModel, orderCreatedEvent);\n```\n\n### Scenario 2: Event Replay Engine\n\n**When**: Replaying historical events to rebuild state\n\n```csharp\npublic class EventReplayEngine {\n    public async Task<TModel> ReplayAsync<TModel, TEvent>(\n        TModel initialModel,\n        IAsyncEnumerable<TEvent> events,\n        string serviceName)\n        where TEvent : IEvent {\n\n        // Get associations once (before loop)\n        var associations = PerspectiveRegistrationExtensions\n            .GetPerspectiveAssociations<TModel, TEvent>(serviceName);\n\n        if (!associations.Any()) {\n            return initialModel; // No perspectives, return unchanged\n        }\n\n        var model = initialModel;\n\n        // Replay each event\n        await foreach (var evt in events) {\n            foreach (var assoc in associations) {\n                model = assoc.ApplyDelegate(model, evt);\n            }\n        }\n\n        return model;\n    }\n}\n\n// Usage\nvar replayEngine = new EventReplayEngine();\nvar events = LoadHistoricalEvents();\nvar currentState = await replayEngine.ReplayAsync(\n    new ProductModel(),\n    events,\n    \"ECommerce.BFF.API\"\n);\n```\n\n### Scenario 3: Multi-Perspective Testing\n\n**When**: Testing that all perspectives handle an event correctly\n\n```csharp\n[Test]\npublic async Task AllPerspectives_HandleProductCreatedEvent_CorrectlyAsync() {\n    // Arrange\n    var associations = PerspectiveRegistrationExtensions\n        .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(\"ECommerce.BFF.API\");\n\n    var model = new ProductModel { ProductCount = 0 };\n    var evt = new ProductCreatedEvent { ProductId = \"prod-123\" };\n\n    // Act & Assert - test each perspective\n    foreach (var assoc in associations) {\n        Console.WriteLine($\"Testing perspective: {assoc.TargetName}\");\n\n        var result = assoc.ApplyDelegate(model, evt);\n\n        // Verify perspective applied changes\n        await Assert.That(result).IsNotEqualTo(model);\n        await Assert.That(result.ProductCount).IsGreaterThan(model.ProductCount);\n\n        model = result; // Update for next perspective\n    }\n\n    // Final assertion\n    await Assert.That(model.ProductCount).IsGreaterThan(0);\n}\n```\n\n### Scenario 4: Conditional Perspective Application\n\n**When**: Applying perspectives based on runtime conditions\n\n```csharp\npublic class ConditionalPerspectiveApplier {\n    public TModel ApplyWithFilter<TModel, TEvent>(\n        TModel model,\n        TEvent evt,\n        string serviceName,\n        Func<PerspectiveAssociationInfo<TModel, TEvent>, bool> filter)\n        where TEvent : IEvent {\n\n        var associations = PerspectiveRegistrationExtensions\n            .GetPerspectiveAssociations<TModel, TEvent>(serviceName);\n\n        // Apply only perspectives matching filter\n        foreach (var assoc in associations.Where(filter)) {\n            model = assoc.ApplyDelegate(model, evt);\n        }\n\n        return model;\n    }\n}\n\n// Usage: Apply only specific perspectives\nvar applier = new ConditionalPerspectiveApplier();\nvar filtered = applier.ApplyWithFilter(\n    productModel,\n    productEvent,\n    serviceName,\n    assoc => assoc.TargetName.Contains(\"Inventory\") // Only inventory perspectives\n);\n```\n\n### Scenario 5: Performance Monitoring\n\n**When**: Monitoring perspective performance\n\n```csharp\npublic class MonitoredPerspectiveApplier {\n    private readonly ILogger _logger;\n\n    public TModel ApplyWithMonitoring<TModel, TEvent>(\n        TModel model,\n        TEvent evt,\n        string serviceName)\n        where TEvent : IEvent {\n\n        var associations = PerspectiveRegistrationExtensions\n            .GetPerspectiveAssociations<TModel, TEvent>(serviceName);\n\n        foreach (var assoc in associations) {\n            var sw = Stopwatch.StartNew();\n\n            model = assoc.ApplyDelegate(model, evt);\n\n            sw.Stop();\n            _logger.LogDebug(\n                \"Perspective {PerspectiveName} took {ElapsedMs}ms\",\n                assoc.TargetName,\n                sw.ElapsedMilliseconds\n            );\n        }\n\n        return model;\n    }\n}\n```\n\n## Type Filtering Behavior\n\n### Exact Type Matching\n\nGetPerspectiveAssociations uses exact type matching (not assignable types):\n\n```csharp\n// Perspective definition\npublic class ProductPerspective : IPerspectiveFor<ProductModel, ProductCreatedEvent> {\n    public ProductModel Apply(ProductModel model, ProductCreatedEvent evt) {\n        // ...\n    }\n}\n\n// ✅ Exact match - returns association\nvar associations1 = PerspectiveRegistrationExtensions\n    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);\n// Returns: [ProductPerspective]\n\n// ❌ Base class - no match\nvar associations2 = PerspectiveRegistrationExtensions\n    .GetPerspectiveAssociations<BaseModel, ProductCreatedEvent>(serviceName);\n// Returns: [] (empty)\n\n// ❌ Interface - no match\nvar associations3 = PerspectiveRegistrationExtensions\n    .GetPerspectiveAssociations<IModel, ProductCreatedEvent>(serviceName);\n// Returns: [] (empty)\n```\n\n### Multiple Perspectives\n\nIf multiple perspectives handle the same model/event combination, all are returned:\n\n```csharp\n// Two perspectives handling ProductModel + ProductCreatedEvent\npublic class InventoryPerspective : IPerspectiveFor<ProductModel, ProductCreatedEvent> { }\npublic class CatalogPerspective : IPerspectiveFor<ProductModel, ProductCreatedEvent> { }\n\nvar associations = PerspectiveRegistrationExtensions\n    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);\n\n// Returns: [InventoryPerspective, CatalogPerspective]\nConsole.WriteLine($\"Found {associations.Count} perspectives\");\n\n// Apply both\nforeach (var assoc in associations) {\n    model = assoc.ApplyDelegate(model, evt);\n}\n```\n\n## Performance Considerations\n\n### Caching Associations\n\n```csharp\n// ❌ WRONG: Calling in loop\nforeach (var evt in events) {\n    var associations = PerspectiveRegistrationExtensions\n        .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);\n    // Unnecessary overhead!\n}\n\n// ✅ CORRECT: Cache outside loop\nvar associations = PerspectiveRegistrationExtensions\n    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);\n\nforeach (var evt in events) {\n    foreach (var assoc in associations) {\n        model = assoc.ApplyDelegate(model, evt);\n    }\n}\n```\n\n### Compile-Time Optimization\n\nThe method uses compile-time type checks, so the JIT compiler can optimize aggressively:\n\n```csharp\n// JIT can inline typeof() checks\n// Result: Very fast (~1-2ns per call once JIT'd)\nvar associations = PerspectiveRegistrationExtensions\n    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);\n```\n\n### Delegate Invocation Cost\n\n```csharp\n// Delegate invocation is extremely fast\n// Approximately 1-2ns per invocation (similar to virtual method call)\nvar result = assoc.ApplyDelegate(model, evt);\n\n// Compare to reflection: ~100-1000ns per call\n// Delegates are 50-500x faster!\n```\n\n## Integration with Message Associations\n\n### Complementary APIs\n\n```csharp\n// 1. Discovery with MessageAssociation (string-based)\nvar allAssociations = PerspectiveRegistrationExtensions\n    .GetMessageAssociations(serviceName);\n\nvar productEvents = allAssociations\n    .Where(a => a.TargetName == \"ProductPerspective\")\n    .Select(a => a.MessageType);\n\nConsole.WriteLine($\"ProductPerspective handles: {string.Join(\", \", productEvents)}\");\n\n// 2. Invocation with GetPerspectiveAssociations (typed)\nvar typedAssociations = PerspectiveRegistrationExtensions\n    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);\n\nforeach (var assoc in typedAssociations) {\n    model = assoc.ApplyDelegate(model, evt);\n}\n```\n\n### Workflow\n\n1. **Discovery**: Use `GetMessageAssociations()` to find available perspectives\n2. **Filtering**: Use fuzzy matching and queries to filter\n3. **Invocation**: Use `GetPerspectiveAssociations<TModel, TEvent>()` to invoke\n\n## API Reference\n\n### Method Details\n\n**Namespace**: `Whizbang.Core.Generated`\n\n**Class**: `PerspectiveRegistrationExtensions`\n\n**Method**: `GetPerspectiveAssociations<TModel, TEvent>`\n\n### Parameters\n\n| Parameter | Type | Description |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/perspectives",
    "title": "Perspectives Guide",
    "category": "Core Concepts",
    "order": 3,
    "description": "Master Whizbang Perspectives - pure function event handlers that maintain eventually consistent read models optimized for queries",
    "tags": "perspectives, read-models, cqrs, eventual-consistency, event-driven, pure-functions, streamkey",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/receptors",
    "title": "Receptors Guide",
    "category": "Core Concepts",
    "order": 2,
    "description": "Master Whizbang Receptors - stateless message handlers that encapsulate business logic, validation, and decision-making",
    "tags": "receptors, message-handlers, business-logic, validation",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/routing",
    "title": "Routing",
    "category": "Core Concepts",
    "order": 999,
    "description": "# Namespace-Based Routing\n\nWhizbang uses namespace-based routing to determine where messages flow. Commands and events follow distinct routing patterns optimized for their specific use cases.\n\n## Overview\n\nRouting in Whizbang is built on two key principles:\n\n1. **Commands → Shared Inbox**: All commands route to a single shared \"inbox\" topic. Services filter by owned namespaces using routing key patterns.\n2. **Events → Namespace Topics**: Events publish to namespace-specific topics. Services subscribe directly to namespaces they care about.\n\nThis separation provides:\n- **Point-to-point delivery** for commands (exactly one handler)\n- **Pub/sub distribution** for events (multiple subscribers)\n- **Automatic subscription discovery** via source generation\n\n## Command Flow\n\nCommands follow a point-to-point pattern with namespace-based filtering:\n\n```\nBFF sends CreateTenantCommand (namespace: MyApp.Users.Commands)\n    ↓\nBFF Outbox → Broker \"inbox\" topic\n    ↓\n    RoutingKey: \"myapp.users.commands.createtenantcommand\"\n    ↓\nALL services subscribed to \"inbox\" (single shared topic)\n    ↓\nEach service filters by owned namespaces:\n    - User Service owns \"myapp.users.commands\" → RECEIVES\n    - Workflow Service owns \"myapp.workflow.commands\" → FILTERED OUT\n    ↓\nUser Service processes command\n```\n\n### How Command Filtering Works\n\nWhen a service starts, it declares which command namespaces it owns:\n\n```csharp\nservices.Configure<RoutingOptions>(opts => {\n  opts.OwnDomains(\"myapp.users.commands\");\n  opts.OwnDomains(\"myapp.inventory.commands\");\n});\n```\n\nThe `SharedTopicInboxStrategy` builds routing patterns from these namespaces:\n\n```csharp\n// Generated routing patterns:\n// - \"whizbang.core.commands.system.#\"  (always included)\n// - \"myapp.users.commands.#\"\n// - \"myapp.inventory.commands.#\"\n```\n\n**Note**: All services automatically subscribe to system commands (`whizbang.core.commands.system.#`) for framework-level operations.\n\n### Wildcard Namespaces\n\nSupport pattern matching for flexible ownership:\n\n```csharp\n// Own all commands under myapp.orders\nopts.OwnDomains(\"myapp.orders.*\");\n// Converts to pattern: \"myapp.orders.#\"\n```\n\n## Event Flow\n\nEvents follow a pub/sub pattern with namespace-based topics:\n\n```\nUser Service publishes TenantCreatedEvent (namespace: MyApp.Users.Events)\n    ↓\nUser Service Outbox → Broker topic \"myapp.users.events\"\n    ↓\n    RoutingKey: \"tenantcreatedevent\"\n    ↓\nServices subscribed to \"myapp.users.events\":\n    - BFF → RECEIVES\n    - Workflow Service → RECEIVES\n    - Notifications Service → RECEIVES\n```\n\n### Automatic Event Subscription Discovery\n\nEvent subscriptions are **automatically discovered** from your code via source generation:\n\n1. **Perspectives**: Events your service projects\n2. **Receptors**: Events your service handles\n\n```csharp\n// This perspective automatically subscribes to \"myapp.orders.events\"\n[Perspective<OrderSummary>]\npublic class OrderSummaryPerspective : IPerspective<OrderCreatedEvent> {\n  // OrderCreatedEvent is in namespace MyApp.Orders.Events\n}\n\n// This receptor automatically subscribes to \"myapp.payments.events\"\npublic class PaymentReceptor : IReceptor<PaymentCompletedEvent> {\n  // PaymentCompletedEvent is in namespace MyApp.Payments.Events\n}\n```\n\nThe `EventNamespaceRegistryGenerator` source generator extracts these namespaces at compile time:\n\n```csharp\n// Generated code (example)\npublic sealed class GeneratedEventNamespaceRegistry : IEventNamespaceRegistry {\n  public IReadOnlySet<string> GetPerspectiveEventNamespaces() =>\n    new HashSet<string>(StringComparer.OrdinalIgnoreCase) {\n      \"myapp.orders.events\"\n    };\n\n  public IReadOnlySet<string> GetReceptorEventNamespaces() =>\n    new HashSet<string>(StringComparer.OrdinalIgnoreCase) {\n      \"myapp.payments.events\"\n    };\n}\n```\n\n### Manual Event Subscriptions\n\nOverride or supplement auto-discovery with manual subscriptions:\n\n```csharp\nservices.Configure<RoutingOptions>(opts => {\n  // Explicitly subscribe to additional event namespaces\n  opts.SubscribeTo(\"myapp.notifications.events\");\n  opts.SubscribeTo(\"myapp.audit.events\");\n});\n```\n\n## System Commands\n\nAll services automatically subscribe to system commands for framework-level operations:\n\n```csharp\nnamespace Whizbang.Core.Commands.System;\n\n// Rebuild a perspective across all services\npublic record RebuildPerspectiveCommand(\n    string PerspectiveName,\n    long? FromEventId = null\n) : ICommand;\n\n// Clear cached data\npublic record ClearCacheCommand(\n    string? CacheKey = null,\n    string? CacheRegion = null\n) : ICommand;\n\n// Collect diagnostics from all services\npublic record DiagnosticsCommand(\n    DiagnosticType Type,\n    Guid? CorrelationId = null\n) : ICommand;\n\n// Pause message processing (coordinated maintenance)\npublic record PauseProcessingCommand(\n    int? DurationSeconds = null,\n    string? Reason = null\n) : ICommand;\n\n// Resume message processing\npublic record ResumeProcessingCommand(\n    string? Reason = null\n) : ICommand;\n```\n\n### Sending System Commands\n\n```csharp\n// Rebuild a perspective across all services\nawait dispatcher.SendAsync(new RebuildPerspectiveCommand(\"OrderSummary\"));\n\n// Clear all caches\nawait dispatcher.SendAsync(new ClearCacheCommand());\n\n// Pause processing for 5 minutes\nawait dispatcher.SendAsync(new PauseProcessingCommand(\n    DurationSeconds: 300,\n    Reason: \"Scheduled maintenance\"\n));\n```\n\n## Configuration\n\n### Fluent Configuration with WithRouting {#with-routing}\n\nThe recommended approach uses the fluent `WithRouting()` extension method:\n\n```csharp\nservices.AddWhizbang()\n    .WithRouting(routing => {\n        routing\n            .OwnDomains(\"myapp.users.commands\")\n            .SubscribeTo(\"myapp.notifications.events\")\n            .Inbox.UseSharedTopic(\"inbox\");\n    })\n    .WithEFCore<MyDbContext>()\n    .WithDriver.Postgres\n    .AddTransportConsumer();  // Auto-generates subscriptions!\n```\n\nThis approach:\n- **Chains with other Whizbang configuration** - Integrates with EF Core, drivers, and transport setup\n- **Auto-generates subscriptions** - When paired with `AddTransportConsumer()`, subscriptions are created automatically\n- **Type-safe** - All configuration is compile-time verified\n\n### Complete Example\n\n```csharp\n// User Service - handles user commands, subscribes to order events\nservices.AddWhizbang()\n    .WithRouting(routing => {\n        // Commands this service handles\n        routing.OwnDomains(\"myapp.users.commands\");\n\n        // Events are auto-discovered from perspectives/receptors\n        // Manual override (adds to auto-discovered):\n        routing.SubscribeTo(\"myapp.notifications.events\");\n\n        // Inbox strategy\n        routing.Inbox.UseSharedTopic(\"inbox\");\n    })\n    .AddTransportConsumer();\n\n// BFF Service - sends commands, receives events\nservices.AddWhizbang()\n    .WithRouting(routing => {\n        // No OwnDomains (BFF doesn't handle commands directly)\n        // Events auto-discovered from its receptors/perspectives\n        routing.Inbox.UseSharedTopic(\"inbox\");\n    })\n    .AddTransportConsumer();\n```\n\n### Legacy Configuration\n\nFor backwards compatibility, you can still configure routing options directly:\n\n```csharp\nservices.Configure<RoutingOptions>(opts => {\n  opts.OwnDomains(\"myapp.users.commands\");\n  opts.SubscribeTo(\"myapp.notifications.events\");\n});\n```\n\n### Strongly-Typed Configuration\n\nUse the generic overloads for compile-time safety and refactor-friendly configuration:\n\n```csharp\nservices.Configure<RoutingOptions>(opts => {\n  // Strongly-typed: extracts namespace from the type\n  opts.OwnNamespaceOf<CreateUserCommand>()      // \"myapp.users.commands\"\n      .OwnNamespaceOf<UpdateInventoryCommand>() // \"myapp.inventory.commands\"\n      .SubscribeToNamespaceOf<OrderCreatedEvent>()   // \"myapp.orders.events\"\n      .SubscribeToNamespaceOf<PaymentCompletedEvent>(); // \"myapp.payments.events\"\n\n  // Can mix with string-based for wildcards\n  opts.OwnDomains(\"myapp.legacy.*\");\n});\n```\n\n**Benefits:**\n- **Compile-time safety** - Invalid types won't compile\n- **Refactor-friendly** - Rename/move types automatically updates references\n- **IDE navigation** - Ctrl+click to go to type definition\n- **No magic strings** - For known namespaces\n\n### Inbox Strategies\n\nTwo inbox routing strategies are available:\n\n#### SharedTopicInboxStrategy (Default)\n\nAll commands go to a single \"inbox\" topic with namespace-based filtering:\n\n```csharp\nservices.Configure<RoutingOptions>(opts => {\n  opts.Inbox.UseSharedTopic(\"inbox\");  // Default\n});\n```\n\n#### DomainTopicInboxStrategy\n\nEach domain gets its own inbox topic:\n\n```csharp\nservices.Configure<RoutingOptions>(opts => {\n  opts.Inbox.UseDomainTopics(\".in\");\n  // Creates topics: \"myapp.users.in\", \"myapp.orders.in\", etc.\n});\n```\n\n## Domain Topic Provisioning {#domain-topic-provisioning}\n\n:::new\nWhen a service declares domain ownership via `OwnDomains()`, Whizbang automatically provisions the corresponding topics/exchanges on the message broker at worker startup. This ensures the domain owner (publisher) creates infrastructure that subscribers will use.\n:::\n\n### How It Works\n\nAt `TransportConsumerWorker` startup, before creating subscriptions:\n\n1. The worker checks for a registered `IInfrastructureProvisioner`\n2. If present, it calls `ProvisionOwnedDomainsAsync()` with the service's owned domains\n3. The provisioner creates topics/exchanges for each owned domain\n4. Then subscriptions are created as normal\n\n```csharp\n// When you configure:\nservices.AddWhizbang()\n    .WithRouting(routing => {\n        routing.OwnDomains(\"myapp.users\", \"myapp.orders\");\n    })\n    .AddTransportConsumer();\n\n// At startup, these topics are automatically provisioned:\n// - myapp.users (topic/exchange)\n// - myapp.orders (topic/exchange)\n```\n\n### Transport-Specific Behavior\n\n| Transport | Provisioned Resource | Idempotent |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/rpc-extraction",
    "title": "Rpc Extraction",
    "category": "Core Concepts",
    "order": 999,
    "description": "# RPC Response Extraction\n\nRPC (Remote Procedure Call) style invocations allow you to call a receptor and receive a specific response type back, while other returned values cascade through normal routing.\n\n## Overview\n\nWhen using `LocalInvokeAsync<TResponse>(command)`, the dispatcher:\n\n1. **Extracts** the requested `TResponse` type from the receptor's return value\n2. **Returns** that value directly to the caller\n3. **Cascades** all other returned values through normal routing (outbox by default)\n\nThis enables receptors to return multiple values (via tuples) while callers receive only what they need.\n\n## Example\n\n```csharp\n// Command\npublic record CreateOrder(Guid OrderId, decimal Amount);\n\n// Response types\npublic record OrderConfirmation {\n  public required Guid OrderId { get; init; }\n  public required string ConfirmationCode { get; init; }\n}\n\n[DefaultRouting(DispatchMode.Outbox)]\npublic record InventoryReserved([property: StreamKey] Guid OrderId) : IEvent;\n\n// Receptor returns tuple: (response to caller, event to cascade)\npublic class CreateOrderReceptor\n    : IReceptor<CreateOrder, (OrderConfirmation, InventoryReserved)> {\n\n  public ValueTask<(OrderConfirmation, InventoryReserved)> HandleAsync(\n      CreateOrder command,\n      CancellationToken ct = default) {\n\n    var confirmation = new OrderConfirmation {\n      OrderId = command.OrderId,\n      ConfirmationCode = $\"CONF-{command.OrderId:N}\"\n    };\n\n    var inventory = new InventoryReserved(command.OrderId);\n\n    return ValueTask.FromResult((confirmation, inventory));\n  }\n}\n```\n\n### Caller Side\n\n```csharp\n// RPC call - OrderConfirmation returned to caller\nvar confirmation = await dispatcher.LocalInvokeAsync<OrderConfirmation>(\n    new CreateOrder(Guid.NewGuid(), 99.99m));\n\n// InventoryReserved automatically cascades to outbox (per [DefaultRouting])\n// confirmation.ConfirmationCode is available to caller\n```\n\n## How It Works\n\n### Response Extraction\n\nThe `ResponseExtractor` utility extracts the requested type from complex return values:\n\n| Return Type | Extraction Behavior |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/scoping",
    "title": "Scoping",
    "category": "Core Concepts",
    "order": 999,
    "description": "# Scoping System\n\nWhizbang's scoping system provides flexible multi-tenancy and data isolation through composable filters, enabling tenant, user, organization, and principal-based access patterns.\n\n## Overview\n\nScoping in Whizbang separates data isolation concerns from your domain models:\n\n- **PerspectiveScope** - Metadata stored with each row (TenantId, UserId, etc.)\n- **ScopeFilter** - Composable flags for query filtering\n- **ScopeFilterBuilder** - Builds filter info from flags and context\n- **IScopedLensFactory** - Resolves lenses with scope filters applied\n\n## PerspectiveScope\n\n`PerspectiveScope` is stored in the `scope` column of perspective rows, separate from your data model.\n\n```csharp\npublic record PerspectiveScope {\n  // Standard scope properties\n  public string? TenantId { get; init; }\n  public string? UserId { get; init; }\n  public string? OrganizationId { get; init; }\n  public string? CustomerId { get; init; }\n\n  // Security principal access list\n  public IReadOnlyList<SecurityPrincipalId>? AllowedPrincipals { get; init; }\n\n  // Custom extension properties\n  public IReadOnlyDictionary<string, string?>? Extensions { get; init; }\n\n  // Unified indexer access\n  public string? this[string key] => ...;\n}\n```\n\n### Why Separate from Data?\n\nStoring scope separately from your domain data provides:\n\n1. **Clean domain models** - Your `Order` class doesn't need `TenantId`\n2. **Consistent filtering** - All perspectives filter the same way\n3. **Flexible extensions** - Add custom scope properties without schema changes\n4. **Security isolation** - Scope enforcement happens at infrastructure level\n\n### Accessing Scope Values\n\n```csharp\nvar scope = new PerspectiveScope {\n  TenantId = \"tenant-123\",\n  UserId = \"user-456\",\n  Extensions = new Dictionary<string, string?> {\n    [\"department\"] = \"Engineering\",\n    [\"region\"] = \"us-west\"\n  }\n};\n\n// Via properties\nvar tenant = scope.TenantId;  // \"tenant-123\"\n\n// Via indexer (standard + extensions)\nvar tenant = scope[\"TenantId\"];     // \"tenant-123\"\nvar dept = scope[\"department\"];     // \"Engineering\"\nvar unknown = scope[\"unknown\"];     // null\n```\n\n## Scope Filters\n\n`ScopeFilter` is a flags enum for composable filtering.\n\n```csharp\n[Flags]\npublic enum ScopeFilter {\n  None = 0,           // No filtering (global access)\n  Tenant = 1 << 0,    // Filter by TenantId\n  Organization = 1 << 1,\n  Customer = 1 << 2,\n  User = 1 << 3,      // Filter by UserId\n  Principal = 1 << 4  // Filter by security principal overlap\n}\n```\n\n### Filter Composition\n\nCombine filters with bitwise OR:\n\n```csharp\n// Single filter\nvar tenantOnly = ScopeFilter.Tenant;\n\n// Multiple filters (AND'd together)\nvar tenantAndUser = ScopeFilter.Tenant | ScopeFilter.User;\n\n// Complex combination\nvar complex = ScopeFilter.Tenant | ScopeFilter.Organization | ScopeFilter.Principal;\n```\n\n### Filter Application\n\n| Filter | Generated WHERE |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/security",
    "title": "Security",
    "category": "Core Concepts",
    "order": 999,
    "description": "# Security System\n\nWhizbang provides a comprehensive security system supporting RBAC (Role-Based Access Control) and ABAC (Attribute-Based Access Control) patterns with composable scope filters, permission checks, and security event auditing.\n\n## Overview\n\nThe security system consists of:\n\n- **Permissions** - Type-safe permission identifiers with wildcard matching\n- **Roles** - Named collections of permissions\n- **Scope Context** - Ambient security context for current operation\n- **Security Principals** - Users, groups, and services with hierarchical membership\n- **Scoped Lens Factory** - Permission-aware lens resolution with composable filters\n- **System Events** - Security audit trail (AccessDenied, AccessGranted, etc.)\n\n## Permissions\n\nPermissions use a `resource:action` pattern and support wildcard matching.\n\n```csharp\n// Factory methods for common patterns\nvar readOrders = Permission.Read(\"orders\");      // \"orders:read\"\nvar writeOrders = Permission.Write(\"orders\");    // \"orders:write\"\nvar deleteOrders = Permission.Delete(\"orders\");  // \"orders:delete\"\nvar adminOrders = Permission.Admin(\"orders\");    // \"orders:admin\"\nvar allOrders = Permission.All(\"orders\");        // \"orders:*\"\n\n// Custom permissions\nvar permission = new Permission(\"orders:export\");\n\n// Wildcard matching\nvar allResources = new Permission(\"*:*\");        // Matches everything\nvar allOrderActions = Permission.All(\"orders\");  // Matches orders:*\n```\n\n### Wildcard Rules\n\n| Permission | Matches |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/system-events",
    "title": "System Events",
    "category": "Core Concepts",
    "order": 999,
    "description": "",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/transport-consumer",
    "title": "Transport Consumer",
    "category": "Core Concepts",
    "order": 999,
    "description": "# Transport Consumer\n\nThe transport consumer automatically subscribes to message broker destinations and processes incoming messages. When combined with `WithRouting()`, subscriptions are auto-generated from your routing configuration.\n\n## Overview\n\nThe `AddTransportConsumer()` extension method:\n\n1. **Auto-generates subscriptions** from `RoutingOptions` configured via `WithRouting()`\n2. **Registers `TransportConsumerOptions`** with populated destinations\n3. **Starts `TransportConsumerWorker`** as a hosted service\n\n## Auto-Configuration {#auto-configuration}\n\nThe recommended approach chains `WithRouting()` and `AddTransportConsumer()`:\n\n```csharp\nservices.AddWhizbang()\n    .WithRouting(routing => {\n        routing\n            .OwnDomains(\"myapp.orders.commands\")\n            .SubscribeTo(\"myapp.payments.events\")\n            .Inbox.UseSharedTopic(\"inbox\");\n    })\n    .WithEFCore<OrderDbContext>()\n    .WithDriver.Postgres\n    .AddTransportConsumer();\n```\n\nThis auto-generates subscriptions:\n- **Inbox subscription** from `OwnDomains()` - Filters commands by namespace pattern\n- **Event subscriptions** from `SubscribeTo()` - Subscribes to each namespace topic\n- **Auto-discovered events** from perspectives and receptors\n\n### What Gets Generated\n\nFor the configuration above, `AddTransportConsumer()` generates:\n\n| Destination | Address | Routing Key |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/type-formatting",
    "title": "Type Formatting",
    "category": "Core Concepts",
    "order": 999,
    "description": "",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/type-matching",
    "title": "Type Matching",
    "category": "Core Concepts",
    "order": 999,
    "description": "",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/type-qualification",
    "title": "Type Qualification",
    "category": "Core Concepts",
    "order": 999,
    "description": "# TypeQualification: Type Name Formatting Control\n\nTypeQualification is a flag enum that controls how .NET type names are formatted in generated code. It enables fine-grained control over namespace, assembly, version, and other type name components.\n\n## Overview\n\n**TypeQualification** provides:\n- ✅ Flag-based control over type name components\n- ✅ Individual component flags for fine-grained control\n- ✅ Composite presets for common scenarios\n- ✅ Fully AOT-compatible (no reflection)\n- ✅ Used by source generators and message association APIs\n\n## Quick Start\n\n### Using TypeQualification Flags\n\n```csharp\nusing Whizbang.Core;\n\nvar type = typeof(ECommerce.Contracts.Events.ProductCreatedEvent);\n\n// Simple type name only\nvar simple = TypeFormatter.FormatType(type, TypeQualification.Simple);\n// Result: \"ProductCreatedEvent\"\n\n// Namespace + type name\nvar namespaced = TypeFormatter.FormatType(type, TypeQualification.NamespaceQualified);\n// Result: \"ECommerce.Contracts.Events.ProductCreatedEvent\"\n\n// Namespace + type + assembly\nvar fullyQualified = TypeFormatter.FormatType(type, TypeQualification.FullyQualified);\n// Result: \"ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts\"\n\n// With version information\nvar withVersion = TypeFormatter.FormatType(type, TypeQualification.FullyQualifiedWithVersion);\n// Result: \"ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts, Version=1.0.0, Culture=neutral, PublicKeyToken=null\"\n```\n\n### Combining Individual Flags\n\n```csharp\n// Custom combination: Namespace + Type + Assembly (no version)\nvar custom = TypeFormatter.FormatType(\n    type,\n    TypeQualification.Namespace | TypeQualification.TypeName | TypeQualification.Assembly\n);\n// Result: \"ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts\"\n\n// With global prefix\nvar globalQualified = TypeFormatter.FormatType(\n    type,\n    TypeQualification.GlobalPrefix | TypeQualification.Namespace | TypeQualification.TypeName\n);\n// Result: \"global::ECommerce.Contracts.Events.ProductCreatedEvent\"\n```\n\n## Component Flags\n\n### Individual Component Flags\n\nEach flag controls a specific part of the type name:\n\n| Flag | Value | Description |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/core-concepts/whizbang-ids",
    "title": "Whizbang Ids",
    "category": "Core Concepts",
    "order": 999,
    "description": "# WhizbangIds: Strongly-Typed Identity Values\n\nWhizbang uses strongly-typed identity values based on UUIDv7 for all identifiers. This provides type safety, prevents ID mixing mistakes, and enables AOT-compatible dependency injection.\n\n## Overview\n\n**WhizbangIds** are source-generated value types that:\n- ✅ Wrap UUIDv7 GUIDs for time-ordered, database-friendly identities\n- ✅ Provide compile-time type safety (can't mix OrderId with CustomerId)\n- ✅ Support both static and DI-based ID generation\n- ✅ Are fully AOT-compatible (zero reflection)\n- ✅ Auto-register with DI via ModuleInitializer\n\n## TrackedGuid: Metadata-Aware GUID Wrapper\n\nFor scenarios where you need to work with raw GUIDs while preserving generation metadata, Whizbang provides `TrackedGuid`:\n\n```csharp\nusing Whizbang.Core.ValueObjects;\n\n// Create with sub-millisecond precision (recommended)\nvar tracked = TrackedGuid.NewMedo();  // Uses Medo.Uuid7 internally\n\n// Check metadata\nbool isTimeOrdered = tracked.IsTimeOrdered;           // true\nbool subMs = tracked.SubMillisecondPrecision;         // true\nDateTimeOffset when = tracked.Timestamp;              // Extracted from UUIDv7\n\n// Implicit conversion to Guid\nGuid guid = tracked;\n\n// Parse from external sources (database, API)\nvar parsed = TrackedGuid.Parse(\"550e8400-e29b-41d4-a716-446655440000\");\nvar external = TrackedGuid.FromExternal(someGuid);\n```\n\n### Why TrackedGuid?\n\n| Feature | `Guid.NewGuid()` | `Guid.CreateVersion7()` | `TrackedGuid.NewMedo()` |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/customization-examples/event-sourcing-cqrs",
    "title": "Event Sourcing & CQRS",
    "category": "Customization Examples",
    "order": 2,
    "description": "Implement full event sourcing with CQRS - event store, snapshots, temporal queries, and projections",
    "tags": "event-sourcing, cqrs, event-store, snapshots, temporal-queries",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/customization-examples/microservices-orchestration",
    "title": "Microservices Orchestration",
    "category": "Customization Examples",
    "order": 3,
    "description": "Implement saga orchestration patterns - distributed workflows, compensation, and process managers",
    "tags": "sagas, orchestration, process-managers, distributed-workflows, compensation",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/customization-examples/multi-tenant-saas",
    "title": "Multi-Tenant SaaS",
    "category": "Customization Examples",
    "order": 1,
    "description": "Build multi-tenant SaaS applications with tenant isolation, per-tenant databases, and cross-tenant analytics",
    "tags": "multi-tenancy, saas, tenant-isolation, database-per-tenant",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/customization-examples/real-time-analytics",
    "title": "Real-Time Analytics",
    "category": "Customization Examples",
    "order": 4,
    "description": "Build real-time analytics dashboards - streaming metrics, SignalR updates, and live KPIs",
    "tags": "real-time, analytics, signalr, streaming, dashboards, websockets",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/data/dapper-integration",
    "title": "Dapper Integration",
    "category": "Data Access",
    "order": 1,
    "description": "Lightweight, high-performance data access with Dapper for Whizbang perspectives and lenses - simple SQL, minimal overhead",
    "tags": "dapper, data-access, postgresql, sql, micro-orm",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/data/efcore-integration",
    "title": "EF Core Integration",
    "category": "Data Access",
    "order": 2,
    "description": "Full-featured ORM with EF Core 10 for complex domain models - JSONB support, UUIDv7, migrations, and advanced querying",
    "tags": "ef-core, entity-framework, postgresql, orm, jsonb, uuidv7",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/data/efcore-json-configuration",
    "title": "EF Core 10 JSON Configuration",
    "category": "Data",
    "order": 10,
    "description": "Configuring EF Core 10 with custom JSON converters for JSONB columns",
    "tags": "efcore, json, jsonb, postgresql, npgsql, converters",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/data/event-store",
    "title": "Event Store",
    "category": "Data Access",
    "order": 4,
    "description": "Event sourcing and stream storage - event streams, replay, checkpoints, snapshots, and temporal queries",
    "tags": "event-sourcing, event-store, streams, replay, checkpoints, snapshots, postgresql",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/data/perspectives-storage",
    "title": "Perspectives Storage",
    "category": "Data Access",
    "order": 3,
    "description": "Read model schema design for perspectives - denormalization strategies, JSONB columns, indexing, and high-volume partitioning",
    "tags": "perspectives, read-models, schema-design, denormalization, postgresql, jsonb, partitioning",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/data/schema-migration",
    "title": "Schema Migration",
    "category": "data",
    "order": 999,
    "description": "# Schema Migration\n\nWhizbang provides automatic schema management for perspective tables, with built-in drift detection and safe rename operations. This page covers how Whizbang handles schema changes across deployments.\n\n## Automatic Schema Creation\n\nWhen your application starts, Whizbang automatically creates all required infrastructure tables and perspective tables:\n\n```csharp\n// In your startup code\nawait dbContext.EnsureWhizbangDatabaseInitializedAsync();\n```\n\nThis single call:\n1. Creates infrastructure tables (`wh_inbox`, `wh_outbox`, `wh_event_store`, etc.)\n2. Creates perspective tables for all discovered perspectives\n3. Registers perspectives in the [perspective registry](/docs/v1.0.0/perspectives/registry)\n4. Detects and logs any schema drift\n\n## Schema Drift Detection\n\nSchema drift occurs when your C# perspective definition doesn't match the database table. Whizbang detects this by comparing SHA-256 hashes of the schema definition.\n\n### Detection Flow\n\n```\n┌─────────────────────┐\n│  Compile Time       │\n├─────────────────────┤\n│ Generate schema     │\n│ JSON from C# class  │\n│ Compute SHA-256     │\n│ hash of schema      │\n└─────────┬───────────┘\n          │\n          ▼\n┌─────────────────────┐\n│  Runtime            │\n├─────────────────────┤\n│ Compare hash with   │\n│ stored hash in      │\n│ perspective_registry│\n└─────────┬───────────┘\n          │\n          ▼\n┌─────────────────────┐\n│  If Different       │\n├─────────────────────┤\n│ Log drift warning   │\n│ Update registry     │\n└─────────────────────┘\n```\n\n### What Causes Drift\n\n| Change Type | Example | Drift Detected? |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/data/turnkey-initialization",
    "title": "Turnkey Initialization",
    "category": "data",
    "order": 999,
    "description": "",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/data-access/schema-generation-pattern",
    "title": "Schema Generation Pattern",
    "category": "Data Access",
    "order": 6,
    "description": "Database-agnostic schema definitions with ISchemaBuilder for Postgres, SQLite, and custom database engines",
    "tags": "schema-generation, database, postgres, sqlite, ddl, ef-core, dapper, aot",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/diagnostics/whiz030",
    "title": "WHIZ030: Perspective Event Missing StreamKey",
    "category": "Diagnostics",
    "order": 999,
    "description": "Event type used in perspective must have exactly one property marked with [StreamKey] attribute",
    "tags": [
      "diagnostics",
      "perspectives",
      "streamkey",
      "source-generator"
    ],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/diagnostics/whiz031",
    "title": "WHIZ031: Multiple StreamKey Attributes",
    "category": "Diagnostics",
    "order": 999,
    "description": "Event type has multiple properties marked with [StreamKey] - only one is allowed",
    "tags": [
      "diagnostics",
      "perspectives",
      "streamkey",
      "source-generator"
    ],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/diagnostics/whiz058",
    "title": "WHIZ058: GUID Call Intercepted",
    "category": "Diagnostics",
    "order": 999,
    "description": "Informational diagnostic indicating a GUID creation call has been intercepted and wrapped with TrackedGuid",
    "tags": [
      "diagnostics",
      "guid",
      "interception",
      "source-generator",
      "trackedguid"
    ],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/diagnostics/whiz059",
    "title": "WHIZ059: GUID Interception Suppressed",
    "category": "Diagnostics",
    "order": 999,
    "description": "Informational diagnostic indicating a GUID creation call was not intercepted due to suppression",
    "tags": [
      "diagnostics",
      "guid",
      "interception",
      "source-generator",
      "suppression"
    ],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/diagnostics/whiz070",
    "title": "WHIZ070: Missing Pgvector.EntityFrameworkCore Package",
    "category": "Diagnostics",
    "order": 999,
    "description": "Error diagnostic when a perspective model uses [VectorField] but the required Pgvector.EntityFrameworkCore package is not referenced",
    "tags": [
      "diagnostics",
      "vector",
      "pgvector",
      "efcore",
      "package-reference"
    ],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/diagnostics/whiz071",
    "title": "WHIZ071: Missing Pgvector Package",
    "category": "Diagnostics",
    "order": 999,
    "description": "Error diagnostic when a perspective model uses [VectorField] but the required base Pgvector package is not referenced",
    "tags": [
      "diagnostics",
      "vector",
      "pgvector",
      "npgsql",
      "package-reference"
    ],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/extensibility/custom-dispatchers",
    "title": "Custom Dispatchers",
    "category": "Extensibility",
    "order": 9,
    "description": "Implement custom dispatcher patterns - mediator, event sourcing, multi-tenant routing",
    "tags": "dispatcher, mediator, routing, event-sourcing",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/extensibility/custom-health-checks",
    "title": "Custom Health Checks",
    "category": "Extensibility",
    "order": 6,
    "description": "Implement custom health checks for transports, databases, external APIs, and custom services",
    "tags": "health-checks, monitoring, kubernetes, readiness, liveness",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/extensibility/custom-id-generators",
    "title": "Custom ID Generators",
    "category": "Extensibility",
    "order": 8,
    "description": "Implement custom ID generation strategies - Snowflake IDs, ULID, CUID, or custom schemes",
    "tags": "id-generation, uuidv7, snowflake, ulid, cuid",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/extensibility/custom-perspectives",
    "title": "Custom Perspectives",
    "category": "Extensibility",
    "order": 3,
    "description": "Advanced perspective patterns - time-travel, snapshots, caching, batching, and custom storage backends",
    "tags": "perspectives, read-models, custom-storage, time-travel, snapshots, caching",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/extensibility/custom-policies",
    "title": "Custom Policies",
    "category": "Extensibility",
    "order": 5,
    "description": "Advanced policy patterns - weighted policies, dynamic registration, async evaluation, caching, and A/B testing",
    "tags": "policies, custom-policy-engine, weighted-policies, async-policies, policy-caching",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/extensibility/custom-receptors",
    "title": "Custom Receptors",
    "category": "Extensibility",
    "order": 2,
    "description": "Advanced receptor customization patterns - streaming, lifecycle hooks, base classes, and performance optimization",
    "tags": "receptors, custom-handlers, streaming, lifecycle, base-classes",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/extensibility/custom-serializers",
    "title": "Custom Serializers",
    "category": "Extensibility",
    "order": 7,
    "description": "Implement custom serializers for Protobuf, MessagePack, or custom binary formats - AOT-compatible patterns",
    "tags": "serialization, protobuf, messagepack, aot, json",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/extensibility/custom-storage",
    "title": "Custom Storage",
    "category": "Extensibility",
    "order": 10,
    "description": "Implement custom storage backends - Redis, MongoDB, Elasticsearch, Cassandra, or custom databases",
    "tags": "storage, iperspectivestore, custom-backends, redis, mongodb",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/extensibility/custom-transports",
    "title": "Custom Transports",
    "category": "Extensibility",
    "order": 4,
    "description": "Implement custom transports for HTTP, gRPC, Kafka, RabbitMQ, or any messaging system - AOT-compatible patterns",
    "tags": "transports, itransport, custom-implementations, http, grpc, kafka, rabbitmq, serialization",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/extensibility/custom-work-coordinators",
    "title": "Custom Work Coordinators",
    "category": "Extensibility",
    "order": 11,
    "description": "Implement custom work coordination strategies - distributed locks, Redis queues, or custom lease management",
    "tags": "work-coordination, iworkcoordinator, distributed-locks, redis-queues",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/extensibility/database-schema-framework",
    "title": "Database Schema Framework",
    "category": "Extensibility",
    "order": 11,
    "description": "Implement database drivers using the Whizbang.Data.Schema framework - database-agnostic table and column definitions for PostgreSQL, SQLite, SQL Server, and custom databases",
    "tags": "schema, database, drivers, postgresql, sqlite, sqlserver, table-definition, column-definition, whizbang-data-type",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/extensibility/hooks-and-middleware",
    "title": "Hooks and Middleware",
    "category": "Extensibility",
    "order": 1,
    "description": "Pipeline behaviors for cross-cutting concerns - logging, validation, retry, caching, and custom pre/post processing",
    "tags": "extensibility, pipeline-behavior, middleware, hooks, cross-cutting-concerns, aop",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/extensibility/plugin-architecture",
    "title": "Plugin Architecture",
    "category": "Extensibility",
    "order": 12,
    "description": "Design plugin systems - dynamic assembly loading, hot-reload, and extension points",
    "tags": "plugins, dynamic-loading, hot-reload, extensibility",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/getting-started/installation",
    "title": "Installation Guide",
    "category": "Getting Started",
    "order": 2,
    "description": "Install Whizbang and set up your first project with NuGet packages, project templates, and IDE configuration",
    "tags": "installation, setup, nuget, project-templates",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/getting-started/introduction",
    "title": "Introduction to Whizbang",
    "category": "Getting Started",
    "order": 1,
    "description": "Learn about Whizbang - a zero-reflection, AOT-compatible .NET library for building event-driven, CQRS, and event-sourced applications",
    "tags": "introduction, overview, philosophy, getting-started",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/getting-started/project-structure",
    "title": "Project Structure Guide",
    "category": "Getting Started",
    "order": 4,
    "description": "Organize your Whizbang application with recommended project structures, separation of concerns, and multi-service architectures",
    "tags": "project-structure, architecture, organization, best-practices",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/getting-started/quick-start",
    "title": "Quick Start Tutorial",
    "category": "Getting Started",
    "order": 3,
    "description": "Build your first Whizbang application in 10 minutes - create messages, receptors, and dispatch commands with complete working examples",
    "tags": "quick-start, tutorial, beginner, hello-world",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/graphql/filtering",
    "title": "Filtering",
    "category": "graphql",
    "order": 999,
    "description": "",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/graphql/index",
    "title": "Index",
    "category": "graphql",
    "order": 999,
    "description": "# GraphQL Integration\n\nWhizbang provides seamless HotChocolate GraphQL integration for Lenses, enabling powerful filtering, sorting, paging, and projection capabilities with full AOT compatibility.\n\n## Overview\n\nThe `Whizbang.Transports.HotChocolate` package integrates Whizbang Lenses with [HotChocolate](https://chillicream.com/docs/hotchocolate), providing:\n\n- **Automatic Query Generation** - Source generators create type-safe GraphQL queries from `[GraphQLLens]` attributes\n- **Full Data Operations** - `[UseFiltering]`, `[UseSorting]`, `[UsePaging]`, `[UseProjection]` support\n- **Scope-Aware Queries** - Multi-tenancy and security filtering via middleware\n- **AOT Compatible** - Zero reflection, source-generated at compile time\n\n## Quick Start\n\n### 1. Install the Package\n\n```bash\ndotnet add package Whizbang.Transports.HotChocolate\n```\n\n### 2. Define Your Lens\n\n```csharp\n[GraphQLLens(QueryName = \"orders\")]\npublic interface IOrderLens : ILensQuery<OrderReadModel> { }\n```\n\n### 3. Configure Services\n\n```csharp\n// Program.cs\nbuilder.Services.AddGraphQLServer()\n    .AddWhizbangLenses()\n    .AddQueryType<Query>();\n\n// Add scope middleware for multi-tenancy\nbuilder.Services.AddWhizbangScope();\n\nvar app = builder.Build();\napp.UseWhizbangScope();\napp.MapGraphQL();\n```\n\n### 4. Query Your Data\n\n```graphql\n{\n  orders(\n    where: { data: { status: { eq: \"Completed\" } } }\n    order: { data: { createdAt: DESC } }\n    first: 10\n  ) {\n    nodes {\n      id\n      data {\n        customerName\n        status\n        totalAmount\n      }\n      metadata {\n        eventType\n        timestamp\n      }\n    }\n    pageInfo {\n      hasNextPage\n      endCursor\n    }\n    totalCount\n  }\n}\n```\n\n## Documentation\n\n| Topic | Description |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/graphql/lens-integration",
    "title": "Lens Integration",
    "category": "graphql",
    "order": 999,
    "description": "# Lens Integration\n\nThe `[GraphQLLens]` attribute marks lens interfaces for GraphQL exposure, enabling automatic query generation with configurable filtering, sorting, and paging.\n\n## Basic Usage\n\n```csharp\n[GraphQLLens(QueryName = \"orders\")]\npublic interface IOrderLens : ILensQuery<OrderReadModel> { }\n```\n\nThis generates a GraphQL query field named `orders` with full data operations support.\n\n## Attribute Properties\n\n| Property | Type | Default | Description |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/graphql/scoping",
    "title": "Scoping",
    "category": "graphql",
    "order": 999,
    "description": "# GraphQL Scoping\n\nWhizbang's scope middleware provides automatic multi-tenancy and security filtering for GraphQL queries, ensuring users only see data they're authorized to access.\n\n## Overview\n\nThe `WhizbangScopeMiddleware` extracts scope information from HTTP requests (JWT claims and headers) and makes it available to lens queries for automatic filtering.\n\n```\nHTTP Request\n    │\n    ├── JWT Claims (tenant_id, sub, groups, ...)\n    ├── Headers (X-Tenant-Id, X-User-Id, ...)\n    │\n    ▼\nWhizbangScopeMiddleware\n    │\n    ├── Extracts scope values\n    ├── Creates IScopeContext\n    │\n    ▼\nIScopeContextAccessor.Current\n    │\n    ▼\nLens Query (automatic filtering)\n```\n\n## Setup\n\n### 1. Register Services\n\n```csharp\nbuilder.Services.AddWhizbangScope();\n```\n\n### 2. Add Middleware\n\n```csharp\napp.UseAuthentication();\napp.UseWhizbangScope();  // After auth\napp.MapGraphQL();\n```\n\n## Configuration\n\n### Default Claim/Header Mappings\n\n| Scope Value | Claim Type | Header Name |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/graphql/setup",
    "title": "Setup",
    "category": "graphql",
    "order": 999,
    "description": "# GraphQL Setup\n\nThis guide covers installation and configuration of Whizbang's HotChocolate GraphQL integration.\n\n## Installation\n\n```bash\ndotnet add package Whizbang.Transports.HotChocolate\n```\n\n## Basic Configuration\n\n### Minimal Setup\n\n```csharp\n// Program.cs\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services\n    .AddGraphQLServer()\n    .AddWhizbangLenses()\n    .AddQueryType<Query>();\n\nvar app = builder.Build();\napp.MapGraphQL();\napp.Run();\n```\n\n### With Scope Middleware\n\nFor multi-tenancy and security filtering:\n\n```csharp\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services\nbuilder.Services.AddWhizbangScope();\nbuilder.Services\n    .AddGraphQLServer()\n    .AddWhizbangLenses()\n    .AddQueryType<Query>();\n\nvar app = builder.Build();\n\n// Middleware order matters\napp.UseAuthentication();\napp.UseWhizbangScope();  // After auth, before GraphQL\napp.MapGraphQL();\n\napp.Run();\n```\n\n## Configuration Options\n\n### WhizbangGraphQLOptions\n\nConfigure default behavior for all lenses:\n\n```csharp\nbuilder.Services\n    .AddGraphQLServer()\n    .AddWhizbangLenses(options => {\n        options.DefaultScope = GraphQLLensScope.Data | GraphQLLensScope.SystemFields;\n        options.DefaultPageSize = 25;\n        options.MaxPageSize = 200;\n    });\n```\n\n| Option | Default | Description |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/graphql/sorting",
    "title": "Sorting",
    "category": "graphql",
    "order": 999,
    "description": "",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/guides/implementing-multi-tenancy",
    "title": "Implementing Multi Tenancy",
    "category": "guides",
    "order": 999,
    "description": "# Implementing Multi-Tenancy\n\nThis guide walks through implementing multi-tenancy in a Whizbang application, from basic tenant isolation to advanced group-based sharing.\n\n## Prerequisites\n\n- Whizbang.Core package installed\n- Basic understanding of perspectives and lenses\n- Familiarity with dependency injection\n\n## Step 1: Configure Security Options\n\nFirst, configure the security system with roles and permission extraction.\n\n```csharp\n// Program.cs\nbuilder.Services.AddSingleton(new SecurityOptions()\n  // Define roles with permissions\n  .DefineRole(\"Admin\", b => b\n    .HasAllPermissions(\"*\"))\n  .DefineRole(\"Manager\", b => b\n    .HasAllPermissions(\"orders\")\n    .HasAllPermissions(\"customers\")\n    .HasReadPermission(\"reports\"))\n  .DefineRole(\"User\", b => b\n    .HasReadPermission(\"orders\")\n    .HasReadPermission(\"products\"))\n\n  // Extract from JWT claims\n  .ExtractPermissionsFromClaim(\"permissions\")\n  .ExtractRolesFromClaim(\"roles\")\n  .ExtractSecurityPrincipalsFromClaim(\"groups\"));\n```\n\n## Step 2: Register Core Services\n\nRegister the security and scoping services.\n\n```csharp\n// Core services\nbuilder.Services.AddSingleton<IScopeContextAccessor, ScopeContextAccessor>();\nbuilder.Services.AddSingleton<ISystemEventEmitter, SystemEventEmitter>();\nbuilder.Services.AddSingleton<LensOptions>();\n\n// Scoped lens factory\nbuilder.Services.AddScoped<IScopedLensFactory, ScopedLensFactory>();\n\n// Your lenses\nbuilder.Services.AddScoped<IOrderLens, OrderLens>();\nbuilder.Services.AddScoped<ICustomerLens, CustomerLens>();\n```\n\n## Step 3: Create Scope Context Middleware\n\nCreate middleware to populate the scope context from the authenticated user.\n\n```csharp\npublic class ScopeContextMiddleware {\n  private readonly RequestDelegate _next;\n  private readonly SecurityOptions _securityOptions;\n\n  public ScopeContextMiddleware(RequestDelegate next, SecurityOptions options) {\n    _next = next;\n    _securityOptions = options;\n  }\n\n  public async Task InvokeAsync(\n      HttpContext httpContext,\n      IScopeContextAccessor accessor) {\n\n    if (httpContext.User.Identity?.IsAuthenticated == true) {\n      var claims = httpContext.User.Claims\n        .ToDictionary(c => c.Type, c => c.Value);\n\n      // Extract using configured extractors\n      var permissions = _securityOptions.Extractors\n        .SelectMany(e => e.ExtractPermissions(claims))\n        .ToHashSet();\n      var roles = _securityOptions.Extractors\n        .SelectMany(e => e.ExtractRoles(claims))\n        .ToHashSet();\n      var principals = _securityOptions.Extractors\n        .SelectMany(e => e.ExtractSecurityPrincipals(claims))\n        .ToHashSet();\n\n      // Add user as principal\n      var userId = claims.GetValueOrDefault(\"sub\");\n      if (userId != null) {\n        principals.Add(SecurityPrincipalId.User(userId));\n      }\n\n      accessor.Current = new ScopeContext {\n        Scope = new PerspectiveScope {\n          TenantId = claims.GetValueOrDefault(\"tenant\"),\n          UserId = userId\n        },\n        Roles = roles,\n        Permissions = permissions,\n        SecurityPrincipals = principals,\n        Claims = claims\n      };\n    }\n\n    await _next(httpContext);\n  }\n}\n\n// Register in Program.cs\napp.UseAuthentication();\napp.UseMiddleware<ScopeContextMiddleware>();\napp.UseAuthorization();\n```\n\n## Step 4: Implement Filterable Lenses\n\nCreate lenses that implement `IFilterableLens` to receive scope filters.\n\n```csharp\npublic interface IOrderLens : ILensQuery, IFilterableLens {\n  Task<List<Order>> GetAllAsync();\n  Task<Order?> GetByIdAsync(Guid id);\n}\n\npublic class OrderLens : IOrderLens {\n  private readonly DbContext _context;\n  private ScopeFilterInfo _filterInfo;\n\n  public OrderLens(DbContext context) {\n    _context = context;\n  }\n\n  public void ApplyFilter(ScopeFilterInfo filterInfo) {\n    _filterInfo = filterInfo;\n  }\n\n  public async Task<List<Order>> GetAllAsync() {\n    var query = _context.Set<PerspectiveRow<Order>>().AsQueryable();\n\n    // Apply scope filters\n    if (_filterInfo.Filters.HasFlag(ScopeFilter.Tenant)) {\n      query = query.Where(r => r.Scope.TenantId == _filterInfo.TenantId);\n    }\n\n    if (_filterInfo.UseOrLogicForUserAndPrincipal) {\n      // User OR Principal\n      query = query.Where(r =>\n        r.Scope.UserId == _filterInfo.UserId ||\n        r.Scope.AllowedPrincipals!.Any(p =>\n          _filterInfo.SecurityPrincipals.Contains(p)));\n    } else {\n      if (_filterInfo.Filters.HasFlag(ScopeFilter.User)) {\n        query = query.Where(r => r.Scope.UserId == _filterInfo.UserId);\n      }\n      if (_filterInfo.Filters.HasFlag(ScopeFilter.Principal)) {\n        query = query.Where(r =>\n          r.Scope.AllowedPrincipals!.Any(p =>\n            _filterInfo.SecurityPrincipals.Contains(p)));\n      }\n    }\n\n    return await query.Select(r => r.Data).ToListAsync();\n  }\n\n  public async Task<Order?> GetByIdAsync(Guid id) {\n    // Similar filtering logic...\n  }\n}\n```\n\n## Step 5: Use in Controllers\n\nUse the scoped lens factory in your controllers.\n\n```csharp\n[ApiController]\n[Route(\"api/orders\")]\npublic class OrdersController : ControllerBase {\n  private readonly IScopedLensFactory _lensFactory;\n\n  public OrdersController(IScopedLensFactory lensFactory) {\n    _lensFactory = lensFactory;\n  }\n\n  [HttpGet]\n  public async Task<IActionResult> GetOrders() {\n    // Gets only orders for current tenant\n    var lens = _lensFactory.GetTenantLens<IOrderLens>();\n    var orders = await lens.GetAllAsync();\n    return Ok(orders);\n  }\n\n  [HttpGet(\"my\")]\n  public async Task<IActionResult> GetMyOrders() {\n    // Gets only current user's orders\n    var lens = _lensFactory.GetUserLens<IOrderLens>();\n    var orders = await lens.GetAllAsync();\n    return Ok(orders);\n  }\n\n  [HttpGet(\"shared\")]\n  public async Task<IActionResult> GetSharedOrders() {\n    // Gets orders shared with user's groups\n    var lens = _lensFactory.GetPrincipalLens<IOrderLens>();\n    var orders = await lens.GetAllAsync();\n    return Ok(orders);\n  }\n\n  [HttpGet(\"all-accessible\")]\n  public async Task<IActionResult> GetAllAccessibleOrders() {\n    // Gets my orders + shared with me\n    var lens = _lensFactory.GetMyOrSharedLens<IOrderLens>();\n    var orders = await lens.GetAllAsync();\n    return Ok(orders);\n  }\n\n  [HttpDelete(\"{id}\")]\n  public async Task<IActionResult> DeleteOrder(Guid id) {\n    // Require delete permission\n    var lens = _lensFactory.GetLens<IOrderLens>(\n      ScopeFilter.Tenant,\n      Permission.Delete(\"orders\"));\n\n    // Will throw AccessDeniedException if not authorized\n    // ...\n  }\n}\n```\n\n## Step 6: Store Data with Scope\n\nWhen creating perspective rows, set the appropriate scope.\n\n```csharp\npublic class OrderPerspective : IPerspectiveFor<Order, OrderCreatedEvent> {\n  private readonly IPerspectiveStore<Order> _store;\n  private readonly IScopeContextAccessor _accessor;\n\n  public async Task Update(OrderCreatedEvent @event, CancellationToken ct) {\n    var context = _accessor.Current!;\n    var order = Apply(new Order(), @event);\n\n    await _store.UpsertAsync(\n      @event.OrderId,\n      order,\n      new PerspectiveScope {\n        TenantId = context.Scope.TenantId,\n        UserId = context.Scope.UserId,\n        // Optional: Allow sharing with user's groups\n        AllowedPrincipals = context.SecurityPrincipals.ToList()\n      },\n      ct);\n  }\n}\n```\n\n## Step 7: Handle Access Denied\n\nHandle `AccessDeniedException` appropriately.\n\n```csharp\npublic class SecurityExceptionMiddleware {\n  private readonly RequestDelegate _next;\n  private readonly ILogger<SecurityExceptionMiddleware> _logger;\n\n  public async Task InvokeAsync(HttpContext context) {\n    try {\n      await _next(context);\n    } catch (AccessDeniedException ex) {\n      _logger.LogWarning(\n        \"Access denied: {Resource} requires {Permission}. Reason: {Reason}\",\n        ex.ResourceType,\n        ex.RequiredPermission,\n        ex.Reason);\n\n      context.Response.StatusCode = 403;\n      await context.Response.WriteAsJsonAsync(new {\n        error = \"Access denied\",\n        resource = ex.ResourceType,\n        requiredPermission = ex.RequiredPermission.Value\n      });\n    }\n  }\n}\n```\n\n## Advanced: Organization Hierarchy\n\nFor organization-based access within a tenant:\n\n```csharp\n// Store with organization scope\nawait _store.UpsertAsync(id, data, new PerspectiveScope {\n  TenantId = \"tenant-123\",\n  OrganizationId = \"org-sales\",\n  AllowedPrincipals = new[] {\n    SecurityPrincipalId.Group(\"org:sales\"),\n    SecurityPrincipalId.Group(\"org:management\")\n  }\n});\n\n// Query organization's data\nvar lens = _lensFactory.GetOrganizationLens<IReportLens>();\n```\n\n## Advanced: Department-Based Extensions\n\nUse extensions for custom scope dimensions:\n\n```csharp\n// Store with custom extensions\nawait _store.UpsertAsync(id, data, new PerspectiveScope {\n  TenantId = \"tenant-123\",\n  Extensions = new Dictionary<string, string?> {\n    [\"department\"] = \"engineering\",\n    [\"costCenter\"] = \"CC-1234\",\n    [\"project\"] = \"alpha\"\n  }\n});\n\n// Access in queries\nvar department = row.Scope[\"department\"];\n```\n\n## Multi-Tenancy in Background Processing\n\n:::new\nBackground processing tenant support added in v1.0.0\n:::\n\nWhen using lifecycle receptors (`PostPerspectiveAsync`, etc.) or background workers, HTTP context is unavailable. This section explains how tenant context flows through the system and how to access it.\n\n### Security Context Propagation Flow\n\nWhizbang captures tenant context when a message is dispatched and propagates it through the entire processing pipeline:\n\n```\nHTTP Request (TenantId from JWT)\n         │\n         ▼\n┌────────────────────────────────┐\n│ ScopeContextMiddleware         │\n│ IScopeContextAccessor.Current  │\n│ = { TenantId: \"tenant-123\" }   │\n└────────────────┬───────────────┘\n                 │\n                 ▼\n┌────────────────────────────────┐\n│ Command Dispatch               │\n│ dispatcher.SendAsync(cmd)      │\n└────────────────┬───────────────┘\n                 │\n                 ▼ TenantId stored in MessageHop\n┌────────────────────────────────┐\n│ Outbox (wh_outbox)             │\n│ hop.SecurityContext.TenantId   │\n│ = \"tenant-123\"                 │\n└────────────────┬───────────────┘\n                 │\n                 ▼ Worker picks up message\n┌────────────────────────────────┐\n│ ServiceBusConsumerWorker       │\n│ Extracts TenantId from hop     │\n│ Establishes IScopeContext      │\n└────────────────┬───────────────┘\n                 │\n                 ▼ Event cascaded\n┌────────────────────────────────┐\n│ Perspective Processing         │\n│ TenantId flows to event        │\n└────────────────┬───────────────┘\n                 │\n                 ▼ Lifecycle receptor fires\n┌────────────────────────────────┐\n│ PostPerspectiveAsync Receptor  │\n│ IMessageContext.TenantId       │\n│ = \"tenant-123\" ✓               │\n└────────────────────────────────┘\n```\n\n**Key insight**: TenantId is preserved through the entire flow without any manual propagation.\n\n### Accessing Tenant Context in Background Receptors\n\nChoose the access method that fits your needs:\n\n#### Option 1: IMessageContext (Simplest)\n\nFor simple tenant access, inject `IMessageContext`:\n\n```csharp\n[FireAt(LifecycleStage.PostPerspectiveAsync)]\npublic class TenantAwareBackgroundHandler : IReceptor<OrderCreatedEvent> {\n  private readonly IMessageContext _messageContext;\n  private readonly ITenantDbFactory _dbFactory;\n\n  public TenantAwareBackgroundHandler(\n      IMessageContext messageContext,\n      ITenantDbFactory dbFactory) {\n    _messageContext = messageContext;\n    _dbFactory = dbFactory;\n  }\n\n  public async ValueTask HandleAsync(OrderCreatedEvent evt, CancellationToken ct) {\n    // TenantId is available even though HTTP context is gone!\n    var tenantId = _messageContext.TenantId;\n\n    if (string.IsNullOrEmpty(tenantId)) {\n      // Handle system messages without tenant context\n      return;\n    }\n\n    // Use tenant-specific database\n    using var db = _dbFactory.CreateForTenant(tenantId);\n    await db.NotifyTenantAsync(evt.OrderId, ct);\n  }\n}\n```\n\n#### Option 2: IScopeContextAccessor (Full Scope)\n\nFor access to roles, permissions, and custom properties:\n\n```csharp\n[FireAt(LifecycleStage.PostPerspectiveAsync)]\npublic class AuthorizedBackgroundHandler : IReceptor<SensitiveEvent> {\n  private readonly IScopeContextAccessor _scopeContextAccessor;\n\n  public AuthorizedBackgroundHandler(IScopeContextAccessor scopeContextAccessor) {\n    _scopeContextAccessor = scopeContextAccessor;\n  }\n\n  public async ValueTask HandleAsync(SensitiveEvent evt, CancellationToken ct) {\n    var scope = _scopeContextAccessor.Current?.Scope;\n\n    var tenantId = scope?.TenantId;\n    var userId = scope?.UserId;\n    var roles = _scopeContextAccessor.Current?.Roles;\n\n    // Full security context available for authorization checks\n    if (roles?.Contains(\"Admin\") != true) {\n      return; // Skip non-admin processing\n    }\n\n    // Process with full context...\n  }\n}\n```\n\n#### Option 3: ISecurityContextCallback (Custom Service Integration)\n\nFor integrating with custom services like `UserContextManager`:\n\n```csharp\npublic class UserContextManagerCallback : ISecurityContextCallback {\n  private readonly UserContextManager _userContextManager;\n\n  public UserContextManagerCallback(UserContextManager userContextManager) {\n    _userContextManager = userContextManager;\n  }\n\n  public ValueTask OnContextEstablishedAsync(\n    IScopeContext context,\n    IMessageEnvelope envelope,\n    IServiceProvider scopedProvider,\n    CancellationToken cancellationToken = default) {\n\n    // Populate UserContextManager BEFORE receptors run\n    if (context?.Scope != null) {\n      _userContextManager.SetTenantContext(\n        new TenantContext { TenantId = context.Scope.TenantId });\n      _userContextManager.SetUserContext(\n        new UserContext { UserId = context.Scope.UserId });\n    }\n\n    return ValueTask.CompletedTask;\n  }\n}\n\n// Register\nservices.AddScoped<ISecurityContextCallback, UserContextManagerCallback>();\n```\n\n### Pattern Decision Guide\n\n| Scenario | Recommended Approach |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/infrastructure/aspire-integration",
    "title": ".NET Aspire Integration",
    "category": "Infrastructure",
    "order": 1,
    "description": "Cloud-native orchestration for Whizbang applications with .NET Aspire - automatic infrastructure provisioning and service discovery",
    "tags": "aspire, cloud-native, orchestration, service-bus, emulator, infrastructure, distributed-applications",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/infrastructure/health-checks",
    "title": "Health Checks",
    "category": "Infrastructure",
    "order": 2,
    "description": "Application health monitoring with built-in health checks for transports, databases, and custom components",
    "tags": "health-checks, monitoring, readiness, liveness, aspire-dashboard, observability",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/infrastructure/policies",
    "title": "Policy-Based Routing",
    "category": "Infrastructure",
    "order": 4,
    "description": "Dynamic message routing and configuration via predicate-based policies - multi-tenancy, environment-based routing, and execution strategies",
    "tags": "policies, routing, multi-tenancy, execution-strategy, policy-engine, decision-trail",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/infrastructure/pooling",
    "title": "Object Pooling",
    "category": "Infrastructure",
    "order": 3,
    "description": "Zero-allocation object pooling for high-performance message processing - reduce heap pressure and GC overhead",
    "tags": "pooling, performance, allocations, gc, policy-context, object-reuse",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/lenses/raw-sql",
    "title": "Raw Sql",
    "category": "lenses",
    "order": 999,
    "description": "",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/lenses/vector-search",
    "title": "Vector Search",
    "category": "lenses",
    "order": 999,
    "description": "# Vector Similarity Search\n\nWhizbang supports pgvector similarity queries for semantic search, embeddings, and AI/ML workloads.\n\n## Turnkey Setup {#turnkey-setup}\n\nWhizbang provides a **turnkey experience** for pgvector. When your perspective models use `[VectorField]` attributes, the source generator automatically creates an `Add{YourDbContext}()` extension method that handles all pgvector configuration:\n\n```csharp\n// Single call configures everything:\n// - NpgsqlDataSource with UseVector()\n// - DbContext with UseVector()\n// - HasPostgresExtension(\"vector\") in OnModelCreating\nbuilder.Services.AddMyAppDbContext(connectionString);\n```\n\n### What Gets Configured Automatically\n\nWhen Whizbang detects `[VectorField]` attributes in your perspective models, the generated code:\n\n1. **Creates the pgvector extension** - Generates `modelBuilder.HasPostgresExtension(\"vector\")` in `ConfigureWhizbang()`\n2. **Configures NpgsqlDataSource** - Calls `dataSourceBuilder.UseVector()` for Npgsql type mapping\n3. **Configures EF Core** - Calls `npgsqlOptions.UseVector()` for EF Core query translation\n4. **Maps vector columns** - Generates proper `HasColumnType(\"vector({dimensions})\")` configuration\n\n### Customization\n\nIf you need to configure the data source (e.g., for JSON options), pass a callback:\n\n```csharp\nbuilder.Services.AddMyAppDbContext(connectionString, dataSourceBuilder => {\n  dataSourceBuilder.ConfigureJsonOptions(jsonOptions);\n  dataSourceBuilder.EnableDynamicJson();\n});\n```\n\nOr configure DbContext options:\n\n```csharp\nbuilder.Services.AddMyAppDbContext(connectionString, configureDbContext: options => {\n  options.EnableSensitiveDataLogging();\n});\n```\n\n## Prerequisites\n\nWhen using `[VectorField]` attributes on your perspective models, you must add both pgvector packages:\n\n```xml\n<ItemGroup>\n  <!-- Base package for NpgsqlDataSourceBuilder.UseVector() -->\n  <PackageReference Include=\"Pgvector\" Version=\"0.3.0\" />\n\n  <!-- EF Core integration for type mapping and queries -->\n  <PackageReference Include=\"Pgvector.EntityFrameworkCore\" Version=\"0.3.0\" />\n</ItemGroup>\n```\n\nIf you forget these packages, compiler diagnostics will guide you:\n\n- **[WHIZ070](/docs/v0.1.0/diagnostics/whiz070)** - Missing `Pgvector.EntityFrameworkCore` package\n- **[WHIZ071](/docs/v0.1.0/diagnostics/whiz071)** - Missing `Pgvector` package\n\n## Defining Vector Fields\n\nAdd `[VectorField]` to properties in your perspective model:\n\n```csharp\npublic class DocumentModel {\n  public Guid Id { get; init; }\n  public string Title { get; init; } = \"\";\n  public string Content { get; init; } = \"\";\n\n  [VectorField(1536)]  // OpenAI ada-002 dimensions\n  public float[]? ContentEmbedding { get; init; }\n\n  [VectorField(1536)]  // For comparison operations\n  public float[]? SummaryEmbedding { get; init; }\n}\n\npublic class UserPreferenceModel {\n  public Guid UserId { get; init; }\n\n  [VectorField(1536)]\n  public float[]? PreferenceEmbedding { get; init; }\n}\n```\n\nThe generator creates pgvector shadow properties with appropriate indexes.\n\n## Usage Patterns\n\nAll methods use **strongly-typed lambda selectors** for compile-time safety.\n\n### Pattern 1: App-Side Vector (Search Query)\n\nUse when the search vector comes from your application (e.g., embedding a user's search query):\n\n```csharp\n// Get embedding from your embedding service (OpenAI, etc.)\nvar searchEmbedding = await embeddingService.EmbedAsync(userSearchQuery);\n\n// Find documents similar to the search query\nvar results = await documentLens.Query\n    .OrderByCosineDistance(m => m.ContentEmbedding, searchEmbedding)\n    .Take(10)\n    .ToListAsync();\n```\n\n**SQL Generated:**\n```sql\nSELECT * FROM documents\nORDER BY content_embedding <=> @p0 ASC\nLIMIT 10\n```\n\n### Pattern 2: Same-Table Column Comparison\n\nUse when comparing two vector columns on the same row (100% SQL, no vector data round-trip):\n\n```csharp\n// Find documents where content differs significantly from summary\n// (potential quality issue - summary doesn't match content)\nvar mismatchedDocs = await documentLens.Query\n    .Where(m => m.ContentEmbedding != null && m.SummaryEmbedding != null)\n    .OrderByCosineDistance(m => m.ContentEmbedding, m => m.SummaryEmbedding)\n    .ThenByDescending(m => m.Data.CreatedAt)  // Most different first, then newest\n    .Take(20)\n    .ToListAsync();\n\n// Find documents where content and summary are similar (well-summarized)\nvar wellSummarized = await documentLens.Query\n    .WithinCosineDistance(m => m.ContentEmbedding, m => m.SummaryEmbedding, threshold: 0.2)\n    .ToListAsync();\n```\n\n**SQL Generated:**\n```sql\n-- No vector data sent to/from C# - all computed in PostgreSQL!\nSELECT * FROM documents\nWHERE content_embedding IS NOT NULL AND summary_embedding IS NOT NULL\nORDER BY content_embedding <=> summary_embedding ASC\nLIMIT 20\n```\n\n### Pattern 3: Cross-Table Comparison (Joins)\n\nUse when comparing vectors from different tables:\n\n```csharp\n// Find documents that match a user's preferences\nvar userId = currentUserId;\n\nvar recommendations = await documentLens.Query\n    .SelectMany(\n        doc => userPreferenceLens.Query.Where(up => up.Data.UserId == userId),\n        (doc, pref) => new { Document = doc, Preference = pref })\n    .OrderByCosineDistance(\n        x => x.Document.Data.ContentEmbedding,    // From documents table\n        x => x.Preference.Data.PreferenceEmbedding)  // From user_preferences table\n    .Select(x => x.Document)\n    .Take(10)\n    .ToListAsync();\n```\n\n**SQL Generated:**\n```sql\nSELECT d.* FROM documents d\nJOIN user_preferences up ON up.user_id = @userId\nORDER BY d.content_embedding <=> up.preference_embedding ASC\nLIMIT 10\n```\n\n### Pattern 4: Filtering by Distance Threshold\n\nUse when you only want results within a certain similarity range:\n\n```csharp\nvar searchEmbedding = await embeddingService.EmbedAsync(userQuery);\n\n// Only return documents with cosine distance < 0.3 (very similar)\nvar closeMatches = await documentLens.Query\n    .WithinCosineDistance(m => m.ContentEmbedding, searchEmbedding, threshold: 0.3)\n    .OrderByCosineDistance(m => m.ContentEmbedding, searchEmbedding)\n    .ToListAsync();\n```\n\n**SQL Generated:**\n```sql\nSELECT * FROM documents\nWHERE content_embedding <=> @p0 < 0.3\nORDER BY content_embedding <=> @p0 ASC\n```\n\n### Pattern 5: Combined Filter + Sort + Project\n\nUse when you need distance/similarity scores in your results:\n\n:::updated\n**Important**: `WithCosineDistance` must be used as the **final projection** before `ToListAsync()`.\nYou cannot chain `.OrderBy(r => r.Distance)` or `.Where(r => r.Distance < x)` after it - use\n`OrderByCosineDistance` and `WithinCosineDistance` for SQL-side operations first.\n:::\n\n```csharp\nvar searchEmbedding = await embeddingService.EmbedAsync(userQuery);\n\n// Filter -> Sort -> Project with scores\nvar results = await documentLens.Query\n    .WithinCosineDistance(m => m.ContentEmbedding, searchEmbedding, threshold: 0.5)\n    .OrderByCosineDistance(m => m.ContentEmbedding, searchEmbedding)\n    .WithCosineDistance(m => m.ContentEmbedding, searchEmbedding)\n    .Take(10)\n    .ToListAsync();\n\nforeach (var result in results) {\n  Console.WriteLine($\"{result.Row.Data.Title}: {result.Similarity:P0} match\");\n  // Output: \"My Document: 95% match\"\n}\n```\n\nReturns `VectorSearchResult<TModel>` with:\n- `Row` - The perspective row\n- `Distance` - Cosine distance (0 = identical, 2 = opposite)\n- `Similarity` - Similarity score (1 = identical, -1 = opposite)\n\n## Query Extension Reference\n\n### Ordering Methods\n\n| Method | PostgreSQL Operator | Use Case |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/messaging/commands-events",
    "title": "Commands Events",
    "category": "messaging",
    "order": 999,
    "description": "",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/messaging/failure-handling",
    "title": "Failure Handling",
    "category": "messaging",
    "order": 999,
    "description": "# Failure Handling\n\n## Overview\n\nWhizbang implements sophisticated failure handling mechanisms including exponential backoff retry scheduling, stream-based failure cascades, and poison message detection. This document details how failures are tracked, scheduled for retry, and how they impact stream processing.\n\n## Core Concepts\n\n### Message Processing Status\n\nMessages track their processing state using bitwise flags in the `status` column:\n\n```csharp\n[Flags]\npublic enum MessageProcessingStatus {\n    Stored = 1,         // Bit 0: Message stored in database\n    EventStored = 2,    // Bit 1: Event persisted to event store\n    Published = 4,      // Bit 2: Message published to transport\n    Failed = 32768      // Bit 15: Processing failed\n}\n```\n\n**Key Properties**:\n- **Bitwise Flags**: Multiple states can coexist (e.g., `Stored | Failed = 32769`)\n- **Status Progression**: `Stored → EventStored → Published` (outbox)\n- **Failure Overlay**: `Failed` flag added via bitwise OR when message fails\n- **Partial Completion**: `CompletedStatus` tracks what was accomplished before failure\n\n### Failure Classification\n\n```csharp\npublic enum MessageFailureReason {\n    Unknown = 99,                    // Default (not classified)\n    TransportUnavailable = 1,        // Network/transport issues\n    HandlerException = 2,            // Handler threw exception\n    ValidationFailure = 3,           // Message validation failed\n    TimeoutExceeded = 4,             // Processing timeout\n    SerializationError = 5,          // Cannot deserialize message\n    DependencyFailure = 6,           // External dependency unavailable\n    PoisonMessage = 7                // Exceeded retry limit\n}\n```\n\n**Purpose**:\n- Enable typed filtering (e.g., \"retry only TransportUnavailable failures\")\n- Support different retry strategies per failure type\n- Metrics and monitoring (failure classification dashboards)\n\n### Retry Scheduling\n\n**Exponential Backoff Formula**:\n```\nscheduled_for = now + (base_interval * 2^attempts)\n\nBase interval: 30 seconds\nAttempts:\n- 0: First attempt (no backoff)\n- 1: 30s * 2^1 = 1 minute\n- 2: 30s * 2^2 = 2 minutes\n- 3: 30s * 2^3 = 4 minutes\n- 4: 30s * 2^4 = 8 minutes\n- 5: 30s * 2^5 = 16 minutes\n- ...\n```\n\n## Failure Processing Flow {#failure-flow}\n\n### Basic Failure and Retry\n\n```mermaid\nsequenceDiagram\n    participant I as Instance\n    participant DB as PostgreSQL\n    participant H as Handler/Transport\n\n    I->>DB: ProcessWorkBatchAsync()\n    DB-->>I: WorkBatch: [M1]\n\n    I->>H: Process M1\n    H-->>I: ❌ Exception: Network timeout\n\n    I->>DB: ProcessWorkBatchAsync(<br/>failures: [M1: error=\"Network timeout\"])\n    DB->>DB: UPDATE wh_outbox<br/>SET status = status | Failed (32768),<br/>error = \"Network timeout\",<br/>attempts = attempts + 1,<br/>scheduled_for = now + (30s * 2^attempts),<br/>instance_id = NULL,<br/>lease_expiry = NULL<br/>WHERE message_id = M1\n    Note over DB: M1: attempts=1<br/>scheduled_for = now + 1 min<br/>Status: Stored | Failed (32769)\n\n    Note over I: Wait 1 minute...\n\n    I->>DB: ProcessWorkBatchAsync()\n    DB->>DB: Find claimable messages:<br/>WHERE scheduled_for <= now\n    DB-->>I: WorkBatch: [M1] (retry)\n\n    I->>H: Process M1 (retry)\n    H-->>I: ✅ Success\n\n    I->>DB: ProcessWorkBatchAsync(<br/>completions: [M1: Published])\n    DB->>DB: UPDATE status = status | Published,<br/>DELETE (outbox done when published)\n    Note over DB: ✅ M1 processed successfully<br/>after retry\n```\n\n### Retry Schedule Timeline\n\n```\nTime →\n0s              60s             120s            180s            240s\n│               │               │               │               │\nM1 ━━━━━━━━━┃ Fail (attempts=0)\n           │\n           ├→ scheduled_for = now + 30s * 2^1 = now + 1 min\n           │\n           ├──── Cannot claim (scheduled_for > now)\n           │\n           │               Retry #1\n           │               ┃ Fail (attempts=1)\n           │               │\n           │               ├→ scheduled_for = now + 30s * 2^2 = now + 2 min\n           │               │\n           │               ├──── Cannot claim\n           │               │\n           │               │                               Retry #2\n           │               │                               ┃ Success\n           │               │                               │\n           │               │                               └→ Published\n```\n\n## Stream-Based Failure Cascades {#failure-cascade}\n\n### Problem: Blocking Entire Stream\n\nWhen message M1 in stream S fails, what happens to messages M2, M3, M4 that come after it?\n\n**Options**:\n1. **Block all**: M2, M3, M4 stuck until M1 succeeds (could wait forever)\n2. **Continue**: Process M2, M3, M4 anyway (violates stream ordering)\n3. **Cascade release**: Allow releasing M2, M3, M4 to unblock stream\n\n**Whizbang's Approach**: Cascade release with explicit control\n\n### Status=0 Release Pattern\n\n**Mechanism**: Completing a message with `Status = 0` clears its lease without changing status flags, allowing it to be reprocessed.\n\n```csharp\n// Release messages M2, M3 (let them be retried)\nawait coordinator.ProcessWorkBatchAsync(\n    // ...\n    outboxCompletions: [\n        new MessageCompletion { MessageId = message2Id, Status = 0 },  // Release\n        new MessageCompletion { MessageId = message3Id, Status = 0 }   // Release\n    ],\n    outboxFailures: [\n        new MessageFailure {\n            MessageId = message1Id,\n            CompletedStatus = MessageProcessingStatus.Stored,\n            Error = \"Processing failed\"\n        }\n    ]\n);\n```\n\n**Effect**:\n- M1: Marked as failed, scheduled for retry\n- M2, M3: Leases cleared (`instance_id = NULL`, `lease_expiry = NULL`)\n- M2, M3: Status unchanged (still `Stored`)\n- M2, M3: Can be reclaimed by any instance\n\n### Cascade Release Sequence Diagram\n\n```mermaid\nsequenceDiagram\n    participant I as Instance\n    participant DB as PostgreSQL\n\n    Note over DB: Stream S has messages M1, M2, M3<br/>(all claimed by Instance)\n\n    I->>I: Process M1 → ❌ Fails\n    I->>I: Cannot process M2, M3<br/>(depend on M1 success)\n\n    I->>DB: ProcessWorkBatchAsync(<br/>failures: [M1],<br/>completions: [M2: Status=0, M3: Status=0])\n\n    DB->>DB: UPDATE wh_outbox<br/>SET status = status | Failed,<br/>scheduled_for = now + 1 min,<br/>instance_id = NULL, lease_expiry = NULL<br/>WHERE message_id = M1\n\n    DB->>DB: UPDATE wh_outbox<br/>SET instance_id = NULL,<br/>lease_expiry = NULL<br/>WHERE message_id IN (M2, M3)<br/>-- Status unchanged (Status | 0 = Status)\n\n    Note over DB: M1: Failed, scheduled for retry<br/>M2, M3: Released, can be reclaimed\n\n    Note over I: Later (next ProcessWorkBatch call)\n\n    I->>DB: ProcessWorkBatchAsync()\n    DB->>DB: Find claimable messages:<br/>M1: scheduled_for > now (blocked)<br/>M2: No earlier messages with active lease ✅<br/>M3: M2 earlier, but no lease ✅\n    DB-->>I: WorkBatch: [M2, M3]\n\n    I->>I: Process M2, M3 successfully\n    I->>DB: ProcessWorkBatchAsync(<br/>completions: [M2: Published, M3: Published])\n    Note over DB: ✅ M2, M3 completed<br/>M1 still scheduled for retry\n```\n\n### Cascade Decision Matrix\n\n| M1 State | M2 Lease Cleared? | M2 Claimable? | Ordering Impact |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/messaging/idempotency-patterns",
    "title": "Idempotency Patterns",
    "category": "messaging",
    "order": 999,
    "description": "# Idempotency Patterns\n\n## Overview\n\nIdempotency ensures that processing the same message multiple times produces the same result as processing it once. Whizbang implements different idempotency strategies for inbox and outbox based on their roles in the system architecture.\n\n## Core Concepts\n\n### What is Idempotency?\n\n**Definition**: An operation is idempotent if performing it multiple times has the same effect as performing it once.\n\n**Why It Matters**:\n- Message brokers often provide at-least-once delivery (duplicates possible)\n- Network retries can cause duplicate message sends\n- Distributed systems need to handle duplicate messages gracefully\n\n**Example**:\n- ✅ Idempotent: `SET balance = 100` (same result whether executed 1x or 10x)\n- ❌ Not Idempotent: `SET balance = balance + 10` (different result each execution)\n\n### Inbox vs. Outbox Strategies\n\n| Aspect | Inbox | Outbox |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/messaging/inbox-pattern",
    "title": "Inbox Pattern",
    "category": "Messaging",
    "order": 2,
    "description": "Achieve exactly-once message processing with the Inbox Pattern - automatic deduplication and idempotent message handling",
    "tags": "inbox, exactly-once, deduplication, idempotency, message-processing",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/messaging/message-envelopes",
    "title": "Message Envelopes Deep Dive",
    "category": "Messaging",
    "order": 4,
    "description": "Deep dive into Message Envelopes - hop-based distributed tracing across Outbox, Inbox, and message transports",
    "tags": "message-envelopes, distributed-tracing, observability, cross-service, azure-service-bus",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/messaging/multi-instance-coordination",
    "title": "Multi Instance Coordination",
    "category": "messaging",
    "order": 999,
    "description": "# Multi-Instance Coordination\n\n## Overview\n\nMulti-instance coordination ensures reliable, ordered message processing across multiple service instances. This document details the coordination mechanisms, decision points, and timing guarantees that enable distributed message processing.\n\n## Core Coordination Mechanisms\n\n### 1. Cross-Instance Stream Ordering {#cross-instance-stream-ordering}\n\n**Rule**: When Instance A holds message M1 from stream S, Instance B cannot claim later messages (M2, M3, M4) from the same stream until Instance A completes or releases M1.\n\n**Why This Matters**: Prevents out-of-order processing when messages from the same stream are distributed across multiple instances via partition assignment.\n\n#### Sequence Diagram\n\n```mermaid\nsequenceDiagram\n    participant I1 as Instance 1\n    participant DB as PostgreSQL\n    participant I2 as Instance 2\n\n    Note over DB: Stream S has messages M1, M2, M3, M4<br/>(temporal order by created_at)\n\n    I1->>DB: ProcessWorkBatch()\n    DB->>DB: Calculate partition ownership<br/>(partition % 2)\n    DB->>DB: M1, M2 assigned to partition 0<br/>M3, M4 assigned to partition 5\n    DB->>DB: Instance 1 owns partition 0<br/>Instance 2 owns partition 5\n    DB-->>I1: Returns M1, M2\n    Note over I1: I1 now holds lease on M1, M2<br/>lease_expiry = now + 5 min\n\n    I2->>DB: ProcessWorkBatch()\n    DB->>DB: Check partition ownership\n    DB->>DB: Find M3, M4 in partition 5 (owned by I2)\n    DB->>DB: NOT EXISTS check:<br/>SELECT 1 FROM wh_outbox earlier<br/>WHERE earlier.stream_id = M3.stream_id<br/>AND earlier.created_at < M3.created_at<br/>AND earlier.instance_id IS NOT NULL<br/>AND earlier.lease_expiry > now\n    Note over DB: ❌ M3, M4 BLOCKED<br/>Earlier messages M1, M2 held by I1<br/>(active lease)\n    DB-->>I2: Returns [] (empty)\n\n    Note over I2: I2 cannot process M3, M4<br/>until I1 completes/releases M1, M2\n\n    I1->>DB: ProcessWorkBatch(<br/>completions: [M1: Published, M2: Published])\n    DB->>DB: Mark M1, M2 as Published\n    DB->>DB: Delete M1, M2 (done)\n\n    I2->>DB: ProcessWorkBatch()\n    DB->>DB: NOT EXISTS check passes<br/>(no earlier messages with active leases)\n    DB-->>I2: Returns M3, M4\n    Note over I2: ✅ Stream ordering preserved<br/>M1, M2 completed before M3, M4 claimed\n```\n\n**Decision Matrix**:\n\n| Earlier Message State | Later Messages Claimable? | Reason |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/messaging/outbox-pattern",
    "title": "Outbox Pattern",
    "category": "Messaging",
    "order": 1,
    "description": "Implement reliable cross-service event publishing with the Outbox Pattern - guaranteed delivery without distributed transactions",
    "tags": "outbox, reliable-messaging, transactional-outbox, event-publishing, distributed-systems",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/messaging/topic-filters",
    "title": "Topic Filters",
    "category": "messaging",
    "order": 999,
    "description": "",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/messaging/work-coordination",
    "title": "Work Coordination",
    "category": "messaging",
    "order": 999,
    "description": "",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/messaging/work-coordinator",
    "title": "Work Coordinator",
    "category": "Messaging",
    "order": 3,
    "description": "Master the Work Coordinator - atomic batch processing for Outbox, Inbox, and event store tracking with lease-based coordination",
    "tags": "work-coordinator, atomic-operations, batch-processing, distributed-coordination, lease-management",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/migration-guide/01-concept-mapping",
    "title": "Concept Mapping",
    "category": "Migration Guide",
    "order": 2,
    "description": "How Marten/Wolverine concepts translate to Whizbang equivalents",
    "tags": "migration, marten, wolverine, concepts, mapping",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/migration-guide/02-project-setup",
    "title": "Project Setup",
    "category": "Migration Guide",
    "order": 3,
    "description": "NuGet packages and initial configuration for migrating to Whizbang",
    "tags": "migration, nuget, packages, configuration, setup",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/migration-guide/03-handler-migration",
    "title": "Handler Migration",
    "category": "Migration Guide",
    "order": 4,
    "description": "Converting Wolverine handlers to Whizbang Receptors",
    "tags": "migration, handlers, receptors, wolverine, conversion",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/migration-guide/04-projection-migration",
    "title": "Projection Migration",
    "category": "Migration Guide",
    "order": 5,
    "description": "Converting Marten projections to Whizbang Perspectives",
    "tags": "migration, projections, perspectives, marten, read-models",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/migration-guide/05-event-store-migration",
    "title": "Event Store Migration",
    "category": "Migration Guide",
    "order": 6,
    "description": "Migrating from Marten's event store to Whizbang's IEventStore",
    "tags": "migration, event-store, marten, events, streams",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/migration-guide/06-transport-configuration",
    "title": "Transport Configuration",
    "category": "Migration Guide",
    "order": 7,
    "description": "Configuring RabbitMQ and Azure Service Bus transports for Whizbang",
    "tags": "migration, transport, rabbitmq, azure-service-bus, messaging",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/migration-guide/07-outbox-migration",
    "title": "Outbox Migration",
    "category": "Migration Guide",
    "order": 8,
    "description": "Migrating from Wolverine's durable outbox to Whizbang's built-in outbox pattern",
    "tags": "migration, outbox, inbox, durability, messaging",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/migration-guide/08-testing-migration",
    "title": "Testing Migration",
    "category": "Migration Guide",
    "order": 9,
    "description": "Updating test infrastructure when migrating to Whizbang",
    "tags": "migration, testing, tunit, mocks, integration-tests",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/migration-guide/README",
    "title": "Migration Guide Overview",
    "category": "Migration Guide",
    "order": 1,
    "description": "Overview of migrating from Marten/Wolverine and other frameworks to Whizbang",
    "tags": "migration, marten, wolverine, upgrade, conversion",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/migration-guide/appendix-checklist",
    "title": "Migration Checklist",
    "category": "Migration Guide",
    "order": 10,
    "description": "Complete checklist for migrating from Marten/Wolverine to Whizbang",
    "tags": "migration, checklist, verification, validation",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/perspectives/registry",
    "title": "Registry",
    "category": "perspectives",
    "order": 999,
    "description": "# Perspective Registry\n\nThe perspective registry is a system table that tracks the mapping between your C# perspective types and their corresponding database tables. It enables automatic schema management, drift detection, and safe table renaming across deployments.\n\n## Overview\n\nWhen Whizbang creates perspective tables, it registers metadata about each perspective in the `wh_perspective_registry` table. This enables:\n\n| Feature | Description |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/perspectives/table-naming",
    "title": "Table Naming",
    "category": "perspectives",
    "order": 999,
    "description": "# Perspective Table Naming\n\nWhizbang automatically generates database table names for your perspectives using configurable naming conventions. By default, common suffixes like `Projection`, `Model`, and `Dto` are stripped to create cleaner, shorter table names.\n\n## Default Behavior\n\nWhen you define a perspective, Whizbang converts the class name to snake_case and adds the `wh_per_` prefix:\n\n| C# Class Name | Default Table Name |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/perspectives/temporal",
    "title": "Temporal",
    "category": "perspectives",
    "order": 999,
    "description": "# Temporal Perspectives\n\nTemporal perspectives create append-only logs where each event creates a NEW row rather than updating existing rows. This pattern is ideal for activity feeds, audit logs, and full history tracking.\n\n## Overview\n\n| Pattern | Interface | Storage | Use Case |\n|",
    "tags": [],
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/source-generators/aggregate-ids",
    "title": "Aggregate IDs",
    "category": "Source Generators",
    "order": 4,
    "description": "Zero-reflection aggregate ID extraction for PolicyContext - compile-time discovery of [AggregateId] marked properties",
    "tags": "source-generators, aggregate-ids, policy-context, zero-reflection, compile-time, uuidv7",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/source-generators/json-contexts",
    "title": "JSON Contexts",
    "category": "Source Generators",
    "order": 5,
    "description": "AOT-compatible JSON serialization with compile-time JsonSerializerContext generation - zero reflection for Native AOT",
    "tags": "source-generators, json, serialization, aot, native-aot, system-text-json, zero-reflection",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/source-generators/message-registry",
    "title": "Message Registry",
    "category": "Source Generators",
    "order": 3,
    "description": "VSCode extension integration via compile-time message registry - navigate from messages to handlers with IDE tooling",
    "tags": "source-generators, vscode, tooling, message-registry, code-navigation, ide-integration",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/source-generators/perspective-discovery",
    "title": "Perspective Discovery",
    "category": "Source Generators",
    "order": 2,
    "description": "Compile-time perspective discovery for event-driven read models - zero reflection registration and Event Store integration",
    "tags": "source-generators, perspectives, read-models, events, roslyn, compile-time, zero-reflection",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/source-generators/polymorphic-serialization",
    "title": "Polymorphic Serialization",
    "category": "Source Generators",
    "order": 6,
    "description": "Automatic polymorphic JSON serialization without explicit [JsonPolymorphic] attributes - type discriminators generated at compile-time for base classes and interfaces",
    "tags": "source-generators, json, serialization, polymorphic, inheritance, aot, native-aot, type-discriminator",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/source-generators/receptor-discovery",
    "title": "Receptor Discovery",
    "category": "Source Generators",
    "order": 1,
    "description": "Compile-time receptor discovery with Roslyn source generators - zero reflection, AOT-compatible message routing",
    "tags": "source-generators, receptors, roslyn, compile-time, zero-reflection, aot",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/source-generators/topic-filter-discovery",
    "title": "Topic Filter Discovery",
    "category": "Source Generators",
    "order": 6,
    "description": "Compile-time topic filter discovery with Roslyn source generators - type-safe, zero-reflection message routing configuration",
    "tags": "source-generators, topic-filters, roslyn, compile-time, zero-reflection, aot, routing",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/testing/lifecycle-synchronization",
    "title": "Lifecycle Synchronization",
    "category": "Testing",
    "order": 3,
    "description": "Deterministic test synchronization using lifecycle receptors - eliminate race conditions in integration tests with PostPerspectiveInline stage",
    "tags": "testing, integration-tests, lifecycle, synchronization, race-conditions, PostPerspectiveInline",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/transports/azure-service-bus",
    "title": "Azure Service Bus Transport",
    "category": "Transports",
    "order": 1,
    "description": "Reliable cross-service messaging with Azure Service Bus topics and subscriptions - AOT-compatible with correlation filters",
    "tags": "transports, azure-service-bus, messaging, topics, subscriptions, correlation-filters, aspire, aot",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/transports/in-memory",
    "title": "In-Memory Transport",
    "category": "Transports",
    "order": 2,
    "description": "Synchronous in-process message delivery for testing and single-process scenarios - zero external dependencies",
    "tags": "transports, in-memory, testing, in-process, synchronous, pub-sub, request-response",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/transports/rabbitmq",
    "title": "RabbitMQ Transport",
    "category": "Transports",
    "order": 2,
    "description": "Distributed event-driven messaging with RabbitMQ topic exchanges - AOT-compatible with channel pooling and dead-letter queue support",
    "tags": "transports, rabbitmq, messaging, topic-exchange, dead-letter-queue, channel-pool, aot, testcontainers",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/tutorial/analytics-service",
    "title": "Analytics Service",
    "category": "Tutorial",
    "order": 8,
    "description": "Build the Analytics Worker - real-time analytics, time-series perspectives, and reporting dashboards",
    "tags": "tutorial, analytics-service, perspectives, time-series, reporting, dashboards",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/tutorial/customer-service",
    "title": "Customer Service (BFF)",
    "category": "Tutorial",
    "order": 7,
    "description": "Build the Customer Service BFF - perspectives, read models, CQRS query side, and GraphQL API",
    "tags": "tutorial, customer-service, bff, perspectives, cqrs, read-models",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/tutorial/deployment",
    "title": "Deployment",
    "category": "Tutorial",
    "order": 10,
    "description": "Deploy to production - Azure Kubernetes Service, CI/CD pipelines, monitoring, and scaling",
    "tags": "tutorial, deployment, kubernetes, azure, cicd, monitoring",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/tutorial/inventory-service",
    "title": "Inventory Service",
    "category": "Tutorial",
    "order": 3,
    "description": "Build the Inventory Worker - event subscription, stock reservations, compensation, and perspectives",
    "tags": "tutorial, inventory-service, event-driven, perspectives, compensation",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/tutorial/notification-service",
    "title": "Notification Service",
    "category": "Tutorial",
    "order": 5,
    "description": "Build the Notification Worker - email/SMS notifications, template rendering, and delivery tracking",
    "tags": "tutorial, notification-service, email, sms, event-driven",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/tutorial/order-management",
    "title": "Order Management Service",
    "category": "Tutorial",
    "order": 2,
    "description": "Build the Order Service - HTTP API, command handling, event publishing, and PostgreSQL persistence",
    "tags": "tutorial, order-service, commands, events, http-api",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/tutorial/payment-processing",
    "title": "Payment Processing Service",
    "category": "Tutorial",
    "order": 4,
    "description": "Build the Payment Worker - payment gateway integration, distributed transactions, and compensation",
    "tags": "tutorial, payment-service, distributed-transactions, saga-pattern, compensation",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/tutorial/shipping-service",
    "title": "Shipping Service",
    "category": "Tutorial",
    "order": 6,
    "description": "Build the Shipping Worker - carrier API integration, shipment creation, tracking, and status updates",
    "tags": "tutorial, shipping-service, carrier-api, tracking, event-driven",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/tutorial/testing-strategy",
    "title": "Testing Strategy",
    "category": "Tutorial",
    "order": 9,
    "description": "Comprehensive testing strategy - unit tests, integration tests, e2e tests, mocks, and fixtures",
    "tags": "tutorial, testing, unit-tests, integration-tests, e2e-tests, tunit",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/tutorial/tutorial-overview",
    "title": "ECommerce Tutorial Overview",
    "category": "Tutorial",
    "order": 1,
    "description": "Build a complete e-commerce system with Whizbang - microservices, event sourcing, CQRS, and distributed messaging",
    "tags": "tutorial, ecommerce, microservices, event-sourcing, cqrs, distributed-systems",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/workers/database-readiness",
    "title": "Database Readiness",
    "category": "Workers",
    "order": 3,
    "description": "Database dependency coordination - IDatabaseReadinessCheck pattern, startup coordination, retry logic, and caching strategies",
    "tags": "database-readiness, dependency-coordination, startup, retry-logic, health-checks",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/workers/execution-lifecycle",
    "title": "Execution Lifecycle",
    "category": "Workers",
    "order": 2,
    "description": "Application startup and shutdown coordination - IExecutionStrategy lifecycle hooks, graceful shutdown with work draining, and worker coordination",
    "tags": "execution-lifecycle, startup, shutdown, graceful-shutdown, work-draining, lifecycle-hooks",
    "version": "v1.0.0"
  },
  {
    "slug": "v1.0.0/workers/perspective-worker",
    "title": "Perspective Worker",
    "category": "Workers",
    "order": 1,
    "description": "Background worker for processing perspective checkpoints - automatic checkpoint creation, polling workflow, error tracking, and startup coordination",
    "tags": "perspective-worker, checkpoints, background-worker, lease-based-coordination, error-tracking",
    "version": "v1.0.0"
  }
]