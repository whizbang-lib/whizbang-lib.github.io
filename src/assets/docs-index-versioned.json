[
  {
    "version": "v0.1.0",
    "metadata": {
      "title": "Version 0.1.0 - Foundation",
      "description": "The foundation release establishing all core components with in-memory implementations",
      "releaseDate": "TBD",
      "status": "planning"
    },
    "docs": [
      {
        "slug": "v0.1.0/README",
        "title": "Version 0.1.0 - Foundation Release",
        "category": "Implementation",
        "order": 1,
        "description": "The foundation release of Whizbang establishing all core components with comprehensive testing and IDE support",
        "tags": "v0.1.0, foundation, implementation",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/components/README",
        "title": "Core Components Overview",
        "category": "Components",
        "order": 1,
        "description": "Overview of all core components in Whizbang v0.1.0",
        "tags": "components, architecture, overview",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/components/dispatcher",
        "title": "Dispatcher Component",
        "category": "Components",
        "order": 2,
        "description": "Core message routing and orchestration with basic handler discovery",
        "tags": "dispatcher, routing, orchestration, mediator, v0.1.0",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/components/drivers",
        "title": "Drivers Component",
        "category": "Components",
        "order": 8,
        "description": "Basic in-memory storage driver for development and testing",
        "tags": "drivers, storage, in-memory, abstraction, v0.1.0",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/components/ledger",
        "title": "Ledger Component",
        "category": "Components",
        "order": 7,
        "description": "In-memory event store with basic append and read operations",
        "tags": "ledger, event-store, events, in-memory, v0.1.0",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/components/lenses",
        "title": "Lenses Component",
        "category": "Components",
        "order": 5,
        "description": "Read-only interfaces for querying data - the query side of Whizbang's CQRS implementation",
        "tags": "lenses, queries, read-model, cqrs, v0.1.0",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/components/perspectives",
        "title": "Perspectives Component",
        "category": "Components",
        "order": 4,
        "description": "Event handlers that update various views of your data - the write side of Whizbang",
        "tags": "perspectives, events, views, write-model, v0.1.0",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/components/policy-engine",
        "title": "Policy Engine Component",
        "category": "Components",
        "order": 6,
        "description": "Cross-cutting concerns as composable policies - retry, timeout, cache, and circuit breaker",
        "tags": "policies, cross-cutting, resilience, caching, v0.1.0",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/components/receptors",
        "title": "Receptors Component",
        "category": "Components",
        "order": 3,
        "description": "Command receivers that make decisions and emit events - the foundation of Whizbang's event-driven architecture",
        "tags": "receptors, commands, events, stateless, v0.1.0",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/components/transports",
        "title": "Transports Component",
        "category": "Components",
        "order": 9,
        "description": "Basic in-process message transport for local development",
        "tags": "transports, messaging, in-process, communication, v0.1.0",
        "version": "v0.1.0"
      }
    ]
  },
  {
    "version": "v0.2.0",
    "metadata": {
      "title": "Version 0.2.0 - Event-Driven Enhancement",
      "description": "Enhanced event-driven capabilities with validation, rich events, and policy improvements",
      "releaseDate": "TBD",
      "status": "planning"
    },
    "docs": [
      {
        "slug": "v0.2.0/enhancements/dispatcher",
        "title": "Pipeline & Middleware Dispatcher",
        "category": "Enhancements",
        "order": 5,
        "description": "Message pipeline with middleware, parallel execution, and handler prioritization",
        "tags": "dispatcher, pipeline, middleware, parallel, prioritization, v0.2.0",
        "version": "v0.2.0"
      },
      {
        "slug": "v0.2.0/enhancements/drivers",
        "title": "File Storage Drivers",
        "category": "Enhancements",
        "order": 3,
        "description": "Persistent file-based storage with JSON serialization and basic indexing",
        "tags": "drivers, file-storage, persistence, json, indexing, v0.2.0",
        "version": "v0.2.0"
      },
      {
        "slug": "v0.2.0/enhancements/ledger",
        "title": "Ledger Persistence",
        "category": "Enhancements",
        "order": 2,
        "description": "File-based persistence, event streams, versioning, and snapshots",
        "tags": "ledger, persistence, streams, snapshots, v0.2.0",
        "version": "v0.2.0"
      },
      {
        "slug": "v0.2.0/enhancements/policies",
        "title": "Policy Enhancements",
        "category": "Enhancements",
        "order": 1,
        "description": "Policy composition, bulkhead isolation, and rate limiting",
        "tags": "policies, composition, rate-limiting, bulkhead, v0.2.0",
        "version": "v0.2.0"
      },
      {
        "slug": "v0.2.0/enhancements/transports",
        "title": "HTTP & WebSocket Transports",
        "category": "Enhancements",
        "order": 4,
        "description": "REST APIs with HTTP transport and real-time communication via WebSockets",
        "tags": "transports, http, websocket, rest, real-time, serialization, v0.2.0",
        "version": "v0.2.0"
      }
    ]
  },
  {
    "version": "v0.3.0",
    "metadata": {
      "title": "Version 0.3.0 - Event Sourcing",
      "description": "Add stateful capabilities with event sourcing, aggregates, and projections",
      "releaseDate": "TBD",
      "status": "planning"
    },
    "docs": [
      {
        "slug": "v0.3.0/features/dispatcher",
        "title": "Saga Orchestration & Workflows",
        "category": "Features",
        "order": 6,
        "description": "Multi-step workflow orchestration with sagas, compensation, and process management",
        "tags": "dispatcher, saga, orchestration, workflow, compensation, state-machine, v0.3.0",
        "version": "v0.3.0"
      },
      {
        "slug": "v0.3.0/features/ledger",
        "title": "Event Sourcing & Projections",
        "category": "Features",
        "order": 4,
        "description": "Full event sourcing with aggregates, projections, and time-travel queries",
        "tags": "ledger, event-sourcing, projections, aggregates, time-travel, v0.3.0",
        "version": "v0.3.0"
      },
      {
        "slug": "v0.3.0/features/policies",
        "title": "Stateful Policy Management",
        "category": "Features",
        "order": 3,
        "description": "Persistent policy state, metrics, and dynamic configuration",
        "tags": "policies, state-management, metrics, monitoring, v0.3.0",
        "version": "v0.3.0"
      },
      {
        "slug": "v0.3.0/features/transports",
        "title": "Message Queue Transports",
        "category": "Features",
        "order": 5,
        "description": "Enterprise messaging with RabbitMQ, Kafka, and Redis pub/sub",
        "tags": "transports, messaging, rabbitmq, kafka, redis, pubsub, queues, v0.3.0",
        "version": "v0.3.0"
      }
    ]
  },
  {
    "version": "v0.4.0",
    "metadata": {
      "title": "Version 0.4.0 - Real Persistence",
      "description": "Production-ready database persistence with PostgreSQL, SQL Server, and SQLite drivers",
      "releaseDate": "TBD",
      "status": "planning"
    },
    "docs": [
      {
        "slug": "v0.4.0/database/drivers",
        "title": "Database Drivers",
        "category": "Database",
        "order": 2,
        "description": "Production database drivers for SQL and NoSQL with JSONB support",
        "tags": "drivers, database, sql, nosql, postgresql, mongodb, redis, jsonb, v0.4.0",
        "version": "v0.4.0"
      }
    ]
  },
  {
    "version": "v0.5.0",
    "metadata": {
      "title": "Version 0.5.0 - Distributed Systems",
      "description": "Enable distributed messaging with Kafka, RabbitMQ, and saga orchestration",
      "releaseDate": "TBD",
      "status": "planning"
    },
    "docs": [
      {
        "slug": "v0.5.0/production/dispatcher",
        "title": "Distributed Orchestration",
        "category": "Production",
        "order": 7,
        "description": "Multi-region distributed saga orchestration with consensus and global coordination",
        "tags": "dispatcher, distributed, orchestration, consensus, raft, global, production, v0.5.0",
        "version": "v0.5.0"
      },
      {
        "slug": "v0.5.0/production/drivers",
        "title": "Distributed Multi-Model Drivers",
        "category": "Production",
        "order": 5,
        "description": "Cloud-native distributed drivers with multi-model support and automatic sharding",
        "tags": "drivers, distributed, multi-model, sharding, cloud-native, dynamodb, cosmosdb, production, v0.5.0",
        "version": "v0.5.0"
      },
      {
        "slug": "v0.5.0/production/ledger",
        "title": "Distributed Event Store",
        "category": "Production",
        "order": 4,
        "description": "Multi-region event store with replication, partitioning, and event streaming",
        "tags": "ledger, distributed, replication, partitioning, event-streaming, production, v0.5.0",
        "version": "v0.5.0"
      },
      {
        "slug": "v0.5.0/production/policies",
        "title": "Production Policy System",
        "category": "Production",
        "order": 3,
        "description": "Distributed policy coordination, federation, and ML-based optimization",
        "tags": "policies, distributed, federation, machine-learning, production, v0.5.0",
        "version": "v0.5.0"
      },
      {
        "slug": "v0.5.0/production/transports",
        "title": "Cloud-Native Transports",
        "category": "Production",
        "order": 6,
        "description": "Multi-cloud messaging with AWS SQS/SNS, Azure Service Bus, Google Pub/Sub, and global federation",
        "tags": "transports, cloud, aws, azure, gcp, federation, multi-cloud, production, v0.5.0",
        "version": "v0.5.0"
      }
    ]
  },
  {
    "state": "drafts",
    "metadata": {
      "folderType": "state",
      "state": "drafts",
      "description": "Documentation currently being written and developed"
    },
    "docs": [
      {
        "slug": "drafts/test-error-display",
        "title": "Test Error Display",
        "category": "Test",
        "order": 999,
        "description": "",
        "tags": [],
        "version": "drafts"
      }
    ]
  },
  {
    "state": "proposals",
    "metadata": {
      "folderType": "state",
      "state": "proposals",
      "description": "Proposed features and documentation under consideration"
    },
    "docs": [
      {
        "slug": "proposals/advanced-features",
        "title": "Advanced Features",
        "category": "Architecture & Design",
        "order": 10,
        "description": "\n# Advanced Features\n\nWhizbang includes advanced features for enterprise scenarios, including cross-aggregate transactions, performance monitoring, Kubernetes operators, and debugging tools.\n\n## Cross-Aggregate Transactions\n\n### Unit of Work Pattern\n\n**Coordinate transactions across multiple aggregates** while maintaining consistency:\n\n```csharp{title=\"Unit of Work Configuration\" description=\"Unit of work pattern configuration for cross-aggregate transactions\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Advanced-Features\", \"Unit-of-Work\", \"Cross-Aggregate-Transactions\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.UseUnitOfWork(uow => {\n        uow.IsolationLevel = IsolationLevel.ReadCommitted;\n        uow.Timeout = TimeSpan.FromSeconds(30);\n        uow.EnableDistributedTransactions = true;\n    });\n});\n\n```csharp{title=\"Multi-Aggregate Command Handler\" description=\"Command handler using unit of work for coordinated multi-aggregate operations\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Advanced-Features\", \"Unit-of-Work\", \"Command-Handlers\"] framework=\"NET8\"}\n// Usage in handlers\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder> {\n    private readonly IUnitOfWork _unitOfWork;\n    private readonly IRepository<Order> _orderRepository;\n    private readonly IRepository<Customer> _customerRepository;\n    private readonly IRepository<Product> _productRepository;\n    \n    public async Task<OrderPlaced> Handle(PlaceOrder command) {\n        return await _unitOfWork.ExecuteAsync(async () => {\n            // Load multiple aggregates\n            var customer = await _customerRepository.Load(command.CustomerId);\n            var products = await _productRepository.LoadMany(command.ProductIds);\n            \n            // Validate business rules across aggregates\n            if (!customer.CanPlaceOrder(command.Total)) {\n                throw new DomainException(\"Customer credit limit exceeded\");\n            }\n            \n            foreach (var product in products) {\n                if (!product.IsAvailable(command.GetQuantity(product.Id))) {\n                    throw new DomainException($\"Product {product.Id} not available\");\n                }\n            }\n            \n            // Create new aggregate\n            var order = new Order(command.CustomerId, command.Items);\n            \n            // Update existing aggregates\n            customer.ReserveCreditLimit(command.Total);\n            foreach (var product in products) {\n                product.ReserveStock(command.GetQuantity(product.Id));\n            }\n            \n            // Save all changes in single transaction\n            await _orderRepository.Save(order);\n            await _customerRepository.Save(customer);\n            await _productRepository.SaveMany(products);\n            \n            return new OrderPlaced(order.Id, command.CustomerId, DateTimeOffset.UtcNow);\n        });\n    }\n}\n```\n\n### Distributed Transactions with Saga Fallback\n\n```csharp{title=\"Distributed Transactions with Saga Fallback\" description=\"Distributed transactions with saga fallback for complex operations\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Advanced-Features\", \"Cross-Aggregate-Transactions\", \"Saga-Fallback\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.CrossAggregateTransactions(transactions => {\n        transactions.DefaultStrategy = TransactionStrategy.UnitOfWork;\n        transactions.FallbackToSaga = true;\n        transactions.SagaTimeoutMs = 30000;\n        \n        // Configure per-operation\n        transactions.ForOperation<PlaceOrder>(op => {\n            op.Strategy = TransactionStrategy.UnitOfWork;\n            op.MaxAggregatesInTransaction = 5;\n        });\n        \n        transactions.ForOperation<ComplexOrderWorkflow>(op => {\n            op.Strategy = TransactionStrategy.Saga; // Force saga for complex operations\n        });\n    });\n});\n```\n\n### Transaction Boundaries\n\n```csharp{title=\"Transaction Boundary Implementation\" description=\"Transaction boundary implementation with automatic rollback on failure\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Advanced-Features\", \"Transaction-Boundaries\", \"Error-Handling\"] framework=\"NET8\"}\npublic class TransactionBoundary : ITransactionBoundary {\n    public async Task<T> ExecuteInTransaction<T>(Func<Task<T>> operation) {\n        using var scope = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled);\n        \n        try {\n            var result = await operation();\n            scope.Complete();\n            return result;\n        } catch (Exception ex) {\n            // Transaction automatically rolled back\n            _logger.LogError(ex, \"Transaction failed and was rolled back\");\n            throw;\n        }\n    }\n}\n```\n\n## Performance Budgets & Monitoring\n\n> **üìã Detailed Coverage**: For comprehensive performance budgets, observability, and monitoring details, see [**Observability & Metrics**](./observability-metrics.md)\n\n### Performance Budget Overview\n\n**Performance budgets** provide automatic tracking and alerting for handler performance:\n\n```csharp{title=\"Performance Budget Attributes\" description=\"Performance budget attributes for automatic tracking and alerting\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Advanced-Features\", \"Performance-Budgets\", \"Monitoring\"] framework=\"NET8\"}\n[PerformanceBudget(MaxLatencyMs = 100)]\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder> {\n    // Automatic budget tracking and violation alerts\n}\n```\n\n## OpenTelemetry Integration\n\n> **üìã Detailed Coverage**: For complete OpenTelemetry setup, metrics, and distributed tracing, see [**Observability & Metrics**](./observability-metrics.md)\n\n```csharp{title=\"OpenTelemetry Integration Configuration\" description=\"OpenTelemetry integration configuration for comprehensive observability\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Advanced-Features\", \"OpenTelemetry\", \"Observability\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.Observability(observability => {\n        observability.UseOpenTelemetry(otel => {\n            otel.TraceAllCommands = true;\n            otel.TraceAllEvents = true;\n            otel.TraceProjections = true;\n            otel.TraceSagas = true;\n            \n            // Custom metrics\n            otel.EmitCustomMetrics = true;\n            otel.MetricsPrefix = \"whizbang\";\n            \n            // Performance budget violations\n            otel.TracePerformanceBudgetViolations = true;\n            otel.AlertOnBudgetViolation = true;\n        });\n    });\n});\n\n```csharp{title=\"Custom Performance Tracking Handler\" description=\"Custom performance tracking handler with detailed metrics collection\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Advanced-Features\", \"Performance-Tracking\", \"Custom-Metrics\"] framework=\"NET8\"}\n// Custom performance tracking\npublic class PerformanceTrackingHandler<T> : ICommandHandler<T> where T : ICommand {\n    private readonly ICommandHandler<T> _innerHandler;\n    private readonly IMetrics _metrics;\n    \n    public async Task Handle(T command) {\n        using var activity = Activity.StartActivity($\"Command.{typeof(T).Name}\");\n        using var timer = _metrics.StartTimer($\"command.{typeof(T).Name.ToLower()}.duration\");\n        \n        var startMemory = GC.GetTotalMemory(false);\n        var stopwatch = Stopwatch.StartNew();\n        \n        try {\n            await _innerHandler.Handle(command);\n            \n            // Record success metrics\n            _metrics.IncrementCounter($\"command.{typeof(T).Name.ToLower()}.success\");\n        } catch (Exception ex) {\n            // Record failure metrics\n            _metrics.IncrementCounter($\"command.{typeof(T).Name.ToLower()}.failure\", \n                new[] { (\"error_type\", ex.GetType().Name) });\n            \n            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);\n            throw;\n        } finally {\n            stopwatch.Stop();\n            var endMemory = GC.GetTotalMemory(false);\n            \n            // Record performance metrics\n            activity?.SetTag(\"duration_ms\", stopwatch.ElapsedMilliseconds);\n            activity?.SetTag(\"memory_allocated_bytes\", endMemory - startMemory);\n            \n            _metrics.RecordValue($\"command.{typeof(T).Name.ToLower()}.memory\", endMemory - startMemory);\n        }\n    }\n}\n```\n\n## Kubernetes Operator Features\n\n> **üìã Detailed Coverage**: For production deployment patterns, health checks, and operational best practices, see [**Deployment & Operations**](./deployment-operations.md)\n\n### Auto-Scaling Projection Workers\n\n```yaml\n",
        "tags": "unit-of-work, performance-budgets, kubernetes-operator, tracing, debugging",
        "version": "proposals"
      },
      {
        "slug": "proposals/concurrency-control",
        "title": "Concurrency Control",
        "category": "Architecture & Design",
        "order": 5,
        "description": "\n# Concurrency Control\n\nWhizbang provides flexible concurrency control mechanisms to handle concurrent updates to aggregates, supporting multiple strategies that developers can choose globally or per-operation.\n\n## Concurrency Strategies\n\n### A. Expected Version (Default)\n\n**Standard event sourcing pattern** - explicitly specify the expected version:\n\n```csharp{title=\"Expected Version Concurrency Control\" description=\"Standard event sourcing pattern with explicit version checking\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"expected-version\", \"optimistic-locking\", \"event-sourcing\"] framework=\"NET8\"}\n// Load aggregate at version 5\nvar order = await repository.Load<Order>(orderId);\n\n// Make changes\norder.AddItem(new OrderItem(\"Product\", 10.00m));\n\n// Save with expected version - will fail if current version != 5\nawait repository.Save(order, expectedVersion: 5);\n```\n\n**Benefits**:\n- ‚úÖ Detects all conflicts\n- ‚úÖ Standard event sourcing pattern\n- ‚úÖ Explicit and predictable\n\n**Drawbacks**:\n- ‚ùå Requires version tracking\n- ‚ùå Manual conflict resolution\n\n### B. Timestamp-Based (Last-Modified)\n\n**HTTP-style semantics** using timestamps:\n\n```csharp{title=\"Timestamp-Based Concurrency Control\" description=\"HTTP-style semantics using last-modified timestamps\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"timestamp-based\", \"http-semantics\", \"last-modified\"] framework=\"NET8\"}\nvar order = await repository.Load<Order>(orderId);\nvar lastModified = order.LastModified;\n\n// Make changes\norder.AddItem(new OrderItem(\"Product\", 10.00m));\n\n// Save with timestamp check\nawait repository.Save(order, ifNotModifiedSince: lastModified);\n```\n\n**Benefits**:\n- ‚úÖ Familiar HTTP semantics\n- ‚úÖ No version number tracking\n\n**Drawbacks**:\n- ‚ùå Clock skew potential\n- ‚ùå Less precise than versions\n\n### C. Automatic Retry with Conflict Resolution\n\n**Smart retry with configurable resolution strategies**:\n\n```csharp{title=\"Automatic Retry with Conflict Resolution\" description=\"Smart retry with configurable resolution strategies via policies\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"concurrency\", \"automatic-retry\", \"conflict-resolution\", \"policy-engine\"] framework=\"NET8\"}\n// Configure automatic retry via policies\nservices.AddWhizbang(options => {\n    options.Policies(policies => {\n        // Default strategy for all operations\n        policies.When(ctx => true)\n                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.AutomaticRetry))\n                .And(config => config.SetRetryAttempts(3))\n                .And(config => config.SetRetryDelay(TimeSpan.FromMilliseconds(100)));\n        \n        // Custom conflict resolution for Order aggregates\n        policies.When(ctx => ctx.MatchesAggregate<Order>())\n                .Then(config => config.SetConflictResolver((current, attempted) => {\n                    // Custom merge logic\n                    var merged = current.Copy();\n                    merged.MergeChanges(attempted);\n                    return merged;\n                }));\n    });\n});\n\n// Save with automatic retry\nawait repository.Save(order); // Retries automatically on conflict\n```\n\n**Benefits**:\n- ‚úÖ Handles most conflicts automatically\n- ‚úÖ Better developer experience\n- ‚úÖ Configurable retry policies\n\n**Drawbacks**:\n- ‚ùå Complex to implement\n- ‚ùå Not all conflicts can be auto-resolved\n\n## Marten-Inspired Extensions\n\nDrawing from Marten's concurrency features, Whizbang also supports:\n\n### D. Token-Based Concurrency\n\n**Using opaque tokens** instead of version numbers:\n\n```csharp{title=\"Token-Based Concurrency Control\" description=\"Using opaque tokens instead of version numbers\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"token-based\", \"opaque-tokens\", \"marten-inspired\"] framework=\"NET8\"}\nvar (order, token) = await repository.LoadWithToken<Order>(orderId);\n\n// Make changes\norder.AddItem(new OrderItem(\"Product\", 10.00m));\n\n// Save with token\nawait repository.Save(order, concurrencyToken: token);\n```\n\n### E. Revision-Based Tracking\n\n**Marten-style revision tracking** with metadata:\n\n```csharp{title=\"Revision-Based Tracking\" description=\"Marten-style revision tracking with automatic metadata\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"revision-based\", \"marten-style\", \"metadata\"] framework=\"NET8\"}\npublic class Order : Aggregate {\n    // Whizbang tracks revision automatically\n    public int Revision { get; internal set; }\n    public DateTime LastModified { get; internal set; }\n    public string LastModifiedBy { get; internal set; }\n}\n\nawait repository.Save(order, expectedRevision: order.Revision);\n```\n\n### F. Conditional Updates\n\n**SQL-style conditional updates**:\n\n```csharp{title=\"Conditional Updates\" description=\"SQL-style conditional updates with business logic conditions\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"conditional-updates\", \"sql-style\", \"business-logic\"] framework=\"NET8\"}\nawait repository.Save(order, condition: o => o.Status == OrderStatus.Pending);\n// Only saves if order is still pending\n```\n\n## Policy-Driven Configuration\n\n> **üìã Universal Configuration**: Whizbang uses the [**Policy Engine**](./policy-engine.md) as the universal configuration scoping mechanism. All concurrency strategies, retry policies, and conflict resolution rules are configured through policies rather than direct configuration methods.\n\n### Basic Policy Configuration\n\n**Configure concurrency strategies using the Policy Engine** - the universal configuration scoping mechanism:\n\n```csharp{title=\"Basic Policy Configuration\" description=\"Global concurrency strategy configuration using policy engine\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"policy-configuration\", \"global-strategy\", \"policy-engine\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.Policies(policies => {\n        // Global default strategy\n        policies.When(ctx => true)\n                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.ExpectedVersion))\n                .And(config => config.SetRetryAttempts(3))\n                .And(config => config.SetRetryDelay(TimeSpan.FromMilliseconds(100)));\n    });\n});\n```\n\n### Advanced Policy Scenarios\n\n**Combine multiple conditions for sophisticated concurrency control**:\n\n```csharp{title=\"Advanced Policy Scenarios\" description=\"Sophisticated concurrency control with context-dependent strategies\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"concurrency\", \"advanced-policies\", \"context-dependent\", \"tenant-specific\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.Policies(policies => {\n        // Orders get automatic retry with more attempts\n        policies.When(ctx => ctx.MatchesAggregate<Order>())\n                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.AutomaticRetry))\n                .And(config => config.SetRetryAttempts(5)); // Orders get more retries\n        \n        // Shopping carts use timestamp-based for simplicity\n        policies.When(ctx => ctx.MatchesAggregate<ShoppingCart>())\n                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.TimestampBased));\n        \n        // High-volume commands get automatic retry\n        policies.When(ctx => ctx.HasTag(\"high-volume\"))\n                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.AutomaticRetry))\n                .And(config => config.SetRetryAttempts(5));\n        \n        // Load testing uses relaxed concurrency\n        policies.When(ctx => ctx.HasFlag(WhizbangFlags.LoadTesting))\n                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.LastWriteWins));\n        \n        // Environment-based strategies\n        policies.When(ctx => ctx.Environment == \"production\")\n                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.ExpectedVersion))\n                .And(config => config.SetRetryAttempts(3));\n        \n        policies.When(ctx => ctx.Environment == \"development\")\n                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.LastWriteWins)); // Relaxed for dev\n        \n        // Tenant-specific strategies\n        policies.When(ctx => ctx.TenantId != null && ctx.HasTag(\"enterprise-tenant\"))\n                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.ExpectedVersion))\n         .And(config => config.SetRetryAttempts(5))\n         .And(config => config.EnableStrictConflictResolution());\n    });\n});\n```\n\n### Runtime Policy Evaluation\n\n**Policies are evaluated at runtime** based on the current context:\n\n```csharp{title=\"Runtime Policy Evaluation\" description=\"Context-driven policy evaluation with automatic strategy selection\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"runtime-evaluation\", \"context-driven\", \"automatic-selection\"] framework=\"NET8\"}\n// Policy evaluation happens automatically during save operations\nawait repository.Save(order, context => {\n    context.WithTag(\"high-volume\");        // Triggers high-volume policy\n    context.WithFlag(WhizbangFlags.Production); // Triggers production policy\n});\n\n// Context determines which concurrency strategy is used\n// No need to manually specify strategy - policies handle it\n```\n\n### Manual Override (When Needed)\n\n**Override policies for exceptional cases**:\n\n```csharp{title=\"Manual Override\" description=\"Explicit override of policy-driven concurrency for critical operations\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"manual-override\", \"policy-bypass\", \"critical-operations\"] framework=\"NET8\"}\n// Explicit override for critical operations\nawait repository.Save(order, saveOptions => {\n    saveOptions.OverrideConcurrencyStrategy(ConcurrencyStrategy.ExpectedVersion);\n    saveOptions.SetExpectedVersion(5);\n    saveOptions.BypassPolicies(); // Skip policy evaluation\n});\n```\n\n## Conflict Resolution Strategies\n\n### Built-in Resolvers\n\n```csharp{title=\"Built-in Conflict Resolvers\" description=\"Common conflict resolution strategies for different scenarios\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"built-in-resolvers\", \"conflict-strategies\", \"merge-strategies\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.Policies(policies => {\n        // Last-write-wins for Order aggregates\n        policies.When(ctx => ctx.MatchesAggregate<Order>())\n                .Then(config => config.SetConflictResolver(ConflictResolvers.LastWriteWins));\n        \n        // First-write-wins for Customer aggregates (reject conflicting changes)\n        policies.When(ctx => ctx.MatchesAggregate<Customer>())\n                .Then(config => config.SetConflictResolver(ConflictResolvers.FirstWriteWins));\n        \n        // Additive merge for ShoppingCart (combine collections)\n        policies.When(ctx => ctx.MatchesAggregate<ShoppingCart>())\n                .Then(config => config.SetConflictResolver(ConflictResolvers.AdditiveMerge));\n    });\n});\n```\n\n### Custom Conflict Resolvers via Policies\n\n**Define custom conflict resolution logic through policies**:\n\n```csharp{title=\"Custom Conflict Resolvers\" description=\"Domain-specific merge logic for different aggregate properties\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"concurrency\", \"custom-resolvers\", \"business-logic-merge\", \"domain-specific\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.Policies(policies => {\n        // Custom resolver for Order aggregates\n        policies.When(ctx => ctx.MatchesAggregate<Order>())\n                .Then(config => config.SetConflictResolver((current, attempted) => {\n                    var resolved = current.Copy();\n                    \n                    // Merge line items additively\n                    foreach (var item in attempted.Items) {\n                        if (!resolved.Items.Any(i => i.ProductId == item.ProductId)) {\n                            resolved.AddItem(item);\n                        }\n                    }\n                    \n                    // Take latest shipping address\n                    if (attempted.ShippingAddress != null) {\n                        resolved.UpdateShippingAddress(attempted.ShippingAddress);\n                    }\n                    \n                    return resolved;\n                }));\n    });\n});\n```\n\n### Advanced Conflict Resolution\n\n**Access full conflict context through policies**:\n\n```csharp{title=\"Advanced Conflict Resolution\" description=\"Three-way merge using original version as merge base\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"concurrency\", \"three-way-merge\", \"advanced-resolution\", \"merge-base\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.Policies(policies => {\n        policies.When(ctx => ctx.MatchesAggregate<Order>())\n                .Then(config => config.SetConflictResolver((context) => {\n                    var current = context.CurrentVersion;\n                    var attempted = context.AttemptedVersion;\n                    var original = context.OriginalVersion; // Version when load started\n                    \n                    // Three-way merge using original as base\n                    return ThreeWayMerge(original, current, attempted);\n                }));\n    });\n});\n});\n```\n\n## Implementation Details\n\n### Concurrency Exception Handling\n\n```csharp{title=\"Concurrency Exception Handling\" description=\"Detailed conflict information for debugging and error handling\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"exception-handling\", \"conflict-information\", \"debugging\"] framework=\"NET8\"}\npublic class ConcurrencyException : Exception {\n    public string StreamId { get; }\n    public int ExpectedVersion { get; }\n    public int ActualVersion { get; }\n    public Type AggregateType { get; }\n    \n    public ConcurrencyException(string streamId, int expectedVersion, int actualVersion, Type aggregateType)\n        : base($\"Concurrency conflict in {aggregateType.Name} stream {streamId}. Expected version {expectedVersion}, but current version is {actualVersion}\") {\n        StreamId = streamId;\n        ExpectedVersion = expectedVersion;\n        ActualVersion = actualVersion;\n        AggregateType = aggregateType;\n    }\n}\n```\n\n### Retry Logic\n\n```csharp{title=\"Retry Logic Configuration\" description=\"Exponential backoff and jitter for reducing contention\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"retry-logic\", \"exponential-backoff\", \"jitter\"] framework=\"NET8\"}\npublic class RetryPolicy {\n    public int MaxAttempts { get; set; } = 3;\n    public TimeSpan InitialDelay { get; set; } = TimeSpan.FromMilliseconds(100);\n    public TimeSpan MaxDelay { get; set; } = TimeSpan.FromSeconds(1);\n    public double BackoffMultiplier { get; set; } = 2.0;\n    public RetryJitter Jitter { get; set; } = RetryJitter.Random;\n}\n\n// Example retry sequence:\n// Attempt 1: 100ms + random(0-50ms)\n// Attempt 2: 200ms + random(0-100ms)  \n// Attempt 3: 400ms + random(0-200ms)\n```\n\n### Driver Interface\n\n```csharp{title=\"Driver Interface\" description=\"Interface for implementing concurrency control strategies\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"concurrency\", \"driver-interface\", \"implementation\", \"strategies\"] framework=\"NET8\"}\npublic interface IConcurrencyDriver {\n    Task<T> Load<T>(string streamId, ConcurrencyOptions options) where T : Aggregate;\n    Task<(T Aggregate, ConcurrencyToken Token)> LoadWithToken<T>(string streamId) where T : Aggregate;\n    \n    Task Save<T>(T aggregate, ConcurrencyCheck check) where T : Aggregate;\n    Task<SaveResult> TrySave<T>(T aggregate, ConcurrencyCheck check) where T : Aggregate;\n    \n    Task<ConflictResolutionResult> ResolveConflict<T>(\n        T original, \n        T current, \n        T attempted, \n        ConflictResolver<T> resolver) where T : Aggregate;\n}\n\npublic class ConcurrencyCheck {\n    public ConcurrencyStrategy Strategy { get; set; }\n    public int? ExpectedVersion { get; set; }\n    public DateTime? IfNotModifiedSince { get; set; }\n    public ConcurrencyToken? Token { get; set; }\n    public Expression<Func<object, bool>>? Condition { get; set; }\n}\n```\n\n## Performance Considerations\n\n### Optimizations\n\n1. **Version caching** - Cache current versions to reduce round trips\n2. **Batch operations** - Group saves to reduce conflicts\n3. **Read replicas** - Load from read replicas to reduce load on primary\n4. **Conflict prediction** - Use heuristics to predict likely conflicts\n\n### Monitoring\n\n```csharp{title=\"Concurrency Monitoring\" description=\"Conflict logging and metrics for observability\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"monitoring\", \"metrics\", \"observability\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.UseOptimisticConcurrency(concurrency => {\n        concurrency.OnConflict = (context) => {\n            // Log conflict for monitoring\n            logger.LogWarning(\"Concurrency conflict in {StreamId}: {Conflict}\", \n                context.StreamId, context.ConflictDescription);\n            \n            // Emit metrics\n            metrics.IncrementCounter(\"whizbang.concurrency.conflicts\", \n                new[] { (\"aggregate_type\", context.AggregateType.Name) });\n        };\n        \n        concurrency.OnRetry = (context) => {\n            logger.LogDebug(\"Retrying save for {StreamId}, attempt {Attempt}\", \n                context.StreamId, context.AttemptNumber);\n        };\n    });\n});\n```\n\n## Best Practices\n\n### Strategy Selection Guidelines\n\n1. **Expected Version** - Use for critical business operations requiring strict consistency\n2. **Timestamp-Based** - Use for user-facing operations where UX matters more than strict consistency\n3. **Automatic Retry** - Use for high-contention scenarios with predictable merge strategies\n4. **Token-Based** - Use when integrating with external systems that provide tokens\n5. **Conditional** - Use for operations that depend on specific business conditions\n\n### Conflict Resolution Guidelines\n\n1. **Keep resolvers fast** - Avoid heavy computation or I/O\n2. **Test thoroughly** - Ensure resolvers handle edge cases\n3. **Make resolvers deterministic** - Same inputs should produce same outputs\n4. **Log conflicts** - Track conflict patterns for optimization\n5. **Fallback to exceptions** - Don't resolve conflicts you can't handle safely\n\n",
        "tags": "concurrency, optimistic-locking, versioning, marten",
        "version": "proposals"
      },
      {
        "slug": "proposals/deployment-operations",
        "title": "Deployment & Operations",
        "category": "Architecture & Design",
        "order": 15,
        "description": "\n# Deployment & Operations\n\nWhizbang is designed as an embedded library that runs within developer services, providing comprehensive operational hooks for production deployment, monitoring, and lifecycle management.\n\n## Deployment Model\n\n### Embedded Library Architecture\n\n**Whizbang runs embedded** within your application, not as a separate service:\n\n```csharp{title=\"Embedded Library Setup\" description=\"Basic embedded library setup within ASP.NET Core application\" category=\"Design\" difficulty=\"BEGINNER\" tags=[\"Design\", \"Deployment\", \"Embedded-Library\", \"ASP.NET-Core\"] framework=\"NET8\"}\n// Your service with Whizbang embedded\npublic class Program {\n    public static void Main(string[] args) {\n        var builder = WebApplication.CreateBuilder(args);\n        \n        // Add your application services\n        builder.Services.AddControllers();\n        builder.Services.AddOrderService();\n        \n        // Add Whizbang as embedded library\n        builder.Services.AddWhizbang(options => {\n            options.UsePostgresEventStore(connectionString);\n            options.UseKafkaMessageBroker(kafkaConfig);\n            options.ConfigureDomains();\n        });\n        \n        var app = builder.Build();\n        \n        // Configure your application pipeline\n        app.MapControllers();\n        app.MapWhizbangEndpoints(); // Optional: Expose Whizbang endpoints\n        \n        app.Run();\n    }\n}\n```\n\n### Service Architecture Patterns\n\n**Multiple deployment patterns** supported:\n\n#### 1. Monolithic Deployment\n\n```yaml\n",
        "tags": "deployment, operations, kubernetes, health-checks, graceful-shutdown",
        "version": "proposals"
      },
      {
        "slug": "proposals/domain-ownership",
        "title": "Domain Ownership",
        "category": "Architecture & Design",
        "order": 6,
        "description": "\n# Domain Ownership\n\nWhizbang enforces explicit domain ownership to prevent distributed system chaos. Every command and event has a clear owner, enabling proper routing, authorization, and system boundaries.\n\n## Ownership Determination Order\n\nDomain ownership is determined in **user-configurable order**, with this **default precedence**:\n\n1. **Namespace Convention** (highest priority)\n2. **Attributes** \n3. **Configuration-Driven** (lowest priority)\n\nEach level can override previous levels, giving developers full control.\n\n## 1. Namespace Convention (Default First)\n\n**Automatic ownership** derived from namespace structure:\n\n```csharp{title=\"Namespace-Based Domain Ownership\" description=\"Automatic domain ownership derived from namespace structure\" category=\"Design\" difficulty=\"BEGINNER\" tags=[\"domain-ownership\", \"namespace-convention\", \"commands\", \"events\"] framework=\"NET8\"}\n// Orders domain\nnamespace MyApp.Orders.Commands {\n    public record PlaceOrder(Guid OrderId, Guid CustomerId, List<OrderItem> Items);\n    // Domain: \"Orders\" (extracted from namespace)\n}\n\nnamespace MyApp.Orders.Events {\n    public record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt);\n    // Domain: \"Orders\"\n}\n\n// Inventory domain  \nnamespace MyApp.Inventory.Commands {\n    public record ReserveStock(Guid ProductId, int Quantity);\n    // Domain: \"Inventory\"\n}\n```\n\n### Namespace Policy Configuration\n\n```csharp{title=\"Namespace Policy Configuration\" description=\"Configuring namespace extraction policies for domain ownership\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"configuration\", \"namespace-policy\", \"setup\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.DomainOwnership(ownership => {\n        // Configure namespace extraction policies\n        ownership.NamespacePolicy(policy => {\n            // Default: Extract domain from namespace segment\n            policy.ExtractDomainFromNamespace = true;\n            policy.DomainNamespacePosition = 1; // MyApp.[Domain].Commands\n            \n            // Custom extraction function\n            policy.DomainExtractor = (type) => {\n                var segments = type.Namespace.Split('.');\n                if (segments.Length >= 3 && segments[1] == \"Domains\") {\n                    return segments[2]; // MyApp.Domains.[Domain].Commands\n                }\n                return segments.Length >= 2 ? segments[1] : \"Default\";\n            };\n            \n            // Namespace patterns\n            policy.CommandNamespacePattern = \"*.Commands\";\n            policy.EventNamespacePattern = \"*.Events\";\n            policy.QueryNamespacePattern = \"*.Queries\";\n        });\n    });\n});\n```\n\n## 2. Attribute-Based Ownership\n\n**Explicit declaration** using attributes:\n\n```csharp{title=\"Attribute-Based Domain Ownership\" description=\"Explicit domain ownership declaration using attributes\" category=\"Design\" difficulty=\"BEGINNER\" tags=[\"domain-ownership\", \"attributes\", \"explicit-declaration\", \"override\"] framework=\"NET8\"}\n[OwnedBy(\"Orders\")]\npublic record PlaceOrder(Guid OrderId, Guid CustomerId, List<OrderItem> Items);\n\n[OwnedBy(\"Orders\")]\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt);\n\n// Override namespace convention\nnamespace MyApp.Shared.Commands {\n    [OwnedBy(\"Inventory\")] // Overrides \"Shared\" from namespace\n    public record ReserveStock(Guid ProductId, int Quantity);\n}\n```\n\n### Attribute Policies\n\n```csharp{title=\"Attribute Policy Configuration\" description=\"Configuring attribute-based ownership policies\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"attribute-policy\", \"configuration\", \"custom-attributes\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.DomainOwnership(ownership => {\n        ownership.AttributePolicy(policy => {\n            // Require explicit ownership for certain patterns\n            policy.RequireExplicitOwnership<ICommand>();\n            policy.RequireExplicitOwnership(type => type.Name.EndsWith(\"Command\"));\n            \n            // Default ownership for unattributed types\n            policy.DefaultDomain = \"Shared\";\n            \n            // Custom attribute types\n            policy.RecognizeAttribute<DomainAttribute>();\n            policy.RecognizeAttribute<BoundedContextAttribute>();\n        });\n    });\n});\n```\n\n## 3. Configuration-Driven Ownership\n\n**Centralized registration** in Program.cs:\n\n```csharp{title=\"Configuration-Driven Ownership\" description=\"Centralized domain registration with explicit ownership\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"configuration\", \"domain-registration\", \"centralized-config\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.DomainOwnership(ownership => {\n        // Register domains with explicit ownership\n        ownership.RegisterDomain(\"Orders\", domain => {\n            domain.OwnsCommand<PlaceOrder>();\n            domain.OwnsCommand<UpdateOrder>();\n            domain.OwnsEvent<OrderPlaced>();\n            domain.OwnsEvent<OrderUpdated>();\n            \n            // Override other declarations\n            domain.OwnsCommand<SpecialSharedCommand>(); // Takes from \"Shared\"\n        });\n        \n        ownership.RegisterDomain(\"Inventory\", domain => {\n            domain.OwnsCommand<ReserveStock>();\n            domain.OwnsCommand<ReleaseStock>();\n            domain.OwnsEvent<StockReserved>();\n            domain.OwnsEvent<StockReleased>();\n        });\n    });\n});\n```\n\n## Interface and Inheritance Policies\n\n### Interface-Based Ownership\n\n```csharp{title=\"Interface-Based Ownership\" description=\"Interface-based domain ownership with marker interfaces\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"interface-based\", \"marker-interfaces\", \"configuration\"] framework=\"NET8\"}\n// Domain marker interfaces\npublic interface IOrderCommand : ICommand { }\npublic interface IInventoryCommand : ICommand { }\n\npublic record PlaceOrder(...) : IOrderCommand;\npublic record ReserveStock(...) : IInventoryCommand;\n\n// Configure interface-based ownership\nservices.AddWhizbang(options => {\n    options.DomainOwnership(ownership => {\n        ownership.InterfacePolicy(policy => {\n            policy.RegisterInterface<IOrderCommand>(\"Orders\");\n            policy.RegisterInterface<IInventoryCommand>(\"Inventory\");\n            policy.RegisterInterface<ISharedCommand>(\"Shared\");\n        });\n    });\n});\n```\n\n### Inheritance-Based Ownership\n\n```csharp{title=\"Inheritance-Based Ownership\" description=\"Inheritance-based domain ownership with base command classes\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"inheritance-based\", \"base-classes\", \"configuration\"] framework=\"NET8\"}\n// Base classes for domains\npublic abstract class OrderCommand : ICommand {\n    // Common order command properties\n}\n\npublic abstract class InventoryCommand : ICommand {\n    // Common inventory command properties  \n}\n\npublic class PlaceOrder : OrderCommand {\n    // Inherits \"Orders\" domain\n}\n\n// Configure inheritance-based ownership\nservices.AddWhizbang(options => {\n    options.DomainOwnership(ownership => {\n        ownership.InheritancePolicy(policy => {\n            policy.RegisterBaseClass<OrderCommand>(\"Orders\");\n            policy.RegisterBaseClass<InventoryCommand>(\"Inventory\");\n        });\n    });\n});\n```\n\n## Custom Ownership Precedence\n\n**Developer controls the order** of ownership determination:\n\n```csharp{title=\"Custom Ownership Precedence\" description=\"Custom ownership precedence order configuration\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"domain-ownership\", \"precedence-order\", \"configuration\", \"custom-rules\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.DomainOwnership(ownership => {\n        // Custom precedence order\n        ownership.PrecedenceOrder(\n            DomainOwnershipSource.Attributes,        // Check attributes first\n            DomainOwnershipSource.Configuration,     // Then explicit config\n            DomainOwnershipSource.Interfaces,        // Then interfaces\n            DomainOwnershipSource.Inheritance,       // Then inheritance\n            DomainOwnershipSource.Namespace          // Finally namespace\n        );\n        \n        // Or use fluent API\n        ownership.CheckAttributesFirst()\n                 .ThenConfiguration()\n                 .ThenInterfaces()\n                 .ThenInheritance()\n                 .FinallyNamespace();\n    });\n});\n```\n\n## Complex Policy Examples\n\n### Multi-Level Namespace Extraction\n\n```csharp{title=\"Multi-Level Namespace Extraction\" description=\"Multi-level namespace extraction with complex custom logic\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"domain-ownership\", \"namespace-extraction\", \"multi-level\", \"custom-logic\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.DomainOwnership(ownership => {\n        ownership.NamespacePolicy(policy => {\n            policy.DomainExtractor = (type) => {\n                var ns = type.Namespace;\n                \n                // MyApp.Domains.Orders.Commands -> \"Orders\"\n                if (ns.Contains(\".Domains.\")) {\n                    var segments = ns.Split('.');\n                    var domainIndex = Array.IndexOf(segments, \"Domains\") + 1;\n                    return domainIndex < segments.Length ? segments[domainIndex] : \"Unknown\";\n                }\n                \n                // MyApp.Orders.V2.Commands -> \"Orders\"\n                var parts = ns.Split('.');\n                if (parts.Length >= 2) {\n                    return parts[1]; // Second segment is domain\n                }\n                \n                return \"Default\";\n            };\n        });\n    });\n});\n```\n\n### Conditional Ownership Rules\n\n```csharp{title=\"Conditional Ownership Rules\" description=\"Conditional ownership rules based on type patterns and assemblies\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"domain-ownership\", \"conditional-rules\", \"assembly-based\", \"integration-events\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.DomainOwnership(ownership => {\n        ownership.ConditionalRules(rules => {\n            // Integration events are always \"Shared\"\n            rules.When(type => type.Name.EndsWith(\"IntegrationEvent\"))\n                 .AssignToDomain(\"Shared\");\n            \n            // Commands from external assemblies go to \"External\"\n            rules.When(type => !type.Assembly.GetName().Name.StartsWith(\"MyApp\"))\n                 .AssignToDomain(\"External\");\n                 \n            // Saga commands inherit from the saga's domain\n            rules.When(type => typeof(ISagaCommand).IsAssignableFrom(type))\n                 .ExtractDomainFromProperty(\"SagaDomain\");\n        });\n    });\n});\n```\n\n### Assembly-Based Policies\n\n```csharp{title=\"Assembly-Based Policies\" description=\"Assembly-based domain ownership with naming conventions\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"assembly-based\", \"assembly-mapping\", \"naming-convention\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.DomainOwnership(ownership => {\n        ownership.AssemblyPolicy(policy => {\n            // Each assembly represents a domain\n            policy.MapAssemblyToDomain(\"MyApp.Orders\", \"Orders\");\n            policy.MapAssemblyToDomain(\"MyApp.Inventory\", \"Inventory\");\n            policy.MapAssemblyToDomain(\"MyApp.Shipping\", \"Shipping\");\n            \n            // Assembly naming convention\n            policy.ExtractDomainFromAssemblyName = true;\n            policy.AssemblyNamePattern = \"MyApp.{Domain}\";\n        });\n    });\n});\n```\n\n## Runtime Ownership Resolution\n\n### Ownership Discovery API\n\n```csharp{title=\"Domain Ownership Resolver API\" description=\"Domain ownership resolver API for runtime discovery\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"runtime-resolution\", \"api\", \"interface\"] framework=\"NET8\"}\npublic interface IDomainOwnershipResolver {\n    string ResolveDomain<T>();\n    string ResolveDomain(Type type);\n    bool IsDomainOwner<T>(string domain);\n    IEnumerable<string> GetAllDomains();\n    IEnumerable<Type> GetDomainTypes(string domain);\n}\n\n// Usage\n```csharp{title=\"Using Domain Ownership Resolver\" description=\"Example of using domain ownership resolver in a controller\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"controllers\", \"usage-example\", \"resolver\"] framework=\"NET8\"}\npublic class OrderController : ControllerBase {\n    private readonly IDomainOwnershipResolver _ownership;\n    \n    public OrderController(IDomainOwnershipResolver ownership) {\n        _ownership = ownership;\n    }\n    \n    public async Task<IActionResult> PlaceOrder(PlaceOrderRequest request) {\n        var domain = _ownership.ResolveDomain<PlaceOrder>();\n        // domain = \"Orders\"\n        \n        var command = new PlaceOrder(request.OrderId, request.CustomerId, request.Items);\n        await _mediator.Send(command);\n        \n        return Ok();\n    }\n}\n```\n\n### Compile-Time Validation\n\n**Roslyn analyzer** enforces ownership rules:\n\n```csharp{title=\"Compile-Time Validation\" description=\"Compile-time validation of domain ownership rules with Roslyn analyzers\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"domain-ownership\", \"compile-time-validation\", \"roslyn-analyzers\", \"source-generators\"] framework=\"NET8\"}\n// This will generate a compile error\n[OwnedBy(\"Orders\")]\npublic record PlaceOrder(...);\n\n// In different assembly/project\npublic class InventoryHandler : ICommandHandler<PlaceOrder> {\n    // ERROR: InventoryHandler cannot handle PlaceOrder - different domains\n    public async Task Handle(PlaceOrder command) { ... }\n}\n```\n\n### Source Generator Support\n\n```csharp{title=\"Auto-Generated Domain Registry\" description=\"Auto-generated domain ownership registry for runtime lookups\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"domain-ownership\", \"source-generation\", \"code-generation\", \"registry\"] framework=\"NET8\"}\n// Generated at compile time\n[GeneratedCode(\"Whizbang.SourceGenerator\")]\npublic static class DomainOwnershipRegistry {\n    public static readonly Dictionary<Type, string> TypeToDomain = new() {\n        { typeof(PlaceOrder), \"Orders\" },\n        { typeof(OrderPlaced), \"Orders\" },\n        { typeof(ReserveStock), \"Inventory\" },\n        { typeof(StockReserved), \"Inventory\" }\n    };\n    \n    public static readonly Dictionary<string, HashSet<Type>> DomainToTypes = new() {\n        { \"Orders\", new HashSet<Type> { typeof(PlaceOrder), typeof(OrderPlaced) } },\n        { \"Inventory\", new HashSet<Type> { typeof(ReserveStock), typeof(StockReserved) } }\n    };\n}\n```\n\n## Command Routing Based on Ownership\n\n### In-Process Routing\n\n```csharp{title=\"In-Process Command Routing\" description=\"Local command routing within the same domain service\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"routing\", \"in-process-communication\", \"local-handling\"] framework=\"NET8\"}\n// Same domain - route locally\nvar command = new PlaceOrder(...);\nvar domain = _ownership.ResolveDomain<PlaceOrder>(); // \"Orders\"\nvar handler = _serviceProvider.GetRequiredService<ICommandHandler<PlaceOrder>>();\nawait handler.Handle(command);\n```\n\n### Cross-Service Routing\n\n```csharp{title=\"Cross-Service Command Routing\" description=\"Cross-service command routing based on domain ownership\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"routing\", \"cross-service-communication\", \"message-broker\"] framework=\"NET8\"}\n// Different domain - route via message broker\nvar command = new ReserveStock(...);\nvar domain = _ownership.ResolveDomain<ReserveStock>(); // \"Inventory\"\n\nif (domain != _currentDomain) {\n    // Send to remote service\n    await _messageBroker.SendToService(domain, command);\n} else {\n    // Handle locally\n    await _localMediator.Send(command);\n}\n```\n\n## Best Practices\n\n### Ownership Guidelines\n\n1. **Be explicit** - Prefer attributes over conventions for critical commands\n2. **Consistent patterns** - Use the same ownership style within a domain\n3. **Document policies** - Make namespace and interface conventions clear\n4. **Validate early** - Use analyzers to catch ownership violations\n5. **Monitor boundaries** - Track cross-domain communication patterns\n\n### Policy Design\n\n1. **Start simple** - Begin with namespace conventions\n2. **Add specificity** - Use attributes for exceptions\n3. **Centralize overrides** - Use configuration for edge cases\n4. **Test policies** - Ensure ownership resolution works as expected\n5. **Version carefully** - Changing ownership affects routing\n\n",
        "tags": "domain-ownership, commands, events, namespace-policies, attributes",
        "version": "proposals"
      },
      {
        "slug": "proposals/event-store-projections",
        "title": "Event Store & Projection Architecture",
        "category": "Architecture & Design",
        "order": 4,
        "description": "\n# Event Store & Projection Architecture\n\nWhizbang implements a hybrid event store and projection architecture that separates event persistence from projection storage, enabling flexible schema evolution and high-performance querying.\n\n## Core Architecture\n\n### Hybrid Storage Design\n\n**Events Table** (Immutable Event Stream):\n```sql\n",
        "tags": "event-store, projections, architecture, jsonb, snapshots",
        "version": "proposals"
      },
      {
        "slug": "proposals/flags-tags-system",
        "title": "Flags & Tags System",
        "category": "Architecture & Design",
        "order": 11,
        "description": "\n# Flags & Tags System\n\nWhizbang provides a sophisticated flags and tags system for message context, enabling dynamic behavior modification, cross-service debugging, and flexible routing throughout the entire message lifecycle.\n\n## Core Concepts\n\n### Flags (Library-Defined)\n\n**Hardcoded enum flags** provided by Whizbang for common scenarios:\n\n```csharp{title=\"WhizbangFlags Enum Definition\" description=\"Library-defined flags enum for common development and operational scenarios\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Message-Context\", \"Cross-Service-Communication\"] framework=\"NET8\"}\n[Flags]\npublic enum WhizbangFlags : long {\n    None = 0,\n    \n    // Testing & Development\n    LoadTesting = 1 << 0,           // Don't replay these events\n    DryRun = 1 << 1,                // Execute handlers but don't persist\n    Development = 1 << 2,           // Development mode behaviors\n    TraceReplay = 1 << 3,           // Replay/trace mode\n    \n    // Debugging & Inspection\n    VerboseLogging = 1 << 4,        // Increase logging verbosity\n    VerboseOtel = 1 << 5,           // Increase OpenTelemetry verbosity\n    IgnoreTimeouts = 1 << 6,        // Bypass timeouts for debugging\n    CursorMode = 1 << 7,            // IDE cursor/scrubbing mode\n    Breakpoint = 1 << 8,            // Trigger breakpoints\n    \n    // Security & Compliance\n    SecurityBypass = 1 << 9,        // Bypass security checks (dangerous)\n    DataScrubbing = 1 << 10,        // Scrub sensitive data\n    ComplianceMode = 1 << 11,       // Extra compliance logging\n    \n    // Routing & Delivery\n    AlternativeRouting = 1 << 12,   // Use alternative handlers\n    PriorityDelivery = 1 << 13,     // Expedite processing\n    DelayedProcessing = 1 << 14,    // Defer processing\n    \n    // Environment & Lifecycle\n    Production = 1 << 15,           // Production environment\n    Staging = 1 << 16,              // Staging environment\n    QA = 1 << 17,                   // QA environment\n    Migration = 1 << 18,            // Data migration context\n    \n    // Custom ranges for user-defined flags\n    UserDefined1 = 1 << 32,\n    UserDefined2 = 1 << 33,\n    // ... up to 1 << 63\n}\n```\n\n### Tags (User-Defined)\n\n**Arbitrary string tags** added by developers for custom scenarios:\n\n```csharp{title=\"MessageContext with Fluent API\" description=\"Message context class with fluent API for flags and tags management\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Message-Context\", \"Fluent-API\"] framework=\"NET8\"}\npublic class MessageContext {\n    public WhizbangFlags Flags { get; set; }\n    public HashSet<string> Tags { get; set; } = new();\n    public string? CorrelationId { get; set; }\n    public string? TenantId { get; set; }\n    public string? Domain { get; set; }\n    \n    // Fluent API for context building\n    public MessageContext WithTag(string tag) {\n        Tags.Add(tag);\n        return this;\n    }\n    \n    public MessageContext WithFlags(WhizbangFlags flags) {\n        Flags |= flags;\n        return this;\n    }\n    \n    public MessageContext WithCorrelationId(string correlationId) {\n        CorrelationId = correlationId;\n        return this;\n    }\n    \n    public bool HasFlag(WhizbangFlags flag) => (Flags & flag) == flag;\n    public bool HasTag(string tag) => Tags.Contains(tag);\n    public bool HasAnyTag(params string[] tags) => tags.Any(Tags.Contains);\n    public bool HasAllTags(params string[] tags) => tags.All(Tags.Contains);\n}\n\n// Usage examples\ncontext.WithTag(\"customer-priority\")\n       .WithTag(\"region-us-west\")\n       .WithTag(\"high-value-order\")\n       .WithFlags(WhizbangFlags.VerboseLogging | WhizbangFlags.PriorityDelivery)\n       .WithCorrelationId(\"debug-session-123\");\n```\n\n## Cross-Service Propagation\n\n### Automatic Flag Propagation\n\n**Flags carry through entire message journey** across service boundaries:\n\n```csharp{title=\"Cross-Service Flag Propagation\" description=\"Automatic flag and tag propagation across service boundaries\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Cross-Service-Propagation\", \"Debugging\"] framework=\"NET8\"}\n// Service 1: Initial command with debugging flags\nvar command = new PlaceOrder(orderId, customerId, items);\nawait _mediator.Send(command, context => {\n    context.WithFlags(WhizbangFlags.VerboseLogging | WhizbangFlags.TraceReplay)\n           .WithTag(\"debug-session-123\")\n           .WithTag(\"customer-vip\");\n});\n\n// Flags automatically propagate to:\n// 1. Command handler execution in Service 1\n// 2. Event publishing from Service 1\n// 3. Cross-service event delivery via message broker\n// 4. Event handler execution in Service 2\n// 5. Projection updates in Service 2\n// 6. Saga execution across services\n\n```csharp{title=\"Context-Aware Event Handler\" description=\"Event handler using propagated flags and tags for conditional processing\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Event-Handlers\", \"Context-Aware-Processing\"] framework=\"NET8\"}\n// Service 2: Receives event with same flags and tags\npublic class InventoryHandler : IEventHandler<OrderPlaced> {\n    public async Task Handle(OrderPlaced @event, EventContext context) {\n        // context.Flags contains VerboseLogging | TraceReplay\n        // context.Tags contains \"debug-session-123\", \"customer-vip\"\n        \n        if (context.HasFlag(WhizbangFlags.VerboseLogging)) {\n            _logger.LogInformation(\"Processing order with verbose logging enabled for debug session {DebugSession}\", \n                context.Tags.FirstOrDefault(t => t.StartsWith(\"debug-session\")));\n        }\n        \n        if (context.HasTag(\"customer-vip\")) {\n            // Special handling for VIP customers\n            await _vipCustomerService.NotifyOrderReceived(@event.OrderId);\n        }\n    }\n}\n```\n\n### Message Context Serialization\n\n**Context travels with messages** across all transport mechanisms:\n\n```csharp{title=\"Message Envelope for Cross-Service Communication\" description=\"Message envelope with context serialization for cross-service communication\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Message-Serialization\", \"Cross-Service\"] framework=\"NET8\"}\n// Message envelope for cross-service communication\npublic class MessageEnvelope<T> {\n    public T Message { get; set; }\n    public MessageContext Context { get; set; }\n    public Dictionary<string, string> Headers { get; set; } = new();\n    public DateTimeOffset Timestamp { get; set; } = DateTimeOffset.UtcNow;\n}\n\n```csharp{title=\"Kafka Message Publisher\" description=\"Kafka message publisher with automatic context serialization\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Kafka\", \"Message-Brokers\"] framework=\"NET8\"}\n// Automatic context serialization in message brokers\npublic class KafkaMessagePublisher : IMessagePublisher {\n    public async Task PublishAsync<T>(T message, MessageContext context) {\n        var envelope = new MessageEnvelope<T> {\n            Message = message,\n            Context = context,\n            Headers = new Dictionary<string, string> {\n                [\"whizbang-flags\"] = ((long)context.Flags).ToString(),\n                [\"whizbang-tags\"] = string.Join(\",\", context.Tags),\n                [\"whizbang-correlation-id\"] = context.CorrelationId ?? \"\",\n                [\"whizbang-tenant-id\"] = context.TenantId ?? \"\",\n                [\"whizbang-domain\"] = context.Domain ?? \"\"\n            }\n        };\n        \n        await _kafkaProducer.ProduceAsync(GetTopicName<T>(), envelope);\n    }\n}\n```\n\n## Debugging and Development Features\n\n### IDE Cursor/Scrubbing Mode\n\n**Interactive debugging** with state inspection:\n\n```csharp{title=\"IDE Cursor Mode Handler\" description=\"IDE integration for interactive debugging with state inspection\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Flags-Tags\", \"IDE-Integration\", \"Debugging\", \"Cursor-Mode\"] framework=\"NET8\"}\n// IDE integration for step-by-step debugging\npublic class CursorModeHandler : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        \n        if (context.HasFlag(WhizbangFlags.CursorMode)) {\n            // Capture pre-execution state\n            var preState = await _stateCapture.CaptureStateAsync(context);\n            \n            // Notify IDE of execution point\n            await _ideNotificationService.NotifyExecutionPoint(new ExecutionPoint {\n                MessageType = typeof(TRequest).Name,\n                HandlerType = context.HandlerType?.Name,\n                CorrelationId = context.CorrelationId,\n                State = preState,\n                CanStepForward = true,\n                CanStepBackward = true\n            });\n            \n            // Wait for IDE to signal continue\n            await _ideNotificationService.WaitForContinueSignal(context.CorrelationId);\n        }\n        \n        var response = await next(message, context);\n        \n        if (context.HasFlag(WhizbangFlags.CursorMode)) {\n            // Capture post-execution state\n            var postState = await _stateCapture.CaptureStateAsync(context);\n            \n            await _ideNotificationService.NotifyExecutionComplete(new ExecutionResult {\n                CorrelationId = context.CorrelationId,\n                Response = response,\n                PostState = postState,\n                ExecutionTime = context.ExecutionTime\n            });\n        }\n        \n        return response;\n    }\n}\n```\n\n### Breakpoint System\n\n**Programmatic breakpoints** triggered by flags:\n\n```csharp{title=\"Programmatic Breakpoint Handler\" description=\"Programmatic breakpoint system triggered by flags for debugging\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Flags-Tags\", \"Debugging\", \"Breakpoints\", \"Development-Tools\"] framework=\"NET8\"}\npublic class BreakpointHandler : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        \n        if (context.HasFlag(WhizbangFlags.Breakpoint)) {\n            var breakpointContext = new BreakpointContext {\n                BreakpointId = Guid.NewGuid(),\n                MessageType = typeof(TRequest).Name,\n                Message = message,\n                Context = context,\n                StackTrace = Environment.StackTrace,\n                Timestamp = DateTimeOffset.UtcNow\n            };\n            \n            // Store breakpoint information\n            await _breakpointStore.StoreBreakpointAsync(breakpointContext);\n            \n            // Notify debugging tools\n            await _debuggerNotificationService.NotifyBreakpointHit(breakpointContext);\n            \n            // Optionally pause execution for attached debuggers\n            if (_debuggerService.IsAttached) {\n                System.Diagnostics.Debugger.Break();\n            }\n        }\n        \n        return await next(message, context);\n    }\n}\n```\n\n## Data Scrubbing and Security\n\n### Automatic Data Scrubbing\n\n**Policy-driven data sanitization** based on flags:\n\n```csharp{title=\"Data Scrubbing Interceptor\" description=\"Policy-driven data sanitization based on flags for security compliance\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Flags-Tags\", \"Data-Scrubbing\", \"Security\", \"Privacy\"] framework=\"NET8\"}\npublic class DataScrubbingInterceptor : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        \n        TRequest processedMessage = message;\n        \n        if (context.HasFlag(WhizbangFlags.DataScrubbing)) {\n            // Apply data scrubbing rules\n            processedMessage = await _dataScrubber.ScrubAsync(message, new ScrubOptions {\n                ScrubPersonalData = true,\n                ScrubFinancialData = true,\n                ScrubSensitiveFields = true,\n                PreserveFunctionality = true,\n                AddScrubbedMarkers = true\n            });\n            \n            // Add scrubbing metadata to context\n            context.Tags.Add(\"data-scrubbed\");\n            context.Tags.Add($\"scrubbed-at-{DateTimeOffset.UtcNow:yyyy-MM-dd-HH-mm-ss}\");\n        }\n        \n        return await next(processedMessage, context);\n    }\n}\n\n```csharp{title=\"Order Data Scrubber Implementation\" description=\"Concrete data scrubber implementation for order data sanitization\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Data-Scrubbing\", \"Implementation\"] framework=\"NET8\"}\n// Data scrubbing rules\npublic class OrderDataScrubber : IDataScrubber<PlaceOrder> {\n    public async Task<PlaceOrder> ScrubAsync(PlaceOrder order, ScrubOptions options) {\n        return order with {\n            // Scrub customer email\n            CustomerEmail = options.ScrubPersonalData ? ScrubEmail(order.CustomerEmail) : order.CustomerEmail,\n            \n            // Scrub payment information\n            PaymentToken = options.ScrubFinancialData ? \"[SCRUBBED-PAYMENT-TOKEN]\" : order.PaymentToken,\n            \n            // Preserve order structure but scrub sensitive data\n            Items = order.Items.Select(item => item with {\n                ProductName = options.PreserveFunctionality ? item.ProductName : $\"Product-{item.ProductId.ToString()[..8]}\"\n            }).ToList()\n        };\n    }\n}\n```\n\n### Production to QA Data Flow\n\n**Secure data replication** with automatic scrubbing:\n\n```csharp{title=\"Production to QA Data Replicator\" description=\"Secure data replication from production to QA with automatic scrubbing\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Flags-Tags\", \"Production-to-QA\", \"Data-Replication\"] framework=\"NET8\"}\n// Handler that duplicates production messages to QA with scrubbing\npublic class ProductionToQAReplicator : IEventHandler<object> {\n    public async Task Handle(object @event, EventContext context) {\n        // Only replicate events tagged for QA replication\n        if (context.HasTag(\"production-data\") && \n            context.HasFlag(WhizbangFlags.QA)) {\n            \n            // Create a copy with scrubbing flag\n            var qaCopy = @event;\n            var qaContext = context.Copy()\n                .WithFlag(WhizbangFlags.DataScrubbing)\n                .WithTag(\"qa-replicated\")\n                .WithTag($\"replicated-from-production-{DateTimeOffset.UtcNow:yyyy-MM-dd}\");\n            \n            // Remove production-specific tags\n            qaContext.Tags.Remove(\"production-data\");\n            qaContext.Tags.Remove(\"customer-vip\"); // Don't carry VIP status to QA\n            \n            // Route to QA environment\n            await _qaEventPublisher.PublishAsync(qaCopy, qaContext);\n        }\n    }\n}\n```\n\n## Performance and Load Testing\n\n### Load Testing Flag Handling\n\n**Optimize behavior for load testing scenarios**:\n\n```csharp{title=\"Load Testing Optimizer\" description=\"Load testing optimization interceptor with flag-based behavior modification\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Load-Testing\", \"Performance-Optimization\"] framework=\"NET8\"}\npublic class LoadTestingOptimizer : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        \n        if (context.HasFlag(WhizbangFlags.LoadTesting)) {\n            // Optimize for load testing\n            using var loadTestScope = _performanceOptimizer.EnterLoadTestMode();\n            \n            // Disable slow operations\n            context.Tags.Add(\"skip-audit-logging\");\n            context.Tags.Add(\"skip-analytics-tracking\");\n            context.Tags.Add(\"minimal-validation\");\n            \n            // Add load test metadata\n            context.Tags.Add($\"load-test-batch-{GetLoadTestBatch()}\");\n            context.Tags.Add($\"load-test-thread-{Thread.CurrentThread.ManagedThreadId}\");\n            \n            // Execute with load test optimizations\n            return await next(message, context);\n        }\n        \n        return await next(message, context);\n    }\n    \n    private string GetLoadTestBatch() {\n        // Identify which load test batch this belongs to\n        return Environment.GetEnvironmentVariable(\"LOAD_TEST_BATCH_ID\") ?? \"unknown\";\n    }\n}\n```\n\n## Advanced Routing Scenarios\n\n### Dynamic Handler Selection\n\n**Route to different handlers** based on flags and tags:\n\n```csharp{title=\"Context-Aware Handler Factory\" description=\"Dynamic handler selection based on flags and tags for flexible routing\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Flags-Tags\", \"Dynamic-Routing\", \"Handler-Selection\"] framework=\"NET8\"}\n// Handler factory that selects implementation based on context\npublic class ContextAwareHandlerFactory<T> : ICommandHandler<T> where T : ICommand {\n    private readonly IServiceProvider _serviceProvider;\n    private readonly IHandlerRoutingRules _routingRules;\n    \n    public async Task Handle(T command, MessageContext context) {\n        var handlerType = await _routingRules.DetermineHandlerType<T>(context);\n        var handler = (ICommandHandler<T>)_serviceProvider.GetRequiredService(handlerType);\n        \n        return await handler.Handle(command, context);\n    }\n}\n\n```csharp{title=\"Handler Routing Rules\" description=\"Context-based routing rules for handler type determination\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Flags-Tags\", \"Routing-Rules\", \"Handler-Selection\"] framework=\"NET8\"}\n// Routing rules based on context\npublic class HandlerRoutingRules : IHandlerRoutingRules {\n    public async Task<Type> DetermineHandlerType<T>(MessageContext context) {\n        // VIP customers get premium handler\n        if (context.HasTag(\"customer-vip\")) {\n            return typeof(PremiumOrderHandler);\n        }\n        \n        // Load testing gets optimized handler\n        if (context.HasFlag(WhizbangFlags.LoadTesting)) {\n            return typeof(LoadTestOptimizedOrderHandler);\n        }\n        \n        // Migration data gets special handler\n        if (context.HasFlag(WhizbangFlags.Migration)) {\n            return typeof(DataMigrationOrderHandler);\n        }\n        \n        // Default handler\n        return typeof(StandardOrderHandler);\n    }\n}\n```\n\n## Configuration and Management\n\n### Flag Management\n\n**Control flag behavior** through configuration:\n\n```csharp{title=\"Flag Management Configuration\" description=\"Flag management configuration with environment-based defaults and validation\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Configuration\", \"Environment-Management\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.Flags(flags => {\n        // Environment-based flag defaults\n        if (_environment.IsDevelopment()) {\n            flags.DefaultFlags = WhizbangFlags.Development | WhizbangFlags.VerboseLogging;\n        } else if (_environment.IsProduction()) {\n            flags.DefaultFlags = WhizbangFlags.Production;\n            flags.RestrictedFlags = WhizbangFlags.SecurityBypass | WhizbangFlags.DataScrubbing;\n        }\n        \n        // Flag validation rules\n        flags.AddValidationRule(ctx => {\n            if (ctx.HasFlag(WhizbangFlags.SecurityBypass) && !ctx.HasTag(\"authorized-security-bypass\")) {\n                throw new UnauthorizedFlagException(\"SecurityBypass flag requires authorization\");\n            }\n        });\n        \n        // Automatic flag addition based on context\n        flags.AddAutoFlag(WhizbangFlags.ComplianceMode, \n            condition: ctx => ctx.HasTag(\"pci-data\") || ctx.HasTag(\"gdpr-data\"));\n    });\n});\n```\n\n### Tag Lifecycle Management\n\n**Manage tag propagation and cleanup**:\n\n```csharp{title=\"Tag Lifecycle Manager\" description=\"Tag lifecycle management with automatic addition and cleanup\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Tag-Lifecycle\", \"Management\"] framework=\"NET8\"}\npublic class TagLifecycleManager : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        \n        // Add automatic tags\n        context.Tags.Add($\"processed-at-{Environment.MachineName}\");\n        context.Tags.Add($\"handler-{typeof(TRequest).Name}\");\n        \n        // Remove expired tags\n        var expiredTags = context.Tags\n            .Where(tag => tag.StartsWith(\"session-\") && IsSessionExpired(tag))\n            .ToList();\n        \n        foreach (var expiredTag in expiredTags) {\n            context.Tags.Remove(expiredTag);\n        }\n        \n        var response = await next(message, context);\n        \n        // Add response-based tags\n        if (response is ISuccessResult) {\n            context.Tags.Add(\"execution-success\");\n        } else if (response is IErrorResult error) {\n            context.Tags.Add($\"execution-error-{error.ErrorCode}\");\n        }\n        \n        return response;\n    }\n}\n```\n\n## Best Practices\n\n### Flag Usage Guidelines\n\n1. **Use library flags first** - Prefer built-in flags over custom tags when possible\n2. **Document custom flags** - Make user-defined flags clear to the team\n3. **Be conservative with propagation** - Not all flags should cross service boundaries\n4. **Consider flag lifetime** - How long should flags persist in the system\n5. **Audit flag usage** - Track which flags are used and where\n\n### Tag Design Principles\n\n1. **Hierarchical naming** - Use consistent naming conventions (e.g., \"customer-vip\", \"region-us-west\")\n2. **Meaningful values** - Tags should be self-documenting\n3. **Avoid high cardinality** - Don't create too many unique tag combinations\n4. **Lifecycle awareness** - Consider when tags should be added/removed\n5. **Security sensitivity** - Don't include sensitive data in tag names\n\n### Security Considerations\n\n1. **Validate flag sources** - Ensure flags come from trusted sources\n2. **Limit dangerous flags** - SecurityBypass should be heavily restricted\n3. **Audit flag changes** - Log all flag modifications\n4. **Encrypt sensitive tags** - Some tags may contain sensitive information\n5. **Principle of least privilege** - Flags should grant minimal necessary permissions\n\n",
        "tags": "flags, tags, message-context, routing, debugging, cross-service",
        "version": "proposals"
      },
      {
        "slug": "proposals/multi-tenancy",
        "title": "Multi-Tenancy",
        "category": "Architecture & Design",
        "order": 8,
        "description": "\n# Multi-Tenancy\n\nWhizbang provides comprehensive multi-tenancy support with flexible tenant isolation strategies, from single database with row-level security to complete database separation.\n\n## Tenant Isolation Strategies\n\n### Single Database with Tenant ID\n\n**Row-level tenant isolation** using tenant ID columns:\n\n```sql\n",
        "tags": "multi-tenancy, tenant-isolation, partitioning, data-isolation",
        "version": "proposals"
      },
      {
        "slug": "proposals/observability-metrics",
        "title": "Observability & Metrics",
        "category": "Architecture & Design",
        "order": 14,
        "description": "\n# Observability & Metrics\n\nWhizbang provides comprehensive observability with policy-driven metrics collection, OpenTelemetry integration, and custom field attributes for rich monitoring and debugging capabilities.\n\n## Metrics Architecture\n\n### Default Metrics (Always Enabled)\n\n**Core performance and health metrics** essential for operation:\n\n```csharp\n",
        "tags": "observability, metrics, opentelemetry, monitoring, performance",
        "version": "proposals"
      },
      {
        "slug": "proposals/open-questions",
        "title": "Open Design Questions - RESOLVED",
        "category": "Architecture & Design",
        "order": 3,
        "description": "\n# Open Design Questions - RESOLVED ‚úÖ\n\n**Status**: All critical and important design questions have been resolved and documented in detailed specification documents.\n\nThis document previously captured open questions and architectural decisions for Whizbang. **All questions have now been resolved** and documented in comprehensive specifications.\n\n## üî¥ Critical Decisions - ALL RESOLVED ‚úÖ\n\n**All critical decisions have been resolved and documented**. See the detailed specifications below:\n\n### 1. Handler Discovery Mechanism ‚úÖ **RESOLVED**\n**Decision**: Hybrid approach (Source Generators + Explicit Registration)\n- **Detailed Specification**: [Domain Ownership](./domain-ownership.md)\n\n### 2. Handler Method Signature Conventions ‚úÖ **RESOLVED**\n**Decision**: Convention-based with Source Generator support\n- **Detailed Specification**: [Domain Ownership](./domain-ownership.md)\n\n### 3. Event Store Schema Design ‚úÖ **RESOLVED**\n**Decision**: Hybrid approach (Separate Events and Projections with JSONB)\n- **Detailed Specification**: [Event Store & Projections](./event-store-projections.md)\n\n### 4. Optimistic Concurrency Strategy ‚úÖ **RESOLVED**\n**Decision**: Support all strategies (Expected Version, Timestamp-Based, Automatic Retry)\n- **Detailed Specification**: [Concurrency Control](./concurrency-control.md)\n\n### 5. Domain Ownership Declaration ‚úÖ **RESOLVED**\n**Decision**: Configurable precedence order (Namespace ‚Üí Attributes ‚Üí Configuration)\n- **Detailed Specification**: [Domain Ownership](./domain-ownership.md)\n\n",
        "tags": "architecture, design-decisions, resolved, specifications",
        "version": "proposals"
      },
      {
        "slug": "proposals/policy-engine",
        "title": "Policy Engine",
        "category": "Architecture & Design",
        "order": 12,
        "description": "\n# Policy Engine\n\nWhizbang includes a sophisticated policy engine that enables flexible, rule-based configuration for routing, behavior modification, and system adaptation across the entire message lifecycle.\n\n## Core Architecture\n\nThe Policy Engine is the **universal configuration scoping mechanism** for Whizbang. Rather than having separate configuration systems for each feature, policies provide a unified way to apply configuration based on context, conditions, and scope.\n\n**Every configurable aspect of Whizbang can use policies** to determine when and how configuration should be applied:\n\n- **Concurrency strategies** - Which concurrency approach to use based on message type/context\n- **Observability levels** - How much detail to capture based on flags/environment\n- **Performance budgets** - Different performance expectations for different scenarios\n- **Serialization formats** - Which serializer to use for different drivers/contexts\n- **Multi-tenancy isolation** - Tenant-specific behavior and storage strategies\n- **Domain ownership** - Dynamic ownership rules based on context\n- **Error handling** - Different resilience policies for different message types\n- **Routing decisions** - Which handlers to use based on flags/tags\n- **Security policies** - Authentication/authorization rules based on context\n\n**Policies can evaluate any aspect of the system state**:\n- **Message content** - Properties, types, values within commands/events\n- **Message context** - Flags, tags, correlation IDs, tenant information\n- **System state** - Current load, resource utilization, error rates\n- **Environment** - Development, staging, production, feature flags\n- **User context** - Authentication, authorization, user roles\n- **Time-based conditions** - Business hours, maintenance windows, seasons\n- **Domain context** - Which domain owns the message, cross-domain interactions\n- **Infrastructure state** - Database health, message broker status\n- **Custom conditions** - Any developer-defined evaluation criteria\n\n> **üìã Message Context**: While policies can evaluate any system aspect, the [**Flags & Tags System**](./flags-tags-system.md) provides a convenient way to carry context through message flows.\n\n## Configuration Architecture Principles\n\n### Policy-Based vs Direct Configuration\n\n**Policies handle behavioral configuration** that varies by context, environment, message type, or runtime conditions:\n\n```csharp{title=\"Policy-Based vs Direct Configuration\" description=\"Policy-based vs direct configuration showing separation of infrastructure and behavioral settings\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Policy-Engine\", \"Configuration\", \"Behavioral-Configuration\"] framework=\"NET8\"}\n",
        "tags": "policy-engine, rules, behavior-modification, routing, configuration",
        "version": "proposals"
      },
      {
        "slug": "proposals/projection-management",
        "title": "Projection Management",
        "category": "Architecture & Design",
        "order": 7,
        "description": "\n# Projection Management\n\nWhizbang provides comprehensive projection management including checkpoints, backfilling strategies, system events for on-demand rebuilds, and flexible storage options.\n\n## Checkpoint Storage\n\nProjections track their progress through **checkpoint storage**, supporting multiple strategies:\n\n### A. Same Database (Default)\n\n**Transactional consistency** - checkpoints and projections updated together:\n\n```csharp{title=\"Transactional Checkpoint Storage Configuration\" description=\"Configuration for transactional checkpoint storage with projections\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"checkpoints\", \"configuration\", \"transactions\"] framework=\"NET8\"}\nservices.AddProjection<OrderSummaryProjection>(options => {\n    options.CheckpointStorage = CheckpointStorage.SameDatabase;\n});\n\n// Implementation: Single transaction\nawait using var transaction = await database.BeginTransactionAsync();\nawait projectionStore.UpdateProjection(orderSummary, transaction);\nawait checkpointStore.SaveCheckpoint(position, transaction);\nawait transaction.CommitAsync();\n```\n\n**Benefits**:\n- ‚úÖ Exactly-once processing guarantee\n- ‚úÖ Simple consistency model\n- ‚úÖ No external dependencies\n\n**Drawbacks**:\n- ‚ùå Tight coupling to projection database\n- ‚ùå Limited to single database systems\n\n### B. Separate Metadata Store\n\n**Flexible checkpoint storage** separate from projection data:\n\n```csharp{title=\"Separate Checkpoint Storage Configuration\" description=\"Configuration for separate checkpoint storage using Redis or other stores\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"checkpoints\", \"redis\", \"eventually-consistent\"] framework=\"NET8\"}\nservices.AddProjection<OrderSummaryProjection>(options => {\n    options.CheckpointStorage = CheckpointStorage.Separate;\n    options.CheckpointStore = CheckpointStore.Redis; // or CosmosDB, DynamoDB\n});\n\n// Implementation: Two-phase with compensation\ntry {\n    await projectionStore.UpdateProjection(orderSummary);\n    await checkpointStore.SaveCheckpoint(position);\n} catch {\n    // Compensation: projection will be updated again on replay\n    // Idempotent handlers ensure correctness\n}\n```\n\n**Benefits**:\n- ‚úÖ Optimized checkpoint storage (Redis, DynamoDB)\n- ‚úÖ Cross-database projections supported\n- ‚úÖ Better performance for high-throughput scenarios\n\n**Drawbacks**:\n- ‚ùå Eventually consistent\n- ‚ùå Requires idempotent projection handlers\n\n### Checkpoint Configuration\n\n```csharp{title=\"Global Checkpoint Configuration\" description=\"Global checkpoint configuration and storage options\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"configuration\", \"global-settings\", \"checkpoints\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.Projections(projections => {\n        // Global checkpoint settings\n        projections.DefaultCheckpointStorage = CheckpointStorage.SameDatabase;\n        projections.CheckpointFrequency = CheckpointFrequency.EveryEvent; // or EveryNEvents(10)\n        \n        // Checkpoint stores\n        projections.UseRedisCheckpoints(\"localhost:6379\");\n        projections.UseCosmosCheckpoints(\"connection-string\");\n        projections.UseSqlCheckpoints(\"connection-string\");\n    });\n});\n```\n\n## Snapshot Management\n\n### A. Automatic Snapshots (Default)\n\n**Configurable automatic snapshotting** for projections:\n\n```csharp{title=\"Automatic Snapshot Configuration\" description=\"Automatic snapshot configuration with frequency and retention policies\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"snapshots\", \"automatic-management\"] framework=\"NET8\"}\nservices.AddProjection<CustomerSummaryProjection>(options => {\n    options.Snapshots(snapshots => {\n        snapshots.Strategy = SnapshotStrategy.Automatic;\n        snapshots.Frequency = SnapshotFrequency.EveryNEvents(1000);\n        snapshots.RetentionPolicy = SnapshotRetention.KeepLast(5);\n    });\n});\n```\n\n### B. Manual Snapshots\n\n**Developer-controlled snapshotting**:\n\n```csharp{title=\"Manual Snapshot Control\" description=\"Manual snapshot control with custom triggers and restoration logic\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"snapshots\", \"manual-control\", \"triggers\"] framework=\"NET8\"}\npublic class CustomerSummaryProjection : IProjectionHandler<CustomerRegistered>,\n                                        IProjectionHandler<CustomerUpdated>,\n                                        ISnapshotProvider<CustomerSummarySnapshot> {\n    \n    public CustomerSummary State { get; private set; }\n    \n    public async Task Handle(CustomerRegistered @event, ProjectionContext context) {\n        State = new CustomerSummary {\n            CustomerId = @event.CustomerId,\n            Name = @event.Name,\n            Email = @event.Email,\n            RegisteredAt = @event.RegisteredAt\n        };\n        \n        await context.Store(@event.CustomerId.ToString(), State);\n    }\n    \n    // Manual snapshot creation\n    [Snapshot(TriggerOn = typeof(CustomerMilestoneReached))]\n    public CustomerSummarySnapshot CreateSnapshot() {\n        return new CustomerSummarySnapshot {\n            CustomerId = State.CustomerId,\n            Name = State.Name,\n            TotalOrders = State.TotalOrders,\n            LifetimeValue = State.LifetimeValue,\n            SnapshotVersion = State.Version\n        };\n    }\n    \n    public void RestoreFromSnapshot(CustomerSummarySnapshot snapshot) {\n        State = new CustomerSummary {\n            CustomerId = snapshot.CustomerId,\n            Name = snapshot.Name,\n            TotalOrders = snapshot.TotalOrders,\n            LifetimeValue = snapshot.LifetimeValue,\n            Version = snapshot.SnapshotVersion\n        };\n    }\n}\n```\n\n### C. No Snapshots\n\n**Opt out of snapshotting** for simple projections:\n\n```csharp{title=\"Disable Snapshots Configuration\" description=\"Disabling snapshots for simple projections that don't need them\" category=\"Design\" difficulty=\"BEGINNER\" tags=[\"projections\", \"snapshots\", \"simple-projections\"] framework=\"NET8\"}\nservices.AddProjection<SimpleEventLogProjection>(options => {\n    options.Snapshots(snapshots => {\n        snapshots.Strategy = SnapshotStrategy.None;\n    });\n});\n```\n\n## Backfilling Strategies\n\n### A. Declarative Backfilling\n\n**Simple configuration-based backfilling**:\n\n```csharp{title=\"Declarative Backfilling Configuration\" description=\"Declarative backfilling configuration with date ranges and batch settings\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"backfilling\", \"declarative-configuration\"] framework=\"NET8\"}\nservices.AddProjection<OrderHistoryProjection>(options => {\n    options.Backfill(backfill => {\n        backfill.StartFrom = DateTimeOffset.Parse(\"2024-01-01\");\n        backfill.AutoStart = true;\n        backfill.BatchSize = 1000;\n        backfill.MaxConcurrency = 4;\n    });\n});\n\n// Or backfill everything\nservices.AddProjection<NewAnalyticsProjection>(options => {\n    options.BackfillFromBeginning();\n});\n```\n\n### B. Imperative Backfilling\n\n**Programmatic control over backfilling**:\n\n```csharp{title=\"Programmatic Backfilling REST API\" description=\"REST API controller for programmatic projection backfilling\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"backfilling\", \"rest-api\", \"controller\"] framework=\"NET8\"}\npublic class BackfillController : ControllerBase {\n    private readonly IProjectionManager _projectionManager;\n    \n    [HttpPost(\"projections/{projectionName}/backfill\")]\n    public async Task<IActionResult> BackfillProjection(\n        string projectionName,\n        BackfillRequest request) {\n        \n        var options = new BackfillOptions {\n            FromDate = request.FromDate,\n            ToDate = request.ToDate,\n            BatchSize = request.BatchSize ?? 1000,\n            IsAtomic = request.IsAtomic ?? false,\n            OnProgress = (progress) => {\n                // Real-time progress updates via SignalR\n                _hubContext.Clients.All.SendAsync(\"BackfillProgress\", progress);\n            }\n        };\n        \n        var result = await _projectionManager.BackfillAsync(projectionName, options);\n        return Ok(result);\n    }\n}\n```\n\n### System Events for On-Demand Backfilling\n\n**Event-driven backfill requests**:\n\n```csharp{title=\"System Events for Backfilling\" description=\"System events for on-demand projection backfilling with criteria\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"system-events\", \"event-driven-backfill\"] framework=\"NET8\"}\n// System event to trigger backfilling\npublic record ProjectionBackfillRequested(\n    string ProjectionName,\n    DateTimeOffset? FromDate,\n    DateTimeOffset? ToDate,\n    bool IsAtomic,\n    BackfillCriteria Criteria,\n    string RequestedBy\n) : ISystemEvent;\n\n```csharp{title=\"Backfill System Event Handler\" description=\"System event handler for processing backfill requests\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"system-events\", \"event-handlers\", \"backfilling\"] framework=\"NET8\"}\n// System event handler\npublic class ProjectionBackfillHandler : ISystemEventHandler<ProjectionBackfillRequested> {\n    public async Task Handle(ProjectionBackfillRequested @event, SystemEventContext context) {\n        var options = new BackfillOptions {\n            FromDate = @event.FromDate,\n            ToDate = @event.ToDate,\n            IsAtomic = @event.IsAtomic,\n            Criteria = @event.Criteria,\n            RequestId = context.CorrelationId\n        };\n        \n        await _projectionManager.BackfillAsync(@event.ProjectionName, options);\n        \n        // Emit completion event\n        await context.PublishSystemEvent(new ProjectionBackfillCompleted(\n            @event.ProjectionName,\n            options.FromDate,\n            options.ToDate,\n            context.CorrelationId\n        ));\n    }\n}\n\n// Trigger backfill via system event\nawait _systemEventPublisher.PublishAsync(new ProjectionBackfillRequested(\n    ProjectionName: \"order-summary\",\n    FromDate: DateTimeOffset.Parse(\"2024-01-01\"),\n    ToDate: null, // To current\n    IsAtomic: true,\n    Criteria: BackfillCriteria.FullRebuild,\n    RequestedBy: \"admin-user\"\n));\n```\n\n### Backfill Criteria Options\n\n```csharp{title=\"Backfill Criteria Options\" description=\"Comprehensive backfill criteria options for different scenarios\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"backfilling\", \"criteria-options\"] framework=\"NET8\"}\npublic enum BackfillCriteria {\n    // Date-based backfill\n    DateRange,              // Specific date range\n    FromDate,               // From date to current\n    LastNDays,              // Last N days only\n    \n    // Event-based backfill  \n    EventNumberRange,       // Specific event number range\n    FromEventNumber,        // From event number to current\n    LastNEvents,            // Last N events only\n    \n    // Full rebuild options\n    FullRebuild,            // Complete rebuild from beginning\n    IncrementalUpdate,      // Only missing/updated events\n    \n    // Custom criteria\n    CustomPredicate         // Custom filter expression\n}\n\n// Usage examples\nservices.AddProjection<OrderSummaryProjection>(options => {\n    options.Backfill(backfill => {\n        backfill.Criteria = BackfillCriteria.LastNDays;\n        backfill.CriteriaValue = 30; // Last 30 days\n    });\n});\n\n// System event with custom criteria\nawait _systemEvents.PublishAsync(new ProjectionBackfillRequested(\n    ProjectionName: \"analytics\",\n    FromDate: null,\n    ToDate: null,\n    IsAtomic: false,\n    Criteria: BackfillCriteria.CustomPredicate,\n    RequestedBy: \"system\"\n) {\n    CustomPredicate = @event => @event.EventType.StartsWith(\"Order\") && \n                               @event.Metadata[\"source\"] == \"web-api\"\n});\n```\n\n## Advanced Backfill Features\n\n### Parallel Processing\n\n```csharp{title=\"Parallel Backfill Processing\" description=\"Parallel backfill processing with partitioning and concurrency control\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"backfilling\", \"parallel-processing\", \"concurrency\"] framework=\"NET8\"}\nservices.AddProjection<AnalyticsProjection>(options => {\n    options.Backfill(backfill => {\n        backfill.Strategy = BackfillStrategy.Parallel;\n        backfill.PartitionBy = @event => @event.StreamId.GetHashCode() % 8;\n        backfill.MaxConcurrency = 8;\n        backfill.BatchSize = 500;\n    });\n});\n```\n\n### Progress Tracking\n\n```csharp{title=\"Backfill Progress Tracking\" description=\"Real-time progress tracking for backfill operations\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"backfilling\", \"progress-tracking\"] framework=\"NET8\"}\npublic class BackfillProgressTracker {\n    public async Task TrackProgress(string projectionName, CancellationToken cancellationToken) {\n        await foreach (var progress in _projectionManager.GetBackfillProgress(projectionName, cancellationToken)) {\n            Console.WriteLine($\"Backfill progress: {progress.EventsProcessed}/{progress.TotalEvents} \" +\n                            $\"({progress.PercentComplete:F1}%) - ETA: {progress.EstimatedTimeRemaining}\");\n        }\n    }\n}\n```\n\n### Rollback Support\n\n```csharp{title=\"Backfill Rollback Support\" description=\"Rollback support for failed backfill operations with backup creation\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"backfilling\", \"rollback-support\", \"backup\"] framework=\"NET8\"}\n// Rollback to previous version if backfill fails\nservices.AddProjection<OrderSummaryProjection>(options => {\n    options.Backfill(backfill => {\n        backfill.EnableRollback = true;\n        backfill.RollbackOnFailure = true;\n        backfill.CreateBackupBeforeBackfill = true;\n    });\n});\n\n// Manual rollback API\nawait _projectionManager.RollbackProjection(\"order-summary\", toVersion: previousVersion);\n```\n\n## System Event Integration\n\n### Built-in System Events\n\n```csharp{title=\"Projection Lifecycle System Events\" description=\"Built-in system events for projection lifecycle monitoring\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"system-events\", \"lifecycle-management\"] framework=\"NET8\"}\n// Projection lifecycle events\npublic record ProjectionStarted(string ProjectionName, DateTimeOffset StartedAt);\npublic record ProjectionStopped(string ProjectionName, DateTimeOffset StoppedAt);\npublic record ProjectionFailed(string ProjectionName, Exception Error, DateTimeOffset FailedAt);\n\n// Backfill events\npublic record ProjectionBackfillStarted(string ProjectionName, BackfillOptions Options);\npublic record ProjectionBackfillProgress(string ProjectionName, BackfillProgress Progress);\npublic record ProjectionBackfillCompleted(string ProjectionName, BackfillResult Result);\npublic record ProjectionBackfillFailed(string ProjectionName, Exception Error);\n\n// Checkpoint events\npublic record ProjectionCheckpointSaved(string ProjectionName, long Position);\npublic record ProjectionCheckpointRestored(string ProjectionName, long Position);\n\n// Snapshot events\npublic record ProjectionSnapshotCreated(string ProjectionName, long EventVersion);\npublic record ProjectionSnapshotRestored(string ProjectionName, long EventVersion);\n```\n\n### Custom System Event Handlers\n\n```csharp{title=\"Projection Monitoring Event Handlers\" description=\"Custom system event handlers for projection monitoring and alerting\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"system-events\", \"monitoring\", \"alerting\"] framework=\"NET8\"}\npublic class ProjectionMonitoringHandler : \n    ISystemEventHandler<ProjectionFailed>,\n    ISystemEventHandler<ProjectionBackfillCompleted> {\n    \n    public async Task Handle(ProjectionFailed @event, SystemEventContext context) {\n        // Alert on projection failures\n        await _alerting.SendAlert($\"Projection {@event.ProjectionName} failed: {@event.Error.Message}\");\n        \n        // Automatic retry for transient failures\n        if (IsTransientError(@event.Error)) {\n            await context.PublishSystemEvent(new ProjectionRestartRequested(\n                @event.ProjectionName,\n                retryAttempt: context.GetRetryAttempt() + 1\n            ));\n        }\n    }\n    \n    public async Task Handle(ProjectionBackfillCompleted @event, SystemEventContext context) {\n        // Update projection metadata\n        await _projectionMetadata.MarkBackfillComplete(@event.ProjectionName, @event.Result);\n        \n        // Notify stakeholders\n        await _notifications.NotifyBackfillComplete(@event.ProjectionName);\n    }\n}\n```\n\n## API Reference\n\n### IProjectionManager Interface\n\n```csharp{title=\"IProjectionManager Interface\" description=\"Comprehensive projection management API interface\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"management-api\", \"interfaces\"] framework=\"NET8\"}\npublic interface IProjectionManager {\n    // Lifecycle management\n    Task StartProjection(string projectionName);\n    Task StopProjection(string projectionName);\n    Task RestartProjection(string projectionName);\n    \n    // Backfilling\n    Task<BackfillResult> BackfillAsync(string projectionName, BackfillOptions options);\n    IAsyncEnumerable<BackfillProgress> GetBackfillProgress(string projectionName, CancellationToken cancellationToken);\n    Task CancelBackfill(string projectionName);\n    \n    // Snapshots\n    Task<SnapshotResult> CreateSnapshot(string projectionName);\n    Task<SnapshotResult> RestoreFromSnapshot(string projectionName, long snapshotVersion);\n    Task<IEnumerable<SnapshotInfo>> GetSnapshots(string projectionName);\n    \n    // Checkpoints\n    Task<long> GetCurrentCheckpoint(string projectionName);\n    Task ResetCheckpoint(string projectionName, long position);\n    \n    // Status and monitoring\n    Task<ProjectionStatus> GetStatus(string projectionName);\n    Task<IEnumerable<ProjectionInfo>> GetAllProjections();\n    Task<ProjectionHealth> GetHealth(string projectionName);\n}\n```\n\n### Configuration Extensions\n\n```csharp{title=\"Projection Configuration Extensions\" description=\"Extension methods for fluent projection configuration API\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"extension-methods\", \"fluent-api\"] framework=\"NET8\"}\npublic static class ProjectionConfigurationExtensions {\n    public static IProjectionBuilder<T> BackfillFromBeginning<T>(this IProjectionBuilder<T> builder) \n        where T : class;\n    \n    public static IProjectionBuilder<T> BackfillFrom<T>(this IProjectionBuilder<T> builder, DateTimeOffset from) \n        where T : class;\n    \n    public static IProjectionBuilder<T> WithSnapshots<T>(this IProjectionBuilder<T> builder, \n        Action<SnapshotConfiguration> configure) where T : class;\n    \n    public static IProjectionBuilder<T> WithCheckpoints<T>(this IProjectionBuilder<T> builder, \n        Action<CheckpointConfiguration> configure) where T : class;\n    \n    public static IProjectionBuilder<T> OnSystemEvent<T, TEvent>(this IProjectionBuilder<T> builder, \n        Func<TEvent, Task> handler) where T : class where TEvent : ISystemEvent;\n}\n```\n\n## Best Practices\n\n### Projection Design\n\n1. **Keep projections focused** - One projection per query need\n2. **Make handlers idempotent** - Support replay scenarios\n3. **Handle missing data gracefully** - Events may be out of order\n4. **Version projection schemas** - Enable evolution over time\n\n### Backfill Planning\n\n1. **Test backfills in staging** - Verify performance and correctness\n2. **Use atomic rebuilds** for critical projections\n3. **Monitor resource usage** during large backfills\n4. **Plan for rollback scenarios** if backfill fails\n\n### Checkpoint Strategy\n\n1. **Use same-database checkpoints** for consistency-critical projections\n2. **Use separate checkpoints** for high-throughput scenarios\n3. **Checkpoint frequently** to minimize replay overhead\n4. **Monitor checkpoint lag** for early failure detection\n\n",
        "tags": "projections, backfilling, checkpoints, system-events, rebuilding",
        "version": "proposals"
      },
      {
        "slug": "proposals/schema-evolution",
        "title": "Schema Evolution & Event Versioning",
        "category": "Architecture & Design",
        "order": 9,
        "description": "\n# Schema Evolution & Event Versioning\n\nWhizbang provides robust schema evolution capabilities using JSONB storage and flexible driver interfaces, allowing events and projections to evolve over time without breaking existing systems.\n\n## JSONB-Based Schema Evolution\n\n### Flexible Event Schema\n\nEvents stored in **JSONB format** naturally support schema evolution:\n\n```csharp{title=\"Event Schema Evolution\" description=\"Event schema evolution from V1 to V3 with backward-compatible changes\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Schema-Evolution\", \"Event-Versioning\", \"Backward-Compatibility\"] framework=\"NET8\"}\n// V1 Event\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId\n);\n\n// V2 Event - Add field (backward compatible)\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset? PlacedAt = null  // Optional for backward compatibility\n);\n\n// V3 Event - Add collection (backward compatible)\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset? PlacedAt = null,\n    List<string> Tags = null         // Null-safe collection\n) {\n    // Ensure collections are never null\n    public List<string> Tags { get; init; } = Tags ?? new List<string>();\n}\n```\n\n**JSONB benefits**:\n- ‚úÖ Missing fields handled gracefully\n- ‚úÖ Extra fields ignored during deserialization\n- ‚úÖ No database schema migrations required\n- ‚úÖ Query flexibility with JSON operators\n\n### Projection Schema Evolution\n\nProjections can evolve independently of events:\n\n```csharp{title=\"Projection Schema Evolution\" description=\"Projection schema evolution without database migrations using JSONB\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Schema-Evolution\", \"Projections\", \"JSONB-Storage\"] framework=\"NET8\"}\n// V1 Projection\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public decimal Total { get; set; }\n    public OrderStatus Status { get; set; }\n}\n\n// V2 Projection - Add fields without migration\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public decimal Total { get; set; }\n    public OrderStatus Status { get; set; }\n    \n    // New fields with sensible defaults\n    public DateTime EstimatedDelivery { get; set; } = DateTime.MinValue;\n    public List<string> Tags { get; set; } = new();\n    public CustomerInfo Customer { get; set; } = new();\n}\n\n// Projection rebuild handles missing data gracefully\npublic class OrderSummaryProjection : IProjectionHandler<OrderPlaced> {\n    public async Task Handle(OrderPlaced @event, ProjectionContext context) {\n        var summary = await context.Load<OrderSummary>(@event.OrderId.ToString()) \n                      ?? new OrderSummary();\n        \n        summary.OrderId = @event.OrderId;\n        summary.Total = @event.Total;\n        \n        // Handle optional V2+ fields\n        if (@event.PlacedAt.HasValue) {\n            summary.EstimatedDelivery = @event.PlacedAt.Value.AddDays(7);\n        }\n        \n        if (@event.Tags?.Any() == true) {\n            summary.Tags = @event.Tags;\n        }\n        \n        await context.Store(@event.OrderId.ToString(), summary);\n    }\n}\n```\n\n## Event Versioning Strategies\n\n### A. Upcasting (Recommended)\n\n**Convert old events to new schema on read**:\n\n```csharp{title=\"Event Upcaster Interface\" description=\"Event upcasting interface for converting old events to new schemas\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Upcasting\", \"Event-Transformation\", \"Interface\"] framework=\"NET8\"}\npublic interface IEventUpcaster<TOld, TNew> {\n    TNew Upcast(TOld oldEvent);\n    bool CanUpcast(Type eventType, int version);\n}\n\n```csharp{title=\"Concrete Upcaster Implementation\" description=\"Concrete upcaster implementation for event version migration\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Upcasting\", \"Implementation\", \"Registration\"] framework=\"NET8\"}\n// Upcast V1 OrderPlaced to V2\npublic class OrderPlacedV1ToV2Upcaster : IEventUpcaster<OrderPlacedV1, OrderPlaced> {\n    public OrderPlaced Upcast(OrderPlacedV1 oldEvent) {\n        return new OrderPlaced(\n            oldEvent.OrderId,\n            oldEvent.CustomerId,\n            PlacedAt: DateTimeOffset.UtcNow, // Best guess for missing data\n            Tags: new List<string>()         // Default to empty\n        );\n    }\n    \n    public bool CanUpcast(Type eventType, int version) {\n        return eventType == typeof(OrderPlacedV1) && version == 1;\n    }\n}\n\n// Registration\nservices.AddWhizbang(options => {\n    options.EventVersioning(versioning => {\n        versioning.AddUpcaster<OrderPlacedV1ToV2Upcaster>();\n        versioning.AddUpcaster<OrderPlacedV2ToV3Upcaster>();\n    });\n});\n```\n\n### B. Multiple Versions Supported Simultaneously\n\n**Keep multiple event versions active**:\n\n```csharp{title=\"Multiple Version Handlers\" description=\"Supporting multiple event versions simultaneously with separate handlers\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Multiple-Versions\", \"Event-Handlers\", \"Registration\"] framework=\"NET8\"}\n// Multiple handlers for different versions\npublic class OrderPlacedV1Handler : IEventHandler<OrderPlacedV1> {\n    public async Task Handle(OrderPlacedV1 @event, EventContext context) {\n        // Handle legacy V1 events\n        var order = await _repository.Load<Order>(@event.OrderId);\n        order.MarkAsPlaced(placedAt: DateTimeOffset.UtcNow); // Default timestamp\n        await _repository.Save(order);\n    }\n}\n\npublic class OrderPlacedV2Handler : IEventHandler<OrderPlaced> {\n    public async Task Handle(OrderPlaced @event, EventContext context) {\n        // Handle current V2+ events\n        var order = await _repository.Load<Order>(@event.OrderId);\n        order.MarkAsPlaced(@event.PlacedAt ?? DateTimeOffset.UtcNow);\n        await _repository.Save(order);\n    }\n}\n\n// Router determines which handler to use based on event version\nservices.AddWhizbang(options => {\n    options.EventVersioning(versioning => {\n        versioning.RouteByVersion = true;\n        versioning.RegisterHandler<OrderPlacedV1Handler>(version: 1);\n        versioning.RegisterHandler<OrderPlacedV2Handler>(version: 2);\n    });\n});\n```\n\n### C. Schema Registry\n\n**Centralized schema management**:\n\n```csharp{title=\"Schema Registry Configuration\" description=\"Centralized schema registry configuration for schema management\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Schema-Registry\", \"Centralized-Management\", \"Configuration\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.EventVersioning(versioning => {\n        versioning.UseSchemaRegistry(registry => {\n            registry.ConnectionString = \"https://schema-registry.company.com\";\n            registry.AutoRegisterSchemas = true;\n            registry.ValidateOnWrite = true;\n            registry.CompatibilityLevel = CompatibilityLevel.Backward;\n        });\n    });\n});\n\n// Events automatically registered with schema registry\n[SchemaRegistration(subject: \"order-placed\", version: 2)]\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset? PlacedAt = null\n);\n```\n\n## Driver Interface for Schema Evolution\n\n### Abstract Driver Interface\n\n```csharp{title=\"Schema Evolution Driver Interface\" description=\"Driver interface for schema evolution with versioning and upcasting support\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Driver-Interface\", \"Serialization\", \"Versioning\"] framework=\"NET8\"}\npublic interface ISchemaEvolutionDriver {\n    // Serialization with versioning\n    Task<byte[]> Serialize<T>(T @event, int? version = null);\n    Task<T> Deserialize<T>(byte[] data, int version);\n    Task<object> DeserializeToLatestVersion(byte[] data, Type eventType, int storedVersion);\n    \n    // Schema registration\n    Task RegisterSchema(Type eventType, int version);\n    Task<SchemaInfo> GetSchema(Type eventType, int version);\n    Task<IEnumerable<SchemaInfo>> GetSchemaEvolution(Type eventType);\n    \n    // Upcasting support\n    Task<T> UpcastToLatest<T>(object oldEvent, int fromVersion);\n    bool CanUpcast(Type eventType, int fromVersion, int toVersion);\n}\n\npublic class SchemaInfo {\n    public Type EventType { get; set; }\n    public int Version { get; set; }\n    public string Schema { get; set; }\n    public DateTime RegisteredAt { get; set; }\n    public CompatibilityLevel Compatibility { get; set; }\n}\n```\n\n### PostgreSQL JSONB Driver Implementation\n\n```csharp{title=\"PostgreSQL Schema Evolution Driver\" description=\"PostgreSQL JSONB implementation of schema evolution driver with serialization and upcasting\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"PostgreSQL\", \"JSONB-Implementation\", \"Driver\"] framework=\"NET8\"}\npublic class PostgresSchemaEvolutionDriver : ISchemaEvolutionDriver {\n    public async Task<byte[]> Serialize<T>(T @event, int? version = null) {\n        var eventType = typeof(T);\n        var currentVersion = version ?? await GetLatestVersion(eventType);\n        \n        var eventData = new {\n            EventType = eventType.FullName,\n            Version = currentVersion,\n            Data = @event\n        };\n        \n        return JsonSerializer.SerializeToUtf8Bytes(eventData);\n    }\n    \n    public async Task<T> Deserialize<T>(byte[] data, int version) {\n        var eventData = JsonSerializer.Deserialize<dynamic>(data);\n        var storedVersion = (int)eventData.Version;\n        \n        if (storedVersion == version) {\n            return JsonSerializer.Deserialize<T>(eventData.Data);\n        }\n        \n        // Need to upcast\n        var oldEvent = DeserializeToVersion(eventData.Data, typeof(T), storedVersion);\n        return await UpcastToLatest<T>(oldEvent, storedVersion);\n    }\n    \n    public async Task<object> DeserializeToLatestVersion(byte[] data, Type eventType, int storedVersion) {\n        var latestVersion = await GetLatestVersion(eventType);\n        \n        if (storedVersion == latestVersion) {\n            // Already latest version\n            return JsonSerializer.Deserialize(data, eventType);\n        }\n        \n        // Upcast to latest\n        var oldEvent = DeserializeToVersion(data, eventType, storedVersion);\n        return await UpcastToLatest(oldEvent, eventType, storedVersion, latestVersion);\n    }\n}\n```\n\n## LINQ Support Evolution\n\n### Driver-Specific LINQ Implementation\n\n```csharp{title=\"Query Evolution Driver Interface\" description=\"Driver interface for schema-aware LINQ querying across versions\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"LINQ-Support\", \"Querying\", \"Interface\"] framework=\"NET8\"}\npublic interface IQueryEvolutionDriver {\n    IQueryable<T> Query<T>() where T : class;\n    IQueryable<T> QueryVersion<T>(int version) where T : class;\n    IQueryable<object> QueryAllVersions(Type eventType);\n}\n\n```csharp{title=\"PostgreSQL Query Driver Implementation\" description=\"PostgreSQL implementation with JSONB operators for evolved schemas\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"PostgreSQL\", \"JSONB-Queries\", \"EF-Core\"] framework=\"NET8\"}\n// PostgreSQL implementation with JSONB operators\npublic class PostgresQueryDriver : IQueryEvolutionDriver {\n    public IQueryable<T> Query<T>() where T : class {\n        return _context.Events\n            .Where(e => e.EventType == typeof(T).Name)\n            .Select(e => JsonSerializer.Deserialize<T>(e.EventData))\n            .AsQueryable();\n    }\n    \n    // JSONB path queries for evolved schemas\n    public IQueryable<OrderSummary> QueryOrdersWithTags() {\n        return _context.Projections\n            .Where(p => p.ProjectionName == \"order-summary\")\n            .Where(p => EF.Functions.JsonExists(p.Document, \"$.Tags\"))  // Has tags field\n            .Select(p => JsonSerializer.Deserialize<OrderSummary>(p.Document))\n            .AsQueryable();\n    }\n    \n    // Query across schema versions\n    public IQueryable<decimal> QueryOrderTotals() {\n        return _context.Events\n            .Where(e => e.EventType == \"OrderPlaced\")\n            .Select(e => EF.Functions.JsonExtract<decimal>(e.EventData, \"$.Total\"))\n            .AsQueryable();\n    }\n}\n```\n\n### Schema-Aware Query Extensions\n\n```csharp{title=\"Schema-Aware Query Extensions\" description=\"Extension methods for schema-aware querying and filtering across versions\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Schema-Evolution\", \"LINQ-Extensions\", \"Query-Helpers\", \"Extensions\"] framework=\"NET8\"}\npublic static class SchemaQueryExtensions {\n    public static IQueryable<T> WhereSchemaVersion<T>(this IQueryable<T> query, int version) {\n        // Filter by schema version\n        return query.Where(/* version filter logic */);\n    }\n    \n    public static IQueryable<T> WhereHasField<T>(this IQueryable<T> query, string fieldPath) {\n        // Filter by field existence (JSONB support)\n        return query.Where(/* field existence logic */);\n    }\n    \n    public static IQueryable<TResult> SelectEvolved<T, TResult>(\n        this IQueryable<T> query, \n        Expression<Func<T, TResult>> selector,\n        SchemaEvolutionOptions options = null) {\n        // Schema-aware projection\n        return query.Select(/* evolved selector logic */);\n    }\n}\n\n// Usage\nvar recentOrdersWithTags = await _context.Query<OrderSummary>()\n    .WhereHasField(\"Tags\")\n    .Where(o => o.PlacedAt > DateTime.UtcNow.AddDays(-30))\n    .ToListAsync();\n```\n\n## Blue/Green Deployment Support\n\n### Driver-Level Blue/Green Implementation\n\n```csharp{title=\"Blue/Green Deployment Driver\" description=\"Driver interface and implementation for blue/green projection deployments\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Blue-Green-Deployment\", \"Driver-Interface\", \"PostgreSQL\"] framework=\"NET8\"}\npublic interface IBlueGreenDriver {\n    Task<string> CreateGreenDeployment(string projectionName);\n    Task BuildGreenProjection(string projectionName, string greenVersion);\n    Task ValidateGreenProjection(string projectionName, string greenVersion);\n    Task SwitchToGreen(string projectionName, string greenVersion);\n    Task CleanupBlueVersion(string projectionName);\n}\n\npublic class PostgresBlueGreenDriver : IBlueGreenDriver {\n    public async Task<string> CreateGreenDeployment(string projectionName) {\n        var greenVersion = Guid.NewGuid().ToString(\"N\")[..8];\n        var greenTableName = $\"{projectionName}_green_{greenVersion}\";\n        \n        // Create green table with same schema as blue\n        await _connection.ExecuteAsync($\"\"\"\n            CREATE TABLE {greenTableName} (LIKE {projectionName} INCLUDING ALL);\n            CREATE INDEX CONCURRENTLY idx_{greenTableName}_tenant \n                ON {greenTableName}(tenant_id) WHERE tenant_id IS NOT NULL;\n        \"\"\");\n        \n        return greenVersion;\n    }\n    \n    public async Task BuildGreenProjection(string projectionName, string greenVersion) {\n        var greenTableName = $\"{projectionName}_green_{greenVersion}\";\n        \n        // Rebuild projection in green table from events\n        await _projectionBuilder.RebuildInTable(projectionName, greenTableName);\n    }\n    \n    public async Task SwitchToGreen(string projectionName, string greenVersion) {\n        var greenTableName = $\"{projectionName}_green_{greenVersion}\";\n        var blueBackupName = $\"{projectionName}_blue_backup_{DateTimeOffset.UtcNow:yyyyMMdd_HHmmss}\";\n        \n        // Atomic table swap\n        await _connection.ExecuteAsync($\"\"\"\n            BEGIN;\n            ALTER TABLE {projectionName} RENAME TO {blueBackupName};\n            ALTER TABLE {greenTableName} RENAME TO {projectionName};\n            COMMIT;\n        \"\"\");\n    }\n}\n```\n\n## Configuration and Best Practices\n\n### Comprehensive Schema Evolution Setup\n\n```csharp{title=\"Comprehensive Schema Evolution Setup\" description=\"Complete schema evolution configuration with all features enabled\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Configuration\", \"Comprehensive-Setup\", \"Best-Practices\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.SchemaEvolution(evolution => {\n        // Storage format\n        evolution.UseJsonb = true;\n        evolution.StoreSchemaVersion = true;\n        evolution.ValidateOnWrite = false; // Allow forward compatibility\n        \n        // Versioning strategy\n        evolution.VersioningStrategy = VersioningStrategy.Upcasting;\n        evolution.AutoRegisterUpcasterts = true;\n        evolution.UpcastOnRead = true;\n        \n        // Schema registry\n        evolution.UseSchemaRegistry(registry => {\n            registry.Url = \"https://schema-registry.internal\";\n            registry.AutoRegister = true;\n            registry.CompatibilityLevel = CompatibilityLevel.Backward;\n        });\n        \n        // Blue/Green deployments\n        evolution.BlueGreen(blueGreen => {\n            blueGreen.ValidationThreshold = 0.99; // 99% accuracy required\n            blueGreen.WarmupPeriod = TimeSpan.FromMinutes(5);\n            blueGreen.AutoSwitch = false; // Manual approval required\n        });\n    });\n});\n```\n\n### Event Versioning Best Practices\n\n```csharp{title=\"Event Versioning Best Practices\" description=\"Best practices for event versioning and backward-compatible schema evolution\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Schema-Evolution\", \"Best-Practices\", \"Backward-Compatibility\", \"Versioning\"] framework=\"NET8\"}\n// 1. Always make fields optional when adding them\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset? PlacedAt = null,      // Optional - added in V2\n    List<string>? Tags = null             // Optional - added in V3\n);\n\n// 2. Use wrapper types for complex evolution\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    OrderMetadata? Metadata = null        // Wrapper for evolving fields\n);\n\npublic record OrderMetadata(\n    DateTimeOffset? PlacedAt = null,\n    List<string>? Tags = null,\n    CustomerInfo? Customer = null\n);\n\n// 3. Never remove fields - mark as obsolete\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    \n    [Obsolete(\"Use Metadata.PlacedAt instead\")]\n    DateTimeOffset? PlacedAt = null,      // Keep for backward compatibility\n    \n    OrderMetadata? Metadata = null\n);\n\n// 4. Use semantic versioning for breaking changes\n[EventVersion(\"order-placed\", \"1.0.0\")]\npublic record OrderPlacedV1(Guid OrderId, Guid CustomerId);\n\n[EventVersion(\"order-placed\", \"1.1.0\")]  // Minor version - additive\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset? PlacedAt = null);\n\n[EventVersion(\"order-placed\", \"2.0.0\")]  // Major version - breaking change\npublic record OrderPlacedV2(Guid OrderId, CustomerId CustomerId, DateTimeOffset PlacedAt);\n```\n\n### Projection Evolution Guidelines\n\n1. **Add fields with defaults** - New fields should have sensible default values\n2. **Rebuild for major changes** - Use blue/green deployment for breaking changes\n3. **Test evolution paths** - Verify old events work with new projections\n4. **Monitor data quality** - Track schema evolution impact on data\n5. **Document changes** - Keep clear records of schema evolution decisions\n\n",
        "tags": "schema-evolution, event-versioning, jsonb, upcasting, backward-compatibility",
        "version": "proposals"
      },
      {
        "slug": "proposals/source-generation-ide",
        "title": "Source Generation & IDE Integration",
        "category": "Architecture & Design",
        "order": 12,
        "description": "\n# Source Generation & IDE Integration\n\nWhizbang uses advanced source generation and IDE integration to provide a seamless developer experience with compile-time validation, intelligent navigation, and powerful debugging tools.\n\n## Source Generator Architecture\n\n### Single Pipeline Generator\n\n**Incremental source generator** with orchestrated pipeline stages for optimal performance:\n\n```csharp{\ntitle: \"Incremental Source Generator\"\ndescription: \"Single incremental source generator with orchestrated pipeline stages\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"Design\", \"Source-Generation\", \"Incremental-Generation\", \"Pipeline-Architecture\"]\nframework: \"NET8\"\n}\n[Generator]\npublic class WhizbangSourceGenerator : IIncrementalGenerator {\n    public void Initialize(IncrementalGeneratorInitializationContext context) {\n        // Stage 1: Handler Discovery Pipeline\n        var handlersPipeline = context.SyntaxProvider.CreateSyntaxProvider(\n            predicate: (node, _) => IsHandlerCandidate(node),\n            transform: (ctx, _) => ExtractHandlerInfo(ctx)\n        ).Where(info => info != null);\n        \n        // Stage 2: Domain Ownership Pipeline  \n        var domainOwnershipPipeline = context.SyntaxProvider.CreateSyntaxProvider(\n            predicate: (node, _) => IsDomainCandidate(node),\n            transform: (ctx, _) => ExtractDomainInfo(ctx)\n        );\n        \n        // Stage 3: Projection Pipeline\n        var projectionsPipeline = context.SyntaxProvider.CreateSyntaxProvider(\n            predicate: (node, _) => IsProjectionCandidate(node),\n            transform: (ctx, _) => ExtractProjectionInfo(ctx)\n        );\n        \n        // Stage 4: Policy Pipeline\n        var policiesPipeline = context.SyntaxProvider.CreateSyntaxProvider(\n            predicate: (node, _) => IsPolicyCandidate(node),\n            transform: (ctx, _) => ExtractPolicyInfo(ctx)\n        );\n        \n        // Combine all sources for cross-project aggregation\n        var combinedPipeline = handlersPipeline\n            .Combine(domainOwnershipPipeline)\n            .Combine(projectionsPipeline)\n            .Combine(policiesPipeline);\n            \n        // Generate code\n        context.RegisterSourceOutput(combinedPipeline, GenerateWhizbangRegistry);\n        \n        // Generate metadata for IDE service\n        context.RegisterSourceOutput(combinedPipeline, GenerateNavigationMetadata);\n        \n        // Generate analyzer data\n        context.RegisterSourceOutput(combinedPipeline, GenerateAnalyzerData);\n    }\n}\n```\n\n### Build Performance & Logging\n\n**Detailed timing and logging** for optimization:\n\n```csharp{\ntitle: \"Performance Tracker\"\ndescription: \"Performance tracking for source generation stages with detailed timing\"\ncategory: \"Design\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Design\", \"Source-Generation\", \"Performance-Tracking\", \"Build-Optimization\"]\nframework: \"NET8\"\n}\npublic class GenerationPerformanceTracker {\n    private readonly Dictionary<string, Stopwatch> _stageTimers = new();\n    \n    public void StartStage(string stageName) {\n        _stageTimers[stageName] = Stopwatch.StartNew();\n        LogInformation($\"Starting stage: {stageName}\");\n    }\n    \n    public void EndStage(string stageName) {\n        if (_stageTimers.TryGetValue(stageName, out var timer)) {\n            timer.Stop();\n            LogInformation($\"Completed stage: {stageName} in {timer.ElapsedMilliseconds}ms\");\n        }\n    }\n    \n    public void LogSummary() {\n        var totalTime = _stageTimers.Values.Sum(t => t.ElapsedMilliseconds);\n        LogInformation($\"Total generation time: {totalTime}ms\");\n        \n        foreach (var (stage, timer) in _stageTimers) {\n            var percentage = (timer.ElapsedMilliseconds / (double)totalTime) * 100;\n            LogInformation($\"  {stage}: {timer.ElapsedMilliseconds}ms ({percentage:F1}%)\");\n        }\n    }\n}\n```\n\n### Multi-Project Aggregation\n\n**Cross-assembly handler discovery** and registration:\n\n```csharp{\ntitle: \"Cross-Project Registry\"\ndescription: \"Generated registry that aggregates handlers across multiple projects\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"Design\", \"Source-Generation\", \"Multi-Project-Aggregation\", \"Code-Generation\"]\nframework: \"NET8\"\n}\n// Generated registry aggregates across projects\n[GeneratedCode(\"Whizbang.SourceGenerator\")]\npublic static class WhizbangGeneratedRegistry {\n    public static void RegisterAll(IServiceCollection services) {\n        // Handlers from current project\n        RegisterLocalHandlers(services);\n        \n        // Handlers from referenced projects\n        RegisterReferencedHandlers(services);\n        \n        // Domain ownership from all projects\n        RegisterDomainOwnership(services);\n        \n        // Policies from all projects\n        RegisterPolicies(services);\n    }\n    \n    private static void RegisterLocalHandlers(IServiceCollection services) {\n        services.AddScoped<ICommandHandler<PlaceOrder>, PlaceOrderHandler>();\n        services.AddScoped<IEventHandler<OrderPlaced>, OrderSummaryProjection>();\n        // ... other local handlers\n    }\n    \n    private static void RegisterReferencedHandlers(IServiceCollection services) {\n        // Handlers discovered from referenced assemblies\n        SharedLibrary.WhizbangRegistry.RegisterHandlers(services);\n        CoreDomain.WhizbangRegistry.RegisterHandlers(services);\n    }\n}\n```\n\n## IDE Navigation Service\n\n### Event Stream Navigation\n\n**GitLens-style navigation** through event streams and handlers:\n\n```csharp{\ntitle: \"Navigation Service\"\ndescription: \"Navigation service interface for GitLens-style event stream traversal\"\ncategory: \"Design\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Design\", \"IDE-Integration\", \"Navigation-Service\", \"Event-Stream-Navigation\"]\nframework: \"NET8\"\n}\npublic interface IWhizbangNavigationService {\n    Task<EventStreamInfo> GetEventStreamAsync(string streamId);\n    Task<IEnumerable<HandlerInfo>> GetHandlersForEventAsync(Type eventType);\n    Task<IEnumerable<ProjectionInfo>> GetProjectionsForEventAsync(Type eventType);\n    Task<EventFlowDiagram> GetEventFlowAsync(Type commandType);\n    Task<DomainMap> GetDomainMapAsync();\n}\n\n// Event flow visualization\npublic class EventFlowDiagram {\n    public CommandInfo Command { get; set; }\n    public HandlerInfo CommandHandler { get; set; }\n    public List<EventInfo> EmittedEvents { get; set; }\n    public Dictionary<EventInfo, List<HandlerInfo>> EventHandlers { get; set; }\n    public Dictionary<EventInfo, List<ProjectionInfo>> EventProjections { get; set; }\n    public List<SagaInfo> TriggeredSagas { get; set; }\n}\n\n```csharp{\ntitle: \"Code Lens Provider\"\ndescription: \"Code lens provider for displaying event flow information in IDE\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"Design\", \"IDE-Integration\", \"Code-Lens-Provider\", \"Event-Flow-Visualization\"]\nframework: \"NET8\"\n}\n// Usage in IDE extension\npublic class WhizbangCodeLensProvider : CodeLensProvider {\n    public override async Task<CodeLens[]> ProvideCodeLensesAsync(Document document) {\n        var semanticModel = await document.GetSemanticModelAsync();\n        var root = await document.GetSyntaxRootAsync();\n        \n        var codeLenses = new List<CodeLens>();\n        \n        // Find command handlers\n        foreach (var handlerClass in root.DescendantNodes().OfType<ClassDeclarationSyntax>()) {\n            if (IsCommandHandler(handlerClass, semanticModel)) {\n                var commandType = GetCommandType(handlerClass, semanticModel);\n                var eventFlow = await _navigationService.GetEventFlowAsync(commandType);\n                \n                codeLenses.Add(new CodeLens {\n                    Range = GetRange(handlerClass),\n                    Command = new Command {\n                        Title = $\"Emits {eventFlow.EmittedEvents.Count} events, triggers {eventFlow.EventHandlers.Count} handlers\",\n                        Arguments = new object[] { eventFlow }\n                    }\n                });\n            }\n        }\n        \n        return codeLenses.ToArray();\n    }\n}\n```\n\n### Generated Metadata\n\n**Rich metadata** for IDE integration:\n\n```json\n// Generated metadata file: WhizbangMetadata.json\n{\n  \"eventStreams\": {\n    \"Order-{orderId}\": {\n      \"aggregateType\": \"Order\",\n      \"domain\": \"Orders\",\n      \"events\": [\"OrderPlaced\", \"OrderUpdated\", \"OrderShipped\"],\n      \"handlers\": [\"OrderSummaryProjection\", \"OrderHistoryProjection\"],\n      \"sagas\": [\"OrderFulfillmentSaga\"]\n    }\n  },\n  \"handlers\": {\n    \"PlaceOrderHandler\": {\n      \"handlerType\": \"Command\",\n      \"inputType\": \"PlaceOrder\",\n      \"outputTypes\": [\"OrderPlaced\"],\n      \"domain\": \"Orders\",\n      \"sourceLocation\": \"OrderService/Handlers/PlaceOrderHandler.cs:15\"\n    }\n  },\n  \"projections\": {\n    \"OrderSummaryProjection\": {\n      \"projectionName\": \"order-summary\",\n      \"subscribedEvents\": [\"OrderPlaced\", \"OrderUpdated\", \"OrderShipped\"],\n      \"domain\": \"Orders\",\n      \"sourceLocation\": \"OrderService/Projections/OrderSummaryProjection.cs:8\"\n    }\n  },\n  \"domains\": {\n    \"Orders\": {\n      \"commands\": [\"PlaceOrder\", \"UpdateOrder\", \"ShipOrder\"],\n      \"events\": [\"OrderPlaced\", \"OrderUpdated\", \"OrderShipped\"],\n      \"handlers\": [\"PlaceOrderHandler\", \"UpdateOrderHandler\"],\n      \"projections\": [\"OrderSummaryProjection\", \"OrderHistoryProjection\"]\n    }\n  }\n}\n```\n\n## Code Analyzers & Fixes\n\n### Domain Ownership Validation\n\n**Compile-time enforcement** of domain ownership rules:\n\n```csharp{\ntitle: \"Domain Ownership Analyzer\"\ndescription: \"Roslyn analyzer for compile-time domain ownership validation\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"Design\", \"Code-Analyzers\", \"Domain-Ownership\", \"Compile-Time-Validation\"]\nframework: \"NET8\"\n}\n[DiagnosticAnalyzer(LanguageNames.CSharp)]\npublic class DomainOwnershipAnalyzer : DiagnosticAnalyzer {\n    public static readonly DiagnosticDescriptor CrossDomainHandlerRule = new(\n        \"WB001\",\n        \"Handler cannot handle command/event from different domain\",\n        \"Handler '{0}' in domain '{1}' cannot handle '{2}' from domain '{3}'\",\n        \"Domain Ownership\",\n        DiagnosticSeverity.Error,\n        isEnabledByDefault: true\n    );\n    \n    public override void Initialize(AnalysisContext context) {\n        context.RegisterSyntaxNodeAction(AnalyzeHandlerClass, SyntaxKind.ClassDeclaration);\n    }\n    \n    private void AnalyzeHandlerClass(SyntaxNodeAnalysisContext context) {\n        var classDeclaration = (ClassDeclarationSyntax)context.Node;\n        var semanticModel = context.SemanticModel;\n        \n        var handlerDomain = GetHandlerDomain(classDeclaration, semanticModel);\n        var handledTypes = GetHandledTypes(classDeclaration, semanticModel);\n        \n        foreach (var handledType in handledTypes) {\n            var messageDomain = GetMessageDomain(handledType, semanticModel);\n            \n            if (handlerDomain != messageDomain) {\n                var diagnostic = Diagnostic.Create(\n                    CrossDomainHandlerRule,\n                    classDeclaration.GetLocation(),\n                    classDeclaration.Identifier.ValueText,\n                    handlerDomain,\n                    handledType.Name,\n                    messageDomain\n                );\n                \n                context.ReportDiagnostic(diagnostic);\n            }\n        }\n    }\n}\n```\n\n### Code Fixes\n\n**Automatic fixes** for common patterns:\n\n```csharp{\ntitle: \"Code Fix Provider\"\ndescription: \"Code fix provider for automatic domain ownership attribute addition\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"Design\", \"Code-Fixes\", \"Domain-Ownership\", \"Automatic-Fixes\"]\nframework: \"NET8\"\n}\n[ExportCodeFixProvider(LanguageNames.CSharp)]\npublic class AddDomainOwnershipCodeFixProvider : CodeFixProvider {\n    public override async Task RegisterCodeFixesAsync(CodeFixContext context) {\n        var diagnostic = context.Diagnostics.FirstOrDefault(d => d.Id == \"WB002\");\n        if (diagnostic == null) return;\n        \n        var document = context.Document;\n        var root = await document.GetSyntaxRootAsync(context.CancellationToken);\n        var declaration = root.FindNode(diagnostic.Location.SourceSpan);\n        \n        // Offer to add [OwnedBy] attribute\n        var codeAction = CodeAction.Create(\n            title: \"Add [OwnedBy] attribute\",\n            createChangedDocument: c => AddOwnedByAttribute(document, declaration, c),\n            equivalenceKey: \"AddOwnedBy\"\n        );\n        \n        context.RegisterCodeFix(codeAction, diagnostic);\n    }\n    \n    private async Task<Document> AddOwnedByAttribute(Document document, SyntaxNode declaration, CancellationToken cancellationToken) {\n        var root = await document.GetSyntaxRootAsync(cancellationToken);\n        var inferredDomain = InferDomainFromNamespace(declaration);\n        \n        var attribute = SyntaxFactory.Attribute(\n            SyntaxFactory.IdentifierName(\"OwnedBy\"),\n            SyntaxFactory.AttributeArgumentList(\n                SyntaxFactory.SingletonSeparatedList(\n                    SyntaxFactory.AttributeArgument(\n                        SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, \n                            SyntaxFactory.Literal(inferredDomain))\n                    )\n                )\n            )\n        );\n        \n        var newDeclaration = AddAttributeToDeclaration(declaration, attribute);\n        var newRoot = root.ReplaceNode(declaration, newDeclaration);\n        \n        return document.WithSyntaxRoot(newRoot);\n    }\n}\n```\n\n## Debugging Integration\n\n### Transparent Generated Code\n\n**Clear, debuggable generated code** with source maps:\n\n```csharp{\ntitle: \"Debuggable Generated Code\"\ndescription: \"Clear, debuggable generated code with source maps and metadata\"\ncategory: \"Design\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Design\", \"Source-Generation\", \"Transparent-Code\", \"Debug-Experience\"]\nframework: \"NET8\"\n}\n// Generated handler registry with clear structure\n[GeneratedCode(\"Whizbang.SourceGenerator\", \"1.0.0\")]\npublic static partial class OrderServiceHandlerRegistry {\n    // Source: OrderService/Handlers/PlaceOrderHandler.cs\n    public static void RegisterPlaceOrderHandler(IServiceCollection services) {\n        services.AddScoped<ICommandHandler<PlaceOrder>, PlaceOrderHandler>();\n        \n        // Generated metadata for debugging\n        services.AddSingleton(new HandlerMetadata {\n            HandlerType = typeof(PlaceOrderHandler),\n            MessageType = typeof(PlaceOrder),\n            SourceFile = \"OrderService/Handlers/PlaceOrderHandler.cs\",\n            SourceLine = 15,\n            Domain = \"Orders\",\n            GeneratedAt = DateTimeOffset.Parse(\"2024-01-01T10:00:00Z\")\n        });\n    }\n    \n    // Source: OrderService/Projections/OrderSummaryProjection.cs  \n    public static void RegisterOrderSummaryProjection(IServiceCollection services) {\n        services.AddScoped<IProjectionHandler<OrderPlaced>, OrderSummaryProjection>();\n        services.AddScoped<IProjectionHandler<OrderUpdated>, OrderSummaryProjection>();\n        services.AddScoped<IProjectionHandler<OrderShipped>, OrderSummaryProjection>();\n        \n        // Register projection metadata\n        services.AddSingleton(new ProjectionMetadata {\n            ProjectionType = typeof(OrderSummaryProjection),\n            ProjectionName = \"order-summary\",\n            SubscribedEvents = new[] { typeof(OrderPlaced), typeof(OrderUpdated), typeof(OrderShipped) },\n            SourceFile = \"OrderService/Projections/OrderSummaryProjection.cs\",\n            SourceLine = 8,\n            Domain = \"Orders\"\n        });\n    }\n}\n```\n\n### Debug Experience Enhancements\n\n**No \"magic\" - clear understanding** of what's happening:\n\n```csharp{\ntitle: \"Debug-Friendly Registration\"\ndescription: \"Debug-friendly service registration with detailed logging\"\ncategory: \"Design\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Design\", \"Source-Generation\", \"Debug-Experience\", \"Service-Registration\"]\nframework: \"NET8\"\n}\n// Debug-friendly service registration\npublic static class WhizbangServiceCollectionExtensions {\n    public static IServiceCollection AddWhizbangGeneratedServices(this IServiceCollection services) {\n        if (IsDebugMode()) {\n            // In debug mode, show detailed registration logging\n            services.AddSingleton<IHandlerRegistrationLogger, DetailedHandlerRegistrationLogger>();\n        }\n        \n        // Call generated registration methods\n        OrderServiceHandlerRegistry.RegisterAll(services);\n        \n        return services;\n    }\n}\n\npublic class DetailedHandlerRegistrationLogger : IHandlerRegistrationLogger {\n    public void LogHandlerRegistration<TMessage, THandler>(string sourceFile, int sourceLine) {\n        Console.WriteLine($\"Registering handler {typeof(THandler).Name} for {typeof(TMessage).Name}\");\n        Console.WriteLine($\"  Source: {sourceFile}:{sourceLine}\");\n        Console.WriteLine($\"  Service lifetime: Scoped\");\n    }\n}\n```\n\n## Performance Optimizations\n\n### Incremental Generation\n\n**Only regenerate what changed** for fast incremental builds:\n\n```csharp{\ntitle: \"Incremental Generation Context\"\ndescription: \"Incremental generation context for tracking file changes and optimization\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"Design\", \"Source-Generation\", \"Incremental-Generation\", \"Performance-Optimization\"]\nframework: \"NET8\"\n}\npublic class IncrementalGenerationContext {\n    private readonly ConcurrentDictionary<string, string> _fileHashes = new();\n    \n    public bool HasFileChanged(string filePath, string content) {\n        var currentHash = ComputeHash(content);\n        var previousHash = _fileHashes.GetValueOrDefault(filePath);\n        \n        if (currentHash != previousHash) {\n            _fileHashes[filePath] = currentHash;\n            return true;\n        }\n        \n        return false;\n    }\n    \n    public void TrackGeneratedOutput(string outputKey, string content) {\n        // Track what we generated so we can skip unchanged outputs\n        _generatedOutputs[outputKey] = ComputeHash(content);\n    }\n}\n```\n\n### Compilation Performance\n\n**Optimize for IDE experience**:\n\n- **Syntax-only analysis** for most validations\n- **Semantic analysis** only when necessary\n- **Caching** of expensive operations\n- **Parallel processing** of independent analysis\n- **Early termination** when errors are found\n\n## Best Practices\n\n### Generator Design\n\n1. **Keep generators focused** - Single responsibility per generator stage\n2. **Minimize semantic model usage** - Use syntax analysis when possible\n3. **Cache expensive operations** - Avoid redundant analysis\n4. **Provide clear diagnostics** - Help developers understand issues\n5. **Generate debuggable code** - Include source references and metadata\n\n### IDE Integration\n\n1. **Responsive navigation** - Fast lookups and searches\n2. **Contextual information** - Show relevant details for current location\n3. **Clear visualizations** - Easy to understand flow diagrams\n4. **Helpful code lenses** - Actionable information overlays\n5. **Intelligent suggestions** - Context-aware code completion\n\n### Debug Experience\n\n1. **No hidden magic** - Everything should be discoverable\n2. **Clear error messages** - Point to exact problems and solutions\n3. **Source mapping** - Connect generated code to source\n4. **Metadata preservation** - Keep debug information through compilation\n5. **Performance transparency** - Show timing and costs\n\n",
        "tags": "source-generation, ide-integration, analyzers, navigation, debugging",
        "version": "proposals"
      },
      {
        "slug": "proposals/testing-development-tools",
        "title": "Testing & Development Tools",
        "category": "Architecture & Design",
        "order": 13,
        "description": "\n# Testing & Development Tools\n\nWhizbang provides comprehensive testing utilities and development tools to ensure a productive developer experience from local development to production deployment.\n\n## Testing Framework\n\n### Whizbang.Testing Package\n\n**Comprehensive testing library** with fluent APIs for all Whizbang scenarios:\n\n```csharp{title=\"Installing Whizbang Testing Package\" description=\"Installing and setting up the Whizbang testing package\" category=\"Design\" difficulty=\"BEGINNER\" tags=[\"Design\", \"Testing\", \"Package-Installation\", \"Setup\"] framework=\"NET8\"}\n// Install the testing package\ndotnet add package Whizbang.Testing\n\n```csharp{title=\"Test Fixture Setup\" description=\"Test fixture setup with in-memory drivers for fast unit testing\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Testing\", \"Test-Fixtures\", \"In-Memory-Drivers\"] framework=\"NET8\"}\n// Test fixture setup\npublic class OrderServiceTests {\n    private readonly WhizbangTestFixture _fixture;\n    \n    public OrderServiceTests() {\n        _fixture = new WhizbangTestFixture()\n            .UseInMemoryEventStore()\n            .UseInMemoryProjections()\n            .UseInMemoryMessageBroker()\n            .ConfigureServices(services => {\n                services.AddScoped<IOrderService, OrderService>();\n                services.AddScoped<ICustomerService, MockCustomerService>();\n            });\n    }\n}\n```\n\n### Event Sourcing Test Helpers\n\n**Given/When/Then fluent API** for event sourcing scenarios:\n\n```csharp{title=\"Given/When/Then Event Sourcing Tests\" description=\"Given/When/Then fluent API for event sourcing test scenarios\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Testing\", \"Given-When-Then\", \"Event-Sourcing\"] framework=\"NET8\"}\n[Test]\npublic async Task PlaceOrder_WithValidCustomer_ShouldEmitOrderPlaced() {\n    // Arrange & Act & Assert in fluent chain\n    await _fixture\n        .Given(\n            new CustomerRegistered(customerId, \"John Doe\", \"john@example.com\"),\n            new ProductCreated(productId, \"Widget\", 10.00m)\n        )\n        .When(new PlaceOrder(orderId, customerId, new[] { \n            new OrderItem(productId, 2, 10.00m) \n        }))\n        .Then()\n        .ShouldEmitEvent<OrderPlaced>()\n        .WithProperty(e => e.OrderId, orderId)\n        .WithProperty(e => e.CustomerId, customerId)\n        .WithProperty(e => e.Total, 20.00m)\n        .And()\n        .ShouldNotEmitEvent<OrderRejected>();\n}\n\n```csharp{title=\"Error Scenario Testing\" description=\"Testing error scenarios with event validation assertions\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Testing\", \"Error-Scenarios\", \"Event-Validation\"] framework=\"NET8\"}\n[Test]\npublic async Task PlaceOrder_WithInvalidCustomer_ShouldEmitOrderRejected() {\n    await _fixture\n        .Given() // No customer registered\n        .When(new PlaceOrder(orderId, customerId, items))\n        .Then()\n        .ShouldEmitEvent<OrderRejected>()\n        .WithProperty(e => e.Reason, \"Customer not found\")\n        .And()\n        .ShouldNotEmitEvent<OrderPlaced>();\n}\n```\n\n### Projection Testing\n\n**Feed events and assert projection state**:\n\n```csharp{title=\"Projection Lifecycle Testing\" description=\"Projection testing with event feeding and state assertions\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Testing\", \"Projections\", \"Lifecycle-Testing\"] framework=\"NET8\"}\n[Test]\npublic async Task OrderSummaryProjection_ShouldTrackOrderLifecycle() {\n    await _fixture\n        .ForProjection<OrderSummaryProjection>()\n        .GivenEvents(\n            new OrderPlaced(orderId, customerId, 100.00m, DateTimeOffset.UtcNow),\n            new OrderShipped(orderId, \"TRACK123\", DateTimeOffset.UtcNow.AddDays(1))\n        )\n        .WhenProjectionRuns()\n        .ThenProjection<OrderSummary>(orderId.ToString())\n        .ShouldExist()\n        .ShouldHaveProperty(s => s.Status, OrderStatus.Shipped)\n        .ShouldHaveProperty(s => s.Total, 100.00m)\n        .ShouldHaveProperty(s => s.TrackingNumber, \"TRACK123\");\n}\n\n[Test]\npublic async Task OrderSummaryProjection_WithMissingEvents_ShouldHandleGracefully() {\n    await _fixture\n        .ForProjection<OrderSummaryProjection>()\n        .GivenEvents(\n            new OrderShipped(orderId, \"TRACK123\", DateTimeOffset.UtcNow) // No OrderPlaced\n        )\n        .WhenProjectionRuns()\n        .ThenProjection<OrderSummary>(orderId.ToString())\n        .ShouldNotExist(); // Projection should handle missing OrderPlaced gracefully\n}\n```\n\n### Policy Testing\n\n**Test policy rules and combinations**:\n\n```csharp{title=\"Policy Rule Testing\" description=\"Testing policy rules and their effects on system behavior\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Testing\", \"Policy-Testing\", \"Load-Testing\"] framework=\"NET8\"}\n[Test]\npublic async Task LoadTestingPolicy_ShouldSkipProjections() {\n    await _fixture\n        .ForPolicy(\"LoadTestingPolicy\")\n        .GivenContext(ctx => ctx.WithFlag(WhizbangFlags.LoadTesting))\n        .GivenMessage(new OrderPlaced(orderId, customerId, 100.00m))\n        .WhenPolicyEvaluates()\n        .ThenActions()\n        .ShouldContain<SkipProjectionsAction>()\n        .ShouldContain<AddTagAction>(action => action.Tag == \"load-test-processed\");\n}\n\n[Test]\npublic async Task VIPCustomerPolicy_ShouldRouteToSpecialHandler() {\n    await _fixture\n        .ForPolicy(\"VIPCustomerPolicy\")\n        .GivenContext(ctx => ctx.WithTag(\"customer-vip\"))\n        .GivenMessage(new PlaceOrder(orderId, customerId, items))\n        .WhenPolicyEvaluates()\n        .ThenActions()\n        .ShouldContain<RouteToHandlerAction<VIPOrderHandler>>();\n}\n```\n\n### Saga Testing\n\n**Test long-running process coordination**:\n\n```csharp{title=\"Saga Workflow Testing\" description=\"Testing long-running saga workflows with command coordination\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Testing\", \"Sagas\", \"Workflow-Coordination\"] framework=\"NET8\"}\n[Test]\npublic async Task OrderFulfillmentSaga_ShouldCoordinateFullWorkflow() {\n    await _fixture\n        .ForSaga<OrderFulfillmentSaga>()\n        .GivenEvents(\n            new OrderPlaced(orderId, customerId, items)\n        )\n        .WhenSagaRuns()\n        .ThenCommands()\n        .ShouldContain<ReserveInventory>(cmd => cmd.OrderId == orderId)\n        .And()\n        .WhenEvent(new InventoryReserved(orderId, items))\n        .ThenCommands()\n        .ShouldContain<ChargePayment>(cmd => cmd.OrderId == orderId)\n        .And()\n        .WhenEvent(new PaymentCharged(orderId, 100.00m))\n        .ThenCommands()\n        .ShouldContain<ShipOrder>(cmd => cmd.OrderId == orderId);\n}\n```\n\n### Integration Testing\n\n**Real drivers with test containers**:\n\n```csharp{title=\"Integration Testing with TestContainers\" description=\"Integration testing with real infrastructure using TestContainers\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Testing\", \"Integration-Testing\", \"TestContainers\"] framework=\"NET8\"}\n[Test]\npublic async Task OrderService_IntegrationTest_WithRealDatabase() {\n    // Uses TestContainers for real PostgreSQL\n    await using var fixture = new WhizbangIntegrationTestFixture()\n        .UseTestContainerPostgres()\n        .UseTestContainerKafka()\n        .ConfigureServices(services => {\n            services.AddOrderService();\n            services.AddInventoryService();\n        });\n    \n    await fixture.StartAsync();\n    \n    // Test with real infrastructure\n    var result = await fixture\n        .Given(/* setup data in real database */)\n        .When(new PlaceOrder(orderId, customerId, items))\n        .Then()\n        .ShouldEmitEvent<OrderPlaced>()\n        .And()\n        .ShouldHaveProjection<OrderSummary>(orderId.ToString())\n        .InDatabase(); // Verify in real database\n}\n```\n\n## Development Tools Suite\n\n### CLI Tool (whizbang-cli)\n\n**Comprehensive command-line interface** for project management:\n\n```bash\n",
        "tags": "testing, development-tools, cli, ide-extensions, dashboard",
        "version": "proposals"
      }
    ]
  },
  {
    "state": "backlog",
    "metadata": {
      "folderType": "state",
      "state": "backlog",
      "description": "Approved features awaiting scheduling and development"
    },
    "docs": []
  },
  {
    "state": "declined",
    "metadata": {
      "folderType": "state",
      "state": "declined",
      "description": "Declined proposals archived for reference"
    },
    "docs": []
  }
]