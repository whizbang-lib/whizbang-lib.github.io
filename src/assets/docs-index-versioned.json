[
  {
    "version": "v0.1.0",
    "metadata": {
      "title": "Version 0.1.0 - Foundation",
      "description": "The foundation release establishing all core components with in-memory implementations",
      "releaseDate": "TBD",
      "status": "planning"
    },
    "docs": [
      {
        "slug": "v0.1.0/README",
        "title": "Version 0.1.0 - Foundation Release",
        "category": "Implementation",
        "order": 1,
        "description": "The foundation release of Whizbang establishing all core components with comprehensive testing and IDE support",
        "tags": "v0.1.0, foundation, implementation",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/advanced-topics/deployment-strategies",
        "title": "Deployment Strategies",
        "category": "Advanced Topics",
        "order": 7,
        "description": "Deployment patterns - blue-green, canary, rolling updates, feature flags, and rollback strategies",
        "tags": "deployment, blue-green, canary, rolling-update, feature-flags, kubernetes",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/advanced-topics/monitoring",
        "title": "Monitoring & Observability",
        "category": "Advanced Topics",
        "order": 6,
        "description": "Application monitoring - Application Insights, Prometheus, distributed tracing, metrics, and dashboards",
        "tags": "monitoring, observability, application-insights, prometheus, tracing, metrics",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/advanced-topics/multi-tenancy",
        "title": "Multi-Tenancy Patterns",
        "category": "Advanced Topics",
        "order": 4,
        "description": "Multi-tenancy architecture patterns - database-per-tenant, schema-per-tenant, row-level security",
        "tags": "multi-tenancy, saas, database-per-tenant, row-level-security, isolation",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/advanced-topics/native-aot",
        "title": "Native AOT",
        "category": "Advanced Topics",
        "order": 3,
        "description": "Deploy with Native AOT - zero reflection, trim-safe code, and AOT-compatible patterns",
        "tags": "native-aot, aot, reflection, trim-safe, deployment",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/advanced-topics/performance-tuning",
        "title": "Performance Tuning",
        "category": "Advanced Topics",
        "order": 1,
        "description": "Optimize Whizbang performance - zero-allocation patterns, pooling, batching, and profiling",
        "tags": "performance, optimization, profiling, zero-allocation, pooling",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/advanced-topics/scaling",
        "title": "Scaling Patterns",
        "category": "Advanced Topics",
        "order": 8,
        "description": "Horizontal scaling - autoscaling, partitioning, load balancing, and performance under load",
        "tags": "scaling, horizontal-scaling, partitioning, load-balancing, autoscaling, performance",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/advanced-topics/security",
        "title": "Security Best Practices",
        "category": "Advanced Topics",
        "order": 5,
        "description": "Security guidelines - authentication, authorization, encryption, secrets management, OWASP Top 10",
        "tags": "security, authentication, authorization, encryption, owasp, secrets",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/advanced-topics/testing-receptors",
        "title": "Testing Receptors & Perspectives",
        "category": "Advanced Topics",
        "order": 2,
        "description": "Unit testing patterns for receptors and perspectives - mocking, fixtures, and test strategies",
        "tags": "testing, unit-tests, mocking, tunit, fixtures",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/advanced-topics/troubleshooting",
        "title": "Troubleshooting Guide",
        "category": "Advanced Topics",
        "order": 9,
        "description": "Common issues, debugging techniques, diagnostic tools, and solutions",
        "tags": "troubleshooting, debugging, diagnostics, common-issues, solutions",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/architecture/message-lifecycle",
        "title": "Message Lifecycle & Architecture",
        "category": "Architecture",
        "order": 1,
        "description": "Complete guide to message flow through Whizbang - Commands, Events, Work Coordinator, and all the hooks between Dispatcher, Receptors, Perspectives, and Outbox/Inbox",
        "tags": "architecture, message-lifecycle, command-flow, event-flow, work-coordinator, sequence-diagrams",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/attributes/streamkey",
        "title": "StreamKey Attribute",
        "category": "Attributes",
        "order": 999,
        "description": "Marks a property as the stream key for event sourcing and perspective event ordering",
        "tags": [
          "attributes",
          "streamkey",
          "perspectives",
          "event-sourcing",
          "source-generator"
        ],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/components/README",
        "title": "Core Components Overview",
        "category": "Components",
        "order": 1,
        "description": "Overview of all core components in Whizbang v0.1.0",
        "tags": "components, architecture, overview",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/components/dispatcher",
        "title": "Dispatcher Component",
        "category": "Components",
        "order": 2,
        "description": "Core message routing and orchestration with basic handler discovery",
        "tags": "dispatcher, routing, orchestration, mediator, v0.1.0",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/components/drivers",
        "title": "Drivers Component",
        "category": "Components",
        "order": 8,
        "description": "Basic in-memory storage driver for development and testing",
        "tags": "drivers, storage, in-memory, abstraction, v0.1.0",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/components/ledger",
        "title": "Ledger Component",
        "category": "Components",
        "order": 7,
        "description": "In-memory event store with basic append and read operations",
        "tags": "ledger, event-store, events, in-memory, v0.1.0",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/components/lenses",
        "title": "Lenses Component",
        "category": "Components",
        "order": 5,
        "description": "Read-only interfaces for querying data - the query side of Whizbang's CQRS implementation",
        "tags": "lenses, queries, read-model, cqrs, v0.1.0",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/components/perspectives",
        "title": "Perspectives Component",
        "category": "Components",
        "order": 4,
        "description": "Event handlers that update various views of your data - the write side of Whizbang",
        "tags": "perspectives, events, views, write-model, v0.1.0",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/components/policy-engine",
        "title": "Policy Engine Component",
        "category": "Components",
        "order": 6,
        "description": "Cross-cutting concerns as composable policies - retry, timeout, cache, and circuit breaker",
        "tags": "policies, cross-cutting, resilience, caching, v0.1.0",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/components/receptors",
        "title": "Receptors Component",
        "category": "Components",
        "order": 3,
        "description": "Command receivers that make decisions and emit events - the foundation of Whizbang's event-driven architecture",
        "tags": "receptors, commands, events, stateless, v0.1.0",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/components/transports",
        "title": "Transports Component",
        "category": "Components",
        "order": 9,
        "description": "Basic in-process message transport for local development",
        "tags": "transports, messaging, in-process, communication, v0.1.0",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/core-concepts/audit-logging",
        "title": "Audit Logging",
        "category": "Core Concepts",
        "order": 7,
        "description": "Implement compliance-ready audit logging using Whizbang's System Events - capture who changed what, when, and why",
        "tags": "audit, compliance, logging, system-events, perspectives, security, gdpr, sox",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/core-concepts/dispatcher",
        "title": "Dispatcher Deep Dive",
        "category": "Core Concepts",
        "order": 1,
        "description": "Master the Whizbang Dispatcher - three dispatch patterns (SendAsync, LocalInvokeAsync, PublishAsync) for commands, queries, and events",
        "tags": "dispatcher, messaging, commands, events, patterns",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/core-concepts/event-store-query",
        "title": "Event Store Query",
        "category": "Core Concepts",
        "order": 10,
        "description": "Query raw events in the event store with full LINQ support and automatic scope filtering",
        "tags": "events, query, linq, ef-core, multi-tenancy",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/core-concepts/fuzzy-matching",
        "title": "Fuzzy Matching",
        "category": "Core Concepts",
        "order": 999,
        "description": "# MatchStrictness: Fuzzy Type Matching Control\n\nMatchStrictness is a flag enum that controls how type names are compared during fuzzy matching. It enables flexible type matching by allowing you to ignore case, version, assembly, or namespace components.\n\n## Overview\n\n**MatchStrictness** provides:\n- ✅ Flag-based control over type matching behavior\n- ✅ Combinable flags for precise matching rules\n- ✅ Composite presets for common scenarios\n- ✅ Works with both formatted and raw type strings\n- ✅ Used by message association queries and type matching APIs\n\n## Quick Start\n\n### Basic Fuzzy Matching\n\n```csharp\nusing Whizbang.Core;\n\nvar fullType = \"ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts, Version=1.0.0\";\nvar simpleType = \"ProductCreatedEvent\";\n\n// Exact match (default)\nbool exactMatch = TypeMatcher.Matches(fullType, simpleType, MatchStrictness.Exact);\n// Result: false (types don't match exactly)\n\n// Simple name match (ignore namespace, assembly, version)\nbool simpleMatch = TypeMatcher.Matches(fullType, simpleType, MatchStrictness.SimpleName);\n// Result: true (both have \"ProductCreatedEvent\")\n\n// Case-insensitive match\nbool caseMatch = TypeMatcher.Matches(\n    \"ProductCreatedEvent\",\n    \"productcreatedevent\",\n    MatchStrictness.CaseInsensitive\n);\n// Result: true (case ignored)\n```\n\n### Combining Multiple Flags\n\n```csharp\n// Ignore both case AND version\nvar strictness = MatchStrictness.IgnoreCase | MatchStrictness.IgnoreVersion;\n\nbool match = TypeMatcher.Matches(\n    \"MyApp.Events.OrderCreated, MyApp, Version=1.0.0\",\n    \"myapp.events.ordercreated, myapp, version=2.0.0\",\n    strictness\n);\n// Result: true (version and case ignored)\n\n// Ignore namespace and case\nvar flexibleMatch = MatchStrictness.IgnoreNamespace | MatchStrictness.IgnoreCase;\n\nbool matches = TypeMatcher.Matches(\n    \"ECommerce.Events.ProductCreated\",\n    \"productcreated\",\n    flexibleMatch\n);\n// Result: true (namespace and case ignored)\n```\n\n## Individual Flags\n\n### Flag Definitions\n\nEach flag controls a specific transformation applied to type strings before comparison:\n\n| Flag | Value | Description |\n|",
        "tags": [],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/core-concepts/lenses",
        "title": "Lenses Guide",
        "category": "Core Concepts",
        "order": 4,
        "description": "Master Whizbang Lenses - query-optimized repositories for fast, efficient access to read models maintained by Perspectives",
        "tags": "lenses, queries, read-models, repositories, cqrs",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/core-concepts/lifecycle-receptors",
        "title": "Lifecycle Receptors",
        "category": "Core Concepts",
        "order": 10,
        "description": "Complete API reference for lifecycle receptors - [FireAt] attribute, ILifecycleContext injection, compile-time vs runtime registration, and AOT-compatible patterns",
        "tags": "lifecycle, receptors, FireAt, attributes, ILifecycleContext, AOT, source-generators",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/core-concepts/lifecycle-stages",
        "title": "Lifecycle Stages",
        "category": "Core Concepts",
        "order": 9,
        "description": "Complete reference for all 20 lifecycle stages in Whizbang message processing pipeline - timing, guarantees, and use cases",
        "tags": "lifecycle, stages, hooks, message-processing, timing",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/core-concepts/message-context",
        "title": "Message Context & Tracing",
        "category": "Core Concepts",
        "order": 5,
        "description": "Track message flow across distributed systems with MessageId, CorrelationId, and CausationId - automatic distributed tracing built into Whizbang",
        "tags": "message-context, correlation, causation, distributed-tracing, observability",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/core-concepts/observability",
        "title": "Observability & Message Hops",
        "category": "Core Concepts",
        "order": 6,
        "description": "Understand Whizbang's hop-based observability architecture - MessageEnvelope and MessageHop for distributed tracing and debugging",
        "tags": "observability, message-hops, distributed-tracing, debugging, telemetry",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/core-concepts/perspectives/association-info",
        "title": "Association Info",
        "category": "Core Concepts",
        "order": 999,
        "description": "# PerspectiveAssociationInfo: Strongly-Typed Associations with Delegates\n\nPerspectiveAssociationInfo is a generic record type that provides strongly-typed perspective associations with AOT-compatible delegates to perspective Apply methods. It enables compile-time type safety and performant perspective invocation without reflection.\n\n## Overview\n\n**PerspectiveAssociationInfo&lt;TModel, TEvent&gt;** provides:\n- ✅ Strongly-typed delegate access to perspective Apply methods\n- ✅ Compile-time type safety (no runtime type checks)\n- ✅ AOT-compatible (zero reflection at runtime)\n- ✅ Generated by source generators for all perspectives\n- ✅ Supports generic perspective invocation\n\n## Quick Start\n\n### Getting Typed Associations\n\n```csharp\nusing Whizbang.Core.Generated;\n\n// Get associations for specific model and event types\nvar associations = PerspectiveRegistrationExtensions\n    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(\"ECommerce.BFF.API\");\n\nforeach (var assoc in associations) {\n    Console.WriteLine($\"Perspective: {assoc.TargetName}\");\n    Console.WriteLine($\"Event: {assoc.MessageType}\");\n    Console.WriteLine($\"Service: {assoc.ServiceName}\");\n\n    // Invoke delegate directly\n    var currentModel = new ProductModel();\n    var evt = new ProductCreatedEvent { ProductId = \"prod-123\" };\n    var updatedModel = assoc.ApplyDelegate(currentModel, evt);\n}\n```\n\n### Using Delegates\n\n```csharp\n// Example: Generic perspective applier\npublic TModel ApplyEvent<TModel, TEvent>(\n    TModel model,\n    TEvent evt,\n    string serviceName)\n    where TEvent : IEvent {\n\n    var associations = PerspectiveRegistrationExtensions\n        .GetPerspectiveAssociations<TModel, TEvent>(serviceName);\n\n    // Apply all matching perspectives\n    foreach (var assoc in associations) {\n        model = assoc.ApplyDelegate(model, evt);\n    }\n\n    return model;\n}\n\n// Usage\nvar productModel = new ProductModel();\nvar productEvent = new ProductCreatedEvent { ProductId = \"prod-123\" };\nvar updated = ApplyEvent(productModel, productEvent, \"ECommerce.BFF.API\");\n```\n\n## Record Structure\n\n### Type Definition\n\n```csharp\n/// <summary>\n/// Rich association info with strongly-typed delegate for perspective Apply method.\n/// Provides compile-time type safety and AOT-compatible delegate invocation.\n/// </summary>\n/// <typeparam name=\"TModel\">The model type maintained by the perspective</typeparam>\n/// <typeparam name=\"TEvent\">The event type handled by the perspective</typeparam>\n/// <param name=\"MessageType\">Fully qualified event type name</param>\n/// <param name=\"TargetName\">Name of the perspective class</param>\n/// <param name=\"ServiceName\">Service name (assembly name)</param>\n/// <param name=\"ApplyDelegate\">Strongly-typed delegate to perspective's Apply method</param>\npublic sealed record PerspectiveAssociationInfo<TModel, TEvent>(\n    string MessageType,\n    string TargetName,\n    string ServiceName,\n    Func<TModel, TEvent, TModel> ApplyDelegate\n) where TEvent : IEvent;\n```\n\n### Properties\n\n| Property | Type | Description |\n|",
        "tags": [],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/core-concepts/perspectives/multi-stream",
        "title": "Multi-Stream Perspectives",
        "category": "Core Concepts",
        "order": 1,
        "description": "IGlobalPerspectiveFor pattern for aggregating events across multiple streams using partition keys - inspired by Marten's MultiStreamProjection",
        "tags": "perspectives, multi-stream, global-perspectives, partition-key, cross-stream, aggregation, read-models, marten",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/core-concepts/perspectives/typed-associations",
        "title": "Typed Associations",
        "category": "Core Concepts",
        "order": 999,
        "description": "# GetPerspectiveAssociations: Strongly-Typed Perspective Queries\n\nGetPerspectiveAssociations is a source-generated method that returns strongly-typed perspective associations filtered by model and event type. It provides compile-time type safety and AOT-compatible delegate access to perspective Apply methods.\n\n## Overview\n\n**GetPerspectiveAssociations&lt;TModel, TEvent&gt;** provides:\n- ✅ Type-filtered perspective associations\n- ✅ Compile-time type checking with generic constraints\n- ✅ AOT-compatible delegates (zero reflection)\n- ✅ Empty array for non-matching types\n- ✅ Source-generated for all discovered perspectives\n\n## Quick Start\n\n### Basic Usage\n\n```csharp\nusing Whizbang.Core.Generated;\n\n// Get all perspectives handling ProductCreatedEvent for ProductModel\nvar associations = PerspectiveRegistrationExtensions\n    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(\"ECommerce.BFF.API\");\n\n// Iterate and invoke\nvar model = new ProductModel();\nvar evt = new ProductCreatedEvent { ProductId = \"prod-123\" };\n\nforeach (var assoc in associations) {\n    Console.WriteLine($\"Applying: {assoc.TargetName}\");\n    model = assoc.ApplyDelegate(model, evt);\n}\n\nConsole.WriteLine($\"Final model: {model}\");\n```\n\n### Type Safety\n\n```csharp\n// Compile-time type safety ensures matching types\nvar associations = PerspectiveRegistrationExtensions\n    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);\n\n// Compiler enforces correct types\nvar productModel = new ProductModel();\nvar productEvent = new ProductCreatedEvent();\n\nforeach (var assoc in associations) {\n    // ✅ Types match - compiles\n    productModel = assoc.ApplyDelegate(productModel, productEvent);\n}\n\n// ❌ Won't compile - type mismatch\nvar orderEvent = new OrderCreatedEvent();\nproductModel = assoc.ApplyDelegate(productModel, orderEvent); // Compiler error!\n```\n\n## Method Signature\n\n### Declaration\n\n```csharp\nnamespace Whizbang.Core.Generated;\n\npublic static class PerspectiveRegistrationExtensions {\n    /// <summary>\n    /// Gets strongly-typed perspective associations with AOT-compatible delegates.\n    /// Returns associations only for the specified TModel and TEvent types.\n    /// Uses compile-time type checking - no reflection.\n    /// </summary>\n    /// <typeparam name=\"TModel\">The model type to filter by</typeparam>\n    /// <typeparam name=\"TEvent\">The event type to filter by</typeparam>\n    /// <param name=\"serviceName\">The service name (assembly name)</param>\n    /// <returns>Read-only list of typed perspective associations with delegates</returns>\n    public static IReadOnlyList<PerspectiveAssociationInfo<TModel, TEvent>>\n        GetPerspectiveAssociations<TModel, TEvent>(string serviceName)\n        where TEvent : IEvent;\n}\n```\n\n### Parameters\n\n- **serviceName**: Service name / assembly name (e.g., \"ECommerce.BFF.API\")\n\n### Type Parameters\n\n- **TModel**: Model type maintained by perspectives\n  - No constraints (can be any type)\n  - Must match perspective's `IPerspectiveFor<TModel, TEvent>` first type argument\n\n- **TEvent**: Event type handled by perspectives\n  - Must implement `IEvent` interface\n  - Must match perspective's `IPerspectiveFor<TModel, TEvent>` second type argument\n\n### Return Value\n\n- Returns `IReadOnlyList<PerspectiveAssociationInfo<TModel, TEvent>>`\n- Returns empty list if no perspectives match the specified types\n- Never returns null\n- List is immutable (read-only)\n\n## Generated Code Structure\n\n### How It Works\n\nThe source generator produces compile-time type checks for each perspective:\n\n```csharp\n// Generated method (simplified example)\npublic static IReadOnlyList<PerspectiveAssociationInfo<TModel, TEvent>>\n    GetPerspectiveAssociations<TModel, TEvent>(string serviceName)\n    where TEvent : IEvent {\n\n    // ProductPerspective: IPerspectiveFor<ProductModel, ProductCreatedEvent>\n    if (typeof(TModel) == typeof(ProductModel) &&\n        typeof(TEvent) == typeof(ProductCreatedEvent)) {\n\n        return new[] {\n            new PerspectiveAssociationInfo<TModel, TEvent>(\n                \"ECommerce.Contracts.Events.ProductCreatedEvent\",\n                \"ProductPerspective\",\n                \"ECommerce.BFF.API\",\n                (model, evt) => {\n                    var perspective = new ProductPerspective();\n                    var typedModel = (ProductModel)((object)model);\n                    var typedEvent = (ProductCreatedEvent)((object)evt);\n                    var result = perspective.Apply(typedModel, typedEvent);\n                    return (TModel)((object)result);\n                }\n            )\n        };\n    }\n\n    // OrderPerspective: IPerspectiveFor<OrderModel, OrderCreatedEvent>\n    if (typeof(TModel) == typeof(OrderModel) &&\n        typeof(TEvent) == typeof(OrderCreatedEvent)) {\n\n        return new[] {\n            new PerspectiveAssociationInfo<TModel, TEvent>(\n                \"ECommerce.Contracts.Events.OrderCreatedEvent\",\n                \"OrderPerspective\",\n                \"ECommerce.BFF.API\",\n                (model, evt) => {\n                    var perspective = new OrderPerspective();\n                    var typedModel = (OrderModel)((object)model);\n                    var typedEvent = (OrderCreatedEvent)((object)evt);\n                    var result = perspective.Apply(typedModel, typedEvent);\n                    return (TModel)((object)result);\n                }\n            )\n        };\n    }\n\n    // No match - return empty\n    return Array.Empty<PerspectiveAssociationInfo<TModel, TEvent>>();\n}\n```\n\n### AOT Compatibility\n\nKey features ensuring AOT compatibility:\n\n1. **Compile-time type checking**: Uses `typeof()` comparisons\n2. **Direct instantiation**: Uses `new` keyword (no `Activator.CreateInstance`)\n3. **Direct method calls**: No `MethodInfo.Invoke`\n4. **No reflection**: All types known at compile time\n5. **Trim-safe**: No dynamic type loading\n\n## Common Scenarios\n\n### Scenario 1: Generic Event Processor\n\n**When**: Building a generic event processing pipeline\n\n```csharp\npublic class EventProcessor {\n    private readonly string _serviceName;\n\n    public EventProcessor(string serviceName) {\n        _serviceName = serviceName;\n    }\n\n    public TModel ProcessEvent<TModel, TEvent>(TModel model, TEvent evt)\n        where TEvent : IEvent {\n\n        // Get associations for this model/event combination\n        var associations = PerspectiveRegistrationExtensions\n            .GetPerspectiveAssociations<TModel, TEvent>(_serviceName);\n\n        if (!associations.Any()) {\n            throw new InvalidOperationException(\n                $\"No perspectives found for {typeof(TModel).Name} + {typeof(TEvent).Name}\"\n            );\n        }\n\n        // Apply all matching perspectives\n        foreach (var assoc in associations) {\n            model = assoc.ApplyDelegate(model, evt);\n        }\n\n        return model;\n    }\n}\n\n// Usage\nvar processor = new EventProcessor(\"ECommerce.BFF.API\");\nvar updatedProduct = processor.ProcessEvent(productModel, productCreatedEvent);\nvar updatedOrder = processor.ProcessEvent(orderModel, orderCreatedEvent);\n```\n\n### Scenario 2: Event Replay Engine\n\n**When**: Replaying historical events to rebuild state\n\n```csharp\npublic class EventReplayEngine {\n    public async Task<TModel> ReplayAsync<TModel, TEvent>(\n        TModel initialModel,\n        IAsyncEnumerable<TEvent> events,\n        string serviceName)\n        where TEvent : IEvent {\n\n        // Get associations once (before loop)\n        var associations = PerspectiveRegistrationExtensions\n            .GetPerspectiveAssociations<TModel, TEvent>(serviceName);\n\n        if (!associations.Any()) {\n            return initialModel; // No perspectives, return unchanged\n        }\n\n        var model = initialModel;\n\n        // Replay each event\n        await foreach (var evt in events) {\n            foreach (var assoc in associations) {\n                model = assoc.ApplyDelegate(model, evt);\n            }\n        }\n\n        return model;\n    }\n}\n\n// Usage\nvar replayEngine = new EventReplayEngine();\nvar events = LoadHistoricalEvents();\nvar currentState = await replayEngine.ReplayAsync(\n    new ProductModel(),\n    events,\n    \"ECommerce.BFF.API\"\n);\n```\n\n### Scenario 3: Multi-Perspective Testing\n\n**When**: Testing that all perspectives handle an event correctly\n\n```csharp\n[Test]\npublic async Task AllPerspectives_HandleProductCreatedEvent_CorrectlyAsync() {\n    // Arrange\n    var associations = PerspectiveRegistrationExtensions\n        .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(\"ECommerce.BFF.API\");\n\n    var model = new ProductModel { ProductCount = 0 };\n    var evt = new ProductCreatedEvent { ProductId = \"prod-123\" };\n\n    // Act & Assert - test each perspective\n    foreach (var assoc in associations) {\n        Console.WriteLine($\"Testing perspective: {assoc.TargetName}\");\n\n        var result = assoc.ApplyDelegate(model, evt);\n\n        // Verify perspective applied changes\n        await Assert.That(result).IsNotEqualTo(model);\n        await Assert.That(result.ProductCount).IsGreaterThan(model.ProductCount);\n\n        model = result; // Update for next perspective\n    }\n\n    // Final assertion\n    await Assert.That(model.ProductCount).IsGreaterThan(0);\n}\n```\n\n### Scenario 4: Conditional Perspective Application\n\n**When**: Applying perspectives based on runtime conditions\n\n```csharp\npublic class ConditionalPerspectiveApplier {\n    public TModel ApplyWithFilter<TModel, TEvent>(\n        TModel model,\n        TEvent evt,\n        string serviceName,\n        Func<PerspectiveAssociationInfo<TModel, TEvent>, bool> filter)\n        where TEvent : IEvent {\n\n        var associations = PerspectiveRegistrationExtensions\n            .GetPerspectiveAssociations<TModel, TEvent>(serviceName);\n\n        // Apply only perspectives matching filter\n        foreach (var assoc in associations.Where(filter)) {\n            model = assoc.ApplyDelegate(model, evt);\n        }\n\n        return model;\n    }\n}\n\n// Usage: Apply only specific perspectives\nvar applier = new ConditionalPerspectiveApplier();\nvar filtered = applier.ApplyWithFilter(\n    productModel,\n    productEvent,\n    serviceName,\n    assoc => assoc.TargetName.Contains(\"Inventory\") // Only inventory perspectives\n);\n```\n\n### Scenario 5: Performance Monitoring\n\n**When**: Monitoring perspective performance\n\n```csharp\npublic class MonitoredPerspectiveApplier {\n    private readonly ILogger _logger;\n\n    public TModel ApplyWithMonitoring<TModel, TEvent>(\n        TModel model,\n        TEvent evt,\n        string serviceName)\n        where TEvent : IEvent {\n\n        var associations = PerspectiveRegistrationExtensions\n            .GetPerspectiveAssociations<TModel, TEvent>(serviceName);\n\n        foreach (var assoc in associations) {\n            var sw = Stopwatch.StartNew();\n\n            model = assoc.ApplyDelegate(model, evt);\n\n            sw.Stop();\n            _logger.LogDebug(\n                \"Perspective {PerspectiveName} took {ElapsedMs}ms\",\n                assoc.TargetName,\n                sw.ElapsedMilliseconds\n            );\n        }\n\n        return model;\n    }\n}\n```\n\n## Type Filtering Behavior\n\n### Exact Type Matching\n\nGetPerspectiveAssociations uses exact type matching (not assignable types):\n\n```csharp\n// Perspective definition\npublic class ProductPerspective : IPerspectiveFor<ProductModel, ProductCreatedEvent> {\n    public ProductModel Apply(ProductModel model, ProductCreatedEvent evt) {\n        // ...\n    }\n}\n\n// ✅ Exact match - returns association\nvar associations1 = PerspectiveRegistrationExtensions\n    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);\n// Returns: [ProductPerspective]\n\n// ❌ Base class - no match\nvar associations2 = PerspectiveRegistrationExtensions\n    .GetPerspectiveAssociations<BaseModel, ProductCreatedEvent>(serviceName);\n// Returns: [] (empty)\n\n// ❌ Interface - no match\nvar associations3 = PerspectiveRegistrationExtensions\n    .GetPerspectiveAssociations<IModel, ProductCreatedEvent>(serviceName);\n// Returns: [] (empty)\n```\n\n### Multiple Perspectives\n\nIf multiple perspectives handle the same model/event combination, all are returned:\n\n```csharp\n// Two perspectives handling ProductModel + ProductCreatedEvent\npublic class InventoryPerspective : IPerspectiveFor<ProductModel, ProductCreatedEvent> { }\npublic class CatalogPerspective : IPerspectiveFor<ProductModel, ProductCreatedEvent> { }\n\nvar associations = PerspectiveRegistrationExtensions\n    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);\n\n// Returns: [InventoryPerspective, CatalogPerspective]\nConsole.WriteLine($\"Found {associations.Count} perspectives\");\n\n// Apply both\nforeach (var assoc in associations) {\n    model = assoc.ApplyDelegate(model, evt);\n}\n```\n\n## Performance Considerations\n\n### Caching Associations\n\n```csharp\n// ❌ WRONG: Calling in loop\nforeach (var evt in events) {\n    var associations = PerspectiveRegistrationExtensions\n        .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);\n    // Unnecessary overhead!\n}\n\n// ✅ CORRECT: Cache outside loop\nvar associations = PerspectiveRegistrationExtensions\n    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);\n\nforeach (var evt in events) {\n    foreach (var assoc in associations) {\n        model = assoc.ApplyDelegate(model, evt);\n    }\n}\n```\n\n### Compile-Time Optimization\n\nThe method uses compile-time type checks, so the JIT compiler can optimize aggressively:\n\n```csharp\n// JIT can inline typeof() checks\n// Result: Very fast (~1-2ns per call once JIT'd)\nvar associations = PerspectiveRegistrationExtensions\n    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);\n```\n\n### Delegate Invocation Cost\n\n```csharp\n// Delegate invocation is extremely fast\n// Approximately 1-2ns per invocation (similar to virtual method call)\nvar result = assoc.ApplyDelegate(model, evt);\n\n// Compare to reflection: ~100-1000ns per call\n// Delegates are 50-500x faster!\n```\n\n## Integration with Message Associations\n\n### Complementary APIs\n\n```csharp\n// 1. Discovery with MessageAssociation (string-based)\nvar allAssociations = PerspectiveRegistrationExtensions\n    .GetMessageAssociations(serviceName);\n\nvar productEvents = allAssociations\n    .Where(a => a.TargetName == \"ProductPerspective\")\n    .Select(a => a.MessageType);\n\nConsole.WriteLine($\"ProductPerspective handles: {string.Join(\", \", productEvents)}\");\n\n// 2. Invocation with GetPerspectiveAssociations (typed)\nvar typedAssociations = PerspectiveRegistrationExtensions\n    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);\n\nforeach (var assoc in typedAssociations) {\n    model = assoc.ApplyDelegate(model, evt);\n}\n```\n\n### Workflow\n\n1. **Discovery**: Use `GetMessageAssociations()` to find available perspectives\n2. **Filtering**: Use fuzzy matching and queries to filter\n3. **Invocation**: Use `GetPerspectiveAssociations<TModel, TEvent>()` to invoke\n\n## API Reference\n\n### Method Details\n\n**Namespace**: `Whizbang.Core.Generated`\n\n**Class**: `PerspectiveRegistrationExtensions`\n\n**Method**: `GetPerspectiveAssociations<TModel, TEvent>`\n\n### Parameters\n\n| Parameter | Type | Description |\n|",
        "tags": [],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/core-concepts/perspectives",
        "title": "Perspectives Guide",
        "category": "Core Concepts",
        "order": 3,
        "description": "Master Whizbang Perspectives - pure function event handlers that maintain eventually consistent read models optimized for queries",
        "tags": "perspectives, read-models, cqrs, eventual-consistency, event-driven, pure-functions, streamkey",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/core-concepts/receptors",
        "title": "Receptors Guide",
        "category": "Core Concepts",
        "order": 2,
        "description": "Master Whizbang Receptors - stateless message handlers that encapsulate business logic, validation, and decision-making",
        "tags": "receptors, message-handlers, business-logic, validation",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/core-concepts/rpc-extraction",
        "title": "Rpc Extraction",
        "category": "Core Concepts",
        "order": 999,
        "description": "# RPC Response Extraction\n\nRPC (Remote Procedure Call) style invocations allow you to call a receptor and receive a specific response type back, while other returned values cascade through normal routing.\n\n## Overview\n\nWhen using `LocalInvokeAsync<TResponse>(command)`, the dispatcher:\n\n1. **Extracts** the requested `TResponse` type from the receptor's return value\n2. **Returns** that value directly to the caller\n3. **Cascades** all other returned values through normal routing (outbox by default)\n\nThis enables receptors to return multiple values (via tuples) while callers receive only what they need.\n\n## Example\n\n```csharp\n// Command\npublic record CreateOrder(Guid OrderId, decimal Amount);\n\n// Response types\npublic record OrderConfirmation {\n  public required Guid OrderId { get; init; }\n  public required string ConfirmationCode { get; init; }\n}\n\n[DefaultRouting(DispatchMode.Outbox)]\npublic record InventoryReserved([property: StreamKey] Guid OrderId) : IEvent;\n\n// Receptor returns tuple: (response to caller, event to cascade)\npublic class CreateOrderReceptor\n    : IReceptor<CreateOrder, (OrderConfirmation, InventoryReserved)> {\n\n  public ValueTask<(OrderConfirmation, InventoryReserved)> HandleAsync(\n      CreateOrder command,\n      CancellationToken ct = default) {\n\n    var confirmation = new OrderConfirmation {\n      OrderId = command.OrderId,\n      ConfirmationCode = $\"CONF-{command.OrderId:N}\"\n    };\n\n    var inventory = new InventoryReserved(command.OrderId);\n\n    return ValueTask.FromResult((confirmation, inventory));\n  }\n}\n```\n\n### Caller Side\n\n```csharp\n// RPC call - OrderConfirmation returned to caller\nvar confirmation = await dispatcher.LocalInvokeAsync<OrderConfirmation>(\n    new CreateOrder(Guid.NewGuid(), 99.99m));\n\n// InventoryReserved automatically cascades to outbox (per [DefaultRouting])\n// confirmation.ConfirmationCode is available to caller\n```\n\n## How It Works\n\n### Response Extraction\n\nThe `ResponseExtractor` utility extracts the requested type from complex return values:\n\n| Return Type | Extraction Behavior |\n|",
        "tags": [],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/core-concepts/type-formatting",
        "title": "Type Formatting",
        "category": "Core Concepts",
        "order": 999,
        "description": "",
        "tags": [],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/core-concepts/type-matching",
        "title": "Type Matching",
        "category": "Core Concepts",
        "order": 999,
        "description": "",
        "tags": [],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/core-concepts/type-qualification",
        "title": "Type Qualification",
        "category": "Core Concepts",
        "order": 999,
        "description": "# TypeQualification: Type Name Formatting Control\n\nTypeQualification is a flag enum that controls how .NET type names are formatted in generated code. It enables fine-grained control over namespace, assembly, version, and other type name components.\n\n## Overview\n\n**TypeQualification** provides:\n- ✅ Flag-based control over type name components\n- ✅ Individual component flags for fine-grained control\n- ✅ Composite presets for common scenarios\n- ✅ Fully AOT-compatible (no reflection)\n- ✅ Used by source generators and message association APIs\n\n## Quick Start\n\n### Using TypeQualification Flags\n\n```csharp\nusing Whizbang.Core;\n\nvar type = typeof(ECommerce.Contracts.Events.ProductCreatedEvent);\n\n// Simple type name only\nvar simple = TypeFormatter.FormatType(type, TypeQualification.Simple);\n// Result: \"ProductCreatedEvent\"\n\n// Namespace + type name\nvar namespaced = TypeFormatter.FormatType(type, TypeQualification.NamespaceQualified);\n// Result: \"ECommerce.Contracts.Events.ProductCreatedEvent\"\n\n// Namespace + type + assembly\nvar fullyQualified = TypeFormatter.FormatType(type, TypeQualification.FullyQualified);\n// Result: \"ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts\"\n\n// With version information\nvar withVersion = TypeFormatter.FormatType(type, TypeQualification.FullyQualifiedWithVersion);\n// Result: \"ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts, Version=1.0.0, Culture=neutral, PublicKeyToken=null\"\n```\n\n### Combining Individual Flags\n\n```csharp\n// Custom combination: Namespace + Type + Assembly (no version)\nvar custom = TypeFormatter.FormatType(\n    type,\n    TypeQualification.Namespace | TypeQualification.TypeName | TypeQualification.Assembly\n);\n// Result: \"ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts\"\n\n// With global prefix\nvar globalQualified = TypeFormatter.FormatType(\n    type,\n    TypeQualification.GlobalPrefix | TypeQualification.Namespace | TypeQualification.TypeName\n);\n// Result: \"global::ECommerce.Contracts.Events.ProductCreatedEvent\"\n```\n\n## Component Flags\n\n### Individual Component Flags\n\nEach flag controls a specific part of the type name:\n\n| Flag | Value | Description |\n|",
        "tags": [],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/core-concepts/whizbang-ids",
        "title": "Whizbang Ids",
        "category": "Core Concepts",
        "order": 999,
        "description": "# WhizbangIds: Strongly-Typed Identity Values\n\nWhizbang uses strongly-typed identity values based on UUIDv7 for all identifiers. This provides type safety, prevents ID mixing mistakes, and enables AOT-compatible dependency injection.\n\n## Overview\n\n**WhizbangIds** are source-generated value types that:\n- ✅ Wrap UUIDv7 GUIDs for time-ordered, database-friendly identities\n- ✅ Provide compile-time type safety (can't mix OrderId with CustomerId)\n- ✅ Support both static and DI-based ID generation\n- ✅ Are fully AOT-compatible (zero reflection)\n- ✅ Auto-register with DI via ModuleInitializer\n\n## TrackedGuid: Metadata-Aware GUID Wrapper\n\nFor scenarios where you need to work with raw GUIDs while preserving generation metadata, Whizbang provides `TrackedGuid`:\n\n```csharp\nusing Whizbang.Core.ValueObjects;\n\n// Create with sub-millisecond precision (recommended)\nvar tracked = TrackedGuid.NewMedo();  // Uses Medo.Uuid7 internally\n\n// Check metadata\nbool isTimeOrdered = tracked.IsTimeOrdered;           // true\nbool subMs = tracked.SubMillisecondPrecision;         // true\nDateTimeOffset when = tracked.Timestamp;              // Extracted from UUIDv7\n\n// Implicit conversion to Guid\nGuid guid = tracked;\n\n// Parse from external sources (database, API)\nvar parsed = TrackedGuid.Parse(\"550e8400-e29b-41d4-a716-446655440000\");\nvar external = TrackedGuid.FromExternal(someGuid);\n```\n\n### Why TrackedGuid?\n\n| Feature | `Guid.NewGuid()` | `Guid.CreateVersion7()` | `TrackedGuid.NewMedo()` |\n|",
        "tags": [],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/customization-examples/event-sourcing-cqrs",
        "title": "Event Sourcing & CQRS",
        "category": "Customization Examples",
        "order": 2,
        "description": "Implement full event sourcing with CQRS - event store, snapshots, temporal queries, and projections",
        "tags": "event-sourcing, cqrs, event-store, snapshots, temporal-queries",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/customization-examples/microservices-orchestration",
        "title": "Microservices Orchestration",
        "category": "Customization Examples",
        "order": 3,
        "description": "Implement saga orchestration patterns - distributed workflows, compensation, and process managers",
        "tags": "sagas, orchestration, process-managers, distributed-workflows, compensation",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/customization-examples/multi-tenant-saas",
        "title": "Multi-Tenant SaaS",
        "category": "Customization Examples",
        "order": 1,
        "description": "Build multi-tenant SaaS applications with tenant isolation, per-tenant databases, and cross-tenant analytics",
        "tags": "multi-tenancy, saas, tenant-isolation, database-per-tenant",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/customization-examples/real-time-analytics",
        "title": "Real-Time Analytics",
        "category": "Customization Examples",
        "order": 4,
        "description": "Build real-time analytics dashboards - streaming metrics, SignalR updates, and live KPIs",
        "tags": "real-time, analytics, signalr, streaming, dashboards, websockets",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/data/dapper-integration",
        "title": "Dapper Integration",
        "category": "Data Access",
        "order": 1,
        "description": "Lightweight, high-performance data access with Dapper for Whizbang perspectives and lenses - simple SQL, minimal overhead",
        "tags": "dapper, data-access, postgresql, sql, micro-orm",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/data/efcore-integration",
        "title": "EF Core Integration",
        "category": "Data Access",
        "order": 2,
        "description": "Full-featured ORM with EF Core 10 for complex domain models - JSONB support, UUIDv7, migrations, and advanced querying",
        "tags": "ef-core, entity-framework, postgresql, orm, jsonb, uuidv7",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/data/event-store",
        "title": "Event Store",
        "category": "Data Access",
        "order": 4,
        "description": "Event sourcing and stream storage - event streams, replay, checkpoints, snapshots, and temporal queries",
        "tags": "event-sourcing, event-store, streams, replay, checkpoints, snapshots, postgresql",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/data/perspectives-storage",
        "title": "Perspectives Storage",
        "category": "Data Access",
        "order": 3,
        "description": "Read model schema design for perspectives - denormalization strategies, JSONB columns, indexing, and high-volume partitioning",
        "tags": "perspectives, read-models, schema-design, denormalization, postgresql, jsonb, partitioning",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/data-access/schema-generation-pattern",
        "title": "Schema Generation Pattern",
        "category": "Data Access",
        "order": 6,
        "description": "Database-agnostic schema definitions with ISchemaBuilder for Postgres, SQLite, and custom database engines",
        "tags": "schema-generation, database, postgres, sqlite, ddl, ef-core, dapper, aot",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/diagnostics/whiz030",
        "title": "WHIZ030: Perspective Event Missing StreamKey",
        "category": "Diagnostics",
        "order": 999,
        "description": "Event type used in perspective must have exactly one property marked with [StreamKey] attribute",
        "tags": [
          "diagnostics",
          "perspectives",
          "streamkey",
          "source-generator"
        ],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/diagnostics/whiz031",
        "title": "WHIZ031: Multiple StreamKey Attributes",
        "category": "Diagnostics",
        "order": 999,
        "description": "Event type has multiple properties marked with [StreamKey] - only one is allowed",
        "tags": [
          "diagnostics",
          "perspectives",
          "streamkey",
          "source-generator"
        ],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/diagnostics/whiz058",
        "title": "WHIZ058: GUID Call Intercepted",
        "category": "Diagnostics",
        "order": 999,
        "description": "Informational diagnostic indicating a GUID creation call has been intercepted and wrapped with TrackedGuid",
        "tags": [
          "diagnostics",
          "guid",
          "interception",
          "source-generator",
          "trackedguid"
        ],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/diagnostics/whiz059",
        "title": "WHIZ059: GUID Interception Suppressed",
        "category": "Diagnostics",
        "order": 999,
        "description": "Informational diagnostic indicating a GUID creation call was not intercepted due to suppression",
        "tags": [
          "diagnostics",
          "guid",
          "interception",
          "source-generator",
          "suppression"
        ],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/extensibility/custom-dispatchers",
        "title": "Custom Dispatchers",
        "category": "Extensibility",
        "order": 9,
        "description": "Implement custom dispatcher patterns - mediator, event sourcing, multi-tenant routing",
        "tags": "dispatcher, mediator, routing, event-sourcing",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/extensibility/custom-health-checks",
        "title": "Custom Health Checks",
        "category": "Extensibility",
        "order": 6,
        "description": "Implement custom health checks for transports, databases, external APIs, and custom services",
        "tags": "health-checks, monitoring, kubernetes, readiness, liveness",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/extensibility/custom-id-generators",
        "title": "Custom ID Generators",
        "category": "Extensibility",
        "order": 8,
        "description": "Implement custom ID generation strategies - Snowflake IDs, ULID, CUID, or custom schemes",
        "tags": "id-generation, uuidv7, snowflake, ulid, cuid",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/extensibility/custom-perspectives",
        "title": "Custom Perspectives",
        "category": "Extensibility",
        "order": 3,
        "description": "Advanced perspective patterns - time-travel, snapshots, caching, batching, and custom storage backends",
        "tags": "perspectives, read-models, custom-storage, time-travel, snapshots, caching",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/extensibility/custom-policies",
        "title": "Custom Policies",
        "category": "Extensibility",
        "order": 5,
        "description": "Advanced policy patterns - weighted policies, dynamic registration, async evaluation, caching, and A/B testing",
        "tags": "policies, custom-policy-engine, weighted-policies, async-policies, policy-caching",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/extensibility/custom-receptors",
        "title": "Custom Receptors",
        "category": "Extensibility",
        "order": 2,
        "description": "Advanced receptor customization patterns - streaming, lifecycle hooks, base classes, and performance optimization",
        "tags": "receptors, custom-handlers, streaming, lifecycle, base-classes",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/extensibility/custom-serializers",
        "title": "Custom Serializers",
        "category": "Extensibility",
        "order": 7,
        "description": "Implement custom serializers for Protobuf, MessagePack, or custom binary formats - AOT-compatible patterns",
        "tags": "serialization, protobuf, messagepack, aot, json",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/extensibility/custom-storage",
        "title": "Custom Storage",
        "category": "Extensibility",
        "order": 10,
        "description": "Implement custom storage backends - Redis, MongoDB, Elasticsearch, Cassandra, or custom databases",
        "tags": "storage, iperspectivestore, custom-backends, redis, mongodb",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/extensibility/custom-transports",
        "title": "Custom Transports",
        "category": "Extensibility",
        "order": 4,
        "description": "Implement custom transports for HTTP, gRPC, Kafka, RabbitMQ, or any messaging system - AOT-compatible patterns",
        "tags": "transports, itransport, custom-implementations, http, grpc, kafka, rabbitmq, serialization",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/extensibility/custom-work-coordinators",
        "title": "Custom Work Coordinators",
        "category": "Extensibility",
        "order": 11,
        "description": "Implement custom work coordination strategies - distributed locks, Redis queues, or custom lease management",
        "tags": "work-coordination, iworkcoordinator, distributed-locks, redis-queues",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/extensibility/database-schema-framework",
        "title": "Database Schema Framework",
        "category": "Extensibility",
        "order": 11,
        "description": "Implement database drivers using the Whizbang.Data.Schema framework - database-agnostic table and column definitions for PostgreSQL, SQLite, SQL Server, and custom databases",
        "tags": "schema, database, drivers, postgresql, sqlite, sqlserver, table-definition, column-definition, whizbang-data-type",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/extensibility/hooks-and-middleware",
        "title": "Hooks and Middleware",
        "category": "Extensibility",
        "order": 1,
        "description": "Pipeline behaviors for cross-cutting concerns - logging, validation, retry, caching, and custom pre/post processing",
        "tags": "extensibility, pipeline-behavior, middleware, hooks, cross-cutting-concerns, aop",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/extensibility/plugin-architecture",
        "title": "Plugin Architecture",
        "category": "Extensibility",
        "order": 12,
        "description": "Design plugin systems - dynamic assembly loading, hot-reload, and extension points",
        "tags": "plugins, dynamic-loading, hot-reload, extensibility",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/getting-started/installation",
        "title": "Installation Guide",
        "category": "Getting Started",
        "order": 2,
        "description": "Install Whizbang and set up your first project with NuGet packages, project templates, and IDE configuration",
        "tags": "installation, setup, nuget, project-templates",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/getting-started/introduction",
        "title": "Introduction to Whizbang",
        "category": "Getting Started",
        "order": 1,
        "description": "Learn about Whizbang - a zero-reflection, AOT-compatible .NET library for building event-driven, CQRS, and event-sourced applications",
        "tags": "introduction, overview, philosophy, getting-started",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/getting-started/project-structure",
        "title": "Project Structure Guide",
        "category": "Getting Started",
        "order": 4,
        "description": "Organize your Whizbang application with recommended project structures, separation of concerns, and multi-service architectures",
        "tags": "project-structure, architecture, organization, best-practices",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/getting-started/quick-start",
        "title": "Quick Start Tutorial",
        "category": "Getting Started",
        "order": 3,
        "description": "Build your first Whizbang application in 10 minutes - create messages, receptors, and dispatch commands with complete working examples",
        "tags": "quick-start, tutorial, beginner, hello-world",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/graphql/filtering",
        "title": "Filtering",
        "category": "graphql",
        "order": 999,
        "description": "",
        "tags": [],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/graphql/index",
        "title": "Index",
        "category": "graphql",
        "order": 999,
        "description": "# GraphQL Integration\n\nWhizbang provides seamless HotChocolate GraphQL integration for Lenses, enabling powerful filtering, sorting, paging, and projection capabilities with full AOT compatibility.\n\n## Overview\n\nThe `Whizbang.Transports.HotChocolate` package integrates Whizbang Lenses with [HotChocolate](https://chillicream.com/docs/hotchocolate), providing:\n\n- **Automatic Query Generation** - Source generators create type-safe GraphQL queries from `[GraphQLLens]` attributes\n- **Full Data Operations** - `[UseFiltering]`, `[UseSorting]`, `[UsePaging]`, `[UseProjection]` support\n- **Scope-Aware Queries** - Multi-tenancy and security filtering via middleware\n- **AOT Compatible** - Zero reflection, source-generated at compile time\n\n## Quick Start\n\n### 1. Install the Package\n\n```bash\ndotnet add package Whizbang.Transports.HotChocolate\n```\n\n### 2. Define Your Lens\n\n```csharp\n[GraphQLLens(QueryName = \"orders\")]\npublic interface IOrderLens : ILensQuery<OrderReadModel> { }\n```\n\n### 3. Configure Services\n\n```csharp\n// Program.cs\nbuilder.Services.AddGraphQLServer()\n    .AddWhizbangLenses()\n    .AddQueryType<Query>();\n\n// Add scope middleware for multi-tenancy\nbuilder.Services.AddWhizbangScope();\n\nvar app = builder.Build();\napp.UseWhizbangScope();\napp.MapGraphQL();\n```\n\n### 4. Query Your Data\n\n```graphql\n{\n  orders(\n    where: { data: { status: { eq: \"Completed\" } } }\n    order: { data: { createdAt: DESC } }\n    first: 10\n  ) {\n    nodes {\n      id\n      data {\n        customerName\n        status\n        totalAmount\n      }\n      metadata {\n        eventType\n        timestamp\n      }\n    }\n    pageInfo {\n      hasNextPage\n      endCursor\n    }\n    totalCount\n  }\n}\n```\n\n## Documentation\n\n| Topic | Description |\n|",
        "tags": [],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/graphql/lens-integration",
        "title": "Lens Integration",
        "category": "graphql",
        "order": 999,
        "description": "# Lens Integration\n\nThe `[GraphQLLens]` attribute marks lens interfaces for GraphQL exposure, enabling automatic query generation with configurable filtering, sorting, and paging.\n\n## Basic Usage\n\n```csharp\n[GraphQLLens(QueryName = \"orders\")]\npublic interface IOrderLens : ILensQuery<OrderReadModel> { }\n```\n\nThis generates a GraphQL query field named `orders` with full data operations support.\n\n## Attribute Properties\n\n| Property | Type | Default | Description |\n|",
        "tags": [],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/graphql/scoping",
        "title": "Scoping",
        "category": "graphql",
        "order": 999,
        "description": "# GraphQL Scoping\n\nWhizbang's scope middleware provides automatic multi-tenancy and security filtering for GraphQL queries, ensuring users only see data they're authorized to access.\n\n## Overview\n\nThe `WhizbangScopeMiddleware` extracts scope information from HTTP requests (JWT claims and headers) and makes it available to lens queries for automatic filtering.\n\n```\nHTTP Request\n    │\n    ├── JWT Claims (tenant_id, sub, groups, ...)\n    ├── Headers (X-Tenant-Id, X-User-Id, ...)\n    │\n    ▼\nWhizbangScopeMiddleware\n    │\n    ├── Extracts scope values\n    ├── Creates IScopeContext\n    │\n    ▼\nIScopeContextAccessor.Current\n    │\n    ▼\nLens Query (automatic filtering)\n```\n\n## Setup\n\n### 1. Register Services\n\n```csharp\nbuilder.Services.AddWhizbangScope();\n```\n\n### 2. Add Middleware\n\n```csharp\napp.UseAuthentication();\napp.UseWhizbangScope();  // After auth\napp.MapGraphQL();\n```\n\n## Configuration\n\n### Default Claim/Header Mappings\n\n| Scope Value | Claim Type | Header Name |\n|",
        "tags": [],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/graphql/setup",
        "title": "Setup",
        "category": "graphql",
        "order": 999,
        "description": "# GraphQL Setup\n\nThis guide covers installation and configuration of Whizbang's HotChocolate GraphQL integration.\n\n## Installation\n\n```bash\ndotnet add package Whizbang.Transports.HotChocolate\n```\n\n## Basic Configuration\n\n### Minimal Setup\n\n```csharp\n// Program.cs\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services\n    .AddGraphQLServer()\n    .AddWhizbangLenses()\n    .AddQueryType<Query>();\n\nvar app = builder.Build();\napp.MapGraphQL();\napp.Run();\n```\n\n### With Scope Middleware\n\nFor multi-tenancy and security filtering:\n\n```csharp\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services\nbuilder.Services.AddWhizbangScope();\nbuilder.Services\n    .AddGraphQLServer()\n    .AddWhizbangLenses()\n    .AddQueryType<Query>();\n\nvar app = builder.Build();\n\n// Middleware order matters\napp.UseAuthentication();\napp.UseWhizbangScope();  // After auth, before GraphQL\napp.MapGraphQL();\n\napp.Run();\n```\n\n## Configuration Options\n\n### WhizbangGraphQLOptions\n\nConfigure default behavior for all lenses:\n\n```csharp\nbuilder.Services\n    .AddGraphQLServer()\n    .AddWhizbangLenses(options => {\n        options.DefaultScope = GraphQLLensScope.Data | GraphQLLensScope.SystemFields;\n        options.DefaultPageSize = 25;\n        options.MaxPageSize = 200;\n    });\n```\n\n| Option | Default | Description |\n|",
        "tags": [],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/graphql/sorting",
        "title": "Sorting",
        "category": "graphql",
        "order": 999,
        "description": "",
        "tags": [],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/infrastructure/aspire-integration",
        "title": ".NET Aspire Integration",
        "category": "Infrastructure",
        "order": 1,
        "description": "Cloud-native orchestration for Whizbang applications with .NET Aspire - automatic infrastructure provisioning and service discovery",
        "tags": "aspire, cloud-native, orchestration, service-bus, emulator, infrastructure, distributed-applications",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/infrastructure/health-checks",
        "title": "Health Checks",
        "category": "Infrastructure",
        "order": 2,
        "description": "Application health monitoring with built-in health checks for transports, databases, and custom components",
        "tags": "health-checks, monitoring, readiness, liveness, aspire-dashboard, observability",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/infrastructure/policies",
        "title": "Policy-Based Routing",
        "category": "Infrastructure",
        "order": 4,
        "description": "Dynamic message routing and configuration via predicate-based policies - multi-tenancy, environment-based routing, and execution strategies",
        "tags": "policies, routing, multi-tenancy, execution-strategy, policy-engine, decision-trail",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/infrastructure/pooling",
        "title": "Object Pooling",
        "category": "Infrastructure",
        "order": 3,
        "description": "Zero-allocation object pooling for high-performance message processing - reduce heap pressure and GC overhead",
        "tags": "pooling, performance, allocations, gc, policy-context, object-reuse",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/messaging/commands-events",
        "title": "Commands Events",
        "category": "messaging",
        "order": 999,
        "description": "",
        "tags": [],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/messaging/failure-handling",
        "title": "Failure Handling",
        "category": "messaging",
        "order": 999,
        "description": "# Failure Handling\n\n## Overview\n\nWhizbang implements sophisticated failure handling mechanisms including exponential backoff retry scheduling, stream-based failure cascades, and poison message detection. This document details how failures are tracked, scheduled for retry, and how they impact stream processing.\n\n## Core Concepts\n\n### Message Processing Status\n\nMessages track their processing state using bitwise flags in the `status` column:\n\n```csharp\n[Flags]\npublic enum MessageProcessingStatus {\n    Stored = 1,         // Bit 0: Message stored in database\n    EventStored = 2,    // Bit 1: Event persisted to event store\n    Published = 4,      // Bit 2: Message published to transport\n    Failed = 32768      // Bit 15: Processing failed\n}\n```\n\n**Key Properties**:\n- **Bitwise Flags**: Multiple states can coexist (e.g., `Stored | Failed = 32769`)\n- **Status Progression**: `Stored → EventStored → Published` (outbox)\n- **Failure Overlay**: `Failed` flag added via bitwise OR when message fails\n- **Partial Completion**: `CompletedStatus` tracks what was accomplished before failure\n\n### Failure Classification\n\n```csharp\npublic enum MessageFailureReason {\n    Unknown = 99,                    // Default (not classified)\n    TransportUnavailable = 1,        // Network/transport issues\n    HandlerException = 2,            // Handler threw exception\n    ValidationFailure = 3,           // Message validation failed\n    TimeoutExceeded = 4,             // Processing timeout\n    SerializationError = 5,          // Cannot deserialize message\n    DependencyFailure = 6,           // External dependency unavailable\n    PoisonMessage = 7                // Exceeded retry limit\n}\n```\n\n**Purpose**:\n- Enable typed filtering (e.g., \"retry only TransportUnavailable failures\")\n- Support different retry strategies per failure type\n- Metrics and monitoring (failure classification dashboards)\n\n### Retry Scheduling\n\n**Exponential Backoff Formula**:\n```\nscheduled_for = now + (base_interval * 2^attempts)\n\nBase interval: 30 seconds\nAttempts:\n- 0: First attempt (no backoff)\n- 1: 30s * 2^1 = 1 minute\n- 2: 30s * 2^2 = 2 minutes\n- 3: 30s * 2^3 = 4 minutes\n- 4: 30s * 2^4 = 8 minutes\n- 5: 30s * 2^5 = 16 minutes\n- ...\n```\n\n## Failure Processing Flow {#failure-flow}\n\n### Basic Failure and Retry\n\n```mermaid\nsequenceDiagram\n    participant I as Instance\n    participant DB as PostgreSQL\n    participant H as Handler/Transport\n\n    I->>DB: ProcessWorkBatchAsync()\n    DB-->>I: WorkBatch: [M1]\n\n    I->>H: Process M1\n    H-->>I: ❌ Exception: Network timeout\n\n    I->>DB: ProcessWorkBatchAsync(<br/>failures: [M1: error=\"Network timeout\"])\n    DB->>DB: UPDATE wh_outbox<br/>SET status = status | Failed (32768),<br/>error = \"Network timeout\",<br/>attempts = attempts + 1,<br/>scheduled_for = now + (30s * 2^attempts),<br/>instance_id = NULL,<br/>lease_expiry = NULL<br/>WHERE message_id = M1\n    Note over DB: M1: attempts=1<br/>scheduled_for = now + 1 min<br/>Status: Stored | Failed (32769)\n\n    Note over I: Wait 1 minute...\n\n    I->>DB: ProcessWorkBatchAsync()\n    DB->>DB: Find claimable messages:<br/>WHERE scheduled_for <= now\n    DB-->>I: WorkBatch: [M1] (retry)\n\n    I->>H: Process M1 (retry)\n    H-->>I: ✅ Success\n\n    I->>DB: ProcessWorkBatchAsync(<br/>completions: [M1: Published])\n    DB->>DB: UPDATE status = status | Published,<br/>DELETE (outbox done when published)\n    Note over DB: ✅ M1 processed successfully<br/>after retry\n```\n\n### Retry Schedule Timeline\n\n```\nTime →\n0s              60s             120s            180s            240s\n│               │               │               │               │\nM1 ━━━━━━━━━┃ Fail (attempts=0)\n           │\n           ├→ scheduled_for = now + 30s * 2^1 = now + 1 min\n           │\n           ├──── Cannot claim (scheduled_for > now)\n           │\n           │               Retry #1\n           │               ┃ Fail (attempts=1)\n           │               │\n           │               ├→ scheduled_for = now + 30s * 2^2 = now + 2 min\n           │               │\n           │               ├──── Cannot claim\n           │               │\n           │               │                               Retry #2\n           │               │                               ┃ Success\n           │               │                               │\n           │               │                               └→ Published\n```\n\n## Stream-Based Failure Cascades {#failure-cascade}\n\n### Problem: Blocking Entire Stream\n\nWhen message M1 in stream S fails, what happens to messages M2, M3, M4 that come after it?\n\n**Options**:\n1. **Block all**: M2, M3, M4 stuck until M1 succeeds (could wait forever)\n2. **Continue**: Process M2, M3, M4 anyway (violates stream ordering)\n3. **Cascade release**: Allow releasing M2, M3, M4 to unblock stream\n\n**Whizbang's Approach**: Cascade release with explicit control\n\n### Status=0 Release Pattern\n\n**Mechanism**: Completing a message with `Status = 0` clears its lease without changing status flags, allowing it to be reprocessed.\n\n```csharp\n// Release messages M2, M3 (let them be retried)\nawait coordinator.ProcessWorkBatchAsync(\n    // ...\n    outboxCompletions: [\n        new MessageCompletion { MessageId = message2Id, Status = 0 },  // Release\n        new MessageCompletion { MessageId = message3Id, Status = 0 }   // Release\n    ],\n    outboxFailures: [\n        new MessageFailure {\n            MessageId = message1Id,\n            CompletedStatus = MessageProcessingStatus.Stored,\n            Error = \"Processing failed\"\n        }\n    ]\n);\n```\n\n**Effect**:\n- M1: Marked as failed, scheduled for retry\n- M2, M3: Leases cleared (`instance_id = NULL`, `lease_expiry = NULL`)\n- M2, M3: Status unchanged (still `Stored`)\n- M2, M3: Can be reclaimed by any instance\n\n### Cascade Release Sequence Diagram\n\n```mermaid\nsequenceDiagram\n    participant I as Instance\n    participant DB as PostgreSQL\n\n    Note over DB: Stream S has messages M1, M2, M3<br/>(all claimed by Instance)\n\n    I->>I: Process M1 → ❌ Fails\n    I->>I: Cannot process M2, M3<br/>(depend on M1 success)\n\n    I->>DB: ProcessWorkBatchAsync(<br/>failures: [M1],<br/>completions: [M2: Status=0, M3: Status=0])\n\n    DB->>DB: UPDATE wh_outbox<br/>SET status = status | Failed,<br/>scheduled_for = now + 1 min,<br/>instance_id = NULL, lease_expiry = NULL<br/>WHERE message_id = M1\n\n    DB->>DB: UPDATE wh_outbox<br/>SET instance_id = NULL,<br/>lease_expiry = NULL<br/>WHERE message_id IN (M2, M3)<br/>-- Status unchanged (Status | 0 = Status)\n\n    Note over DB: M1: Failed, scheduled for retry<br/>M2, M3: Released, can be reclaimed\n\n    Note over I: Later (next ProcessWorkBatch call)\n\n    I->>DB: ProcessWorkBatchAsync()\n    DB->>DB: Find claimable messages:<br/>M1: scheduled_for > now (blocked)<br/>M2: No earlier messages with active lease ✅<br/>M3: M2 earlier, but no lease ✅\n    DB-->>I: WorkBatch: [M2, M3]\n\n    I->>I: Process M2, M3 successfully\n    I->>DB: ProcessWorkBatchAsync(<br/>completions: [M2: Published, M3: Published])\n    Note over DB: ✅ M2, M3 completed<br/>M1 still scheduled for retry\n```\n\n### Cascade Decision Matrix\n\n| M1 State | M2 Lease Cleared? | M2 Claimable? | Ordering Impact |\n|",
        "tags": [],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/messaging/idempotency-patterns",
        "title": "Idempotency Patterns",
        "category": "messaging",
        "order": 999,
        "description": "# Idempotency Patterns\n\n## Overview\n\nIdempotency ensures that processing the same message multiple times produces the same result as processing it once. Whizbang implements different idempotency strategies for inbox and outbox based on their roles in the system architecture.\n\n## Core Concepts\n\n### What is Idempotency?\n\n**Definition**: An operation is idempotent if performing it multiple times has the same effect as performing it once.\n\n**Why It Matters**:\n- Message brokers often provide at-least-once delivery (duplicates possible)\n- Network retries can cause duplicate message sends\n- Distributed systems need to handle duplicate messages gracefully\n\n**Example**:\n- ✅ Idempotent: `SET balance = 100` (same result whether executed 1x or 10x)\n- ❌ Not Idempotent: `SET balance = balance + 10` (different result each execution)\n\n### Inbox vs. Outbox Strategies\n\n| Aspect | Inbox | Outbox |\n|",
        "tags": [],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/messaging/inbox-pattern",
        "title": "Inbox Pattern",
        "category": "Messaging",
        "order": 2,
        "description": "Achieve exactly-once message processing with the Inbox Pattern - automatic deduplication and idempotent message handling",
        "tags": "inbox, exactly-once, deduplication, idempotency, message-processing",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/messaging/message-envelopes",
        "title": "Message Envelopes Deep Dive",
        "category": "Messaging",
        "order": 4,
        "description": "Deep dive into Message Envelopes - hop-based distributed tracing across Outbox, Inbox, and message transports",
        "tags": "message-envelopes, distributed-tracing, observability, cross-service, azure-service-bus",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/messaging/multi-instance-coordination",
        "title": "Multi Instance Coordination",
        "category": "messaging",
        "order": 999,
        "description": "# Multi-Instance Coordination\n\n## Overview\n\nMulti-instance coordination ensures reliable, ordered message processing across multiple service instances. This document details the coordination mechanisms, decision points, and timing guarantees that enable distributed message processing.\n\n## Core Coordination Mechanisms\n\n### 1. Cross-Instance Stream Ordering {#cross-instance-stream-ordering}\n\n**Rule**: When Instance A holds message M1 from stream S, Instance B cannot claim later messages (M2, M3, M4) from the same stream until Instance A completes or releases M1.\n\n**Why This Matters**: Prevents out-of-order processing when messages from the same stream are distributed across multiple instances via partition assignment.\n\n#### Sequence Diagram\n\n```mermaid\nsequenceDiagram\n    participant I1 as Instance 1\n    participant DB as PostgreSQL\n    participant I2 as Instance 2\n\n    Note over DB: Stream S has messages M1, M2, M3, M4<br/>(temporal order by created_at)\n\n    I1->>DB: ProcessWorkBatch()\n    DB->>DB: Calculate partition ownership<br/>(partition % 2)\n    DB->>DB: M1, M2 assigned to partition 0<br/>M3, M4 assigned to partition 5\n    DB->>DB: Instance 1 owns partition 0<br/>Instance 2 owns partition 5\n    DB-->>I1: Returns M1, M2\n    Note over I1: I1 now holds lease on M1, M2<br/>lease_expiry = now + 5 min\n\n    I2->>DB: ProcessWorkBatch()\n    DB->>DB: Check partition ownership\n    DB->>DB: Find M3, M4 in partition 5 (owned by I2)\n    DB->>DB: NOT EXISTS check:<br/>SELECT 1 FROM wh_outbox earlier<br/>WHERE earlier.stream_id = M3.stream_id<br/>AND earlier.created_at < M3.created_at<br/>AND earlier.instance_id IS NOT NULL<br/>AND earlier.lease_expiry > now\n    Note over DB: ❌ M3, M4 BLOCKED<br/>Earlier messages M1, M2 held by I1<br/>(active lease)\n    DB-->>I2: Returns [] (empty)\n\n    Note over I2: I2 cannot process M3, M4<br/>until I1 completes/releases M1, M2\n\n    I1->>DB: ProcessWorkBatch(<br/>completions: [M1: Published, M2: Published])\n    DB->>DB: Mark M1, M2 as Published\n    DB->>DB: Delete M1, M2 (done)\n\n    I2->>DB: ProcessWorkBatch()\n    DB->>DB: NOT EXISTS check passes<br/>(no earlier messages with active leases)\n    DB-->>I2: Returns M3, M4\n    Note over I2: ✅ Stream ordering preserved<br/>M1, M2 completed before M3, M4 claimed\n```\n\n**Decision Matrix**:\n\n| Earlier Message State | Later Messages Claimable? | Reason |\n|",
        "tags": [],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/messaging/outbox-pattern",
        "title": "Outbox Pattern",
        "category": "Messaging",
        "order": 1,
        "description": "Implement reliable cross-service event publishing with the Outbox Pattern - guaranteed delivery without distributed transactions",
        "tags": "outbox, reliable-messaging, transactional-outbox, event-publishing, distributed-systems",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/messaging/topic-filters",
        "title": "Topic Filters",
        "category": "messaging",
        "order": 999,
        "description": "",
        "tags": [],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/messaging/work-coordination",
        "title": "Work Coordination",
        "category": "messaging",
        "order": 999,
        "description": "",
        "tags": [],
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/messaging/work-coordinator",
        "title": "Work Coordinator",
        "category": "Messaging",
        "order": 3,
        "description": "Master the Work Coordinator - atomic batch processing for Outbox, Inbox, and event store tracking with lease-based coordination",
        "tags": "work-coordinator, atomic-operations, batch-processing, distributed-coordination, lease-management",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/migration-guide/01-concept-mapping",
        "title": "Concept Mapping",
        "category": "Migration Guide",
        "order": 2,
        "description": "How Marten/Wolverine concepts translate to Whizbang equivalents",
        "tags": "migration, marten, wolverine, concepts, mapping",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/migration-guide/02-project-setup",
        "title": "Project Setup",
        "category": "Migration Guide",
        "order": 3,
        "description": "NuGet packages and initial configuration for migrating to Whizbang",
        "tags": "migration, nuget, packages, configuration, setup",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/migration-guide/03-handler-migration",
        "title": "Handler Migration",
        "category": "Migration Guide",
        "order": 4,
        "description": "Converting Wolverine handlers to Whizbang Receptors",
        "tags": "migration, handlers, receptors, wolverine, conversion",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/migration-guide/04-projection-migration",
        "title": "Projection Migration",
        "category": "Migration Guide",
        "order": 5,
        "description": "Converting Marten projections to Whizbang Perspectives",
        "tags": "migration, projections, perspectives, marten, read-models",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/migration-guide/05-event-store-migration",
        "title": "Event Store Migration",
        "category": "Migration Guide",
        "order": 6,
        "description": "Migrating from Marten's event store to Whizbang's IEventStore",
        "tags": "migration, event-store, marten, events, streams",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/migration-guide/06-transport-configuration",
        "title": "Transport Configuration",
        "category": "Migration Guide",
        "order": 7,
        "description": "Configuring RabbitMQ and Azure Service Bus transports for Whizbang",
        "tags": "migration, transport, rabbitmq, azure-service-bus, messaging",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/migration-guide/07-outbox-migration",
        "title": "Outbox Migration",
        "category": "Migration Guide",
        "order": 8,
        "description": "Migrating from Wolverine's durable outbox to Whizbang's built-in outbox pattern",
        "tags": "migration, outbox, inbox, durability, messaging",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/migration-guide/08-testing-migration",
        "title": "Testing Migration",
        "category": "Migration Guide",
        "order": 9,
        "description": "Updating test infrastructure when migrating to Whizbang",
        "tags": "migration, testing, tunit, mocks, integration-tests",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/migration-guide/README",
        "title": "Migration Guide Overview",
        "category": "Migration Guide",
        "order": 1,
        "description": "Overview of migrating from Marten/Wolverine and other frameworks to Whizbang",
        "tags": "migration, marten, wolverine, upgrade, conversion",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/migration-guide/appendix-checklist",
        "title": "Migration Checklist",
        "category": "Migration Guide",
        "order": 10,
        "description": "Complete checklist for migrating from Marten/Wolverine to Whizbang",
        "tags": "migration, checklist, verification, validation",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/source-generators/aggregate-ids",
        "title": "Aggregate IDs",
        "category": "Source Generators",
        "order": 4,
        "description": "Zero-reflection aggregate ID extraction for PolicyContext - compile-time discovery of [AggregateId] marked properties",
        "tags": "source-generators, aggregate-ids, policy-context, zero-reflection, compile-time, uuidv7",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/source-generators/json-contexts",
        "title": "JSON Contexts",
        "category": "Source Generators",
        "order": 5,
        "description": "AOT-compatible JSON serialization with compile-time JsonSerializerContext generation - zero reflection for Native AOT",
        "tags": "source-generators, json, serialization, aot, native-aot, system-text-json, zero-reflection",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/source-generators/message-registry",
        "title": "Message Registry",
        "category": "Source Generators",
        "order": 3,
        "description": "VSCode extension integration via compile-time message registry - navigate from messages to handlers with IDE tooling",
        "tags": "source-generators, vscode, tooling, message-registry, code-navigation, ide-integration",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/source-generators/perspective-discovery",
        "title": "Perspective Discovery",
        "category": "Source Generators",
        "order": 2,
        "description": "Compile-time perspective discovery for event-driven read models - zero reflection registration and Event Store integration",
        "tags": "source-generators, perspectives, read-models, events, roslyn, compile-time, zero-reflection",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/source-generators/receptor-discovery",
        "title": "Receptor Discovery",
        "category": "Source Generators",
        "order": 1,
        "description": "Compile-time receptor discovery with Roslyn source generators - zero reflection, AOT-compatible message routing",
        "tags": "source-generators, receptors, roslyn, compile-time, zero-reflection, aot",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/source-generators/topic-filter-discovery",
        "title": "Topic Filter Discovery",
        "category": "Source Generators",
        "order": 6,
        "description": "Compile-time topic filter discovery with Roslyn source generators - type-safe, zero-reflection message routing configuration",
        "tags": "source-generators, topic-filters, roslyn, compile-time, zero-reflection, aot, routing",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/testing/lifecycle-synchronization",
        "title": "Lifecycle Synchronization",
        "category": "Testing",
        "order": 3,
        "description": "Deterministic test synchronization using lifecycle receptors - eliminate race conditions in integration tests with PostPerspectiveInline stage",
        "tags": "testing, integration-tests, lifecycle, synchronization, race-conditions, PostPerspectiveInline",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/transports/azure-service-bus",
        "title": "Azure Service Bus Transport",
        "category": "Transports",
        "order": 1,
        "description": "Reliable cross-service messaging with Azure Service Bus topics and subscriptions - AOT-compatible with correlation filters",
        "tags": "transports, azure-service-bus, messaging, topics, subscriptions, correlation-filters, aspire, aot",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/transports/in-memory",
        "title": "In-Memory Transport",
        "category": "Transports",
        "order": 2,
        "description": "Synchronous in-process message delivery for testing and single-process scenarios - zero external dependencies",
        "tags": "transports, in-memory, testing, in-process, synchronous, pub-sub, request-response",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/transports/rabbitmq",
        "title": "RabbitMQ Transport",
        "category": "Transports",
        "order": 2,
        "description": "Distributed event-driven messaging with RabbitMQ topic exchanges - AOT-compatible with channel pooling and dead-letter queue support",
        "tags": "transports, rabbitmq, messaging, topic-exchange, dead-letter-queue, channel-pool, aot, testcontainers",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/tutorial/analytics-service",
        "title": "Analytics Service",
        "category": "Tutorial",
        "order": 8,
        "description": "Build the Analytics Worker - real-time analytics, time-series perspectives, and reporting dashboards",
        "tags": "tutorial, analytics-service, perspectives, time-series, reporting, dashboards",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/tutorial/customer-service",
        "title": "Customer Service (BFF)",
        "category": "Tutorial",
        "order": 7,
        "description": "Build the Customer Service BFF - perspectives, read models, CQRS query side, and GraphQL API",
        "tags": "tutorial, customer-service, bff, perspectives, cqrs, read-models",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/tutorial/deployment",
        "title": "Deployment",
        "category": "Tutorial",
        "order": 10,
        "description": "Deploy to production - Azure Kubernetes Service, CI/CD pipelines, monitoring, and scaling",
        "tags": "tutorial, deployment, kubernetes, azure, cicd, monitoring",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/tutorial/inventory-service",
        "title": "Inventory Service",
        "category": "Tutorial",
        "order": 3,
        "description": "Build the Inventory Worker - event subscription, stock reservations, compensation, and perspectives",
        "tags": "tutorial, inventory-service, event-driven, perspectives, compensation",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/tutorial/notification-service",
        "title": "Notification Service",
        "category": "Tutorial",
        "order": 5,
        "description": "Build the Notification Worker - email/SMS notifications, template rendering, and delivery tracking",
        "tags": "tutorial, notification-service, email, sms, event-driven",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/tutorial/order-management",
        "title": "Order Management Service",
        "category": "Tutorial",
        "order": 2,
        "description": "Build the Order Service - HTTP API, command handling, event publishing, and PostgreSQL persistence",
        "tags": "tutorial, order-service, commands, events, http-api",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/tutorial/payment-processing",
        "title": "Payment Processing Service",
        "category": "Tutorial",
        "order": 4,
        "description": "Build the Payment Worker - payment gateway integration, distributed transactions, and compensation",
        "tags": "tutorial, payment-service, distributed-transactions, saga-pattern, compensation",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/tutorial/shipping-service",
        "title": "Shipping Service",
        "category": "Tutorial",
        "order": 6,
        "description": "Build the Shipping Worker - carrier API integration, shipment creation, tracking, and status updates",
        "tags": "tutorial, shipping-service, carrier-api, tracking, event-driven",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/tutorial/testing-strategy",
        "title": "Testing Strategy",
        "category": "Tutorial",
        "order": 9,
        "description": "Comprehensive testing strategy - unit tests, integration tests, e2e tests, mocks, and fixtures",
        "tags": "tutorial, testing, unit-tests, integration-tests, e2e-tests, tunit",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/tutorial/tutorial-overview",
        "title": "ECommerce Tutorial Overview",
        "category": "Tutorial",
        "order": 1,
        "description": "Build a complete e-commerce system with Whizbang - microservices, event sourcing, CQRS, and distributed messaging",
        "tags": "tutorial, ecommerce, microservices, event-sourcing, cqrs, distributed-systems",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/workers/database-readiness",
        "title": "Database Readiness",
        "category": "Workers",
        "order": 3,
        "description": "Database dependency coordination - IDatabaseReadinessCheck pattern, startup coordination, retry logic, and caching strategies",
        "tags": "database-readiness, dependency-coordination, startup, retry-logic, health-checks",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/workers/execution-lifecycle",
        "title": "Execution Lifecycle",
        "category": "Workers",
        "order": 2,
        "description": "Application startup and shutdown coordination - IExecutionStrategy lifecycle hooks, graceful shutdown with work draining, and worker coordination",
        "tags": "execution-lifecycle, startup, shutdown, graceful-shutdown, work-draining, lifecycle-hooks",
        "version": "v0.1.0"
      },
      {
        "slug": "v0.1.0/workers/perspective-worker",
        "title": "Perspective Worker",
        "category": "Workers",
        "order": 1,
        "description": "Background worker for processing perspective checkpoints - automatic checkpoint creation, polling workflow, error tracking, and startup coordination",
        "tags": "perspective-worker, checkpoints, background-worker, lease-based-coordination, error-tracking",
        "version": "v0.1.0"
      }
    ]
  },
  {
    "version": "v1.0.0",
    "metadata": {},
    "docs": [
      {
        "slug": "v1.0.0/core-concepts/routing",
        "title": "Routing",
        "category": "Core Concepts",
        "order": 999,
        "description": "# Namespace-Based Routing\n\nWhizbang uses namespace-based routing to determine where messages flow. Commands and events follow distinct routing patterns optimized for their specific use cases.\n\n## Overview\n\nRouting in Whizbang is built on two key principles:\n\n1. **Commands → Shared Inbox**: All commands route to a single shared \"inbox\" topic. Services filter by owned namespaces using routing key patterns.\n2. **Events → Namespace Topics**: Events publish to namespace-specific topics. Services subscribe directly to namespaces they care about.\n\nThis separation provides:\n- **Point-to-point delivery** for commands (exactly one handler)\n- **Pub/sub distribution** for events (multiple subscribers)\n- **Automatic subscription discovery** via source generation\n\n## Command Flow\n\nCommands follow a point-to-point pattern with namespace-based filtering:\n\n```\nBFF sends CreateTenantCommand (namespace: MyApp.Users.Commands)\n    ↓\nBFF Outbox → Broker \"inbox\" topic\n    ↓\n    RoutingKey: \"myapp.users.commands.createtenantcommand\"\n    ↓\nALL services subscribed to \"inbox\" (single shared topic)\n    ↓\nEach service filters by owned namespaces:\n    - User Service owns \"myapp.users.commands\" → RECEIVES\n    - Workflow Service owns \"myapp.workflow.commands\" → FILTERED OUT\n    ↓\nUser Service processes command\n```\n\n### How Command Filtering Works\n\nWhen a service starts, it declares which command namespaces it owns:\n\n```csharp\nservices.Configure<RoutingOptions>(opts => {\n  opts.OwnDomains(\"myapp.users.commands\");\n  opts.OwnDomains(\"myapp.inventory.commands\");\n});\n```\n\nThe `SharedTopicInboxStrategy` builds routing patterns from these namespaces:\n\n```csharp\n// Generated routing patterns:\n// - \"whizbang.core.commands.system.#\"  (always included)\n// - \"myapp.users.commands.#\"\n// - \"myapp.inventory.commands.#\"\n```\n\n**Note**: All services automatically subscribe to system commands (`whizbang.core.commands.system.#`) for framework-level operations.\n\n### Wildcard Namespaces\n\nSupport pattern matching for flexible ownership:\n\n```csharp\n// Own all commands under myapp.orders\nopts.OwnDomains(\"myapp.orders.*\");\n// Converts to pattern: \"myapp.orders.#\"\n```\n\n## Event Flow\n\nEvents follow a pub/sub pattern with namespace-based topics:\n\n```\nUser Service publishes TenantCreatedEvent (namespace: MyApp.Users.Events)\n    ↓\nUser Service Outbox → Broker topic \"myapp.users.events\"\n    ↓\n    RoutingKey: \"tenantcreatedevent\"\n    ↓\nServices subscribed to \"myapp.users.events\":\n    - BFF → RECEIVES\n    - Workflow Service → RECEIVES\n    - Notifications Service → RECEIVES\n```\n\n### Automatic Event Subscription Discovery\n\nEvent subscriptions are **automatically discovered** from your code via source generation:\n\n1. **Perspectives**: Events your service projects\n2. **Receptors**: Events your service handles\n\n```csharp\n// This perspective automatically subscribes to \"myapp.orders.events\"\n[Perspective<OrderSummary>]\npublic class OrderSummaryPerspective : IPerspective<OrderCreatedEvent> {\n  // OrderCreatedEvent is in namespace MyApp.Orders.Events\n}\n\n// This receptor automatically subscribes to \"myapp.payments.events\"\npublic class PaymentReceptor : IReceptor<PaymentCompletedEvent> {\n  // PaymentCompletedEvent is in namespace MyApp.Payments.Events\n}\n```\n\nThe `EventNamespaceRegistryGenerator` source generator extracts these namespaces at compile time:\n\n```csharp\n// Generated code (example)\npublic sealed class GeneratedEventNamespaceRegistry : IEventNamespaceRegistry {\n  public IReadOnlySet<string> GetPerspectiveEventNamespaces() =>\n    new HashSet<string>(StringComparer.OrdinalIgnoreCase) {\n      \"myapp.orders.events\"\n    };\n\n  public IReadOnlySet<string> GetReceptorEventNamespaces() =>\n    new HashSet<string>(StringComparer.OrdinalIgnoreCase) {\n      \"myapp.payments.events\"\n    };\n}\n```\n\n### Manual Event Subscriptions\n\nOverride or supplement auto-discovery with manual subscriptions:\n\n```csharp\nservices.Configure<RoutingOptions>(opts => {\n  // Explicitly subscribe to additional event namespaces\n  opts.SubscribeTo(\"myapp.notifications.events\");\n  opts.SubscribeTo(\"myapp.audit.events\");\n});\n```\n\n## System Commands\n\nAll services automatically subscribe to system commands for framework-level operations:\n\n```csharp\nnamespace Whizbang.Core.Commands.System;\n\n// Rebuild a perspective across all services\npublic record RebuildPerspectiveCommand(\n    string PerspectiveName,\n    long? FromEventId = null\n) : ICommand;\n\n// Clear cached data\npublic record ClearCacheCommand(\n    string? CacheKey = null,\n    string? CacheRegion = null\n) : ICommand;\n\n// Collect diagnostics from all services\npublic record DiagnosticsCommand(\n    DiagnosticType Type,\n    Guid? CorrelationId = null\n) : ICommand;\n\n// Pause message processing (coordinated maintenance)\npublic record PauseProcessingCommand(\n    int? DurationSeconds = null,\n    string? Reason = null\n) : ICommand;\n\n// Resume message processing\npublic record ResumeProcessingCommand(\n    string? Reason = null\n) : ICommand;\n```\n\n### Sending System Commands\n\n```csharp\n// Rebuild a perspective across all services\nawait dispatcher.SendAsync(new RebuildPerspectiveCommand(\"OrderSummary\"));\n\n// Clear all caches\nawait dispatcher.SendAsync(new ClearCacheCommand());\n\n// Pause processing for 5 minutes\nawait dispatcher.SendAsync(new PauseProcessingCommand(\n    DurationSeconds: 300,\n    Reason: \"Scheduled maintenance\"\n));\n```\n\n## Configuration\n\n### Fluent Configuration with WithRouting {#with-routing}\n\nThe recommended approach uses the fluent `WithRouting()` extension method:\n\n```csharp\nservices.AddWhizbang()\n    .WithRouting(routing => {\n        routing\n            .OwnDomains(\"myapp.users.commands\")\n            .SubscribeTo(\"myapp.notifications.events\")\n            .Inbox.UseSharedTopic(\"inbox\");\n    })\n    .WithEFCore<MyDbContext>()\n    .WithDriver.Postgres\n    .AddTransportConsumer();  // Auto-generates subscriptions!\n```\n\nThis approach:\n- **Chains with other Whizbang configuration** - Integrates with EF Core, drivers, and transport setup\n- **Auto-generates subscriptions** - When paired with `AddTransportConsumer()`, subscriptions are created automatically\n- **Type-safe** - All configuration is compile-time verified\n\n### Complete Example\n\n```csharp\n// User Service - handles user commands, subscribes to order events\nservices.AddWhizbang()\n    .WithRouting(routing => {\n        // Commands this service handles\n        routing.OwnDomains(\"myapp.users.commands\");\n\n        // Events are auto-discovered from perspectives/receptors\n        // Manual override (adds to auto-discovered):\n        routing.SubscribeTo(\"myapp.notifications.events\");\n\n        // Inbox strategy\n        routing.Inbox.UseSharedTopic(\"inbox\");\n    })\n    .AddTransportConsumer();\n\n// BFF Service - sends commands, receives events\nservices.AddWhizbang()\n    .WithRouting(routing => {\n        // No OwnDomains (BFF doesn't handle commands directly)\n        // Events auto-discovered from its receptors/perspectives\n        routing.Inbox.UseSharedTopic(\"inbox\");\n    })\n    .AddTransportConsumer();\n```\n\n### Legacy Configuration\n\nFor backwards compatibility, you can still configure routing options directly:\n\n```csharp\nservices.Configure<RoutingOptions>(opts => {\n  opts.OwnDomains(\"myapp.users.commands\");\n  opts.SubscribeTo(\"myapp.notifications.events\");\n});\n```\n\n### Strongly-Typed Configuration\n\nUse the generic overloads for compile-time safety and refactor-friendly configuration:\n\n```csharp\nservices.Configure<RoutingOptions>(opts => {\n  // Strongly-typed: extracts namespace from the type\n  opts.OwnNamespaceOf<CreateUserCommand>()      // \"myapp.users.commands\"\n      .OwnNamespaceOf<UpdateInventoryCommand>() // \"myapp.inventory.commands\"\n      .SubscribeToNamespaceOf<OrderCreatedEvent>()   // \"myapp.orders.events\"\n      .SubscribeToNamespaceOf<PaymentCompletedEvent>(); // \"myapp.payments.events\"\n\n  // Can mix with string-based for wildcards\n  opts.OwnDomains(\"myapp.legacy.*\");\n});\n```\n\n**Benefits:**\n- **Compile-time safety** - Invalid types won't compile\n- **Refactor-friendly** - Rename/move types automatically updates references\n- **IDE navigation** - Ctrl+click to go to type definition\n- **No magic strings** - For known namespaces\n\n### Inbox Strategies\n\nTwo inbox routing strategies are available:\n\n#### SharedTopicInboxStrategy (Default)\n\nAll commands go to a single \"inbox\" topic with namespace-based filtering:\n\n```csharp\nservices.Configure<RoutingOptions>(opts => {\n  opts.Inbox.UseSharedTopic(\"inbox\");  // Default\n});\n```\n\n#### DomainTopicInboxStrategy\n\nEach domain gets its own inbox topic:\n\n```csharp\nservices.Configure<RoutingOptions>(opts => {\n  opts.Inbox.UseDomainTopics(\".in\");\n  // Creates topics: \"myapp.users.in\", \"myapp.orders.in\", etc.\n});\n```\n\n## Domain Topic Provisioning {#domain-topic-provisioning}\n\n:::new\nWhen a service declares domain ownership via `OwnDomains()`, Whizbang automatically provisions the corresponding topics/exchanges on the message broker at worker startup. This ensures the domain owner (publisher) creates infrastructure that subscribers will use.\n:::\n\n### How It Works\n\nAt `TransportConsumerWorker` startup, before creating subscriptions:\n\n1. The worker checks for a registered `IInfrastructureProvisioner`\n2. If present, it calls `ProvisionOwnedDomainsAsync()` with the service's owned domains\n3. The provisioner creates topics/exchanges for each owned domain\n4. Then subscriptions are created as normal\n\n```csharp\n// When you configure:\nservices.AddWhizbang()\n    .WithRouting(routing => {\n        routing.OwnDomains(\"myapp.users\", \"myapp.orders\");\n    })\n    .AddTransportConsumer();\n\n// At startup, these topics are automatically provisioned:\n// - myapp.users (topic/exchange)\n// - myapp.orders (topic/exchange)\n```\n\n### Transport-Specific Behavior\n\n| Transport | Provisioned Resource | Idempotent |\n|",
        "tags": [],
        "version": "v1.0.0"
      },
      {
        "slug": "v1.0.0/core-concepts/scoping",
        "title": "Scoping",
        "category": "Core Concepts",
        "order": 999,
        "description": "# Scoping System\n\nWhizbang's scoping system provides flexible multi-tenancy and data isolation through composable filters, enabling tenant, user, organization, and principal-based access patterns.\n\n## Overview\n\nScoping in Whizbang separates data isolation concerns from your domain models:\n\n- **PerspectiveScope** - Metadata stored with each row (TenantId, UserId, etc.)\n- **ScopeFilter** - Composable flags for query filtering\n- **ScopeFilterBuilder** - Builds filter info from flags and context\n- **IScopedLensFactory** - Resolves lenses with scope filters applied\n\n## PerspectiveScope\n\n`PerspectiveScope` is stored in the `scope` column of perspective rows, separate from your data model.\n\n```csharp\npublic record PerspectiveScope {\n  // Standard scope properties\n  public string? TenantId { get; init; }\n  public string? UserId { get; init; }\n  public string? OrganizationId { get; init; }\n  public string? CustomerId { get; init; }\n\n  // Security principal access list\n  public IReadOnlyList<SecurityPrincipalId>? AllowedPrincipals { get; init; }\n\n  // Custom extension properties\n  public IReadOnlyDictionary<string, string?>? Extensions { get; init; }\n\n  // Unified indexer access\n  public string? this[string key] => ...;\n}\n```\n\n### Why Separate from Data?\n\nStoring scope separately from your domain data provides:\n\n1. **Clean domain models** - Your `Order` class doesn't need `TenantId`\n2. **Consistent filtering** - All perspectives filter the same way\n3. **Flexible extensions** - Add custom scope properties without schema changes\n4. **Security isolation** - Scope enforcement happens at infrastructure level\n\n### Accessing Scope Values\n\n```csharp\nvar scope = new PerspectiveScope {\n  TenantId = \"tenant-123\",\n  UserId = \"user-456\",\n  Extensions = new Dictionary<string, string?> {\n    [\"department\"] = \"Engineering\",\n    [\"region\"] = \"us-west\"\n  }\n};\n\n// Via properties\nvar tenant = scope.TenantId;  // \"tenant-123\"\n\n// Via indexer (standard + extensions)\nvar tenant = scope[\"TenantId\"];     // \"tenant-123\"\nvar dept = scope[\"department\"];     // \"Engineering\"\nvar unknown = scope[\"unknown\"];     // null\n```\n\n## Scope Filters\n\n`ScopeFilter` is a flags enum for composable filtering.\n\n```csharp\n[Flags]\npublic enum ScopeFilter {\n  None = 0,           // No filtering (global access)\n  Tenant = 1 << 0,    // Filter by TenantId\n  Organization = 1 << 1,\n  Customer = 1 << 2,\n  User = 1 << 3,      // Filter by UserId\n  Principal = 1 << 4  // Filter by security principal overlap\n}\n```\n\n### Filter Composition\n\nCombine filters with bitwise OR:\n\n```csharp\n// Single filter\nvar tenantOnly = ScopeFilter.Tenant;\n\n// Multiple filters (AND'd together)\nvar tenantAndUser = ScopeFilter.Tenant | ScopeFilter.User;\n\n// Complex combination\nvar complex = ScopeFilter.Tenant | ScopeFilter.Organization | ScopeFilter.Principal;\n```\n\n### Filter Application\n\n| Filter | Generated WHERE |\n|",
        "tags": [],
        "version": "v1.0.0"
      },
      {
        "slug": "v1.0.0/core-concepts/security",
        "title": "Security",
        "category": "Core Concepts",
        "order": 999,
        "description": "# Security System\n\nWhizbang provides a comprehensive security system supporting RBAC (Role-Based Access Control) and ABAC (Attribute-Based Access Control) patterns with composable scope filters, permission checks, and security event auditing.\n\n## Overview\n\nThe security system consists of:\n\n- **Permissions** - Type-safe permission identifiers with wildcard matching\n- **Roles** - Named collections of permissions\n- **Scope Context** - Ambient security context for current operation\n- **Security Principals** - Users, groups, and services with hierarchical membership\n- **Scoped Lens Factory** - Permission-aware lens resolution with composable filters\n- **System Events** - Security audit trail (AccessDenied, AccessGranted, etc.)\n\n## Permissions\n\nPermissions use a `resource:action` pattern and support wildcard matching.\n\n```csharp\n// Factory methods for common patterns\nvar readOrders = Permission.Read(\"orders\");      // \"orders:read\"\nvar writeOrders = Permission.Write(\"orders\");    // \"orders:write\"\nvar deleteOrders = Permission.Delete(\"orders\");  // \"orders:delete\"\nvar adminOrders = Permission.Admin(\"orders\");    // \"orders:admin\"\nvar allOrders = Permission.All(\"orders\");        // \"orders:*\"\n\n// Custom permissions\nvar permission = new Permission(\"orders:export\");\n\n// Wildcard matching\nvar allResources = new Permission(\"*:*\");        // Matches everything\nvar allOrderActions = Permission.All(\"orders\");  // Matches orders:*\n```\n\n### Wildcard Rules\n\n| Permission | Matches |\n|",
        "tags": [],
        "version": "v1.0.0"
      },
      {
        "slug": "v1.0.0/core-concepts/system-events",
        "title": "System Events",
        "category": "Core Concepts",
        "order": 999,
        "description": "",
        "tags": [],
        "version": "v1.0.0"
      },
      {
        "slug": "v1.0.0/core-concepts/transport-consumer",
        "title": "Transport Consumer",
        "category": "Core Concepts",
        "order": 999,
        "description": "# Transport Consumer\n\nThe transport consumer automatically subscribes to message broker destinations and processes incoming messages. When combined with `WithRouting()`, subscriptions are auto-generated from your routing configuration.\n\n## Overview\n\nThe `AddTransportConsumer()` extension method:\n\n1. **Auto-generates subscriptions** from `RoutingOptions` configured via `WithRouting()`\n2. **Registers `TransportConsumerOptions`** with populated destinations\n3. **Starts `TransportConsumerWorker`** as a hosted service\n\n## Auto-Configuration {#auto-configuration}\n\nThe recommended approach chains `WithRouting()` and `AddTransportConsumer()`:\n\n```csharp\nservices.AddWhizbang()\n    .WithRouting(routing => {\n        routing\n            .OwnDomains(\"myapp.orders.commands\")\n            .SubscribeTo(\"myapp.payments.events\")\n            .Inbox.UseSharedTopic(\"inbox\");\n    })\n    .WithEFCore<OrderDbContext>()\n    .WithDriver.Postgres\n    .AddTransportConsumer();\n```\n\nThis auto-generates subscriptions:\n- **Inbox subscription** from `OwnDomains()` - Filters commands by namespace pattern\n- **Event subscriptions** from `SubscribeTo()` - Subscribes to each namespace topic\n- **Auto-discovered events** from perspectives and receptors\n\n### What Gets Generated\n\nFor the configuration above, `AddTransportConsumer()` generates:\n\n| Destination | Address | Routing Key |\n|",
        "tags": [],
        "version": "v1.0.0"
      },
      {
        "slug": "v1.0.0/data/efcore-json-configuration",
        "title": "EF Core 10 JSON Configuration",
        "category": "Data",
        "order": 10,
        "description": "Configuring EF Core 10 with custom JSON converters for JSONB columns",
        "tags": "efcore, json, jsonb, postgresql, npgsql, converters",
        "version": "v1.0.0"
      },
      {
        "slug": "v1.0.0/data/schema-migration",
        "title": "Schema Migration",
        "category": "data",
        "order": 999,
        "description": "# Schema Migration\n\nWhizbang provides automatic schema management for perspective tables, with built-in drift detection and safe rename operations. This page covers how Whizbang handles schema changes across deployments.\n\n## Automatic Schema Creation\n\nWhen your application starts, Whizbang automatically creates all required infrastructure tables and perspective tables:\n\n```csharp\n// In your startup code\nawait dbContext.EnsureWhizbangDatabaseInitializedAsync();\n```\n\nThis single call:\n1. Creates infrastructure tables (`wh_inbox`, `wh_outbox`, `wh_event_store`, etc.)\n2. Creates perspective tables for all discovered perspectives\n3. Registers perspectives in the [perspective registry](/docs/v1.0.0/perspectives/registry)\n4. Detects and logs any schema drift\n\n## Schema Drift Detection\n\nSchema drift occurs when your C# perspective definition doesn't match the database table. Whizbang detects this by comparing SHA-256 hashes of the schema definition.\n\n### Detection Flow\n\n```\n┌─────────────────────┐\n│  Compile Time       │\n├─────────────────────┤\n│ Generate schema     │\n│ JSON from C# class  │\n│ Compute SHA-256     │\n│ hash of schema      │\n└─────────┬───────────┘\n          │\n          ▼\n┌─────────────────────┐\n│  Runtime            │\n├─────────────────────┤\n│ Compare hash with   │\n│ stored hash in      │\n│ perspective_registry│\n└─────────┬───────────┘\n          │\n          ▼\n┌─────────────────────┐\n│  If Different       │\n├─────────────────────┤\n│ Log drift warning   │\n│ Update registry     │\n└─────────────────────┘\n```\n\n### What Causes Drift\n\n| Change Type | Example | Drift Detected? |\n|",
        "tags": [],
        "version": "v1.0.0"
      },
      {
        "slug": "v1.0.0/guides/implementing-multi-tenancy",
        "title": "Implementing Multi Tenancy",
        "category": "guides",
        "order": 999,
        "description": "",
        "tags": [],
        "version": "v1.0.0"
      },
      {
        "slug": "v1.0.0/lenses/raw-sql",
        "title": "Raw Sql",
        "category": "lenses",
        "order": 999,
        "description": "",
        "tags": [],
        "version": "v1.0.0"
      },
      {
        "slug": "v1.0.0/lenses/vector-search",
        "title": "Vector Search",
        "category": "lenses",
        "order": 999,
        "description": "# Vector Similarity Search\n\nWhizbang supports pgvector similarity queries for semantic search, embeddings, and AI/ML workloads.\n\n## Prerequisites\n\nWhen using `[VectorField]` attributes on your perspective models, you must add the Pgvector.EntityFrameworkCore package:\n\n```xml\n<PackageReference Include=\"Pgvector.EntityFrameworkCore\" Version=\"0.3.0\" />\n```\n\nIf you forget this package, the WHIZ070 diagnostic will guide you:\n\n> WHIZ070: Property 'Embedding' uses [VectorField] but Pgvector.EntityFrameworkCore package is not referenced.\n\n## Defining Vector Fields\n\nAdd `[VectorField]` to properties in your perspective model:\n\n```csharp\npublic class DocumentModel {\n  public Guid Id { get; init; }\n  public string Title { get; init; } = \"\";\n  public string Content { get; init; } = \"\";\n\n  [VectorField(1536)]  // OpenAI ada-002 dimensions\n  public float[]? ContentEmbedding { get; init; }\n\n  [VectorField(1536)]  // For comparison operations\n  public float[]? SummaryEmbedding { get; init; }\n}\n\npublic class UserPreferenceModel {\n  public Guid UserId { get; init; }\n\n  [VectorField(1536)]\n  public float[]? PreferenceEmbedding { get; init; }\n}\n```\n\nThe generator creates pgvector shadow properties with appropriate indexes.\n\n## Usage Patterns\n\nAll methods use **strongly-typed lambda selectors** for compile-time safety.\n\n### Pattern 1: App-Side Vector (Search Query)\n\nUse when the search vector comes from your application (e.g., embedding a user's search query):\n\n```csharp\n// Get embedding from your embedding service (OpenAI, etc.)\nvar searchEmbedding = await embeddingService.EmbedAsync(userSearchQuery);\n\n// Find documents similar to the search query\nvar results = await documentLens.Query\n    .OrderByCosineDistance(m => m.ContentEmbedding, searchEmbedding)\n    .Take(10)\n    .ToListAsync();\n```\n\n**SQL Generated:**\n```sql\nSELECT * FROM documents\nORDER BY content_embedding <=> @p0 ASC\nLIMIT 10\n```\n\n### Pattern 2: Same-Table Column Comparison\n\nUse when comparing two vector columns on the same row (100% SQL, no vector data round-trip):\n\n```csharp\n// Find documents where content differs significantly from summary\n// (potential quality issue - summary doesn't match content)\nvar mismatchedDocs = await documentLens.Query\n    .Where(m => m.ContentEmbedding != null && m.SummaryEmbedding != null)\n    .OrderByCosineDistance(m => m.ContentEmbedding, m => m.SummaryEmbedding)\n    .ThenByDescending(m => m.Data.CreatedAt)  // Most different first, then newest\n    .Take(20)\n    .ToListAsync();\n\n// Find documents where content and summary are similar (well-summarized)\nvar wellSummarized = await documentLens.Query\n    .WithinCosineDistance(m => m.ContentEmbedding, m => m.SummaryEmbedding, threshold: 0.2)\n    .ToListAsync();\n```\n\n**SQL Generated:**\n```sql\n-- No vector data sent to/from C# - all computed in PostgreSQL!\nSELECT * FROM documents\nWHERE content_embedding IS NOT NULL AND summary_embedding IS NOT NULL\nORDER BY content_embedding <=> summary_embedding ASC\nLIMIT 20\n```\n\n### Pattern 3: Cross-Table Comparison (Joins)\n\nUse when comparing vectors from different tables:\n\n```csharp\n// Find documents that match a user's preferences\nvar userId = currentUserId;\n\nvar recommendations = await documentLens.Query\n    .SelectMany(\n        doc => userPreferenceLens.Query.Where(up => up.Data.UserId == userId),\n        (doc, pref) => new { Document = doc, Preference = pref })\n    .OrderByCosineDistance(\n        x => x.Document.Data.ContentEmbedding,    // From documents table\n        x => x.Preference.Data.PreferenceEmbedding)  // From user_preferences table\n    .Select(x => x.Document)\n    .Take(10)\n    .ToListAsync();\n```\n\n**SQL Generated:**\n```sql\nSELECT d.* FROM documents d\nJOIN user_preferences up ON up.user_id = @userId\nORDER BY d.content_embedding <=> up.preference_embedding ASC\nLIMIT 10\n```\n\n### Pattern 4: Filtering by Distance Threshold\n\nUse when you only want results within a certain similarity range:\n\n```csharp\nvar searchEmbedding = await embeddingService.EmbedAsync(userQuery);\n\n// Only return documents with cosine distance < 0.3 (very similar)\nvar closeMatches = await documentLens.Query\n    .WithinCosineDistance(m => m.ContentEmbedding, searchEmbedding, threshold: 0.3)\n    .OrderByCosineDistance(m => m.ContentEmbedding, searchEmbedding)\n    .ToListAsync();\n```\n\n**SQL Generated:**\n```sql\nSELECT * FROM documents\nWHERE content_embedding <=> @p0 < 0.3\nORDER BY content_embedding <=> @p0 ASC\n```\n\n### Pattern 5: Combined Filter + Sort + Project\n\nUse when you need distance/similarity scores in your results:\n\n:::updated\n**Important**: `WithCosineDistance` must be used as the **final projection** before `ToListAsync()`.\nYou cannot chain `.OrderBy(r => r.Distance)` or `.Where(r => r.Distance < x)` after it - use\n`OrderByCosineDistance` and `WithinCosineDistance` for SQL-side operations first.\n:::\n\n```csharp\nvar searchEmbedding = await embeddingService.EmbedAsync(userQuery);\n\n// Filter -> Sort -> Project with scores\nvar results = await documentLens.Query\n    .WithinCosineDistance(m => m.ContentEmbedding, searchEmbedding, threshold: 0.5)\n    .OrderByCosineDistance(m => m.ContentEmbedding, searchEmbedding)\n    .WithCosineDistance(m => m.ContentEmbedding, searchEmbedding)\n    .Take(10)\n    .ToListAsync();\n\nforeach (var result in results) {\n  Console.WriteLine($\"{result.Row.Data.Title}: {result.Similarity:P0} match\");\n  // Output: \"My Document: 95% match\"\n}\n```\n\nReturns `VectorSearchResult<TModel>` with:\n- `Row` - The perspective row\n- `Distance` - Cosine distance (0 = identical, 2 = opposite)\n- `Similarity` - Similarity score (1 = identical, -1 = opposite)\n\n## Query Extension Reference\n\n### Ordering Methods\n\n| Method | PostgreSQL Operator | Use Case |\n|",
        "tags": [],
        "version": "v1.0.0"
      },
      {
        "slug": "v1.0.0/perspectives/registry",
        "title": "Registry",
        "category": "perspectives",
        "order": 999,
        "description": "# Perspective Registry\n\nThe perspective registry is a system table that tracks the mapping between your C# perspective types and their corresponding database tables. It enables automatic schema management, drift detection, and safe table renaming across deployments.\n\n## Overview\n\nWhen Whizbang creates perspective tables, it registers metadata about each perspective in the `wh_perspective_registry` table. This enables:\n\n| Feature | Description |\n|",
        "tags": [],
        "version": "v1.0.0"
      },
      {
        "slug": "v1.0.0/perspectives/table-naming",
        "title": "Table Naming",
        "category": "perspectives",
        "order": 999,
        "description": "# Perspective Table Naming\n\nWhizbang automatically generates database table names for your perspectives using configurable naming conventions. By default, common suffixes like `Projection`, `Model`, and `Dto` are stripped to create cleaner, shorter table names.\n\n## Default Behavior\n\nWhen you define a perspective, Whizbang converts the class name to snake_case and adds the `wh_per_` prefix:\n\n| C# Class Name | Default Table Name |\n|",
        "tags": [],
        "version": "v1.0.0"
      },
      {
        "slug": "v1.0.0/perspectives/temporal",
        "title": "Temporal",
        "category": "perspectives",
        "order": 999,
        "description": "# Temporal Perspectives\n\nTemporal perspectives create append-only logs where each event creates a NEW row rather than updating existing rows. This pattern is ideal for activity feeds, audit logs, and full history tracking.\n\n## Overview\n\n| Pattern | Interface | Storage | Use Case |\n|",
        "tags": [],
        "version": "v1.0.0"
      }
    ]
  },
  {
    "state": "drafts",
    "metadata": {
      "folderType": "state",
      "state": "drafts",
      "description": "Documentation currently being written and developed"
    },
    "docs": [
      {
        "slug": "drafts/attributes/must-exist",
        "title": "MustExist Attribute",
        "category": "Attributes",
        "order": 999,
        "description": "Marks a perspective Apply method as requiring the model to already exist",
        "tags": [
          "attributes",
          "mustexist",
          "perspectives",
          "validation",
          "source-generator"
        ],
        "version": "drafts"
      },
      {
        "slug": "drafts/core-concepts/model-action",
        "title": "Model Actions - Perspective Deletion Support",
        "category": "Core Concepts",
        "order": 4,
        "description": "Control perspective model lifecycle with ModelAction - support soft delete, hard delete (purge), and conditional updates in pure Apply methods",
        "tags": "perspectives, deletion, soft-delete, purge, model-action, apply-result, cqrs, read-models",
        "version": "drafts"
      },
      {
        "slug": "drafts/test-error-display",
        "title": "Test Error Display",
        "category": "Test",
        "order": 999,
        "description": "",
        "tags": [],
        "version": "drafts"
      }
    ]
  },
  {
    "state": "proposals",
    "metadata": {
      "folderType": "state",
      "state": "proposals",
      "description": "Proposed features and documentation under consideration"
    },
    "docs": [
      {
        "slug": "proposals/advanced-features",
        "title": "Advanced Features",
        "category": "Architecture & Design",
        "order": 10,
        "description": "\n# Advanced Features\n\nWhizbang includes advanced features for enterprise scenarios, including cross-aggregate transactions, performance monitoring, Kubernetes operators, and debugging tools.\n\n## Cross-Aggregate Transactions\n\n### Unit of Work Pattern\n\n**Coordinate transactions across multiple aggregates** while maintaining consistency:\n\n```csharp{title=\"Unit of Work Configuration\" description=\"Unit of work pattern configuration for cross-aggregate transactions\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Advanced-Features\", \"Unit-of-Work\", \"Cross-Aggregate-Transactions\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.UseUnitOfWork(uow => {\n        uow.IsolationLevel = IsolationLevel.ReadCommitted;\n        uow.Timeout = TimeSpan.FromSeconds(30);\n        uow.EnableDistributedTransactions = true;\n    });\n});\n\n```csharp{title=\"Multi-Aggregate Command Handler\" description=\"Command handler using unit of work for coordinated multi-aggregate operations\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Advanced-Features\", \"Unit-of-Work\", \"Command-Handlers\"] framework=\"NET8\"}\n// Usage in handlers\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder> {\n    private readonly IUnitOfWork _unitOfWork;\n    private readonly IRepository<Order> _orderRepository;\n    private readonly IRepository<Customer> _customerRepository;\n    private readonly IRepository<Product> _productRepository;\n    \n    public async Task<OrderPlaced> Handle(PlaceOrder command) {\n        return await _unitOfWork.ExecuteAsync(async () => {\n            // Load multiple aggregates\n            var customer = await _customerRepository.Load(command.CustomerId);\n            var products = await _productRepository.LoadMany(command.ProductIds);\n            \n            // Validate business rules across aggregates\n            if (!customer.CanPlaceOrder(command.Total)) {\n                throw new DomainException(\"Customer credit limit exceeded\");\n            }\n            \n            foreach (var product in products) {\n                if (!product.IsAvailable(command.GetQuantity(product.Id))) {\n                    throw new DomainException($\"Product {product.Id} not available\");\n                }\n            }\n            \n            // Create new aggregate\n            var order = new Order(command.CustomerId, command.Items);\n            \n            // Update existing aggregates\n            customer.ReserveCreditLimit(command.Total);\n            foreach (var product in products) {\n                product.ReserveStock(command.GetQuantity(product.Id));\n            }\n            \n            // Save all changes in single transaction\n            await _orderRepository.Save(order);\n            await _customerRepository.Save(customer);\n            await _productRepository.SaveMany(products);\n            \n            return new OrderPlaced(order.Id, command.CustomerId, DateTimeOffset.UtcNow);\n        });\n    }\n}\n```\n\n### Distributed Transactions with Saga Fallback\n\n```csharp{title=\"Distributed Transactions with Saga Fallback\" description=\"Distributed transactions with saga fallback for complex operations\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Advanced-Features\", \"Cross-Aggregate-Transactions\", \"Saga-Fallback\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.CrossAggregateTransactions(transactions => {\n        transactions.DefaultStrategy = TransactionStrategy.UnitOfWork;\n        transactions.FallbackToSaga = true;\n        transactions.SagaTimeoutMs = 30000;\n        \n        // Configure per-operation\n        transactions.ForOperation<PlaceOrder>(op => {\n            op.Strategy = TransactionStrategy.UnitOfWork;\n            op.MaxAggregatesInTransaction = 5;\n        });\n        \n        transactions.ForOperation<ComplexOrderWorkflow>(op => {\n            op.Strategy = TransactionStrategy.Saga; // Force saga for complex operations\n        });\n    });\n});\n```\n\n### Transaction Boundaries\n\n```csharp{title=\"Transaction Boundary Implementation\" description=\"Transaction boundary implementation with automatic rollback on failure\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Advanced-Features\", \"Transaction-Boundaries\", \"Error-Handling\"] framework=\"NET8\"}\npublic class TransactionBoundary : ITransactionBoundary {\n    public async Task<T> ExecuteInTransaction<T>(Func<Task<T>> operation) {\n        using var scope = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled);\n        \n        try {\n            var result = await operation();\n            scope.Complete();\n            return result;\n        } catch (Exception ex) {\n            // Transaction automatically rolled back\n            _logger.LogError(ex, \"Transaction failed and was rolled back\");\n            throw;\n        }\n    }\n}\n```\n\n## Performance Budgets & Monitoring\n\n> **📋 Detailed Coverage**: For comprehensive performance budgets, observability, and monitoring details, see [**Observability & Metrics**](./observability-metrics.md)\n\n### Performance Budget Overview\n\n**Performance budgets** provide automatic tracking and alerting for handler performance:\n\n```csharp{title=\"Performance Budget Attributes\" description=\"Performance budget attributes for automatic tracking and alerting\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Advanced-Features\", \"Performance-Budgets\", \"Monitoring\"] framework=\"NET8\"}\n[PerformanceBudget(MaxLatencyMs = 100)]\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder> {\n    // Automatic budget tracking and violation alerts\n}\n```\n\n## OpenTelemetry Integration\n\n> **📋 Detailed Coverage**: For complete OpenTelemetry setup, metrics, and distributed tracing, see [**Observability & Metrics**](./observability-metrics.md)\n\n```csharp{title=\"OpenTelemetry Integration Configuration\" description=\"OpenTelemetry integration configuration for comprehensive observability\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Advanced-Features\", \"OpenTelemetry\", \"Observability\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.Observability(observability => {\n        observability.UseOpenTelemetry(otel => {\n            otel.TraceAllCommands = true;\n            otel.TraceAllEvents = true;\n            otel.TraceProjections = true;\n            otel.TraceSagas = true;\n            \n            // Custom metrics\n            otel.EmitCustomMetrics = true;\n            otel.MetricsPrefix = \"whizbang\";\n            \n            // Performance budget violations\n            otel.TracePerformanceBudgetViolations = true;\n            otel.AlertOnBudgetViolation = true;\n        });\n    });\n});\n\n```csharp{title=\"Custom Performance Tracking Handler\" description=\"Custom performance tracking handler with detailed metrics collection\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Advanced-Features\", \"Performance-Tracking\", \"Custom-Metrics\"] framework=\"NET8\"}\n// Custom performance tracking\npublic class PerformanceTrackingHandler<T> : ICommandHandler<T> where T : ICommand {\n    private readonly ICommandHandler<T> _innerHandler;\n    private readonly IMetrics _metrics;\n    \n    public async Task Handle(T command) {\n        using var activity = Activity.StartActivity($\"Command.{typeof(T).Name}\");\n        using var timer = _metrics.StartTimer($\"command.{typeof(T).Name.ToLower()}.duration\");\n        \n        var startMemory = GC.GetTotalMemory(false);\n        var stopwatch = Stopwatch.StartNew();\n        \n        try {\n            await _innerHandler.Handle(command);\n            \n            // Record success metrics\n            _metrics.IncrementCounter($\"command.{typeof(T).Name.ToLower()}.success\");\n        } catch (Exception ex) {\n            // Record failure metrics\n            _metrics.IncrementCounter($\"command.{typeof(T).Name.ToLower()}.failure\", \n                new[] { (\"error_type\", ex.GetType().Name) });\n            \n            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);\n            throw;\n        } finally {\n            stopwatch.Stop();\n            var endMemory = GC.GetTotalMemory(false);\n            \n            // Record performance metrics\n            activity?.SetTag(\"duration_ms\", stopwatch.ElapsedMilliseconds);\n            activity?.SetTag(\"memory_allocated_bytes\", endMemory - startMemory);\n            \n            _metrics.RecordValue($\"command.{typeof(T).Name.ToLower()}.memory\", endMemory - startMemory);\n        }\n    }\n}\n```\n\n## Kubernetes Operator Features\n\n> **📋 Detailed Coverage**: For production deployment patterns, health checks, and operational best practices, see [**Deployment & Operations**](./deployment-operations.md)\n\n### Auto-Scaling Projection Workers\n\n```yaml\n",
        "tags": "unit-of-work, performance-budgets, kubernetes-operator, tracing, debugging",
        "version": "proposals"
      },
      {
        "slug": "proposals/concurrency-control",
        "title": "Concurrency Control",
        "category": "Architecture & Design",
        "order": 5,
        "description": "\n# Concurrency Control\n\nWhizbang provides flexible concurrency control mechanisms to handle concurrent updates to aggregates, supporting multiple strategies that developers can choose globally or per-operation.\n\n## Concurrency Strategies\n\n### A. Expected Version (Default)\n\n**Standard event sourcing pattern** - explicitly specify the expected version:\n\n```csharp{title=\"Expected Version Concurrency Control\" description=\"Standard event sourcing pattern with explicit version checking\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"expected-version\", \"optimistic-locking\", \"event-sourcing\"] framework=\"NET8\"}\n// Load aggregate at version 5\nvar order = await repository.Load<Order>(orderId);\n\n// Make changes\norder.AddItem(new OrderItem(\"Product\", 10.00m));\n\n// Save with expected version - will fail if current version != 5\nawait repository.Save(order, expectedVersion: 5);\n```\n\n**Benefits**:\n- ✅ Detects all conflicts\n- ✅ Standard event sourcing pattern\n- ✅ Explicit and predictable\n\n**Drawbacks**:\n- ❌ Requires version tracking\n- ❌ Manual conflict resolution\n\n### B. Timestamp-Based (Last-Modified)\n\n**HTTP-style semantics** using timestamps:\n\n```csharp{title=\"Timestamp-Based Concurrency Control\" description=\"HTTP-style semantics using last-modified timestamps\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"timestamp-based\", \"http-semantics\", \"last-modified\"] framework=\"NET8\"}\nvar order = await repository.Load<Order>(orderId);\nvar lastModified = order.LastModified;\n\n// Make changes\norder.AddItem(new OrderItem(\"Product\", 10.00m));\n\n// Save with timestamp check\nawait repository.Save(order, ifNotModifiedSince: lastModified);\n```\n\n**Benefits**:\n- ✅ Familiar HTTP semantics\n- ✅ No version number tracking\n\n**Drawbacks**:\n- ❌ Clock skew potential\n- ❌ Less precise than versions\n\n### C. Automatic Retry with Conflict Resolution\n\n**Smart retry with configurable resolution strategies**:\n\n```csharp{title=\"Automatic Retry with Conflict Resolution\" description=\"Smart retry with configurable resolution strategies via policies\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"concurrency\", \"automatic-retry\", \"conflict-resolution\", \"policy-engine\"] framework=\"NET8\"}\n// Configure automatic retry via policies\nservices.AddWhizbang(options => {\n    options.Policies(policies => {\n        // Default strategy for all operations\n        policies.When(ctx => true)\n                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.AutomaticRetry))\n                .And(config => config.SetRetryAttempts(3))\n                .And(config => config.SetRetryDelay(TimeSpan.FromMilliseconds(100)));\n        \n        // Custom conflict resolution for Order aggregates\n        policies.When(ctx => ctx.MatchesAggregate<Order>())\n                .Then(config => config.SetConflictResolver((current, attempted) => {\n                    // Custom merge logic\n                    var merged = current.Copy();\n                    merged.MergeChanges(attempted);\n                    return merged;\n                }));\n    });\n});\n\n// Save with automatic retry\nawait repository.Save(order); // Retries automatically on conflict\n```\n\n**Benefits**:\n- ✅ Handles most conflicts automatically\n- ✅ Better developer experience\n- ✅ Configurable retry policies\n\n**Drawbacks**:\n- ❌ Complex to implement\n- ❌ Not all conflicts can be auto-resolved\n\n## Marten-Inspired Extensions\n\nDrawing from Marten's concurrency features, Whizbang also supports:\n\n### D. Token-Based Concurrency\n\n**Using opaque tokens** instead of version numbers:\n\n```csharp{title=\"Token-Based Concurrency Control\" description=\"Using opaque tokens instead of version numbers\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"token-based\", \"opaque-tokens\", \"marten-inspired\"] framework=\"NET8\"}\nvar (order, token) = await repository.LoadWithToken<Order>(orderId);\n\n// Make changes\norder.AddItem(new OrderItem(\"Product\", 10.00m));\n\n// Save with token\nawait repository.Save(order, concurrencyToken: token);\n```\n\n### E. Revision-Based Tracking\n\n**Marten-style revision tracking** with metadata:\n\n```csharp{title=\"Revision-Based Tracking\" description=\"Marten-style revision tracking with automatic metadata\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"revision-based\", \"marten-style\", \"metadata\"] framework=\"NET8\"}\npublic class Order : Aggregate {\n    // Whizbang tracks revision automatically\n    public int Revision { get; internal set; }\n    public DateTime LastModified { get; internal set; }\n    public string LastModifiedBy { get; internal set; }\n}\n\nawait repository.Save(order, expectedRevision: order.Revision);\n```\n\n### F. Conditional Updates\n\n**SQL-style conditional updates**:\n\n```csharp{title=\"Conditional Updates\" description=\"SQL-style conditional updates with business logic conditions\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"conditional-updates\", \"sql-style\", \"business-logic\"] framework=\"NET8\"}\nawait repository.Save(order, condition: o => o.Status == OrderStatus.Pending);\n// Only saves if order is still pending\n```\n\n## Policy-Driven Configuration\n\n> **📋 Universal Configuration**: Whizbang uses the [**Policy Engine**](./policy-engine.md) as the universal configuration scoping mechanism. All concurrency strategies, retry policies, and conflict resolution rules are configured through policies rather than direct configuration methods.\n\n### Basic Policy Configuration\n\n**Configure concurrency strategies using the Policy Engine** - the universal configuration scoping mechanism:\n\n```csharp{title=\"Basic Policy Configuration\" description=\"Global concurrency strategy configuration using policy engine\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"policy-configuration\", \"global-strategy\", \"policy-engine\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.Policies(policies => {\n        // Global default strategy\n        policies.When(ctx => true)\n                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.ExpectedVersion))\n                .And(config => config.SetRetryAttempts(3))\n                .And(config => config.SetRetryDelay(TimeSpan.FromMilliseconds(100)));\n    });\n});\n```\n\n### Advanced Policy Scenarios\n\n**Combine multiple conditions for sophisticated concurrency control**:\n\n```csharp{title=\"Advanced Policy Scenarios\" description=\"Sophisticated concurrency control with context-dependent strategies\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"concurrency\", \"advanced-policies\", \"context-dependent\", \"tenant-specific\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.Policies(policies => {\n        // Orders get automatic retry with more attempts\n        policies.When(ctx => ctx.MatchesAggregate<Order>())\n                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.AutomaticRetry))\n                .And(config => config.SetRetryAttempts(5)); // Orders get more retries\n        \n        // Shopping carts use timestamp-based for simplicity\n        policies.When(ctx => ctx.MatchesAggregate<ShoppingCart>())\n                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.TimestampBased));\n        \n        // High-volume commands get automatic retry\n        policies.When(ctx => ctx.HasTag(\"high-volume\"))\n                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.AutomaticRetry))\n                .And(config => config.SetRetryAttempts(5));\n        \n        // Load testing uses relaxed concurrency\n        policies.When(ctx => ctx.HasFlag(WhizbangFlags.LoadTesting))\n                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.LastWriteWins));\n        \n        // Environment-based strategies\n        policies.When(ctx => ctx.Environment == \"production\")\n                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.ExpectedVersion))\n                .And(config => config.SetRetryAttempts(3));\n        \n        policies.When(ctx => ctx.Environment == \"development\")\n                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.LastWriteWins)); // Relaxed for dev\n        \n        // Tenant-specific strategies\n        policies.When(ctx => ctx.TenantId != null && ctx.HasTag(\"enterprise-tenant\"))\n                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.ExpectedVersion))\n         .And(config => config.SetRetryAttempts(5))\n         .And(config => config.EnableStrictConflictResolution());\n    });\n});\n```\n\n### Runtime Policy Evaluation\n\n**Policies are evaluated at runtime** based on the current context:\n\n```csharp{title=\"Runtime Policy Evaluation\" description=\"Context-driven policy evaluation with automatic strategy selection\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"runtime-evaluation\", \"context-driven\", \"automatic-selection\"] framework=\"NET8\"}\n// Policy evaluation happens automatically during save operations\nawait repository.Save(order, context => {\n    context.WithTag(\"high-volume\");        // Triggers high-volume policy\n    context.WithFlag(WhizbangFlags.Production); // Triggers production policy\n});\n\n// Context determines which concurrency strategy is used\n// No need to manually specify strategy - policies handle it\n```\n\n### Manual Override (When Needed)\n\n**Override policies for exceptional cases**:\n\n```csharp{title=\"Manual Override\" description=\"Explicit override of policy-driven concurrency for critical operations\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"manual-override\", \"policy-bypass\", \"critical-operations\"] framework=\"NET8\"}\n// Explicit override for critical operations\nawait repository.Save(order, saveOptions => {\n    saveOptions.OverrideConcurrencyStrategy(ConcurrencyStrategy.ExpectedVersion);\n    saveOptions.SetExpectedVersion(5);\n    saveOptions.BypassPolicies(); // Skip policy evaluation\n});\n```\n\n## Conflict Resolution Strategies\n\n### Built-in Resolvers\n\n```csharp{title=\"Built-in Conflict Resolvers\" description=\"Common conflict resolution strategies for different scenarios\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"built-in-resolvers\", \"conflict-strategies\", \"merge-strategies\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.Policies(policies => {\n        // Last-write-wins for Order aggregates\n        policies.When(ctx => ctx.MatchesAggregate<Order>())\n                .Then(config => config.SetConflictResolver(ConflictResolvers.LastWriteWins));\n        \n        // First-write-wins for Customer aggregates (reject conflicting changes)\n        policies.When(ctx => ctx.MatchesAggregate<Customer>())\n                .Then(config => config.SetConflictResolver(ConflictResolvers.FirstWriteWins));\n        \n        // Additive merge for ShoppingCart (combine collections)\n        policies.When(ctx => ctx.MatchesAggregate<ShoppingCart>())\n                .Then(config => config.SetConflictResolver(ConflictResolvers.AdditiveMerge));\n    });\n});\n```\n\n### Custom Conflict Resolvers via Policies\n\n**Define custom conflict resolution logic through policies**:\n\n```csharp{title=\"Custom Conflict Resolvers\" description=\"Domain-specific merge logic for different aggregate properties\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"concurrency\", \"custom-resolvers\", \"business-logic-merge\", \"domain-specific\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.Policies(policies => {\n        // Custom resolver for Order aggregates\n        policies.When(ctx => ctx.MatchesAggregate<Order>())\n                .Then(config => config.SetConflictResolver((current, attempted) => {\n                    var resolved = current.Copy();\n                    \n                    // Merge line items additively\n                    foreach (var item in attempted.Items) {\n                        if (!resolved.Items.Any(i => i.ProductId == item.ProductId)) {\n                            resolved.AddItem(item);\n                        }\n                    }\n                    \n                    // Take latest shipping address\n                    if (attempted.ShippingAddress != null) {\n                        resolved.UpdateShippingAddress(attempted.ShippingAddress);\n                    }\n                    \n                    return resolved;\n                }));\n    });\n});\n```\n\n### Advanced Conflict Resolution\n\n**Access full conflict context through policies**:\n\n```csharp{title=\"Advanced Conflict Resolution\" description=\"Three-way merge using original version as merge base\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"concurrency\", \"three-way-merge\", \"advanced-resolution\", \"merge-base\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.Policies(policies => {\n        policies.When(ctx => ctx.MatchesAggregate<Order>())\n                .Then(config => config.SetConflictResolver((context) => {\n                    var current = context.CurrentVersion;\n                    var attempted = context.AttemptedVersion;\n                    var original = context.OriginalVersion; // Version when load started\n                    \n                    // Three-way merge using original as base\n                    return ThreeWayMerge(original, current, attempted);\n                }));\n    });\n});\n});\n```\n\n## Implementation Details\n\n### Concurrency Exception Handling\n\n```csharp{title=\"Concurrency Exception Handling\" description=\"Detailed conflict information for debugging and error handling\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"exception-handling\", \"conflict-information\", \"debugging\"] framework=\"NET8\"}\npublic class ConcurrencyException : Exception {\n    public string StreamId { get; }\n    public int ExpectedVersion { get; }\n    public int ActualVersion { get; }\n    public Type AggregateType { get; }\n    \n    public ConcurrencyException(string streamId, int expectedVersion, int actualVersion, Type aggregateType)\n        : base($\"Concurrency conflict in {aggregateType.Name} stream {streamId}. Expected version {expectedVersion}, but current version is {actualVersion}\") {\n        StreamId = streamId;\n        ExpectedVersion = expectedVersion;\n        ActualVersion = actualVersion;\n        AggregateType = aggregateType;\n    }\n}\n```\n\n### Retry Logic\n\n```csharp{title=\"Retry Logic Configuration\" description=\"Exponential backoff and jitter for reducing contention\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"retry-logic\", \"exponential-backoff\", \"jitter\"] framework=\"NET8\"}\npublic class RetryPolicy {\n    public int MaxAttempts { get; set; } = 3;\n    public TimeSpan InitialDelay { get; set; } = TimeSpan.FromMilliseconds(100);\n    public TimeSpan MaxDelay { get; set; } = TimeSpan.FromSeconds(1);\n    public double BackoffMultiplier { get; set; } = 2.0;\n    public RetryJitter Jitter { get; set; } = RetryJitter.Random;\n}\n\n// Example retry sequence:\n// Attempt 1: 100ms + random(0-50ms)\n// Attempt 2: 200ms + random(0-100ms)  \n// Attempt 3: 400ms + random(0-200ms)\n```\n\n### Driver Interface\n\n```csharp{title=\"Driver Interface\" description=\"Interface for implementing concurrency control strategies\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"concurrency\", \"driver-interface\", \"implementation\", \"strategies\"] framework=\"NET8\"}\npublic interface IConcurrencyDriver {\n    Task<T> Load<T>(string streamId, ConcurrencyOptions options) where T : Aggregate;\n    Task<(T Aggregate, ConcurrencyToken Token)> LoadWithToken<T>(string streamId) where T : Aggregate;\n    \n    Task Save<T>(T aggregate, ConcurrencyCheck check) where T : Aggregate;\n    Task<SaveResult> TrySave<T>(T aggregate, ConcurrencyCheck check) where T : Aggregate;\n    \n    Task<ConflictResolutionResult> ResolveConflict<T>(\n        T original, \n        T current, \n        T attempted, \n        ConflictResolver<T> resolver) where T : Aggregate;\n}\n\npublic class ConcurrencyCheck {\n    public ConcurrencyStrategy Strategy { get; set; }\n    public int? ExpectedVersion { get; set; }\n    public DateTime? IfNotModifiedSince { get; set; }\n    public ConcurrencyToken? Token { get; set; }\n    public Expression<Func<object, bool>>? Condition { get; set; }\n}\n```\n\n## Performance Considerations\n\n### Optimizations\n\n1. **Version caching** - Cache current versions to reduce round trips\n2. **Batch operations** - Group saves to reduce conflicts\n3. **Read replicas** - Load from read replicas to reduce load on primary\n4. **Conflict prediction** - Use heuristics to predict likely conflicts\n\n### Monitoring\n\n```csharp{title=\"Concurrency Monitoring\" description=\"Conflict logging and metrics for observability\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"monitoring\", \"metrics\", \"observability\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.UseOptimisticConcurrency(concurrency => {\n        concurrency.OnConflict = (context) => {\n            // Log conflict for monitoring\n            logger.LogWarning(\"Concurrency conflict in {StreamId}: {Conflict}\", \n                context.StreamId, context.ConflictDescription);\n            \n            // Emit metrics\n            metrics.IncrementCounter(\"whizbang.concurrency.conflicts\", \n                new[] { (\"aggregate_type\", context.AggregateType.Name) });\n        };\n        \n        concurrency.OnRetry = (context) => {\n            logger.LogDebug(\"Retrying save for {StreamId}, attempt {Attempt}\", \n                context.StreamId, context.AttemptNumber);\n        };\n    });\n});\n```\n\n## Best Practices\n\n### Strategy Selection Guidelines\n\n1. **Expected Version** - Use for critical business operations requiring strict consistency\n2. **Timestamp-Based** - Use for user-facing operations where UX matters more than strict consistency\n3. **Automatic Retry** - Use for high-contention scenarios with predictable merge strategies\n4. **Token-Based** - Use when integrating with external systems that provide tokens\n5. **Conditional** - Use for operations that depend on specific business conditions\n\n### Conflict Resolution Guidelines\n\n1. **Keep resolvers fast** - Avoid heavy computation or I/O\n2. **Test thoroughly** - Ensure resolvers handle edge cases\n3. **Make resolvers deterministic** - Same inputs should produce same outputs\n4. **Log conflicts** - Track conflict patterns for optimization\n5. **Fallback to exceptions** - Don't resolve conflicts you can't handle safely\n\n",
        "tags": "concurrency, optimistic-locking, versioning, marten",
        "version": "proposals"
      },
      {
        "slug": "proposals/deployment-operations",
        "title": "Deployment & Operations",
        "category": "Architecture & Design",
        "order": 15,
        "description": "\n# Deployment & Operations\n\nWhizbang is designed as an embedded library that runs within developer services, providing comprehensive operational hooks for production deployment, monitoring, and lifecycle management.\n\n## Deployment Model\n\n### Embedded Library Architecture\n\n**Whizbang runs embedded** within your application, not as a separate service:\n\n```csharp{title=\"Embedded Library Setup\" description=\"Basic embedded library setup within ASP.NET Core application\" category=\"Design\" difficulty=\"BEGINNER\" tags=[\"Design\", \"Deployment\", \"Embedded-Library\", \"ASP.NET-Core\"] framework=\"NET8\"}\n// Your service with Whizbang embedded\npublic class Program {\n    public static void Main(string[] args) {\n        var builder = WebApplication.CreateBuilder(args);\n        \n        // Add your application services\n        builder.Services.AddControllers();\n        builder.Services.AddOrderService();\n        \n        // Add Whizbang as embedded library\n        builder.Services.AddWhizbang(options => {\n            options.UsePostgresEventStore(connectionString);\n            options.UseKafkaMessageBroker(kafkaConfig);\n            options.ConfigureDomains();\n        });\n        \n        var app = builder.Build();\n        \n        // Configure your application pipeline\n        app.MapControllers();\n        app.MapWhizbangEndpoints(); // Optional: Expose Whizbang endpoints\n        \n        app.Run();\n    }\n}\n```\n\n### Service Architecture Patterns\n\n**Multiple deployment patterns** supported:\n\n#### 1. Monolithic Deployment\n\n```yaml\n",
        "tags": "deployment, operations, kubernetes, health-checks, graceful-shutdown",
        "version": "proposals"
      },
      {
        "slug": "proposals/domain-ownership",
        "title": "Domain Ownership",
        "category": "Architecture & Design",
        "order": 6,
        "description": "\n# Domain Ownership\n\nWhizbang enforces explicit domain ownership to prevent distributed system chaos. Every command and event has a clear owner, enabling proper routing, authorization, and system boundaries.\n\n## Ownership Determination Order\n\nDomain ownership is determined in **user-configurable order**, with this **default precedence**:\n\n1. **Namespace Convention** (highest priority)\n2. **Attributes** \n3. **Configuration-Driven** (lowest priority)\n\nEach level can override previous levels, giving developers full control.\n\n## 1. Namespace Convention (Default First)\n\n**Automatic ownership** derived from namespace structure:\n\n```csharp{title=\"Namespace-Based Domain Ownership\" description=\"Automatic domain ownership derived from namespace structure\" category=\"Design\" difficulty=\"BEGINNER\" tags=[\"domain-ownership\", \"namespace-convention\", \"commands\", \"events\"] framework=\"NET8\"}\n// Orders domain\nnamespace MyApp.Orders.Commands {\n    public record PlaceOrder(Guid OrderId, Guid CustomerId, List<OrderItem> Items);\n    // Domain: \"Orders\" (extracted from namespace)\n}\n\nnamespace MyApp.Orders.Events {\n    public record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt);\n    // Domain: \"Orders\"\n}\n\n// Inventory domain  \nnamespace MyApp.Inventory.Commands {\n    public record ReserveStock(Guid ProductId, int Quantity);\n    // Domain: \"Inventory\"\n}\n```\n\n### Namespace Policy Configuration\n\n```csharp{title=\"Namespace Policy Configuration\" description=\"Configuring namespace extraction policies for domain ownership\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"configuration\", \"namespace-policy\", \"setup\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.DomainOwnership(ownership => {\n        // Configure namespace extraction policies\n        ownership.NamespacePolicy(policy => {\n            // Default: Extract domain from namespace segment\n            policy.ExtractDomainFromNamespace = true;\n            policy.DomainNamespacePosition = 1; // MyApp.[Domain].Commands\n            \n            // Custom extraction function\n            policy.DomainExtractor = (type) => {\n                var segments = type.Namespace.Split('.');\n                if (segments.Length >= 3 && segments[1] == \"Domains\") {\n                    return segments[2]; // MyApp.Domains.[Domain].Commands\n                }\n                return segments.Length >= 2 ? segments[1] : \"Default\";\n            };\n            \n            // Namespace patterns\n            policy.CommandNamespacePattern = \"*.Commands\";\n            policy.EventNamespacePattern = \"*.Events\";\n            policy.QueryNamespacePattern = \"*.Queries\";\n        });\n    });\n});\n```\n\n## 2. Attribute-Based Ownership\n\n**Explicit declaration** using attributes:\n\n```csharp{title=\"Attribute-Based Domain Ownership\" description=\"Explicit domain ownership declaration using attributes\" category=\"Design\" difficulty=\"BEGINNER\" tags=[\"domain-ownership\", \"attributes\", \"explicit-declaration\", \"override\"] framework=\"NET8\"}\n[OwnedBy(\"Orders\")]\npublic record PlaceOrder(Guid OrderId, Guid CustomerId, List<OrderItem> Items);\n\n[OwnedBy(\"Orders\")]\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt);\n\n// Override namespace convention\nnamespace MyApp.Shared.Commands {\n    [OwnedBy(\"Inventory\")] // Overrides \"Shared\" from namespace\n    public record ReserveStock(Guid ProductId, int Quantity);\n}\n```\n\n### Attribute Policies\n\n```csharp{title=\"Attribute Policy Configuration\" description=\"Configuring attribute-based ownership policies\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"attribute-policy\", \"configuration\", \"custom-attributes\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.DomainOwnership(ownership => {\n        ownership.AttributePolicy(policy => {\n            // Require explicit ownership for certain patterns\n            policy.RequireExplicitOwnership<ICommand>();\n            policy.RequireExplicitOwnership(type => type.Name.EndsWith(\"Command\"));\n            \n            // Default ownership for unattributed types\n            policy.DefaultDomain = \"Shared\";\n            \n            // Custom attribute types\n            policy.RecognizeAttribute<DomainAttribute>();\n            policy.RecognizeAttribute<BoundedContextAttribute>();\n        });\n    });\n});\n```\n\n## 3. Configuration-Driven Ownership\n\n**Centralized registration** in Program.cs:\n\n```csharp{title=\"Configuration-Driven Ownership\" description=\"Centralized domain registration with explicit ownership\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"configuration\", \"domain-registration\", \"centralized-config\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.DomainOwnership(ownership => {\n        // Register domains with explicit ownership\n        ownership.RegisterDomain(\"Orders\", domain => {\n            domain.OwnsCommand<PlaceOrder>();\n            domain.OwnsCommand<UpdateOrder>();\n            domain.OwnsEvent<OrderPlaced>();\n            domain.OwnsEvent<OrderUpdated>();\n            \n            // Override other declarations\n            domain.OwnsCommand<SpecialSharedCommand>(); // Takes from \"Shared\"\n        });\n        \n        ownership.RegisterDomain(\"Inventory\", domain => {\n            domain.OwnsCommand<ReserveStock>();\n            domain.OwnsCommand<ReleaseStock>();\n            domain.OwnsEvent<StockReserved>();\n            domain.OwnsEvent<StockReleased>();\n        });\n    });\n});\n```\n\n## Interface and Inheritance Policies\n\n### Interface-Based Ownership\n\n```csharp{title=\"Interface-Based Ownership\" description=\"Interface-based domain ownership with marker interfaces\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"interface-based\", \"marker-interfaces\", \"configuration\"] framework=\"NET8\"}\n// Domain marker interfaces\npublic interface IOrderCommand : ICommand { }\npublic interface IInventoryCommand : ICommand { }\n\npublic record PlaceOrder(...) : IOrderCommand;\npublic record ReserveStock(...) : IInventoryCommand;\n\n// Configure interface-based ownership\nservices.AddWhizbang(options => {\n    options.DomainOwnership(ownership => {\n        ownership.InterfacePolicy(policy => {\n            policy.RegisterInterface<IOrderCommand>(\"Orders\");\n            policy.RegisterInterface<IInventoryCommand>(\"Inventory\");\n            policy.RegisterInterface<ISharedCommand>(\"Shared\");\n        });\n    });\n});\n```\n\n### Inheritance-Based Ownership\n\n```csharp{title=\"Inheritance-Based Ownership\" description=\"Inheritance-based domain ownership with base command classes\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"inheritance-based\", \"base-classes\", \"configuration\"] framework=\"NET8\"}\n// Base classes for domains\npublic abstract class OrderCommand : ICommand {\n    // Common order command properties\n}\n\npublic abstract class InventoryCommand : ICommand {\n    // Common inventory command properties  \n}\n\npublic class PlaceOrder : OrderCommand {\n    // Inherits \"Orders\" domain\n}\n\n// Configure inheritance-based ownership\nservices.AddWhizbang(options => {\n    options.DomainOwnership(ownership => {\n        ownership.InheritancePolicy(policy => {\n            policy.RegisterBaseClass<OrderCommand>(\"Orders\");\n            policy.RegisterBaseClass<InventoryCommand>(\"Inventory\");\n        });\n    });\n});\n```\n\n## Custom Ownership Precedence\n\n**Developer controls the order** of ownership determination:\n\n```csharp{title=\"Custom Ownership Precedence\" description=\"Custom ownership precedence order configuration\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"domain-ownership\", \"precedence-order\", \"configuration\", \"custom-rules\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.DomainOwnership(ownership => {\n        // Custom precedence order\n        ownership.PrecedenceOrder(\n            DomainOwnershipSource.Attributes,        // Check attributes first\n            DomainOwnershipSource.Configuration,     // Then explicit config\n            DomainOwnershipSource.Interfaces,        // Then interfaces\n            DomainOwnershipSource.Inheritance,       // Then inheritance\n            DomainOwnershipSource.Namespace          // Finally namespace\n        );\n        \n        // Or use fluent API\n        ownership.CheckAttributesFirst()\n                 .ThenConfiguration()\n                 .ThenInterfaces()\n                 .ThenInheritance()\n                 .FinallyNamespace();\n    });\n});\n```\n\n## Complex Policy Examples\n\n### Multi-Level Namespace Extraction\n\n```csharp{title=\"Multi-Level Namespace Extraction\" description=\"Multi-level namespace extraction with complex custom logic\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"domain-ownership\", \"namespace-extraction\", \"multi-level\", \"custom-logic\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.DomainOwnership(ownership => {\n        ownership.NamespacePolicy(policy => {\n            policy.DomainExtractor = (type) => {\n                var ns = type.Namespace;\n                \n                // MyApp.Domains.Orders.Commands -> \"Orders\"\n                if (ns.Contains(\".Domains.\")) {\n                    var segments = ns.Split('.');\n                    var domainIndex = Array.IndexOf(segments, \"Domains\") + 1;\n                    return domainIndex < segments.Length ? segments[domainIndex] : \"Unknown\";\n                }\n                \n                // MyApp.Orders.V2.Commands -> \"Orders\"\n                var parts = ns.Split('.');\n                if (parts.Length >= 2) {\n                    return parts[1]; // Second segment is domain\n                }\n                \n                return \"Default\";\n            };\n        });\n    });\n});\n```\n\n### Conditional Ownership Rules\n\n```csharp{title=\"Conditional Ownership Rules\" description=\"Conditional ownership rules based on type patterns and assemblies\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"domain-ownership\", \"conditional-rules\", \"assembly-based\", \"integration-events\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.DomainOwnership(ownership => {\n        ownership.ConditionalRules(rules => {\n            // Integration events are always \"Shared\"\n            rules.When(type => type.Name.EndsWith(\"IntegrationEvent\"))\n                 .AssignToDomain(\"Shared\");\n            \n            // Commands from external assemblies go to \"External\"\n            rules.When(type => !type.Assembly.GetName().Name.StartsWith(\"MyApp\"))\n                 .AssignToDomain(\"External\");\n                 \n            // Saga commands inherit from the saga's domain\n            rules.When(type => typeof(ISagaCommand).IsAssignableFrom(type))\n                 .ExtractDomainFromProperty(\"SagaDomain\");\n        });\n    });\n});\n```\n\n### Assembly-Based Policies\n\n```csharp{title=\"Assembly-Based Policies\" description=\"Assembly-based domain ownership with naming conventions\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"assembly-based\", \"assembly-mapping\", \"naming-convention\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.DomainOwnership(ownership => {\n        ownership.AssemblyPolicy(policy => {\n            // Each assembly represents a domain\n            policy.MapAssemblyToDomain(\"MyApp.Orders\", \"Orders\");\n            policy.MapAssemblyToDomain(\"MyApp.Inventory\", \"Inventory\");\n            policy.MapAssemblyToDomain(\"MyApp.Shipping\", \"Shipping\");\n            \n            // Assembly naming convention\n            policy.ExtractDomainFromAssemblyName = true;\n            policy.AssemblyNamePattern = \"MyApp.{Domain}\";\n        });\n    });\n});\n```\n\n## Runtime Ownership Resolution\n\n### Ownership Discovery API\n\n```csharp{title=\"Domain Ownership Resolver API\" description=\"Domain ownership resolver API for runtime discovery\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"runtime-resolution\", \"api\", \"interface\"] framework=\"NET8\"}\npublic interface IDomainOwnershipResolver {\n    string ResolveDomain<T>();\n    string ResolveDomain(Type type);\n    bool IsDomainOwner<T>(string domain);\n    IEnumerable<string> GetAllDomains();\n    IEnumerable<Type> GetDomainTypes(string domain);\n}\n\n// Usage\n```csharp{title=\"Using Domain Ownership Resolver\" description=\"Example of using domain ownership resolver in a controller\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"controllers\", \"usage-example\", \"resolver\"] framework=\"NET8\"}\npublic class OrderController : ControllerBase {\n    private readonly IDomainOwnershipResolver _ownership;\n    \n    public OrderController(IDomainOwnershipResolver ownership) {\n        _ownership = ownership;\n    }\n    \n    public async Task<IActionResult> PlaceOrder(PlaceOrderRequest request) {\n        var domain = _ownership.ResolveDomain<PlaceOrder>();\n        // domain = \"Orders\"\n        \n        var command = new PlaceOrder(request.OrderId, request.CustomerId, request.Items);\n        await _mediator.Send(command);\n        \n        return Ok();\n    }\n}\n```\n\n### Compile-Time Validation\n\n**Roslyn analyzer** enforces ownership rules:\n\n```csharp{title=\"Compile-Time Validation\" description=\"Compile-time validation of domain ownership rules with Roslyn analyzers\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"domain-ownership\", \"compile-time-validation\", \"roslyn-analyzers\", \"source-generators\"] framework=\"NET8\"}\n// This will generate a compile error\n[OwnedBy(\"Orders\")]\npublic record PlaceOrder(...);\n\n// In different assembly/project\npublic class InventoryHandler : ICommandHandler<PlaceOrder> {\n    // ERROR: InventoryHandler cannot handle PlaceOrder - different domains\n    public async Task Handle(PlaceOrder command) { ... }\n}\n```\n\n### Source Generator Support\n\n```csharp{title=\"Auto-Generated Domain Registry\" description=\"Auto-generated domain ownership registry for runtime lookups\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"domain-ownership\", \"source-generation\", \"code-generation\", \"registry\"] framework=\"NET8\"}\n// Generated at compile time\n[GeneratedCode(\"Whizbang.SourceGenerator\")]\npublic static class DomainOwnershipRegistry {\n    public static readonly Dictionary<Type, string> TypeToDomain = new() {\n        { typeof(PlaceOrder), \"Orders\" },\n        { typeof(OrderPlaced), \"Orders\" },\n        { typeof(ReserveStock), \"Inventory\" },\n        { typeof(StockReserved), \"Inventory\" }\n    };\n    \n    public static readonly Dictionary<string, HashSet<Type>> DomainToTypes = new() {\n        { \"Orders\", new HashSet<Type> { typeof(PlaceOrder), typeof(OrderPlaced) } },\n        { \"Inventory\", new HashSet<Type> { typeof(ReserveStock), typeof(StockReserved) } }\n    };\n}\n```\n\n## Command Routing Based on Ownership\n\n### In-Process Routing\n\n```csharp{title=\"In-Process Command Routing\" description=\"Local command routing within the same domain service\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"routing\", \"in-process-communication\", \"local-handling\"] framework=\"NET8\"}\n// Same domain - route locally\nvar command = new PlaceOrder(...);\nvar domain = _ownership.ResolveDomain<PlaceOrder>(); // \"Orders\"\nvar handler = _serviceProvider.GetRequiredService<ICommandHandler<PlaceOrder>>();\nawait handler.Handle(command);\n```\n\n### Cross-Service Routing\n\n```csharp{title=\"Cross-Service Command Routing\" description=\"Cross-service command routing based on domain ownership\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"routing\", \"cross-service-communication\", \"message-broker\"] framework=\"NET8\"}\n// Different domain - route via message broker\nvar command = new ReserveStock(...);\nvar domain = _ownership.ResolveDomain<ReserveStock>(); // \"Inventory\"\n\nif (domain != _currentDomain) {\n    // Send to remote service\n    await _messageBroker.SendToService(domain, command);\n} else {\n    // Handle locally\n    await _localMediator.Send(command);\n}\n```\n\n## Best Practices\n\n### Ownership Guidelines\n\n1. **Be explicit** - Prefer attributes over conventions for critical commands\n2. **Consistent patterns** - Use the same ownership style within a domain\n3. **Document policies** - Make namespace and interface conventions clear\n4. **Validate early** - Use analyzers to catch ownership violations\n5. **Monitor boundaries** - Track cross-domain communication patterns\n\n### Policy Design\n\n1. **Start simple** - Begin with namespace conventions\n2. **Add specificity** - Use attributes for exceptions\n3. **Centralize overrides** - Use configuration for edge cases\n4. **Test policies** - Ensure ownership resolution works as expected\n5. **Version carefully** - Changing ownership affects routing\n\n",
        "tags": "domain-ownership, commands, events, namespace-policies, attributes",
        "version": "proposals"
      },
      {
        "slug": "proposals/event-store-projections",
        "title": "Event Store & Projection Architecture",
        "category": "Architecture & Design",
        "order": 4,
        "description": "\n# Event Store & Projection Architecture\n\nWhizbang implements a hybrid event store and projection architecture that separates event persistence from projection storage, enabling flexible schema evolution and high-performance querying.\n\n## Core Architecture\n\n### Hybrid Storage Design\n\n**Events Table** (Immutable Event Stream):\n```sql\n",
        "tags": "event-store, projections, architecture, jsonb, snapshots",
        "version": "proposals"
      },
      {
        "slug": "proposals/flags-tags-system",
        "title": "Flags & Tags System",
        "category": "Architecture & Design",
        "order": 11,
        "description": "\n# Flags & Tags System\n\nWhizbang provides a sophisticated flags and tags system for message context, enabling dynamic behavior modification, cross-service debugging, and flexible routing throughout the entire message lifecycle.\n\n## Core Concepts\n\n### Flags (Library-Defined)\n\n**Hardcoded enum flags** provided by Whizbang for common scenarios:\n\n```csharp{title=\"WhizbangFlags Enum Definition\" description=\"Library-defined flags enum for common development and operational scenarios\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Message-Context\", \"Cross-Service-Communication\"] framework=\"NET8\"}\n[Flags]\npublic enum WhizbangFlags : long {\n    None = 0,\n    \n    // Testing & Development\n    LoadTesting = 1 << 0,           // Don't replay these events\n    DryRun = 1 << 1,                // Execute handlers but don't persist\n    Development = 1 << 2,           // Development mode behaviors\n    TraceReplay = 1 << 3,           // Replay/trace mode\n    \n    // Debugging & Inspection\n    VerboseLogging = 1 << 4,        // Increase logging verbosity\n    VerboseOtel = 1 << 5,           // Increase OpenTelemetry verbosity\n    IgnoreTimeouts = 1 << 6,        // Bypass timeouts for debugging\n    CursorMode = 1 << 7,            // IDE cursor/scrubbing mode\n    Breakpoint = 1 << 8,            // Trigger breakpoints\n    \n    // Security & Compliance\n    SecurityBypass = 1 << 9,        // Bypass security checks (dangerous)\n    DataScrubbing = 1 << 10,        // Scrub sensitive data\n    ComplianceMode = 1 << 11,       // Extra compliance logging\n    \n    // Routing & Delivery\n    AlternativeRouting = 1 << 12,   // Use alternative handlers\n    PriorityDelivery = 1 << 13,     // Expedite processing\n    DelayedProcessing = 1 << 14,    // Defer processing\n    \n    // Environment & Lifecycle\n    Production = 1 << 15,           // Production environment\n    Staging = 1 << 16,              // Staging environment\n    QA = 1 << 17,                   // QA environment\n    Migration = 1 << 18,            // Data migration context\n    \n    // Custom ranges for user-defined flags\n    UserDefined1 = 1 << 32,\n    UserDefined2 = 1 << 33,\n    // ... up to 1 << 63\n}\n```\n\n### Tags (User-Defined)\n\n**Arbitrary string tags** added by developers for custom scenarios:\n\n```csharp{title=\"MessageContext with Fluent API\" description=\"Message context class with fluent API for flags and tags management\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Message-Context\", \"Fluent-API\"] framework=\"NET8\"}\npublic class MessageContext {\n    public WhizbangFlags Flags { get; set; }\n    public HashSet<string> Tags { get; set; } = new();\n    public string? CorrelationId { get; set; }\n    public string? TenantId { get; set; }\n    public string? Domain { get; set; }\n    \n    // Fluent API for context building\n    public MessageContext WithTag(string tag) {\n        Tags.Add(tag);\n        return this;\n    }\n    \n    public MessageContext WithFlags(WhizbangFlags flags) {\n        Flags |= flags;\n        return this;\n    }\n    \n    public MessageContext WithCorrelationId(string correlationId) {\n        CorrelationId = correlationId;\n        return this;\n    }\n    \n    public bool HasFlag(WhizbangFlags flag) => (Flags & flag) == flag;\n    public bool HasTag(string tag) => Tags.Contains(tag);\n    public bool HasAnyTag(params string[] tags) => tags.Any(Tags.Contains);\n    public bool HasAllTags(params string[] tags) => tags.All(Tags.Contains);\n}\n\n// Usage examples\ncontext.WithTag(\"customer-priority\")\n       .WithTag(\"region-us-west\")\n       .WithTag(\"high-value-order\")\n       .WithFlags(WhizbangFlags.VerboseLogging | WhizbangFlags.PriorityDelivery)\n       .WithCorrelationId(\"debug-session-123\");\n```\n\n## Cross-Service Propagation\n\n### Automatic Flag Propagation\n\n**Flags carry through entire message journey** across service boundaries:\n\n```csharp{title=\"Cross-Service Flag Propagation\" description=\"Automatic flag and tag propagation across service boundaries\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Cross-Service-Propagation\", \"Debugging\"] framework=\"NET8\"}\n// Service 1: Initial command with debugging flags\nvar command = new PlaceOrder(orderId, customerId, items);\nawait _mediator.Send(command, context => {\n    context.WithFlags(WhizbangFlags.VerboseLogging | WhizbangFlags.TraceReplay)\n           .WithTag(\"debug-session-123\")\n           .WithTag(\"customer-vip\");\n});\n\n// Flags automatically propagate to:\n// 1. Command handler execution in Service 1\n// 2. Event publishing from Service 1\n// 3. Cross-service event delivery via message broker\n// 4. Event handler execution in Service 2\n// 5. Projection updates in Service 2\n// 6. Saga execution across services\n\n```csharp{title=\"Context-Aware Event Handler\" description=\"Event handler using propagated flags and tags for conditional processing\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Event-Handlers\", \"Context-Aware-Processing\"] framework=\"NET8\"}\n// Service 2: Receives event with same flags and tags\npublic class InventoryHandler : IEventHandler<OrderPlaced> {\n    public async Task Handle(OrderPlaced @event, EventContext context) {\n        // context.Flags contains VerboseLogging | TraceReplay\n        // context.Tags contains \"debug-session-123\", \"customer-vip\"\n        \n        if (context.HasFlag(WhizbangFlags.VerboseLogging)) {\n            _logger.LogInformation(\"Processing order with verbose logging enabled for debug session {DebugSession}\", \n                context.Tags.FirstOrDefault(t => t.StartsWith(\"debug-session\")));\n        }\n        \n        if (context.HasTag(\"customer-vip\")) {\n            // Special handling for VIP customers\n            await _vipCustomerService.NotifyOrderReceived(@event.OrderId);\n        }\n    }\n}\n```\n\n### Message Context Serialization\n\n**Context travels with messages** across all transport mechanisms:\n\n```csharp{title=\"Message Envelope for Cross-Service Communication\" description=\"Message envelope with context serialization for cross-service communication\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Message-Serialization\", \"Cross-Service\"] framework=\"NET8\"}\n// Message envelope for cross-service communication\npublic class MessageEnvelope<T> {\n    public T Message { get; set; }\n    public MessageContext Context { get; set; }\n    public Dictionary<string, string> Headers { get; set; } = new();\n    public DateTimeOffset Timestamp { get; set; } = DateTimeOffset.UtcNow;\n}\n\n```csharp{title=\"Kafka Message Publisher\" description=\"Kafka message publisher with automatic context serialization\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Kafka\", \"Message-Brokers\"] framework=\"NET8\"}\n// Automatic context serialization in message brokers\npublic class KafkaMessagePublisher : IMessagePublisher {\n    public async Task PublishAsync<T>(T message, MessageContext context) {\n        var envelope = new MessageEnvelope<T> {\n            Message = message,\n            Context = context,\n            Headers = new Dictionary<string, string> {\n                [\"whizbang-flags\"] = ((long)context.Flags).ToString(),\n                [\"whizbang-tags\"] = string.Join(\",\", context.Tags),\n                [\"whizbang-correlation-id\"] = context.CorrelationId ?? \"\",\n                [\"whizbang-tenant-id\"] = context.TenantId ?? \"\",\n                [\"whizbang-domain\"] = context.Domain ?? \"\"\n            }\n        };\n        \n        await _kafkaProducer.ProduceAsync(GetTopicName<T>(), envelope);\n    }\n}\n```\n\n## Debugging and Development Features\n\n### IDE Cursor/Scrubbing Mode\n\n**Interactive debugging** with state inspection:\n\n```csharp{title=\"IDE Cursor Mode Handler\" description=\"IDE integration for interactive debugging with state inspection\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Flags-Tags\", \"IDE-Integration\", \"Debugging\", \"Cursor-Mode\"] framework=\"NET8\"}\n// IDE integration for step-by-step debugging\npublic class CursorModeHandler : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        \n        if (context.HasFlag(WhizbangFlags.CursorMode)) {\n            // Capture pre-execution state\n            var preState = await _stateCapture.CaptureStateAsync(context);\n            \n            // Notify IDE of execution point\n            await _ideNotificationService.NotifyExecutionPoint(new ExecutionPoint {\n                MessageType = typeof(TRequest).Name,\n                HandlerType = context.HandlerType?.Name,\n                CorrelationId = context.CorrelationId,\n                State = preState,\n                CanStepForward = true,\n                CanStepBackward = true\n            });\n            \n            // Wait for IDE to signal continue\n            await _ideNotificationService.WaitForContinueSignal(context.CorrelationId);\n        }\n        \n        var response = await next(message, context);\n        \n        if (context.HasFlag(WhizbangFlags.CursorMode)) {\n            // Capture post-execution state\n            var postState = await _stateCapture.CaptureStateAsync(context);\n            \n            await _ideNotificationService.NotifyExecutionComplete(new ExecutionResult {\n                CorrelationId = context.CorrelationId,\n                Response = response,\n                PostState = postState,\n                ExecutionTime = context.ExecutionTime\n            });\n        }\n        \n        return response;\n    }\n}\n```\n\n### Breakpoint System\n\n**Programmatic breakpoints** triggered by flags:\n\n```csharp{title=\"Programmatic Breakpoint Handler\" description=\"Programmatic breakpoint system triggered by flags for debugging\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Flags-Tags\", \"Debugging\", \"Breakpoints\", \"Development-Tools\"] framework=\"NET8\"}\npublic class BreakpointHandler : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        \n        if (context.HasFlag(WhizbangFlags.Breakpoint)) {\n            var breakpointContext = new BreakpointContext {\n                BreakpointId = Guid.NewGuid(),\n                MessageType = typeof(TRequest).Name,\n                Message = message,\n                Context = context,\n                StackTrace = Environment.StackTrace,\n                Timestamp = DateTimeOffset.UtcNow\n            };\n            \n            // Store breakpoint information\n            await _breakpointStore.StoreBreakpointAsync(breakpointContext);\n            \n            // Notify debugging tools\n            await _debuggerNotificationService.NotifyBreakpointHit(breakpointContext);\n            \n            // Optionally pause execution for attached debuggers\n            if (_debuggerService.IsAttached) {\n                System.Diagnostics.Debugger.Break();\n            }\n        }\n        \n        return await next(message, context);\n    }\n}\n```\n\n## Data Scrubbing and Security\n\n### Automatic Data Scrubbing\n\n**Policy-driven data sanitization** based on flags:\n\n```csharp{title=\"Data Scrubbing Interceptor\" description=\"Policy-driven data sanitization based on flags for security compliance\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Flags-Tags\", \"Data-Scrubbing\", \"Security\", \"Privacy\"] framework=\"NET8\"}\npublic class DataScrubbingInterceptor : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        \n        TRequest processedMessage = message;\n        \n        if (context.HasFlag(WhizbangFlags.DataScrubbing)) {\n            // Apply data scrubbing rules\n            processedMessage = await _dataScrubber.ScrubAsync(message, new ScrubOptions {\n                ScrubPersonalData = true,\n                ScrubFinancialData = true,\n                ScrubSensitiveFields = true,\n                PreserveFunctionality = true,\n                AddScrubbedMarkers = true\n            });\n            \n            // Add scrubbing metadata to context\n            context.Tags.Add(\"data-scrubbed\");\n            context.Tags.Add($\"scrubbed-at-{DateTimeOffset.UtcNow:yyyy-MM-dd-HH-mm-ss}\");\n        }\n        \n        return await next(processedMessage, context);\n    }\n}\n\n```csharp{title=\"Order Data Scrubber Implementation\" description=\"Concrete data scrubber implementation for order data sanitization\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Data-Scrubbing\", \"Implementation\"] framework=\"NET8\"}\n// Data scrubbing rules\npublic class OrderDataScrubber : IDataScrubber<PlaceOrder> {\n    public async Task<PlaceOrder> ScrubAsync(PlaceOrder order, ScrubOptions options) {\n        return order with {\n            // Scrub customer email\n            CustomerEmail = options.ScrubPersonalData ? ScrubEmail(order.CustomerEmail) : order.CustomerEmail,\n            \n            // Scrub payment information\n            PaymentToken = options.ScrubFinancialData ? \"[SCRUBBED-PAYMENT-TOKEN]\" : order.PaymentToken,\n            \n            // Preserve order structure but scrub sensitive data\n            Items = order.Items.Select(item => item with {\n                ProductName = options.PreserveFunctionality ? item.ProductName : $\"Product-{item.ProductId.ToString()[..8]}\"\n            }).ToList()\n        };\n    }\n}\n```\n\n### Production to QA Data Flow\n\n**Secure data replication** with automatic scrubbing:\n\n```csharp{title=\"Production to QA Data Replicator\" description=\"Secure data replication from production to QA with automatic scrubbing\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Flags-Tags\", \"Production-to-QA\", \"Data-Replication\"] framework=\"NET8\"}\n// Handler that duplicates production messages to QA with scrubbing\npublic class ProductionToQAReplicator : IEventHandler<object> {\n    public async Task Handle(object @event, EventContext context) {\n        // Only replicate events tagged for QA replication\n        if (context.HasTag(\"production-data\") && \n            context.HasFlag(WhizbangFlags.QA)) {\n            \n            // Create a copy with scrubbing flag\n            var qaCopy = @event;\n            var qaContext = context.Copy()\n                .WithFlag(WhizbangFlags.DataScrubbing)\n                .WithTag(\"qa-replicated\")\n                .WithTag($\"replicated-from-production-{DateTimeOffset.UtcNow:yyyy-MM-dd}\");\n            \n            // Remove production-specific tags\n            qaContext.Tags.Remove(\"production-data\");\n            qaContext.Tags.Remove(\"customer-vip\"); // Don't carry VIP status to QA\n            \n            // Route to QA environment\n            await _qaEventPublisher.PublishAsync(qaCopy, qaContext);\n        }\n    }\n}\n```\n\n## Performance and Load Testing\n\n### Load Testing Flag Handling\n\n**Optimize behavior for load testing scenarios**:\n\n```csharp{title=\"Load Testing Optimizer\" description=\"Load testing optimization interceptor with flag-based behavior modification\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Load-Testing\", \"Performance-Optimization\"] framework=\"NET8\"}\npublic class LoadTestingOptimizer : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        \n        if (context.HasFlag(WhizbangFlags.LoadTesting)) {\n            // Optimize for load testing\n            using var loadTestScope = _performanceOptimizer.EnterLoadTestMode();\n            \n            // Disable slow operations\n            context.Tags.Add(\"skip-audit-logging\");\n            context.Tags.Add(\"skip-analytics-tracking\");\n            context.Tags.Add(\"minimal-validation\");\n            \n            // Add load test metadata\n            context.Tags.Add($\"load-test-batch-{GetLoadTestBatch()}\");\n            context.Tags.Add($\"load-test-thread-{Thread.CurrentThread.ManagedThreadId}\");\n            \n            // Execute with load test optimizations\n            return await next(message, context);\n        }\n        \n        return await next(message, context);\n    }\n    \n    private string GetLoadTestBatch() {\n        // Identify which load test batch this belongs to\n        return Environment.GetEnvironmentVariable(\"LOAD_TEST_BATCH_ID\") ?? \"unknown\";\n    }\n}\n```\n\n## Advanced Routing Scenarios\n\n### Dynamic Handler Selection\n\n**Route to different handlers** based on flags and tags:\n\n```csharp{title=\"Context-Aware Handler Factory\" description=\"Dynamic handler selection based on flags and tags for flexible routing\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Flags-Tags\", \"Dynamic-Routing\", \"Handler-Selection\"] framework=\"NET8\"}\n// Handler factory that selects implementation based on context\npublic class ContextAwareHandlerFactory<T> : ICommandHandler<T> where T : ICommand {\n    private readonly IServiceProvider _serviceProvider;\n    private readonly IHandlerRoutingRules _routingRules;\n    \n    public async Task Handle(T command, MessageContext context) {\n        var handlerType = await _routingRules.DetermineHandlerType<T>(context);\n        var handler = (ICommandHandler<T>)_serviceProvider.GetRequiredService(handlerType);\n        \n        return await handler.Handle(command, context);\n    }\n}\n\n```csharp{title=\"Handler Routing Rules\" description=\"Context-based routing rules for handler type determination\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Flags-Tags\", \"Routing-Rules\", \"Handler-Selection\"] framework=\"NET8\"}\n// Routing rules based on context\npublic class HandlerRoutingRules : IHandlerRoutingRules {\n    public async Task<Type> DetermineHandlerType<T>(MessageContext context) {\n        // VIP customers get premium handler\n        if (context.HasTag(\"customer-vip\")) {\n            return typeof(PremiumOrderHandler);\n        }\n        \n        // Load testing gets optimized handler\n        if (context.HasFlag(WhizbangFlags.LoadTesting)) {\n            return typeof(LoadTestOptimizedOrderHandler);\n        }\n        \n        // Migration data gets special handler\n        if (context.HasFlag(WhizbangFlags.Migration)) {\n            return typeof(DataMigrationOrderHandler);\n        }\n        \n        // Default handler\n        return typeof(StandardOrderHandler);\n    }\n}\n```\n\n## Configuration and Management\n\n### Flag Management\n\n**Control flag behavior** through configuration:\n\n```csharp{title=\"Flag Management Configuration\" description=\"Flag management configuration with environment-based defaults and validation\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Configuration\", \"Environment-Management\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.Flags(flags => {\n        // Environment-based flag defaults\n        if (_environment.IsDevelopment()) {\n            flags.DefaultFlags = WhizbangFlags.Development | WhizbangFlags.VerboseLogging;\n        } else if (_environment.IsProduction()) {\n            flags.DefaultFlags = WhizbangFlags.Production;\n            flags.RestrictedFlags = WhizbangFlags.SecurityBypass | WhizbangFlags.DataScrubbing;\n        }\n        \n        // Flag validation rules\n        flags.AddValidationRule(ctx => {\n            if (ctx.HasFlag(WhizbangFlags.SecurityBypass) && !ctx.HasTag(\"authorized-security-bypass\")) {\n                throw new UnauthorizedFlagException(\"SecurityBypass flag requires authorization\");\n            }\n        });\n        \n        // Automatic flag addition based on context\n        flags.AddAutoFlag(WhizbangFlags.ComplianceMode, \n            condition: ctx => ctx.HasTag(\"pci-data\") || ctx.HasTag(\"gdpr-data\"));\n    });\n});\n```\n\n### Tag Lifecycle Management\n\n**Manage tag propagation and cleanup**:\n\n```csharp{title=\"Tag Lifecycle Manager\" description=\"Tag lifecycle management with automatic addition and cleanup\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Tag-Lifecycle\", \"Management\"] framework=\"NET8\"}\npublic class TagLifecycleManager : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        \n        // Add automatic tags\n        context.Tags.Add($\"processed-at-{Environment.MachineName}\");\n        context.Tags.Add($\"handler-{typeof(TRequest).Name}\");\n        \n        // Remove expired tags\n        var expiredTags = context.Tags\n            .Where(tag => tag.StartsWith(\"session-\") && IsSessionExpired(tag))\n            .ToList();\n        \n        foreach (var expiredTag in expiredTags) {\n            context.Tags.Remove(expiredTag);\n        }\n        \n        var response = await next(message, context);\n        \n        // Add response-based tags\n        if (response is ISuccessResult) {\n            context.Tags.Add(\"execution-success\");\n        } else if (response is IErrorResult error) {\n            context.Tags.Add($\"execution-error-{error.ErrorCode}\");\n        }\n        \n        return response;\n    }\n}\n```\n\n## Best Practices\n\n### Flag Usage Guidelines\n\n1. **Use library flags first** - Prefer built-in flags over custom tags when possible\n2. **Document custom flags** - Make user-defined flags clear to the team\n3. **Be conservative with propagation** - Not all flags should cross service boundaries\n4. **Consider flag lifetime** - How long should flags persist in the system\n5. **Audit flag usage** - Track which flags are used and where\n\n### Tag Design Principles\n\n1. **Hierarchical naming** - Use consistent naming conventions (e.g., \"customer-vip\", \"region-us-west\")\n2. **Meaningful values** - Tags should be self-documenting\n3. **Avoid high cardinality** - Don't create too many unique tag combinations\n4. **Lifecycle awareness** - Consider when tags should be added/removed\n5. **Security sensitivity** - Don't include sensitive data in tag names\n\n### Security Considerations\n\n1. **Validate flag sources** - Ensure flags come from trusted sources\n2. **Limit dangerous flags** - SecurityBypass should be heavily restricted\n3. **Audit flag changes** - Log all flag modifications\n4. **Encrypt sensitive tags** - Some tags may contain sensitive information\n5. **Principle of least privilege** - Flags should grant minimal necessary permissions\n\n",
        "tags": "flags, tags, message-context, routing, debugging, cross-service",
        "version": "proposals"
      },
      {
        "slug": "proposals/multi-tenancy",
        "title": "Multi-Tenancy",
        "category": "Architecture & Design",
        "order": 8,
        "description": "\n# Multi-Tenancy\n\nWhizbang provides comprehensive multi-tenancy support with flexible tenant isolation strategies, from single database with row-level security to complete database separation.\n\n## Tenant Isolation Strategies\n\n### Single Database with Tenant ID\n\n**Row-level tenant isolation** using tenant ID columns:\n\n```sql\n",
        "tags": "multi-tenancy, tenant-isolation, partitioning, data-isolation",
        "version": "proposals"
      },
      {
        "slug": "proposals/observability-metrics",
        "title": "Observability & Metrics",
        "category": "Architecture & Design",
        "order": 14,
        "description": "\n# Observability & Metrics\n\nWhizbang provides comprehensive observability with policy-driven metrics collection, OpenTelemetry integration, and custom field attributes for rich monitoring and debugging capabilities.\n\n## Metrics Architecture\n\n### Default Metrics (Always Enabled)\n\n**Core performance and health metrics** essential for operation:\n\n```csharp\n",
        "tags": "observability, metrics, opentelemetry, monitoring, performance",
        "version": "proposals"
      },
      {
        "slug": "proposals/open-questions",
        "title": "Open Design Questions - RESOLVED",
        "category": "Architecture & Design",
        "order": 3,
        "description": "\n# Open Design Questions - RESOLVED ✅\n\n**Status**: All critical and important design questions have been resolved and documented in detailed specification documents.\n\nThis document previously captured open questions and architectural decisions for Whizbang. **All questions have now been resolved** and documented in comprehensive specifications.\n\n## 🔴 Critical Decisions - ALL RESOLVED ✅\n\n**All critical decisions have been resolved and documented**. See the detailed specifications below:\n\n### 1. Handler Discovery Mechanism ✅ **RESOLVED**\n**Decision**: Hybrid approach (Source Generators + Explicit Registration)\n- **Detailed Specification**: [Domain Ownership](./domain-ownership.md)\n\n### 2. Handler Method Signature Conventions ✅ **RESOLVED**\n**Decision**: Convention-based with Source Generator support\n- **Detailed Specification**: [Domain Ownership](./domain-ownership.md)\n\n### 3. Event Store Schema Design ✅ **RESOLVED**\n**Decision**: Hybrid approach (Separate Events and Projections with JSONB)\n- **Detailed Specification**: [Event Store & Projections](./event-store-projections.md)\n\n### 4. Optimistic Concurrency Strategy ✅ **RESOLVED**\n**Decision**: Support all strategies (Expected Version, Timestamp-Based, Automatic Retry)\n- **Detailed Specification**: [Concurrency Control](./concurrency-control.md)\n\n### 5. Domain Ownership Declaration ✅ **RESOLVED**\n**Decision**: Configurable precedence order (Namespace → Attributes → Configuration)\n- **Detailed Specification**: [Domain Ownership](./domain-ownership.md)\n\n",
        "tags": "architecture, design-decisions, resolved, specifications",
        "version": "proposals"
      },
      {
        "slug": "proposals/policy-engine",
        "title": "Policy Engine",
        "category": "Architecture & Design",
        "order": 12,
        "description": "\n# Policy Engine\n\nWhizbang includes a sophisticated policy engine that enables flexible, rule-based configuration for routing, behavior modification, and system adaptation across the entire message lifecycle.\n\n## Core Architecture\n\nThe Policy Engine is the **universal configuration scoping mechanism** for Whizbang. Rather than having separate configuration systems for each feature, policies provide a unified way to apply configuration based on context, conditions, and scope.\n\n**Every configurable aspect of Whizbang can use policies** to determine when and how configuration should be applied:\n\n- **Concurrency strategies** - Which concurrency approach to use based on message type/context\n- **Observability levels** - How much detail to capture based on flags/environment\n- **Performance budgets** - Different performance expectations for different scenarios\n- **Serialization formats** - Which serializer to use for different drivers/contexts\n- **Multi-tenancy isolation** - Tenant-specific behavior and storage strategies\n- **Domain ownership** - Dynamic ownership rules based on context\n- **Error handling** - Different resilience policies for different message types\n- **Routing decisions** - Which handlers to use based on flags/tags\n- **Security policies** - Authentication/authorization rules based on context\n\n**Policies can evaluate any aspect of the system state**:\n- **Message content** - Properties, types, values within commands/events\n- **Message context** - Flags, tags, correlation IDs, tenant information\n- **System state** - Current load, resource utilization, error rates\n- **Environment** - Development, staging, production, feature flags\n- **User context** - Authentication, authorization, user roles\n- **Time-based conditions** - Business hours, maintenance windows, seasons\n- **Domain context** - Which domain owns the message, cross-domain interactions\n- **Infrastructure state** - Database health, message broker status\n- **Custom conditions** - Any developer-defined evaluation criteria\n\n> **📋 Message Context**: While policies can evaluate any system aspect, the [**Flags & Tags System**](./flags-tags-system.md) provides a convenient way to carry context through message flows.\n\n## Configuration Architecture Principles\n\n### Policy-Based vs Direct Configuration\n\n**Policies handle behavioral configuration** that varies by context, environment, message type, or runtime conditions:\n\n```csharp{title=\"Policy-Based vs Direct Configuration\" description=\"Policy-based vs direct configuration showing separation of infrastructure and behavioral settings\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Policy-Engine\", \"Configuration\", \"Behavioral-Configuration\"] framework=\"NET8\"}\n",
        "tags": "policy-engine, rules, behavior-modification, routing, configuration",
        "version": "proposals"
      },
      {
        "slug": "proposals/projection-management",
        "title": "Projection Management",
        "category": "Architecture & Design",
        "order": 7,
        "description": "\n# Projection Management\n\nWhizbang provides comprehensive projection management including checkpoints, backfilling strategies, system events for on-demand rebuilds, and flexible storage options.\n\n## Checkpoint Storage\n\nProjections track their progress through **checkpoint storage**, supporting multiple strategies:\n\n### A. Same Database (Default)\n\n**Transactional consistency** - checkpoints and projections updated together:\n\n```csharp{title=\"Transactional Checkpoint Storage Configuration\" description=\"Configuration for transactional checkpoint storage with projections\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"checkpoints\", \"configuration\", \"transactions\"] framework=\"NET8\"}\nservices.AddProjection<OrderSummaryProjection>(options => {\n    options.CheckpointStorage = CheckpointStorage.SameDatabase;\n});\n\n// Implementation: Single transaction\nawait using var transaction = await database.BeginTransactionAsync();\nawait projectionStore.UpdateProjection(orderSummary, transaction);\nawait checkpointStore.SaveCheckpoint(position, transaction);\nawait transaction.CommitAsync();\n```\n\n**Benefits**:\n- ✅ Exactly-once processing guarantee\n- ✅ Simple consistency model\n- ✅ No external dependencies\n\n**Drawbacks**:\n- ❌ Tight coupling to projection database\n- ❌ Limited to single database systems\n\n### B. Separate Metadata Store\n\n**Flexible checkpoint storage** separate from projection data:\n\n```csharp{title=\"Separate Checkpoint Storage Configuration\" description=\"Configuration for separate checkpoint storage using Redis or other stores\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"checkpoints\", \"redis\", \"eventually-consistent\"] framework=\"NET8\"}\nservices.AddProjection<OrderSummaryProjection>(options => {\n    options.CheckpointStorage = CheckpointStorage.Separate;\n    options.CheckpointStore = CheckpointStore.Redis; // or CosmosDB, DynamoDB\n});\n\n// Implementation: Two-phase with compensation\ntry {\n    await projectionStore.UpdateProjection(orderSummary);\n    await checkpointStore.SaveCheckpoint(position);\n} catch {\n    // Compensation: projection will be updated again on replay\n    // Idempotent handlers ensure correctness\n}\n```\n\n**Benefits**:\n- ✅ Optimized checkpoint storage (Redis, DynamoDB)\n- ✅ Cross-database projections supported\n- ✅ Better performance for high-throughput scenarios\n\n**Drawbacks**:\n- ❌ Eventually consistent\n- ❌ Requires idempotent projection handlers\n\n### Checkpoint Configuration\n\n```csharp{title=\"Global Checkpoint Configuration\" description=\"Global checkpoint configuration and storage options\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"configuration\", \"global-settings\", \"checkpoints\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.Projections(projections => {\n        // Global checkpoint settings\n        projections.DefaultCheckpointStorage = CheckpointStorage.SameDatabase;\n        projections.CheckpointFrequency = CheckpointFrequency.EveryEvent; // or EveryNEvents(10)\n        \n        // Checkpoint stores\n        projections.UseRedisCheckpoints(\"localhost:6379\");\n        projections.UseCosmosCheckpoints(\"connection-string\");\n        projections.UseSqlCheckpoints(\"connection-string\");\n    });\n});\n```\n\n## Snapshot Management\n\n### A. Automatic Snapshots (Default)\n\n**Configurable automatic snapshotting** for projections:\n\n```csharp{title=\"Automatic Snapshot Configuration\" description=\"Automatic snapshot configuration with frequency and retention policies\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"snapshots\", \"automatic-management\"] framework=\"NET8\"}\nservices.AddProjection<CustomerSummaryProjection>(options => {\n    options.Snapshots(snapshots => {\n        snapshots.Strategy = SnapshotStrategy.Automatic;\n        snapshots.Frequency = SnapshotFrequency.EveryNEvents(1000);\n        snapshots.RetentionPolicy = SnapshotRetention.KeepLast(5);\n    });\n});\n```\n\n### B. Manual Snapshots\n\n**Developer-controlled snapshotting**:\n\n```csharp{title=\"Manual Snapshot Control\" description=\"Manual snapshot control with custom triggers and restoration logic\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"snapshots\", \"manual-control\", \"triggers\"] framework=\"NET8\"}\npublic class CustomerSummaryProjection : IProjectionHandler<CustomerRegistered>,\n                                        IProjectionHandler<CustomerUpdated>,\n                                        ISnapshotProvider<CustomerSummarySnapshot> {\n    \n    public CustomerSummary State { get; private set; }\n    \n    public async Task Handle(CustomerRegistered @event, ProjectionContext context) {\n        State = new CustomerSummary {\n            CustomerId = @event.CustomerId,\n            Name = @event.Name,\n            Email = @event.Email,\n            RegisteredAt = @event.RegisteredAt\n        };\n        \n        await context.Store(@event.CustomerId.ToString(), State);\n    }\n    \n    // Manual snapshot creation\n    [Snapshot(TriggerOn = typeof(CustomerMilestoneReached))]\n    public CustomerSummarySnapshot CreateSnapshot() {\n        return new CustomerSummarySnapshot {\n            CustomerId = State.CustomerId,\n            Name = State.Name,\n            TotalOrders = State.TotalOrders,\n            LifetimeValue = State.LifetimeValue,\n            SnapshotVersion = State.Version\n        };\n    }\n    \n    public void RestoreFromSnapshot(CustomerSummarySnapshot snapshot) {\n        State = new CustomerSummary {\n            CustomerId = snapshot.CustomerId,\n            Name = snapshot.Name,\n            TotalOrders = snapshot.TotalOrders,\n            LifetimeValue = snapshot.LifetimeValue,\n            Version = snapshot.SnapshotVersion\n        };\n    }\n}\n```\n\n### C. No Snapshots\n\n**Opt out of snapshotting** for simple projections:\n\n```csharp{title=\"Disable Snapshots Configuration\" description=\"Disabling snapshots for simple projections that don't need them\" category=\"Design\" difficulty=\"BEGINNER\" tags=[\"projections\", \"snapshots\", \"simple-projections\"] framework=\"NET8\"}\nservices.AddProjection<SimpleEventLogProjection>(options => {\n    options.Snapshots(snapshots => {\n        snapshots.Strategy = SnapshotStrategy.None;\n    });\n});\n```\n\n## Backfilling Strategies\n\n### A. Declarative Backfilling\n\n**Simple configuration-based backfilling**:\n\n```csharp{title=\"Declarative Backfilling Configuration\" description=\"Declarative backfilling configuration with date ranges and batch settings\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"backfilling\", \"declarative-configuration\"] framework=\"NET8\"}\nservices.AddProjection<OrderHistoryProjection>(options => {\n    options.Backfill(backfill => {\n        backfill.StartFrom = DateTimeOffset.Parse(\"2024-01-01\");\n        backfill.AutoStart = true;\n        backfill.BatchSize = 1000;\n        backfill.MaxConcurrency = 4;\n    });\n});\n\n// Or backfill everything\nservices.AddProjection<NewAnalyticsProjection>(options => {\n    options.BackfillFromBeginning();\n});\n```\n\n### B. Imperative Backfilling\n\n**Programmatic control over backfilling**:\n\n```csharp{title=\"Programmatic Backfilling REST API\" description=\"REST API controller for programmatic projection backfilling\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"backfilling\", \"rest-api\", \"controller\"] framework=\"NET8\"}\npublic class BackfillController : ControllerBase {\n    private readonly IProjectionManager _projectionManager;\n    \n    [HttpPost(\"projections/{projectionName}/backfill\")]\n    public async Task<IActionResult> BackfillProjection(\n        string projectionName,\n        BackfillRequest request) {\n        \n        var options = new BackfillOptions {\n            FromDate = request.FromDate,\n            ToDate = request.ToDate,\n            BatchSize = request.BatchSize ?? 1000,\n            IsAtomic = request.IsAtomic ?? false,\n            OnProgress = (progress) => {\n                // Real-time progress updates via SignalR\n                _hubContext.Clients.All.SendAsync(\"BackfillProgress\", progress);\n            }\n        };\n        \n        var result = await _projectionManager.BackfillAsync(projectionName, options);\n        return Ok(result);\n    }\n}\n```\n\n### System Events for On-Demand Backfilling\n\n**Event-driven backfill requests**:\n\n```csharp{title=\"System Events for Backfilling\" description=\"System events for on-demand projection backfilling with criteria\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"system-events\", \"event-driven-backfill\"] framework=\"NET8\"}\n// System event to trigger backfilling\npublic record ProjectionBackfillRequested(\n    string ProjectionName,\n    DateTimeOffset? FromDate,\n    DateTimeOffset? ToDate,\n    bool IsAtomic,\n    BackfillCriteria Criteria,\n    string RequestedBy\n) : ISystemEvent;\n\n```csharp{title=\"Backfill System Event Handler\" description=\"System event handler for processing backfill requests\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"system-events\", \"event-handlers\", \"backfilling\"] framework=\"NET8\"}\n// System event handler\npublic class ProjectionBackfillHandler : ISystemEventHandler<ProjectionBackfillRequested> {\n    public async Task Handle(ProjectionBackfillRequested @event, SystemEventContext context) {\n        var options = new BackfillOptions {\n            FromDate = @event.FromDate,\n            ToDate = @event.ToDate,\n            IsAtomic = @event.IsAtomic,\n            Criteria = @event.Criteria,\n            RequestId = context.CorrelationId\n        };\n        \n        await _projectionManager.BackfillAsync(@event.ProjectionName, options);\n        \n        // Emit completion event\n        await context.PublishSystemEvent(new ProjectionBackfillCompleted(\n            @event.ProjectionName,\n            options.FromDate,\n            options.ToDate,\n            context.CorrelationId\n        ));\n    }\n}\n\n// Trigger backfill via system event\nawait _systemEventPublisher.PublishAsync(new ProjectionBackfillRequested(\n    ProjectionName: \"order-summary\",\n    FromDate: DateTimeOffset.Parse(\"2024-01-01\"),\n    ToDate: null, // To current\n    IsAtomic: true,\n    Criteria: BackfillCriteria.FullRebuild,\n    RequestedBy: \"admin-user\"\n));\n```\n\n### Backfill Criteria Options\n\n```csharp{title=\"Backfill Criteria Options\" description=\"Comprehensive backfill criteria options for different scenarios\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"backfilling\", \"criteria-options\"] framework=\"NET8\"}\npublic enum BackfillCriteria {\n    // Date-based backfill\n    DateRange,              // Specific date range\n    FromDate,               // From date to current\n    LastNDays,              // Last N days only\n    \n    // Event-based backfill  \n    EventNumberRange,       // Specific event number range\n    FromEventNumber,        // From event number to current\n    LastNEvents,            // Last N events only\n    \n    // Full rebuild options\n    FullRebuild,            // Complete rebuild from beginning\n    IncrementalUpdate,      // Only missing/updated events\n    \n    // Custom criteria\n    CustomPredicate         // Custom filter expression\n}\n\n// Usage examples\nservices.AddProjection<OrderSummaryProjection>(options => {\n    options.Backfill(backfill => {\n        backfill.Criteria = BackfillCriteria.LastNDays;\n        backfill.CriteriaValue = 30; // Last 30 days\n    });\n});\n\n// System event with custom criteria\nawait _systemEvents.PublishAsync(new ProjectionBackfillRequested(\n    ProjectionName: \"analytics\",\n    FromDate: null,\n    ToDate: null,\n    IsAtomic: false,\n    Criteria: BackfillCriteria.CustomPredicate,\n    RequestedBy: \"system\"\n) {\n    CustomPredicate = @event => @event.EventType.StartsWith(\"Order\") && \n                               @event.Metadata[\"source\"] == \"web-api\"\n});\n```\n\n## Advanced Backfill Features\n\n### Parallel Processing\n\n```csharp{title=\"Parallel Backfill Processing\" description=\"Parallel backfill processing with partitioning and concurrency control\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"backfilling\", \"parallel-processing\", \"concurrency\"] framework=\"NET8\"}\nservices.AddProjection<AnalyticsProjection>(options => {\n    options.Backfill(backfill => {\n        backfill.Strategy = BackfillStrategy.Parallel;\n        backfill.PartitionBy = @event => @event.StreamId.GetHashCode() % 8;\n        backfill.MaxConcurrency = 8;\n        backfill.BatchSize = 500;\n    });\n});\n```\n\n### Progress Tracking\n\n```csharp{title=\"Backfill Progress Tracking\" description=\"Real-time progress tracking for backfill operations\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"backfilling\", \"progress-tracking\"] framework=\"NET8\"}\npublic class BackfillProgressTracker {\n    public async Task TrackProgress(string projectionName, CancellationToken cancellationToken) {\n        await foreach (var progress in _projectionManager.GetBackfillProgress(projectionName, cancellationToken)) {\n            Console.WriteLine($\"Backfill progress: {progress.EventsProcessed}/{progress.TotalEvents} \" +\n                            $\"({progress.PercentComplete:F1}%) - ETA: {progress.EstimatedTimeRemaining}\");\n        }\n    }\n}\n```\n\n### Rollback Support\n\n```csharp{title=\"Backfill Rollback Support\" description=\"Rollback support for failed backfill operations with backup creation\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"backfilling\", \"rollback-support\", \"backup\"] framework=\"NET8\"}\n// Rollback to previous version if backfill fails\nservices.AddProjection<OrderSummaryProjection>(options => {\n    options.Backfill(backfill => {\n        backfill.EnableRollback = true;\n        backfill.RollbackOnFailure = true;\n        backfill.CreateBackupBeforeBackfill = true;\n    });\n});\n\n// Manual rollback API\nawait _projectionManager.RollbackProjection(\"order-summary\", toVersion: previousVersion);\n```\n\n## System Event Integration\n\n### Built-in System Events\n\n```csharp{title=\"Projection Lifecycle System Events\" description=\"Built-in system events for projection lifecycle monitoring\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"system-events\", \"lifecycle-management\"] framework=\"NET8\"}\n// Projection lifecycle events\npublic record ProjectionStarted(string ProjectionName, DateTimeOffset StartedAt);\npublic record ProjectionStopped(string ProjectionName, DateTimeOffset StoppedAt);\npublic record ProjectionFailed(string ProjectionName, Exception Error, DateTimeOffset FailedAt);\n\n// Backfill events\npublic record ProjectionBackfillStarted(string ProjectionName, BackfillOptions Options);\npublic record ProjectionBackfillProgress(string ProjectionName, BackfillProgress Progress);\npublic record ProjectionBackfillCompleted(string ProjectionName, BackfillResult Result);\npublic record ProjectionBackfillFailed(string ProjectionName, Exception Error);\n\n// Checkpoint events\npublic record ProjectionCheckpointSaved(string ProjectionName, long Position);\npublic record ProjectionCheckpointRestored(string ProjectionName, long Position);\n\n// Snapshot events\npublic record ProjectionSnapshotCreated(string ProjectionName, long EventVersion);\npublic record ProjectionSnapshotRestored(string ProjectionName, long EventVersion);\n```\n\n### Custom System Event Handlers\n\n```csharp{title=\"Projection Monitoring Event Handlers\" description=\"Custom system event handlers for projection monitoring and alerting\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"system-events\", \"monitoring\", \"alerting\"] framework=\"NET8\"}\npublic class ProjectionMonitoringHandler : \n    ISystemEventHandler<ProjectionFailed>,\n    ISystemEventHandler<ProjectionBackfillCompleted> {\n    \n    public async Task Handle(ProjectionFailed @event, SystemEventContext context) {\n        // Alert on projection failures\n        await _alerting.SendAlert($\"Projection {@event.ProjectionName} failed: {@event.Error.Message}\");\n        \n        // Automatic retry for transient failures\n        if (IsTransientError(@event.Error)) {\n            await context.PublishSystemEvent(new ProjectionRestartRequested(\n                @event.ProjectionName,\n                retryAttempt: context.GetRetryAttempt() + 1\n            ));\n        }\n    }\n    \n    public async Task Handle(ProjectionBackfillCompleted @event, SystemEventContext context) {\n        // Update projection metadata\n        await _projectionMetadata.MarkBackfillComplete(@event.ProjectionName, @event.Result);\n        \n        // Notify stakeholders\n        await _notifications.NotifyBackfillComplete(@event.ProjectionName);\n    }\n}\n```\n\n## API Reference\n\n### IProjectionManager Interface\n\n```csharp{title=\"IProjectionManager Interface\" description=\"Comprehensive projection management API interface\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"management-api\", \"interfaces\"] framework=\"NET8\"}\npublic interface IProjectionManager {\n    // Lifecycle management\n    Task StartProjection(string projectionName);\n    Task StopProjection(string projectionName);\n    Task RestartProjection(string projectionName);\n    \n    // Backfilling\n    Task<BackfillResult> BackfillAsync(string projectionName, BackfillOptions options);\n    IAsyncEnumerable<BackfillProgress> GetBackfillProgress(string projectionName, CancellationToken cancellationToken);\n    Task CancelBackfill(string projectionName);\n    \n    // Snapshots\n    Task<SnapshotResult> CreateSnapshot(string projectionName);\n    Task<SnapshotResult> RestoreFromSnapshot(string projectionName, long snapshotVersion);\n    Task<IEnumerable<SnapshotInfo>> GetSnapshots(string projectionName);\n    \n    // Checkpoints\n    Task<long> GetCurrentCheckpoint(string projectionName);\n    Task ResetCheckpoint(string projectionName, long position);\n    \n    // Status and monitoring\n    Task<ProjectionStatus> GetStatus(string projectionName);\n    Task<IEnumerable<ProjectionInfo>> GetAllProjections();\n    Task<ProjectionHealth> GetHealth(string projectionName);\n}\n```\n\n### Configuration Extensions\n\n```csharp{title=\"Projection Configuration Extensions\" description=\"Extension methods for fluent projection configuration API\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"extension-methods\", \"fluent-api\"] framework=\"NET8\"}\npublic static class ProjectionConfigurationExtensions {\n    public static IProjectionBuilder<T> BackfillFromBeginning<T>(this IProjectionBuilder<T> builder) \n        where T : class;\n    \n    public static IProjectionBuilder<T> BackfillFrom<T>(this IProjectionBuilder<T> builder, DateTimeOffset from) \n        where T : class;\n    \n    public static IProjectionBuilder<T> WithSnapshots<T>(this IProjectionBuilder<T> builder, \n        Action<SnapshotConfiguration> configure) where T : class;\n    \n    public static IProjectionBuilder<T> WithCheckpoints<T>(this IProjectionBuilder<T> builder, \n        Action<CheckpointConfiguration> configure) where T : class;\n    \n    public static IProjectionBuilder<T> OnSystemEvent<T, TEvent>(this IProjectionBuilder<T> builder, \n        Func<TEvent, Task> handler) where T : class where TEvent : ISystemEvent;\n}\n```\n\n## Best Practices\n\n### Projection Design\n\n1. **Keep projections focused** - One projection per query need\n2. **Make handlers idempotent** - Support replay scenarios\n3. **Handle missing data gracefully** - Events may be out of order\n4. **Version projection schemas** - Enable evolution over time\n\n### Backfill Planning\n\n1. **Test backfills in staging** - Verify performance and correctness\n2. **Use atomic rebuilds** for critical projections\n3. **Monitor resource usage** during large backfills\n4. **Plan for rollback scenarios** if backfill fails\n\n### Checkpoint Strategy\n\n1. **Use same-database checkpoints** for consistency-critical projections\n2. **Use separate checkpoints** for high-throughput scenarios\n3. **Checkpoint frequently** to minimize replay overhead\n4. **Monitor checkpoint lag** for early failure detection\n\n",
        "tags": "projections, backfilling, checkpoints, system-events, rebuilding",
        "version": "proposals"
      },
      {
        "slug": "proposals/schema-evolution",
        "title": "Schema Evolution & Event Versioning",
        "category": "Architecture & Design",
        "order": 9,
        "description": "\n# Schema Evolution & Event Versioning\n\nWhizbang provides robust schema evolution capabilities using JSONB storage and flexible driver interfaces, allowing events and projections to evolve over time without breaking existing systems.\n\n## JSONB-Based Schema Evolution\n\n### Flexible Event Schema\n\nEvents stored in **JSONB format** naturally support schema evolution:\n\n```csharp{title=\"Event Schema Evolution\" description=\"Event schema evolution from V1 to V3 with backward-compatible changes\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Schema-Evolution\", \"Event-Versioning\", \"Backward-Compatibility\"] framework=\"NET8\"}\n// V1 Event\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId\n);\n\n// V2 Event - Add field (backward compatible)\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset? PlacedAt = null  // Optional for backward compatibility\n);\n\n// V3 Event - Add collection (backward compatible)\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset? PlacedAt = null,\n    List<string> Tags = null         // Null-safe collection\n) {\n    // Ensure collections are never null\n    public List<string> Tags { get; init; } = Tags ?? new List<string>();\n}\n```\n\n**JSONB benefits**:\n- ✅ Missing fields handled gracefully\n- ✅ Extra fields ignored during deserialization\n- ✅ No database schema migrations required\n- ✅ Query flexibility with JSON operators\n\n### Projection Schema Evolution\n\nProjections can evolve independently of events:\n\n```csharp{title=\"Projection Schema Evolution\" description=\"Projection schema evolution without database migrations using JSONB\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Schema-Evolution\", \"Projections\", \"JSONB-Storage\"] framework=\"NET8\"}\n// V1 Projection\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public decimal Total { get; set; }\n    public OrderStatus Status { get; set; }\n}\n\n// V2 Projection - Add fields without migration\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public decimal Total { get; set; }\n    public OrderStatus Status { get; set; }\n    \n    // New fields with sensible defaults\n    public DateTime EstimatedDelivery { get; set; } = DateTime.MinValue;\n    public List<string> Tags { get; set; } = new();\n    public CustomerInfo Customer { get; set; } = new();\n}\n\n// Projection rebuild handles missing data gracefully\npublic class OrderSummaryProjection : IProjectionHandler<OrderPlaced> {\n    public async Task Handle(OrderPlaced @event, ProjectionContext context) {\n        var summary = await context.Load<OrderSummary>(@event.OrderId.ToString()) \n                      ?? new OrderSummary();\n        \n        summary.OrderId = @event.OrderId;\n        summary.Total = @event.Total;\n        \n        // Handle optional V2+ fields\n        if (@event.PlacedAt.HasValue) {\n            summary.EstimatedDelivery = @event.PlacedAt.Value.AddDays(7);\n        }\n        \n        if (@event.Tags?.Any() == true) {\n            summary.Tags = @event.Tags;\n        }\n        \n        await context.Store(@event.OrderId.ToString(), summary);\n    }\n}\n```\n\n## Event Versioning Strategies\n\n### A. Upcasting (Recommended)\n\n**Convert old events to new schema on read**:\n\n```csharp{title=\"Event Upcaster Interface\" description=\"Event upcasting interface for converting old events to new schemas\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Upcasting\", \"Event-Transformation\", \"Interface\"] framework=\"NET8\"}\npublic interface IEventUpcaster<TOld, TNew> {\n    TNew Upcast(TOld oldEvent);\n    bool CanUpcast(Type eventType, int version);\n}\n\n```csharp{title=\"Concrete Upcaster Implementation\" description=\"Concrete upcaster implementation for event version migration\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Upcasting\", \"Implementation\", \"Registration\"] framework=\"NET8\"}\n// Upcast V1 OrderPlaced to V2\npublic class OrderPlacedV1ToV2Upcaster : IEventUpcaster<OrderPlacedV1, OrderPlaced> {\n    public OrderPlaced Upcast(OrderPlacedV1 oldEvent) {\n        return new OrderPlaced(\n            oldEvent.OrderId,\n            oldEvent.CustomerId,\n            PlacedAt: DateTimeOffset.UtcNow, // Best guess for missing data\n            Tags: new List<string>()         // Default to empty\n        );\n    }\n    \n    public bool CanUpcast(Type eventType, int version) {\n        return eventType == typeof(OrderPlacedV1) && version == 1;\n    }\n}\n\n// Registration\nservices.AddWhizbang(options => {\n    options.EventVersioning(versioning => {\n        versioning.AddUpcaster<OrderPlacedV1ToV2Upcaster>();\n        versioning.AddUpcaster<OrderPlacedV2ToV3Upcaster>();\n    });\n});\n```\n\n### B. Multiple Versions Supported Simultaneously\n\n**Keep multiple event versions active**:\n\n```csharp{title=\"Multiple Version Handlers\" description=\"Supporting multiple event versions simultaneously with separate handlers\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Multiple-Versions\", \"Event-Handlers\", \"Registration\"] framework=\"NET8\"}\n// Multiple handlers for different versions\npublic class OrderPlacedV1Handler : IEventHandler<OrderPlacedV1> {\n    public async Task Handle(OrderPlacedV1 @event, EventContext context) {\n        // Handle legacy V1 events\n        var order = await _repository.Load<Order>(@event.OrderId);\n        order.MarkAsPlaced(placedAt: DateTimeOffset.UtcNow); // Default timestamp\n        await _repository.Save(order);\n    }\n}\n\npublic class OrderPlacedV2Handler : IEventHandler<OrderPlaced> {\n    public async Task Handle(OrderPlaced @event, EventContext context) {\n        // Handle current V2+ events\n        var order = await _repository.Load<Order>(@event.OrderId);\n        order.MarkAsPlaced(@event.PlacedAt ?? DateTimeOffset.UtcNow);\n        await _repository.Save(order);\n    }\n}\n\n// Router determines which handler to use based on event version\nservices.AddWhizbang(options => {\n    options.EventVersioning(versioning => {\n        versioning.RouteByVersion = true;\n        versioning.RegisterHandler<OrderPlacedV1Handler>(version: 1);\n        versioning.RegisterHandler<OrderPlacedV2Handler>(version: 2);\n    });\n});\n```\n\n### C. Schema Registry\n\n**Centralized schema management**:\n\n```csharp{title=\"Schema Registry Configuration\" description=\"Centralized schema registry configuration for schema management\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Schema-Registry\", \"Centralized-Management\", \"Configuration\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.EventVersioning(versioning => {\n        versioning.UseSchemaRegistry(registry => {\n            registry.ConnectionString = \"https://schema-registry.company.com\";\n            registry.AutoRegisterSchemas = true;\n            registry.ValidateOnWrite = true;\n            registry.CompatibilityLevel = CompatibilityLevel.Backward;\n        });\n    });\n});\n\n// Events automatically registered with schema registry\n[SchemaRegistration(subject: \"order-placed\", version: 2)]\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset? PlacedAt = null\n);\n```\n\n## Driver Interface for Schema Evolution\n\n### Abstract Driver Interface\n\n```csharp{title=\"Schema Evolution Driver Interface\" description=\"Driver interface for schema evolution with versioning and upcasting support\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Driver-Interface\", \"Serialization\", \"Versioning\"] framework=\"NET8\"}\npublic interface ISchemaEvolutionDriver {\n    // Serialization with versioning\n    Task<byte[]> Serialize<T>(T @event, int? version = null);\n    Task<T> Deserialize<T>(byte[] data, int version);\n    Task<object> DeserializeToLatestVersion(byte[] data, Type eventType, int storedVersion);\n    \n    // Schema registration\n    Task RegisterSchema(Type eventType, int version);\n    Task<SchemaInfo> GetSchema(Type eventType, int version);\n    Task<IEnumerable<SchemaInfo>> GetSchemaEvolution(Type eventType);\n    \n    // Upcasting support\n    Task<T> UpcastToLatest<T>(object oldEvent, int fromVersion);\n    bool CanUpcast(Type eventType, int fromVersion, int toVersion);\n}\n\npublic class SchemaInfo {\n    public Type EventType { get; set; }\n    public int Version { get; set; }\n    public string Schema { get; set; }\n    public DateTime RegisteredAt { get; set; }\n    public CompatibilityLevel Compatibility { get; set; }\n}\n```\n\n### PostgreSQL JSONB Driver Implementation\n\n```csharp{title=\"PostgreSQL Schema Evolution Driver\" description=\"PostgreSQL JSONB implementation of schema evolution driver with serialization and upcasting\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"PostgreSQL\", \"JSONB-Implementation\", \"Driver\"] framework=\"NET8\"}\npublic class PostgresSchemaEvolutionDriver : ISchemaEvolutionDriver {\n    public async Task<byte[]> Serialize<T>(T @event, int? version = null) {\n        var eventType = typeof(T);\n        var currentVersion = version ?? await GetLatestVersion(eventType);\n        \n        var eventData = new {\n            EventType = eventType.FullName,\n            Version = currentVersion,\n            Data = @event\n        };\n        \n        return JsonSerializer.SerializeToUtf8Bytes(eventData);\n    }\n    \n    public async Task<T> Deserialize<T>(byte[] data, int version) {\n        var eventData = JsonSerializer.Deserialize<dynamic>(data);\n        var storedVersion = (int)eventData.Version;\n        \n        if (storedVersion == version) {\n            return JsonSerializer.Deserialize<T>(eventData.Data);\n        }\n        \n        // Need to upcast\n        var oldEvent = DeserializeToVersion(eventData.Data, typeof(T), storedVersion);\n        return await UpcastToLatest<T>(oldEvent, storedVersion);\n    }\n    \n    public async Task<object> DeserializeToLatestVersion(byte[] data, Type eventType, int storedVersion) {\n        var latestVersion = await GetLatestVersion(eventType);\n        \n        if (storedVersion == latestVersion) {\n            // Already latest version\n            return JsonSerializer.Deserialize(data, eventType);\n        }\n        \n        // Upcast to latest\n        var oldEvent = DeserializeToVersion(data, eventType, storedVersion);\n        return await UpcastToLatest(oldEvent, eventType, storedVersion, latestVersion);\n    }\n}\n```\n\n## LINQ Support Evolution\n\n### Driver-Specific LINQ Implementation\n\n```csharp{title=\"Query Evolution Driver Interface\" description=\"Driver interface for schema-aware LINQ querying across versions\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"LINQ-Support\", \"Querying\", \"Interface\"] framework=\"NET8\"}\npublic interface IQueryEvolutionDriver {\n    IQueryable<T> Query<T>() where T : class;\n    IQueryable<T> QueryVersion<T>(int version) where T : class;\n    IQueryable<object> QueryAllVersions(Type eventType);\n}\n\n```csharp{title=\"PostgreSQL Query Driver Implementation\" description=\"PostgreSQL implementation with JSONB operators for evolved schemas\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"PostgreSQL\", \"JSONB-Queries\", \"EF-Core\"] framework=\"NET8\"}\n// PostgreSQL implementation with JSONB operators\npublic class PostgresQueryDriver : IQueryEvolutionDriver {\n    public IQueryable<T> Query<T>() where T : class {\n        return _context.Events\n            .Where(e => e.EventType == typeof(T).Name)\n            .Select(e => JsonSerializer.Deserialize<T>(e.EventData))\n            .AsQueryable();\n    }\n    \n    // JSONB path queries for evolved schemas\n    public IQueryable<OrderSummary> QueryOrdersWithTags() {\n        return _context.Projections\n            .Where(p => p.ProjectionName == \"order-summary\")\n            .Where(p => EF.Functions.JsonExists(p.Document, \"$.Tags\"))  // Has tags field\n            .Select(p => JsonSerializer.Deserialize<OrderSummary>(p.Document))\n            .AsQueryable();\n    }\n    \n    // Query across schema versions\n    public IQueryable<decimal> QueryOrderTotals() {\n        return _context.Events\n            .Where(e => e.EventType == \"OrderPlaced\")\n            .Select(e => EF.Functions.JsonExtract<decimal>(e.EventData, \"$.Total\"))\n            .AsQueryable();\n    }\n}\n```\n\n### Schema-Aware Query Extensions\n\n```csharp{title=\"Schema-Aware Query Extensions\" description=\"Extension methods for schema-aware querying and filtering across versions\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Schema-Evolution\", \"LINQ-Extensions\", \"Query-Helpers\", \"Extensions\"] framework=\"NET8\"}\npublic static class SchemaQueryExtensions {\n    public static IQueryable<T> WhereSchemaVersion<T>(this IQueryable<T> query, int version) {\n        // Filter by schema version\n        return query.Where(/* version filter logic */);\n    }\n    \n    public static IQueryable<T> WhereHasField<T>(this IQueryable<T> query, string fieldPath) {\n        // Filter by field existence (JSONB support)\n        return query.Where(/* field existence logic */);\n    }\n    \n    public static IQueryable<TResult> SelectEvolved<T, TResult>(\n        this IQueryable<T> query, \n        Expression<Func<T, TResult>> selector,\n        SchemaEvolutionOptions options = null) {\n        // Schema-aware projection\n        return query.Select(/* evolved selector logic */);\n    }\n}\n\n// Usage\nvar recentOrdersWithTags = await _context.Query<OrderSummary>()\n    .WhereHasField(\"Tags\")\n    .Where(o => o.PlacedAt > DateTime.UtcNow.AddDays(-30))\n    .ToListAsync();\n```\n\n## Blue/Green Deployment Support\n\n### Driver-Level Blue/Green Implementation\n\n```csharp{title=\"Blue/Green Deployment Driver\" description=\"Driver interface and implementation for blue/green projection deployments\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Blue-Green-Deployment\", \"Driver-Interface\", \"PostgreSQL\"] framework=\"NET8\"}\npublic interface IBlueGreenDriver {\n    Task<string> CreateGreenDeployment(string projectionName);\n    Task BuildGreenProjection(string projectionName, string greenVersion);\n    Task ValidateGreenProjection(string projectionName, string greenVersion);\n    Task SwitchToGreen(string projectionName, string greenVersion);\n    Task CleanupBlueVersion(string projectionName);\n}\n\npublic class PostgresBlueGreenDriver : IBlueGreenDriver {\n    public async Task<string> CreateGreenDeployment(string projectionName) {\n        var greenVersion = Guid.NewGuid().ToString(\"N\")[..8];\n        var greenTableName = $\"{projectionName}_green_{greenVersion}\";\n        \n        // Create green table with same schema as blue\n        await _connection.ExecuteAsync($\"\"\"\n            CREATE TABLE {greenTableName} (LIKE {projectionName} INCLUDING ALL);\n            CREATE INDEX CONCURRENTLY idx_{greenTableName}_tenant \n                ON {greenTableName}(tenant_id) WHERE tenant_id IS NOT NULL;\n        \"\"\");\n        \n        return greenVersion;\n    }\n    \n    public async Task BuildGreenProjection(string projectionName, string greenVersion) {\n        var greenTableName = $\"{projectionName}_green_{greenVersion}\";\n        \n        // Rebuild projection in green table from events\n        await _projectionBuilder.RebuildInTable(projectionName, greenTableName);\n    }\n    \n    public async Task SwitchToGreen(string projectionName, string greenVersion) {\n        var greenTableName = $\"{projectionName}_green_{greenVersion}\";\n        var blueBackupName = $\"{projectionName}_blue_backup_{DateTimeOffset.UtcNow:yyyyMMdd_HHmmss}\";\n        \n        // Atomic table swap\n        await _connection.ExecuteAsync($\"\"\"\n            BEGIN;\n            ALTER TABLE {projectionName} RENAME TO {blueBackupName};\n            ALTER TABLE {greenTableName} RENAME TO {projectionName};\n            COMMIT;\n        \"\"\");\n    }\n}\n```\n\n## Configuration and Best Practices\n\n### Comprehensive Schema Evolution Setup\n\n```csharp{title=\"Comprehensive Schema Evolution Setup\" description=\"Complete schema evolution configuration with all features enabled\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Configuration\", \"Comprehensive-Setup\", \"Best-Practices\"] framework=\"NET8\"}\nservices.AddWhizbang(options => {\n    options.SchemaEvolution(evolution => {\n        // Storage format\n        evolution.UseJsonb = true;\n        evolution.StoreSchemaVersion = true;\n        evolution.ValidateOnWrite = false; // Allow forward compatibility\n        \n        // Versioning strategy\n        evolution.VersioningStrategy = VersioningStrategy.Upcasting;\n        evolution.AutoRegisterUpcasterts = true;\n        evolution.UpcastOnRead = true;\n        \n        // Schema registry\n        evolution.UseSchemaRegistry(registry => {\n            registry.Url = \"https://schema-registry.internal\";\n            registry.AutoRegister = true;\n            registry.CompatibilityLevel = CompatibilityLevel.Backward;\n        });\n        \n        // Blue/Green deployments\n        evolution.BlueGreen(blueGreen => {\n            blueGreen.ValidationThreshold = 0.99; // 99% accuracy required\n            blueGreen.WarmupPeriod = TimeSpan.FromMinutes(5);\n            blueGreen.AutoSwitch = false; // Manual approval required\n        });\n    });\n});\n```\n\n### Event Versioning Best Practices\n\n```csharp{title=\"Event Versioning Best Practices\" description=\"Best practices for event versioning and backward-compatible schema evolution\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Schema-Evolution\", \"Best-Practices\", \"Backward-Compatibility\", \"Versioning\"] framework=\"NET8\"}\n// 1. Always make fields optional when adding them\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset? PlacedAt = null,      // Optional - added in V2\n    List<string>? Tags = null             // Optional - added in V3\n);\n\n// 2. Use wrapper types for complex evolution\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    OrderMetadata? Metadata = null        // Wrapper for evolving fields\n);\n\npublic record OrderMetadata(\n    DateTimeOffset? PlacedAt = null,\n    List<string>? Tags = null,\n    CustomerInfo? Customer = null\n);\n\n// 3. Never remove fields - mark as obsolete\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    \n    [Obsolete(\"Use Metadata.PlacedAt instead\")]\n    DateTimeOffset? PlacedAt = null,      // Keep for backward compatibility\n    \n    OrderMetadata? Metadata = null\n);\n\n// 4. Use semantic versioning for breaking changes\n[EventVersion(\"order-placed\", \"1.0.0\")]\npublic record OrderPlacedV1(Guid OrderId, Guid CustomerId);\n\n[EventVersion(\"order-placed\", \"1.1.0\")]  // Minor version - additive\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset? PlacedAt = null);\n\n[EventVersion(\"order-placed\", \"2.0.0\")]  // Major version - breaking change\npublic record OrderPlacedV2(Guid OrderId, CustomerId CustomerId, DateTimeOffset PlacedAt);\n```\n\n### Projection Evolution Guidelines\n\n1. **Add fields with defaults** - New fields should have sensible default values\n2. **Rebuild for major changes** - Use blue/green deployment for breaking changes\n3. **Test evolution paths** - Verify old events work with new projections\n4. **Monitor data quality** - Track schema evolution impact on data\n5. **Document changes** - Keep clear records of schema evolution decisions\n\n",
        "tags": "schema-evolution, event-versioning, jsonb, upcasting, backward-compatibility",
        "version": "proposals"
      },
      {
        "slug": "proposals/source-generation-ide",
        "title": "Source Generation & IDE Integration",
        "category": "Architecture & Design",
        "order": 12,
        "description": "\n# Source Generation & IDE Integration\n\nWhizbang uses advanced source generation and IDE integration to provide a seamless developer experience with compile-time validation, intelligent navigation, and powerful debugging tools.\n\n## Source Generator Architecture\n\n### Single Pipeline Generator\n\n**Incremental source generator** with orchestrated pipeline stages for optimal performance:\n\n```csharp{\ntitle: \"Incremental Source Generator\"\ndescription: \"Single incremental source generator with orchestrated pipeline stages\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"Design\", \"Source-Generation\", \"Incremental-Generation\", \"Pipeline-Architecture\"]\nframework: \"NET8\"\n}\n[Generator]\npublic class WhizbangSourceGenerator : IIncrementalGenerator {\n    public void Initialize(IncrementalGeneratorInitializationContext context) {\n        // Stage 1: Handler Discovery Pipeline\n        var handlersPipeline = context.SyntaxProvider.CreateSyntaxProvider(\n            predicate: (node, _) => IsHandlerCandidate(node),\n            transform: (ctx, _) => ExtractHandlerInfo(ctx)\n        ).Where(info => info != null);\n        \n        // Stage 2: Domain Ownership Pipeline  \n        var domainOwnershipPipeline = context.SyntaxProvider.CreateSyntaxProvider(\n            predicate: (node, _) => IsDomainCandidate(node),\n            transform: (ctx, _) => ExtractDomainInfo(ctx)\n        );\n        \n        // Stage 3: Projection Pipeline\n        var projectionsPipeline = context.SyntaxProvider.CreateSyntaxProvider(\n            predicate: (node, _) => IsProjectionCandidate(node),\n            transform: (ctx, _) => ExtractProjectionInfo(ctx)\n        );\n        \n        // Stage 4: Policy Pipeline\n        var policiesPipeline = context.SyntaxProvider.CreateSyntaxProvider(\n            predicate: (node, _) => IsPolicyCandidate(node),\n            transform: (ctx, _) => ExtractPolicyInfo(ctx)\n        );\n        \n        // Combine all sources for cross-project aggregation\n        var combinedPipeline = handlersPipeline\n            .Combine(domainOwnershipPipeline)\n            .Combine(projectionsPipeline)\n            .Combine(policiesPipeline);\n            \n        // Generate code\n        context.RegisterSourceOutput(combinedPipeline, GenerateWhizbangRegistry);\n        \n        // Generate metadata for IDE service\n        context.RegisterSourceOutput(combinedPipeline, GenerateNavigationMetadata);\n        \n        // Generate analyzer data\n        context.RegisterSourceOutput(combinedPipeline, GenerateAnalyzerData);\n    }\n}\n```\n\n### Build Performance & Logging\n\n**Detailed timing and logging** for optimization:\n\n```csharp{\ntitle: \"Performance Tracker\"\ndescription: \"Performance tracking for source generation stages with detailed timing\"\ncategory: \"Design\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Design\", \"Source-Generation\", \"Performance-Tracking\", \"Build-Optimization\"]\nframework: \"NET8\"\n}\npublic class GenerationPerformanceTracker {\n    private readonly Dictionary<string, Stopwatch> _stageTimers = new();\n    \n    public void StartStage(string stageName) {\n        _stageTimers[stageName] = Stopwatch.StartNew();\n        LogInformation($\"Starting stage: {stageName}\");\n    }\n    \n    public void EndStage(string stageName) {\n        if (_stageTimers.TryGetValue(stageName, out var timer)) {\n            timer.Stop();\n            LogInformation($\"Completed stage: {stageName} in {timer.ElapsedMilliseconds}ms\");\n        }\n    }\n    \n    public void LogSummary() {\n        var totalTime = _stageTimers.Values.Sum(t => t.ElapsedMilliseconds);\n        LogInformation($\"Total generation time: {totalTime}ms\");\n        \n        foreach (var (stage, timer) in _stageTimers) {\n            var percentage = (timer.ElapsedMilliseconds / (double)totalTime) * 100;\n            LogInformation($\"  {stage}: {timer.ElapsedMilliseconds}ms ({percentage:F1}%)\");\n        }\n    }\n}\n```\n\n### Multi-Project Aggregation\n\n**Cross-assembly handler discovery** and registration:\n\n```csharp{\ntitle: \"Cross-Project Registry\"\ndescription: \"Generated registry that aggregates handlers across multiple projects\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"Design\", \"Source-Generation\", \"Multi-Project-Aggregation\", \"Code-Generation\"]\nframework: \"NET8\"\n}\n// Generated registry aggregates across projects\n[GeneratedCode(\"Whizbang.SourceGenerator\")]\npublic static class WhizbangGeneratedRegistry {\n    public static void RegisterAll(IServiceCollection services) {\n        // Handlers from current project\n        RegisterLocalHandlers(services);\n        \n        // Handlers from referenced projects\n        RegisterReferencedHandlers(services);\n        \n        // Domain ownership from all projects\n        RegisterDomainOwnership(services);\n        \n        // Policies from all projects\n        RegisterPolicies(services);\n    }\n    \n    private static void RegisterLocalHandlers(IServiceCollection services) {\n        services.AddScoped<ICommandHandler<PlaceOrder>, PlaceOrderHandler>();\n        services.AddScoped<IEventHandler<OrderPlaced>, OrderSummaryProjection>();\n        // ... other local handlers\n    }\n    \n    private static void RegisterReferencedHandlers(IServiceCollection services) {\n        // Handlers discovered from referenced assemblies\n        SharedLibrary.WhizbangRegistry.RegisterHandlers(services);\n        CoreDomain.WhizbangRegistry.RegisterHandlers(services);\n    }\n}\n```\n\n## IDE Navigation Service\n\n### Event Stream Navigation\n\n**GitLens-style navigation** through event streams and handlers:\n\n```csharp{\ntitle: \"Navigation Service\"\ndescription: \"Navigation service interface for GitLens-style event stream traversal\"\ncategory: \"Design\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Design\", \"IDE-Integration\", \"Navigation-Service\", \"Event-Stream-Navigation\"]\nframework: \"NET8\"\n}\npublic interface IWhizbangNavigationService {\n    Task<EventStreamInfo> GetEventStreamAsync(string streamId);\n    Task<IEnumerable<HandlerInfo>> GetHandlersForEventAsync(Type eventType);\n    Task<IEnumerable<ProjectionInfo>> GetProjectionsForEventAsync(Type eventType);\n    Task<EventFlowDiagram> GetEventFlowAsync(Type commandType);\n    Task<DomainMap> GetDomainMapAsync();\n}\n\n// Event flow visualization\npublic class EventFlowDiagram {\n    public CommandInfo Command { get; set; }\n    public HandlerInfo CommandHandler { get; set; }\n    public List<EventInfo> EmittedEvents { get; set; }\n    public Dictionary<EventInfo, List<HandlerInfo>> EventHandlers { get; set; }\n    public Dictionary<EventInfo, List<ProjectionInfo>> EventProjections { get; set; }\n    public List<SagaInfo> TriggeredSagas { get; set; }\n}\n\n```csharp{\ntitle: \"Code Lens Provider\"\ndescription: \"Code lens provider for displaying event flow information in IDE\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"Design\", \"IDE-Integration\", \"Code-Lens-Provider\", \"Event-Flow-Visualization\"]\nframework: \"NET8\"\n}\n// Usage in IDE extension\npublic class WhizbangCodeLensProvider : CodeLensProvider {\n    public override async Task<CodeLens[]> ProvideCodeLensesAsync(Document document) {\n        var semanticModel = await document.GetSemanticModelAsync();\n        var root = await document.GetSyntaxRootAsync();\n        \n        var codeLenses = new List<CodeLens>();\n        \n        // Find command handlers\n        foreach (var handlerClass in root.DescendantNodes().OfType<ClassDeclarationSyntax>()) {\n            if (IsCommandHandler(handlerClass, semanticModel)) {\n                var commandType = GetCommandType(handlerClass, semanticModel);\n                var eventFlow = await _navigationService.GetEventFlowAsync(commandType);\n                \n                codeLenses.Add(new CodeLens {\n                    Range = GetRange(handlerClass),\n                    Command = new Command {\n                        Title = $\"Emits {eventFlow.EmittedEvents.Count} events, triggers {eventFlow.EventHandlers.Count} handlers\",\n                        Arguments = new object[] { eventFlow }\n                    }\n                });\n            }\n        }\n        \n        return codeLenses.ToArray();\n    }\n}\n```\n\n### Generated Metadata\n\n**Rich metadata** for IDE integration:\n\n```json\n// Generated metadata file: WhizbangMetadata.json\n{\n  \"eventStreams\": {\n    \"Order-{orderId}\": {\n      \"aggregateType\": \"Order\",\n      \"domain\": \"Orders\",\n      \"events\": [\"OrderPlaced\", \"OrderUpdated\", \"OrderShipped\"],\n      \"handlers\": [\"OrderSummaryProjection\", \"OrderHistoryProjection\"],\n      \"sagas\": [\"OrderFulfillmentSaga\"]\n    }\n  },\n  \"handlers\": {\n    \"PlaceOrderHandler\": {\n      \"handlerType\": \"Command\",\n      \"inputType\": \"PlaceOrder\",\n      \"outputTypes\": [\"OrderPlaced\"],\n      \"domain\": \"Orders\",\n      \"sourceLocation\": \"OrderService/Handlers/PlaceOrderHandler.cs:15\"\n    }\n  },\n  \"projections\": {\n    \"OrderSummaryProjection\": {\n      \"projectionName\": \"order-summary\",\n      \"subscribedEvents\": [\"OrderPlaced\", \"OrderUpdated\", \"OrderShipped\"],\n      \"domain\": \"Orders\",\n      \"sourceLocation\": \"OrderService/Projections/OrderSummaryProjection.cs:8\"\n    }\n  },\n  \"domains\": {\n    \"Orders\": {\n      \"commands\": [\"PlaceOrder\", \"UpdateOrder\", \"ShipOrder\"],\n      \"events\": [\"OrderPlaced\", \"OrderUpdated\", \"OrderShipped\"],\n      \"handlers\": [\"PlaceOrderHandler\", \"UpdateOrderHandler\"],\n      \"projections\": [\"OrderSummaryProjection\", \"OrderHistoryProjection\"]\n    }\n  }\n}\n```\n\n## Code Analyzers & Fixes\n\n### Domain Ownership Validation\n\n**Compile-time enforcement** of domain ownership rules:\n\n```csharp{\ntitle: \"Domain Ownership Analyzer\"\ndescription: \"Roslyn analyzer for compile-time domain ownership validation\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"Design\", \"Code-Analyzers\", \"Domain-Ownership\", \"Compile-Time-Validation\"]\nframework: \"NET8\"\n}\n[DiagnosticAnalyzer(LanguageNames.CSharp)]\npublic class DomainOwnershipAnalyzer : DiagnosticAnalyzer {\n    public static readonly DiagnosticDescriptor CrossDomainHandlerRule = new(\n        \"WB001\",\n        \"Handler cannot handle command/event from different domain\",\n        \"Handler '{0}' in domain '{1}' cannot handle '{2}' from domain '{3}'\",\n        \"Domain Ownership\",\n        DiagnosticSeverity.Error,\n        isEnabledByDefault: true\n    );\n    \n    public override void Initialize(AnalysisContext context) {\n        context.RegisterSyntaxNodeAction(AnalyzeHandlerClass, SyntaxKind.ClassDeclaration);\n    }\n    \n    private void AnalyzeHandlerClass(SyntaxNodeAnalysisContext context) {\n        var classDeclaration = (ClassDeclarationSyntax)context.Node;\n        var semanticModel = context.SemanticModel;\n        \n        var handlerDomain = GetHandlerDomain(classDeclaration, semanticModel);\n        var handledTypes = GetHandledTypes(classDeclaration, semanticModel);\n        \n        foreach (var handledType in handledTypes) {\n            var messageDomain = GetMessageDomain(handledType, semanticModel);\n            \n            if (handlerDomain != messageDomain) {\n                var diagnostic = Diagnostic.Create(\n                    CrossDomainHandlerRule,\n                    classDeclaration.GetLocation(),\n                    classDeclaration.Identifier.ValueText,\n                    handlerDomain,\n                    handledType.Name,\n                    messageDomain\n                );\n                \n                context.ReportDiagnostic(diagnostic);\n            }\n        }\n    }\n}\n```\n\n### Code Fixes\n\n**Automatic fixes** for common patterns:\n\n```csharp{\ntitle: \"Code Fix Provider\"\ndescription: \"Code fix provider for automatic domain ownership attribute addition\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"Design\", \"Code-Fixes\", \"Domain-Ownership\", \"Automatic-Fixes\"]\nframework: \"NET8\"\n}\n[ExportCodeFixProvider(LanguageNames.CSharp)]\npublic class AddDomainOwnershipCodeFixProvider : CodeFixProvider {\n    public override async Task RegisterCodeFixesAsync(CodeFixContext context) {\n        var diagnostic = context.Diagnostics.FirstOrDefault(d => d.Id == \"WB002\");\n        if (diagnostic == null) return;\n        \n        var document = context.Document;\n        var root = await document.GetSyntaxRootAsync(context.CancellationToken);\n        var declaration = root.FindNode(diagnostic.Location.SourceSpan);\n        \n        // Offer to add [OwnedBy] attribute\n        var codeAction = CodeAction.Create(\n            title: \"Add [OwnedBy] attribute\",\n            createChangedDocument: c => AddOwnedByAttribute(document, declaration, c),\n            equivalenceKey: \"AddOwnedBy\"\n        );\n        \n        context.RegisterCodeFix(codeAction, diagnostic);\n    }\n    \n    private async Task<Document> AddOwnedByAttribute(Document document, SyntaxNode declaration, CancellationToken cancellationToken) {\n        var root = await document.GetSyntaxRootAsync(cancellationToken);\n        var inferredDomain = InferDomainFromNamespace(declaration);\n        \n        var attribute = SyntaxFactory.Attribute(\n            SyntaxFactory.IdentifierName(\"OwnedBy\"),\n            SyntaxFactory.AttributeArgumentList(\n                SyntaxFactory.SingletonSeparatedList(\n                    SyntaxFactory.AttributeArgument(\n                        SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, \n                            SyntaxFactory.Literal(inferredDomain))\n                    )\n                )\n            )\n        );\n        \n        var newDeclaration = AddAttributeToDeclaration(declaration, attribute);\n        var newRoot = root.ReplaceNode(declaration, newDeclaration);\n        \n        return document.WithSyntaxRoot(newRoot);\n    }\n}\n```\n\n## Debugging Integration\n\n### Transparent Generated Code\n\n**Clear, debuggable generated code** with source maps:\n\n```csharp{\ntitle: \"Debuggable Generated Code\"\ndescription: \"Clear, debuggable generated code with source maps and metadata\"\ncategory: \"Design\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Design\", \"Source-Generation\", \"Transparent-Code\", \"Debug-Experience\"]\nframework: \"NET8\"\n}\n// Generated handler registry with clear structure\n[GeneratedCode(\"Whizbang.SourceGenerator\", \"1.0.0\")]\npublic static partial class OrderServiceHandlerRegistry {\n    // Source: OrderService/Handlers/PlaceOrderHandler.cs\n    public static void RegisterPlaceOrderHandler(IServiceCollection services) {\n        services.AddScoped<ICommandHandler<PlaceOrder>, PlaceOrderHandler>();\n        \n        // Generated metadata for debugging\n        services.AddSingleton(new HandlerMetadata {\n            HandlerType = typeof(PlaceOrderHandler),\n            MessageType = typeof(PlaceOrder),\n            SourceFile = \"OrderService/Handlers/PlaceOrderHandler.cs\",\n            SourceLine = 15,\n            Domain = \"Orders\",\n            GeneratedAt = DateTimeOffset.Parse(\"2024-01-01T10:00:00Z\")\n        });\n    }\n    \n    // Source: OrderService/Projections/OrderSummaryProjection.cs  \n    public static void RegisterOrderSummaryProjection(IServiceCollection services) {\n        services.AddScoped<IProjectionHandler<OrderPlaced>, OrderSummaryProjection>();\n        services.AddScoped<IProjectionHandler<OrderUpdated>, OrderSummaryProjection>();\n        services.AddScoped<IProjectionHandler<OrderShipped>, OrderSummaryProjection>();\n        \n        // Register projection metadata\n        services.AddSingleton(new ProjectionMetadata {\n            ProjectionType = typeof(OrderSummaryProjection),\n            ProjectionName = \"order-summary\",\n            SubscribedEvents = new[] { typeof(OrderPlaced), typeof(OrderUpdated), typeof(OrderShipped) },\n            SourceFile = \"OrderService/Projections/OrderSummaryProjection.cs\",\n            SourceLine = 8,\n            Domain = \"Orders\"\n        });\n    }\n}\n```\n\n### Debug Experience Enhancements\n\n**No \"magic\" - clear understanding** of what's happening:\n\n```csharp{\ntitle: \"Debug-Friendly Registration\"\ndescription: \"Debug-friendly service registration with detailed logging\"\ncategory: \"Design\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Design\", \"Source-Generation\", \"Debug-Experience\", \"Service-Registration\"]\nframework: \"NET8\"\n}\n// Debug-friendly service registration\npublic static class WhizbangServiceCollectionExtensions {\n    public static IServiceCollection AddWhizbangGeneratedServices(this IServiceCollection services) {\n        if (IsDebugMode()) {\n            // In debug mode, show detailed registration logging\n            services.AddSingleton<IHandlerRegistrationLogger, DetailedHandlerRegistrationLogger>();\n        }\n        \n        // Call generated registration methods\n        OrderServiceHandlerRegistry.RegisterAll(services);\n        \n        return services;\n    }\n}\n\npublic class DetailedHandlerRegistrationLogger : IHandlerRegistrationLogger {\n    public void LogHandlerRegistration<TMessage, THandler>(string sourceFile, int sourceLine) {\n        Console.WriteLine($\"Registering handler {typeof(THandler).Name} for {typeof(TMessage).Name}\");\n        Console.WriteLine($\"  Source: {sourceFile}:{sourceLine}\");\n        Console.WriteLine($\"  Service lifetime: Scoped\");\n    }\n}\n```\n\n## Performance Optimizations\n\n### Incremental Generation\n\n**Only regenerate what changed** for fast incremental builds:\n\n```csharp{\ntitle: \"Incremental Generation Context\"\ndescription: \"Incremental generation context for tracking file changes and optimization\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"Design\", \"Source-Generation\", \"Incremental-Generation\", \"Performance-Optimization\"]\nframework: \"NET8\"\n}\npublic class IncrementalGenerationContext {\n    private readonly ConcurrentDictionary<string, string> _fileHashes = new();\n    \n    public bool HasFileChanged(string filePath, string content) {\n        var currentHash = ComputeHash(content);\n        var previousHash = _fileHashes.GetValueOrDefault(filePath);\n        \n        if (currentHash != previousHash) {\n            _fileHashes[filePath] = currentHash;\n            return true;\n        }\n        \n        return false;\n    }\n    \n    public void TrackGeneratedOutput(string outputKey, string content) {\n        // Track what we generated so we can skip unchanged outputs\n        _generatedOutputs[outputKey] = ComputeHash(content);\n    }\n}\n```\n\n### Compilation Performance\n\n**Optimize for IDE experience**:\n\n- **Syntax-only analysis** for most validations\n- **Semantic analysis** only when necessary\n- **Caching** of expensive operations\n- **Parallel processing** of independent analysis\n- **Early termination** when errors are found\n\n## Best Practices\n\n### Generator Design\n\n1. **Keep generators focused** - Single responsibility per generator stage\n2. **Minimize semantic model usage** - Use syntax analysis when possible\n3. **Cache expensive operations** - Avoid redundant analysis\n4. **Provide clear diagnostics** - Help developers understand issues\n5. **Generate debuggable code** - Include source references and metadata\n\n### IDE Integration\n\n1. **Responsive navigation** - Fast lookups and searches\n2. **Contextual information** - Show relevant details for current location\n3. **Clear visualizations** - Easy to understand flow diagrams\n4. **Helpful code lenses** - Actionable information overlays\n5. **Intelligent suggestions** - Context-aware code completion\n\n### Debug Experience\n\n1. **No hidden magic** - Everything should be discoverable\n2. **Clear error messages** - Point to exact problems and solutions\n3. **Source mapping** - Connect generated code to source\n4. **Metadata preservation** - Keep debug information through compilation\n5. **Performance transparency** - Show timing and costs\n\n",
        "tags": "source-generation, ide-integration, analyzers, navigation, debugging",
        "version": "proposals"
      },
      {
        "slug": "proposals/testing-development-tools",
        "title": "Testing & Development Tools",
        "category": "Architecture & Design",
        "order": 13,
        "description": "\n# Testing & Development Tools\n\nWhizbang provides comprehensive testing utilities and development tools to ensure a productive developer experience from local development to production deployment.\n\n## Testing Framework\n\n### Whizbang.Testing Package\n\n**Comprehensive testing library** with fluent APIs for all Whizbang scenarios:\n\n```csharp{title=\"Installing Whizbang Testing Package\" description=\"Installing and setting up the Whizbang testing package\" category=\"Design\" difficulty=\"BEGINNER\" tags=[\"Design\", \"Testing\", \"Package-Installation\", \"Setup\"] framework=\"NET8\"}\n// Install the testing package\ndotnet add package Whizbang.Testing\n\n```csharp{title=\"Test Fixture Setup\" description=\"Test fixture setup with in-memory drivers for fast unit testing\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Testing\", \"Test-Fixtures\", \"In-Memory-Drivers\"] framework=\"NET8\"}\n// Test fixture setup\npublic class OrderServiceTests {\n    private readonly WhizbangTestFixture _fixture;\n    \n    public OrderServiceTests() {\n        _fixture = new WhizbangTestFixture()\n            .UseInMemoryEventStore()\n            .UseInMemoryProjections()\n            .UseInMemoryMessageBroker()\n            .ConfigureServices(services => {\n                services.AddScoped<IOrderService, OrderService>();\n                services.AddScoped<ICustomerService, MockCustomerService>();\n            });\n    }\n}\n```\n\n### Event Sourcing Test Helpers\n\n**Given/When/Then fluent API** for event sourcing scenarios:\n\n```csharp{title=\"Given/When/Then Event Sourcing Tests\" description=\"Given/When/Then fluent API for event sourcing test scenarios\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Testing\", \"Given-When-Then\", \"Event-Sourcing\"] framework=\"NET8\"}\n[Test]\npublic async Task PlaceOrder_WithValidCustomer_ShouldEmitOrderPlaced() {\n    // Arrange & Act & Assert in fluent chain\n    await _fixture\n        .Given(\n            new CustomerRegistered(customerId, \"John Doe\", \"john@example.com\"),\n            new ProductCreated(productId, \"Widget\", 10.00m)\n        )\n        .When(new PlaceOrder(orderId, customerId, new[] { \n            new OrderItem(productId, 2, 10.00m) \n        }))\n        .Then()\n        .ShouldEmitEvent<OrderPlaced>()\n        .WithProperty(e => e.OrderId, orderId)\n        .WithProperty(e => e.CustomerId, customerId)\n        .WithProperty(e => e.Total, 20.00m)\n        .And()\n        .ShouldNotEmitEvent<OrderRejected>();\n}\n\n```csharp{title=\"Error Scenario Testing\" description=\"Testing error scenarios with event validation assertions\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Testing\", \"Error-Scenarios\", \"Event-Validation\"] framework=\"NET8\"}\n[Test]\npublic async Task PlaceOrder_WithInvalidCustomer_ShouldEmitOrderRejected() {\n    await _fixture\n        .Given() // No customer registered\n        .When(new PlaceOrder(orderId, customerId, items))\n        .Then()\n        .ShouldEmitEvent<OrderRejected>()\n        .WithProperty(e => e.Reason, \"Customer not found\")\n        .And()\n        .ShouldNotEmitEvent<OrderPlaced>();\n}\n```\n\n### Projection Testing\n\n**Feed events and assert projection state**:\n\n```csharp{title=\"Projection Lifecycle Testing\" description=\"Projection testing with event feeding and state assertions\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Testing\", \"Projections\", \"Lifecycle-Testing\"] framework=\"NET8\"}\n[Test]\npublic async Task OrderSummaryProjection_ShouldTrackOrderLifecycle() {\n    await _fixture\n        .ForProjection<OrderSummaryProjection>()\n        .GivenEvents(\n            new OrderPlaced(orderId, customerId, 100.00m, DateTimeOffset.UtcNow),\n            new OrderShipped(orderId, \"TRACK123\", DateTimeOffset.UtcNow.AddDays(1))\n        )\n        .WhenProjectionRuns()\n        .ThenProjection<OrderSummary>(orderId.ToString())\n        .ShouldExist()\n        .ShouldHaveProperty(s => s.Status, OrderStatus.Shipped)\n        .ShouldHaveProperty(s => s.Total, 100.00m)\n        .ShouldHaveProperty(s => s.TrackingNumber, \"TRACK123\");\n}\n\n[Test]\npublic async Task OrderSummaryProjection_WithMissingEvents_ShouldHandleGracefully() {\n    await _fixture\n        .ForProjection<OrderSummaryProjection>()\n        .GivenEvents(\n            new OrderShipped(orderId, \"TRACK123\", DateTimeOffset.UtcNow) // No OrderPlaced\n        )\n        .WhenProjectionRuns()\n        .ThenProjection<OrderSummary>(orderId.ToString())\n        .ShouldNotExist(); // Projection should handle missing OrderPlaced gracefully\n}\n```\n\n### Policy Testing\n\n**Test policy rules and combinations**:\n\n```csharp{title=\"Policy Rule Testing\" description=\"Testing policy rules and their effects on system behavior\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Testing\", \"Policy-Testing\", \"Load-Testing\"] framework=\"NET8\"}\n[Test]\npublic async Task LoadTestingPolicy_ShouldSkipProjections() {\n    await _fixture\n        .ForPolicy(\"LoadTestingPolicy\")\n        .GivenContext(ctx => ctx.WithFlag(WhizbangFlags.LoadTesting))\n        .GivenMessage(new OrderPlaced(orderId, customerId, 100.00m))\n        .WhenPolicyEvaluates()\n        .ThenActions()\n        .ShouldContain<SkipProjectionsAction>()\n        .ShouldContain<AddTagAction>(action => action.Tag == \"load-test-processed\");\n}\n\n[Test]\npublic async Task VIPCustomerPolicy_ShouldRouteToSpecialHandler() {\n    await _fixture\n        .ForPolicy(\"VIPCustomerPolicy\")\n        .GivenContext(ctx => ctx.WithTag(\"customer-vip\"))\n        .GivenMessage(new PlaceOrder(orderId, customerId, items))\n        .WhenPolicyEvaluates()\n        .ThenActions()\n        .ShouldContain<RouteToHandlerAction<VIPOrderHandler>>();\n}\n```\n\n### Saga Testing\n\n**Test long-running process coordination**:\n\n```csharp{title=\"Saga Workflow Testing\" description=\"Testing long-running saga workflows with command coordination\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Testing\", \"Sagas\", \"Workflow-Coordination\"] framework=\"NET8\"}\n[Test]\npublic async Task OrderFulfillmentSaga_ShouldCoordinateFullWorkflow() {\n    await _fixture\n        .ForSaga<OrderFulfillmentSaga>()\n        .GivenEvents(\n            new OrderPlaced(orderId, customerId, items)\n        )\n        .WhenSagaRuns()\n        .ThenCommands()\n        .ShouldContain<ReserveInventory>(cmd => cmd.OrderId == orderId)\n        .And()\n        .WhenEvent(new InventoryReserved(orderId, items))\n        .ThenCommands()\n        .ShouldContain<ChargePayment>(cmd => cmd.OrderId == orderId)\n        .And()\n        .WhenEvent(new PaymentCharged(orderId, 100.00m))\n        .ThenCommands()\n        .ShouldContain<ShipOrder>(cmd => cmd.OrderId == orderId);\n}\n```\n\n### Integration Testing\n\n**Real drivers with test containers**:\n\n```csharp{title=\"Integration Testing with TestContainers\" description=\"Integration testing with real infrastructure using TestContainers\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Testing\", \"Integration-Testing\", \"TestContainers\"] framework=\"NET8\"}\n[Test]\npublic async Task OrderService_IntegrationTest_WithRealDatabase() {\n    // Uses TestContainers for real PostgreSQL\n    await using var fixture = new WhizbangIntegrationTestFixture()\n        .UseTestContainerPostgres()\n        .UseTestContainerKafka()\n        .ConfigureServices(services => {\n            services.AddOrderService();\n            services.AddInventoryService();\n        });\n    \n    await fixture.StartAsync();\n    \n    // Test with real infrastructure\n    var result = await fixture\n        .Given(/* setup data in real database */)\n        .When(new PlaceOrder(orderId, customerId, items))\n        .Then()\n        .ShouldEmitEvent<OrderPlaced>()\n        .And()\n        .ShouldHaveProjection<OrderSummary>(orderId.ToString())\n        .InDatabase(); // Verify in real database\n}\n```\n\n## Development Tools Suite\n\n### CLI Tool (whizbang-cli)\n\n**Comprehensive command-line interface** for project management:\n\n```bash\n",
        "tags": "testing, development-tools, cli, ide-extensions, dashboard",
        "version": "proposals"
      }
    ]
  },
  {
    "state": "backlog",
    "metadata": {
      "folderType": "state",
      "state": "backlog",
      "description": "Approved features awaiting scheduling and development"
    },
    "docs": []
  },
  {
    "state": "declined",
    "metadata": {
      "folderType": "state",
      "state": "declined",
      "description": "Declined proposals archived for reference"
    },
    "docs": []
  }
]