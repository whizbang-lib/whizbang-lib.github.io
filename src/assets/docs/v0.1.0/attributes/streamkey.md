---
title: "StreamKey Attribute"
description: "Marks a property as the stream key for event sourcing and perspective event ordering"
category: "Attributes"
tags: ["attributes", "streamkey", "perspectives", "event-sourcing", "source-generator"]
---

# StreamKey Attribute

The `[StreamKey]` attribute marks a property as the stream key for event sourcing. The stream key identifies which stream (aggregate) an event belongs to, enabling ordered event processing in perspectives.

## Namespace

```csharp
using Whizbang.Core;
```

## Syntax

```csharp
[StreamKey]
public Guid PropertyName { get; init; }
```

## Applies To

- **Event properties** (types implementing `IEvent`)
- **Model properties** (types used as `TModel` in `IPerspectiveFor<TModel, ...>`)

## Purpose

The `[StreamKey]` attribute serves two critical purposes:

1. **Event Ordering**: Groups events by stream for ordered processing in perspectives
2. **Compile-Time Extraction**: Source generator creates zero-reflection `ExtractStreamId()` methods

## Requirements

- **Exactly one property** per type must have `[StreamKey]`
- The property must have a `get` accessor (typically `public`)
- The property should uniquely identify the aggregate/stream

## Basic Example

```csharp
public record ProductCreatedEvent : IEvent {
  [StreamKey]  // Identifies which product this event belongs to
  public Guid ProductId { get; init; }
  public string Name { get; init; } = string.Empty;
  public decimal Price { get; init; }
}

public record ProductDto {
  [StreamKey]  // Identifies which product this model represents
  public Guid ProductId { get; init; }
  public string Name { get; init; } = string.Empty;
  public decimal Price { get; init; }
}

public class ProductCatalogPerspective : IPerspectiveFor<ProductDto, ProductCreatedEvent> {
  public ProductDto Apply(ProductDto currentData, ProductCreatedEvent @event) {
    return new ProductDto {
      ProductId = @event.ProductId,
      Name = @event.Name,
      Price = @event.Price
    };
  }
}
```

## How It Works

### 1. Compile-Time Stream ID Extraction

The source generator finds properties marked with `[StreamKey]` and generates extraction methods:

```csharp
// Generated by PerspectiveRunnerGenerator
public class ProductCatalogPerspectiveRunner : IPerspectiveRunner {
  private static string ExtractStreamId(ProductCreatedEvent @event) {
    return @event.ProductId.ToString();  // Uses [StreamKey] property
  }
}
```

### 2. Event Grouping and Ordering

At runtime, the `PerspectiveWorker` uses the stream ID to:
1. Group events by stream (e.g., all events for Product A vs Product B)
2. Process events in UUID7 timestamp order within each stream
3. Apply events using pure `Apply()` methods

### 3. Unit-of-Work Pattern

Events are batched per stream:

```csharp
// Pseudo-code showing how PerspectiveWorker uses StreamKey
var streamId = ExtractStreamId(@event);  // Uses [StreamKey] property
var currentModel = await LoadModel(streamId);  // Load existing state
var updatedModel = perspective.Apply(currentModel, @event);  // Pure function
await SaveModel(streamId, updatedModel);  // Atomic save with checkpoint
```

## Multiple Events Example

All events for the same aggregate should use the same `[StreamKey]` property:

```csharp
public record OrderCreatedEvent : IEvent {
  [StreamKey]
  public Guid OrderId { get; init; }
  public Guid CustomerId { get; init; }
  public DateTime CreatedAt { get; init; }
}

public record OrderShippedEvent : IEvent {
  [StreamKey]
  public Guid OrderId { get; init; }  // Same stream key as OrderCreatedEvent
  public string TrackingNumber { get; init; } = string.Empty;
  public DateTime ShippedAt { get; init; }
}

public record OrderCancelledEvent : IEvent {
  [StreamKey]
  public Guid OrderId { get; init; }  // Same stream key
  public string Reason { get; init; } = string.Empty;
  public DateTime CancelledAt { get; init; }
}
```

This ensures all events for Order #123 are processed in timestamp order.

## Model StreamKey

Models also need `[StreamKey]` to identify which stream they represent:

```csharp
public record OrderDto {
  [StreamKey]  // Matches OrderId from events
  public Guid OrderId { get; init; }
  public string Status { get; init; } = string.Empty;
  public string? TrackingNumber { get; init; }
  public DateTime? CancelledAt { get; init; }
}

public class OrderPerspective :
  IPerspectiveFor<OrderDto, OrderCreatedEvent, OrderShippedEvent, OrderCancelledEvent> {

  public OrderDto Apply(OrderDto currentData, OrderCreatedEvent @event) {
    return new OrderDto {
      OrderId = @event.OrderId,  // StreamKey property
      Status = "Created"
    };
  }

  public OrderDto Apply(OrderDto currentData, OrderShippedEvent @event) {
    return currentData with {
      Status = "Shipped",
      TrackingNumber = @event.TrackingNumber
    };
  }

  public OrderDto Apply(OrderDto currentData, OrderCancelledEvent @event) {
    return currentData with {
      Status = "Cancelled",
      CancelledAt = @event.CancelledAt
    };
  }
}
```

## Property Types

Common property types for `[StreamKey]`:

```csharp
// Guid (most common - UUID7 for time-ordering)
[StreamKey]
public Guid ProductId { get; init; }

// String (for natural keys)
[StreamKey]
public string AccountNumber { get; init; } = string.Empty;

// Custom value object
[StreamKey]
public CustomerId CustomerId { get; init; }
```

The property should implement `ToString()` for conversion to stream ID string.

## Diagnostics

The source generator validates `[StreamKey]` usage:

### WHIZ030: Missing StreamKey

**Error**: Event used in perspective has no `[StreamKey]` property

```csharp
// ❌ Causes WHIZ030
public record ProductEvent : IEvent {
  public Guid ProductId { get; init; }  // No [StreamKey]!
}

// ✅ Fixed
public record ProductEvent : IEvent {
  [StreamKey]
  public Guid ProductId { get; init; }
}
```

See [WHIZ030 Diagnostic](../diagnostics/whiz030.md) for details.

### WHIZ031: Multiple StreamKeys

**Error**: Event has multiple properties with `[StreamKey]`

```csharp
// ❌ Causes WHIZ031
public record OrderEvent : IEvent {
  [StreamKey]
  public Guid OrderId { get; init; }

  [StreamKey]  // Only one [StreamKey] allowed!
  public Guid CustomerId { get; init; }
}

// ✅ Fixed - Choose the primary aggregate
public record OrderEvent : IEvent {
  [StreamKey]  // Order is the primary aggregate
  public Guid OrderId { get; init; }

  public Guid CustomerId { get; init; }  // Related entity, not stream key
}
```

See [WHIZ031 Diagnostic](../diagnostics/whiz031.md) for details.

## Best Practices

### ✅ DO: Use on Aggregate ID

```csharp
public record ProductCreatedEvent : IEvent {
  [StreamKey]  // Primary aggregate identifier
  public Guid ProductId { get; init; }
  public Guid CategoryId { get; init; }  // Related entity
}
```

### ✅ DO: Match Event and Model StreamKeys

```csharp
// Event
public record ProductEvent : IEvent {
  [StreamKey]
  public Guid ProductId { get; init; }
}

// Model - Same property name
public record ProductDto {
  [StreamKey]
  public Guid ProductId { get; init; }
}
```

### ✅ DO: Use UUID7 for Time-Ordered IDs

```csharp
public record OrderCreatedEvent : IEvent {
  [AggregateId]  // Can combine attributes
  [StreamKey]
  public Guid OrderId { get; init; }  // UUID7 provides time-ordering
}
```

### ❌ DON'T: Use on Multiple Properties

```csharp
// ❌ WRONG - Multiple [StreamKey]
public record Event : IEvent {
  [StreamKey]
  public Guid Id1 { get; init; }

  [StreamKey]  // Causes WHIZ031
  public Guid Id2 { get; init; }
}
```

### ❌ DON'T: Use on Non-Aggregate Properties

```csharp
// ❌ WRONG - CreatedAt is not an aggregate identifier
public record ProductEvent : IEvent {
  public Guid ProductId { get; init; }

  [StreamKey]  // Wrong property!
  public DateTime CreatedAt { get; init; }
}
```

## Advanced: Composite Keys

If you truly need a composite key (rare in event sourcing), create a single computed property:

```csharp
public record OrderLineItemEvent : IEvent {
  [StreamKey]
  public string StreamKey => $"{OrderId}:{LineItemId}";  // Composite key

  public Guid OrderId { get; init; }
  public int LineItemId { get; init; }
}
```

However, this indicates you may need to rethink your aggregate boundaries. Most domain events belong to a single aggregate.

## Zero Reflection and AOT

The `[StreamKey]` attribute enables zero-reflection stream ID extraction:

**Without [StreamKey] (reflection)**:
```csharp
// ❌ Runtime reflection - not AOT-compatible
var streamId = @event.GetType()
    .GetProperty("ProductId")
    .GetValue(@event)
    .ToString();
```

**With [StreamKey] (generated)**:
```csharp
// ✅ Compile-time code generation - AOT-compatible
private static string ExtractStreamId(ProductCreatedEvent @event) {
  return @event.ProductId.ToString();
}
```

This generated code:
- Works with Native AOT
- Has zero runtime overhead
- Is type-safe at compile-time

## See Also

- [Perspectives](../core-concepts/perspectives.md) - Pure function perspectives using StreamKey
- [PerspectiveRunner Architecture](../core-concepts/perspectives.md#perspectiverunner-architecture) - How runners use StreamKey
- [WHIZ030 Diagnostic](../diagnostics/whiz030.md) - Missing StreamKey error
- [WHIZ031 Diagnostic](../diagnostics/whiz031.md) - Multiple StreamKey error
- [Event Sourcing](../core-concepts/event-sourcing.md) - Understanding aggregates and streams
