---
title: Aggregate IDs
version: 1.0.0
category: Source Generators
order: 4
description: >-
  Zero-reflection aggregate ID extraction for PolicyContext - compile-time
  discovery of [AggregateId] marked properties
tags: >-
  source-generators, aggregate-ids, policy-context, zero-reflection,
  compile-time, uuidv7
codeReferences:
  - src/Whizbang.Generators/AggregateIdGenerator.cs
  - src/Whizbang.Core/Policies/PolicyContext.cs
---

# Aggregate IDs

The **AggregateIdGenerator** discovers properties marked with `[AggregateId]` at compile-time and generates zero-reflection extractor methods. This enables `PolicyContext` to extract aggregate IDs from messages for distributed tracing, tenant isolation, and policy decisions without runtime reflection.

## Why Aggregate IDs?

**Aggregate IDs** are the primary identifiers for domain entities (Orders, Customers, Products). Whizbang uses them for:

| Use Case | Description | Example |
|----------|-------------|---------|
| **Distributed Tracing** | Group all events for an aggregate | All events for Order #123 |
| **Tenant Isolation** | Route messages to correct tenant database | Customer #456 → Tenant A database |
| **Policy Decisions** | Make routing decisions based on ID | High-value orders → Priority queue |
| **Stream Keys** | Organize events in Event Store | Stream: `Order-abc123` |
| **Partitioning** | Distribute work across instances | Order #789 → Instance 2 |

**Problem**: Extracting IDs at runtime requires **reflection** (slow, not AOT-compatible).

**Solution**: Generator discovers IDs at compile-time, generates **zero-reflection extractors**.

---

## How It Works

### 1. Mark Properties with [AggregateId]

```csharp
using Whizbang.Core;

// Command
public record CreateOrder(
    [property: AggregateId] Guid OrderId,  // ← Marked as aggregate ID
    Guid CustomerId,
    OrderItem[] Items
) : ICommand;

// Event
public record OrderCreated(
    [property: AggregateId] Guid OrderId,  // ← Marked as aggregate ID
    Guid CustomerId,
    decimal Total,
    DateTimeOffset CreatedAt
) : IEvent;
```

**Convention**: One `[AggregateId]` per message type (typically the primary entity ID).

---

### 2. Compile-Time Discovery

```
┌──────────────────────────────────────────────────┐
│  AggregateIdGenerator (Roslyn)                  │
│                                                  │
│  1. Scan syntax tree for records/classes        │
│  2. Check properties for [AggregateId] attribute│
│  3. Extract: Message type, Property name        │
│  4. Validate: Must be Guid or Guid?             │
└─────────────────┬────────────────────────────────┘
                  │
                  ▼
┌──────────────────────────────────────────────────┐
│  Generated: AggregateIdExtractors.g.cs           │
│                                                  │
│  - Static extractor methods (zero reflection)   │
│  - Type-safe property access                    │
│  - AOT-compatible                                │
└──────────────────────────────────────────────────┘
```

---

### 3. Generated Code

**AggregateIdExtractors.g.cs**:
```csharp
// <auto-generated/>
using System;

namespace MyApp.Generated;

public static class AggregateIdExtractors {
    /// <summary>
    /// Extracts aggregate ID from a message (zero reflection, AOT-compatible).
    /// Generated for 3 message types with [AggregateId] attributes.
    /// </summary>
    public static Guid? ExtractAggregateId(object message, Type messageType) {
        // CreateOrder
        if (messageType == typeof(global::MyApp.Commands.CreateOrder)) {
            return ((global::MyApp.Commands.CreateOrder)message).OrderId;
        }

        // OrderCreated
        if (messageType == typeof(global::MyApp.Events.OrderCreated)) {
            return ((global::MyApp.Events.OrderCreated)message).OrderId;
        }

        // ShipOrder
        if (messageType == typeof(global::MyApp.Commands.ShipOrder)) {
            return ((global::MyApp.Commands.ShipOrder)message).OrderId;
        }

        return null;  // No [AggregateId] found
    }
}
```

**Key Features**:
- **Zero Reflection**: Direct type checks and casts
- **Type Safe**: Compile-time property access
- **AOT Compatible**: No `MakeGenericType` or `GetProperty` calls
- **Fast**: < 10ns per extraction (vs ~1,000ns with reflection)

---

## Usage in PolicyContext

### PolicyContext Integration

```csharp
using Whizbang.Core.Policies;

public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> {
    private readonly IPolicyEngine _policies;

    public async ValueTask<OrderCreated> HandleAsync(
        CreateOrder message,
        CancellationToken ct = default) {

        // PolicyContext automatically extracts OrderId via generated extractor
        var context = new PolicyContext {
            Message = message,
            MessageType = typeof(CreateOrder),
            AggregateId = AggregateIdExtractors.ExtractAggregateId(message, typeof(CreateOrder)),  // ← Generated method
            UserId = GetCurrentUserId(),
            TenantId = GetCurrentTenantId()
        };

        // Policy decisions based on aggregate ID
        var decision = await _policies.EvaluateAsync("OrderRouting", context, ct);

        // Route based on aggregate ID
        if (decision.IsAllowed) {
            // Process order...
        }

        return new OrderCreated(/* ... */);
    }
}
```

**Automatic Extraction** (via MessageEnvelope):
```csharp
// MessageEnvelope automatically extracts aggregate ID
var envelope = MessageEnvelope.Create(
    messageId: MessageId.New(),
    correlationId: CorrelationId.New(),
    causationId: null,
    payload: message,
    currentHop: new MessageHop {
        // Aggregate ID extracted automatically via generator
        StreamKey: AggregateIdExtractors.ExtractAggregateId(message, message.GetType())?.ToString()
    }
);
```

---

## Patterns

### Pattern 1: Simple Aggregate ID

```csharp
public record CreateOrder(
    [property: AggregateId] Guid OrderId,  // ← Primary entity ID
    Guid CustomerId,
    OrderItem[] Items
) : ICommand;
```

**Generated**:
```csharp
if (messageType == typeof(CreateOrder)) {
    return ((CreateOrder)message).OrderId;
}
```

---

### Pattern 2: Nullable Aggregate ID

```csharp
public record GetOrders(
    [property: AggregateId] Guid? OrderId,  // ← Nullable (optional filter)
    Guid CustomerId
) : ICommand;
```

**Generated**:
```csharp
if (messageType == typeof(GetOrders)) {
    return ((GetOrders)message).OrderId;  // Returns Guid? (nullable)
}
```

**Use Case**: Query commands where aggregate ID is optional.

---

### Pattern 3: Inherited Aggregate ID

```csharp
// Base class
public abstract record OrderCommand {
    [AggregateId]
    public Guid OrderId { get; init; }
}

// Derived commands inherit [AggregateId]
public record ShipOrder(Guid OrderId, string TrackingNumber) : OrderCommand, ICommand;
public record CancelOrder(Guid OrderId, string Reason) : OrderCommand, ICommand;
```

**Generated** (one extractor per type):
```csharp
if (messageType == typeof(ShipOrder)) {
    return ((ShipOrder)message).OrderId;  // Inherited property
}

if (messageType == typeof(CancelOrder)) {
    return ((CancelOrder)message).OrderId;  // Inherited property
}
```

---

## Diagnostics

### WHIZ004: Aggregate ID Property Discovered

**Severity**: Info

**Message**: `Found [AggregateId] on property '{0}.{1}'`

**Example**:
```
info WHIZ004: Found [AggregateId] on property 'CreateOrder.OrderId'
info WHIZ004: Found [AggregateId] on property 'OrderCreated.OrderId'
```

---

### WHIZ005: Multiple [AggregateId] Attributes

**Severity**: Warning

**Message**: `Type '{0}' has multiple [AggregateId] attributes. Using first: '{1}'`

**Example**:
```
warning WHIZ005: Type 'CreateOrder' has multiple [AggregateId] attributes. Using first: 'OrderId'
```

**Cause**:
```csharp
public record CreateOrder(
    [property: AggregateId] Guid OrderId,  // ← First (used)
    [property: AggregateId] Guid CustomerId  // ← Second (ignored)
) : ICommand;
```

**Fix**: Only mark **one property** per message type.

---

### WHIZ006: Invalid Property Type

**Severity**: Error

**Message**: `Property '{0}.{1}' has [AggregateId] but is not Guid or Guid?`

**Example**:
```
error WHIZ006: Property 'CreateOrder.OrderId' has [AggregateId] but is not Guid or Guid?
```

**Cause**:
```csharp
public record CreateOrder(
    [property: AggregateId] string OrderId,  // ❌ String, not Guid
    Guid CustomerId
) : ICommand;
```

**Fix**: Use `Guid` or `Guid?`:
```csharp
public record CreateOrder(
    [property: AggregateId] Guid OrderId,  // ✅ Guid
    Guid CustomerId
) : ICommand;
```

---

## Performance

### Benchmark: Extraction Speed

| Method | Overhead | Notes |
|--------|----------|-------|
| **Generated Extractor** | ~8ns | Direct cast + property access |
| **Reflection** | ~1,000ns | `GetProperty()` + `GetValue()` |

**125x faster** than reflection!

```csharp
// ✅ Generated (fast)
var id = AggregateIdExtractors.ExtractAggregateId(message, typeof(CreateOrder));

// ❌ Reflection (slow)
var property = typeof(CreateOrder).GetProperty("OrderId");
var id = (Guid?)property?.GetValue(message);
```

### Zero Allocations

Generated code produces **zero allocations**:

```csharp
// Generated code (no boxing/unboxing, no reflection overhead)
if (messageType == typeof(CreateOrder)) {
    return ((CreateOrder)message).OrderId;  // Direct property access
}
```

**Benchmark**:
```
Memory Diagnostics:
  Gen 0: 0
  Gen 1: 0
  Gen 2: 0
  Allocated: 0 bytes
```

---

## Best Practices

### DO ✅

- ✅ **Mark primary entity ID** with `[AggregateId]`
- ✅ **Use Guid or Guid?** for ID properties
- ✅ **Use UUIDv7** for time-ordered IDs (`Guid.CreateVersion7()`)
- ✅ **One [AggregateId] per message** (typically the main entity)
- ✅ **Consistent naming** (OrderId, CustomerId, ProductId)
- ✅ **Apply to both commands and events** for traceability

### DON'T ❌

- ❌ Mark multiple properties (only first is used)
- ❌ Use non-Guid types (must be Guid or Guid?)
- ❌ Skip [AggregateId] on primary entities (breaks tracing)
- ❌ Use random GUIDs (use UUIDv7 for time-ordering)

---

## Troubleshooting

### Problem: Extractor Returns Null

**Symptoms**: `ExtractAggregateId()` returns `null` for message.

**Causes**:
1. Property not marked with `[AggregateId]`
2. Wrong message type passed

**Solution**:
```csharp
// ✅ Mark property
public record CreateOrder(
    [property: AggregateId] Guid OrderId,  // Add attribute
    Guid CustomerId
) : ICommand;

// ✅ Pass correct type
var id = AggregateIdExtractors.ExtractAggregateId(message, message.GetType());
```

### Problem: Property Ignored

**Symptoms**: Warning WHIZ005, second property not used.

**Cause**: Multiple `[AggregateId]` attributes on same type.

**Solution**: Remove duplicate:
```csharp
// ❌ Multiple attributes
public record CreateOrder(
    [property: AggregateId] Guid OrderId,
    [property: AggregateId] Guid CustomerId  // ← Remove this
) : ICommand;

// ✅ Single attribute
public record CreateOrder(
    [property: AggregateId] Guid OrderId,
    Guid CustomerId
) : ICommand;
```

---

## Integration with Event Store

### Stream Key Generation

Aggregate IDs are used to generate **Event Store stream keys**:

```csharp
// Event Store automatically uses aggregate ID for stream key
var streamKey = AggregateIdExtractors.ExtractAggregateId(@event, @event.GetType())?.ToString();

// Stream: "Order-abc123-def456-..."
// All events for Order #abc123 in same stream
```

**Benefits**:
- **Consistent Ordering**: Events for same aggregate always ordered
- **Rebuild Capability**: Replay events for specific aggregate
- **Query Efficiency**: Read all events for aggregate in one query

---

## Further Reading

**Source Generators**:
- [Receptor Discovery](receptor-discovery.md) - Compile-time receptor discovery
- [Perspective Discovery](perspective-discovery.md) - Compile-time perspective discovery
- [Message Registry](message-registry.md) - VSCode extension integration
- [JSON Contexts](json-contexts.md) - AOT-compatible JSON serialization

**Core Concepts**:
- [Message Context](../core-concepts/message-context.md) - MessageId, CorrelationId, CausationId
- [Observability](../core-concepts/observability.md) - Distributed tracing with hops

**Data Access**:
- [Event Store](../data/event-store.md) - Event sourcing and stream storage

**Infrastructure**:
- [Policies](../infrastructure/policies.md) - Policy-based routing and decisions

---

*Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12*
