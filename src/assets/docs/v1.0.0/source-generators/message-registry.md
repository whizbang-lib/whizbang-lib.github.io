---
title: Message Registry
version: 1.0.0
category: Source Generators
order: 3
description: >-
  VSCode extension integration via compile-time message registry - navigate from
  messages to handlers with IDE tooling
tags: >-
  source-generators, vscode, tooling, message-registry, code-navigation,
  ide-integration
codeReferences:
  - src/Whizbang.Generators/MessageRegistryGenerator.cs
  - tools/vscode-extension/src/staticAnalysis/messageRegistry.ts
---

# Message Registry

The **MessageRegistryGenerator** discovers all messages, dispatchers, receptors, and perspectives at compile-time and generates a JSON registry file for the **Whizbang VSCode Extension**. This enables rich IDE features like CodeLens annotations, hover tooltips, and "Go to Handler" navigation.

## VSCode Extension Integration

### IDE Features Enabled

| Feature | Description | Example |
|---------|-------------|---------|
| **CodeLens** | Inline annotations showing handler counts | `CreateOrder` → 3 dispatchers, 1 receptor |
| **Hover Tooltip** | Rich markdown with handler locations | Mouse over message → see all handlers |
| **Go to Handler** | Navigate from message to implementation | Click CodeLens → jump to receptor |
| **Find References** | List all dispatchers for a message | Right-click → Find dispatchers |

**Visual Example**:
```csharp
// In your code editor:
public record CreateOrder(Guid CustomerId, OrderItem[] Items) : ICommand;
             ↑↑↑↑↑↑↑↑↑↑↑
             [3 dispatchers] [1 receptor] [0 perspectives]  ← CodeLens

// Click [1 receptor] → Jump to OrderReceptor.HandleAsync()
```

---

## How It Works

### 1. Compile-Time Discovery

```
┌──────────────────────────────────────────────────┐
│  MessageRegistryGenerator (Roslyn)              │
│                                                  │
│  Discovers 4 types of constructs:               │
│                                                  │
│  1. Messages (ICommand, IEvent)                 │
│  2. Dispatchers (SendAsync, PublishAsync calls) │
│  3. Receptors (IReceptor implementations)       │
│  4. Perspectives (IPerspectiveOf implementations)│
└─────────────────┬────────────────────────────────┘
                  │
                  ▼
┌──────────────────────────────────────────────────┐
│  Generated: MessageRegistry.g.cs                 │
│                                                  │
│  Contains:                                       │
│  - Embedded JSON with message-to-handler mapping│
│  - File paths and line numbers for navigation   │
│  - Message type metadata (command vs event)     │
└─────────────────┬────────────────────────────────┘
                  │
                  ▼
┌──────────────────────────────────────────────────┐
│  Build Process: Copy to .whizbang/               │
│                                                  │
│  message-registry.json                           │
│  └─ Used by VSCode extension for tooling        │
└──────────────────────────────────────────────────┘
```

### 2. Generated File

**MessageRegistry.g.cs** (simplified):
```csharp
// <auto-generated/>
// This file is generated by MessageRegistryGenerator
// DO NOT EDIT - Changes will be overwritten

namespace MyApp.Generated;

internal static class MessageRegistry {
    public static string Json = @"{
  ""messages"": [
    {
      ""type"": ""MyApp.Commands.CreateOrder"",
      ""isCommand"": true,
      ""isEvent"": false,
      ""filePath"": ""src/Commands/CreateOrder.cs"",
      ""lineNumber"": 5,
      ""dispatchers"": [
        {
          ""className"": ""MyApp.Controllers.OrderController"",
          ""methodName"": ""CreateAsync"",
          ""filePath"": ""src/Controllers/OrderController.cs"",
          ""lineNumber"": 42
        },
        {
          ""className"": ""MyApp.Sagas.OrderSaga"",
          ""methodName"": ""ProcessAsync"",
          ""filePath"": ""src/Sagas/OrderSaga.cs"",
          ""lineNumber"": 18
        }
      ],
      ""receptors"": [
        {
          ""className"": ""MyApp.Receptors.OrderReceptor"",
          ""methodName"": ""HandleAsync"",
          ""filePath"": ""src/Receptors/OrderReceptor.cs"",
          ""lineNumber"": 12
        }
      ],
      ""perspectives"": []
    },
    {
      ""type"": ""MyApp.Events.OrderCreated"",
      ""isCommand"": false,
      ""isEvent"": true,
      ""filePath"": ""src/Events/OrderCreated.cs"",
      ""lineNumber"": 3,
      ""dispatchers"": [
        {
          ""className"": ""MyApp.Receptors.OrderReceptor"",
          ""methodName"": ""HandleAsync"",
          ""filePath"": ""src/Receptors/OrderReceptor.cs"",
          ""lineNumber"": 25
        }
      ],
      ""receptors"": [],
      ""perspectives"": [
        {
          ""className"": ""MyApp.Perspectives.OrderSummaryPerspective"",
          ""filePath"": ""src/Perspectives/OrderSummaryPerspective.cs"",
          ""lineNumber"": 8
        },
        {
          ""className"": ""MyApp.Perspectives.CustomerStatisticsPerspective"",
          ""filePath"": ""src/Perspectives/CustomerStatisticsPerspective.cs"",
          ""lineNumber"": 15
        }
      ]
    }
  ]
}";
}
```

**Key Information**:
- Message type (fully qualified name)
- Message kind (command vs event)
- Definition location (file path + line number)
- All dispatchers calling this message
- All receptors handling this message
- All perspectives listening to this event

---

## Discovery Patterns

### Pattern 1: Message Discovery

Discovers **ICommand** and **IEvent** implementations:

```csharp
// Command
public record CreateOrder(
    Guid CustomerId,
    OrderItem[] Items
) : ICommand;  // ← Discovered

// Event
public record OrderCreated(
    Guid OrderId,
    Guid CustomerId,
    decimal Total,
    DateTimeOffset CreatedAt
) : IEvent;  // ← Discovered
```

**Generator finds**:
- Type name: `MyApp.Commands.CreateOrder`
- File: `src/Commands/CreateOrder.cs`
- Line: 5
- IsCommand: `true`
- IsEvent: `false`

---

### Pattern 2: Dispatcher Discovery

Discovers **SendAsync** and **PublishAsync** call sites:

```csharp
public class OrderController : ControllerBase {
    private readonly IDispatcher _dispatcher;

    public async Task<IActionResult> CreateAsync(CreateOrderRequest request) {
        var command = new CreateOrder(request.CustomerId, request.Items);

        // ← Dispatcher call discovered
        var @event = await _dispatcher.SendAsync(command);

        return Ok(@event);
    }
}
```

**Generator finds**:
- Message type: `CreateOrder`
- Class: `OrderController`
- Method: `CreateAsync`
- File: `src/Controllers/OrderController.cs`
- Line: 42

**Also discovers PublishAsync**:
```csharp
// Inside OrderReceptor
var @event = new OrderCreated(/* ... */);
await _dispatcher.PublishAsync(@event);  // ← Discovered
```

---

### Pattern 3: Receptor Discovery

Discovers **IReceptor<TMessage, TResponse>** implementations:

```csharp
public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> {
    public async ValueTask<OrderCreated> HandleAsync(  // ← Method discovered
        CreateOrder message,
        CancellationToken ct = default) {

        // Business logic...
        return new OrderCreated(/* ... */);
    }
}
```

**Generator finds**:
- Message type: `CreateOrder`
- Class: `OrderReceptor`
- Method: `HandleAsync`
- File: `src/Receptors/OrderReceptor.cs`
- Line: 12 (HandleAsync method location)

---

### Pattern 4: Perspective Discovery

Discovers **IPerspectiveOf<TEvent>** implementations:

```csharp
public class OrderSummaryPerspective :
    IPerspectiveOf<OrderCreated>,  // ← Discovered
    IPerspectiveOf<OrderShipped>,  // ← Discovered
    IPerspectiveOf<OrderCancelled> {  // ← Discovered

    public async Task UpdateAsync(OrderCreated @event, CancellationToken ct) {
        // Update order_summaries table
    }

    public async Task UpdateAsync(OrderShipped @event, CancellationToken ct) {
        // Update order_summaries table
    }

    public async Task UpdateAsync(OrderCancelled @event, CancellationToken ct) {
        // Update order_summaries table
    }
}
```

**Generator finds**:
- Event types: `OrderCreated`, `OrderShipped`, `OrderCancelled`
- Class: `OrderSummaryPerspective`
- File: `src/Perspectives/OrderSummaryPerspective.cs`
- Line: 8 (class declaration)

**Result**: One perspective, three event type mappings.

---

## JSON Structure

### Complete Example

```json
{
  "messages": [
    {
      "type": "MyApp.Commands.CreateOrder",
      "isCommand": true,
      "isEvent": false,
      "filePath": "src/Commands/CreateOrder.cs",
      "lineNumber": 5,
      "dispatchers": [
        {
          "className": "MyApp.Controllers.OrderController",
          "methodName": "CreateAsync",
          "filePath": "src/Controllers/OrderController.cs",
          "lineNumber": 42
        }
      ],
      "receptors": [
        {
          "className": "MyApp.Receptors.OrderReceptor",
          "methodName": "HandleAsync",
          "filePath": "src/Receptors/OrderReceptor.cs",
          "lineNumber": 12
        }
      ],
      "perspectives": []
    },
    {
      "type": "MyApp.Events.OrderCreated",
      "isCommand": false,
      "isEvent": true,
      "filePath": "src/Events/OrderCreated.cs",
      "lineNumber": 3,
      "dispatchers": [
        {
          "className": "MyApp.Receptors.OrderReceptor",
          "methodName": "HandleAsync",
          "filePath": "src/Receptors/OrderReceptor.cs",
          "lineNumber": 25
        }
      ],
      "receptors": [],
      "perspectives": [
        {
          "className": "MyApp.Perspectives.OrderSummaryPerspective",
          "filePath": "src/Perspectives/OrderSummaryPerspective.cs",
          "lineNumber": 8
        }
      ]
    }
  ]
}
```

### Field Descriptions

| Field | Type | Description |
|-------|------|-------------|
| `type` | string | Fully qualified message type name |
| `isCommand` | boolean | True if implements ICommand |
| `isEvent` | boolean | True if implements IEvent |
| `filePath` | string | Relative path from workspace root |
| `lineNumber` | number | Line number (1-based) |
| `dispatchers` | array | All SendAsync/PublishAsync calls |
| `receptors` | array | All IReceptor implementations |
| `perspectives` | array | All IPerspectiveOf implementations |

---

## VSCode Extension Usage

### Installing the Extension

```bash
# From VSCode Extensions panel:
# Search: "Whizbang"
# Install: Whizbang Message Flow Visualizer

# Or from command line:
code --install-extension whizbang.whizbang-vscode
```

### Extension Features

#### 1. CodeLens Annotations

Inline annotations above message types:

```csharp
// [3 dispatchers] [1 receptor] [0 perspectives]
public record CreateOrder(Guid CustomerId, OrderItem[] Items) : ICommand;
```

**Click counts** to navigate:
- `[3 dispatchers]` → List of dispatcher locations
- `[1 receptor]` → Jump to receptor HandleAsync
- `[0 perspectives]` → No perspectives for this command

#### 2. Hover Tooltips

Rich markdown tooltips on hover:

```
CreateOrder

Type: Command
Handlers: 1 receptor

Dispatchers (3):
  • OrderController.CreateAsync (Controllers/OrderController.cs:42)
  • OrderSaga.ProcessAsync (Sagas/OrderSaga.cs:18)
  • OrderScheduler.ScheduleAsync (Schedulers/OrderScheduler.cs:105)

Receptors (1):
  • OrderReceptor.HandleAsync (Receptors/OrderReceptor.cs:12)
    Returns: OrderCreated
```

#### 3. Go to Handler Command

Right-click message → **"Go to Whizbang Handler"**:

```
Jump to:
  • OrderReceptor.HandleAsync (Receptors/OrderReceptor.cs:12)
```

#### 4. Message Flow Visualization

Command palette → **"Whizbang: Show Message Flow"**:

```
CreateOrder
  ├─ Dispatcher: OrderController.CreateAsync
  │   └─ Receptor: OrderReceptor.HandleAsync
  │       └─ Publishes: OrderCreated
  │           ├─ Perspective: OrderSummaryPerspective
  │           └─ Perspective: CustomerStatisticsPerspective
  └─ Dispatcher: OrderSaga.ProcessAsync
      └─ (Remote via Outbox)
```

---

## Build Integration

### MSBuild Target

Generator runs automatically during build. Optional: Copy JSON to `.whizbang/` folder for extension:

```xml
<!-- MyApp.csproj -->
<Target Name="CopyMessageRegistry" AfterTargets="Build">
  <ItemGroup>
    <MessageRegistryFiles Include="$(IntermediateOutputPath)generated/**/*MessageRegistry.g.cs" />
  </ItemGroup>

  <!-- Extract JSON from generated C# file and write to .whizbang/message-registry.json -->
  <Exec Command="dotnet run --project tools/extract-message-registry.csproj" />
</Target>
```

### Extract JSON Script

```csharp
// tools/extract-message-registry/Program.cs
using System.Text.RegularExpressions;

var generatedFile = args[0];  // Path to MessageRegistry.g.cs
var outputFile = ".whizbang/message-registry.json";

var content = File.ReadAllText(generatedFile);

// Extract JSON from embedded string
var match = Regex.Match(content, @"public static string Json = @""(.+?)"";", RegexOptions.Singleline);
if (match.Success) {
    var json = match.Groups[1].Value.Replace("\"\"", "\"");  // Unescape
    Directory.CreateDirectory(".whizbang");
    File.WriteAllText(outputFile, json);
    Console.WriteLine($"Wrote message registry to {outputFile}");
}
```

**Run after build**:
```bash
dotnet build
# Writes .whizbang/message-registry.json
```

---

## Generator Performance

### Multi-Pipeline Architecture

Generator uses **4 independent pipelines** for optimal caching:

```csharp
// Pipeline 1: Messages
var messageTypes = context.SyntaxProvider.CreateSyntaxProvider(
    predicate: static (node, _) => node is RecordDeclarationSyntax { BaseList.Types.Count: > 0 },
    transform: static (ctx, ct) => ExtractMessageType(ctx, ct)
);

// Pipeline 2: Dispatchers
var dispatchers = context.SyntaxProvider.CreateSyntaxProvider(
    predicate: static (node, _) => node is InvocationExpressionSyntax { ... },
    transform: static (ctx, ct) => ExtractDispatcher(ctx, ct)
);

// Pipeline 3: Receptors
var receptors = context.SyntaxProvider.CreateSyntaxProvider(
    predicate: static (node, _) => node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 },
    transform: static (ctx, ct) => ExtractReceptor(ctx, ct)
);

// Pipeline 4: Perspectives
var perspectives = context.SyntaxProvider.CreateSyntaxProvider(
    predicate: static (node, _) => node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 },
    transform: static (ctx, ct) => ExtractPerspective(ctx, ct)
);

// Combine at the end
var allData = messageTypes.Collect()
    .Combine(dispatchers.Collect())
    .Combine(receptors.Collect())
    .Combine(perspectives.Collect());
```

**Why 4 pipelines?**
- **Independent caching**: Changing a dispatcher doesn't invalidate message cache
- **Optimized predicates**: Each pipeline filters for its specific construct
- **Parallel execution**: Roslyn runs pipelines concurrently

### Performance Characteristics

```
First compilation (100 messages, 200 handlers):
├─ Message discovery: 30ms
├─ Dispatcher discovery: 40ms
├─ Receptor discovery: 20ms
├─ Perspective discovery: 15ms
├─ JSON generation: 5ms
└─ Total: 110ms

Incremental compilation (change 1 receptor):
├─ Message cache: 0ms (unchanged)
├─ Dispatcher cache: 0ms (unchanged)
├─ Receptor discovery: 20ms (changed)
├─ Perspective cache: 0ms (unchanged)
├─ JSON generation: 5ms
└─ Total: 25ms (85ms saved!)
```

---

## Cross-Assembly Messages

Generator handles messages **from referenced assemblies**:

```csharp
// In Whizbang.Core (referenced assembly)
public interface ICommand { }

// In MyApp (your project)
public record CreateOrder(Guid CustomerId) : ICommand;  // ← Discovered

// Also in MyApp
public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> {
    // ← Receptor discovered, links to CreateOrder
}
```

**Result**: CreateOrder appears in registry even though `ICommand` is external.

**External Messages**:
```csharp
// In SharedMessages (referenced assembly)
public record CustomerCreated(Guid CustomerId) : IEvent;

// In MyApp
public class CustomerStatsPerspective : IPerspectiveOf<CustomerCreated> {
    // ← Perspective discovered, links to CustomerCreated
}
```

**JSON output**:
```json
{
  "type": "SharedMessages.CustomerCreated",
  "isCommand": false,
  "isEvent": true,
  "filePath": "",  // Empty - not defined in this project
  "lineNumber": 0,
  "dispatchers": [],
  "receptors": [],
  "perspectives": [
    {
      "className": "MyApp.Perspectives.CustomerStatsPerspective",
      "filePath": "src/Perspectives/CustomerStatsPerspective.cs",
      "lineNumber": 8
    }
  ]
}
```

**Benefit**: Complete message flow visualization across assemblies.

---

## Debugging

### View Generated File

```
obj/Debug/net10.0/generated/Whizbang.Generators/MessageRegistryGenerator/
└── MessageRegistry.g.cs
```

Or configured output:
```xml
<PropertyGroup>
  <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
  <CompilerGeneratedFilesOutputPath>.whizbang-generated</CompilerGeneratedFilesOutputPath>
</PropertyGroup>
```

### Validate JSON

```bash
# Extract JSON from generated file
dotnet run --project tools/extract-message-registry.csproj

# Validate JSON
cat .whizbang/message-registry.json | jq .

# Output:
{
  "messages": [
    {
      "type": "MyApp.Commands.CreateOrder",
      "isCommand": true,
      ...
    }
  ]
}
```

### VSCode Extension Logs

View extension logs:
1. **View** → **Output**
2. Select **"Whizbang"** from dropdown
3. See message registry loading and parsing

```
[Whizbang] Loading message registry from .whizbang/message-registry.json
[Whizbang] Found 15 messages
[Whizbang] Registered 42 CodeLens providers
[Whizbang] Registry loaded successfully
```

---

## Best Practices

### DO ✅

- ✅ **Use ICommand and IEvent** markers for all messages
- ✅ **Keep messages in dedicated folders** (Commands/, Events/)
- ✅ **Use descriptive names** (CreateOrder, not Order1)
- ✅ **Commit .whizbang/message-registry.json** to source control (helps team)
- ✅ **Rebuild after adding new messages** (F5 in VSCode to reload extension)

### DON'T ❌

- ❌ Modify MessageRegistry.g.cs manually (regenerated on build)
- ❌ Use abstract message types (can't be instantiated)
- ❌ Mix commands and events (implement one interface only)
- ❌ Delete .whizbang/ folder (VSCode extension needs it)

---

## Troubleshooting

### Problem: CodeLens Not Showing

**Symptoms**: No `[X dispatchers]` annotations above messages.

**Causes**:
1. Extension not installed
2. Message registry not generated
3. Extension not loaded

**Solution**:
```bash
# 1. Verify extension installed
code --list-extensions | grep whizbang

# 2. Rebuild project (generates registry)
dotnet build

# 3. Check .whizbang/message-registry.json exists
ls -la .whizbang/

# 4. Reload VSCode window
Ctrl+Shift+P → "Developer: Reload Window"
```

### Problem: Wrong Handler Count

**Symptoms**: CodeLens shows `[1 receptor]` but you have 2 receptors.

**Causes**:
1. Stale message-registry.json
2. Receptor not discovered (missing IReceptor interface)

**Solution**:
```bash
# Clean and rebuild
dotnet clean && dotnet build

# Check generated file
cat .whizbang/message-registry.json | jq '.messages[] | select(.type == "MyApp.Commands.CreateOrder")'

# Verify receptor implements interface correctly
public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> {
    // Must have HandleAsync method
}
```

### Problem: External Messages Not Found

**Symptoms**: Messages from referenced assemblies don't appear in registry.

**Causes**:
1. Message not used in any dispatcher/receptor/perspective
2. Assembly reference missing

**Solution**: Generator only includes messages that are actually **used** in the project. If you want external messages in registry, add at least one handler:

```csharp
// Add a perspective for external event
public class ExternalEventPerspective : IPerspectiveOf<SharedMessages.CustomerCreated> {
    public async Task UpdateAsync(CustomerCreated @event, CancellationToken ct) {
        // Now CustomerCreated appears in registry!
    }
}
```

---

## Further Reading

**Source Generators**:
- [Receptor Discovery](receptor-discovery.md) - Compile-time receptor discovery
- [Perspective Discovery](perspective-discovery.md) - Compile-time perspective discovery
- [Aggregate IDs](aggregate-ids.md) - UUIDv7 generation for identity value objects
- [JSON Contexts](json-contexts.md) - AOT-compatible JSON serialization

**Core Concepts**:
- [Dispatcher](../core-concepts/dispatcher.md) - Message routing patterns
- [Receptors](../core-concepts/receptors.md) - Message handlers
- [Perspectives](../core-concepts/perspectives.md) - Event-driven read models

**Tools**:
- [VSCode Extension](../tools/vscode-extension.md) - IDE integration features

---

*Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12*
