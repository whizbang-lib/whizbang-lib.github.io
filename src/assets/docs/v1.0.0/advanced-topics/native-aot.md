---
title: Native AOT
version: 1.0.0
category: Advanced Topics
order: 3
description: >-
  Deploy with Native AOT - zero reflection, trim-safe code, and AOT-compatible
  patterns
tags: 'native-aot, aot, reflection, trim-safe, deployment'
---

# Native AOT

Deploy Whizbang applications with **Native AOT (Ahead-of-Time compilation)** for faster startup, smaller memory footprint, and self-contained executables.

---

## Why Native AOT?

| Metric | JIT (.NET Runtime) | Native AOT |
|--------|-------------------|------------|
| **Startup Time** | 1-2 seconds | < 100ms |
| **Memory Footprint** | 100-200 MB | 20-40 MB |
| **Deployment Size** | 80 MB + runtime | 10-15 MB (self-contained) |
| **Reflection** | ✅ Fully supported | ❌ Limited |
| **Trim-Safe** | Optional | ✅ Required |

---

## Enabling Native AOT

**Project file (.csproj)**:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <PublishAot>true</PublishAot>
    <InvariantGlobalization>true</InvariantGlobalization>
    <IlcOptimizationPreference>Speed</IlcOptimizationPreference>
    <IlcGenerateStackTraceData>false</IlcGenerateStackTraceData>
  </PropertyGroup>
</Project>
```

**Publish**:

```bash
dotnet publish -c Release -r linux-x64
```

**Output**:

```
ECommerce.OrderService.API (self-contained executable)
Size: 12.3 MB
Startup: 87ms
Memory: 24 MB
```

---

## Whizbang is AOT-Ready

Whizbang uses **source generators** instead of reflection, making it AOT-compatible by default:

```csharp
// ❌ BAD - Reflection (not AOT-compatible)
public class ReflectionDispatcher : IDispatcher {
  public async Task<TResponse> DispatchAsync<TRequest, TResponse>(
    TRequest request,
    CancellationToken ct
  ) {
    var receptorType = typeof(IReceptor<,>).MakeGenericType(typeof(TRequest), typeof(TResponse));
    var receptor = (IReceptor<TRequest, TResponse>)_services.GetService(receptorType);
    return await receptor.HandleAsync(request, ct);
  }
}

// ✅ GOOD - Source-generated (AOT-compatible)
public partial class GeneratedDispatcher : IDispatcher {
  public async Task<TResponse> DispatchAsync<TRequest, TResponse>(
    TRequest request,
    CancellationToken ct
  ) {
    return request switch {
      CreateOrder cmd => (TResponse)(object)await DispatchCreateOrderAsync(cmd, ct),
      UpdateOrder cmd => (TResponse)(object)await DispatchUpdateOrderAsync(cmd, ct),
      _ => throw new InvalidOperationException($"No handler for {typeof(TRequest).Name}")
    };
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  private async Task<OrderCreated> DispatchCreateOrderAsync(
    CreateOrder command,
    CancellationToken ct
  ) {
    var receptor = _services.GetRequiredService<IReceptor<CreateOrder, OrderCreated>>();
    return await receptor.HandleAsync(command, ct);
  }
}
```

**Key differences**:
- ✅ **No reflection** - Direct method calls
- ✅ **No `MakeGenericType`** - All types known at compile-time
- ✅ **Inlineable** - JIT/AOT can inline small methods
- ✅ **Trim-safe** - No dynamic type loading

---

## JSON Serialization (AOT-Compatible)

Use `System.Text.Json` source generators for AOT-compatible JSON:

**JsonContextRegistry.cs**:

```csharp
using System.Text.Json.Serialization;

[JsonSerializable(typeof(CreateOrder))]
[JsonSerializable(typeof(OrderCreated))]
[JsonSerializable(typeof(PaymentProcessed))]
[JsonSerializable(typeof(ShipmentCreated))]
public partial class MessageJsonContext : JsonSerializerContext {
}

public static class JsonContextRegistry {
  public static JsonSerializerOptions CreateOptions() {
    return new JsonSerializerOptions {
      TypeInfoResolver = JsonTypeInfoResolver.Combine(
        MessageJsonContext.Default
      )
    };
  }
}
```

**Usage**:

```csharp
// ✅ GOOD - AOT-compatible
var options = JsonContextRegistry.CreateOptions();
var json = JsonSerializer.Serialize(order, options);
var deserialized = JsonSerializer.Deserialize<OrderCreated>(json, options);

// ❌ BAD - NOT AOT-compatible
var json = JsonSerializer.Serialize(order);  // Uses reflection
var deserialized = JsonSerializer.Deserialize<OrderCreated>(json);
```

**Whizbang MessageJsonContextGenerator**:

Whizbang automatically generates `JsonSerializerContext` for all messages:

```csharp
// Generated by Whizbang.Generators.MessageJsonContextGenerator
[JsonSerializable(typeof(CreateOrder))]
[JsonSerializable(typeof(OrderCreated))]
// ... all discovered messages
public partial class WhizbangJsonContext : JsonSerializerContext {
}
```

---

## Trim Warnings

Enable trim analysis to detect non-AOT-safe code:

**Project file**:

```xml
<PropertyGroup>
  <PublishAot>true</PublishAot>
  <EnableTrimAnalyzer>true</EnableTrimAnalyzer>
  <SuppressTrimAnalysisWarnings>false</SuppressTrimAnalysisWarnings>
</PropertyGroup>
```

**Common warnings**:

```
IL2026: Using member 'System.Type.GetType(string)' which has 'RequiresUnreferencedCodeAttribute' can break functionality when trimming application code.
```

**Fix**:

```csharp
// ❌ BAD
var type = Type.GetType("MyNamespace.MyClass");

// ✅ GOOD
var type = typeof(MyClass);  // Compile-time reference
```

---

## Dependency Injection (AOT-Compatible)

Use constructor injection with explicit registrations:

**Program.cs**:

```csharp
// ✅ GOOD - Explicit registration (AOT-compatible)
builder.Services.AddSingleton<IReceptor<CreateOrder, OrderCreated>, CreateOrderReceptor>();
builder.Services.AddSingleton<IReceptor<UpdateOrder, OrderUpdated>, UpdateOrderReceptor>();

// ❌ BAD - Assembly scanning (NOT AOT-compatible)
builder.Services.Scan(scan => scan
  .FromAssemblyOf<CreateOrderReceptor>()
  .AddClasses(classes => classes.AssignableTo(typeof(IReceptor<,>)))
  .AsImplementedInterfaces()
  .WithSingletonLifetime()
);
```

**Whizbang ReceptorDiscoveryGenerator**:

Whizbang automatically generates DI registrations:

```csharp
// Generated by Whizbang.Generators.ReceptorDiscoveryGenerator
public static class ReceptorServiceCollectionExtensions {
  public static IServiceCollection AddGeneratedReceptors(this IServiceCollection services) {
    services.AddSingleton<IReceptor<CreateOrder, OrderCreated>, CreateOrderReceptor>();
    services.AddSingleton<IReceptor<UpdateOrder, OrderUpdated>, UpdateOrderReceptor>();
    // ... all discovered receptors
    return services;
  }
}
```

---

## Entity Framework Core (AOT-Compatible)

EF Core 10 added AOT support with compiled models:

**Generate compiled model**:

```bash
dotnet ef dbcontext optimize -c OrderDbContext -o CompiledModels
```

**Generated code**:

```csharp
// CompiledModels/OrderDbContextModel.cs
public partial class OrderDbContextModel : RuntimeModel {
  static OrderDbContextModel() {
    var model = new OrderDbContextModel();
    model.Initialize();
    _instance = model;
  }

  private static OrderDbContextModel _instance;
  public static IModel Instance => _instance;
}
```

**Usage**:

```csharp
public class OrderDbContext : DbContext {
  protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) {
    optionsBuilder
      .UseNpgsql("Host=localhost;Database=orders;...")
      .UseModel(OrderDbContextModel.Instance);  // Use compiled model
  }
}
```

---

## Dapper (AOT-Compatible)

Dapper works with AOT, but avoid dynamic SQL:

**✅ GOOD**:

```csharp
var orders = await connection.QueryAsync<OrderRow>(
  """
  SELECT order_id, customer_id, total_amount
  FROM orders
  WHERE customer_id = @CustomerId
  """,
  new { CustomerId = "cust-123" }
);
```

**❌ BAD**:

```csharp
var orders = await connection.QueryAsync(  // Dynamic type
  "SELECT * FROM orders WHERE customer_id = @CustomerId",
  new { CustomerId = "cust-123" }
);
```

---

## Azure Service Bus (AOT-Compatible)

Azure Service Bus SDK is AOT-compatible in .NET 10:

**Program.cs**:

```csharp
builder.Services.AddSingleton<ServiceBusClient>(sp => {
  var connectionString = builder.Configuration["AzureServiceBus:ConnectionString"];
  return new ServiceBusClient(connectionString);
});

builder.Services.AddSingleton<ServiceBusSender>(sp => {
  var client = sp.GetRequiredService<ServiceBusClient>();
  return client.CreateSender("orders");
});
```

---

## Testing AOT Compatibility

### 1. Compile with AOT

```bash
dotnet publish -c Release -r linux-x64
```

If compilation succeeds, your code is AOT-compatible.

### 2. Run Trim Analysis

```bash
dotnet publish -c Release -r linux-x64 -p:EnableTrimAnalyzer=true
```

Review warnings in build output.

### 3. Validate at Runtime

```bash
./bin/Release/net10.0/linux-x64/publish/ECommerce.OrderService.API
```

If it starts and handles requests, AOT is working correctly.

---

## Performance Comparison

**Benchmark: Order Creation (1000 requests)**

| Runtime | Startup | Total Time | Memory |
|---------|---------|------------|--------|
| **JIT** | 1.2s | 3.5s | 142 MB |
| **AOT** | 0.09s | 2.4s | 28 MB |

**AOT wins**:
- ✅ **13x faster startup**
- ✅ **1.5x faster overall** (less GC pressure)
- ✅ **5x smaller memory**

---

## Troubleshooting AOT Issues

### Issue 1: Reflection Warnings

**Error**:

```
IL2026: Using member 'Type.GetType(string)' which has 'RequiresUnreferencedCodeAttribute'
```

**Fix**: Replace reflection with compile-time types:

```csharp
// ❌ BAD
var type = Type.GetType(typeName);

// ✅ GOOD
var type = typeName switch {
  "CreateOrder" => typeof(CreateOrder),
  "UpdateOrder" => typeof(UpdateOrder),
  _ => throw new InvalidOperationException($"Unknown type: {typeName}")
};
```

### Issue 2: JSON Deserialization Fails

**Error**:

```
System.InvalidOperationException: Serialization and deserialization of 'CreateOrder' is not supported.
```

**Fix**: Add `[JsonSerializable(typeof(CreateOrder))]` to `JsonSerializerContext`.

### Issue 3: Missing Dependencies

**Error**:

```
Unhandled exception. System.DllNotFoundException: Unable to load shared library 'libssl.so.3'
```

**Fix**: Include native dependencies in publish:

```xml
<ItemGroup>
  <RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" />
  <TrimmerRootAssembly Include="System.Private.CoreLib" />
</ItemGroup>
```

---

## Key Takeaways

✅ **Whizbang is AOT-Ready** - Zero reflection, source-generated code
✅ **13x Faster Startup** - < 100ms vs. 1-2 seconds
✅ **5x Smaller Memory** - 28 MB vs. 142 MB
✅ **JSON Source Generators** - MessageJsonContextGenerator
✅ **Trim Analysis** - Detect non-AOT-safe code at build time
✅ **EF Core Compiled Models** - `dotnet ef dbcontext optimize`

---

## When to Use Native AOT

| Scenario | Use AOT? |
|----------|----------|
| **Serverless (Azure Functions, AWS Lambda)** | ✅ Yes (fast cold starts) |
| **Containers (Kubernetes)** | ✅ Yes (smaller images) |
| **Edge Computing** | ✅ Yes (resource-constrained) |
| **Long-Running Services** | ⚠️ Maybe (JIT eventually optimizes better) |
| **Developer Workstations** | ❌ No (longer build times) |

---

*Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12*
