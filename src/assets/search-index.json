[
  {
    "type": "document",
    "slug": "advanced/advanced-scenarios",
    "title": "Advanced Scenarios",
    "category": "Advanced",
    "url": "/docs/advanced/advanced-scenarios",
    "chunks": [
      {
        "id": "advanced/advanced-scenarios-chunk-0",
        "text": "Advanced Scenarios\nThis document covers advanced scenarios for production deployments, including data seeding, Backend-for-Frontend (BFF) patterns, and central control commands Data Seeding in Scaled Environments\nWhen deploying to scaled-out environments (Kubernetes, multiple replicas), data seeding must be coordinated to avoid duplicates or race conditions Coordinated Seeding\n`csharp{\ntitle: \"Coordinated Data Seeding\"\ndescription: \"Seed data in scaled environments without duplicates\"\nframework: \"NET8\"\ncategory: \"Deployment\"\ndifficulty: \"ADVANCED\"\ntags: [\"Seeding\", \"Deployment\", \"Kubernetes\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\"]\nusingStatements: [\"Microsoft Extensions Hosting\", \"Whizbang\", \"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Microsoft Extensions Hosting;\nusing Whizbang;\npublic class DataSeeder : IHostedService {\n    private readonly IWhizbang _whizbang;\n    private readonly IDistributedLock _distributedLock;\n    public DataSeeder(IWhizbang whizbang, IDistributedLock distributedLock) {\n        _whizbang = whizbang;\n        _distributedLock = distributedLock;\n    }\n    public async Task StartAsync(CancellationToken cancellationToken) {\n        // Only ONE replica seeds data (distributed lock)\n        await using var @lock = await _distributedLock AcquireAsync(\"data-seeding\", TimeSpan FromMinutes(5));\n        if (@lock = null) {\n            await SeedDataAsync();\n        }\n    }\n    private async Task SeedDataAsync() {\n        // Check if already seeded\n        var alreadySeeded = await CheckIfSeededAsync();\n        if (alreadySeeded) {\n            return;\n        }\n        // Seed master data\n        await SeedProductCatalogAsync();\n        await SeedDefaultTenantsAsync();\n        await SeedReferenceDataAsync();\n        // Mark as seeded\n        await MarkAsSeededAsync();\n    }\n    public Task StopAsync(CancellationToken cancellationToken) => Task CompletedTask;\n}\n`\nIdempotent Seeding\nMake seeding operations idempotent:\n`csharp{\ntitle: \"Idempotent Seeding\"\ndescription: \"Seed data that can be run multiple times safely\"\nframework: \"NET8\"\ncategory: \"Deployment\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Seeding\", \"Idempotence\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\npublic class ProductCatalogSeeder {\n    private readonly IRepository<ProductCatalog> _repository;\n    public ProductCatalogSeeder(IRepository<ProductCatalog> repository) {\n        _repository = repository;\n    }\n    public async Task SeedAsync() {\n        // Idempotent: only create if doesn't exist\n        var catalog = await _repository FindAsync(WellKnownIds DefaultCatalog);\n        if (catalog == null) {\n            catalog = new ProductCatalog(WellKnownIds",
        "startIndex": 0,
        "preview": "Advanced Scenarios\nThis document covers advanced scenarios for production deployments, including data seeding, Backend-for-Frontend (BFF) patterns, an..."
      },
      {
        "id": "advanced/advanced-scenarios-chunk-1",
        "text": "using System Threading Tasks; using Whizbang; public class ProductCatalogSeeder { private readonly IRepository<ProductCatalog> _repository; public ProductCatalogSeeder(IRepository<ProductCatalog> repository) { _repository = repository; } public async Task SeedAsync() { // Idempotent: only create if doesn't exist var catalog = await _repository FindAsync(WellKnownIds DefaultCatalog); if (catalog == null) { catalog = new ProductCatalog(WellKnownIds DefaultCatalog, \"Default Catalog\");\n            catalog AddProduct(new Product(\"Widget\", 19 99m));\n            catalog AddProduct(new Product(\"Gadget\", 29 99m));\n            catalog AddProduct(new Product(\"Doohickey\", 39 99m));\n            await _repository SaveAsync(catalog);\n        }\n    }\n}\n`\nEnvironment-Specific Seeding\nDifferent data for dev/staging/production:\n`csharp{\ntitle: \"Environment-Specific Seeding\"\ndescription: \"Seed different data per environment\"\nframework: \"NET8\"\ncategory: \"Deployment\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Seeding\", \"Environments\"]\nnugetPackages: [\"Whizbang Core\", \"Microsoft Extensions Hosting\"]\nusingStatements: [\"Microsoft Extensions Hosting\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System Threading Tasks;\nusing Microsoft Extensions Hosting;\npublic class EnvironmentSeeder : IHostedService {\n    private readonly IHostEnvironment _env;\n    private readonly IDataSeeder _seeder;\n    public EnvironmentSeeder(IHostEnvironment env, IDataSeeder seeder) {\n        _env = env;\n        _seeder = seeder;\n    }\n    public async Task StartAsync(CancellationToken cancellationToken) {\n        if (_env IsDevelopment()) {\n            // Seed lots of test data for local development\n            await _seeder SeedDevelopmentDataAsync();\n            await _seeder SeedTestTenantsAsync(count: 10);\n            await _seeder SeedSampleOrdersAsync(count: 1000);\n        }\n        else if (_env IsStaging()) {\n            // Seed realistic production-like data\n            await _seeder SeedProductionLikeDataAsync();\n            await _seeder SeedTestTenantsAsync(count: 2);  // Fewer test tenants\n        }\n        else if (_env IsProduction()) {\n            // Only seed essential master data\n            await _seeder SeedMasterDataAsync();\n            // Do NOT seed test data in production\n        }\n    }\n    public Task StopAsync(CancellationToken cancellationToken) => Task CompletedTask;\n}\n`\nKubernetes Init Container Seeding\nUse Kubernetes init containers for pre-startup seeding:\n`yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: orders-service\nspec:\n  replicas: 3\n  template:\n    spec:\n      Init container runs BEFORE main container\n      initContainers:\nname: seed-data\n        image: myapp/orders-service:latest\n        command: [\"dotnet\", \"OrdersService dll\", \"--seed-only\"]\n        env:\nname: ASPNETCORE_ENVIRONMENT\n          value: \"Production\"\n      Main application container\n      containers:\nname: orders-service\n        image: myapp/orders-service:latest\n`\nApplication code:\n`csharp\n// In Program cs\nif (args",
        "startIndex": 2926,
        "preview": "using System Threading Tasks; using Whizbang; public class ProductCatalogSeeder { private readonly IRepository<ProductCatalog> _repository; public Pro..."
      },
      {
        "id": "advanced/advanced-scenarios-chunk-2",
        "text": "apps/v1 kind: Deployment metadata: name: orders-service spec: replicas: 3 template: spec: Init container runs BEFORE main container initContainers: name: seed-data image: myapp/orders-service:latest command: [\"dotnet\", \"OrdersService dll\", \"--seed-only\"] env: name: ASPNETCORE_ENVIRONMENT value: \"Production\" Main application container containers: name: orders-service image: myapp/orders-service:latest ` Application code: `csharp // In Program cs if (args Contains(\"--seed-only\")) {\n    await SeedDataAsync(app Services);\n    return;  // Exit after seeding\n}\nawait app RunAsync();  // Normal startup\n`\n---\nBackend-for-Frontend (BFF) Support\nBFF pattern creates backend APIs tailored to specific frontend applications (web, mobile, desktop) BFF Architecture\n`\n┌─────────────┐       ┌─────────────┐       ┌─────────────┐\n│  Web App    │       │ Mobile App  │       │ Desktop App │\n│  (React)    │       │  (Swift)    │       │  (WinUI)    │\n└──────┬──────┘       └──────┬──────┘       └──────┬──────┘\n       │                     │                     │\n       ↓                     ↓                     ↓\n┌─────────────┐       ┌─────────────┐       ┌─────────────┐\n│   Web BFF   │       │  Mobile BFF │       │ Desktop BFF │\n│  (GraphQL)  │       │   (REST)    │       │  (gRPC)     │\n└──────┬──────┘       └──────┬──────┘       └──────┬──────┘\n       │                     │                     │\n       └─────────────┬───────┴─────────────────────┘\n                     ↓\n              ┌──────────────┐\n              │   Whizbang   │\n              │  Microservices│\n              └──────────────┘\n`\nCreating a BFF with Whizbang\n`csharp{\ntitle: \"Web BFF Implementation\"\ndescription: \"Backend-for-Frontend for web application\"\nframework: \"NET8\"\ncategory: \"BFF\"\ndifficulty: \"ADVANCED\"\ntags: [\"BFF\", \"GraphQL\", \"Web\"]\nnugetPackages: [\"Whizbang Core\", \"HotChocolate\"]\nfilename: \"WebBFF/Program cs\"\nusingStatements: [\"Microsoft AspNetCore Builder\", \"Whizbang\", \"HotChocolate\"]\nshowLineNumbers: true\n}\nusing Microsoft AspNetCore Builder;\nusing Whizbang;\nusing HotChocolate;\nvar builder = WebApplication CreateBuilder(args);\n// Add Whizbang as client (sends commands/queries to backend services)\nbuilder Services AddWhizbangClient(options => {\n    options UseDomainOwnership(domains => {\n        domains RegisterDomain(\"Orders\", \"http://orders-service\");\n        domains RegisterDomain(\"Inventory\", \"http://inventory-service\");\n        domains RegisterDomain(\"Customers\", \"http://customers-service\");\n    });\n});\n// Add GraphQL for web frontend\nbuilder Services AddGraphQLServer() AddQueryType<WebQuery>() AddMutationType<WebMutation>();\nvar app = builder Build();\napp MapGraphQL();\napp Run();\n// GraphQL types optimized for web UI\npublic class WebQuery {\n    public async Task<CustomerDashboard> GetDashboardAsync(\n        [Service] IWhizbang whizbang,\n        Guid customerId\n    ) {\n        // Aggregate data from multiple services\n        var customer = await whizbang",
        "startIndex": 5512,
        "preview": "apps/v1 kind: Deployment metadata: name: orders-service spec: replicas: 3 template: spec: Init container runs BEFORE main container initContainers: na..."
      },
      {
        "id": "advanced/advanced-scenarios-chunk-3",
        "text": "for web frontend builder Services AddGraphQLServer() AddQueryType<WebQuery>() AddMutationType<WebMutation>(); var app = builder Build(); app MapGraphQL(); app Run(); // GraphQL types optimized for web UI public class WebQuery { public async Task<CustomerDashboard> GetDashboardAsync( [Service] IWhizbang whizbang, Guid customerId ) { // Aggregate data from multiple services var customer = await whizbang QueryAsync(new GetCustomer(customerId));\n        var orders = await whizbang QueryAsync(new GetCustomerOrders(customerId));\n        var recommendations = await whizbang QueryAsync(new GetRecommendations(customerId));\n        // Return web-optimized payload\n        return new CustomerDashboard(customer, orders, recommendations);\n    }\n}\n`\nMobile BFF (Optimized for Bandwidth)\n`csharp{\ntitle: \"Mobile BFF Implementation\"\ndescription: \"Backend-for-Frontend for mobile apps (minimal payloads)\"\nframework: \"NET8\"\ncategory: \"BFF\"\ndifficulty: \"ADVANCED\"\ntags: [\"BFF\", \"Mobile\", \"REST\"]\nnugetPackages: [\"Whizbang Core\", \"Microsoft AspNetCore\"]\nfilename: \"MobileBFF/Program cs\"\nusingStatements: [\"Microsoft AspNetCore Builder\", \"Microsoft AspNetCore Http\", \"Whizbang\", \"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Microsoft AspNetCore Builder;\nusing Microsoft AspNetCore Http;\nusing Whizbang;\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbangClient(/ /);\nvar app = builder Build();\n// Mobile-optimized endpoints (minimal payloads, pagination)\napp MapGet(\"/mobile/orders\", async (IWhizbang whizbang, Guid customerId, int page) => {\n    var orders = await whizbang QueryAsync(new GetCustomerOrders(customerId) {\n        Page = page,\n        PageSize = 20,  // Mobile shows 20 at a time\n        IncludeFields = new[] { \"id\", \"status\", \"total\", \"placedAt\" }  // Minimal fields\n    });\n    // Return mobile-friendly response\n    return Results Ok(new {\n        orders = orders Select(o => new {\n            id = o Id,\n            status = o Status,\n            total = $\"${o Total:F2}\",  // Pre-formatted for display\n            date = o PlacedAt ToString(\"MMM dd\")\n        }),\n        hasMore = orders Count == 20\n    });\n});\napp Run();\n`\nBFF Aggregation Pattern\nBFFs aggregate data from multiple services:\n`csharp{\ntitle: \"BFF Data Aggregation\"\ndescription: \"Aggregate data from multiple services in BFF\"\nframework: \"NET8\"\ncategory: \"BFF\"\ndifficulty: \"ADVANCED\"\ntags: [\"BFF\", \"Aggregation\", \"Microservices\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System",
        "startIndex": 8039,
        "preview": "for web frontend builder Services AddGraphQLServer() AddQueryType<WebQuery>() AddMutationType<WebMutation>(); var app = builder Build(); app MapGraphQ..."
      },
      {
        "id": "advanced/advanced-scenarios-chunk-4",
        "text": "orders Count == 20 }); }); app Run(); ` BFF Aggregation Pattern BFFs aggregate data from multiple services: `csharp{ title: \"BFF Data Aggregation\" description: \"Aggregate data from multiple services in BFF\" framework: \"NET8\" category: \"BFF\" difficulty: \"ADVANCED\" tags: [\"BFF\", \"Aggregation\", \"Microservices\"] nugetPackages: [\"Whizbang Core\"] usingStatements: [\"System\", \"System Threading Tasks\", \"System Linq\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Linq;\nusing System Threading Tasks;\nusing Whizbang;\npublic class OrderDetailsAggregator {\n    private readonly IWhizbang _whizbang;\n    public OrderDetailsAggregator(IWhizbang whizbang) {\n        _whizbang = whizbang;\n    }\n    public async Task<OrderDetailsViewModel> GetOrderDetailsAsync(Guid orderId) {\n        // Query multiple services in parallel\n        var orderTask = _whizbang QueryAsync(new GetOrder(orderId));\n        var customerTask = _whizbang QueryAsync(new GetCustomer(/ customerId from order /));\n        var inventoryTask = _whizbang QueryAsync(new GetInventoryStatus(orderId));\n        var shippingTask = _whizbang QueryAsync(new GetShippingStatus(orderId));\n        await Task WhenAll(orderTask, customerTask, inventoryTask, shippingTask);\n        // Aggregate into view model\n        return new OrderDetailsViewModel {\n            Order = orderTask Result,\n            Customer = customerTask Result,\n            Inventory = inventoryTask Result,\n            Shipping = shippingTask Result,\n            EstimatedDelivery = CalculateEstimatedDelivery(shippingTask Result)\n        };\n    }\n}\n`\n---\nCentral Control Commands\nCentral control plane for managing distributed services (configuration changes, projection rebuilds, diagnostics) Control Plane Architecture\n`\n┌────────────────────────────────────────┐\n│      Whizbang Control Dashboard        │\n│  (Web UI for operators/administrators) │\n└───────────────┬────────────────────────┘\n                │\n                ↓\n┌───────────────────────────────────────┐\n│       Control Plane Service           │\n│   (Sends control commands to services)│\n└───────────────┬───────────────────────┘\n                │\n       ┌────────┴────────┬──────────┐\n       ↓                 ↓          ↓\n┌──────────┐      ┌──────────┐  ┌──────────┐\n│ Orders   │      │Inventory │  │ Shipping │\n│ Service  │      │ Service  │  │ Service  │\n└──────────┘      └──────────┘  └──────────┘\n`\nControl Commands\n`csharp{\ntitle: \"Control Command Definitions\"\ndescription: \"Central commands for managing services\"\nframework: \"NET8\"\ncategory: \"Control Plane\"\ndifficulty: \"ADVANCED\"\ntags: [\"Control Plane\", \"Operations\", \"Commands\"]\nnugetPackages: [\"Whizbang ControlPlane\"]\nusingStatements: [\"System\", \"Whizbang ControlPlane\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang ControlPlane;\n// Rebuild a projection across all services\npublic record RebuildProjection(\n    string ProjectionName,\n    DateTimeOffset",
        "startIndex": 10230,
        "preview": "orders Count == 20 }); }); app Run(); ` BFF Aggregation Pattern BFFs aggregate data from multiple services: `csharp{ title: \"BFF Data Aggregation\" des..."
      },
      {
        "id": "advanced/advanced-scenarios-chunk-5",
        "text": "title: \"Control Command Definitions\" description: \"Central commands for managing services\" framework: \"NET8\" category: \"Control Plane\" difficulty: \"ADVANCED\" tags: [\"Control Plane\", \"Operations\", \"Commands\"] nugetPackages: [\"Whizbang ControlPlane\"] usingStatements: [\"System\", \"Whizbang ControlPlane\"] showLineNumbers: true } using System; using Whizbang ControlPlane; // Rebuild a projection across all services public record RebuildProjection( string ProjectionName, DateTimeOffset StartFrom = null\n) : ControlCommand;\n// Change log level dynamically\npublic record SetLogLevel(\n    string Category,\n    LogLevel Level\n) : ControlCommand;\n// Enable/disable feature flags\npublic record ToggleFeature(\n    string FeatureName,\n    bool Enabled\n) : ControlCommand;\n// Trigger health check\npublic record RunHealthCheck() : ControlCommand;\n// Clear caches\npublic record ClearCaches(\n    string[] CacheNames\n) : ControlCommand;\n`\nControl Command Handler\nServices implement handlers for control commands:\n`csharp{\ntitle: \"Control Command Handler\"\ndescription: \"Handle central control commands in services\"\nframework: \"NET8\"\ncategory: \"Control Plane\"\ndifficulty: \"ADVANCED\"\ntags: [\"Control Plane\", \"Handlers\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang ControlPlane\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Microsoft Extensions Logging\", \"Whizbang ControlPlane\", \"Whizbang Projections\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Microsoft Extensions Logging;\nusing Whizbang ControlPlane;\nusing Whizbang Projections;\npublic class RebuildProjectionHandler {\n    private readonly IProjectionEngine _projectionEngine;\n    private readonly ILogger _logger;\n    public RebuildProjectionHandler(IProjectionEngine projectionEngine, ILogger logger) {\n        _projectionEngine = projectionEngine;\n        _logger = logger;\n    }\n    public async Task Handle(RebuildProjection command) {\n        _logger LogWarning(\"Rebuilding projection {ProjectionName} from {StartFrom}\",\n            command ProjectionName,\n            command StartFrom DateTimeOffset MinValue\n        );\n        // Stop projection\n        await _projectionEngine StopProjectionAsync(command ProjectionName);\n        // Clear projection data\n        await _projectionEngine ClearProjectionAsync(command ProjectionName);\n        // Restart from specified point\n        await _projectionEngine StartProjectionAsync(command ProjectionName, command StartFrom);\n        _logger LogInformation(\"Projection {ProjectionName} rebuild started\", command ProjectionName);\n    }\n}\n`\nSending Control Commands\nFrom the control dashboard:\n`csharp{\ntitle: \"Sending Control Commands\"\ndescription: \"Send control commands from central dashboard\"\nframework: \"NET8\"\ncategory: \"Control Plane\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Control Plane\", \"Dashboard\"]\nnugetPackages: [\"Whizbang ControlPlane\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang",
        "startIndex": 12758,
        "preview": "title: \"Control Command Definitions\" description: \"Central commands for managing services\" framework: \"NET8\" category: \"Control Plane\" difficulty: \"AD..."
      },
      {
        "id": "advanced/advanced-scenarios-chunk-6",
        "text": "StartFrom); _logger LogInformation(\"Projection {ProjectionName} rebuild started\", command ProjectionName); } } ` Sending Control Commands From the control dashboard: `csharp{ title: \"Sending Control Commands\" description: \"Send control commands from central dashboard\" framework: \"NET8\" category: \"Control Plane\" difficulty: \"INTERMEDIATE\" tags: [\"Control Plane\", \"Dashboard\"] nugetPackages: [\"Whizbang ControlPlane\"] usingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang ControlPlane\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang ControlPlane;\npublic class ControlPlaneClient {\n    private readonly IWhizbangControlPlane _controlPlane;\n    public ControlPlaneClient(IWhizbangControlPlane controlPlane) {\n        _controlPlane = controlPlane;\n    }\n    public async Task RebuildProjectionAcrossAllServicesAsync(string projectionName) {\n        // Send command to ALL services that have this projection\n        await _controlPlane BroadcastAsync(new RebuildProjection(projectionName));\n    }\n    public async Task RebuildProjectionOnSpecificServiceAsync(string service, string projection) {\n        // Send command to specific service only\n        await _controlPlane SendToServiceAsync(service, new RebuildProjection(projection));\n    }\n    public async Task SetLogLevelGloballyAsync(string category, LogLevel level) {\n        // Change log level across all services\n        await _controlPlane BroadcastAsync(new SetLogLevel(category, level));\n    }\n}\n`\nNext Steps\nWhizbang Dashboard - Visual control plane\nObservability - Monitoring and tracing\nDistributed Messaging - Microservices architecture",
        "startIndex": 15240,
        "preview": "StartFrom); _logger LogInformation(\"Projection {ProjectionName} rebuild started\", command ProjectionName); } } ` Sending Control Commands From the con..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "advanced/configuration",
    "title": "Configuration",
    "category": "Advanced",
    "url": "/docs/advanced/configuration",
    "chunks": [
      {
        "id": "advanced/configuration-chunk-0",
        "text": "Configuration\nWhizbang provides a comprehensive configuration system that allows you to customize every aspect of the runtime, from storage backends to messaging systems, observability, and performance tuning Basic Configuration\nMinimal Setup\n`csharp\n// Program cs\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbang(options => {\n    // Scan assemblies for handlers, aggregates, and projections\n    options ScanAssembly(typeof(Program) Assembly);\n});\nvar app = builder Build();\napp Run();\n`\nWith Storage Backend\n`csharp\nbuilder Services AddWhizbang(options => {\n    options ScanAssembly(typeof(Program) Assembly);\n    // Configure event store\n    options UseEventSourcing(es => {\n        es UsePostgres(connectionString);\n        // or es UseSqlServer(connectionString);\n        // or es UseInMemory(); // for testing\n    });\n});\n`\nStorage Configuration\nEvent Store Options\n`csharp\noptions UseEventSourcing(es => {\n    es UsePostgres(connectionString, postgres => {\n        postgres SchemaName = \"events\";\n        postgres TableName = \"event_store\";\n        postgres SnapshotInterval = 100;\n        postgres EnableAutomaticMigrations = true;\n    });\n});\n`\nProjection Store Options\n`csharp\noptions UseProjections(proj => {\n    // Use same database as event store\n    proj UseSameStoreAsEvents();\n    // Or use different database\n    proj UsePostgres(projectionConnectionString, postgres => {\n        postgres SchemaName = \"projections\";\n        postgres EnableAutomaticMigrations = true;\n    });\n    // Or use MongoDB for projections\n    proj UseMongoDb(mongoConnectionString, mongo => {\n        mongo DatabaseName = \"whizbang_projections\";\n    });\n});\n`\nMessaging Configuration\nIn-Process Messaging\n`csharp\noptions UseMessaging(msg => {\n    msg UseInProcess(); // Default - all handlers run in same process\n});\n`\nDistributed Messaging\n`csharp\noptions UseMessaging(msg => {\n    msg UseKafka(kafka => {\n        kafka BootstrapServers = \"localhost:9092\";\n        kafka ConsumerGroup = \"whizbang-consumers\";\n        kafka EnableIdempotency = true;\n        kafka RetryPolicy = RetryPolicy ExponentialBackoff(\n            maxRetries: 5,\n            baseDelay: TimeSpan FromSeconds(1)\n        );\n    });\n    // or msg UseRabbitMQ( );\n    // or msg UseAzureServiceBus( );\n});\n`\nOutbox Pattern\n`csharp\noptions UseMessaging(msg => {\n    msg UseOutbox(outbox => {\n        outbox ProcessingInterval = TimeSpan FromSeconds(5);\n        outbox BatchSize = 100;\n        outbox RetryFailedMessages = true;\n        outbox MaxRetries = 3;\n    });\n});\n`\nHandler Configuration\nAssembly Scanning\n`csharp\noptions ScanAssembly(typeof(Program) Assembly);\noptions ScanAssemblies(\n    typeof(OrderHandlers)",
        "startIndex": 0,
        "preview": "Configuration\nWhizbang provides a comprehensive configuration system that allows you to customize every aspect of the runtime, from storage backends t..."
      },
      {
        "id": "advanced/configuration-chunk-1",
        "text": "); // or msg UseAzureServiceBus( ); }); ` Outbox Pattern `csharp options UseMessaging(msg => { msg UseOutbox(outbox => { outbox ProcessingInterval = TimeSpan FromSeconds(5); outbox BatchSize = 100; outbox RetryFailedMessages = true; outbox MaxRetries = 3; }); }); ` Handler Configuration Assembly Scanning `csharp options ScanAssembly(typeof(Program) Assembly); options ScanAssemblies( typeof(OrderHandlers) Assembly,\n    typeof(PaymentHandlers) Assembly\n);\n// Scan all assemblies in current directory\noptions ScanCurrentDirectory();\n`\nManual Registration\n`csharp\noptions RegisterHandlers(handlers => {\n    handlers RegisterCommandHandler<PlaceOrderHandler>();\n    handlers RegisterEventHandler<OrderPlacedHandler>();\n    handlers RegisterQueryHandler<GetOrderHandler>();\n});\n`\nHandler Lifetime\n`csharp\noptions ConfigureHandlers(handlers => {\n    handlers DefaultLifetime = ServiceLifetime Scoped;\n    // Override specific handlers\n    handlers SetLifetime<ExpensiveHandler>(ServiceLifetime Singleton);\n});\n`\nProjection Configuration\nRegistration and Subscriptions\n`csharp\noptions UseProjections(proj => {\n    proj RegisterProjection<OrderSummaryProjection>(p => {\n        p Subscribe<OrderPlacedEvent>();\n        p Subscribe<OrderShippedEvent>();\n        p Subscribe<OrderCancelledEvent>();\n        // Backfill from specific point\n        p BackfillFrom = DateTimeOffset UtcNow AddDays(-30);\n        // Partition by customer for parallel processing\n        p PartitionBy = @event => ((dynamic)@event) CustomerId;\n    });\n});\n`\nPerformance Tuning\n`csharp\nproj ConfigurePerformance(perf => {\n    perf BatchSize = 1000;\n    perf ConcurrentPartitions = Environment ProcessorCount;\n    perf CheckpointInterval = TimeSpan FromSeconds(10);\n    perf MaxLagBeforeAlert = TimeSpan FromMinutes(5);\n});\n`\nObservability Configuration\nOpenTelemetry Integration\n`csharp\noptions UseObservability(obs => {\n    obs UseOpenTelemetry(otel => {\n        otel ServiceName = \"my-whizbang-service\";\n        otel ServiceVersion = \"1 0 0\";\n        // Export to Jaeger\n        otel AddJaegerExporter(jaeger => {\n            jaeger Endpoint = new Uri(\"http://localhost:14268\");\n        });\n        // Export to Application Insights\n        otel AddApplicationInsightsExporter(ai => {\n            ai ConnectionString = builder Configuration GetConnectionString(\"ApplicationInsights\");\n        });\n    });\n    // Built-in metrics\n    obs EnableMetrics = true;\n    obs EnableHealthChecks = true;\n});\n`\nLogging Configuration\n`csharp\noptions UseLogging(logging => {\n    logging LogLevel = LogLevel Information;\n    logging LogCommands = true;\n    logging LogEvents = true;\n    logging LogQueries = false; // Can be noisy\n    // Structured logging\n    logging UseStructuredLogging = true;\n    logging IncludeCorrelationIds = true;\n});\n`\nSecurity Configuration\nAuthentication & Authorization\n`csharp\noptions",
        "startIndex": 2712,
        "preview": "); // or msg UseAzureServiceBus( ); }); ` Outbox Pattern `csharp options UseMessaging(msg => { msg UseOutbox(outbox => { outbox ProcessingInterval = T..."
      },
      {
        "id": "advanced/configuration-chunk-2",
        "text": "}); ` Logging Configuration `csharp options UseLogging(logging => { logging LogLevel = LogLevel Information; logging LogCommands = true; logging LogEvents = true; logging LogQueries = false; // Can be noisy // Structured logging logging UseStructuredLogging = true; logging IncludeCorrelationIds = true; }); ` Security Configuration Authentication & Authorization `csharp options UseSecurity(security => {\n    // Require authentication for all commands\n    security RequireAuthentication = true;\n    // Configure permissions\n    security ConfigureAuthorization(auth => {\n        auth RequirePermission<PlaceOrderCommand>(\"orders:write\");\n        auth RequirePermission<GetOrderQuery>(\"orders:read\");\n        // Role-based access\n        auth RequireRole<CancelOrderCommand>(\"OrderManager\");\n    });\n    // Multi-tenancy\n    security UseMultiTenancy(mt => {\n        mt TenantResolutionStrategy = TenantResolutionStrategy FromClaims;\n        mt TenantClaimType = \"tenant_id\";\n        mt IsolateTenantData = true;\n    });\n});\n`\nData Protection\n`csharp\noptions UseSecurity(security => {\n    security UseEncryption(encryption => {\n        encryption EncryptSensitiveFields = true;\n        encryption KeyRotationInterval = TimeSpan FromDays(90);\n        // Azure Key Vault integration\n        encryption UseAzureKeyVault(kv => {\n            kv VaultUri = \"https://my-vault vault azure net/\";\n            kv KeyName = \"whizbang-encryption-key\";\n        });\n    });\n});\n`\nPerformance Configuration\nConnection Pooling\n`csharp\noptions ConfigurePerformance(perf => {\n    perf DatabaseConnections = conn => {\n        conn MaxPoolSize = 100;\n        conn MinPoolSize = 10;\n        conn ConnectionTimeout = TimeSpan FromSeconds(30);\n        conn CommandTimeout = TimeSpan FromSeconds(60);\n    };\n});\n`\nCaching\n`csharp\noptions UseCaching(cache => {\n    cache UseDistributedCache(dist => {\n        dist UseRedis(redis => {\n            redis ConnectionString = \"localhost:6379\";\n            redis DatabaseNumber = 0;\n        });\n    });\n    // Cache aggregates for read-heavy scenarios\n    cache CacheAggregates = true;\n    cache AggregateCacheDuration = TimeSpan FromMinutes(5);\n    // Cache projection results\n    cache CacheProjections = true;\n    cache ProjectionCacheDuration = TimeSpan FromMinutes(1);\n});\n`\nEnvironment-Specific Configuration\nDevelopment Environment\n`csharp\nif (builder Environment IsDevelopment()) {\n    options UseDevelopmentDefaults(dev => {\n        dev UseInMemoryStorage = true;\n        dev EnableDetailedErrors = true;\n        dev LogAllQueries = true;\n        dev EnableSwagger = true;\n    });\n}\n`\nProduction Environment\n`csharp\nif (builder Environment IsProduction()) {\n    options UseProductionDefaults(prod => {\n        prod EnableOptimizations = true;\n        prod UseConnectionPooling = true;\n        prod EnableMetrics = true;\n        prod EnableHealthChecks = true;\n        prod",
        "startIndex": 5177,
        "preview": "}); ` Logging Configuration `csharp options UseLogging(logging => { logging LogLevel = LogLevel Information; logging LogCommands = true; logging LogEv..."
      },
      {
        "id": "advanced/configuration-chunk-3",
        "text": "=> { dev UseInMemoryStorage = true; dev EnableDetailedErrors = true; dev LogAllQueries = true; dev EnableSwagger = true; }); } ` Production Environment `csharp if (builder Environment IsProduction()) { options UseProductionDefaults(prod => { prod EnableOptimizations = true; prod UseConnectionPooling = true; prod EnableMetrics = true; prod EnableHealthChecks = true; prod LogLevel = LogLevel Warning;\n    });\n}\n`\nConfiguration from appsettings json\n`json\n{\n  \"Whizbang\": {\n    \"EventStore\": {\n      \"Provider\": \"Postgres\",\n      \"ConnectionString\": \"Host=localhost;Database=events;Username=user;Password=pass\",\n      \"SchemaName\": \"events\",\n      \"SnapshotInterval\": 100\n    },\n    \"Messaging\": {\n      \"Provider\": \"Kafka\",\n      \"BootstrapServers\": \"localhost:9092\",\n      \"ConsumerGroup\": \"my-service-consumers\"\n    },\n    \"Projections\": {\n      \"BatchSize\": 1000,\n      \"ConcurrentPartitions\": 4,\n      \"CheckpointInterval\": \"00:00:10\"\n    },\n    \"Observability\": {\n      \"ServiceName\": \"my-whizbang-service\",\n      \"EnableMetrics\": true,\n      \"LogLevel\": \"Information\"\n    }\n  }\n}\n`\n`csharp\n// Load from configuration\noptions ConfigureFromSection(builder Configuration GetSection(\"Whizbang\"));\n`\nValidation and Diagnostics\nConfiguration Validation\n`csharp\noptions ValidateConfiguration = true;\noptions ValidateOnStartup = true;\n// Custom validation\noptions AddConfigurationValidator<CustomConfigValidator>();\n`\nHealth Checks\n`csharp\nbuilder Services AddHealthChecks() AddWhizbangHealthChecks(); // Adds event store, projections, messaging health checks\n`\nRelated Topics\nGetting Started - Basic setup and configuration\nPackage Structure - Available NuGet packages and adapters NET Aspire Integration - Cloud-native configuration\nAdvanced Scenarios - Complex configuration patterns\nNext Steps\nThis page covers the core configuration options in Whizbang For specific deployment scenarios and advanced patterns, refer to the specialized documentation sections",
        "startIndex": 4849,
        "preview": "=> { dev UseInMemoryStorage = true; dev EnableDetailedErrors = true; dev LogAllQueries = true; dev EnableSwagger = true; }); } ` Production Environmen..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "architecture-design/architecture",
    "title": "Architecture Overview",
    "category": "Architecture & Design",
    "url": "/docs/architecture-design/architecture",
    "chunks": [
      {
        "id": "architecture-design/architecture-chunk-0",
        "text": "Architecture Overview\nWhizbang is built on a layered architecture that supports scaling from a simple in-process mediator to a full distributed event-sourced system Architectural Layers\n`\n┌─────────────────────────────────────────────────────────────┐\n│                     Application Layer                       │\n│  (Your Domain Code: Aggregates, Projections, Handlers)      │\n└─────────────────────────────────────────────────────────────┘\n                            ↓\n┌─────────────────────────────────────────────────────────────┐\n│                    Whizbang Runtime                          │\n│  • Message Routing        • Event Sourcing Engine            │\n│  • Command Handling       • Projection Management            │\n│  • Event Publishing       • Saga Coordination                │\n│  • Idempotence            • Observability Pipeline           │\n└─────────────────────────────────────────────────────────────┘\n                            ↓\n┌─────────────────────────────────────────────────────────────┐\n│                      Driver Layer                            │\n│  • Persistence Drivers    • Message Broker Adapters          │\n│  • Serialization Drivers  • Telemetry Drivers                │\n└─────────────────────────────────────────────────────────────┘\n                            ↓\n┌─────────────────────────────────────────────────────────────┐\n│                   Infrastructure                             │\n│  • Databases              • Message Brokers                  │\n│  • Telemetry Backends     • Service Discovery                │\n└─────────────────────────────────────────────────────────────┘\n`\nCore Components\nMessage Router with Return Type Semantics\nThe Message Router is the heart of Whizbang It interprets handler return types to determine behavior:\nRoutes commands to their owning domain's handlers\nPublishes events to all interested subscribers  \nExecutes queries against projections\nCoordinates sagas across long-running processes\nReturn type semantics - What you return determines what happens:\nSingle message return → Publish/Send based on type\nTuple return → Multiple cascading messages\nVoid return → Fire-and-forget execution\nIAsyncEnumerable → Streaming results\nAll message routing respects domain ownership—commands must be sent to the service that owns that aggregate, while events are broadcast from the owning domain to subscribers Event Store\nThe Event Store is the source of truth for all state changes",
        "startIndex": 0,
        "preview": "Architecture Overview\nWhizbang is built on a layered architecture that supports scaling from a simple in-process mediator to a full distributed event-..."
      },
      {
        "id": "architecture-design/architecture-chunk-1",
        "text": "messages Void return → Fire-and-forget execution IAsyncEnumerable → Streaming results All message routing respects domain ownership—commands must be sent to the service that owns that aggregate, while events are broadcast from the owning domain to subscribers Event Store The Event Store is the source of truth for all state changes It:\nAppends events to immutable streams (one stream per aggregate)\nSupports time-based queries (get all events before/after a timestamp)\nEnables backfilling new projections from historical events\nProvides global ordering for cross-aggregate event streams\nImplements optimistic concurrency for aggregate updates\nThe Event Store is driver-based, supporting:\nPostgres (JSONB + sequential IDs)\nSQL Server (JSON columns + IDENTITY)\nMySQL (JSON columns + auto-increment)\nCosmos DB (native event streams)\nLiteFS/SQLite (binary codec for edge deployments)\nProjection Engine\nThe Projection Engine builds read models from event streams",
        "startIndex": 2466,
        "preview": "messages Void return → Fire-and-forget execution IAsyncEnumerable → Streaming results All message routing respects domain ownership—commands must be s..."
      },
      {
        "id": "architecture-design/architecture-chunk-2",
        "text": "Implements optimistic concurrency for aggregate updates The Event Store is driver-based, supporting: Postgres (JSONB + sequential IDs) SQL Server (JSON columns + IDENTITY) MySQL (JSON columns + auto-increment) Cosmos DB (native event streams) LiteFS/SQLite (binary codec for edge deployments) Projection Engine The Projection Engine builds read models from event streams It:\nSubscribes to event streams (local or from remote services)\nApplies events to projection handlers in order\nTracks checkpoint positions to resume after restarts\nSupports parallel processing across partitions\nHandles schema migrations for evolving projections\nProjections can be:\nInline - Updated synchronously within the same transaction as event append\nAsync - Updated in background workers for eventual consistency\nCached - Materialized in-memory for ultra-low latency\nExternal - Pushed to Elasticsearch, Redis, or other specialized stores\nAspect-Oriented Pipeline\nThe AOP Pipeline weaves cross-cutting concerns through source generation:\n`\nIncoming Message\n      ↓\n  [Logged] - Structured logging aspect\n      ↓\n  [Validated] - Input validation aspect\n      ↓\n  [Authorized] - Security aspect\n      ↓\n  [Cached] - Result caching aspect\n      ↓\n  [Retry] - Resilience aspect\n      ↓\n  [Timed] - Performance metrics aspect\n      ↓\n  Handler Execution\n      ↓\n  [Transactional] - Database transaction aspect\n      ↓\n  Event Append / Projection Update\n      ↓\n  [Outbox] - Distributed messaging aspect\n      ↓\n  Response / New Messages\n`\nAspects are:\nDeclarative - Applied via attributes\nCompiled - Source generators create zero-overhead code\nComposable - Multiple aspects work together\nTestable - Can be verified in isolation\nEvery stage is pluggable and observable Saga Coordinator\nSagas orchestrate long-running processes across multiple aggregates or services Whizbang supports two saga styles:\nOrchestration - A central coordinator issues commands and listens for events:\n`csharp\npublic class OrderFulfillmentSaga : Saga {\n    public async Task Handle(OrderPlaced @event) {\n        await Send(new ReserveInventory(@event OrderId));\n    }\n    public async Task Handle(InventoryReserved @event) {\n        await Send(new ChargePayment(@event OrderId));\n    }\n    public async Task Handle(PaymentCharged @event) {\n        await Send(new ShipOrder(@event",
        "startIndex": 3093,
        "preview": "Implements optimistic concurrency for aggregate updates The Event Store is driver-based, supporting: Postgres (JSONB + sequential IDs) SQL Server (JSO..."
      },
      {
        "id": "architecture-design/architecture-chunk-3",
        "text": "styles: Orchestration - A central coordinator issues commands and listens for events: `csharp public class OrderFulfillmentSaga : Saga { public async Task Handle(OrderPlaced @event) { await Send(new ReserveInventory(@event OrderId)); } public async Task Handle(InventoryReserved @event) { await Send(new ChargePayment(@event OrderId)); } public async Task Handle(PaymentCharged @event) { await Send(new ShipOrder(@event OrderId));\n    }\n}\n`\nChoreography - Each service reacts to events and publishes new ones (no central coordinator) Sagas are persisted as event streams and can be replayed or debugged like any other aggregate Outbox/Inbox Pattern\nFor distributed messaging, Whizbang implements the Outbox/Inbox pattern to ensure exactly-once delivery:\nOutbox (Publishing Service):\nHandler executes and appends events to event store\nEvents also written to outbox table in same transaction\nBackground worker publishes outbox messages to message broker\nMessages marked as published after broker confirms\nInbox (Subscribing Service):\nMessage arrives from broker\nStored in inbox table with unique message ID\nIf message ID exists (duplicate), skip processing\nOtherwise, process handler and mark message as complete\nPeriodic cleanup of old inbox entries\nThis pattern guarantees at-least-once delivery from the broker combined with idempotent handling for exactly-once semantics Domain Ownership Model\nWhizbang enforces explicit domain ownership to prevent distributed system chaos",
        "startIndex": 5052,
        "preview": "styles: Orchestration - A central coordinator issues commands and listens for events: `csharp public class OrderFulfillmentSaga : Saga { public async ..."
      },
      {
        "id": "architecture-design/architecture-chunk-4",
        "text": "ID If message ID exists (duplicate), skip processing Otherwise, process handler and mark message as complete Periodic cleanup of old inbox entries This pattern guarantees at-least-once delivery from the broker combined with idempotent handling for exactly-once semantics Domain Ownership Model Whizbang enforces explicit domain ownership to prevent distributed system chaos Commands\nCommands are sent TO the service that owns the aggregate:\n`csharp\n[OwnedBy(\"Orders\")]  // This command belongs to the Orders service\npublic record PlaceOrder(Guid OrderId, Guid CustomerId, List<OrderItem> Items);\n`\nWhen you send a command:\nIn a monolith, it's routed to the local handler\nIn microservices, it's routed to the Orders service via the message broker\nEvents\nEvents are emitted FROM the service that owns the domain:\n`csharp\n[OwnedBy(\"Orders\")]  // This event comes from the Orders service\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt);\n`\nOther services can subscribe to OrderPlaced events:\nIn a monolith, subscribers get events via in-process pub/sub\nIn microservices, subscribers get events from the message broker topic\nBackfilling Projections\nWhen a new service subscribes to events for the first time, it can backfill from the beginning:\n`csharp\nservices AddProjection<OrderHistoryProjection>(options => {\n    options Subscribe<OrderPlaced>();\n    options Subscribe<OrderShipped>();\n    options BackfillFrom = DateTimeOffset MinValue;  // Start from the beginning\n});\n`\nThe projection engine will:\nQuery the Orders service's event store for all historical events\nApply them to the projection in order\nContinue processing new events as they arrive\nThis allows new projections to be built from existing event history Scaling Patterns\nSingle Process (Mediator Mode)\n`\n┌─────────────────────────────┐\n│   ASP",
        "startIndex": 6112,
        "preview": "ID If message ID exists (duplicate), skip processing Otherwise, process handler and mark message as complete Periodic cleanup of old inbox entries Thi..."
      },
      {
        "id": "architecture-design/architecture-chunk-5",
        "text": "` The projection engine will: Query the Orders service's event store for all historical events Apply them to the projection in order Continue processing new events as they arrive This allows new projections to be built from existing event history Scaling Patterns Single Process (Mediator Mode) ` ┌─────────────────────────────┐ │ ASP NET Core Web API      │\n│                             │\n│  ┌──────────────────────┐   │\n│  │  Whizbang Runtime    │   │\n│  │  (In-Memory)         │   │\n│  └──────────────────────┘   │\n│           ↓                 │\n│  ┌──────────────────────┐   │\n│  │  SQLite / Postgres   │   │\n│  └──────────────────────┘   │\n└─────────────────────────────┘\n`\nPerfect for:\nMonolithic applications\nLocal development\nSimple CQRS without microservices\nMulti-Service (Distributed)\n`\n┌─────────────┐      ┌─────────────┐      ┌─────────────┐\n│   Orders    │      │  Inventory  │      │  Shipping   │\n│   Service   │      │   Service   │      │   Service   │\n│             │      │             │      │             │\n│  Whizbang   │      │  Whizbang   │      │  Whizbang   │\n│             │      │             │      │             │\n│  Postgres   │      │  Postgres   │      │  Postgres   │\n└──────┬──────┘      └──────┬──────┘      └──────┬──────┘\n       │                    │                    │\n       └────────────┬───────┴────────────────────┘\n                    ↓\n          ┌──────────────────┐\n          │  Kafka / RabbitMQ│\n          │  (Message Broker)│\n          └──────────────────┘\n`\nEach service:\nHas its own event store for database isolation\nPublishes events to the shared message broker\nSubscribes to events from other services\nRoutes commands to owning services\nMulti-Region (Disaster Recovery)\n`\n        Region 1                         Region 2\n┌─────────────────────┐         ┌─────────────────────┐\n│  Primary Services   │         │  Replica Services   │\n│                     │         │                     │\n│  Event Stores       │◄───────►│  Event Stores       │\n│  (Postgres)         │  Sync   │  (Postgres)         │\n└─────────────────────┘         └─────────────────────┘\n         ↓                               ↓\n┌─────────────────────┐         ┌─────────────────────┐\n│  Kafka Cluster      │◄───────►│  Kafka Cluster      │\n│  (Region 1)         │  Mirror │  (Region 2)         │\n└─────────────────────┘         └─────────────────────┘\n`\nEvent streams are replicated across regions for disaster recovery Region 2 can take over if Region 1 fails",
        "startIndex": 7579,
        "preview": "` The projection engine will: Query the Orders service's event store for all historical events Apply them to the projection in order Continue processi..."
      },
      {
        "id": "architecture-design/architecture-chunk-6",
        "text": "│ (Postgres) │ Sync │ (Postgres) │ └─────────────────────┘ └─────────────────────┘ ↓ ↓ ┌─────────────────────┐ ┌─────────────────────┐ │ Kafka Cluster │◄───────►│ Kafka Cluster │ │ (Region 1) │ Mirror │ (Region 2) │ └─────────────────────┘ └─────────────────────┘ ` Event streams are replicated across regions for disaster recovery Region 2 can take over if Region 1 fails Progressive Enhancement Modes\nWhizbang provides four deployment modes, all using the exact same handler code:\nMode 1: In-Process (Development)\n`csharp\nservices AddWhizbang() UseInProcessMode();\n`\nNo infrastructure dependencies\nImmediate execution\nPerfect for development and testing\nMode 2: Durable (Single Service)\n`csharp\nservices AddWhizbang() UseDurableMode() UsePostgreSQL(connectionString);\n`\nPersistent message queue\nAutomatic retry on failure\nOutbox pattern for reliability\nMode 3: Distributed (Microservices)\n`csharp\nservices AddWhizbang() UseDistributedMode() UseKafka(kafkaConfig) UsePostgreSQL(connectionString);\n`\nCross-service messaging\nService discovery\nDistributed tracing\nMode 4: Event-Sourced (Full CQRS/ES)\n`csharp\nservices AddWhizbang() UseEventSourcedMode() UseEventStore(eventStoreConfig) UseProjections(projectionConfig);\n`\nComplete event sourcing\nTime travel debugging\nProjection rebuilding\nMessage Execution Patterns\nWithin any mode, Whizbang supports three execution patterns:\nInline Mode\nHandler executes synchronously within the caller's transaction:\n`csharp\nvar result = await whizbang Send(new PlaceOrder( ));\n// Handler executed, events appended, projections updated—all before returning\n`\nBest for:\nStrong consistency requirements\nSimple CRUD operations\nLocal development\nDurable Mode\nHandler executes asynchronously in a background worker:\n`csharp\nawait whizbang Publish(new PlaceOrder( ));\n// Command written to queue, returns immediately\n// Handler executes in background worker\n`\nBest for:\nHigh throughput\nNon-blocking operations\nEventual consistency scenarios\nBatched Mode\nMultiple messages batched together for efficiency:\n`csharp\nawait whizbang PublishBatch(new[] {\n    new PlaceOrder( ),\n    new PlaceOrder( ),\n    new PlaceOrder( )\n});\n// All three commands processed in one batch for better throughput\n`\nBest for:\nBulk imports\nScheduled jobs\nData migration\nThe same handler code works in all three modes Toggle via configuration, not code changes",
        "startIndex": 9740,
        "preview": "│ (Postgres) │ Sync │ (Postgres) │ └─────────────────────┘ └─────────────────────┘ ↓ ↓ ┌─────────────────────┐ ┌─────────────────────┐ │ Kafka Cluster..."
      },
      {
        "id": "architecture-design/architecture-chunk-7",
        "text": "`csharp await whizbang PublishBatch(new[] { new PlaceOrder( ), new PlaceOrder( ), new PlaceOrder( ) }); // All three commands processed in one batch for better throughput ` Best for: Bulk imports Scheduled jobs Data migration The same handler code works in all three modes Toggle via configuration, not code changes Next Steps\nNow that you understand the overall architecture, dive into:\nCore Concepts - Deep dive into Events, Commands, Aggregates, Projections\nPackage Structure - Which NuGet packages to install\nGetting Started - Build your first Whizbang application",
        "startIndex": 11781,
        "preview": "`csharp await whizbang PublishBatch(new[] { new PlaceOrder( ), new PlaceOrder( ), new PlaceOrder( ) }); // All three commands processed in one batch f..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "architecture-design/aspect-oriented-programming",
    "title": "Aspect-Oriented Programming in Whizbang",
    "category": "Architecture & Design",
    "url": "/docs/architecture-design/aspect-oriented-programming",
    "chunks": [
      {
        "id": "architecture-design/aspect-oriented-programming-chunk-0",
        "text": "Aspect-Oriented Programming in Whizbang\nOverview\nWhizbang brings true aspect-oriented programming (AOP) to NET messaging through source generators Cross-cutting concerns like logging, caching, retry, and authorization are first-class citizens, not afterthoughts bolted onto your handlers What Makes Whizbang's AOP Different\nTraditional NET AOP approaches suffer from:\nRuntime reflection overhead (Castle DynamicProxy, PostSharp)\nLimited compile-time verification (Attributes without validation)\nPoor IDE support (No IntelliSense for aspects)\nComplex configuration (XML files, registration ceremonies)\nWhizbang solves these with:\nSource generation - Zero runtime overhead\nCompile-time verification - Catch errors during build\nRich IDE integration - Full IntelliSense and refactoring\nConvention-based - Aspects just work\nCore Concepts\nAspects as Attributes\n`csharp\n[Logged]                    // Add structured logging\n[Timed]                     // Track execution time\n[Cached(Duration = \"5m\")]   // Cache results\n[Retry(3, Backoff = \"exponential\")]  // Retry on failure\n[Authorized(Role = \"Admin\")]         // Enforce authorization\n[Validated]                 // Validate input\n[Transactional]            // Wrap in transaction\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Your business logic here\n        // All aspects are automatically woven in\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nAspect Execution Pipeline\n`mermaid\ngraph LR\n    Request --> Logged\n    Logged --> Authorized\n    Authorized --> Validated\n    Validated --> Cached{Cache Hit }\n    Cached -->|Yes| Response\n    Cached -->|No| Timed\n    Timed --> Transactional\n    Transactional --> Handler[Business Logic]\n    Handler --> Retry{Success }\n    Retry -->|No| Handler\n    Retry -->|Yes| UpdateCache\n    UpdateCache --> Response\n`\nBuilt-in Aspects\nLogging Aspect\n`csharp\n[Logged(\n    Level = LogLevel Information,\n    IncludeParameters = true,\n    IncludeResult = true,\n    IncludeDuration = true,\n    Message = \"Processing order {OrderId}\"\n)]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Automatically logs:\n        // - Method entry with parameters\n        // - Method exit with result\n        // - Execution duration\n        // - Any exceptions\n        return new OrderCreated(cmd",
        "startIndex": 0,
        "preview": "Aspect-Oriented Programming in Whizbang\nOverview\nWhizbang brings true aspect-oriented programming (AOP) to NET messaging through source generators Cro..."
      },
      {
        "id": "architecture-design/aspect-oriented-programming-chunk-1",
        "text": "true, IncludeResult = true, IncludeDuration = true, Message = \"Processing order {OrderId}\" )] public class OrderHandler : IHandle<CreateOrder> { public OrderCreated Handle(CreateOrder cmd) { // Automatically logs: // - Method entry with parameters // - Method exit with result // - Execution duration // - Any exceptions return new OrderCreated(cmd OrderId);\n    }\n}\n// Generated structured log output:\n// {\n//   \"timestamp\": \"2024-01-15T10:30:00Z\",\n//   \"level\": \"Information\",\n//   \"message\": \"Processing order 123\",\n//   \"handler\": \"OrderHandler\",\n//   \"method\": \"Handle\",\n//   \"parameters\": { \"orderId\": \"123\", \"customerId\": \"456\" },\n//   \"duration\": 45,\n//   \"result\": { \"orderId\": \"123\", \"success\": true }\n// }\n`\nCaching Aspect\n`csharp\n[Cached(\n    Duration = \"5m\",                    // Cache for 5 minutes\n    Key = \"{CustomerId}:{OrderId}\",     // Custom cache key\n    Condition = \"Result Success\",        // Only cache successful results\n    VaryBy = [\"Country\", \"Currency\"],   // Vary cache by these parameters\n    Group = \"Orders\"                     // Cache group for bulk invalidation\n)]\npublic class GetOrderHandler : IHandle<GetOrder> {\n    public Order Handle(GetOrder query) {\n        // First call: execute and cache\n        // Subsequent calls within 5min: return from cache\n        return LoadOrderFromDatabase(query OrderId);\n    }\n}\n// Cache invalidation\n[InvalidatesCache(Group = \"Orders\")]\npublic class UpdateOrderHandler : IHandle<UpdateOrder> {\n    public void Handle(UpdateOrder cmd) {\n        // Automatically invalidates all cached orders\n    }\n}\n`\nRetry Aspect\n`csharp\n[Retry(\n    MaxAttempts = 3,\n    Backoff = BackoffStrategy Exponential,\n    InitialDelay = \"1s\",\n    MaxDelay = \"30s\",\n    RetryOn = [typeof(TransientException)],\n    AbortOn = [typeof(ValidationException)],\n    OnRetry = nameof(LogRetry)\n)]\npublic class PaymentHandler : IHandle<ProcessPayment> {\n    public PaymentResult Handle(ProcessPayment cmd) {\n        // Automatically retries on TransientException\n        // Aborts immediately on ValidationException\n        return ProcessPayment(cmd);\n    }\n    private void LogRetry(Exception ex, int attempt, TimeSpan delay) {\n        _logger LogWarning($\"Retry {attempt} after {delay}: {ex Message}\");\n    }\n}\n`\nAuthorization Aspect\n`csharp\n[Authorized(\n    Roles = [\"Admin\", \"Manager\"],\n    Policies = [\"OrderManagement\"],\n    RequireAll = false,  // OR condition\n    FailureMode = AuthFailureMode",
        "startIndex": 2403,
        "preview": "true, IncludeResult = true, IncludeDuration = true, Message = \"Processing order {OrderId}\" )] public class OrderHandler : IHandle<CreateOrder> { publi..."
      },
      {
        "id": "architecture-design/aspect-oriented-programming-chunk-2",
        "text": "retries on TransientException // Aborts immediately on ValidationException return ProcessPayment(cmd); } private void LogRetry(Exception ex, int attempt, TimeSpan delay) { _logger LogWarning($\"Retry {attempt} after {delay}: {ex Message}\"); } } ` Authorization Aspect `csharp [Authorized( Roles = [\"Admin\", \"Manager\"], Policies = [\"OrderManagement\"], RequireAll = false, // OR condition FailureMode = AuthFailureMode ThrowException\n)]\npublic class DeleteOrderHandler : IHandle<DeleteOrder> {\n    public void Handle(DeleteOrder cmd) {\n        // Only accessible to Admin or Manager roles\n        // Or users with OrderManagement policy\n    }\n}\n// Resource-based authorization\n[ResourceAuthorized(\n    Resource = \"{OrderId}\",\n    Permission = \"Delete\",\n    ResourceType = typeof(Order)\n)]\npublic class DeleteOrderHandler : IHandle<DeleteOrder> {\n    public void Handle(DeleteOrder cmd) {\n        // Checks if user can delete specific order\n    }\n}\n`\nValidation Aspect\n`csharp\n[Validated(\n    Mode = ValidationMode Strict,\n    ThrowOnFailure = true,\n    ErrorCode = \"VALIDATION_FAILED\"\n)]\npublic class CreateOrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Automatically validates cmd using:\n        // - Data annotations\n        // - FluentValidation rules\n        // - Custom validators\n        return new OrderCreated(cmd OrderId);\n    }\n}\n// The command with validation rules\npublic record CreateOrder(\n    [Required] Guid CustomerId,\n    [MinLength(1)] List<OrderItem> Items,\n    [EmailAddress] string CustomerEmail\n) : ICommand<OrderCreated>;\n`\nTransaction Aspect\n`csharp\n[Transactional(\n    IsolationLevel = IsolationLevel ReadCommitted,\n    Timeout = \"30s\",\n    ReadOnly = false,\n    Propagation = Propagation Required,\n    RollbackOn = [typeof(BusinessException)]\n)]\npublic class TransferMoneyHandler : IHandle<TransferMoney> {\n    public TransferResult Handle(TransferMoney cmd) {\n        // Entire operation wrapped in transaction\n        // Automatically rolled back on exception\n        DebitAccount(cmd FromAccount, cmd Amount);\n        CreditAccount(cmd ToAccount, cmd Amount);\n        return new TransferResult(cmd TransferId);\n    }\n}\n`\nMetrics Aspect\n`csharp\n[Metrics(\n    Counter = \"orders created\",\n    Histogram = \"order processing",
        "startIndex": 4501,
        "preview": "retries on TransientException // Aborts immediately on ValidationException return ProcessPayment(cmd); } private void LogRetry(Exception ex, int attem..."
      },
      {
        "id": "architecture-design/aspect-oriented-programming-chunk-3",
        "text": "public class TransferMoneyHandler : IHandle<TransferMoney> { public TransferResult Handle(TransferMoney cmd) { // Entire operation wrapped in transaction // Automatically rolled back on exception DebitAccount(cmd FromAccount, cmd Amount); CreditAccount(cmd ToAccount, cmd Amount); return new TransferResult(cmd TransferId); } } ` Metrics Aspect `csharp [Metrics( Counter = \"orders created\", Histogram = \"order processing duration\",\n    Tags = [\"country:{Country}\", \"product:{ProductType}\"],\n    IncludeDefaultTags = true\n)]\npublic class CreateOrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Automatically tracks:\n        // - Invocation count\n        // - Duration histogram\n        // - Success/failure rate\n        // - Custom tags from command\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nCreating Custom Aspects\nSimple Custom Aspect\n`csharp\n[AttributeUsage(AttributeTargets Class | AttributeTargets Method)]\npublic class AuditAttribute : AspectAttribute {\n    public override async Task<T> InterceptAsync<T>(\n        AspectContext context, \n        Func<Task<T>> next) {\n        var audit = new AuditEntry {\n            User = context User Identity Name,\n            Action = context Method Name,\n            Timestamp = DateTime UtcNow,\n            Parameters = context Arguments\n        };\n        try {\n            var result = await next();\n            audit Success = true;\n            audit Result = result;\n            return result;\n        }\n        catch (Exception ex) {\n            audit Success = false;\n            audit Error = ex Message;\n            throw;\n        }\n        finally {\n            await context Services GetService<IAuditLog>() LogAsync(audit);\n        }\n    }\n}\n`\nAdvanced Custom Aspect with Source Generator\n`csharp\n// Aspect definition\n[AspectGenerator]\npublic class RateLimitAttribute : AspectAttribute {\n    public int RequestsPerMinute { get; set; }\n    public string Key { get; set; }\n}\n// Source generator creates:\npublic static class RateLimitAspectGenerator {\n    [GeneratedCode]\n    public static async Task<T> Apply<T>(\n        Func<Task<T>> handler,\n        RateLimitAttribute attribute,\n        AspectContext context) {\n        var rateLimiter = context GetService<IRateLimiter>();\n        var key = attribute Key Replace(\"{UserId}\", context User Id);\n        if ( await rateLimiter AllowRequest(key, attribute",
        "startIndex": 6384,
        "preview": "public class TransferMoneyHandler : IHandle<TransferMoney> { public TransferResult Handle(TransferMoney cmd) { // Entire operation wrapped in transact..."
      },
      {
        "id": "architecture-design/aspect-oriented-programming-chunk-4",
        "text": "public string Key { get; set; } } // Source generator creates: public static class RateLimitAspectGenerator { [GeneratedCode] public static async Task<T> Apply<T>( Func<Task<T>> handler, RateLimitAttribute attribute, AspectContext context) { var rateLimiter = context GetService<IRateLimiter>(); var key = attribute Key Replace(\"{UserId}\", context User Id); if ( await rateLimiter AllowRequest(key, attribute RequestsPerMinute)) {\n            throw new RateLimitExceededException();\n        }\n        return await handler();\n    }\n}\n`\nAspect Composition\nSequential Composition\n`csharp\n// Aspects execute in order\n[First]   // Executes first\n[Second]  // Executes second\n[Third]   // Executes third\npublic class Handler : IHandle<Command> {\n    // Execution order: First -> Second -> Third -> Handler -> Third -> Second -> First\n}\n`\nConditional Composition\n`csharp\n[ConditionalAspect(When = \"Environment == 'Production'\", Apply = typeof(AuditAspect))]\n[ConditionalAspect(When = \"User IsAdmin\", Apply = typeof(AdminLoggingAspect))]\npublic class Handler : IHandle<Command> {\n    // Aspects applied based on runtime conditions\n}\n`\nComposite Aspects\n`csharp\n// Define a composite aspect\n[CompositeAspect]\n[Logged]\n[Timed]\n[Retry(3)]\n[Cached(\"5m\")]\npublic class StandardHandlerAspects : AspectAttribute { }\n// Use the composite\n[StandardHandlerAspects]\npublic class OrderHandler : IHandle<CreateOrder> {\n    // Gets all aspects from composite\n}\n`\nCompile-Time Verification\nPure Function Enforcement\n`csharp\n[Pure] // Compile-time verification\npublic class CalculationHandler : IHandle<Calculate> {\n    public Result Handle(Calculate cmd) {\n        // ✅ Allowed: Pure computation\n        var result = cmd A + cmd B;\n        // ❌ Compile error: I/O not allowed\n        // await database SaveAsync(result);\n        // ❌ Compile error: State mutation not allowed  \n        // this",
        "startIndex": 8421,
        "preview": "public string Key { get; set; } } // Source generator creates: public static class RateLimitAspectGenerator { [GeneratedCode] public static async Task..."
      },
      {
        "id": "architecture-design/aspect-oriented-programming-chunk-5",
        "text": "`csharp [Pure] // Compile-time verification public class CalculationHandler : IHandle<Calculate> { public Result Handle(Calculate cmd) { // ✅ Allowed: Pure computation var result = cmd A + cmd B; // ❌ Compile error: I/O not allowed // await database SaveAsync(result); // ❌ Compile error: State mutation not allowed // this field = result;\n        return new Result(result);\n    }\n}\n`\nEffect Tracking\n`csharp\n[Effects(\n    Reads = [\"Database\", \"Cache\"],\n    Writes = [\"Database\"],\n    Publishes = [\"OrderEvents\"],\n    NetworkCalls = [\"PaymentGateway\"]\n)]\npublic class OrderHandler : IHandle<ProcessOrder> {\n    public async Task<Result> Handle(ProcessOrder cmd) {\n        // Source generator verifies declared effects match actual usage\n        var order = await ReadDatabase();      // ✅ Matches Reads\n        await WriteDatabase(order);            // ✅ Matches Writes\n        await PublishEvent(new OrderCreated());// ✅ Matches Publishes\n        // await CallUndeclaredService();      // ❌ Compile error: Undeclared effect\n    }\n}\n`\nAspect Compatibility Checking\n`csharp\n// Source generator detects incompatible aspects\n[Cached]        // ❌ Compile error: Cannot cache with [NoCache]\n[NoCache]       \npublic class Handler { }\n[Transactional] // ❌ Compile error: ReadOnly transaction cannot Write\n[ReadOnly]\n[Writes(\"Database\")]\npublic class Handler { }\n`\nPerformance Optimizations\nZero-Overhead Aspects\n`csharp\n// Source generator creates optimized code\n[Logged]\n[Timed]\npublic class Handler : IHandle<Command> {\n    public Result Handle(Command cmd) => new Result();\n}\n// Generated code (simplified):\npublic class Handler_Generated : IHandle<Command> {\n    private readonly Handler _handler;\n    private readonly ILogger _logger;\n    private readonly IMetrics _metrics;\n    public Result Handle(Command cmd) {\n        var stopwatch = ValueStopwatch StartNew(); // Stack allocated\n        _logger LogDebug(\"Handling {Command}\", cmd);\n        try {\n            var result = _handler Handle(cmd);\n            _logger LogDebug(\"Handled {Command} in {Duration}ms\", cmd, stopwatch ElapsedMilliseconds);\n            _metrics RecordDuration(\"handler duration\", stopwatch Elapsed);\n            return result;\n        }\n        catch (Exception ex) {\n            _logger LogError(ex, \"Error handling {Command}\", cmd);\n            _metrics IncrementCounter(\"handler",
        "startIndex": 9883,
        "preview": "`csharp [Pure] // Compile-time verification public class CalculationHandler : IHandle<Calculate> { public Result Handle(Calculate cmd) { // ✅ Allowed:..."
      },
      {
        "id": "architecture-design/aspect-oriented-programming-chunk-6",
        "text": "Handle(Command cmd) { var stopwatch = ValueStopwatch StartNew(); // Stack allocated _logger LogDebug(\"Handling {Command}\", cmd); try { var result = _handler Handle(cmd); _logger LogDebug(\"Handled {Command} in {Duration}ms\", cmd, stopwatch ElapsedMilliseconds); _metrics RecordDuration(\"handler duration\", stopwatch Elapsed); return result; } catch (Exception ex) { _logger LogError(ex, \"Error handling {Command}\", cmd); _metrics IncrementCounter(\"handler errors\");\n            throw;\n        }\n    }\n}\n`\nAspect Caching\n`csharp\n// Aspects instances are cached and reused\n[Expensive] // This aspect instance is created once and reused\npublic class Handler : IHandle<Command> {\n    // Aspect state is maintained across invocations where appropriate\n}\n`\nTesting with Aspects\nUnit Testing\n`csharp\n[Test]\npublic async Task Handler_WithAspects_LogsAndTimes() {\n    // Arrange\n    var handler = new OrderHandler();\n    var context = new TestAspectContext();\n    // Act\n    var result = await AspectRunner RunWithAspects(\n        handler,\n        new CreateOrder { OrderId = \"123\" },\n        context\n    );\n    // Assert\n    result ShouldBeSuccess();\n    context Logs ShouldContain(log => log Message Contains(\"123\"));\n    context Metrics[\"handler duration\"] ShouldBeLessThan(100);\n}\n`\nIntegration Testing\n`csharp\n[Test]\npublic async Task Handler_WithProductionAspects_WorksCorrectly() {\n    await Whizbang Test<OrderHandler>() Given(new CreateOrder { }) WithAspects(AspectProfile Production) // Use production aspects WhenHandled() Then(result => result ShouldBeSuccess()) AndAspect<CacheAspect>(cache => \n            cache ShouldHaveStored(\"order:123\")) AndAspect<LoggingAspect>(logs => \n            logs ShouldContain(LogLevel Info, \"Order created\"));\n}\n`\nIDE Integration\nIntelliSense Support\n`csharp\n// IDE suggests applicable aspects based on handler type\n[Wh| // IDE suggests: WhizbangCached, WhizbangLogged, WhizbangRetry",
        "startIndex": 11917,
        "preview": "Handle(Command cmd) { var stopwatch = ValueStopwatch StartNew(); // Stack allocated _logger LogDebug(\"Handling {Command}\", cmd); try { var result = _h..."
      },
      {
        "id": "architecture-design/aspect-oriented-programming-chunk-7",
        "text": "Test<OrderHandler>() Given(new CreateOrder { }) WithAspects(AspectProfile Production) // Use production aspects WhenHandled() Then(result => result ShouldBeSuccess()) AndAspect<CacheAspect>(cache => cache ShouldHaveStored(\"order:123\")) AndAspect<LoggingAspect>(logs => logs ShouldContain(LogLevel Info, \"Order created\")); } ` IDE Integration IntelliSense Support `csharp // IDE suggests applicable aspects based on handler type [Wh| // IDE suggests: WhizbangCached, WhizbangLogged, WhizbangRetry // IDE shows aspect execution order\n[Logged]    // (1)\n[Cached]    // (2)  \n[Retry]     // (3)\npublic class Handler { \n    // IDE tooltip: \"Execution order: Logged -> Cached -> Retry -> Handler\"\n}\n`\nRefactoring Support\n`csharp\n// Rename aspect updates all usages\n[MyCustomAspect] // F2 rename updates everywhere\npublic class Handler { }\n// Extract aspect combination to composite\n[Logged]\n[Timed]\n[Retry] // Right-click -> \"Extract to Composite Aspect\"\n`\nBest Practices\nDo's\n✅ Use aspects for cross-cutting concerns\n`csharp\n[Logged]\n[Authorized]\n[Transactional]\n`\n✅ Keep aspects focused and single-purpose\n`csharp\n[Cached]  // Just caching\n[Logged]  // Just logging\n`\n✅ Compose aspects for complex scenarios\n`csharp\n[StandardSecurity]  // Composite of auth, audit, encryption\n`\n✅ Test aspects independently\n`csharp\nAspectTester Test<LoggingAspect>() VerifyBehavior();\n`\nDon'ts\n❌ Don't put business logic in aspects\n`csharp\n[CalculateTax] // Bad: Business logic belongs in handler\n`\n❌ Don't create circular aspect dependencies\n`csharp\n[AspectA(DependsOn = \"AspectB\")]\n[AspectB(DependsOn = \"AspectA\")] // Circular `\n❌ Don't overuse aspects\n`csharp\n// Too many aspects obscure logic\n[Aspect1][Aspect2][Aspect3][Aspect4][Aspect5] `\nSummary\nWhizbang's AOP system brings enterprise-grade aspect-oriented programming to NET with:\nZero runtime overhead through source generation\nCompile-time safety with verification\nRich IDE support for productivity  \nComposable aspects for complex scenarios\nTestable aspects for confidence\nThis enables clean separation of cross-cutting concerns from business logic while maintaining performance and type safety Next Steps\nLearn about Return Type Semantics\nExplore Policy Composition\nSee Aspect-Oriented Handlers pattern\nReview Testing Strategies for aspects",
        "startIndex": 13443,
        "preview": "Test<OrderHandler>() Given(new CreateOrder { }) WithAspects(AspectProfile Production) // Use production aspects WhenHandled() Then(result => result Sh..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "architecture-design/event-driven-architecture",
    "title": "Event-Driven Architecture",
    "category": "Architecture & Design",
    "url": "/docs/architecture-design/event-driven-architecture",
    "chunks": [
      {
        "id": "architecture-design/event-driven-architecture-chunk-0",
        "text": "Event-Driven Architecture\nOverview\nWhizbang is built on a universal event-driven architecture where all state changes flow through events, regardless of whether you're using Event-Driven or Event-Sourced mode This fundamental design principle enables seamless progression from simple applications to complex event-sourced systems without changing your core logic The Key Insight\nWrite through events, read through lenses This simple principle unifies all Whizbang applications:\nCommands flow to Receptors which make decisions\nReceptors emit Events representing those decisions  \nEvents flow to Perspectives which update views\nLenses provide read-only access to current state\nEvent-Driven vs Event-Sourced\nBoth modes use the same components and patterns The only difference is whether events are persisted:\n| Aspect | Event-Driven Mode | Event-Sourced Mode |\n|--------|-------------------|-------------------|\n| Events | Transient - drive immediate updates | Persisted - become source of truth |\n| Receptors | Stateless - get state from Lenses | Stateful - maintain state from event stream |\n| Perspectives | Execute inline with receptor | Execute async from event stream |\n| Ledger | Not used | Stores all events permanently |\n| Replay | Not possible | Can rebuild from events |\n| Transaction | Receptor + Perspective together | Event append is the transaction |\nCore Components\nReceptor\nPurpose: Receives commands, makes decisions, emits events\n`csharp\n// Same interface works in both modes public class OrderReceptor : IReceptor<CreateOrder> {\n    public OrderCreated Receive(CreateOrder cmd, IOrderLens lens) {\n        // Validate using lens (read-only view)\n        var customer = lens GetCustomer(cmd CustomerId);\n        if ( customer IsActive) {\n            throw new InactiveCustomerException();\n        }\n        // Make decision and emit event\n        return new OrderCreated(\n            Guid NewGuid(),\n            cmd CustomerId,\n            cmd Items,\n            DateTime",
        "startIndex": 0,
        "preview": "Event-Driven Architecture\nOverview\nWhizbang is built on a universal event-driven architecture where all state changes flow through events, regardless ..."
      },
      {
        "id": "architecture-design/event-driven-architecture-chunk-1",
        "text": "public class OrderReceptor : IReceptor<CreateOrder> { public OrderCreated Receive(CreateOrder cmd, IOrderLens lens) { // Validate using lens (read-only view) var customer = lens GetCustomer(cmd CustomerId); if ( customer IsActive) { throw new InactiveCustomerException(); } // Make decision and emit event return new OrderCreated( Guid NewGuid(), cmd CustomerId, cmd Items, DateTime UtcNow\n        );\n    }\n}\n`\nPerspective\nPurpose: Updates views and projections from events\n`csharp\n// Perspectives work identically in both modes\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        // Update database\n        await db Orders Add(new Order { \n            Id = e OrderId,\n            CustomerId = e CustomerId \n        });\n        // Update cache\n        await cache Invalidate($\"customer:{e CustomerId}\");\n        // Update search index\n        await search Index(e);\n    }\n}\n`\nLens\nPurpose: Provides read-only access to current state\n`csharp\n// Lenses provide consistent reads regardless of mode\npublic interface IOrderLens {\n    Order Focus(Guid id);                           // Get single item\n    IEnumerable<Order> View(Expression<Func<Order, bool>> filter);\n    OrderSummary Glimpse(Guid id);                  // Summary view\n    bool Exists(Guid id);                           // Quick check\n}\n`\nDispatcher\nPurpose: Routes commands to receptors and events to perspectives\n`csharp\npublic interface IDispatcher {\n    Task<TEvent> Dispatch<TEvent>(ICommand<TEvent> command);\n    Task Broadcast(IEvent @event);\n    Task<TResult> Query<TResult>(IQuery<TResult> query);\n}\n`\nThe Universal Pattern\nThis pattern works identically in both modes:\n`csharp\npublic class TransferMoneyReceptor : IReceptor<TransferMoney> {\n    public MoneyTransferred Receive(TransferMoney cmd, IAccountLens lens) {\n        // Read current state through lens\n        var fromAccount = lens Focus(cmd FromAccountId);\n        var toAccount = lens Focus(cmd ToAccountId);\n        // Make business decision\n        if (fromAccount Balance < cmd Amount) {\n            throw new InsufficientFundsException();\n        }\n        // Emit event - this IS the write operation\n        return new MoneyTransferred(\n            cmd FromAccountId,\n            cmd ToAccountId,\n            cmd Amount,\n            DateTime UtcNow\n        );\n    }\n}\npublic class AccountPerspective : IPerspectiveOf<MoneyTransferred> {\n    public async Task Update(MoneyTransferred e) {\n        // In Event-Driven: Direct database update\n        // In Event-Sourced: Update from replayed event\n        await db UpdateBalance(e FromAccountId, -e",
        "startIndex": 1992,
        "preview": "public class OrderReceptor : IReceptor<CreateOrder> { public OrderCreated Receive(CreateOrder cmd, IOrderLens lens) { // Validate using lens (read-onl..."
      },
      {
        "id": "architecture-design/event-driven-architecture-chunk-2",
        "text": "- this IS the write operation return new MoneyTransferred( cmd FromAccountId, cmd ToAccountId, cmd Amount, DateTime UtcNow ); } } public class AccountPerspective : IPerspectiveOf<MoneyTransferred> { public async Task Update(MoneyTransferred e) { // In Event-Driven: Direct database update // In Event-Sourced: Update from replayed event await db UpdateBalance(e FromAccountId, -e Amount);\n        await db UpdateBalance(e ToAccountId, e Amount);\n        await db AddTransaction(e);\n    }\n}\n`\nMode Selection via Policies\nConfigure behavior per-receptor using policies:\n`csharp\nservices AddWhizbang() UseDispatcher(dispatcher => {\n        // Default mode for all receptors\n        dispatcher DefaultPolicy = new EventDrivenPolicy();\n        // Specific receptors use event sourcing\n        dispatcher ForReceptor<PaymentReceptor>() UsePolicy(new EventSourcedPolicy());\n        dispatcher ForReceptor<AuditReceptor>() UsePolicy(new EventSourcedPolicy());\n        // Mix modes in same application });\n`\nEvolution Path\nPhase 1: Event-Driven (Stateless Receptors)\n`csharp\n// Stateless receptor gets state from lens\npublic class OrderReceptor : IReceptor<ShipOrder> {\n    public OrderShipped Receive(ShipOrder cmd, IOrderLens lens) {\n        var order = lens Focus(cmd OrderId);  // Get state from lens\n        if (order Status = \"Paid\") {\n            throw new InvalidOperationException(\"Order must be paid\");\n        }\n        return new OrderShipped(cmd OrderId, DateTime UtcNow);\n    }\n}\n`\nPhase 2: Event-Sourced (Stateful Receptors)\n`csharp\n// Same receptor, now stateful\n[EventSourced]\npublic class OrderReceptor : IReceptor<ShipOrder> {\n    private OrderStatus status;  // State maintained from events\n    public OrderShipped Receive(ShipOrder cmd) {\n        if (status = OrderStatus Paid) {  // Use internal state\n            throw new InvalidOperationException(\"Order must be paid\");\n        }\n        return new OrderShipped(Id, DateTime UtcNow);\n    }\n    // Apply events to maintain state\n    public void Absorb(OrderCreated e) => status = OrderStatus Created;\n    public void Absorb(OrderPaid e) => status = OrderStatus Paid;\n    public void Absorb(OrderShipped e) => status = OrderStatus",
        "startIndex": 4260,
        "preview": "- this IS the write operation return new MoneyTransferred( cmd FromAccountId, cmd ToAccountId, cmd Amount, DateTime UtcNow ); } } public class Account..."
      },
      {
        "id": "architecture-design/event-driven-architecture-chunk-3",
        "text": "{ // Use internal state throw new InvalidOperationException(\"Order must be paid\"); } return new OrderShipped(Id, DateTime UtcNow); } // Apply events to maintain state public void Absorb(OrderCreated e) => status = OrderStatus Created; public void Absorb(OrderPaid e) => status = OrderStatus Paid; public void Absorb(OrderShipped e) => status = OrderStatus Shipped;\n}\n`\nThe Flow\nEvent-Driven Mode\n`\nCommand → Dispatcher → Receptor → Event\n                           ↓\n                    Perspective → Database (immediate)\n                           ↓\n                        Lens → Queries\n`\nEvent-Sourced Mode\n`\nCommand → Dispatcher → Receptor → Event\n                           ↓\n                        Ledger (persist)\n                           ↓\n                    Perspective → Database (async)\n                           ↓\n                        Lens → Queries\n`\nKey Principles\nEvents Are The Write Model\nNo direct database writes All state changes flow through events:\n`csharp\n// ❌ WRONG - Direct database write\npublic void Handle(CreateOrder cmd) {\n    var order = new Order { };\n    database Orders Add(order);  // Don't do this database SaveChanges();\n}\n// ✅ RIGHT - Write through events\npublic OrderCreated Receive(CreateOrder cmd) {\n    return new OrderCreated( );  // Perspective handles the write\n}\n`\nLenses Are Read-Only\nLenses never modify state, they only observe:\n`csharp\n// ❌ WRONG - Lens with write methods\npublic interface IOrderLens {\n    void Save(Order order);  // Don't do this }\n// ✅ RIGHT - Read-only lens\npublic interface IOrderLens {\n    Order Focus(Guid id);\n    bool Exists(Guid id);\n}\n`\nPerspectives Handle All Writes\nAll database updates happen in perspectives:\n`csharp\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        // ALL writes happen here\n        await db Orders Add( );\n        await cache Set( );\n        await search Index(",
        "startIndex": 6113,
        "preview": "{ // Use internal state throw new InvalidOperationException(\"Order must be paid\"); } return new OrderShipped(Id, DateTime UtcNow); } // Apply events t..."
      },
      {
        "id": "architecture-design/event-driven-architecture-chunk-4",
        "text": "IOrderLens { Order Focus(Guid id); bool Exists(Guid id); } ` Perspectives Handle All Writes All database updates happen in perspectives: `csharp public class OrderPerspective : IPerspectiveOf<OrderCreated> { public async Task Update(OrderCreated e) { // ALL writes happen here await db Orders Add( ); await cache Set( ); await search Index( );\n    }\n}\n`\nBenefits\nImmediate Benefits (Event-Driven Mode)\nClear separation between reads and writes\nExplicit side effects - all changes visible as events\nNatural audit trail - events show what happened\nTestability - test receptors without database\nAdditional Benefits (Event-Sourced Mode)\nComplete history - every change is recorded\nTime travel - see state at any point in time\nEvent replay - rebuild projections from events\nDebugging - trace exactly what happened\nMigration Strategy\nMoving from Event-Driven to Event-Sourced is seamless:\n`csharp\n// Step 1: You're already Event-Driven\nservices AddWhizbang() UseDispatcher(d => d DefaultPolicy = new EventDrivenPolicy());\n// Step 2: Enable Event-Sourcing for specific receptors\nservices AddWhizbang() UseDispatcher(d => {\n        d DefaultPolicy = new EventDrivenPolicy();\n        d ForReceptor<Order>() UsePolicy(new EventSourcedPolicy());\n    });\n// Step 3: Gradually migrate more receptors\n// No code changes needed `\nReal-World Example\n`csharp\n// This receptor works in BOTH modes without changes\npublic class CheckoutReceptor : IReceptor<Checkout> {\n    public CheckoutCompleted Receive(Checkout cmd, ICheckoutLens lens) {\n        // Validate inventory\n        var inventory = lens GetInventory(cmd Items);\n        if ( inventory IsAvailable()) {\n            throw new OutOfStockException();\n        }\n        // Validate payment\n        var paymentMethod = lens GetPaymentMethod(cmd PaymentId);\n        if ( paymentMethod IsValid()) {\n            throw new InvalidPaymentException();\n        }\n        // Emit event - the perspective handles all writes\n        return new CheckoutCompleted(\n            Guid NewGuid(),\n            cmd CustomerId,\n            cmd Items,\n            cmd PaymentId,\n            DateTime UtcNow\n        );\n    }\n}\n// Multiple perspectives update different concerns\npublic class OrderPerspective : IPerspectiveOf<CheckoutCompleted> {\n    public async Task Update(CheckoutCompleted e) {\n        await db Orders Create(e OrderId, e CustomerId, e",
        "startIndex": 7715,
        "preview": "IOrderLens { Order Focus(Guid id); bool Exists(Guid id); } ` Perspectives Handle All Writes All database updates happen in perspectives: `csharp publi..."
      },
      {
        "id": "architecture-design/event-driven-architecture-chunk-5",
        "text": "Emit event - the perspective handles all writes return new CheckoutCompleted( Guid NewGuid(), cmd CustomerId, cmd Items, cmd PaymentId, DateTime UtcNow ); } } // Multiple perspectives update different concerns public class OrderPerspective : IPerspectiveOf<CheckoutCompleted> { public async Task Update(CheckoutCompleted e) { await db Orders Create(e OrderId, e CustomerId, e Items);\n    }\n}\npublic class InventoryPerspective : IPerspectiveOf<CheckoutCompleted> {\n    public async Task Update(CheckoutCompleted e) {\n        foreach (var item in e Items) {\n            await db Inventory Reserve(item ProductId, item Quantity);\n        }\n    }\n}\npublic class PaymentPerspective : IPerspectiveOf<CheckoutCompleted> {\n    public async Task Update(CheckoutCompleted e) {\n        await paymentGateway Charge(e PaymentId, e Total);\n    }\n}\n`\nSummary\nThe Event-Driven Architecture in Whizbang provides:\nUnified model - Same patterns for Event-Driven and Event-Sourced\nProgressive enhancement - Start simple, add event sourcing when needed\nNo rewrites - Same receptor code works in both modes\nMix and match - Use different modes for different aggregates\nClear semantics - Events for writes, lenses for reads\nThis architecture ensures that you're always thinking in events, whether you choose to persist them or not Next Steps\nLearn about Receptors - The universal command handler\nExplore Perspectives - Event-driven projections\nUnderstand Lenses - Read-only query interfaces\nSee Progressive Enhancement - Evolution strategies",
        "startIndex": 9758,
        "preview": "Emit event - the perspective handles all writes return new CheckoutCompleted( Guid NewGuid(), cmd CustomerId, cmd Items, cmd PaymentId, DateTime UtcNo..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "architecture-design/philosophy",
    "title": "Philosophy & Design Principles",
    "category": "Architecture & Design",
    "url": "/docs/architecture-design/philosophy",
    "chunks": [
      {
        "id": "architecture-design/philosophy-chunk-0",
        "text": "Philosophy & Design Principles\nWhizbang is a unified event-sourced data and messaging runtime for NET that collapses the complexity of MartenDB, Wolverine, MassTransit, and MediatR into a single cohesive platform with one mental model Core Philosophy\nEvents as the Source of Truth\nEvents are immutable facts that have happened In Whizbang, events are not just notifications—they are the authoritative record of everything that has occurred in your system All aggregates and projections can be rebuilt or reimagined from the event stream at any time, even years after initial deployment This approach provides:\nComplete audit trail - Every state change is recorded forever\nTime travel debugging - Replay events to understand how state evolved\nFlexible projections - Build new read models from existing events\nMigration freedom - Refactor your domain model without losing history\nSingle Surface Area\nTeams waste cognitive energy context-switching between different APIs, patterns, and abstractions Whizbang provides one set of primitives for:\nAggregates - Write-side domain models that enforce business rules\nProjections - Read-side models optimized for queries\nCommands - Requests to change state, routed to domain owners\nQueries - Requests for data, executed against projections\nSagas - Long-running processes that coordinate across domains\nAll of these concepts share the same handler model, dependency injection patterns, and testing approaches Learn once, apply everywhere One Runtime Any Mode Every Pattern Write your business logic once Run it anywhere Whizbang provides a unified mental model that scales from simple in-process messaging to complex distributed event-sourced systems—without changing your handlers `csharp\n// This SAME handler works across ALL modes\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Your business logic here\n        return new OrderCreated(cmd OrderId);\n    }\n}\n// Mode switching is just configuration\nservices AddWhizbang() UseInProcessMode();    // Development\nservices AddWhizbang() UseDurableMode();      // Single service\nservices AddWhizbang()",
        "startIndex": 0,
        "preview": "Philosophy & Design Principles\nWhizbang is a unified event-sourced data and messaging runtime for NET that collapses the complexity of MartenDB, Wolve..."
      },
      {
        "id": "architecture-design/philosophy-chunk-1",
        "text": "`csharp // This SAME handler works across ALL modes public class OrderHandler : IHandle<CreateOrder> { public OrderCreated Handle(CreateOrder cmd) { // Your business logic here return new OrderCreated(cmd OrderId); } } // Mode switching is just configuration services AddWhizbang() UseInProcessMode(); // Development services AddWhizbang() UseDurableMode(); // Single service services AddWhizbang() UseDistributedMode();  // Microservices\nservices AddWhizbang() UseEventSourcedMode(); // Event sourcing\n`\nReturn Type Semantics\nWhat you return determines what happens No configuration files, no routing tables, no ceremony Your intent is clear from your code:\n`csharp\n// Single return = single effect\nreturn new OrderCreated();                           // Publishes event\n// Tuple return = multiple effects\nreturn (new OrderCreated(), new ProcessPayment());   // Cascading messages\n// Result return = railway-oriented programming\nreturn Result Success(new OrderCreated());          // Success/failure handling\n// Streaming return = real-time processing\nyield return new OrderProcessed();                  // IAsyncEnumerable\n`\nAspect-Oriented by Design\nCross-cutting concerns are first-class citizens Through source generators and compile-time weaving, aspects like logging, retry, caching, and authorization are declarative and performant:\n`csharp\n[Logged]\n[Cached(Duration = \"5m\")]\n[Retry(3, Backoff = \"exponential\")]\n[Authorized(Role = \"Admin\")]\npublic class OrderHandler : IHandle<CreateOrder> {\n    [Pure] // Compile-time verification of no side effects\n    public OrderCreated Handle(CreateOrder cmd) {\n        // All aspects automatically applied\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nFrom Simple to Scale\nWhizbang is designed for the full spectrum:\nSimple Start: Use Whizbang as an in-process mediator for CQRS without any infrastructure dependencies Perfect for small apps or getting started Growth Path: Add event sourcing, projections, and persistence as your needs grow Every feature is opt-in Enterprise Scale: Deploy across microservices with message brokers, multiple databases, multi-region disaster recovery, and Kubernetes auto-scaling The same code works at every scale Your simple mediator handlers become distributed message handlers without rewrites Progressive Enhancement\nStart simple Add complexity only when needed",
        "startIndex": 2165,
        "preview": "`csharp // This SAME handler works across ALL modes public class OrderHandler : IHandle<CreateOrder> { public OrderCreated Handle(CreateOrder cmd) { /..."
      },
      {
        "id": "architecture-design/philosophy-chunk-2",
        "text": "as your needs grow Every feature is opt-in Enterprise Scale: Deploy across microservices with message brokers, multiple databases, multi-region disaster recovery, and Kubernetes auto-scaling The same code works at every scale Your simple mediator handlers become distributed message handlers without rewrites Progressive Enhancement Start simple Add complexity only when needed Every Whizbang application follows the same growth path:\nIn-Process - Simple mediator, no infrastructure\nDurable - Add persistence and retry\nDistributed - Scale across services\nEvent-Sourced - Full event sourcing when needed\nThe same handler code works at every level No rewrites as you scale Design Principles\nDriver-Based Architecture\nNever lock into a specific technology Whizbang uses a driver-based system for:\nPersistence - Postgres, SQL Server, MySQL, Cosmos DB, LiteFS/SQLite\nMessaging - Kafka, RabbitMQ, Azure Service Bus, AWS SQS, in-memory\nSerialization - JSON, Protobuf, MessagePack, custom formats\nObservability - OpenTelemetry, Application Insights, custom telemetry\nSwap drivers through configuration, not code changes Start with SQLite for local dev, move to Postgres in staging, scale to Cosmos DB in production—all with the same domain code Domain Ownership\nEvery event and command has a home In distributed systems, clarity about ownership prevents chaos:\nCommands are sent TO the domain that owns them\nEvents are emitted FROM the domain that owns them\nNew services can subscribe to events and backfill projections from the entire event stream\nDomain boundaries are explicit in code and configuration\nThis prevents the \"event spaghetti\" problem where no one knows who publishes what, or where to send commands Handlers as Pure Functions\nHandlers are just Cmethods that return results or new messages No magic base classes, no required interfaces (unless you want them), no framework coupling Mark a handler as pure and the Roslyn analyzer forbids hidden side effects—guaranteeing your handler is a true function from input to output",
        "startIndex": 4137,
        "preview": "as your needs grow Every feature is opt-in Enterprise Scale: Deploy across microservices with message brokers, multiple databases, multi-region disast..."
      },
      {
        "id": "architecture-design/philosophy-chunk-3",
        "text": "as Pure Functions Handlers are just Cmethods that return results or new messages No magic base classes, no required interfaces (unless you want them), no framework coupling Mark a handler as pure and the Roslyn analyzer forbids hidden side effects—guaranteeing your handler is a true function from input to output `csharp\n[Pure]\npublic OrderCalculated Calculate(CalculateOrder cmd) {\n    // ✅ Pure computation allowed\n    return new OrderCalculated(cmd Items Sum(i => i Price));\n    // ❌ Compile error: Side effects not allowed in pure handler\n    // await database SaveAsync(result);\n}\n`\nConvention Over Configuration\nYour code expresses intent through conventions Return types determine behavior Attributes declare aspects Source generators eliminate boilerplate No XML files, no complex registration, no ceremony `csharp\n// Return type determines what happens\npublic OrderCreated Handle(CreateOrder cmd) => new OrderCreated();        // Event\npublic ProcessPayment Handle(OrderCreated e) => new ProcessPayment();     // Command\npublic void Handle(LogActivity cmd) => Console WriteLine(cmd Message);   // Fire-and-forget\n// Attributes declare behavior\n[Idempotent]     // Automatic deduplication\n[Transactional]  // Wrap in transaction\n[Logged]         // Structured logging\n`\nObservable by Default\nProblems found in production are 10x more expensive than problems found in development Whizbang includes:\nOpenTelemetry traces for every message, event, and projection\nLive dashboard showing message lag, projection health, and error rates\nDistributed tracing across services and message brokers\nPerformance budgets that alert when handlers exceed latency targets\nObservability is not bolted on—it's built into the core runtime Idempotence Everywhere\nMessages may be delivered more than once Whizbang ensures:\nExactly-once semantics for event handling and projection updates\nAutomatic deduplication based on message IDs\nOutbox/Inbox pattern for reliable message delivery across service boundaries\nIdempotent consumers that can safely process the same event multiple times\nYour domain logic never needs to worry about duplicate messages Compile-Time Safety\nCatch errors during build, not at runtime",
        "startIndex": 5799,
        "preview": "as Pure Functions Handlers are just Cmethods that return results or new messages No magic base classes, no required interfaces (unless you want them),..."
      },
      {
        "id": "architecture-design/philosophy-chunk-4",
        "text": "event handling and projection updates Automatic deduplication based on message IDs Outbox/Inbox pattern for reliable message delivery across service boundaries Idempotent consumers that can safely process the same event multiple times Your domain logic never needs to worry about duplicate messages Compile-Time Safety Catch errors during build, not at runtime Through source generators and Roslyn analyzers, Whizbang provides unprecedented compile-time verification:\n`csharp\n[Pure]\npublic class CalculationHandler : IHandle<Calculate> {\n    public Result Handle(Calculate cmd) {\n        // ✅ Pure computation allowed\n        var result = cmd A + cmd B;\n        // ❌ Compile error: I/O not allowed in pure function\n        // await database SaveAsync(result);\n        return new Result(result);\n    }\n}\n[Effects(Writes = \"Orders\", Publishes = \"OrderEvents\")]\npublic class OrderHandler : IHandle<CreateOrder> {\n    // Source generator verifies declared effects match actual usage\n}\n`\nAOT-Safe and Performance-First\nModern NET demands performance Whizbang achieves both developer experience and runtime performance through:\nSource generation - Zero runtime reflection overhead\nNative AOT - Full trimming and AOT compilation support\nAssembly trimming - Only include what you use\nStruct messages - Stack allocation for small messages\nObject pooling - Automatic pooling of handlers and messages\nSIMD operations - Vectorized operations where applicable\nDeploy as a tiny container or serverless function without compromise Security and Multi-Tenancy First\nSecurity is not an afterthought Whizbang provides built-in support for:\nMulti-tenancy - Tenant isolation at the event stream, projection, and command level\nPermission scoping - Fine-grained authorization for commands, queries, and events\nTrusted/untrusted boundaries - Separate handling for internal vs external services\nAudit logging - Track who did what, when, and why\nData encryption - At-rest and in-transit encryption support\nMulti-tenant architecture:\nTenant ID propagated through all message contexts\nTenant-scoped event streams (e g , Tenant-{tenantId}-Order-{orderId})\nTenant-specific projections and read models\nCross-tenant operations prevented by default\nPermission model:\nCommands require explicit permissions (e",
        "startIndex": 7693,
        "preview": "event handling and projection updates Automatic deduplication based on message IDs Outbox/Inbox pattern for reliable message delivery across service b..."
      },
      {
        "id": "architecture-design/philosophy-chunk-5",
        "text": "logging - Track who did what, when, and why Data encryption - At-rest and in-transit encryption support Multi-tenant architecture: Tenant ID propagated through all message contexts Tenant-scoped event streams (e g , Tenant-{tenantId}-Order-{orderId}) Tenant-specific projections and read models Cross-tenant operations prevented by default Permission model: Commands require explicit permissions (e g , orders:place, inventory:reserve)\nQueries can be scoped to accessible data only\nEvents carry identity context for audit trails\nRoslyn analyzer enforces authorization checks\nService trust boundaries:\nInternal services (trusted) can access raw event streams\nExternal services (untrusted) receive filtered, sanitized events\nAPI gateways enforce authentication and authorization\nService-to-service authentication via mutual TLS or tokens\nOpinionated Recipes, Flexible Foundation\nWhizbang provides opinionated recipes to prevent analysis paralysis:\nStarter templates for common scenarios (web API, worker service, microservice)\nBest practice examples for aggregates, sagas, projections\nConvention-based configuration that \"just works\" out of the box\nBut under the hood, everything is pluggable:\nSwap drivers\nOverride conventions\nCustomize serialization\nExtend the pipeline\nYou're not locked into our opinions if your scenario demands something different Comparison to Existing Tools\nvs Marten + Wolverine (The \"Critter Stack\")\nWhat they are: Marten is a document database and event store for PostgreSQL Wolverine is a messaging and mediator framework Together they form the \"Critter Stack\"—the most mature CQRS/ES stack in NET as of 2025 Strengths:\nBattle-tested in production since 2016\nExcellent PostgreSQL integration with partitioning, snapshotting, and \"Quick Append\"\nFull OpenTelemetry and metrics support\n\"Aggregate handler workflow\" for clean CQRS\nWhizbang Differences:\nMulti-database: Marten is PostgreSQL-only Whizbang supports Postgres, SQL Server, MySQL, Cosmos DB, and SQLite through drivers Unified runtime: Marten + Wolverine are two separate libraries Whizbang is a single, cohesive runtime Domain ownership: Whizbang enforces explicit domain ownership for distributed systems (commands TO owner, events FROM owner)",
        "startIndex": 17,
        "preview": "logging - Track who did what, when, and why Data encryption - At-rest and in-transit encryption support Multi-tenant architecture: Tenant ID propagate..."
      },
      {
        "id": "architecture-design/philosophy-chunk-6",
        "text": "CQRS Whizbang Differences: Multi-database: Marten is PostgreSQL-only Whizbang supports Postgres, SQL Server, MySQL, Cosmos DB, and SQLite through drivers Unified runtime: Marten + Wolverine are two separate libraries Whizbang is a single, cohesive runtime Domain ownership: Whizbang enforces explicit domain ownership for distributed systems (commands TO owner, events FROM owner) Multi-tenancy first: Built-in tenant isolation at the event stream, projection, and command level Aspire integration: First-class NET Aspire support with one-command local dev setup Lakehouse streaming: Stream events to Delta Lake, Iceberg, or Parquet for analytics Dashboard: Dedicated web dashboard for message journey visualization and control plane When to choose Marten + Wolverine: You're committed to PostgreSQL and want the most mature, proven stack When to choose Whizbang: You need multi-database support, tighter integration, multi-tenancy, or advanced features like lakehouse streaming ---\nvs MediatR\nWhat it is: MediatR is a simple in-process mediator for implementing CQRS in a single application Used by thousands of NET projects Strengths:\nExtremely simple and lightweight\nNo infrastructure dependencies\nPerfect for monolithic applications\nMinimal learning curve\nWhizbang Differences:\nEvent sourcing: MediatR has no event sourcing Whizbang includes full event store support Projections: MediatR has no read model support Whizbang includes projection engine Distributed messaging: MediatR is in-process only Whizbang scales to microservices Growth path: With MediatR, scaling to distributed requires a complete rewrite With Whizbang, the same handler code works at every scale When to choose MediatR: You're building a simple monolith and will never need event sourcing or microservices When to choose Whizbang: You want a growth path from simple to complex without rewrites ---\nvs MassTransit\nWhat it is: MassTransit is a mature distributed messaging framework for NET Supports RabbitMQ, Azure Service Bus, Amazon SQS, and more Open source (Apache 2 0)",
        "startIndex": 11452,
        "preview": "CQRS Whizbang Differences: Multi-database: Marten is PostgreSQL-only Whizbang supports Postgres, SQL Server, MySQL, Cosmos DB, and SQLite through driv..."
      },
      {
        "id": "architecture-design/philosophy-chunk-7",
        "text": "never need event sourcing or microservices When to choose Whizbang: You want a growth path from simple to complex without rewrites --- vs MassTransit What it is: MassTransit is a mature distributed messaging framework for NET Supports RabbitMQ, Azure Service Bus, Amazon SQS, and more Open source (Apache 2 0) Strengths:\nMature message routing, retries, and error handling\nExcellent transport abstraction (RabbitMQ, Azure Service Bus, etc )\nSaga support for long-running processes\nFree for production use\nWhizbang Differences:\nEvent sourcing: MassTransit has no event sourcing Whizbang includes event store Projections: MassTransit has no read model support Whizbang includes projection engine All-in-one: MassTransit focuses on messaging Whizbang integrates messaging + event sourcing + projections Mediator: MassTransit requires a broker even for in-process Whizbang starts as a simple mediator When to choose MassTransit: You only need messaging and already have event sourcing/projections handled separately When to choose Whizbang: You want a unified platform for CQRS/ES with messaging built-in ---\nvs NServiceBus\nWhat it is: NServiceBus is the enterprise-grade service bus for NET from Particular Software The most feature-rich messaging framework Strengths:\nComprehensive tooling (ServicePulse, ServiceInsight for monitoring)\nEnterprise support and training available\nBattle-tested in large-scale systems\nAdvanced error handling and sagas\nWhizbang Differences:\nLicensing: NServiceBus requires paid license for production Whizbang is open source Event sourcing: NServiceBus has no event sourcing Whizbang includes event store Projections: NServiceBus has no read model engine Whizbang includes projection engine Dashboard: NServiceBus has separate tools (ServicePulse, ServiceInsight) Whizbang has integrated dashboard When to choose NServiceBus: You need enterprise support and are willing to pay for it When to choose Whizbang: You want open-source, all-in-one CQRS/ES with messaging ---\nvs Equinox\nWhat it is: Equinox is an event sourcing library from Jet com (Walmart) Supports CosmosDB, DynamoDB, EventStoreDB, and SqlStreamStore backends F#-first design",
        "startIndex": 13147,
        "preview": "never need event sourcing or microservices When to choose Whizbang: You want a growth path from simple to complex without rewrites --- vs MassTransit ..."
      },
      {
        "id": "architecture-design/philosophy-chunk-8",
        "text": "to choose NServiceBus: You need enterprise support and are willing to pay for it When to choose Whizbang: You want open-source, all-in-one CQRS/ES with messaging --- vs Equinox What it is: Equinox is an event sourcing library from Jet com (Walmart) Supports CosmosDB, DynamoDB, EventStoreDB, and SqlStreamStore backends F#-first design Strengths:\nPolyglot storage (CosmosDB, DynamoDB, EventStoreDB, etc )\nSophisticated caching strategies\nFunctional programming approach (Ffirst)\nLibrary, not framework (lightweight coupling)\nWhizbang Differences:\nC#-first: Equinox is F#-first Whizbang is designed for Cdevelopers Messaging: Equinox has no built-in messaging Whizbang includes distributed messaging Projections: Equinox requires separate Propulsion library Whizbang includes projection engine Dashboard: Equinox has no dashboard Whizbang includes web dashboard Aspire: Equinox has no Aspire integration Whizbang has first-class Aspire support When to choose Equinox: You're building in Fand want a lightweight library When to choose Whizbang: You're building in Cand want an integrated framework ---\nvs EventStoreDB\nWhat it is: EventStoreDB is a purpose-built event store database The gold standard for event sourcing since 2012 Strengths:\nPurpose-built for event sourcing\nProjections built into the database\nCatchup subscriptions and persistent subscriptions\nMature and proven\nWhizbang Differences:\nDatabase dependency: EventStoreDB is a separate database to run Whizbang works with databases you already have (Postgres, SQL Server, etc ) CQRS framework: EventStoreDB is just storage Whizbang includes mediator, messaging, projections, and dashboard Driver-based: Whizbang isn't locked to one database EventStoreDB is a single product When to choose EventStoreDB: You want the absolute best event store and are willing to run a dedicated database When to choose Whizbang: You want an all-in-one framework using databases you already have",
        "startIndex": 15032,
        "preview": "to choose NServiceBus: You need enterprise support and are willing to pay for it When to choose Whizbang: You want open-source, all-in-one CQRS/ES wit..."
      },
      {
        "id": "architecture-design/philosophy-chunk-9",
        "text": "mediator, messaging, projections, and dashboard Driver-based: Whizbang isn't locked to one database EventStoreDB is a single product When to choose EventStoreDB: You want the absolute best event store and are willing to run a dedicated database When to choose Whizbang: You want an all-in-one framework using databases you already have ---\nSummary Comparison\n| Feature | Whizbang | Marten + Wolverine | MediatR | MassTransit | NServiceBus | Equinox | EventStoreDB |\n|---------|----------|-------------------|---------|-------------|-------------|---------|--------------|\n| Event Sourcing | ✅ Built-in | ✅ Marten | ❌ | ❌ | ❌ | ✅ Library | ✅ Database |\n| Projections | ✅ Built-in | ✅ Marten | ❌ | ❌ | ❌ | ⚠️ Propulsion | ✅ Built-in |\n| Messaging | ✅ Built-in | ✅ Wolverine | ❌ | ✅ Core focus | ✅ Core focus | ❌ | ❌ |\n| Mediator | ✅ Built-in | ✅ Wolverine | ✅ Core focus | ⚠️ Via broker | ❌ | ❌ | ❌ |\n| Multi-database | ✅ Yes | ❌ Postgres only | N/A | N/A | N/A | ✅ Yes | ❌ Own DB |\n| Dashboard | ✅ Included | ❌ | ❌ | ❌ | ✅ Paid tools | ❌ | ✅ UI |\n| Multi-tenancy | ✅ First-class | ⚠️ Manual | ❌ | ❌ | ❌ | ❌ | ❌ |\n| Aspire | ✅ First-class | ⚠️ Community | ❌ | ⚠️ Community | ❌ | ❌ | ⚠️ Community |\n| License | 🟢 Open source | 🟢 Open source | 🟢 Open source | 🟢 Apache 2 0 | 🔴 Commercial | 🟢 Apache 2",
        "startIndex": 16658,
        "preview": "mediator, messaging, projections, and dashboard Driver-based: Whizbang isn't locked to one database EventStoreDB is a single product When to choose Ev..."
      },
      {
        "id": "architecture-design/philosophy-chunk-10",
        "text": "| ❌ | | Aspire | ✅ First-class | ⚠️ Community | ❌ | ⚠️ Community | ❌ | ❌ | ⚠️ Community | | License | 🟢 Open source | 🟢 Open source | 🟢 Open source | 🟢 Apache 2 0 | 🔴 Commercial | 🟢 Apache 2 0 | 🟡 Free/Paid |\n| Cvs F# | C#-first | C#-first | C#-first | C#-first | C#-first | F#-first | Language-agnostic |\nKey Insight: Whizbang is the only library that combines event sourcing, projections, messaging, mediator, multi-tenancy, and dashboard into a single, cohesive runtime with multi-database support Our Stance\nWe believe:\nEvents are more valuable than current state\nDomain ownership prevents distributed system chaos\nPure functions are easier to test and reason about\nObservability must be built in, not bolted on\nAOT and small binaries matter for modern deployments\nDevelopers should never be locked into a specific database or message broker\nSimple scenarios should stay simple; complex scenarios should be possible\nNext Steps\nNow that you understand Whizbang's philosophy and design principles:\nGetting Started - Build your first Whizbang application with a step-by-step tutorial\nPackage Structure - Learn about all available NuGet packages and their dependencies\nCore Concepts - Deep dive into commands, events, projections, and aggregates\nWe are building Whizbang to be the pit of success for event-sourced, message-driven systems in NET",
        "startIndex": 17625,
        "preview": "| ❌ | | Aspire | ✅ First-class | ⚠️ Community | ❌ | ⚠️ Community | ❌ | ❌ | ⚠️ Community | | License | 🟢 Open source | 🟢 Open source | 🟢 Open source..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "architecture-design/whizbang-unified-vision",
    "title": "Whizbang Unified Vision",
    "category": "Architecture & Design",
    "url": "/docs/architecture-design/whizbang-unified-vision",
    "chunks": [
      {
        "id": "architecture-design/whizbang-unified-vision-chunk-0",
        "text": "Whizbang Unified Vision\nOne Runtime Any Mode Every Pattern Whizbang represents a fundamental shift in how we think about messaging, events, and commands in NET Instead of choosing between different libraries for different needs, Whizbang provides one mental model that scales from simple in-process messaging to complex distributed event-sourced systems—without changing your code The Problem We Solve\nToday's NET developers face an impossible choice:\nMediatR for simple in-process messaging\nWolverine for performance and durability  \nMassTransit for distributed systems\nNServiceBus for enterprise features\nCustom solutions for event sourcing\nEach library requires different patterns, different abstractions, and different mental models Migrating between them means rewriting your entire application layer The Whizbang Solution: Progressive Enhancement\n`csharp\n// This SAME handler works across ALL modes\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd, IOrderRepository repo) {\n        var order = repo CreateOrder(cmd);\n        return new OrderCreated(order Id, order Total);\n    }\n}\n// Start simple (like MediatR)\nservices AddWhizbang() UseInProcessMode();\n// Add durability (like Wolverine) - SAME HANDLER\nservices AddWhizbang() UseDurableMode();\n// Scale to distributed (like MassTransit) - SAME HANDLER  \nservices AddWhizbang() UseDistributedMode();\n// Enable event sourcing (unique to Whizbang) - SAME HANDLER\nservices AddWhizbang() UseEventSourcedMode();\n`\nCore Philosophy\nOne Mental Model\nWrite your business logic once The same handlers, same patterns, and same abstractions work whether you're building a monolith or a distributed system Convention Over Configuration\nSmart defaults derived from the best practices of all major libraries Return types determine behavior Attributes declare aspects Source generators eliminate boilerplate Aspect-Oriented by Design\nCross-cutting concerns are first-class citizens, not afterthoughts Logging, retry, caching, authorization—all composable through a powerful aspect system Compile-Time Safety\nSource generators verify correctness at build time Pure functions are enforced Side effects are tracked Mistakes are caught before runtime Performance Without Compromise\nRuntime code generation like Wolverine Zero-allocation patterns Adaptive optimization",
        "startIndex": 0,
        "preview": "Whizbang Unified Vision\nOne Runtime Any Mode Every Pattern Whizbang represents a fundamental shift in how we think about messaging, events, and comman..."
      },
      {
        "id": "architecture-design/whizbang-unified-vision-chunk-1",
        "text": "concerns are first-class citizens, not afterthoughts Logging, retry, caching, authorization—all composable through a powerful aspect system Compile-Time Safety Source generators verify correctness at build time Pure functions are enforced Side effects are tracked Mistakes are caught before runtime Performance Without Compromise Runtime code generation like Wolverine Zero-allocation patterns Adaptive optimization The convenience of high-level abstractions with the performance of hand-tuned code Learning from the Best\nWhat We Take from Each Library\n| Library | What We Adopt | How We Improve |\n|---------|---------------|----------------|\n| MediatR | Simplicity, pipeline behaviors | Add durability without complexity |\n| Wolverine | Return type semantics, code generation | Extend to distributed scenarios |\n| MassTransit | State machines, routing | Simplify configuration |\n| Brighter | Policy attributes, command processor | Unify with aspects |\n| Rebus | Flexibility, defer patterns | Maintain simplicity at scale |\n| NServiceBus | Saga orchestration, monitoring | Open source with better DX |\nUnique Innovations\nReturn Type Semantics\n`csharp\npublic class OrderHandler {\n    // Single return = single effect\n    public OrderCreated Handle(CreateOrder cmd) => \n        new OrderCreated(cmd OrderId);\n    // Tuple return = multiple effects (cascading)\n    public (OrderCreated, ProcessPayment, SendEmail) HandleComplete(CreateOrder cmd) => \n        (new OrderCreated(), new ProcessPayment(), new SendEmail());\n    // Result return = validation with railway-oriented programming\n    public Result<OrderCreated> HandleWithValidation(CreateOrder cmd) =>\n        cmd IsValid() Result Success(new OrderCreated())\n            : Result Failure<OrderCreated>(\"Invalid order\");\n    // IAsyncEnumerable = streaming results\n    public async IAsyncEnumerable<OrderEvent> HandleBatch(ProcessBatch cmd) {\n        foreach (var item in cmd Items) {\n            yield return ProcessItem(item);\n        }\n    }\n    // Void = fire-and-forget\n    public void HandleNotification(NotifyUser cmd) => \n        Console",
        "startIndex": 2378,
        "preview": "concerns are first-class citizens, not afterthoughts Logging, retry, caching, authorization—all composable through a powerful aspect system Compile-Ti..."
      },
      {
        "id": "architecture-design/whizbang-unified-vision-chunk-2",
        "text": "with railway-oriented programming public Result<OrderCreated> HandleWithValidation(CreateOrder cmd) => cmd IsValid() Result Success(new OrderCreated()) : Result Failure<OrderCreated>(\"Invalid order\"); // IAsyncEnumerable = streaming results public async IAsyncEnumerable<OrderEvent> HandleBatch(ProcessBatch cmd) { foreach (var item in cmd Items) { yield return ProcessItem(item); } } // Void = fire-and-forget public void HandleNotification(NotifyUser cmd) => Console WriteLine(\"Notified\");\n}\n`\nAspect-Oriented Programming\n`csharp\n[Logged]\n[Timed]\n[Cached(Duration = \"5m\")]\n[Retry(3, Backoff = \"exponential\")]\n[Authorized(Role = \"Admin\")]\npublic class OrderHandler : IHandle<CreateOrder> {\n    [Pure] // Compile-time verification of no side effects\n    public OrderCreated Handle(CreateOrder cmd) {\n        // All aspects automatically applied via source generation\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nPure Functions with Effect Tracking\n`csharp\n[Pure] // Enforced at compile time\npublic OrderCalculated Calculate(Order order) {\n    // ✅ Pure computation allowed\n    return new OrderCalculated(order Items Sum(i => i Price));\n    // ❌ Compile error: I/O not allowed in pure function\n    // await database SaveAsync(order);\n}\n[Effects(Reads = \"Inventory\", Writes = \"Orders\", Publishes = \"OrderEvents\")]\npublic async Task<OrderCreated> Handle(CreateOrder cmd) {\n    // Effects are declared and tracked\n    var inventory = await ReadInventory();\n    var order = await WriteOrder(cmd);\n    await PublishEvent(new OrderCreated());\n    return order;\n}\n`\nCompile-Time Verification\n`csharp\n[EventSourced]\npublic class Order : Aggregate {\n    [Pure] // Verified: no side effects in event application\n    public void Apply(OrderCreated e) {\n        Id = e OrderId;\n        Total = e Total;\n        // await EmailService Send(); // ❌ Compile error\n    }\n    [Command]\n    public OrderShipped Ship(ShipOrder cmd) {\n        // Business logic with compile-time rule checking\n        if (Status = OrderStatus Paid) {\n            throw new InvalidOperationException(); // ⚠️ Warning: Consider Result<T>\n        }\n        return new OrderShipped(Id);\n    }\n}\n`\nArchitecture Modes\nMode 1: In-Process (Development/Monolith)\n`csharp\nservices AddWhizbang() UseInProcessMode() WithInMemoryStorage();\n`\nZero configuration\nImmediate execution\nPerfect for development\nNo infrastructure needed\nMode 2: Durable (Single Service)\n`csharp\nservices AddWhizbang() UseDurableMode() UsePostgreSQL(connectionString)",
        "startIndex": 4078,
        "preview": "with railway-oriented programming public Result<OrderCreated> HandleWithValidation(CreateOrder cmd) => cmd IsValid() Result Success(new OrderCreated()..."
      },
      {
        "id": "architecture-design/whizbang-unified-vision-chunk-3",
        "text": "OrderStatus Paid) { throw new InvalidOperationException(); // ⚠️ Warning: Consider Result<T> } return new OrderShipped(Id); } } ` Architecture Modes Mode 1: In-Process (Development/Monolith) `csharp services AddWhizbang() UseInProcessMode() WithInMemoryStorage(); ` Zero configuration Immediate execution Perfect for development No infrastructure needed Mode 2: Durable (Single Service) `csharp services AddWhizbang() UseDurableMode() UsePostgreSQL(connectionString) WithOutbox();\n`\nAutomatic persistence\nOutbox pattern\nRetry on failure\nTransaction support\nMode 3: Distributed (Microservices)\n`csharp\nservices AddWhizbang() UseDistributedMode() UseKafka(config) WithSagaOrchestration() WithDistributedTracing();\n`\nCross-service messaging\nSaga orchestration\nDistributed tracing\nMultiple transports\nMode 4: Event-Sourced (Event-Driven)\n`csharp\nservices AddWhizbang() UseEventSourcedMode() UseEventStore(config) WithProjections() WithSnapshots();\n`\nFull event sourcing\nAutomatic projections\nTime travel debugging\nCQRS patterns\nThe Developer Experience\nIDE Integration\n`csharp\n// IntelliSense knows about aspects and suggests appropriate ones\n[Wh| // IDE suggests: WhizbangHandler, WhizbangSaga, WhizbangProjection\npublic class OrderHandler {\n    // Type 'Handle' and IDE generates method with aspects\n    public Handle| // IDE template with return type options\n}\n`\nTesting Excellence\n`csharp\n[Test]\npublic async Task OrderHandler_CreatesOrder_WithAllAspects() {\n    await Whizbang Test<OrderHandler>() Given(new CreateOrder { }) WithAspects() // Test with production aspects WhenHandled() Then(result => result ShouldBeSuccess()) AndAspect<LoggingAspect>(logs => logs ShouldContain(\"Order created\")) AndAspect<MetricsAspect>(metrics => metrics[\"orders created\"] ShouldBe(1)) AndAspect<CacheAspect>(cache => cache ShouldHaveStored(\"order:123\"));\n}\n`\nObservability Built-In\n`csharp\n// Automatic OpenTelemetry integration\n[Observed]\npublic class OrderHandler {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Automatically generates:\n        // - Distributed trace spans\n        // - Metrics (count, duration, errors)\n        // - Structured logs\n        // - Health checks\n        return new OrderCreated();\n    }\n}\n`\nMigration Path\nFrom MediatR\n`csharp\n// Before (MediatR)\npublic class Handler : IRequestHandler<Command, Result> {\n    public Task<Result> Handle(Command request, CancellationToken ct) { }\n}\n// After (Whizbang) - Almost identical",
        "startIndex": 6137,
        "preview": "OrderStatus Paid) { throw new InvalidOperationException(); // ⚠️ Warning: Consider Result<T> } return new OrderShipped(Id); } } ` Architecture Modes M..."
      },
      {
        "id": "architecture-design/whizbang-unified-vision-chunk-4",
        "text": "// - Metrics (count, duration, errors) // - Structured logs // - Health checks return new OrderCreated(); } } ` Migration Path From MediatR `csharp // Before (MediatR) public class Handler : IRequestHandler<Command, Result> { public Task<Result> Handle(Command request, CancellationToken ct) { } } // After (Whizbang) - Almost identical public class Handler : IHandle<Command> {\n    public Result Handle(Command cmd) { }  // Simpler, no cancellation token\n}\n`\nFrom MassTransit\n`csharp\n// Before (MassTransit)\npublic class Consumer : IConsumer<Message> {\n    public async Task Consume(ConsumeContext<Message> context) { }\n}\n// After (Whizbang) - Cleaner, same power\npublic class Handler : IHandle<Message> {\n    public Response Handle(Message msg) { }  // Context available via aspects\n}\n`\nFrom Wolverine\n`csharp\n// Before (Wolverine)\npublic static class Handler {\n    public static Result Handle(Command cmd) { }\n}\n// After (Whizbang) - Same return type semantics",
        "startIndex": 8233,
        "preview": "// - Metrics (count, duration, errors) // - Structured logs // - Health checks return new OrderCreated(); } } ` Migration Path From MediatR `csharp //..."
      },
      {
        "id": "architecture-design/whizbang-unified-vision-chunk-5",
        "text": "- Cleaner, same power public class Handler : IHandle<Message> { public Response Handle(Message msg) { } // Context available via aspects } ` From Wolverine `csharp // Before (Wolverine) public static class Handler { public static Result Handle(Command cmd) { } } // After (Whizbang) - Same return type semantics public class Handler : IHandle<Command> {\n    public Result Handle(Command cmd) { }  // Return type still determines behavior\n}\n`\nPerformance Characteristics\n| Aspect | Implementation | Benefit |\n|--------|---------------|---------|\n| Source Generation | Compile-time code generation | Zero reflection overhead |\n| Struct Messages | Value types for small messages | Reduced allocations |\n| Object Pooling | Automatic for handlers and messages | Lower GC pressure |\n| SIMD Operations | Vectorized operations where applicable | Faster processing |\n| Adaptive Optimization | Runtime profiling and recompilation | Improves over time |\nComparison Matrix\n| Feature | Whizbang | MediatR | Wolverine | MassTransit | NServiceBus |\n|---------|----------|---------|-----------|-------------|-------------|\n| In-Process | ✅ | ✅ | ✅ | ✅ | ✅ |\n| Distributed | ✅ | ❌ | ✅ | ✅ | ✅ |\n| Event Sourcing | ✅ Native | ❌ | ⚠️ | ❌ | ⚠️ |\n| AOP | ✅ First-class | ⚠️ | ⚠️ | ⚠️ | ⚠️ |\n| Return Type Semantics | ✅ | ❌ | ✅ | ❌ | ❌ |\n| Source Generation | ✅ | ❌ | ✅ | ❌ | ❌ |\n| Pure Functions | ✅ | ❌ | ❌ | ❌ | ❌ |\n| Effect Tracking | ✅ | ❌ | ❌ | ❌ | ❌ |\n| Progressive Enhancement | ✅ | ❌ | ⚠️ | ⚠️ | ⚠️ |\n| Time Travel Testing | ✅ | ❌ | ❌ | ❌ | ❌ |\nSummary\nWhizbang is not just another messaging library—it's a unified platform that grows with your application",
        "startIndex": 8861,
        "preview": "- Cleaner, same power public class Handler : IHandle<Message> { public Response Handle(Message msg) { } // Context available via aspects } ` From Wolv..."
      },
      {
        "id": "architecture-design/whizbang-unified-vision-chunk-6",
        "text": "| ❌ | ❌ | | Progressive Enhancement | ✅ | ❌ | ⚠️ | ⚠️ | ⚠️ | | Time Travel Testing | ✅ | ❌ | ❌ | ❌ | ❌ | Summary Whizbang is not just another messaging library—it's a unified platform that grows with your application Start simple like MediatR, add durability like Wolverine, scale like MassTransit, and leverage event sourcing when you need it—all without changing your handlers or learning new patterns Write once Run anywhere Scale infinitely Next Steps\nSee Aspect-Oriented Programming for the AOP system\nLearn about Return Type Semantics \nExplore Progressive Enhancement\nRead the Getting Started guide",
        "startIndex": 10194,
        "preview": "| ❌ | ❌ | | Progressive Enhancement | ✅ | ❌ | ⚠️ | ⚠️ | ⚠️ | | Time Travel Testing | ✅ | ❌ | ❌ | ❌ | ❌ | Summary Whizbang is not just another messagin..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "commands/command-handling",
    "title": "Command Handling",
    "category": "Commands",
    "url": "/docs/commands/command-handling",
    "chunks": [
      {
        "id": "commands/command-handling-chunk-0",
        "text": "Command Handling\nCommands represent intent or actions in your system Command handlers contain business logic, validate commands, apply business rules, and emit events to record what happened CRITICAL: Events Can ONLY Be Emitted via Command Handling\nEvents are the result of command processing - they cannot be created directly You must send a command to emit an event `mermaid\nsequenceDiagram\n    participant User\n    participant API as API/Service\n    participant Handler as Command Handler\n    participant Context as CommandContext\n    participant EventStore as Event Store\n    participant Projection as Projections\n    User->>API: Send Command<br/>(PlaceOrder)\n    API->>Handler: Handle(command, context)\n    Note over Handler: ✅ Validate command<br/>✅ Apply business rules<br/>✅ Make decisions\n    Handler->>Context: EmitEvent(OrderPlaced)<br/>⚠️ ONLY way to create events\n    Context->>Context: Populate EventContext<br/>(user, tenant, timestamp)\n    Context->>EventStore: Append event\n    EventStore-->>Context: Event persisted\n    Context-->>Handler: Event emitted\n    Handler->>Context: Send(ReserveInventory)<br/>✅ Emit follow-up commands\n    Context->>API: Route command\n    Handler-->>API: Return event\n    API-->>User: Success\n    EventStore->>Projection: Notify subscribers\n    Note over Projection: ✅ Pure transformation<br/>❌ NO event emission\n`\nThis constraint ensures:\nSingle Source of Truth: All events originate from command handling - clear causation\nAuditability: Every event has a corresponding command that caused it\nAuthorization: Commands are the authorization boundary - validate before creating events\nBusiness Logic Encapsulation: Events are created only after business rules pass\nTransaction Boundary: Command handling is the transaction boundary for event emission\nEvent Context: CommandContext automatically populates EventContext metadata (user, tenant, etc",
        "startIndex": 0,
        "preview": "Command Handling\nCommands represent intent or actions in your system Command handlers contain business logic, validate commands, apply business rules,..."
      },
      {
        "id": "commands/command-handling-chunk-1",
        "text": "has a corresponding command that caused it Authorization: Commands are the authorization boundary - validate before creating events Business Logic Encapsulation: Events are created only after business rules pass Transaction Boundary: Command handling is the transaction boundary for event emission Event Context: CommandContext automatically populates EventContext metadata (user, tenant, etc )\nCommandContext Structure\n`csharp\npublic class CommandContext {\n    // Command metadata\n    public CommandMetadata Command { get; init; }\n    // Security context (from command initiator)\n    public SecurityContext Security { get; init; }\n    // Emit events - ONLY way to create events\n    public TEvent EmitEvent<TEvent>(TEvent @event) where TEvent : class;\n    // Emit follow-up commands\n    public Task Send<TCommand>(TCommand command, CancellationToken ct = default) where TCommand : class;\n    // Access to stores for reading (not writing - use events for that)\n    public IEventStore EventStore { get; init; }\n}\npublic class CommandMetadata {\n    public Guid CommandId { get; init; }\n    public string CommandType { get; init; }\n    public DateTime ReceivedAt { get; init; }\n    public Guid CorrelationId { get; init; }\n}\n`\nBasic Command Handler\n`csharp{\ntitle: \"Basic Command Handler with Event Emission\"\ndescription: \"Command handler that validates, applies business logic, and emits events\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"Command Handlers\", \"Events\", \"Business Logic\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n// ✅ CORRECT: Command handler contains business logic\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderPlaced> {\n    public async Task<OrderPlaced> Handle(\n        PlaceOrder command,\n        CommandContext context,  // ✅ Context for emitting events and commands\n        CancellationToken ct) {\n        // ✅ Business logic happens HERE\n        // - Validate the order\n        // - Check inventory\n        // - Calculate totals\n        // - Apply business rules\n        // - Decide if order should be marked as expired\n        var expiresAt = DateTime UtcNow",
        "startIndex": 1894,
        "preview": "has a corresponding command that caused it Authorization: Commands are the authorization boundary - validate before creating events Business Logic Enc..."
      },
      {
        "id": "commands/command-handling-chunk-2",
        "text": "// ✅ Context for emitting events and commands CancellationToken ct) { // ✅ Business logic happens HERE // - Validate the order // - Check inventory // - Calculate totals // - Apply business rules // - Decide if order should be marked as expired var expiresAt = DateTime UtcNow AddDays(90);  // ✅ Business decision\n        var isExpired = false;  // ✅ Business decision\n        var status = \"Placed\";   // ✅ Business decision\n        // ✅ Emit event via CommandContext - the ONLY way to create events\n        var @event = context EmitEvent(new OrderPlaced {\n            OrderId = command OrderId,\n            CustomerId = command CustomerId,\n            Total = command Total,\n            ExpiresAt = expiresAt,      // ✅ Set by handler\n            IsExpired = isExpired,       // ✅ Set by handler\n            Status = status              // ✅ Set by handler\n        });\n        return @event;\n    }\n}\n// ✅ CORRECT: Command is a POCO (Plain Old CLR Object)\npublic record PlaceOrder {\n    public Guid OrderId { get; init; }\n    public Guid CustomerId { get; init; }\n    public decimal Total { get; init; }\n    public List<OrderItem> Items { get; init; }\n}\n// ✅ CORRECT: Event is a POCO - describes what happened\npublic record OrderPlaced {\n    public Guid OrderId { get; init; }\n    public Guid CustomerId { get; init; }\n    public decimal Total { get; init; }\n    public DateTime ExpiresAt { get; init; }     // ✅ Data only (set by handler)\n    public bool IsExpired { get; init; }         // ✅ Data only (set by handler)\n    public string Status { get; init; }          // ✅ Data only (set by handler)\n    // ❌ NO business logic methods like:\n    // public bool ShouldExpire() => DateTime",
        "startIndex": 3797,
        "preview": "// ✅ Context for emitting events and commands CancellationToken ct) { // ✅ Business logic happens HERE // - Validate the order // - Check inventory //..."
      },
      {
        "id": "commands/command-handling-chunk-3",
        "text": "init; } // ✅ Data only (set by handler) public bool IsExpired { get; init; } // ✅ Data only (set by handler) public string Status { get; init; } // ✅ Data only (set by handler) // ❌ NO business logic methods like: // public bool ShouldExpire() => DateTime UtcNow > ExpiresAt;\n    // Events are immutable data - handlers make decisions, events record them\n}\npublic record OrderItem {\n    public Guid ProductId { get; init; }\n    public int Quantity { get; init; }\n}\n`\nWhat You CAN and CANNOT Do\n✅ In Command Handlers (Business Logic Layer)\n`csharp\n// ✅ CAN use DateTime UtcNow for business decisions\nvar expiresAt = DateTime UtcNow AddDays(90);\n// ✅ CAN use Random or Guid NewGuid()\nvar confirmationCode = Random Shared Next(100000, 999999);\n// ✅ CAN call external APIs\nvar customerData = await _customerService GetCustomerAsync(command CustomerId, ct);\n// ✅ CAN read from databases\nvar product = await _productRepository GetAsync(command ProductId, ct);\n// ✅ CAN perform calculations and validations\nif (command Total <= 0) {\n    throw new InvalidOperationException(\"Order total must be positive\");\n}\n// ✅ CAN make business decisions\nvar needsApproval = command Total > 10000;\nvar discount = customer IsPremium 0 10m : 0;\n// ✅ CAN emit events via CommandContext\nvar @event = context EmitEvent(new OrderPlaced { });\n// ✅ CAN emit follow-up commands via CommandContext\nawait context Send(new ReserveInventory { }, ct);\n`\n❌ Outside Command Handlers\n`csharp\n// ❌ CANNOT emit events directly - no CommandContext\npublic class SomeService {\n    private readonly IEventStore _eventStore;\n    public async Task DoSomething() {\n        // ❌ FORBIDDEN: Cannot create events outside of command handling\n        var @event = new OrderPlaced { };\n        await _eventStore AppendAsync(@event);  // 💥 Compile error - not allowed // ✅ CORRECT: Must send a command instead\n        await _whizbang Send(new PlaceOrder {",
        "startIndex": 5209,
        "preview": "init; } // ✅ Data only (set by handler) public bool IsExpired { get; init; } // ✅ Data only (set by handler) public string Status { get; init; } // ✅ ..."
      },
      {
        "id": "commands/command-handling-chunk-4",
        "text": "{ private readonly IEventStore _eventStore; public async Task DoSomething() { // ❌ FORBIDDEN: Cannot create events outside of command handling var @event = new OrderPlaced { }; await _eventStore AppendAsync(@event); // 💥 Compile error - not allowed // ✅ CORRECT: Must send a command instead await _whizbang Send(new PlaceOrder { });\n        // The command handler will emit the event via CommandContext\n    }\n}\n// ❌ CANNOT emit events from projections\n[WhizbangProjection]\npublic class BadProjection {\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        CancellationToken ct) {\n        // ❌ FORBIDDEN: Projections cannot emit events\n        // No CommandContext available - projections are read-side only\n        var newEvent = new OrderProcessed { };  // 💥 Cannot emit\n        // ✅ CORRECT: If you need to trigger something, emit a command\n        await _whizbang Send(new ProcessOrder { });\n        // The command handler will emit events\n    }\n}\n`\nCommand Emission (Sagas and Process Managers)\nHandlers can emit follow-up commands to coordinate workflows:\n`csharp{\ntitle: \"Command Emission in Handlers\"\ndescription: \"Emitting follow-up commands for workflow coordination\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"Sagas\", \"Workflows\", \"Process Managers\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n// Command handler emits both events and commands\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderPlaced> {\n    public async Task<OrderPlaced> Handle(\n        PlaceOrder command,\n        CommandContext context,\n        CancellationToken ct) {\n        // Business logic\n        var expiresAt = DateTime UtcNow AddDays(90);\n        // ✅ Emit event via CommandContext\n        var @event = context EmitEvent(new OrderPlaced {\n            OrderId = command OrderId,\n            CustomerId = command CustomerId,\n            Total = command Total,\n            ExpiresAt = expiresAt\n        });\n        // ✅ Emit follow-up commands to coordinate workflow\n        await context Send(new ReserveInventory {\n            OrderId = command OrderId,\n            Items = command Items\n        }, ct);\n        await context Send(new NotifyCustomer {\n            CustomerId = command",
        "startIndex": 6883,
        "preview": "{ private readonly IEventStore _eventStore; public async Task DoSomething() { // ❌ FORBIDDEN: Cannot create events outside of command handling var @ev..."
      },
      {
        "id": "commands/command-handling-chunk-5",
        "text": "EmitEvent(new OrderPlaced { OrderId = command OrderId, CustomerId = command CustomerId, Total = command Total, ExpiresAt = expiresAt }); // ✅ Emit follow-up commands to coordinate workflow await context Send(new ReserveInventory { OrderId = command OrderId, Items = command Items }, ct); await context Send(new NotifyCustomer { CustomerId = command CustomerId,\n            Message = \"Your order has been placed\"\n        }, ct);\n        return @event;\n    }\n}\n// Saga pattern - event handlers emit commands to orchestrate workflow\npublic class OrderSagaHandler : IEventHandler<OrderPlaced> {\n    private readonly IWhizbang _whizbang;\n    public async Task Handle(OrderPlaced @event, CancellationToken ct) {\n        // ✅ Event handler can emit commands (but NOT events)\n        // Step 1: Reserve inventory\n        await _whizbang Send(new ReserveInventory {\n            OrderId = @event OrderId,\n            Items = @event Items\n        }, ct);\n        // Step 2: Authorize payment\n        await _whizbang Send(new AuthorizePayment {\n            OrderId = @event OrderId,\n            Amount = @event Total,\n            CustomerId = @event CustomerId\n        }, ct);\n    }\n}\n`\nAggregate Command Handling\nAggregates can also emit events via CommandContext:\n`csharp{\ntitle: \"Aggregate Command Handling\"\ndescription: \"Using aggregates to handle commands and emit events\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"ADVANCED\"\ntags: [\"Aggregates\", \"Commands\", \"Events\", \"DDD\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\n// Aggregate can emit events via CommandContext\npublic class OrderAggregate : Aggregate {\n    private Guid _orderId;\n    private OrderStatus _status;\n    private List<OrderItem> _items = new();\n    public async Task PlaceOrder(PlaceOrder command, CommandContext context) {\n        // Apply business rules\n        if (_status = OrderStatus None) {\n            throw new InvalidOperationException(\"Order already placed\");\n        }\n        var expiresAt = DateTime UtcNow AddDays(90);\n        // ✅ Emit event via CommandContext\n        var @event = context EmitEvent(new OrderPlaced {\n            OrderId = command OrderId,\n            CustomerId = command CustomerId,\n            Total = command",
        "startIndex": 8990,
        "preview": "EmitEvent(new OrderPlaced { OrderId = command OrderId, CustomerId = command CustomerId, Total = command Total, ExpiresAt = expiresAt }); // ✅ Emit fol..."
      },
      {
        "id": "commands/command-handling-chunk-6",
        "text": "command, CommandContext context) { // Apply business rules if (_status = OrderStatus None) { throw new InvalidOperationException(\"Order already placed\"); } var expiresAt = DateTime UtcNow AddDays(90); // ✅ Emit event via CommandContext var @event = context EmitEvent(new OrderPlaced { OrderId = command OrderId, CustomerId = command CustomerId, Total = command Total,\n            ExpiresAt = expiresAt\n        });\n        // Apply event to aggregate state\n        Apply(@event);\n        // ✅ Aggregate can also emit follow-up commands via CommandContext\n        await context Send(new SendOrderConfirmationEmail {\n            OrderId = command OrderId,\n            CustomerEmail = command CustomerEmail\n        });\n    }\n    public async Task ShipOrder(ShipOrder command, CommandContext context) {\n        // Validate state\n        if (_status = OrderStatus Placed) {\n            throw new InvalidOperationException(\"Order cannot be shipped in current state\");\n        }\n        // ✅ Emit event via CommandContext\n        var @event = context EmitEvent(new OrderShipped {\n            OrderId = command OrderId,\n            TrackingNumber = command TrackingNumber\n        });\n        Apply(@event);\n        // ✅ Emit follow-up command\n        await context Send(new NotifyCustomerOfShipment {\n            OrderId = command OrderId,\n            TrackingNumber = command TrackingNumber\n        });\n    }\n    // Event handlers update aggregate state\n    private void Apply(OrderPlaced @event) {\n        _orderId = @event OrderId;\n        _status = OrderStatus Placed;\n    }\n    private void Apply(OrderShipped @event) {\n        _status = OrderStatus",
        "startIndex": 11060,
        "preview": "command, CommandContext context) { // Apply business rules if (_status = OrderStatus None) { throw new InvalidOperationException(\"Order already placed..."
      },
      {
        "id": "commands/command-handling-chunk-7",
        "text": "}); Apply(@event); // ✅ Emit follow-up command await context Send(new NotifyCustomerOfShipment { OrderId = command OrderId, TrackingNumber = command TrackingNumber }); } // Event handlers update aggregate state private void Apply(OrderPlaced @event) { _orderId = @event OrderId; _status = OrderStatus Placed; } private void Apply(OrderShipped @event) { _status = OrderStatus Shipped;\n    }\n}\npublic enum OrderStatus {\n    None,\n    Placed,\n    Shipped,\n    Delivered,\n    Cancelled\n}\n`\nUse Cases for Command Emission\nSagas / Process Managers: Orchestrate multi-step workflows across aggregates/services\nCommand Chaining: Break complex operations into smaller, coordinated commands\nSide Effects: Trigger notifications, emails, integrations\nCompensating Actions: Send rollback commands if a step fails\nDistributed Transactions: Coordinate actions across multiple bounded contexts\nWorkflow Automation: Trigger next steps in business processes\nSaga Workflow Example\n`mermaid\nsequenceDiagram\n    participant User\n    participant OrderService\n    participant OrderSaga\n    participant InventoryService\n    participant PaymentService\n    participant ShippingService\n    User->>OrderService: PlaceOrder Command\n    OrderService->>OrderService: Validate & Emit OrderPlaced Event\n    OrderService-->>User: Order Created\n    OrderService->>OrderSaga: OrderPlaced Event\n    Note over OrderSaga: Saga orchestrates<br/>multi-step workflow\n    OrderSaga->>InventoryService: ReserveInventory Command\n    InventoryService->>InventoryService: Reserve & Emit InventoryReserved\n    InventoryService-->>OrderSaga: Success\n    OrderSaga->>PaymentService: AuthorizePayment Command\n    PaymentService->>PaymentService: Authorize & Emit PaymentAuthorized\n    PaymentService-->>OrderSaga: Success\n    OrderSaga->>ShippingService: ScheduleShipment Command\n    ShippingService->>ShippingService: Schedule & Emit ShipmentScheduled\n    ShippingService-->>OrderSaga: Success\n    Note over OrderSaga: Workflow complete <br/>All steps succeeded\n    alt Payment Fails\n        PaymentService-->>OrderSaga: Payment Failed\n        OrderSaga->>InventoryService: ReleaseInventory Command\n        Note over OrderSaga: Compensating action<br/>rollback inventory\n    end\n`\nThe Three-Layer Architecture\n`mermaid\ngraph TB\n    subgraph BusinessLogic[\"Command Handler / Aggregate (Business Logic Layer)\"]\n        BL1[\"✅ Validates commands\"]\n        BL2[\"✅ Applies business rules\"]\n        BL3[\"✅ Makes decisions\"]\n        BL4[\"✅ Creates event POCOs with results\"]\n        BL5[\"✅ CAN emit commands (sagas)\"]\n        BL6[\"✅ CAN use DateTime UtcNow, Random, APIs\"]\n    end\n    subgraph DataLayer[\"Data Layer (POCOs - No Logic)\"]\n        Event[\"Event<br/>- Properties only<br/>- NO methods<br/>- Describes what happened\"]\n        Command[\"Command<br/>- Properties only<br/>- NO methods<br/>- Describes intent\"]\n    end\n    subgraph ReadModel[\"Projection (Read Model Layer)\"]\n        P1[\"✅ Pure transformation of event data\"]\n        P2[\"❌ NO business logic\"]\n        P3[\"❌ NO DateTime",
        "startIndex": 12346,
        "preview": "}); Apply(@event); // ✅ Emit follow-up command await context Send(new NotifyCustomerOfShipment { OrderId = command OrderId, TrackingNumber = command T..."
      },
      {
        "id": "commands/command-handling-chunk-8",
        "text": "(sagas)\"] BL6[\"✅ CAN use DateTime UtcNow, Random, APIs\"] end subgraph DataLayer[\"Data Layer (POCOs - No Logic)\"] Event[\"Event<br/>- Properties only<br/>- NO methods<br/>- Describes what happened\"] Command[\"Command<br/>- Properties only<br/>- NO methods<br/>- Describes intent\"] end subgraph ReadModel[\"Projection (Read Model Layer)\"] P1[\"✅ Pure transformation of event data\"] P2[\"❌ NO business logic\"] P3[\"❌ NO DateTime UtcNow, Random, APIs\"]\n        P4[\"✅ ONLY event data or EventContext\"]\n        P5[\"✅ Deterministic and replayable\"]\n    end\n    BusinessLogic -->|Emits Events| Event\n    BusinessLogic -->|Emits Commands| Command\n    Event -->|Consumed by| ReadModel\n    Command -->|Handled by| BusinessLogic\n    style BusinessLogic fill:#d4edda,stroke:#28a745,stroke-width:2px\n    style DataLayer fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    style ReadModel fill:#cce5ff,stroke:#004085,stroke-width:2px\n    style Event fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    style Command fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n`\nCommands vs Events vs Queries\n| Aspect | Command | Event | Query |\n|--------|---------|-------|-------|\n| Purpose | Express intent | Record what happened | Retrieve data |\n| Tense | Imperative (PlaceOrder) | Past tense (OrderPlaced) | Question (GetOrder) |\n| Business Logic | Handler contains logic | NO logic - POCO | NO logic - handler reads data |\n| Side Effects | YES - creates events | NO - immutable data | NO - read-only |\n| Can Fail | YES - validation errors | NO - fact that happened | NO - returns null/empty |\n| Emit Events | YES - via CommandContext | N/A | NO |\n| Emit Commands | YES - via CommandContext | Via event handlers | NO |\nValidation and Error Handling\n`csharp{\ntitle: \"Command Validation and Error Handling\"\ndescription: \"Proper validation and error handling in command handlers\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Validation\", \"Error Handling\", \"Commands\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading",
        "startIndex": 15006,
        "preview": "(sagas)\"] BL6[\"✅ CAN use DateTime UtcNow, Random, APIs\"] end subgraph DataLayer[\"Data Layer (POCOs - No Logic)\"] Event[\"Event<br/>- Properties only<br..."
      },
      {
        "id": "commands/command-handling-chunk-9",
        "text": "Error Handling `csharp{ title: \"Command Validation and Error Handling\" description: \"Proper validation and error handling in command handlers\" framework: \"NET8\" category: \"Commands\" difficulty: \"INTERMEDIATE\" tags: [\"Validation\", \"Error Handling\", \"Commands\"] nugetPackages: [\"Whizbang Core\"] usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading; using System Threading Tasks;\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderPlaced> {\n    private readonly IProductRepository _products;\n    private readonly ICustomerRepository _customers;\n    public PlaceOrderHandler(IProductRepository products, ICustomerRepository customers) {\n        _products = products;\n        _customers = customers;\n    }\n    public async Task<OrderPlaced> Handle(\n        PlaceOrder command,\n        CommandContext context,\n        CancellationToken ct) {\n        // ✅ Validate command data\n        if (command OrderId == Guid Empty) {\n            throw new ArgumentException(\"OrderId is required\", nameof(command OrderId));\n        }\n        if (command Items == null || command Items Count == 0) {\n            throw new ArgumentException(\"Order must have at least one item\", nameof(command Items));\n        }\n        // ✅ Validate business rules\n        var customer = await _customers GetAsync(command CustomerId, ct);\n        if (customer == null) {\n            throw new InvalidOperationException($\"Customer {command CustomerId} not found\");\n        }\n        if ( customer IsActive) {\n            throw new InvalidOperationException(\"Cannot place order for inactive customer\");\n        }\n        // ✅ Check availability\n        foreach (var item in command Items) {\n            var product = await _products GetAsync(item ProductId, ct);\n            if (product == null) {\n                throw new InvalidOperationException($\"Product {item ProductId} not found\");\n            }\n            if (product Stock < item Quantity) {\n                throw new InvalidOperationException(\n                    $\"Insufficient stock for product {product Name} \" +\n                    $\"Available: {product Stock}, Requested: {item Quantity}\");\n            }\n        }\n        // ✅ Calculate totals\n        decimal total = 0;\n        foreach (var item in command Items) {\n            var product = await _products GetAsync(item ProductId, ct);\n            total += product Price * item Quantity;\n        }\n        // ✅ Apply business rules\n        var discount = customer IsPremium total * 0 10m : 0;\n        var finalTotal = total - discount;\n        // ✅ Emit event with all business decisions made\n        var @event = context",
        "startIndex": 16735,
        "preview": "Error Handling `csharp{ title: \"Command Validation and Error Handling\" description: \"Proper validation and error handling in command handlers\" framewo..."
      },
      {
        "id": "commands/command-handling-chunk-10",
        "text": "product = await _products GetAsync(item ProductId, ct); total += product Price * item Quantity; } // ✅ Apply business rules var discount = customer IsPremium total * 0 10m : 0; var finalTotal = total - discount; // ✅ Emit event with all business decisions made var @event = context EmitEvent(new OrderPlaced {\n            OrderId = command OrderId,\n            CustomerId = command CustomerId,\n            Total = finalTotal,\n            Discount = discount,\n            ExpiresAt = DateTime UtcNow AddDays(90),\n            IsExpired = false,\n            Status = \"Placed\"\n        });\n        return @event;\n    }\n}\n`\nSummary\nEvents can ONLY be emitted via CommandContext during command handling\nCommand handlers contain business logic - validation, rules, decisions\nEvents are POCOs describing what happened (no logic)\nCommands are POCOs describing intent (no logic)\nHandlers can emit follow-up commands for sagas and workflows\nCommandContext provides authorization boundary - events created after validation\nProjections cannot emit events - they're read-side only\nNext Steps\nCommand Validation - Advanced validation patterns\nSagas and Process Managers - Workflow orchestration\nAggregates - Domain-driven design with aggregates\nProjection Purity - Maintaining pure projections",
        "startIndex": 4049,
        "preview": "product = await _products GetAsync(item ProductId, ct); total += product Price * item Quantity; } // ✅ Apply business rules var discount = customer Is..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "contributors/coding-standards",
    "title": "Coding Standards",
    "category": "Contributors",
    "url": "/docs/contributors/coding-standards",
    "chunks": [
      {
        "id": "contributors/coding-standards-chunk-0",
        "text": "Coding Standards\nWhizbang follows strict coding standards to ensure consistency, maintainability, and AOT compatibility EditorConfig\nAll code MUST follow the editorconfig rules in the repository Documentation examples follow CODE_SAMPLES editorconfig CVersion\nMinimum: C12\nTarget: Latest stable Cversion\nUse modern language features (pattern matching, records, file-scoped namespaces, etc )\nBrace Style\nUse K&R/Egyptian braces (opening brace on same line):\n`csharp\n// ✅ CORRECT - K&R/Egyptian style\npublic class Order {\n    public void Ship() {\n        if (Status == OrderStatus Placed) {\n            Status = OrderStatus Shipped;\n        }\n    }\n}\n// ❌ WRONG - Allman style\npublic class Order\n{\n    public void Ship()\n    {\n        if (Status == OrderStatus Placed)\n        {\n            Status = OrderStatus Shipped;\n        }\n    }\n}\n`\nNaming Conventions\nTypes\nPascalCase for classes, interfaces, records, enums, structs:\n`csharp\npublic class OrderProcessor { }\npublic interface IOrderRepository { }\npublic record OrderPlaced(Guid OrderId);\npublic enum OrderStatus { Placed, Shipped }\n`\nI-prefix for interfaces:\n`csharp\npublic interface IEventStore { }\npublic interface IProjection { }\n`\nMethods and Properties\nPascalCase:\n`csharp\npublic class Order {\n    public Guid Id { get; private set; }\n    public decimal Total { get; private set; }\n    public void Ship(string trackingNumber) {\n        // }\n}\n`\nAsync suffix for async methods:\n`csharp\npublic async Task<Order> GetOrderAsync(Guid orderId) {\n    // }\npublic async Task SaveAsync(Order order) {\n    // }\n`\nParameters and Local Variables\ncamelCase:\n`csharp\npublic void ProcessOrder(Guid orderId, List<OrderItem> items) {\n    var total = items Sum(i => i Price * i",
        "startIndex": 0,
        "preview": "Coding Standards\nWhizbang follows strict coding standards to ensure consistency, maintainability, and AOT compatibility EditorConfig\nAll code MUST fol..."
      },
      {
        "id": "contributors/coding-standards-chunk-1",
        "text": "// } } ` Async suffix for async methods: `csharp public async Task<Order> GetOrderAsync(Guid orderId) { // } public async Task SaveAsync(Order order) { // } ` Parameters and Local Variables camelCase: `csharp public void ProcessOrder(Guid orderId, List<OrderItem> items) { var total = items Sum(i => i Price * i Quantity);\n    var customerId = GetCustomerId(orderId);\n}\n`\nFields\n_camelCase (underscore prefix) for private fields:\n`csharp\npublic class OrderProcessor {\n    private readonly IOrderRepository _repository;\n    private readonly ILogger _logger;\n    public OrderProcessor(IOrderRepository repository, ILogger logger) {\n        _repository = repository;\n        _logger = logger;\n    }\n}\n`\nConstants\nALL_CAPS with underscores:\n`csharp\npublic class EventStoreConstants {\n    public const string DEFAULT_STREAM_PREFIX = \"whizbang-\";\n    public const int MAX_BATCH_SIZE = 1000;\n}\n`\nvar Keyword\nAlways use var for local variables when the type is obvious:\n`csharp\n// ✅ CORRECT\nvar order = new Order(customerId, items);\nvar total = items Sum(i => i Price);\nvar repository = serviceProvider GetRequiredService<IOrderRepository>();\n// ❌ WRONG\nOrder order = new Order(customerId, items);\ndecimal total = items Sum(i => i Price);\nIOrderRepository repository = serviceProvider GetRequiredService<IOrderRepository>();\n`\nException: Use explicit type when it aids clarity:\n`csharp\n// OK - explicit type makes intent clear\nIEnumerable<Order> activeOrders = GetOrders() Where(o => o IsActive);\n`\nFile-Scoped Namespaces\nAlways use file-scoped namespaces (C10+):\n`csharp\n// ✅ CORRECT\nusing System;\nusing Whizbang;\nnamespace MyApp Orders;\npublic class Order {\n    // }\n// ❌ WRONG\nusing System;\nusing Whizbang;\nnamespace MyApp Orders {\n    public class Order {\n        // }\n}\n`\nUsing Directives\nPlace outside namespace, System directives first:\n`csharp\n// ✅ CORRECT\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nnamespace MyApp Orders;\npublic class OrderService {\n    // }\n// ❌ WRONG - using inside namespace\nnamespace MyApp Orders {\n    using System;\n    using Whizbang;\n    public class OrderService {\n        //",
        "startIndex": 1741,
        "preview": "// } } ` Async suffix for async methods: `csharp public async Task<Order> GetOrderAsync(Guid orderId) { // } public async Task SaveAsync(Order order) ..."
      },
      {
        "id": "contributors/coding-standards-chunk-2",
        "text": "first: `csharp // ✅ CORRECT using System; using System Collections Generic; using System Threading Tasks; using Microsoft Extensions DependencyInjection; using Whizbang; namespace MyApp Orders; public class OrderService { // } // ❌ WRONG - using inside namespace namespace MyApp Orders { using System; using Whizbang; public class OrderService { // }\n}\n`\nRecords for DTOs and Events\nUse records for immutable data:\n`csharp\n// ✅ CORRECT - Events as records\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt);\npublic record PlaceOrder(Guid CustomerId, List<OrderItem> Items);\n// ❌ WRONG - Events as classes with setters\npublic class OrderPlaced {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    public DateTimeOffset PlacedAt { get; set; }\n}\n`\nNullable Reference Types\nEnable nullable reference types in all projects:\n`xml\n<PropertyGroup>\n    <Nullable>enable</Nullable>\n</PropertyGroup>\n`\nAnnotate nullability explicitly:\n`csharp\npublic class OrderRepository {\n    // Non-nullable - must never be null\n    private readonly IEventStore _eventStore;\n    // Nullable - can be null\n    private Order _cachedOrder;\n    public async Task<Order > FindAsync(Guid orderId) {\n        // Returns null if not found\n        return await _eventStore LoadAsync<Order>(orderId);\n    }\n    public async Task<Order> GetAsync(Guid orderId) {\n        // Throws if not found (non-nullable return)\n        var order = await FindAsync(orderId);\n        return order throw new OrderNotFoundException(orderId);\n    }\n}\n`\nException Handling\nThrow Specific Exceptions\n`csharp\n// ✅ CORRECT\nthrow new OrderNotFoundException(orderId);\nthrow new InvalidOperationException(\"Cannot ship a cancelled order\");\n// ❌ WRONG\nthrow new Exception(\"Order not found\");\n`\nDon't Swallow Exceptions\n`csharp\n// ✅ CORRECT\ntry {\n    await processor ProcessAsync(order);\n} catch (InvalidOrderException ex) {\n    _logger LogError(ex, \"Order validation failed: {OrderId}\", order Id);\n    throw;  // Re-throw to propagate\n}\n// ❌ WRONG\ntry {\n    await processor ProcessAsync(order);\n} catch {\n    // Silent failure - very bad",
        "startIndex": 3655,
        "preview": "first: `csharp // ✅ CORRECT using System; using System Collections Generic; using System Threading Tasks; using Microsoft Extensions DependencyInjecti..."
      },
      {
        "id": "contributors/coding-standards-chunk-3",
        "text": "found\"); ` Don't Swallow Exceptions `csharp // ✅ CORRECT try { await processor ProcessAsync(order); } catch (InvalidOrderException ex) { _logger LogError(ex, \"Order validation failed: {OrderId}\", order Id); throw; // Re-throw to propagate } // ❌ WRONG try { await processor ProcessAsync(order); } catch { // Silent failure - very bad }\n`\nUse Specific Catches\n`csharp\n// ✅ CORRECT\ntry {\n    await SaveAsync(order);\n} catch (DbUpdateConcurrencyException ex) {\n    throw new OptimisticConcurrencyException(\"Order was modified\", ex);\n} catch (DbException ex) {\n    _logger LogError(ex, \"Database error saving order\");\n    throw;\n}\n// ❌ WRONG - catching everything\ntry {\n    await SaveAsync(order);\n} catch (Exception ex) {\n    _logger LogError(ex, \"Error\");\n    throw;\n}\n`\nAsync/Await\nAlways Async All the Way\n`csharp\n// ✅ CORRECT\npublic async Task<Order> GetOrderAsync(Guid orderId) {\n    var events = await _eventStore LoadStreamAsync($\"Order-{orderId}\");\n    return await ReconstructAsync(events);\n}\n// ❌ WRONG - mixing sync and async\npublic Order GetOrder(Guid orderId) {\n    var events = _eventStore LoadStreamAsync($\"Order-{orderId}\") Result;  // Deadlock risk return ReconstructAsync(events) Result;\n}\n`\nUse ConfigureAwait(false) in Libraries\n`csharp\n// ✅ CORRECT - library code\npublic async Task SaveAsync(Order order) {\n    var events = order GetUncommittedEvents();\n    await _eventStore AppendAsync(streamId, events) ConfigureAwait(false);\n}\n// Application code can omit ConfigureAwait\n`\nAOT Compatibility\nNever use reflection that breaks AOT:\n`csharp\n// ❌ WRONG - breaks AOT\nvar type = Type GetType(\"MyApp Orders Order\");\nvar instance = Activator CreateInstance(type);\n// ✅ CORRECT - use source generators\n[GenerateHandlers]  // Source generator creates handler registry\npublic partial class HandlerRegistry { }\n`\nUse generic constraints instead of runtime type checks:\n`csharp\n// ❌ WRONG\npublic void Process(object message) {\n    if (message GetType() == typeof(PlaceOrder)) {\n        //",
        "startIndex": 5448,
        "preview": "found\"); ` Don't Swallow Exceptions `csharp // ✅ CORRECT try { await processor ProcessAsync(order); } catch (InvalidOrderException ex) { _logger LogEr..."
      },
      {
        "id": "contributors/coding-standards-chunk-4",
        "text": "var instance = Activator CreateInstance(type); // ✅ CORRECT - use source generators [GenerateHandlers] // Source generator creates handler registry public partial class HandlerRegistry { } ` Use generic constraints instead of runtime type checks: `csharp // ❌ WRONG public void Process(object message) { if (message GetType() == typeof(PlaceOrder)) { // }\n}\n// ✅ CORRECT\npublic void Process<TMessage>(TMessage message) where TMessage : class {\n    // Compile-time type safety\n}\n`\nDependency Injection\nConstructor Injection\n`csharp\n// ✅ CORRECT\npublic class OrderService {\n    private readonly IOrderRepository _repository;\n    private readonly IEventPublisher _publisher;\n    public OrderService(IOrderRepository repository, IEventPublisher publisher) {\n        _repository = repository;\n        _publisher = publisher;\n    }\n}\n// ❌ WRONG - property injection\npublic class OrderService {\n    public IOrderRepository Repository { get; set; }\n}\n`\nRegister Services Explicitly\n`csharp\n// ✅ CORRECT - explicit registration\nservices AddScoped<IOrderRepository, OrderRepository>();\nservices AddSingleton<IEventStore, PostgresEventStore>();\n// ❌ WRONG - magic scanning that breaks AOT\nservices Scan(scan => scan FromAssemblyOf<Order>() AddClasses() AsImplementedInterfaces());\n`\nPerformance\nUse ValueTask for Hot Paths\n`csharp\n// ✅ CORRECT - high-frequency method\npublic ValueTask<bool> TryGetFromCacheAsync(string key) {\n    if (_cache TryGetValue(key, out var value)) {\n        return new ValueTask<bool>(true);  // Synchronous completion\n    }\n    return LoadFromDatabaseAsync(key);  // Async completion\n}\n`\nAvoid Allocations in Hot Paths\n`csharp\n// ✅ CORRECT - reuse span/memory\npublic void ProcessEvents(ReadOnlySpan<Event> events) {\n    foreach (var @event in events) {\n        // Process without allocation\n    }\n}\n// ❌ WRONG - allocates array\npublic void ProcessEvents(Event[] events) {\n    // }\n`\nTesting Conventions\nTest Method Naming\nFormat: MethodName_Scenario_ExpectedBehavior\n`csharp\n[Fact]\npublic void Ship_WhenOrderIsPlaced_UpdatesStatusToShipped() {\n    // Arrange\n    var order = new Order(customerId, items);\n    // Act\n    order Ship(trackingNumber);\n    // Assert\n    order Status Should() Be(OrderStatus Shipped);\n}\n[Fact]\npublic void Ship_WhenOrderIsCancelled_ThrowsInvalidOperationException() {\n    // Arrange\n    var order = new Order(customerId, items);\n    order Cancel(\"Customer requested\");\n    // Act & Assert\n    var act = () => order Ship(trackingNumber);\n    act Should()",
        "startIndex": 7124,
        "preview": "var instance = Activator CreateInstance(type); // ✅ CORRECT - use source generators [GenerateHandlers] // Source generator creates handler registry pu..."
      },
      {
        "id": "contributors/coding-standards-chunk-5",
        "text": "{ // Arrange var order = new Order(customerId, items); // Act order Ship(trackingNumber); // Assert order Status Should() Be(OrderStatus Shipped); } [Fact] public void Ship_WhenOrderIsCancelled_ThrowsInvalidOperationException() { // Arrange var order = new Order(customerId, items); order Cancel(\"Customer requested\"); // Act & Assert var act = () => order Ship(trackingNumber); act Should() Throw<InvalidOperationException>();\n}\n`\nUse FluentAssertions\n`csharp\n// ✅ CORRECT - readable assertions\nresult Should() NotBeNull();\nresult OrderId Should() Be(expectedId);\nresult Items Should() HaveCount(2);\n// ❌ WRONG - xUnit asserts (less readable)\nAssert NotNull(result);\nAssert Equal(expectedId, result OrderId);\nAssert Equal(2, result Items Count);\n`\nComments\nExplain Why, Not What\n`csharp\n// ✅ CORRECT - explains non-obvious decision\n// Use pessimistic locking here because optimistic concurrency\n// causes too many retries under high contention\nawait _connection ExecuteAsync(\"SELECT FOR UPDATE\");\n// ❌ WRONG - states the obvious\n// Get the order\nvar order = await GetOrderAsync(orderId);\n`\nXML Documentation for Public APIs\n`csharp\n/// <summary>\n/// Appends events to an aggregate stream with optimistic concurrency /// </summary>\n/// <param name=\"streamId\">The unique identifier for the event stream </param>\n/// <param name=\"events\">The events to append </param>\n/// <param name=\"expectedVersion\">\n/// The expected current version of the stream If the actual version\n/// does not match, throws <see cref=\"ConcurrencyException\"/> /// </param>\n/// <exception cref=\"ConcurrencyException\">\n/// Thrown when the stream has been modified since it was loaded /// </exception>\npublic async Task AppendAsync(string streamId, IEnumerable<object> events, long expectedVersion) {\n    // }\n`\nAnalyzer Configuration\nWhizbang uses Roslyn analyzers to enforce standards",
        "startIndex": 9272,
        "preview": "{ // Arrange var order = new Order(customerId, items); // Act order Ship(trackingNumber); // Assert order Status Should() Be(OrderStatus Shipped); } [..."
      },
      {
        "id": "contributors/coding-standards-chunk-6",
        "text": "actual version /// does not match, throws <see cref=\"ConcurrencyException\"/> /// </param> /// <exception cref=\"ConcurrencyException\"> /// Thrown when the stream has been modified since it was loaded /// </exception> public async Task AppendAsync(string streamId, IEnumerable<object> events, long expectedVersion) { // } ` Analyzer Configuration Whizbang uses Roslyn analyzers to enforce standards Key rules:\nWBZ001: Command/event must have [OwnedBy] attribute\nWBZ002: Handler marked [Pure] must not have side effects\nWBZ003: Async method must have Async suffix\nWBZ004: Event must be immutable (record or readonly properties)\nSuppress warnings only when absolutely necessary:\n`csharp\n#pragma warning disable WBZ001 // Justification: Internal command, ownership not needed\npublic record InternalCleanupCommand();\n#pragma warning restore WBZ001\n`\nSummary Checklist\nBefore submitting code, verify:\n[ ] K&R/Egyptian braces used\n[ ] var used for local variables\n[ ] File-scoped namespaces\n[ ] Nullable reference types enabled and annotated\n[ ] Async methods have Async suffix\n[ ] No reflection that breaks AOT\n[ ] All public APIs have XML documentation\n[ ] Tests follow naming convention\n[ ] Code passes all analyzer rules\nQuestions If you're unsure about any convention, ask in GitHub Discussions",
        "startIndex": 10749,
        "preview": "actual version /// does not match, throws <see cref=\"ConcurrencyException\"/> /// </param> /// <exception cref=\"ConcurrencyException\"> /// Thrown when ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "contributors/contributing",
    "title": "Contributing to Whizbang",
    "category": "Contributors",
    "url": "/docs/contributors/contributing",
    "chunks": [
      {
        "id": "contributors/contributing-chunk-0",
        "text": "Contributing to Whizbang\nThank you for your interest in contributing to Whizbang This guide will help you get started Code of Conduct\nWe are committed to providing a welcoming and inclusive environment Please read and follow our Code of Conduct Ways to Contribute\n🐛 Report Bugs\nFound a bug Open an issue with:\nClear description of the problem\nSteps to reproduce\nExpected vs actual behavior\nWhizbang version and NET version\nRelevant code samples\n💡 Suggest Features\nHave an idea Start a discussion to:\nDescribe the use case\nExplain why existing features don't solve it\nPropose an API design\nDiscuss tradeoffs and alternatives\n📝 Improve Documentation\nDocumentation improvements are always welcome:\nFix typos or unclear explanations\nAdd missing examples\nImprove code samples\nTranslate to other languages\nDocumentation lives in this repository at src/assets/docs/ 🔨 Submit Code\nReady to code Great Please:\nDiscuss first - For non-trivial changes, open an issue or discussion first\nFollow conventions - See Coding Standards\nWrite tests - All new features need tests\nUpdate docs - Documentation is part of the PR, not an afterthought\nKeep it focused - One feature/fix per PR\nDevelopment Setup\nPrerequisites NET 8 0 SDK or later\nDocker (for running test databases)\nGit\nYour favorite IDE (Visual Studio, Rider, VS Code)\nClone the Repository\n`bash\ngit clone https://github com/whizbang-lib/whizbang git\ncd whizbang\n`\nBuild the Solution\n`bash\ndotnet build\n`\nRun Tests\n`bash\nRun all tests\ndotnet test\nRun with coverage\ndotnet test /p:CollectCoverage=true\n`\nStart Local Infrastructure\nFor integration tests, you'll need Postgres and Kafka:\n`bash\ndocker-compose up -d\n`\nThis starts:\nPostgres on localhost:5432\nKafka on localhost:9092\nZookeeper on localhost:2181\nProject Structure\n`\nwhizbang/\n├── src/\n│   ├── Whizbang Core/              Core mediator and messaging\n│   ├── Whizbang EventSourcing/     Event store and aggregates\n│   ├── Whizbang",
        "startIndex": 0,
        "preview": "Contributing to Whizbang\nThank you for your interest in contributing to Whizbang This guide will help you get started Code of Conduct\nWe are committed..."
      },
      {
        "id": "contributors/contributing-chunk-1",
        "text": "Infrastructure For integration tests, you'll need Postgres and Kafka: `bash docker-compose up -d ` This starts: Postgres on localhost:5432 Kafka on localhost:9092 Zookeeper on localhost:2181 Project Structure ` whizbang/ ├── src/ │ ├── Whizbang Core/ Core mediator and messaging │ ├── Whizbang EventSourcing/ Event store and aggregates │ ├── Whizbang Projections/       Projection engine\n│   ├── Whizbang Messaging/         Distributed messaging\n│   ├── Whizbang Postgres/          Postgres driver\n│   ├── Whizbang Kafka/             Kafka driver\n│   ├── Whizbang OpenTelemetry/     Observability\n│   └── Whizbang Analyzers/         Roslyn analyzers\n├── tests/\n│   ├── Whizbang Core Tests/\n│   ├── Whizbang EventSourcing Tests/\n│   ├── Integration Tests/          Multi-package integration tests\n│   └── Documentation/              Tests for documentation examples\n├── samples/\n│   ├── SimpleMediator/             Basic mediator sample\n│   ├── EventSourcedMonolith/       Event sourcing sample\n│   └── Microservices/              Distributed messaging sample\n└── docs/\n    └── (Documentation website - separate repo)\n`\nBranching Strategy\nmain - Stable, released code\ndevelop - Active development\nfeature/xyz - New features (branch from develop)\nfix/xyz - Bug fixes (branch from develop or main for hotfixes)\nPull Request Process\nCreate a Branch\n`bash\ngit checkout develop\ngit pull origin develop\ngit checkout -b feature/my-awesome-feature\n`\nMake Changes\nWrite code following Coding Standards\nAdd tests for new functionality\nUpdate documentation\nEnsure all tests pass\nCommit Changes\nWe use Conventional Commits:\n`bash\ngit commit -m \"feat: add support for SQL Server driver\"\ngit commit -m \"fix: correct optimistic concurrency check\"\ngit commit -m \"docs: add examples for projections\"\n`\nCommit types:\nfeat: - New feature\nfix: - Bug fix\ndocs: - Documentation changes\ntest: - Adding or updating tests\nrefactor: - Code refactoring\nperf: - Performance improvements\nchore: - Build/tooling changes\nPush and Create PR\n`bash\ngit push origin feature/my-awesome-feature\n`\nThen open a PR on GitHub targeting develop branch PR Review\nMaintainers will review your PR",
        "startIndex": 1946,
        "preview": "Infrastructure For integration tests, you'll need Postgres and Kafka: `bash docker-compose up -d ` This starts: Postgres on localhost:5432 Kafka on lo..."
      },
      {
        "id": "contributors/contributing-chunk-2",
        "text": "Bug fix docs: - Documentation changes test: - Adding or updating tests refactor: - Code refactoring perf: - Performance improvements chore: - Build/tooling changes Push and Create PR `bash git push origin feature/my-awesome-feature ` Then open a PR on GitHub targeting develop branch PR Review Maintainers will review your PR Please:\nRespond to feedback promptly\nMake requested changes\nKeep the PR focused (split large PRs if needed)\nBe patient - we review PRs as quickly as we can\nMerge\nOnce approved, a maintainer will merge your PR Congrats 🎉\nTesting Guidelines\nUnit Tests\nTest individual classes in isolation\nUse mocks for dependencies\nFast execution (<100ms per test)\nLocated in * Tests projects\nExample:\n`csharp\npublic class OrderTests {\n    [Fact]\n    public void PlaceOrder_WithValidItems_EmitsOrderPlacedEvent() {\n        // Arrange\n        var order = new Order(customerId, items);\n        // Act\n        var events = order GetUncommittedEvents();\n        // Assert\n        var placed = events Should() ContainSingle() Which Should() BeOfType<OrderPlaced>();\n        placed CustomerId Should() Be(customerId);\n    }\n}\n`\nIntegration Tests\nTest multiple components together\nUse real databases (Docker containers)\nSlower execution (can be seconds)\nLocated in Integration Tests project\nExample:\n`csharp\npublic class EventStoreIntegrationTests : IClassFixture<PostgresFixture> {\n    [Fact]\n    public async Task AppendAndLoad_RoundTrip_PreservesEvents() {\n        // Arrange\n        var store = new PostgresEventStore(connectionString);\n        var events = new[] { new OrderPlaced( ), new OrderShipped( ) };\n        // Act\n        await store AppendAsync(\"Order-123\", events);\n        var loaded = await store LoadStreamAsync(\"Order-123\");\n        // Assert\n        loaded Should() BeEquivalentTo(events);\n    }\n}\n`\nDocumentation Tests\nCRITICAL: All complete code examples in documentation MUST have corresponding tests Located in tests/Documentation/, these tests:\nExtract code from documentation\nVerify examples compile\nValidate examples actually work\nPrevent documentation from becoming stale\nSee Test-Driven Examples for details Documentation Standards\nAll Code Examples Must:\nInclude complete using statements\nFollow CODE_SAMPLES editorconfig (K&R/Egyptian braces)\nUse Cnaming conventions (PascalCase, camelCase, etc",
        "startIndex": 3748,
        "preview": "Bug fix docs: - Documentation changes test: - Adding or updating tests refactor: - Code refactoring perf: - Performance improvements chore: - Build/to..."
      },
      {
        "id": "contributors/contributing-chunk-3",
        "text": "have corresponding tests Located in tests/Documentation/, these tests: Extract code from documentation Verify examples compile Validate examples actually work Prevent documentation from becoming stale See Test-Driven Examples for details Documentation Standards All Code Examples Must: Include complete using statements Follow CODE_SAMPLES editorconfig (K&R/Egyptian braces) Use Cnaming conventions (PascalCase, camelCase, etc )\nBe compilable - No pseudo-code or placeholders\nInclude metadata for enhanced code blocks\nExample Format\nmarkdown\n`csharp{\ntitle: \"Order Command Handler\"\ndescription: \"Processes order placement commands\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"Handlers\", \"Orders\"]\nnugetPackages: [\"Whizbang Core\"]\ntestFile: \"OrderHandlerTests cs\"\ntestMethod: \"HandlePlaceOrder_ValidOrder_ReturnsSuccess\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\npublic class PlaceOrderHandler {\n    public async Task<OrderPlacedResult> Handle(PlaceOrder command) {\n        // Implementation\n    }\n}\n`\nSee DOCUMENTATION-STANDARDS md for complete guidelines Coding Standards\nSee Coding Standards for detailed Cconventions Key Points:\nBrace Style: K&R/Egyptian (opening brace on same line)\nvar: Always use var for local variables\nNaming: PascalCase for public, camelCase for private, _camelCase for fields\nAsync: Suffix async methods with Async\nNullability: Enable nullable reference types\nAOT-Safe: No reflection tricks that break native AOT\nDesign Philosophy\nWhen contributing, keep these principles in mind:\nEvents are the source of truth - Always\nSimple things should be simple - Don't overcomplicate the basic mediator scenario\nComplex things should be possible - But with clear opt-in\nAOT-first - All features must work with native AOT\nDriver-based - Never lock users into a specific technology\nObservable by default - Telemetry is built-in, not bolted-on\nIdempotent - Message handlers should be safe to retry\nGetting Help\nQuestions Ask in GitHub Discussions\nStuck Ping us on Discord (coming soon)\nFound a bug Open an issue\nRecognition\nContributors are recognized in:\nRelease notes for the version their PR shipped in\nCONTRIBUTORS",
        "startIndex": 5759,
        "preview": "have corresponding tests Located in tests/Documentation/, these tests: Extract code from documentation Verify examples compile Validate examples actua..."
      },
      {
        "id": "contributors/contributing-chunk-4",
        "text": "- Telemetry is built-in, not bolted-on Idempotent - Message handlers should be safe to retry Getting Help Questions Ask in GitHub Discussions Stuck Ping us on Discord (coming soon) Found a bug Open an issue Recognition Contributors are recognized in: Release notes for the version their PR shipped in CONTRIBUTORS md file\nOur gratitude and appreciation 🙏\nThank you for making Whizbang better",
        "startIndex": 7625,
        "preview": "- Telemetry is built-in, not bolted-on Idempotent - Message handlers should be safe to retry Getting Help Questions Ask in GitHub Discussions Stuck Pi..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "core-concepts/aggregates",
    "title": "Aggregates",
    "category": "Core Concepts",
    "url": "/docs/core-concepts/aggregates",
    "chunks": [
      {
        "id": "core-concepts/aggregates-chunk-0",
        "text": "Aggregates\nAggregates are the fundamental building blocks of Whizbang's event-sourced architecture They serve as consistency boundaries that encapsulate business logic and ensure data integrity What are Aggregates An aggregate is a cluster of domain objects that can be treated as a single unit for data changes In Whizbang:\nConsistency Boundary: All changes within an aggregate are atomic\nEvent Source: Aggregates generate events when their state changes\nBusiness Logic Container: They encapsulate domain rules and invariants\nIdentity: Each aggregate has a unique identifier\nKey Characteristics\nEvent-Sourced State\nAggregates don't store current state directly Instead, they:\nStore a sequence of events that represent state changes\nRebuild current state by replaying events from the event store\nAppend new events when commands are processed\nCommand Processing\nAggregates receive commands and:\nValidate the command against current state\nApply business rules and invariants\nGenerate domain events if the command is valid\nThrow exceptions if the command violates business rules\nOptimistic Concurrency\nWhizbang aggregates use optimistic concurrency control:\nEach aggregate has a version number\nConcurrent modifications are detected and handled\nPrevents lost update problems in distributed scenarios\nExample Structure\n`csharp\npublic class OrderAggregate : Aggregate {\n    public Guid Id { get; private set; }\n    public OrderStatus Status { get; private set; }\n    public List<OrderItem> Items { get; private set; } = new();\n    // Constructor for new aggregates\n    public OrderAggregate(PlaceOrderCommand command) {\n        // Validate and apply business rules\n        Apply(new OrderPlacedEvent(command OrderId, command Items));\n    }\n    // Event handler (rebuilds state)\n    private void When(OrderPlacedEvent @event) {\n        Id = @event OrderId;\n        Status = OrderStatus Placed;\n        Items = @event Items;\n    }\n    // Command method\n    public void Ship(ShipOrderCommand command) {\n        if (Status = OrderStatus Placed) {\n            throw new InvalidOperationException(\"Order must be placed to ship\");\n        }\n        Apply(new OrderShippedEvent(Id, command",
        "startIndex": 0,
        "preview": "Aggregates\nAggregates are the fundamental building blocks of Whizbang's event-sourced architecture They serve as consistency boundaries that encapsula..."
      },
      {
        "id": "core-concepts/aggregates-chunk-1",
        "text": "} // Event handler (rebuilds state) private void When(OrderPlacedEvent @event) { Id = @event OrderId; Status = OrderStatus Placed; Items = @event Items; } // Command method public void Ship(ShipOrderCommand command) { if (Status = OrderStatus Placed) { throw new InvalidOperationException(\"Order must be placed to ship\"); } Apply(new OrderShippedEvent(Id, command TrackingNumber));\n    }\n}\n`\nBest Practices\nKeep Aggregates Small\nFocus on a single business concept\nAvoid large, complex aggregates\nConsider splitting if aggregate becomes unwieldy\nDesign Around Invariants\nIdentify what must remain consistent\nEncapsulate related data that changes together\nUse domain events to communicate between aggregates\nAvoid Cross-Aggregate Transactions\nOne aggregate per transaction\nUse eventual consistency between aggregates\nCommunicate via domain events and sagas\nIntegration with Whizbang\nWhizbang provides:\nRepository pattern for loading and saving aggregates\nAutomatic event publishing when aggregates are saved\nOptimistic concurrency handling out of the box\nMultiple storage backends (Postgres, SQL Server, etc )\nRelated Topics\nCore Concepts - Overview of Whizbang's architectural patterns\nRepositories and CQRS Helpers - Working with aggregate repositories\nCommand Handling - Processing commands in aggregates\nGetting Started - Hands-on tutorial building aggregates\nNext Steps\nThis page provides an overview of aggregates in Whizbang For detailed implementation examples and advanced patterns, see the comprehensive documentation linked above",
        "startIndex": 2182,
        "preview": "} // Event handler (rebuilds state) private void When(OrderPlacedEvent @event) { Id = @event OrderId; Status = OrderStatus Placed; Items = @event Item..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "core-concepts/core-concepts",
    "title": "Core Concepts",
    "category": "Core Concepts",
    "url": "/docs/core-concepts/core-concepts",
    "chunks": [
      {
        "id": "core-concepts/core-concepts-chunk-0",
        "text": "Core Concepts\nWhizbang is built on four foundational concepts: Events, Commands, Aggregates, and Projections Understanding these primitives is essential to using Whizbang effectively Events\nEvents are immutable facts that have happened in your system They represent state changes and are the source of truth in event-sourced architectures Characteristics\nPast tense naming - OrderPlaced, PaymentProcessed, InventoryReserved\nImmutable - Once written, never modified\nAppend-only - New events are added to the stream, old events remain forever\nDomain-owned - Each event belongs to a specific domain/service\nExample\n`csharp{\ntitle: \"Order Domain Events\"\ndescription: \"Events representing state changes in the order lifecycle\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Events\", \"Domain Events\", \"Order Management\"]\nusingStatements: [\"System\"]\nshowLineNumbers: true\n}\nusing System;\nnamespace MyApp Orders Events;\n// Event: Order was placed by a customer\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset PlacedAt,\n    List<OrderItem> Items,\n    decimal Total\n);\n// Event: Order was shipped\npublic record OrderShipped(\n    Guid OrderId,\n    DateTimeOffset ShippedAt,\n    string TrackingNumber\n);\n// Event: Order was cancelled\npublic record OrderCancelled(\n    Guid OrderId,\n    DateTimeOffset CancelledAt,\n    string Reason\n);\n`\nEvent Streams\nEvents are stored in streams, one stream per aggregate instance:\n`\nStream: \"Order-{orderId}\"\n  [0] OrderPlaced\n  [1] OrderItemAdded\n  [2] OrderShipped\n  [3] OrderDelivered\n`\nEach event has a position (sequence number) in the stream, enabling:\nReplaying the stream to rebuild aggregate state\nOptimistic concurrency - Detect conflicting concurrent updates\nPoint-in-time queries - Get state as of a specific event\nDomain Ownership\nEvents are owned by the domain that publishes them:\n`csharp{\ntitle: \"Domain-Owned Events\"\ndescription: \"Marking events with their owning domain\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Events\", \"Domain Ownership\", \"Distributed Systems\"]\nusingStatements: [\"Whizbang\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nnamespace MyApp Orders",
        "startIndex": 0,
        "preview": "Core Concepts\nWhizbang is built on four foundational concepts: Events, Commands, Aggregates, and Projections Understanding these primitives is essenti..."
      },
      {
        "id": "core-concepts/core-concepts-chunk-1",
        "text": "specific event Domain Ownership Events are owned by the domain that publishes them: `csharp{ title: \"Domain-Owned Events\" description: \"Marking events with their owning domain\" framework: \"NET8\" category: \"Domain Logic\" difficulty: \"INTERMEDIATE\" tags: [\"Events\", \"Domain Ownership\", \"Distributed Systems\"] usingStatements: [\"Whizbang\", \"System\"] showLineNumbers: true } using System; using Whizbang; namespace MyApp Orders Events;\n[OwnedBy(\"Orders\")]  // This event comes from the Orders domain\npublic record OrderPlaced(Guid OrderId, Guid CustomerId);\n[OwnedBy(\"Inventory\")]  // This event comes from the Inventory domain\npublic record InventoryReserved(Guid OrderId, List<Guid> ProductIds);\n`\nWhen other services subscribe to these events:\nThey're consuming a public API from the owning domain\nThe owning domain controls the event schema\nSubscribers can backfill from the entire event history\nCommands\nCommands are requests to change state They represent intent and are sent to the domain that owns the aggregate Characteristics\nImperative naming - PlaceOrder, ProcessPayment, ReserveInventory\nValidated - Can be rejected if invalid\nRouted - Sent to the owning domain's handlers\nSingle recipient - Unlike events, commands go to exactly one handler\nExample\n`csharp{\ntitle: \"Order Domain Commands\"\ndescription: \"Commands representing requests to change order state\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"CQRS\", \"Order Management\"]\nusingStatements: [\"System\"]\nshowLineNumbers: true\n}\nusing System;\nnamespace MyApp Orders Commands;\n// Command: Request to place a new order\npublic record PlaceOrder(\n    Guid CustomerId,\n    List<OrderItem> Items\n);\n// Command: Request to cancel an order\npublic record CancelOrder(\n    Guid OrderId,\n    string Reason\n);\n// Command: Request to update shipping address\npublic record UpdateShippingAddress(\n    Guid OrderId,\n    Address NewAddress\n);\n`\nCommand Handlers\nHandlers receive commands, validate them, and produce events:\n`csharp{\ntitle: \"Order Command Handler\"\ndescription: \"Handler that validates commands and produces events\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"Handlers\", \"Validation\", \"Events\"]\nusingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading",
        "startIndex": 2227,
        "preview": "specific event Domain Ownership Events are owned by the domain that publishes them: `csharp{ title: \"Domain-Owned Events\" description: \"Marking events..."
      },
      {
        "id": "core-concepts/core-concepts-chunk-2",
        "text": "` Command Handlers Handlers receive commands, validate them, and produce events: `csharp{ title: \"Order Command Handler\" description: \"Handler that validates commands and produces events\" framework: \"NET8\" category: \"Domain Logic\" difficulty: \"INTERMEDIATE\" tags: [\"Commands\", \"Handlers\", \"Validation\", \"Events\"] usingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading Tasks;\nusing Whizbang;\nnamespace MyApp Orders Handlers;\npublic class PlaceOrderHandler {\n    private readonly IOrderRepository _repository;\n    public PlaceOrderHandler(IOrderRepository repository) {\n        _repository = repository;\n    }\n    public async Task<OrderPlaced> Handle(PlaceOrder command) {\n        // Validate command\n        if (command Items Count == 0) {\n            throw new InvalidOperationException(\"Order must have at least one item\");\n        }\n        // Create aggregate\n        var order = new Order(\n            Guid NewGuid(),\n            command CustomerId,\n            command Items\n        );\n        // Persist aggregate (events are appended)\n        await _repository SaveAsync(order);\n        // Return event (auto-published by Whizbang)\n        return new OrderPlaced(\n            order Id,\n            command CustomerId,\n            DateTimeOffset UtcNow,\n            command Items,\n            order Total\n        );\n    }\n}\n`\nCommand Routing\nCommands are routed to the owning domain:\n`csharp{\ntitle: \"Sending Commands\"\ndescription: \"How to send commands to their owning domain\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"Routing\", \"Distributed Systems\"]\nusingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\npublic class CheckoutService {\n    private readonly IWhizbang _whizbang;\n    public CheckoutService(IWhizbang whizbang) {\n        _whizbang = whizbang;\n    }\n    public async Task CheckoutAsync(Guid customerId, List<OrderItem> items) {\n        // Send command to Orders domain\n        var placed = await _whizbang Send(new PlaceOrder(customerId, items));\n        // Send command to Inventory domain\n        await _whizbang Send(new ReserveInventory(placed OrderId, items));\n        // Send command to Payment domain\n        await _whizbang Send(new ProcessPayment(placed OrderId, placed Total));\n    }\n}\n`\nIn a monolith, these commands are routed to local handlers In microservices, they're routed to the owning service via message broker Aggregates\nAggregates are the write-side domain models that enforce business rules",
        "startIndex": 4174,
        "preview": "` Command Handlers Handlers receive commands, validate them, and produce events: `csharp{ title: \"Order Command Handler\" description: \"Handler that va..."
      },
      {
        "id": "core-concepts/core-concepts-chunk-3",
        "text": "OrderId, items)); // Send command to Payment domain await _whizbang Send(new ProcessPayment(placed OrderId, placed Total)); } } ` In a monolith, these commands are routed to local handlers In microservices, they're routed to the owning service via message broker Aggregates Aggregates are the write-side domain models that enforce business rules They are the consistency boundary for commands and events Characteristics\nConsistency boundary - All changes within an aggregate are transactional\nEvent-sourced - State is built by replaying events\nValidated - Enforce invariants before producing events\nSingle writer - Only one command can modify an aggregate at a time (optimistic concurrency)\nExample\n`csharp{\ntitle: \"Order Aggregate\"\ndescription: \"Event-sourced aggregate that enforces order business rules\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aggregates\", \"Event Sourcing\", \"Domain-Driven Design\"]\nusingStatements: [\"Whizbang\", \"System\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing Whizbang;\nnamespace MyApp Orders Domain;\npublic class Order : Aggregate {\n    public Guid Id { get; private set; }\n    public Guid CustomerId { get; private set; }\n    public OrderStatus Status { get; private set; }\n    public List<OrderItem> Items { get; private set; } = new();\n    public decimal Total { get; private set; }\n    // Constructor for new aggregates\n    public Order(Guid id, Guid customerId, List<OrderItem> items) {\n        // Validate business rules\n        if (items Count == 0) {\n            throw new InvalidOperationException(\"Order must have items\");\n        }\n        // Produce event\n        Apply(new OrderPlaced(\n            id,\n            customerId,\n            DateTimeOffset UtcNow,\n            items,\n            items Sum(i => i Price * i Quantity)\n        ));\n    }\n    // Event handler - updates state\n    private void When(OrderPlaced @event) {\n        Id = @event OrderId;\n        CustomerId = @event CustomerId;\n        Status = OrderStatus Placed;\n        Items = @event Items;\n        Total = @event Total;\n    }\n    // Command method - enforces business rules\n    public void Ship(string trackingNumber) {\n        if (Status = OrderStatus",
        "startIndex": 6389,
        "preview": "OrderId, items)); // Send command to Payment domain await _whizbang Send(new ProcessPayment(placed OrderId, placed Total)); } } ` In a monolith, these..."
      },
      {
        "id": "core-concepts/core-concepts-chunk-4",
        "text": ")); } // Event handler - updates state private void When(OrderPlaced @event) { Id = @event OrderId; CustomerId = @event CustomerId; Status = OrderStatus Placed; Items = @event Items; Total = @event Total; } // Command method - enforces business rules public void Ship(string trackingNumber) { if (Status = OrderStatus Placed) {\n            throw new InvalidOperationException(\"Can only ship placed orders\");\n        }\n        Apply(new OrderShipped(Id, DateTimeOffset UtcNow, trackingNumber));\n    }\n    // Event handler - updates state\n    private void When(OrderShipped @event) {\n        Status = OrderStatus Shipped;\n    }\n    // Command method - enforces business rules\n    public void Cancel(string reason) {\n        if (Status == OrderStatus Shipped || Status == OrderStatus Delivered) {\n            throw new InvalidOperationException(\"Cannot cancel shipped/delivered orders\");\n        }\n        Apply(new OrderCancelled(Id, DateTimeOffset UtcNow, reason));\n    }\n    // Event handler - updates state\n    private void When(OrderCancelled @event) {\n        Status = OrderStatus Cancelled;\n    }\n}\npublic enum OrderStatus {\n    Placed,\n    Shipped,\n    Delivered,\n    Cancelled\n}\n`\nEvent Sourcing Pattern\nAggregates follow this pattern:\nLoad aggregate by replaying events from the stream\nExecute command method, which validates business rules\nApply events to update state\nSave new events to the stream\n`csharp{\ntitle: \"Loading and Saving Aggregates\"\ndescription: \"How aggregates are loaded from and saved to event streams\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"ADVANCED\"\ntags: [\"Aggregates\", \"Event Sourcing\", \"Repositories\"]\nusingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nusing Whizbang;\npublic class OrderRepository : IOrderRepository {\n    private readonly IEventStore _eventStore;\n    public OrderRepository(IEventStore eventStore) {\n        _eventStore = eventStore;\n    }\n    public async Task<Order> GetAsync(Guid orderId) {\n        // Load events from stream\n        var events = await _eventStore LoadStreamAsync($\"Order-{orderId}\");\n        // Reconstitute aggregate by replaying events\n        var order = new Order();\n        foreach (var @event in events) {\n            order",
        "startIndex": 8314,
        "preview": ")); } // Event handler - updates state private void When(OrderPlaced @event) { Id = @event OrderId; CustomerId = @event CustomerId; Status = OrderStat..."
      },
      {
        "id": "core-concepts/core-concepts-chunk-5",
        "text": ": IOrderRepository { private readonly IEventStore _eventStore; public OrderRepository(IEventStore eventStore) { _eventStore = eventStore; } public async Task<Order> GetAsync(Guid orderId) { // Load events from stream var events = await _eventStore LoadStreamAsync($\"Order-{orderId}\"); // Reconstitute aggregate by replaying events var order = new Order(); foreach (var @event in events) { order ApplyEvent(@event);  // Calls private When() methods\n        }\n        return order;\n    }\n    public async Task SaveAsync(Order order) {\n        // Get uncommitted events from aggregate\n        var newEvents = order GetUncommittedEvents();\n        // Append to event stream with optimistic concurrency check\n        await _eventStore AppendToStreamAsync(\n            $\"Order-{order Id}\",\n            newEvents,\n            expectedVersion: order Version\n        );\n        // Mark events as committed\n        order MarkEventsAsCommitted();\n    }\n}\n`\nProjections\nProjections are read-side models optimized for queries They are built by subscribing to events and updating denormalized views Characteristics\nEventually consistent - Updated asynchronously as events arrive\nDenormalized - Optimized for specific query patterns\nRebuildable - Can be deleted and rebuilt from event history\nIsolated - Each projection has its own data model\nExample\n`csharp{\ntitle: \"Order History Projection\"\ndescription: \"Projection that maintains a queryable order history\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"CQRS\", \"Read Models\"]\nusingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\nnamespace MyApp Orders Projections;\n// Read model - optimized for queries\npublic class OrderHistoryItem {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    public DateTimeOffset PlacedAt { get; set; }\n    public DateTimeOffset ShippedAt { get; set; }\n    public decimal Total { get; set; }\n    public string Status { get; set; }\n}\n// Projection handler - subscribes to events\npublic class OrderHistoryProjection {\n    private readonly IOrderHistoryStore _store;\n    public OrderHistoryProjection(IOrderHistoryStore store) {\n        _store = store;\n    }\n    // Event handler - updates read model\n    public async Task Handle(OrderPlaced @event) {\n        await _store",
        "startIndex": 10359,
        "preview": ": IOrderRepository { private readonly IEventStore _eventStore; public OrderRepository(IEventStore eventStore) { _eventStore = eventStore; } public asy..."
      },
      {
        "id": "core-concepts/core-concepts-chunk-6",
        "text": "{ get; set; } public string Status { get; set; } } // Projection handler - subscribes to events public class OrderHistoryProjection { private readonly IOrderHistoryStore _store; public OrderHistoryProjection(IOrderHistoryStore store) { _store = store; } // Event handler - updates read model public async Task Handle(OrderPlaced @event) { await _store InsertAsync(new OrderHistoryItem {\n            OrderId = @event OrderId,\n            CustomerId = @event CustomerId,\n            PlacedAt = @event PlacedAt,\n            Total = @event Total,\n            Status = \"Placed\"\n        });\n    }\n    // Event handler - updates read model\n    public async Task Handle(OrderShipped @event) {\n        await _store UpdateAsync(@event OrderId, item => {\n            item ShippedAt = @event ShippedAt;\n            item Status = \"Shipped\";\n        });\n    }\n    // Event handler - updates read model\n    public async Task Handle(OrderCancelled @event) {\n        await _store UpdateAsync(@event OrderId, item => {\n            item Status = \"Cancelled\";\n        });\n    }\n}\n`\nQuerying Projections\nProjections are queried directly, not through the event store:\n`csharp{\ntitle: \"Querying Order History\"\ndescription: \"How to query projections for read-side data\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Projections\", \"Queries\", \"CQRS\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\npublic class OrderQueryService {\n    private readonly IOrderHistoryStore _store;\n    public OrderQueryService(IOrderHistoryStore store) {\n        _store = store;\n    }\n    public async Task<List<OrderHistoryItem>> GetCustomerOrdersAsync(Guid customerId) {\n        // Query the projection (fast, optimized for reads)\n        return await _store QueryAsync(item => item CustomerId == customerId);\n    }\n    public async Task<OrderHistoryItem> GetOrderDetailsAsync(Guid orderId) {\n        return await _store GetAsync(orderId);\n    }\n}\n`\nProjection Backfilling\nWhen a projection is added to a new service, it can backfill from historical events:\n`csharp{\ntitle: \"Backfilling a Projection\"\ndescription: \"Configure a projection to rebuild from historical events\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Backfilling\", \"Event Sourcing\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Microsoft Extensions",
        "startIndex": 12379,
        "preview": "{ get; set; } public string Status { get; set; } } // Projection handler - subscribes to events public class OrderHistoryProjection { private readonly..."
      },
      {
        "id": "core-concepts/core-concepts-chunk-7",
        "text": "to a new service, it can backfill from historical events: `csharp{ title: \"Backfilling a Projection\" description: \"Configure a projection to rebuild from historical events\" framework: \"NET8\" category: \"Domain Logic\" difficulty: \"ADVANCED\" tags: [\"Projections\", \"Backfilling\", \"Event Sourcing\"] usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"] showLineNumbers: true } using System; using Microsoft Extensions DependencyInjection;\nusing Whizbang;\npublic static class ServiceCollectionExtensions {\n    public static IServiceCollection AddOrderProjections(this IServiceCollection services) {\n        services AddProjection<OrderHistoryProjection>(options => {\n            // Subscribe to events from the Orders domain\n            options Subscribe<OrderPlaced>();\n            options Subscribe<OrderShipped>();\n            options Subscribe<OrderCancelled>();\n            // Backfill from the beginning of time\n            options BackfillFrom = DateTimeOffset MinValue;\n            // Process in parallel across order IDs (partitioned by OrderId)\n            options PartitionBy = @event => ((dynamic)@event) OrderId;\n        });\n        return services;\n    }\n}\n`\nWhen this projection starts:\nIt queries the Orders service for all historical OrderPlaced, OrderShipped, and OrderCancelled events\nIt applies them in order to build the initial projection state\nIt continues processing new events as they arrive\nCQRS Pattern\nCQRS (Command Query Responsibility Segregation) separates writes from reads:\nCommands → Aggregates (write side)\nQueries → Projections (read side)\n`\n     Command                   Event                   Query\n        ↓                        ↓                        ↓\n   ┌─────────┐             ┌──────────┐            ┌──────────┐\n   │Aggregate│ ─Events→    │Event     │ ─Events→   │Projection│\n   │         │             │Store     │            │          │\n   └─────────┘             └──────────┘            └──────────┘\n   Write Model             Source of Truth          Read Model\n   (Normalized)            (Immutable)              (Denormalized)\n`\nBenefits:\nOptimized models - Write and read models can have different schemas\nScalability - Scale reads independently from writes\nFlexibility - Multiple projections can be built from the same events\nNext Steps\nNow that you understand the core concepts, learn how to:\nGet Started - Build your first Whizbang application\nPackage Structure - Choose the right NuGet packages\nDriver System - Understand how to swap persistence and messaging backends",
        "startIndex": 14594,
        "preview": "to a new service, it can backfill from historical events: `csharp{ title: \"Backfilling a Projection\" description: \"Configure a projection to rebuild f..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "core-concepts/lenses",
    "title": "Lenses",
    "category": "Core Concepts",
    "url": "/docs/core-concepts/lenses",
    "chunks": [
      {
        "id": "core-concepts/lenses-chunk-0",
        "text": "Lenses\nOverview\nLenses provide focused, read-only views into your data They are the query side of Whizbang's CQRS implementation, offering a clean separation between reads and writes Lenses work consistently across Event-Driven and Event-Sourced modes, always providing the current view of data regardless of how it's stored What is a Lens A Lens:\nProvides read-only access to data\nFocuses on specific query needs\nNever modifies state\nAbstracts the underlying storage mechanism\nThink of a lens as a window into your data - you can look through it from different angles to see different views, but you can't reach through it to change what you see The Lens Interface Pattern\n`csharp\npublic interface IOrderLens {\n    // Focus on a single item\n    Order Focus(Guid id);\n    // View a filtered collection\n    IEnumerable<Order> View(Expression<Func<Order, bool>> filter);\n    // Glimpse a summary or partial view\n    OrderSummary Glimpse(Guid id);\n    // Check existence\n    bool Exists(Guid id);\n    // Scan all items (use sparingly)\n    IEnumerable<Order> Scan();\n}\n`\nCore Lens Methods\nFocus - Single Item Retrieval\n`csharp\npublic interface ICustomerLens {\n    Customer Focus(Guid customerId);\n    Task<Customer> FocusAsync(Guid customerId);\n}\n// Implementation\npublic class CustomerLens : ICustomerLens {\n    private readonly IDatabase db;\n    public Customer Focus(Guid customerId) {\n        return db Customers FirstOrDefault(c => c Id == customerId);\n    }\n}\n`\nView - Filtered Collections\n`csharp\npublic interface IOrderLens {\n    IEnumerable<Order> View(Expression<Func<Order, bool>> filter);\n    IEnumerable<Order> ViewByCustomer(Guid customerId);\n    IEnumerable<Order> ViewByStatus(OrderStatus status);\n}\n// Implementation\npublic class OrderLens : IOrderLens {\n    public IEnumerable<Order> View(Expression<Func<Order, bool>> filter) {\n        return db Orders Where(filter);\n    }\n    public IEnumerable<Order> ViewByCustomer(Guid customerId) {\n        return db Orders Where(o => o CustomerId == customerId);\n    }\n}\n`\nGlimpse - Summaries and Projections\n`csharp\npublic interface IInventoryLens {\n    InventorySummary Glimpse(Guid productId);\n    StockLevel GlimpseStock(Guid productId);\n    IEnumerable<LowStockItem> GlimpseLowStock();\n}\n// Implementation  \npublic class InventoryLens : IInventoryLens {\n    public InventorySummary Glimpse(Guid productId) {\n        var product = db Products",
        "startIndex": 0,
        "preview": "Lenses\nOverview\nLenses provide focused, read-only views into your data They are the query side of Whizbang's CQRS implementation, offering a clean sep..."
      },
      {
        "id": "core-concepts/lenses-chunk-1",
        "text": "{ return db Orders Where(o => o CustomerId == customerId); } } ` Glimpse - Summaries and Projections `csharp public interface IInventoryLens { InventorySummary Glimpse(Guid productId); StockLevel GlimpseStock(Guid productId); IEnumerable<LowStockItem> GlimpseLowStock(); } // Implementation public class InventoryLens : IInventoryLens { public InventorySummary Glimpse(Guid productId) { var product = db Products Find(productId);\n        return new InventorySummary {\n            ProductId = product Id,\n            Name = product Name,\n            InStock = product Quantity,\n            Reserved = product ReservedQuantity,\n            Available = product Quantity - product ReservedQuantity\n        };\n    }\n}\n`\nExists - Efficient Existence Checks\n`csharp\npublic interface IProductLens {\n    bool Exists(Guid productId);\n    bool Exists(Expression<Func<Product, bool>> condition);\n}\n// Implementation\npublic class ProductLens : IProductLens {\n    public bool Exists(Guid productId) {\n        return db Products Any(p => p Id == productId);\n    }\n    public bool Exists(Expression<Func<Product, bool>> condition) {\n        return db Products Any(condition);\n    }\n}\n`\nLens Usage in Receptors\nLenses provide state for stateless receptors:\n`csharp\npublic class OrderReceptor : IReceptor<CreateOrder> {\n    public OrderCreated Receive(CreateOrder cmd, IOrderLens orderLens, ICustomerLens customerLens) {\n        // Use lenses to validate\n        if ( customerLens Exists(cmd CustomerId)) {\n            throw new CustomerNotFoundException();\n        }\n        var customer = customerLens Focus(cmd CustomerId);\n        if ( customer IsActive) {\n            throw new InactiveCustomerException();\n        }\n        // Check for duplicate orders\n        if (orderLens Exists(o => o CustomerId == cmd CustomerId && o IsPending)) {\n            throw new PendingOrderExistsException();\n        }\n        // Make decision based on lens data\n        return new OrderCreated(\n            Guid NewGuid(),\n            cmd CustomerId,\n            cmd Items,\n            CalculateTotal(cmd Items, customer Tier)\n        );\n    }\n}\n`\nComposite Lenses\nCombine multiple data sources into a unified view:\n`csharp\npublic interface ICheckoutLens {\n    CheckoutContext PrepareCheckout(Guid customerId, List<CartItem> items);\n}\npublic class CheckoutLens : ICheckoutLens {\n    private readonly ICustomerLens customerLens;\n    private readonly IInventoryLens inventoryLens;\n    private readonly IPromotionLens promotionLens;\n    private readonly ITaxLens taxLens;\n    public CheckoutContext PrepareCheckout(Guid customerId, List<CartItem> items) {\n        var customer = customerLens Focus(customerId);\n        var inventory = inventoryLens",
        "startIndex": 2407,
        "preview": "{ return db Orders Where(o => o CustomerId == customerId); } } ` Glimpse - Summaries and Projections `csharp public interface IInventoryLens { Invento..."
      },
      {
        "id": "core-concepts/lenses-chunk-2",
        "text": "view: `csharp public interface ICheckoutLens { CheckoutContext PrepareCheckout(Guid customerId, List<CartItem> items); } public class CheckoutLens : ICheckoutLens { private readonly ICustomerLens customerLens; private readonly IInventoryLens inventoryLens; private readonly IPromotionLens promotionLens; private readonly ITaxLens taxLens; public CheckoutContext PrepareCheckout(Guid customerId, List<CartItem> items) { var customer = customerLens Focus(customerId); var inventory = inventoryLens CheckAvailability(items);\n        var promotions = promotionLens GetApplicable(customer, items);\n        var tax = taxLens Calculate(customer Address, items);\n        return new CheckoutContext {\n            Customer = customer,\n            Items = items,\n            InventoryStatus = inventory,\n            AppliedPromotions = promotions,\n            TaxAmount = tax,\n            Total = CalculateTotal(items, promotions, tax)\n        };\n    }\n}\n`\nCached Lenses\nOptimize read performance with caching:\n`csharp\npublic class CachedProductLens : IProductLens {\n    private readonly IProductLens innerLens;\n    private readonly ICache cache;\n    public Product Focus(Guid productId) {\n        var cacheKey = $\"product:{productId}\";\n        return cache GetOrSet(cacheKey, () => {\n            return innerLens Focus(productId);\n        }, TimeSpan FromMinutes(5));\n    }\n    public IEnumerable<Product> ViewByCategory(string category) {\n        var cacheKey = $\"products:category:{category}\";\n        return cache GetOrSet(cacheKey, () => {\n            return innerLens ViewByCategory(category) ToList();\n        }, TimeSpan FromMinutes(1));\n    }\n}\n`\nPaged Queries\nSupport pagination for large result sets:\n`csharp\npublic interface IOrderLens {\n    PagedResult<Order> ViewPaged(int page, int pageSize, Expression<Func<Order, bool>> filter = null);\n}\npublic class OrderLens : IOrderLens {\n    public PagedResult<Order> ViewPaged(int page, int pageSize, Expression<Func<Order, bool>> filter = null) {\n        var query = db Orders AsQueryable();\n        if (filter = null) {\n            query = query Where(filter);\n        }\n        var totalCount = query Count();\n        var items = query OrderByDescending(o => o CreatedAt) Skip((page - 1) * pageSize) Take(pageSize) ToList();\n        return new PagedResult<Order> {\n            Items = items,\n            Page = page,\n            PageSize = pageSize,\n            TotalCount = totalCount,\n            TotalPages = (int)Math",
        "startIndex": 4711,
        "preview": "view: `csharp public interface ICheckoutLens { CheckoutContext PrepareCheckout(Guid customerId, List<CartItem> items); } public class CheckoutLens : I..."
      },
      {
        "id": "core-concepts/lenses-chunk-3",
        "text": "AsQueryable(); if (filter = null) { query = query Where(filter); } var totalCount = query Count(); var items = query OrderByDescending(o => o CreatedAt) Skip((page - 1) * pageSize) Take(pageSize) ToList(); return new PagedResult<Order> { Items = items, Page = page, PageSize = pageSize, TotalCount = totalCount, TotalPages = (int)Math Ceiling(totalCount / (double)pageSize)\n        };\n    }\n}\n`\nAggregate Queries\nProvide pre-calculated aggregations:\n`csharp\npublic interface IStatisticsLens {\n    OrderStatistics GetOrderStats(DateTime from, DateTime to);\n    CustomerMetrics GetCustomerMetrics(Guid customerId);\n    IEnumerable<TopProduct> GetTopProducts(int count);\n}\npublic class StatisticsLens : IStatisticsLens {\n    public OrderStatistics GetOrderStats(DateTime from, DateTime to) {\n        var orders = db Orders Where(o => o CreatedAt >= from && o CreatedAt <= to);\n        return new OrderStatistics {\n            TotalOrders = orders Count(),\n            TotalRevenue = orders Sum(o => o Total),\n            AverageOrderValue = orders Average(o => o Total),\n            OrdersByStatus = orders GroupBy(o => o Status) Select(g => new StatusCount { \n                    Status = g Key, \n                    Count = g Count() \n                }) ToList()\n        };\n    }\n}\n`\nSearch Lenses\nIntegrate with search infrastructure:\n`csharp\npublic interface ISearchLens {\n    SearchResults<Product> SearchProducts(string query, SearchOptions options);\n    IEnumerable<SearchSuggestion> GetSuggestions(string prefix);\n}\npublic class ElasticSearchLens : ISearchLens {\n    private readonly IElasticClient elastic;\n    public SearchResults<Product> SearchProducts(string query, SearchOptions options) {\n        var searchRequest = new SearchRequest<Product> {\n            Query = new MultiMatchQuery {\n                Query = query,\n                Fields = new[] { \"name\", \"description\", \"category\" }\n            },\n            From = options Offset,\n            Size = options Limit,\n            Aggregations = new TermsAggregation(\"categories\") {\n                Field = \"category keyword\"\n            }\n        };\n        var response = elastic Search<Product>(searchRequest);\n        return new SearchResults<Product> {\n            Items = response Documents,\n            TotalCount = response Total,\n            Facets = ExtractFacets(response Aggregations),\n            HighlightedTerms = ExtractHighlights(response Hits)\n        };\n    }\n}\n`\nLens Configuration\nConfigure lenses with the dispatcher:\n`csharp\nservices AddWhizbang() UseDispatcher(dispatcher => {\n        // Register lenses\n        dispatcher RegisterLensesFromAssembly(typeof(Program) Assembly);\n        // Configure caching for all lenses\n        dispatcher Lenses EnableCaching(TimeSpan FromMinutes(5)) UseCacheProvider<RedisCache>();\n        // Specific lens configuration\n        dispatcher ForLens<IProductLens>()",
        "startIndex": 6738,
        "preview": "AsQueryable(); if (filter = null) { query = query Where(filter); } var totalCount = query Count(); var items = query OrderByDescending(o => o CreatedA..."
      },
      {
        "id": "core-concepts/lenses-chunk-4",
        "text": "response Total, Facets = ExtractFacets(response Aggregations), HighlightedTerms = ExtractHighlights(response Hits) }; } } ` Lens Configuration Configure lenses with the dispatcher: `csharp services AddWhizbang() UseDispatcher(dispatcher => { // Register lenses dispatcher RegisterLensesFromAssembly(typeof(Program) Assembly); // Configure caching for all lenses dispatcher Lenses EnableCaching(TimeSpan FromMinutes(5)) UseCacheProvider<RedisCache>(); // Specific lens configuration dispatcher ForLens<IProductLens>() UseCaching(TimeSpan FromMinutes(10)) WithImplementation<CachedProductLens>();\n    });\n// Manual registration\nservices AddScoped<IOrderLens, OrderLens>();\nservices AddScoped<ICustomerLens, CustomerLens>();\nservices Decorate<IProductLens, CachedProductLens>();\n`\nTesting Lenses\nLenses are easy to test and mock:\n`csharp\n[Fact]\npublic void OrderLens_ViewByCustomer_ReturnsCustomerOrders() {\n    // Arrange\n    var db = new InMemoryDatabase();\n    var customerId = Guid NewGuid();\n    db Orders Add(new Order { CustomerId = customerId });\n    db Orders Add(new Order { CustomerId = customerId });\n    db Orders Add(new Order { CustomerId = Guid NewGuid() });\n    var lens = new OrderLens(db);\n    // Act\n    var orders = lens ViewByCustomer(customerId);\n    // Assert\n    Assert Equal(2, orders Count());\n    Assert All(orders, o => Assert Equal(customerId, o CustomerId));\n}\n// Mocking in receptor tests\n[Fact]\npublic void OrderReceptor_ThrowsException_WhenCustomerNotFound() {\n    // Arrange\n    var customerLens = Mock Of<ICustomerLens>(l => \n        l Exists(It IsAny<Guid>()) == false\n    );\n    var receptor = new OrderReceptor();\n    // Act & Assert\n    Assert Throws<CustomerNotFoundException>(() =>\n        receptor Receive(new CreateOrder(), null, customerLens)\n    );\n}\n`\nBest Practices\nDo's\n✅ Keep lenses read-only\n`csharp\npublic interface IOrderLens {\n    Order Focus(Guid id);  // Read-only methods only\n}\n`\n✅ Use specific method names\n`csharp\nIEnumerable<Order> ViewPending();      // Clear intent\nIEnumerable<Order> ViewByDateRange(DateTime from, DateTime to);\n`\n✅ Optimize for common queries\n`csharp\n// Pre-calculate common aggregations\nCustomerDashboard GetCustomerDashboard(Guid customerId);\n`\n✅ Return immutable data\n`csharp\npublic IReadOnlyList<Order> ViewRecent() {\n    return db Orders OrderByDescending(o => o CreatedAt) Take(10) ToList() AsReadOnly();\n}\n`\nDon'ts\n❌ Don't include write operations\n`csharp\n// BAD - Lenses are read-only\npublic interface IOrderLens {\n    void Save(Order order);  // Don't do this",
        "startIndex": 9353,
        "preview": "response Total, Facets = ExtractFacets(response Aggregations), HighlightedTerms = ExtractHighlights(response Hits) }; } } ` Lens Configuration Configu..."
      },
      {
        "id": "core-concepts/lenses-chunk-5",
        "text": "aggregations CustomerDashboard GetCustomerDashboard(Guid customerId); ` ✅ Return immutable data `csharp public IReadOnlyList<Order> ViewRecent() { return db Orders OrderByDescending(o => o CreatedAt) Take(10) ToList() AsReadOnly(); } ` Don'ts ❌ Don't include write operations `csharp // BAD - Lenses are read-only public interface IOrderLens { void Save(Order order); // Don't do this }\n`\n❌ Don't return mutable entities\n`csharp\n// BAD - Returns mutable entity\npublic Order Focus(Guid id) {\n    return db Orders Find(id);  // Can be modified\n}\n// GOOD - Return immutable view\npublic OrderView Focus(Guid id) {\n    var order = db Orders Find(id);\n    return new OrderView(order);  // Immutable copy\n}\n`\n❌ Don't perform business logic\n`csharp\n// BAD - Business logic in lens\npublic IEnumerable<Order> ViewDiscounted() {\n    return db Orders Where(o => {\n        if (o Total > 100) {  // Business rule return true;\n        }\n    });\n}\n`\nAdvanced Patterns\nMaterialized View Lenses\nRead from pre-computed materialized views:\n`csharp\npublic class MaterializedOrderLens : IOrderLens {\n    // Read from denormalized view maintained by perspectives\n    public OrderSummary Glimpse(Guid orderId) {\n        return db OrderSummaries Find(orderId);  // Pre-computed\n    }\n    public IEnumerable<Order> ViewTopOrders(int count) {\n        return db TopOrdersView Take(count);  // Maintained by perspective\n    }\n}\n`\nCross-Service Lenses\nQuery data from multiple services:\n`csharp\npublic class DistributedCustomerLens : ICustomerLens {\n    private readonly IOrderService orderService;\n    private readonly IPaymentService paymentService;\n    public async Task<CustomerProfile> GetCompleteProfile(Guid customerId) {\n        var customerTask = db Customers FindAsync(customerId);\n        var ordersTask = orderService GetCustomerOrders(customerId);\n        var paymentsTask = paymentService GetPaymentHistory(customerId);\n        await Task WhenAll(customerTask, ordersTask, paymentsTask);\n        return new CustomerProfile {\n            Customer = customerTask Result,\n            RecentOrders = ordersTask Result,\n            PaymentHistory = paymentsTask",
        "startIndex": 11425,
        "preview": "aggregations CustomerDashboard GetCustomerDashboard(Guid customerId); ` ✅ Return immutable data `csharp public IReadOnlyList<Order> ViewRecent() { ret..."
      },
      {
        "id": "core-concepts/lenses-chunk-6",
        "text": "private readonly IOrderService orderService; private readonly IPaymentService paymentService; public async Task<CustomerProfile> GetCompleteProfile(Guid customerId) { var customerTask = db Customers FindAsync(customerId); var ordersTask = orderService GetCustomerOrders(customerId); var paymentsTask = paymentService GetPaymentHistory(customerId); await Task WhenAll(customerTask, ordersTask, paymentsTask); return new CustomerProfile { Customer = customerTask Result, RecentOrders = ordersTask Result, PaymentHistory = paymentsTask Result\n        };\n    }\n}\n`\nTime-Travel Lenses\nIn Event-Sourced mode, query historical state:\n`csharp\npublic interface IHistoricalLens {\n    Order FocusAsOf(Guid orderId, DateTime pointInTime);\n    IEnumerable<Order> ViewAsOf(DateTime pointInTime);\n}\npublic class HistoricalOrderLens : IHistoricalLens {\n    private readonly IEventStore eventStore;\n    public Order FocusAsOf(Guid orderId, DateTime pointInTime) {\n        var events = eventStore GetEvents(orderId, untilTime: pointInTime);\n        return RebuildOrder(events);\n    }\n}\n`\nSummary\nLenses provide the read side of Whizbang's architecture:\nRead-only interfaces maintain clear separation of concerns\nFocused methods optimize for specific query needs  \nWork consistently across Event-Driven and Event-Sourced modes\nEasy to test and mock\nComposable for complex query scenarios\nLenses ensure that reading data is simple, efficient, and completely separate from writing data Next Steps\nExplore Receptors - How commands are processed\nLearn about Perspectives - How data is written\nSee Event-Driven Architecture - Complete architecture\nReview CQRS Implementation - Query patterns",
        "startIndex": 13194,
        "preview": "private readonly IOrderService orderService; private readonly IPaymentService paymentService; public async Task<CustomerProfile> GetCompleteProfile(Gu..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "core-concepts/perspectives",
    "title": "Perspectives",
    "category": "Core Concepts",
    "url": "/docs/core-concepts/perspectives",
    "chunks": [
      {
        "id": "core-concepts/perspectives-chunk-0",
        "text": "Perspectives\nOverview\nPerspectives are the components that react to events and update various views of your data They handle all write operations in Whizbang, ensuring that state changes flow consistently from events to storage The same perspective code works in both Event-Driven and Event-Sourced modes, making them a key part of Whizbang's unified architecture What is a Perspective A Perspective:\nReacts to events emitted by receptors\nUpdates databases, caches, search indexes, and other stores\nMaintains different views of the same data\nExecutes all write operations in the system\nThink of perspectives as event handlers that maintain materialized views Each perspective provides a different \"perspective\" on the events flowing through your system The Core Interface\n`csharp\npublic interface IPerspectiveOf<TEvent> {\n    Task Update(TEvent @event);\n}\n`\nSimple, yet powerful - perspectives react to specific events and update their views accordingly How Perspectives Work\nIn Event-Driven Mode\nEvents flow directly from receptors to perspectives in the same transaction:\n`csharp\n// Receptor emits event\npublic OrderCreated Receive(CreateOrder cmd) {\n    return new OrderCreated(Guid NewGuid(), cmd CustomerId);\n}\n// Perspective immediately updates database\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await db Orders Add(new Order { \n            Id = e OrderId,\n            CustomerId = e CustomerId \n        });\n        await db SaveChanges();  // Immediate write\n    }\n}\n`\nIn Event-Sourced Mode\nEvents are first persisted to the ledger, then perspectives update asynchronously:\n`csharp\n// Same perspective code, different execution model\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        // Exact same code, but executed async from event stream\n        await db Orders Add(new Order { \n            Id = e OrderId,\n            CustomerId = e CustomerId \n        });\n        await db",
        "startIndex": 0,
        "preview": "Perspectives\nOverview\nPerspectives are the components that react to events and update various views of your data They handle all write operations in W..."
      },
      {
        "id": "core-concepts/perspectives-chunk-1",
        "text": "perspectives update asynchronously: `csharp // Same perspective code, different execution model public class OrderPerspective : IPerspectiveOf<OrderCreated> { public async Task Update(OrderCreated e) { // Exact same code, but executed async from event stream await db Orders Add(new Order { Id = e OrderId, CustomerId = e CustomerId }); await db SaveChanges();\n    }\n}\n`\nMultiple Perspectives Pattern\nDifferent perspectives provide different views of the same events:\n`csharp\n// Order list for display\npublic class OrderListPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await db OrderList Add(new OrderListItem {\n            Id = e OrderId,\n            CustomerName = await GetCustomerName(e CustomerId),\n            Total = e Total,\n            Status = \"New\",\n            CreatedAt = e Timestamp\n        });\n    }\n}\n// Customer statistics\npublic class CustomerStatsPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await db CustomerStats IncrementOrderCount(e CustomerId);\n        await db CustomerStats AddToTotalSpent(e CustomerId, e Total);\n        await db CustomerStats UpdateLastOrderDate(e CustomerId, e Timestamp);\n    }\n}\n// Search index\npublic class SearchPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await searchIndex Index(new SearchDocument {\n            Id = e OrderId ToString(),\n            Type = \"order\",\n            CustomerId = e CustomerId,\n            Timestamp = e Timestamp,\n            Searchable = $\"Order {e OrderId} Customer {e CustomerId}\"\n        });\n    }\n}\n// Analytics/reporting\npublic class AnalyticsPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await analytics Track(\"OrderCreated\", new {\n            OrderId = e OrderId,\n            CustomerId = e CustomerId,\n            Total = e Total,\n            ItemCount = e Items Count\n        });\n    }\n}\n`\nComplex Perspective Patterns\nMulti-Event Perspectives\nPerspectives can handle multiple event types to maintain complex views:\n`csharp\npublic class OrderStatusPerspective : \n    IPerspectiveOf<OrderCreated>,\n    IPerspectiveOf<OrderPaid>,\n    IPerspectiveOf<OrderShipped>,\n    IPerspectiveOf<OrderCancelled> {\n    public async Task Update(OrderCreated e) {\n        await db OrderStatus Add(new OrderStatus {\n            OrderId = e OrderId,\n            Status = \"Created\",\n            UpdatedAt = e Timestamp\n        });\n    }\n    public async Task Update(OrderPaid e) {\n        await db OrderStatus UpdateStatus(e OrderId, \"Paid\", e",
        "startIndex": 2036,
        "preview": "perspectives update asynchronously: `csharp // Same perspective code, different execution model public class OrderPerspective : IPerspectiveOf<OrderCr..."
      },
      {
        "id": "core-concepts/perspectives-chunk-2",
        "text": "complex views: `csharp public class OrderStatusPerspective : IPerspectiveOf<OrderCreated>, IPerspectiveOf<OrderPaid>, IPerspectiveOf<OrderShipped>, IPerspectiveOf<OrderCancelled> { public async Task Update(OrderCreated e) { await db OrderStatus Add(new OrderStatus { OrderId = e OrderId, Status = \"Created\", UpdatedAt = e Timestamp }); } public async Task Update(OrderPaid e) { await db OrderStatus UpdateStatus(e OrderId, \"Paid\", e Timestamp);\n        await db PaymentRecords Add(new PaymentRecord {\n            OrderId = e OrderId,\n            Amount = e Amount,\n            Method = e PaymentMethod\n        });\n    }\n    public async Task Update(OrderShipped e) {\n        await db OrderStatus UpdateStatus(e OrderId, \"Shipped\", e Timestamp);\n        await db ShippingRecords Add(new ShippingRecord {\n            OrderId = e OrderId,\n            Carrier = e Carrier,\n            TrackingNumber = e TrackingNumber\n        });\n    }\n    public async Task Update(OrderCancelled e) {\n        await db OrderStatus UpdateStatus(e OrderId, \"Cancelled\", e Timestamp);\n        await db CancellationReasons Add(new CancellationReason {\n            OrderId = e OrderId,\n            Reason = e Reason,\n            RefundAmount = e RefundAmount\n        });\n    }\n}\n`\nDenormalized Views\nPerspectives excel at maintaining denormalized views for query performance:\n`csharp\npublic class OrderSummaryPerspective : \n    IPerspectiveOf<OrderCreated>,\n    IPerspectiveOf<ItemAdded>,\n    IPerspectiveOf<ItemRemoved> {\n    public async Task Update(OrderCreated e) {\n        // Create denormalized summary\n        var customer = await customerService GetCustomer(e CustomerId);\n        await db OrderSummaries Add(new OrderSummary {\n            OrderId = e OrderId,\n            CustomerId = e CustomerId,\n            CustomerName = customer Name,\n            CustomerEmail = customer Email,\n            CustomerTier = customer Tier,\n            ItemCount = e Items Count,\n            TotalAmount = e Total,\n            CreatedAt = e Timestamp\n        });\n    }\n    public async Task Update(ItemAdded e) {\n        var summary = await db OrderSummaries Get(e OrderId);\n        summary ItemCount++;\n        summary TotalAmount = e NewTotal;\n        summary LastModified = e Timestamp;\n        await db OrderSummaries Update(summary);\n    }\n}\n`\nCache Invalidation\nPerspectives handle cache updates and invalidation:\n`csharp\npublic class CachePerspective : \n    IPerspectiveOf<OrderCreated>,\n    IPerspectiveOf<OrderUpdated> {\n    private readonly ICache cache;\n    public async Task Update(OrderCreated e) {\n        // Invalidate customer's order list cache\n        await cache Remove($\"customer:{e",
        "startIndex": 4323,
        "preview": "complex views: `csharp public class OrderStatusPerspective : IPerspectiveOf<OrderCreated>, IPerspectiveOf<OrderPaid>, IPerspectiveOf<OrderShipped>, IP..."
      },
      {
        "id": "core-concepts/perspectives-chunk-3",
        "text": "= e NewTotal; summary LastModified = e Timestamp; await db OrderSummaries Update(summary); } } ` Cache Invalidation Perspectives handle cache updates and invalidation: `csharp public class CachePerspective : IPerspectiveOf<OrderCreated>, IPerspectiveOf<OrderUpdated> { private readonly ICache cache; public async Task Update(OrderCreated e) { // Invalidate customer's order list cache await cache Remove($\"customer:{e CustomerId}:orders\");\n        // Pre-warm order cache\n        var order = new OrderCache {\n            Id = e OrderId,\n            CustomerId = e CustomerId,\n            Total = e Total\n        };\n        await cache Set($\"order:{e OrderId}\", order, TimeSpan FromHours(1));\n    }\n    public async Task Update(OrderUpdated e) {\n        // Invalidate all related caches\n        await cache Remove($\"order:{e OrderId}\");\n        await cache Remove($\"customer:{e CustomerId}:orders\");\n        await cache Remove(\"orders:recent\");\n    }\n}\n`\nPerspective Configuration\nConfigure perspectives behavior via the dispatcher:\n`csharp\nservices AddWhizbang() UseDispatcher(dispatcher => {\n        // Register all perspectives\n        dispatcher RegisterPerspectivesFromAssembly(typeof(Program) Assembly);\n        // Configure perspective execution\n        dispatcher Perspectives BufferSize(100)           // Buffer events for batch processing MaxConcurrency(10)         // Parallel perspective execution RetryPolicy(3, \"exponential\") ErrorHandling(ErrorStrategy DeadLetter);\n        // Specific perspective configuration\n        dispatcher ForPerspective<AnalyticsPerspective>() ExecuteAsync()             // Always async WithPriority(Priority Low);\n    });\n`\nBatch Processing\nPerspectives can process events in batches for efficiency:\n`csharp\npublic class BatchedPerspective : IBatchPerspectiveOf<OrderCreated> {\n    public async Task UpdateBatch(IEnumerable<OrderCreated> events) {\n        // Process multiple events efficiently\n        var orders = events Select(e => new Order {\n            Id = e OrderId,\n            CustomerId = e CustomerId,\n            Total = e Total\n        }) ToList();\n        // Single database round-trip\n        await db Orders BulkInsert(orders);\n        // Batch cache update\n        var cacheUpdates = orders Select(o => \n            new CacheEntry($\"order:{o Id}\", o, TimeSpan FromHours(1))\n        );\n        await cache SetMany(cacheUpdates);\n    }\n}\n`\nIdempotent Perspectives\nEnsure perspectives are idempotent for reliability:\n`csharp\npublic class IdempotentOrderPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        // Check if already processed\n        var exists = await db Orders Exists(e OrderId);\n        if (exists) {\n            return;  // Already processed, skip\n        }\n        // Process event\n        await db Orders",
        "startIndex": 6563,
        "preview": "= e NewTotal; summary LastModified = e Timestamp; await db OrderSummaries Update(summary); } } ` Cache Invalidation Perspectives handle cache updates ..."
      },
      {
        "id": "core-concepts/perspectives-chunk-4",
        "text": "` Idempotent Perspectives Ensure perspectives are idempotent for reliability: `csharp public class IdempotentOrderPerspective : IPerspectiveOf<OrderCreated> { public async Task Update(OrderCreated e) { // Check if already processed var exists = await db Orders Exists(e OrderId); if (exists) { return; // Already processed, skip } // Process event await db Orders Add(new Order {\n            Id = e OrderId,\n            CustomerId = e CustomerId,\n            ProcessedAt = DateTime UtcNow\n        });\n    }\n}\n`\nTesting Perspectives\nPerspectives are easy to test in isolation:\n`csharp\n[Fact]\npublic async Task OrderPerspective_CreatesOrder_WhenOrderCreatedEventReceived() {\n    // Arrange\n    var db = new InMemoryDatabase();\n    var perspective = new OrderPerspective(db);\n    var @event = new OrderCreated {\n        OrderId = Guid NewGuid(),\n        CustomerId = Guid NewGuid(),\n        Total = 100 00m\n    };\n    // Act\n    await perspective Update(@event);\n    // Assert\n    var order = await db Orders Get(@event OrderId);\n    Assert NotNull(order);\n    Assert Equal(@event CustomerId, order CustomerId);\n    Assert Equal(@event Total, order Total);\n}\n[Fact]\npublic async Task CachePerspective_InvalidatesCache_WhenOrderUpdated() {\n    // Arrange\n    var cache = new MockCache();\n    cache Set(\"order:123\", new Order());\n    var perspective = new CachePerspective(cache);\n    // Act\n    await perspective Update(new OrderUpdated { OrderId = Guid Parse(\"123\") });\n    // Assert\n    Assert False(await cache Exists(\"order:123\"));\n}\n`\nBest Practices\nDo's\n✅ Make perspectives idempotent\n`csharp\npublic async Task Update(OrderCreated e) {\n    await db Orders Upsert(e OrderId, order);  // Idempotent\n}\n`\n✅ Handle failures gracefully\n`csharp\npublic async Task Update(OrderCreated e) {\n    try {\n        await externalService Notify(e);\n    } catch (Exception ex) {\n        await deadLetter Queue(e, ex);\n    }\n}\n`\n✅ Keep perspectives focused\n`csharp\n// Each perspective has a single responsibility\npublic class EmailPerspective : IPerspectiveOf<OrderCreated> { }\npublic class InventoryPerspective : IPerspectiveOf<OrderCreated> { }\n`\n✅ Use batching for performance\n`csharp\npublic async Task UpdateBatch(IEnumerable<OrderCreated> events) {\n    await db",
        "startIndex": 9052,
        "preview": "` Idempotent Perspectives Ensure perspectives are idempotent for reliability: `csharp public class IdempotentOrderPerspective : IPerspectiveOf<OrderCr..."
      },
      {
        "id": "core-concepts/perspectives-chunk-5",
        "text": "ex) { await deadLetter Queue(e, ex); } } ` ✅ Keep perspectives focused `csharp // Each perspective has a single responsibility public class EmailPerspective : IPerspectiveOf<OrderCreated> { } public class InventoryPerspective : IPerspectiveOf<OrderCreated> { } ` ✅ Use batching for performance `csharp public async Task UpdateBatch(IEnumerable<OrderCreated> events) { await db BulkInsert(events);\n}\n`\nDon'ts\n❌ Don't emit events from perspectives\n`csharp\n// BAD - Perspectives react, they don't decide\npublic async Task Update(OrderCreated e) {\n    await dispatcher Send(new SendEmail());  // Don't do this }\n`\n❌ Don't call other perspectives directly\n`csharp\n// BAD - Let the dispatcher handle coordination\npublic async Task Update(OrderCreated e) {\n    await otherPerspective Update(e);  // Don't do this }\n`\n❌ Don't make business decisions\n`csharp\n// BAD - Business logic belongs in receptors\npublic async Task Update(OrderCreated e) {\n    if (e Total > 1000) {  // Business rule doesn't belong here\n        await db VipOrders Add(e);\n    }\n}\n`\nAdvanced Patterns\nTemporal Perspectives\nMaintain time-based views:\n`csharp\npublic class DailyStatsPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        var date = e Timestamp Date;\n        await db DailyStats Increment(date, stats => {\n            stats OrderCount++;\n            stats TotalRevenue += e Total;\n            stats AverageOrderValue = stats TotalRevenue / stats OrderCount;\n        });\n    }\n}\n`\nGraph Perspectives\nUpdate graph databases or relationship stores:\n`csharp\npublic class GraphPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await graph CreateNode(\"Order\", e OrderId);\n        await graph CreateNode(\"Customer\", e CustomerId);\n        await graph CreateRelationship(\"PLACED_BY\", e OrderId, e CustomerId);\n        foreach (var item in e Items) {\n            await graph CreateRelationship(\"CONTAINS\", e OrderId, item ProductId);\n        }\n    }\n}\n`\nMachine Learning Perspectives\nFeed ML models or feature stores:\n`csharp\npublic class MLPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await featureStore Update(\"customer_features\", e CustomerId, new {\n            LastOrderDate = e Timestamp,\n            OrderCount = await GetOrderCount(e",
        "startIndex": 10938,
        "preview": "ex) { await deadLetter Queue(e, ex); } } ` ✅ Keep perspectives focused `csharp // Each perspective has a single responsibility public class EmailPersp..."
      },
      {
        "id": "core-concepts/perspectives-chunk-6",
        "text": "Items) { await graph CreateRelationship(\"CONTAINS\", e OrderId, item ProductId); } } } ` Machine Learning Perspectives Feed ML models or feature stores: `csharp public class MLPerspective : IPerspectiveOf<OrderCreated> { public async Task Update(OrderCreated e) { await featureStore Update(\"customer_features\", e CustomerId, new { LastOrderDate = e Timestamp, OrderCount = await GetOrderCount(e CustomerId) + 1,\n            TotalSpent = await GetTotalSpent(e CustomerId) + e Total,\n            PreferredCategory = await DeterminePreferredCategory(e Items)\n        });\n        await mlPipeline TriggerRetrain(\"customer_segmentation\");\n    }\n}\n`\nSummary\nPerspectives are the write-side workhorses of Whizbang:\nReact to events and update various stores\nSame code works in Event-Driven and Event-Sourced modes\nMultiple perspectives provide different views of the same data\nIdempotent and resilient by design\nTestable in isolation\nPerspectives ensure that all state changes flow from events to storage in a consistent, maintainable way Next Steps\nLearn about Lenses - Read-only query interfaces\nExplore Receptors - Event producers\nSee Event-Driven Architecture - Complete picture\nReview Testing Strategies - Testing perspectives",
        "startIndex": 12923,
        "preview": "Items) { await graph CreateRelationship(\"CONTAINS\", e OrderId, item ProductId); } } } ` Machine Learning Perspectives Feed ML models or feature stores..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "core-concepts/projections",
    "title": "Projections",
    "category": "Core Concepts",
    "url": "/docs/core-concepts/projections",
    "chunks": [
      {
        "id": "core-concepts/projections-chunk-0",
        "text": "Projections\nProjections are the read-side component of CQRS in Whizbang They create optimized, denormalized views of your data by subscribing to domain events and building read models tailored for specific query patterns What are Projections Projections transform events from the write-side (aggregates) into read models optimized for queries:\nEvent Subscribers: Listen to domain events as they occur\nRead Model Builders: Create denormalized views optimized for queries\nEventually Consistent: Updated asynchronously as events are processed\nRebuildable: Can be deleted and rebuilt from event history\nKey Benefits\nQuery Optimization\nDenormalized Data: Flatten complex relationships for fast reads\nIndexed Views: Create optimal indexes for specific query patterns\nMultiple Formats: Same events can feed different projection formats\nScalability\nIndependent Scaling: Scale read and write sides independently\nCaching Friendly: Read models can be heavily cached\nDistributed Reads: Replicate read models across regions\nFlexibility\nMultiple Projections: Create different views from same events\nTechnology Choice: Use different databases for different projections\nSchema Evolution: Add new projections without affecting writes\nHow Projections Work\n`mermaid\nsequenceDiagram\n    participant Aggregate\n    participant EventStore as Event Store\n    participant Projection\n    participant ReadDB as Read Database\n    participant Query as Query Handler\n    Aggregate->>EventStore: Save Events\n    EventStore->>Projection: Publish Events\n    Projection->>Projection: Process Events\n    Projection->>ReadDB: Update Read Model\n    Query->>ReadDB: Query Read Model\n    ReadDB->>Query: Return Results\n`\nExample Projection\n`csharp\npublic class OrderSummaryProjection {\n    private readonly IProjectionStore<OrderSummary> _store;\n    public OrderSummaryProjection(IProjectionStore<OrderSummary> store) {\n        _store = store;\n    }\n    // Event handler - creates new read model\n    public async Task Handle(OrderPlacedEvent @event) {\n        await _store UpsertAsync(@event OrderId, new OrderSummary {\n            OrderId = @event OrderId,\n            CustomerId = @event CustomerId,\n            Total = @event Total,\n            Status = \"Placed\",\n            PlacedAt = @event PlacedAt\n        });\n    }\n    // Event handler - updates existing read model\n    public async Task Handle(OrderShippedEvent @event) {\n        await _store UpdateAsync(@event OrderId, summary => {\n            summary Status = \"Shipped\";\n            summary ShippedAt = @event ShippedAt;\n            summary",
        "startIndex": 0,
        "preview": "Projections\nProjections are the read-side component of CQRS in Whizbang They create optimized, denormalized views of your data by subscribing to domai..."
      },
      {
        "id": "core-concepts/projections-chunk-1",
        "text": "@event OrderId, CustomerId = @event CustomerId, Total = @event Total, Status = \"Placed\", PlacedAt = @event PlacedAt }); } // Event handler - updates existing read model public async Task Handle(OrderShippedEvent @event) { await _store UpdateAsync(@event OrderId, summary => { summary Status = \"Shipped\"; summary ShippedAt = @event ShippedAt; summary TrackingNumber = @event TrackingNumber;\n        });\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    public decimal Total { get; set; }\n    public string Status { get; set; }\n    public DateTime PlacedAt { get; set; }\n    public DateTime ShippedAt { get; set; }\n    public string TrackingNumber { get; set; }\n}\n`\nProjection Types\nSimple Projections\nSingle Entity: One event stream → One read model\nDirect Mapping: Events map directly to read model properties\nUse Case: Basic CRUD operations, simple reporting\nComposite Projections\nMultiple Streams: Events from multiple aggregates\nJoined Data: Combine data from different domains\nUse Case: Complex reports, dashboards, analytics\nCached Projections\nMemory-Based: Keep frequently accessed data in memory\nHigh Performance: Sub-millisecond query times\nUse Case: Real-time dashboards, autocomplete\nConfiguration\n`csharp\nservices AddWhizbang(options => {\n    options UseProjections(proj => {\n        // Register projection\n        proj RegisterProjection<OrderSummaryProjection>(p => {\n            p Subscribe<OrderPlacedEvent>();\n            p Subscribe<OrderShippedEvent>();\n            p Subscribe<OrderCancelledEvent>();\n        });\n        // Configure backfilling\n        proj BackfillFromBeginning = true;\n        // Configure partitioning\n        proj PartitionBy = @event => ((dynamic)@event)",
        "startIndex": 2568,
        "preview": "@event OrderId, CustomerId = @event CustomerId, Total = @event Total, Status = \"Placed\", PlacedAt = @event PlacedAt }); } // Event handler - updates e..."
      },
      {
        "id": "core-concepts/projections-chunk-2",
        "text": "High Performance: Sub-millisecond query times Use Case: Real-time dashboards, autocomplete Configuration `csharp services AddWhizbang(options => { options UseProjections(proj => { // Register projection proj RegisterProjection<OrderSummaryProjection>(p => { p Subscribe<OrderPlacedEvent>(); p Subscribe<OrderShippedEvent>(); p Subscribe<OrderCancelledEvent>(); }); // Configure backfilling proj BackfillFromBeginning = true; // Configure partitioning proj PartitionBy = @event => ((dynamic)@event) OrderId;\n    });\n});\n`\nAdvanced Features\nBackfilling\nHistorical Data: Process events from before projection was created\nIncremental: Resume from last processed event\nParallel: Process multiple partitions concurrently\nEvent Filtering\nSelective Processing: Only process relevant events\nPattern Matching: Subscribe to events by type or properties\nPerformance: Reduce unnecessary processing\nSchema Evolution\nVersioning: Handle projection schema changes\nMigration: Update existing read models\nBackward Compatibility: Support multiple projection versions\nBest Practices\nDesign for Queries\nQuery-First: Design projections around actual query needs\nDenormalize: Include all data needed for queries\nIndex Appropriately: Add indexes for query patterns\nHandle Failures\nRetry Logic: Handle transient failures\nDead Letter Queues: Capture failed events\nMonitoring: Track projection health and lag\nPerformance Optimization\nBatch Processing: Process events in batches\nAsync Processing: Use async/await throughout\nConnection Pooling: Optimize database connections\nStorage Options\nWhizbang supports multiple projection storage backends:\nSQL Databases: Postgres, SQL Server, MySQL\nDocument Stores: MongoDB, CosmosDB\nSearch Engines: Elasticsearch, Azure Search\nKey-Value Stores: Redis, DynamoDB\nMemory: In-memory caching\nRelated Topics\nCore Concepts - Overview of CQRS and event sourcing\nProjection Subscriptions - Configuring event subscriptions\nProjection Contexts - Managing projection lifecycle\nGetting Started - Tutorial building your first projection\nNext Steps\nThis page provides an overview of projections in Whizbang For detailed implementation patterns and advanced scenarios, explore the specialized projection documentation in the Projections section",
        "startIndex": 3986,
        "preview": "High Performance: Sub-millisecond query times Use Case: Real-time dashboards, autocomplete Configuration `csharp services AddWhizbang(options => { opt..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "core-concepts/receptors",
    "title": "Receptors",
    "category": "Core Concepts",
    "url": "/docs/core-concepts/receptors",
    "chunks": [
      {
        "id": "core-concepts/receptors-chunk-0",
        "text": "Receptors\nOverview\nReceptors are the decision-making components in Whizbang They receive commands, apply business rules, and emit events representing the decisions made The same receptor interface works in both Event-Driven (stateless) and Event-Sourced (stateful) modes, making them the cornerstone of Whizbang's progressive enhancement philosophy What is a Receptor A Receptor:\nReceives commands from external sources\nDecides what should happen based on business rules\nEmits events representing those decisions\nNever performs side effects directly\nThink of a receptor as a pure decision function: given a command and current state, what event(s) should occur The Universal Interface\n`csharp\npublic interface IReceptor<TCommand> {\n    object Receive(TCommand command);\n}\n`\nThe return type determines what happens:\nSingle event → Published to perspectives\nMultiple events (tuple) → All published\nResult<TEvent> → Success/failure handling\nvoid → No events (rare)\nStateless Receptors (Event-Driven Mode)\nIn Event-Driven mode, receptors are stateless and get current state from Lenses:\n`csharp\npublic class OrderReceptor : IReceptor<CreateOrder> {\n    // Stateless - gets state from lens parameter\n    public OrderCreated Receive(CreateOrder cmd, IOrderLens lens) {\n        // Validate using lens (read-only)\n        var customer = lens GetCustomer(cmd CustomerId);\n        if ( customer IsActive) {\n            throw new InactiveCustomerException();\n        }\n        // Check inventory through lens\n        var inventory = lens GetInventory(cmd Items);\n        if ( inventory HasStock()) {\n            throw new OutOfStockException();\n        }\n        // Make decision and emit event\n        return new OrderCreated(\n            Guid NewGuid(),\n            cmd CustomerId,\n            cmd Items,\n            CalculateTotal(cmd Items),\n            DateTime",
        "startIndex": 0,
        "preview": "Receptors\nOverview\nReceptors are the decision-making components in Whizbang They receive commands, apply business rules, and emit events representing ..."
      },
      {
        "id": "core-concepts/receptors-chunk-1",
        "text": "lens GetCustomer(cmd CustomerId); if ( customer IsActive) { throw new InactiveCustomerException(); } // Check inventory through lens var inventory = lens GetInventory(cmd Items); if ( inventory HasStock()) { throw new OutOfStockException(); } // Make decision and emit event return new OrderCreated( Guid NewGuid(), cmd CustomerId, cmd Items, CalculateTotal(cmd Items), DateTime UtcNow\n        );\n    }\n}\n`\nCharacteristics of Stateless Receptors\nGet state from Lens parameters\nCreated per request (transient lifetime)\nNo internal state between calls\nPerfect for simple CRUD operations\nStateful Receptors (Event-Sourced Mode)\nIn Event-Sourced mode, receptors maintain internal state rebuilt from events:\n`csharp\n[EventSourced]\npublic class OrderReceptor : \n    IReceptor<CreateOrder>,\n    IReceptor<AddItem>,\n    IReceptor<RemoveItem>,\n    IReceptor<ShipOrder> {\n    // Internal state maintained from events\n    private Guid id;\n    private Guid customerId;\n    private List<OrderItem> items = new();\n    private OrderStatus status;\n    private decimal total;\n    // Command handlers - no lens needed\n    public OrderCreated Receive(CreateOrder cmd) {\n        if (id = Guid Empty) {\n            throw new InvalidOperationException(\"Order already created\");\n        }\n        return new OrderCreated(\n            Guid NewGuid(),\n            cmd CustomerId,\n            cmd Items,\n            cmd Items Sum(i => i Quantity * i Price),\n            DateTime UtcNow\n        );\n    }\n    public ItemAdded Receive(AddItem cmd) {\n        if (status = OrderStatus Pending) {\n            throw new InvalidOperationException(\"Cannot modify shipped order\");\n        }\n        var newTotal = total + (cmd Quantity * cmd Price);\n        return new ItemAdded(id, cmd ProductId, cmd Quantity, cmd Price, newTotal);\n    }\n    public OrderShipped Receive(ShipOrder cmd) {\n        if (status = OrderStatus Paid) {\n            throw new InvalidOperationException(\"Order must be paid before shipping\");\n        }\n        return new OrderShipped(id, cmd TrackingNumber, DateTime UtcNow);\n    }\n    // Event handlers - update internal state\n    public void Absorb(OrderCreated e) {\n        id = e OrderId;\n        customerId = e CustomerId;\n        items = e Items ToList();\n        total = e Total;\n        status = OrderStatus Pending;\n    }\n    public void Absorb(ItemAdded e) {\n        items Add(new OrderItem(e ProductId, e Quantity, e Price));\n        total = e NewTotal;\n    }\n    public void Absorb(OrderShipped e) {\n        status = OrderStatus",
        "startIndex": 1861,
        "preview": "lens GetCustomer(cmd CustomerId); if ( customer IsActive) { throw new InactiveCustomerException(); } // Check inventory through lens var inventory = l..."
      },
      {
        "id": "core-concepts/receptors-chunk-2",
        "text": "e) { id = e OrderId; customerId = e CustomerId; items = e Items ToList(); total = e Total; status = OrderStatus Pending; } public void Absorb(ItemAdded e) { items Add(new OrderItem(e ProductId, e Quantity, e Price)); total = e NewTotal; } public void Absorb(OrderShipped e) { status = OrderStatus Shipped;\n    }\n}\n`\nCharacteristics of Stateful Receptors\nMaintain internal state from event stream\nState rebuilt by replaying events\nLong-lived (cached between requests)\nPerfect for complex domain logic\nReturn Type Semantics\nWhat you return determines what happens:\n`csharp\npublic class PaymentReceptor : IReceptor<ProcessPayment> {\n    // Single event - published to perspectives\n    public PaymentProcessed Receive(ProcessPayment cmd) {\n        return new PaymentProcessed(cmd OrderId, cmd Amount);\n    }\n    // Multiple events - all published\n    public (PaymentProcessed, EmailQueued, InventoryReserved) ReceiveWithEffects(ProcessPayment cmd) {\n        return (\n            new PaymentProcessed(cmd OrderId, cmd Amount),\n            new EmailQueued(cmd CustomerEmail, \"Payment received\"),\n            new InventoryReserved(cmd OrderId, cmd Items)\n        );\n    }\n    // Result type - success/failure handling\n    public Result<PaymentProcessed> ReceiveWithValidation(ProcessPayment cmd) {\n        if (cmd Amount <= 0) {\n            return Result Failure<PaymentProcessed>(\"Invalid amount\");\n        }\n        return Result Success(new PaymentProcessed(cmd OrderId, cmd Amount));\n    }\n}\n`\nEvolution Pattern\nReceptors naturally evolve from stateless to stateful as complexity grows:\nStage 1: Simple Stateless\n`csharp\npublic class ProductReceptor : IReceptor<CreateProduct> {\n    public ProductCreated Receive(CreateProduct cmd) {\n        return new ProductCreated(Guid NewGuid(), cmd Name, cmd Price);\n    }\n}\n`\nStage 2: Stateless with Validation\n`csharp\npublic class ProductReceptor : IReceptor<CreateProduct> {\n    public ProductCreated Receive(CreateProduct cmd, IProductLens lens) {\n        if (lens Exists(p => p Name == cmd Name)) {\n            throw new DuplicateProductException();\n        }\n        return new ProductCreated(Guid NewGuid(), cmd Name, cmd",
        "startIndex": 4015,
        "preview": "e) { id = e OrderId; customerId = e CustomerId; items = e Items ToList(); total = e Total; status = OrderStatus Pending; } public void Absorb(ItemAdde..."
      },
      {
        "id": "core-concepts/receptors-chunk-3",
        "text": "new ProductCreated(Guid NewGuid(), cmd Name, cmd Price); } } ` Stage 2: Stateless with Validation `csharp public class ProductReceptor : IReceptor<CreateProduct> { public ProductCreated Receive(CreateProduct cmd, IProductLens lens) { if (lens Exists(p => p Name == cmd Name)) { throw new DuplicateProductException(); } return new ProductCreated(Guid NewGuid(), cmd Name, cmd Price);\n    }\n}\n`\nStage 3: Multiple Commands\n`csharp\npublic class ProductReceptor : \n    IReceptor<CreateProduct>,\n    IReceptor<UpdatePrice>,\n    IReceptor<Discontinue> {\n    // Multiple related commands suggest need for state\n}\n`\nStage 4: Stateful (Event-Sourced)\n`csharp\n[EventSourced]\npublic class ProductReceptor : \n    IReceptor<CreateProduct>,\n    IReceptor<UpdatePrice>,\n    IReceptor<Discontinue> {\n    private Guid id;\n    private decimal price;\n    private bool isDiscontinued;\n    // Now maintains state across commands\n}\n`\nReceptor Configuration\nConfigure receptors via policies:\n`csharp\nservices AddWhizbang() UseDispatcher(dispatcher => {\n        // Register all receptors\n        dispatcher RegisterReceptorsFromAssembly(typeof(Program) Assembly);\n        // Configure specific receptors\n        dispatcher ForReceptor<OrderReceptor>() UsePolicy(new EventSourcedPolicy {\n                SnapshotFrequency = 100,\n                CacheDuration = TimeSpan FromMinutes(5)\n            });\n        dispatcher ForReceptor<NotificationReceptor>() UsePolicy(new EventDrivenPolicy {\n                MaxConcurrency = 10\n            });\n    });\n`\nBest Practices\nDo's\n✅ Keep receptors focused on decisions\n`csharp\npublic OrderCreated Receive(CreateOrder cmd) {\n    // Only business logic and decision making\n    return new OrderCreated( );\n}\n`\n✅ Use descriptive event names\n`csharp\nreturn new OrderShipmentInitiated( );  // Clear what happened\n`\n✅ Validate business rules\n`csharp\nif (status = OrderStatus Paid) {\n    throw new BusinessRuleViolationException(\"Order must be paid\");\n}\n`\n✅ Return events for all state changes\n`csharp\npublic PriceUpdated Receive(UpdatePrice cmd) {\n    return new PriceUpdated(id, oldPrice, cmd NewPrice);\n}\n`\nDon'ts\n❌ Don't perform side effects\n`csharp\n// BAD - Side effect in receptor\npublic OrderCreated Receive(CreateOrder cmd) {\n    emailService SendEmail( );  // Don't do this database Save( );           // Don't do this return new OrderCreated(",
        "startIndex": 5883,
        "preview": "new ProductCreated(Guid NewGuid(), cmd Name, cmd Price); } } ` Stage 2: Stateless with Validation `csharp public class ProductReceptor : IReceptor<Cre..."
      },
      {
        "id": "core-concepts/receptors-chunk-4",
        "text": "`csharp public PriceUpdated Receive(UpdatePrice cmd) { return new PriceUpdated(id, oldPrice, cmd NewPrice); } ` Don'ts ❌ Don't perform side effects `csharp // BAD - Side effect in receptor public OrderCreated Receive(CreateOrder cmd) { emailService SendEmail( ); // Don't do this database Save( ); // Don't do this return new OrderCreated( );\n}\n`\n❌ Don't mix read and write concerns\n`csharp\n// BAD - Receptor shouldn't query\npublic OrderList Receive(GetOrders query) {  // Use Lens instead\n`\n❌ Don't mutate command parameters\n`csharp\n// BAD - Commands are immutable\ncmd Items Add(newItem);  // Don't modify `\nTesting Receptors\nReceptors are easy to test because they're pure decision functions:\n`csharp\n[Fact]\npublic void CreateOrder_ValidCommand_ReturnsOrderCreatedEvent() {\n    // Arrange\n    var receptor = new OrderReceptor();\n    var command = new CreateOrder {\n        CustomerId = Guid NewGuid(),\n        Items = new[] { new OrderItem(\"SKU-1\", 2, 10 00m) }\n    };\n    // Act\n    var @event = receptor Receive(command);\n    // Assert\n    Assert IsType<OrderCreated>(@event);\n    var orderCreated = (OrderCreated)@event;\n    Assert Equal(command CustomerId, orderCreated CustomerId);\n    Assert Equal(20 00m, orderCreated Total);\n}\n[Fact]\npublic void ShipOrder_UnpaidOrder_ThrowsException() {\n    // Arrange\n    var receptor = new OrderReceptor();\n    receptor Absorb(new OrderCreated( ));  // Not paid\n    // Act & Assert\n    Assert Throws<BusinessRuleViolationException>(\n        () => receptor Receive(new ShipOrder( ))\n    );\n}\n`\nAdvanced Patterns\nCompensating Events\n`csharp\npublic class PaymentReceptor : IReceptor<RefundPayment> {\n    public (PaymentRefunded, InventoryReleased) Receive(RefundPayment cmd) {\n        if (status = PaymentStatus Completed) {\n            throw new InvalidOperationException(\"Can only refund completed payments\");\n        }\n        // Return compensating events\n        return (\n            new PaymentRefunded(id, amount, DateTime UtcNow),\n            new InventoryReleased(orderId, items)  // Compensate inventory\n        );\n    }\n}\n`\nConditional Events\n`csharp\npublic class OrderReceptor : IReceptor<CompleteOrder> {\n    public object Receive(CompleteOrder cmd) {\n        return status switch {\n            OrderStatus Pending => new OrderCompleted(id),\n            OrderStatus",
        "startIndex": 7920,
        "preview": "`csharp public PriceUpdated Receive(UpdatePrice cmd) { return new PriceUpdated(id, oldPrice, cmd NewPrice); } ` Don'ts ❌ Don't perform side effects `c..."
      },
      {
        "id": "core-concepts/receptors-chunk-5",
        "text": "only refund completed payments\"); } // Return compensating events return ( new PaymentRefunded(id, amount, DateTime UtcNow), new InventoryReleased(orderId, items) // Compensate inventory ); } } ` Conditional Events `csharp public class OrderReceptor : IReceptor<CompleteOrder> { public object Receive(CompleteOrder cmd) { return status switch { OrderStatus Pending => new OrderCompleted(id), OrderStatus OnHold => (object)(\n                new OrderReleased(id),\n                new OrderCompleted(id)\n            ),\n            _ => throw new InvalidOperationException($\"Cannot complete order in {status} status\")\n        };\n    }\n}\n`\nSaga Initiation\n`csharp\npublic class CheckoutReceptor : IReceptor<Checkout> {\n    public (CheckoutStarted, ReserveInventory, ProcessPayment) Receive(Checkout cmd) {\n        // Start a distributed transaction\n        return (\n            new CheckoutStarted(cmd OrderId),\n            new ReserveInventory(cmd OrderId, cmd Items),\n            new ProcessPayment(cmd OrderId, cmd PaymentMethod, cmd Total)\n        );\n    }\n}\n`\nSummary\nReceptors are the heart of Whizbang's decision-making:\nUniversal interface works in both Event-Driven and Event-Sourced modes\nPure functions that transform commands into events\nProgressive enhancement from stateless to stateful\nTestable without infrastructure dependencies\nComposable through return type semantics\nWhether stateless or stateful, receptors ensure your business logic remains clean, testable, and portable across different deployment modes Next Steps\nExplore Perspectives - How events update views\nLearn about Lenses - Read-only state access\nSee Event-Driven Architecture - The bigger picture\nReview Testing Strategies - Testing receptors",
        "startIndex": 9908,
        "preview": "only refund completed payments\"); } // Return compensating events return ( new PaymentRefunded(id, amount, DateTime UtcNow), new InventoryReleased(ord..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "core-concepts/repositories-and-helpers",
    "title": "Repositories and CQRS Helpers",
    "category": "Core Concepts",
    "url": "/docs/core-concepts/repositories-and-helpers",
    "chunks": [
      {
        "id": "core-concepts/repositories-and-helpers-chunk-0",
        "text": "Repositories and CQRS Helpers\nWhizbang provides rich framework support for implementing CQRS patterns through repositories, query handlers, and helper classes that separate concerns across the write and read sides of your application Repository Patterns\nWrite-Side Repository (Aggregates)\nThe IRepository<TAggregate> interface handles loading and saving event-sourced aggregates:\n`csharp{\ntitle: \"Aggregate Repository Interface\"\ndescription: \"Core interface for aggregate persistence\"\nframework: \"NET8\"\ncategory: \"Repositories\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Repositories\", \"Aggregates\", \"Event Sourcing\"]\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nnamespace Whizbang EventSourcing;\npublic interface IRepository<TAggregate> where TAggregate : Aggregate {\n    /// <summary>\n    /// Loads an aggregate by replaying its event stream /// </summary>\n    Task<TAggregate > FindAsync(Guid id, CancellationToken ct = default);\n    /// <summary>\n    /// Loads an aggregate, throwing if not found /// </summary>\n    Task<TAggregate> GetAsync(Guid id, CancellationToken ct = default);\n    /// <summary>\n    /// Saves uncommitted events from the aggregate to the event store /// </summary>\n    Task SaveAsync(TAggregate aggregate, CancellationToken ct = default);\n    /// <summary>\n    /// Loads aggregate as of a specific version (point-in-time query) /// </summary>\n    Task<TAggregate > GetAsOfAsync(Guid id, long version, CancellationToken ct = default);\n    /// <summary>\n    /// Loads aggregate as of a specific timestamp (time-travel debugging) /// </summary>\n    Task<TAggregate > GetAsOfAsync(Guid id, DateTimeOffset timestamp, CancellationToken ct = default);\n}\n`\nUsage:\n`csharp{\ntitle: \"Using Aggregate Repository\"\ndescription: \"Load, modify, and save an aggregate\"\nframework: \"NET8\"\ncategory: \"Repositories\"\ndifficulty: \"BEGINNER\"\ntags: [\"Repositories\", \"Aggregates\", \"Commands\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\npublic class PlaceOrderHandler {\n    private readonly IRepository<Order> _orderRepository;\n    public PlaceOrderHandler(IRepository<Order> orderRepository) {\n        _orderRepository = orderRepository;\n    }\n    public async Task<OrderPlaced> Handle(PlaceOrder command) {\n        // Create new aggregate\n        var order = new Order(command CustomerId, command Items);\n        // Save (appends events to stream)\n        await _orderRepository SaveAsync(order);\n        return new OrderPlaced(order Id, command CustomerId, order",
        "startIndex": 0,
        "preview": "Repositories and CQRS Helpers\nWhizbang provides rich framework support for implementing CQRS patterns through repositories, query handlers, and helper..."
      },
      {
        "id": "core-concepts/repositories-and-helpers-chunk-1",
        "text": "public class PlaceOrderHandler { private readonly IRepository<Order> _orderRepository; public PlaceOrderHandler(IRepository<Order> orderRepository) { _orderRepository = orderRepository; } public async Task<OrderPlaced> Handle(PlaceOrder command) { // Create new aggregate var order = new Order(command CustomerId, command Items); // Save (appends events to stream) await _orderRepository SaveAsync(order); return new OrderPlaced(order Id, command CustomerId, order Total);\n    }\n}\n`\nRead-Side Repository (Projections)\nThe IProjectionStore<TProjection> interface handles querying denormalized read models:\n`csharp{\ntitle: \"Projection Store Interface\"\ndescription: \"Interface for querying read models\"\nframework: \"NET8\"\ncategory: \"Repositories\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Queries\", \"CQRS\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\", \"System Linq Expressions\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Linq Expressions;\nusing System Threading Tasks;\nnamespace Whizbang Projections;\npublic interface IProjectionStore<TProjection> where TProjection : class {\n    /// <summary>\n    /// Gets a projection by ID /// </summary>\n    Task<TProjection > GetAsync(Guid id, CancellationToken ct = default);\n    /// <summary>\n    /// Queries projections using a predicate /// </summary>\n    Task<List<TProjection>> QueryAsync(\n        Expression<Func<TProjection, bool>> predicate,\n        CancellationToken ct = default\n    );\n    /// <summary>\n    /// Paged query for large result sets /// </summary>\n    Task<PagedResult<TProjection>> QueryPagedAsync(\n        Expression<Func<TProjection, bool>> predicate,\n        int page,\n        int pageSize,\n        CancellationToken ct = default\n    );\n    /// <summary>\n    /// Inserts or updates a projection /// </summary>\n    Task UpsertAsync(Guid id, TProjection projection, CancellationToken ct = default);\n    /// <summary>\n    /// Updates an existing projection /// </summary>\n    Task UpdateAsync(Guid id, Action<TProjection> update, CancellationToken ct = default);\n    /// <summary>\n    /// Deletes a projection /// </summary>\n    Task DeleteAsync(Guid id, CancellationToken ct = default);\n}\n`\nUsage:\n`csharp{\ntitle: \"Querying Projection Store\"\ndescription: \"Query read models for customer orders\"\nframework: \"NET8\"\ncategory: \"Repositories\"\ndifficulty: \"BEGINNER\"\ntags: [\"Projections\", \"Queries\", \"CQRS\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\", \"Whizbang Projections\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nusing Whizbang",
        "startIndex": 2668,
        "preview": "public class PlaceOrderHandler { private readonly IRepository<Order> _orderRepository; public PlaceOrderHandler(IRepository<Order> orderRepository) { ..."
      },
      {
        "id": "core-concepts/repositories-and-helpers-chunk-2",
        "text": "} ` Usage: `csharp{ title: \"Querying Projection Store\" description: \"Query read models for customer orders\" framework: \"NET8\" category: \"Repositories\" difficulty: \"BEGINNER\" tags: [\"Projections\", \"Queries\", \"CQRS\"] usingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\", \"Whizbang Projections\"] showLineNumbers: true } using System; using System Collections Generic; using System Threading Tasks; using Whizbang Projections;\npublic class OrderQueryService {\n    private readonly IProjectionStore<OrderHistoryItem> _store;\n    public OrderQueryService(IProjectionStore<OrderHistoryItem> store) {\n        _store = store;\n    }\n    public async Task<List<OrderHistoryItem>> GetCustomerOrdersAsync(Guid customerId) {\n        return await _store QueryAsync(order => order CustomerId == customerId);\n    }\n    public async Task<PagedResult<OrderHistoryItem>> GetRecentOrdersAsync(int page, int pageSize) {\n        return await _store QueryPagedAsync(\n            order => order Status = \"Cancelled\",\n            page,\n            pageSize\n        );\n    }\n}\n`\nCQRS Helper Classes\nCommand Bus\nThe ICommandBus sends commands to their handlers:\n`csharp{\ntitle: \"Command Bus Interface\"\ndescription: \"Send commands and receive results\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"CQRS\", \"Messaging\"]\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nnamespace Whizbang;\npublic interface ICommandBus {\n    /// <summary>\n    /// Sends a command and waits for result /// </summary>\n    Task<TResult> SendAsync<TResult>(object command, CancellationToken ct = default);\n    /// <summary>\n    /// Sends a command without waiting for result (fire-and-forget) /// </summary>\n    Task PublishAsync(object command, CancellationToken ct = default);\n    /// <summary>\n    /// Sends multiple commands in a batch /// </summary>\n    Task PublishBatchAsync(IEnumerable<object> commands, CancellationToken ct = default);\n}\n`\nQuery Bus\nThe IQueryBus executes queries against projections:\n`csharp{\ntitle: \"Query Bus Interface\"\ndescription: \"Execute queries and return results\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Queries\", \"CQRS\", \"Projections\"]\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nnamespace Whizbang;\npublic interface IQueryBus {\n    /// <summary>\n    /// Executes a query and returns result",
        "startIndex": 4910,
        "preview": "} ` Usage: `csharp{ title: \"Querying Projection Store\" description: \"Query read models for customer orders\" framework: \"NET8\" category: \"Repositories\"..."
      },
      {
        "id": "core-concepts/repositories-and-helpers-chunk-3",
        "text": "`csharp{ title: \"Query Bus Interface\" description: \"Execute queries and return results\" framework: \"NET8\" category: \"CQRS\" difficulty: \"INTERMEDIATE\" tags: [\"Queries\", \"CQRS\", \"Projections\"] usingStatements: [\"System\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading Tasks; namespace Whizbang; public interface IQueryBus { /// <summary> /// Executes a query and returns result /// </summary>\n    Task<TResult> QueryAsync<TResult>(object query, CancellationToken ct = default);\n}\n`\nUsage:\n`csharp{\ntitle: \"Using Query Bus\"\ndescription: \"Execute queries via query bus\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"BEGINNER\"\ntags: [\"Queries\", \"CQRS\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nusing Whizbang;\n// Define query\npublic record GetCustomerOrders(Guid CustomerId);\n// Define query handler\npublic class GetCustomerOrdersHandler {\n    private readonly IProjectionStore<OrderHistoryItem> _store;\n    public GetCustomerOrdersHandler(IProjectionStore<OrderHistoryItem> store) {\n        _store = store;\n    }\n    public async Task<List<OrderHistoryItem>> Handle(GetCustomerOrders query) {\n        return await _store QueryAsync(o => o CustomerId == query CustomerId);\n    }\n}\n// Execute query\npublic class OrderController {\n    private readonly IQueryBus _queryBus;\n    public OrderController(IQueryBus queryBus) {\n        _queryBus = queryBus;\n    }\n    public async Task<IActionResult> GetOrders(Guid customerId) {\n        var orders = await _queryBus QueryAsync<List<OrderHistoryItem>>(\n            new GetCustomerOrders(customerId)\n        );\n        return Ok(orders);\n    }\n}\n`\nEvent Publisher\nThe IEventPublisher publishes domain events to subscribers:\n`csharp{\ntitle: \"Event Publisher Interface\"\ndescription: \"Publish events to subscribers\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Events\", \"Publishing\", \"Messaging\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nnamespace Whizbang;\npublic interface IEventPublisher {\n    /// <summary>\n    /// Publishes a single event to all subscribers /// </summary>\n    Task PublishAsync(object @event, CancellationToken ct = default);\n    /// <summary>\n    /// Publishes multiple events in order /// </summary>\n    Task PublishBatchAsync(IEnumerable<object> events, CancellationToken ct = default);\n    /// <summary>\n    /// Publishes event to specific subscribers (filtered)",
        "startIndex": 7012,
        "preview": "`csharp{ title: \"Query Bus Interface\" description: \"Execute queries and return results\" framework: \"NET8\" category: \"CQRS\" difficulty: \"INTERMEDIATE\" ..."
      },
      {
        "id": "core-concepts/repositories-and-helpers-chunk-4",
        "text": "Whizbang; public interface IEventPublisher { /// <summary> /// Publishes a single event to all subscribers /// </summary> Task PublishAsync(object @event, CancellationToken ct = default); /// <summary> /// Publishes multiple events in order /// </summary> Task PublishBatchAsync(IEnumerable<object> events, CancellationToken ct = default); /// <summary> /// Publishes event to specific subscribers (filtered) /// </summary>\n    Task PublishToAsync(object @event, string subscriberFilter, CancellationToken ct = default);\n}\n`\nSpecialized Helpers\nUnit of Work Pattern\nFor scenarios requiring transactional consistency across multiple aggregates:\n`csharp{\ntitle: \"Unit of Work Interface\"\ndescription: \"Transactional boundary for multiple aggregates\"\nframework: \"NET8\"\ncategory: \"Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Unit of Work\", \"Transactions\", \"Aggregates\"]\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nnamespace Whizbang EventSourcing;\npublic interface IUnitOfWork : IDisposable {\n    /// <summary>\n    /// Gets a repository for an aggregate type /// </summary>\n    IRepository<TAggregate> Repository<TAggregate>() where TAggregate : Aggregate;\n    /// <summary>\n    /// Commits all changes across all aggregates /// </summary>\n    Task CommitAsync(CancellationToken ct = default);\n    /// <summary>\n    /// Rolls back all changes /// </summary>\n    Task RollbackAsync(CancellationToken ct = default);\n}\n`\nUsage (use sparingly - violates aggregate boundaries):\n`csharp{\ntitle: \"Using Unit of Work\"\ndescription: \"Transactional update across multiple aggregates\"\nframework: \"NET8\"\ncategory: \"Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Unit of Work\", \"Transactions\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang EventSourcing\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang EventSourcing;\npublic class TransferInventoryHandler {\n    private readonly IUnitOfWork _unitOfWork;\n    public TransferInventoryHandler(IUnitOfWork unitOfWork) {\n        _unitOfWork = unitOfWork;\n    }\n    public async Task Handle(TransferInventory command) {\n        var sourceWarehouse = await _unitOfWork Repository<Warehouse>() GetAsync(command SourceWarehouseId);\n        var destWarehouse = await _unitOfWork Repository<Warehouse>() GetAsync(command DestinationWarehouseId);\n        // Both aggregates modified in same transaction\n        sourceWarehouse RemoveInventory(command ProductId, command Quantity);\n        destWarehouse AddInventory(command ProductId, command Quantity);\n        await _unitOfWork Repository<Warehouse>() SaveAsync(sourceWarehouse);\n        await _unitOfWork Repository<Warehouse>() SaveAsync(destWarehouse);\n        // Atomic commit\n        await _unitOfWork",
        "startIndex": 9302,
        "preview": "Whizbang; public interface IEventPublisher { /// <summary> /// Publishes a single event to all subscribers /// </summary> Task PublishAsync(object @ev..."
      },
      {
        "id": "core-concepts/repositories-and-helpers-chunk-5",
        "text": "Task Handle(TransferInventory command) { var sourceWarehouse = await _unitOfWork Repository<Warehouse>() GetAsync(command SourceWarehouseId); var destWarehouse = await _unitOfWork Repository<Warehouse>() GetAsync(command DestinationWarehouseId); // Both aggregates modified in same transaction sourceWarehouse RemoveInventory(command ProductId, command Quantity); destWarehouse AddInventory(command ProductId, command Quantity); await _unitOfWork Repository<Warehouse>() SaveAsync(sourceWarehouse); await _unitOfWork Repository<Warehouse>() SaveAsync(destWarehouse); // Atomic commit await _unitOfWork CommitAsync();\n    }\n}\n`\nWarning: Use sagas instead when possible to maintain aggregate boundaries Specification Pattern\nFor complex query logic:\n`csharp{\ntitle: \"Specification Pattern\"\ndescription: \"Reusable query specifications\"\nframework: \"NET8\"\ncategory: \"Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Specification\", \"Queries\", \"Patterns\"]\nusingStatements: [\"System\", \"System Linq Expressions\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Linq Expressions;\nnamespace Whizbang Projections;\npublic interface ISpecification<TProjection> {\n    Expression<Func<TProjection, bool>> Predicate { get; }\n}\npublic class ActiveOrdersSpecification : ISpecification<OrderHistoryItem> {\n    public Expression<Func<OrderHistoryItem, bool>> Predicate =>\n        order => order Status = \"Cancelled\" && order Status = \"Delivered\";\n}\npublic class CustomerOrdersSpecification : ISpecification<OrderHistoryItem> {\n    private readonly Guid _customerId;\n    public CustomerOrdersSpecification(Guid customerId) {\n        _customerId = customerId;\n    }\n    public Expression<Func<OrderHistoryItem, bool>> Predicate =>\n        order => order CustomerId == _customerId;\n}\n`\nUsage:\n`csharp{\ntitle: \"Using Specifications\"\ndescription: \"Compose reusable query specifications\"\nframework: \"NET8\"\ncategory: \"Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Specification\", \"Queries\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\", \"Whizbang Projections\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nusing Whizbang Projections;\npublic class OrderQueryService {\n    private readonly IProjectionStore<OrderHistoryItem> _store;\n    public OrderQueryService(IProjectionStore<OrderHistoryItem> store) {\n        _store = store;\n    }\n    public async Task<List<OrderHistoryItem>> GetActiveCustomerOrdersAsync(Guid customerId) {\n        var spec = new ActiveOrdersSpecification() And(new CustomerOrdersSpecification(customerId));\n        return await _store QueryAsync(spec Predicate);\n    }\n}\n`\nProjection Builder\nHelper for building complex projections:\n`csharp{\ntitle: \"Projection Builder\"\ndescription: \"Fluent API for building projections\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Builder Pattern\"]\nusingStatements: [\"System\", \"Whizbang Projections\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang",
        "startIndex": 11761,
        "preview": "Task Handle(TransferInventory command) { var sourceWarehouse = await _unitOfWork Repository<Warehouse>() GetAsync(command SourceWarehouseId); var dest..."
      },
      {
        "id": "core-concepts/repositories-and-helpers-chunk-6",
        "text": "new ActiveOrdersSpecification() And(new CustomerOrdersSpecification(customerId)); return await _store QueryAsync(spec Predicate); } } ` Projection Builder Helper for building complex projections: `csharp{ title: \"Projection Builder\" description: \"Fluent API for building projections\" framework: \"NET8\" category: \"Projections\" difficulty: \"ADVANCED\" tags: [\"Projections\", \"Builder Pattern\"] usingStatements: [\"System\", \"Whizbang Projections\"] showLineNumbers: true } using System; using Whizbang Projections;\npublic class OrderSummaryProjectionBuilder : ProjectionBuilder<OrderSummary> {\n    public OrderSummaryProjectionBuilder() {\n        // Subscribe to events\n        On<OrderPlaced>(@event => {\n            Upsert(@event OrderId, new OrderSummary {\n                OrderId = @event OrderId,\n                CustomerId = @event CustomerId,\n                Total = @event Total,\n                Status = \"Placed\"\n            });\n        });\n        On<OrderShipped>(@event => {\n            Update(@event OrderId, summary => {\n                summary Status = \"Shipped\";\n                summary ShippedAt = @event ShippedAt;\n            });\n        });\n        On<OrderCancelled>(@event => {\n            Update(@event OrderId, summary => summary Status = \"Cancelled\");\n        });\n    }\n}\n`\nMulti-Tenant Repository Support\nAll repository interfaces support tenant scoping:\n`csharp{\ntitle: \"Multi-Tenant Repository\"\ndescription: \"Tenant-scoped aggregate repository\"\nframework: \"NET8\"\ncategory: \"Multi-Tenancy\"\ndifficulty: \"ADVANCED\"\ntags: [\"Multi-Tenancy\", \"Repositories\", \"Security\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang EventSourcing\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang EventSourcing;\npublic interface ITenantRepository<TAggregate> where TAggregate : Aggregate {\n    /// <summary>\n    /// Loads aggregate for specific tenant /// </summary>\n    Task<TAggregate > FindAsync(Guid tenantId, Guid aggregateId, CancellationToken ct = default);\n    /// <summary>\n    /// Saves aggregate with tenant isolation /// Stream ID: \"Tenant-{tenantId}-Order-{orderId}\"\n    /// </summary>\n    Task SaveAsync(Guid tenantId, TAggregate aggregate, CancellationToken ct = default);\n}\n// Usage with tenant context\npublic class PlaceOrderHandler {\n    private readonly ITenantRepository<Order> _repository;\n    private readonly ITenantContext _tenantContext;\n    public PlaceOrderHandler(ITenantRepository<Order> repository, ITenantContext tenantContext) {\n        _repository = repository;\n        _tenantContext = tenantContext;\n    }\n    public async Task<OrderPlaced> Handle(PlaceOrder command) {\n        var order = new Order(command CustomerId, command Items);\n        // Tenant ID from context (claims, header, etc )\n        await _repository SaveAsync(_tenantContext TenantId, order);\n        return new OrderPlaced(order Id, command CustomerId, order",
        "startIndex": 14195,
        "preview": "new ActiveOrdersSpecification() And(new CustomerOrdersSpecification(customerId)); return await _store QueryAsync(spec Predicate); } } ` Projection Bui..."
      },
      {
        "id": "core-concepts/repositories-and-helpers-chunk-7",
        "text": "ITenantContext _tenantContext; public PlaceOrderHandler(ITenantRepository<Order> repository, ITenantContext tenantContext) { _repository = repository; _tenantContext = tenantContext; } public async Task<OrderPlaced> Handle(PlaceOrder command) { var order = new Order(command CustomerId, command Items); // Tenant ID from context (claims, header, etc ) await _repository SaveAsync(_tenantContext TenantId, order); return new OrderPlaced(order Id, command CustomerId, order Total);\n    }\n}\n`\nPermission-Scoped Repositories\nRepositories can enforce permissions:\n`csharp{\ntitle: \"Permission-Scoped Repository\"\ndescription: \"Repository with built-in authorization\"\nframework: \"NET8\"\ncategory: \"Security\"\ndifficulty: \"ADVANCED\"\ntags: [\"Security\", \"Authorization\", \"Repositories\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang EventSourcing\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang EventSourcing;\npublic interface ISecureRepository<TAggregate> where TAggregate : Aggregate {\n    /// <summary>\n    /// Loads aggregate only if user has read permission /// </summary>\n    Task<TAggregate > FindAsync(Guid id, CancellationToken ct = default);\n    /// <summary>\n    /// Saves aggregate only if user has write permission /// Throws UnauthorizedAccessException if permission denied /// </summary>\n    Task SaveAsync(TAggregate aggregate, CancellationToken ct = default);\n}\n// Configuration\nservices AddWhizbang(options => {\n    options UseRepositories(repos => {\n        repos EnforcePermissions = true;\n        repos RequirePermission<Order>(\"orders:read\", \"orders:write\");\n        repos RequirePermission<Inventory>(\"inventory:read\", \"inventory:write\");\n    });\n});\n`\nNext Steps\nTesting - Test repositories and handlers\nMulti-Tenancy - Deep dive into tenant isolation\nSecurity - Authorization and authentication patterns",
        "startIndex": 16625,
        "preview": "ITenantContext _tenantContext; public PlaceOrderHandler(ITenantRepository<Order> repository, ITenantContext tenantContext) { _repository = repository;..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "core-concepts/return-type-semantics",
    "title": "Return Type Semantics",
    "category": "Core Concepts",
    "url": "/docs/core-concepts/return-type-semantics",
    "chunks": [
      {
        "id": "core-concepts/return-type-semantics-chunk-0",
        "text": "Return Type Semantics\nOverview\nIn Whizbang, what you return determines what happens next This simple yet powerful concept eliminates configuration and makes your code's intent crystal clear Inspired by Wolverine's approach but extended to cover all messaging patterns Core Philosophy\nTraditional messaging libraries require explicit configuration:\n`csharp\n// Traditional approach - configuration separate from logic\nawait bus Publish(event1);\nawait bus Send(command1);\nawait bus Reply(response1);\nawait bus Defer(message1, TimeSpan FromMinutes(5));\n`\nWhizbang's approach - return values drive behavior:\n`csharp\n// Whizbang - intent is clear from return type\nreturn event1;                                    // Publishes event\nreturn command1;                                  // Sends command  \nreturn response1;                                 // Replies to sender\nreturn message1 After(TimeSpan FromMinutes(5));  // Defers message\n`\nBasic Return Types\nSingle Message Return\n`csharp\npublic class OrderHandler : IHandle<CreateOrder> {\n    // Returning a single message publishes it as an event\n    public OrderCreated Handle(CreateOrder cmd) {\n        var order = CreateOrder(cmd);\n        return new OrderCreated(order Id, order Total);\n    }\n}\n`\nBehavior: \nIf return type implements IEvent → Publish to all subscribers\nIf return type implements ICommand → Send to single handler\nIf return type implements IResponse → Reply to original sender\nVoid Return (Fire-and-Forget)\n`csharp\npublic class NotificationHandler : IHandle<SendNotification> {\n    // Void means no follow-up messages\n    public void Handle(SendNotification cmd) {\n        Console WriteLine($\"Notification: {cmd Message}\");\n        // No return = no cascading messages\n    }\n}\n`\nBehavior: Handler executes with no subsequent messages\nTask Return (Async Void)\n`csharp\npublic class EmailHandler : IHandle<SendEmail> {\n    // Async with no result\n    public async Task Handle(SendEmail cmd) {\n        await emailService SendAsync(cmd To, cmd Subject, cmd",
        "startIndex": 0,
        "preview": "Return Type Semantics\nOverview\nIn Whizbang, what you return determines what happens next This simple yet powerful concept eliminates configuration and..."
      },
      {
        "id": "core-concepts/return-type-semantics-chunk-1",
        "text": "Console WriteLine($\"Notification: {cmd Message}\"); // No return = no cascading messages } } ` Behavior: Handler executes with no subsequent messages Task Return (Async Void) `csharp public class EmailHandler : IHandle<SendEmail> { // Async with no result public async Task Handle(SendEmail cmd) { await emailService SendAsync(cmd To, cmd Subject, cmd Body);\n        // No return value = no cascading messages\n    }\n}\n`\nBehavior: Async execution with no follow-up messages\nAdvanced Return Types\nTuple Return (Multiple Effects)\n`csharp\npublic class OrderHandler : IHandle<CreateOrder> {\n    // Return multiple messages in one operation\n    public (OrderCreated, ProcessPayment, SendConfirmation) Handle(CreateOrder cmd) {\n        var order = CreateOrder(cmd);\n        return (\n            new OrderCreated(order Id, order Total),           // Publish event\n            new ProcessPayment(order Id, order Total),         // Send command\n            new SendConfirmation(order CustomerEmail, order Id) // Send command\n        );\n    }\n}\n`\nBehavior: All messages in tuple are processed according to their type\nResult Type (Railway-Oriented Programming)\n`csharp\npublic class OrderHandler : IHandle<CreateOrder> {\n    // Result<T> for success/failure handling\n    public Result<OrderCreated> Handle(CreateOrder cmd) {\n        if ( IsValid(cmd)) {\n            return Result Failure<OrderCreated>(\"Invalid order data\");\n        }\n        var order = CreateOrder(cmd);\n        return Result Success(new OrderCreated(order Id));\n    }\n}\n// Alternative with custom error type\npublic class PaymentHandler : IHandle<ProcessPayment> {\n    public Result<PaymentProcessed, PaymentError> Handle(ProcessPayment cmd) {\n        try {\n            var transaction = ProcessPayment(cmd);\n            return Result Success(new PaymentProcessed(transaction Id));\n        }\n        catch (InsufficientFundsException ex) {\n            return Result Failure(new PaymentError(\"Insufficient funds\", ex));\n        }\n    }\n}\n`\nBehavior: \nOn Success → Process success value\nOn Failure → Handle error (can trigger compensation)\nIAsyncEnumerable (Streaming Results)\n`csharp\npublic class BatchHandler : IHandle<ProcessBatch> {\n    // Stream results as they're processed\n    public async IAsyncEnumerable<OrderProcessed> Handle(ProcessBatch cmd) {\n        foreach (var item in cmd Items) {\n            await Task Delay(100); // Simulate processing\n            var result = ProcessItem(item);\n            yield return new OrderProcessed(result Id, result",
        "startIndex": 2023,
        "preview": "Console WriteLine($\"Notification: {cmd Message}\"); // No return = no cascading messages } } ` Behavior: Handler executes with no subsequent messages T..."
      },
      {
        "id": "core-concepts/return-type-semantics-chunk-2",
        "text": "Handle error (can trigger compensation) IAsyncEnumerable (Streaming Results) `csharp public class BatchHandler : IHandle<ProcessBatch> { // Stream results as they're processed public async IAsyncEnumerable<OrderProcessed> Handle(ProcessBatch cmd) { foreach (var item in cmd Items) { await Task Delay(100); // Simulate processing var result = ProcessItem(item); yield return new OrderProcessed(result Id, result Status);\n            // Each yielded item is immediately published\n        }\n    }\n}\n`\nBehavior: Each yielded item is processed as it's produced (streaming)\nOption Type (Maybe Monad)\n`csharp\npublic class QueryHandler : IHandle<GetOrder> {\n    // Option<T> for queries that might return nothing\n    public Option<Order> Handle(GetOrder query) {\n        var order = repository FindById(query OrderId);\n        return order = null Option Some(order)\n            : Option None<Order>();\n    }\n}\n`\nBehavior:\nSome(value) → Process the value\nNone → Handle absence (no error)\nSpecialized Return Types\nDeferred Messages\n`csharp\npublic class ReminderHandler : IHandle<ScheduleReminder> {\n    // Defer message with fluent syntax\n    public Deferred<SendReminder> Handle(ScheduleReminder cmd) {\n        return new SendReminder(cmd UserId, cmd Message) After(TimeSpan FromHours(24));\n    }\n    // Or with specific time\n    public Deferred<SendReminder> HandleAt(ScheduleReminder cmd) {\n        return new SendReminder(cmd UserId, cmd Message) At(DateTime UtcNow AddDays(1) Date AddHours(9)); // Tomorrow 9 AM\n    }\n}\n`\nBehavior: Message is scheduled for future delivery\nSaga Instructions\n`csharp\npublic class OrderSaga : Saga<OrderState> {\n    // Return saga instructions\n    public SagaAction Handle(OrderCreated @event) {\n        State OrderId = @event OrderId;\n        State Status = \"Created\";\n        return SagaAction Send(new ProcessPayment(@event OrderId, @event Total)) After(TimeSpan FromSeconds(5)) WithTimeout(TimeSpan FromMinutes(10)) OnTimeout(new CancelOrder(@event OrderId));\n    }\n}\n`\nBehavior: Complex saga orchestration with timeout handling\nBatched Returns\n`csharp\npublic class BatchHandler : IHandle<ProcessOrders> {\n    // Return collection of messages\n    public IEnumerable<IMessage> Handle(ProcessOrders cmd) {\n        var messages = new List<IMessage>();\n        foreach (var orderId in cmd OrderIds) {\n            messages Add(new ProcessOrder(orderId));\n            messages Add(new LogOrderProcessing(orderId));\n        }\n        return messages;\n    }\n    // Or with LINQ\n    public IEnumerable<ProcessOrder> HandleLinq(ProcessOrders cmd) {\n        return cmd OrderIds",
        "startIndex": 4188,
        "preview": "Handle error (can trigger compensation) IAsyncEnumerable (Streaming Results) `csharp public class BatchHandler : IHandle<ProcessBatch> { // Stream res..."
      },
      {
        "id": "core-concepts/return-type-semantics-chunk-3",
        "text": "public class BatchHandler : IHandle<ProcessOrders> { // Return collection of messages public IEnumerable<IMessage> Handle(ProcessOrders cmd) { var messages = new List<IMessage>(); foreach (var orderId in cmd OrderIds) { messages Add(new ProcessOrder(orderId)); messages Add(new LogOrderProcessing(orderId)); } return messages; } // Or with LINQ public IEnumerable<ProcessOrder> HandleLinq(ProcessOrders cmd) { return cmd OrderIds Select(id => new ProcessOrder(id));\n    }\n}\n`\nBehavior: All messages in collection are processed\nConditional Returns\n`csharp\npublic class ConditionalHandler : IHandle<ProcessOrder> {\n    // Use pattern matching for conditional returns\n    public IMessage Handle(ProcessOrder cmd) {\n        return cmd Priority switch {\n            Priority High => new ProcessImmediately(cmd OrderId),\n            Priority Normal => new ProcessOrder(cmd OrderId) After(\"5m\"),\n            Priority Low => new QueueForBatch(cmd OrderId),\n            _ => new LogUnknownPriority(cmd OrderId)\n        };\n    }\n}\n`\nBehavior: Different messages based on conditions\nComplex Return Patterns\nNested Tuples for Grouping\n`csharp\npublic class ComplexHandler : IHandle<ComplexCommand> {\n    // Group related messages\n    public ((OrderCreated, InventoryReserved), (SendEmail, LogActivity)) Handle(ComplexCommand cmd) {\n        var order = CreateOrder(cmd);\n        var inventory = ReserveInventory(cmd);\n        return (\n            // Business events\n            (new OrderCreated(order Id), new InventoryReserved(inventory Id)),\n            // Side effects\n            (new SendEmail(cmd Email), new LogActivity(\"Order created\"))\n        );\n    }\n}\n`\nDiscriminated Unions\n`csharp\npublic class PaymentHandler : IHandle<ProcessPayment> {\n    // Return different types based on outcome\n    public OneOf<PaymentSucceeded, PaymentFailed, PaymentPending> Handle(ProcessPayment cmd) {\n        var result = paymentGateway Process(cmd);\n        return result Status switch {\n            \"succeeded\" => new PaymentSucceeded(result TransactionId),\n            \"failed\" => new PaymentFailed(result ErrorCode),\n            \"pending\" => new PaymentPending(result PendingId),\n            _ => throw new UnknownPaymentStatus(result Status)\n        };\n    }\n}\n`\nRecursive Returns\n`csharp\npublic class RecursiveHandler : IHandle<ProcessNode> {\n    // Return can trigger same handler recursively\n    public IEnumerable<ProcessNode> Handle(ProcessNode cmd) {\n        ProcessCurrentNode(cmd);\n        // Return child nodes for recursive processing\n        return cmd Children",
        "startIndex": 6468,
        "preview": "public class BatchHandler : IHandle<ProcessOrders> { // Return collection of messages public IEnumerable<IMessage> Handle(ProcessOrders cmd) { var mes..."
      },
      {
        "id": "core-concepts/return-type-semantics-chunk-4",
        "text": "new PaymentFailed(result ErrorCode), \"pending\" => new PaymentPending(result PendingId), _ => throw new UnknownPaymentStatus(result Status) }; } } ` Recursive Returns `csharp public class RecursiveHandler : IHandle<ProcessNode> { // Return can trigger same handler recursively public IEnumerable<ProcessNode> Handle(ProcessNode cmd) { ProcessCurrentNode(cmd); // Return child nodes for recursive processing return cmd Children Select(child => new ProcessNode(child));\n    }\n}\n`\nReturn Type Metadata\nPriority and Headers\n`csharp\npublic class PriorityHandler : IHandle<CreateOrder> {\n    public MessageWithMetadata<OrderCreated> Handle(CreateOrder cmd) {\n        var order = CreateOrder(cmd);\n        return new OrderCreated(order Id) WithPriority(MessagePriority High) WithHeader(\"CustomerId\", cmd CustomerId) WithHeader(\"Source\", \"WebAPI\") WithCorrelationId(cmd CorrelationId);\n    }\n}\n`\nRouting Instructions\n`csharp\npublic class RoutingHandler : IHandle<RouteOrder> {\n    public RoutedMessage Handle(RouteOrder cmd) {\n        return new ProcessOrder(cmd OrderId) RouteTo(cmd Region switch {\n                \"US\" => \"us-queue\",\n                \"EU\" => \"eu-queue\",\n                \"ASIA\" => \"asia-queue\",\n                _ => \"global-queue\"\n            }) WithRoutingKey($\"orders {cmd Priority} {cmd Region}\");\n    }\n}\n`\nCompile-Time Verification\nReturn Type Validation\n`csharp\n// Source generator validates return types\npublic class InvalidHandler : IHandle<CreateOrder> {\n    // ❌ Compile error: Handler must return a message type\n    public string Handle(CreateOrder cmd) {\n        return \"This won't compile\";\n    }\n}\n[Pure]\npublic class PureHandler : IHandle<Calculate> {\n    // ❌ Compile error: Pure handlers cannot return commands\n    public SendEmail Handle(Calculate cmd) {\n        return new SendEmail(); // Side effect not allowed\n    }\n    // ✅ Valid: Pure handlers can return events\n    public Calculated Handle(Calculate cmd) {\n        return new Calculated(cmd A + cmd",
        "startIndex": 8595,
        "preview": "new PaymentFailed(result ErrorCode), \"pending\" => new PaymentPending(result PendingId), _ => throw new UnknownPaymentStatus(result Status) }; } } ` Re..."
      },
      {
        "id": "core-concepts/return-type-semantics-chunk-5",
        "text": "} [Pure] public class PureHandler : IHandle<Calculate> { // ❌ Compile error: Pure handlers cannot return commands public SendEmail Handle(Calculate cmd) { return new SendEmail(); // Side effect not allowed } // ✅ Valid: Pure handlers can return events public Calculated Handle(Calculate cmd) { return new Calculated(cmd A + cmd B);\n    }\n}\n`\nEffect Tracking\n`csharp\n[Effects(Publishes = \"OrderEvents\")]\npublic class TrackedHandler : IHandle<CreateOrder> {\n    // ✅ Valid: Return type matches declared effects\n    public OrderCreated Handle(CreateOrder cmd) {\n        return new OrderCreated();\n    }\n    // ❌ Compile error: PaymentProcessed not in declared effects\n    public PaymentProcessed HandlePayment(ProcessPayment cmd) {\n        return new PaymentProcessed();\n    }\n}\n`\nPerformance Optimizations\nStack-Allocated Returns\n`csharp\n// Small structs are stack-allocated for performance\npublic readonly struct LightweightEvent : IEvent {\n    public readonly Guid Id;\n    public readonly DateTime Timestamp;\n    public LightweightEvent(Guid id) {\n        Id = id;\n        Timestamp = DateTime UtcNow;\n    }\n}\npublic class PerformantHandler : IHandle<QuickCommand> {\n    // Returns struct without heap allocation\n    public LightweightEvent Handle(QuickCommand cmd) {\n        return new LightweightEvent(cmd Id);\n    }\n}\n`\nPooled Returns\n`csharp\n[PooledReturns] // Source generator creates pooling\npublic class PooledHandler : IHandle<FrequentCommand> {\n    public FrequentEvent Handle(FrequentCommand cmd) {\n        // Return value is automatically pooled and reused\n        return new FrequentEvent { Id = cmd Id };\n    }\n}\n`\nTesting Return Types\n`csharp\n[Test]\npublic async Task Handler_ReturnsCorrectMessageTypes() {\n    // Given\n    var handler = new OrderHandler();\n    var command = new CreateOrder { };\n    // When\n    var result = handler Handle(command);\n    // Then - Verify return types\n    result Should() BeOfType<(OrderCreated, ProcessPayment, SendEmail)>() Which Should() Satisfy(\n            r => r Item1 OrderId == command OrderId,\n            r => r Item2 Amount == command Total,\n            r => r Item3 Recipient == command",
        "startIndex": 10229,
        "preview": "} [Pure] public class PureHandler : IHandle<Calculate> { // ❌ Compile error: Pure handlers cannot return commands public SendEmail Handle(Calculate cm..."
      },
      {
        "id": "core-concepts/return-type-semantics-chunk-6",
        "text": "command = new CreateOrder { }; // When var result = handler Handle(command); // Then - Verify return types result Should() BeOfType<(OrderCreated, ProcessPayment, SendEmail)>() Which Should() Satisfy( r => r Item1 OrderId == command OrderId, r => r Item2 Amount == command Total, r => r Item3 Recipient == command CustomerEmail\n        );\n}\n[Test]\npublic async Task Handler_StreamingReturn_YieldsAllItems() {\n    var handler = new BatchHandler();\n    var items = new[] { item1, item2, item3 };\n    var results = await handler Handle(new ProcessBatch { Items = items }) ToListAsync();\n    results Should() HaveCount(3);\n    results Should() AllBeOfType<OrderProcessed>();\n}\n`\nBest Practices\nDo's\n✅ Use specific return types for clarity\n`csharp\npublic OrderCreated Handle(CreateOrder cmd)  // Clear intent\n`\n✅ Leverage tuples for related messages\n`csharp\npublic (OrderCreated, SendEmail) Handle(CreateOrder cmd)\n`\n✅ Use Result<T> for fallible operations\n`csharp\npublic Result<PaymentProcessed> Handle(ProcessPayment cmd)\n`\n✅ Stream large result sets\n`csharp\npublic async IAsyncEnumerable<Result> Handle(LargeQuery query)\n`\nDon'ts\n❌ Don't use generic object returns\n`csharp\npublic object Handle(Command cmd)  // Loses type safety\n`\n❌ Don't mix unrelated messages in tuples\n`csharp\npublic (OrderCreated, UnrelatedUserLogout) Handle(CreateOrder cmd)\n`\n❌ Don't ignore return values in tests\n`csharp\nhandler Handle(cmd);  // Should verify return value\n`\nSummary\nReturn type semantics in Whizbang provide:\nClear intent from method signatures\nZero configuration message routing\nType safety with compile-time verification\nFlexibility through various return patterns\nPerformance with optimized return handling\nThis approach makes your handlers self-documenting and eliminates the impedance mismatch between your domain logic and messaging infrastructure Next Steps\nExplore Policy Composition for resilience\nLearn about Aspect-Oriented Handlers\nSee Progressive Enhancement patterns\nReview Testing Strategies",
        "startIndex": 12069,
        "preview": "command = new CreateOrder { }; // When var result = handler Handle(command); // Then - Verify return types result Should() BeOfType<(OrderCreated, Pro..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "design/advanced-features",
    "title": "Advanced Features",
    "category": "Architecture & Design",
    "url": "/docs/design/advanced-features",
    "chunks": [
      {
        "id": "design/advanced-features-chunk-0",
        "text": "Advanced Features\nWhizbang includes advanced features for enterprise scenarios, including cross-aggregate transactions, performance monitoring, Kubernetes operators, and debugging tools Cross-Aggregate Transactions\nUnit of Work Pattern\nCoordinate transactions across multiple aggregates while maintaining consistency:\n`csharp\nservices AddWhizbang(options => {\n    options UseUnitOfWork(uow => {\n        uow IsolationLevel = IsolationLevel ReadCommitted;\n        uow Timeout = TimeSpan FromSeconds(30);\n        uow EnableDistributedTransactions = true;\n    });\n});\n// Usage in handlers\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder> {\n    private readonly IUnitOfWork _unitOfWork;\n    private readonly IRepository<Order> _orderRepository;\n    private readonly IRepository<Customer> _customerRepository;\n    private readonly IRepository<Product> _productRepository;\n    public async Task<OrderPlaced> Handle(PlaceOrder command) {\n        return await _unitOfWork ExecuteAsync(async () => {\n            // Load multiple aggregates\n            var customer = await _customerRepository Load(command CustomerId);\n            var products = await _productRepository LoadMany(command ProductIds);\n            // Validate business rules across aggregates\n            if ( customer CanPlaceOrder(command Total)) {\n                throw new DomainException(\"Customer credit limit exceeded\");\n            }\n            foreach (var product in products) {\n                if ( product IsAvailable(command GetQuantity(product Id))) {\n                    throw new DomainException($\"Product {product Id} not available\");\n                }\n            }\n            // Create new aggregate\n            var order = new Order(command CustomerId, command Items);\n            // Update existing aggregates\n            customer ReserveCreditLimit(command Total);\n            foreach (var product in products) {\n                product ReserveStock(command GetQuantity(product Id));\n            }\n            // Save all changes in single transaction\n            await _orderRepository Save(order);\n            await _customerRepository Save(customer);\n            await _productRepository SaveMany(products);\n            return new OrderPlaced(order Id, command CustomerId, DateTimeOffset UtcNow);\n        });\n    }\n}\n`\nDistributed Transactions with Saga Fallback\n`csharp\nservices AddWhizbang(options => {\n    options CrossAggregateTransactions(transactions => {\n        transactions DefaultStrategy = TransactionStrategy UnitOfWork;\n        transactions FallbackToSaga = true;\n        transactions SagaTimeoutMs = 30000;\n        // Configure per-operation\n        transactions ForOperation<PlaceOrder>(op => {\n            op Strategy = TransactionStrategy UnitOfWork;\n            op MaxAggregatesInTransaction = 5;\n        });\n        transactions ForOperation<ComplexOrderWorkflow>(op => {\n            op Strategy = TransactionStrategy Saga; // Force saga for complex operations\n        });\n    });\n});\n`\nTransaction Boundaries\n`csharp\npublic class TransactionBoundary : ITransactionBoundary {\n    public async Task<T> ExecuteInTransaction<T>(Func<Task<T>> operation) {\n        using var scope = new TransactionScope(TransactionScopeAsyncFlowOption",
        "startIndex": 0,
        "preview": "Advanced Features\nWhizbang includes advanced features for enterprise scenarios, including cross-aggregate transactions, performance monitoring, Kubern..."
      },
      {
        "id": "design/advanced-features-chunk-1",
        "text": "op Strategy = TransactionStrategy UnitOfWork; op MaxAggregatesInTransaction = 5; }); transactions ForOperation<ComplexOrderWorkflow>(op => { op Strategy = TransactionStrategy Saga; // Force saga for complex operations }); }); }); ` Transaction Boundaries `csharp public class TransactionBoundary : ITransactionBoundary { public async Task<T> ExecuteInTransaction<T>(Func<Task<T>> operation) { using var scope = new TransactionScope(TransactionScopeAsyncFlowOption Enabled);\n        try {\n            var result = await operation();\n            scope Complete();\n            return result;\n        } catch (Exception ex) {\n            // Transaction automatically rolled back\n            _logger LogError(ex, \"Transaction failed and was rolled back\");\n            throw;\n        }\n    }\n}\n`\nPerformance Budgets & Monitoring\n> 📋 Detailed Coverage: For comprehensive performance budgets, observability, and monitoring details, see Observability & Metrics\nPerformance Budget Overview\nPerformance budgets provide automatic tracking and alerting for handler performance:\n`csharp\n[PerformanceBudget(MaxLatencyMs = 100)]\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder> {\n    // Automatic budget tracking and violation alerts\n}\n`\nOpenTelemetry Integration\n> 📋 Detailed Coverage: For complete OpenTelemetry setup, metrics, and distributed tracing, see Observability & Metrics\n`csharp\nservices AddWhizbang(options => {\n    options Observability(observability => {\n        observability UseOpenTelemetry(otel => {\n            otel TraceAllCommands = true;\n            otel TraceAllEvents = true;\n            otel TraceProjections = true;\n            otel TraceSagas = true;\n            // Custom metrics\n            otel EmitCustomMetrics = true;\n            otel MetricsPrefix = \"whizbang\";\n            // Performance budget violations\n            otel TracePerformanceBudgetViolations = true;\n            otel AlertOnBudgetViolation = true;\n        });\n    });\n});\n// Custom performance tracking\npublic class PerformanceTrackingHandler<T> : ICommandHandler<T> where T : ICommand {\n    private readonly ICommandHandler<T> _innerHandler;\n    private readonly IMetrics _metrics;\n    public async Task Handle(T command) {\n        using var activity = Activity StartActivity($\"Command {typeof(T) Name}\");\n        using var timer = _metrics StartTimer($\"command {typeof(T) Name ToLower()} duration\");\n        var startMemory = GC GetTotalMemory(false);\n        var stopwatch = Stopwatch StartNew();\n        try {\n            await _innerHandler Handle(command);\n            // Record success metrics\n            _metrics IncrementCounter($\"command {typeof(T) Name ToLower()} success\");\n        } catch (Exception ex) {\n            // Record failure metrics\n            _metrics IncrementCounter($\"command {typeof(T) Name ToLower()} failure\", \n                new[] { (\"error_type\", ex",
        "startIndex": 3245,
        "preview": "op Strategy = TransactionStrategy UnitOfWork; op MaxAggregatesInTransaction = 5; }); transactions ForOperation<ComplexOrderWorkflow>(op => { op Strate..."
      },
      {
        "id": "design/advanced-features-chunk-2",
        "text": "_metrics StartTimer($\"command {typeof(T) Name ToLower()} duration\"); var startMemory = GC GetTotalMemory(false); var stopwatch = Stopwatch StartNew(); try { await _innerHandler Handle(command); // Record success metrics _metrics IncrementCounter($\"command {typeof(T) Name ToLower()} success\"); } catch (Exception ex) { // Record failure metrics _metrics IncrementCounter($\"command {typeof(T) Name ToLower()} failure\", new[] { (\"error_type\", ex GetType() Name) });\n            activity SetStatus(ActivityStatusCode Error, ex Message);\n            throw;\n        } finally {\n            stopwatch Stop();\n            var endMemory = GC GetTotalMemory(false);\n            // Record performance metrics\n            activity SetTag(\"duration_ms\", stopwatch ElapsedMilliseconds);\n            activity SetTag(\"memory_allocated_bytes\", endMemory - startMemory);\n            _metrics RecordValue($\"command {typeof(T) Name ToLower()} memory\", endMemory - startMemory);\n        }\n    }\n}\n`\nKubernetes Operator Features\n> 📋 Detailed Coverage: For production deployment patterns, health checks, and operational best practices, see Deployment & Operations\nAuto-Scaling Projection Workers\n`yaml\napiVersion: whizbang io/v1\nkind: ProjectionWorker\nmetadata:\n  name: order-summary-projection\nspec:\n  projectionName: order-summary\n  scaling:\n    strategy: lag-based\n    minReplicas: 2\n    maxReplicas: 10\n    lagThresholdSeconds: 30\n    scaleUpCooldownMs: 300000   5 minutes\n    scaleDownCooldownMs: 600000 10 minutes\n  partitioning:\n    enabled: true\n    partitionCount: 8\n    partitionBy: \"streamId\"\n  resources:\n    requests:\n      cpu: 100m\n      memory: 128Mi\n    limits:\n      cpu: 500m\n      memory: 512Mi\n`\nPartition-Aware Pod Placement\n`yaml\napiVersion: whizbang io/v1\nkind: PartitionedProjection\nmetadata:\n  name: analytics-projection\nspec:\n  projectionName: analytics\n  partitions:\nid: 0\n    nodeSelector:\n      whizbang io/partition-group: \"group-a\"\nid: 1\n    nodeSelector:\n      whizbang io/partition-group: \"group-a\"\nid: 2\n    nodeSelector:\n      whizbang io/partition-group: \"group-b\"\nid: 3\n    nodeSelector:\n      whizbang io/partition-group: \"group-b\"\n  antiAffinity:\n    enabled: true\n    topologyKey: kubernetes io/hostname\n`\nBlue/Green Projection Deployments\n`yaml\napiVersion: whizbang io/v1\nkind: ProjectionDeployment\nmetadata:\n  name: order-summary-deployment\nspec:\n  strategy: blue-green\n  validation:\n    samplingRate: 0 1          Validate 10% of data\n    accuracyThreshold: 0 99    99% accuracy required\n    validationTimeoutMinutes: 30\n  switchover:\n    automatic: false           Manual approval required\n    trafficSplitDurationMinutes: 10\n  cleanup:\n    retainBlueVersionHours: 24 Keep blue for 24 hours after switchover\n`\nAutomatic Backfilling\n`yaml\napiVersion: whizbang",
        "startIndex": 5665,
        "preview": "_metrics StartTimer($\"command {typeof(T) Name ToLower()} duration\"); var startMemory = GC GetTotalMemory(false); var stopwatch = Stopwatch StartNew();..."
      },
      {
        "id": "design/advanced-features-chunk-3",
        "text": "whizbang io/v1 kind: ProjectionDeployment metadata: name: order-summary-deployment spec: strategy: blue-green validation: samplingRate: 0 1 Validate 10% of data accuracyThreshold: 0 99 99% accuracy required validationTimeoutMinutes: 30 switchover: automatic: false Manual approval required trafficSplitDurationMinutes: 10 cleanup: retainBlueVersionHours: 24 Keep blue for 24 hours after switchover ` Automatic Backfilling `yaml apiVersion: whizbang io/v1\nkind: BackfillJob\nmetadata:\n  name: customer-analytics-backfill\nspec:\n  projectionName: customer-analytics\n  trigger: deployment-update  Trigger on projection deployment\n  source:\n    fromDate: \"2024-01-01T00:00:00Z\"\n    toDate: null              Current time\n  execution:\n    batchSize: 1000\n    parallelism: 4\n    maxRetries: 3\n  resources:\n    requests:\n      cpu: 200m\n      memory: 256Mi\n    limits:\n      cpu: 1000m\n      memory: 1Gi\n`\nKubernetes Operator Implementation\n`csharp\npublic class WhizbangOperator : IHostedService {\n    private readonly IKubernetesClient _kubernetesClient;\n    private readonly IProjectionManager _projectionManager;\n    public async Task StartAsync(CancellationToken cancellationToken) {\n        // Watch for ProjectionWorker resources\n        await _kubernetesClient WatchAsync<ProjectionWorker>(\n            onEvent: async (eventType, resource) => {\n                switch (eventType) {\n                    case WatchEventType Added:\n                        await CreateProjectionWorker(resource);\n                        break;\n                    case WatchEventType Modified:\n                        await UpdateProjectionWorker(resource);\n                        break;\n                    case WatchEventType Deleted:\n                        await DeleteProjectionWorker(resource);\n                        break;\n                }\n            },\n            cancellationToken: cancellationToken\n        );\n        // Monitor projection lag and auto-scale\n        _ = Task Run(() => MonitorAndScale(cancellationToken), cancellationToken);\n    }\n    private async Task MonitorAndScale(CancellationToken cancellationToken) {\n        while ( cancellationToken IsCancellationRequested) {\n            var projections = await _projectionManager GetAllProjections();\n            foreach (var projection in projections) {\n                var lag = await _projectionManager GetLag(projection Name);\n                var workerSpec = await GetProjectionWorkerSpec(projection Name);\n                if (ShouldScaleUp(lag, workerSpec)) {\n                    await ScaleUpProjectionWorker(projection Name, workerSpec);\n                } else if (ShouldScaleDown(lag, workerSpec)) {\n                    await ScaleDownProjectionWorker(projection Name, workerSpec);\n                }\n            }\n            await Task Delay(TimeSpan FromSeconds(30), cancellationToken);\n        }\n    }\n}\n`\nDebugging and Development Tools\n> 📋 Detailed Coverage: For comprehensive testing framework, development tools, CLI, and IDE integration, see Testing & Development Tools and Source Generation & IDE Integration\nOpenTelemetry Journey Visualization\nCapture and visualize message journeys for debugging:\n`csharp\nservices AddWhizbang(options => {\n    options Debugging(debugging => {\n        debugging CaptureMessageJourneys = true;\n        debugging JourneyRetentionDays = 7;\n        debugging EnableBreakpoints = true;\n        debugging",
        "startIndex": 8007,
        "preview": "whizbang io/v1 kind: ProjectionDeployment metadata: name: order-summary-deployment spec: strategy: blue-green validation: samplingRate: 0 1 Validate 1..."
      },
      {
        "id": "design/advanced-features-chunk-4",
        "text": "framework, development tools, CLI, and IDE integration, see Testing & Development Tools and Source Generation & IDE Integration OpenTelemetry Journey Visualization Capture and visualize message journeys for debugging: `csharp services AddWhizbang(options => { options Debugging(debugging => { debugging CaptureMessageJourneys = true; debugging JourneyRetentionDays = 7; debugging EnableBreakpoints = true; debugging EnableStateInspection = true;\n    });\n});\n// Message journey tracking\npublic class MessageJourneyTracker : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message, \n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        var journeyId = context CorrelationId Guid NewGuid() ToString();\n        using var activity = Activity StartActivity(\"MessageJourney\");\n        activity SetTag(\"journey_id\", journeyId);\n        activity SetTag(\"message_type\", typeof(TRequest) Name);\n        activity SetTag(\"handler_type\", context HandlerType Name);\n        var stopwatch = Stopwatch StartNew();\n        try {\n            var response = await next(message, context);\n            await _journeyStore RecordStep(new JourneyStep {\n                JourneyId = journeyId,\n                MessageType = typeof(TRequest) Name,\n                HandlerType = context HandlerType Name,\n                Duration = stopwatch Elapsed,\n                Status = \"Success\",\n                Input = JsonSerializer Serialize(message),\n                Output = JsonSerializer Serialize(response)\n            });\n            return response;\n        } catch (Exception ex) {\n            await _journeyStore RecordStep(new JourneyStep {\n                JourneyId = journeyId,\n                MessageType = typeof(TRequest) Name,\n                HandlerType = context HandlerType Name,\n                Duration = stopwatch Elapsed,\n                Status = \"Failed\",\n                Error = ex ToString(),\n                Input = JsonSerializer Serialize(message)\n            });\n            throw;\n        }\n    }\n}\n`\nReplay and Simulation\nReplay events for debugging and testing:\n`csharp\npublic interface IEventReplayService {\n    Task<ReplayResult> ReplayEvents(ReplayOptions options);\n    Task<SimulationResult> SimulateEventStream(SimulationOptions options);\n    IAsyncEnumerable<ReplayProgress> GetReplayProgress(string replayId);\n}\npublic class EventReplayService : IEventReplayService {\n    public async Task<ReplayResult> ReplayEvents(ReplayOptions options) {\n        var replayId = Guid NewGuid() ToString();\n        // Create isolated replay environment\n        var replayContext = await CreateReplayContext(replayId, options);\n        try {\n            // Load events to replay\n            var events = await LoadEventsForReplay(options);\n            // Replay events in isolated context\n            foreach (var @event in events) {\n                if (options Breakpoints Contains(@event EventNumber) == true) {\n                    await PauseForBreakpoint(@event, replayContext);\n                }\n                await replayContext ProcessEvent(@event);\n                if (options",
        "startIndex": 10966,
        "preview": "framework, development tools, CLI, and IDE integration, see Testing & Development Tools and Source Generation & IDE Integration OpenTelemetry Journey ..."
      },
      {
        "id": "design/advanced-features-chunk-5",
        "text": "isolated replay environment var replayContext = await CreateReplayContext(replayId, options); try { // Load events to replay var events = await LoadEventsForReplay(options); // Replay events in isolated context foreach (var @event in events) { if (options Breakpoints Contains(@event EventNumber) == true) { await PauseForBreakpoint(@event, replayContext); } await replayContext ProcessEvent(@event); if (options StepByStep) {\n                    await WaitForContinueSignal(replayId);\n                }\n            }\n            return new ReplayResult {\n                ReplayId = replayId,\n                EventsProcessed = events Count(),\n                Status = ReplayStatus Completed\n            };\n        } catch (Exception ex) {\n            return new ReplayResult {\n                ReplayId = replayId,\n                Status = ReplayStatus Failed,\n                Error = ex Message\n            };\n        }\n    }\n}\n// Usage\nvar replayOptions = new ReplayOptions {\n    FromEventNumber = 1000,\n    ToEventNumber = 2000,\n    StreamFilter = streamId => streamId StartsWith(\"Order-\"),\n    StepByStep = true,\n    Breakpoints = new[] { 1500, 1750 },\n    IsolatedEnvironment = true\n};\nvar result = await _replayService ReplayEvents(replayOptions);\n`\nState Inspection and Breakpoints\nInspect aggregate and projection state during debugging:\n`csharp\npublic interface IStateInspector {\n    Task<AggregateState> InspectAggregate(string streamId, long version = null);\n    Task<ProjectionState> InspectProjection(string projectionName, string documentId);\n    Task<IEnumerable<EventInfo>> GetEventHistory(string streamId);\n    Task SetBreakpoint(string streamId, long eventVersion);\n    Task<BreakpointContext> WaitForBreakpoint(string breakpointId);\n}\n// Breakpoint implementation\npublic class BreakpointHandler : IEventHandler<object> {\n    public async Task Handle(object @event, EventContext context) {\n        var breakpoints = await _breakpointStore GetActiveBreakpoints(context StreamId);\n        foreach (var breakpoint in breakpoints) {\n            if (ShouldTriggerBreakpoint(breakpoint, @event, context)) {\n                var breakpointContext = new BreakpointContext {\n                    BreakpointId = breakpoint Id,\n                    Event = @event,\n                    StreamId = context StreamId,\n                    EventVersion = context EventVersion,\n                    AggregateState = await LoadAggregateState(context StreamId, context EventVersion - 1),\n                    Timestamp = DateTimeOffset UtcNow\n                };\n                await _breakpointStore RecordBreakpointHit(breakpointContext);\n                await _notificationService NotifyBreakpointHit(breakpointContext);\n                // Pause execution until developer continues\n                await WaitForContinueSignal(breakpoint Id);\n            }\n        }\n    }\n}\n`\nW3C Trace Context Integration\nDistributed tracing with W3C standards:\n`csharp\nservices AddWhizbang(options => {\n    options DistributedTracing(tracing => {\n        tracing UseW3CTraceContext = true;\n        tracing PropagateTraceHeaders = true;\n        tracing SampleRate = 0",
        "startIndex": 13740,
        "preview": "isolated replay environment var replayContext = await CreateReplayContext(replayId, options); try { // Load events to replay var events = await LoadEv..."
      },
      {
        "id": "design/advanced-features-chunk-6",
        "text": "await _breakpointStore RecordBreakpointHit(breakpointContext); await _notificationService NotifyBreakpointHit(breakpointContext); // Pause execution until developer continues await WaitForContinueSignal(breakpoint Id); } } } } ` W3C Trace Context Integration Distributed tracing with W3C standards: `csharp services AddWhizbang(options => { options DistributedTracing(tracing => { tracing UseW3CTraceContext = true; tracing PropagateTraceHeaders = true; tracing SampleRate = 0 1; // Sample 10% of traces\n        tracing CustomTags Add(\"service name\", \"whizbang-orders\");\n        tracing CustomTags Add(\"service version\", \"1 2 3\");\n    });\n});\n// Automatic trace propagation\npublic class TraceContextPropagator : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        // Extract W3C trace context from headers\n        var traceParent = context Headers GetValueOrDefault(\"traceparent\");\n        var traceState = context Headers GetValueOrDefault(\"tracestate\");\n        if (traceParent = null) {\n            // Parse W3C trace context\n            var traceContext = W3CTraceContext Parse(traceParent, traceState);\n            // Create child span\n            using var activity = Activity StartActivity($\"Handle{typeof(TRequest) Name}\");\n            activity SetParentId(traceContext TraceId, traceContext SpanId);\n            activity SetTag(\"whizbang correlation_id\", context CorrelationId);\n            activity SetTag(\"whizbang message_type\", typeof(TRequest) Name);\n            // Add custom trace state\n            var newTraceState = $\"whizbang=correlation-id:{context CorrelationId}\";\n            if ( string IsNullOrEmpty(traceState)) {\n                newTraceState = $\"{traceState},{newTraceState}\";\n            }\n            activity SetTag(\"tracestate\", newTraceState);\n            return await next(message, context);\n        }\n        // No parent trace - start new one\n        using var rootActivity = Activity StartActivity($\"Handle{typeof(TRequest) Name}\");\n        return await next(message, context);\n    }\n}\n`\nConfiguration Examples\nComprehensive Advanced Features Setup\n`csharp\nservices AddWhizbang(options => {\n    // Cross-aggregate transactions\n    options UseUnitOfWork(uow => {\n        uow IsolationLevel = IsolationLevel ReadCommitted;\n        uow EnableDistributedTransactions = true;\n        uow FallbackToSaga = true;\n    });\n    // Performance budgets\n    options PerformanceBudgets(budgets => {\n        budgets DefaultCommandLatency = TimeSpan FromMilliseconds(500);\n        budgets AlertOnViolation = true;\n        budgets UseOpenTelemetryMetrics = true;\n    });\n    // Observability\n    options Observability(observability => {\n        observability UseOpenTelemetry();\n        observability CaptureMessageJourneys = true;\n        observability EnableDistributedTracing = true;\n    });\n    // Debugging\n    options Debugging(debugging => {\n        debugging EnableBreakpoints = true;\n        debugging EnableStateInspection = true;\n        debugging EnableEventReplay = true;\n        debugging RetainDebugDataDays = 7;\n    });\n    // Kubernetes integration\n    options",
        "startIndex": 16475,
        "preview": "await _breakpointStore RecordBreakpointHit(breakpointContext); await _notificationService NotifyBreakpointHit(breakpointContext); // Pause execution u..."
      },
      {
        "id": "design/advanced-features-chunk-7",
        "text": "true; budgets UseOpenTelemetryMetrics = true; }); // Observability options Observability(observability => { observability UseOpenTelemetry(); observability CaptureMessageJourneys = true; observability EnableDistributedTracing = true; }); // Debugging options Debugging(debugging => { debugging EnableBreakpoints = true; debugging EnableStateInspection = true; debugging EnableEventReplay = true; debugging RetainDebugDataDays = 7; }); // Kubernetes integration options Kubernetes(k8s => {\n        k8s EnableOperator = true;\n        k8s AutoScaleProjections = true;\n        k8s EnableBlueGreenDeployments = true;\n        k8s PartitionAwarePlacement = true;\n    });\n});\n`\nBest Practices\nTransaction Guidelines\nKeep transactions short - Minimize time holding locks\nLimit aggregate count - Avoid transactions with too many aggregates\nUse sagas for long processes - Don't use transactions for workflows\nTest rollback scenarios - Ensure proper cleanup on failure\nMonitor transaction metrics - Track duration and failure rates\nPerformance Monitoring\nSet realistic budgets - Base on actual performance requirements\nMonitor trends - Track performance over time\nAlert on violations - Set up proper alerting for budget violations\nUse sampling - Don't trace every request in production\nCorrelate with business metrics - Connect performance to business impact\nDebugging Best Practices\nUse structured logging - Include correlation IDs and context\nLimit debug data retention - Don't keep debug data indefinitely\nSecure sensitive data - Mask PII in debug traces\nTest replay scenarios - Ensure replay works correctly\nDocument debugging procedures - Help team members debug effectively\n---\nRelated Documentation\nCore Architecture\nEvent Store & Projections - Core storage architecture\nConcurrency Control - Managing concurrent updates\nPolicy Engine - Universal configuration scoping mechanism\nFlags & Tags System - Cross-service context propagation\nImplementation & Operations\nSource Generation & IDE Integration - Development tooling and navigation\nTesting & Development Tools - Testing framework and CLI tools  \nObservability & Metrics - Production monitoring and observability\nDeployment & Operations - Operational patterns and best practices",
        "startIndex": 19262,
        "preview": "true; budgets UseOpenTelemetryMetrics = true; }); // Observability options Observability(observability => { observability UseOpenTelemetry(); observab..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "design/concurrency-control",
    "title": "Concurrency Control",
    "category": "Architecture & Design",
    "url": "/docs/design/concurrency-control",
    "chunks": [
      {
        "id": "design/concurrency-control-chunk-0",
        "text": "Concurrency Control\nWhizbang provides flexible concurrency control mechanisms to handle concurrent updates to aggregates, supporting multiple strategies that developers can choose globally or per-operation Concurrency Strategies\nA Expected Version (Default)\nStandard event sourcing pattern - explicitly specify the expected version:\n`csharp\n// Load aggregate at version 5\nvar order = await repository Load<Order>(orderId);\n// Make changes\norder AddItem(new OrderItem(\"Product\", 10 00m));\n// Save with expected version - will fail if current version = 5\nawait repository Save(order, expectedVersion: 5);\n`\nBenefits:\n✅ Detects all conflicts\n✅ Standard event sourcing pattern\n✅ Explicit and predictable\nDrawbacks:\n❌ Requires version tracking\n❌ Manual conflict resolution\nB Timestamp-Based (Last-Modified)\nHTTP-style semantics using timestamps:\n`csharp\nvar order = await repository Load<Order>(orderId);\nvar lastModified = order LastModified;\n// Make changes\norder AddItem(new OrderItem(\"Product\", 10 00m));\n// Save with timestamp check\nawait repository Save(order, ifNotModifiedSince: lastModified);\n`\nBenefits:\n✅ Familiar HTTP semantics\n✅ No version number tracking\nDrawbacks:\n❌ Clock skew potential\n❌ Less precise than versions\nC Automatic Retry with Conflict Resolution\nSmart retry with configurable resolution strategies:\n`csharp\n// Configure automatic retry via policies\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        // Default strategy for all operations\n        policies When(ctx => true) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy AutomaticRetry)) And(config => config SetRetryAttempts(3)) And(config => config SetRetryDelay(TimeSpan FromMilliseconds(100)));\n        // Custom conflict resolution for Order aggregates\n        policies When(ctx => ctx MatchesAggregate<Order>()) Then(config => config SetConflictResolver((current, attempted) => {\n                    // Custom merge logic\n                    var merged = current Copy();\n                    merged MergeChanges(attempted);\n                    return merged;\n                }));\n    });\n});\n// Save with automatic retry\nawait repository Save(order); // Retries automatically on conflict\n`\nBenefits:\n✅ Handles most conflicts automatically\n✅ Better developer experience\n✅ Configurable retry policies\nDrawbacks:\n❌ Complex to implement\n❌ Not all conflicts can be auto-resolved\nMarten-Inspired Extensions\nDrawing from Marten's concurrency features, Whizbang also supports:\nD",
        "startIndex": 0,
        "preview": "Concurrency Control\nWhizbang provides flexible concurrency control mechanisms to handle concurrent updates to aggregates, supporting multiple strategi..."
      },
      {
        "id": "design/concurrency-control-chunk-1",
        "text": "Save with automatic retry await repository Save(order); // Retries automatically on conflict ` Benefits: ✅ Handles most conflicts automatically ✅ Better developer experience ✅ Configurable retry policies Drawbacks: ❌ Complex to implement ❌ Not all conflicts can be auto-resolved Marten-Inspired Extensions Drawing from Marten's concurrency features, Whizbang also supports: D Token-Based Concurrency\nUsing opaque tokens instead of version numbers:\n`csharp\nvar (order, token) = await repository LoadWithToken<Order>(orderId);\n// Make changes\norder AddItem(new OrderItem(\"Product\", 10 00m));\n// Save with token\nawait repository Save(order, concurrencyToken: token);\n`\nE Revision-Based Tracking\nMarten-style revision tracking with metadata:\n`csharp\npublic class Order : Aggregate {\n    // Whizbang tracks revision automatically\n    public int Revision { get; internal set; }\n    public DateTime LastModified { get; internal set; }\n    public string LastModifiedBy { get; internal set; }\n}\nawait repository Save(order, expectedRevision: order Revision);\n`\nF Conditional Updates\nSQL-style conditional updates:\n`csharp\nawait repository Save(order, condition: o => o Status == OrderStatus Pending);\n// Only saves if order is still pending\n`\nPolicy-Driven Configuration\n> 📋 Universal Configuration: Whizbang uses the Policy Engine as the universal configuration scoping mechanism All concurrency strategies, retry policies, and conflict resolution rules are configured through policies rather than direct configuration methods Basic Policy Configuration\nConfigure concurrency strategies using the Policy Engine - the universal configuration scoping mechanism:\n`csharp\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        // Global default strategy\n        policies When(ctx => true) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy ExpectedVersion)) And(config => config SetRetryAttempts(3)) And(config => config SetRetryDelay(TimeSpan FromMilliseconds(100)));\n    });\n});\n`\nAdvanced Policy Scenarios\nCombine multiple conditions for sophisticated concurrency control:\n`csharp\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        // Orders get automatic retry with more attempts\n        policies When(ctx => ctx MatchesAggregate<Order>()) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy AutomaticRetry)) And(config => config",
        "startIndex": 2568,
        "preview": "Save with automatic retry await repository Save(order); // Retries automatically on conflict ` Benefits: ✅ Handles most conflicts automatically ✅ Bett..."
      },
      {
        "id": "design/concurrency-control-chunk-2",
        "text": "config SetRetryAttempts(3)) And(config => config SetRetryDelay(TimeSpan FromMilliseconds(100))); }); }); ` Advanced Policy Scenarios Combine multiple conditions for sophisticated concurrency control: `csharp services AddWhizbang(options => { options Policies(policies => { // Orders get automatic retry with more attempts policies When(ctx => ctx MatchesAggregate<Order>()) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy AutomaticRetry)) And(config => config SetRetryAttempts(5)); // Orders get more retries\n        // Shopping carts use timestamp-based for simplicity\n        policies When(ctx => ctx MatchesAggregate<ShoppingCart>()) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy TimestampBased));\n        // High-volume commands get automatic retry\n        policies When(ctx => ctx HasTag(\"high-volume\")) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy AutomaticRetry)) And(config => config SetRetryAttempts(5));\n        // Load testing uses relaxed concurrency\n        policies When(ctx => ctx HasFlag(WhizbangFlags LoadTesting)) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy LastWriteWins));\n        // Environment-based strategies\n        policies When(ctx => ctx Environment == \"production\") Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy ExpectedVersion)) And(config => config SetRetryAttempts(3));\n        policies When(ctx => ctx Environment == \"development\") Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy LastWriteWins)); // Relaxed for dev\n        // Tenant-specific strategies\n        policies When(ctx => ctx TenantId = null && ctx HasTag(\"enterprise-tenant\")) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy ExpectedVersion)) And(config => config SetRetryAttempts(5)) And(config => config EnableStrictConflictResolution());\n    });\n});\n`\nRuntime Policy Evaluation\nPolicies are evaluated at runtime based on the current context:\n`csharp\n// Policy evaluation happens automatically during save operations\nawait repository Save(order, context => {\n    context WithTag(\"high-volume\");        // Triggers high-volume policy\n    context WithFlag(WhizbangFlags Production); // Triggers production policy\n});\n// Context determines which concurrency strategy is used\n// No need to manually specify strategy - policies handle it\n`\nManual Override (When Needed)\nOverride policies for exceptional cases:\n`csharp\n// Explicit override for critical operations\nawait repository Save(order, saveOptions => {\n    saveOptions OverrideConcurrencyStrategy(ConcurrencyStrategy ExpectedVersion);\n    saveOptions SetExpectedVersion(5);\n    saveOptions BypassPolicies(); // Skip policy evaluation\n});\n`\nConflict Resolution Strategies\nBuilt-in Resolvers\n`csharp\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        // Last-write-wins for Order aggregates\n        policies When(ctx => ctx MatchesAggregate<Order>()) Then(config => config SetConflictResolver(ConflictResolvers",
        "startIndex": 4679,
        "preview": "config SetRetryAttempts(3)) And(config => config SetRetryDelay(TimeSpan FromMilliseconds(100))); }); }); ` Advanced Policy Scenarios Combine multiple ..."
      },
      {
        "id": "design/concurrency-control-chunk-3",
        "text": "for critical operations await repository Save(order, saveOptions => { saveOptions OverrideConcurrencyStrategy(ConcurrencyStrategy ExpectedVersion); saveOptions SetExpectedVersion(5); saveOptions BypassPolicies(); // Skip policy evaluation }); ` Conflict Resolution Strategies Built-in Resolvers `csharp services AddWhizbang(options => { options Policies(policies => { // Last-write-wins for Order aggregates policies When(ctx => ctx MatchesAggregate<Order>()) Then(config => config SetConflictResolver(ConflictResolvers LastWriteWins));\n        // First-write-wins for Customer aggregates (reject conflicting changes)\n        policies When(ctx => ctx MatchesAggregate<Customer>()) Then(config => config SetConflictResolver(ConflictResolvers FirstWriteWins));\n        // Additive merge for ShoppingCart (combine collections)\n        policies When(ctx => ctx MatchesAggregate<ShoppingCart>()) Then(config => config SetConflictResolver(ConflictResolvers AdditiveMerge));\n    });\n});\n`\nCustom Conflict Resolvers via Policies\nDefine custom conflict resolution logic through policies:\n`csharp\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        // Custom resolver for Order aggregates\n        policies When(ctx => ctx MatchesAggregate<Order>()) Then(config => config SetConflictResolver((current, attempted) => {\n                    var resolved = current Copy();\n                    // Merge line items additively\n                    foreach (var item in attempted Items) {\n                        if ( resolved Items Any(i => i ProductId == item ProductId)) {\n                            resolved AddItem(item);\n                        }\n                    }\n                    // Take latest shipping address\n                    if (attempted ShippingAddress = null) {\n                        resolved UpdateShippingAddress(attempted ShippingAddress);\n                    }\n                    return resolved;\n                }));\n    });\n});\n`\nAdvanced Conflict Resolution\nAccess full conflict context through policies:\n`csharp\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        policies When(ctx => ctx MatchesAggregate<Order>()) Then(config => config SetConflictResolver((context) => {\n                    var current = context CurrentVersion;\n                    var attempted = context AttemptedVersion;\n                    var original = context OriginalVersion; // Version when load started\n                    // Three-way merge using original as base\n                    return ThreeWayMerge(original, current, attempted);\n                }));\n    });\n});\n});\n`\nImplementation Details\nConcurrency Exception Handling\n`csharp\npublic class ConcurrencyException : Exception {\n    public string StreamId { get; }\n    public int ExpectedVersion { get; }\n    public int ActualVersion { get; }\n    public Type AggregateType { get; }\n    public ConcurrencyException(string streamId, int expectedVersion, int actualVersion, Type aggregateType)\n        : base($\"Concurrency conflict in {aggregateType Name} stream {streamId}",
        "startIndex": 7390,
        "preview": "for critical operations await repository Save(order, saveOptions => { saveOptions OverrideConcurrencyStrategy(ConcurrencyStrategy ExpectedVersion); sa..."
      },
      {
        "id": "design/concurrency-control-chunk-4",
        "text": "Exception Handling `csharp public class ConcurrencyException : Exception { public string StreamId { get; } public int ExpectedVersion { get; } public int ActualVersion { get; } public Type AggregateType { get; } public ConcurrencyException(string streamId, int expectedVersion, int actualVersion, Type aggregateType) : base($\"Concurrency conflict in {aggregateType Name} stream {streamId} Expected version {expectedVersion}, but current version is {actualVersion}\") {\n        StreamId = streamId;\n        ExpectedVersion = expectedVersion;\n        ActualVersion = actualVersion;\n        AggregateType = aggregateType;\n    }\n}\n`\nRetry Logic\n`csharp\npublic class RetryPolicy {\n    public int MaxAttempts { get; set; } = 3;\n    public TimeSpan InitialDelay { get; set; } = TimeSpan FromMilliseconds(100);\n    public TimeSpan MaxDelay { get; set; } = TimeSpan FromSeconds(1);\n    public double BackoffMultiplier { get; set; } = 2 0;\n    public RetryJitter Jitter { get; set; } = RetryJitter Random;\n}\n// Example retry sequence:\n// Attempt 1: 100ms + random(0-50ms)\n// Attempt 2: 200ms + random(0-100ms)  \n// Attempt 3: 400ms + random(0-200ms)\n`\nDriver Interface\n`csharp\npublic interface IConcurrencyDriver {\n    Task<T> Load<T>(string streamId, ConcurrencyOptions options) where T : Aggregate;\n    Task<(T Aggregate, ConcurrencyToken Token)> LoadWithToken<T>(string streamId) where T : Aggregate;\n    Task Save<T>(T aggregate, ConcurrencyCheck check) where T : Aggregate;\n    Task<SaveResult> TrySave<T>(T aggregate, ConcurrencyCheck check) where T : Aggregate;\n    Task<ConflictResolutionResult> ResolveConflict<T>(\n        T original, \n        T current, \n        T attempted, \n        ConflictResolver<T> resolver) where T : Aggregate;\n}\npublic class ConcurrencyCheck {\n    public ConcurrencyStrategy Strategy { get; set; }\n    public int ExpectedVersion { get; set; }\n    public DateTime IfNotModifiedSince { get; set; }\n    public ConcurrencyToken Token { get; set; }\n    public Expression<Func<object, bool>> Condition { get; set; }\n}\n`\nPerformance Considerations\nOptimizations\nVersion caching - Cache current versions to reduce round trips\nBatch operations - Group saves to reduce conflicts\nRead replicas - Load from read replicas to reduce load on primary\nConflict prediction - Use heuristics to predict likely conflicts\nMonitoring\n`csharp\nservices",
        "startIndex": 10014,
        "preview": "Exception Handling `csharp public class ConcurrencyException : Exception { public string StreamId { get; } public int ExpectedVersion { get; } public ..."
      },
      {
        "id": "design/concurrency-control-chunk-5",
        "text": "get; set; } } ` Performance Considerations Optimizations Version caching - Cache current versions to reduce round trips Batch operations - Group saves to reduce conflicts Read replicas - Load from read replicas to reduce load on primary Conflict prediction - Use heuristics to predict likely conflicts Monitoring `csharp services AddWhizbang(options => {\n    options UseOptimisticConcurrency(concurrency => {\n        concurrency OnConflict = (context) => {\n            // Log conflict for monitoring\n            logger LogWarning(\"Concurrency conflict in {StreamId}: {Conflict}\", \n                context StreamId, context ConflictDescription);\n            // Emit metrics\n            metrics IncrementCounter(\"whizbang concurrency conflicts\", \n                new[] { (\"aggregate_type\", context AggregateType Name) });\n        };\n        concurrency OnRetry = (context) => {\n            logger LogDebug(\"Retrying save for {StreamId}, attempt {Attempt}\", \n                context StreamId, context AttemptNumber);\n        };\n    });\n});\n`\nBest Practices\nStrategy Selection Guidelines\nExpected Version - Use for critical business operations requiring strict consistency\nTimestamp-Based - Use for user-facing operations where UX matters more than strict consistency\nAutomatic Retry - Use for high-contention scenarios with predictable merge strategies\nToken-Based - Use when integrating with external systems that provide tokens\nConditional - Use for operations that depend on specific business conditions\nConflict Resolution Guidelines\nKeep resolvers fast - Avoid heavy computation or I/O\nTest thoroughly - Ensure resolvers handle edge cases\nMake resolvers deterministic - Same inputs should produce same outputs\nLog conflicts - Track conflict patterns for optimization\nFallback to exceptions - Don't resolve conflicts you can't handle safely\n---\nRelated Documentation\nEvent Store & Projections - Storage architecture\nDomain Ownership - Command routing and ownership\nPerformance Optimization - Scaling strategies",
        "startIndex": 1387,
        "preview": "get; set; } } ` Performance Considerations Optimizations Version caching - Cache current versions to reduce round trips Batch operations - Group saves..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "design/deployment-operations",
    "title": "Deployment & Operations",
    "category": "Architecture & Design",
    "url": "/docs/design/deployment-operations",
    "chunks": [
      {
        "id": "design/deployment-operations-chunk-0",
        "text": "Deployment & Operations\nWhizbang is designed as an embedded library that runs within developer services, providing comprehensive operational hooks for production deployment, monitoring, and lifecycle management Deployment Model\nEmbedded Library Architecture\nWhizbang runs embedded within your application, not as a separate service:\n`csharp\n// Your service with Whizbang embedded\npublic class Program {\n    public static void Main(string[] args) {\n        var builder = WebApplication CreateBuilder(args);\n        // Add your application services\n        builder Services AddControllers();\n        builder Services AddOrderService();\n        // Add Whizbang as embedded library\n        builder Services AddWhizbang(options => {\n            options UsePostgresEventStore(connectionString);\n            options UseKafkaMessageBroker(kafkaConfig);\n            options ConfigureDomains();\n        });\n        var app = builder Build();\n        // Configure your application pipeline\n        app MapControllers();\n        app MapWhizbangEndpoints(); // Optional: Expose Whizbang endpoints\n        app",
        "startIndex": 0,
        "preview": "Deployment & Operations\nWhizbang is designed as an embedded library that runs within developer services, providing comprehensive operational hooks for..."
      },
      {
        "id": "design/deployment-operations-chunk-1",
        "text": "CreateBuilder(args); // Add your application services builder Services AddControllers(); builder Services AddOrderService(); // Add Whizbang as embedded library builder Services AddWhizbang(options => { options UsePostgresEventStore(connectionString); options UseKafkaMessageBroker(kafkaConfig); options ConfigureDomains(); }); var app = builder Build(); // Configure your application pipeline app MapControllers(); app MapWhizbangEndpoints(); // Optional: Expose Whizbang endpoints app Run();\n    }\n}\n`\nService Architecture Patterns\nMultiple deployment patterns supported:\nMonolithic Deployment\n`yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: ecommerce-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: ecommerce-service\n  template:\n    metadata:\n      labels:\n        app: ecommerce-service\n    spec:\n      containers:\nname: ecommerce-service\n        image: myapp/ecommerce-service:latest\n        ports:\ncontainerPort: 8080\n        env:\nname: WHIZBANG_EVENTSTORE_CONNECTION\n          valueFrom:\n            secretKeyRef:\n              name: database-secrets\n              key: connection-string\nname: WHIZBANG_MESSAGEBROKER_BOOTSTRAP_SERVERS\n          value: \"kafka:9092\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /health/ready\n            port: 8080\n          initialDelaySeconds: 5\n          periodSeconds: 5\n`\nMicroservices Deployment\n`yaml\nCommand Service\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: order-command-service\nspec:\n  replicas: 2\n  template:\n    spec:\n      containers:\nname: order-service\n        image: myapp/order-service:latest\n        env:\nname: WHIZBANG_DOMAIN\n          value: \"Orders\"\nname: WHIZBANG_PROJECTION_MODE\n          value: \"Disabled\" Command service doesn't run projections\n---\nProjection Worker Service  \napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: order-projection-worker\nspec:\n  replicas: 3\n  template:\n    spec:\n      containers:\nname: projection-worker\n        image: myapp/order-projection-worker:latest\n        env:\nname: WHIZBANG_DOMAIN\n          value: \"Orders\"\nname: WHIZBANG_COMMAND_MODE\n          value: \"Disabled\" Projection worker doesn't handle commands\nname: WHIZBANG_PROJECTIONS\n          value: \"OrderSummary,OrderHistory,OrderAnalytics\"\n`\nDomain-per-Service Deployment\n`yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: orders-service\nspec:\n  template:\n    spec:\n      containers:\nname: orders-service\n        image: myapp/orders-service:latest\n        env:\nname: WHIZBANG_OWNED_DOMAINS\n          value: \"Orders\"\n---\napiVersion: apps/v1  \nkind: Deployment\nmetadata:\n  name: inventory-service\nspec:\n  template:\n    spec:\n      containers:\nname: inventory-service\n        image: myapp/inventory-service:latest\n        env:\nname: WHIZBANG_OWNED_DOMAINS\n          value: \"Inventory\"\n`\nHealth Checks\nBuilt-in Health Check System\nComprehensive health monitoring ready for Kubernetes probes:\n`csharp\nservices AddWhizbang(options => {\n    options HealthChecks(health => {\n        // Core infrastructure health\n        health CheckEventStoreConnection = true;\n        health CheckMessageBrokerConnection = true;\n        health CheckProjectionHealth = true;\n        // Operational thresholds\n        health ProjectionLagThreshold = TimeSpan FromMinutes(5);\n        health EventStoreLatencyThreshold = TimeSpan FromMilliseconds(100);\n        health",
        "startIndex": 1097,
        "preview": "CreateBuilder(args); // Add your application services builder Services AddControllers(); builder Services AddOrderService(); // Add Whizbang as embedd..."
      },
      {
        "id": "design/deployment-operations-chunk-2",
        "text": "Built-in Health Check System Comprehensive health monitoring ready for Kubernetes probes: `csharp services AddWhizbang(options => { options HealthChecks(health => { // Core infrastructure health health CheckEventStoreConnection = true; health CheckMessageBrokerConnection = true; health CheckProjectionHealth = true; // Operational thresholds health ProjectionLagThreshold = TimeSpan FromMinutes(5); health EventStoreLatencyThreshold = TimeSpan FromMilliseconds(100); health MessageBrokerLatencyThreshold = TimeSpan FromMilliseconds(500);\n        // Custom health checks\n        health AddCheck<CustomBusinessLogicHealthCheck>();\n    });\n});\n// Register health check endpoints\napp MapHealthChecks(\"/health\", new HealthCheckOptions {\n    ResponseWriter = UIResponseWriter WriteHealthCheckUIResponse\n});\napp MapHealthChecks(\"/health/ready\", new HealthCheckOptions {\n    Predicate = check => check Tags Contains(\"ready\"),\n    ResponseWriter = UIResponseWriter WriteHealthCheckUIResponse\n});\napp MapHealthChecks(\"/health/live\", new HealthCheckOptions {\n    Predicate = check => check Tags Contains(\"live\")\n});\n`\nHealth Check Implementation\nDetailed health check implementation:\n`csharp\npublic class WhizbangHealthCheck : IHealthCheck {\n    private readonly IEventStore _eventStore;\n    private readonly IMessageBroker _messageBroker;\n    private readonly IProjectionManager _projectionManager;\n    private readonly WhizbangHealthOptions _options;\n    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default) {\n        var checks = new List<(string name, bool healthy, string details)>();\n        // Event store connectivity\n        if (_options CheckEventStoreConnection) {\n            try {\n                await _eventStore HealthCheckAsync(cancellationToken);\n                checks Add((\"EventStore\", true, \"Connected\"));\n            } catch (Exception ex) {\n                checks Add((\"EventStore\", false, ex Message));\n            }\n        }\n        // Message broker connectivity\n        if (_options CheckMessageBrokerConnection) {\n            try {\n                await _messageBroker HealthCheckAsync(cancellationToken);\n                checks Add((\"MessageBroker\", true, \"Connected\"));\n            } catch (Exception ex) {\n                checks Add((\"MessageBroker\", false, ex Message));\n            }\n        }\n        // Projection health\n        if (_options CheckProjectionHealth) {\n            var projections = await _projectionManager GetAllProjectionsAsync(cancellationToken);\n            foreach (var projection in projections) {\n                var lag = await _projectionManager GetLagAsync(projection Name, cancellationToken);\n                var healthy = lag <= _options ProjectionLagThreshold;\n                checks Add(($\"Projection:{projection Name}\", healthy, $\"Lag: {lag TotalSeconds}s\"));\n            }\n        }\n        // Determine overall health\n        var allHealthy = checks All(c => c healthy);\n        var status = allHealthy HealthStatus Healthy : HealthStatus Unhealthy;\n        var data = checks ToDictionary(c => c name, c => (object)new { \n            healthy = c healthy, \n            details = c",
        "startIndex": 4138,
        "preview": "Built-in Health Check System Comprehensive health monitoring ready for Kubernetes probes: `csharp services AddWhizbang(options => { options HealthChec..."
      },
      {
        "id": "design/deployment-operations-chunk-3",
        "text": "ProjectionLagThreshold; checks Add(($\"Projection:{projection Name}\", healthy, $\"Lag: {lag TotalSeconds}s\")); } } // Determine overall health var allHealthy = checks All(c => c healthy); var status = allHealthy HealthStatus Healthy : HealthStatus Unhealthy; var data = checks ToDictionary(c => c name, c => (object)new { healthy = c healthy, details = c details \n        });\n        return new HealthCheckResult(status, data: data);\n    }\n}\n`\nGraceful Shutdown NET Host Lifetime Integration\nProper integration with NET hosting lifetime for clean shutdown:\n`csharp\npublic class WhizbangHostedService : IHostedService, IDisposable {\n    private readonly IWhizbangRuntime _runtime;\n    private readonly ILogger<WhizbangHostedService> _logger;\n    private readonly WhizbangOptions _options;\n    public async Task StartAsync(CancellationToken cancellationToken) {\n        _logger LogInformation(\"Starting Whizbang runtime\");\n        await _runtime StartAsync(cancellationToken);\n        _logger LogInformation(\"Whizbang runtime started\");\n    }\n    public async Task StopAsync(CancellationToken cancellationToken) {\n        _logger LogInformation(\"Stopping Whizbang runtime\");\n        try {\n            // Stop accepting new messages\n            await _runtime StopAcceptingMessagesAsync(cancellationToken);\n            _logger LogInformation(\"Stopped accepting new messages\");\n            // Drain in-flight messages with timeout\n            var drainTimeout = _options GracefulShutdownTimeout TimeSpan FromSeconds(30);\n            using var drainCts = CancellationTokenSource CreateLinkedTokenSource(cancellationToken);\n            drainCts CancelAfter(drainTimeout);\n            await _runtime DrainInFlightMessagesAsync(drainCts Token);\n            _logger LogInformation(\"Drained in-flight messages\");\n            // Stop projections\n            await _runtime StopProjectionsAsync(cancellationToken);\n            _logger LogInformation(\"Stopped projections\");\n            // Close connections\n            await _runtime CloseConnectionsAsync(cancellationToken);\n            _logger LogInformation(\"Closed connections\");\n        } catch (OperationCanceledException) {\n            _logger LogWarning(\"Graceful shutdown timed out, forcing shutdown\");\n        } catch (Exception ex) {\n            _logger LogError(ex, \"Error during graceful shutdown\");\n        }\n        _logger LogInformation(\"Whizbang runtime stopped\");\n    }\n    public void Dispose() {\n        _runtime Dispose();\n    }\n}\n`\nKubernetes Integration\nSIGTERM handling for Kubernetes graceful shutdown:\n`csharp\npublic class GracefulShutdownService : BackgroundService {\n    private readonly IHostApplicationLifetime _applicationLifetime;\n    private readonly IWhizbangRuntime _runtime;\n    private readonly ILogger<GracefulShutdownService> _logger;\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken) {\n        // Register for shutdown notification\n        _applicationLifetime ApplicationStopping Register(OnShutdown);\n        // Wait for shutdown\n        await Task Delay(Timeout Infinite, stoppingToken);\n    }\n    private void OnShutdown() {\n        _logger LogInformation(\"Received shutdown signal, initiating graceful shutdown\");\n        // Custom shutdown logic\n        Task",
        "startIndex": 6881,
        "preview": "ProjectionLagThreshold; checks Add(($\"Projection:{projection Name}\", healthy, $\"Lag: {lag TotalSeconds}s\")); } } // Determine overall health var allHe..."
      },
      {
        "id": "design/deployment-operations-chunk-4",
        "text": "_applicationLifetime; private readonly IWhizbangRuntime _runtime; private readonly ILogger<GracefulShutdownService> _logger; protected override async Task ExecuteAsync(CancellationToken stoppingToken) { // Register for shutdown notification _applicationLifetime ApplicationStopping Register(OnShutdown); // Wait for shutdown await Task Delay(Timeout Infinite, stoppingToken); } private void OnShutdown() { _logger LogInformation(\"Received shutdown signal, initiating graceful shutdown\"); // Custom shutdown logic Task Run(async () => {\n            try {\n                // Give projections time to finish current batch\n                await _runtime CompleteCurrentBatchAsync(TimeSpan FromSeconds(10));\n                // Signal readiness probe to fail (remove from load balancer)\n                _runtime MarkAsNotReady();\n                // Wait for load balancer to drain\n                await Task Delay(TimeSpan FromSeconds(5));\n                _logger LogInformation(\"Graceful shutdown preparation complete\");\n            } catch (Exception ex) {\n                _logger LogError(ex, \"Error during shutdown preparation\");\n            }\n        });\n    }\n}\n`\nConfiguration Management\nEnvironment-Specific Configuration\nFlexible configuration for different deployment environments:\n`csharp\n// appsettings json (base configuration)\n{\n  \"Whizbang\": {\n    \"EventStore\": {\n      \"Driver\": \"Postgres\"\n    },\n    \"MessageBroker\": {\n      \"Driver\": \"Kafka\"\n    },\n    \"Projections\": {\n      \"DefaultStrategy\": \"Automatic\"\n    }\n  }\n}\n// appsettings Development json\n{\n  \"Whizbang\": {\n    \"EventStore\": {\n      \"ConnectionString\": \"Host=localhost;Database=whizbang_dev\",\n      \"EnableDetailedLogging\": true\n    },\n    \"MessageBroker\": {\n      \"BootstrapServers\": \"localhost:9092\",\n      \"EnableAutoCommit\": true\n    },\n    \"Observability\": {\n      \"Level\": \"Verbose\",\n      \"SampleRate\": 1 0\n    }\n  }\n}\n// appsettings Production json\n{\n  \"Whizbang\": {\n    \"EventStore\": {\n      \"ConnectionString\": \"\", // Set via environment variable\n      \"PoolSize\": 20,\n      \"CommandTimeout\": 30\n    },\n    \"MessageBroker\": {\n      \"BootstrapServers\": \"\", // Set via environment variable\n      \"SecurityProtocol\": \"SaslSsl\",\n      \"EnableIdempotence\": true\n    },\n    \"Observability\": {\n      \"Level\": \"Standard\",\n      \"SampleRate\": 0 1\n    },\n    \"HealthChecks\": {\n      \"ProjectionLagThresholdMinutes\": 5,\n      \"EventStoreLatencyThresholdMs\": 100\n    }\n  }\n}\n`\nSecret Management\nSecure credential handling:\n`csharp\n// Using Azure Key Vault\nbuilder Configuration AddAzureKeyVault(\n    new Uri(\"https://myapp-keyvault vault azure net/\"),\n    new DefaultAzureCredential()\n);\n// Using Kubernetes secrets\nservices AddWhizbang(options => {\n    // Connection string from Kubernetes secret\n    var connectionString = Environment GetEnvironmentVariable(\"WHIZBANG_EVENTSTORE_CONNECTION\") throw new InvalidOperationException(\"Event store connection string not configured\");\n    options UsePostgresEventStore(connectionString);\n    // Message broker configuration from environment\n    options UseKafkaMessageBroker(kafka => {\n        kafka BootstrapServers = Environment GetEnvironmentVariable(\"KAFKA_BOOTSTRAP_SERVERS\");\n        kafka",
        "startIndex": 9806,
        "preview": "_applicationLifetime; private readonly IWhizbangRuntime _runtime; private readonly ILogger<GracefulShutdownService> _logger; protected override async ..."
      },
      {
        "id": "design/deployment-operations-chunk-5",
        "text": "azure net/\"), new DefaultAzureCredential() ); // Using Kubernetes secrets services AddWhizbang(options => { // Connection string from Kubernetes secret var connectionString = Environment GetEnvironmentVariable(\"WHIZBANG_EVENTSTORE_CONNECTION\") throw new InvalidOperationException(\"Event store connection string not configured\"); options UsePostgresEventStore(connectionString); // Message broker configuration from environment options UseKafkaMessageBroker(kafka => { kafka BootstrapServers = Environment GetEnvironmentVariable(\"KAFKA_BOOTSTRAP_SERVERS\"); kafka SecurityProtocol = Enum Parse<SecurityProtocol>(\n            Environment GetEnvironmentVariable(\"KAFKA_SECURITY_PROTOCOL\") \"Plaintext\"\n        );\n        if (kafka SecurityProtocol = SecurityProtocol Plaintext) {\n            kafka SaslUsername = Environment GetEnvironmentVariable(\"KAFKA_SASL_USERNAME\");\n            kafka SaslPassword = Environment GetEnvironmentVariable(\"KAFKA_SASL_PASSWORD\");\n        }\n    });\n});\n`\nMonitoring and Alerting\nProduction Monitoring Setup\nComprehensive monitoring stack integration:\n`yaml\nPrometheus ServiceMonitor for metrics scraping\napiVersion: monitoring coreos com/v1\nkind: ServiceMonitor\nmetadata:\n  name: whizbang-metrics\nspec:\n  selector:\n    matchLabels:\n      app: ecommerce-service\n  endpoints:\nport: metrics\n    path: /metrics\n    interval: 30s\n    scrapeTimeout: 10s\n---\nGrafana dashboard ConfigMap\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: whizbang-dashboard\ndata:\n  dashboard json: |\n    {\n      \"dashboard\": {\n        \"title\": \"Whizbang Application Metrics\",\n        \"panels\": [\n          {\n            \"title\": \"Command Processing Rate\",\n            \"targets\": [\n              {\n                \"expr\": \"rate(whizbang_command_total[5m])\",\n                \"legendFormat\": \"{{command_type}}\"\n              }\n            ]\n          }\n        ]\n      }\n    }\n`\nLog Aggregation\nStructured logging for centralized log management:\n`csharp\nservices AddWhizbang(options => {\n    options Logging(logging => {\n        logging StructuredLogging = true;\n        logging IncludeCorrelationIds = true;\n        logging IncludeDomainContext = true;\n        logging SanitizeSensitiveData = true;\n        // Log levels by component\n        logging SetLogLevel(\"Whizbang Commands\", LogLevel Information);\n        logging SetLogLevel(\"Whizbang Events\", LogLevel Information);\n        logging SetLogLevel(\"Whizbang Projections\", LogLevel Warning);\n        logging SetLogLevel(\"Whizbang Policies\", LogLevel Debug);\n    });\n});\n// Example structured log output\n{\n  \"timestamp\": \"2024-01-01T10:00:00",
        "startIndex": 12511,
        "preview": "azure net/\"), new DefaultAzureCredential() ); // Using Kubernetes secrets services AddWhizbang(options => { // Connection string from Kubernetes secre..."
      },
      {
        "id": "design/deployment-operations-chunk-6",
        "text": "StructuredLogging = true; logging IncludeCorrelationIds = true; logging IncludeDomainContext = true; logging SanitizeSensitiveData = true; // Log levels by component logging SetLogLevel(\"Whizbang Commands\", LogLevel Information); logging SetLogLevel(\"Whizbang Events\", LogLevel Information); logging SetLogLevel(\"Whizbang Projections\", LogLevel Warning); logging SetLogLevel(\"Whizbang Policies\", LogLevel Debug); }); }); // Example structured log output { \"timestamp\": \"2024-01-01T10:00:00 000Z\",\n  \"level\": \"Information\",\n  \"messageTemplate\": \"Command {CommandType} processed for domain {Domain}\",\n  \"properties\": {\n    \"CommandType\": \"PlaceOrder\",\n    \"Domain\": \"Orders\",\n    \"CorrelationId\": \"abc-123-def\",\n    \"TenantId\": \"tenant-456\",\n    \"ExecutionTimeMs\": 45,\n    \"Success\": true\n  }\n}\n`\nScaling Strategies\nHorizontal Scaling\nScale-out patterns for high throughput:\n`yaml\nHorizontal Pod Autoscaler\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: ecommerce-service-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: ecommerce-service\n  minReplicas: 2\n  maxReplicas: 20\n  metrics:\ntype: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70\ntype: Resource\n    resource:\n      name: memory\n      target:\n        type: Utilization\n        averageUtilization: 80\ntype: Pods\n    pods:\n      metric:\n        name: whizbang_projection_lag_seconds\n      target:\n        type: AverageValue\n        averageValue: \"300\" Scale when lag > 5 minutes\n`\nVertical Scaling\nResource optimization for different workloads:\n`yaml\nCommand-heavy service\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: order-command-service\nspec:\n  template:\n    spec:\n      containers:\nname: order-service\n        resources:\n          requests:\n            cpu: 500m      Higher CPU for command processing\n            memory: 512Mi\n          limits:\n            cpu: 2000m\n            memory: 1Gi\n---\nProjection-heavy service\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: analytics-projection-worker\nspec:\n  template:\n    spec:\n      containers:\nname: projection-worker\n        resources:\n          requests:\n            cpu: 200m\n            memory: 1Gi    Higher memory for projection state\n          limits:\n            cpu: 1000m\n            memory: 4Gi\n`\nBest Practices\nDeployment Guidelines\nStart simple - Begin with monolithic deployment, extract services as needed\nUse health checks - Implement comprehensive liveness and readiness probes\nPlan for scaling - Design with horizontal scaling in mind\nMonitor everything - Set up observability before going to production\nTest failure modes - Practice chaos engineering and disaster recovery\nConfiguration Management\nEnvironment parity - Keep development and production configs similar\nSecure secrets - Never store credentials in code or config files\nValidate on startup - Fail fast if configuration is invalid\nDocument settings - Maintain clear documentation of all configuration options\nVersion configurations - Track configuration changes alongside code\nOperational Excellence\nAutomate deployments - Use CI/CD pipelines for consistent deployments\nMonitor SLOs - Define and track service level objectives\nPlan for disasters - Regular backup and recovery testing\nCapacity planning - Monitor trends and plan for growth\nRegular maintenance - Schedule updates and maintenance windows\n---\nRelated Documentation\nObservability & Metrics - Production monitoring setup\nTesting & Development Tools - Testing deployment configurations\nAdvanced Features - Kubernetes operator features",
        "startIndex": 14549,
        "preview": "StructuredLogging = true; logging IncludeCorrelationIds = true; logging IncludeDomainContext = true; logging SanitizeSensitiveData = true; // Log leve..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "design/domain-ownership",
    "title": "Domain Ownership",
    "category": "Architecture & Design",
    "url": "/docs/design/domain-ownership",
    "chunks": [
      {
        "id": "design/domain-ownership-chunk-0",
        "text": "Domain Ownership\nWhizbang enforces explicit domain ownership to prevent distributed system chaos Every command and event has a clear owner, enabling proper routing, authorization, and system boundaries Ownership Determination Order\nDomain ownership is determined in user-configurable order, with this default precedence:\nNamespace Convention (highest priority)\nAttributes \nConfiguration-Driven (lowest priority)\nEach level can override previous levels, giving developers full control Namespace Convention (Default First)\nAutomatic ownership derived from namespace structure:\n`csharp\n// Orders domain\nnamespace MyApp Orders Commands {\n    public record PlaceOrder(Guid OrderId, Guid CustomerId, List<OrderItem> Items);\n    // Domain: \"Orders\" (extracted from namespace)\n}\nnamespace MyApp Orders Events {\n    public record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt);\n    // Domain: \"Orders\"\n}\n// Inventory domain  \nnamespace MyApp Inventory Commands {\n    public record ReserveStock(Guid ProductId, int Quantity);\n    // Domain: \"Inventory\"\n}\n`\nNamespace Policy Configuration\n`csharp\nservices AddWhizbang(options => {\n    options DomainOwnership(ownership => {\n        // Configure namespace extraction policies\n        ownership NamespacePolicy(policy => {\n            // Default: Extract domain from namespace segment\n            policy ExtractDomainFromNamespace = true;\n            policy DomainNamespacePosition = 1; // MyApp [Domain] Commands\n            // Custom extraction function\n            policy DomainExtractor = (type) => {\n                var segments = type Namespace Split(' ');\n                if (segments Length >= 3 && segments[1] == \"Domains\") {\n                    return segments[2]; // MyApp Domains [Domain] Commands\n                }\n                return segments Length >= 2 segments[1] : \"Default\";\n            };\n            // Namespace patterns\n            policy CommandNamespacePattern = \"* Commands\";\n            policy EventNamespacePattern = \"* Events\";\n            policy QueryNamespacePattern = \"* Queries\";\n        });\n    });\n});\n`\nAttribute-Based Ownership\nExplicit declaration using attributes:\n`csharp\n[OwnedBy(\"Orders\")]\npublic record PlaceOrder(Guid OrderId, Guid CustomerId, List<OrderItem> Items);\n[OwnedBy(\"Orders\")]\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt);\n// Override namespace convention\nnamespace MyApp Shared Commands {\n    [OwnedBy(\"Inventory\")] // Overrides \"Shared\" from namespace\n    public record ReserveStock(Guid ProductId, int Quantity);\n}\n`\nAttribute Policies\n`csharp\nservices AddWhizbang(options => {\n    options DomainOwnership(ownership => {\n        ownership",
        "startIndex": 0,
        "preview": "Domain Ownership\nWhizbang enforces explicit domain ownership to prevent distributed system chaos Every command and event has a clear owner, enabling p..."
      },
      {
        "id": "design/domain-ownership-chunk-1",
        "text": "PlaceOrder(Guid OrderId, Guid CustomerId, List<OrderItem> Items); [OwnedBy(\"Orders\")] public record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt); // Override namespace convention namespace MyApp Shared Commands { [OwnedBy(\"Inventory\")] // Overrides \"Shared\" from namespace public record ReserveStock(Guid ProductId, int Quantity); } ` Attribute Policies `csharp services AddWhizbang(options => { options DomainOwnership(ownership => { ownership AttributePolicy(policy => {\n            // Require explicit ownership for certain patterns\n            policy RequireExplicitOwnership<ICommand>();\n            policy RequireExplicitOwnership(type => type Name EndsWith(\"Command\"));\n            // Default ownership for unattributed types\n            policy DefaultDomain = \"Shared\";\n            // Custom attribute types\n            policy RecognizeAttribute<DomainAttribute>();\n            policy RecognizeAttribute<BoundedContextAttribute>();\n        });\n    });\n});\n`\nConfiguration-Driven Ownership\nCentralized registration in Program cs:\n`csharp\nservices AddWhizbang(options => {\n    options DomainOwnership(ownership => {\n        // Register domains with explicit ownership\n        ownership RegisterDomain(\"Orders\", domain => {\n            domain OwnsCommand<PlaceOrder>();\n            domain OwnsCommand<UpdateOrder>();\n            domain OwnsEvent<OrderPlaced>();\n            domain OwnsEvent<OrderUpdated>();\n            // Override other declarations\n            domain OwnsCommand<SpecialSharedCommand>(); // Takes from \"Shared\"\n        });\n        ownership RegisterDomain(\"Inventory\", domain => {\n            domain OwnsCommand<ReserveStock>();\n            domain OwnsCommand<ReleaseStock>();\n            domain OwnsEvent<StockReserved>();\n            domain OwnsEvent<StockReleased>();\n        });\n    });\n});\n`\nInterface and Inheritance Policies\nInterface-Based Ownership\n`csharp\n// Domain marker interfaces\npublic interface IOrderCommand : ICommand { }\npublic interface IInventoryCommand : ICommand { }\npublic record PlaceOrder( ) : IOrderCommand;\npublic record ReserveStock( ) : IInventoryCommand;\n// Configure interface-based ownership\nservices AddWhizbang(options => {\n    options DomainOwnership(ownership => {\n        ownership InterfacePolicy(policy => {\n            policy RegisterInterface<IOrderCommand>(\"Orders\");\n            policy RegisterInterface<IInventoryCommand>(\"Inventory\");\n            policy RegisterInterface<ISharedCommand>(\"Shared\");\n        });\n    });\n});\n`\nInheritance-Based Ownership\n`csharp\n// Base classes for domains\npublic abstract class OrderCommand : ICommand {\n    // Common order command properties\n}\npublic abstract class InventoryCommand : ICommand {\n    // Common inventory command properties  \n}\npublic class PlaceOrder : OrderCommand {\n    // Inherits \"Orders\" domain\n}\n// Configure inheritance-based ownership\nservices AddWhizbang(options => {\n    options DomainOwnership(ownership => {\n        ownership InheritancePolicy(policy => {\n            policy RegisterBaseClass<OrderCommand>(\"Orders\");\n            policy RegisterBaseClass<InventoryCommand>(\"Inventory\");\n        });\n    });\n});\n`\nCustom Ownership Precedence\nDeveloper controls the order of ownership determination:\n`csharp\nservices",
        "startIndex": 2700,
        "preview": "PlaceOrder(Guid OrderId, Guid CustomerId, List<OrderItem> Items); [OwnedBy(\"Orders\")] public record OrderPlaced(Guid OrderId, Guid CustomerId, DateTim..."
      },
      {
        "id": "design/domain-ownership-chunk-2",
        "text": "command properties } public class PlaceOrder : OrderCommand { // Inherits \"Orders\" domain } // Configure inheritance-based ownership services AddWhizbang(options => { options DomainOwnership(ownership => { ownership InheritancePolicy(policy => { policy RegisterBaseClass<OrderCommand>(\"Orders\"); policy RegisterBaseClass<InventoryCommand>(\"Inventory\"); }); }); }); ` Custom Ownership Precedence Developer controls the order of ownership determination: `csharp services AddWhizbang(options => {\n    options DomainOwnership(ownership => {\n        // Custom precedence order\n        ownership PrecedenceOrder(\n            DomainOwnershipSource Attributes,        // Check attributes first\n            DomainOwnershipSource Configuration,     // Then explicit config\n            DomainOwnershipSource Interfaces,        // Then interfaces\n            DomainOwnershipSource Inheritance,       // Then inheritance\n            DomainOwnershipSource Namespace          // Finally namespace\n        );\n        // Or use fluent API\n        ownership CheckAttributesFirst() ThenConfiguration() ThenInterfaces() ThenInheritance() FinallyNamespace();\n    });\n});\n`\nComplex Policy Examples\nMulti-Level Namespace Extraction\n`csharp\nservices AddWhizbang(options => {\n    options DomainOwnership(ownership => {\n        ownership NamespacePolicy(policy => {\n            policy DomainExtractor = (type) => {\n                var ns = type Namespace;\n                // MyApp Domains Orders Commands -> \"Orders\"\n                if (ns Contains(\" Domains \")) {\n                    var segments = ns Split(' ');\n                    var domainIndex = Array IndexOf(segments, \"Domains\") + 1;\n                    return domainIndex < segments Length segments[domainIndex] : \"Unknown\";\n                }\n                // MyApp Orders V2 Commands -> \"Orders\"\n                var parts = ns Split(' ');\n                if (parts Length >= 2) {\n                    return parts[1]; // Second segment is domain\n                }\n                return \"Default\";\n            };\n        });\n    });\n});\n`\nConditional Ownership Rules\n`csharp\nservices AddWhizbang(options => {\n    options DomainOwnership(ownership => {\n        ownership ConditionalRules(rules => {\n            // Integration events are always \"Shared\"\n            rules When(type => type Name EndsWith(\"IntegrationEvent\")) AssignToDomain(\"Shared\");\n            // Commands from external assemblies go to \"External\"\n            rules When(type => type Assembly GetName() Name StartsWith(\"MyApp\")) AssignToDomain(\"External\");\n            // Saga commands inherit from the saga's domain\n            rules When(type => typeof(ISagaCommand) IsAssignableFrom(type)) ExtractDomainFromProperty(\"SagaDomain\");\n        });\n    });\n});\n`\nAssembly-Based Policies\n`csharp\nservices AddWhizbang(options => {\n    options DomainOwnership(ownership => {\n        ownership AssemblyPolicy(policy => {\n            // Each assembly represents a domain\n            policy MapAssemblyToDomain(\"MyApp Orders\", \"Orders\");\n            policy MapAssemblyToDomain(\"MyApp Inventory\", \"Inventory\");\n            policy MapAssemblyToDomain(\"MyApp",
        "startIndex": 1119,
        "preview": "command properties } public class PlaceOrder : OrderCommand { // Inherits \"Orders\" domain } // Configure inheritance-based ownership services AddWhizb..."
      },
      {
        "id": "design/domain-ownership-chunk-3",
        "text": "AssignToDomain(\"External\"); // Saga commands inherit from the saga's domain rules When(type => typeof(ISagaCommand) IsAssignableFrom(type)) ExtractDomainFromProperty(\"SagaDomain\"); }); }); }); ` Assembly-Based Policies `csharp services AddWhizbang(options => { options DomainOwnership(ownership => { ownership AssemblyPolicy(policy => { // Each assembly represents a domain policy MapAssemblyToDomain(\"MyApp Orders\", \"Orders\"); policy MapAssemblyToDomain(\"MyApp Inventory\", \"Inventory\"); policy MapAssemblyToDomain(\"MyApp Shipping\", \"Shipping\");\n            // Assembly naming convention\n            policy ExtractDomainFromAssemblyName = true;\n            policy AssemblyNamePattern = \"MyApp {Domain}\";\n        });\n    });\n});\n`\nRuntime Ownership Resolution\nOwnership Discovery API\n`csharp\npublic interface IDomainOwnershipResolver {\n    string ResolveDomain<T>();\n    string ResolveDomain(Type type);\n    bool IsDomainOwner<T>(string domain);\n    IEnumerable<string> GetAllDomains();\n    IEnumerable<Type> GetDomainTypes(string domain);\n}\n// Usage\npublic class OrderController : ControllerBase {\n    private readonly IDomainOwnershipResolver _ownership;\n    public OrderController(IDomainOwnershipResolver ownership) {\n        _ownership = ownership;\n    }\n    public async Task<IActionResult> PlaceOrder(PlaceOrderRequest request) {\n        var domain = _ownership ResolveDomain<PlaceOrder>();\n        // domain = \"Orders\"\n        var command = new PlaceOrder(request OrderId, request CustomerId, request Items);\n        await _mediator Send(command);\n        return Ok();\n    }\n}\n`\nCompile-Time Validation\nRoslyn analyzer enforces ownership rules:\n`csharp\n// This will generate a compile error\n[OwnedBy(\"Orders\")]\npublic record PlaceOrder( );\n// In different assembly/project\npublic class InventoryHandler : ICommandHandler<PlaceOrder> {\n    // ERROR: InventoryHandler cannot handle PlaceOrder - different domains\n    public async Task Handle(PlaceOrder command) { }\n}\n`\nSource Generator Support\n`csharp\n// Generated at compile time\n[GeneratedCode(\"Whizbang SourceGenerator\")]\npublic static class DomainOwnershipRegistry {\n    public static readonly Dictionary<Type, string> TypeToDomain = new() {\n        { typeof(PlaceOrder), \"Orders\" },\n        { typeof(OrderPlaced), \"Orders\" },\n        { typeof(ReserveStock), \"Inventory\" },\n        { typeof(StockReserved), \"Inventory\" }\n    };\n    public static readonly Dictionary<string, HashSet<Type>> DomainToTypes = new() {\n        { \"Orders\", new HashSet<Type> { typeof(PlaceOrder), typeof(OrderPlaced) } },\n        { \"Inventory\", new HashSet<Type> { typeof(ReserveStock), typeof(StockReserved) } }\n    };\n}\n`\nCommand Routing Based on Ownership\nIn-Process Routing\n`csharp\n// Same domain - route locally\nvar command = new PlaceOrder( );\nvar domain = _ownership ResolveDomain<PlaceOrder>(); // \"Orders\"\nvar handler = _serviceProvider",
        "startIndex": 8316,
        "preview": "AssignToDomain(\"External\"); // Saga commands inherit from the saga's domain rules When(type => typeof(ISagaCommand) IsAssignableFrom(type)) ExtractDom..."
      },
      {
        "id": "design/domain-ownership-chunk-4",
        "text": "new HashSet<Type> { typeof(PlaceOrder), typeof(OrderPlaced) } }, { \"Inventory\", new HashSet<Type> { typeof(ReserveStock), typeof(StockReserved) } } }; } ` Command Routing Based on Ownership In-Process Routing `csharp // Same domain - route locally var command = new PlaceOrder( ); var domain = _ownership ResolveDomain<PlaceOrder>(); // \"Orders\" var handler = _serviceProvider GetRequiredService<ICommandHandler<PlaceOrder>>();\nawait handler Handle(command);\n`\nCross-Service Routing\n`csharp\n// Different domain - route via message broker\nvar command = new ReserveStock( );\nvar domain = _ownership ResolveDomain<ReserveStock>(); // \"Inventory\"\nif (domain = _currentDomain) {\n    // Send to remote service\n    await _messageBroker SendToService(domain, command);\n} else {\n    // Handle locally\n    await _localMediator Send(command);\n}\n`\nBest Practices\nOwnership Guidelines\nBe explicit - Prefer attributes over conventions for critical commands\nConsistent patterns - Use the same ownership style within a domain\nDocument policies - Make namespace and interface conventions clear\nValidate early - Use analyzers to catch ownership violations\nMonitor boundaries - Track cross-domain communication patterns\nPolicy Design\nStart simple - Begin with namespace conventions\nAdd specificity - Use attributes for exceptions\nCentralize overrides - Use configuration for edge cases\nTest policies - Ensure ownership resolution works as expected\nVersion carefully - Changing ownership affects routing\n---\nRelated Documentation\nEvent Store & Projections - Storage architecture\nConcurrency Control - Managing concurrent updates  \nMulti-Tenancy - Tenant isolation with domain ownership",
        "startIndex": 10684,
        "preview": "new HashSet<Type> { typeof(PlaceOrder), typeof(OrderPlaced) } }, { \"Inventory\", new HashSet<Type> { typeof(ReserveStock), typeof(StockReserved) } } };..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "design/event-store-projections",
    "title": "Event Store & Projection Architecture",
    "category": "Architecture & Design",
    "url": "/docs/design/event-store-projections",
    "chunks": [
      {
        "id": "design/event-store-projections-chunk-0",
        "text": "Event Store & Projection Architecture\nWhizbang implements a hybrid event store and projection architecture that separates event persistence from projection storage, enabling flexible schema evolution and high-performance querying Core Architecture\nHybrid Storage Design\nEvents Table (Immutable Event Stream):\n`sql\nCREATE TABLE events (\n    event_id BIGSERIAL PRIMARY KEY,\n    stream_id VARCHAR(255) NOT NULL,\n    stream_version INT NOT NULL,\n    event_type VARCHAR(255) NOT NULL,\n    event_data JSONB NOT NULL,\n    metadata JSONB,\n    tenant_id VARCHAR(100),\n    created_at TIMESTAMPTZ NOT NULL,\n    UNIQUE(stream_id, stream_version)\n);\nCREATE INDEX idx_stream ON events(stream_id);\nCREATE INDEX idx_type ON events(event_type);\nCREATE INDEX idx_tenant ON events(tenant_id) WHERE tenant_id IS NOT NULL;\n`\nProjections Tables (Mutable JSONB Documents):\n`sql\nCREATE TABLE projections (\n    projection_name VARCHAR(255) NOT NULL,\n    document_id VARCHAR(255) NOT NULL,\n    document JSONB NOT NULL,\n    tenant_id VARCHAR(100),\n    version BIGINT NOT NULL,\n    last_updated TIMESTAMPTZ NOT NULL,\n    PRIMARY KEY (projection_name, document_id, COALESCE(tenant_id, ''))\n);\nCREATE INDEX idx_projection_tenant ON projections(projection_name, tenant_id);\n`\nBenefits of Hybrid Approach\nEvents are immutable - Perfect audit trail, never changes\nProjections are mutable - Can be rebuilt, schema can evolve\nJSONB flexibility - No schema migrations for projection changes\nPerformance optimization - Events optimized for append, projections for queries\nIndependent scaling - Different databases/drivers for events vs projections\nProjection Management\nSchema-Free Evolution\n`csharp\n// V1 Projection\npublic class OrderSummaryProjection {\n    public Guid OrderId { get; set; }\n    public decimal Total { get; set; }\n    public OrderStatus Status { get; set; }\n}\n// V2 Projection - Add fields without migration\npublic class OrderSummaryProjection {\n    public Guid OrderId { get; set; }\n    public decimal Total { get; set; }\n    public OrderStatus Status { get; set; }\n    public DateTime EstimatedDelivery { get; set; }  // New field\n    public List<string> Tags { get; set; } = new();   // New collection\n}\n`\nNo database migration required - JSONB handles missing fields gracefully",
        "startIndex": 0,
        "preview": "Event Store & Projection Architecture\nWhizbang implements a hybrid event store and projection architecture that separates event persistence from proje..."
      },
      {
        "id": "design/event-store-projections-chunk-1",
        "text": "set; } public decimal Total { get; set; } public OrderStatus Status { get; set; } public DateTime EstimatedDelivery { get; set; } // New field public List<string> Tags { get; set; } = new(); // New collection } ` No database migration required - JSONB handles missing fields gracefully Atomic Projection Rebuilds\nWhizbang supports zero-downtime projection rebuilds using temporary table swapping:\n`csharp\nservices AddProjection<OrderSummaryProjection>(options => {\n    options RebuildStrategy = RebuildStrategy AtomicSwap;\n});\n// Rebuild process:\n// 1 Create temporary table: projections_ordersummary_temp\n// 2 Build new projection in temp table from events\n// 3 Atomic swap: RENAME projections_ordersummary TO projections_ordersummary_old,\n//                  projections_ordersummary_temp TO projections_ordersummary\n// 4 Drop old table\n`\nProjection Drivers\nProjections use driver-based storage for flexibility:\n`csharp\n// PostgreSQL JSONB Driver (default)\nservices AddWhizbang(options => {\n    options UsePostgresProjections(connectionString);\n});\n// SQL Server JSON Driver\nservices AddWhizbang(options => {\n    options UseSqlServerProjections(connectionString);\n});\n// MongoDB Driver\nservices AddWhizbang(options => {\n    options UseMongoProjections(connectionString);\n});\n// Custom Driver\nservices AddWhizbang(options => {\n    options UseProjectionDriver<MyCustomDriver>();\n});\n`\nSnapshotting\nSmart Replay with Snapshots\nWhizbang supports snapshot-assisted replays to reduce replay overhead:\n`csharp\npublic class OrderAggregate : Aggregate {\n    public Guid Id { get; private set; }\n    public decimal Total { get; private set; }\n    public List<OrderItem> Items { get; private set; } = new();\n    // Automatic snapshots every 100 events\n    [Snapshot(Every = 100)]\n    public OrderSnapshot CreateSnapshot() {\n        return new OrderSnapshot {\n            Id = Id,\n            Total = Total,\n            Items = Items ToList()\n        };\n    }\n    // Restore from snapshot\n    public void RestoreFromSnapshot(OrderSnapshot snapshot) {\n        Id = snapshot Id;\n        Total = snapshot Total;\n        Items = snapshot",
        "startIndex": 2265,
        "preview": "set; } public decimal Total { get; set; } public OrderStatus Status { get; set; } public DateTime EstimatedDelivery { get; set; } // New field public ..."
      },
      {
        "id": "design/event-store-projections-chunk-2",
        "text": "new(); // Automatic snapshots every 100 events [Snapshot(Every = 100)] public OrderSnapshot CreateSnapshot() { return new OrderSnapshot { Id = Id, Total = Total, Items = Items ToList() }; } // Restore from snapshot public void RestoreFromSnapshot(OrderSnapshot snapshot) { Id = snapshot Id; Total = snapshot Total; Items = snapshot Items;\n    }\n}\n`\nSnapshot Storage\n`sql\nCREATE TABLE snapshots (\n    stream_id VARCHAR(255) NOT NULL,\n    snapshot_version BIGINT NOT NULL,\n    snapshot_data JSONB NOT NULL,\n    tenant_id VARCHAR(100),\n    created_at TIMESTAMPTZ NOT NULL,\n    PRIMARY KEY (stream_id, snapshot_version)\n);\n`\nReplay Strategy\nWhen replaying events for projection rebuilds:\nFind closest snapshot ≤ starting event number\nRestore snapshot if available\nReplay remaining events from snapshot version to target\nNon-atomic replays only - atomic replays always start from beginning\n`csharp\n// Smart replay from event #50,000\nvar snapshot = await snapshotStore GetLatestBefore(streamId, eventNumber: 50000);\nif (snapshot = null && snapshot Version >= 49900) { // Within 100 events\n    aggregate RestoreFromSnapshot(snapshot);\n    var events = await eventStore ReadFrom(streamId, snapshot Version + 1, 50000);\n} else {\n    var events = await eventStore ReadFrom(streamId, 0, 50000);\n}\n`\nImplementation Details\nProjection Handler Registration\n`csharp\npublic class OrderSummaryProjection : IProjectionHandler<OrderPlaced>,\n                                     IProjectionHandler<OrderUpdated>,\n                                     IProjectionHandler<OrderShipped> {\n    public async Task Handle(OrderPlaced @event, ProjectionContext context) {\n        var summary = new OrderSummary {\n            OrderId = @event OrderId,\n            Total = @event Total,\n            Status = OrderStatus Placed,\n            CustomerId = @event CustomerId\n        };\n        await context Store(summary OrderId ToString(), summary);\n    }\n    public async Task Handle(OrderUpdated @event, ProjectionContext context) {\n        var summary = await context Load<OrderSummary>(@event OrderId ToString());\n        if (summary = null) {\n            summary Total = @event NewTotal;\n            summary Items = @event UpdatedItems;\n            await context Store(@event OrderId ToString(), summary);\n        }\n    }\n}\n`\nProjection Configuration\n`csharp\nservices AddProjection<OrderSummaryProjection>(projection => {\n    projection ProjectionName = \"order-summary\";\n    projection PartitionBy = order => order CustomerId; // Multi-tenant partitioning\n    projection SnapshotStrategy = SnapshotStrategy Automatic;\n    projection RebuildStrategy = RebuildStrategy",
        "startIndex": 4107,
        "preview": "new(); // Automatic snapshots every 100 events [Snapshot(Every = 100)] public OrderSnapshot CreateSnapshot() { return new OrderSnapshot { Id = Id, Tot..."
      },
      {
        "id": "design/event-store-projections-chunk-3",
        "text": "summary Total = @event NewTotal; summary Items = @event UpdatedItems; await context Store(@event OrderId ToString(), summary); } } } ` Projection Configuration `csharp services AddProjection<OrderSummaryProjection>(projection => { projection ProjectionName = \"order-summary\"; projection PartitionBy = order => order CustomerId; // Multi-tenant partitioning projection SnapshotStrategy = SnapshotStrategy Automatic; projection RebuildStrategy = RebuildStrategy AtomicSwap;\n    projection CheckpointStorage = CheckpointStorage SameDatabase;\n});\n`\nDriver Interface\n`csharp\npublic interface IProjectionDriver {\n    Task Store<T>(string projectionName, string documentId, T document, string tenantId = null);\n    Task<T > Load<T>(string projectionName, string documentId, string tenantId = null);\n    Task Delete(string projectionName, string documentId, string tenantId = null);\n    // Querying support\n    Task<IEnumerable<T>> Query<T>(string projectionName, Expression<Func<T, bool>> predicate, string tenantId = null);\n    Task<IEnumerable<T>> QueryAll<T>(string projectionName, string tenantId = null);\n    // Rebuild support\n    Task<string> CreateTemporaryProjectionTable(string projectionName);\n    Task SwapProjectionTables(string projectionName, string temporaryTableName);\n    Task DropProjectionTable(string tableName);\n}\n`\nMulti-Database Support\nEvents and Projections in Different Databases\n`csharp\nservices AddWhizbang(options => {\n    // Events in PostgreSQL\n    options UsePostgresEventStore(\"Host=events-db;Database=events\");\n    // Projections in MongoDB\n    options UseMongoProjections(\"mongodb://projections-cluster\");\n    // Or projections in separate PostgreSQL instance\n    options",
        "startIndex": 6416,
        "preview": "summary Total = @event NewTotal; summary Items = @event UpdatedItems; await context Store(@event OrderId ToString(), summary); } } } ` Projection Conf..."
      },
      {
        "id": "design/event-store-projections-chunk-4",
        "text": "null); // Rebuild support Task<string> CreateTemporaryProjectionTable(string projectionName); Task SwapProjectionTables(string projectionName, string temporaryTableName); Task DropProjectionTable(string tableName); } ` Multi-Database Support Events and Projections in Different Databases `csharp services AddWhizbang(options => { // Events in PostgreSQL options UsePostgresEventStore(\"Host=events-db;Database=events\"); // Projections in MongoDB options UseMongoProjections(\"mongodb://projections-cluster\"); // Or projections in separate PostgreSQL instance options UsePostgresProjections(\"Host=projections-db;Database=projections\");\n});\n`\nPerformance Benefits\nEvents database optimized for writes (append-only)\nProjections database optimized for reads (complex queries)\nIndependent scaling of read vs write workloads\nDifferent drivers for different use cases\nBest Practices\nProjection Design\nKeep projections focused - One projection per use case\nDenormalize for queries - Include all needed data\nUse tenant partitioning - For multi-tenant scenarios\nVersion projections - For breaking changes\nSnapshot Guidelines\nSnapshot long-lived aggregates - Orders, customers, accounts\nDon't snapshot short-lived aggregates - Shopping carts, sessions\nConsider snapshot frequency - Balance storage vs replay speed\nTest snapshot restore - Ensure snapshots work correctly\nRebuild Strategies\nUse atomic swaps for production rebuilds\nUse in-place updates for development\nMonitor rebuild progress with checkpoints\nValidate rebuilt projections before swapping\n---\nRelated Documentation\nConcurrency Control - How concurrency is managed\nMulti-Tenancy - Tenant isolation strategies\nPerformance Optimization - Scaling and tuning",
        "startIndex": 7662,
        "preview": "null); // Rebuild support Task<string> CreateTemporaryProjectionTable(string projectionName); Task SwapProjectionTables(string projectionName, string ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "design/flags-tags-system",
    "title": "Flags & Tags System",
    "category": "Architecture & Design",
    "url": "/docs/design/flags-tags-system",
    "chunks": [
      {
        "id": "design/flags-tags-system-chunk-0",
        "text": "Flags & Tags System\nWhizbang provides a sophisticated flags and tags system for message context, enabling dynamic behavior modification, cross-service debugging, and flexible routing throughout the entire message lifecycle Core Concepts\nFlags (Library-Defined)\nHardcoded enum flags provided by Whizbang for common scenarios:\n`csharp\n[Flags]\npublic enum WhizbangFlags : long {\n    None = 0,\n    // Testing & Development\n    LoadTesting = 1 << 0,           // Don't replay these events\n    DryRun = 1 << 1,                // Execute handlers but don't persist\n    Development = 1 << 2,           // Development mode behaviors\n    TraceReplay = 1 << 3,           // Replay/trace mode\n    // Debugging & Inspection\n    VerboseLogging = 1 << 4,        // Increase logging verbosity\n    VerboseOtel = 1 << 5,           // Increase OpenTelemetry verbosity\n    IgnoreTimeouts = 1 << 6,        // Bypass timeouts for debugging\n    CursorMode = 1 << 7,            // IDE cursor/scrubbing mode\n    Breakpoint = 1 << 8,            // Trigger breakpoints\n    // Security & Compliance\n    SecurityBypass = 1 << 9,        // Bypass security checks (dangerous)\n    DataScrubbing = 1 << 10,        // Scrub sensitive data\n    ComplianceMode = 1 << 11,       // Extra compliance logging\n    // Routing & Delivery\n    AlternativeRouting = 1 << 12,   // Use alternative handlers\n    PriorityDelivery = 1 << 13,     // Expedite processing\n    DelayedProcessing = 1 << 14,    // Defer processing\n    // Environment & Lifecycle\n    Production = 1 << 15,           // Production environment\n    Staging = 1 << 16,              // Staging environment\n    QA = 1 << 17,                   // QA environment\n    Migration = 1 << 18,            // Data migration context\n    // Custom ranges for user-defined flags\n    UserDefined1 = 1 << 32,\n    UserDefined2 = 1 << 33,\n    // up to 1 << 63\n}\n`\nTags (User-Defined)\nArbitrary string tags added by developers for custom scenarios:\n`csharp\npublic class MessageContext {\n    public WhizbangFlags Flags { get; set; }\n    public HashSet<string> Tags { get; set; } = new();\n    public string",
        "startIndex": 0,
        "preview": "Flags & Tags System\nWhizbang provides a sophisticated flags and tags system for message context, enabling dynamic behavior modification, cross-service..."
      },
      {
        "id": "design/flags-tags-system-chunk-1",
        "text": "1 << 32, UserDefined2 = 1 << 33, // up to 1 << 63 } ` Tags (User-Defined) Arbitrary string tags added by developers for custom scenarios: `csharp public class MessageContext { public WhizbangFlags Flags { get; set; } public HashSet<string> Tags { get; set; } = new(); public string CorrelationId { get; set; }\n    public string TenantId { get; set; }\n    public string Domain { get; set; }\n    // Fluent API for context building\n    public MessageContext WithTag(string tag) {\n        Tags Add(tag);\n        return this;\n    }\n    public MessageContext WithFlags(WhizbangFlags flags) {\n        Flags |= flags;\n        return this;\n    }\n    public MessageContext WithCorrelationId(string correlationId) {\n        CorrelationId = correlationId;\n        return this;\n    }\n    public bool HasFlag(WhizbangFlags flag) => (Flags & flag) == flag;\n    public bool HasTag(string tag) => Tags Contains(tag);\n    public bool HasAnyTag(params string[] tags) => tags Any(Tags Contains);\n    public bool HasAllTags(params string[] tags) => tags All(Tags Contains);\n}\n// Usage examples\ncontext WithTag(\"customer-priority\") WithTag(\"region-us-west\") WithTag(\"high-value-order\") WithFlags(WhizbangFlags VerboseLogging | WhizbangFlags PriorityDelivery) WithCorrelationId(\"debug-session-123\");\n`\nCross-Service Propagation\nAutomatic Flag Propagation\nFlags carry through entire message journey across service boundaries:\n`csharp\n// Service 1: Initial command with debugging flags\nvar command = new PlaceOrder(orderId, customerId, items);\nawait _mediator Send(command, context => {\n    context WithFlags(WhizbangFlags VerboseLogging | WhizbangFlags TraceReplay) WithTag(\"debug-session-123\") WithTag(\"customer-vip\");\n});\n// Flags automatically propagate to:\n// 1 Command handler execution in Service 1\n// 2 Event publishing from Service 1\n// 3 Cross-service event delivery via message broker\n// 4 Event handler execution in Service 2\n// 5 Projection updates in Service 2\n// 6 Saga execution across services\n// Service 2: Receives event with same flags and tags\npublic class InventoryHandler : IEventHandler<OrderPlaced> {\n    public async Task Handle(OrderPlaced @event, EventContext context) {\n        // context Flags contains VerboseLogging | TraceReplay\n        // context Tags contains \"debug-session-123\", \"customer-vip\"\n        if (context HasFlag(WhizbangFlags VerboseLogging)) {\n            _logger",
        "startIndex": 2113,
        "preview": "1 << 32, UserDefined2 = 1 << 33, // up to 1 << 63 } ` Tags (User-Defined) Arbitrary string tags added by developers for custom scenarios: `csharp publ..."
      },
      {
        "id": "design/flags-tags-system-chunk-2",
        "text": "2 // 6 Saga execution across services // Service 2: Receives event with same flags and tags public class InventoryHandler : IEventHandler<OrderPlaced> { public async Task Handle(OrderPlaced @event, EventContext context) { // context Flags contains VerboseLogging | TraceReplay // context Tags contains \"debug-session-123\", \"customer-vip\" if (context HasFlag(WhizbangFlags VerboseLogging)) { _logger LogInformation(\"Processing order with verbose logging enabled for debug session {DebugSession}\", \n                context Tags FirstOrDefault(t => t StartsWith(\"debug-session\")));\n        }\n        if (context HasTag(\"customer-vip\")) {\n            // Special handling for VIP customers\n            await _vipCustomerService NotifyOrderReceived(@event OrderId);\n        }\n    }\n}\n`\nMessage Context Serialization\nContext travels with messages across all transport mechanisms:\n`csharp\n// Message envelope for cross-service communication\npublic class MessageEnvelope<T> {\n    public T Message { get; set; }\n    public MessageContext Context { get; set; }\n    public Dictionary<string, string> Headers { get; set; } = new();\n    public DateTimeOffset Timestamp { get; set; } = DateTimeOffset UtcNow;\n}\n// Automatic context serialization in message brokers\npublic class KafkaMessagePublisher : IMessagePublisher {\n    public async Task PublishAsync<T>(T message, MessageContext context) {\n        var envelope = new MessageEnvelope<T> {\n            Message = message,\n            Context = context,\n            Headers = new Dictionary<string, string> {\n                [\"whizbang-flags\"] = ((long)context Flags) ToString(),\n                [\"whizbang-tags\"] = string Join(\",\", context Tags),\n                [\"whizbang-correlation-id\"] = context CorrelationId \"\",\n                [\"whizbang-tenant-id\"] = context TenantId \"\",\n                [\"whizbang-domain\"] = context Domain \"\"\n            }\n        };\n        await _kafkaProducer ProduceAsync(GetTopicName<T>(), envelope);\n    }\n}\n`\nDebugging and Development Features\nIDE Cursor/Scrubbing Mode\nInteractive debugging with state inspection:\n`csharp\n// IDE integration for step-by-step debugging\npublic class CursorModeHandler : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        if (context HasFlag(WhizbangFlags CursorMode)) {\n            // Capture pre-execution state\n            var preState = await _stateCapture CaptureStateAsync(context);\n            // Notify IDE of execution point\n            await _ideNotificationService NotifyExecutionPoint(new ExecutionPoint {\n                MessageType = typeof(TRequest) Name,\n                HandlerType = context HandlerType Name,\n                CorrelationId = context",
        "startIndex": 4282,
        "preview": "2 // 6 Saga execution across services // Service 2: Receives event with same flags and tags public class InventoryHandler : IEventHandler<OrderPlaced>..."
      },
      {
        "id": "design/flags-tags-system-chunk-3",
        "text": "async Task<TResponse> Intercept<TRequest, TResponse>( TRequest message, MessageContext context, MessageHandlerDelegate<TRequest, TResponse> next) { if (context HasFlag(WhizbangFlags CursorMode)) { // Capture pre-execution state var preState = await _stateCapture CaptureStateAsync(context); // Notify IDE of execution point await _ideNotificationService NotifyExecutionPoint(new ExecutionPoint { MessageType = typeof(TRequest) Name, HandlerType = context HandlerType Name, CorrelationId = context CorrelationId,\n                State = preState,\n                CanStepForward = true,\n                CanStepBackward = true\n            });\n            // Wait for IDE to signal continue\n            await _ideNotificationService WaitForContinueSignal(context CorrelationId);\n        }\n        var response = await next(message, context);\n        if (context HasFlag(WhizbangFlags CursorMode)) {\n            // Capture post-execution state\n            var postState = await _stateCapture CaptureStateAsync(context);\n            await _ideNotificationService NotifyExecutionComplete(new ExecutionResult {\n                CorrelationId = context CorrelationId,\n                Response = response,\n                PostState = postState,\n                ExecutionTime = context ExecutionTime\n            });\n        }\n        return response;\n    }\n}\n`\nBreakpoint System\nProgrammatic breakpoints triggered by flags:\n`csharp\npublic class BreakpointHandler : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        if (context HasFlag(WhizbangFlags Breakpoint)) {\n            var breakpointContext = new BreakpointContext {\n                BreakpointId = Guid NewGuid(),\n                MessageType = typeof(TRequest) Name,\n                Message = message,\n                Context = context,\n                StackTrace = Environment StackTrace,\n                Timestamp = DateTimeOffset UtcNow\n            };\n            // Store breakpoint information\n            await _breakpointStore StoreBreakpointAsync(breakpointContext);\n            // Notify debugging tools\n            await _debuggerNotificationService NotifyBreakpointHit(breakpointContext);\n            // Optionally pause execution for attached debuggers\n            if (_debuggerService IsAttached) {\n                System Diagnostics Debugger Break();\n            }\n        }\n        return await next(message, context);\n    }\n}\n`\nData Scrubbing and Security\nAutomatic Data Scrubbing\nPolicy-driven data sanitization based on flags:\n`csharp\npublic class DataScrubbingInterceptor : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        TRequest processedMessage = message;\n        if (context HasFlag(WhizbangFlags DataScrubbing)) {\n            // Apply data scrubbing rules\n            processedMessage = await _dataScrubber ScrubAsync(message, new ScrubOptions {\n                ScrubPersonalData = true,\n                ScrubFinancialData = true,\n                ScrubSensitiveFields = true,\n                PreserveFunctionality = true,\n                AddScrubbedMarkers = true\n            });\n            // Add scrubbing metadata to context\n            context Tags Add(\"data-scrubbed\");\n            context",
        "startIndex": 6727,
        "preview": "async Task<TResponse> Intercept<TRequest, TResponse>( TRequest message, MessageContext context, MessageHandlerDelegate<TRequest, TResponse> next) { if..."
      },
      {
        "id": "design/flags-tags-system-chunk-4",
        "text": "next) { TRequest processedMessage = message; if (context HasFlag(WhizbangFlags DataScrubbing)) { // Apply data scrubbing rules processedMessage = await _dataScrubber ScrubAsync(message, new ScrubOptions { ScrubPersonalData = true, ScrubFinancialData = true, ScrubSensitiveFields = true, PreserveFunctionality = true, AddScrubbedMarkers = true }); // Add scrubbing metadata to context context Tags Add(\"data-scrubbed\"); context Tags Add($\"scrubbed-at-{DateTimeOffset UtcNow:yyyy-MM-dd-HH-mm-ss}\");\n        }\n        return await next(processedMessage, context);\n    }\n}\n// Data scrubbing rules\npublic class OrderDataScrubber : IDataScrubber<PlaceOrder> {\n    public async Task<PlaceOrder> ScrubAsync(PlaceOrder order, ScrubOptions options) {\n        return order with {\n            // Scrub customer email\n            CustomerEmail = options ScrubPersonalData ScrubEmail(order CustomerEmail) : order CustomerEmail,\n            // Scrub payment information\n            PaymentToken = options ScrubFinancialData \"[SCRUBBED-PAYMENT-TOKEN]\" : order PaymentToken,\n            // Preserve order structure but scrub sensitive data\n            Items = order Items Select(item => item with {\n                ProductName = options PreserveFunctionality item ProductName : $\"Product-{item ProductId ToString()[ 8]}\"\n            }) ToList()\n        };\n    }\n}\n`\nProduction to QA Data Flow\nSecure data replication with automatic scrubbing:\n`csharp\n// Handler that duplicates production messages to QA with scrubbing\npublic class ProductionToQAReplicator : IEventHandler<object> {\n    public async Task Handle(object @event, EventContext context) {\n        // Only replicate events tagged for QA replication\n        if (context HasTag(\"production-data\") && \n            context HasFlag(WhizbangFlags QA)) {\n            // Create a copy with scrubbing flag\n            var qaCopy = @event;\n            var qaContext = context Copy() WithFlag(WhizbangFlags DataScrubbing) WithTag(\"qa-replicated\") WithTag($\"replicated-from-production-{DateTimeOffset UtcNow:yyyy-MM-dd}\");\n            // Remove production-specific tags\n            qaContext Tags Remove(\"production-data\");\n            qaContext Tags Remove(\"customer-vip\"); // Don't carry VIP status to QA\n            // Route to QA environment\n            await _qaEventPublisher PublishAsync(qaCopy, qaContext);\n        }\n    }\n}\n`\nPerformance and Load Testing\nLoad Testing Flag Handling\nOptimize behavior for load testing scenarios:\n`csharp\npublic class LoadTestingOptimizer : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        if (context HasFlag(WhizbangFlags LoadTesting)) {\n            // Optimize for load testing\n            using var loadTestScope = _performanceOptimizer EnterLoadTestMode();\n            // Disable slow operations\n            context Tags",
        "startIndex": 8,
        "preview": "next) { TRequest processedMessage = message; if (context HasFlag(WhizbangFlags DataScrubbing)) { // Apply data scrubbing rules processedMessage = awai..."
      },
      {
        "id": "design/flags-tags-system-chunk-5",
        "text": "Flag Handling Optimize behavior for load testing scenarios: `csharp public class LoadTestingOptimizer : IMessageInterceptor { public async Task<TResponse> Intercept<TRequest, TResponse>( TRequest message, MessageContext context, MessageHandlerDelegate<TRequest, TResponse> next) { if (context HasFlag(WhizbangFlags LoadTesting)) { // Optimize for load testing using var loadTestScope = _performanceOptimizer EnterLoadTestMode(); // Disable slow operations context Tags Add(\"skip-audit-logging\");\n            context Tags Add(\"skip-analytics-tracking\");\n            context Tags Add(\"minimal-validation\");\n            // Add load test metadata\n            context Tags Add($\"load-test-batch-{GetLoadTestBatch()}\");\n            context Tags Add($\"load-test-thread-{Thread CurrentThread ManagedThreadId}\");\n            // Execute with load test optimizations\n            return await next(message, context);\n        }\n        return await next(message, context);\n    }\n    private string GetLoadTestBatch() {\n        // Identify which load test batch this belongs to\n        return Environment GetEnvironmentVariable(\"LOAD_TEST_BATCH_ID\") \"unknown\";\n    }\n}\n`\nAdvanced Routing Scenarios\nDynamic Handler Selection\nRoute to different handlers based on flags and tags:\n`csharp\n// Handler factory that selects implementation based on context\npublic class ContextAwareHandlerFactory<T> : ICommandHandler<T> where T : ICommand {\n    private readonly IServiceProvider _serviceProvider;\n    private readonly IHandlerRoutingRules _routingRules;\n    public async Task Handle(T command, MessageContext context) {\n        var handlerType = await _routingRules DetermineHandlerType<T>(context);\n        var handler = (ICommandHandler<T>)_serviceProvider GetRequiredService(handlerType);\n        return await handler Handle(command, context);\n    }\n}\n// Routing rules based on context\npublic class HandlerRoutingRules : IHandlerRoutingRules {\n    public async Task<Type> DetermineHandlerType<T>(MessageContext context) {\n        // VIP customers get premium handler\n        if (context HasTag(\"customer-vip\")) {\n            return typeof(PremiumOrderHandler);\n        }\n        // Load testing gets optimized handler\n        if (context HasFlag(WhizbangFlags LoadTesting)) {\n            return typeof(LoadTestOptimizedOrderHandler);\n        }\n        // Migration data gets special handler\n        if (context HasFlag(WhizbangFlags Migration)) {\n            return typeof(DataMigrationOrderHandler);\n        }\n        // Default handler\n        return typeof(StandardOrderHandler);\n    }\n}\n`\nConfiguration and Management\nFlag Management\nControl flag behavior through configuration:\n`csharp\nservices AddWhizbang(options => {\n    options Flags(flags => {\n        // Environment-based flag defaults\n        if (_environment IsDevelopment()) {\n            flags DefaultFlags = WhizbangFlags Development | WhizbangFlags VerboseLogging;\n        } else if (_environment IsProduction()) {\n            flags DefaultFlags = WhizbangFlags Production;\n            flags RestrictedFlags = WhizbangFlags SecurityBypass | WhizbangFlags",
        "startIndex": 12316,
        "preview": "Flag Handling Optimize behavior for load testing scenarios: `csharp public class LoadTestingOptimizer : IMessageInterceptor { public async Task<TRespo..."
      },
      {
        "id": "design/flags-tags-system-chunk-6",
        "text": "Flag Management Control flag behavior through configuration: `csharp services AddWhizbang(options => { options Flags(flags => { // Environment-based flag defaults if (_environment IsDevelopment()) { flags DefaultFlags = WhizbangFlags Development | WhizbangFlags VerboseLogging; } else if (_environment IsProduction()) { flags DefaultFlags = WhizbangFlags Production; flags RestrictedFlags = WhizbangFlags SecurityBypass | WhizbangFlags DataScrubbing;\n        }\n        // Flag validation rules\n        flags AddValidationRule(ctx => {\n            if (ctx HasFlag(WhizbangFlags SecurityBypass) && ctx HasTag(\"authorized-security-bypass\")) {\n                throw new UnauthorizedFlagException(\"SecurityBypass flag requires authorization\");\n            }\n        });\n        // Automatic flag addition based on context\n        flags AddAutoFlag(WhizbangFlags ComplianceMode, \n            condition: ctx => ctx HasTag(\"pci-data\") || ctx HasTag(\"gdpr-data\"));\n    });\n});\n`\nTag Lifecycle Management\nManage tag propagation and cleanup:\n`csharp\npublic class TagLifecycleManager : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        // Add automatic tags\n        context Tags Add($\"processed-at-{Environment MachineName}\");\n        context Tags Add($\"handler-{typeof(TRequest) Name}\");\n        // Remove expired tags\n        var expiredTags = context Tags Where(tag => tag StartsWith(\"session-\") && IsSessionExpired(tag)) ToList();\n        foreach (var expiredTag in expiredTags) {\n            context Tags Remove(expiredTag);\n        }\n        var response = await next(message, context);\n        // Add response-based tags\n        if (response is ISuccessResult) {\n            context Tags Add(\"execution-success\");\n        } else if (response is IErrorResult error) {\n            context Tags Add($\"execution-error-{error ErrorCode}\");\n        }\n        return response;\n    }\n}\n`\nBest Practices\nFlag Usage Guidelines\nUse library flags first - Prefer built-in flags over custom tags when possible\nDocument custom flags - Make user-defined flags clear to the team\nBe conservative with propagation - Not all flags should cross service boundaries\nConsider flag lifetime - How long should flags persist in the system\nAudit flag usage - Track which flags are used and where\nTag Design Principles\nHierarchical naming - Use consistent naming conventions (e g",
        "startIndex": 14954,
        "preview": "Flag Management Control flag behavior through configuration: `csharp services AddWhizbang(options => { options Flags(flags => { // Environment-based f..."
      },
      {
        "id": "design/flags-tags-system-chunk-7",
        "text": "to the team Be conservative with propagation - Not all flags should cross service boundaries Consider flag lifetime - How long should flags persist in the system Audit flag usage - Track which flags are used and where Tag Design Principles Hierarchical naming - Use consistent naming conventions (e g , \"customer-vip\", \"region-us-west\")\nMeaningful values - Tags should be self-documenting\nAvoid high cardinality - Don't create too many unique tag combinations\nLifecycle awareness - Consider when tags should be added/removed\nSecurity sensitivity - Don't include sensitive data in tag names\nSecurity Considerations\nValidate flag sources - Ensure flags come from trusted sources\nLimit dangerous flags - SecurityBypass should be heavily restricted\nAudit flag changes - Log all flag modifications\nEncrypt sensitive tags - Some tags may contain sensitive information\nPrinciple of least privilege - Flags should grant minimal necessary permissions\n---\nRelated Documentation\nPolicy Engine - How policies use flags and tags for decision making\nObservability & Metrics - Flag-driven observability levels\nTesting & Development Tools - Testing with flags and tags",
        "startIndex": 17054,
        "preview": "to the team Be conservative with propagation - Not all flags should cross service boundaries Consider flag lifetime - How long should flags persist in..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "design/multi-tenancy",
    "title": "Multi-Tenancy",
    "category": "Architecture & Design",
    "url": "/docs/design/multi-tenancy",
    "chunks": [
      {
        "id": "design/multi-tenancy-chunk-0",
        "text": "Multi-Tenancy\nWhizbang provides comprehensive multi-tenancy support with flexible tenant isolation strategies, from single database with row-level security to complete database separation Tenant Isolation Strategies\nSingle Database with Tenant ID\nRow-level tenant isolation using tenant ID columns:\n`sql\n-- Events table with tenant isolation\nCREATE TABLE events (\n    event_id BIGSERIAL PRIMARY KEY,\n    stream_id VARCHAR(255) NOT NULL,\n    stream_version INT NOT NULL,\n    event_type VARCHAR(255) NOT NULL,\n    event_data JSONB NOT NULL,\n    metadata JSONB,\n    tenant_id UUID NOT NULL,  -- Tenant isolation\n    created_at TIMESTAMPTZ NOT NULL,\n    UNIQUE(tenant_id, stream_id, stream_version)\n);\n-- Projections table with tenant isolation\nCREATE TABLE projections (\n    projection_name VARCHAR(255) NOT NULL,\n    document_id VARCHAR(255) NOT NULL,\n    document JSONB NOT NULL,\n    tenant_id UUID NOT NULL,  -- Tenant isolation\n    version BIGINT NOT NULL,\n    last_updated TIMESTAMPTZ NOT NULL,\n    PRIMARY KEY (projection_name, document_id, tenant_id)\n);\n-- Row-level security policies\nCREATE POLICY tenant_isolation_events ON events\n    USING (tenant_id = current_setting('app current_tenant_id')::UUID);\nCREATE POLICY tenant_isolation_projections ON projections  \n    USING (tenant_id = current_setting('app current_tenant_id')::UUID);\n`\nMultiple Databases\nComplete database separation per tenant:\n`csharp\nservices AddWhizbang(options => {\n    options MultiTenancy(tenancy => {\n        tenancy Strategy = TenancyStrategy SeparateDatabases;\n        tenancy DatabaseProvider = (tenantId) => {\n            return $\"Host=db-server;Database=tenant_{tenantId};Username=app;Password=secret\";\n        };\n        // Database creation for new tenants\n        tenancy AutoCreateDatabases = true;\n        tenancy",
        "startIndex": 0,
        "preview": "Multi-Tenancy\nWhizbang provides comprehensive multi-tenancy support with flexible tenant isolation strategies, from single database with row-level sec..."
      },
      {
        "id": "design/multi-tenancy-chunk-1",
        "text": "tenant_isolation_projections ON projections USING (tenant_id = current_setting('app current_tenant_id')::UUID); ` Multiple Databases Complete database separation per tenant: `csharp services AddWhizbang(options => { options MultiTenancy(tenancy => { tenancy Strategy = TenancyStrategy SeparateDatabases; tenancy DatabaseProvider = (tenantId) => { return $\"Host=db-server;Database=tenant_{tenantId};Username=app;Password=secret\"; }; // Database creation for new tenants tenancy AutoCreateDatabases = true; tenancy DatabaseTemplate = \"tenant_template\";\n    });\n});\n`\nSame Table with Partitioning\nTable partitioning by tenant for performance:\n`sql\n-- Partitioned events table\nCREATE TABLE events (\n    event_id BIGSERIAL,\n    stream_id VARCHAR(255) NOT NULL,\n    stream_version INT NOT NULL,\n    event_type VARCHAR(255) NOT NULL,\n    event_data JSONB NOT NULL,\n    metadata JSONB,\n    tenant_id UUID NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL\n) PARTITION BY HASH (tenant_id);\n-- Create partitions\nCREATE TABLE events_p0 PARTITION OF events FOR VALUES WITH (MODULUS 4, REMAINDER 0);\nCREATE TABLE events_p1 PARTITION OF events FOR VALUES WITH (MODULUS 4, REMAINDER 1);\nCREATE TABLE events_p2 PARTITION OF events FOR VALUES WITH (MODULUS 4, REMAINDER 2);\nCREATE TABLE events_p3 PARTITION OF events FOR VALUES WITH (MODULUS 4, REMAINDER 3);\n`\nTenant ID Definition\nDefault Tenant ID Field\nStandard GUID-based tenant identification:\n`csharp\n// Default: Look for TenantId property\npublic class Order : Aggregate {\n    public Guid Id { get; private set; }\n    public Guid TenantId { get; private set; } // Automatically detected\n    public decimal Total { get; private set; }\n    public Order(Guid tenantId, Guid id) {\n        TenantId = tenantId;\n        Id = id;\n    }\n}\n// Strong-typed tenant ID\npublic record TenantId(Guid Value) : StrongTypeId<Guid>(Value);\npublic class Order : Aggregate {\n    public Guid Id { get; private set; }\n    public TenantId TenantId { get; private set; } // Strong type detected\n    public decimal Total { get; private set; }\n}\n`\nComposite Tenant ID\nMulti-field tenant identification:\n`csharp\nservices AddWhizbang(options => {\n    options MultiTenancy(tenancy => {\n        tenancy TenantIdComposition<Order>(composition => {\n            composition FromFields(order => new { \n                order",
        "startIndex": 1807,
        "preview": "tenant_isolation_projections ON projections USING (tenant_id = current_setting('app current_tenant_id')::UUID); ` Multiple Databases Complete database..."
      },
      {
        "id": "design/multi-tenancy-chunk-2",
        "text": "private set; } public TenantId TenantId { get; private set; } // Strong type detected public decimal Total { get; private set; } } ` Composite Tenant ID Multi-field tenant identification: `csharp services AddWhizbang(options => { options MultiTenancy(tenancy => { tenancy TenantIdComposition<Order>(composition => { composition FromFields(order => new { order OrganizationId, \n                order DivisionId \n            });\n        });\n        tenancy TenantIdComposition<Customer>(composition => {\n            composition FromFields(customer => customer CompanyId);\n        });\n    });\n});\n// Usage in aggregates\npublic class Order : Aggregate {\n    public Guid Id { get; private set; }\n    public Guid OrganizationId { get; private set; } // Part of tenant ID\n    public Guid DivisionId { get; private set; }     // Part of tenant ID\n    public Guid CustomerId { get; private set; }\n}\n`\nCustom Tenant Resolution\nComplex tenant identification logic:\n`csharp\nservices AddWhizbang(options => {\n    options MultiTenancy(tenancy => {\n        tenancy TenantResolver<Order>(order => {\n            // Custom logic to determine tenant\n            if (order OrganizationId == SpecialOrgId) {\n                return $\"special-{order DivisionId}\";\n            }\n            return order OrganizationId ToString();\n        });\n    });\n});\n`\nTenant Context Management\nTenant Context Propagation\n`csharp\npublic interface ITenantContext {\n    string CurrentTenantId { get; }\n    void SetTenant(string tenantId);\n    void ClearTenant();\n    bool HasTenant { get; }\n}\n// ASP NET Core middleware\npublic class TenantContextMiddleware {\n    public async Task InvokeAsync(HttpContext context, RequestDelegate next) {\n        var tenantId = ExtractTenantId(context);\n        if (tenantId = null) {\n            _tenantContext SetTenant(tenantId);\n        }\n        try {\n            await next(context);\n        } finally {\n            _tenantContext ClearTenant();\n        }\n    }\n    private string ExtractTenantId(HttpContext context) {\n        // From header\n        if (context Request Headers TryGetValue(\"X-Tenant-ID\", out var headerValue)) {\n            return headerValue;\n        }\n        // From subdomain\n        var host = context Request Host Host;\n        if (host Contains(' ')) {\n            var subdomain = host Split(' ')[0];\n            return subdomain = \"www\" subdomain : null;\n        }\n        // From route\n        if (context Request RouteValues TryGetValue(\"tenantId\", out var routeValue)) {\n            return routeValue",
        "startIndex": 3617,
        "preview": "private set; } public TenantId TenantId { get; private set; } // Strong type detected public decimal Total { get; private set; } } ` Composite Tenant ..."
      },
      {
        "id": "design/multi-tenancy-chunk-3",
        "text": "out var headerValue)) { return headerValue; } // From subdomain var host = context Request Host Host; if (host Contains(' ')) { var subdomain = host Split(' ')[0]; return subdomain = \"www\" subdomain : null; } // From route if (context Request RouteValues TryGetValue(\"tenantId\", out var routeValue)) { return routeValue ToString();\n        }\n        return null;\n    }\n}\n`\nTenant-Aware Command/Event Handling\n`csharp\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder> {\n    private readonly ITenantContext _tenantContext;\n    private readonly IOrderRepository _repository;\n    public async Task<OrderPlaced> Handle(PlaceOrder command) {\n        var tenantId = _tenantContext CurrentTenantId throw new InvalidOperationException(\"No tenant context\");\n        var order = new Order(\n            tenantId: Guid Parse(tenantId),\n            orderId: command OrderId,\n            customerId: command CustomerId,\n            items: command Items\n        );\n        await _repository Save(order);\n        return new OrderPlaced(\n            command OrderId,\n            command CustomerId,\n            DateTimeOffset UtcNow\n        ) {\n            TenantId = tenantId // Automatically added to event metadata\n        };\n    }\n}\n`\nTenant-Aware Projections\nProjection-Level Isolation\n`csharp\nservices AddProjection<OrderSummaryProjection>(options => {\n    options TenantIsolation(isolation => {\n        isolation Strategy = ProjectionTenantStrategy TenantSpecific;\n        isolation AllowCrossTenantQueries = false;\n    });\n});\npublic class OrderSummaryProjection : IProjectionHandler<OrderPlaced> {\n    public async Task Handle(OrderPlaced @event, ProjectionContext context) {\n        var tenantId = context TenantId; // Automatically extracted\n        var summary = new OrderSummary {\n            OrderId = @event OrderId,\n            TenantId = tenantId,\n            Total = @event Total\n        };\n        // Stored with tenant isolation\n        await context Store(@event OrderId ToString(), summary);\n    }\n}\n`\nCross-Tenant Projections\nGlobal projections that aggregate across tenants:\n`csharp\nservices AddProjection<GlobalAnalyticsProjection>(options => {\n    options TenantIsolation(isolation => {\n        isolation Strategy = ProjectionTenantStrategy CrossTenant;\n        isolation RequireExplicitTenantAccess = true;\n    });\n});\npublic class GlobalAnalyticsProjection : IProjectionHandler<OrderPlaced> {\n    public async Task Handle(OrderPlaced @event, ProjectionContext context) {\n        // Access to all tenant data for analytics\n        var analytics = await context LoadGlobal<GlobalAnalytics>(\"summary\");\n        analytics = new GlobalAnalytics();\n        analytics TotalOrders++;\n        analytics TotalRevenue += @event Total;\n        analytics OrdersByTenant[context TenantId] = \n            analytics OrdersByTenant GetValueOrDefault(context TenantId) + 1;\n        await context",
        "startIndex": 5795,
        "preview": "out var headerValue)) { return headerValue; } // From subdomain var host = context Request Host Host; if (host Contains(' ')) { var subdomain = host S..."
      },
      {
        "id": "design/multi-tenancy-chunk-4",
        "text": "class GlobalAnalyticsProjection : IProjectionHandler<OrderPlaced> { public async Task Handle(OrderPlaced @event, ProjectionContext context) { // Access to all tenant data for analytics var analytics = await context LoadGlobal<GlobalAnalytics>(\"summary\"); analytics = new GlobalAnalytics(); analytics TotalOrders++; analytics TotalRevenue += @event Total; analytics OrdersByTenant[context TenantId] = analytics OrdersByTenant GetValueOrDefault(context TenantId) + 1; await context StoreGlobal(\"summary\", analytics);\n    }\n}\n`\nDriver Support for Multi-Tenancy\nPostgreSQL Driver\n`csharp\npublic class PostgresTenantDriver : IEventStoreDriver {\n    public async Task<IEnumerable<Event>> ReadEvents(string streamId, string tenantId = null) {\n        var sql = tenantId = null \"SELECT * FROM events WHERE stream_id = @streamId AND tenant_id = @tenantId ORDER BY stream_version\"\n            : \"SELECT * FROM events WHERE stream_id = @streamId ORDER BY stream_version\";\n        return await _connection QueryAsync<Event>(sql, new { streamId, tenantId });\n    }\n    public async Task AppendEvents(string streamId, IEnumerable<Event> events, string tenantId = null) {\n        if (tenantId == null) {\n            throw new InvalidOperationException(\"Tenant ID required for event storage\");\n        }\n        foreach (var @event in events) {\n            @event TenantId = tenantId;\n        }\n        await _connection ExecuteAsync(\n            \"INSERT INTO events (stream_id, stream_version, event_type, event_data, tenant_id, created_at) \" +\n            \"VALUES (@StreamId, @StreamVersion, @EventType, @EventData, @TenantId, @CreatedAt)\",\n            events\n        );\n    }\n}\n`\nAbstract Driver Interface\n`csharp\npublic interface ITenantAwareDriver {\n    Task<T> Load<T>(string id, string tenantId = null);\n    Task Save<T>(T entity, string tenantId = null);\n    Task<IEnumerable<T>> Query<T>(Expression<Func<T, bool>> predicate, string tenantId = null);\n    // Cross-tenant operations (require special permissions)\n    Task<IEnumerable<T>> QueryAllTenants<T>(Expression<Func<T, bool>> predicate);\n    Task<Dictionary<string, IEnumerable<T>>> QueryByTenant<T>(Expression<Func<T, bool>> predicate);\n}\n`\nSecurity and Authorization\nTenant-Based Authorization\n`csharp\nservices AddWhizbang(options => {\n    options Authorization(auth => {\n        auth RequireTenantContext = true;\n        auth EnforceTenantIsolation = true;\n        auth AddPolicy(\"TenantAdmin\", policy => {\n            policy RequireClaim(\"tenant_id\");\n            policy RequireClaim(\"role\", \"admin\");\n        });\n        auth AddPolicy(\"CrossTenantRead\", policy => {\n            policy RequireClaim(\"permission\", \"cross_tenant_read\");\n        });\n    });\n});\n[Authorize(\"TenantAdmin\")]\npublic class OrderController : ControllerBase {\n    [HttpGet]\n    public async Task<IActionResult> GetOrders() {\n        // Automatically filtered by tenant context\n        var orders = await _orderQuery",
        "startIndex": 8392,
        "preview": "class GlobalAnalyticsProjection : IProjectionHandler<OrderPlaced> { public async Task Handle(OrderPlaced @event, ProjectionContext context) { // Acces..."
      },
      {
        "id": "design/multi-tenancy-chunk-5",
        "text": "auth EnforceTenantIsolation = true; auth AddPolicy(\"TenantAdmin\", policy => { policy RequireClaim(\"tenant_id\"); policy RequireClaim(\"role\", \"admin\"); }); auth AddPolicy(\"CrossTenantRead\", policy => { policy RequireClaim(\"permission\", \"cross_tenant_read\"); }); }); }); [Authorize(\"TenantAdmin\")] public class OrderController : ControllerBase { [HttpGet] public async Task<IActionResult> GetOrders() { // Automatically filtered by tenant context var orders = await _orderQuery GetOrdersForCurrentTenant();\n        return Ok(orders);\n    }\n    [HttpGet(\"all-tenants\")]\n    [Authorize(\"CrossTenantRead\")]\n    public async Task<IActionResult> GetOrdersAllTenants() {\n        // Requires special permission\n        var orders = await _orderQuery GetOrdersAllTenants();\n        return Ok(orders);\n    }\n}\n`\nRow-Level Security Integration\n`csharp\nservices AddWhizbang(options => {\n    options UsePostgres(connectionString, postgres => {\n        postgres EnableRowLevelSecurity = true;\n        postgres TenantContextVariable = \"app current_tenant_id\";\n    });\n});\n// Automatically sets tenant context for all database operations\npublic class PostgresTenantConnectionFactory : IDbConnectionFactory {\n    public async Task<IDbConnection> CreateConnection() {\n        var connection = new NpgsqlConnection(_connectionString);\n        await connection OpenAsync();\n        var tenantId = _tenantContext CurrentTenantId;\n        if (tenantId = null) {\n            await connection ExecuteAsync(\n                \"SET app current_tenant_id = @tenantId\", \n                new { tenantId }\n            );\n        }\n        return connection;\n    }\n}\n`\nConfiguration Examples\nComprehensive Multi-Tenancy Setup\n`csharp\nservices AddWhizbang(options => {\n    options MultiTenancy(tenancy => {\n        // Tenant identification\n        tenancy TenantIdField = \"TenantId\";\n        tenancy TenantIdType = typeof(Guid);\n        // Storage strategy\n        tenancy Strategy = TenancyStrategy SingleDatabaseWithIsolation;\n        tenancy EnableRowLevelSecurity = true;\n        // Tenant context\n        tenancy TenantResolver = (httpContext) => {\n            return httpContext Request Headers[\"X-Tenant-ID\"] FirstOrDefault();\n        };\n        // Cross-tenant operations\n        tenancy AllowCrossTenantOperations = false;\n        tenancy RequireExplicitCrossTenantPermission = true;\n        // Database partitioning\n        tenancy UsePartitioning = true;\n        tenancy PartitionCount = 16;\n        // Tenant lifecycle\n        tenancy AutoCreateTenantData = true;\n        tenancy TenantDataTemplate = \"default_tenant_template\";\n    });\n    // Tenant-aware projections\n    options Projections(projections => {\n        projections DefaultTenantStrategy = ProjectionTenantStrategy TenantSpecific;\n        projections AllowGlobalProjections = true;\n        projections RequireExplicitCrossTenantAccess = true;\n    });\n});\n`\nTenant Onboarding Workflow\n`csharp\npublic class TenantOnboardingService {\n    public async Task OnboardTenant(string tenantId, TenantConfiguration config) {\n        // Create tenant-specific database resources\n        await _tenantManager CreateTenantResources(tenantId);\n        // Initialize tenant data\n        await _tenantManager",
        "startIndex": 10876,
        "preview": "auth EnforceTenantIsolation = true; auth AddPolicy(\"TenantAdmin\", policy => { policy RequireClaim(\"tenant_id\"); policy RequireClaim(\"role\", \"admin\"); ..."
      },
      {
        "id": "design/multi-tenancy-chunk-6",
        "text": "options Projections(projections => { projections DefaultTenantStrategy = ProjectionTenantStrategy TenantSpecific; projections AllowGlobalProjections = true; projections RequireExplicitCrossTenantAccess = true; }); }); ` Tenant Onboarding Workflow `csharp public class TenantOnboardingService { public async Task OnboardTenant(string tenantId, TenantConfiguration config) { // Create tenant-specific database resources await _tenantManager CreateTenantResources(tenantId); // Initialize tenant data await _tenantManager InitializeTenantData(tenantId, config);\n        // Set up tenant-specific projections\n        await _projectionManager CreateTenantProjections(tenantId);\n        // Emit tenant onboarded event\n        await _eventPublisher PublishAsync(new TenantOnboarded(\n            tenantId,\n            config,\n            DateTimeOffset UtcNow\n        ));\n    }\n}\n`\nBest Practices\nTenant Design Guidelines\nDesign for isolation - Assume tenants can't see each other's data\nValidate tenant context - Always check tenant context in handlers\nUse consistent tenant IDs - Keep tenant identification simple\nPlan for scale - Design partitioning strategy from the start\nTest cross-tenant security - Verify isolation works correctly\nPerformance Considerations\nPartition by tenant - Use database partitioning for large tables\nIndex tenant columns - Include tenant_id in all indexes\nConnection pooling - Consider tenant-specific connection pools\nCache tenant data - Cache tenant configuration and permissions\nMonitor per-tenant usage - Track resource usage by tenant\nSecurity Best Practices\nDefense in depth - Use multiple layers of tenant isolation\nPrinciple of least privilege - Only grant necessary cross-tenant permissions\nAudit tenant access - Log all cross-tenant operations\nValidate tenant ownership - Check tenant context in all operations\nRegular security reviews - Audit tenant isolation regularly\n---\nRelated Documentation\nEvent Store & Projections - Storage architecture with tenant isolation\nDomain Ownership - How domain ownership works with tenants\nPerformance Optimization - Scaling multi-tenant systems",
        "startIndex": 13633,
        "preview": "options Projections(projections => { projections DefaultTenantStrategy = ProjectionTenantStrategy TenantSpecific; projections AllowGlobalProjections =..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "design/observability-metrics",
    "title": "Observability & Metrics",
    "category": "Architecture & Design",
    "url": "/docs/design/observability-metrics",
    "chunks": [
      {
        "id": "design/observability-metrics-chunk-0",
        "text": "Observability & Metrics\nWhizbang provides comprehensive observability with policy-driven metrics collection, OpenTelemetry integration, and custom field attributes for rich monitoring and debugging capabilities Metrics Architecture\nDefault Metrics (Always Enabled)\nCore performance and health metrics essential for operation:\n`csharp\n// Command metrics\nwhizbang_command_duration_seconds{command_type, domain, handler_type, status}\nwhizbang_command_total{command_type, domain, status}\n// Event metrics  \nwhizbang_event_published_total{event_type, domain, source_handler}\nwhizbang_event_processing_duration_seconds{event_type, handler_type, status}\n// Projection metrics\nwhizbang_projection_lag_seconds{projection_name, partition}\nwhizbang_projection_events_processed_total{projection_name, event_type}\nwhizbang_projection_errors_total{projection_name, error_type}\n// Infrastructure metrics\nwhizbang_event_store_append_duration_seconds{driver_type, operation}\nwhizbang_message_broker_publish_duration_seconds{broker_type, topic}\nwhizbang_message_broker_consume_duration_seconds{broker_type, topic}\n// System health\nwhizbang_active_handlers_total{handler_type}\nwhizbang_memory_usage_bytes{component}\nwhizbang_cpu_usage_percent{component}\n`\nObservability Levels\nConfigurable detail levels for different scenarios:\n`csharp\npublic enum ObservabilityLevel {\n    Minimal,    // Only essential metrics + errors\n    Standard,   // Default metrics + basic timing\n    Detailed,   // Additional context + custom fields  \n    Verbose,    // Everything + debug information\n    Debug       // Maximum detail for troubleshooting\n}\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        // Default observability configuration\n        policies When(ctx => true) // Matches all contexts Then(config => config SetObservabilityLevel(ObservabilityLevel Standard)) And(config => config EnableCustomFields());\n        // Environment-specific policies\n        policies When(ctx => ctx IsEnvironment(\"production\")) Then(config => config SetObservabilityLevel(ObservabilityLevel Standard)) And(config => config SetSampleRate(0 1)); // 10% sampling in production\n        policies When(ctx => ctx IsEnvironment(\"development\")) Then(config => config SetObservabilityLevel(ObservabilityLevel Verbose)) And(config => config SetSampleRate(1 0)); // Full sampling in development\n    });\n});\n`\nPolicy-Driven Observability\nContext-Aware Metrics Collection\nDynamic observability based on message context and policies:\n`csharp\nservices AddWhizbang(options => {\n    options Observability(obs => {\n        obs Policies(policies => {\n            // Verbose logging for critical customer journeys\n            policies When(ctx => ctx HasTag(\"customer-vip\")) Then(action => action SetObservabilityLevel(ObservabilityLevel Verbose)) And(action => action CaptureCustomFields()) And(action => action EnableDistributedTracing());\n            // Detailed metrics for flagged debugging sessions\n            policies When(ctx => ctx HasFlag(WhizbangFlags VerboseOtel)) Then(action => action SetObservabilityLevel(ObservabilityLevel Debug)) And(action => action CaptureMethodParameters()) And(action => action CaptureReturnValues());\n            // Minimal overhead for load testing\n            policies When(ctx => ctx HasFlag(WhizbangFlags LoadTesting)) Then(action => action SetObservabilityLevel(ObservabilityLevel Minimal))",
        "startIndex": 0,
        "preview": "Observability & Metrics\nWhizbang provides comprehensive observability with policy-driven metrics collection, OpenTelemetry integration, and custom fie..."
      },
      {
        "id": "design/observability-metrics-chunk-1",
        "text": "=> action CaptureCustomFields()) And(action => action EnableDistributedTracing()); // Detailed metrics for flagged debugging sessions policies When(ctx => ctx HasFlag(WhizbangFlags VerboseOtel)) Then(action => action SetObservabilityLevel(ObservabilityLevel Debug)) And(action => action CaptureMethodParameters()) And(action => action CaptureReturnValues()); // Minimal overhead for load testing policies When(ctx => ctx HasFlag(WhizbangFlags LoadTesting)) Then(action => action SetObservabilityLevel(ObservabilityLevel Minimal)) And(action => action DisableSlowMetrics());\n            // Enhanced monitoring for production critical paths\n            policies When(ctx => ctx HasTag(\"critical-path\") && ctx HasFlag(WhizbangFlags Production)) Then(action => action SetObservabilityLevel(ObservabilityLevel Detailed)) And(action => action EnablePerformanceBudgetTracking()) And(action => action AlertOnAnomalies());\n        });\n    });\n});\n`\nAdaptive Sampling\nSmart sampling based on context and system load:\n`csharp\npublic class AdaptiveObservabilityPolicy : IObservabilityPolicy {\n    public async Task<ObservabilityConfig> GetConfigAsync(MessageContext context) {\n        var config = new ObservabilityConfig();\n        // Always capture errors\n        if (context HasError) {\n            config Level = ObservabilityLevel Verbose;\n            config SampleRate = 1 0;\n            return config;\n        }\n        // Adaptive sampling based on system load\n        var systemLoad = await _systemMetrics GetCurrentLoadAsync();\n        if (systemLoad > 0 8) {\n            config SampleRate = 0 01; // 1% when system is under stress\n        } else if (systemLoad > 0 5) {\n            config SampleRate = 0 1;  // 10% when system is busy\n        } else {\n            config SampleRate = 0 5;  // 50% when system is idle\n        }\n        // VIP customers always get full tracking\n        if (context HasTag(\"customer-vip\")) {\n            config SampleRate = 1 0;\n            config Level = ObservabilityLevel Detailed;\n        }\n        return config;\n    }\n}\n`\nCustom Field Attributes\nSource Generation for Rich Metrics\nAutomatically include relevant fields in metrics via attributes:\n`csharp\n// Command with observability annotations\npublic record PlaceOrder(\n    Guid OrderId,\n    [ObservabilityField(MetricType Label)] \n    Guid CustomerId,    // Include as metric label\n    [ObservabilityField(MetricType Measure)] \n    decimal Total,      // Include as measured value\n    [ObservabilityField(MetricType Label, Transform = \"Range\")] \n    decimal Total2,     // Transform to range (0-100, 100-500, etc )\n    [ObservabilityField(MetricType",
        "startIndex": 2955,
        "preview": "=> action CaptureCustomFields()) And(action => action EnableDistributedTracing()); // Detailed metrics for flagged debugging sessions policies When(ct..."
      },
      {
        "id": "design/observability-metrics-chunk-2",
        "text": "fields in metrics via attributes: `csharp // Command with observability annotations public record PlaceOrder( Guid OrderId, [ObservabilityField(MetricType Label)] Guid CustomerId, // Include as metric label [ObservabilityField(MetricType Measure)] decimal Total, // Include as measured value [ObservabilityField(MetricType Label, Transform = \"Range\")] decimal Total2, // Transform to range (0-100, 100-500, etc ) [ObservabilityField(MetricType Context)]\n    string Region,      // Include in trace context only\n    List<OrderItem> Items, // Not annotated - not included\n    [SensitiveData]\n    string PaymentToken // Marked sensitive - never included\n);\n// Generated metrics include custom fields\n// whizbang_command_total{command_type=\"PlaceOrder\", customer_id=\"123\", total_range=\"100-500\", region=\"us-west\"}\n// whizbang_command_duration_seconds{command_type=\"PlaceOrder\", customer_id=\"123\", total_range=\"100-500\"}\n`\nField Transformation Options\nSmart field transformations for better cardinality management:\n`csharp\npublic enum FieldTransform {\n    None,           // Use raw value\n    Range,          // Convert numbers to ranges (0-100, 100-500, etc )\n    Hash,           // Hash sensitive identifiers\n    Truncate,       // Truncate long strings\n    Sanitize,       // Remove sensitive parts\n    Category        // Map to predefined categories\n}\n[ObservabilityField(MetricType Label, Transform = FieldTransform Range, Ranges = \"0,100,500,1000,5000\")]\npublic decimal Total { get; set; }\n[ObservabilityField(MetricType Label, Transform = FieldTransform Hash)]\npublic string CustomerId { get; set; } // Becomes hash for privacy\n[ObservabilityField(MetricType Label, Transform = FieldTransform Category, \n    Categories = \"standard,premium,enterprise\")]\npublic string CustomerTier { get; set; }\n`\nGenerated Metric Collection\nSource generator creates metric collection code:\n`csharp\n// Generated metric collection for PlaceOrder\n[GeneratedCode(\"Whizbang SourceGenerator\")]\npublic partial class PlaceOrderMetricsCollector {\n    public static void RecordCommandExecution(PlaceOrder command, CommandResult result, TimeSpan duration) {\n        var labels = new Dictionary<string, object> {\n            [\"command_type\"] = \"PlaceOrder\",\n            [\"customer_id\"] = command CustomerId ToString(),\n            [\"total_range\"] = TransformToRange(command Total, new[] { 0, 100, 500, 1000, 5000 }),\n            [\"region\"] = command Region,\n            [\"status\"] = result Success \"success\" : \"failure\"\n        };\n        _commandDurationHistogram Record(duration TotalSeconds, labels);\n        _commandTotalCounter Add(1, labels);\n        if ( result Success) {\n            _commandErrorsCounter Add(1, labels Concat(new[] {\n                new KeyValuePair<string, object>(\"error_type\", result",
        "startIndex": 5842,
        "preview": "fields in metrics via attributes: `csharp // Command with observability annotations public record PlaceOrder( Guid OrderId, [ObservabilityField(Metric..."
      },
      {
        "id": "design/observability-metrics-chunk-3",
        "text": "[\"customer_id\"] = command CustomerId ToString(), [\"total_range\"] = TransformToRange(command Total, new[] { 0, 100, 500, 1000, 5000 }), [\"region\"] = command Region, [\"status\"] = result Success \"success\" : \"failure\" }; _commandDurationHistogram Record(duration TotalSeconds, labels); _commandTotalCounter Add(1, labels); if ( result Success) { _commandErrorsCounter Add(1, labels Concat(new[] { new KeyValuePair<string, object>(\"error_type\", result ErrorType)\n            }));\n        }\n    }\n    private static string TransformToRange(decimal value, decimal[] ranges) {\n        for (int i = 0; i < ranges Length - 1; i++) {\n            if (value >= ranges[i] && value < ranges[i + 1]) {\n                return $\"{ranges[i]}-{ranges[i + 1]}\";\n            }\n        }\n        return $\"{ranges[^1]}+\";\n    }\n}\n`\nOpenTelemetry Integration\nComprehensive Instrumentation\nFull OpenTelemetry implementation with Whizbang-specific semantics:\n`csharp\nservices AddWhizbang(options => {\n    options UseOpenTelemetry(otel => {\n        otel ConfigureTracing(tracing => {\n            tracing AddWhizbangInstrumentation() AddAspNetCoreInstrumentation() AddHttpClientInstrumentation() AddEntityFrameworkCoreInstrumentation();\n            // Whizbang-specific trace attributes\n            tracing SetSampler(new WhizbangAdaptiveSampler());\n            tracing AddProcessor<WhizbangSpanProcessor>();\n        });\n        otel ConfigureMetrics(metrics => {\n            metrics AddWhizbangInstrumentation() AddRuntimeInstrumentation() AddAspNetCoreInstrumentation();\n            // Custom metric providers\n            metrics AddMeter(\"Whizbang Commands\");\n            metrics AddMeter(\"Whizbang Events\");\n            metrics AddMeter(\"Whizbang Projections\");\n        });\n        otel ConfigureLogs(logs => {\n            logs AddWhizbangInstrumentation() AddConsoleExporter() AddOpenTelemetryProtocolExporter();\n        });\n    });\n});\n`\nSemantic Conventions\nWhizbang-specific OpenTelemetry semantic conventions:\n`csharp\npublic static class WhizbangSemanticConventions {\n    // Span attributes\n    public const string CommandType = \"whizbang command type\";\n    public const string EventType = \"whizbang event type\";\n    public const string ProjectionName = \"whizbang projection name\";\n    public const string Domain = \"whizbang domain\";\n    public const string StreamId = \"whizbang stream id\";\n    public const string StreamVersion = \"whizbang stream version\";\n    public const string CorrelationId = \"whizbang correlation id\";\n    public const string TenantId = \"whizbang tenant id\";\n    // Metric attributes\n    public const string HandlerType = \"whizbang handler type\";\n    public const string DriverType = \"whizbang driver type\";\n    public const string PolicyName = \"whizbang policy name\";\n    public const string FlagValue = \"whizbang flags\";\n    // Resource attributes\n    public const string ServiceDomain = \"whizbang service domain\";\n    public const string ServiceVersion = \"whizbang service",
        "startIndex": 8186,
        "preview": "[\"customer_id\"] = command CustomerId ToString(), [\"total_range\"] = TransformToRange(command Total, new[] { 0, 100, 500, 1000, 5000 }), [\"region\"] = co..."
      },
      {
        "id": "design/observability-metrics-chunk-4",
        "text": "attributes public const string HandlerType = \"whizbang handler type\"; public const string DriverType = \"whizbang driver type\"; public const string PolicyName = \"whizbang policy name\"; public const string FlagValue = \"whizbang flags\"; // Resource attributes public const string ServiceDomain = \"whizbang service domain\"; public const string ServiceVersion = \"whizbang service version\";\n    public const string LibraryVersion = \"whizbang library version\";\n}\n// Usage in instrumentation\npublic class WhizbangCommandInstrumentation : IDisposable {\n    public Activity StartCommandActivity<T>(T command, MessageContext context) where T : ICommand {\n        var activity = Activity StartActivity($\"Command {typeof(T) Name}\");\n        activity SetTag(WhizbangSemanticConventions CommandType, typeof(T) Name);\n        activity SetTag(WhizbangSemanticConventions Domain, context Domain);\n        activity SetTag(WhizbangSemanticConventions CorrelationId, context CorrelationId);\n        if (context TenantId = null) {\n            activity SetTag(WhizbangSemanticConventions TenantId, context TenantId);\n        }\n        // Add custom fields from annotations\n        AddCustomFields(activity, command);\n        return activity;\n    }\n}\n`\nPerformance Budget Integration\nBudget-Aware Observability\nAutomatic performance budget tracking with alerts:\n`csharp\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        // Performance budgets for specific handlers\n        policies When(ctx => ctx MatchesHandler<PlaceOrderHandler>()) Then(config => config SetPerformanceBudget(new PerformanceBudget {\n                    MaxLatency = TimeSpan FromMilliseconds(100),\n                    MaxMemoryMB = 10,\n                    MaxCpuMs = 50\n                })) And(config => config OnBudgetViolation(async (violation) => {\n                    // Increase observability for budget violations\n                    await _observabilityService IncreaseDetailLevel(\n                        violation HandlerType, \n                        ObservabilityLevel Debug,\n                        duration: TimeSpan FromMinutes(10)\n                    );\n                    // Alert on violations\n                    await _alerting SendBudgetViolationAlert(violation);\n                }));\n        // Default budget tracking settings\n        policies When(ctx => true) // Matches all contexts Then(config => config EnableBudgetTracking()) And(config => config SetBudgetViolationSampleRate(1 0)); // Always capture violations\n    });\n});\n// Generated budget tracking metrics\nwhizbang_performance_budget_violation_total{handler_type, budget_type, severity}\nwhizbang_performance_budget_utilization_ratio{handler_type, budget_type}\nwhizbang_performance_budget_headroom_seconds{handler_type}\n`\nDistributed Tracing\nW3C Trace Context Propagation\nStandards-compliant distributed tracing:\n`csharp\npublic class WhizbangTraceContextPropagator : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        // Extract W3C trace context from message headers\n        var traceParent = context Headers GetValueOrDefault(\"traceparent\");\n        var traceState = context Headers GetValueOrDefault(\"tracestate\");\n        Activity",
        "startIndex": 10852,
        "preview": "attributes public const string HandlerType = \"whizbang handler type\"; public const string DriverType = \"whizbang driver type\"; public const string Pol..."
      },
      {
        "id": "design/observability-metrics-chunk-5",
        "text": "Distributed Tracing W3C Trace Context Propagation Standards-compliant distributed tracing: `csharp public class WhizbangTraceContextPropagator : IMessageInterceptor { public async Task<TResponse> Intercept<TRequest, TResponse>( TRequest message, MessageContext context, MessageHandlerDelegate<TRequest, TResponse> next) { // Extract W3C trace context from message headers var traceParent = context Headers GetValueOrDefault(\"traceparent\"); var traceState = context Headers GetValueOrDefault(\"tracestate\"); Activity activity = null;\n        if (traceParent = null) {\n            // Continue existing trace\n            var traceContext = W3CTraceContext Parse(traceParent, traceState);\n            activity = Activity StartActivity($\"Handle {typeof(TRequest) Name}\");\n            activity SetParentId(traceContext TraceId, traceContext SpanId);\n        } else {\n            // Start new trace\n            activity = Activity StartActivity($\"Handle {typeof(TRequest) Name}\");\n        }\n        // Add Whizbang-specific context\n        activity SetTag(WhizbangSemanticConventions CommandType, typeof(TRequest) Name);\n        activity SetTag(WhizbangSemanticConventions CorrelationId, context CorrelationId);\n        activity SetTag(WhizbangSemanticConventions Domain, context Domain);\n        // Enhance trace state with Whizbang context\n        var enhancedTraceState = EnhanceTraceState(traceState, context);\n        activity SetTag(\"tracestate\", enhancedTraceState);\n        try {\n            var response = await next(message, context);\n            activity SetTag(\"status\", \"success\");\n            return response;\n        } catch (Exception ex) {\n            activity SetTag(\"status\", \"error\");\n            activity SetTag(\"error type\", ex GetType() Name);\n            activity SetTag(\"error message\", ex Message);\n            throw;\n        } finally {\n            activity Dispose();\n        }\n    }\n    private string EnhanceTraceState(string existingTraceState, MessageContext context) {\n        var whizbangState = new List<string>();\n        if (context CorrelationId = null) {\n            whizbangState Add($\"correlation-id:{context CorrelationId}\");\n        }\n        if (context Domain = null) {\n            whizbangState Add($\"domain:{context Domain}\");\n        }\n        if (context Flags = WhizbangFlags None) {\n            whizbangState Add($\"flags:{(long)context Flags}\");\n        }\n        var newTraceState = $\"whizbang={string Join(\",\", whizbangState)}\";\n        return string IsNullOrEmpty(existingTraceState)",
        "startIndex": 13904,
        "preview": "Distributed Tracing W3C Trace Context Propagation Standards-compliant distributed tracing: `csharp public class WhizbangTraceContextPropagator : IMess..."
      },
      {
        "id": "design/observability-metrics-chunk-6",
        "text": "EnhanceTraceState(string existingTraceState, MessageContext context) { var whizbangState = new List<string>(); if (context CorrelationId = null) { whizbangState Add($\"correlation-id:{context CorrelationId}\"); } if (context Domain = null) { whizbangState Add($\"domain:{context Domain}\"); } if (context Flags = WhizbangFlags None) { whizbangState Add($\"flags:{(long)context Flags}\"); } var newTraceState = $\"whizbang={string Join(\",\", whizbangState)}\"; return string IsNullOrEmpty(existingTraceState) newTraceState \n            : $\"{existingTraceState},{newTraceState}\";\n    }\n}\n`\nMonitoring Dashboards\nPre-built Dashboard Configurations\nReady-to-use monitoring dashboards for popular platforms:\n`json\n// Grafana dashboard configuration\n{\n  \"dashboard\": {\n    \"title\": \"Whizbang Application Metrics\",\n    \"panels\": [\n      {\n        \"title\": \"Command Processing Rate\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(whizbang_command_total[5m])\",\n            \"legendFormat\": \"{{command_type}} ({{domain}})\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Projection Lag\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"whizbang_projection_lag_seconds\",\n            \"legendFormat\": \"{{projection_name}}\"\n          }\n        ],\n        \"thresholds\": [\n          { \"value\": 300, \"color\": \"yellow\" },\n          { \"value\": 600, \"color\": \"red\" }\n        ]\n      },\n      {\n        \"title\": \"Performance Budget Violations\",\n        \"type\": \"table\",\n        \"targets\": [\n          {\n            \"expr\": \"increase(whizbang_performance_budget_violation_total[1h])\",\n            \"format\": \"table\"\n          }\n        ]\n      }\n    ]\n  }\n}\n`\nAlert Rules\nProduction-ready alerting rules:\n`yaml\nPrometheus alerting rules\ngroups:\nname: whizbang rules\n    rules:\nalert: ProjectionLagHigh\n        expr: whizbang_projection_lag_seconds > 300\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"Projection {{ $labels projection_name }} is lagging\"\n          description: \"Projection {{ $labels projection_name }} has been lagging behind by {{ $value }} seconds for more than 5 minutes\"\nalert: CommandErrorRateHigh\n        expr: rate(whizbang_command_errors_total[5m]) / rate(whizbang_command_total[5m]) > 0 05\n        for: 2m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"High command error rate for {{ $labels command_type }}\"\n          description: \"Command {{ $labels command_type }} error rate is {{ $value | humanizePercentage }}\"\nalert: PerformanceBudgetViolation\n        expr: increase(whizbang_performance_budget_violation_total[10m]) > 5\n        for: 0m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"Performance budget violations for {{ $labels handler_type }}\"\n          description: \"Handler {{ $labels",
        "startIndex": 15949,
        "preview": "EnhanceTraceState(string existingTraceState, MessageContext context) { var whizbangState = new List<string>(); if (context CorrelationId = null) { whi..."
      },
      {
        "id": "design/observability-metrics-chunk-7",
        "text": "annotations: summary: \"High command error rate for {{ $labels command_type }}\" description: \"Command {{ $labels command_type }} error rate is {{ $value | humanizePercentage }}\" alert: PerformanceBudgetViolation expr: increase(whizbang_performance_budget_violation_total[10m]) > 5 for: 0m labels: severity: warning annotations: summary: \"Performance budget violations for {{ $labels handler_type }}\" description: \"Handler {{ $labels handler_type }} has violated its performance budget {{ $value }} times in the last 10 minutes\"\n`\nBest Practices\nMetric Design\nControl cardinality - Avoid high-cardinality labels\nUse transformations - Convert IDs to ranges or categories\nStandardize naming - Follow OpenTelemetry conventions\nInclude context - Domain, tenant, and correlation information\nMonitor overhead - Track observability performance impact\nPolicy Configuration\nStart conservative - Begin with standard observability level\nUse adaptive sampling - Reduce overhead under load\nPrioritize critical paths - Enhanced monitoring for important flows\nHandle errors specially - Always capture error scenarios\nRegular review - Adjust policies based on insights\nDashboard Organization\nLayer dashboards - Overview → Domain → Handler specific\nUse SLOs - Define and track service level objectives\nAlert on trends - Early warning indicators\nInclude business metrics - Connect technical to business impact\nRegular maintenance - Keep dashboards current and useful\n---\nRelated Documentation\nPolicy Engine - How policies drive observability\nFlags & Tags System - Cross-service context propagation\nTesting & Development Tools - Testing observability features\nDeployment & Operations - Production monitoring setup",
        "startIndex": 18348,
        "preview": "annotations: summary: \"High command error rate for {{ $labels command_type }}\" description: \"Command {{ $labels command_type }} error rate is {{ $valu..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "design/open-questions",
    "title": "Open Design Questions - RESOLVED",
    "category": "Architecture & Design",
    "url": "/docs/design/open-questions",
    "chunks": [
      {
        "id": "design/open-questions-chunk-0",
        "text": "Open Design Questions - RESOLVED ✅\nStatus: All critical and important design questions have been resolved and documented in detailed specification documents This document previously captured open questions and architectural decisions for Whizbang All questions have now been resolved and documented in comprehensive specifications 🔴 Critical Decisions - ALL RESOLVED ✅\nAll critical decisions have been resolved and documented",
        "startIndex": 0,
        "preview": "Open Design Questions - RESOLVED ✅\nStatus: All critical and important design questions have been resolved and documented in detailed specification doc..."
      },
      {
        "id": "design/open-questions-chunk-1",
        "text": "and important design questions have been resolved and documented in detailed specification documents This document previously captured open questions and architectural decisions for Whizbang All questions have now been resolved and documented in comprehensive specifications 🔴 Critical Decisions - ALL RESOLVED ✅ All critical decisions have been resolved and documented See the detailed specifications below:\nHandler Discovery Mechanism ✅ RESOLVED\nDecision: Hybrid approach (Source Generators + Explicit Registration)\nDetailed Specification: Domain Ownership\nHandler Method Signature Conventions ✅ RESOLVED\nDecision: Convention-based with Source Generator support\nDetailed Specification: Domain Ownership\nEvent Store Schema Design ✅ RESOLVED\nDecision: Hybrid approach (Separate Events and Projections with JSONB)\nDetailed Specification: Event Store & Projections\nOptimistic Concurrency Strategy ✅ RESOLVED\nDecision: Support all strategies (Expected Version, Timestamp-Based, Automatic Retry)\nDetailed Specification: Concurrency Control\nDomain Ownership Declaration ✅ RESOLVED\nDecision: Configurable precedence order (Namespace → Attributes → Configuration)\nDetailed Specification: Domain Ownership\n---\n🟡 Important Decisions - ALL RESOLVED ✅\nProjection Checkpoint Storage ✅ RESOLVED\nDecision: Support both Same Database (default) and Separate Metadata Store\nDetailed Specification: Projection Management\nSnapshot Strategy ✅ RESOLVED\nDecision: Support all strategies (Automatic, Manual, None with Automatic as default)\nDetailed Specification: Event Store & Projections\nProjection Backfilling API ✅ RESOLVED\nDecision: Support both Declarative and Imperative with System Events\nDetailed Specification: Projection Management\nSaga State Persistence ✅ RESOLVED\nDecision: Event-Sourced Sagas as primary pattern\nDetailed Specification: Event Store & Projections\n---\n🟢 Future Considerations - DOCUMENTED ✅\nAll future considerations have been documented in the new specification files:\nMulti-Tenancy Support ✅ DOCUMENTED\nComprehensive support for single/multiple databases and tenant isolation\nDetailed Specification: Multi-Tenancy\nSchema Evolution & Event Versioning ✅ DOCUMENTED\nJSONB-based evolution with upcasting and schema registry support\nDetailed Specification: Schema Evolution\nBlue/Green Projection Deployments ✅ DOCUMENTED\nDriver-level blue/green implementation with atomic table swapping\nDetailed Specification: Schema Evolution\nCross-Aggregate Transactions ✅ DOCUMENTED\nUnit of Work pattern with saga fallback for complex operations\nDetailed Specification: Advanced Features\nOutbox/Inbox Table Schema ✅ DOCUMENTED\nComprehensive outbox/inbox pattern implementation\nDetailed Specification: Event Store & Projections\nDistributed Tracing Context ✅ DOCUMENTED\nW3C trace context headers with OpenTelemetry integration\nDetailed Specification: Advanced Features\nPerformance Budgets & SLOs ✅ DOCUMENTED\nAttribute and programmatic performance budgets with OpenTelemetry\nDetailed Specification: Advanced Features\nKubernetes Operator Features ✅ DOCUMENTED\nAuto-scaling, partition-aware placement, and blue/green deployments\nDetailed Specification: Advanced Features\nDebugging & Development Tools ✅ DOCUMENTED\nOpenTelemetry journey visualization, replay, and state inspection\nDetailed Specification: Advanced Features\n---\nImplementation Status\nAll architectural questions have been resolved and documented in comprehensive specification files",
        "startIndex": 431,
        "preview": "and important design questions have been resolved and documented in detailed specification documents This document previously captured open questions ..."
      },
      {
        "id": "design/open-questions-chunk-2",
        "text": "Specification: Advanced Features Kubernetes Operator Features ✅ DOCUMENTED Auto-scaling, partition-aware placement, and blue/green deployments Detailed Specification: Advanced Features Debugging & Development Tools ✅ DOCUMENTED OpenTelemetry journey visualization, replay, and state inspection Detailed Specification: Advanced Features --- Implementation Status All architectural questions have been resolved and documented in comprehensive specification files The library design is now ready for implementation Next Steps\nReview specifications - Study the detailed documentation for each area\nCreate ADRs - Document key decisions in Architecture Decision Records\nBegin implementation - Start building based on the specifications\nValidate with prototypes - Build proof-of-concepts to validate designs\nFor Contributors\nAll major architectural decisions have been made Contributors should:\nRead the specifications before starting work\nFollow the documented patterns in implementation\nPropose changes via GitHub Discussions if specifications need updates\nFor Maintainers\nFocus on:\nImplementation planning - Break down specifications into development tasks\nPrototype validation - Build key components to validate architectural decisions\nDocumentation updates - Keep specifications current as implementation progresses\n---\nComplete Specification Suite\nCore Architecture\nEvent Store & Projections - Storage architecture and JSONB projections\nDomain Ownership - Handler discovery and ownership policies\nConcurrency Control - Multiple concurrency strategies\nAdvanced Features\nProjection Management - Checkpoints, snapshots, and backfilling\nMulti-Tenancy - Comprehensive tenant isolation strategies\nSchema Evolution - JSONB evolution and versioning\nPolicy Engine - Universal configuration scoping mechanism\nFlags & Tags System - Cross-service context propagation\nAdvanced Features - Cross-aggregate transactions, K8s operators, debugging\nImplementation & Tooling\nSource Generation & IDE Integration - Incremental generation and navigation service\nTesting & Development Tools - Comprehensive testing framework and CLI tools\nObservability & Metrics - Policy-driven monitoring and OpenTelemetry\nDeployment & Operations - Production deployment and operational patterns\nFoundation Documents\nPhilosophy - Core principles and design philosophy\nArchitecture - Overall system architecture\n---\nReady to implement",
        "startIndex": 3496,
        "preview": "Specification: Advanced Features Kubernetes Operator Features ✅ DOCUMENTED Auto-scaling, partition-aware placement, and blue/green deployments Detaile..."
      },
      {
        "id": "design/open-questions-chunk-3",
        "text": "generation and navigation service Testing & Development Tools - Comprehensive testing framework and CLI tools Observability & Metrics - Policy-driven monitoring and OpenTelemetry Deployment & Operations - Production deployment and operational patterns Foundation Documents Philosophy - Core principles and design philosophy Architecture - Overall system architecture --- Ready to implement All questions resolved, specifications complete, design decisions documented ---\n🆕 New Questions Emerging from Implementation Planning\nAs we dive deeper into the specifications, new architectural questions have emerged that need resolution:\n🔴 Critical Implementation Questions\nSource Generator Architecture ✅ RESOLVED\nDecision: Single incremental generator with pipeline architecture\nKey Requirements:\nIncremental generation - Only regenerate what changed\nIDE integration - Analyzer errors/fixes + navigation service\nMulti-project support - Aggregate generated code across project dependencies\nDebug transparency - No \"magic\", clear generated code + metadata\nBuild observability - Detailed logging and timing for optimization\nImplementation Approach:\n`csharp\n[Generator]\npublic class WhizbangSourceGenerator : IIncrementalGenerator {\n    public void Initialize(IncrementalGeneratorInitializationContext context) {\n        // Pipeline stages with timing/logging\n        var handlersPipeline = context SyntaxProvider CreateSyntaxProvider( );\n        var domainOwnershipPipeline = context SyntaxProvider CreateSyntaxProvider( );\n        var projectionsPipeline = context SyntaxProvider CreateSyntaxProvider( );\n        // Combine all sources for cross-project aggregation\n        var combinedPipeline = handlersPipeline Combine(domainOwnershipPipeline) Combine(projectionsPipeline);\n        context RegisterSourceOutput(combinedPipeline, GenerateCode);\n        context RegisterSourceOutput(combinedPipeline, GenerateMetadata); // For IDE service\n    }\n}\n// Generated metadata for IDE navigation service\npublic class WhizbangNavigationMetadata {\n    public Dictionary<string, EventStreamInfo> EventStreams { get; set; }\n    public Dictionary<string, HandlerInfo> Handlers { get; set; }\n    public Dictionary<string, ProjectionInfo> Projections { get; set; }\n    public Dictionary<string, DomainInfo> Domains { get; set; }\n}\n`\nIDE Integration Features:\nGitLens-style event stream navigation\nCommand → Handler → Events → Projections flow visualization\nAnalyzer errors for misconfigured ownership/handlers\nCode fixes for common patterns\n---\nDriver Loading & Plugin Architecture ✅ RESOLVED\nDecision: Option A - Explicit registration for simplicity and predictability\nImplementation:\n`csharp\nservices",
        "startIndex": 5432,
        "preview": "generation and navigation service Testing & Development Tools - Comprehensive testing framework and CLI tools Observability & Metrics - Policy-driven ..."
      },
      {
        "id": "design/open-questions-chunk-4",
        "text": "} } ` IDE Integration Features: GitLens-style event stream navigation Command → Handler → Events → Projections flow visualization Analyzer errors for misconfigured ownership/handlers Code fixes for common patterns --- Driver Loading & Plugin Architecture ✅ RESOLVED Decision: Option A - Explicit registration for simplicity and predictability Implementation: `csharp services AddWhizbang(options => {\n    options UseEventStoreDriver<PostgresDriver>(\"connection-string\");\n    options UseProjectionDriver<MongoDriver>(\"mongo-connection\");\n    options UseMessageBrokerDriver<KafkaDriver>(kafka => {\n        kafka BootstrapServers = \"localhost:9092\";\n        kafka EnableIdempotence = true;\n    });\n});\n`\nBenefits:\nClear, explicit dependencies\nCompile-time safety\nPredictable behavior\nEasy to reason about and debug\nWorks well with dependency injection\n---\nMessage Serialization Strategy ✅ RESOLVED\nDecision: Duck-typed serialization with System Text Json default + abstraction layer\nKey Principles:\nDecoupled microservices - No shared dependencies required\nDuck typing - Service1 EventA can deserialize to Service5 EventC if shapes match\nInterface support - Both duck-typed and pure-shared interfaces\nPure type sharing - Support shared Domain Models libraries when desired\nZero-copy optimization - When applicable through adapters\nCompression support - Through driver adapters\nImplementation Architecture:\n`csharp\n// Duck-typed serialization example\n// Service 1 publishes:\npublic record OrderPlaced(Guid OrderId, string CustomerName, decimal Total);\n// Service 5 receives as:\npublic record OrderReceived(Guid OrderId, string CustomerName, decimal Total);\n// Works automatically via duck typing\n// Interface-based approach (optional)\npublic interface IOrderEvent {\n    Guid OrderId { get; }\n    string CustomerName { get; }\n    decimal Total { get; }\n}\n// Both services can implement the interface\npublic record OrderPlaced( ) : IOrderEvent;\npublic record OrderReceived( ) : IOrderEvent;\n// Serialization configuration\nservices AddWhizbang(options => {\n    options Serialization(serialization => {\n        serialization DefaultSerializer = SystemTextJsonSerializer Default;\n        serialization EnableDuckTyping = true;\n        serialization EnableInterfaceMapping = true;\n        serialization EnableZeroCopy = true; // When supported by driver\n        // Driver-specific optimizations\n        serialization ForDriver<PostgresDriver>() UseJsonOptimizations(jsonb: true);\n        serialization ForDriver<KafkaDriver>() UseCompression(CompressionType",
        "startIndex": 7759,
        "preview": "} } ` IDE Integration Features: GitLens-style event stream navigation Command → Handler → Events → Projections flow visualization Analyzer errors for ..."
      },
      {
        "id": "design/open-questions-chunk-5",
        "text": "IOrderEvent; public record OrderReceived( ) : IOrderEvent; // Serialization configuration services AddWhizbang(options => { options Serialization(serialization => { serialization DefaultSerializer = SystemTextJsonSerializer Default; serialization EnableDuckTyping = true; serialization EnableInterfaceMapping = true; serialization EnableZeroCopy = true; // When supported by driver // Driver-specific optimizations serialization ForDriver<PostgresDriver>() UseJsonOptimizations(jsonb: true); serialization ForDriver<KafkaDriver>() UseCompression(CompressionType Gzip);\n    });\n});\n`\nDuck Typing Implementation:\n`csharp\npublic interface IMessageSerializer {\n    T Deserialize<T>(byte[] data, Type sourceType);\n    byte[] Serialize<T>(T message);\n    bool CanDuckType(Type source, Type target);\n}\npublic class DuckTypingJsonSerializer : IMessageSerializer {\n    public T Deserialize<T>(byte[] data, Type sourceType) {\n        if (typeof(T) == sourceType) {\n            return JsonSerializer Deserialize<T>(data);\n        }\n        // Duck typing: deserialize to JObject then convert\n        var json = JsonSerializer Deserialize<JsonObject>(data);\n        return json Deserialize<T>();\n    }\n}\n`\n---\nError Handling & Resilience Patterns ✅ RESOLVED\nDecision: Use Polly as the resilience framework with Whizbang-specific defaults and policies\nCore Principle: Never lose data - prefer backing up streams over discarding messages\nImplementation Strategy:\n`csharp\nservices AddWhizbang(options => {\n    options Resilience(resilience => {\n        // Default policies (can be overridden)\n        resilience DefaultRetryPolicy = Policy Handle<TransientException>() WaitAndRetryAsync(3, retryAttempt => \n                TimeSpan FromSeconds(Math Pow(2, retryAttempt)));\n        resilience DefaultCircuitBreakerPolicy = Policy Handle<Exception>() CircuitBreakerAsync(5, TimeSpan FromMinutes(1));\n        // Data integrity first - back up rather than lose\n        resilience OnMaxRetriesExceeded = (context, exception) => {\n            // Back up the stream, don't discard\n            return ResilienceAction BackupAndHold;\n        };\n        // Per-event/interface/pattern customization\n        resilience ForEvent<OrderPlaced>() UseRetryPolicy(customOrderRetryPolicy);\n        resilience ForInterface<IProjectionHandler>() UseCircuitBreaker(projectionCircuitBreaker);\n        resilience ForPattern(type => type Name EndsWith(\"Command\")) UseTimeout(TimeSpan FromSeconds(30));\n    });\n});\n`\nDefault Behaviors with Safety Warnings:\n`csharp\n// Safe defaults\npublic static class DefaultResiliencePolicies {\n    public static ResiliencePolicy SafeDefault => new() {\n        MaxRetries = 3,\n        BackoffStrategy = BackoffStrategy ExponentialWithJitter,\n        OnFailure = ResilienceAction BackupAndHold, // SAFE: Don't lose data\n        CircuitBreakerThreshold = 5,\n        CircuitBreakerDuration = TimeSpan FromMinutes(1)\n    };\n    // Dangerous overrides (with warnings)\n    [Obsolete(\"WARNING: This policy may result in data loss Use SafeDefault unless you understand the risks",
        "startIndex": 9961,
        "preview": "IOrderEvent; public record OrderReceived( ) : IOrderEvent; // Serialization configuration services AddWhizbang(options => { options Serialization(seri..."
      },
      {
        "id": "design/open-questions-chunk-6",
        "text": "static ResiliencePolicy SafeDefault => new() { MaxRetries = 3, BackoffStrategy = BackoffStrategy ExponentialWithJitter, OnFailure = ResilienceAction BackupAndHold, // SAFE: Don't lose data CircuitBreakerThreshold = 5, CircuitBreakerDuration = TimeSpan FromMinutes(1) }; // Dangerous overrides (with warnings) [Obsolete(\"WARNING: This policy may result in data loss Use SafeDefault unless you understand the risks \")]\n    public static ResiliencePolicy DangerousDiscardOnFailure => new() {\n        OnFailure = ResilienceAction Discard // DANGEROUS: May lose data\n    };\n}\n`\nCustomizable Hooks:\n`csharp\n// Global hooks\nresilience OnTransientFailure = async (context, exception) => {\n    await _logger LogWarningAsync($\"Transient failure in {context HandlerType}: {exception Message}\");\n};\nresilience OnPermanentFailure = async (context, exception) => {\n    await _alerting SendCriticalAlert($\"Permanent failure in {context HandlerType}: {exception Message}\");\n    await _deadLetterQueue SendAsync(context Message, exception);\n};\n`\n---\nConfiguration Management Strategy ✅ RESOLVED\nDecision: Hybrid approach - Options B & C (fluent + configuration) with Policy Engine integration\nImplementation Strategy:\n`csharp\n// Fluent builder for type safety and discoverability\nservices AddWhizbang(options => {\n    options UseEventStore<PostgresDriver>(\"connection-string\") UseProjections(proj => proj DefaultStrategy = SnapshotStrategy Automatic) UseDomainOwnership(dom => dom PrecedenceOrder(\"Namespace\", \"Attributes\")) UseMultiTenancy(mt => mt DefaultStrategy = TenancyStrategy SingleDatabase);\n    // Policy-driven configuration\n    options Policies(policies => {\n        policies ForEnvironment(\"Production\") LoadFromConfiguration(\"ProductionPolicies\");\n        policies ForEnvironment(\"Development\") Apply(DevelopmentPolicies Default);\n    });\n});\n// Configuration sections for environment-specific overrides\n{\n  \"Whizbang\": {\n    \"EventStore\": { \"Driver\": \"Postgres\", \"ConnectionString\": \" \" },\n    \"Projections\": { \"DefaultStrategy\": \"Automatic\" },\n    \"Policies\": {\n      \"Production\": [ ],\n      \"Development\": [ ]\n    }\n  }\n}\n`\nBenefits:\nType safety through fluent builder\nFlexibility through configuration sections\nPolicy-driven behavior for environment adaptation\nValidation at startup with clear error messages\n---\nTesting Strategy & Test Helpers ✅ RESOLVED\nDecision: Provide comprehensive testing library including suggested helpers\nImplementation:\n`csharp\n// Whizbang",
        "startIndex": 12557,
        "preview": "static ResiliencePolicy SafeDefault => new() { MaxRetries = 3, BackoffStrategy = BackoffStrategy ExponentialWithJitter, OnFailure = ResilienceAction B..."
      },
      {
        "id": "design/open-questions-chunk-7",
        "text": "], \"Development\": [ ] } } } ` Benefits: Type safety through fluent builder Flexibility through configuration sections Policy-driven behavior for environment adaptation Validation at startup with clear error messages --- Testing Strategy & Test Helpers ✅ RESOLVED Decision: Provide comprehensive testing library including suggested helpers Implementation: `csharp // Whizbang Testing package\npublic class WhizbangTestFixture {\n    public GivenEventsBuilder Given(params object[] events);\n    public WhenCommandBuilder When(ICommand command);\n    public ThenEventsBuilder Then();\n    // Projection testing\n    public ProjectionTestBuilder ForProjection<TProjection>();\n    // Policy testing\n    public PolicyTestBuilder ForPolicy(string policyName);\n}\n// Usage in tests\n[Test]\npublic async Task PlaceOrder_ShouldEmitOrderPlaced() {\n    await _fixture Given(new CustomerRegistered(customerId, \"John Doe\")) When(new PlaceOrder(orderId, customerId, items)) Then() ShouldEmitEvent<OrderPlaced>() WithProperty(e => e CustomerId, customerId);\n}\n// In-memory drivers for testing\nservices AddWhizbang(options => {\n    options UseInMemoryEventStore()  // For unit tests UseInMemoryProjections() UseInMemoryMessageBroker();\n});\n`\nFeatures:\nIn-memory drivers for fast unit testing\nGiven/When/Then fluent test API\nProjection test helpers with event feeding\nPolicy testing for complex rule validation\nIntegration test helpers with test containers\n---\nMetrics & Observability Data Model ✅ RESOLVED\nDecision: Configurable metrics with policy-driven verbosity and custom field attributes\nDefault Metrics (Always Enabled):\n`csharp\n// Core performance metrics\nwhizbang_command_duration_seconds{command_type, domain, handler_type}\nwhizbang_command_total{command_type, domain, status}\nwhizbang_event_processing_duration_seconds{event_type, handler_type}\nwhizbang_projection_lag_seconds{projection_name}\n// Infrastructure health\nwhizbang_event_store_append_duration_seconds{driver_type}\nwhizbang_message_broker_publish_duration_seconds{broker_type}\n`\nPolicy-Driven Observability:\n`csharp\nservices AddWhizbang(options => {\n    options Observability(obs => {\n        obs DefaultLevel = ObservabilityLevel Standard;\n        // Policy-based observability levels\n        obs Policies(policies => {\n            policies When(ctx => ctx HasFlag(WhizbangFlags VerboseOtel)) Then(action => action SetObservabilityLevel(ObservabilityLevel Verbose));\n            policies When(ctx => ctx HasTag(\"critical-path\")) Then(action => action EnableDetailedMetrics()) And(action => action",
        "startIndex": 14690,
        "preview": "], \"Development\": [ ] } } } ` Benefits: Type safety through fluent builder Flexibility through configuration sections Policy-driven behavior for envir..."
      },
      {
        "id": "design/open-questions-chunk-8",
        "text": "whizbang_event_store_append_duration_seconds{driver_type} whizbang_message_broker_publish_duration_seconds{broker_type} ` Policy-Driven Observability: `csharp services AddWhizbang(options => { options Observability(obs => { obs DefaultLevel = ObservabilityLevel Standard; // Policy-based observability levels obs Policies(policies => { policies When(ctx => ctx HasFlag(WhizbangFlags VerboseOtel)) Then(action => action SetObservabilityLevel(ObservabilityLevel Verbose)); policies When(ctx => ctx HasTag(\"critical-path\")) Then(action => action EnableDetailedMetrics()) And(action => action CaptureCustomFields());\n        });\n    });\n});\n`\nCustom Field Attributes for Source Generation:\n`csharp\n// Add fields to metadata via attributes\npublic record OrderPlaced(\n    Guid OrderId,\n    [ObservabilityField] Guid CustomerId,    // Include in metrics\n    [ObservabilityField] decimal Total,      // Include in metrics\n    List<OrderItem> Items\n);\n// Generated metric includes custom fields\nwhizbang_event_published_total{event_type=\"OrderPlaced\", customer_id=\"123\", total_range=\"1000-5000\"}\n`\n---\nDevelopment Experience & Tooling ✅ RESOLVED\nDecision: Comprehensive tooling suite as outlined\nPlanned Tools:\n`bash\nCLI tool (whizbang-cli)\nwhizbang new --template microservice --name OrderService\nwhizbang add projection --name OrderSummary --events OrderPlaced,OrderShipped\nwhizbang migrate --from 1 0 --to 2 0\nwhizbang dashboard --port 5000\nwhizbang replay --stream orders --from 2024-01-01\nVisual Studio integration\ndotnet new whizbang-service --name MyService\ndotnet new whizbang-projection --name OrderSummary\n`\nIDE Extensions:\nNavigation service for GitLens-style event stream traversal\nCode analyzers for ownership and pattern validation\nLive templates for commands, events, projections, sagas\nDebugging tools with state inspection and replay\nWeb Dashboard:\nReal-time projection lag monitoring\nEvent stream visualization\nPolicy rule testing and validation\nPerformance metrics and alerting\nDocumentation: Dedicated tools page and documentation section\n---\nDeployment & Operations Patterns ✅ RESOLVED\nDecision: Embedded library with comprehensive operational hooks\nDeployment Model:\nEmbedded library - Runs within developer's service\nBuilt-in health checks - Ready for Kubernetes probes\nGraceful shutdown - Message draining support NET integration - Hooks into NET hosting lifetime\nImplementation:\n`csharp\n// Built-in health checks\nservices AddWhizbang(options => {\n    options HealthChecks(health => {\n        health CheckEventStoreConnection = true;\n        health CheckProjectionLag = true;\n        health CheckMessageBrokerConnection = true;\n        health ProjectionLagThreshold = TimeSpan",
        "startIndex": 16994,
        "preview": "whizbang_event_store_append_duration_seconds{driver_type} whizbang_message_broker_publish_duration_seconds{broker_type} ` Policy-Driven Observability:..."
      },
      {
        "id": "design/open-questions-chunk-9",
        "text": "checks - Ready for Kubernetes probes Graceful shutdown - Message draining support NET integration - Hooks into NET hosting lifetime Implementation: `csharp // Built-in health checks services AddWhizbang(options => { options HealthChecks(health => { health CheckEventStoreConnection = true; health CheckProjectionLag = true; health CheckMessageBrokerConnection = true; health ProjectionLagThreshold = TimeSpan FromMinutes(5);\n    });\n});\n// Graceful shutdown integration\npublic class WhizbangHostedService : IHostedService {\n    public async Task StopAsync(CancellationToken cancellationToken) {\n        // Drain in-flight messages\n        await _messageProcessor DrainAsync(cancellationToken);\n        // Stop accepting new messages\n        await _messageSubscriptions StopAsync(cancellationToken);\n    }\n}\n`\n---\n🟢 Future Enhancement Questions\nEvent Store Scaling Patterns ✅ RESOLVED\nDecision: All suggested scaling patterns should be available as options\nScaling Options:\nSharding strategies - By tenant, aggregate type, time, or custom logic\nRead replicas - For query load distribution\nEvent archiving - Automated cold storage migration\nCross-shard projections - With aggregation support\nAdvanced Saga Patterns\nQuestion: Should Whizbang support more sophisticated saga patterns Considerations:\nSaga compensation - Automatic rollback workflows\nSaga timeouts - What happens when sagas get stuck\nNested sagas - Sagas that spawn other sagas\nSaga state queries - Query current saga states\nReal-time Features\nQuestion: How should Whizbang support real-time scenarios Considerations:\nLive projections - Real-time projection updates\nEvent streaming - WebSocket/SSE event feeds\nPush notifications - Mobile/web notifications\nLive dashboards - Real-time metrics and monitoring\n---\nDecision Process for New Questions\nPrioritize by impact - Focus on critical implementation blockers first\nPrototype when uncertain - Build spikes to validate approaches\nConsider ecosystem integration - How do decisions affect NET ecosystem fit\nBalance simplicity vs power - Don't over-engineer early decisions\nDocument decisions - Update specifications as decisions are made\nNext Steps: Review and prioritize these questions for the implementation phase",
        "startIndex": 19099,
        "preview": "checks - Ready for Kubernetes probes Graceful shutdown - Message draining support NET integration - Hooks into NET hosting lifetime Implementation: `c..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "design/policy-engine",
    "title": "Policy Engine",
    "category": "Architecture & Design",
    "url": "/docs/design/policy-engine",
    "chunks": [
      {
        "id": "design/policy-engine-chunk-0",
        "text": "Policy Engine\nWhizbang includes a sophisticated policy engine that enables flexible, rule-based configuration for routing, behavior modification, and system adaptation across the entire message lifecycle Core Architecture\nThe Policy Engine is the universal configuration scoping mechanism for Whizbang Rather than having separate configuration systems for each feature, policies provide a unified way to apply configuration based on context, conditions, and scope Every configurable aspect of Whizbang can use policies to determine when and how configuration should be applied:\nConcurrency strategies - Which concurrency approach to use based on message type/context\nObservability levels - How much detail to capture based on flags/environment\nPerformance budgets - Different performance expectations for different scenarios\nSerialization formats - Which serializer to use for different drivers/contexts\nMulti-tenancy isolation - Tenant-specific behavior and storage strategies\nDomain ownership - Dynamic ownership rules based on context\nError handling - Different resilience policies for different message types\nRouting decisions - Which handlers to use based on flags/tags\nSecurity policies - Authentication/authorization rules based on context\nPolicies can evaluate any aspect of the system state:\nMessage content - Properties, types, values within commands/events\nMessage context - Flags, tags, correlation IDs, tenant information\nSystem state - Current load, resource utilization, error rates\nEnvironment - Development, staging, production, feature flags\nUser context - Authentication, authorization, user roles\nTime-based conditions - Business hours, maintenance windows, seasons\nDomain context - Which domain owns the message, cross-domain interactions\nInfrastructure state - Database health, message broker status\nCustom conditions - Any developer-defined evaluation criteria\n> 📋 Message Context: While policies can evaluate any system aspect, the Flags & Tags System provides a convenient way to carry context through message flows Configuration Architecture Principles\nPolicy-Based vs Direct Configuration\nPolicies handle behavioral configuration that varies by context, environment, message type, or runtime conditions:\n`csharp\nservices",
        "startIndex": 0,
        "preview": "Policy Engine\nWhizbang includes a sophisticated policy engine that enables flexible, rule-based configuration for routing, behavior modification, and ..."
      },
      {
        "id": "design/policy-engine-chunk-1",
        "text": "criteria > 📋 Message Context: While policies can evaluate any system aspect, the Flags & Tags System provides a convenient way to carry context through message flows Configuration Architecture Principles Policy-Based vs Direct Configuration Policies handle behavioral configuration that varies by context, environment, message type, or runtime conditions: `csharp services AddWhizbang(options => {\n    // INFRASTRUCTURE CONFIGURATION (Direct)\n    // - Connection strings, driver selection, basic setup\n    options UseEventStoreDriver<PostgresDriver>(connectionString);\n    options UseMessageBrokerDriver<KafkaDriver>(kafkaConfig);\n    // BEHAVIORAL CONFIGURATION (Policy-Based)\n    // - Strategies, levels, rules that change based on context\n    options Policies(policies => {\n        // Environment-based behavior\n        policies When(ctx => ctx IsEnvironment(\"production\")) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy ExpectedVersion)) And(config => config SetObservabilityLevel(ObservabilityLevel Standard));\n        // Message type-based behavior\n        policies WhenMessageName(name => name Contains(\"Payment\")) Then(config => config SetStrictSecurity()) And(config => config EnableDetailedAuditing());\n        // Load/context-based behavior\n        policies When(ctx => ctx HasFlag(WhizbangFlags LoadTesting)) Then(config => config UseOptimizedForThroughput());\n    });\n});\n`\nWhen to use Policies vs Direct Configuration:\n| Configuration Type | Use Policies | Use Direct |\n|-------------------|-------------|------------|\n| Concurrency Strategies | ✅ Context-dependent | ❌ |\n| Observability Levels | ✅ Environment/load dependent | ❌ |\n| Security Policies | ✅ Message/tenant dependent | ❌ |\n| Performance Budgets | ✅ Handler/context dependent | ❌ |\n| Multi-tenancy Strategy | ✅ Tenant-type dependent | ❌ |\n| Connection Strings | ❌ | ✅ Infrastructure |\n| Driver Selection | ✅ Environment dependent | ✅ Simple cases |\n| Basic DI Registration | ❌ | ✅ Infrastructure |\nPolicy Engine Architecture\nUniversal Configuration via Policies\nAll Whizbang configuration can be scoped using policies:\n`csharp\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        // === CONCURRENCY STRATEGY POLICIES ===\n        policies When(ctx => ctx MatchesMessage<HighVolumeCommand>()) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy AutomaticRetry)) And(config => config SetMaxRetries(5));\n        policies When(ctx => ctx HasTag(\"critical-transaction\")) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy ExpectedVersion)) And(config => config SetIsolationLevel(IsolationLevel",
        "startIndex": 2253,
        "preview": "criteria > 📋 Message Context: While policies can evaluate any system aspect, the Flags & Tags System provides a convenient way to carry context throu..."
      },
      {
        "id": "design/policy-engine-chunk-2",
        "text": "Whizbang configuration can be scoped using policies: `csharp services AddWhizbang(options => { options Policies(policies => { // === CONCURRENCY STRATEGY POLICIES === policies When(ctx => ctx MatchesMessage<HighVolumeCommand>()) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy AutomaticRetry)) And(config => config SetMaxRetries(5)); policies When(ctx => ctx HasTag(\"critical-transaction\")) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy ExpectedVersion)) And(config => config SetIsolationLevel(IsolationLevel Serializable));\n        // === OBSERVABILITY POLICIES ===\n        policies When(ctx => ctx HasFlag(WhizbangFlags Production)) Then(config => config SetObservabilityLevel(ObservabilityLevel Standard)) And(config => config SetSampleRate(0 1));\n        policies When(ctx => ctx HasTag(\"customer-vip\") || ctx HasFlag(WhizbangFlags VerboseLogging)) Then(config => config SetObservabilityLevel(ObservabilityLevel Verbose)) And(config => config SetSampleRate(1 0)) And(config => config EnableCustomFields());\n        // === PERFORMANCE BUDGET POLICIES ===\n        policies WhenMessageName(name => name EndsWith(\"Command\")) Then(config => config SetPerformanceBudget(new PerformanceBudget {\n                    MaxLatency = TimeSpan FromMilliseconds(500),\n                    MaxMemoryMB = 10\n                }));\n        policies When(ctx => ctx HasTag(\"real-time\")) Then(config => config SetPerformanceBudget(new PerformanceBudget {\n                    MaxLatency = TimeSpan FromMilliseconds(50),\n                    AlertOnViolation = true\n                }));\n        // === SERIALIZATION POLICIES ===\n        policies WhenDriverType<KafkaDriver>() Then(config => config UseSerializer<AvroSerializer>()) And(config => config EnableCompression(CompressionType Gzip));\n        policies WhenDriverType<PostgresDriver>() Then(config => config UseSerializer<JsonSerializer>()) And(config => config EnableJsonbOptimizations());\n        // === MULTI-TENANCY POLICIES ===\n        policies When(ctx => ctx TenantId = null && ctx HasTag(\"enterprise-tenant\")) Then(config => config UseTenancyStrategy(TenancyStrategy SeparateDatabases)) And(config => config EnableTenantIsolation());\n        policies When(ctx => ctx TenantId = null && ctx HasTag(\"startup-tenant\")) Then(config => config UseTenancyStrategy(TenancyStrategy SingleDatabaseWithIsolation)) And(config => config EnableSharedResources());\n        // === ERROR HANDLING POLICIES ===\n        policies WhenMessageName(name => name Contains(\"Payment\")) Then(config => config UseResiliencePolicy(StrictRetryPolicy)) And(config => config SetMaxRetries(3)) And(config => config EnableCircuitBreaker());\n        policies When(ctx => ctx HasFlag(WhizbangFlags LoadTesting)) Then(config => config UseResiliencePolicy(FastFailPolicy)) And(config => config DisableRetries());\n        // === ROUTING POLICIES ===\n        policies When(ctx => ctx HasTag(\"customer-vip\")) Then(config => config RouteToHandler<PremiumOrderHandler>()) And(config => config SetPriority(MessagePriority High));\n        policies When(ctx => ctx SystemLoad > 0 8) Then(config => config RouteToHandler<LightweightOrderHandler>()) And(config => config DeferNonCriticalProcessing());\n        // === SECURITY POLICIES ===\n        policies When(ctx => ctx HasTag(\"pci-data\") || ctx HasTag(\"sensitive\")) Then(config => config RequireEncryption()) And(config => config",
        "startIndex": 4667,
        "preview": "Whizbang configuration can be scoped using policies: `csharp services AddWhizbang(options => { options Policies(policies => { // === CONCURRENCY STRAT..."
      },
      {
        "id": "design/policy-engine-chunk-3",
        "text": "policies When(ctx => ctx HasTag(\"customer-vip\")) Then(config => config RouteToHandler<PremiumOrderHandler>()) And(config => config SetPriority(MessagePriority High)); policies When(ctx => ctx SystemLoad > 0 8) Then(config => config RouteToHandler<LightweightOrderHandler>()) And(config => config DeferNonCriticalProcessing()); // === SECURITY POLICIES === policies When(ctx => ctx HasTag(\"pci-data\") || ctx HasTag(\"sensitive\")) Then(config => config RequireEncryption()) And(config => config EnableAuditLogging()) And(config => config RequireAuthorization(\"pci-access\"));\n        policies When(ctx => ctx IsEnvironment(\"production\") && ctx HasTag(\"external-api\")) Then(config => config EnableRateLimiting(100, TimeSpan FromMinutes(1))) And(config => config RequireApiKey());\n    });\n});\n`\nPolicy Combination Strategies\n`csharp\n// Venn diagram-style policy combinations\npolicies Combine(\n    // Policy A: High-priority customers\n    policies When(ctx => ctx HasTag(\"customer-vip\")),\n    // Policy B: Large orders with custom condition\n    policies When(ctx => ctx MatchesEvent<OrderPlaced>() && ctx GetEvent<OrderPlaced>() Total > 10000),\n    // Combination strategies\n    CombinationStrategy Intersection  // Both A AND B\n);\npolicies Combine(\n    policies When(ctx => ctx HasFlag(WhizbangFlags LoadTesting)),\n    policies When(ctx => ctx HasFlag(WhizbangFlags DryRun)),\n    CombinationStrategy Union        // Either A OR B\n);\npolicies Combine(\n    policies When(ctx => ctx HasTag(\"batch-import\")),\n    policies When(ctx => ctx HasFlag(WhizbangFlags Migration)),\n    CombinationStrategy Exclusion    // A XOR B (one but not both)\n);\n`\nCanned/Static Policies\n`csharp\n// Pre-defined policies for common scenarios\npublic static class WhizbangPolicies {\n    public static Policy LoadTestingPolicy => new PolicyBuilder() When(ctx => ctx HasFlag(WhizbangFlags LoadTesting)) Then(action => action SkipProjections()) And(action => action DisableSlowOperations()) And(action => action AddTag(\"load-test-ignored\")) Build();\n    public static Policy ProductionSafetyPolicy => new PolicyBuilder() When(ctx => ctx HasFlag(WhizbangFlags Production)) Then(action => action EnableDataScrubbing()) And(action => action EnforceRateLimits()) And(action => action EnableAuditLogging()) Build();\n    public static Policy DevelopmentDebuggingPolicy => new PolicyBuilder() When(ctx => ctx HasFlag(WhizbangFlags Development)) Then(action => action EnableVerboseLogging()) And(action => action EnableBreakpoints()) And(action => action DisableTimeouts()) Build();\n}\n// Apply canned policies\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        policies Apply(WhizbangPolicies LoadTestingPolicy);\n        policies Apply(WhizbangPolicies ProductionSafetyPolicy);\n        policies Apply(WhizbangPolicies DevelopmentDebuggingPolicy);\n        // Custom policies can override or extend canned policies\n        policies When(ctx => ctx HasTag(\"special-case\")) OverridePolicy(WhizbangPolicies",
        "startIndex": 7981,
        "preview": "policies When(ctx => ctx HasTag(\"customer-vip\")) Then(config => config RouteToHandler<PremiumOrderHandler>()) And(config => config SetPriority(Message..."
      },
      {
        "id": "design/policy-engine-chunk-4",
        "text": "Then(action => action EnableVerboseLogging()) And(action => action EnableBreakpoints()) And(action => action DisableTimeouts()) Build(); } // Apply canned policies services AddWhizbang(options => { options Policies(policies => { policies Apply(WhizbangPolicies LoadTestingPolicy); policies Apply(WhizbangPolicies ProductionSafetyPolicy); policies Apply(WhizbangPolicies DevelopmentDebuggingPolicy); // Custom policies can override or extend canned policies policies When(ctx => ctx HasTag(\"special-case\")) OverridePolicy(WhizbangPolicies ProductionSafetyPolicy) Then(action => action DisableDataScrubbing()); // Override for this case\n    });\n});\n`\nAdvanced Policy Scenarios\nCross-Service Flag Propagation\nFlags carry through entire message journey:\n`csharp\n// Initial command with debugging flags\nvar command = new PlaceOrder(orderId, customerId, items);\nawait _mediator Send(command, context => {\n    context WithFlags(WhizbangFlags VerboseLogging | WhizbangFlags TraceReplay) WithTag(\"debug-session-123\");\n});\n// Flags automatically propagate to:\n// 1 Command handler execution\n// 2 Event publishing\n// 3 Cross-service event delivery\n// 4 Projection updates\n// 5 Saga execution\n// Service 2 receives event with same flags\npublic class InventoryHandler : IEventHandler<OrderPlaced> {\n    public async Task Handle(OrderPlaced @event, EventContext context) {\n        // context Flags contains VerboseLogging | TraceReplay\n        // context Tags contains \"debug-session-123\"\n        if (context HasFlag(WhizbangFlags VerboseLogging)) {\n            _logger LogInformation(\"Processing order with verbose logging enabled\");\n        }\n    }\n}\n`\nData Scrubbing with Policy-Based Duplication\n`csharp\n// Production to QA data flow with scrubbing\npolicies When(ctx => ctx HasTag(\"production-data\") && ctx HasFlag(WhizbangFlags QA)) Then(action => action DuplicateMessage()) And(action => action ScrubSensitiveData()) And(action => action AddFlag(WhizbangFlags DataScrubbing)) And(action => action RouteToEnvironment(\"qa\"));\n// Handler that applies scrubbing\npublic class DataScrubbingHandler : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message, \n        MessageContext context, \n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        if (context HasFlag(WhizbangFlags DataScrubbing)) {\n            message = _dataScrubber Scrub(message);\n        }\n        return await next(message, context);\n    }\n}\n`\nDynamic Handler Routing\n`csharp\n// Route to different handlers based on flags/tags\npolicies When(ctx => ctx HasTag(\"high-value-customer\")) Then(action => action RouteToHandler<PremiumOrderHandler>()) Else(action => action RouteToHandler<StandardOrderHandler>());\npolicies When(ctx => ctx HasFlag(WhizbangFlags LoadTesting)) Then(action => action RouteToHandler<LoadTestOrderHandler>()) And(action => action",
        "startIndex": 10411,
        "preview": "Then(action => action EnableVerboseLogging()) And(action => action EnableBreakpoints()) And(action => action DisableTimeouts()) Build(); } // Apply ca..."
      },
      {
        "id": "design/policy-engine-chunk-5",
        "text": "message = _dataScrubber Scrub(message); } return await next(message, context); } } ` Dynamic Handler Routing `csharp // Route to different handlers based on flags/tags policies When(ctx => ctx HasTag(\"high-value-customer\")) Then(action => action RouteToHandler<PremiumOrderHandler>()) Else(action => action RouteToHandler<StandardOrderHandler>()); policies When(ctx => ctx HasFlag(WhizbangFlags LoadTesting)) Then(action => action RouteToHandler<LoadTestOrderHandler>()) And(action => action SkipProjections());\n// Alternative handler registration\nservices AddWhizbang(options => {\n    options RegisterHandler<PlaceOrder, StandardOrderHandler>(); // Default\n    options RegisterHandler<PlaceOrder, PremiumOrderHandler>(\n        condition: ctx => ctx Tags Contains(\"high-value-customer\"));\n    options RegisterHandler<PlaceOrder, LoadTestOrderHandler>(\n        condition: ctx => ctx Flags HasFlag(WhizbangFlags LoadTesting));\n});\n`\nIDE Debugging Support\n`csharp\n// IDE cursor/scrubbing mode\npolicies When(ctx => ctx HasFlag(WhizbangFlags CursorMode)) Then(action => action EnableStepByStepExecution()) And(action => action CaptureStateSnapshots()) And(action => action AllowTimeTravel());\n// Breakpoint support\npolicies When(ctx => ctx HasFlag(WhizbangFlags Breakpoint)) Then(action => action PauseExecution()) And(action => action NotifyIDE()) And(action => action CaptureFullContext());\n// State inspection\npublic class StateInspectionInterceptor : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        if (context HasFlag(WhizbangFlags CursorMode)) {\n            await _stateCapture CapturePreExecutionState(message, context);\n        }\n        var response = await next(message, context);\n        if (context HasFlag(WhizbangFlags CursorMode)) {\n            await _stateCapture",
        "startIndex": 13122,
        "preview": "message = _dataScrubber Scrub(message); } return await next(message, context); } } ` Dynamic Handler Routing `csharp // Route to different handlers ba..."
      },
      {
        "id": "design/policy-engine-chunk-6",
        "text": "NotifyIDE()) And(action => action CaptureFullContext()); // State inspection public class StateInspectionInterceptor : IMessageInterceptor { public async Task<TResponse> Intercept<TRequest, TResponse>( TRequest message, MessageContext context, MessageHandlerDelegate<TRequest, TResponse> next) { if (context HasFlag(WhizbangFlags CursorMode)) { await _stateCapture CapturePreExecutionState(message, context); } var response = await next(message, context); if (context HasFlag(WhizbangFlags CursorMode)) { await _stateCapture CapturePostExecutionState(response, context);\n        }\n        return response;\n    }\n}\n`\nPolicy Engine Implementation\nCore Interfaces\n`csharp\npublic interface IPolicyEngine {\n    Task<PolicyResult> EvaluateAsync<T>(T message, MessageContext context);\n    void RegisterPolicy(IPolicy policy);\n    void RegisterPolicies(IEnumerable<IPolicy> policies);\n    IPolicy CombinePolicies(IEnumerable<IPolicy> policies, CombinationStrategy strategy);\n}\npublic interface IPolicy {\n    string Name { get; }\n    int Priority { get; }\n    Task<bool> ShouldApplyAsync<T>(T message, MessageContext context);\n    Task<PolicyAction[]> GetActionsAsync<T>(T message, MessageContext context);\n}\npublic abstract class PolicyAction {\n    public abstract Task ExecuteAsync<T>(T message, MessageContext context);\n}\n// Specific policy actions\npublic class RouteToHandlerAction<THandler> : PolicyAction { }\npublic class AddFlagAction : PolicyAction { }\npublic class AddTagAction : PolicyAction { }\npublic class SkipProjectionsAction : PolicyAction { }\npublic class EnableVerboseLoggingAction : PolicyAction { }\npublic class ScrubDataAction : PolicyAction { }\n`\nTyped Policy Methods\nContext provides strongly-typed matching methods:\n`csharp\npublic class MessageContext {\n    // Core properties\n    public string CorrelationId { get; set; }\n    public WhizbangFlags Flags { get; set; }\n    public HashSet<string> Tags { get; set; }\n    public string Environment { get; set; }\n    public string TenantId { get; set; }\n    public Type MessageType { get; set; }\n    public Type AggregateType { get; set; }\n    public Type HandlerType { get; set; }\n    // Strongly-typed matching methods (for types)\n    public bool MatchesMessage<T>() => MessageType == typeof(T);\n    public bool MatchesEvent<T>() where T : IEvent => MessageType == typeof(T);\n    public bool MatchesCommand<T>() where T : ICommand => MessageType == typeof(T);\n    public bool MatchesAggregate<T>() where T : Aggregate => AggregateType == typeof(T);\n    public bool MatchesHandler<T>() => HandlerType == typeof(T);\n    public bool MatchesDriver<T>() => DriverType == typeof(T);\n    // Convenience methods\n    public bool HasFlag(WhizbangFlags flag) => Flags",
        "startIndex": 14624,
        "preview": "NotifyIDE()) And(action => action CaptureFullContext()); // State inspection public class StateInspectionInterceptor : IMessageInterceptor { public as..."
      },
      {
        "id": "design/policy-engine-chunk-7",
        "text": "IEvent => MessageType == typeof(T); public bool MatchesCommand<T>() where T : ICommand => MessageType == typeof(T); public bool MatchesAggregate<T>() where T : Aggregate => AggregateType == typeof(T); public bool MatchesHandler<T>() => HandlerType == typeof(T); public bool MatchesDriver<T>() => DriverType == typeof(T); // Convenience methods public bool HasFlag(WhizbangFlags flag) => Flags HasFlag(flag);\n    public bool HasTag(string tag) => Tags Contains(tag);\n    public bool IsEnvironment(string env) => Environment Equals(env, StringComparison OrdinalIgnoreCase);\n}\n// Simple policy builder\npublic interface IPolicyBuilder {\n    IPolicyBuilder When(Func<MessageContext, bool> condition);\n    IPolicyBuilder Then(Action<ConfigurationBuilder> action);\n    IPolicyBuilder And(Action<ConfigurationBuilder> action);\n}\n// Clean, readable policy configuration\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        // Type matching using context methods\n        policies When(ctx => ctx MatchesMessage<PlaceOrder>()) Then(config => config SetPerformanceBudget(orderBudget));\n        policies When(ctx => ctx MatchesAggregate<Order>()) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy AutomaticRetry));\n        policies When(ctx => ctx MatchesHandler<PaymentHandler>()) Then(config => config RequireEncryption());\n        // Conditional type matching with additional checks\n        policies When(ctx => ctx MatchesEvent<OrderPlaced>() && \n                             ctx GetEvent<OrderPlaced>() Total > 10000) Then(config => config EnableDetailedAuditing());\n        // Pattern matching on message names\n        policies When(ctx => ctx MessageType Name EndsWith(\"Command\")) Then(config => config SetMaxLatency(TimeSpan FromSeconds(1)));\n        // Flag and tag conditions\n        policies When(ctx => ctx HasFlag(WhizbangFlags Production)) Then(config => config SetObservabilityLevel(ObservabilityLevel Standard));\n        policies When(ctx => ctx HasTag(\"critical-path\") && ctx IsEnvironment(\"production\")) Then(config => config SetObservabilityLevel(ObservabilityLevel Detailed));\n        // Complex tenant conditions\n        policies When(ctx => ctx TenantId = null && ctx HasTag(\"enterprise\")) Then(config => config UseTenancyStrategy(TenancyStrategy SeparateDatabases));\n    });\n});\n`\nPolicy Hashing & Tracing\nEvery policy generates a deterministic hash for tracing and debugging:\n`csharp\npublic interface IPolicy {\n    string Name { get; }\n    int Priority { get; }\n    string PolicyHash { get; } // Deterministic hash of policy conditions & actions\n    Task<bool> ShouldApplyAsync<T>(T message, MessageContext context);\n    Task<PolicyAction[]> GetActionsAsync<T>(T message, MessageContext context);\n}\n// Policy hash generation\npublic class PolicyBuilder {\n    public string GeneratePolicyHash() {\n        var hashInput = new {\n            Conditions = _conditions",
        "startIndex": 16818,
        "preview": "IEvent => MessageType == typeof(T); public bool MatchesCommand<T>() where T : ICommand => MessageType == typeof(T); public bool MatchesAggregate<T>() ..."
      },
      {
        "id": "design/policy-engine-chunk-8",
        "text": "} int Priority { get; } string PolicyHash { get; } // Deterministic hash of policy conditions & actions Task<bool> ShouldApplyAsync<T>(T message, MessageContext context); Task<PolicyAction[]> GetActionsAsync<T>(T message, MessageContext context); } // Policy hash generation public class PolicyBuilder { public string GeneratePolicyHash() { var hashInput = new { Conditions = _conditions Select(c => c ToHashString()),\n            Actions = _actions Select(a => a ToHashString()),\n            Priority = _priority\n        };\n        using var sha = SHA256 Create();\n        var bytes = sha ComputeHash(Encoding UTF8 GetBytes(JsonSerializer Serialize(hashInput)));\n        return Convert ToBase64String(bytes)[ 8]; // Short hash for readability\n    }\n}\n// Context carries applied policies\npublic class MessageContext {\n    public string CorrelationId { get; set; }\n    public WhizbangFlags Flags { get; set; }\n    public HashSet<string> Tags { get; set; }\n    // Policy tracking for debugging\n    public List<AppliedPolicy> AppliedPolicies { get; set; } = new();\n    public string ActivePolicyHash { get; set; } // Currently executing policy\n    public Dictionary<string, object> PolicyDecisions { get; set; } = new();\n}\npublic class AppliedPolicy {\n    public string PolicyHash { get; set; }\n    public string PolicyName { get; set; }\n    public DateTimeOffset AppliedAt { get; set; }\n    public Dictionary<string, object> Decisions { get; set; }\n    public TimeSpan EvaluationTime { get; set; }\n}\n`\nDistributed Tracing Integration\nPolicy decisions are traced through OpenTelemetry:\n`csharp\npublic class PolicyTracingInterceptor : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        using var activity = Activity StartActivity(\"PolicyEvaluation\");\n        // Evaluate applicable policies\n        var policies = await _policyEngine EvaluateAsync(message, context);\n        foreach (var policy in policies) {\n            // Add policy hash to trace\n            activity SetTag(\"whizbang policy hash\", policy PolicyHash);\n            activity SetTag(\"whizbang policy name\", policy Name);\n            // Track in context for debugging\n            context AppliedPolicies Add(new AppliedPolicy {\n                PolicyHash = policy PolicyHash,\n                PolicyName = policy Name,\n                AppliedAt = DateTimeOffset UtcNow,\n                Decisions = policy",
        "startIndex": 19475,
        "preview": "} int Priority { get; } string PolicyHash { get; } // Deterministic hash of policy conditions & actions Task<bool> ShouldApplyAsync<T>(T message, Mess..."
      },
      {
        "id": "design/policy-engine-chunk-9",
        "text": "foreach (var policy in policies) { // Add policy hash to trace activity SetTag(\"whizbang policy hash\", policy PolicyHash); activity SetTag(\"whizbang policy name\", policy Name); // Track in context for debugging context AppliedPolicies Add(new AppliedPolicy { PolicyHash = policy PolicyHash, PolicyName = policy Name, AppliedAt = DateTimeOffset UtcNow, Decisions = policy GetDecisions()\n            });\n        }\n        // Include policy hashes in trace state\n        var traceState = $\"policies={string Join(',', policies Select(p => p PolicyHash))}\";\n        activity SetTag(\"tracestate\", traceState);\n        return await next(message, context);\n    }\n}\n// Policy decisions visible in traces\n// Trace: PlaceOrder -> OrderHandler\n//   Tags:\n//     whizbang policy hash: \"Ab3d9F2x\"\n//     whizbang policy name: \"HighValueOrderPolicy\"\n//     whizbang decisions: { \"concurrency\": \"ExpectedVersion\", \"observability\": \"Verbose\" }\n`\nIDE Integration via Source Generation\nSource generator creates policy metadata for IDE tooling:\n`csharp\n// Generated policy metadata for IDE navigation\n[GeneratedCode(\"Whizbang SourceGenerator\")]\npublic static class PolicyMetadata {\n    // Map of types to affecting policies\n    public static readonly Dictionary<Type, List<PolicyInfo>> TypePolicies = new() {\n        [typeof(Order)] = new List<PolicyInfo> {\n            new(\"Ab3d9F2x\", \"OrderConcurrencyPolicy\", PolicyEffect ConcurrencyStrategy),\n            new(\"Cd5e8G3y\", \"OrderObservabilityPolicy\", PolicyEffect ObservabilityLevel),\n            new(\"Ef7h2K4z\", \"OrderPerformanceBudget\", PolicyEffect PerformanceBudget)\n        },\n        [typeof(OrderPlaced)] = new List<PolicyInfo> {\n            new(\"Gh9j4M5a\", \"EventRoutingPolicy\", PolicyEffect Routing),\n            new(\"Ij2k6N7b\", \"EventSerializationPolicy\", PolicyEffect Serialization)\n        },\n        [typeof(OrderSummaryProjection)] = new List<PolicyInfo> {\n            new(\"Kl4m8P9c\", \"ProjectionLagPolicy\", PolicyEffect Performance),\n            new(\"Mn6o2Q1d\", \"ProjectionPartitioningPolicy\", PolicyEffect Partitioning)\n        }\n    };\n    // Reverse mapping for \"what does this policy affect \"\n    public static readonly Dictionary<string, List<AffectedType>> PolicyEffects = new() {\n        [\"Ab3d9F2x\"] = new List<AffectedType> {\n            new(typeof(Order), \"Aggregate\", \"Sets concurrency to ExpectedVersion\"),\n            new(typeof(PlaceOrder), \"Command\", \"Inherits aggregate concurrency\"),\n            new(typeof(UpdateOrder), \"Command\", \"Inherits aggregate concurrency\")\n        }\n    };\n    // Policy evaluation paths for debugging\n    public static readonly Dictionary<string, PolicyEvaluationPath> PolicyPaths = new() {\n        [\"Ab3d9F2x\"] = new PolicyEvaluationPath {\n            Conditions = new[] { \"AggregateType == Order\" },\n            Actions = new[] { \"SetConcurrencyStrategy(ExpectedVersion)\" },\n            Priority = 100,\n            Source = \"OrderConcurrencyPolicy",
        "startIndex": 21618,
        "preview": "foreach (var policy in policies) { // Add policy hash to trace activity SetTag(\"whizbang policy hash\", policy PolicyHash); activity SetTag(\"whizbang p..."
      },
      {
        "id": "design/policy-engine-chunk-10",
        "text": "\"Inherits aggregate concurrency\"), new(typeof(UpdateOrder), \"Command\", \"Inherits aggregate concurrency\") } }; // Policy evaluation paths for debugging public static readonly Dictionary<string, PolicyEvaluationPath> PolicyPaths = new() { [\"Ab3d9F2x\"] = new PolicyEvaluationPath { Conditions = new[] { \"AggregateType == Order\" }, Actions = new[] { \"SetConcurrencyStrategy(ExpectedVersion)\" }, Priority = 100, Source = \"OrderConcurrencyPolicy cs:line 15\"\n        }\n    };\n}\n`\nGitLens-Style IDE Experience\nVisual Studio/Rider extension shows policy effects inline:\n`csharp\n// OrderAggregate cs\npublic class Order : Aggregate { // 📋 3 policies affect this aggregate [hover for details]\n    // PolicyLens: Ab3d9F2x (Concurrency: ExpectedVersion)\n    // PolicyLens: Cd5e8G3y (Observability: Verbose for orders > $1000)  \n    // PolicyLens: Ef7h2K4z (Performance Budget: 100ms max latency)\n    public void PlaceOrder(CustomerId customerId, List<OrderItem> items) {\n        // PolicyLens: This method triggers policies Ab3d9F2x, Gh9j4M5a\n        Apply(new OrderPlaced( ));\n    }\n}\n// OrderSummaryProjection cs  \npublic class OrderSummaryProjection { // 📋 2 policies affect this projection\n    // PolicyLens: Kl4m8P9c (Max lag: 5 minutes before alert)\n    // PolicyLens: Mn6o2Q1d (Partitioned by CustomerId)\n    public void Handle(OrderPlaced @event) { // PolicyLens: Routed by policy Gh9j4M5a\n        // Update projection }\n}\n`\nPolicy Debugging Commands\nIDE commands for policy investigation:\n`csharp\n// Right-click on any type/method in IDE:\n// > Whizbang: Show Affecting Policies\n// > Whizbang: Trace Policy Evaluation  \n// > Whizbang: Simulate Policy Changes\n// > Whizbang: Show Policy History (git blame for policies)\n// Command palette:\n// > Whizbang: What policies affect Order aggregate // > Whizbang: What does policy Ab3d9F2x affect // > Whizbang: Show policy evaluation for PlaceOrder command\n// > Whizbang: Compare policies between environments\n`\nRuntime Policy Debugging\nAccess policy decisions at runtime:\n`csharp\npublic class PolicyDebugMiddleware {\n    public async Task InvokeAsync(HttpContext context, RequestDelegate next) {\n        // Inject policy debug header\n        context Response OnStarting(() => {\n            var messageContext = context GetMessageContext();\n            if (messageContext AppliedPolicies",
        "startIndex": 24189,
        "preview": "\"Inherits aggregate concurrency\"), new(typeof(UpdateOrder), \"Command\", \"Inherits aggregate concurrency\") } }; // Policy evaluation paths for debugging..."
      },
      {
        "id": "design/policy-engine-chunk-11",
        "text": "for PlaceOrder command // > Whizbang: Compare policies between environments ` Runtime Policy Debugging Access policy decisions at runtime: `csharp public class PolicyDebugMiddleware { public async Task InvokeAsync(HttpContext context, RequestDelegate next) { // Inject policy debug header context Response OnStarting(() => { var messageContext = context GetMessageContext(); if (messageContext AppliedPolicies Any() == true) {\n                var policyHashes = string Join(\",\", \n                    messageContext AppliedPolicies Select(p => p PolicyHash));\n                context Response Headers[\"X-Whizbang-Policies\"] = policyHashes;\n                // Debug mode: include full policy decisions\n                if (context Request Headers ContainsKey(\"X-Debug-Policies\")) {\n                    context Response Headers[\"X-Whizbang-Policy-Decisions\"] = \n                        JsonSerializer Serialize(messageContext PolicyDecisions);\n                }\n            }\n            return Task CompletedTask;\n        });\n        await next(context);\n    }\n}\n// HTTP Response Headers:\n// X-Whizbang-Policies: Ab3d9F2x,Cd5e8G3y,Ef7h2K4z\n// X-Whizbang-Policy-Decisions: {\"concurrency\":\"ExpectedVersion\",\"observability\":\"Verbose\"}\n`\nPolicy Evaluation Pipeline\n`csharp\npublic class PolicyEvaluationPipeline : IMessageInterceptor {\n    private readonly IPolicyEngine _policyEngine;\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        // Evaluate policies before handler execution\n        var policyResult = await _policyEngine EvaluateAsync(message, context);\n        // Apply pre-execution actions\n        foreach (var action in policyResult PreExecutionActions) {\n            await action ExecuteAsync(message, context);\n        }\n        // Execute handler (might be changed by policy)\n        var response = await next(message, context);\n        // Apply post-execution actions\n        foreach (var action in policyResult PostExecutionActions) {\n            await action ExecuteAsync(response, context);\n        }\n        return response;\n    }\n}\n`\nConfiguration Integration\n`csharp\n// Environment-based policy loading\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        // Load environment-specific policies\n        if (_environment IsProduction()) {\n            policies LoadFromConfiguration(\"Production\");\n            policies Apply(WhizbangPolicies ProductionSafetyPolicy);\n        } else if (_environment IsDevelopment()) {\n            policies LoadFromConfiguration(\"Development\");\n            policies Apply(WhizbangPolicies DevelopmentDebuggingPolicy);\n        }\n        // Load custom policies from configuration\n        policies LoadFromSection(\"CustomPolicies\");\n        // Team-specific canned policies\n        policies Apply(TeamPolicies DataTeamStandardPolicies);\n        policies Apply(TeamPolicies",
        "startIndex": 26089,
        "preview": "for PlaceOrder command // > Whizbang: Compare policies between environments ` Runtime Policy Debugging Access policy decisions at runtime: `csharp pub..."
      },
      {
        "id": "design/policy-engine-chunk-12",
        "text": "services AddWhizbang(options => { options Policies(policies => { // Load environment-specific policies if (_environment IsProduction()) { policies LoadFromConfiguration(\"Production\"); policies Apply(WhizbangPolicies ProductionSafetyPolicy); } else if (_environment IsDevelopment()) { policies LoadFromConfiguration(\"Development\"); policies Apply(WhizbangPolicies DevelopmentDebuggingPolicy); } // Load custom policies from configuration policies LoadFromSection(\"CustomPolicies\"); // Team-specific canned policies policies Apply(TeamPolicies DataTeamStandardPolicies); policies Apply(TeamPolicies SecurityTeamCompliancePolicies);\n    });\n});\n// Configuration example\n{\n  \"Whizbang\": {\n    \"Policies\": {\n      \"Production\": [\n        {\n          \"Name\": \"ProductionDataScrubbing\",\n          \"Condition\": \"HasFlag('Production') && HasTag('sensitive-data')\",\n          \"Actions\": [\n            { \"Type\": \"ScrubData\", \"Fields\": [\"SSN\", \"CreditCard\"] },\n            { \"Type\": \"AddTag\", \"Value\": \"scrubbed\" }\n          ]\n        }\n      ]\n    }\n  }\n}\n`\nBest Practices\nPolicy Design Guidelines\nKeep policies focused - One policy per concern\nUse clear naming - Policy names should describe their purpose\nDocument side effects - Policies can change behavior significantly\nTest policy interactions - Multiple policies can interact unexpectedly\nMonitor policy performance - Complex policies can impact performance\nFlag Usage Guidelines\nUse library flags first - Prefer built-in flags over custom tags\nDocument custom flags - Make user-defined flags clear to the team\nBe conservative with propagation - Not all flags should cross service boundaries\nConsider flag lifetime - How long should flags persist in the system\nAudit flag usage - Track which flags are used and where\nSecurity Considerations\nValidate flag sources - Ensure flags come from trusted sources\nLimit dangerous flags - SecurityBypass should be heavily restricted\nAudit policy changes - Log all policy modifications\nEncrypt sensitive tags - Some tags may contain sensitive information\nPrinciple of least privilege - Policies should grant minimal necessary permissions\n---\nRelated Documentation\nEvent Store & Projections - How policies affect storage and projections\nDomain Ownership - Policy-based routing and ownership\nAdvanced Features - Debugging and development tools integration",
        "startIndex": 28658,
        "preview": "services AddWhizbang(options => { options Policies(policies => { // Load environment-specific policies if (_environment IsProduction()) { policies Loa..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "design/projection-management",
    "title": "Projection Management",
    "category": "Architecture & Design",
    "url": "/docs/design/projection-management",
    "chunks": [
      {
        "id": "design/projection-management-chunk-0",
        "text": "Projection Management\nWhizbang provides comprehensive projection management including checkpoints, backfilling strategies, system events for on-demand rebuilds, and flexible storage options Checkpoint Storage\nProjections track their progress through checkpoint storage, supporting multiple strategies:\nA Same Database (Default)\nTransactional consistency - checkpoints and projections updated together:\n`csharp\nservices AddProjection<OrderSummaryProjection>(options => {\n    options CheckpointStorage = CheckpointStorage SameDatabase;\n});\n// Implementation: Single transaction\nawait using var transaction = await database BeginTransactionAsync();\nawait projectionStore UpdateProjection(orderSummary, transaction);\nawait checkpointStore SaveCheckpoint(position, transaction);\nawait transaction CommitAsync();\n`\nBenefits:\n✅ Exactly-once processing guarantee\n✅ Simple consistency model\n✅ No external dependencies\nDrawbacks:\n❌ Tight coupling to projection database\n❌ Limited to single database systems\nB Separate Metadata Store\nFlexible checkpoint storage separate from projection data:\n`csharp\nservices AddProjection<OrderSummaryProjection>(options => {\n    options CheckpointStorage = CheckpointStorage Separate;\n    options CheckpointStore = CheckpointStore Redis; // or CosmosDB, DynamoDB\n});\n// Implementation: Two-phase with compensation\ntry {\n    await projectionStore UpdateProjection(orderSummary);\n    await checkpointStore SaveCheckpoint(position);\n} catch {\n    // Compensation: projection will be updated again on replay\n    // Idempotent handlers ensure correctness\n}\n`\nBenefits:\n✅ Optimized checkpoint storage (Redis, DynamoDB)\n✅ Cross-database projections supported\n✅ Better performance for high-throughput scenarios\nDrawbacks:\n❌ Eventually consistent\n❌ Requires idempotent projection handlers\nCheckpoint Configuration\n`csharp\nservices AddWhizbang(options => {\n    options Projections(projections => {\n        // Global checkpoint settings\n        projections DefaultCheckpointStorage = CheckpointStorage SameDatabase;\n        projections CheckpointFrequency = CheckpointFrequency EveryEvent; // or EveryNEvents(10)\n        // Checkpoint stores\n        projections UseRedisCheckpoints(\"localhost:6379\");\n        projections UseCosmosCheckpoints(\"connection-string\");\n        projections UseSqlCheckpoints(\"connection-string\");\n    });\n});\n`\nSnapshot Management\nA Automatic Snapshots (Default)\nConfigurable automatic snapshotting for projections:\n`csharp\nservices AddProjection<CustomerSummaryProjection>(options => {\n    options Snapshots(snapshots => {\n        snapshots Strategy = SnapshotStrategy Automatic;\n        snapshots Frequency = SnapshotFrequency EveryNEvents(1000);\n        snapshots RetentionPolicy = SnapshotRetention KeepLast(5);\n    });\n});\n`\nB",
        "startIndex": 0,
        "preview": "Projection Management\nWhizbang provides comprehensive projection management including checkpoints, backfilling strategies, system events for on-demand..."
      },
      {
        "id": "design/projection-management-chunk-1",
        "text": "Checkpoint stores projections UseRedisCheckpoints(\"localhost:6379\"); projections UseCosmosCheckpoints(\"connection-string\"); projections UseSqlCheckpoints(\"connection-string\"); }); }); ` Snapshot Management A Automatic Snapshots (Default) Configurable automatic snapshotting for projections: `csharp services AddProjection<CustomerSummaryProjection>(options => { options Snapshots(snapshots => { snapshots Strategy = SnapshotStrategy Automatic; snapshots Frequency = SnapshotFrequency EveryNEvents(1000); snapshots RetentionPolicy = SnapshotRetention KeepLast(5); }); }); ` B Manual Snapshots\nDeveloper-controlled snapshotting:\n`csharp\npublic class CustomerSummaryProjection : IProjectionHandler<CustomerRegistered>,\n                                        IProjectionHandler<CustomerUpdated>,\n                                        ISnapshotProvider<CustomerSummarySnapshot> {\n    public CustomerSummary State { get; private set; }\n    public async Task Handle(CustomerRegistered @event, ProjectionContext context) {\n        State = new CustomerSummary {\n            CustomerId = @event CustomerId,\n            Name = @event Name,\n            Email = @event Email,\n            RegisteredAt = @event RegisteredAt\n        };\n        await context Store(@event CustomerId ToString(), State);\n    }\n    // Manual snapshot creation\n    [Snapshot(TriggerOn = typeof(CustomerMilestoneReached))]\n    public CustomerSummarySnapshot CreateSnapshot() {\n        return new CustomerSummarySnapshot {\n            CustomerId = State CustomerId,\n            Name = State Name,\n            TotalOrders = State TotalOrders,\n            LifetimeValue = State LifetimeValue,\n            SnapshotVersion = State Version\n        };\n    }\n    public void RestoreFromSnapshot(CustomerSummarySnapshot snapshot) {\n        State = new CustomerSummary {\n            CustomerId = snapshot CustomerId,\n            Name = snapshot Name,\n            TotalOrders = snapshot TotalOrders,\n            LifetimeValue = snapshot LifetimeValue,\n            Version = snapshot SnapshotVersion\n        };\n    }\n}\n`\nC No Snapshots\nOpt out of snapshotting for simple projections:\n`csharp\nservices AddProjection<SimpleEventLogProjection>(options => {\n    options Snapshots(snapshots => {\n        snapshots Strategy = SnapshotStrategy None;\n    });\n});\n`\nBackfilling Strategies\nA Declarative Backfilling\nSimple configuration-based backfilling:\n`csharp\nservices AddProjection<OrderHistoryProjection>(options => {\n    options Backfill(backfill => {\n        backfill StartFrom = DateTimeOffset Parse(\"2024-01-01\");\n        backfill AutoStart = true;\n        backfill BatchSize = 1000;\n        backfill MaxConcurrency = 4;\n    });\n});\n// Or backfill everything\nservices AddProjection<NewAnalyticsProjection>(options => {\n    options BackfillFromBeginning();\n});\n`\nB Imperative Backfilling\nProgrammatic control over backfilling:\n`csharp\npublic class BackfillController : ControllerBase {\n    private readonly IProjectionManager _projectionManager;\n    [HttpPost(\"projections/{projectionName}/backfill\")]\n    public async Task<IActionResult> BackfillProjection(\n        string projectionName,\n        BackfillRequest request) {\n        var options = new BackfillOptions {\n            FromDate = request FromDate,\n            ToDate = request ToDate,\n            BatchSize = request BatchSize",
        "startIndex": 2778,
        "preview": "Checkpoint stores projections UseRedisCheckpoints(\"localhost:6379\"); projections UseCosmosCheckpoints(\"connection-string\"); projections UseSqlCheckpoi..."
      },
      {
        "id": "design/projection-management-chunk-2",
        "text": "options BackfillFromBeginning(); }); ` B Imperative Backfilling Programmatic control over backfilling: `csharp public class BackfillController : ControllerBase { private readonly IProjectionManager _projectionManager; [HttpPost(\"projections/{projectionName}/backfill\")] public async Task<IActionResult> BackfillProjection( string projectionName, BackfillRequest request) { var options = new BackfillOptions { FromDate = request FromDate, ToDate = request ToDate, BatchSize = request BatchSize 1000,\n            IsAtomic = request IsAtomic false,\n            OnProgress = (progress) => {\n                // Real-time progress updates via SignalR\n                _hubContext Clients All SendAsync(\"BackfillProgress\", progress);\n            }\n        };\n        var result = await _projectionManager BackfillAsync(projectionName, options);\n        return Ok(result);\n    }\n}\n`\nSystem Events for On-Demand Backfilling\nEvent-driven backfill requests:\n`csharp\n// System event to trigger backfilling\npublic record ProjectionBackfillRequested(\n    string ProjectionName,\n    DateTimeOffset FromDate,\n    DateTimeOffset ToDate,\n    bool IsAtomic,\n    BackfillCriteria Criteria,\n    string RequestedBy\n) : ISystemEvent;\n// System event handler\npublic class ProjectionBackfillHandler : ISystemEventHandler<ProjectionBackfillRequested> {\n    public async Task Handle(ProjectionBackfillRequested @event, SystemEventContext context) {\n        var options = new BackfillOptions {\n            FromDate = @event FromDate,\n            ToDate = @event ToDate,\n            IsAtomic = @event IsAtomic,\n            Criteria = @event Criteria,\n            RequestId = context CorrelationId\n        };\n        await _projectionManager BackfillAsync(@event ProjectionName, options);\n        // Emit completion event\n        await context PublishSystemEvent(new ProjectionBackfillCompleted(\n            @event ProjectionName,\n            options FromDate,\n            options ToDate,\n            context CorrelationId\n        ));\n    }\n}\n// Trigger backfill via system event\nawait _systemEventPublisher PublishAsync(new ProjectionBackfillRequested(\n    ProjectionName: \"order-summary\",\n    FromDate: DateTimeOffset Parse(\"2024-01-01\"),\n    ToDate: null, // To current\n    IsAtomic: true,\n    Criteria: BackfillCriteria FullRebuild,\n    RequestedBy: \"admin-user\"\n));\n`\nBackfill Criteria Options\n`csharp\npublic enum BackfillCriteria {\n    // Date-based backfill\n    DateRange,              // Specific date range\n    FromDate,               // From date to current\n    LastNDays,              // Last N days only\n    // Event-based backfill  \n    EventNumberRange,       // Specific event number range\n    FromEventNumber,        // From event number to current\n    LastNEvents,            // Last N events only\n    // Full rebuild options\n    FullRebuild,            // Complete rebuild from beginning\n    IncrementalUpdate,      // Only missing/updated events\n    // Custom criteria\n    CustomPredicate         // Custom filter expression\n}\n// Usage examples\nservices AddProjection<OrderSummaryProjection>(options => {\n    options",
        "startIndex": 5551,
        "preview": "options BackfillFromBeginning(); }); ` B Imperative Backfilling Programmatic control over backfilling: `csharp public class BackfillController : Contr..."
      },
      {
        "id": "design/projection-management-chunk-3",
        "text": "// Specific event number range FromEventNumber, // From event number to current LastNEvents, // Last N events only // Full rebuild options FullRebuild, // Complete rebuild from beginning IncrementalUpdate, // Only missing/updated events // Custom criteria CustomPredicate // Custom filter expression } // Usage examples services AddProjection<OrderSummaryProjection>(options => { options Backfill(backfill => {\n        backfill Criteria = BackfillCriteria LastNDays;\n        backfill CriteriaValue = 30; // Last 30 days\n    });\n});\n// System event with custom criteria\nawait _systemEvents PublishAsync(new ProjectionBackfillRequested(\n    ProjectionName: \"analytics\",\n    FromDate: null,\n    ToDate: null,\n    IsAtomic: false,\n    Criteria: BackfillCriteria CustomPredicate,\n    RequestedBy: \"system\"\n) {\n    CustomPredicate = @event => @event EventType StartsWith(\"Order\") && \n                               @event Metadata[\"source\"] == \"web-api\"\n});\n`\nAdvanced Backfill Features\nParallel Processing\n`csharp\nservices AddProjection<AnalyticsProjection>(options => {\n    options Backfill(backfill => {\n        backfill Strategy = BackfillStrategy Parallel;\n        backfill PartitionBy = @event => @event StreamId GetHashCode() % 8;\n        backfill MaxConcurrency = 8;\n        backfill BatchSize = 500;\n    });\n});\n`\nProgress Tracking\n`csharp\npublic class BackfillProgressTracker {\n    public async Task TrackProgress(string projectionName, CancellationToken cancellationToken) {\n        await foreach (var progress in _projectionManager GetBackfillProgress(projectionName, cancellationToken)) {\n            Console WriteLine($\"Backfill progress: {progress EventsProcessed}/{progress TotalEvents} \" +\n                            $\"({progress PercentComplete:F1}%) - ETA: {progress EstimatedTimeRemaining}\");\n        }\n    }\n}\n`\nRollback Support\n`csharp\n// Rollback to previous version if backfill fails\nservices AddProjection<OrderSummaryProjection>(options => {\n    options Backfill(backfill => {\n        backfill EnableRollback = true;\n        backfill RollbackOnFailure = true;\n        backfill CreateBackupBeforeBackfill = true;\n    });\n});\n// Manual rollback API\nawait _projectionManager",
        "startIndex": 4685,
        "preview": "// Specific event number range FromEventNumber, // From event number to current LastNEvents, // Last N events only // Full rebuild options FullRebuild..."
      },
      {
        "id": "design/projection-management-chunk-4",
        "text": "+ $\"({progress PercentComplete:F1}%) - ETA: {progress EstimatedTimeRemaining}\"); } } } ` Rollback Support `csharp // Rollback to previous version if backfill fails services AddProjection<OrderSummaryProjection>(options => { options Backfill(backfill => { backfill EnableRollback = true; backfill RollbackOnFailure = true; backfill CreateBackupBeforeBackfill = true; }); }); // Manual rollback API await _projectionManager RollbackProjection(\"order-summary\", toVersion: previousVersion);\n`\nSystem Event Integration\nBuilt-in System Events\n`csharp\n// Projection lifecycle events\npublic record ProjectionStarted(string ProjectionName, DateTimeOffset StartedAt);\npublic record ProjectionStopped(string ProjectionName, DateTimeOffset StoppedAt);\npublic record ProjectionFailed(string ProjectionName, Exception Error, DateTimeOffset FailedAt);\n// Backfill events\npublic record ProjectionBackfillStarted(string ProjectionName, BackfillOptions Options);\npublic record ProjectionBackfillProgress(string ProjectionName, BackfillProgress Progress);\npublic record ProjectionBackfillCompleted(string ProjectionName, BackfillResult Result);\npublic record ProjectionBackfillFailed(string ProjectionName, Exception Error);\n// Checkpoint events\npublic record ProjectionCheckpointSaved(string ProjectionName, long Position);\npublic record ProjectionCheckpointRestored(string ProjectionName, long Position);\n// Snapshot events\npublic record ProjectionSnapshotCreated(string ProjectionName, long EventVersion);\npublic record ProjectionSnapshotRestored(string ProjectionName, long EventVersion);\n`\nCustom System Event Handlers\n`csharp\npublic class ProjectionMonitoringHandler : \n    ISystemEventHandler<ProjectionFailed>,\n    ISystemEventHandler<ProjectionBackfillCompleted> {\n    public async Task Handle(ProjectionFailed @event, SystemEventContext context) {\n        // Alert on projection failures\n        await _alerting SendAlert($\"Projection {@event ProjectionName} failed: {@event Error Message}\");\n        // Automatic retry for transient failures\n        if (IsTransientError(@event Error)) {\n            await context PublishSystemEvent(new ProjectionRestartRequested(\n                @event ProjectionName,\n                retryAttempt: context GetRetryAttempt() + 1\n            ));\n        }\n    }\n    public async Task Handle(ProjectionBackfillCompleted @event, SystemEventContext context) {\n        // Update projection metadata\n        await _projectionMetadata MarkBackfillComplete(@event ProjectionName, @event Result);\n        // Notify stakeholders\n        await _notifications NotifyBackfillComplete(@event",
        "startIndex": 9973,
        "preview": "+ $\"({progress PercentComplete:F1}%) - ETA: {progress EstimatedTimeRemaining}\"); } } } ` Rollback Support `csharp // Rollback to previous version if b..."
      },
      {
        "id": "design/projection-management-chunk-5",
        "text": "Error Message}\"); // Automatic retry for transient failures if (IsTransientError(@event Error)) { await context PublishSystemEvent(new ProjectionRestartRequested( @event ProjectionName, retryAttempt: context GetRetryAttempt() + 1 )); } } public async Task Handle(ProjectionBackfillCompleted @event, SystemEventContext context) { // Update projection metadata await _projectionMetadata MarkBackfillComplete(@event ProjectionName, @event Result); // Notify stakeholders await _notifications NotifyBackfillComplete(@event ProjectionName);\n    }\n}\n`\nAPI Reference\nIProjectionManager Interface\n`csharp\npublic interface IProjectionManager {\n    // Lifecycle management\n    Task StartProjection(string projectionName);\n    Task StopProjection(string projectionName);\n    Task RestartProjection(string projectionName);\n    // Backfilling\n    Task<BackfillResult> BackfillAsync(string projectionName, BackfillOptions options);\n    IAsyncEnumerable<BackfillProgress> GetBackfillProgress(string projectionName, CancellationToken cancellationToken);\n    Task CancelBackfill(string projectionName);\n    // Snapshots\n    Task<SnapshotResult> CreateSnapshot(string projectionName);\n    Task<SnapshotResult> RestoreFromSnapshot(string projectionName, long snapshotVersion);\n    Task<IEnumerable<SnapshotInfo>> GetSnapshots(string projectionName);\n    // Checkpoints\n    Task<long> GetCurrentCheckpoint(string projectionName);\n    Task ResetCheckpoint(string projectionName, long position);\n    // Status and monitoring\n    Task<ProjectionStatus> GetStatus(string projectionName);\n    Task<IEnumerable<ProjectionInfo>> GetAllProjections();\n    Task<ProjectionHealth> GetHealth(string projectionName);\n}\n`\nConfiguration Extensions\n`csharp\npublic static class ProjectionConfigurationExtensions {\n    public static IProjectionBuilder<T> BackfillFromBeginning<T>(this IProjectionBuilder<T> builder) \n        where T : class;\n    public static IProjectionBuilder<T> BackfillFrom<T>(this IProjectionBuilder<T> builder, DateTimeOffset from) \n        where T : class;\n    public static IProjectionBuilder<T> WithSnapshots<T>(this IProjectionBuilder<T> builder, \n        Action<SnapshotConfiguration> configure) where T : class;\n    public static IProjectionBuilder<T> WithCheckpoints<T>(this IProjectionBuilder<T> builder, \n        Action<CheckpointConfiguration> configure) where T : class;\n    public static IProjectionBuilder<T> OnSystemEvent<T, TEvent>(this IProjectionBuilder<T> builder, \n        Func<TEvent, Task> handler) where T : class where TEvent : ISystemEvent;\n}\n`\nBest Practices\nProjection Design\nKeep projections focused - One projection per query need\nMake handlers idempotent - Support replay scenarios\nHandle missing data gracefully - Events may be out of order\nVersion projection schemas - Enable evolution over time\nBackfill Planning\nTest backfills in staging - Verify performance and correctness\nUse atomic rebuilds for critical projections\nMonitor resource usage during large backfills\nPlan for rollback scenarios if backfill fails\nCheckpoint Strategy\nUse same-database checkpoints for consistency-critical projections\nUse separate checkpoints for high-throughput scenarios\nCheckpoint frequently to minimize replay overhead\nMonitor checkpoint lag for early failure detection\n---\nRelated Documentation\nEvent Store & Projections - Core storage architecture\nMulti-Tenancy - Tenant-aware projection management\nPerformance Optimization - Scaling projection processing",
        "startIndex": 12156,
        "preview": "Error Message}\"); // Automatic retry for transient failures if (IsTransientError(@event Error)) { await context PublishSystemEvent(new ProjectionResta..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "design/schema-evolution",
    "title": "Schema Evolution & Event Versioning",
    "category": "Architecture & Design",
    "url": "/docs/design/schema-evolution",
    "chunks": [
      {
        "id": "design/schema-evolution-chunk-0",
        "text": "Schema Evolution & Event Versioning\nWhizbang provides robust schema evolution capabilities using JSONB storage and flexible driver interfaces, allowing events and projections to evolve over time without breaking existing systems JSONB-Based Schema Evolution\nFlexible Event Schema\nEvents stored in JSONB format naturally support schema evolution:\n`csharp\n// V1 Event\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId\n);\n// V2 Event - Add field (backward compatible)\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset PlacedAt = null  // Optional for backward compatibility\n);\n// V3 Event - Add collection (backward compatible)\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset PlacedAt = null,\n    List<string> Tags = null         // Null-safe collection\n) {\n    // Ensure collections are never null\n    public List<string> Tags { get; init; } = Tags new List<string>();\n}\n`\nJSONB benefits:\n✅ Missing fields handled gracefully\n✅ Extra fields ignored during deserialization\n✅ No database schema migrations required\n✅ Query flexibility with JSON operators\nProjection Schema Evolution\nProjections can evolve independently of events:\n`csharp\n// V1 Projection\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public decimal Total { get; set; }\n    public OrderStatus Status { get; set; }\n}\n// V2 Projection - Add fields without migration\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public decimal Total { get; set; }\n    public OrderStatus Status { get; set; }\n    // New fields with sensible defaults\n    public DateTime EstimatedDelivery { get; set; } = DateTime MinValue;\n    public List<string> Tags { get; set; } = new();\n    public CustomerInfo Customer { get; set; } = new();\n}\n// Projection rebuild handles missing data gracefully\npublic class OrderSummaryProjection : IProjectionHandler<OrderPlaced> {\n    public async Task Handle(OrderPlaced @event, ProjectionContext context) {\n        var summary = await context Load<OrderSummary>(@event OrderId ToString()) new OrderSummary();\n        summary OrderId = @event OrderId;\n        summary",
        "startIndex": 0,
        "preview": "Schema Evolution & Event Versioning\nWhizbang provides robust schema evolution capabilities using JSONB storage and flexible driver interfaces, allowin..."
      },
      {
        "id": "design/schema-evolution-chunk-1",
        "text": "} = new(); public CustomerInfo Customer { get; set; } = new(); } // Projection rebuild handles missing data gracefully public class OrderSummaryProjection : IProjectionHandler<OrderPlaced> { public async Task Handle(OrderPlaced @event, ProjectionContext context) { var summary = await context Load<OrderSummary>(@event OrderId ToString()) new OrderSummary(); summary OrderId = @event OrderId; summary Total = @event Total;\n        // Handle optional V2+ fields\n        if (@event PlacedAt HasValue) {\n            summary EstimatedDelivery = @event PlacedAt Value AddDays(7);\n        }\n        if (@event Tags Any() == true) {\n            summary Tags = @event Tags;\n        }\n        await context Store(@event OrderId ToString(), summary);\n    }\n}\n`\nEvent Versioning Strategies\nA Upcasting (Recommended)\nConvert old events to new schema on read:\n`csharp\npublic interface IEventUpcaster<TOld, TNew> {\n    TNew Upcast(TOld oldEvent);\n    bool CanUpcast(Type eventType, int version);\n}\n// Upcast V1 OrderPlaced to V2\npublic class OrderPlacedV1ToV2Upcaster : IEventUpcaster<OrderPlacedV1, OrderPlaced> {\n    public OrderPlaced Upcast(OrderPlacedV1 oldEvent) {\n        return new OrderPlaced(\n            oldEvent OrderId,\n            oldEvent CustomerId,\n            PlacedAt: DateTimeOffset UtcNow, // Best guess for missing data\n            Tags: new List<string>()         // Default to empty\n        );\n    }\n    public bool CanUpcast(Type eventType, int version) {\n        return eventType == typeof(OrderPlacedV1) && version == 1;\n    }\n}\n// Registration\nservices AddWhizbang(options => {\n    options EventVersioning(versioning => {\n        versioning AddUpcaster<OrderPlacedV1ToV2Upcaster>();\n        versioning AddUpcaster<OrderPlacedV2ToV3Upcaster>();\n    });\n});\n`\nB Multiple Versions Supported Simultaneously\nKeep multiple event versions active:\n`csharp\n// Multiple handlers for different versions\npublic class OrderPlacedV1Handler : IEventHandler<OrderPlacedV1> {\n    public async Task Handle(OrderPlacedV1 @event, EventContext context) {\n        // Handle legacy V1 events\n        var order = await _repository Load<Order>(@event OrderId);\n        order MarkAsPlaced(placedAt: DateTimeOffset UtcNow); // Default timestamp\n        await _repository Save(order);\n    }\n}\npublic class OrderPlacedV2Handler : IEventHandler<OrderPlaced> {\n    public async Task Handle(OrderPlaced @event, EventContext context) {\n        // Handle current V2+ events\n        var order = await _repository Load<Order>(@event OrderId);\n        order MarkAsPlaced(@event PlacedAt DateTimeOffset UtcNow);\n        await _repository",
        "startIndex": 2206,
        "preview": "} = new(); public CustomerInfo Customer { get; set; } = new(); } // Projection rebuild handles missing data gracefully public class OrderSummaryProjec..."
      },
      {
        "id": "design/schema-evolution-chunk-2",
        "text": "= await _repository Load<Order>(@event OrderId); order MarkAsPlaced(placedAt: DateTimeOffset UtcNow); // Default timestamp await _repository Save(order); } } public class OrderPlacedV2Handler : IEventHandler<OrderPlaced> { public async Task Handle(OrderPlaced @event, EventContext context) { // Handle current V2+ events var order = await _repository Load<Order>(@event OrderId); order MarkAsPlaced(@event PlacedAt DateTimeOffset UtcNow); await _repository Save(order);\n    }\n}\n// Router determines which handler to use based on event version\nservices AddWhizbang(options => {\n    options EventVersioning(versioning => {\n        versioning RouteByVersion = true;\n        versioning RegisterHandler<OrderPlacedV1Handler>(version: 1);\n        versioning RegisterHandler<OrderPlacedV2Handler>(version: 2);\n    });\n});\n`\nC Schema Registry\nCentralized schema management:\n`csharp\nservices AddWhizbang(options => {\n    options EventVersioning(versioning => {\n        versioning UseSchemaRegistry(registry => {\n            registry ConnectionString = \"https://schema-registry company com\";\n            registry AutoRegisterSchemas = true;\n            registry ValidateOnWrite = true;\n            registry CompatibilityLevel = CompatibilityLevel Backward;\n        });\n    });\n});\n// Events automatically registered with schema registry\n[SchemaRegistration(subject: \"order-placed\", version: 2)]\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset PlacedAt = null\n);\n`\nDriver Interface for Schema Evolution\nAbstract Driver Interface\n`csharp\npublic interface ISchemaEvolutionDriver {\n    // Serialization with versioning\n    Task<byte[]> Serialize<T>(T @event, int version = null);\n    Task<T> Deserialize<T>(byte[] data, int version);\n    Task<object> DeserializeToLatestVersion(byte[] data, Type eventType, int storedVersion);\n    // Schema registration\n    Task RegisterSchema(Type eventType, int version);\n    Task<SchemaInfo> GetSchema(Type eventType, int version);\n    Task<IEnumerable<SchemaInfo>> GetSchemaEvolution(Type eventType);\n    // Upcasting support\n    Task<T> UpcastToLatest<T>(object oldEvent, int fromVersion);\n    bool CanUpcast(Type eventType, int fromVersion, int toVersion);\n}\npublic class SchemaInfo {\n    public Type EventType { get; set; }\n    public int Version { get; set; }\n    public string Schema { get; set; }\n    public DateTime RegisteredAt { get; set; }\n    public CompatibilityLevel Compatibility { get; set; }\n}\n`\nPostgreSQL JSONB Driver Implementation\n`csharp\npublic class PostgresSchemaEvolutionDriver : ISchemaEvolutionDriver {\n    public async Task<byte[]> Serialize<T>(T @event, int version = null) {\n        var eventType = typeof(T);\n        var currentVersion = version await GetLatestVersion(eventType);\n        var eventData = new {\n            EventType = eventType",
        "startIndex": 4425,
        "preview": "= await _repository Load<Order>(@event OrderId); order MarkAsPlaced(placedAt: DateTimeOffset UtcNow); // Default timestamp await _repository Save(orde..."
      },
      {
        "id": "design/schema-evolution-chunk-3",
        "text": "set; } public CompatibilityLevel Compatibility { get; set; } } ` PostgreSQL JSONB Driver Implementation `csharp public class PostgresSchemaEvolutionDriver : ISchemaEvolutionDriver { public async Task<byte[]> Serialize<T>(T @event, int version = null) { var eventType = typeof(T); var currentVersion = version await GetLatestVersion(eventType); var eventData = new { EventType = eventType FullName,\n            Version = currentVersion,\n            Data = @event\n        };\n        return JsonSerializer SerializeToUtf8Bytes(eventData);\n    }\n    public async Task<T> Deserialize<T>(byte[] data, int version) {\n        var eventData = JsonSerializer Deserialize<dynamic>(data);\n        var storedVersion = (int)eventData Version;\n        if (storedVersion == version) {\n            return JsonSerializer Deserialize<T>(eventData Data);\n        }\n        // Need to upcast\n        var oldEvent = DeserializeToVersion(eventData Data, typeof(T), storedVersion);\n        return await UpcastToLatest<T>(oldEvent, storedVersion);\n    }\n    public async Task<object> DeserializeToLatestVersion(byte[] data, Type eventType, int storedVersion) {\n        var latestVersion = await GetLatestVersion(eventType);\n        if (storedVersion == latestVersion) {\n            // Already latest version\n            return JsonSerializer Deserialize(data, eventType);\n        }\n        // Upcast to latest\n        var oldEvent = DeserializeToVersion(data, eventType, storedVersion);\n        return await UpcastToLatest(oldEvent, eventType, storedVersion, latestVersion);\n    }\n}\n`\nLINQ Support Evolution\nDriver-Specific LINQ Implementation\n`csharp\npublic interface IQueryEvolutionDriver {\n    IQueryable<T> Query<T>() where T : class;\n    IQueryable<T> QueryVersion<T>(int version) where T : class;\n    IQueryable<object> QueryAllVersions(Type eventType);\n}\n// PostgreSQL implementation with JSONB operators\npublic class PostgresQueryDriver : IQueryEvolutionDriver {\n    public IQueryable<T> Query<T>() where T : class {\n        return _context Events Where(e => e EventType == typeof(T) Name) Select(e => JsonSerializer Deserialize<T>(e EventData)) AsQueryable();\n    }\n    // JSONB path queries for evolved schemas\n    public IQueryable<OrderSummary> QueryOrdersWithTags() {\n        return _context Projections Where(p => p ProjectionName == \"order-summary\") Where(p => EF Functions JsonExists(p Document, \"$ Tags\"))  // Has tags field Select(p => JsonSerializer Deserialize<OrderSummary>(p Document)) AsQueryable();\n    }\n    // Query across schema versions\n    public IQueryable<decimal> QueryOrderTotals() {\n        return _context Events Where(e => e EventType == \"OrderPlaced\") Select(e => EF Functions JsonExtract<decimal>(e EventData, \"$ Total\"))",
        "startIndex": 6811,
        "preview": "set; } public CompatibilityLevel Compatibility { get; set; } } ` PostgreSQL JSONB Driver Implementation `csharp public class PostgresSchemaEvolutionDr..."
      },
      {
        "id": "design/schema-evolution-chunk-4",
        "text": "=> p ProjectionName == \"order-summary\") Where(p => EF Functions JsonExists(p Document, \"$ Tags\")) // Has tags field Select(p => JsonSerializer Deserialize<OrderSummary>(p Document)) AsQueryable(); } // Query across schema versions public IQueryable<decimal> QueryOrderTotals() { return _context Events Where(e => e EventType == \"OrderPlaced\") Select(e => EF Functions JsonExtract<decimal>(e EventData, \"$ Total\")) AsQueryable();\n    }\n}\n`\nSchema-Aware Query Extensions\n`csharp\npublic static class SchemaQueryExtensions {\n    public static IQueryable<T> WhereSchemaVersion<T>(this IQueryable<T> query, int version) {\n        // Filter by schema version\n        return query Where(/ version filter logic /);\n    }\n    public static IQueryable<T> WhereHasField<T>(this IQueryable<T> query, string fieldPath) {\n        // Filter by field existence (JSONB support)\n        return query Where(/ field existence logic /);\n    }\n    public static IQueryable<TResult> SelectEvolved<T, TResult>(\n        this IQueryable<T> query, \n        Expression<Func<T, TResult>> selector,\n        SchemaEvolutionOptions options = null) {\n        // Schema-aware projection\n        return query Select(/ evolved selector logic /);\n    }\n}\n// Usage\nvar recentOrdersWithTags = await _context Query<OrderSummary>() WhereHasField(\"Tags\") Where(o => o PlacedAt > DateTime UtcNow AddDays(-30)) ToListAsync();\n`\nBlue/Green Deployment Support\nDriver-Level Blue/Green Implementation\n`csharp\npublic interface IBlueGreenDriver {\n    Task<string> CreateGreenDeployment(string projectionName);\n    Task BuildGreenProjection(string projectionName, string greenVersion);\n    Task ValidateGreenProjection(string projectionName, string greenVersion);\n    Task SwitchToGreen(string projectionName, string greenVersion);\n    Task CleanupBlueVersion(string projectionName);\n}\npublic class PostgresBlueGreenDriver : IBlueGreenDriver {\n    public async Task<string> CreateGreenDeployment(string projectionName) {\n        var greenVersion = Guid NewGuid() ToString(\"N\")[ 8];\n        var greenTableName = $\"{projectionName}_green_{greenVersion}\";\n        // Create green table with same schema as blue\n        await _connection ExecuteAsync($\"\"\"\n            CREATE TABLE {greenTableName} (LIKE {projectionName} INCLUDING ALL);\n            CREATE INDEX CONCURRENTLY idx_{greenTableName}_tenant \n                ON {greenTableName}(tenant_id) WHERE tenant_id IS NOT NULL;\n        \"\"\");\n        return greenVersion;\n    }\n    public async Task BuildGreenProjection(string projectionName, string greenVersion) {\n        var greenTableName = $\"{projectionName}_green_{greenVersion}\";\n        // Rebuild projection in green table from events\n        await _projectionBuilder RebuildInTable(projectionName, greenTableName);\n    }\n    public async Task SwitchToGreen(string projectionName, string greenVersion) {\n        var greenTableName = $\"{projectionName}_green_{greenVersion}\";\n        var blueBackupName = $\"{projectionName}_blue_backup_{DateTimeOffset UtcNow:yyyyMMdd_HHmmss}\";\n        // Atomic table swap\n        await _connection",
        "startIndex": 9288,
        "preview": "=> p ProjectionName == \"order-summary\") Where(p => EF Functions JsonExists(p Document, \"$ Tags\")) // Has tags field Select(p => JsonSerializer Deseria..."
      },
      {
        "id": "design/schema-evolution-chunk-5",
        "text": "greenVersion; } public async Task BuildGreenProjection(string projectionName, string greenVersion) { var greenTableName = $\"{projectionName}_green_{greenVersion}\"; // Rebuild projection in green table from events await _projectionBuilder RebuildInTable(projectionName, greenTableName); } public async Task SwitchToGreen(string projectionName, string greenVersion) { var greenTableName = $\"{projectionName}_green_{greenVersion}\"; var blueBackupName = $\"{projectionName}_blue_backup_{DateTimeOffset UtcNow:yyyyMMdd_HHmmss}\"; // Atomic table swap await _connection ExecuteAsync($\"\"\"\n            BEGIN;\n            ALTER TABLE {projectionName} RENAME TO {blueBackupName};\n            ALTER TABLE {greenTableName} RENAME TO {projectionName};\n            COMMIT;\n        \"\"\");\n    }\n}\n`\nConfiguration and Best Practices\nComprehensive Schema Evolution Setup\n`csharp\nservices AddWhizbang(options => {\n    options SchemaEvolution(evolution => {\n        // Storage format\n        evolution UseJsonb = true;\n        evolution StoreSchemaVersion = true;\n        evolution ValidateOnWrite = false; // Allow forward compatibility\n        // Versioning strategy\n        evolution VersioningStrategy = VersioningStrategy Upcasting;\n        evolution AutoRegisterUpcasterts = true;\n        evolution UpcastOnRead = true;\n        // Schema registry\n        evolution UseSchemaRegistry(registry => {\n            registry Url = \"https://schema-registry internal\";\n            registry AutoRegister = true;\n            registry CompatibilityLevel = CompatibilityLevel Backward;\n        });\n        // Blue/Green deployments\n        evolution BlueGreen(blueGreen => {\n            blueGreen ValidationThreshold = 0 99; // 99% accuracy required\n            blueGreen WarmupPeriod = TimeSpan FromMinutes(5);\n            blueGreen AutoSwitch = false; // Manual approval required\n        });\n    });\n});\n`\nEvent Versioning Best Practices\n`csharp\n// 1 Always make fields optional when adding them\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset PlacedAt = null,      // Optional - added in V2\n    List<string> Tags = null             // Optional - added in V3\n);\n// 2 Use wrapper types for complex evolution\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    OrderMetadata Metadata = null        // Wrapper for evolving fields\n);\npublic record OrderMetadata(\n    DateTimeOffset PlacedAt = null,\n    List<string> Tags = null,\n    CustomerInfo Customer = null\n);\n// 3 Never remove fields - mark as obsolete\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    [Obsolete(\"Use Metadata PlacedAt instead\")]\n    DateTimeOffset PlacedAt = null,      // Keep for backward compatibility\n    OrderMetadata Metadata = null\n);\n// 4",
        "startIndex": 11977,
        "preview": "greenVersion; } public async Task BuildGreenProjection(string projectionName, string greenVersion) { var greenTableName = $\"{projectionName}_green_{gr..."
      },
      {
        "id": "design/schema-evolution-chunk-6",
        "text": "OrderMetadata( DateTimeOffset PlacedAt = null, List<string> Tags = null, CustomerInfo Customer = null ); // 3 Never remove fields - mark as obsolete public record OrderPlaced( Guid OrderId, Guid CustomerId, [Obsolete(\"Use Metadata PlacedAt instead\")] DateTimeOffset PlacedAt = null, // Keep for backward compatibility OrderMetadata Metadata = null ); // 4 Use semantic versioning for breaking changes\n[EventVersion(\"order-placed\", \"1 0 0\")]\npublic record OrderPlacedV1(Guid OrderId, Guid CustomerId);\n[EventVersion(\"order-placed\", \"1 1 0\")]  // Minor version - additive\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt = null);\n[EventVersion(\"order-placed\", \"2 0 0\")]  // Major version - breaking change\npublic record OrderPlacedV2(Guid OrderId, CustomerId CustomerId, DateTimeOffset PlacedAt);\n`\nProjection Evolution Guidelines\nAdd fields with defaults - New fields should have sensible default values\nRebuild for major changes - Use blue/green deployment for breaking changes\nTest evolution paths - Verify old events work with new projections\nMonitor data quality - Track schema evolution impact on data\nDocument changes - Keep clear records of schema evolution decisions\n---\nRelated Documentation\nEvent Store & Projections - Core storage architecture\nProjection Management - Backfilling and rebuilding strategies\nAdvanced Features - Cross-aggregate transactions and distributed tracing",
        "startIndex": 14192,
        "preview": "OrderMetadata( DateTimeOffset PlacedAt = null, List<string> Tags = null, CustomerInfo Customer = null ); // 3 Never remove fields - mark as obsolete p..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "design/source-generation-ide",
    "title": "Source Generation & IDE Integration",
    "category": "Architecture & Design",
    "url": "/docs/design/source-generation-ide",
    "chunks": [
      {
        "id": "design/source-generation-ide-chunk-0",
        "text": "Source Generation & IDE Integration\nWhizbang uses advanced source generation and IDE integration to provide a seamless developer experience with compile-time validation, intelligent navigation, and powerful debugging tools Source Generator Architecture\nSingle Pipeline Generator\nIncremental source generator with orchestrated pipeline stages for optimal performance:\n`csharp\n[Generator]\npublic class WhizbangSourceGenerator : IIncrementalGenerator {\n    public void Initialize(IncrementalGeneratorInitializationContext context) {\n        // Stage 1: Handler Discovery Pipeline\n        var handlersPipeline = context SyntaxProvider CreateSyntaxProvider(\n            predicate: (node, _) => IsHandlerCandidate(node),\n            transform: (ctx, _) => ExtractHandlerInfo(ctx)\n        ) Where(info => info = null);\n        // Stage 2: Domain Ownership Pipeline  \n        var domainOwnershipPipeline = context SyntaxProvider CreateSyntaxProvider(\n            predicate: (node, _) => IsDomainCandidate(node),\n            transform: (ctx, _) => ExtractDomainInfo(ctx)\n        );\n        // Stage 3: Projection Pipeline\n        var projectionsPipeline = context SyntaxProvider CreateSyntaxProvider(\n            predicate: (node, _) => IsProjectionCandidate(node),\n            transform: (ctx, _) => ExtractProjectionInfo(ctx)\n        );\n        // Stage 4: Policy Pipeline\n        var policiesPipeline = context SyntaxProvider CreateSyntaxProvider(\n            predicate: (node, _) => IsPolicyCandidate(node),\n            transform: (ctx, _) => ExtractPolicyInfo(ctx)\n        );\n        // Combine all sources for cross-project aggregation\n        var combinedPipeline = handlersPipeline Combine(domainOwnershipPipeline) Combine(projectionsPipeline) Combine(policiesPipeline);\n        // Generate code\n        context RegisterSourceOutput(combinedPipeline, GenerateWhizbangRegistry);\n        // Generate metadata for IDE service\n        context RegisterSourceOutput(combinedPipeline, GenerateNavigationMetadata);\n        // Generate analyzer data\n        context RegisterSourceOutput(combinedPipeline, GenerateAnalyzerData);\n    }\n}\n`\nBuild Performance & Logging\nDetailed timing and logging for optimization:\n`csharp\npublic class GenerationPerformanceTracker {\n    private readonly Dictionary<string, Stopwatch> _stageTimers = new();\n    public void StartStage(string stageName) {\n        _stageTimers[stageName] = Stopwatch StartNew();\n        LogInformation($\"Starting stage: {stageName}\");\n    }\n    public void EndStage(string stageName) {\n        if (_stageTimers TryGetValue(stageName, out var timer)) {\n            timer Stop();\n            LogInformation($\"Completed stage: {stageName} in {timer ElapsedMilliseconds}ms\");\n        }\n    }\n    public void LogSummary() {\n        var totalTime = _stageTimers Values Sum(t => t ElapsedMilliseconds);\n        LogInformation($\"Total generation time: {totalTime}ms\");\n        foreach (var (stage, timer) in _stageTimers) {\n            var percentage = (timer ElapsedMilliseconds / (double)totalTime) * 100;\n            LogInformation($\"  {stage}: {timer",
        "startIndex": 0,
        "preview": "Source Generation & IDE Integration\nWhizbang uses advanced source generation and IDE integration to provide a seamless developer experience with compi..."
      },
      {
        "id": "design/source-generation-ide-chunk-1",
        "text": "out var timer)) { timer Stop(); LogInformation($\"Completed stage: {stageName} in {timer ElapsedMilliseconds}ms\"); } } public void LogSummary() { var totalTime = _stageTimers Values Sum(t => t ElapsedMilliseconds); LogInformation($\"Total generation time: {totalTime}ms\"); foreach (var (stage, timer) in _stageTimers) { var percentage = (timer ElapsedMilliseconds / (double)totalTime) * 100; LogInformation($\" {stage}: {timer ElapsedMilliseconds}ms ({percentage:F1}%)\");\n        }\n    }\n}\n`\nMulti-Project Aggregation\nCross-assembly handler discovery and registration:\n`csharp\n// Generated registry aggregates across projects\n[GeneratedCode(\"Whizbang SourceGenerator\")]\npublic static class WhizbangGeneratedRegistry {\n    public static void RegisterAll(IServiceCollection services) {\n        // Handlers from current project\n        RegisterLocalHandlers(services);\n        // Handlers from referenced projects\n        RegisterReferencedHandlers(services);\n        // Domain ownership from all projects\n        RegisterDomainOwnership(services);\n        // Policies from all projects\n        RegisterPolicies(services);\n    }\n    private static void RegisterLocalHandlers(IServiceCollection services) {\n        services AddScoped<ICommandHandler<PlaceOrder>, PlaceOrderHandler>();\n        services AddScoped<IEventHandler<OrderPlaced>, OrderSummaryProjection>();\n        // other local handlers\n    }\n    private static void RegisterReferencedHandlers(IServiceCollection services) {\n        // Handlers discovered from referenced assemblies\n        SharedLibrary WhizbangRegistry RegisterHandlers(services);\n        CoreDomain WhizbangRegistry RegisterHandlers(services);\n    }\n}\n`\nIDE Navigation Service\nEvent Stream Navigation\nGitLens-style navigation through event streams and handlers:\n`csharp\npublic interface IWhizbangNavigationService {\n    Task<EventStreamInfo> GetEventStreamAsync(string streamId);\n    Task<IEnumerable<HandlerInfo>> GetHandlersForEventAsync(Type eventType);\n    Task<IEnumerable<ProjectionInfo>> GetProjectionsForEventAsync(Type eventType);\n    Task<EventFlowDiagram> GetEventFlowAsync(Type commandType);\n    Task<DomainMap> GetDomainMapAsync();\n}\n// Event flow visualization\npublic class EventFlowDiagram {\n    public CommandInfo Command { get; set; }\n    public HandlerInfo CommandHandler { get; set; }\n    public List<EventInfo> EmittedEvents { get; set; }\n    public Dictionary<EventInfo, List<HandlerInfo>> EventHandlers { get; set; }\n    public Dictionary<EventInfo, List<ProjectionInfo>> EventProjections { get; set; }\n    public List<SagaInfo> TriggeredSagas { get; set; }\n}\n// Usage in IDE extension\npublic class WhizbangCodeLensProvider : CodeLensProvider {\n    public override async Task<CodeLens[]> ProvideCodeLensesAsync(Document document) {\n        var semanticModel = await document GetSemanticModelAsync();\n        var root = await document GetSyntaxRootAsync();\n        var codeLenses = new List<CodeLens>();\n        // Find command handlers\n        foreach (var handlerClass in root DescendantNodes() OfType<ClassDeclarationSyntax>()) {\n            if (IsCommandHandler(handlerClass, semanticModel)) {\n                var commandType = GetCommandType(handlerClass, semanticModel);\n                var eventFlow = await _navigationService GetEventFlowAsync(commandType);\n                codeLenses",
        "startIndex": 3139,
        "preview": "out var timer)) { timer Stop(); LogInformation($\"Completed stage: {stageName} in {timer ElapsedMilliseconds}ms\"); } } public void LogSummary() { var t..."
      },
      {
        "id": "design/source-generation-ide-chunk-2",
        "text": "async Task<CodeLens[]> ProvideCodeLensesAsync(Document document) { var semanticModel = await document GetSemanticModelAsync(); var root = await document GetSyntaxRootAsync(); var codeLenses = new List<CodeLens>(); // Find command handlers foreach (var handlerClass in root DescendantNodes() OfType<ClassDeclarationSyntax>()) { if (IsCommandHandler(handlerClass, semanticModel)) { var commandType = GetCommandType(handlerClass, semanticModel); var eventFlow = await _navigationService GetEventFlowAsync(commandType); codeLenses Add(new CodeLens {\n                    Range = GetRange(handlerClass),\n                    Command = new Command {\n                        Title = $\"Emits {eventFlow EmittedEvents Count} events, triggers {eventFlow EventHandlers Count} handlers\",\n                        Arguments = new object[] { eventFlow }\n                    }\n                });\n            }\n        }\n        return codeLenses ToArray();\n    }\n}\n`\nGenerated Metadata\nRich metadata for IDE integration:\n`csharp\n// Generated metadata file: WhizbangMetadata json\n{\n  \"eventStreams\": {\n    \"Order-{orderId}\": {\n      \"aggregateType\": \"Order\",\n      \"domain\": \"Orders\",\n      \"events\": [\"OrderPlaced\", \"OrderUpdated\", \"OrderShipped\"],\n      \"handlers\": [\"OrderSummaryProjection\", \"OrderHistoryProjection\"],\n      \"sagas\": [\"OrderFulfillmentSaga\"]\n    }\n  },\n  \"handlers\": {\n    \"PlaceOrderHandler\": {\n      \"handlerType\": \"Command\",\n      \"inputType\": \"PlaceOrder\",\n      \"outputTypes\": [\"OrderPlaced\"],\n      \"domain\": \"Orders\",\n      \"sourceLocation\": \"OrderService/Handlers/PlaceOrderHandler cs:15\"\n    }\n  },\n  \"projections\": {\n    \"OrderSummaryProjection\": {\n      \"projectionName\": \"order-summary\",\n      \"subscribedEvents\": [\"OrderPlaced\", \"OrderUpdated\", \"OrderShipped\"],\n      \"domain\": \"Orders\",\n      \"sourceLocation\": \"OrderService/Projections/OrderSummaryProjection cs:8\"\n    }\n  },\n  \"domains\": {\n    \"Orders\": {\n      \"commands\": [\"PlaceOrder\", \"UpdateOrder\", \"ShipOrder\"],\n      \"events\": [\"OrderPlaced\", \"OrderUpdated\", \"OrderShipped\"],\n      \"handlers\": [\"PlaceOrderHandler\", \"UpdateOrderHandler\"],\n      \"projections\": [\"OrderSummaryProjection\", \"OrderHistoryProjection\"]\n    }\n  }\n}\n`\nCode Analyzers & Fixes\nDomain Ownership Validation\nCompile-time enforcement of domain ownership rules:\n`csharp\n[DiagnosticAnalyzer(LanguageNames CSharp)]\npublic class DomainOwnershipAnalyzer : DiagnosticAnalyzer {\n    public static readonly DiagnosticDescriptor CrossDomainHandlerRule = new(\n        \"WB001\",\n        \"Handler cannot handle command/event from different domain\",\n        \"Handler '{0}' in domain '{1}' cannot handle '{2}' from domain '{3}'\",\n        \"Domain Ownership\",\n        DiagnosticSeverity Error,\n        isEnabledByDefault: true\n    );\n    public override void Initialize(AnalysisContext context) {\n        context RegisterSyntaxNodeAction(AnalyzeHandlerClass, SyntaxKind ClassDeclaration);\n    }\n    private void AnalyzeHandlerClass(SyntaxNodeAnalysisContext context) {\n        var classDeclaration = (ClassDeclarationSyntax)context Node;\n        var semanticModel = context SemanticModel;\n        var handlerDomain = GetHandlerDomain(classDeclaration, semanticModel);\n        var handledTypes = GetHandledTypes(classDeclaration, semanticModel);\n        foreach (var handledType in handledTypes) {\n            var messageDomain = GetMessageDomain(handledType, semanticModel);\n            if (handlerDomain = messageDomain) {\n                var diagnostic = Diagnostic Create(\n                    CrossDomainHandlerRule,\n                    classDeclaration GetLocation(),\n                    classDeclaration Identifier ValueText,\n                    handlerDomain,\n                    handledType",
        "startIndex": 6058,
        "preview": "async Task<CodeLens[]> ProvideCodeLensesAsync(Document document) { var semanticModel = await document GetSemanticModelAsync(); var root = await docume..."
      },
      {
        "id": "design/source-generation-ide-chunk-3",
        "text": "{ var classDeclaration = (ClassDeclarationSyntax)context Node; var semanticModel = context SemanticModel; var handlerDomain = GetHandlerDomain(classDeclaration, semanticModel); var handledTypes = GetHandledTypes(classDeclaration, semanticModel); foreach (var handledType in handledTypes) { var messageDomain = GetMessageDomain(handledType, semanticModel); if (handlerDomain = messageDomain) { var diagnostic = Diagnostic Create( CrossDomainHandlerRule, classDeclaration GetLocation(), classDeclaration Identifier ValueText, handlerDomain, handledType Name,\n                    messageDomain\n                );\n                context ReportDiagnostic(diagnostic);\n            }\n        }\n    }\n}\n`\nCode Fixes\nAutomatic fixes for common patterns:\n`csharp\n[ExportCodeFixProvider(LanguageNames CSharp)]\npublic class AddDomainOwnershipCodeFixProvider : CodeFixProvider {\n    public override async Task RegisterCodeFixesAsync(CodeFixContext context) {\n        var diagnostic = context Diagnostics FirstOrDefault(d => d Id == \"WB002\");\n        if (diagnostic == null) return;\n        var document = context Document;\n        var root = await document GetSyntaxRootAsync(context CancellationToken);\n        var declaration = root FindNode(diagnostic Location SourceSpan);\n        // Offer to add [OwnedBy] attribute\n        var codeAction = CodeAction Create(\n            title: \"Add [OwnedBy] attribute\",\n            createChangedDocument: c => AddOwnedByAttribute(document, declaration, c),\n            equivalenceKey: \"AddOwnedBy\"\n        );\n        context RegisterCodeFix(codeAction, diagnostic);\n    }\n    private async Task<Document> AddOwnedByAttribute(Document document, SyntaxNode declaration, CancellationToken cancellationToken) {\n        var root = await document GetSyntaxRootAsync(cancellationToken);\n        var inferredDomain = InferDomainFromNamespace(declaration);\n        var attribute = SyntaxFactory Attribute(\n            SyntaxFactory IdentifierName(\"OwnedBy\"),\n            SyntaxFactory AttributeArgumentList(\n                SyntaxFactory SingletonSeparatedList(\n                    SyntaxFactory AttributeArgument(\n                        SyntaxFactory LiteralExpression(SyntaxKind StringLiteralExpression, \n                            SyntaxFactory Literal(inferredDomain))\n                    )\n                )\n            )\n        );\n        var newDeclaration = AddAttributeToDeclaration(declaration, attribute);\n        var newRoot = root ReplaceNode(declaration, newDeclaration);\n        return document WithSyntaxRoot(newRoot);\n    }\n}\n`\nDebugging Integration\nTransparent Generated Code\nClear, debuggable generated code with source maps:\n`csharp\n// Generated handler registry with clear structure\n[GeneratedCode(\"Whizbang SourceGenerator\", \"1 0 0\")]\npublic static partial class OrderServiceHandlerRegistry {\n    // Source: OrderService/Handlers/PlaceOrderHandler cs\n    public static void RegisterPlaceOrderHandler(IServiceCollection services) {\n        services AddScoped<ICommandHandler<PlaceOrder>, PlaceOrderHandler>();\n        // Generated metadata for debugging\n        services AddSingleton(new HandlerMetadata {\n            HandlerType = typeof(PlaceOrderHandler),\n            MessageType = typeof(PlaceOrder),\n            SourceFile = \"OrderService/Handlers/PlaceOrderHandler cs\",\n            SourceLine = 15,\n            Domain = \"Orders\",\n            GeneratedAt = DateTimeOffset Parse(\"2024-01-01T10:00:00Z\")\n        });\n    }\n    // Source: OrderService/Projections/OrderSummaryProjection cs  \n    public static void RegisterOrderSummaryProjection(IServiceCollection services) {\n        services AddScoped<IProjectionHandler<OrderPlaced>, OrderSummaryProjection>();\n        services AddScoped<IProjectionHandler<OrderUpdated>, OrderSummaryProjection>();\n        services",
        "startIndex": 9257,
        "preview": "{ var classDeclaration = (ClassDeclarationSyntax)context Node; var semanticModel = context SemanticModel; var handlerDomain = GetHandlerDomain(classDe..."
      },
      {
        "id": "design/source-generation-ide-chunk-4",
        "text": "AddScoped<ICommandHandler<PlaceOrder>, PlaceOrderHandler>(); // Generated metadata for debugging services AddSingleton(new HandlerMetadata { HandlerType = typeof(PlaceOrderHandler), MessageType = typeof(PlaceOrder), SourceFile = \"OrderService/Handlers/PlaceOrderHandler cs\", SourceLine = 15, Domain = \"Orders\", GeneratedAt = DateTimeOffset Parse(\"2024-01-01T10:00:00Z\") }); } // Source: OrderService/Projections/OrderSummaryProjection cs public static void RegisterOrderSummaryProjection(IServiceCollection services) { services AddScoped<IProjectionHandler<OrderPlaced>, OrderSummaryProjection>(); services AddScoped<IProjectionHandler<OrderUpdated>, OrderSummaryProjection>(); services AddScoped<IProjectionHandler<OrderShipped>, OrderSummaryProjection>();\n        // Register projection metadata\n        services AddSingleton(new ProjectionMetadata {\n            ProjectionType = typeof(OrderSummaryProjection),\n            ProjectionName = \"order-summary\",\n            SubscribedEvents = new[] { typeof(OrderPlaced), typeof(OrderUpdated), typeof(OrderShipped) },\n            SourceFile = \"OrderService/Projections/OrderSummaryProjection cs\",\n            SourceLine = 8,\n            Domain = \"Orders\"\n        });\n    }\n}\n`\nDebug Experience Enhancements\nNo \"magic\" - clear understanding of what's happening:\n`csharp\n// Debug-friendly service registration\npublic static class WhizbangServiceCollectionExtensions {\n    public static IServiceCollection AddWhizbangGeneratedServices(this IServiceCollection services) {\n        if (IsDebugMode()) {\n            // In debug mode, show detailed registration logging\n            services AddSingleton<IHandlerRegistrationLogger, DetailedHandlerRegistrationLogger>();\n        }\n        // Call generated registration methods\n        OrderServiceHandlerRegistry RegisterAll(services);\n        return services;\n    }\n}\npublic class DetailedHandlerRegistrationLogger : IHandlerRegistrationLogger {\n    public void LogHandlerRegistration<TMessage, THandler>(string sourceFile, int sourceLine) {\n        Console WriteLine($\"Registering handler {typeof(THandler) Name} for {typeof(TMessage) Name}\");\n        Console WriteLine($\"  Source: {sourceFile}:{sourceLine}\");\n        Console WriteLine($\"  Service lifetime: Scoped\");\n    }\n}\n`\nPerformance Optimizations\nIncremental Generation\nOnly regenerate what changed for fast incremental builds:\n`csharp\npublic class IncrementalGenerationContext {\n    private readonly ConcurrentDictionary<string, string> _fileHashes = new();\n    public bool HasFileChanged(string filePath, string content) {\n        var currentHash = ComputeHash(content);\n        var previousHash = _fileHashes GetValueOrDefault(filePath);\n        if (currentHash",
        "startIndex": 12520,
        "preview": "AddScoped<ICommandHandler<PlaceOrder>, PlaceOrderHandler>(); // Generated metadata for debugging services AddSingleton(new HandlerMetadata { HandlerTy..."
      },
      {
        "id": "design/source-generation-ide-chunk-5",
        "text": "Console WriteLine($\" Service lifetime: Scoped\"); } } ` Performance Optimizations Incremental Generation Only regenerate what changed for fast incremental builds: `csharp public class IncrementalGenerationContext { private readonly ConcurrentDictionary<string, string> _fileHashes = new(); public bool HasFileChanged(string filePath, string content) { var currentHash = ComputeHash(content); var previousHash = _fileHashes GetValueOrDefault(filePath); if (currentHash = previousHash) {\n            _fileHashes[filePath] = currentHash;\n            return true;\n        }\n        return false;\n    }\n    public void TrackGeneratedOutput(string outputKey, string content) {\n        // Track what we generated so we can skip unchanged outputs\n        _generatedOutputs[outputKey] = ComputeHash(content);\n    }\n}\n`\nCompilation Performance\nOptimize for IDE experience:\nSyntax-only analysis for most validations\nSemantic analysis only when necessary\nCaching of expensive operations\nParallel processing of independent analysis\nEarly termination when errors are found\nBest Practices\nGenerator Design\nKeep generators focused - Single responsibility per generator stage\nMinimize semantic model usage - Use syntax analysis when possible\nCache expensive operations - Avoid redundant analysis\nProvide clear diagnostics - Help developers understand issues\nGenerate debuggable code - Include source references and metadata\nIDE Integration\nResponsive navigation - Fast lookups and searches\nContextual information - Show relevant details for current location\nClear visualizations - Easy to understand flow diagrams\nHelpful code lenses - Actionable information overlays\nIntelligent suggestions - Context-aware code completion\nDebug Experience\nNo hidden magic - Everything should be discoverable\nClear error messages - Point to exact problems and solutions\nSource mapping - Connect generated code to source\nMetadata preservation - Keep debug information through compilation\nPerformance transparency - Show timing and costs\n---\nRelated Documentation\nDomain Ownership - How ownership affects source generation\nPolicy Engine - Policy-based code generation\nFlags & Tags System - Cross-service context propagation\nTesting & Development Tools - Testing the generated code",
        "startIndex": 14549,
        "preview": "Console WriteLine($\" Service lifetime: Scoped\"); } } ` Performance Optimizations Incremental Generation Only regenerate what changed for fast incremen..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "design/testing-development-tools",
    "title": "Testing & Development Tools",
    "category": "Architecture & Design",
    "url": "/docs/design/testing-development-tools",
    "chunks": [
      {
        "id": "design/testing-development-tools-chunk-0",
        "text": "Testing & Development Tools\nWhizbang provides comprehensive testing utilities and development tools to ensure a productive developer experience from local development to production deployment Testing Framework\nWhizbang Testing Package\nComprehensive testing library with fluent APIs for all Whizbang scenarios:\n`csharp\n// Install the testing package\ndotnet add package Whizbang Testing\n// Test fixture setup\npublic class OrderServiceTests {\n    private readonly WhizbangTestFixture _fixture;\n    public OrderServiceTests() {\n        _fixture = new WhizbangTestFixture() UseInMemoryEventStore() UseInMemoryProjections() UseInMemoryMessageBroker() ConfigureServices(services => {\n                services AddScoped<IOrderService, OrderService>();\n                services AddScoped<ICustomerService, MockCustomerService>();\n            });\n    }\n}\n`\nEvent Sourcing Test Helpers\nGiven/When/Then fluent API for event sourcing scenarios:\n`csharp\n[Test]\npublic async Task PlaceOrder_WithValidCustomer_ShouldEmitOrderPlaced() {\n    // Arrange & Act & Assert in fluent chain\n    await _fixture Given(\n            new CustomerRegistered(customerId, \"John Doe\", \"john@example com\"),\n            new ProductCreated(productId, \"Widget\", 10 00m)\n        ) When(new PlaceOrder(orderId, customerId, new[] { \n            new OrderItem(productId, 2, 10 00m) \n        })) Then() ShouldEmitEvent<OrderPlaced>() WithProperty(e => e OrderId, orderId) WithProperty(e => e CustomerId, customerId) WithProperty(e => e Total, 20 00m) And() ShouldNotEmitEvent<OrderRejected>();\n}\n[Test]\npublic async Task PlaceOrder_WithInvalidCustomer_ShouldEmitOrderRejected() {\n    await _fixture Given() // No customer registered When(new PlaceOrder(orderId, customerId, items)) Then() ShouldEmitEvent<OrderRejected>() WithProperty(e => e Reason, \"Customer not found\") And() ShouldNotEmitEvent<OrderPlaced>();\n}\n`\nProjection Testing\nFeed events and assert projection state:\n`csharp\n[Test]\npublic async Task OrderSummaryProjection_ShouldTrackOrderLifecycle() {\n    await _fixture ForProjection<OrderSummaryProjection>() GivenEvents(\n            new OrderPlaced(orderId, customerId, 100 00m, DateTimeOffset UtcNow),\n            new OrderShipped(orderId, \"TRACK123\", DateTimeOffset UtcNow AddDays(1))\n        ) WhenProjectionRuns() ThenProjection<OrderSummary>(orderId ToString()) ShouldExist() ShouldHaveProperty(s => s Status, OrderStatus Shipped) ShouldHaveProperty(s => s Total, 100 00m) ShouldHaveProperty(s => s TrackingNumber, \"TRACK123\");\n}\n[Test]\npublic async Task OrderSummaryProjection_WithMissingEvents_ShouldHandleGracefully() {\n    await _fixture ForProjection<OrderSummaryProjection>() GivenEvents(\n            new OrderShipped(orderId, \"TRACK123\", DateTimeOffset UtcNow) // No OrderPlaced\n        ) WhenProjectionRuns() ThenProjection<OrderSummary>(orderId ToString()) ShouldNotExist(); // Projection should handle missing OrderPlaced gracefully\n}\n`\nPolicy Testing\nTest policy rules and combinations:\n`csharp\n[Test]\npublic async Task LoadTestingPolicy_ShouldSkipProjections() {\n    await _fixture ForPolicy(\"LoadTestingPolicy\") GivenContext(ctx => ctx WithFlag(WhizbangFlags LoadTesting))",
        "startIndex": 0,
        "preview": "Testing & Development Tools\nWhizbang provides comprehensive testing utilities and development tools to ensure a productive developer experience from l..."
      },
      {
        "id": "design/testing-development-tools-chunk-1",
        "text": "OrderSummaryProjection_WithMissingEvents_ShouldHandleGracefully() { await _fixture ForProjection<OrderSummaryProjection>() GivenEvents( new OrderShipped(orderId, \"TRACK123\", DateTimeOffset UtcNow) // No OrderPlaced ) WhenProjectionRuns() ThenProjection<OrderSummary>(orderId ToString()) ShouldNotExist(); // Projection should handle missing OrderPlaced gracefully } ` Policy Testing Test policy rules and combinations: `csharp [Test] public async Task LoadTestingPolicy_ShouldSkipProjections() { await _fixture ForPolicy(\"LoadTestingPolicy\") GivenContext(ctx => ctx WithFlag(WhizbangFlags LoadTesting)) GivenMessage(new OrderPlaced(orderId, customerId, 100 00m)) WhenPolicyEvaluates() ThenActions() ShouldContain<SkipProjectionsAction>() ShouldContain<AddTagAction>(action => action Tag == \"load-test-processed\");\n}\n[Test]\npublic async Task VIPCustomerPolicy_ShouldRouteToSpecialHandler() {\n    await _fixture ForPolicy(\"VIPCustomerPolicy\") GivenContext(ctx => ctx WithTag(\"customer-vip\")) GivenMessage(new PlaceOrder(orderId, customerId, items)) WhenPolicyEvaluates() ThenActions() ShouldContain<RouteToHandlerAction<VIPOrderHandler>>();\n}\n`\nSaga Testing\nTest long-running process coordination:\n`csharp\n[Test]\npublic async Task OrderFulfillmentSaga_ShouldCoordinateFullWorkflow() {\n    await _fixture ForSaga<OrderFulfillmentSaga>() GivenEvents(\n            new OrderPlaced(orderId, customerId, items)\n        ) WhenSagaRuns() ThenCommands() ShouldContain<ReserveInventory>(cmd => cmd OrderId == orderId) And() WhenEvent(new InventoryReserved(orderId, items)) ThenCommands() ShouldContain<ChargePayment>(cmd => cmd OrderId == orderId) And() WhenEvent(new PaymentCharged(orderId, 100 00m)) ThenCommands() ShouldContain<ShipOrder>(cmd => cmd OrderId == orderId);\n}\n`\nIntegration Testing\nReal drivers with test containers:\n`csharp\n[Test]\npublic async Task OrderService_IntegrationTest_WithRealDatabase() {\n    // Uses TestContainers for real PostgreSQL\n    await using var fixture = new WhizbangIntegrationTestFixture() UseTestContainerPostgres() UseTestContainerKafka() ConfigureServices(services => {\n            services AddOrderService();\n            services AddInventoryService();\n        });\n    await fixture StartAsync();\n    // Test with real infrastructure\n    var result = await fixture Given(/ setup data in real database /) When(new PlaceOrder(orderId, customerId, items)) Then() ShouldEmitEvent<OrderPlaced>() And() ShouldHaveProjection<OrderSummary>(orderId ToString()) InDatabase(); // Verify in real database\n}\n`\nDevelopment Tools Suite\nCLI Tool (whizbang-cli)\nComprehensive command-line interface for project management:\n`bash\nProject scaffolding\nwhizbang new --template microservice --name OrderService\nwhizbang new --template monolith --name ECommerceApp\nwhizbang new --template projection-worker --name AnalyticsWorker\nCode generation\nwhizbang add command --name PlaceOrder --domain Orders\nwhizbang add event --name OrderPlaced --domain Orders  \nwhizbang add projection --name OrderSummary --events OrderPlaced,OrderShipped\nwhizbang add saga --name OrderFulfillment --triggers OrderPlaced\nDevelopment utilities\nwhizbang validate --project /OrderService --check-ownership\nwhizbang generate --project /OrderService --watch\nwhizbang dashboard --port 5000 --project",
        "startIndex": 3503,
        "preview": "OrderSummaryProjection_WithMissingEvents_ShouldHandleGracefully() { await _fixture ForProjection<OrderSummaryProjection>() GivenEvents( new OrderShipp..."
      },
      {
        "id": "design/testing-development-tools-chunk-2",
        "text": "projection-worker --name AnalyticsWorker Code generation whizbang add command --name PlaceOrder --domain Orders whizbang add event --name OrderPlaced --domain Orders whizbang add projection --name OrderSummary --events OrderPlaced,OrderShipped whizbang add saga --name OrderFulfillment --triggers OrderPlaced Development utilities whizbang validate --project /OrderService --check-ownership whizbang generate --project /OrderService --watch whizbang dashboard --port 5000 --project /OrderService\nEvent store utilities\nwhizbang events list --stream \"Order-*\" --from 2024-01-01\nwhizbang events replay --stream \"Order-123\" --to-projection OrderSummary\nwhizbang events export --stream \"Order-*\" --format json --output orders json\nMigration utilities\nwhizbang migrate --from 1 0 --to 2 0 --dry-run\nwhizbang migrate --apply --backup\n`\nCLI Implementation Architecture\n`csharp\n// CLI command structure\n[Command(\"whizbang\")]\npublic class WhizbangCliCommand {\n    [Command(\"new\")]\n    public class NewCommand {\n        [Option(\"--template\", Description = \"Project template\")]\n        public string Template { get; set; } = \"microservice\";\n        [Option(\"--name\", Description = \"Project name\")]\n        public string Name { get; set; }\n        public async Task<int> ExecuteAsync() {\n            var templateEngine = new ProjectTemplateEngine();\n            await templateEngine CreateProjectAsync(Template, Name);\n            return 0;\n        }\n    }\n    [Command(\"add\")]\n    public class AddCommand {\n        [Command(\"command\")]\n        public class AddCommandCommand {\n            [Option(\"--name\")] public string Name { get; set; }\n            [Option(\"--domain\")] public string Domain { get; set; }\n            public async Task<int> ExecuteAsync() {\n                var generator = new CodeGenerator();\n                await generator GenerateCommandAsync(Name, Domain);\n                return 0;\n            }\n        }\n    }\n}\n`\nVisual Studio Integration\nTemplates and extensions for rapid development:\n`xml\n< -- dotnet new templates -->\n<Project Sdk=\"Microsoft NET Sdk\">\n  <PropertyGroup>\n    <PackageType>Template</PackageType>\n    <PackageVersion>1 0 0</PackageVersion>\n    <PackageId>Whizbang",
        "startIndex": 6482,
        "preview": "projection-worker --name AnalyticsWorker Code generation whizbang add command --name PlaceOrder --domain Orders whizbang add event --name OrderPlaced ..."
      },
      {
        "id": "design/testing-development-tools-chunk-3",
        "text": "get; set; } public async Task<int> ExecuteAsync() { var generator = new CodeGenerator(); await generator GenerateCommandAsync(Name, Domain); return 0; } } } } ` Visual Studio Integration Templates and extensions for rapid development: `xml < -- dotnet new templates --> <Project Sdk=\"Microsoft NET Sdk\"> <PropertyGroup> <PackageType>Template</PackageType> <PackageVersion>1 0 0</PackageVersion> <PackageId>Whizbang Templates</PackageId>\n    <Title>Whizbang Project Templates</Title>\n    <Description>Templates for Whizbang applications</Description>\n    <IncludeContentInPack>true</IncludeContentInPack>\n    <IncludeBuildOutput>false</IncludeBuildOutput>\n    <ContentTargetFolders>content</ContentTargetFolders>\n  </PropertyGroup>\n</Project>\n`\nLive Templates for common patterns:\n`csharp\n// Command template\npublic record $COMMAND_NAME$(\n    $PARAMETERS$\n) : ICommand;\n// Event template  \npublic record $EVENT_NAME$(\n    $PARAMETERS$\n) : IEvent;\n// Handler template\npublic class $HANDLER_NAME$ : ICommandHandler<$COMMAND_TYPE$> {\n    public async Task<IEvent[]> Handle($COMMAND_TYPE$ command) {\n        $HANDLER_LOGIC$\n        return new IEvent[] {\n            new $EVENT_TYPE$($EVENT_PARAMETERS$)\n        };\n    }\n}\n// Projection template\npublic class $PROJECTION_NAME$ : IProjectionHandler<$EVENT_TYPE$> {\n    public async Task Handle($EVENT_TYPE$ @event, ProjectionContext context) {\n        var projection = await context Load<$PROJECTION_MODEL$>(@event $KEY_FIELD$ ToString()) new $PROJECTION_MODEL$ { $KEY_FIELD$ = @event $KEY_FIELD$ };\n        $PROJECTION_LOGIC$\n        await context Store(@event $KEY_FIELD$ ToString(), projection);\n    }\n}\n`\nWeb Dashboard\nReal-time monitoring and debugging interface:\n`csharp\n// Dashboard startup\npublic class WhizbangDashboard {\n    public static void ConfigureDashboard(WebApplicationBuilder builder) {\n        builder Services AddWhizbangDashboard(options => {\n            options EnableRealTimeUpdates = true;\n            options EventRetentionHours = 24;\n            options ProjectionLagAlertThreshold = TimeSpan FromMinutes(5);\n        });\n    }\n    public static void MapDashboardEndpoints(WebApplication app) {\n        app MapWhizbangDashboard(\"/dashboard\");\n        // API endpoints for dashboard\n        app MapGet(\"/api/whizbang/projections\", GetProjectionStatus);\n        app MapGet(\"/api/whizbang/events/{streamId}\", GetEventStream);\n        app MapPost(\"/api/whizbang/replay\", TriggerReplay);\n        app MapGet(\"/api/whizbang/policies\", GetActivePolicies);\n        app",
        "startIndex": 8198,
        "preview": "get; set; } public async Task<int> ExecuteAsync() { var generator = new CodeGenerator(); await generator GenerateCommandAsync(Name, Domain); return 0;..."
      },
      {
        "id": "design/testing-development-tools-chunk-4",
        "text": "void ConfigureDashboard(WebApplicationBuilder builder) { builder Services AddWhizbangDashboard(options => { options EnableRealTimeUpdates = true; options EventRetentionHours = 24; options ProjectionLagAlertThreshold = TimeSpan FromMinutes(5); }); } public static void MapDashboardEndpoints(WebApplication app) { app MapWhizbangDashboard(\"/dashboard\"); // API endpoints for dashboard app MapGet(\"/api/whizbang/projections\", GetProjectionStatus); app MapGet(\"/api/whizbang/events/{streamId}\", GetEventStream); app MapPost(\"/api/whizbang/replay\", TriggerReplay); app MapGet(\"/api/whizbang/policies\", GetActivePolicies); app MapPost(\"/api/whizbang/policies/test\", TestPolicy);\n    }\n}\n`\nDashboard Features:\nReal-time Projection Monitoring\nProjection lag visualization\nEvent processing rates\nError rates and alerts\nCheckpoint status\nEvent Stream Visualization\nStream browsing and filtering\nEvent details and metadata\nCross-stream correlation\nFlow diagrams\nPolicy Rule Testing\nPolicy condition testing\nAction preview\nRule combination visualization\nPerformance impact analysis\nPerformance Metrics\nHandler execution times\nThroughput measurements\nResource utilization\nBottleneck identification\nIDE Extensions\nVisual Studio Code Extension with advanced features:\n`typescript\n// VSCode extension main functionality\nexport function activate(context: vscode ExtensionContext) {\n    // Register command for event stream navigation\n    const navigateCommand = vscode commands registerCommand(\n        'whizbang navigateEventStream',\n        async () => {\n            const streamId = await vscode window showInputBox({\n                prompt: 'Enter stream ID or pattern'\n            });\n            if (streamId) {\n                const events = await whizbangService getEventStream(streamId);\n                showEventStreamPanel(events);\n            }\n        }\n    );\n    // Register hover provider for command/event info\n    const hoverProvider = vscode languages registerHoverProvider(\n        'csharp',\n        new WhizbangHoverProvider()\n    );\n    // Register code lens provider for handler flow\n    const codeLensProvider = vscode languages registerCodeLensProvider(\n        'csharp',\n        new WhizbangCodeLensProvider()\n    );\n    context subscriptions push(navigateCommand, hoverProvider, codeLensProvider);\n}\nclass WhizbangHoverProvider implements vscode HoverProvider {\n    async provideHover(document: vscode TextDocument, position: vscode Position): Promise<vscode Hover | undefined> {\n        const word = document getWordRangeAtPosition(position);\n        if ( word) return;\n        const wordText = document getText(word);\n        // Check if it's a Whizbang command/event\n        const metadata = await whizbangService getTypeMetadata(wordText);\n        if (metadata) {\n            const contents = new vscode MarkdownString();\n            contents appendMarkdown(${metadata type}: ${metadata name}\\n\\n);\n            contents appendMarkdown(Domain: ${metadata domain}\\n\\n);\n            if (metadata handlers) {\n                contents appendMarkdown(Handlers:\\n);\n                metadata handlers forEach(h => {\n                    contents appendMarkdown(- ${h name} (${h",
        "startIndex": 10339,
        "preview": "void ConfigureDashboard(WebApplicationBuilder builder) { builder Services AddWhizbangDashboard(options => { options EnableRealTimeUpdates = true; opti..."
      },
      {
        "id": "design/testing-development-tools-chunk-5",
        "text": "= document getText(word); // Check if it's a Whizbang command/event const metadata = await whizbangService getTypeMetadata(wordText); if (metadata) { const contents = new vscode MarkdownString(); contents appendMarkdown(${metadata type}: ${metadata name}\\n\\n); contents appendMarkdown(Domain: ${metadata domain}\\n\\n); if (metadata handlers) { contents appendMarkdown(Handlers:\\n); metadata handlers forEach(h => { contents appendMarkdown(- ${h name} (${h domain})\\n);\n                });\n            }\n            return new vscode Hover(contents, word);\n        }\n    }\n}\n`\nIn-Memory Drivers for Testing\nFast Unit Test Infrastructure\nOptimized in-memory implementations for rapid testing:\n`csharp\n// In-memory event store\npublic class InMemoryEventStore : IEventStoreDriver {\n    private readonly ConcurrentDictionary<string, List<StoredEvent>> _streams = new();\n    public async Task AppendEventsAsync(string streamId, IEnumerable<IEvent> events, int expectedVersion) {\n        var streamEvents = _streams GetOrAdd(streamId, _ => new List<StoredEvent>());\n        lock (streamEvents) {\n            if (streamEvents Count = expectedVersion) {\n                throw new ConcurrencyException(streamId, expectedVersion, streamEvents Count);\n            }\n            foreach (var @event in events) {\n                streamEvents Add(new StoredEvent {\n                    StreamId = streamId,\n                    EventId = Guid NewGuid(),\n                    EventType = @event GetType() Name,\n                    EventData = JsonSerializer Serialize(@event),\n                    Version = streamEvents Count + 1,\n                    Timestamp = DateTimeOffset UtcNow\n                });\n            }\n        }\n    }\n    public async Task<IEnumerable<StoredEvent>> ReadEventsAsync(string streamId, int fromVersion = 0) {\n        var streamEvents = _streams GetOrAdd(streamId, _ => new List<StoredEvent>());\n        return streamEvents Where(e => e Version > fromVersion) ToList();\n    }\n}\n// In-memory projection store\npublic class InMemoryProjectionStore : IProjectionDriver {\n    private readonly ConcurrentDictionary<string, Dictionary<string, object>> _projections = new();\n    public async Task Store<T>(string projectionName, string documentId, T document, string tenantId = null) {\n        var key = tenantId = null $\"{projectionName}_{tenantId}\" : projectionName;\n        var projectionData = _projections GetOrAdd(key, _ => new Dictionary<string, object>());\n        lock (projectionData) {\n            projectionData[documentId] = document;\n        }\n    }\n    public async Task<T > Load<T>(string projectionName, string documentId, string tenantId = null) {\n        var key = tenantId = null $\"{projectionName}_{tenantId}\" : projectionName;\n        if (_projections TryGetValue(key, out var projectionData)) {\n            lock (projectionData) {\n                if (projectionData",
        "startIndex": 12901,
        "preview": "= document getText(word); // Check if it's a Whizbang command/event const metadata = await whizbangService getTypeMetadata(wordText); if (metadata) { ..."
      },
      {
        "id": "design/testing-development-tools-chunk-6",
        "text": "= _projections GetOrAdd(key, _ => new Dictionary<string, object>()); lock (projectionData) { projectionData[documentId] = document; } } public async Task<T > Load<T>(string projectionName, string documentId, string tenantId = null) { var key = tenantId = null $\"{projectionName}_{tenantId}\" : projectionName; if (_projections TryGetValue(key, out var projectionData)) { lock (projectionData) { if (projectionData TryGetValue(documentId, out var document)) {\n                    return (T)document;\n                }\n            }\n        }\n        return default(T);\n    }\n}\n`\nTesting Best Practices\nTest Organization\nSeparate test categories:\nUnit tests - Fast, isolated, use in-memory drivers\nIntegration tests - Real infrastructure with test containers\nEnd-to-end tests - Full system testing\nPerformance tests - Load and stress testing\nTest data management:\nBuilders for complex test data construction\nFixtures for reusable test scenarios\nCleanup strategies for integration tests\nAssertion patterns:\nFluent assertions for readability\nCustom matchers for domain concepts\nError scenarios testing\nDevelopment Workflow\nTDD-friendly - Tests before implementation\nFast feedback - Sub-second unit test execution\nIDE integration - Run tests from code editor\nContinuous testing - Watch mode for automatic test runs\nCoverage tracking - Identify untested code paths\n---\nRelated Documentation\nSource Generation & IDE Integration - How testing integrates with generated code\nPolicy Engine - Testing policy rules and combinations\nFlags & Tags System - Cross-service context propagation\nObservability & Metrics - Testing observability features",
        "startIndex": 15345,
        "preview": "= _projections GetOrAdd(key, _ => new Dictionary<string, object>()); lock (projectionData) { projectionData[documentId] = document; } } public async T..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "examples/enhanced-csharp-examples",
    "title": "C# Code Examples",
    "category": "Examples",
    "url": "/docs/examples/enhanced-csharp-examples",
    "chunks": [
      {
        "id": "examples/enhanced-csharp-examples-chunk-0",
        "text": "CCode Examples\nThis document demonstrates comprehensive Ccode examples with rich metadata, interactive features, and professional styling Basic Examples\nSimple Console Application\n`csharp{\ntitle: \"Hello World Console App\"\ndescription: \"A simple console application demonstrating basic Csyntax\"\nframework: \"NET8\"\ndifficulty: \"BEGINNER\"\nfilename: \"Program cs\"\n}\nusing System;\nnamespace HelloWorld {\n    class Program {\n        static void Main(string[] args) {\n            Console WriteLine(\"Hello, World \");\n            Console WriteLine(\"Welcome to enhanced Ccode viewing \");\n            var message = GetWelcomeMessage(\"Developer\");\n            Console WriteLine(message);\n        }\n        static string GetWelcomeMessage(string name) {\n            return $\"Hello, {name} Today is {DateTime Now:yyyy-MM-dd}\";\n        }\n    }\n}\n`\nBasic Class Example\n`csharp{\ntitle: \"Person Class\"\ndescription: \"Simple class with properties and methods\"\ncategory: \"ENTITY\"\ndifficulty: \"BEGINNER\"\ntags: [\"Class\", \"Properties\", \"Methods\"]\nfilename: \"Person cs\"\n}\npublic class Person {\n    public string Name { get; set; }\n    public int Age { get; set; }\n    public string Email { get; set; }\n    public Person(string name, int age, string email) {\n        Name = name;\n        Age = age;\n        Email = email;\n    }\n    public void DisplayInfo() {\n        Console WriteLine($\"Name: {Name}\");\n        Console WriteLine($\"Age: {Age}\");\n        Console WriteLine($\"Email: {Email}\");\n    }\n    public bool IsAdult() {\n        return Age >= 18;\n    }\n}\n`\nNuGet Package Example\n`csharp{\ntitle: \"JSON Serialization Example\"\ndescription: \"Using Newtonsoft Json for JSON operations\"\nframework: \"NET8\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"JSON\", \"Serialization\", \"NuGet\"]\nnugetPackages: [\"Newtonsoft Json\"]\nfilename: \"JsonExample cs\"\n}\nusing Newtonsoft Json;\nusing System Collections Generic;\npublic class JsonExample {\n    public void SerializeExample() {\n        var person = new Person(\"John Doe\", 30, \"john@example com\");\n        // Serialize to JSON\n        string json = JsonConvert SerializeObject(person, Formatting Indented);\n        Console WriteLine(\"Serialized JSON:\");\n        Console WriteLine(json);\n        // Deserialize from JSON\n        var deserializedPerson = JsonConvert DeserializeObject<Person>(json);\n        Console WriteLine(\"\\nDeserialized object:\");\n        deserializedPerson",
        "startIndex": 0,
        "preview": "CCode Examples\nThis document demonstrates comprehensive Ccode examples with rich metadata, interactive features, and professional styling Basic Exampl..."
      },
      {
        "id": "examples/enhanced-csharp-examples-chunk-1",
        "text": "using System Collections Generic; public class JsonExample { public void SerializeExample() { var person = new Person(\"John Doe\", 30, \"john@example com\"); // Serialize to JSON string json = JsonConvert SerializeObject(person, Formatting Indented); Console WriteLine(\"Serialized JSON:\"); Console WriteLine(json); // Deserialize from JSON var deserializedPerson = JsonConvert DeserializeObject<Person>(json); Console WriteLine(\"\\nDeserialized object:\"); deserializedPerson DisplayInfo();\n    }\n}\n`\nAdvanced Examples\nBasic API Controller Example\n`csharp{\ntitle: \"User Management API Controller\"\ndescription: \"A comprehensive REST API controller for user management with CRUD operations\"\nframework: \"NET8\"\ncategory: \"API\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Web API\", \"REST\", \"CRUD\", \"Authentication\"]\ngithubUrl: \"https://github com/example/user-api\"\ndocsUrl: \"https://docs microsoft com/aspnet/core/web-api\"\nnugetPackages: [\"Microsoft AspNetCore Mvc\", \"Microsoft EntityFrameworkCore\", \"Microsoft AspNetCore Authorization\"]\nfilename: \"UserController cs\"\nshowLineNumbers: true\nshowLinesOnly: [1, 2, 3, 8, 9, 12, 13, 14, 15, 18, 19] \nhighlightLines: [12, 15, 28, 45]\nusingStatements: [\"Microsoft AspNetCore Mvc\", \"Microsoft EntityFrameworkCore\", \"Microsoft AspNetCore Authorization\", \"System Threading Tasks\", \"System Collections Generic\"]\n}\nusing Microsoft AspNetCore Mvc;\nusing Microsoft EntityFrameworkCore;\nusing Microsoft AspNetCore Authorization;\nnamespace UserManagement Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public class UserController : ControllerBase\n    {\n        private readonly UserDbContext _context;\n        private readonly ILogger<UserController> _logger;\n        public UserController(UserDbContext context, ILogger<UserController> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n        [HttpGet]\n        public async Task<ActionResult<IEnumerable<UserDto>>> GetUsers()\n        {\n            try\n            {\n                var users = await _context Users Where(u => u IsActive) Select(u => new UserDto\n                    {\n                        Id = u Id,\n                        Name = u Name,\n                        Email = u Email,\n                        CreatedAt = u CreatedAt\n                    }) ToListAsync();\n                return Ok(users);\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error retrieving users\");\n                return StatusCode(500, \"Internal server error\");\n            }\n        }\n        [HttpGet(\"{id}\")]\n        public async Task<ActionResult<UserDto>> GetUser(int id)\n        {\n            var user = await _context Users FindAsync(id);\n            if (user == null)\n            {\n                return NotFound($\"User with ID {id} not found\");\n            }\n            return Ok(new UserDto\n            {\n                Id = user Id,\n                Name = user Name,\n                Email = user Email,\n                CreatedAt = user",
        "startIndex": 2380,
        "preview": "using System Collections Generic; public class JsonExample { public void SerializeExample() { var person = new Person(\"John Doe\", 30, \"john@example co..."
      },
      {
        "id": "examples/enhanced-csharp-examples-chunk-2",
        "text": "server error\"); } } [HttpGet(\"{id}\")] public async Task<ActionResult<UserDto>> GetUser(int id) { var user = await _context Users FindAsync(id); if (user == null) { return NotFound($\"User with ID {id} not found\"); } return Ok(new UserDto { Id = user Id, Name = user Name, Email = user Email, CreatedAt = user CreatedAt\n            });\n        }\n        [HttpPost]\n        public async Task<ActionResult<UserDto>> CreateUser([FromBody] CreateUserRequest request)\n        {\n            if ( ModelState IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n            var user = new User\n            {\n                Name = request Name,\n                Email = request Email,\n                CreatedAt = DateTime UtcNow,\n                IsActive = true\n            };\n            _context Users Add(user);\n            await _context SaveChangesAsync();\n            var userDto = new UserDto\n            {\n                Id = user Id,\n                Name = user Name,\n                Email = user Email,\n                CreatedAt = user CreatedAt\n            };\n            return CreatedAtAction(nameof(GetUser), new { id = user Id }, userDto);\n        }\n    }\n}\n`\nEntity Framework Model Example\n`csharp{\ntitle: \"User Entity Model\"\ndescription: \"Entity Framework model with relationships and validation attributes\"\nframework: \"NET8\"\ncategory: \"ENTITY\"\ndifficulty: \"BEGINNER\"\ntags: [\"Entity Framework\", \"Models\", \"Data Annotations\"]\nnugetPackages: [\"Microsoft EntityFrameworkCore\", \"System ComponentModel Annotations\"]\nfilename: \"User cs\"\n}\nusing System ComponentModel DataAnnotations;\nusing System ComponentModel DataAnnotations Schema;\nnamespace UserManagement Models\n{\n    [Table(\"Users\")]\n    public class User\n    {\n        [Key]\n        [DatabaseGenerated(DatabaseGeneratedOption Identity)]\n        public int Id { get; set; }\n        [Required]\n        [StringLength(100, MinimumLength = 2)]\n        public string Name { get; set; } = string Empty;\n        [Required]\n        [EmailAddress]\n        [StringLength(255)]\n        public string Email { get; set; } = string Empty;\n        [Required]\n        public DateTime CreatedAt { get; set; }\n        public DateTime",
        "startIndex": 5016,
        "preview": "server error\"); } } [HttpGet(\"{id}\")] public async Task<ActionResult<UserDto>> GetUser(int id) { var user = await _context Users FindAsync(id); if (us..."
      },
      {
        "id": "examples/enhanced-csharp-examples-chunk-3",
        "text": "User { [Key] [DatabaseGenerated(DatabaseGeneratedOption Identity)] public int Id { get; set; } [Required] [StringLength(100, MinimumLength = 2)] public string Name { get; set; } = string Empty; [Required] [EmailAddress] [StringLength(255)] public string Email { get; set; } = string Empty; [Required] public DateTime CreatedAt { get; set; } public DateTime UpdatedAt { get; set; }\n        [Required]\n        public bool IsActive { get; set; } = true;\n        // Navigation properties\n        public virtual ICollection<UserRole> UserRoles { get; set; } = new List<UserRole>();\n        public virtual ICollection<UserProfile> UserProfiles { get; set; } = new List<UserProfile>();\n    }\n    public class UserDto\n    {\n        public int Id { get; set; }\n        public string Name { get; set; } = string Empty;\n        public string Email { get; set; } = string Empty;\n        public DateTime CreatedAt { get; set; }\n    }\n    public class CreateUserRequest\n    {\n        [Required]\n        [StringLength(100, MinimumLength = 2)]\n        public string Name { get; set; } = string Empty;\n        [Required]\n        [EmailAddress]\n        public string Email { get; set; } = string Empty;\n    }\n}\n`\nAdvanced Service Pattern Example\n`csharp{\ntitle: \"User Service with Repository Pattern\"\ndescription: \"Implementation of service layer with dependency injection and error handling\"\nframework: \"NET8\"\ncategory: \"SERVICE\"\ndifficulty: \"ADVANCED\"\ntags: [\"Service Pattern\", \"Repository\", \"Dependency Injection\", \"Error Handling\"]\ngithubUrl: \"https://github com/example/user-service\"\nnugetPackages: [\"Microsoft Extensions Logging\", \"AutoMapper\"]\nfilename: \"UserService cs\"\nshowLinesOnly: [1, 2, 3, 4, 9, 10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 24, 25]\ncollapsible: false\n}\nusing AutoMapper;\nusing Microsoft Extensions Logging;\nusing UserManagement Models;\nusing UserManagement Repositories;\nusing UserManagement Exceptions;\nnamespace UserManagement Services\n{\n    public interface IUserService\n    {\n        Task<IEnumerable<UserDto>> GetAllUsersAsync();\n        Task<UserDto > GetUserByIdAsync(int id);\n        Task<UserDto> CreateUserAsync(CreateUserRequest request);\n        Task<UserDto",
        "startIndex": 6914,
        "preview": "User { [Key] [DatabaseGenerated(DatabaseGeneratedOption Identity)] public int Id { get; set; } [Required] [StringLength(100, MinimumLength = 2)] publi..."
      },
      {
        "id": "examples/enhanced-csharp-examples-chunk-4",
        "text": "4, 9, 10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 24, 25] collapsible: false } using AutoMapper; using Microsoft Extensions Logging; using UserManagement Models; using UserManagement Repositories; using UserManagement Exceptions; namespace UserManagement Services { public interface IUserService { Task<IEnumerable<UserDto>> GetAllUsersAsync(); Task<UserDto > GetUserByIdAsync(int id); Task<UserDto> CreateUserAsync(CreateUserRequest request); Task<UserDto > UpdateUserAsync(int id, UpdateUserRequest request);\n        Task<bool> DeleteUserAsync(int id);\n        Task<bool> UserExistsAsync(string email);\n    }\n    public class UserService : IUserService\n    {\n        private readonly IUserRepository _userRepository;\n        private readonly IMapper _mapper;\n        private readonly ILogger<UserService> _logger;\n        public UserService(\n            IUserRepository userRepository,\n            IMapper mapper,\n            ILogger<UserService> logger)\n        {\n            _userRepository = userRepository throw new ArgumentNullException(nameof(userRepository));\n            _mapper = mapper throw new ArgumentNullException(nameof(mapper));\n            _logger = logger throw new ArgumentNullException(nameof(logger));\n        }\n        public async Task<IEnumerable<UserDto>> GetAllUsersAsync()\n        {\n            try\n            {\n                _logger LogInformation(\"Retrieving all active users\");\n                var users = await _userRepository GetActiveUsersAsync();\n                var userDtos = _mapper Map<IEnumerable<UserDto>>(users);\n                _logger LogInformation(\"Retrieved {UserCount} active users\", users Count());\n                return userDtos;\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error occurred while retrieving users\");\n                throw new ServiceException(\"Failed to retrieve users\", ex);\n            }\n        }\n        public async Task<UserDto > GetUserByIdAsync(int id)\n        {\n            try\n            {\n                _logger LogInformation(\"Retrieving user with ID: {UserId}\", id);\n                var user = await _userRepository GetByIdAsync(id);\n                if (user == null)\n                {\n                    _logger LogWarning(\"User with ID {UserId} not found\", id);\n                    return null;\n                }\n                var userDto = _mapper Map<UserDto>(user);\n                _logger LogInformation(\"Successfully retrieved user: {UserEmail}\", user Email);\n                return userDto;\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error occurred while retrieving user with ID: {UserId}\", id);\n                throw new ServiceException($\"Failed to retrieve user with ID: {id}\", ex);\n            }\n        }\n        public async Task<UserDto> CreateUserAsync(CreateUserRequest request)\n        {\n            try\n            {\n                _logger LogInformation(\"Creating new user with email: {Email}\", request Email);\n                // Check if user already exists\n                if (await UserExistsAsync(request Email))\n                {\n                    throw new DuplicateUserException($\"User with email {request Email} already exists\");\n                }\n                var user = _mapper Map<User>(request);\n                user CreatedAt = DateTime UtcNow;\n                user IsActive = true;\n                var createdUser = await _userRepository",
        "startIndex": 8735,
        "preview": "4, 9, 10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 24, 25] collapsible: false } using AutoMapper; using Microsoft Extensions Logging; using UserManagement ..."
      },
      {
        "id": "examples/enhanced-csharp-examples-chunk-5",
        "text": "{ _logger LogInformation(\"Creating new user with email: {Email}\", request Email); // Check if user already exists if (await UserExistsAsync(request Email)) { throw new DuplicateUserException($\"User with email {request Email} already exists\"); } var user = _mapper Map<User>(request); user CreatedAt = DateTime UtcNow; user IsActive = true; var createdUser = await _userRepository CreateAsync(user);\n                var userDto = _mapper Map<UserDto>(createdUser);\n                _logger LogInformation(\"Successfully created user with ID: {UserId}\", createdUser Id);\n                return userDto;\n            }\n            catch (DuplicateUserException)\n            {\n                throw; // Re-throw business logic exceptions\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error occurred while creating user with email: {Email}\", request Email);\n                throw new ServiceException(\"Failed to create user\", ex);\n            }\n        }\n        public async Task<bool> UserExistsAsync(string email)\n        {\n            try\n            {\n                return await _userRepository ExistsByEmailAsync(email);\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error checking if user exists with email: {Email}\", email);\n                throw new ServiceException(\"Failed to check user existence\", ex);\n            }\n        }\n    }\n}\n`\nMiddleware Configuration Example\n`csharp{\ntitle: \"Custom Authentication Middleware\"\ndescription: \"JWT authentication middleware with custom claims handling\"\nframework: \"NET8\"\ncategory: \"MIDDLEWARE\"\ndifficulty: \"ADVANCED\"\ntags: [\"Middleware\", \"JWT\", \"Authentication\", \"Security\"]\ndocsUrl: \"https://docs microsoft com/aspnet/core/fundamentals/middleware\"\nnugetPackages: [\"Microsoft AspNetCore Authentication JwtBearer\", \"System IdentityModel Tokens Jwt\"]\nfilename: \"JwtAuthenticationMiddleware cs\"\n}\nusing Microsoft AspNetCore Authentication;\nusing Microsoft Extensions Options;\nusing System IdentityModel Tokens Jwt;\nusing System Security Claims;\nusing System Text Encodings Web;\nusing Microsoft IdentityModel Tokens;\nusing System Text;\nnamespace UserManagement Middleware\n{\n    public class JwtAuthenticationMiddleware\n    {\n        private readonly RequestDelegate _next;\n        private readonly JwtSettings _jwtSettings;\n        private readonly ILogger<JwtAuthenticationMiddleware> _logger;\n        public JwtAuthenticationMiddleware(\n            RequestDelegate next,\n            IOptions<JwtSettings> jwtSettings,\n            ILogger<JwtAuthenticationMiddleware> logger)\n        {\n            _next = next;\n            _jwtSettings = jwtSettings Value;\n            _logger = logger;\n        }\n        public async Task InvokeAsync(HttpContext context)\n        {\n            var token = ExtractTokenFromHeader(context);\n            if ( string IsNullOrEmpty(token))\n            {\n                await ValidateAndSetUser(context, token);\n            }\n            await _next(context);\n        }\n        private string ExtractTokenFromHeader(HttpContext context)\n        {\n            var authHeader = context Request Headers[\"Authorization\"] FirstOrDefault();\n            if (authHeader = null && authHeader",
        "startIndex": 11764,
        "preview": "{ _logger LogInformation(\"Creating new user with email: {Email}\", request Email); // Check if user already exists if (await UserExistsAsync(request Em..."
      },
      {
        "id": "examples/enhanced-csharp-examples-chunk-6",
        "text": "= next; _jwtSettings = jwtSettings Value; _logger = logger; } public async Task InvokeAsync(HttpContext context) { var token = ExtractTokenFromHeader(context); if ( string IsNullOrEmpty(token)) { await ValidateAndSetUser(context, token); } await _next(context); } private string ExtractTokenFromHeader(HttpContext context) { var authHeader = context Request Headers[\"Authorization\"] FirstOrDefault(); if (authHeader = null && authHeader StartsWith(\"Bearer \"))\n            {\n                return authHeader Substring(\"Bearer \" Length) Trim();\n            }\n            return null;\n        }\n        private async Task ValidateAndSetUser(HttpContext context, string token)\n        {\n            try\n            {\n                var tokenHandler = new JwtSecurityTokenHandler();\n                var key = Encoding ASCII GetBytes(_jwtSettings SecretKey);\n                var validationParameters = new TokenValidationParameters\n                {\n                    ValidateIssuerSigningKey = true,\n                    IssuerSigningKey = new SymmetricSecurityKey(key),\n                    ValidateIssuer = true,\n                    ValidIssuer = _jwtSettings Issuer,\n                    ValidateAudience = true,\n                    ValidAudience = _jwtSettings Audience,\n                    ValidateLifetime = true,\n                    ClockSkew = TimeSpan Zero\n                };\n                var principal = tokenHandler ValidateToken(token, validationParameters, out SecurityToken validatedToken);\n                // Set the user context\n                context User = principal;\n                _logger LogInformation(\"JWT token validated successfully for user: {UserId}\", \n                    principal FindFirst(ClaimTypes NameIdentifier) Value);\n            }\n            catch (SecurityTokenException ex)\n            {\n                _logger LogWarning(\"Invalid JWT token: {Error}\", ex Message);\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error validating JWT token\");\n            }\n        }\n    }\n    public class JwtSettings\n    {\n        public string SecretKey { get; set; } = string Empty;\n        public string Issuer { get; set; } = string Empty;\n        public string Audience { get; set; } = string Empty;\n        public int ExpirationMinutes { get; set; } = 60;\n    }\n}\n`\nConfiguration and Startup Example\n`csharp{\ntitle: \"Program cs Configuration\"\ndescription: \"Modern NET 8 minimal hosting model with comprehensive service configuration\"\nframework: \"NET8\"\ncategory: \"CONFIG\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Configuration\", \"Dependency Injection\", \"Startup\", \"Minimal API\"]\nfilename: \"Program cs\"\n}\nusing Microsoft EntityFrameworkCore;\nusing Microsoft AspNetCore Authentication JwtBearer;\nusing Microsoft IdentityModel Tokens;\nusing System Text;\nusing UserManagement Data;\nusing UserManagement Services;\nusing UserManagement Repositories;\nusing UserManagement Middleware;\nvar builder = WebApplication CreateBuilder(args);\n// Configuration\nvar jwtSettings = builder Configuration",
        "startIndex": 14649,
        "preview": "= next; _jwtSettings = jwtSettings Value; _logger = logger; } public async Task InvokeAsync(HttpContext context) { var token = ExtractTokenFromHeader(..."
      },
      {
        "id": "examples/enhanced-csharp-examples-chunk-7",
        "text": "tags: [\"Configuration\", \"Dependency Injection\", \"Startup\", \"Minimal API\"] filename: \"Program cs\" } using Microsoft EntityFrameworkCore; using Microsoft AspNetCore Authentication JwtBearer; using Microsoft IdentityModel Tokens; using System Text; using UserManagement Data; using UserManagement Services; using UserManagement Repositories; using UserManagement Middleware; var builder = WebApplication CreateBuilder(args); // Configuration var jwtSettings = builder Configuration GetSection(\"JwtSettings\");\nvar connectionString = builder Configuration GetConnectionString(\"DefaultConnection\");\n// Add services to the container\nbuilder Services AddDbContext<UserDbContext>(options =>\n    options UseSqlServer(connectionString));\n// JWT Authentication\nbuilder Services Configure<JwtSettings>(jwtSettings);\nbuilder Services AddAuthentication(JwtBearerDefaults AuthenticationScheme) AddJwtBearer(options =>\n    {\n        options TokenValidationParameters = new TokenValidationParameters\n        {\n            ValidateIssuerSigningKey = true,\n            IssuerSigningKey = new SymmetricSecurityKey(\n                Encoding ASCII GetBytes(jwtSettings[\"SecretKey\"] )),\n            ValidateIssuer = true,\n            ValidIssuer = jwtSettings[\"Issuer\"],\n            ValidateAudience = true,\n            ValidAudience = jwtSettings[\"Audience\"],\n            ValidateLifetime = true,\n            ClockSkew = TimeSpan Zero\n        };\n    });\nbuilder Services AddAuthorization();\n// Register application services\nbuilder Services AddScoped<IUserRepository, UserRepository>();\nbuilder Services AddScoped<IUserService, UserService>();\n// AutoMapper\nbuilder Services AddAutoMapper(typeof(Program));\n// API Controllers\nbuilder Services AddControllers();\n// API Documentation\nbuilder Services AddEndpointsApiExplorer();\nbuilder Services AddSwaggerGen(c =>\n{\n    c SwaggerDoc(\"v1\", new() { Title = \"User Management API\", Version = \"v1\" });\n    c AddSecurityDefinition(\"Bearer\", new()\n    {\n        Description = \"JWT Authorization header using the Bearer scheme \",\n        Name = \"Authorization\",\n        In = Microsoft OpenApi Models ParameterLocation Header,\n        Type = Microsoft OpenApi Models SecuritySchemeType Http,\n        Scheme = \"bearer\"\n    });\n});\n// CORS\nbuilder Services AddCors(options =>\n{\n    options AddPolicy(\"AllowSpecificOrigins\", policy =>\n    {\n        policy WithOrigins(\"https://localhost:4200\", \"https://myapp com\") AllowAnyHeader() AllowAnyMethod();\n    });\n});\n// Logging\nbuilder Services AddLogging(config =>\n{\n    config AddConsole();\n    config AddDebug();\n});\nvar app = builder Build();\n// Configure the HTTP request pipeline\nif (app Environment IsDevelopment())\n{\n    app UseSwagger();\n    app UseSwaggerUI();\n    app UseDeveloperExceptionPage();\n}\napp UseHttpsRedirection();\napp UseCors(\"AllowSpecificOrigins\");\n// Custom JWT middleware\napp UseMiddleware<JwtAuthenticationMiddleware>();\napp UseAuthentication();\napp UseAuthorization();\napp MapControllers();\napp",
        "startIndex": 17276,
        "preview": "tags: [\"Configuration\", \"Dependency Injection\", \"Startup\", \"Minimal API\"] filename: \"Program cs\" } using Microsoft EntityFrameworkCore; using Microsof..."
      },
      {
        "id": "examples/enhanced-csharp-examples-chunk-8",
        "text": "builder Services AddLogging(config => { config AddConsole(); config AddDebug(); }); var app = builder Build(); // Configure the HTTP request pipeline if (app Environment IsDevelopment()) { app UseSwagger(); app UseSwaggerUI(); app UseDeveloperExceptionPage(); } app UseHttpsRedirection(); app UseCors(\"AllowSpecificOrigins\"); // Custom JWT middleware app UseMiddleware<JwtAuthenticationMiddleware>(); app UseAuthentication(); app UseAuthorization(); app MapControllers(); app Run();\n`\nThis documentation showcases the enhanced Ccode viewing capabilities with:\nRich Metadata: Titles, descriptions, framework versions, categories, difficulty levels\nInteractive Features: Copy, download, GitHub links, NuGet package integration\nVisual Enhancements: Syntax highlighting, line numbers, code folding\nProfessional Styling: VS Code-inspired themes, hover effects, responsive design\nDeveloper Tools: Line highlighting, collapsible sections, tag categorization",
        "startIndex": 19814,
        "preview": "builder Services AddLogging(config => { config AddConsole(); config AddDebug(); }); var app = builder Build(); // Configure the HTTP request pipeline ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "getting-started/aspire-integration",
    "title": ".NET Aspire Integration",
    "category": "Getting Started",
    "url": "/docs/getting-started/aspire-integration",
    "chunks": [
      {
        "id": "getting-started/aspire-integration-chunk-0",
        "text": "NET Aspire Integration\nWhizbang provides first-class support for NET Aspire, Microsoft's opinionated stack for building observable, production-ready cloud-native applications Overview\nWith Aspire integration, you get:\nLocal emulation of Postgres, Kafka, Redis, and other infrastructure\nOne-command setup for end-to-end development environment\nService discovery for microservices communication\nBuilt-in observability with OpenTelemetry dashboards\nResource orchestration with Docker containers\nConfiguration management across services\nQuick Start\nInstall Aspire Workload\n`bash\ndotnet workload install aspire\n`\nAdd Whizbang Aspire Package\n`bash\ndotnet add package Whizbang Aspire\n`\nConfigure AppHost\nCreate an Aspire AppHost project:\n`csharp{\ntitle: \"Aspire AppHost Configuration\"\ndescription: \"Configure Whizbang services with Aspire\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"BEGINNER\"\ntags: [\"Aspire\", \"Configuration\", \"Local Development\"]\nnugetPackages: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nfilename: \"Program cs\"\nusingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting;\nusing Whizbang Aspire;\nvar builder = DistributedApplication CreateBuilder(args);\n// Add Whizbang infrastructure\nvar whizbang = builder AddWhizbang(\"whizbang\") WithPostgres()       // Event store WithKafka()          // Message broker WithRedis()          // Caching WithOpenTelemetry(); // Observability\n// Add your services\nvar ordersService = builder AddProject<Projects OrdersService>(\"orders\") WithReference(whizbang);\nvar inventoryService = builder AddProject<Projects InventoryService>(\"inventory\") WithReference(whizbang);\nvar apiGateway = builder AddProject<Projects ApiGateway>(\"api\") WithReference(ordersService) WithReference(inventoryService);\nbuilder Build() Run();\n`\nConfigure Service\nIn your service's Program cs:\n`csharp{\ntitle: \"Service Configuration with Aspire\"\ndescription: \"Wire up Whizbang in a service using Aspire\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"BEGINNER\"\ntags: [\"Aspire\", \"Configuration\", \"Microservices\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Messaging\", \"Whizbang Aspire\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions Hosting\", \"Whizbang\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions Hosting;\nusing Whizbang;\nusing Whizbang Aspire;\nvar builder = WebApplication CreateBuilder(args);\n// Add Aspire service defaults (observability, health checks, etc )\nbuilder AddServiceDefaults();\n// Add Whizbang with Aspire integration\nbuilder Services AddWhizbangWithAspire(options => {\n    options ScanAssembly(typeof(Program) Assembly);\n    // Infrastructure auto-configured from Aspire\n    options UseAspireEventStore();      // Connects to Aspire-managed Postgres\n    options",
        "startIndex": 0,
        "preview": "NET Aspire Integration\nWhizbang provides first-class support for NET Aspire, Microsoft's opinionated stack for building observable, production-ready c..."
      },
      {
        "id": "getting-started/aspire-integration-chunk-1",
        "text": "Hosting; using Whizbang; using Whizbang Aspire; var builder = WebApplication CreateBuilder(args); // Add Aspire service defaults (observability, health checks, etc ) builder AddServiceDefaults(); // Add Whizbang with Aspire integration builder Services AddWhizbangWithAspire(options => { options ScanAssembly(typeof(Program) Assembly); // Infrastructure auto-configured from Aspire options UseAspireEventStore(); // Connects to Aspire-managed Postgres options UseAspireMessaging();       // Connects to Aspire-managed Kafka\n    options UseAspireProjectionCache(); // Connects to Aspire-managed Redis\n});\nvar app = builder Build();\napp MapDefaultEndpoints();  // Aspire health/metrics endpoints\napp Run();\n`\nRun Everything\n`bash\ndotnet run --project AppHost\n`\nThis single command:\nStarts Postgres container for event store\nStarts Kafka + Zookeeper containers for messaging\nStarts Redis container for caching\nStarts all your microservices\nOpens Aspire dashboard with logs, metrics, and traces\nAspire Dashboard\nNavigate to http://localhost:15000 (or the URL shown in console) to see:\nResources - All running containers and services\nLogs - Structured logs from all services\nTraces - Distributed tracing across services\nMetrics - Real-time metrics (event throughput, projection lag, etc )\nHealth - Service health status\nOut-of-the-Box Infrastructure\nPostgres (Event Store)\nWhizbang automatically configures Postgres for event storage:\n`csharp{\ntitle: \"Aspire Postgres Configuration\"\ndescription: \"Auto-configured Postgres event store\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aspire\", \"Postgres\", \"Event Store\"]\nnugetPackages: [\"Whizbang Aspire\", \"Whizbang Postgres\"]\nusingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting;\nusing Whizbang Aspire;\nvar builder = DistributedApplication CreateBuilder(args);\nvar whizbang = builder AddWhizbang(\"whizbang\") WithPostgres(postgres => {\n        postgres DatabaseName = \"whizbang_events\";\n        postgres WithPgAdmin();  // Optional: PgAdmin UI\n        postgres WithInitialData(\" /seed-data",
        "startIndex": 2854,
        "preview": "Hosting; using Whizbang; using Whizbang Aspire; var builder = WebApplication CreateBuilder(args); // Add Aspire service defaults (observability, healt..."
      },
      {
        "id": "getting-started/aspire-integration-chunk-2",
        "text": "tags: [\"Aspire\", \"Postgres\", \"Event Store\"] nugetPackages: [\"Whizbang Aspire\", \"Whizbang Postgres\"] usingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"] showLineNumbers: true } using Aspire Hosting; using Whizbang Aspire; var builder = DistributedApplication CreateBuilder(args); var whizbang = builder AddWhizbang(\"whizbang\") WithPostgres(postgres => { postgres DatabaseName = \"whizbang_events\"; postgres WithPgAdmin(); // Optional: PgAdmin UI postgres WithInitialData(\" /seed-data sql\");  // Optional: Seed data\n    });\n`\nWhat it does:\nStarts Postgres 16 container\nCreates whizbang_events database\nApplies Whizbang event store schema automatically\nConfigures connection string in all services\nEnables OpenTelemetry instrumentation\nKafka (Message Broker)\nWhizbang sets up Kafka for distributed messaging:\n`csharp{\ntitle: \"Aspire Kafka Configuration\"\ndescription: \"Auto-configured Kafka message broker\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aspire\", \"Kafka\", \"Messaging\"]\nnugetPackages: [\"Whizbang Aspire\", \"Whizbang Kafka\"]\nusingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting;\nusing Whizbang Aspire;\nvar whizbang = builder AddWhizbang(\"whizbang\") WithKafka(kafka => {\n        kafka WithKafkaUI();  // Optional: Kafka UI for topic inspection\n        kafka WithTopics(\n            \"whizbang orders events\",\n            \"whizbang inventory events\",\n            \"whizbang shipping events\"\n        );\n    });\n`\nWhat it does:\nStarts Kafka + Zookeeper containers\nCreates topics for each domain\nConfigures producers and consumers\nEnables distributed tracing for messages\nProvides Kafka UI at http://localhost:8080\nRedis (Caching & Projections)\nOptional Redis for projection caching:\n`csharp{\ntitle: \"Aspire Redis Configuration\"\ndescription: \"Auto-configured Redis for caching\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aspire\", \"Redis\", \"Caching\"]\nnugetPackages: [\"Whizbang Aspire\"]\nusingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting;\nusing Whizbang Aspire;\nvar whizbang = builder AddWhizbang(\"whizbang\") WithRedis(redis => {\n        redis WithRedisInsight();  // Optional: Redis UI\n        redis",
        "startIndex": 4503,
        "preview": "tags: [\"Aspire\", \"Postgres\", \"Event Store\"] nugetPackages: [\"Whizbang Aspire\", \"Whizbang Postgres\"] usingStatements: [\"Aspire Hosting\", \"Whizbang Aspi..."
      },
      {
        "id": "getting-started/aspire-integration-chunk-3",
        "text": "\"Aspire Redis Configuration\" description: \"Auto-configured Redis for caching\" framework: \"NET8\" category: \"Aspire\" difficulty: \"INTERMEDIATE\" tags: [\"Aspire\", \"Redis\", \"Caching\"] nugetPackages: [\"Whizbang Aspire\"] usingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"] showLineNumbers: true } using Aspire Hosting; using Whizbang Aspire; var whizbang = builder AddWhizbang(\"whizbang\") WithRedis(redis => { redis WithRedisInsight(); // Optional: Redis UI redis WithPersistence();   // Optional: Persist to disk\n    });\n`\nWhat it does:\nStarts Redis container\nConfigures projection caching\nEnables distributed locks for projection processing\nProvides Redis Insight UI\nService Discovery\nServices automatically discover each other through Aspire:\n`csharp{\ntitle: \"Service Discovery with Aspire\"\ndescription: \"Services discover each other automatically\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aspire\", \"Service Discovery\", \"Microservices\"]\nnugetPackages: [\"Whizbang Aspire\", \"Whizbang Messaging\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nusing Whizbang Aspire;\n// In API Gateway\nbuilder Services AddWhizbangWithAspire(options => {\n    options UseMessaging(msg => {\n        // Service URLs automatically resolved via Aspire\n        msg UseDomainOwnership(domains => {\n            domains RegisterDomain(\"Orders\", \"http://orders\");        // Aspire resolves to actual URL\n            domains RegisterDomain(\"Inventory\", \"http://inventory\");  // Aspire resolves to actual URL\n        });\n    });\n});\n// Commands automatically routed to correct service\nawait whizbang Send(new PlaceOrder( ));  // Routes to http://orders (resolved by Aspire)\n`\nEnd-to-End Example\nComplete Aspire setup for microservices:\n`csharp{\ntitle: \"Complete Aspire Setup\"\ndescription: \"Full microservices setup with Whizbang and Aspire\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"ADVANCED\"\ntags: [\"Aspire\", \"Microservices\", \"Complete Example\"]\nnugetPackages: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nfilename: \"AppHost/Program cs\"\nusingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting;\nusing Whizbang Aspire;\nvar builder = DistributedApplication CreateBuilder(args);\n// Shared infrastructure\nvar whizbang = builder AddWhizbang(\"whizbang\") WithPostgres(pg => {\n        pg DatabaseName = \"whizbang_events\";\n        pg WithPgAdmin();\n    }) WithKafka(kafka => {\n        kafka WithKafkaUI();\n        kafka WithTopics(\n            \"whizbang orders events\",\n            \"whizbang inventory events\",\n            \"whizbang shipping events\",\n            \"whizbang payments events\"\n        );\n    }) WithRedis(redis => {\n        redis",
        "startIndex": 6281,
        "preview": "\"Aspire Redis Configuration\" description: \"Auto-configured Redis for caching\" framework: \"NET8\" category: \"Aspire\" difficulty: \"INTERMEDIATE\" tags: [\"..."
      },
      {
        "id": "getting-started/aspire-integration-chunk-4",
        "text": "Whizbang Aspire; var builder = DistributedApplication CreateBuilder(args); // Shared infrastructure var whizbang = builder AddWhizbang(\"whizbang\") WithPostgres(pg => { pg DatabaseName = \"whizbang_events\"; pg WithPgAdmin(); }) WithKafka(kafka => { kafka WithKafkaUI(); kafka WithTopics( \"whizbang orders events\", \"whizbang inventory events\", \"whizbang shipping events\", \"whizbang payments events\" ); }) WithRedis(redis => { redis WithRedisInsight();\n    }) WithOpenTelemetry();\n// Microservices (each has own event store partition)\nvar orders = builder AddProject<Projects OrdersService>(\"orders\") WithReference(whizbang) WithReplicas(3);  // Scale out\nvar inventory = builder AddProject<Projects InventoryService>(\"inventory\") WithReference(whizbang) WithReplicas(2);\nvar shipping = builder AddProject<Projects ShippingService>(\"shipping\") WithReference(whizbang);\nvar payments = builder AddProject<Projects PaymentsService>(\"payments\") WithReference(whizbang);\n// Analytics service (subscribes to all events)\nvar analytics = builder AddProject<Projects AnalyticsService>(\"analytics\") WithReference(whizbang);\n// API Gateway\nvar api = builder AddProject<Projects ApiGateway>(\"api\") WithReference(orders) WithReference(inventory) WithReference(shipping) WithReference(payments) WithHttpsEndpoint(port: 5000);\nbuilder Build() Run();\n`\nRunning:\n`bash\ndotnet run --project AppHost\n`\nStarts:\n1 Postgres container (shared event store)\n1 Kafka + Zookeeper (shared message broker)\n1 Redis (shared cache)\n3 replicas of Orders service\n2 replicas of Inventory service\n1 Shipping service\n1 Payments service\n1 Analytics service\n1 API Gateway\nAspire Dashboard with full observability\nConfiguration Management\nAspire manages configuration across all services:\n`json\n{\n  \"Aspire\": {\n    \"Whizbang\": {\n      \"EventStore\": {\n        \"ConnectionString\": \" auto-configured \",\n        \"SchemaName\": \"whizbang\",\n        \"AutoMigrate\": true\n      },\n      \"Messaging\": {\n        \"Kafka\": {\n          \"BootstrapServers\": \" auto-configured \",\n          \"ConsumerGroup\": \"orders-service\"\n        }\n      },\n      \"Projections\": {\n        \"Redis\": {\n          \"ConnectionString\": \" auto-configured \"\n        }\n      }\n    }\n  }\n}\n`\nConnection strings and URLs are automatically injected from Aspire infrastructure Testing with Aspire\nRun integration tests against Aspire-managed infrastructure:\n`csharp{\ntitle: \"Integration Tests with Aspire\"\ndescription: \"Test against real infrastructure via Aspire\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"ADVANCED\"\ntags: [\"Testing\", \"Aspire\", \"Integration Tests\"]\nnugetPackages: [\"Aspire Hosting Testing\", \"Whizbang Aspire\", \"xUnit\"]\nusingStatements: [\"Aspire Hosting Testing\", \"Xunit\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting Testing;\nusing System Threading",
        "startIndex": 8648,
        "preview": "Whizbang Aspire; var builder = DistributedApplication CreateBuilder(args); // Shared infrastructure var whizbang = builder AddWhizbang(\"whizbang\") Wit..."
      },
      {
        "id": "getting-started/aspire-integration-chunk-5",
        "text": "infrastructure: `csharp{ title: \"Integration Tests with Aspire\" description: \"Test against real infrastructure via Aspire\" framework: \"NET8\" category: \"Testing\" difficulty: \"ADVANCED\" tags: [\"Testing\", \"Aspire\", \"Integration Tests\"] nugetPackages: [\"Aspire Hosting Testing\", \"Whizbang Aspire\", \"xUnit\"] usingStatements: [\"Aspire Hosting Testing\", \"Xunit\", \"System Threading Tasks\"] showLineNumbers: true } using Aspire Hosting Testing; using System Threading Tasks;\nusing Xunit;\npublic class OrderServiceTests : IClassFixture<DistributedApplicationFixture> {\n    private readonly DistributedApplicationFixture _fixture;\n    public OrderServiceTests(DistributedApplicationFixture fixture) {\n        _fixture = fixture;\n    }\n    [Fact]\n    public async Task PlaceOrder_PersistsToEventStore() {\n        // Aspire starts Postgres, Kafka, and services\n        await using var app = await _fixture CreateApplicationAsync();\n        await app StartAsync();\n        var ordersService = app GetHttpClient(\"orders\");\n        // Test against real service with real infrastructure\n        var response = await ordersService PostAsJsonAsync(\"/orders\", new {\n            CustomerId = Guid NewGuid(),\n            Items = new[] { new { ProductId = Guid NewGuid(), Quantity = 2, Price = 19 99 } }\n        });\n        response EnsureSuccessStatusCode();\n        // Events are actually persisted to Postgres\n        // Projections are actually updated via Kafka\n    }\n}\n`\nTests run against real infrastructure (Postgres, Kafka, etc ) managed by Aspire Benefits of Aspire Integration\nFor Local Development\nOne command starts everything (databases, message brokers, services)\nNo manual Docker Compose management\nAutomatic configuration (connection strings, URLs)\nLive reload with hot reload support\nObservability dashboard out of the box\nFor Team Onboarding\nNew developers clone repo and run dotnet run --project AppHost\nEverything \"just works\" - no manual setup\nConsistent environment across team members\nSelf-documenting infrastructure (defined in code)\nFor Production\nSame infrastructure configuration in dev and prod\nAspire generates Kubernetes manifests\nEasy transition from local to cloud\nAzure Container Apps / AKS deployment support\nDeployment\nGenerate deployment artifacts from Aspire:\n`bash\nGenerate Kubernetes manifests\ndotnet run --project AppHost -- publish --output-path /deploy/k8s\nGenerate Docker Compose\ndotnet run --project AppHost -- publish --output-path",
        "startIndex": 11096,
        "preview": "infrastructure: `csharp{ title: \"Integration Tests with Aspire\" description: \"Test against real infrastructure via Aspire\" framework: \"NET8\" category:..."
      },
      {
        "id": "getting-started/aspire-integration-chunk-6",
        "text": "configuration in dev and prod Aspire generates Kubernetes manifests Easy transition from local to cloud Azure Container Apps / AKS deployment support Deployment Generate deployment artifacts from Aspire: `bash Generate Kubernetes manifests dotnet run --project AppHost -- publish --output-path /deploy/k8s Generate Docker Compose dotnet run --project AppHost -- publish --output-path /deploy/docker --format docker-compose\nDeploy to Azure Container Apps\nazd init\nazd up\n`\nNext Steps\nDistributed Messaging - Microservices with Kafka\nObservability - OpenTelemetry and monitoring\nTesting - Test with Aspire infrastructure\nResources NET Aspire Documentation\nWhizbang Aspire Samples\nAspire Dashboard Guide",
        "startIndex": 13095,
        "preview": "configuration in dev and prod Aspire generates Kubernetes manifests Easy transition from local to cloud Azure Container Apps / AKS deployment support ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "getting-started/getting-started",
    "title": "Getting Started",
    "category": "Getting Started",
    "url": "/docs/getting-started/getting-started",
    "chunks": [
      {
        "id": "getting-started/getting-started-chunk-0",
        "text": "Getting Started\nThis is a hands-on tutorial that walks you through building your first Whizbang application, starting with a simple in-process mediator and progressively adding event sourcing, projections, and distributed messaging What you'll build:\n✅ Event-Driven Architecture - Receptors, Perspectives, and Lenses with Whizbang Core\n✅ Event Sourcing - Stateful receptors and ledger with Whizbang EventSourcing\n✅ Multiple Perspectives - Different views of the same events for efficient queries\n`mermaid\ngraph LR\n    A[Event-Driven] -->|Add Ledger| B[Event-Sourced]\n    B -->|Add Perspectives| C[Full Event Architecture]\n    class A layer-command\n    class B layer-event\n    class C layer-read\n`\nCompanion guides:\n📦 Package Structure - Reference guide for all NuGet packages, ORMs, and message broker adapters\n🧠 Philosophy - Understand Whizbang's design principles and architectural decisions\n📚 Core Concepts - Deep dive into commands, events, aggregates, and projections\nPrerequisites NET 8 0 SDK or later\nC12 or later\nYour favorite IDE (Visual Studio, Rider, VS Code)\nInstallation\n> 📦 Want to understand all available packages See the Package Structure Reference for a complete guide to Whizbang's NuGet packages, ORM integrations, and message broker adapters Step 1: Create a New Project\n`bash\ndotnet new webapi -n MyApp\ncd MyApp\n`\nStep 2: Install Whizbang\nFor this tutorial, we'll start with just the core package:\n`bash\ndotnet add package Whizbang Core\n`\nWhat is Whizbang Core The foundation for event-driven architecture - includes dispatcher, receptors, perspectives, and lenses Perfect for learning event-driven patterns where all writes flow through events We'll add event sourcing later in this tutorial ---\nYour First Command and Receptor\nLet's build a simple order system with event-driven architecture",
        "startIndex": 0,
        "preview": "Getting Started\nThis is a hands-on tutorial that walks you through building your first Whizbang application, starting with a simple in-process mediato..."
      },
      {
        "id": "getting-started/getting-started-chunk-1",
        "text": "What is Whizbang Core The foundation for event-driven architecture - includes dispatcher, receptors, perspectives, and lenses Perfect for learning event-driven patterns where all writes flow through events We'll add event sourcing later in this tutorial --- Your First Command and Receptor Let's build a simple order system with event-driven architecture `mermaid\nsequenceDiagram\n    participant API as API Endpoint\n    participant D as Dispatcher\n    participant R as OrderReceptor\n    participant P as OrderPerspective\n    participant DB as Database\n    API->>D: Dispatch(PlaceOrder)\n    D->>R: Receive(PlaceOrder)\n    R->>R: Validate with Lens\n    R-->>D: OrderPlaced event\n    D->>P: Update(OrderPlaced)\n    P->>DB: Write order\n    D-->>API: OrderPlaced event\n    Note over API,DB: Event-driven pattern<br/>All writes through events\n`\nStep 1: Define a Command\nCreate Commands/PlaceOrder cs:\n`csharp{\ntitle: \"PlaceOrder Command\"\ndescription: \"Command to place a new order\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"CQRS\"]\nfilename: \"Commands/PlaceOrder cs\"\nusingStatements: [\"System\"]\nshowLineNumbers: true\n}\nusing System;\nnamespace MyApp Commands;\npublic record PlaceOrder(\n    Guid CustomerId,\n    List<OrderItem> Items\n);\npublic record OrderItem(\n    Guid ProductId,\n    int Quantity,\n    decimal Price\n);\n`\nStep 2: Create a Receptor\nCreate Receptors/PlaceOrderReceptor cs:\n`csharp{\ntitle: \"PlaceOrder Receptor\"\ndescription: \"Receptor that processes PlaceOrder commands\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Event-Driven\", \"Commands\"]\nfilename: \"Receptors/PlaceOrderReceptor cs\"\nusingStatements: [\"System\", \"Whizbang\", \"MyApp Commands\", \"MyApp Events\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing MyApp Commands;\nusing MyApp Events;\nnamespace MyApp Receptors;\npublic class PlaceOrderReceptor : IReceptor<PlaceOrder> {\n    public OrderPlaced Receive(PlaceOrder command) {\n        // Validate\n        if (command Items Count == 0) {\n            throw new InvalidOperationException(\"Order must have at least one item\");\n        }\n        // Create event\n        var orderId = Guid NewGuid();\n        var total = command Items Sum(i => i Price * i Quantity);\n        // Return event - perspective will handle persistence\n        return new OrderPlaced(\n            orderId,\n            command CustomerId,\n            DateTimeOffset UtcNow,\n            command Items,\n            total\n        );\n    }\n}\n`\nStep 3: Create a Perspective\nCreate Perspectives/OrderPerspective",
        "startIndex": 1829,
        "preview": "What is Whizbang Core The foundation for event-driven architecture - includes dispatcher, receptors, perspectives, and lenses Perfect for learning eve..."
      },
      {
        "id": "getting-started/getting-started-chunk-2",
        "text": "// Create event var orderId = Guid NewGuid(); var total = command Items Sum(i => i Price * i Quantity); // Return event - perspective will handle persistence return new OrderPlaced( orderId, command CustomerId, DateTimeOffset UtcNow, command Items, total ); } } ` Step 3: Create a Perspective Create Perspectives/OrderPerspective cs:\n`csharp{\ntitle: \"Order Perspective\"\ndescription: \"Perspective that handles OrderPlaced events\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Perspectives\", \"Event-Driven\", \"Database\"]\nfilename: \"Perspectives/OrderPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\", \"MyApp Events\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\nusing MyApp Events;\nnamespace MyApp Perspectives;\npublic class OrderPerspective : IPerspectiveOf<OrderPlaced> {\n    private readonly IOrderDatabase db;\n    public OrderPerspective(IOrderDatabase db) {\n        _db = db;\n    }\n    public async Task Update(OrderPlaced @event) {\n        // Perspective handles all writes\n        await _db Orders Add(new Order {\n            Id = @event OrderId,\n            CustomerId = @event CustomerId,\n            PlacedAt = @event PlacedAt,\n            Total = @event Total,\n            Status = \"Placed\"\n        });\n        await _db SaveChanges();\n    }\n}\n`\nStep 4: Configure Whizbang\nUpdate Program cs:\n`csharp{\ntitle: \"Whizbang Configuration\"\ndescription: \"Configure Whizbang dispatcher in ASP NET Core\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Configuration\", \"Setup\", \"ASP NET Core\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nvar builder = WebApplication CreateBuilder(args);\n// Add Whizbang dispatcher\nbuilder Services AddWhizbang(options => {\n    // Scan this assembly for receptors and perspectives\n    options ScanAssembly(typeof(Program) Assembly);\n});\nvar app = builder Build();\napp MapPost(\"/orders\", async (PlaceOrder command, IDispatcher dispatcher) => {\n    var @event = await dispatcher Send(command);\n    return Results Ok(new { OrderId = @event OrderId, Total = @event Total });\n});\napp",
        "startIndex": 4065,
        "preview": "// Create event var orderId = Guid NewGuid(); var total = command Items Sum(i => i Price * i Quantity); // Return event - perspective will handle pers..."
      },
      {
        "id": "getting-started/getting-started-chunk-3",
        "text": "AddWhizbang(options => { // Scan this assembly for receptors and perspectives options ScanAssembly(typeof(Program) Assembly); }); var app = builder Build(); app MapPost(\"/orders\", async (PlaceOrder command, IDispatcher dispatcher) => { var @event = await dispatcher Send(command); return Results Ok(new { OrderId = @event OrderId, Total = @event Total }); }); app Run();\n`\nStep 5: Run the Application\n`bash\ndotnet run\n`\nTest with curl:\n`bash\ncurl -X POST http://localhost:5000/orders \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"customerId\": \"123e4567-e89b-12d3-a456-426614174000\",\n    \"items\": [\n      { \"productId\": \"prod-1\", \"quantity\": 2, \"price\": 19 99 }\n    ]\n  }'\n`\nCongratulations You've created your first Whizbang event-driven application with receptors and perspectives All writes flow through events, making the transition to event sourcing seamless ---\nAdding Event Sourcing\nLet's upgrade to event sourcing with stateful receptors and a ledger for complete audit trail `mermaid\nsequenceDiagram\n    participant API as API Endpoint\n    participant D as Dispatcher\n    participant R as OrderReceptor\n    participant L as Ledger\n    participant P as Perspective\n    API->>D: Send(PlaceOrder)\n    D->>R: Receive(PlaceOrder)\n    R->>R: Validate business rules\n    R->>R: Apply(OrderPlaced)\n    Note over R: Event updates<br/>receptor state\n    D->>L: Append events to stream\n    L-->>D: Events saved\n    D->>P: Update(OrderPlaced)\n    P->>P: Update read models\n    D-->>API: OrderPlaced event\n    Note over API,P: Events stored as immutable log<br/>Complete audit trail\n`\n> 📦 Learn more: See Whizbang EventSourcing in the Package Structure guide for ORM options, database support, and advanced configuration Step 1: Install Event Sourcing Package\n`bash\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang Postgres  Or Whizbang SqlServer, Whizbang EntityFramework, etc `\nStep 2: Define Events\nCreate Events/OrderEvents cs:\n`csharp{\ntitle: \"Order Domain Events\"\ndescription: \"Events representing order lifecycle state changes\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"BEGINNER\"\ntags: [\"Events\", \"Event Sourcing\", \"Domain Events\"]\nfilename: \"Events/OrderEvents cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nnamespace MyApp",
        "startIndex": 5967,
        "preview": "AddWhizbang(options => { // Scan this assembly for receptors and perspectives options ScanAssembly(typeof(Program) Assembly); }); var app = builder Bu..."
      },
      {
        "id": "getting-started/getting-started-chunk-4",
        "text": "EntityFramework, etc ` Step 2: Define Events Create Events/OrderEvents cs: `csharp{ title: \"Order Domain Events\" description: \"Events representing order lifecycle state changes\" framework: \"NET8\" category: \"Event Sourcing\" difficulty: \"BEGINNER\" tags: [\"Events\", \"Event Sourcing\", \"Domain Events\"] filename: \"Events/OrderEvents cs\" usingStatements: [\"System\", \"Whizbang\"] showLineNumbers: true } using System; using Whizbang; namespace MyApp Events;\n[OwnedBy(\"Orders\")]  // This event comes from the Orders domain\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset PlacedAt,\n    List<OrderItem> Items,\n    decimal Total\n);\n[OwnedBy(\"Orders\")]\npublic record OrderShipped(\n    Guid OrderId,\n    DateTimeOffset ShippedAt,\n    string TrackingNumber\n);\n`\nStep 3: Create a Stateful Receptor\nCreate Receptors/OrderReceptor cs:\n`csharp{\ntitle: \"Event-Sourced Order Receptor\"\ndescription: \"Stateful receptor for event-sourced orders\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Receptors\", \"Event Sourcing\", \"Stateful\"]\nfilename: \"Receptors/OrderReceptor cs\"\nusingStatements: [\"System\", \"Whizbang\", \"MyApp Commands\", \"MyApp Events\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing MyApp Commands;\nusing MyApp Events;\nnamespace MyApp Receptors;\n[EventSourced]\npublic class OrderReceptor : \n    IReceptor<PlaceOrder>,\n    IReceptor<ShipOrder> {\n    private Guid id;\n    private Guid customerId;\n    private OrderStatus status;\n    private List<OrderItem> items = new();\n    private decimal total;\n    // Command handler for new orders\n    public OrderPlaced Receive(PlaceOrder command) {\n        if (id = Guid Empty) {\n            throw new InvalidOperationException(\"Order already exists\");\n        }\n        if (command Items Count == 0) {\n            throw new InvalidOperationException(\"Order must have items\");\n        }\n        var orderTotal = command Items Sum(i => i Price * i Quantity);\n        return new OrderPlaced(\n            Guid NewGuid(),\n            command CustomerId,\n            DateTimeOffset UtcNow,\n            command Items,\n            orderTotal\n        );\n    }\n    // Command handler for shipping\n    public OrderShipped Receive(ShipOrder command) {\n        if (status = OrderStatus Placed) {\n            throw new InvalidOperationException(\"Only placed orders can be shipped\");\n        }\n        return new OrderShipped(id, DateTimeOffset UtcNow, command TrackingNumber);\n    }\n    // Event handler - updates internal state\n    public void Absorb(OrderPlaced @event) {\n        id = @event OrderId;\n        customerId = @event CustomerId;\n        status = OrderStatus Placed;\n        items = @event Items ToList();\n        total = @event",
        "startIndex": 7934,
        "preview": "EntityFramework, etc ` Step 2: Define Events Create Events/OrderEvents cs: `csharp{ title: \"Order Domain Events\" description: \"Events representing ord..."
      },
      {
        "id": "getting-started/getting-started-chunk-5",
        "text": "{ throw new InvalidOperationException(\"Only placed orders can be shipped\"); } return new OrderShipped(id, DateTimeOffset UtcNow, command TrackingNumber); } // Event handler - updates internal state public void Absorb(OrderPlaced @event) { id = @event OrderId; customerId = @event CustomerId; status = OrderStatus Placed; items = @event Items ToList(); total = @event Total;\n    }\n    // Event handler - updates internal state\n    public void Absorb(OrderShipped @event) {\n        status = OrderStatus Shipped;\n    }\n}\npublic enum OrderStatus {\n    Placed,\n    Shipped,\n    Delivered,\n    Cancelled\n}\npublic record ShipOrder(Guid OrderId, string TrackingNumber);\n`\nStep 4: Add Event Definitions\nUpdate Events/OrderEvents cs with shipping event:\n`csharp{\ntitle: \"Complete Order Domain Events\"\ndescription: \"Events representing complete order lifecycle\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"BEGINNER\"\ntags: [\"Events\", \"Event Sourcing\", \"Domain Events\"]\nfilename: \"Events/OrderEvents cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nnamespace MyApp Events;\n[OwnedBy(\"Orders\")]\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset PlacedAt,\n    List<OrderItem> Items,\n    decimal Total\n);\n[OwnedBy(\"Orders\")]\npublic record OrderShipped(\n    Guid OrderId,\n    DateTimeOffset ShippedAt,\n    string TrackingNumber\n);\n`\nStep 5: Configure Event Sourcing\nUpdate Program cs:\n`csharp{\ntitle: \"Event Sourcing Configuration\"\ndescription: \"Configure Whizbang dispatcher with event sourcing and ledger\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Configuration\", \"Event Sourcing\", \"Postgres\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbang(dispatcher => {\n    dispatcher RegisterReceptorsFromAssembly(typeof(Program) Assembly);\n    dispatcher RegisterPerspectivesFromAssembly(typeof(Program) Assembly);\n    // Enable event sourcing with ledger\n    dispatcher UseEventSourcing(es => {\n        es UseLedger(ledger => {\n            ledger UsePostgres(builder Configuration GetConnectionString(\"EventStore\"));\n        });\n    });\n});\nvar app = builder Build();\napp MapPost(\"/orders\", async (PlaceOrder command, IDispatcher dispatcher) => {\n    var @event = await dispatcher Send(command);\n    return Results Ok(new { OrderId = @event OrderId, Total = @event Total });\n});\napp Run();\n`\nAdd connection string to appsettings",
        "startIndex": 10233,
        "preview": "{ throw new InvalidOperationException(\"Only placed orders can be shipped\"); } return new OrderShipped(id, DateTimeOffset UtcNow, command TrackingNumbe..."
      },
      {
        "id": "getting-started/getting-started-chunk-6",
        "text": "{ ledger UsePostgres(builder Configuration GetConnectionString(\"EventStore\")); }); }); }); var app = builder Build(); app MapPost(\"/orders\", async (PlaceOrder command, IDispatcher dispatcher) => { var @event = await dispatcher Send(command); return Results Ok(new { OrderId = @event OrderId, Total = @event Total }); }); app Run(); ` Add connection string to appsettings json:\n`json\n{\n  \"ConnectionStrings\": {\n    \"EventStore\": \"Host=localhost;Database=myapp;Username=user;Password=pass\"\n  }\n}\n`\nNow you have full event sourcing Receptors maintain state from events stored in the ledger, providing a complete audit trail and the ability to replay state from any point in time ---\nAdding Multiple Perspectives (Read Models)\nLet's add additional perspectives to maintain different views of order data for efficient queries `mermaid\ngraph TB\n    subgraph \"Write Side (Commands)\"\n        CMD[PlaceOrder Command]\n        AGG[Order Aggregate]\n        ES[Event Store]\n    end\n    subgraph \"Event Bus\"\n        EVT[OrderPlaced Event]\n    end\n    subgraph \"Read Side (Queries)\"\n        PROJ[OrderHistoryProjection]\n        RM[Read Model DB]\n        QUERY[Query: Get Orders]\n    end\n    CMD -->|Creates| AGG\n    AGG -->|Stores events| ES\n    ES -->|Publishes| EVT\n    EVT -->|Subscribes| PROJ\n    PROJ -->|Updates| RM\n    QUERY -->|Reads from| RM\n    class CMD layer-command\n    class AGG layer-core\n    class ES layer-event\n    class PROJ layer-read\n    class RM layer-read\n`\n> 📦 Learn more: See Whizbang Perspectives in the Package Structure guide for advanced perspective patterns and database integration Step 1: Create Order History Lens\nCreate Lenses/IOrderLens cs:\n`csharp{\ntitle: \"Order Lens Interface\"\ndescription: \"Read-only lens for querying orders\"\nframework: \"NET8\"\ncategory: \"Lenses\"\ndifficulty: \"BEGINNER\"\ntags: [\"Lenses\", \"Queries\", \"Read-Only\"]\nfilename: \"Lenses/IOrderLens cs\"\nusingStatements: [\"System\", \"System Linq Expressions\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Linq Expressions;\nnamespace MyApp Lenses;\npublic interface IOrderLens {\n    OrderSummary Focus(Guid orderId);\n    IEnumerable<OrderSummary> ViewByCustomer(Guid customerId);\n    IEnumerable<OrderSummary> View(Expression<Func<OrderSummary, bool>> filter);\n    bool Exists(Guid orderId);\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    public DateTimeOffset PlacedAt { get; set; }\n    public DateTimeOffset",
        "startIndex": 12474,
        "preview": "{ ledger UsePostgres(builder Configuration GetConnectionString(\"EventStore\")); }); }); }); var app = builder Build(); app MapPost(\"/orders\", async (Pl..."
      },
      {
        "id": "getting-started/getting-started-chunk-7",
        "text": "Linq Expressions; namespace MyApp Lenses; public interface IOrderLens { OrderSummary Focus(Guid orderId); IEnumerable<OrderSummary> ViewByCustomer(Guid customerId); IEnumerable<OrderSummary> View(Expression<Func<OrderSummary, bool>> filter); bool Exists(Guid orderId); } public class OrderSummary { public Guid OrderId { get; set; } public Guid CustomerId { get; set; } public DateTimeOffset PlacedAt { get; set; } public DateTimeOffset ShippedAt { get; set; }\n    public decimal Total { get; set; }\n    public string Status { get; set; }\n}\n`\nStep 2: Create Order History Perspective\nCreate Perspectives/OrderHistoryPerspective cs:\n`csharp{\ntitle: \"Order History Perspective\"\ndescription: \"Perspective that maintains order history for queries\"\nframework: \"NET8\"\ncategory: \"Perspectives\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Read Models\", \"Multiple Views\"]\nfilename: \"Perspectives/OrderHistoryPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\", \"MyApp Events\", \"MyApp Lenses\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\nusing MyApp Events;\nusing MyApp Lenses;\nnamespace MyApp Perspectives;\npublic class OrderHistoryPerspective : \n    IPerspectiveOf<OrderPlaced>,\n    IPerspectiveOf<OrderShipped> {\n    private readonly IOrderHistoryDatabase db;\n    public OrderHistoryPerspective(IOrderHistoryDatabase db) {\n        _db = db;\n    }\n    public async Task Update(OrderPlaced @event) {\n        await _db OrderHistory Add(new OrderSummary {\n            OrderId = @event OrderId,\n            CustomerId = @event CustomerId,\n            PlacedAt = @event PlacedAt,\n            Total = @event Total,\n            Status = \"Placed\"\n        });\n        await _db SaveChanges();\n    }\n    public async Task Update(OrderShipped @event) {\n        var order = await _db OrderHistory Get(@event OrderId);\n        order ShippedAt = @event ShippedAt;\n        order Status = \"Shipped\";\n        await _db SaveChanges();\n    }\n}\n`\nStep 3: Implement Order Lens\nCreate Lenses/OrderLens cs:\n`csharp{\ntitle: \"Order Lens Implementation\"\ndescription: \"Lens implementation for querying order history\"\nframework: \"NET8\"\ncategory: \"Lenses\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Implementation\", \"Database\"]\nfilename: \"Lenses/OrderLens cs\"\nusingStatements: [\"System\", \"System Linq Expressions\", \"MyApp Lenses\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Linq Expressions;\nusing MyApp Lenses;\nnamespace MyApp",
        "startIndex": 14568,
        "preview": "Linq Expressions; namespace MyApp Lenses; public interface IOrderLens { OrderSummary Focus(Guid orderId); IEnumerable<OrderSummary> ViewByCustomer(Gui..."
      },
      {
        "id": "getting-started/getting-started-chunk-8",
        "text": "Lens Create Lenses/OrderLens cs: `csharp{ title: \"Order Lens Implementation\" description: \"Lens implementation for querying order history\" framework: \"NET8\" category: \"Lenses\" difficulty: \"INTERMEDIATE\" tags: [\"Lenses\", \"Implementation\", \"Database\"] filename: \"Lenses/OrderLens cs\" usingStatements: [\"System\", \"System Linq Expressions\", \"MyApp Lenses\"] showLineNumbers: true } using System; using System Linq Expressions; using MyApp Lenses; namespace MyApp Lenses;\npublic class OrderLens : IOrderLens {\n    private readonly IOrderHistoryDatabase db;\n    public OrderLens(IOrderHistoryDatabase db) {\n        _db = db;\n    }\n    public OrderSummary Focus(Guid orderId) {\n        return _db OrderHistory FirstOrDefault(o => o OrderId == orderId);\n    }\n    public IEnumerable<OrderSummary> ViewByCustomer(Guid customerId) {\n        return _db OrderHistory Where(o => o CustomerId == customerId) OrderByDescending(o => o PlacedAt);\n    }\n    public IEnumerable<OrderSummary> View(Expression<Func<OrderSummary, bool>> filter) {\n        return _db OrderHistory Where(filter);\n    }\n    public bool Exists(Guid orderId) {\n        return _db OrderHistory Any(o => o OrderId == orderId);\n    }\n}\n`\nStep 4: Configure Multiple Perspectives\nUpdate Program cs:\n`csharp{\ntitle: \"Multiple Perspectives Configuration\"\ndescription: \"Configure multiple perspectives in Whizbang dispatcher\"\nframework: \"NET8\"\ncategory: \"Perspectives\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Configuration\", \"Perspectives\", \"Multiple Views\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"MyApp Lenses\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing MyApp Lenses;\nbuilder Services AddWhizbang(dispatcher => {\n    dispatcher RegisterReceptorsFromAssembly(typeof(Program) Assembly);\n    dispatcher RegisterPerspectivesFromAssembly(typeof(Program) Assembly);\n    // Register lenses\n    dispatcher RegisterLensesFromAssembly(typeof(Program) Assembly);\n    dispatcher UseEventSourcing(es => {\n        es UseLedger(ledger => {\n            ledger UsePostgres(connectionString);\n        });\n    });\n});\n// Register lens implementations\nbuilder Services AddScoped<IOrderLens, OrderLens>();\n`\nStep 5: Query via Lens\nAdd query endpoint:\n`csharp{\ntitle: \"Query Order History via Lens\"\ndescription: \"Query endpoint using order lens for read operations\"\nframework: \"NET8\"\ncategory: \"Lenses\"\ndifficulty: \"BEGINNER\"\ntags: [\"Queries\", \"Lenses\", \"API\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft AspNetCore Builder\", \"System\", \"MyApp Lenses\"]\nshowLineNumbers: true\n}\napp MapGet(\"/customers/{customerId}/orders\", (\n    Guid customerId,\n    IOrderLens lens\n) => {\n    var orders = lens ViewByCustomer(customerId);\n    return Results Ok(orders);\n});\napp MapGet(\"/orders/{orderId}\", (\n    Guid orderId,\n    IOrderLens lens\n) => {\n    var order = lens",
        "startIndex": 16608,
        "preview": "Lens Create Lenses/OrderLens cs: `csharp{ title: \"Order Lens Implementation\" description: \"Lens implementation for querying order history\" framework: ..."
      },
      {
        "id": "getting-started/getting-started-chunk-9",
        "text": "tags: [\"Queries\", \"Lenses\", \"API\"] filename: \"Program cs\" usingStatements: [\"Microsoft AspNetCore Builder\", \"System\", \"MyApp Lenses\"] showLineNumbers: true } app MapGet(\"/customers/{customerId}/orders\", ( Guid customerId, IOrderLens lens ) => { var orders = lens ViewByCustomer(customerId); return Results Ok(orders); }); app MapGet(\"/orders/{orderId}\", ( Guid orderId, IOrderLens lens ) => { var order = lens Focus(orderId);\n    return order = null Results Ok(order) : Results NotFound();\n});\n`\nNow you have complete CQRS Commands go to receptors (decision-making), events flow to perspectives (write side), and queries use lenses (read side) Multiple perspectives can maintain different views of the same events ---\nNext Steps\nYou've built a complete Event-Driven and Event-Sourced application with Whizbang Here's what to explore next:\nPhilosophy - Understand Whizbang's design principles and architectural philosophy\nCore Concepts - Deep dive into receptors, perspectives, lenses, and events\nPackage Structure - Learn about all available packages\nTesting - Test your event-driven and event-sourced applications\nDistributed Messaging - Scale to microservices with relays and message brokers\nSagas - Coordinate long-running processes across receptors\nObservability - Monitor your event-driven systems",
        "startIndex": 19024,
        "preview": "tags: [\"Queries\", \"Lenses\", \"API\"] filename: \"Program cs\" usingStatements: [\"Microsoft AspNetCore Builder\", \"System\", \"MyApp Lenses\"] showLineNumbers:..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "getting-started/package-structure",
    "title": "Package Structure",
    "category": "Getting Started",
    "url": "/docs/getting-started/package-structure",
    "chunks": [
      {
        "id": "getting-started/package-structure-chunk-0",
        "text": "Package Structure\nThis is a reference guide to all available Whizbang NuGet packages, their capabilities, and how to choose the right ones for your application > 💡 New to Whizbang Start with the Getting Started Tutorial for hands-on, step-by-step learning Come back here when you need detailed package information Overview\nWhizbang is distributed as a suite of NuGet packages, allowing you to install only what you need This keeps your application lean and supports AOT compilation Package Philosophy:\nStart minimal - Begin with Whizbang Core (just the mediator)\nAdd as needed - Install event sourcing, projections, messaging only when required\nChoose your stack - Pick your preferred ORM (EF Core, Dapper, NHibernate) and message broker\nStay lean - No forced dependencies, excellent for AOT compilation\n`mermaid\n%%{init: {'flowchart': {'nodeSpacing': 800}, 'themeVariables': {'fontSize': '200px'}}}%%\ngraph LR\n    subgraph ORM[\"ORM Integrations\"]\n        WhizEF[Whizbang EntityFramework<br/>EF Core Integration]\n        WhizDapper[Whizbang Dapper<br/>Dapper Integration]\n        WhizNH[Whizbang NHibernate<br/>NHibernate Integration]\n    end\n    subgraph Core[\"Core Packages\"]\n        WhizCore[Whizbang Core<br/>Mediator, Handlers, Pipeline]\n        WhizES[Whizbang EventSourcing<br/>Event Store, Aggregates]\n        WhizProj[Whizbang Projections<br/>Read Models, Subscriptions]\n        WhizMsg[Whizbang Messaging<br/>Distributed Messaging, Outbox/Inbox]\n    end\n    subgraph Messaging[\"Message Broker Adapters\"]\n        WhizKafka[Whizbang Kafka]\n        WhizRabbit[Whizbang RabbitMQ]\n        WhizASB[Whizbang AzureServiceBus]\n        WhizSQS[Whizbang AWSSQS]\n    end\n    subgraph Observability[\"Observability\"]\n        WhizOTel[Whizbang OpenTelemetry<br/>Tracing, Metrics]\n        WhizDash[Whizbang Dashboard<br/>Monitoring UI]\n    end\n    subgraph Dev[\"Developer Tools\"]\n        WhizAnalyzers[Whizbang Analyzers<br/>Roslyn Analyzers, Purity Checks]\n        WhizTesting[Whizbang Testing<br/>In-Memory Doubles, Test Helpers]\n    end\n    ORM - ->|Require| WhizES\n    Messaging -",
        "startIndex": 0,
        "preview": "Package Structure\nThis is a reference guide to all available Whizbang NuGet packages, their capabilities, and how to choose the right ones for your ap..."
      },
      {
        "id": "getting-started/package-structure-chunk-1",
        "text": "Projections<br/>Read Models, Subscriptions] WhizMsg[Whizbang Messaging<br/>Distributed Messaging, Outbox/Inbox] end subgraph Messaging[\"Message Broker Adapters\"] WhizKafka[Whizbang Kafka] WhizRabbit[Whizbang RabbitMQ] WhizASB[Whizbang AzureServiceBus] WhizSQS[Whizbang AWSSQS] end subgraph Observability[\"Observability\"] WhizOTel[Whizbang OpenTelemetry<br/>Tracing, Metrics] WhizDash[Whizbang Dashboard<br/>Monitoring UI] end subgraph Dev[\"Developer Tools\"] WhizAnalyzers[Whizbang Analyzers<br/>Roslyn Analyzers, Purity Checks] WhizTesting[Whizbang Testing<br/>In-Memory Doubles, Test Helpers] end ORM - ->|Require| WhizES Messaging - ->|Require| WhizMsg\n    WhizES --> WhizCore\n    WhizProj --> WhizCore\n    WhizProj --> WhizES\n    WhizMsg --> WhizCore\n`\nFunctional Area Color Key\nThe diagram uses color-coded edges to indicate functional areas:\n🟢 Green (Core) - Core business logic and domain functionality\n🔴 Red (Event) - Event sourcing, data persistence, and event handling\n🔵 Blue (Read) - Read models, projections, and query operations\n🟡 Yellow (Command) - Commands, write operations, and distributed messaging\n🔷 Teal (Observability) - Telemetry, metrics, tracing, and monitoring\n🟣 Purple (Infrastructure) - Developer tools, analyzers, and testing utilities\nCore Packages\nWhizbang Core\nThe minimal foundation for all Whizbang applications `bash\ndotnet add package Whizbang Core\n`\nIncludes:\nMessage routing (commands, events, queries)\nIn-memory mediator\nHandler discovery and execution\nBasic pipeline (validation, authorization hooks)\nNo persistence, no external messaging\nUse when:\nBuilding a simple CQRS application\nYou don't need event sourcing or projections\nIn-process messaging is sufficient\nLearning Whizbang\nExample:\n`csharp{\ntitle: \"Simple Mediator Setup - Complete Program cs\"\ndescription: \"Complete example showing Whizbang Core as an in-process mediator with handler discovery\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Mediator\", \"CQRS\", \"Setup\", \"Program cs\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\"]\nshowLineNumbers: true\ncollapsedLines: [1-3, 25-35]\n}\n// Stage 1: Imports\nusing Microsoft Extensions DependencyInjection;\nusing Microsoft Extensions Hosting;\nusing Whizbang;\n// Stage 2: Host builder setup\nvar builder = Host CreateApplicationBuilder(args);\n// Stage 3: Register Whizbang mediator (in-memory only)\nbuilder Services",
        "startIndex": 2086,
        "preview": "Projections<br/>Read Models, Subscriptions] WhizMsg[Whizbang Messaging<br/>Distributed Messaging, Outbox/Inbox] end subgraph Messaging[\"Message Broker..."
      },
      {
        "id": "getting-started/package-structure-chunk-2",
        "text": "Core\"] usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\"] showLineNumbers: true collapsedLines: [1-3, 25-35] } // Stage 1: Imports using Microsoft Extensions DependencyInjection; using Microsoft Extensions Hosting; using Whizbang; // Stage 2: Host builder setup var builder = Host CreateApplicationBuilder(args); // Stage 3: Register Whizbang mediator (in-memory only) builder Services AddWhizbang(options => {\n    // OPTION A: Source generator approach (recommended)\n    // Handlers decorated with [WhizbangHandler] are auto-discovered at compile time\n    options RegisterGeneratedHandlers();\n    // OPTION B: Explicit registration\n    // Manually register each handler for fine-grained control\n    // options RegisterHandler<PlaceOrder, PlaceOrderHandler>();\n    // options RegisterHandler<CancelOrder, CancelOrderHandler>();\n});\n// Stage 4: Build and run\nvar app = builder Build();\nawait app RunAsync();\n// Stage 5: Example handler decorated with [WhizbangHandler]\n[WhizbangHandler]  // Source generator picks this up\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderResult> {\n    public async Task<OrderResult> Handle(PlaceOrder command, CancellationToken ct) {\n        // Business logic here\n        return new OrderResult(command OrderId);\n    }\n}\n`\nHandler Discovery Approaches:\nWhizbang is 100% AOT-compatible and supports two ways to register handlers:\nSource Generator (Recommended): Decorate handlers with [WhizbangHandler] attribute At compile time, a source generator discovers all marked handlers and generates registration code Call options RegisterGeneratedHandlers() to use them `csharp\n   // Handler definition\n   [WhizbangHandler]\n   public class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderResult> { }\n   // Registration\n   options RegisterGeneratedHandlers();\n   `\n   Benefits:\nZero runtime reflection\nAOT-safe\nAutomatic discovery at compile time\nNo manual registration needed\nExplicit Registration: Manually register each handler Gives you full control and is AOT-safe `csharp\n   options RegisterHandler<PlaceOrder, PlaceOrderHandler>();\n   options RegisterHandler<CancelOrder, CancelOrderHandler>();\n   `\n   Benefits:\nFine-grained control over registration\nNo attributes in domain code\nExplicit and obvious\nAOT-safe\nNote: The [WhizbangHandler] attribute can be placed on:\nThe handler class itself\nA base class the handler inherits from\nAn interface the handler implements\nThe source generator will discover handlers through any of these paths",
        "startIndex": 3938,
        "preview": "Core\"] usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\"] showLineNumbers: true collapsedLines:..."
      },
      {
        "id": "getting-started/package-structure-chunk-3",
        "text": "` Benefits: Fine-grained control over registration No attributes in domain code Explicit and obvious AOT-safe Note: The [WhizbangHandler] attribute can be placed on: The handler class itself A base class the handler inherits from An interface the handler implements The source generator will discover handlers through any of these paths Attribute Naming: All Whizbang attributes use the Whizbang prefix for consistency and to avoid naming collisions ([WhizbangHandler], [WhizbangProjection], [WhizbangSubscribe]) ---\nWhizbang EventSourcing\nEvent sourcing and aggregate support `bash\ndotnet add package Whizbang EventSourcing\n`\nIncludes:\nEvent store abstraction\nAggregate base classes\nEvent stream management\nOptimistic concurrency\nEvent versioning\nRequires a persistence driver (see below)\nUse when:\nYou need event sourcing\nBuilding event-sourced aggregates\nYou want complete audit trails\nExample:\n`csharp{\ntitle: \"Event Sourcing Setup - Complete Program cs\"\ndescription: \"Complete example adding event sourcing to your application\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Event Sourcing\", \"Aggregates\", \"Setup\", \"Program cs\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\"]\nshowLineNumbers: true\ncollapsedLines: [1-3, 7-8]\n}\n// Stage 1: Imports\nusing Microsoft Extensions DependencyInjection;\nusing Microsoft Extensions Hosting;\nusing Whizbang;\n// Stage 2: Host builder setup\nvar builder = Host CreateApplicationBuilder(args);\n// Stage 3: Register Whizbang with event sourcing\nbuilder Services AddWhizbang(options => {\n    // Register handlers (using source generator)\n    options RegisterGeneratedHandlers();\n    // Stage 4: Enable event sourcing\n    options UseEventSourcing(es => {\n        // For production, use an ORM integration (see ORM Integrations section)\n        // es UseEntityFramework(ef => ef UseNpgsql(connectionString));\n        // es UseDapper(d => d UseNpgsql(connectionString));\n        // For development/testing, use in-memory store\n        es UseInMemoryStore();\n    });\n});\n// Stage 5: Build and run\nvar app = builder Build();\nawait app RunAsync();\n`\n---\nWhizbang Projections\nRead-side projections and CQRS queries `bash\ndotnet add package Whizbang",
        "startIndex": 6060,
        "preview": "` Benefits: Fine-grained control over registration No attributes in domain code Explicit and obvious AOT-safe Note: The [WhizbangHandler] attribute ca..."
      },
      {
        "id": "getting-started/package-structure-chunk-4",
        "text": "// es UseEntityFramework(ef => ef UseNpgsql(connectionString)); // es UseDapper(d => d UseNpgsql(connectionString)); // For development/testing, use in-memory store es UseInMemoryStore(); }); }); // Stage 5: Build and run var app = builder Build(); await app RunAsync(); ` --- Whizbang Projections Read-side projections and CQRS queries `bash dotnet add package Whizbang Projections\n`\nIncludes:\nProjection engine\nEvent subscription management\nCheckpoint tracking\nBackfilling from event history\nParallel processing across partitions\nUse when:\nBuilding read models from events\nImplementing CQRS\nYou need denormalized views for queries\nExample:\n`csharp{\ntitle: \"Projections Setup - Complete Program cs\"\ndescription: \"Complete example adding projection support with attribute-based registration\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"CQRS\", \"Read Models\", \"Program cs\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Projections\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\", \"System Threading Tasks\", \"System Threading\"]\nshowLineNumbers: true\ncollapsedLines: [1-3, 7-8, 28-30]\n}\n// Stage 1: Imports\nusing Microsoft Extensions DependencyInjection;\nusing Microsoft Extensions Hosting;\nusing Whizbang;\n// Stage 2: Host builder setup\nvar builder = Host CreateApplicationBuilder(args);\n// Stage 3: Register Whizbang with projections\nbuilder Services AddWhizbang(options => {\n    options RegisterGeneratedHandlers();\n    options UseEventSourcing(es => es UseInMemoryStore());\n    // Stage 4: Enable projections\n    options UseProjections(proj => {\n        // OPTION A: Attribute-based registration (recommended)\n        // Projections decorated with [Projection] are auto-discovered\n        proj RegisterGeneratedProjections();\n        // OPTION B: Manual registration\n        // proj RegisterProjection<OrderHistoryProjection>();\n        // proj RegisterProjection<CustomerSummaryProjection>();\n    });\n});\n// Stage 5: Build and run\nvar app = builder Build();\nawait app RunAsync();\n// Stage 6: Example projection with attribute-based event subscriptions\n[WhizbangProjection]  // Source generator picks this up\npublic class OrderHistoryProjection {\n    private readonly List<OrderSummary> _orders = new();\n    // Subscribe to events using [WhizbangSubscribe] attribute on method parameter\n    public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) {\n        _orders Add(new OrderSummary(\n            @event OrderId,\n            @event CustomerId,\n            @event Total,\n            \"Placed\"\n        ));\n        return Task",
        "startIndex": 8057,
        "preview": "// es UseEntityFramework(ef => ef UseNpgsql(connectionString)); // es UseDapper(d => d UseNpgsql(connectionString)); // For development/testing, use i..."
      },
      {
        "id": "getting-started/package-structure-chunk-5",
        "text": "event subscriptions [WhizbangProjection] // Source generator picks this up public class OrderHistoryProjection { private readonly List<OrderSummary> _orders = new(); // Subscribe to events using [WhizbangSubscribe] attribute on method parameter public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) { _orders Add(new OrderSummary( @event OrderId, @event CustomerId, @event Total, \"Placed\" )); return Task CompletedTask;\n    }\n    public Task Handle([WhizbangSubscribe] OrderShipped @event, CancellationToken ct) {\n        var order = _orders First(o => o OrderId == @event OrderId);\n        order Status = \"Shipped\";\n        return Task CompletedTask;\n    }\n    // Query method (not a subscription)\n    public IEnumerable<OrderSummary> GetOrders() => _orders;\n}\npublic record OrderSummary(Guid OrderId, Guid CustomerId, decimal Total, string Status) {\n    public string Status { get; set; } = Status;\n}\n`\nProjection Registration Approaches:\nWhizbang supports two ways to register projections:\nAttribute-Based (Recommended for AOT): Decorate projection classes with [WhizbangProjection] and mark event handler parameters with [WhizbangSubscribe] `csharp\n   [WhizbangProjection]  // Can be on class, base class, or interface\n   public class OrderHistoryProjection {\n       public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) {\n           // Handle event\n       }\n   }\n   // Registration\n   proj RegisterGeneratedProjections();\n   `\nManual Registration: Explicitly register each projection `csharp\n   proj RegisterProjection<OrderHistoryProjection>();\n   proj",
        "startIndex": 10366,
        "preview": "event subscriptions [WhizbangProjection] // Source generator picks this up public class OrderHistoryProjection { private readonly List<OrderSummary> _..."
      },
      {
        "id": "getting-started/package-structure-chunk-6",
        "text": "and mark event handler parameters with [WhizbangSubscribe] `csharp [WhizbangProjection] // Can be on class, base class, or interface public class OrderHistoryProjection { public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) { // Handle event } } // Registration proj RegisterGeneratedProjections(); ` Manual Registration: Explicitly register each projection `csharp proj RegisterProjection<OrderHistoryProjection>(); proj RegisterProjection<CustomerSummaryProjection>();\n   `\nEvent Subscription with [WhizbangSubscribe] Attribute:\nPlace [WhizbangSubscribe] directly on the method parameter representing the event\nOnly one parameter per method can have [WhizbangSubscribe]\nAdditional parameters (like CancellationToken, injected services, EventContext, ProjectionContext) are allowed\nMethod names are flexible: Use Handle, On, When, or any descriptive name you prefer\nAuto-registration: The source generator automatically wires subscriptions to service configuration\nThe source generator validates subscription rules at compile time\nSupports polymorphism: Subscribe to base classes or interfaces to handle multiple event types\nFor complete projection documentation, see:\nProjection Subscriptions - Event subscription patterns, polymorphism, generics, flexible method naming\nProjection Contexts - EventContext and ProjectionContext injection for metadata and CRUD operations\nProjection Purity - Maintaining pure, deterministic projections with compile-time enforcement\nProjection Return Values - Using return values for observability and metrics\nFor command handling documentation, see:\nCommand Handling - Business logic, CommandContext, event emission, sagas, and workflows\nWhizbang Messaging\nDistributed messaging and outbox/inbox patterns `bash\ndotnet add package Whizbang Messaging\n`\nIncludes:\nMessage broker abstraction\nOutbox/Inbox pattern for exactly-once delivery\nDomain ownership routing\nSaga coordination\nRequires a message broker adapter (see below)\nUse when:\nBuilding microservices\nYou need distributed messaging\nCommands/events cross service boundaries\nExample:\n`csharp{\ntitle: \"Distributed Messaging Setup - Complete Program cs\"\ndescription: \"Complete example configuring Whizbang for microservices with message broker\"\nframework: \"NET8\"\ncategory: \"Distributed Systems\"\ndifficulty: \"ADVANCED\"\ntags: [\"Messaging\", \"Microservices\", \"Distributed Systems\", \"Program cs\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Messaging\", \"Whizbang Kafka\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions",
        "startIndex": 11555,
        "preview": "and mark event handler parameters with [WhizbangSubscribe] `csharp [WhizbangProjection] // Can be on class, base class, or interface public class Orde..."
      },
      {
        "id": "getting-started/package-structure-chunk-7",
        "text": "cross service boundaries Example: `csharp{ title: \"Distributed Messaging Setup - Complete Program cs\" description: \"Complete example configuring Whizbang for microservices with message broker\" framework: \"NET8\" category: \"Distributed Systems\" difficulty: \"ADVANCED\" tags: [\"Messaging\", \"Microservices\", \"Distributed Systems\", \"Program cs\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Messaging\", \"Whizbang Kafka\"] usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\"]\nshowLineNumbers: true\ncollapsedLines: [1-3, 7-8, 36-38]\n}\n// Stage 1: Imports\nusing Microsoft Extensions DependencyInjection;\nusing Microsoft Extensions Hosting;\nusing Whizbang;\n// Stage 2: Host builder setup\nvar builder = Host CreateApplicationBuilder(args);\n// Stage 3: Register Whizbang with distributed messaging\nbuilder Services AddWhizbang(options => {\n    options RegisterGeneratedHandlers();\n    options UseEventSourcing(es => es UseInMemoryStore());\n    // Stage 4: Enable distributed messaging\n    options UseMessaging(msg => {\n        // Register logical domain ownership (no URLs - services communicate via broker)\n        msg UseDomainOwnership(domains => {\n            // Declare which domains THIS service owns\n            domains RegisterDomain(\"Orders\");    // This service owns Orders domain\n            domains RegisterDomain(\"Payments\");  // This service owns Payments domain\n            // Other domains owned by other services:\n            // - \"Inventory\" owned by Inventory service\n            // - \"Shipping\" owned by Shipping service\n        });\n        // Configure message broker (how services actually communicate)\n        msg UseKafka(kafka => {\n            kafka BootstrapServers = \"localhost:9092\";\n            // Topic routing based on domain ownership\n            kafka CommandTopicPattern = \"commands {domain}\";  // commands Orders, commands Inventory\n            kafka EventTopicPattern = \"events {domain}\";      // events Orders, events Payments\n        });\n        // Enable exactly-once semantics\n        msg UseOutbox();  // Reliable message publishing (transactional)\n        msg UseInbox();   // Idempotent message consumption (deduplication)\n    });\n});\n// Stage 5: Build and run\nvar app = builder Build();\nawait app RunAsync();\n`\nDomain Ownership Explained:\nDomain ownership is logical, not physical",
        "startIndex": 13670,
        "preview": "cross service boundaries Example: `csharp{ title: \"Distributed Messaging Setup - Complete Program cs\" description: \"Complete example configuring Whizb..."
      },
      {
        "id": "getting-started/package-structure-chunk-8",
        "text": "// events Orders, events Payments }); // Enable exactly-once semantics msg UseOutbox(); // Reliable message publishing (transactional) msg UseInbox(); // Idempotent message consumption (deduplication) }); }); // Stage 5: Build and run var app = builder Build(); await app RunAsync(); ` Domain Ownership Explained: Domain ownership is logical, not physical Services declare which domains they own, and Whizbang routes messages based on ownership:\nCommands are sent TO the domain owner\nEvents are published BY the domain owner\nServices communicate via message broker (not HTTP endpoints)\nExample Message Flow:\n`csharp\n// Inventory service sends PlaceOrder command\n// → Whizbang routes to Kafka topic \"commands Orders\"\n// → Orders service (domain owner) receives and handles it\nawait whizbang Send(new PlaceOrder( ));\n// Orders service publishes OrderPlaced event\n// → Whizbang publishes to Kafka topic \"events Orders\"\n// → All interested services (Inventory, Shipping, etc ) receive it\nawait whizbang Publish(new OrderPlaced( ));\n`\nRouting Configuration:\nThe message broker adapter handles physical routing Different deployment scenarios use different configurations:\nIn-Process (Monolith): All domains in one service, in-memory routing\nMicroservices (Kafka): Domains in separate services, Kafka topics\nKubernetes (RabbitMQ): Pods communicate via RabbitMQ exchanges\nHybrid: Some domains in-process, others distributed\nThe domain registration stays the same—only the message broker adapter configuration changes ---\nORM Integrations\nWhizbang uses ORMs (not custom database drivers) for persistence, allowing you to leverage existing tools and database compatibility Whizbang EntityFramework\nEntity Framework Core integration for event store and projections `bash\ndotnet add package Whizbang EntityFramework\n`\nFeatures:\nWorks with ANY EF Core database provider (Postgres, SQL Server, MySQL, SQLite, Cosmos DB, etc",
        "startIndex": 15537,
        "preview": "// events Orders, events Payments }); // Enable exactly-once semantics msg UseOutbox(); // Reliable message publishing (transactional) msg UseInbox();..."
      },
      {
        "id": "getting-started/package-structure-chunk-9",
        "text": "ORMs (not custom database drivers) for persistence, allowing you to leverage existing tools and database compatibility Whizbang EntityFramework Entity Framework Core integration for event store and projections `bash dotnet add package Whizbang EntityFramework ` Features: Works with ANY EF Core database provider (Postgres, SQL Server, MySQL, SQLite, Cosmos DB, etc )\nAutomatic migrations for event store schema\nDbContext integration for projections\nChange tracking for optimistic concurrency\nFull LINQ query support for projections\nShadow properties for metadata\nUse when:\nYou're already using Entity Framework Core\nYou want automatic migrations and schema management\nYou need complex LINQ queries in projections\nYou prefer convention-over-configuration\nExample with Postgres:\n`csharp{\ntitle: \"Entity Framework with Postgres\"\ndescription: \"Using EF Core with Postgres for event store and projections\"\nframework: \"NET8\"\ncategory: \"Persistence\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Entity Framework\", \"Postgres\", \"Event Store\", \"ORM\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang EntityFramework\", \"Npgsql EntityFrameworkCore PostgreSQL\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseEntityFramework(ef => {\n            // Use any EF Core database provider\n            ef UseNpgsql(\"Host=localhost;Database=myapp;Username=user;Password=pass\");\n            // Optional: customize event store schema\n            ef EventStoreSchema = \"events\";\n            ef EnableSensitiveDataLogging = false;\n        });\n    });\n});\n`\nExample with SQL Server:\n`csharp{\ntitle: \"Entity Framework with SQL Server\"\ndescription: \"Using EF Core with SQL Server for event store\"\nframework: \"NET8\"\ncategory: \"Persistence\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Entity Framework\", \"SQL Server\", \"Event Store\", \"ORM\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang EntityFramework\", \"Microsoft EntityFrameworkCore SqlServer\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseEntityFramework(ef => {\n            ef UseSqlServer(\"Server=localhost;Database=myapp;Trusted_Connection=True;\");\n        });\n    });\n});\n`\n---\nWhizbang Dapper\nDapper integration for high-performance event store and projections `bash\ndotnet add package Whizbang",
        "startIndex": 17099,
        "preview": "ORMs (not custom database drivers) for persistence, allowing you to leverage existing tools and database compatibility Whizbang EntityFramework Entity..."
      },
      {
        "id": "getting-started/package-structure-chunk-10",
        "text": "DependencyInjection\", \"Whizbang\"] showLineNumbers: true } using Microsoft Extensions DependencyInjection; using Whizbang; var services = new ServiceCollection(); services AddWhizbang(options => { options UseEventSourcing(es => { es UseEntityFramework(ef => { ef UseSqlServer(\"Server=localhost;Database=myapp;Trusted_Connection=True;\"); }); }); }); ` --- Whizbang Dapper Dapper integration for high-performance event store and projections `bash dotnet add package Whizbang Dapper\n`\nFeatures:\nWorks with ANY ADO NET database provider (Postgres, SQL Server, MySQL, SQLite, Oracle, etc )\nMinimal overhead - nearly raw SQL performance\nExplicit control over SQL queries\nBulk insert optimizations for event batches\nCustom type handlers for domain types\nMulti-database support in single application\nUse when:\nPerformance is critical\nYou want explicit control over SQL\nYou're comfortable writing queries\nYou need the absolute fastest event sourcing\nYou're using multiple database types\nExample with Postgres:\n`csharp{\ntitle: \"Dapper with Postgres\"\ndescription: \"Using Dapper with Postgres for high-performance event store\"\nframework: \"NET8\"\ncategory: \"Persistence\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Dapper\", \"Postgres\", \"Event Store\", \"Performance\", \"ORM\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Dapper\", \"Npgsql\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseDapper(dapper => {\n            dapper UseNpgsql(\"Host=localhost;Database=myapp;Username=user;Password=pass\");\n            // Optional: customize SQL queries for specific database optimizations\n            dapper UseJsonBinaryFormat = true;  // Postgres JSONB\n            dapper BatchSize = 1000;            // Bulk insert optimization\n        });\n    });\n});\n`\nExample with SQL Server:\n`csharp{\ntitle: \"Dapper with SQL Server\"\ndescription: \"Using Dapper with SQL Server for event store\"\nframework: \"NET8\"\ncategory: \"Persistence\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Dapper\", \"SQL Server\", \"Event Store\", \"Performance\", \"ORM\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Dapper\", \"Microsoft Data SqlClient\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseDapper(dapper => {\n            dapper",
        "startIndex": 19463,
        "preview": "DependencyInjection\", \"Whizbang\"] showLineNumbers: true } using Microsoft Extensions DependencyInjection; using Whizbang; var services = new ServiceCo..."
      },
      {
        "id": "getting-started/package-structure-chunk-11",
        "text": "tags: [\"Dapper\", \"SQL Server\", \"Event Store\", \"Performance\", \"ORM\"] nugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Dapper\", \"Microsoft Data SqlClient\"] usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"] showLineNumbers: true } using Microsoft Extensions DependencyInjection; using Whizbang; var services = new ServiceCollection(); services AddWhizbang(options => { options UseEventSourcing(es => { es UseDapper(dapper => { dapper UseSqlServer(\"Server=localhost;Database=myapp;Trusted_Connection=True;\");\n            // SQL Server optimizations\n            dapper UseMemoryOptimizedTables = true;\n            dapper EnableChangeTracking = true;\n        });\n    });\n});\n`\n---\nWhizbang NHibernate\nNHibernate integration for event store and projections `bash\ndotnet add package Whizbang NHibernate\n`\nFeatures:\nWorks with ANY NHibernate-supported database (Postgres, SQL Server, MySQL, Oracle, SQLite, etc )\nMature ORM with extensive database support\nXML or fluent mapping configuration\nAdvanced caching strategies (first-level, second-level, query cache)\nLazy loading and eager fetching strategies\nSupports legacy database schemas\nUse when:\nYou're already using NHibernate\nYou need advanced caching strategies\nYou're working with legacy database schemas\nYou require complex mapping scenarios\nYou want mature, battle-tested ORM\nExample with Postgres:\n`csharp{\ntitle: \"NHibernate with Postgres\"\ndescription: \"Using NHibernate with Postgres for event store\"\nframework: \"NET8\"\ncategory: \"Persistence\"\ndifficulty: \"ADVANCED\"\ntags: [\"NHibernate\", \"Postgres\", \"Event Store\", \"ORM\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang NHibernate\", \"NHibernate\", \"NHibernate Driver NpgsqlDriver\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\", \"NHibernate Cfg\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing NHibernate Cfg;\nusing Whizbang;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseNHibernate(nh => {\n            nh ConfigureWith(cfg => {\n                cfg DataBaseIntegration(db => {\n                    db ConnectionString = \"Host=localhost;Database=myapp;Username=user;Password=pass\";\n                    db Driver<NpgsqlDriver>();\n                    db Dialect<PostgreSQLDialect>();\n                });\n                // Optional: enable second-level cache\n                cfg Cache(c => {\n                    c UseSecondLevelCache = true;\n                    c UseQueryCache = true;\n                });\n            });\n        });\n    });\n});\n`\n---\nChoosing an ORM\nEntity Framework - Best for:\nGeneral-purpose applications\nAutomatic migrations\nConvention-over-configuration\nComplex LINQ queries\nMost",
        "startIndex": 21670,
        "preview": "tags: [\"Dapper\", \"SQL Server\", \"Event Store\", \"Performance\", \"ORM\"] nugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Dapper\", \"Mic..."
      },
      {
        "id": "getting-started/package-structure-chunk-12",
        "text": "db ConnectionString = \"Host=localhost;Database=myapp;Username=user;Password=pass\"; db Driver<NpgsqlDriver>(); db Dialect<PostgreSQLDialect>(); }); // Optional: enable second-level cache cfg Cache(c => { c UseSecondLevelCache = true; c UseQueryCache = true; }); }); }); }); }); ` --- Choosing an ORM Entity Framework - Best for: General-purpose applications Automatic migrations Convention-over-configuration Complex LINQ queries Most NET developers (familiar)\nDapper - Best for:\nHigh-performance scenarios\nExplicit SQL control\nMinimal overhead\nLarge event volumes\nPolyglot persistence (multiple databases)\nNHibernate - Best for:\nLegacy database integration\nAdvanced caching requirements\nComplex mapping scenarios\nEnterprise applications with existing NHibernate usage\n---\nMessage Broker Adapters\nWhizbang Kafka\nApache Kafka adapter for distributed messaging `bash\ndotnet add package Whizbang Kafka\n`\nFeatures:\nHigh throughput\nPartition-aware consumers\nCompacted topics for snapshots\nExactly-once semantics\nUse when:\nBuilding event-driven microservices at scale\nYou need event replay and time-travel capabilities\n---\nWhizbang RabbitMQ\nRabbitMQ adapter for distributed messaging `bash\ndotnet add package Whizbang RabbitMQ\n`\nFeatures:\nFlexible routing\nPriority queues\nDead-letter exchanges\nPublisher confirms\n---\nWhizbang AzureServiceBus\nAzure Service Bus adapter `bash\ndotnet add package Whizbang AzureServiceBus\n`\nFeatures:\nManaged service (no infrastructure)\nSessions for ordered processing\nDuplicate detection\nIntegration with Azure ecosystem\n---\nWhizbang AWSSQS\nAWS SQS/SNS adapter `bash\ndotnet add package Whizbang AWSSQS\n`\nFeatures:\nManaged service\nFIFO queues for ordering\nIntegration with AWS ecosystem\n---\nObservability Packages\nWhizbang OpenTelemetry\nOpenTelemetry integration `bash\ndotnet add package Whizbang OpenTelemetry\n`\nIncludes:\nAutomatic tracing for all messages\nMetrics for throughput, latency, errors\nDistributed context propagation\n---\nWhizbang Dashboard\nWeb-based monitoring dashboard `bash\ndotnet add package Whizbang Dashboard\n`\nFeatures:\nLive message flow visualization\nProjection lag monitoring\nError tracking\nPerformance metrics\n---\nDeveloper Packages\nWhizbang Analyzers\nRoslyn analyzers for compile-time validation `bash\ndotnet add package Whizbang",
        "startIndex": 23997,
        "preview": "db ConnectionString = \"Host=localhost;Database=myapp;Username=user;Password=pass\"; db Driver<NpgsqlDriver>(); db Dialect<PostgreSQLDialect>(); }); // ..."
      },
      {
        "id": "getting-started/package-structure-chunk-13",
        "text": "all messages Metrics for throughput, latency, errors Distributed context propagation --- Whizbang Dashboard Web-based monitoring dashboard `bash dotnet add package Whizbang Dashboard ` Features: Live message flow visualization Projection lag monitoring Error tracking Performance metrics --- Developer Packages Whizbang Analyzers Roslyn analyzers for compile-time validation `bash dotnet add package Whizbang Analyzers\n`\nIncludes:\nProjection Purity Checks: Enforce pure functions in projections\nNo field/property mutations outside method scope\nNo I/O operations (file system, network, database writes)\nNo static mutation\nNo logging or side effects in projection handlers\nHandler Validation: Enforce [Pure] attribute on command/query handlers\nDomain Ownership: Detect missing domain ownership attributes\nNaming Conventions: Validate event and command naming conventions\nAsync Patterns: Check for synchronous I/O in async handlers\nSubscription Rules: Validate [WhizbangSubscribe] usage (one per method, etc )\nSecurity Context: Warn when security-sensitive operations lack tenant/user validation\nPurity Enforcement Example:\n`csharp\n[WhizbangProjection]\npublic class OrderProjection {\n    private readonly ILogger _logger;  // ⚠️ Warning: Injected services should be read-only\n    // ✅ VALID - Pure projection handler\n    public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) {\n        // Pure state updates only\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - Side effect detected (logging)\n    public Task Handle([WhizbangSubscribe] OrderShipped @event, CancellationToken ct) {\n        _logger LogInformation(\"Order shipped\");  // 💥 Compile error: Side effect in projection\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - I/O operation detected\n    public async Task Handle([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) {\n        await File WriteAllTextAsync(\"log txt\", \"cancelled\");  // 💥 Compile error: I/O in projection\n    }\n}\n`\n---\nWhizbang Testing\nTesting utilities and in-memory doubles `bash\ndotnet add package Whizbang Testing\n`\nIncludes:\nIn-memory event store\nFake message bus\nProjection test helpers\nAggregate test fixtures\n---\nCustomizable Attributes\nWhizbang uses attributes for source generator discovery ([WhizbangHandler], [WhizbangProjection], [WhizbangSubscribe]), and these attributes are customizable to fit your team's preferences or naming conventions",
        "startIndex": 25846,
        "preview": "all messages Metrics for throughput, latency, errors Distributed context propagation --- Whizbang Dashboard Web-based monitoring dashboard `bash dotne..."
      },
      {
        "id": "getting-started/package-structure-chunk-14",
        "text": "utilities and in-memory doubles `bash dotnet add package Whizbang Testing ` Includes: In-memory event store Fake message bus Projection test helpers Aggregate test fixtures --- Customizable Attributes Whizbang uses attributes for source generator discovery ([WhizbangHandler], [WhizbangProjection], [WhizbangSubscribe]), and these attributes are customizable to fit your team's preferences or naming conventions Why the Whizbang prefix All attributes use consistent Whizbang prefix to:\nAvoid naming collisions with other frameworks (e g , generic [Handler] attribute)\nProvide clear visual indication of framework-specific attributes\nEnable easy searching across codebase (grep \"WhizbangHandler\")\nMaintain consistent naming convention\nUsing Custom Attribute Names\nYou can configure Whizbang to recognize alternate attribute names:\n`csharp{\ntitle: \"Custom Attribute Names Configuration\"\ndescription: \"Configure Whizbang to use custom attribute names\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Attributes\", \"Source Generator\", \"Configuration\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nvar builder = Host CreateApplicationBuilder(args);\nbuilder Services AddWhizbang(options => {\n    // Configure custom attribute names\n    options Attributes(attr => {\n        // Use your own handler attribute name\n        attr HandlerAttribute = \"MyCompany CommandHandlerAttribute\";\n        // Use your own projection attribute name\n        attr ProjectionAttribute = \"MyCompany ProjectionAttribute\";\n        // Use your own subscription attribute name\n        attr SubscribeAttribute = \"MyCompany EventSubscriptionAttribute\";\n    });\n    options RegisterGeneratedHandlers();\n    options UseProjections(proj => proj RegisterGeneratedProjections());\n});\n`\nSource-Generated Attributes (Future)\nIn future versions, Whizbang may provide source-generated attributes that are automatically created in your project:\n`csharp\n// Auto-generated by Whizbang source generator\nnamespace MyCompany;\n[AttributeUsage(AttributeTargets Class | AttributeTargets Interface)]\npublic class CommandHandlerAttribute : Attribute { }\n[AttributeUsage(AttributeTargets Class | AttributeTargets Interface)]\npublic class ProjectionAttribute : Attribute { }\n[AttributeUsage(AttributeTargets Parameter)]\npublic class EventSubscriptionAttribute : Attribute { }\n`\nBenefits:\nNo dependency on Whizbang",
        "startIndex": 27879,
        "preview": "utilities and in-memory doubles `bash dotnet add package Whizbang Testing ` Includes: In-memory event store Fake message bus Projection test helpers A..."
      },
      {
        "id": "getting-started/package-structure-chunk-15",
        "text": "your project: `csharp // Auto-generated by Whizbang source generator namespace MyCompany; [AttributeUsage(AttributeTargets Class | AttributeTargets Interface)] public class CommandHandlerAttribute : Attribute { } [AttributeUsage(AttributeTargets Class | AttributeTargets Interface)] public class ProjectionAttribute : Attribute { } [AttributeUsage(AttributeTargets Parameter)] public class EventSubscriptionAttribute : Attribute { } ` Benefits: No dependency on Whizbang Core in your domain layer\nYour own namespace and naming conventions\nStill compatible with Whizbang's source generator\nEnables clean architecture (domain doesn't reference framework)\nWhy Customizable Attributes Team Conventions: Match your existing attribute naming patterns\nClean Architecture: Keep framework attributes out of domain layer\nLegacy Integration: Reuse existing attributes from other frameworks\nMulti-Framework: Use same attributes with multiple frameworks\n---\nPackage Decision Tree\n`\nDo you need event sourcing ├─ NO → Whizbang Core (mediator only)\n└─ YES → Whizbang Core + Whizbang EventSourcing\n          └─ Choose an ORM integration:\n              ├─ Whizbang EntityFramework (recommended for most)\n              ├─ Whizbang Dapper (high performance)\n              └─ Whizbang NHibernate (enterprise/legacy)\nDo you need read models └─ YES → Add Whizbang Projections\nAre you building microservices └─ YES → Add Whizbang Messaging\n          └─ Choose a message broker adapter:\n              ├─ Whizbang Kafka\n              ├─ Whizbang RabbitMQ\n              ├─ Whizbang AzureServiceBus\n              └─ Whizbang AWSSQS\nDo you need observability └─ YES → Add Whizbang OpenTelemetry or Whizbang Dashboard\nAre you developing/testing └─ YES → Add Whizbang Testing and Whizbang Analyzers\n`\n---\nTypical Configurations\nSimple Monolith\n`bash\ndotnet add package Whizbang Core\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang EntityFramework\ndotnet add package Npgsql EntityFrameworkCore PostgreSQL\n`\n---\nMonolith with Read Models\n`bash\ndotnet add package Whizbang Core\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang Projections\ndotnet add package Whizbang EntityFramework\ndotnet add package Npgsql EntityFrameworkCore PostgreSQL\n`\n---\nHigh-Performance Monolith\n`bash\ndotnet add package Whizbang Core\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang",
        "startIndex": 30002,
        "preview": "your project: `csharp // Auto-generated by Whizbang source generator namespace MyCompany; [AttributeUsage(AttributeTargets Class | AttributeTargets In..."
      },
      {
        "id": "getting-started/package-structure-chunk-16",
        "text": "Monolith with Read Models `bash dotnet add package Whizbang Core dotnet add package Whizbang EventSourcing dotnet add package Whizbang Projections dotnet add package Whizbang EntityFramework dotnet add package Npgsql EntityFrameworkCore PostgreSQL ` --- High-Performance Monolith `bash dotnet add package Whizbang Core dotnet add package Whizbang EventSourcing dotnet add package Whizbang Projections\ndotnet add package Whizbang Dapper\ndotnet add package Npgsql\n`\n---\nMicroservices with Kafka\n`bash\ndotnet add package Whizbang Core\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang Projections\ndotnet add package Whizbang Messaging\ndotnet add package Whizbang EntityFramework\ndotnet add package Npgsql EntityFrameworkCore PostgreSQL\ndotnet add package Whizbang Kafka\ndotnet add package Whizbang OpenTelemetry\n`\n---\nEnterprise with SQL Server\n`bash\ndotnet add package Whizbang Core\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang Projections\ndotnet add package Whizbang NHibernate\ndotnet add package NHibernate\ndotnet add package NHibernate Driver MicrosoftDataSqlClientDriver\n`\n---\nNext Steps\nGetting Started - Build your first Whizbang application\nPhilosophy - Understand Whizbang's design principles and architectural philosophy\nCore Concepts - Deep dive into commands, events, projections, and aggregates\nDriver System - Learn how to implement custom drivers\nTesting - Test your event-sourced applications",
        "startIndex": 31674,
        "preview": "Monolith with Read Models `bash dotnet add package Whizbang Core dotnet add package Whizbang EventSourcing dotnet add package Whizbang Projections dot..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "observability/dashboard",
    "title": "Whizbang Dashboard",
    "category": "Observability",
    "url": "/docs/observability/dashboard",
    "chunks": [
      {
        "id": "observability/dashboard-chunk-0",
        "text": "Whizbang Dashboard\nThe Whizbang Dashboard is a separate web application (package: Whizbang Dashboard) that provides real-time visualization of your event-sourced, message-driven system Overview\nThe dashboard offers:\nMessage Journey Visualization - See the complete lifecycle of commands and events\nDistributed Tracing - Track messages across microservices\nProjection Health - Monitor projection lag and errors\nEvent Stream Explorer - Browse aggregate event streams\nPerformance Metrics - Throughput, latency, error rates\nControl Plane - Send control commands to services\nInstallation\nNuGet Package\n`bash\ndotnet add package Whizbang Dashboard\n`\nStandalone Dashboard Application\nOr run as a separate service:\n`bash\ndotnet tool install --global Whizbang Dashboard\nwhizbang-dashboard --port 5050\n`\nEmbedded in Application\nAdd to your ASP NET Core application:\n`csharp{\ntitle: \"Embed Dashboard in Application\"\ndescription: \"Add dashboard to existing ASP NET Core app\"\nframework: \"NET8\"\ncategory: \"Observability\"\ndifficulty: \"BEGINNER\"\ntags: [\"Dashboard\", \"Setup\"]\nnugetPackages: [\"Whizbang Dashboard\", \"Microsoft AspNetCore\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft AspNetCore Builder\", \"Whizbang Dashboard\"]\nshowLineNumbers: true\n}\nusing Microsoft AspNetCore Builder;\nusing Whizbang Dashboard;\nvar builder = WebApplication CreateBuilder(args);\n// Add Whizbang Dashboard\nbuilder Services AddWhizbangDashboard(options => {\n    options EnableRealTimeUpdates = true;\n    options RetentionPeriod = TimeSpan FromHours(24);  // Keep traces for 24 hours\n    options RequireAuthentication = true;              // Protect dashboard\n});\nvar app = builder Build();\n// Mount dashboard at /whizbang\napp MapWhizbangDashboard(\"/whizbang\");\napp",
        "startIndex": 0,
        "preview": "Whizbang Dashboard\nThe Whizbang Dashboard is a separate web application (package: Whizbang Dashboard) that provides real-time visualization of your ev..."
      },
      {
        "id": "observability/dashboard-chunk-1",
        "text": "var builder = WebApplication CreateBuilder(args); // Add Whizbang Dashboard builder Services AddWhizbangDashboard(options => { options EnableRealTimeUpdates = true; options RetentionPeriod = TimeSpan FromHours(24); // Keep traces for 24 hours options RequireAuthentication = true; // Protect dashboard }); var app = builder Build(); // Mount dashboard at /whizbang app MapWhizbangDashboard(\"/whizbang\"); app Run();\n`\nAccess at: http://localhost:5000/whizbang\nMessage Journey Visualization\nEnd-to-End Flow\nSee the complete journey of a command through your system:\n`\nPlaceOrder (Command)\n  ↓\nOrderCommandHandler\n  ↓\nOrderPlaced (Event)\n  ├─→ OrderHistoryProjection (updated)\n  ├─→ InventoryReservationSaga (triggered)\n  │   ↓\n  │   ReserveInventory (Command) → InventoryService\n  │   ↓\n  │   InventoryReserved (Event)\n  │   ↓\n  │   ProcessPayment (Command) → PaymentService\n  │   ↓\n  │   PaymentProcessed (Event)\n  └─→ CustomerNotificationHandler (email sent)\n`\nDashboard Visualization:\n`\n┌────────────────────────────────────────────────────────────┐\n│  Message Journey: PlaceOrder                               │\n├────────────────────────────────────────────────────────────┤\n│                                                             │\n│  [PlaceOrder] ──→ [OrderHandler] ──→ [OrderPlaced]         │\n│      ↓ 42ms          ↓ 120ms           ↓                   │\n│      │               │                 ├─→ [OrderHistory]  │\n│      │               │                 │    ↓ 15ms         │\n│      │               │                 │                   │\n│      │               │                 ├─→ [ReserveSaga]   │\n│      │               │                 │    ↓ 200ms        │\n│      │               │                 │    └─→ [Inventory]│\n│      │               │                 │         ↓ 350ms   │\n│      │               │                 │         └─→ [Pay] │\n│      │               │                 │              ↓    │\n│      │               │                 └─→ [Notify] ✓      │\n│                                                             │\n│  Total Duration: 727ms                                      │\n│  Status: ✓ Success                                          │\n└────────────────────────────────────────────────────────────┘\n`\nInteractive Trace Explorer\nClick on any message to drill down:\n`\n┌────────────────────────────────────────────────────────────┐\n│  OrderPlaced Event Details                                 │\n├────────────────────────────────────────────────────────────┤\n│  Event ID: evt_01J7G3KZ9P │\n│  Timestamp: 2025-10-18 14:32:15 234 UTC                    │\n│  Correlation ID: cmd_01J7G3KZ8N │\n│  Causation ID: cmd_01J7G3KZ8N │\n│                                                             │\n│  Payload:                                                   │\n│  {                                                          │\n│    \"orderId\": \"ord_123\",                                    │\n│    \"customerId\": \"cust_456\",                                │\n│    \"total\": 99 99,                                          │\n│    \"items\": [ /",
        "startIndex": 1736,
        "preview": "var builder = WebApplication CreateBuilder(args); // Add Whizbang Dashboard builder Services AddWhizbangDashboard(options => { options EnableRealTimeU..."
      },
      {
        "id": "observability/dashboard-chunk-2",
        "text": "Details │ ├────────────────────────────────────────────────────────────┤ │ Event ID: evt_01J7G3KZ9P │ │ Timestamp: 2025-10-18 14:32:15 234 UTC │ │ Correlation ID: cmd_01J7G3KZ8N │ │ Causation ID: cmd_01J7G3KZ8N │ │ │ │ Payload: │ │ { │ │ \"orderId\": \"ord_123\", │ │ \"customerId\": \"cust_456\", │ │ \"total\": 99 99, │ │ \"items\": [ / / ]                                   │\n│  }                                                          │\n│                                                             │\n│  Metadata:                                                  │\n│  - Tenant: acme-corp                                        │\n│  - User: john doe@acme com                                  │\n│  - Source: orders-service-pod-3                             │\n│  - Trace ID: 4bf92f3577b34da6a3ce929d0e0e4736              │\n│                                                             │\n│  Subscribers (3):                                           │\n│  ✓ OrderHistoryProjection (15ms)                           │\n│  ✓ InventoryReservationSaga (200ms)                        │\n│  ✓ CustomerNotificationHandler (42ms)                      │\n└────────────────────────────────────────────────────────────┘\n`\nDistributed Tracing\nCross-Service Traces\nVisualize messages flowing across microservices:\n`\nAPI Gateway         Orders Service      Inventory Service    Payment Service\n    │                     │                     │                   │\n    ├─ PlaceOrder ──────→ │                     │                   │\n    │                     ├─ OrderPlaced ──────→│                   │\n    │                     │                     ├─ ReserveInventory │\n    │                     │                     │                   │\n    │                     │ ←── InventoryReserved                   │\n    │                     ├─ ProcessPayment ────────────────────→  │\n    │                     │                     │                   │\n    │                     │ ←─────────────────── PaymentProcessed ─┤\n    │ ←── OrderConfirmed ─┤                     │                   │\n    │                     │                     │                   │\n`\nOpenTelemetry Integration:\nThe dashboard integrates with OpenTelemetry traces:\n`csharp{\ntitle: \"OpenTelemetry Integration\"\ndescription: \"Dashboard reads OpenTelemetry traces\"\nframework: \"NET8\"\ncategory: \"Observability\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"OpenTelemetry\", \"Tracing\", \"Dashboard\"]\nnugetPackages: [\"Whizbang Dashboard\", \"Whizbang OpenTelemetry\"]\nusingStatements: [\"Whizbang Dashboard\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang Dashboard;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbangDashboard(options => {\n    // Read traces from OpenTelemetry collector\n    options UseOpenTelemetry(otel => {\n        otel Endpoint = \"http://otel-collector:4317\";\n        otel Protocol = OpenTelemetryProtocol Grpc;\n    });\n    // Or from Jaeger\n    options UseJaeger(jaeger => {\n        jaeger Endpoint = \"http://jaeger:16686\";\n    });\n    // Or from Zipkin\n    options UseZipkin(zipkin => {\n        zipkin",
        "startIndex": 4494,
        "preview": "Details │ ├────────────────────────────────────────────────────────────┤ │ Event ID: evt_01J7G3KZ9P │ │ Timestamp: 2025-10-18 14:32:15 234 UTC │ │ Cor..."
      },
      {
        "id": "observability/dashboard-chunk-3",
        "text": "using Microsoft Extensions DependencyInjection; services AddWhizbangDashboard(options => { // Read traces from OpenTelemetry collector options UseOpenTelemetry(otel => { otel Endpoint = \"http://otel-collector:4317\"; otel Protocol = OpenTelemetryProtocol Grpc; }); // Or from Jaeger options UseJaeger(jaeger => { jaeger Endpoint = \"http://jaeger:16686\"; }); // Or from Zipkin options UseZipkin(zipkin => { zipkin Endpoint = \"http://zipkin:9411\";\n    });\n});\n`\nTrace Timeline View\nWaterfall chart showing message timing:\n`\nTime ──────────────────────────────────────────────────→\n0ms   100ms  200ms  300ms  400ms  500ms  600ms  700ms\nPlaceOrder\n│────────────│ (120ms)\n             OrderPlaced\n             │──────────────────│ (200ms - saga processing)\n                                ReserveInventory\n                                │──────────────│ (150ms)\n                                               InventoryReserved\n                                               │────────────│ (100ms)\n                                                           ProcessPayment\n                                                           │──────────────│ (150ms)\n                                                                         PaymentProcessed\n                                                                         │─│ (5ms - notification)\n═══════════════════════════════════════════════════════════════════════════\nTotal: 727ms\n`\nProjection Health Monitoring\nProjection Dashboard\nReal-time view of all projections:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Projections                                                      │\n├──────────────────────────────────────────────────────────────────┤\n│                                                                   │\n│  Name                   Status    Lag      Throughput    Errors  │\n│  ────────────────────   ──────    ────     ──────────    ──────  │\n│  OrderHistory           🟢 OK     2ms      450 evt/sec   0       │\n│  CustomerStats          🟢 OK     5ms      320 evt/sec   0       │\n│  InventorySummary       🟡 WARN   2 5s     180 evt/sec   0       │\n│  ProductRecommendations 🔴 ERROR  45s      0 evt/sec     15      │\n│                                                                   │\n│  [Rebuild] [Pause] [Reset Checkpoint]                            │\n└──────────────────────────────────────────────────────────────────┘\n`\nLag Alert: Visual indicator when projection falls behind event stream Projection Details\nDrill into individual projection:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Projection: ProductRecommendations                               │\n├──────────────────────────────────────────────────────────────────┤\n│  Status: 🔴 ERROR                                                 │\n│  Last Processed Event: evt_01J7G3KZ9P",
        "startIndex": 7270,
        "preview": "using Microsoft Extensions DependencyInjection; services AddWhizbangDashboard(options => { // Read traces from OpenTelemetry collector options UseOpen..."
      },
      {
        "id": "observability/dashboard-chunk-4",
        "text": "🔴 ERROR 45s 0 evt/sec 15 │ │ │ │ [Rebuild] [Pause] [Reset Checkpoint] │ └──────────────────────────────────────────────────────────────────┘ ` Lag Alert: Visual indicator when projection falls behind event stream Projection Details Drill into individual projection: ` ┌──────────────────────────────────────────────────────────────────┐ │ Projection: ProductRecommendations │ ├──────────────────────────────────────────────────────────────────┤ │ Status: 🔴 ERROR │ │ Last Processed Event: evt_01J7G3KZ9P (45 seconds ago)        │\n│  Current Checkpoint: 123,456                                      │\n│  Latest Event Position: 125,890                                   │\n│  Lag: 2,434 events (~45 seconds)                                  │\n│                                                                   │\n│  Recent Errors (15):                                              │\n│  - NullReferenceException at UpdateRecommendations:42            │\n│  - NullReferenceException at UpdateRecommendations:42            │\n│  - NullReferenceException at UpdateRecommendations:42            │\n│  [View Stack Trace]                                               │\n│                                                                   │\n│  Actions:                                                         │\n│  [Rebuild from Start] [Rebuild from Checkpoint] [Skip Failed]    │\n└──────────────────────────────────────────────────────────────────┘\n`\nActions:\nRebuild: Clear projection and replay all events\nSkip: Skip the failing event and continue\nPause: Stop projection processing\nEvent Stream Explorer\nBrowse aggregate event streams:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Event Stream: Order-ord_123                                      │\n├──────────────────────────────────────────────────────────────────┤\n│                                                                   │\n│  [0] OrderPlaced              2025-10-18 14:32:15 UTC            │\n│      Customer: cust_456       Total: $99 99                       │\n│                                                                   │\n│  [1] OrderItemAdded           2025-10-18 14:33:02 UTC            │\n│      Product: Widget          Quantity: 2                         │\n│                                                                   │\n│  [2] OrderShipped             2025-10-18 14:45:10 UTC            │\n│      Carrier: UPS             Tracking: 1Z999AA10123456789        │\n│                                                                   │\n│  [3] OrderDelivered           2025-10-20 10:15:33 UTC            │\n│      Signature: J",
        "startIndex": 9723,
        "preview": "🔴 ERROR 45s 0 evt/sec 15 │ │ │ │ [Rebuild] [Pause] [Reset Checkpoint] │ └──────────────────────────────────────────────────────────────────┘ ` Lag Al..."
      },
      {
        "id": "observability/dashboard-chunk-5",
        "text": "│ │ Customer: cust_456 Total: $99 99 │ │ │ │ [1] OrderItemAdded 2025-10-18 14:33:02 UTC │ │ Product: Widget Quantity: 2 │ │ │ │ [2] OrderShipped 2025-10-18 14:45:10 UTC │ │ Carrier: UPS Tracking: 1Z999AA10123456789 │ │ │ │ [3] OrderDelivered 2025-10-20 10:15:33 UTC │ │ Signature: J Doe        Location: Front door                │\n│                                                                   │\n│  Total Events: 4              Aggregate Version: 3                │\n│                                                                   │\n│  [Replay] [Download JSON] [View Snapshots]                        │\n└──────────────────────────────────────────────────────────────────┘\n`\nFeatures:\nView full event stream for any aggregate\nDownload events as JSON\nReplay events (time-travel debugging)\nView snapshots (if enabled)\nPerformance Metrics\nThroughput Dashboard\nReal-time metrics:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Throughput (Last 5 Minutes)                                      │\n├──────────────────────────────────────────────────────────────────┤\n│                                                                   │\n│  Commands/sec:  ████████████████░░░░  120/sec                    │\n│  Events/sec:    ██████████████████░░  450/sec                    │\n│  Queries/sec:   ████████████░░░░░░░░  80/sec                     │\n│                                                                   │\n│  Avg Latency:                                                     │\n│  - Commands:    42ms   (p50: 35ms, p95: 120ms, p99: 250ms)       │\n│  - Events:      15ms   (p50: 12ms, p95: 45ms, p99: 80ms)         │\n│  - Queries:     8ms    (p50: 5ms, p95: 25ms, p99: 50ms)          │\n│                                                                   │\n│  Error Rate:    0 02%  (3 errors in 15,000 messages)             │\n└──────────────────────────────────────────────────────────────────┘\n`\nService Health\nMonitor individual services:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Services                                                         │\n├──────────────────────────────────────────────────────────────────┤\n│  Name              Status    CPU    Memory   Replicas   Requests │\n│  ──────────────    ──────    ───    ──────   ────────   ──────── │\n│  orders-service    🟢 OK     23%    1 2 GB   3/3        450/sec  │\n│  inventory-service 🟢 OK     45%    800 MB   2/2        320/sec  │\n│  payment-service   🟡 WARN   78%    1",
        "startIndex": 11840,
        "preview": "│ │ Customer: cust_456 Total: $99 99 │ │ │ │ [1] OrderItemAdded 2025-10-18 14:33:02 UTC │ │ Product: Widget Quantity: 2 │ │ │ │ [2] OrderShipped 2025-..."
      },
      {
        "id": "observability/dashboard-chunk-6",
        "text": "services: ` ┌──────────────────────────────────────────────────────────────────┐ │ Services │ ├──────────────────────────────────────────────────────────────────┤ │ Name Status CPU Memory Replicas Requests │ │ ────────────── ────── ─── ────── ──────── ──────── │ │ orders-service 🟢 OK 23% 1 2 GB 3/3 450/sec │ │ inventory-service 🟢 OK 45% 800 MB 2/2 320/sec │ │ payment-service 🟡 WARN 78% 1 8 GB   2/2        180/sec  │\n│  shipping-service  🟢 OK     12%    600 MB   1/1        80/sec   │\n└──────────────────────────────────────────────────────────────────┘\n`\nControl Plane UI\nSend Control Commands\nFrom the dashboard UI:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Control Commands                                                 │\n├──────────────────────────────────────────────────────────────────┤\n│                                                                   │\n│  Command: [Rebuild Projection ▼]                                 │\n│                                                                   │\n│  Projection Name: [OrderHistory_____________]                     │\n│  Target Service:  [All Services ▼]                                │\n│  Start From:      [Beginning of Time ▼]                           │\n│                                                                   │\n│  ⚠️  Warning: This will clear and rebuild the projection │\n│      Queries may return incomplete data during rebuild │\n│                                                                   │\n│  [Cancel]  [Execute Command]                                      │\n└──────────────────────────────────────────────────────────────────┘\n`\nAvailable Commands:\nRebuild Projection\nSet Log Level\nClear Caches\nRun Health Check\nToggle Feature Flags\nPause/Resume Message Processing\nCommand History\nTrack what control commands were executed:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Command History                                                  │\n├──────────────────────────────────────────────────────────────────┤\n│  Time                Command                   User      Status  │\n│  ──────────────────  ────────────────────────  ────────  ──────  │\n│  14:52:10 UTC        Rebuild OrderHistory      admin     ✓ Done  │\n│  14:45:33 UTC        Set Log Level=Debug       john doe  ✓ Done  │\n│  14:32:15 UTC        Clear Cache               admin     ✗ Failed│\n│  14:18:02 UTC        Pause Projection          jane doe  ✓ Done  │\n└──────────────────────────────────────────────────────────────────┘\n`\nSearch and Filtering\nSearch Messages\nFind specific messages:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Search Messages                                                  │\n├──────────────────────────────────────────────────────────────────┤\n│  Query: [customer_id:cust_456 AND status:shipped_____________]   │\n│  Time Range: [Last 24 Hours ▼]                                   │\n│  [Search]                                                         │\n│                                                                   │\n│  Results (42):                                                    │\n│  ────────────────────────────────────────────────────────────────│\n│  OrderShipped - ord_123 - 2025-10-18 14:45:10                    │\n│  OrderShipped - ord_789 - 2025-10-18 12:15:33                    │\n│  OrderShipped - ord_456 - 2025-10-17 16:32:45                    │\n│",
        "startIndex": 14055,
        "preview": "services: ` ┌──────────────────────────────────────────────────────────────────┐ │ Services │ ├───────────────────────────────────────────────────────..."
      },
      {
        "id": "observability/dashboard-chunk-7",
        "text": "│ Query: [customer_id:cust_456 AND status:shipped_____________] │ │ Time Range: [Last 24 Hours ▼] │ │ [Search] │ │ │ │ Results (42): │ │ ────────────────────────────────────────────────────────────────│ │ OrderShipped - ord_123 - 2025-10-18 14:45:10 │ │ OrderShipped - ord_789 - 2025-10-18 12:15:33 │ │ OrderShipped - ord_456 - 2025-10-17 16:32:45 │ │ │\n└──────────────────────────────────────────────────────────────────┘\n`\nQuery Syntax:\nevent_type:OrderPlaced\ntenant_id:acme-corp\ntimestamp > 2025-10-18\nstatus:error AND service:payment\nReal-Time Updates\nDashboard updates in real-time via SignalR:\n`csharp{\ntitle: \"Real-Time Dashboard Updates\"\ndescription: \"Dashboard receives live updates via SignalR\"\nframework: \"NET8\"\ncategory: \"Observability\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Dashboard\", \"SignalR\", \"Real-Time\"]\nnugetPackages: [\"Whizbang Dashboard\", \"Microsoft AspNetCore SignalR\"]\nusingStatements: [\"Whizbang Dashboard\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang Dashboard;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbangDashboard(options => {\n    // Real-time updates via SignalR\n    options EnableRealTimeUpdates = true;\n    // Push notifications for important events\n    options PushNotifications(notify => {\n        notify OnProjectionError = true;\n        notify OnHighLatency = true;\n        notify OnErrorRateThreshold = 0 05;  // Alert if error rate > 5%\n    });\n});\n`\nFeatures:\nLive message journey updates\nReal-time projection lag updates\nInstant error notifications\nThroughput graphs update every second\nSecurity\nAuthentication\nProtect the dashboard:\n`csharp{\ntitle: \"Dashboard Authentication\"\ndescription: \"Secure dashboard with authentication\"\nframework: \"NET8\"\ncategory: \"Security\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Dashboard\", \"Authentication\", \"Security\"]\nnugetPackages: [\"Whizbang Dashboard\", \"Microsoft AspNetCore Authentication\"]\nusingStatements: [\"Whizbang Dashboard\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang Dashboard;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbangDashboard(options => {\n    // Require authentication\n    options RequireAuthentication = true;\n    // Role-based access\n    options RequireRole(\"WhizbangAdmin\");\n    // Or custom authorization policy\n    options RequirePolicy(\"WhizbangDashboardAccess\");\n});\n`\nAudit Log\nTrack who accessed the dashboard:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Audit Log                                                        │\n├──────────────────────────────────────────────────────────────────┤\n│  Timestamp           User         Action                          │\n│  ──────────────────  ───────────  ─────────────────────────────  │\n│  14:52:10 UTC        admin        Rebuilt projection OrderHistory│\n│  14:45:33 UTC        john",
        "startIndex": 17189,
        "preview": "│ Query: [customer_id:cust_456 AND status:shipped_____________] │ │ Time Range: [Last 24 Hours ▼] │ │ [Search] │ │ │ │ Results (42): │ │ ─────────────..."
      },
      {
        "id": "observability/dashboard-chunk-8",
        "text": "true; // Role-based access options RequireRole(\"WhizbangAdmin\"); // Or custom authorization policy options RequirePolicy(\"WhizbangDashboardAccess\"); }); ` Audit Log Track who accessed the dashboard: ` ┌──────────────────────────────────────────────────────────────────┐ │ Audit Log │ ├──────────────────────────────────────────────────────────────────┤ │ Timestamp User Action │ │ ────────────────── ─────────── ───────────────────────────── │ │ 14:52:10 UTC admin Rebuilt projection OrderHistory│ │ 14:45:33 UTC john doe     Viewed order stream ord_123    │\n│  14:32:15 UTC        admin        Set log level to Debug         │\n│  14:18:02 UTC        jane doe     Paused projection              │\n└──────────────────────────────────────────────────────────────────┘\n`\nNext Steps\nObservability - OpenTelemetry integration\nAdvanced Scenarios - Control plane commands\nDistributed Messaging - Cross-service tracing",
        "startIndex": 19710,
        "preview": "true; // Role-based access options RequireRole(\"WhizbangAdmin\"); // Or custom authorization policy options RequirePolicy(\"WhizbangDashboardAccess\"); }..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "projections/projection-contexts",
    "title": "Projection Contexts",
    "category": "Projections",
    "url": "/docs/projections/projection-contexts",
    "chunks": [
      {
        "id": "projections/projection-contexts-chunk-0",
        "text": "Projection Contexts\nWhizbang provides two types of context for projections:\nEventContext - Rich event metadata (pure data, no side effects)\nProjectionContext - Projection-specific operations and metadata (CRUD operations, projection info)\nBoth can be injected at the method level or constructor level `mermaid\ngraph LR\n    Event[Event] --> Handler[Projection Handler]\n    subgraph Contexts[\"Injected Contexts\"]\n        EC[EventContext<br/>Pure Data Only]\n        PC[ProjectionContext<br/>With CRUD Operations]\n    end\n    subgraph ECData[\"EventContext Contents\"]\n        System[System Data<br/>Timestamp, Machine, etc ]\n        Security[Security Context<br/>User, Tenant, Roles]\n        EventMeta[Event Metadata<br/>EventId, Causation]\n        Tracing[Tracing Context<br/>CorrelationId, TraceId]\n    end\n    subgraph PCData[\"ProjectionContext Contents\"]\n        ProjMeta[Projection Metadata<br/>Name, Version, Type]\n        ServiceMeta[Service Metadata<br/>Environment, Machine]\n        Store[Projection Store<br/>Create, Update, Patch, Delete]\n    end\n    EC --> ECData\n    PC --> PCData\n    Handler --> EC\n    Handler --> PC\n    PC --> Store\n    style Event fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    style Handler fill:#cce5ff,stroke:#004085,stroke-width:2px\n    style EC fill:#d4edda,stroke:#28a745,stroke-width:2px\n    style PC fill:#d1ecf1,stroke:#0c5460,stroke-width:2px\n    style Store fill:#f8d7da,stroke:#dc3545,stroke-width:2px\n`\nEventContext Injection\nEventContext is pure data (no side effects) that provides rich metadata about every event EventContext Structure\n`csharp\npublic class EventContext {\n    // System metadata\n    public SystemData System { get; init; }\n    // Security and multi-tenancy context\n    public SecurityContext Security { get; init; }\n    // Event-specific metadata\n    public EventMetadata Event { get; init; }\n    // Distributed tracing information\n    public TracingContext Tracing { get; init; }\n}\npublic class SystemData {\n    // System-generated metadata\n    public DateTime Timestamp { get; init; }\n    public string MachineName { get; init; }\n    public string Environment { get; init; }\n    public long EventSequenceNumber { get; init; }\n    // Custom system metadata (extensible)\n    public IReadOnlyDictionary<string, object> CustomMetadata { get; init; }\n}\npublic class SecurityContext {\n    // User information\n    public Guid UserId { get; init; }\n    public string UserName { get; init; }\n    public IReadOnlyList<string> Roles { get; init; }\n    // Multi-tenancy\n    public Guid",
        "startIndex": 0,
        "preview": "Projection Contexts\nWhizbang provides two types of context for projections:\nEventContext - Rich event metadata (pure data, no side effects)\nProjection..."
      },
      {
        "id": "projections/projection-contexts-chunk-1",
        "text": "{ get; init; } // Custom system metadata (extensible) public IReadOnlyDictionary<string, object> CustomMetadata { get; init; } } public class SecurityContext { // User information public Guid UserId { get; init; } public string UserName { get; init; } public IReadOnlyList<string> Roles { get; init; } // Multi-tenancy public Guid TenantId { get; init; }\n    public string TenantName { get; init; }\n    // Permissions (evaluated at command/event creation time)\n    public IReadOnlyList<string> Permissions { get; init; }\n    // Service trust boundary\n    public bool IsTrustedService { get; init; }\n    public string ServiceName { get; init; }\n}\npublic class EventMetadata {\n    // Event identification\n    public Guid EventId { get; init; }\n    public string EventType { get; init; }\n    public int EventVersion { get; init; }\n    // Causation (what caused this event)\n    public Guid CausationId { get; init; }  // Command that caused this event\n    public string CausationType { get; init; }\n    // Custom event metadata\n    public IReadOnlyDictionary<string, object> CustomMetadata { get; init; }\n}\npublic class TracingContext {\n    // Distributed tracing\n    public string CorrelationId { get; init; }  // End-to-end request tracking\n    public string TraceId { get; init; }        // OpenTelemetry trace ID\n    public string SpanId { get; init; }         // OpenTelemetry span ID\n    // Message journey\n    public int HopCount { get; init; }          // Number of services traversed\n    public DateTime InitiatedAt { get; init; }  // When the original request started\n}\n`\nEventContext Usage Example\n`csharp{\ntitle: \"EventContext Usage in Projections\"\ndescription: \"Accessing system metadata, security context, and tracing information\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"EventContext\", \"Security\", \"Multi-Tenancy\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading",
        "startIndex": 2543,
        "preview": "{ get; init; } // Custom system metadata (extensible) public IReadOnlyDictionary<string, object> CustomMetadata { get; init; } } public class Security..."
      },
      {
        "id": "projections/projection-contexts-chunk-2",
        "text": "Example `csharp{ title: \"EventContext Usage in Projections\" description: \"Accessing system metadata, security context, and tracing information\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Projections\", \"EventContext\", \"Security\", \"Multi-Tenancy\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"] usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading; using System Threading Tasks;\n[WhizbangProjection]\npublic class TenantOrderHistoryProjection {\n    private readonly Dictionary<Guid, List<TenantOrderRecord>> _ordersByTenant = new();\n    public Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        EventContext context,\n        CancellationToken ct) {\n        // Use security context for tenant isolation\n        if ( context Security TenantId HasValue) {\n            throw new InvalidOperationException(\"TenantId is required for order events\");\n        }\n        var tenantId = context Security TenantId Value;\n        // Create tenant-scoped record with rich context\n        var record = new TenantOrderRecord {\n            OrderId = @event OrderId,\n            TenantId = tenantId,\n            TenantName = context Security TenantName,\n            CustomerId = @event CustomerId,\n            Total = @event Total,\n            // System metadata\n            PlacedAt = context System Timestamp,\n            PlacedBy = context Security UserName,\n            PlacedByUserId = context Security UserId,\n            // Tracing\n            CorrelationId = context Tracing CorrelationId,\n            OriginatedAt = context Tracing InitiatedAt,\n            // Event metadata\n            EventId = context Event EventId,\n            CausationId = context Event CausationId  // The PlaceOrder command ID\n        };\n        if ( _ordersByTenant ContainsKey(tenantId)) {\n            _ordersByTenant[tenantId] = new List<TenantOrderRecord>();\n        }\n        _ordersByTenant[tenantId] Add(record);\n        return Task CompletedTask;\n    }\n    // Query methods (tenant-scoped)\n    public IEnumerable<TenantOrderRecord> GetOrdersForTenant(Guid tenantId) {\n        return _ordersByTenant TryGetValue(tenantId, out var orders) orders\n            : Enumerable Empty<TenantOrderRecord>();\n    }\n}\npublic record TenantOrderRecord {\n    public Guid OrderId { get; init; }\n    public Guid TenantId { get; init; }\n    public string TenantName { get; init; }\n    public Guid CustomerId { get; init; }\n    public decimal Total { get; init; }\n    // System metadata\n    public DateTime PlacedAt { get; init; }\n    public string PlacedBy { get; init; }\n    public Guid",
        "startIndex": 4306,
        "preview": "Example `csharp{ title: \"EventContext Usage in Projections\" description: \"Accessing system metadata, security context, and tracing information\" framew..."
      },
      {
        "id": "projections/projection-contexts-chunk-3",
        "text": "get; init; } public Guid TenantId { get; init; } public string TenantName { get; init; } public Guid CustomerId { get; init; } public decimal Total { get; init; } // System metadata public DateTime PlacedAt { get; init; } public string PlacedBy { get; init; } public Guid PlacedByUserId { get; init; }\n    // Tracing\n    public string CorrelationId { get; init; }\n    public DateTime OriginatedAt { get; init; }\n    // Event lineage\n    public Guid EventId { get; init; }\n    public Guid CausationId { get; init; }\n}\n`\nEventContext Benefits\nMulti-Tenancy: Access tenant context for data isolation\nSecurity: User, roles, permissions available for authorization\nAuditing: Track who did what and when\nTracing: End-to-end request tracking with correlation IDs\nCausation: Link events back to originating commands\nPure Data: All context is immutable, enabling pure function projections\nExtensible: Custom metadata dictionaries for app-specific data\nPurity Guarantees\nEventContext is designed to maintain projection purity:\nImmutable: All properties are init-only\nNo side effects: Contains only data, no methods with side effects\nNo I/O: No database, file system, or network access\nDeterministic: Same event + context always produces same projection state\nRoslyn Analyzers: Whizbang Analyzers enforces purity rules at compile time\n---\nProjectionContext Injection\nWhile EventContext is pure data, ProjectionContext provides database operations and projection metadata It can be injected at the method level or constructor level",
        "startIndex": 6516,
        "preview": "get; init; } public Guid TenantId { get; init; } public string TenantName { get; init; } public Guid CustomerId { get; init; } public decimal Total { ..."
      },
      {
        "id": "projections/projection-contexts-chunk-4",
        "text": "system, or network access Deterministic: Same event + context always produces same projection state Roslyn Analyzers: Whizbang Analyzers enforces purity rules at compile time --- ProjectionContext Injection While EventContext is pure data, ProjectionContext provides database operations and projection metadata It can be injected at the method level or constructor level ProjectionContext Structure\n`csharp\npublic class ProjectionContext {\n    // Projection metadata\n    public ProjectionMetadata Projection { get; init; }\n    // Service information\n    public ServiceMetadata Service { get; init; }\n    // Database operations (Create, Update, Patch, Delete)\n    public IProjectionStore Store { get; init; }\n}\npublic class ProjectionMetadata {\n    public string ProjectionName { get; init; }\n    public string ProjectionVersion { get; init; }\n    public Type ProjectionType { get; init; }\n    public DateTime StartedAt { get; init; }\n    // Custom projection metadata\n    public IReadOnlyDictionary<string, object> CustomMetadata { get; init; }\n}\npublic class ServiceMetadata {\n    public string ServiceName { get; init; }\n    public string ServiceVersion { get; init; }\n    public string Environment { get; init; }\n    public string MachineName { get; init; }\n}\npublic interface IProjectionStore {\n    // Create\n    Task CreateAsync<TProjection>(TProjection projection, CancellationToken ct = default)\n        where TProjection : class;\n    // Read (for checking existence or retrieving current state)\n    Task<TProjection",
        "startIndex": 7767,
        "preview": "system, or network access Deterministic: Same event + context always produces same projection state Roslyn Analyzers: Whizbang Analyzers enforces puri..."
      },
      {
        "id": "projections/projection-contexts-chunk-5",
        "text": "} public string ServiceVersion { get; init; } public string Environment { get; init; } public string MachineName { get; init; } } public interface IProjectionStore { // Create Task CreateAsync<TProjection>(TProjection projection, CancellationToken ct = default) where TProjection : class; // Read (for checking existence or retrieving current state) Task<TProjection > GetAsync<TProjection>(object key, CancellationToken ct = default)\n        where TProjection : class;\n    // Update (replace entire document)\n    Task UpdateAsync<TProjection>(object key, TProjection projection, CancellationToken ct = default)\n        where TProjection : class;\n    // Patch (partial update)\n    Task PatchAsync<TProjection>(object key, Action<TProjection> patchAction, CancellationToken ct = default)\n        where TProjection : class;\n    // Delete\n    Task DeleteAsync<TProjection>(object key, CancellationToken ct = default)\n        where TProjection : class;\n    // Batch operations\n    Task CreateManyAsync<TProjection>(IEnumerable<TProjection> projections, CancellationToken ct = default)\n        where TProjection : class;\n}\n// Return values for projection methods\npublic enum ProjectionReturnType {\n    Accepted,  // Event was processed successfully (default)\n    Ignored    // Event was intentionally ignored/skipped\n}\npublic static class ProjectionContextExtensions {\n    // Return a projection outcome (metadata only, no side effects)\n    public static Task Return(this ProjectionContext context, ProjectionReturnType returnType) {\n        context RecordOutcome(returnType);\n        return Task CompletedTask;\n    }\n}\n`\nProjectionContext Usage Examples\nSee the complete examples in Projection Return Values ProjectionContext Benefits\nDatabase Operations: Built-in CRUD operations (Create, Update, Patch, Delete)\nProjection Metadata: Access projection name, version, and custom metadata\nService Context: Know which service and environment the projection is running in\nFlexible Injection: Inject at method or constructor level based on your needs\nBatch Operations: Efficient bulk creates for high-throughput scenarios\nReturn Values: Signal processing outcomes with Return() method\n---\nNext Steps\nProjection Subscriptions - Event subscription patterns\nProjection Purity - Maintaining pure, deterministic projections\nProjection Return Values - Using return values for observability",
        "startIndex": 8920,
        "preview": "} public string ServiceVersion { get; init; } public string Environment { get; init; } public string MachineName { get; init; } } public interface IPr..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "projections/projection-purity",
    "title": "Projection Purity",
    "category": "Projections",
    "url": "/docs/projections/projection-purity",
    "chunks": [
      {
        "id": "projections/projection-purity-chunk-0",
        "text": "Projection Purity\nCRITICAL: Projections must be pure functions and deterministic The same event must ALWAYS produce the same projection state, regardless of when it's processed The Purity Rule\nProjections are read-side transformations that convert event data into queryable read models They must:\nBe deterministic (same input = same output)\nHave no side effects\nUse only data from events or EventContext\nNever perform business logic\nGood vs Bad Projections\n✅ Good Projection (Pure)\n`csharp{\ntitle: \"Pure Projection Example\"\ndescription: \"Correct projection using only event data and EventContext\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Purity\", \"Best Practices\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class GoodProjection {\n    // ✅ CORRECT: Use event timestamp from EventContext\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        EventContext eventContext,\n        CancellationToken ct) {\n        var summary = new OrderSummary {\n            OrderId = @event OrderId,\n            PlacedAt = eventContext System Timestamp,  // ✅ Deterministic\n            ExpiresAt = @event ExpiresAt,              // ✅ From event (business logic set this)\n            CustomerId = @event CustomerId,\n            Total = @event Total\n        };\n        await projection Store CreateAsync(summary, ct);\n    }\n    // ✅ CORRECT: Business logic decision in event, not projection\n    public Task OnOrderPlaced2(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // Event already contains IsExpired flag (set by business logic)\n        if (@event IsExpired) {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Process non-expired order\n        return Task CompletedTask;\n    }\n    // ✅ CORRECT: Use data from event or context\n    public async Task OnOrderShipped(\n        [WhizbangSubscribe] OrderShipped @event,\n        ProjectionContext projection,\n        EventContext eventContext,\n        CancellationToken ct) {\n        await projection Store PatchAsync<OrderSummary>(\n            @event OrderId,\n            order => {\n                order Status = \"Shipped\";\n                order ShippedAt = eventContext System Timestamp;  // ✅ From context\n                order TrackingNumber = @event",
        "startIndex": 0,
        "preview": "Projection Purity\nCRITICAL: Projections must be pure functions and deterministic The same event must ALWAYS produce the same projection state, regardl..."
      },
      {
        "id": "projections/projection-purity-chunk-1",
        "text": "// ✅ CORRECT: Use data from event or context public async Task OnOrderShipped( [WhizbangSubscribe] OrderShipped @event, ProjectionContext projection, EventContext eventContext, CancellationToken ct) { await projection Store PatchAsync<OrderSummary>( @event OrderId, order => { order Status = \"Shipped\"; order ShippedAt = eventContext System Timestamp; // ✅ From context order TrackingNumber = @event TrackingNumber;      // ✅ From event\n            },\n            ct);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public DateTime PlacedAt { get; set; }\n    public DateTime ExpiresAt { get; set; }\n    public Guid CustomerId { get; set; }\n    public decimal Total { get; set; }\n    public string Status { get; set; }\n    public DateTime ShippedAt { get; set; }\n    public string TrackingNumber { get; set; }\n}\n`\n❌ Bad Projection (Impure)\n`csharp{\ntitle: \"Impure Projection Example\"\ndescription: \"Common purity violations and how to avoid them\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Anti-Patterns\", \"Common Mistakes\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System IO\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System IO;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class BadProjection {\n    // ❌ WRONG: DateTime UtcNow is non-deterministic\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        var summary = new OrderSummary {\n            OrderId = @event OrderId,\n            PlacedAt = DateTime UtcNow,  // ❌ NON-DETERMINISTIC - Will be different on replay };\n        await projection Store CreateAsync(summary, ct);\n        // 💥 Whizbang Analyzers will flag this as a compile error\n    }\n    // ❌ WRONG: Business logic in projection\n    public Task OnOrderPlaced2(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        EventContext eventContext,\n        CancellationToken ct) {\n        // ❌ WRONG: Calculating expiration in projection is business logic\n        var age = DateTime UtcNow - eventContext System Timestamp;  // ❌ Non-deterministic\n        if (age > TimeSpan FromDays(90)) {\n            return projection Return(ProjectionReturnType",
        "startIndex": 2639,
        "preview": "// ✅ CORRECT: Use data from event or context public async Task OnOrderShipped( [WhizbangSubscribe] OrderShipped @event, ProjectionContext projection, ..."
      },
      {
        "id": "projections/projection-purity-chunk-2",
        "text": "❌ WRONG: Business logic in projection public Task OnOrderPlaced2( [WhizbangSubscribe] OrderPlaced @event, ProjectionContext projection, EventContext eventContext, CancellationToken ct) { // ❌ WRONG: Calculating expiration in projection is business logic var age = DateTime UtcNow - eventContext System Timestamp; // ❌ Non-deterministic if (age > TimeSpan FromDays(90)) { return projection Return(ProjectionReturnType Ignored);\n        }\n        // Business logic belongs in command handler or aggregate, not projection return Task CompletedTask;\n        // 💥 Whizbang Analyzers will flag DateTime UtcNow usage\n    }\n    // ❌ WRONG: Random values\n    public async Task OnOrderPlaced3(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        var summary = new OrderSummary {\n            OrderId = @event OrderId,\n            RandomValue = Random Shared Next()  // ❌ NON-DETERMINISTIC\n        };\n        await projection Store CreateAsync(summary, ct);\n        // 💥 Whizbang Analyzers will flag Random usage\n    }\n    // ❌ WRONG: External I/O in projection\n    public async Task OnOrderPlaced4(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        HttpClient httpClient,\n        CancellationToken ct) {\n        // ❌ WRONG: Calling external API is non-deterministic\n        var customerData = await httpClient GetAsync($\"https://api/customers/{@event CustomerId}\");\n        // External data can change - not deterministic // 💥 Whizbang Analyzers will flag external I/O\n    }\n    // ❌ WRONG: File I/O in projection\n    public async Task OnOrderPlaced5(\n        [WhizbangSubscribe] OrderPlaced @event,\n        CancellationToken ct) {\n        // ❌ WRONG: File writes are side effects\n        await File WriteAllTextAsync(\"orders log\", @event OrderId ToString());\n        // 💥 Whizbang Analyzers will flag file I/O\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public DateTime PlacedAt { get; set; }\n    public int RandomValue { get; set; }\n}\n`\nPurity Rules\nProjections must follow these rules to remain pure and deterministic:\n| ❌ NEVER Use | ✅ Instead Use | Why |\n|-----------------|-------------------|---------|\n| DateTime UtcNow | eventContext System Timestamp | Current time is non-deterministic |\n| DateTime Now | eventContext System",
        "startIndex": 4666,
        "preview": "❌ WRONG: Business logic in projection public Task OnOrderPlaced2( [WhizbangSubscribe] OrderPlaced @event, ProjectionContext projection, EventContext e..."
      },
      {
        "id": "projections/projection-purity-chunk-3",
        "text": "RandomValue { get; set; } } ` Purity Rules Projections must follow these rules to remain pure and deterministic: | ❌ NEVER Use | ✅ Instead Use | Why | |-----------------|-------------------|---------| | DateTime UtcNow | eventContext System Timestamp | Current time is non-deterministic | | DateTime Now | eventContext System Timestamp | Current time is non-deterministic |\n| Random / Guid NewGuid() | Data from event or context | Random values are non-deterministic |\n| External API calls | Data in event | External data can change |\n| Database reads (outside projection store) | Data in event | External data can change |\n| File I/O | Data in event | External data can change |\n| Environment variables | eventContext or config in event | Environment can change |\n| Business logic calculations | Business logic sets flags in event | Projections transform, don't decide |\nWhere Business Logic Belongs\nBusiness logic must live in command handlers and aggregates, NOT in projections ✅ Correct: Business Logic in Command Handler\n`csharp{\ntitle: \"Business Logic in Command Handler\"\ndescription: \"Correct placement of business logic and decision-making\"\nframework: \"NET8\"\ncategory: \"Command Handling\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Command Handlers\", \"Business Logic\", \"Best Practices\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n// ✅ CORRECT: Business logic in command handler or aggregate\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderPlaced> {\n    public async Task<OrderPlaced> Handle(\n        PlaceOrder command,\n        CommandContext context,\n        CancellationToken ct) {\n        // ✅ Business logic happens HERE\n        // - Validate the order\n        // - Check inventory\n        // - Calculate totals\n        // - Apply business rules\n        // - Decide if order should be marked as expired\n        var expiresAt = DateTime UtcNow",
        "startIndex": 6647,
        "preview": "RandomValue { get; set; } } ` Purity Rules Projections must follow these rules to remain pure and deterministic: | ❌ NEVER Use | ✅ Instead Use | Why |..."
      },
      {
        "id": "projections/projection-purity-chunk-4",
        "text": "public async Task<OrderPlaced> Handle( PlaceOrder command, CommandContext context, CancellationToken ct) { // ✅ Business logic happens HERE // - Validate the order // - Check inventory // - Calculate totals // - Apply business rules // - Decide if order should be marked as expired var expiresAt = DateTime UtcNow AddDays(90);  // ✅ Business decision\n        var isExpired = false;  // ✅ Business decision\n        var status = \"Placed\";   // ✅ Business decision\n        // Create event POCO with results of business logic\n        // Event is just a data container - NO logic in the event class itself\n        var @event = context EmitEvent(new OrderPlaced {\n            OrderId = command OrderId,\n            CustomerId = command CustomerId,\n            Total = command Total,\n            ExpiresAt = expiresAt,      // ✅ Set by handler\n            IsExpired = isExpired,       // ✅ Set by handler\n            Status = status              // ✅ Set by handler\n        });\n        return @event;\n    }\n}\n// ✅ CORRECT: Event is just a POCO (Plain Old CLR Object)\n// NO business logic, NO methods (except maybe ToString for debugging)\n// Just immutable data describing what happened\npublic record OrderPlaced {\n    public Guid OrderId { get; init; }\n    public Guid CustomerId { get; init; }\n    public decimal Total { get; init; }\n    public DateTime ExpiresAt { get; init; }     // ✅ Data only\n    public bool IsExpired { get; init; }         // ✅ Data only\n    public string Status { get; init; }          // ✅ Data only\n    // ❌ NO business logic methods like:\n    // public bool ShouldExpire() => DateTime",
        "startIndex": 8342,
        "preview": "public async Task<OrderPlaced> Handle( PlaceOrder command, CommandContext context, CancellationToken ct) { // ✅ Business logic happens HERE // - Valid..."
      },
      {
        "id": "projections/projection-purity-chunk-5",
        "text": "{ get; init; } public DateTime ExpiresAt { get; init; } // ✅ Data only public bool IsExpired { get; init; } // ✅ Data only public string Status { get; init; } // ✅ Data only // ❌ NO business logic methods like: // public bool ShouldExpire() => DateTime UtcNow > ExpiresAt;\n    // public void MarkAsExpired() => IsExpired = true;\n    // Events are immutable data - handlers make decisions, events record them\n}\n// ✅ CORRECT: Projection just transforms event data\n[WhizbangProjection]\npublic class OrderProjection {\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // ✅ No business logic - just transform POCO event to read model\n        var summary = new OrderSummary {\n            OrderId = @event OrderId,\n            ExpiresAt = @event ExpiresAt,    // ✅ Copy from event (handler set this)\n            IsExpired = @event IsExpired,     // ✅ Copy from event (handler set this)\n            Status = @event Status            // ✅ Copy from event (handler set this)\n        };\n        if (@event IsExpired) {\n            // Simple filtering based on event data (not a business decision)\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        await projection Store CreateAsync(summary, ct);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public DateTime ExpiresAt { get; set; }\n    public bool IsExpired { get; set; }\n    public string Status { get; set; }\n}\n`\nThe Three-Layer Architecture\nWhizbang enforces a clear separation of concerns:\n`mermaid\ngraph TB\n    subgraph BusinessLogic[\"Command Handler / Aggregate (Business Logic Layer)\"]\n        BL1[\"✅ Validates commands\"]\n        BL2[\"✅ Applies business rules\"]\n        BL3[\"✅ Makes decisions\"]\n        BL4[\"✅ Creates event POCOs with results\"]\n        BL5[\"✅ CAN emit commands (sagas)\"]\n        BL6[\"✅ CAN use DateTime",
        "startIndex": 9635,
        "preview": "{ get; init; } public DateTime ExpiresAt { get; init; } // ✅ Data only public bool IsExpired { get; init; } // ✅ Data only public string Status { get;..."
      },
      {
        "id": "projections/projection-purity-chunk-6",
        "text": "set; } } ` The Three-Layer Architecture Whizbang enforces a clear separation of concerns: `mermaid graph TB subgraph BusinessLogic[\"Command Handler / Aggregate (Business Logic Layer)\"] BL1[\"✅ Validates commands\"] BL2[\"✅ Applies business rules\"] BL3[\"✅ Makes decisions\"] BL4[\"✅ Creates event POCOs with results\"] BL5[\"✅ CAN emit commands (sagas)\"] BL6[\"✅ CAN use DateTime UtcNow, Random, APIs\"]\n    end\n    subgraph DataLayer[\"Data Layer (POCOs - No Logic)\"]\n        Event[\"Event<br/>- Properties only<br/>- NO methods<br/>- Describes what happened\"]\n        Command[\"Command<br/>- Properties only<br/>- NO methods<br/>- Describes intent\"]\n    end\n    subgraph ReadModel[\"Projection (Read Model Layer)\"]\n        P1[\"✅ Pure transformation of event data\"]\n        P2[\"❌ NO business logic\"]\n        P3[\"❌ NO DateTime UtcNow, Random, APIs\"]\n        P4[\"✅ ONLY event data or EventContext\"]\n        P5[\"✅ Deterministic and replayable\"]\n    end\n    BusinessLogic -->|Emits Events| Event\n    BusinessLogic -->|Emits Commands| Command\n    Event -->|Consumed by| ReadModel\n    Command -->|Handled by| BusinessLogic\n    style BusinessLogic fill:#d4edda,stroke:#28a745,stroke-width:2px\n    style DataLayer fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    style ReadModel fill:#cce5ff,stroke:#004085,stroke-width:2px\n    style Event fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    style Command fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n`\nWhy Purity Matters\nReplay: Events can be replayed to rebuild projections - must produce same result\nTesting: Pure functions are easy to test - same input, same output\nDebugging: Deterministic behavior makes bugs reproducible\nScaling: Multiple projection instances can process same events safely\nTime Travel: Can replay events from any point in time\nAuditing: Projection state is always verifiable from event stream\nDisaster Recovery: Projections can be rebuilt from events after data loss\nBlue/Green Deployments: New projection version can process same events\nWhizbang Analyzers Enforcement\nThe Whizbang Analyzers package enforces purity at compile time:\n`csharp{\ntitle: \"Analyzer Enforcement Example\"\ndescription: \"Compile-time purity validation with Whizbang Analyzers\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Analyzers\", \"Purity\", \"Compile-Time Validation\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\", \"Whizbang Analyzers\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading",
        "startIndex": 11329,
        "preview": "set; } } ` The Three-Layer Architecture Whizbang enforces a clear separation of concerns: `mermaid graph TB subgraph BusinessLogic[\"Command Handler / ..."
      },
      {
        "id": "projections/projection-purity-chunk-7",
        "text": "compile time: `csharp{ title: \"Analyzer Enforcement Example\" description: \"Compile-time purity validation with Whizbang Analyzers\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Analyzers\", \"Purity\", \"Compile-Time Validation\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\", \"Whizbang Analyzers\"] usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading; using System Threading Tasks;\n[WhizbangProjection]\npublic class OrderProjection {\n    private readonly ILogger _logger;  // ⚠️ Warning: Injected services should be read-only\n    // ✅ VALID - Pure projection handler\n    public Task Handle([WhizbangSubscribe] OrderPlaced @event, EventContext context, CancellationToken ct) {\n        // Pure state updates only\n        var summary = new OrderSummary {\n            PlacedAt = context System Timestamp  // ✅ OK - from context\n        };\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - Side effect detected (logging)\n    public Task Handle([WhizbangSubscribe] OrderShipped @event, CancellationToken ct) {\n        _logger LogInformation(\"Order shipped\");  // 💥 WBG001: Side effect in projection\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - DateTime UtcNow usage\n    public Task Handle([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) {\n        var cancelledAt = DateTime UtcNow;  // 💥 WBG002: Non-deterministic time source\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - Random value generation\n    public Task Handle([WhizbangSubscribe] OrderCompleted @event, CancellationToken ct) {\n        var random = Random Shared Next();  // 💥 WBG003: Non-deterministic random source\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - External I/O detected\n    public async Task Handle([WhizbangSubscribe] OrderRefunded @event, CancellationToken ct) {\n        await File WriteAllTextAsync(\"log txt\", \"refunded\");  // 💥 WBG004: I/O in projection\n    }\n}\npublic class OrderSummary {\n    public DateTime PlacedAt { get; set; }\n}\n`\nAnalyzer Error Codes\nWBG001: Side effect detected in projection (logging, console writes, etc )\nWBG002: Non-deterministic time source (DateTime UtcNow, DateTime Now)\nWBG003: Non-deterministic random source (Random, Guid NewGuid())\nWBG004: I/O operation detected (file system, network, external database)\nWBG005: Database operation outside ProjectionContext",
        "startIndex": 13523,
        "preview": "compile time: `csharp{ title: \"Analyzer Enforcement Example\" description: \"Compile-time purity validation with Whizbang Analyzers\" framework: \"NET8\" c..."
      },
      {
        "id": "projections/projection-purity-chunk-8",
        "text": "PlacedAt { get; set; } } ` Analyzer Error Codes WBG001: Side effect detected in projection (logging, console writes, etc ) WBG002: Non-deterministic time source (DateTime UtcNow, DateTime Now) WBG003: Non-deterministic random source (Random, Guid NewGuid()) WBG004: I/O operation detected (file system, network, external database) WBG005: Database operation outside ProjectionContext Store\nWBG006: Environment variable access\nWBG007: Complex business logic detected in projection (warning)\nPurity Checklist\nBefore merging projection code, verify:\n[ ] No DateTime UtcNow or DateTime Now usage\n[ ] No Random or Guid NewGuid() calls\n[ ] No external API calls (HTTP, gRPC, etc )\n[ ] No file system operations\n[ ] No logging or console writes\n[ ] No database operations outside ProjectionContext Store\n[ ] No environment variable reads\n[ ] All timestamps from EventContext System Timestamp\n[ ] All business decisions from event data (not calculated in projection)\n[ ] Whizbang Analyzers passes with no errors\nSummary\nProjections = Pure transformations of event data into read models\nBusiness Logic = Command handlers and aggregates that make decisions and emit events\nEvents = POCOs describing what happened (no logic)\nDeterminism = Same event always produces same projection state\nWhizbang Analyzers = Compile-time enforcement of purity rules\nNext Steps\nProjection Subscriptions - Event subscription patterns\nProjection Contexts - EventContext and ProjectionContext injection\nProjection Return Values - Using return values for observability",
        "startIndex": 15479,
        "preview": "PlacedAt { get; set; } } ` Analyzer Error Codes WBG001: Side effect detected in projection (logging, console writes, etc ) WBG002: Non-deterministic t..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "projections/projection-return-values",
    "title": "Projection Return Values",
    "category": "Projections",
    "url": "/docs/projections/projection-return-values",
    "chunks": [
      {
        "id": "projections/projection-return-values-chunk-0",
        "text": "Projection Return Values\nProjection methods can return metadata about the processing outcome using ProjectionContext Return() This is metadata only with no side effects - it's purely for observability and metrics ProjectionReturnType Enum\n`csharp\npublic enum ProjectionReturnType {\n    Accepted,  // Event was processed successfully (default)\n    Ignored    // Event was intentionally ignored/skipped\n}\n`\nReturn Value Semantics\n| Return Type | Meaning | Use When | Metrics Impact |\n|------------|---------|----------|----------------|\n| Accepted | Event was processed successfully | Default behavior, projection state updated | Increments events_processed counter |\n| Ignored | Event was intentionally skipped | Filtering, tenant isolation, deduplication | Increments events_ignored counter |\nBasic Usage\n`csharp{\ntitle: \"Basic Projection Return Values\"\ndescription: \"Using return values to signal projection processing outcomes\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"BEGINNER\"\ntags: [\"Projections\", \"Return Values\", \"Observability\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class OrderProjection {\n    // Example 1: Explicit Accepted return (default behavior)\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        await projection Store CreateAsync(new OrderSummary {\n            OrderId = @event OrderId,\n            Status = \"Placed\"\n        }, ct);\n        // Explicitly signal success (optional - this is the default)\n        return projection Return(ProjectionReturnType Accepted);\n    }\n    // Example 2: Implicit Accepted (no return statement)\n    public async Task OnOrderShipped(\n        [WhizbangSubscribe] OrderShipped @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        await projection Store PatchAsync<OrderSummary>(\n            @event OrderId,\n            order => order Status = \"Shipped\",\n            ct);\n        // No explicit return = Accepted (default)\n    }\n    // Example 3: Ignored return (event intentionally skipped)\n    public Task OnOrderEvent(\n        [WhizbangSubscribe] OrderEvent @event,\n        ProjectionContext projection,\n        EventContext eventContext,\n        CancellationToken ct) {\n        // Only process events for current tenant\n        if (eventContext Security TenantId = projection Service CurrentTenantId) {\n            // Different tenant - ignore this event\n            return projection Return(ProjectionReturnType",
        "startIndex": 0,
        "preview": "Projection Return Values\nProjection methods can return metadata about the processing outcome using ProjectionContext Return() This is metadata only wi..."
      },
      {
        "id": "projections/projection-return-values-chunk-1",
        "text": "Accepted (default) } // Example 3: Ignored return (event intentionally skipped) public Task OnOrderEvent( [WhizbangSubscribe] OrderEvent @event, ProjectionContext projection, EventContext eventContext, CancellationToken ct) { // Only process events for current tenant if (eventContext Security TenantId = projection Service CurrentTenantId) { // Different tenant - ignore this event return projection Return(ProjectionReturnType Ignored);\n        }\n        // Process the event\n        // return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public string Status { get; set; }\n}\n`\nCommon Use Cases for Ignored\nTenant Isolation\n`csharp{\ntitle: \"Tenant Isolation with Return Values\"\ndescription: \"Using Ignored to skip events for different tenants\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Multi-Tenancy\", \"Filtering\", \"Return Values\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class TenantOrderProjection {\n    private readonly Guid _currentTenantId;\n    public TenantOrderProjection(Guid currentTenantId) {\n        _currentTenantId = currentTenantId;\n    }\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        EventContext eventContext,\n        CancellationToken ct) {\n        // Skip events for other tenants\n        if (eventContext Security TenantId = _currentTenantId) {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Process event for current tenant\n        await projection Store CreateAsync(new OrderSummary {\n            OrderId = @event OrderId,\n            TenantId = _currentTenantId,\n            Status = \"Placed\"\n        }, ct);\n        return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public Guid TenantId { get; set; }\n    public string Status { get; set; }\n}\n`\nVersion Checking and Deduplication\n`csharp{\ntitle: \"Version Checking and Deduplication\"\ndescription: \"Using Ignored to skip out-of-order or duplicate events\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Deduplication\", \"Versioning\", \"Return Values\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading",
        "startIndex": 2742,
        "preview": "Accepted (default) } // Example 3: Ignored return (event intentionally skipped) public Task OnOrderEvent( [WhizbangSubscribe] OrderEvent @event, Proje..."
      },
      {
        "id": "projections/projection-return-values-chunk-2",
        "text": "Deduplication `csharp{ title: \"Version Checking and Deduplication\" description: \"Using Ignored to skip out-of-order or duplicate events\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Deduplication\", \"Versioning\", \"Return Values\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"] usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading; using System Threading Tasks;\n[WhizbangProjection]\npublic class VersionedOrderProjection {\n    public async Task OnOrderUpdated(\n        [WhizbangSubscribe] OrderUpdated @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // Get current projection state\n        var current = await projection Store GetAsync<OrderSummary>(@event OrderId, ct);\n        // Ignore if projection doesn't exist (might be deleted)\n        if (current == null) {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Ignore if event is older than current state (out-of-order delivery)\n        if (@event Version <= current Version) {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Update the projection\n        await projection Store UpdateAsync(@event OrderId, new OrderSummary {\n            OrderId = @event OrderId,\n            Version = @event Version,\n            Status = @event Status\n        }, ct);\n        return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public int Version { get; set; }\n    public string Status { get; set; }\n}\n`\nEvent Data Filtering\n`csharp{\ntitle: \"Event Data Filtering\"\ndescription: \"Using Ignored to filter based on event flags set by business logic\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Filtering\", \"Event Data\", \"Return Values\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class ActiveOrderProjection {\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // ✅ CORRECT: Business logic already set IsExpired in the event\n        // The command handler made this decision, projection just filters\n        if (@event IsExpired) {\n            // Event already marked as expired by business logic\n            return projection Return(ProjectionReturnType",
        "startIndex": 5034,
        "preview": "Deduplication `csharp{ title: \"Version Checking and Deduplication\" description: \"Using Ignored to skip out-of-order or duplicate events\" framework: \"N..."
      },
      {
        "id": "projections/projection-return-values-chunk-3",
        "text": "{ public async Task OnOrderPlaced( [WhizbangSubscribe] OrderPlaced @event, ProjectionContext projection, CancellationToken ct) { // ✅ CORRECT: Business logic already set IsExpired in the event // The command handler made this decision, projection just filters if (@event IsExpired) { // Event already marked as expired by business logic return projection Return(ProjectionReturnType Ignored);\n        }\n        // Process non-expired event\n        await projection Store CreateAsync(new OrderSummary {\n            OrderId = @event OrderId,\n            Status = \"Active\"\n        }, ct);\n        return projection Return(ProjectionReturnType Accepted);\n    }\n    public async Task OnOrderStatusChanged(\n        [WhizbangSubscribe] OrderStatusChanged @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // Only track \"active\" status changes\n        if (@event NewStatus = \"Active\") {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        await projection Store PatchAsync<OrderSummary>(\n            @event OrderId,\n            order => order Status = @event NewStatus,\n            ct);\n        return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public string Status { get; set; }\n}\n`\nFeature Flag Filtering\n`csharp{\ntitle: \"Feature Flag Filtering\"\ndescription: \"Using Ignored to skip events when features are disabled\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"ADVANCED\"\ntags: [\"Feature Flags\", \"Configuration\", \"Return Values\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class NotificationProjection {\n    private readonly IFeatureFlagService _featureFlags;\n    public NotificationProjection(IFeatureFlagService featureFlags) {\n        _featureFlags = featureFlags;\n    }\n    public async Task OnOrderShipped(\n        [WhizbangSubscribe] OrderShipped @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // Skip if shipping notifications are disabled\n        // Feature flag is from config, not time-based (deterministic for replay)\n        if ( _featureFlags IsEnabled(\"ShippingNotifications\")) {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        await projection Store CreateAsync(new NotificationRecord {\n            EventId = @event OrderId,\n            Type = \"ShippingNotification\",\n            CreatedAt = DateTime UtcNow\n        }, ct);\n        return projection Return(ProjectionReturnType",
        "startIndex": 7225,
        "preview": "{ public async Task OnOrderPlaced( [WhizbangSubscribe] OrderPlaced @event, ProjectionContext projection, CancellationToken ct) { // ✅ CORRECT: Busines..."
      },
      {
        "id": "projections/projection-return-values-chunk-4",
        "text": "// Skip if shipping notifications are disabled // Feature flag is from config, not time-based (deterministic for replay) if ( _featureFlags IsEnabled(\"ShippingNotifications\")) { return projection Return(ProjectionReturnType Ignored); } await projection Store CreateAsync(new NotificationRecord { EventId = @event OrderId, Type = \"ShippingNotification\", CreatedAt = DateTime UtcNow }, ct); return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic interface IFeatureFlagService {\n    bool IsEnabled(string featureName);\n}\npublic class NotificationRecord {\n    public Guid EventId { get; set; }\n    public string Type { get; set; }\n    public DateTime CreatedAt { get; set; }\n}\n`\nProjection Existence Checking\n`csharp{\ntitle: \"Projection Existence Checking\"\ndescription: \"Using Ignored to skip updates to deleted projections\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Existence Checks\", \"Deleted Projections\", \"Return Values\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class OrderHistoryProjection {\n    public async Task OnOrderUpdated(\n        [WhizbangSubscribe] OrderUpdated @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // Check if projection exists\n        var existing = await projection Store GetAsync<OrderHistory>(@event OrderId, ct);\n        if (existing == null) {\n            // Projection was deleted or never created - ignore this update\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Update existing projection\n        await projection Store PatchAsync<OrderHistory>(\n            @event OrderId,\n            history => history UpdatedAt = DateTime UtcNow,\n            ct);\n        return projection Return(ProjectionReturnType Accepted);\n    }\n    public async Task OnOrderDeleted(\n        [WhizbangSubscribe] OrderDeleted @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        await projection Store DeleteAsync<OrderHistory>(@event OrderId, ct);\n        return projection Return(ProjectionReturnType",
        "startIndex": 9580,
        "preview": "// Skip if shipping notifications are disabled // Feature flag is from config, not time-based (deterministic for replay) if ( _featureFlags IsEnabled(..."
      },
      {
        "id": "projections/projection-return-values-chunk-5",
        "text": "update return projection Return(ProjectionReturnType Ignored); } // Update existing projection await projection Store PatchAsync<OrderHistory>( @event OrderId, history => history UpdatedAt = DateTime UtcNow, ct); return projection Return(ProjectionReturnType Accepted); } public async Task OnOrderDeleted( [WhizbangSubscribe] OrderDeleted @event, ProjectionContext projection, CancellationToken ct) { await projection Store DeleteAsync<OrderHistory>(@event OrderId, ct); return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic class OrderHistory {\n    public Guid OrderId { get; set; }\n    public DateTime UpdatedAt { get; set; }\n}\n`\nImportant Notes\nNo Side Effects: Return values are metadata only - they don't affect event flow or projection state\nDefault is Accepted: If you don't explicitly return, Accepted is assumed\nObservability: Return values are recorded for metrics, logging, and dashboard visualization\nNo Error Return: Errors should throw exceptions, not return a status code\nPure Metadata: Return values don't trigger any framework behavior - they're for observability\nMetrics and Observability\nReturn values enable rich metrics and dashboards:\n`csharp\n// Whizbang automatically tracks these metrics:\n// - whizbang_projection_events_accepted{projection=\"OrderProjection\", event=\"OrderPlaced\"}\n// - whizbang_projection_events_ignored{projection=\"OrderProjection\", event=\"OrderPlaced\"}\n// - whizbang_projection_acceptance_rate{projection=\"OrderProjection\"}\n// - whizbang_projection_throughput{projection=\"OrderProjection\"}\n`\nDashboard Visualization\nThe Whizbang Dashboard uses return values to show:\nProjection Health: Acceptance rate over time\nEvent Filtering: Which events are commonly ignored\nTenant Metrics: Events processed per tenant\nPerformance: Throughput and latency per projection\nDebugging: Identify misconfigured filters\nExample Metrics Query\n`promql\nProjection acceptance rate (should be high for normal operations)\nsum(rate(whizbang_projection_events_accepted[5m])) by (projection)\n/\nsum(rate(whizbang_projection_events_total[5m])) by (projection)\nEvents ignored by reason (for debugging)\nsum(rate(whizbang_projection_events_ignored[5m])) by (projection, reason)\nTenant-specific processing rate\nsum(rate(whizbang_projection_events_accepted[5m])) by (tenant_id)\n`\nBest Practices\nBe Explicit When Filtering\n`csharp\n// ✅ GOOD - Explicit and clear\nif (@event IsExpired) {\n    return projection Return(ProjectionReturnType Ignored);\n}\n// ❌ BAD - Implicit, unclear why event is ignored\nif (@event IsExpired) {\n    return Task",
        "startIndex": 11432,
        "preview": "update return projection Return(ProjectionReturnType Ignored); } // Update existing projection await projection Store PatchAsync<OrderHistory>( @event..."
      },
      {
        "id": "projections/projection-return-values-chunk-6",
        "text": "sum(rate(whizbang_projection_events_ignored[5m])) by (projection, reason) Tenant-specific processing rate sum(rate(whizbang_projection_events_accepted[5m])) by (tenant_id) ` Best Practices Be Explicit When Filtering `csharp // ✅ GOOD - Explicit and clear if (@event IsExpired) { return projection Return(ProjectionReturnType Ignored); } // ❌ BAD - Implicit, unclear why event is ignored if (@event IsExpired) { return Task CompletedTask;  // Looks like Accepted, but event wasn't processed\n}\n`\nUse Ignored for Intentional Filtering\n`csharp\n// ✅ GOOD - Intentional filtering (return Ignored)\nif (eventContext Security TenantId = _currentTenantId) {\n    return projection Return(ProjectionReturnType Ignored);\n}\n// ❌ BAD - Errors should throw exceptions, not return Ignored\ntry {\n    await projection Store CreateAsync(summary, ct);\n} catch (Exception) {\n    return projection Return(ProjectionReturnType Ignored);  // Wrong Throw the exception\n}\n`\nDocument Ignored Reasons\n`csharp\n// ✅ GOOD - Comment explains why event is ignored\npublic Task OnOrderPlaced(\n    [WhizbangSubscribe] OrderPlaced @event,\n    ProjectionContext projection,\n    EventContext eventContext,\n    CancellationToken ct) {\n    // Ignore events for other tenants - this projection is tenant-scoped\n    if (eventContext Security TenantId = _currentTenantId) {\n        return projection Return(ProjectionReturnType Ignored);\n    }\n    // Process event }\n`\nMonitor Acceptance Rates\nSet up alerts for low acceptance rates:\n`yaml\nPrometheus alert rule\nalert: LowProjectionAcceptanceRate\n  expr: |\n    sum(rate(whizbang_projection_events_accepted[5m])) by (projection)\n    /\n    sum(rate(whizbang_projection_events_total[5m])) by (projection)\n    < 0 5\n  for: 10m\n  annotations:\n    summary: \"Projection {{ $labels",
        "startIndex": 13477,
        "preview": "sum(rate(whizbang_projection_events_ignored[5m])) by (projection, reason) Tenant-specific processing rate sum(rate(whizbang_projection_events_accepted..."
      },
      {
        "id": "projections/projection-return-values-chunk-7",
        "text": "Security TenantId = _currentTenantId) { return projection Return(ProjectionReturnType Ignored); } // Process event } ` Monitor Acceptance Rates Set up alerts for low acceptance rates: `yaml Prometheus alert rule alert: LowProjectionAcceptanceRate expr: | sum(rate(whizbang_projection_events_accepted[5m])) by (projection) / sum(rate(whizbang_projection_events_total[5m])) by (projection) < 0 5 for: 10m annotations: summary: \"Projection {{ $labels projection }} has low acceptance rate\"\n    description: \"Less than 50% of events are being accepted\"\n`\nSummary\nReturn values are metadata only - no side effects\nDefault is Accepted - explicit return is optional\nUse Ignored for intentional filtering - tenant isolation, versioning, feature flags\nErrors should throw exceptions - not return Ignored\nMetrics enable observability - track acceptance rates, throughput, and health\nDashboard visualization - see projection health and filtering patterns\nNext Steps\nProjection Subscriptions - Event subscription patterns\nProjection Contexts - EventContext and ProjectionContext injection\nProjection Purity - Maintaining pure, deterministic projections",
        "startIndex": 14839,
        "preview": "Security TenantId = _currentTenantId) { return projection Return(ProjectionReturnType Ignored); } // Process event } ` Monitor Acceptance Rates Set up..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "projections/projection-subscriptions",
    "title": "Projection Subscriptions",
    "category": "Projections",
    "url": "/docs/projections/projection-subscriptions",
    "chunks": [
      {
        "id": "projections/projection-subscriptions-chunk-0",
        "text": "Projection Subscriptions\nWhizbang provides flexible event subscription patterns using the [WhizbangSubscribe] attribute Projections can subscribe to specific event types, base classes, interfaces, or use generic methods for maximum reusability Basic Subscription Pattern\nPlace [WhizbangSubscribe] directly on the method parameter representing the event:\n`csharp{\ntitle: \"Basic Event Subscription\"\ndescription: \"Simple event subscription pattern with flexible method naming\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"BEGINNER\"\ntags: [\"Projections\", \"Subscriptions\", \"Events\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class OrderHistoryProjection {\n    private readonly List<OrderSummary> _orders = new();\n    // ✅ Method names are flexible - use what makes sense\n    public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) {\n        _orders Add(new OrderSummary(@event OrderId, \"Placed\"));\n        return Task CompletedTask;\n    }\n    public Task On([WhizbangSubscribe] OrderShipped @event, CancellationToken ct) {\n        var order = _orders First(o => o OrderId == @event OrderId);\n        order Status = \"Shipped\";\n        return Task CompletedTask;\n    }\n    public Task When([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) {\n        _orders RemoveAll(o => o OrderId == @event OrderId);\n        return Task CompletedTask;\n    }\n    // Descriptive names work too\n    public Task OnOrderCompleted([WhizbangSubscribe] OrderCompleted @event, CancellationToken ct) {\n        var order = _orders First(o => o OrderId == @event OrderId);\n        order Status = \"Completed\";\n        return Task",
        "startIndex": 0,
        "preview": "Projection Subscriptions\nWhizbang provides flexible event subscription patterns using the [WhizbangSubscribe] attribute Projections can subscribe to s..."
      },
      {
        "id": "projections/projection-subscriptions-chunk-1",
        "text": "public Task When([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) { _orders RemoveAll(o => o OrderId == @event OrderId); return Task CompletedTask; } // Descriptive names work too public Task OnOrderCompleted([WhizbangSubscribe] OrderCompleted @event, CancellationToken ct) { var order = _orders First(o => o OrderId == @event OrderId); order Status = \"Completed\"; return Task CompletedTask;\n    }\n}\npublic record OrderSummary(Guid OrderId, string Status) {\n    public string Status { get; set; } = Status;\n}\n`\nSubscription Rules\nOne subscription per method: Only one parameter can have [WhizbangSubscribe] attribute\nAdditional parameters allowed: CancellationToken, EventContext, ProjectionContext, injected services\nFlexible naming: Use Handle, On, When, or any descriptive name\nAuto-registration: Source generator automatically wires subscriptions to service configuration\nSupports polymorphism: Subscribe to base classes or interfaces\nPolymorphic Subscriptions\nBase Class Subscriptions\nSubscribe to a base class to handle all derived event types:\n`csharp{\ntitle: \"Base Class Event Subscriptions\"\ndescription: \"Using base classes to handle multiple event types\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Polymorphism\", \"Base Classes\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n// Base class for all order events\npublic abstract record OrderEvent(Guid OrderId, DateTime Timestamp);\n// Derived event types\npublic record OrderPlaced(Guid OrderId, DateTime Timestamp, decimal Total)\n    : OrderEvent(OrderId, Timestamp);\npublic record OrderShipped(Guid OrderId, DateTime Timestamp, string TrackingNumber)\n    : OrderEvent(OrderId, Timestamp);\npublic record OrderCancelled(Guid OrderId, DateTime Timestamp, string Reason)\n    : OrderEvent(OrderId, Timestamp);\n[WhizbangProjection]\npublic class OrderAuditProjection {\n    private readonly List<AuditRecord> _auditLog = new();\n    // Single method handles ALL OrderEvent-derived types\n    public Task Handle([WhizbangSubscribe] OrderEvent @event, CancellationToken ct) {\n        // Common processing for all order events\n        LogAudit(@event OrderId, @event GetType() Name, @event",
        "startIndex": 1857,
        "preview": "public Task When([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) { _orders RemoveAll(o => o OrderId == @event OrderId); return Task C..."
      },
      {
        "id": "projections/projection-subscriptions-chunk-2",
        "text": "public record OrderCancelled(Guid OrderId, DateTime Timestamp, string Reason) : OrderEvent(OrderId, Timestamp); [WhizbangProjection] public class OrderAuditProjection { private readonly List<AuditRecord> _auditLog = new(); // Single method handles ALL OrderEvent-derived types public Task Handle([WhizbangSubscribe] OrderEvent @event, CancellationToken ct) { // Common processing for all order events LogAudit(@event OrderId, @event GetType() Name, @event Timestamp);\n        // Pattern matching for specific handling\n        return @event switch {\n            OrderPlaced placed => HandlePlaced(placed),\n            OrderShipped shipped => HandleShipped(shipped),\n            OrderCancelled cancelled => HandleCancelled(cancelled),\n            _ => Task CompletedTask\n        };\n    }\n    private Task HandlePlaced(OrderPlaced @event) {\n        _auditLog Add(new AuditRecord(\"Order placed with total: \" + @event Total));\n        return Task CompletedTask;\n    }\n    private Task HandleShipped(OrderShipped @event) {\n        _auditLog Add(new AuditRecord(\"Order shipped: \" + @event TrackingNumber));\n        return Task CompletedTask;\n    }\n    private Task HandleCancelled(OrderCancelled @event) {\n        _auditLog Add(new AuditRecord(\"Order cancelled: \" + @event Reason));\n        return Task CompletedTask;\n    }\n    private void LogAudit(Guid orderId, string eventType, DateTime timestamp) {\n        Console WriteLine($\"[{timestamp}] {eventType} - Order {orderId}\");\n    }\n}\npublic record AuditRecord(string Message);\n`\nInterface Subscriptions\nSubscribe to an interface to handle all implementing event types:\n`csharp{\ntitle: \"Interface Event Subscriptions\"\ndescription: \"Using interfaces to handle multiple event types\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Polymorphism\", \"Interfaces\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading;\nusing System Threading",
        "startIndex": 3841,
        "preview": "public record OrderCancelled(Guid OrderId, DateTime Timestamp, string Reason) : OrderEvent(OrderId, Timestamp); [WhizbangProjection] public class Orde..."
      },
      {
        "id": "projections/projection-subscriptions-chunk-3",
        "text": "Event Subscriptions\" description: \"Using interfaces to handle multiple event types\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Projections\", \"Polymorphism\", \"Interfaces\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"] usingStatements: [\"System\", \"System Collections Generic\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Collections Generic; using System Threading; using System Threading Tasks;\n// Interface for all inventory events\npublic interface IInventoryEvent {\n    Guid ProductId { get; }\n}\n// Event implementations\npublic record InventoryAdjusted(Guid ProductId, int Quantity) : IInventoryEvent;\npublic record InventoryReserved(Guid ProductId, int Quantity, Guid OrderId) : IInventoryEvent;\npublic record InventoryReleased(Guid ProductId, int Quantity, Guid OrderId) : IInventoryEvent;\n[WhizbangProjection]\npublic class InventoryProjection {\n    private readonly Dictionary<Guid, int> _stock = new();\n    // Single method handles ALL IInventoryEvent implementations\n    public Task Handle([WhizbangSubscribe] IInventoryEvent @event, CancellationToken ct) {\n        return @event switch {\n            InventoryAdjusted adjusted => HandleAdjusted(adjusted),\n            InventoryReserved reserved => HandleReserved(reserved),\n            InventoryReleased released => HandleReleased(released),\n            _ => Task CompletedTask\n        };\n    }\n    private Task HandleAdjusted(InventoryAdjusted @event) {\n        _stock[@event ProductId] = @event Quantity;\n        return Task CompletedTask;\n    }\n    private Task HandleReserved(InventoryReserved @event) {\n        if (_stock ContainsKey(@event ProductId)) {\n            _stock[@event ProductId] -= @event Quantity;\n        }\n        return Task CompletedTask;\n    }\n    private Task HandleReleased(InventoryReleased @event) {\n        if (_stock ContainsKey(@event ProductId)) {\n            _stock[@event ProductId] += @event Quantity;\n        }\n        return Task CompletedTask;\n    }\n    // Query method\n    public int GetStock(Guid productId) {\n        return _stock TryGetValue(productId, out var stock) stock : 0;\n    }\n}\n`\nGeneric Method Subscriptions\nUse generic methods for maximum flexibility and reusability:\n`csharp{\ntitle: \"Generic Method Subscriptions\"\ndescription: \"Using generic methods to handle multiple event types with shared logic\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Generics\", \"Polymorphism\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading;\nusing System Threading",
        "startIndex": 5512,
        "preview": "Event Subscriptions\" description: \"Using interfaces to handle multiple event types\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIAT..."
      },
      {
        "id": "projections/projection-subscriptions-chunk-4",
        "text": "generic methods to handle multiple event types with shared logic\" framework: \"NET8\" category: \"Projections\" difficulty: \"ADVANCED\" tags: [\"Projections\", \"Generics\", \"Polymorphism\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"] usingStatements: [\"System\", \"System Collections Generic\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Collections Generic; using System Threading; using System Threading Tasks;\n// Marker interface for all events\npublic interface IEvent {\n    Guid EventId { get; }\n    DateTime Timestamp { get; }\n}\n// Base interface for domain events\npublic interface IDomainEvent : IEvent {\n    string Domain { get; }\n}\n// Example events\npublic abstract record OrderEvent(Guid EventId, DateTime Timestamp, string Domain) : IDomainEvent;\npublic record OrderPlaced(Guid EventId, DateTime Timestamp, Guid OrderId, decimal Total)\n    : OrderEvent(EventId, Timestamp, \"Orders\");\npublic record OrderShipped(Guid EventId, DateTime Timestamp, Guid OrderId, string TrackingNumber)\n    : OrderEvent(EventId, Timestamp, \"Orders\");\n// Generic method with interface constraint\n[WhizbangProjection]\npublic class EventAuditProjection {\n    private readonly List<EventAuditRecord> _auditLog = new();\n    // This ONE generic method handles ALL events implementing IEvent\n    public Task OnEvent<TEvent>([WhizbangSubscribe] TEvent @event, EventContext context, CancellationToken ct)\n        where TEvent : IEvent {\n        // Source generator creates separate registration for each concrete event type:\n        // - OnEvent<OrderPlaced>\n        // - OnEvent<OrderShipped>\n        // - OnEvent<InventoryAdjusted>\n        // - etc _auditLog Add(new EventAuditRecord {\n            EventId = @event EventId,\n            EventType = typeof(TEvent) Name,  // Concrete type name\n            Timestamp = @event Timestamp,\n            UserId = context Security UserId,\n            TenantId = context Security TenantId\n        });\n        return Task CompletedTask;\n    }\n}\n// Generic method with base class constraint\n[WhizbangProjection]\npublic class OrderEventLogProjection {\n    private readonly Dictionary<string, List<string>> _logsByDomain = new();\n    // Handles all OrderEvent-derived types\n    public Task LogOrderEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct)\n        where TEvent : OrderEvent {\n        if ( _logsByDomain ContainsKey(@event Domain)) {\n            _logsByDomain[@event Domain] = new List<string>();\n        }\n        _logsByDomain[@event Domain] Add(\n            $\"{@event Timestamp:O} - {typeof(TEvent) Name} - {@event EventId}\"\n        );\n        return Task",
        "startIndex": 7833,
        "preview": "generic methods to handle multiple event types with shared logic\" framework: \"NET8\" category: \"Projections\" difficulty: \"ADVANCED\" tags: [\"Projections..."
      },
      {
        "id": "projections/projection-subscriptions-chunk-5",
        "text": "private readonly Dictionary<string, List<string>> _logsByDomain = new(); // Handles all OrderEvent-derived types public Task LogOrderEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct) where TEvent : OrderEvent { if ( _logsByDomain ContainsKey(@event Domain)) { _logsByDomain[@event Domain] = new List<string>(); } _logsByDomain[@event Domain] Add( $\"{@event Timestamp:O} - {typeof(TEvent) Name} - {@event EventId}\" ); return Task CompletedTask;\n    }\n}\npublic record EventAuditRecord {\n    public Guid EventId { get; init; }\n    public string EventType { get; init; }\n    public DateTime Timestamp { get; init; }\n    public Guid UserId { get; init; }\n    public Guid TenantId { get; init; }\n}\n`\nHow Generic Methods Work\nSource Generator Discovers Generic Methods: At compile time, finds all generic methods with [WhizbangSubscribe]\nCreates Registrations for Each Concrete Type: For every event type matching the generic constraint:\n   `csharp\n   // You write this ONE generic method:\n   public Task OnEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct)\n       where TEvent : IEvent { }\n   // Source generator creates registrations for ALL event types:\n   services Subscribe<OrderPlaced, EventAuditProjection>(p => p OnEvent);\n   services Subscribe<OrderShipped, EventAuditProjection>(p => p OnEvent);\n   services Subscribe<InventoryAdjusted, EventAuditProjection>(p => p OnEvent);\n   // etc `\nType Safety Maintained: Generic constraints ensure only valid event types are registered\nMultiple Constraints Supported: Use where TEvent : class, IEvent, new() or any valid Cconstraint\nCombining Generic and Specific Methods\nMix generic and specific subscriptions in the same projection:\n`csharp{\ntitle: \"Hybrid Generic and Specific Subscriptions\"\ndescription: \"Combining generic catch-all methods with specific handlers\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Generics\", \"Hybrid Patterns\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class HybridProjection {\n    // Generic catch-all for all events\n    public Task OnEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct)\n        where TEvent : IEvent {\n        // Log all events generically\n        Console WriteLine($\"Event received: {typeof(TEvent)",
        "startIndex": 10041,
        "preview": "private readonly Dictionary<string, List<string>> _logsByDomain = new(); // Handles all OrderEvent-derived types public Task LogOrderEvent<TEvent>([Wh..."
      },
      {
        "id": "projections/projection-subscriptions-chunk-6",
        "text": "[\"System\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading; using System Threading Tasks; [WhizbangProjection] public class HybridProjection { // Generic catch-all for all events public Task OnEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct) where TEvent : IEvent { // Log all events generically Console WriteLine($\"Event received: {typeof(TEvent) Name}\");\n        return Task CompletedTask;\n    }\n    // Specific handler for OrderPlaced (takes precedence)\n    public Task OnOrderPlaced([WhizbangSubscribe] OrderPlaced @event, ProjectionContext projection, CancellationToken ct) {\n        // Special handling for OrderPlaced\n        Console WriteLine($\"Special handling for order: {@event OrderId}\");\n        return Task CompletedTask;\n    }\n    // Specific handler for high-priority events\n    public Task OnOrderCancelled([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) {\n        // Alert handling for cancellations\n        Console WriteLine($\"ALERT: Order cancelled - {@event Reason}\");\n        return Task CompletedTask;\n    }\n}\n`\nPrecedence Rules\nWhen multiple methods can handle an event, Whizbang invokes handlers in this order:\nExact type match (e g , OrderPlaced @event)\nBase class match (e g , OrderEvent @event)\nInterface match (e g , IEvent @event)\nGeneric with specific constraint (e g , TEvent where TEvent : OrderEvent)\nGeneric with general constraint (e g , TEvent where TEvent : IEvent)\nAll matching handlers are invoked in precedence order (most specific to least specific) `mermaid\ngraph TD\n    OrderPlaced[\"OrderPlaced Event<br/>(Concrete Type)\"]\n    subgraph Handlers[\"Projection Handlers (Invoked in Order)\"]\n        H1[\"1 OnOrderPlaced<br/>(Exact Match)<br/>⭐ Highest Priority\"]\n        H2[\"2 OnOrderEvent<br/>(Base Class Match)\"]\n        H3[\"3 OnDomainEvent<br/>(Interface Match)\"]\n        H4[\"4 OnEvent&lt;TEvent&gt; where TEvent : OrderEvent<br/>(Generic Specific)\"]\n        H5[\"5 OnEvent&lt;TEvent&gt; where TEvent : IEvent<br/>(Generic General)<br/>⭐ Lowest Priority\"]\n    end\n    OrderPlaced --> H1\n    OrderPlaced - -> H2\n    OrderPlaced - -> H3\n    OrderPlaced - -> H4\n    OrderPlaced - -> H5\n    style OrderPlaced fill:#fff3cd,stroke:#ffc107,stroke-width:3px\n    style H1 fill:#d4edda,stroke:#28a745,stroke-width:2px\n    style H5 fill:#f8d7da,stroke:#dc3545,stroke-width:2px\n`\nBenefits of Polymorphic Subscriptions\nSingle Entry Point: One method handles all related events\nShared Logic: Common processing for all event types (logging, auditing, etc",
        "startIndex": 12108,
        "preview": "[\"System\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading; using System Threading Tasks; [..."
      },
      {
        "id": "projections/projection-subscriptions-chunk-7",
        "text": "OrderPlaced - -> H2 OrderPlaced - -> H3 OrderPlaced - -> H4 OrderPlaced - -> H5 style OrderPlaced fill:#fff3cd,stroke:#ffc107,stroke-width:3px style H1 fill:#d4edda,stroke:#28a745,stroke-width:2px style H5 fill:#f8d7da,stroke:#dc3545,stroke-width:2px ` Benefits of Polymorphic Subscriptions Single Entry Point: One method handles all related events Shared Logic: Common processing for all event types (logging, auditing, etc )\nType Safety: Pattern matching ensures all cases are handled\nFlexibility: Mix polymorphic and specific subscriptions as needed\nClean Code: Reduces boilerplate for related event types\nBenefits of Generic Methods\nDRY Principle: Write once, handle many event types\nShared Logic: Common processing for all events matching constraint\nType Safety: Generic constraints enforce compile-time safety\nAutomatic Registration: Source generator wires up all matching event types\nFlexibility: Combine with non-generic methods for specific overrides\nScalability: New event types automatically get handled without code changes\nValid Subscription Patterns\n`csharp\n// ✅ VALID - Specific event type\npublic Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) { }\n// ✅ VALID - Base class subscription\npublic Task OnOrderEvent([WhizbangSubscribe] OrderEvent @event, CancellationToken ct) { }\n// ✅ VALID - Interface subscription\npublic Task HandleInventoryEvent([WhizbangSubscribe] IInventoryEvent @event, CancellationToken ct) { }\n// ✅ VALID - Generic method\npublic Task OnEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct)\n    where TEvent : IEvent { }\n// ✅ VALID - With EventContext\npublic Task OnOrderPlaced([WhizbangSubscribe] OrderPlaced @event, EventContext context, CancellationToken ct) { }\n// ✅ VALID - With ProjectionContext\npublic Task OnOrderShipped([WhizbangSubscribe] OrderShipped @event, ProjectionContext projection, CancellationToken ct) { }\n// ✅ VALID - With both contexts\npublic Task WhenOrderPlaced(\n    [WhizbangSubscribe] OrderPlaced @event,\n    EventContext eventContext,\n    ProjectionContext projection,\n    CancellationToken ct) { }\n// ✅ VALID - With injected services (for querying, not mutation)\npublic Task ProcessOrder([WhizbangSubscribe] OrderPlaced @event, IOrderRepository repo, CancellationToken ct) { }\n// ❌ INVALID - Multiple subscriptions per method (compile error)\npublic Task OnOrderEvents([WhizbangSubscribe] OrderPlaced order, [WhizbangSubscribe] OrderShipped shipped) { }\n`\nAuto-Registration\nWhen you use [WhizbangSubscribe] on a method parameter, the source generator:\nDiscovers the subscription at compile time\nGenerates registration code linking the event type to the projection method\nAutomatically configures the service to route events to this projection\nNo manual registration needed - just mark with [WhizbangSubscribe]\n`mermaid\nsequenceDiagram\n    participant ES as Event Store\n    participant Router as Event Router\n    participant Proj1 as OrderProjection\n    participant Proj2 as AuditProjection\n    participant Store as Projection Store\n    ES->>Router: OrderPlaced event\n    Note over Router: Routes to all<br/>subscribed projections\n    Router->>Proj1: OnOrderPlaced(event, context)\n    Note over Proj1: ✅ Pure transformation<br/>Uses eventContext",
        "startIndex": 14264,
        "preview": "OrderPlaced - -> H2 OrderPlaced - -> H3 OrderPlaced - -> H4 OrderPlaced - -> H5 style OrderPlaced fill:#fff3cd,stroke:#ffc107,stroke-width:3px style H..."
      },
      {
        "id": "projections/projection-subscriptions-chunk-8",
        "text": "- just mark with [WhizbangSubscribe] `mermaid sequenceDiagram participant ES as Event Store participant Router as Event Router participant Proj1 as OrderProjection participant Proj2 as AuditProjection participant Store as Projection Store ES->>Router: OrderPlaced event Note over Router: Routes to all<br/>subscribed projections Router->>Proj1: OnOrderPlaced(event, context) Note over Proj1: ✅ Pure transformation<br/>Uses eventContext System Timestamp\n    Proj1->>Store: CreateAsync(OrderSummary)\n    Store-->>Proj1: Success\n    Proj1-->>Router: Accepted\n    Router->>Proj2: OnEvent<OrderPlaced>(event, context)\n    Note over Proj2: Generic handler<br/>Logs all events\n    Proj2->>Store: CreateAsync(AuditRecord)\n    Store-->>Proj2: Success\n    Proj2-->>Router: Accepted\n    Router->>Router: All projections complete\n`\n`csharp\n// This subscription is automatically registered\npublic Task OnOrderPlaced([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) {\n    // Source generator creates registration code like:\n    // services Subscribe<OrderPlaced, OrderSummaryProjection>(\n    //     projection => projection OnOrderPlaced);\n}\n`\nNext Steps\nProjection Contexts - EventContext and ProjectionContext injection\nProjection Purity - Maintaining pure, deterministic projections\nProjection Return Values - Using return values for observability",
        "startIndex": 666,
        "preview": "- just mark with [WhizbangSubscribe] `mermaid sequenceDiagram participant ES as Event Store participant Router as Event Router participant Proj1 as Or..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "roadmap/backups-and-snapshots",
    "title": "Backups and Snapshots",
    "category": "Roadmap",
    "url": "/docs/roadmap/backups-and-snapshots",
    "chunks": [
      {
        "id": "roadmap/backups-and-snapshots-chunk-0",
        "text": "Backups and Snapshots\n⚠️ FUTURE FEATURE - NOT YET RELEASED\nThis documentation describes backup and snapshot support planned for v1 1 0 These features are not available in the current release Status: Planned\nTarget Version: 1 1 0\n---\nOverview\nWhizbang will provide comprehensive backup and snapshot capabilities for disaster recovery, point-in-time restoration, and performance optimization Event Store Backups\nContinuous Backup\nAutomatic, incremental backups of event streams:\n`csharp{\ntitle: \"Backup Configuration\"\ndescription: \"Configure automatic event store backups\"\nframework: \"NET8\"\ncategory: \"Backups\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Backups\", \"Disaster Recovery\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang Backups\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UsePostgres(connectionString);\n        // Configure backups\n        es UseBackups(backup => {\n            // Continuous backup to Azure Blob Storage\n            backup UseAzureBlobStorage(config => {\n                config ConnectionString = azureStorageConnectionString;\n                config ContainerName = \"whizbang-backups\";\n            });\n            // Backup every 5 minutes\n            backup Interval = TimeSpan FromMinutes(5);\n            // Retention policy\n            backup RetainFor = TimeSpan FromDays(30);\n            backup PointInTimeRecovery = true;  // Keep transaction logs\n        });\n    });\n});\n`\nBackup Targets:\nAzure Blob Storage\nAWS S3\nGoogle Cloud Storage\nLocal file system\nNetwork share (SMB/NFS)\nPoint-in-Time Recovery (PITR)\nRestore event store to any point in time:\n`csharp{\ntitle: \"Point-in-Time Recovery\"\ndescription: \"Restore event store to specific timestamp\"\nframework: \"NET8\"\ncategory: \"Disaster Recovery\"\ndifficulty: \"ADVANCED\"\ntags: [\"Backups\", \"Disaster Recovery\", \"PITR\"]\nnugetPackages: [\"Whizbang Backups\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang Backups\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang Backups;\npublic class DisasterRecoveryService {\n    private readonly IEventStoreBackupManager _backupManager;\n    public DisasterRecoveryService(IEventStoreBackupManager backupManager) {\n        _backupManager = backupManager;\n    }\n    public async Task RecoverToPointInTimeAsync(DateTimeOffset targetTime) {\n        // Restore event store to specific timestamp\n        await _backupManager",
        "startIndex": 0,
        "preview": "Backups and Snapshots\n⚠️ FUTURE FEATURE - NOT YET RELEASED\nThis documentation describes backup and snapshot support planned for v1 1 0 These features ..."
      },
      {
        "id": "roadmap/backups-and-snapshots-chunk-1",
        "text": "usingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang Backups\"] showLineNumbers: true } using System; using System Threading Tasks; using Whizbang Backups; public class DisasterRecoveryService { private readonly IEventStoreBackupManager _backupManager; public DisasterRecoveryService(IEventStoreBackupManager backupManager) { _backupManager = backupManager; } public async Task RecoverToPointInTimeAsync(DateTimeOffset targetTime) { // Restore event store to specific timestamp await _backupManager RestoreAsync(new RestoreOptions {\n            TargetTime = targetTime,\n            TargetDatabase = \"whizbang_events_restored\",\n            VerifyIntegrity = true\n        });\n        // All events after targetTime are discarded\n        // All events before targetTime are restored\n    }\n    public async Task RecoverLastGoodStateAsync() {\n        // Find last known good backup\n        var lastGood = await _backupManager GetLastHealthyBackupAsync();\n        await _backupManager RestoreAsync(new RestoreOptions {\n            BackupId = lastGood Id,\n            TargetDatabase = \"whizbang_events\"\n        });\n    }\n}\n`\nBackup Verification\nAutomatic verification of backup integrity:\n`csharp{\ntitle: \"Backup Verification\"\ndescription: \"Verify backup integrity automatically\"\nframework: \"NET8\"\ncategory: \"Backups\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Backups\", \"Verification\"]\nnugetPackages: [\"Whizbang Backups\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseBackups(backup => {\n            // Verify backups automatically\n            backup VerifyAfterBackup = true;\n            // Restore to temporary database and validate\n            backup VerificationStrategy = BackupVerificationStrategy FullRestore;\n            // Alert on verification failure\n            backup OnVerificationFailed = async (backupId, error) => {\n                await alertService SendAsync($\"Backup {backupId} verification failed: {error}\");\n            };\n        });\n    });\n});\n`\nAggregate Snapshots\nPerformance Optimization\nSnapshots avoid replaying thousands of events for long-lived aggregates:\n`csharp{\ntitle: \"Aggregate Snapshots\"\ndescription: \"Configure snapshots for aggregates\"\nframework: \"NET8\"\ncategory: \"Snapshots\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Snapshots\", \"Performance\", \"Aggregates\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang Snapshots\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseSnapshots(snap => {\n            // Snapshot every 100 events\n            snap SnapshotEvery = 100;\n            // Store snapshots in same database as events\n            snap",
        "startIndex": 2587,
        "preview": "usingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang Backups\"] showLineNumbers: true } using System; using System Threading Tasks; using Wh..."
      },
      {
        "id": "roadmap/backups-and-snapshots-chunk-2",
        "text": "EventSourcing\", \"Whizbang Snapshots\"] usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"] showLineNumbers: true } using System; using Whizbang; using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseEventSourcing(es => { es UseSnapshots(snap => { // Snapshot every 100 events snap SnapshotEvery = 100; // Store snapshots in same database as events snap UsePostgres(connectionString);\n            // Or use faster storage for snapshots\n            snap UseRedis(redisConnectionString);\n            // Async snapshot creation (doesn't block aggregate saves)\n            snap CreateAsynchronously = true;\n        });\n    });\n});\n`\nManual Snapshots\nCreate snapshots for specific aggregates:\n`csharp{\ntitle: \"Manual Snapshot Creation\"\ndescription: \"Create snapshots on demand\"\nframework: \"NET8\"\ncategory: \"Snapshots\"\ndifficulty: \"ADVANCED\"\ntags: [\"Snapshots\", \"Aggregates\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang Snapshots\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang Snapshots\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang Snapshots;\npublic class SnapshotService {\n    private readonly ISnapshotStore _snapshotStore;\n    private readonly IRepository<Order> _orderRepository;\n    public SnapshotService(ISnapshotStore snapshotStore, IRepository<Order> orderRepository) {\n        _snapshotStore = snapshotStore;\n        _orderRepository = orderRepository;\n    }\n    public async Task CreateSnapshotAsync(Guid orderId) {\n        // Load aggregate\n        var order = await _orderRepository GetAsync(orderId);\n        // Create snapshot\n        await _snapshotStore SaveSnapshotAsync(order);\n    }\n    public async Task RebuildSnapshotsForAllOrdersAsync() {\n        // Rebuild all snapshots (e g , after schema change)\n        var orderIds = await GetAllOrderIdsAsync();\n        foreach (var orderId in orderIds) {\n            await CreateSnapshotAsync(orderId);\n        }\n    }\n}\n`\nSnapshot Schema Versioning\nHandle snapshot schema changes:\n`csharp{\ntitle: \"Snapshot Versioning\"\ndescription: \"Handle evolving snapshot schemas\"\nframework: \"NET8\"\ncategory: \"Snapshots\"\ndifficulty: \"ADVANCED\"\ntags: [\"Snapshots\", \"Versioning\", \"Schema Evolution\"]\nnugetPackages: [\"Whizbang Snapshots\"]\nusingStatements: [\"System\", \"Whizbang Snapshots\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang",
        "startIndex": 5101,
        "preview": "EventSourcing\", \"Whizbang Snapshots\"] usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"] showLineNumbers: true } usin..."
      },
      {
        "id": "roadmap/backups-and-snapshots-chunk-3",
        "text": "in orderIds) { await CreateSnapshotAsync(orderId); } } } ` Snapshot Schema Versioning Handle snapshot schema changes: `csharp{ title: \"Snapshot Versioning\" description: \"Handle evolving snapshot schemas\" framework: \"NET8\" category: \"Snapshots\" difficulty: \"ADVANCED\" tags: [\"Snapshots\", \"Versioning\", \"Schema Evolution\"] nugetPackages: [\"Whizbang Snapshots\"] usingStatements: [\"System\", \"Whizbang Snapshots\"] showLineNumbers: true } using System; using Whizbang Snapshots;\n// V1 snapshot\npublic class OrderSnapshotV1 {\n    public Guid Id { get; set; }\n    public string Status { get; set; }\n    public decimal Total { get; set; }\n}\n// V2 snapshot (added fields)\npublic class OrderSnapshotV2 {\n    public Guid Id { get; set; }\n    public string Status { get; set; }\n    public decimal Total { get; set; }\n    public DateTimeOffset PlacedAt { get; set; }  // New field\n    public string Currency { get; set; }          // New field\n}\n// Upcaster converts V1 → V2\npublic class OrderSnapshotUpcaster : ISnapshotUpcaster<OrderSnapshotV1, OrderSnapshotV2> {\n    public OrderSnapshotV2 Upcast(OrderSnapshotV1 oldSnapshot) {\n        return new OrderSnapshotV2 {\n            Id = oldSnapshot Id,\n            Status = oldSnapshot Status,\n            Total = oldSnapshot Total,\n            PlacedAt = DateTimeOffset MinValue,  // Default for old snapshots\n            Currency = \"USD\"                      // Default currency\n        };\n    }\n}\n`\nProjection Backups\nRebuild vs Backup\nProjections can be rebuilt from events, but backups provide faster recovery:\n`csharp{\ntitle: \"Projection Backup Strategy\"\ndescription: \"Choose between rebuild and backup restore\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Backups\", \"Disaster Recovery\"]\nnugetPackages: [\"Whizbang Projections\", \"Whizbang Backups\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseProjections(proj => {\n        proj RegisterProjection<OrderHistoryProjection>(p => {\n            // Strategy 1: Rebuild from events (slow but always correct)\n            p DisasterRecoveryStrategy = ProjectionRecoveryStrategy RebuildFromEvents;\n            // Strategy 2: Restore from backup (fast but needs regular backups)\n            p DisasterRecoveryStrategy = ProjectionRecoveryStrategy RestoreFromBackup;\n            p BackupInterval = TimeSpan",
        "startIndex": 7099,
        "preview": "in orderIds) { await CreateSnapshotAsync(orderId); } } } ` Snapshot Schema Versioning Handle snapshot schema changes: `csharp{ title: \"Snapshot Versio..."
      },
      {
        "id": "roadmap/backups-and-snapshots-chunk-4",
        "text": "Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseProjections(proj => { proj RegisterProjection<OrderHistoryProjection>(p => { // Strategy 1: Rebuild from events (slow but always correct) p DisasterRecoveryStrategy = ProjectionRecoveryStrategy RebuildFromEvents; // Strategy 2: Restore from backup (fast but needs regular backups) p DisasterRecoveryStrategy = ProjectionRecoveryStrategy RestoreFromBackup; p BackupInterval = TimeSpan FromHours(1);\n            // Strategy 3: Hybrid (restore backup, then replay recent events)\n            p DisasterRecoveryStrategy = ProjectionRecoveryStrategy Hybrid;\n            p BackupInterval = TimeSpan FromHours(6);\n        });\n    });\n});\n`\nProjection Snapshots\nExport projection state for analytics or migration:\n`csharp{\ntitle: \"Projection Export\"\ndescription: \"Export projection state for backup or analytics\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Backups\", \"Export\"]\nnugetPackages: [\"Whizbang Projections\", \"Whizbang Backups\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang Backups\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang Backups;\npublic class ProjectionBackupService {\n    private readonly IProjectionBackupManager _backupManager;\n    public ProjectionBackupService(IProjectionBackupManager backupManager) {\n        _backupManager = backupManager;\n    }\n    public async Task BackupProjectionAsync<TProjection>() {\n        // Export entire projection to Parquet file\n        await _backupManager ExportProjectionAsync<TProjection>(new ExportOptions {\n            Format = ExportFormat Parquet,\n            Destination = \"s3://backups/projections/order-history parquet\",\n            Compression = CompressionType Snappy\n        });\n    }\n    public async Task RestoreProjectionAsync<TProjection>(string backupPath) {\n        // Import projection from backup\n        await _backupManager ImportProjectionAsync<TProjection>(new ImportOptions {\n            Source = backupPath,\n            TruncateExisting = true  // Clear current data first\n        });\n    }\n}\n`\nCross-Region Replication\nReplicate event streams to multiple regions for disaster recovery:\n`csharp{\ntitle: \"Cross-Region Replication\"\ndescription: \"Replicate events to multiple regions\"\nframework: \"NET8\"\ncategory: \"Disaster Recovery\"\ndifficulty: \"ADVANCED\"\ntags: [\"Replication\", \"Multi-Region\", \"Disaster Recovery\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang Replication\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        // Primary region (US East)\n        es UsePostgres(\"Host=us-east postgres azure com; \");\n        // Replicate to secondary regions\n        es UseReplication(repl => {\n            repl ReplicateTo(\"us-west\", \"Host=us-west postgres azure com; \");\n            repl ReplicateTo(\"eu-west\", \"Host=eu-west postgres azure",
        "startIndex": 9160,
        "preview": "Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseProjections(proj => { proj RegisterProjection<OrderHistoryProje..."
      },
      {
        "id": "roadmap/backups-and-snapshots-chunk-5",
        "text": "DependencyInjection\"] showLineNumbers: true } using Whizbang; using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseEventSourcing(es => { // Primary region (US East) es UsePostgres(\"Host=us-east postgres azure com; \"); // Replicate to secondary regions es UseReplication(repl => { repl ReplicateTo(\"us-west\", \"Host=us-west postgres azure com; \"); repl ReplicateTo(\"eu-west\", \"Host=eu-west postgres azure com; \");\n            // Async replication (eventual consistency)\n            repl Mode = ReplicationMode Asynchronous;\n            // Failover configuration\n            repl AutomaticFailover = true;\n            repl HealthCheckInterval = TimeSpan FromSeconds(10);\n        });\n    });\n});\n`\nBackup Monitoring\nMonitor backup health and alert on issues:\n`csharp{\ntitle: \"Backup Monitoring\"\ndescription: \"Monitor and alert on backup health\"\nframework: \"NET8\"\ncategory: \"Observability\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Backups\", \"Monitoring\", \"Alerts\"]\nnugetPackages: [\"Whizbang Backups\", \"Whizbang OpenTelemetry\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseBackups(backup => {\n        // Emit OpenTelemetry metrics\n        backup UseOpenTelemetry();\n        // Alert on backup failures\n        backup OnBackupFailed = async (error) => {\n            await alertService SendAsync($\"Backup failed: {error Message}\");\n        };\n        // Alert if backup hasn't run recently\n        backup AlertIfNoBackupFor = TimeSpan FromHours(2);\n        // Alert on low disk space\n        backup AlertIfStorageBelow = 10  1024  1024 * 1024;  // 10 GB\n    });\n});\n`\nMetrics Emitted:\nwhizbang backup duration - How long backups take\nwhizbang backup size - Backup size in bytes\nwhizbang backup success - Backup success/failure count\nwhizbang backup verification_duration - Verification time\nNext Steps\nLakehouse Streaming - Stream events to data lakes\nObservability - Monitor backup health\nDisaster Recovery - Complete DR strategy\nFeedback Welcome\nWe're designing this feature now What backup strategies do you need Share your thoughts",
        "startIndex": 11553,
        "preview": "DependencyInjection\"] showLineNumbers: true } using Whizbang; using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { option..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "roadmap/distributed-messaging",
    "title": "Distributed Messaging",
    "category": "Roadmap",
    "url": "/docs/roadmap/distributed-messaging",
    "chunks": [
      {
        "id": "roadmap/distributed-messaging-chunk-0",
        "text": "Distributed Messaging\n⚠️ FUTURE FEATURE - NOT YET RELEASED\nThis documentation describes distributed messaging support planned for v1 0 0 This feature is not available in the current release Status: Planned\nTarget Version: 1 0 0\n---\nOverview\nDistributed messaging enables Whizbang applications to scale beyond a single process into microservices architecture Commands and events can be routed across service boundaries using message brokers like Kafka, RabbitMQ, or Azure Service Bus Key Features\nDomain Ownership Routing\nCommands are routed to the service that owns the domain:\n`csharp\n// In the API Gateway service\nawait whizbang Send(new PlaceOrder( ));\n// ↓\n// Command automatically routed to Orders service via message broker\n`\nEvents are broadcast from the owning domain to all subscribers:\n`csharp\n// In the Orders service\nawait repository SaveAsync(order);  // Emits OrderPlaced event\n// ↓\n// Event published to message broker\n// ↓\n// Inventory, Shipping, and Analytics services all receive the event\n`\nOutbox/Inbox Pattern\nEnsures exactly-once semantics for distributed messaging:\nOutbox (publishing side):\nEvents written to outbox table in same transaction as event store append\nBackground worker publishes from outbox to message broker\nMessages marked as published after broker confirms\nInbox (subscribing side):\nMessages received from broker stored in inbox table\nIdempotent handler checks if message ID already processed\nPeriodic cleanup of old inbox entries\nMessage Broker Adapters\nMultiple message broker adapters will be supported:\nKafka - High throughput, event replay, partition awareness\nRabbitMQ - Flexible routing, priority queues\nAzure Service Bus - Managed service, sessions, duplicate detection\nAWS SQS/SNS - Managed service, FIFO queues\nConfiguration\nIntended API:\n`csharp{\ntitle: \"Distributed Messaging Configuration\"\ndescription: \"How distributed messaging will be configured\"\nframework: \"NET8\"\ncategory: \"Distributed Systems\"\ndifficulty: \"ADVANCED\"\ntags: [\"Messaging\", \"Configuration\", \"Microservices\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Messaging\", \"Whizbang Kafka\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions",
        "startIndex": 0,
        "preview": "Distributed Messaging\n⚠️ FUTURE FEATURE - NOT YET RELEASED\nThis documentation describes distributed messaging support planned for v1 0 0 This feature ..."
      },
      {
        "id": "roadmap/distributed-messaging-chunk-1",
        "text": "- Managed service, sessions, duplicate detection AWS SQS/SNS - Managed service, FIFO queues Configuration Intended API: `csharp{ title: \"Distributed Messaging Configuration\" description: \"How distributed messaging will be configured\" framework: \"NET8\" category: \"Distributed Systems\" difficulty: \"ADVANCED\" tags: [\"Messaging\", \"Configuration\", \"Microservices\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Messaging\", \"Whizbang Kafka\"] usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseMessaging(msg => {\n        // Configure domain ownership\n        msg UseDomainOwnership(domains => {\n            domains RegisterDomain(\"Orders\", \"https://orders myapp com\");\n            domains RegisterDomain(\"Inventory\", \"https://inventory myapp com\");\n            domains RegisterDomain(\"Shipping\", \"https://shipping myapp com\");\n        });\n        // Use Kafka as message broker\n        msg UseKafka(kafka => {\n            kafka BootstrapServers = \"kafka:9092\";\n            kafka ConsumerGroup = \"orders-service\";\n        });\n        // Enable outbox for reliable publishing\n        msg UseOutbox(outbox => {\n            outbox PublishInterval = TimeSpan FromSeconds(1);\n        });\n        // Enable inbox for idempotent consumption\n        msg UseInbox(inbox => {\n            inbox CleanupRetention = TimeSpan FromDays(7);\n        });\n    });\n});\n`\nBackfilling Projections\nWhen a new service subscribes to events for the first time, it can backfill from the entire event history:\n`csharp{\ntitle: \"Projection Backfilling\"\ndescription: \"Subscribe to events and backfill from history\"\nframework: \"NET8\"\ncategory: \"Distributed Systems\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Backfilling\", \"Event Sourcing\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Projections\", \"Whizbang Messaging\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseProjections(proj => {\n        proj RegisterProjection<OrderAnalyticsProjection>(p => {\n            // Subscribe to events from Orders domain\n            p Subscribe<OrderPlaced>();\n            p Subscribe<OrderShipped>();\n            p Subscribe<OrderCancelled>();\n            // Backfill from the beginning of time\n            p BackfillFrom = DateTimeOffset MinValue;\n            // Query Orders service for historical events\n            p BackfillSource = \"https://orders myapp",
        "startIndex": 2161,
        "preview": "- Managed service, sessions, duplicate detection AWS SQS/SNS - Managed service, FIFO queues Configuration Intended API: `csharp{ title: \"Distributed M..."
      },
      {
        "id": "roadmap/distributed-messaging-chunk-2",
        "text": "DependencyInjection; services AddWhizbang(options => { options UseProjections(proj => { proj RegisterProjection<OrderAnalyticsProjection>(p => { // Subscribe to events from Orders domain p Subscribe<OrderPlaced>(); p Subscribe<OrderShipped>(); p Subscribe<OrderCancelled>(); // Backfill from the beginning of time p BackfillFrom = DateTimeOffset MinValue; // Query Orders service for historical events p BackfillSource = \"https://orders myapp com/events\";\n        });\n    });\n});\n`\nThe projection engine will:\nQuery the Orders service's event store via HTTP API\nFetch all historical events matching subscribed types\nApply them to the projection in order\nSwitch to real-time message broker consumption\nContinue processing new events as they arrive\nFeedback Welcome\nWe're designing this feature now and welcome your input What message brokers do you need supported What edge cases should we handle What API would be most intuitive Open a discussion to share your thoughts",
        "startIndex": 4398,
        "preview": "DependencyInjection; services AddWhizbang(options => { options UseProjections(proj => { proj RegisterProjection<OrderAnalyticsProjection>(p => { // Su..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "roadmap/lakehouse-streaming",
    "title": "Lakehouse Streaming",
    "category": "Roadmap",
    "url": "/docs/roadmap/lakehouse-streaming",
    "chunks": [
      {
        "id": "roadmap/lakehouse-streaming-chunk-0",
        "text": "Lakehouse Streaming\n⚠️ FUTURE FEATURE - NOT YET RELEASED\nThis documentation describes lakehouse streaming support planned for v1 2 0 This feature is not available in the current release Status: Planned\nTarget Version: 1 2 0\n---\nOverview\nWhizbang will provide first-class integration with data lakehouses (Delta Lake, Apache Iceberg, Apache Hudi), enabling real-time streaming of events for analytics, ML, and business intelligence Why Lakehouse Streaming Event Store as Operational Database\nThe event store is optimized for transactional workloads (fast writes, point queries):\nWrite new events\nLoad aggregate streams\nSupport projections\nLakehouse as Analytical Database\nLakehouses are optimized for analytical workloads (complex queries, aggregations):\nAd-hoc SQL queries across all events\nTime-series analytics\nMachine learning feature extraction\nBusiness intelligence dashboards\nStream events from Whizbang → Lakehouse for the best of both worlds Supported Lakehouses\nDelta Lake (Databricks, Azure Synapse, AWS EMR)\nApache Iceberg (Snowflake, AWS Athena, Google BigQuery)\nApache Hudi (AWS EMR, Google Dataproc)\nParquet files (S3, Azure Data Lake, Google Cloud Storage)\nConfiguration\nDelta Lake Streaming\n`csharp{\ntitle: \"Delta Lake Streaming Configuration\"\ndescription: \"Stream events to Delta Lake\"\nframework: \"NET8\"\ncategory: \"Analytics\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Delta Lake\", \"Streaming\", \"Analytics\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UsePostgres(connectionString);\n        // Stream events to Delta Lake\n        es StreamToLakehouse(lake => {\n            lake UseDeltaLake(delta => {\n                delta StoragePath = \"s3://my-data-lake/whizbang/events\";\n                delta PartitionBy = \"event_date\";  // Partition by date for performance\n                delta MergeSchema = true;          // Handle schema evolution\n            });\n            // Stream continuously\n            lake StreamingMode = StreamingMode Continuous;\n            // Batch events for efficiency\n            lake BatchSize = 1000;\n            lake FlushInterval = TimeSpan",
        "startIndex": 0,
        "preview": "Lakehouse Streaming\n⚠️ FUTURE FEATURE - NOT YET RELEASED\nThis documentation describes lakehouse streaming support planned for v1 2 0 This feature is n..."
      },
      {
        "id": "roadmap/lakehouse-streaming-chunk-1",
        "text": "=> { lake UseDeltaLake(delta => { delta StoragePath = \"s3://my-data-lake/whizbang/events\"; delta PartitionBy = \"event_date\"; // Partition by date for performance delta MergeSchema = true; // Handle schema evolution }); // Stream continuously lake StreamingMode = StreamingMode Continuous; // Batch events for efficiency lake BatchSize = 1000; lake FlushInterval = TimeSpan FromSeconds(30);\n        });\n    });\n});\n`\nWhat happens:\nEvents written to Postgres event store\nBackground worker batches events\nEvents written to Delta Lake as Parquet files\nPartitioned by date for efficient queries\nSchema automatically detected and evolved\nApache Iceberg Streaming\n`csharp{\ntitle: \"Apache Iceberg Streaming Configuration\"\ndescription: \"Stream events to Apache Iceberg\"\nframework: \"NET8\"\ncategory: \"Analytics\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Iceberg\", \"Streaming\", \"Analytics\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es StreamToLakehouse(lake => {\n            lake UseIceberg(iceberg => {\n                iceberg Catalog = \"glue\";  // AWS Glue catalog\n                iceberg Database = \"whizbang\";\n                iceberg TableName = \"events\";\n                iceberg WarehousePath = \"s3://my-warehouse/whizbang\";\n            });\n        });\n    });\n});\n`\nEvent Filtering\nStream only specific events to lakehouse:\n`csharp{\ntitle: \"Event Filtering for Lakehouse\"\ndescription: \"Stream only specific events\"\nframework: \"NET8\"\ncategory: \"Analytics\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Filtering\", \"Streaming\", \"Analytics\"]\nnugetPackages: [\"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es StreamToLakehouse(lake => {\n            lake UseDeltaLake(delta => { / / });\n            // Stream only certain event types\n            lake IncludeEvents(\n                typeof(OrderPlaced),\n                typeof(OrderShipped),\n                typeof(PaymentProcessed)\n            );\n            // Exclude sensitive events\n            lake ExcludeEvents(typeof(PaymentMethodUpdated));\n            // Custom filter\n            lake Filter = @event => {\n                // Don't stream test tenant data\n                return @event Metadata TenantId",
        "startIndex": 2349,
        "preview": "=> { lake UseDeltaLake(delta => { delta StoragePath = \"s3://my-data-lake/whizbang/events\"; delta PartitionBy = \"event_date\"; // Partition by date for ..."
      },
      {
        "id": "roadmap/lakehouse-streaming-chunk-2",
        "text": "=> { es StreamToLakehouse(lake => { lake UseDeltaLake(delta => { / / }); // Stream only certain event types lake IncludeEvents( typeof(OrderPlaced), typeof(OrderShipped), typeof(PaymentProcessed) ); // Exclude sensitive events lake ExcludeEvents(typeof(PaymentMethodUpdated)); // Custom filter lake Filter = @event => { // Don't stream test tenant data return @event Metadata TenantId StartsWith(\"test-\");\n            };\n        });\n    });\n});\n`\nEvent Schema Mapping\nMap events to lakehouse schema:\n`csharp{\ntitle: \"Event Schema Mapping\"\ndescription: \"Map events to lakehouse table schema\"\nframework: \"NET8\"\ncategory: \"Analytics\"\ndifficulty: \"ADVANCED\"\ntags: [\"Schema\", \"Mapping\", \"Analytics\"]\nnugetPackages: [\"Whizbang Lakehouse\"]\nusingStatements: [\"System\", \"Whizbang Lakehouse\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang Lakehouse;\npublic class OrderPlacedEventMapper : IEventMapper<OrderPlaced> {\n    public LakehouseRow Map(OrderPlaced @event) {\n        return new LakehouseRow {\n            // Standard fields\n            [\"event_id\"] = @event EventId,\n            [\"event_type\"] = \"OrderPlaced\",\n            [\"event_timestamp\"] = @event Timestamp,\n            [\"aggregate_id\"] = @event OrderId,\n            [\"tenant_id\"] = @event TenantId,\n            // Event-specific fields\n            [\"customer_id\"] = @event CustomerId,\n            [\"order_total\"] = @event Total,\n            [\"order_status\"] = \"Placed\",\n            [\"item_count\"] = @event Items Count,\n            // Denormalized for analytics\n            [\"year\"] = @event PlacedAt Year,\n            [\"month\"] = @event PlacedAt Month,\n            [\"day\"] = @event PlacedAt Day,\n            [\"hour\"] = @event PlacedAt Hour\n        };\n    }\n}\n`\nQuerying Lakehouse Data\nSQL Queries (Delta Lake)\nOnce events are in the lakehouse, query with SQL:\n`sql\n-- Total orders by day\nSELECT\n    event_date,\n    COUNT(*) as order_count,\n    SUM(order_total) as total_revenue\nFROM whizbang events\nWHERE event_type = 'OrderPlaced'\nGROUP BY event_date\nORDER BY event_date DESC;\n-- Customer lifetime value\nSELECT\n    customer_id,\n    COUNT(DISTINCT aggregate_id) as total_orders,\n    SUM(order_total) as lifetime_value\nFROM whizbang events\nWHERE event_type = 'OrderPlaced'\nGROUP BY customer_id\nORDER BY lifetime_value DESC\nLIMIT 100;\n-- Hourly order trends\nSELECT\n    DATE_TRUNC('hour', event_timestamp) as hour,\n    COUNT(*) as order_count\nFROM whizbang",
        "startIndex": 4595,
        "preview": "=> { es StreamToLakehouse(lake => { lake UseDeltaLake(delta => { / / }); // Stream only certain event types lake IncludeEvents( typeof(OrderPlaced), t..."
      },
      {
        "id": "roadmap/lakehouse-streaming-chunk-3",
        "text": "GROUP BY event_date ORDER BY event_date DESC; -- Customer lifetime value SELECT customer_id, COUNT(DISTINCT aggregate_id) as total_orders, SUM(order_total) as lifetime_value FROM whizbang events WHERE event_type = 'OrderPlaced' GROUP BY customer_id ORDER BY lifetime_value DESC LIMIT 100; -- Hourly order trends SELECT DATE_TRUNC('hour', event_timestamp) as hour, COUNT(*) as order_count FROM whizbang events\nWHERE event_type = 'OrderPlaced'\n  AND event_date >= CURRENT_DATE - INTERVAL '7 days'\nGROUP BY hour\nORDER BY hour;\n`\nDataFrames (Spark/Databricks)\n`python\nLoad events from Delta Lake\nevents = spark read format(\"delta\") load(\"s3://my-data-lake/whizbang/events\")\nFilter to order events\norders = events filter(events event_type == \"OrderPlaced\")\nAggregate by customer\ncustomer_stats = orders groupBy(\"customer_id\") agg(\n    count(\"*\") alias(\"order_count\"),\n    sum(\"order_total\") alias(\"total_spend\"),\n    avg(\"order_total\") alias(\"avg_order_value\")\n)\nWrite to feature store for ML\ncustomer_stats write format(\"delta\") mode(\"overwrite\") save(\"s3://features/customers\")\n`\nTime Travel Queries\nLakehouse time travel enables querying historical data:\n`sql\n-- Query events as of yesterday\nSELECT * FROM whizbang events TIMESTAMP AS OF '2025-10-17 00:00:00';\n-- Query events from specific version\nSELECT * FROM whizbang events VERSION AS OF 123;\n-- See all changes between versions\nSELECT * FROM whizbang events VERSION AS OF 100\nEXCEPT\nSELECT * FROM whizbang events VERSION AS OF 150;\n`\nSchema Evolution\nLakehouses handle schema changes gracefully:\n`csharp{\ntitle: \"Schema Evolution\"\ndescription: \"Handle evolving event schemas in lakehouse\"\nframework: \"NET8\"\ncategory: \"Analytics\"\ndifficulty: \"ADVANCED\"\ntags: [\"Schema\", \"Evolution\", \"Analytics\"]\nnugetPackages: [\"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es StreamToLakehouse(lake => {\n            lake UseDeltaLake(delta => {\n                // Automatically add new columns when event schema changes\n                delta MergeSchema = true;\n                // Or use strict mode (fail on schema mismatch)\n                delta MergeSchema = false;\n                delta OnSchemaMismatch = SchemaMismatchPolicy",
        "startIndex": 6624,
        "preview": "GROUP BY event_date ORDER BY event_date DESC; -- Customer lifetime value SELECT customer_id, COUNT(DISTINCT aggregate_id) as total_orders, SUM(order_t..."
      },
      {
        "id": "roadmap/lakehouse-streaming-chunk-4",
        "text": "using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseEventSourcing(es => { es StreamToLakehouse(lake => { lake UseDeltaLake(delta => { // Automatically add new columns when event schema changes delta MergeSchema = true; // Or use strict mode (fail on schema mismatch) delta MergeSchema = false; delta OnSchemaMismatch = SchemaMismatchPolicy Fail;\n            });\n        });\n    });\n});\n`\nExample:\n`csharp\n// V1 event\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, decimal Total);\n// V2 event (added field)\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, decimal Total, string Currency);\n`\nWith MergeSchema = true:\nOld events have Currency = null\nNew events have all fields\nNo data migration needed\nPerformance Optimization\nPartitioning Strategy\n`csharp{\ntitle: \"Lakehouse Partitioning\"\ndescription: \"Optimize queries with partitioning\"\nframework: \"NET8\"\ncategory: \"Performance\"\ndifficulty: \"ADVANCED\"\ntags: [\"Partitioning\", \"Performance\", \"Analytics\"]\nnugetPackages: [\"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es StreamToLakehouse(lake => {\n            lake UseDeltaLake(delta => {\n                // Partition by date and tenant for fast queries\n                delta PartitionBy = new[] { \"event_date\", \"tenant_id\" };\n                // Z-order for co-located data\n                delta ZOrderBy = new[] { \"customer_id\", \"event_type\" };\n                // Optimize file sizes\n                delta TargetFileSize = 128  1024  1024;  // 128 MB\n            });\n        });\n    });\n});\n`\nQuery optimization:\n`sql\n-- Fast (partition pruning)\nSELECT * FROM events\nWHERE event_date = '2025-10-18'\n  AND tenant_id = 'acme-corp';\n-- Slow (full table scan)\nSELECT * FROM events\nWHERE customer_id = '12345';\n`\nCompaction\nPeriodically compact small files:\n`csharp{\ntitle: \"Lakehouse Compaction\"\ndescription: \"Compact small files for better performance\"\nframework: \"NET8\"\ncategory: \"Performance\"\ndifficulty: \"ADVANCED\"\ntags: [\"Compaction\", \"Performance\", \"Analytics\"]\nnugetPackages: [\"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es StreamToLakehouse(lake => {\n            lake",
        "startIndex": 8608,
        "preview": "using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseEventSourcing(es => { es StreamToLakehouse(lake => { lake..."
      },
      {
        "id": "roadmap/lakehouse-streaming-chunk-5",
        "text": "description: \"Compact small files for better performance\" framework: \"NET8\" category: \"Performance\" difficulty: \"ADVANCED\" tags: [\"Compaction\", \"Performance\", \"Analytics\"] nugetPackages: [\"Whizbang Lakehouse\"] usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"] showLineNumbers: true } using System; using Whizbang; using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseEventSourcing(es => { es StreamToLakehouse(lake => { lake UseDeltaLake(delta => {\n                // Auto-compact small files\n                delta AutoCompact = true;\n                delta CompactInterval = TimeSpan FromHours(6);\n                delta TargetFileSize = 128  1024  1024;  // 128 MB\n            });\n        });\n    });\n});\n`\nIntegration with BI Tools\nDatabricks\nEvents in Delta Lake are queryable from Databricks notebooks:\n`python\nConnect to lakehouse\nevents = spark read format(\"delta\") load(\"s3://my-data-lake/whizbang/events\")\nCreate temp view for SQL\nevents createOrReplaceTempView(\"events\")\nQuery with Spark SQL\nresults = spark sql(\"\"\"\n    SELECT event_date, COUNT(*) as event_count\n    FROM events\n    GROUP BY event_date\n    ORDER BY event_date DESC\n\"\"\")\nVisualize in notebook\ndisplay(results)\n`\nPower BI / Tableau\nConnect via ODBC/JDBC:\n`plaintext\nConnection: Delta Lake (S3)\nPath: s3://my-data-lake/whizbang/events\nTable: events\n`\ndbt (Data Build Tool)\nCreate analytics models from events:\n`sql\n-- models/orders_daily sql\n{{ config(materialized='table') }}\nSELECT\n    DATE(event_timestamp) as date,\n    COUNT(DISTINCT aggregate_id) as order_count,\n    SUM(order_total) as revenue,\n    AVG(order_total) as avg_order_value\nFROM {{ source('whizbang', 'events') }}\nWHERE event_type = 'OrderPlaced'\nGROUP BY date\n`\nStreaming Guarantees\nAt-Least-Once Delivery\nEvents are guaranteed to be delivered to the lakehouse at least once:\nIdempotent writes (duplicate events filtered by event_id)\nCheckpointing for crash recovery\nTransactional writes to lakehouse\nExactly-Once Semantics\nFor critical analytics, enable exactly-once:\n`csharp{\ntitle: \"Exactly-Once Lakehouse Streaming\"\ndescription: \"Ensure no duplicate events in lakehouse\"\nframework: \"NET8\"\ncategory: \"Reliability\"\ndifficulty: \"ADVANCED\"\ntags: [\"Exactly-Once\", \"Reliability\", \"Streaming\"]\nnugetPackages: [\"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es StreamToLakehouse(lake => {\n            lake UseDeltaLake(delta => { / / });\n            // Exactly-once semantics\n            lake",
        "startIndex": 10817,
        "preview": "description: \"Compact small files for better performance\" framework: \"NET8\" category: \"Performance\" difficulty: \"ADVANCED\" tags: [\"Compaction\", \"Perfo..."
      },
      {
        "id": "roadmap/lakehouse-streaming-chunk-6",
        "text": "framework: \"NET8\" category: \"Reliability\" difficulty: \"ADVANCED\" tags: [\"Exactly-Once\", \"Reliability\", \"Streaming\"] nugetPackages: [\"Whizbang Lakehouse\"] usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"] showLineNumbers: true } using Whizbang; using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseEventSourcing(es => { es StreamToLakehouse(lake => { lake UseDeltaLake(delta => { / / }); // Exactly-once semantics lake DeliveryGuarantee = DeliveryGuarantee ExactlyOnce;\n            // Deduplication by event ID\n            lake DeduplicateBy = \"event_id\";\n        });\n    });\n});\n`\nNext Steps\nBackups and Snapshots - Backup strategies\nObservability - Monitor streaming health\nAnalytics - Query patterns and examples\nFeedback Welcome\nWhat analytics use cases do you have for event data Share your thoughts",
        "startIndex": 13041,
        "preview": "framework: \"NET8\" category: \"Reliability\" difficulty: \"ADVANCED\" tags: [\"Exactly-Once\", \"Reliability\", \"Streaming\"] nugetPackages: [\"Whizbang Lakehous..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "usage-patterns/aspect-oriented-handlers",
    "title": "Aspect-Oriented Handlers",
    "category": "Usage Patterns",
    "url": "/docs/usage-patterns/aspect-oriented-handlers",
    "chunks": [
      {
        "id": "usage-patterns/aspect-oriented-handlers-chunk-0",
        "text": "Aspect-Oriented Handlers\nOverview\nAspect-Oriented Programming (AOP) in Whizbang allows you to cleanly separate cross-cutting concerns from your business logic Through source generators and declarative attributes, you can add logging, caching, validation, authorization, and other behaviors without cluttering your handler code Core Concepts\nAspects vs Traditional Approaches\nTraditional approach with manual cross-cutting concerns:\n`csharp\n// ❌ Traditional: Business logic mixed with infrastructure concerns\npublic class OrderHandler {\n    private readonly ILogger _logger;\n    private readonly ICache _cache;\n    private readonly IMetrics _metrics;\n    private readonly IValidator _validator;\n    public async Task<Result> Handle(CreateOrder cmd) {\n        // Validation\n        var validationResult = _validator Validate(cmd);\n        if ( validationResult IsValid) {\n            _logger Warning(\"Validation failed: {Errors}\", validationResult Errors);\n            return Result Failure(validationResult Errors);\n        }\n        // Logging\n        _logger Information(\"Processing order for customer {CustomerId}\", cmd CustomerId);\n        var stopwatch = Stopwatch StartNew();\n        try {\n            // Check cache\n            var cacheKey = $\"order:{cmd CustomerId}\";\n            var cached = await _cache GetAsync<Order>(cacheKey);\n            if (cached = null) {\n                _logger Debug(\"Cache hit for {CacheKey}\", cacheKey);\n                return Result Success(cached);\n            }\n            // FINALLY: Actual business logic (buried in infrastructure)\n            var order = CreateOrder(cmd);\n            // Update cache\n            await _cache SetAsync(cacheKey, order);\n            // Metrics\n            _metrics Increment(\"orders created\");\n            _metrics RecordDuration(\"order processing\", stopwatch Elapsed);\n            _logger Information(\"Order {OrderId} created successfully\", order Id);\n            return Result Success(order);\n        }\n        catch (Exception ex) {\n            _logger Error(ex, \"Failed to create order\");\n            _metrics Increment(\"orders failed\");\n            throw;\n        }\n    }\n}\n`\nWhizbang approach with aspects:\n`csharp\n// ✅ Whizbang: Pure business logic with declarative aspects\n[Validated]\n[Logged]\n[Cached(Duration = \"5m\")]\n[Timed]\n[Metered(\"orders\")]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // ONLY business logic - clean and focused\n        var order = CreateOrder(cmd);\n        return new OrderCreated(order Id, order Total);\n    }\n}\n`\nBuilt-in Aspects\nLogging Aspect\n`csharp{\ntitle: \"Logging Aspect\"\ndescription: \"Automatic structured logging for handlers\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"BEGINNER\"\ntags: [\"Logging\", \"Observability\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"LoggingAspect",
        "startIndex": 0,
        "preview": "Aspect-Oriented Handlers\nOverview\nAspect-Oriented Programming (AOP) in Whizbang allows you to cleanly separate cross-cutting concerns from your busine..."
      },
      {
        "id": "usage-patterns/aspect-oriented-handlers-chunk-1",
        "text": "// ONLY business logic - clean and focused var order = CreateOrder(cmd); return new OrderCreated(order Id, order Total); } } ` Built-in Aspects Logging Aspect `csharp{ title: \"Logging Aspect\" description: \"Automatic structured logging for handlers\" framework: \"NET8\" category: \"Aspects\" difficulty: \"BEGINNER\" tags: [\"Logging\", \"Observability\", \"Aspects\"] nugetPackages: [\"Whizbang Core\"] filename: \"LoggingAspect cs\"\nshowLineNumbers: true\nhighlightLines: [1, 2, 3]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Basic logging\n[Logged]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Automatically logs:\n        // - Handler execution start\n        // - Input parameters (redacted sensitive data)\n        // - Execution duration\n        // - Success/failure status\n        // - Return value summary\n        return new OrderCreated(cmd OrderId);\n    }\n}\n// Detailed logging with custom levels\n[Logged(\n    Level = LogLevel Debug,\n    LogInputs = true,\n    LogOutputs = true,\n    LogDuration = true\n)]\npublic class DetailedHandler : IHandle<ComplexOperation> {\n    public Result Handle(ComplexOperation cmd) {\n        return ProcessComplex(cmd);\n    }\n}\n// Conditional logging\n[Logged(\n    OnlyOnError = true,\n    IncludeStackTrace = true,\n    MaxDepth = 3  // How deep to serialize objects\n)]\npublic class ErrorFocusedHandler : IHandle<RiskyOperation> {\n    public Result Handle(RiskyOperation cmd) {\n        // Only logs when exception occurs\n        return PerformRiskyOperation(cmd);\n    }\n}\n// Custom log enrichment\n[Logged(Enricher = nameof(EnrichLog))]\npublic class EnrichedHandler : IHandle<BusinessOperation> {\n    public Result Handle(BusinessOperation cmd) {\n        return Process(cmd);\n    }\n    private void EnrichLog(LogContext context, BusinessOperation cmd) {\n        context AddProperty(\"TenantId\", cmd TenantId);\n        context AddProperty(\"Region\", GetRegion(cmd));\n        context AddProperty(\"Priority\", cmd Priority);\n    }\n}\n`\nValidation Aspect\n`csharp{\ntitle: \"Validation Aspect\"\ndescription: \"Automatic input validation using FluentValidation or DataAnnotations\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"BEGINNER\"\ntags: [\"Validation\", \"Input Validation\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"ValidationAspect cs\"\nshowLineNumbers: true\nhighlightLines: [1, 14, 27]\nusingStatements: [\"Whizbang\", \"System\", \"System ComponentModel",
        "startIndex": 2880,
        "preview": "// ONLY business logic - clean and focused var order = CreateOrder(cmd); return new OrderCreated(order Id, order Total); } } ` Built-in Aspects Loggin..."
      },
      {
        "id": "usage-patterns/aspect-oriented-handlers-chunk-2",
        "text": "GetRegion(cmd)); context AddProperty(\"Priority\", cmd Priority); } } ` Validation Aspect `csharp{ title: \"Validation Aspect\" description: \"Automatic input validation using FluentValidation or DataAnnotations\" framework: \"NET8\" category: \"Aspects\" difficulty: \"BEGINNER\" tags: [\"Validation\", \"Input Validation\", \"Aspects\"] nugetPackages: [\"Whizbang Core\"] filename: \"ValidationAspect cs\" showLineNumbers: true highlightLines: [1, 14, 27] usingStatements: [\"Whizbang\", \"System\", \"System ComponentModel DataAnnotations\"]\n}\n// Automatic validation with conventions\n[Validated]\npublic class CreateUserHandler : IHandle<CreateUser> {\n    public UserCreated Handle(CreateUser cmd) {\n        // Validation happens before this executes\n        // Looks for CreateUserValidator automatically\n        return new UserCreated(cmd Email);\n    }\n}\n// Explicit validator specification\n[Validated(Validator = typeof(CustomOrderValidator))]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        return new OrderCreated(cmd OrderId);\n    }\n}\n// Inline validation rules\n[Validated(\n    Rules = new[] {\n        \"Amount > 0\",\n        \"Currency = null\",\n        \"CustomerId = Guid Empty\"\n    }\n)]\npublic class PaymentHandler : IHandle<ProcessPayment> {\n    public PaymentProcessed Handle(ProcessPayment cmd) {\n        return new PaymentProcessed(cmd Amount);\n    }\n}\n// Combining with FluentValidation\npublic class CreateOrderValidator : AbstractValidator<CreateOrder> {\n    public CreateOrderValidator() {\n        RuleFor(x => x CustomerId) NotEmpty();\n        RuleFor(x => x Items) NotEmpty() Must(items => items All(i => i Quantity > 0));\n        RuleFor(x => x ShippingAddress) NotEmpty() MaximumLength(500);\n    }\n}\n[Validated] // Automatically uses CreateOrderValidator\npublic class ValidatedOrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nCaching Aspect\n`csharp{\ntitle: \"Caching Aspect\"\ndescription: \"Automatic result caching with flexible cache keys\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Caching\", \"Performance\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"CachingAspect cs\"\nshowLineNumbers: true\nhighlightLines: [1, 12, 24, 36]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Simple caching with duration\n[Cached(Duration = \"5m\")]\npublic class ProductHandler : IHandle<GetProduct> {\n    public Product Handle(GetProduct query) {\n        // Result cached for 5 minutes\n        // Cache key auto-generated from query properties\n        return database GetProduct(query",
        "startIndex": 4907,
        "preview": "GetRegion(cmd)); context AddProperty(\"Priority\", cmd Priority); } } ` Validation Aspect `csharp{ title: \"Validation Aspect\" description: \"Automatic in..."
      },
      {
        "id": "usage-patterns/aspect-oriented-handlers-chunk-3",
        "text": "Core\"] filename: \"CachingAspect cs\" showLineNumbers: true highlightLines: [1, 12, 24, 36] usingStatements: [\"Whizbang\", \"System\"] } // Simple caching with duration [Cached(Duration = \"5m\")] public class ProductHandler : IHandle<GetProduct> { public Product Handle(GetProduct query) { // Result cached for 5 minutes // Cache key auto-generated from query properties return database GetProduct(query ProductId);\n    }\n}\n// Custom cache key generation\n[Cached(\n    Duration = \"10m\",\n    KeyGenerator = nameof(GenerateCacheKey)\n)]\npublic class CustomKeyHandler : IHandle<ComplexQuery> {\n    public QueryResult Handle(ComplexQuery query) {\n        return ExecuteComplexQuery(query);\n    }\n    private string GenerateCacheKey(ComplexQuery query) {\n        return $\"complex:{query TenantId}:{query FilterHash}\";\n    }\n}\n// Sliding expiration cache\n[Cached(\n    Duration = \"1h\",\n    Mode = \"sliding\",  // Resets on each access\n    CacheNullResults = false\n)]\npublic class SlidingCacheHandler : IHandle<GetUserPreferences> {\n    public UserPreferences Handle(GetUserPreferences query) {\n        return userService GetPreferences(query UserId);\n    }\n}\n// Conditional caching\n[Cached(\n    Duration = \"30m\",\n    Condition = nameof(ShouldCache),\n    InvalidateOn = new[] { typeof(UserUpdated), typeof(UserDeleted) }\n)]\npublic class ConditionalCacheHandler : IHandle<GetUserProfile> {\n    public UserProfile Handle(GetUserProfile query) {\n        return userService GetProfile(query UserId);\n    }\n    private bool ShouldCache(GetUserProfile query) {\n        // Only cache for non-admin users\n        return query IsAdmin;\n    }\n}\n// Distributed cache\n[Cached(\n    Duration = \"1h\",\n    CacheType = \"distributed\",  // Redis, Memcached, etc SerializationFormat = \"msgpack\"\n)]\npublic class DistributedCacheHandler : IHandle<GetOrderHistory> {\n    public OrderHistory Handle(GetOrderHistory query) {\n        return orderService GetHistory(query CustomerId);\n    }\n}\n`\nAuthorization Aspect\n`csharp{\ntitle: \"Authorization Aspect\"\ndescription: \"Declarative security with fine-grained access control\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Authorization\", \"Security\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"AuthorizationAspect",
        "startIndex": 7083,
        "preview": "Core\"] filename: \"CachingAspect cs\" showLineNumbers: true highlightLines: [1, 12, 24, 36] usingStatements: [\"Whizbang\", \"System\"] } // Simple caching ..."
      },
      {
        "id": "usage-patterns/aspect-oriented-handlers-chunk-4",
        "text": "SerializationFormat = \"msgpack\" )] public class DistributedCacheHandler : IHandle<GetOrderHistory> { public OrderHistory Handle(GetOrderHistory query) { return orderService GetHistory(query CustomerId); } } ` Authorization Aspect `csharp{ title: \"Authorization Aspect\" description: \"Declarative security with fine-grained access control\" framework: \"NET8\" category: \"Aspects\" difficulty: \"INTERMEDIATE\" tags: [\"Authorization\", \"Security\", \"Aspects\"] nugetPackages: [\"Whizbang Core\"] filename: \"AuthorizationAspect cs\"\nshowLineNumbers: true\nhighlightLines: [1, 10, 19, 30]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Role-based authorization\n[Authorized(Roles = \"Admin,Manager\")]\npublic class AdminHandler : IHandle<AdminCommand> {\n    public Result Handle(AdminCommand cmd) {\n        // Only admins and managers can execute\n        return PerformAdminAction(cmd);\n    }\n}\n// Policy-based authorization\n[Authorized(Policy = \"CanEditOrders\")]\npublic class OrderEditHandler : IHandle<EditOrder> {\n    public OrderUpdated Handle(EditOrder cmd) {\n        // Policy evaluated before execution\n        return UpdateOrder(cmd);\n    }\n}\n// Resource-based authorization\n[Authorized(Resource = nameof(GetOrderResource))]\npublic class OrderAccessHandler : IHandle<GetOrder> {\n    public Order Handle(GetOrder query) {\n        return orderService Get(query OrderId);\n    }\n    private object GetOrderResource(GetOrder query) {\n        return new { Type = \"Order\", Id = query OrderId };\n    }\n}\n// Custom authorization logic\n[Authorized(Authorizer = typeof(CustomOrderAuthorizer))]\npublic class CustomAuthHandler : IHandle<SensitiveOperation> {\n    public Result Handle(SensitiveOperation cmd) {\n        return ExecuteSensitive(cmd);\n    }\n}\npublic class CustomOrderAuthorizer : IAuthorizer<SensitiveOperation> {\n    public Task<bool> AuthorizeAsync(SensitiveOperation cmd, IUser user) {\n        // Custom authorization logic\n        if (user IsInRole(\"Admin\")) return Task FromResult(true);\n        if (cmd OwnerId == user Id) return Task FromResult(true);\n        if (user HasPermission(\"sensitive execute\")) return Task FromResult(true);\n        return Task FromResult(false);\n    }\n}\n`\nTransactional Aspect\n`csharp{\ntitle: \"Transactional Aspect\"\ndescription: \"Automatic transaction management with various isolation levels\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Transactions\", \"Database\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"TransactionalAspect cs\"\nshowLineNumbers: true\nhighlightLines: [1, 11, 22, 35]\nusingStatements: [\"Whizbang\", \"System\", \"System Data\"]\n}\n// Simple transaction\n[Transactional]\npublic class TransferHandler : IHandle<TransferMoney> {\n    public TransferCompleted Handle(TransferMoney cmd, IAccountService accounts) {\n        // Entire operation wrapped in transaction\n        accounts Debit(cmd FromAccount, cmd Amount);\n        accounts Credit(cmd ToAccount, cmd",
        "startIndex": 8947,
        "preview": "SerializationFormat = \"msgpack\" )] public class DistributedCacheHandler : IHandle<GetOrderHistory> { public OrderHistory Handle(GetOrderHistory query)..."
      },
      {
        "id": "usage-patterns/aspect-oriented-handlers-chunk-5",
        "text": "[\"Whizbang Core\"] filename: \"TransactionalAspect cs\" showLineNumbers: true highlightLines: [1, 11, 22, 35] usingStatements: [\"Whizbang\", \"System\", \"System Data\"] } // Simple transaction [Transactional] public class TransferHandler : IHandle<TransferMoney> { public TransferCompleted Handle(TransferMoney cmd, IAccountService accounts) { // Entire operation wrapped in transaction accounts Debit(cmd FromAccount, cmd Amount); accounts Credit(cmd ToAccount, cmd Amount);\n        return new TransferCompleted(cmd TransferId);\n    }\n}\n// Transaction with specific isolation level\n[Transactional(\n    IsolationLevel = IsolationLevel ReadCommitted,\n    Timeout = \"30s\"\n)]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Executes with ReadCommitted isolation\n        return CreateOrderWithInventory(cmd);\n    }\n}\n// Nested transaction support\n[Transactional(AllowNested = true)]\npublic class ParentHandler : IHandle<ParentCommand> {\n    public Result Handle(ParentCommand cmd, IWhizbang whizbang) {\n        // Start transaction\n        var result1 = ProcessFirst(cmd);\n        // This creates a nested transaction\n        var result2 = whizbang Send(new ChildCommand());\n        return CombineResults(result1, result2);\n    }\n}\n// Distributed transaction\n[Transactional(\n    Mode = \"distributed\",\n    Coordinator = \"saga\"\n)]\npublic class DistributedHandler : IHandle<CrossServiceCommand> {\n    public async Task<Result> Handle(CrossServiceCommand cmd) {\n        // Coordinates transaction across services\n        await orderService CreateOrder(cmd Order);\n        await inventoryService ReserveStock(cmd Items);\n        await paymentService ProcessPayment(cmd Payment);\n        return Result Success();\n    }\n}\n`\nPerformance Aspects\n`csharp{\ntitle: \"Performance Aspects\"\ndescription: \"Timing, metrics, and performance monitoring\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Performance\", \"Metrics\", \"Monitoring\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"PerformanceAspects",
        "startIndex": 11362,
        "preview": "[\"Whizbang Core\"] filename: \"TransactionalAspect cs\" showLineNumbers: true highlightLines: [1, 11, 22, 35] usingStatements: [\"Whizbang\", \"System\", \"Sy..."
      },
      {
        "id": "usage-patterns/aspect-oriented-handlers-chunk-6",
        "text": "// Coordinates transaction across services await orderService CreateOrder(cmd Order); await inventoryService ReserveStock(cmd Items); await paymentService ProcessPayment(cmd Payment); return Result Success(); } } ` Performance Aspects `csharp{ title: \"Performance Aspects\" description: \"Timing, metrics, and performance monitoring\" framework: \"NET8\" category: \"Aspects\" difficulty: \"INTERMEDIATE\" tags: [\"Performance\", \"Metrics\", \"Monitoring\"] nugetPackages: [\"Whizbang Core\"] filename: \"PerformanceAspects cs\"\nshowLineNumbers: true\nhighlightLines: [1, 2, 3]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Comprehensive performance monitoring\n[Timed]\n[Metered(\"orders\")]\n[Traced]\npublic class MonitoredHandler : IHandle<ProcessOrder> {\n    public OrderProcessed Handle(ProcessOrder cmd) {\n        // Automatically tracks:\n        // - Execution duration (Timed)\n        // - Success/failure counts (Metered)\n        // - Distributed trace span (Traced)\n        return ProcessOrder(cmd);\n    }\n}\n// Detailed timing with percentiles\n[Timed(\n    RecordPercentiles = new[] { 50, 90, 95, 99 },\n    PublishHistogram = true,\n    BucketSize = \"100ms\"\n)]\npublic class DetailedTimingHandler : IHandle<ComplexCalculation> {\n    public CalculationResult Handle(ComplexCalculation cmd) {\n        return PerformCalculation(cmd);\n    }\n}\n// Custom metrics\n[Metered(\n    Namespace = \"business orders\",\n    RecordErrors = true,\n    RecordDuration = true,\n    Tags = new[] { \"region\", \"customer_type\" }\n)]\npublic class MeteredHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Publishes metrics:\n        // - business orders count\n        // - business orders errors\n        // - business orders duration\n        // Tagged with region and customer_type\n        return CreateOrder(cmd);\n    }\n}\n`\nCustom Aspects\nCreating Custom Aspects\n`csharp{\ntitle: \"Custom Aspect Implementation\"\ndescription: \"Build your own aspects for specific concerns\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"ADVANCED\"\ntags: [\"Custom Aspects\", \"Extensibility\", \"Source Generators\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"CustomAspects cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Define custom aspect attribute\n[AttributeUsage(AttributeTargets Class | AttributeTargets",
        "startIndex": 12964,
        "preview": "// Coordinates transaction across services await orderService CreateOrder(cmd Order); await inventoryService ReserveStock(cmd Items); await paymentSer..."
      },
      {
        "id": "usage-patterns/aspect-oriented-handlers-chunk-7",
        "text": "Aspects Creating Custom Aspects `csharp{ title: \"Custom Aspect Implementation\" description: \"Build your own aspects for specific concerns\" framework: \"NET8\" category: \"Aspects\" difficulty: \"ADVANCED\" tags: [\"Custom Aspects\", \"Extensibility\", \"Source Generators\"] nugetPackages: [\"Whizbang Core\"] filename: \"CustomAspects cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"System\"] } // Define custom aspect attribute [AttributeUsage(AttributeTargets Class | AttributeTargets Method)]\npublic class AuditedAttribute : AspectAttribute {\n    public bool IncludeResult { get; set; } = false;\n    public string AuditTable { get; set; } = \"AuditLog\";\n}\n// Source generator creates this implementation\n[SourceGenerated]\ninternal class AuditedAspect : IAspect {\n    private readonly IAuditService _auditService;\n    public async Task<T> InterceptAsync<T>(\n        AspectContext context,\n        Func<Task<T>> next) {\n        // Before execution\n        var auditEntry = new AuditEntry {\n            UserId = context User Id,\n            Operation = context HandlerName,\n            Input = SerializeInput(context Message),\n            Timestamp = DateTime UtcNow\n        };\n        try {\n            // Execute handler\n            var result = await next();\n            // After execution\n            auditEntry Success = true;\n            if (context Attribute IncludeResult) {\n                auditEntry Output = SerializeOutput(result);\n            }\n            return result;\n        }\n        catch (Exception ex) {\n            auditEntry Success = false;\n            auditEntry Error = ex Message;\n            throw;\n        }\n        finally {\n            // Always audit\n            await _auditService LogAsync(\n                context Attribute AuditTable, \n                auditEntry\n            );\n        }\n    }\n}\n// Use custom aspect\n[Audited(IncludeResult = true, AuditTable = \"OrderAudits\")]\npublic class AuditedOrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nAspect Composition\n`csharp{\ntitle: \"Composing Multiple Aspects\"\ndescription: \"Combining aspects for comprehensive behavior\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"ADVANCED\"\ntags: [\"Aspect Composition\", \"Ordering\", \"Dependencies\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"AspectComposition cs\"\nshowLineNumbers: true\nhighlightLines: [1, 2, 3, 4, 5, 6]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Aspects execute in order of declaration\n[Logged]                    // 1 Outermost - logs everything\n[Timed]                     // 2 Times the entire operation\n[Authorized]                // 3 Check authorization\n[Validated]                 // 4 Validate inputs\n[Transactional]            // 5",
        "startIndex": 14764,
        "preview": "Aspects Creating Custom Aspects `csharp{ title: \"Custom Aspect Implementation\" description: \"Build your own aspects for specific concerns\" framework: ..."
      },
      {
        "id": "usage-patterns/aspect-oriented-handlers-chunk-8",
        "text": "filename: \"AspectComposition cs\" showLineNumbers: true highlightLines: [1, 2, 3, 4, 5, 6] usingStatements: [\"Whizbang\", \"System\"] } // Aspects execute in order of declaration [Logged] // 1 Outermost - logs everything [Timed] // 2 Times the entire operation [Authorized] // 3 Check authorization [Validated] // 4 Validate inputs [Transactional] // 5 Start transaction\n[Cached(Duration = \"10m\")]  // 6 Innermost - check cache first\npublic class FullyAspectedHandler : IHandle<ComplexQuery> {\n    public QueryResult Handle(ComplexQuery query) {\n        // Execution flow:\n        // → Logging starts\n        //   → Timer starts\n        //     → Authorization check\n        //       → Input validation\n        //         → Transaction begins\n        //           → Cache check (hit = early return)\n        //             → Handler executes\n        //           ← Cache stores result\n        //         ← Transaction commits\n        //       ← Validation complete\n        //     ← Authorization complete\n        //   ← Timer stops\n        // ← Logging ends\n        return ExecuteComplexQuery(query);\n    }\n}\n// Conditional aspect composition\n[ConditionalAspect(typeof(CachedAttribute), Condition = nameof(IsReadOperation))]\n[ConditionalAspect(typeof(TransactionalAttribute), Condition = nameof(IsWriteOperation))]\npublic class AdaptiveHandler : IHandle<DynamicCommand> {\n    public Result Handle(DynamicCommand cmd) {\n        return ProcessDynamic(cmd);\n    }\n    private bool IsReadOperation(DynamicCommand cmd) => cmd IsQuery;\n    private bool IsWriteOperation(DynamicCommand cmd) => cmd IsQuery;\n}\n// Aspect dependencies\n[RequiresAspect(typeof(LoggedAttribute))]  // Must have Logged\npublic class DependentAuditAttribute : AspectAttribute { }\n[Logged]\n[DependentAudit]  // OK - Logged is present\npublic class ValidHandler : IHandle<Command> { }\n// [DependentAudit]  // Compile error - Missing required Logged aspect\npublic class InvalidHandler : IHandle<Command> { }\n`\nTesting with Aspects\n`csharp{\ntitle: \"Testing Aspect Behavior\"\ndescription: \"Verify aspects work correctly in isolation and composition\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Testing\", \"Aspects\", \"Unit Tests\"]\nnugetPackages: [\"Whizbang Core\", \"xUnit\"]\nfilename: \"AspectTests cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang Testing\", \"Xunit\"]\n}\n[Fact]\npublic async Task CacheAspect_CachesResult() {\n    // Arrange\n    var test = await Whizbang Test<ProductHandler>() WithAspect<CachedAttribute>() Given(new GetProduct { ProductId = \"123\" });\n    // Act - First call\n    var result1 = await test",
        "startIndex": 17064,
        "preview": "filename: \"AspectComposition cs\" showLineNumbers: true highlightLines: [1, 2, 3, 4, 5, 6] usingStatements: [\"Whizbang\", \"System\"] } // Aspects execute..."
      },
      {
        "id": "usage-patterns/aspect-oriented-handlers-chunk-9",
        "text": "[\"Testing\", \"Aspects\", \"Unit Tests\"] nugetPackages: [\"Whizbang Core\", \"xUnit\"] filename: \"AspectTests cs\" showLineNumbers: true usingStatements: [\"Whizbang Testing\", \"Xunit\"] } [Fact] public async Task CacheAspect_CachesResult() { // Arrange var test = await Whizbang Test<ProductHandler>() WithAspect<CachedAttribute>() Given(new GetProduct { ProductId = \"123\" }); // Act - First call var result1 = await test WhenHandled();\n    // Act - Second call\n    var result2 = await test WhenHandled();\n    // Assert\n    Assert Same(result1, result2);  // Same instance\n    test Aspect<CachedAttribute>() Should() HaveHitCache() OnSecondCall();\n    test Handler Should() HaveBeenCalledOnce();  // Not twice\n}\n[Fact]\npublic async Task ValidationAspect_RejectsInvalidInput() {\n    // Arrange\n    var test = await Whizbang Test<CreateUserHandler>() WithAspect<ValidatedAttribute>() Given(new CreateUser { Email = \"invalid\" });\n    // Act & Assert\n    await test WhenHandled() Should() FailValidation() WithError(\"Email\", \"Invalid email format\");\n    test Handler Should() NotHaveBeenCalled();\n}\n[Fact]\npublic async Task TransactionalAspect_RollsBackOnError() {\n    // Arrange\n    var test = await Whizbang Test<TransferHandler>() WithAspect<TransactionalAttribute>() WithDatabase(db) Given(new TransferMoney { Amount = 100 });\n    // Act - Force error\n    test Handler ThrowsOn(2);  // Throw on second operation\n    // Assert\n    await test WhenHandled() Should() Throw<Exception>();\n    test Database Should() HaveNoChanges();  // Rolled back\n    test Aspect<TransactionalAttribute>() Should() HaveRolledBack();\n}\n// Test aspect ordering\n[Fact]\npublic async Task Aspects_ExecuteInCorrectOrder() {\n    // Arrange\n    var test = await Whizbang Test<FullyAspectedHandler>() WithAllAspects() RecordExecutionOrder();\n    // Act\n    await test WhenHandled(new ComplexQuery());\n    // Assert\n    test ExecutionOrder Should() BeInOrder(\n        \"LoggedAspect Before\",\n        \"TimedAspect Before\",\n        \"AuthorizedAspect Before\",\n        \"ValidatedAspect Before\",\n        \"TransactionalAspect Before\",\n        \"CachedAspect Before\",\n        \"Handler Execute\",\n        \"CachedAspect After\",\n        \"TransactionalAspect After\",\n        \"ValidatedAspect After\",\n        \"AuthorizedAspect After\",\n        \"TimedAspect After\",\n        \"LoggedAspect After\"\n    );\n}\n`\nPerformance Considerations\nSource Generation\n`csharp{\ntitle: \"Zero-Overhead Aspects via Source Generation\"\ndescription: \"How source generators eliminate aspect overhead\"\nframework: \"NET8\"\ncategory: \"Performance\"\ndifficulty: \"ADVANCED\"\ntags: [\"Source Generators\", \"Performance\", \"Compilation\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"SourceGeneration",
        "startIndex": 19337,
        "preview": "[\"Testing\", \"Aspects\", \"Unit Tests\"] nugetPackages: [\"Whizbang Core\", \"xUnit\"] filename: \"AspectTests cs\" showLineNumbers: true usingStatements: [\"Whi..."
      },
      {
        "id": "usage-patterns/aspect-oriented-handlers-chunk-10",
        "text": "Execute\", \"CachedAspect After\", \"TransactionalAspect After\", \"ValidatedAspect After\", \"AuthorizedAspect After\", \"TimedAspect After\", \"LoggedAspect After\" ); } ` Performance Considerations Source Generation `csharp{ title: \"Zero-Overhead Aspects via Source Generation\" description: \"How source generators eliminate aspect overhead\" framework: \"NET8\" category: \"Performance\" difficulty: \"ADVANCED\" tags: [\"Source Generators\", \"Performance\", \"Compilation\"] nugetPackages: [\"Whizbang Core\"] filename: \"SourceGeneration cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// What you write\n[Logged]\n[Cached(Duration = \"5m\")]\npublic class UserHandler : IHandle<GetUser> {\n    public User Handle(GetUser query) {\n        return database GetUser(query UserId);\n    }\n}\n// What source generator produces\n[SourceGenerated]\ninternal class UserHandler_Generated : IHandle<GetUser> {\n    private readonly UserHandler _inner;\n    private readonly ILogger _logger;\n    private readonly ICache _cache;\n    public User Handle(GetUser query) {\n        // Inlined logging\n        _logger LogInformation(\"Executing UserHandler with {UserId}\", query UserId);\n        var stopwatch = Stopwatch StartNew();\n        try {\n            // Inlined caching\n            var cacheKey = $\"user:{query UserId}\";\n            if (_cache TryGet<User>(cacheKey, out var cached)) {\n                _logger LogDebug(\"Cache hit for {Key}\", cacheKey);\n                return cached;\n            }\n            // Call actual handler\n            var result = _inner Handle(query);\n            // Store in cache\n            _cache Set(cacheKey, result, TimeSpan FromMinutes(5));\n            _logger LogInformation(\"UserHandler completed in {Duration}ms\", \n                stopwatch ElapsedMilliseconds);\n            return result;\n        }\n        catch (Exception ex) {\n            _logger LogError(ex, \"UserHandler failed\");\n            throw;\n        }\n    }\n}\n`\nBest Practices\nDo's\n✅ Use aspects for cross-cutting concerns\n`csharp\n[Logged]\n[Validated]\n[Cached]\n`\n✅ Keep handlers focused on business logic\n`csharp\npublic OrderCreated Handle(CreateOrder cmd) {\n    // Only business logic, no infrastructure\n    return CreateOrder(cmd);\n}\n`\n✅ Order aspects correctly\n`csharp\n[Logged]        // Outermost - see everything\n[Authorized]    // Check auth before validation\n[Validated]     // Validate before execution\n[Transactional] // Wrap actual work\n`\n✅ Test aspects in isolation\n`csharp\nawait Test<Handler>() WithAspect<CachedAttribute>() VerifyBehavior();\n`\nDon'ts\n❌ Don't mix aspects with manual concerns\n`csharp\n[Logged]\npublic Result Handle(Command cmd) {\n    _logger",
        "startIndex": 21745,
        "preview": "Execute\", \"CachedAspect After\", \"TransactionalAspect After\", \"ValidatedAspect After\", \"AuthorizedAspect After\", \"TimedAspect After\", \"LoggedAspect Aft..."
      },
      {
        "id": "usage-patterns/aspect-oriented-handlers-chunk-11",
        "text": "[Logged] // Outermost - see everything [Authorized] // Check auth before validation [Validated] // Validate before execution [Transactional] // Wrap actual work ` ✅ Test aspects in isolation `csharp await Test<Handler>() WithAspect<CachedAttribute>() VerifyBehavior(); ` Don'ts ❌ Don't mix aspects with manual concerns `csharp [Logged] public Result Handle(Command cmd) { _logger Log(\"Starting\");  // Don't - redundant with aspect\n}\n`\n❌ Don't create aspects for business logic\n`csharp\n[CalculateTax]  // Bad - business logic not cross-cutting\n`\n❌ Don't ignore aspect overhead in hot paths\n`csharp\n[Logged(LogInputs = true)]  // Careful with large objects\npublic Result Handle(LargeDataQuery query)\n`\nReal-World Example\n`csharp{\ntitle: \"Complete E-Commerce Handler with Aspects\"\ndescription: \"Production-ready handler showcasing multiple aspects\"\nframework: \"NET8\"\ncategory: \"Real World\"\ndifficulty: \"ADVANCED\"\ntags: [\"E-Commerce\", \"Production\", \"Complete Example\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"ECommerceHandler cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Order processing with comprehensive aspects\n[Logged(Level = LogLevel Information)]\n[Timed(PublishHistogram = true)]\n[Metered(\"orders checkout\")]\n[Authorized(Policy = \"CanCreateOrders\")]\n[Validated]\n[RateLimited(Permits = 100, Window = \"1m\")]\n[Transactional(IsolationLevel = IsolationLevel ReadCommitted)]\n[Retry(3, Backoff = \"exponential\")]\n[CircuitBreaker(Threshold = 10, Duration = \"30s\")]\n[Traced(IncludeHeaders = true)]\npublic class CheckoutHandler : IHandle<Checkout> {\n    public CheckoutCompleted Handle(Checkout cmd, \n        IInventoryService inventory,\n        IPaymentService payment,\n        IShippingService shipping) {\n        // Pure business logic - all concerns handled by aspects\n        // Reserve inventory\n        var reservation = inventory Reserve(cmd Items);\n        // Process payment\n        var transaction = payment Charge(\n            cmd PaymentMethod, \n            cmd Total\n        );\n        // Create shipment\n        var shipment = shipping CreateShipment(\n            cmd ShippingAddress,\n            cmd Items\n        );\n        // Return completed checkout\n        return new CheckoutCompleted {\n            OrderId = Guid NewGuid(),\n            ReservationId = reservation Id,\n            TransactionId = transaction Id,\n            ShipmentId = shipment Id,\n            EstimatedDelivery = shipment",
        "startIndex": 23888,
        "preview": "[Logged] // Outermost - see everything [Authorized] // Check auth before validation [Validated] // Validate before execution [Transactional] // Wrap a..."
      },
      {
        "id": "usage-patterns/aspect-oriented-handlers-chunk-12",
        "text": "var transaction = payment Charge( cmd PaymentMethod, cmd Total ); // Create shipment var shipment = shipping CreateShipment( cmd ShippingAddress, cmd Items ); // Return completed checkout return new CheckoutCompleted { OrderId = Guid NewGuid(), ReservationId = reservation Id, TransactionId = transaction Id, ShipmentId = shipment Id, EstimatedDelivery = shipment EstimatedDelivery\n        };\n    }\n}\n// Query handler with read-optimized aspects\n[Logged(OnlyOnError = true)]\n[Cached(Duration = \"15m\", Mode = \"sliding\")]\n[Compressed]\n[Traced]\npublic class OrderHistoryHandler : IHandle<GetOrderHistory> {\n    public OrderHistory Handle(GetOrderHistory query) {\n        // Cached and compressed for performance\n        return orderService GetHistory(\n            query CustomerId,\n            query StartDate,\n            query EndDate\n        );\n    }\n}\n`\nNext Steps\nExplore Progressive Enhancement for scaling patterns\nLearn about Policy Composition for resilience\nReview Testing Strategies for aspect testing\nSee Source Generators for implementation details",
        "startIndex": 25944,
        "preview": "var transaction = payment Charge( cmd PaymentMethod, cmd Total ); // Create shipment var shipment = shipping CreateShipment( cmd ShippingAddress, cmd ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "usage-patterns/cqrs-implementation",
    "title": "CQRS Implementation",
    "category": "Usage Patterns",
    "url": "/docs/usage-patterns/cqrs-implementation",
    "chunks": [
      {
        "id": "usage-patterns/cqrs-implementation-chunk-0",
        "text": "CQRS Implementation\nOverview\nCommand Query Responsibility Segregation (CQRS) is a pattern that uses separate models for reading and writing data Whizbang provides first-class support for CQRS, allowing you to optimize reads and writes independently while maintaining consistency through event-driven projections What is CQRS CQRS separates your application into two distinct paths:\nCommand Side: Handles writes, enforces business rules, generates events\nQuery Side: Handles reads from optimized, denormalized read models\nBenefits of CQRS\nPerformance: Optimize reads and writes independently\nScalability: Scale read and write sides separately\nFlexibility: Different storage technologies for different needs\nSimplicity: Simpler models focused on specific tasks\nEvolution: Change read models without affecting writes\nArchitecture Diagram\n`mermaid\ngraph TB\n    subgraph \"Write Side\"\n        CMD[Commands] --> CH[Command Handlers]\n        CH --> AGG[Aggregates]\n        AGG --> ES[(Event Store)]\n    end\n    subgraph \"Read Side\"\n        ES --> PROJ[Projections]\n        PROJ --> RM1[(Order List)]\n        PROJ --> RM2[(Customer View)]\n        PROJ --> RM3[(Analytics)]\n        Q[Queries] --> QH[Query Handlers]\n        QH --> RM1\n        QH --> RM2\n        QH --> RM3\n    end\n    style ES fill:#0066cc,color:#fff\n    style PROJ fill:#28a745,color:#fff\n`\nCore Components\nRequired Packages\n`xml\n<PackageReference Include=\"Whizbang Core\" Version=\"1 0 0\" />\n<PackageReference Include=\"Whizbang EventSourcing\" Version=\"1 0 0\" />\n<PackageReference Include=\"Whizbang Projections\" Version=\"1 0 0\" />\n`\nKey Concepts\nWrite Model: Aggregates that enforce business rules\nRead Model: Denormalized views optimized for queries\nProjection: Process that builds read models from events\nEventually Consistent: Read models update asynchronously\nQuery Handler: Returns data from read models\nStep-by-Step Implementation\nStep 1: Define Read Models\n`csharp{\ntitle: \"Read Model Definitions\"\ndescription: \"Create denormalized read models optimized for specific queries\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Read Models\", \"Projections\", \"Query Models\"]\nnugetPackages: [\"Whizbang Projections\"]\nfilename: \"OrderReadModels cs\"\nshowLineNumbers: true\nhighlightLines: [9, 25, 41]\nusingStatements: [\"Whizbang Projections\", \"System\", \"System Collections Generic\"]\n}\nusing Whizbang Projections;\nusing System;\nusing System Collections Generic;\nnamespace MyApp Orders",
        "startIndex": 0,
        "preview": "CQRS Implementation\nOverview\nCommand Query Responsibility Segregation (CQRS) is a pattern that uses separate models for reading and writing data Whizb..."
      },
      {
        "id": "usage-patterns/cqrs-implementation-chunk-1",
        "text": "read models optimized for specific queries\" framework: \"NET8\" category: \"CQRS\" difficulty: \"INTERMEDIATE\" tags: [\"Read Models\", \"Projections\", \"Query Models\"] nugetPackages: [\"Whizbang Projections\"] filename: \"OrderReadModels cs\" showLineNumbers: true highlightLines: [9, 25, 41] usingStatements: [\"Whizbang Projections\", \"System\", \"System Collections Generic\"] } using Whizbang Projections; using System; using System Collections Generic; namespace MyApp Orders ReadModels;\n// Read model for order list/search\n[ReadModel(\"OrderList\")]\npublic class OrderListItem {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    public string CustomerName { get; set; }\n    public decimal TotalAmount { get; set; }\n    public string Status { get; set; }\n    public DateTime CreatedAt { get; set; }\n    public DateTime",
        "startIndex": 2461,
        "preview": "read models optimized for specific queries\" framework: \"NET8\" category: \"CQRS\" difficulty: \"INTERMEDIATE\" tags: [\"Read Models\", \"Projections\", \"Query ..."
      },
      {
        "id": "usage-patterns/cqrs-implementation-chunk-2",
        "text": "list/search [ReadModel(\"OrderList\")] public class OrderListItem { public Guid OrderId { get; set; } public Guid CustomerId { get; set; } public string CustomerName { get; set; } public decimal TotalAmount { get; set; } public string Status { get; set; } public DateTime CreatedAt { get; set; } public DateTime ShippedAt { get; set; }\n    // Denormalized data for fast queries\n    public int ItemCount { get; set; }\n    public string FirstItemName { get; set; }\n    public bool IsHighValue { get; set; } // TotalAmount > 1000\n}\n// Read model for customer order history\n[ReadModel(\"CustomerOrders\")]\npublic class CustomerOrderSummary {\n    public Guid CustomerId { get; set; }\n    public string CustomerName { get; set; }\n    public int TotalOrders { get; set; }\n    public int CompletedOrders { get; set; }\n    public int PendingOrders { get; set; }\n    public decimal LifetimeValue { get; set; }\n    public DateTime LastOrderDate { get; set; }\n    public List<RecentOrder> RecentOrders { get; set; } = new();\n}\npublic class RecentOrder {\n    public Guid OrderId { get; set; }\n    public decimal Amount { get; set; }\n    public string Status { get; set; }\n    public DateTime Date { get; set; }\n}\n// Read model for order details\n[ReadModel(\"OrderDetails\")]\npublic class OrderDetailsView {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    // Customer info (denormalized)\n    public string CustomerName { get; set; }\n    public string CustomerEmail { get; set; }\n    public string CustomerPhone { get; set; }\n    // Order info\n    public List<OrderLineView> Lines { get; set; } = new();\n    public decimal SubTotal { get; set; }\n    public decimal TaxAmount { get; set; }\n    public decimal ShippingCost { get; set; }\n    public decimal TotalAmount { get; set; }\n    // Shipping info\n    public string ShippingAddress { get; set; }\n    public string TrackingNumber { get; set; }\n    public string Carrier { get; set; }\n    // Status and dates\n    public string Status { get; set; }\n    public DateTime CreatedAt { get; set; }\n    public DateTime",
        "startIndex": 2836,
        "preview": "list/search [ReadModel(\"OrderList\")] public class OrderListItem { public Guid OrderId { get; set; } public Guid CustomerId { get; set; } public string..."
      },
      {
        "id": "usage-patterns/cqrs-implementation-chunk-3",
        "text": "decimal TotalAmount { get; set; } // Shipping info public string ShippingAddress { get; set; } public string TrackingNumber { get; set; } public string Carrier { get; set; } // Status and dates public string Status { get; set; } public DateTime CreatedAt { get; set; } public DateTime ShippedAt { get; set; }\n    public DateTime DeliveredAt { get; set; }\n    // Audit trail\n    public List<OrderEvent> EventHistory { get; set; } = new();\n}\npublic class OrderLineView {\n    public string ProductId { get; set; }\n    public string ProductName { get; set; }\n    public string ProductImageUrl { get; set; } // Enriched data\n    public int Quantity { get; set; }\n    public decimal UnitPrice { get; set; }\n    public decimal LineTotal { get; set; }\n}\npublic class OrderEvent {\n    public string EventType { get; set; }\n    public DateTime OccurredAt { get; set; }\n    public string Description { get; set; }\n}\n`\nStep 2: Create Projections\n`csharp{\ntitle: \"Projection Implementation\"\ndescription: \"Build projections that update read models from events\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Event Handlers\", \"Read Model Updates\"]\nnugetPackages: [\"Whizbang Projections\"]\nfilename: \"OrderProjections cs\"\nshowLineNumbers: true\nhighlightLines: [15, 35, 55, 75]\nusingStatements: [\"Whizbang Projections\", \"System\", \"System Threading Tasks\"]\n}\nusing Whizbang Projections;\nusing System;\nusing System Linq;\nusing System Threading;\nusing System Threading Tasks;\nusing MyApp Orders Events;\nusing MyApp Orders ReadModels;\nnamespace MyApp Orders Projections;\n[Projection(\"OrderListProjection\")]\npublic class OrderListProjection : IProjection {\n    private readonly IReadModelStore<OrderListItem> _store;\n    private readonly ICustomerService _customerService;\n    public OrderListProjection(\n        IReadModelStore<OrderListItem> store,\n        ICustomerService customerService) {\n        _store = store;\n        _customerService = customerService;\n    }\n    [Subscribe]\n    public async Task Handle(\n        OrderCreated @event,\n        EventMetadata metadata,\n        CancellationToken cancellationToken) {\n        // Enrich with customer data\n        var customer = await _customerService GetCustomer(\n            @event CustomerId,\n            cancellationToken\n        );\n        // Create read model\n        var item = new OrderListItem {\n            OrderId = @event",
        "startIndex": 4604,
        "preview": "decimal TotalAmount { get; set; } // Shipping info public string ShippingAddress { get; set; } public string TrackingNumber { get; set; } public strin..."
      },
      {
        "id": "usage-patterns/cqrs-implementation-chunk-4",
        "text": "ICustomerService customerService) { _store = store; _customerService = customerService; } [Subscribe] public async Task Handle( OrderCreated @event, EventMetadata metadata, CancellationToken cancellationToken) { // Enrich with customer data var customer = await _customerService GetCustomer( @event CustomerId, cancellationToken ); // Create read model var item = new OrderListItem { OrderId = @event OrderId,\n            CustomerId = @event CustomerId,\n            CustomerName = customer Name \"Unknown\",\n            TotalAmount = @event TotalAmount,\n            Status = \"Pending\",\n            CreatedAt = @event CreatedAt,\n            ItemCount = @event Items Count,\n            FirstItemName = @event Items FirstOrDefault() ProductName,\n            IsHighValue = @event TotalAmount > 1000\n        };\n        await _store Add(item OrderId, item, cancellationToken);\n    }\n    [Subscribe]\n    public async Task Handle(\n        OrderShipped @event,\n        EventMetadata metadata,\n        CancellationToken cancellationToken) {\n        await _store Update(\n            @event OrderId,\n            item => {\n                item Status = \"Shipped\";\n                item ShippedAt = @event ShippedAt;\n            },\n            cancellationToken\n        );\n    }\n    [Subscribe]\n    public async Task Handle(\n        OrderCancelled @event,\n        EventMetadata metadata,\n        CancellationToken cancellationToken) {\n        await _store Update(\n            @event OrderId,\n            item => item Status = \"Cancelled\",\n            cancellationToken\n        );\n    }\n}\n[Projection(\"CustomerOrdersProjection\")]\npublic class CustomerOrdersProjection : IProjection {\n    private readonly IReadModelStore<CustomerOrderSummary> _store;\n    public CustomerOrdersProjection(IReadModelStore<CustomerOrderSummary> store) {\n        _store = store;\n    }\n    [Subscribe]\n    public async Task Handle(\n        OrderCreated @event,\n        EventMetadata metadata,\n        CancellationToken cancellationToken) {\n        var summary = await _store GetById(@event CustomerId, cancellationToken) new CustomerOrderSummary { \n                CustomerId = @event CustomerId \n            };\n        // Update summary\n        summary TotalOrders++;\n        summary PendingOrders++;\n        summary LifetimeValue += @event TotalAmount;\n        summary LastOrderDate = @event CreatedAt;\n        // Add to recent orders (keep last 10)\n        summary RecentOrders Insert(0, new RecentOrder {\n            OrderId = @event OrderId,\n            Amount = @event TotalAmount,\n            Status = \"Pending\",\n            Date = @event CreatedAt\n        });\n        if (summary RecentOrders Count > 10) {\n            summary RecentOrders RemoveAt(10);\n        }\n        await _store Upsert(\n            summary CustomerId, \n            summary, \n            cancellationToken\n        );\n    }\n    [Subscribe]\n    public async Task Handle(\n        OrderShipped @event,\n        EventMetadata metadata,\n        CancellationToken cancellationToken) {\n        // Update customer summary when order ships\n        await _store Update(\n            @event CustomerId,\n            summary => {\n                summary PendingOrders--;\n                summary",
        "startIndex": 6723,
        "preview": "ICustomerService customerService) { _store = store; _customerService = customerService; } [Subscribe] public async Task Handle( OrderCreated @event, E..."
      },
      {
        "id": "usage-patterns/cqrs-implementation-chunk-5",
        "text": "if (summary RecentOrders Count > 10) { summary RecentOrders RemoveAt(10); } await _store Upsert( summary CustomerId, summary, cancellationToken ); } [Subscribe] public async Task Handle( OrderShipped @event, EventMetadata metadata, CancellationToken cancellationToken) { // Update customer summary when order ships await _store Update( @event CustomerId, summary => { summary PendingOrders--; summary CompletedOrders++;\n                var recentOrder = summary RecentOrders FirstOrDefault(o => o OrderId == @event OrderId);\n                if (recentOrder = null) {\n                    recentOrder Status = \"Shipped\";\n                }\n            },\n            cancellationToken\n        );\n    }\n}\n`\nStep 3: Implement Query Handlers\n`csharp{\ntitle: \"Query Handler Implementation\"\ndescription: \"Query handlers that read from optimized read models\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Query Handlers\", \"Read Operations\", \"Performance\"]\nnugetPackages: [\"Whizbang Projections\"]\nfilename: \"OrderQueryHandlers cs\"\nshowLineNumbers: true\nhighlightLines: [18, 40, 65]\nusingStatements: [\"Whizbang Projections\", \"System\", \"System Linq\", \"System Threading Tasks\"]\n}\nusing Whizbang;\nusing Whizbang Projections;\nusing System;\nusing System Collections Generic;\nusing System Linq;\nusing System Threading;\nusing System Threading Tasks;\nusing MyApp Orders Queries;\nusing MyApp Orders ReadModels;\nnamespace MyApp Orders Handlers;\npublic class GetOrderListHandler : IQueryHandler<GetOrderListQuery, PagedResult<OrderListItem>> {\n    private readonly IReadModelStore<OrderListItem> _store;\n    public GetOrderListHandler(IReadModelStore<OrderListItem> store) {\n        _store = store;\n    }\n    public async Task<PagedResult<OrderListItem>> Handle(\n        GetOrderListQuery query,\n        CancellationToken cancellationToken) {\n        // Query read model with filtering, sorting, paging\n        var items = await _store Query(\n            filter: item => {\n                var matches = true;\n                if (query CustomerId HasValue) {\n                    matches &= item CustomerId == query CustomerId;\n                }\n                if ( string IsNullOrEmpty(query Status)) {\n                    matches &= item Status == query Status;\n                }\n                if (query MinAmount HasValue) {\n                    matches &= item TotalAmount >= query MinAmount;\n                }\n                if (query IsHighValue HasValue) {\n                    matches &= item IsHighValue == query IsHighValue;\n                }\n                return matches;\n            },\n            orderBy: query SortBy switch {\n                \"date\" => items => query SortDescending items OrderByDescending(i => i CreatedAt)\n                    : items OrderBy(i => i CreatedAt),\n                \"amount\" => items => query SortDescending items",
        "startIndex": 9562,
        "preview": "if (summary RecentOrders Count > 10) { summary RecentOrders RemoveAt(10); } await _store Upsert( summary CustomerId, summary, cancellationToken ); } [..."
      },
      {
        "id": "usage-patterns/cqrs-implementation-chunk-6",
        "text": "TotalAmount >= query MinAmount; } if (query IsHighValue HasValue) { matches &= item IsHighValue == query IsHighValue; } return matches; }, orderBy: query SortBy switch { \"date\" => items => query SortDescending items OrderByDescending(i => i CreatedAt) : items OrderBy(i => i CreatedAt), \"amount\" => items => query SortDescending items OrderByDescending(i => i TotalAmount)\n                    : items OrderBy(i => i TotalAmount),\n                _ => items => items OrderByDescending(i => i CreatedAt)\n            },\n            skip: (query Page - 1) * query PageSize,\n            take: query PageSize,\n            cancellationToken: cancellationToken\n        );\n        var totalCount = await _store Count(cancellationToken);\n        return new PagedResult<OrderListItem> {\n            Items = items,\n            Page = query Page,\n            PageSize = query PageSize,\n            TotalCount = totalCount,\n            TotalPages = (int)Math Ceiling(totalCount / (double)query PageSize)\n        };\n    }\n}\npublic class GetCustomerOrdersHandler : IQueryHandler<GetCustomerOrdersQuery, CustomerOrderSummary> {\n    private readonly IReadModelStore<CustomerOrderSummary> _store;\n    private readonly ICustomerService _customerService;\n    public GetCustomerOrdersHandler(\n        IReadModelStore<CustomerOrderSummary> store,\n        ICustomerService customerService) {\n        _store = store;\n        _customerService = customerService;\n    }\n    public async Task<CustomerOrderSummary> Handle(\n        GetCustomerOrdersQuery query,\n        CancellationToken cancellationToken) {\n        // Get from read model\n        var summary = await _store GetById(query CustomerId, cancellationToken);\n        if (summary == null) {\n            // No orders yet, return empty summary\n            var customer = await _customerService GetCustomer(\n                query CustomerId,\n                cancellationToken\n            );\n            return new CustomerOrderSummary {\n                CustomerId = query CustomerId,\n                CustomerName = customer Name \"Unknown\",\n                TotalOrders = 0,\n                CompletedOrders = 0,\n                PendingOrders = 0,\n                LifetimeValue = 0,\n                RecentOrders = new List<RecentOrder>()\n            };\n        }\n        return summary;\n    }\n}\npublic class SearchOrdersHandler : IQueryHandler<SearchOrdersQuery, List<OrderListItem>> {\n    private readonly IReadModelStore<OrderListItem> _store;\n    private readonly ISearchService _searchService;\n    public SearchOrdersHandler(\n        IReadModelStore<OrderListItem> store,\n        ISearchService searchService) {\n        _store = store;\n        _searchService = searchService;\n    }\n    public async Task<List<OrderListItem>> Handle(\n        SearchOrdersQuery query,\n        CancellationToken cancellationToken) {\n        // Use search service for full-text search\n        var orderIds = await _searchService SearchOrders(\n            query SearchTerm,\n            limit: query",
        "startIndex": 11913,
        "preview": "TotalAmount >= query MinAmount; } if (query IsHighValue HasValue) { matches &= item IsHighValue == query IsHighValue; } return matches; }, orderBy: qu..."
      },
      {
        "id": "usage-patterns/cqrs-implementation-chunk-7",
        "text": "List<OrderListItem>> { private readonly IReadModelStore<OrderListItem> _store; private readonly ISearchService _searchService; public SearchOrdersHandler( IReadModelStore<OrderListItem> store, ISearchService searchService) { _store = store; _searchService = searchService; } public async Task<List<OrderListItem>> Handle( SearchOrdersQuery query, CancellationToken cancellationToken) { // Use search service for full-text search var orderIds = await _searchService SearchOrders( query SearchTerm, limit: query MaxResults,\n            cancellationToken: cancellationToken\n        );\n        // Get read models for matching orders\n        var orders = new List<OrderListItem>();\n        foreach (var orderId in orderIds) {\n            var order = await _store GetById(orderId, cancellationToken);\n            if (order = null) {\n                orders Add(order);\n            }\n        }\n        return orders;\n    }\n}\n`\nStep 4: Configure CQRS\n`csharp{\ntitle: \"CQRS Configuration\"\ndescription: \"Configure Whizbang with CQRS pattern and projection processing\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Configuration\", \"CQRS Setup\", \"Projections\"]\nnugetPackages: [\"Whizbang Projections\", \"Whizbang EventSourcing\"]\nfilename: \"Program cs\"\nshowLineNumbers: true\nhighlightLines: [9, 16, 23, 33]\nusingStatements: [\"Whizbang\", \"Whizbang Projections\", \"Microsoft Extensions DependencyInjection\"]\n}\nusing Whizbang;\nusing Whizbang Projections;\nusing Microsoft AspNetCore Builder;\nusing Microsoft Extensions DependencyInjection;\nvar builder = WebApplication CreateBuilder(args);\n// Configure Whizbang with CQRS\nbuilder Services AddWhizbang(config => {\n    // Configure event sourcing for write side\n    config UseEventSourcing(options => {\n        options UsePostgreSQL(builder Configuration GetConnectionString(\"EventStore\"));\n    });\n    // Configure projections for read side\n    config UseProjections(options => {\n        // Use separate database for read models\n        options UsePostgreSQL(builder Configuration GetConnectionString(\"ReadModels\"));\n        // Configure projection processing\n        options ProcessingMode = ProjectionProcessingMode Async;\n        options RetryPolicy = RetryPolicy Exponential(3, TimeSpan FromSeconds(1));\n        // Register projections\n        options RegisterProjectionsFromAssembly(typeof(Program) Assembly);\n        // Configure read model stores\n        options ConfigureStore<OrderListItem>(store => {\n            store TableName = \"order_list\";\n            store EnableCaching(TimeSpan FromMinutes(5));\n        });\n        options ConfigureStore<CustomerOrderSummary>(store => {\n            store TableName = \"customer_orders\";\n            store EnableCaching(TimeSpan FromMinutes(10));\n        });\n        options ConfigureStore<OrderDetailsView>(store => {\n            store TableName = \"order_details\";\n            store EnableCaching(TimeSpan FromMinutes(2));\n        });\n    });\n    // Register handlers\n    config RegisterHandlersFromAssembly(typeof(Program) Assembly);\n});\n// Register services\nbuilder Services AddScoped<ICustomerService, CustomerService>();\nbuilder Services AddScoped<ISearchService, ElasticsearchService>();\nbuilder Services AddControllers();\nvar app = builder",
        "startIndex": 14765,
        "preview": "List<OrderListItem>> { private readonly IReadModelStore<OrderListItem> _store; private readonly ISearchService _searchService; public SearchOrdersHand..."
      },
      {
        "id": "usage-patterns/cqrs-implementation-chunk-8",
        "text": "options ConfigureStore<CustomerOrderSummary>(store => { store TableName = \"customer_orders\"; store EnableCaching(TimeSpan FromMinutes(10)); }); options ConfigureStore<OrderDetailsView>(store => { store TableName = \"order_details\"; store EnableCaching(TimeSpan FromMinutes(2)); }); }); // Register handlers config RegisterHandlersFromAssembly(typeof(Program) Assembly); }); // Register services builder Services AddScoped<ICustomerService, CustomerService>(); builder Services AddScoped<ISearchService, ElasticsearchService>(); builder Services AddControllers(); var app = builder Build();\n// Initialize projection infrastructure\nawait app InitializeProjections();\n// Start projection processor\napp UseProjectionProcessor();\napp UseRouting();\napp MapControllers();\napp Run();\n`\nComplete Example\n`csharp{\ntitle: \"Complete CQRS Implementation\"\ndescription: \"Full working example showing CQRS from commands to queries\"\nframework: \"NET8\"\ncategory: \"Complete Example\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"CQRS\", \"Complete\", \"API\", \"Commands\", \"Queries\"]\nnugetPackages: [\"Whizbang Projections\", \"Microsoft AspNetCore Mvc\"]\nfilename: \"CQRSOrdersController cs\"\nshowLineNumbers: true\nhighlightLines: [22, 36, 51, 66, 81]\ntestFile: \"CQRSOrdersTests cs\"\ntestMethod: \"CreateOrder_UpdatesReadModel_QueryReturnsData\"\nusingStatements: [\"Whizbang\", \"Microsoft AspNetCore Mvc\", \"System Threading Tasks\"]\n}\nusing Whizbang;\nusing Microsoft AspNetCore Mvc;\nusing System;\nusing System Threading;\nusing System Threading Tasks;\nusing MyApp Orders Commands;\nusing MyApp Orders Queries;\nusing MyApp Orders ReadModels;\nnamespace MyApp Controllers;\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class OrdersController : ControllerBase {\n    private readonly IMediator _mediator;\n    public OrdersController(IMediator mediator) {\n        _mediator = mediator;\n    }\n    // COMMAND SIDE - Write operations\n    [HttpPost]\n    public async Task<ActionResult<OrderCreatedResult>> CreateOrder(\n        [FromBody] CreateOrderRequest request,\n        CancellationToken cancellationToken) {\n        var command = new CreateOrderCommand(\n            request CustomerId,\n            request Items,\n            request ShippingAddress\n        );\n        var result = await _mediator Send(command, cancellationToken);\n        return CreatedAtAction(nameof(GetOrderDetails), new { orderId = result OrderId }, result);\n    }\n    [HttpPost(\"{orderId}/ship\")]\n    public async Task<ActionResult<ShipmentResult>> ShipOrder(\n        Guid orderId,\n        CancellationToken cancellationToken) {\n        var command = new ShipOrderCommand(orderId);\n        var result = await _mediator Send(command, cancellationToken);\n        return Ok(result);\n    }\n    // QUERY SIDE - Read operations from optimized read models\n    [HttpGet]\n    public async Task<ActionResult<PagedResult<OrderListItem>>> GetOrders(\n        [FromQuery] int page = 1,\n        [FromQuery] int pageSize = 20,\n        [FromQuery] string status = null,\n        [FromQuery] decimal",
        "startIndex": 17514,
        "preview": "options ConfigureStore<CustomerOrderSummary>(store => { store TableName = \"customer_orders\"; store EnableCaching(TimeSpan FromMinutes(10)); }); option..."
      },
      {
        "id": "usage-patterns/cqrs-implementation-chunk-9",
        "text": "CancellationToken cancellationToken) { var command = new ShipOrderCommand(orderId); var result = await _mediator Send(command, cancellationToken); return Ok(result); } // QUERY SIDE - Read operations from optimized read models [HttpGet] public async Task<ActionResult<PagedResult<OrderListItem>>> GetOrders( [FromQuery] int page = 1, [FromQuery] int pageSize = 20, [FromQuery] string status = null, [FromQuery] decimal minAmount = null,\n        [FromQuery] string sortBy = \"date\",\n        [FromQuery] bool sortDescending = true,\n        CancellationToken cancellationToken = default) {\n        var query = new GetOrderListQuery {\n            Page = page,\n            PageSize = pageSize,\n            Status = status,\n            MinAmount = minAmount,\n            SortBy = sortBy,\n            SortDescending = sortDescending\n        };\n        var result = await _mediator Send(query, cancellationToken);\n        return Ok(result);\n    }\n    [HttpGet(\"{orderId}\")]\n    public async Task<ActionResult<OrderDetailsView>> GetOrderDetails(\n        Guid orderId,\n        CancellationToken cancellationToken) {\n        var query = new GetOrderDetailsQuery(orderId);\n        var result = await _mediator Send(query, cancellationToken);\n        if (result == null) {\n            return NotFound();\n        }\n        return Ok(result);\n    }\n    [HttpGet(\"customer/{customerId}\")]\n    public async Task<ActionResult<CustomerOrderSummary>> GetCustomerOrders(\n        Guid customerId,\n        CancellationToken cancellationToken) {\n        var query = new GetCustomerOrdersQuery(customerId);\n        var result = await _mediator Send(query, cancellationToken);\n        return Ok(result);\n    }\n    [HttpGet(\"search\")]\n    public async Task<ActionResult<List<OrderListItem>>> SearchOrders(\n        [FromQuery] string q,\n        [FromQuery] int maxResults = 50,\n        CancellationToken cancellationToken = default) {\n        if (string IsNullOrWhiteSpace(q)) {\n            return BadRequest(\"Search term is required\");\n        }\n        var query = new SearchOrdersQuery {\n            SearchTerm = q,\n            MaxResults = maxResults\n        };\n        var result = await _mediator Send(query, cancellationToken);\n        return Ok(result);\n    }\n    // Analytics queries from specialized read models\n    [HttpGet(\"analytics/top-customers\")]\n    public async Task<ActionResult<List<TopCustomer>>> GetTopCustomers(\n        [FromQuery] int count = 10,\n        CancellationToken cancellationToken = default) {\n        var query = new GetTopCustomersQuery(count);\n        var result = await _mediator Send(query, cancellationToken);\n        return Ok(result);\n    }\n    [HttpGet(\"analytics/sales-by-day\")]\n    public async Task<ActionResult<List<DailySales>>> GetSalesByDay(\n        [FromQuery] DateTime startDate,\n        [FromQuery] DateTime endDate,\n        CancellationToken cancellationToken = default) {\n        var query = new GetSalesByDayQuery(startDate, endDate);\n        var result = await _mediator",
        "startIndex": 19937,
        "preview": "CancellationToken cancellationToken) { var command = new ShipOrderCommand(orderId); var result = await _mediator Send(command, cancellationToken); ret..."
      },
      {
        "id": "usage-patterns/cqrs-implementation-chunk-10",
        "text": "count = 10, CancellationToken cancellationToken = default) { var query = new GetTopCustomersQuery(count); var result = await _mediator Send(query, cancellationToken); return Ok(result); } [HttpGet(\"analytics/sales-by-day\")] public async Task<ActionResult<List<DailySales>>> GetSalesByDay( [FromQuery] DateTime startDate, [FromQuery] DateTime endDate, CancellationToken cancellationToken = default) { var query = new GetSalesByDayQuery(startDate, endDate); var result = await _mediator Send(query, cancellationToken);\n        return Ok(result);\n    }\n}\n// Query definitions\npublic record GetOrderListQuery {\n    public int Page { get; set; } = 1;\n    public int PageSize { get; set; } = 20;\n    public Guid CustomerId { get; set; }\n    public string Status { get; set; }\n    public decimal MinAmount { get; set; }\n    public bool IsHighValue { get; set; }\n    public string SortBy { get; set; } = \"date\";\n    public bool SortDescending { get; set; } = true;\n}\npublic record SearchOrdersQuery {\n    public string SearchTerm { get; set; }\n    public int MaxResults { get; set; } = 50;\n}\n`\nTesting Strategy\nTesting Projections\n`csharp{\ntitle: \"Projection Tests\"\ndescription: \"Test that projections correctly update read models from events\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Unit Testing\", \"Projections\", \"Read Models\"]\nnugetPackages: [\"Whizbang Projections\", \"xUnit\", \"Moq\"]\nfilename: \"OrderProjectionTests cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang Projections\", \"Xunit\", \"Moq\"]\n}\nusing Whizbang Projections;\nusing Xunit;\nusing Moq;\nusing System;\nusing System Threading;\nusing System Threading Tasks;\nusing MyApp Orders Events;\nusing MyApp Orders Projections;\nusing MyApp Orders ReadModels;\nnamespace MyApp Tests Orders;\npublic class OrderListProjectionTests {\n    private readonly Mock<IReadModelStore<OrderListItem>> _storeMock;\n    private readonly Mock<ICustomerService> _customerServiceMock;\n    private readonly OrderListProjection _projection;\n    public OrderListProjectionTests() {\n        _storeMock = new Mock<IReadModelStore<OrderListItem>>();\n        _customerServiceMock = new Mock<ICustomerService>();\n        _projection = new OrderListProjection(\n            _storeMock Object,\n            _customerServiceMock Object\n        );\n    }\n    [Fact]\n    public async Task Handle_OrderCreated_CreatesReadModel() {\n        // Arrange\n        var @event = new OrderCreated(\n            Guid NewGuid(),\n            Guid NewGuid(),\n            new List<OrderItem> {\n                new OrderItem(\"P1\", \"Widget\", 2, 500 00m)\n            },\n            1000 00m,\n            \"123 Main St\",\n            DateTime",
        "startIndex": 22517,
        "preview": "count = 10, CancellationToken cancellationToken = default) { var query = new GetTopCustomersQuery(count); var result = await _mediator Send(query, can..."
      },
      {
        "id": "usage-patterns/cqrs-implementation-chunk-11",
        "text": "= new Mock<IReadModelStore<OrderListItem>>(); _customerServiceMock = new Mock<ICustomerService>(); _projection = new OrderListProjection( _storeMock Object, _customerServiceMock Object ); } [Fact] public async Task Handle_OrderCreated_CreatesReadModel() { // Arrange var @event = new OrderCreated( Guid NewGuid(), Guid NewGuid(), new List<OrderItem> { new OrderItem(\"P1\", \"Widget\", 2, 500 00m) }, 1000 00m, \"123 Main St\", DateTime UtcNow\n        );\n        _customerServiceMock Setup(x => x GetCustomer(It IsAny<Guid>(), It IsAny<CancellationToken>())) ReturnsAsync(new Customer { Name = \"John Doe\" });\n        // Act\n        await _projection Handle(\n            @event,\n            new EventMetadata(),\n            CancellationToken None\n        );\n        // Assert\n        _storeMock Verify(x => x Add(\n            @event OrderId,\n            It Is<OrderListItem>(item =>\n                item OrderId == @event OrderId &&\n                item TotalAmount == 1000 00m &&\n                item Status == \"Pending\" &&\n                item IsHighValue == true &&\n                item CustomerName == \"John Doe\"\n            ),\n            It IsAny<CancellationToken>()\n        ), Times Once);\n    }\n    [Fact]\n    public async Task Handle_OrderShipped_UpdatesStatus() {\n        // Arrange\n        var orderId = Guid NewGuid();\n        var @event = new OrderShipped(\n            orderId,\n            \"TRACK123\",\n            \"FedEx\",\n            DateTime UtcNow\n        );\n        // Act\n        await _projection Handle(\n            @event,\n            new EventMetadata(),\n            CancellationToken None\n        );\n        // Assert\n        _storeMock Verify(x => x Update(\n            orderId,\n            It IsAny<Action<OrderListItem>>(),\n            It IsAny<CancellationToken>()\n        ), Times Once);\n    }\n}\n`\nCommon Pitfalls\nDon't Query Write Models\n`csharp\n// ❌ BAD - Querying aggregates for read operations\npublic async Task<List<Order>> GetOrders() {\n    var aggregates = await _repository GetAll<OrderAggregate>();\n    return aggregates Select(a => MapToDto(a)) ToList();\n}\n// ✅ GOOD - Query optimized read models\npublic async Task<List<OrderListItem>> GetOrders() {\n    return await _readModelStore Query<OrderListItem>();\n}\n`\nHandle Eventual Consistency\n`csharp\n// ❌ BAD - Expecting immediate consistency\nvar orderId = await CreateOrder(command);\nvar order = await GetOrder(orderId); // May not exist yet // ✅ GOOD - Handle eventual consistency\nvar orderId = await CreateOrder(command);\nawait Task",
        "startIndex": 24699,
        "preview": "= new Mock<IReadModelStore<OrderListItem>>(); _customerServiceMock = new Mock<ICustomerService>(); _projection = new OrderListProjection( _storeMock O..."
      },
      {
        "id": "usage-patterns/cqrs-implementation-chunk-12",
        "text": "async Task<List<OrderListItem>> GetOrders() { return await _readModelStore Query<OrderListItem>(); } ` Handle Eventual Consistency `csharp // ❌ BAD - Expecting immediate consistency var orderId = await CreateOrder(command); var order = await GetOrder(orderId); // May not exist yet // ✅ GOOD - Handle eventual consistency var orderId = await CreateOrder(command); await Task Delay(100); // Or use polling/SignalR for real-time updates\nvar order = await GetOrder(orderId);\n`\nAvoid Complex Projections\n`csharp\n// ❌ BAD - Projection doing too much\npublic async Task Handle(OrderCreated @event) {\n    await UpdateOrderList();\n    await UpdateCustomerSummary();\n    await SendEmail();\n    await UpdateInventory();\n}\n// ✅ GOOD - Single responsibility projections\npublic class OrderListProjection { / Updates order list only / }\npublic class CustomerSummaryProjection { / Updates customer summary only / }\npublic class EmailNotificationHandler { / Sends emails only / }\n`\nProgressive Enhancement\nAdd Multiple Read Stores\n`csharp\n// Configure different stores for different needs\nconfig UseProjections(options => {\n    // PostgreSQL for transactional queries\n    options AddStore<OrderListItem>() UsePostgreSQL(connString) WithCaching(TimeSpan FromMinutes(5));\n    // MongoDB for document queries\n    options AddStore<OrderDetailsView>() UseMongoDB(mongoConnection) WithIndexes(\"CustomerId\", \"Status\");\n    // Elasticsearch for search\n    options AddStore<OrderSearchDocument>() UseElasticsearch(elasticUri) WithFullTextSearch();\n});\n`\nImplement Sagas for Complex Workflows\nSee Saga Orchestration for coordinating multi-aggregate operations Add Real-Time Updates\n`csharp\n// SignalR for real-time notifications\npublic class OrderHub : Hub {\n    public async Task SubscribeToOrders(Guid customerId) {\n        await Groups AddToGroupAsync(Context ConnectionId, $\"customer-{customerId}\");\n    }\n}\n// In projection\npublic async Task Handle(OrderCreated @event) {\n    await UpdateReadModel(@event);\n    await _hubContext Clients Group($\"customer-{@event CustomerId}\") SendAsync(\"OrderCreated\", @event);\n}\n`\nRelated Patterns\nEvent Sourcing Basics - Foundation for CQRS write side\nSimple Mediator Pattern - Simpler alternative without separation\nDistributed Messaging - Scale CQRS across services\nProduction Considerations\nRead Model Rebuild\n`csharp\n// Rebuild read models from events\nawait projectionManager RebuildProjection<OrderListProjection>(\n    fromPosition: EventPosition Start,\n    toPosition: EventPosition End\n);\n`\nMonitoring and Health Checks\n`csharp\n// Monitor projection lag\nservices AddHealthChecks() AddCheck<ProjectionLagHealthCheck>(\"projection-lag\")",
        "startIndex": 26810,
        "preview": "async Task<List<OrderListItem>> GetOrders() { return await _readModelStore Query<OrderListItem>(); } ` Handle Eventual Consistency `csharp // ❌ BAD - ..."
      },
      {
        "id": "usage-patterns/cqrs-implementation-chunk-13",
        "text": "Simple Mediator Pattern - Simpler alternative without separation Distributed Messaging - Scale CQRS across services Production Considerations Read Model Rebuild `csharp // Rebuild read models from events await projectionManager RebuildProjection<OrderListProjection>( fromPosition: EventPosition Start, toPosition: EventPosition End ); ` Monitoring and Health Checks `csharp // Monitor projection lag services AddHealthChecks() AddCheck<ProjectionLagHealthCheck>(\"projection-lag\") AddCheck<ReadModelConsistencyCheck>(\"read-consistency\");\n`\nPerformance Optimization\nUse appropriate indexes on read models\nImplement caching strategies\nConsider materialized views for complex queries\nMonitor query performance\nNext Steps\nExplore Saga Orchestration for complex workflows\nLearn about Distributed Messaging for microservices\nReview Projections Documentation for advanced patterns\nCheck out Query Optimization techniques",
        "startIndex": 29172,
        "preview": "Simple Mediator Pattern - Simpler alternative without separation Distributed Messaging - Scale CQRS across services Production Considerations Read Mod..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "usage-patterns/distributed-messaging",
    "title": "Distributed Messaging",
    "category": "Usage Patterns",
    "url": "/docs/usage-patterns/distributed-messaging",
    "chunks": [
      {
        "id": "usage-patterns/distributed-messaging-chunk-0",
        "text": "Distributed Messaging\nOverview\nDistributed Messaging enables reliable communication between services in a microservices architecture. Whizbang provides robust patterns for handling distributed transactions, ensuring message delivery, and maintaining consistency across service boundaries.\nKey Concepts\nOutbox Pattern: Ensure reliable message publishing\nInbox Pattern: Handle duplicate messages and ensure idempotency\nMessage Routing: Direct messages to appropriate handlers\nSaga Coordination: Orchestrate multi-service workflows\nArchitecture Diagram\n`mermaid\ngraph TB\n    subgraph \"Service A\"\n        A1[Command Handler] --> A2[Aggregate]\n        A2 --> A3[Event Store]\n        A3 --> A4[Outbox]\n        A4 --> A5[Message Publisher]\n    end\n    subgraph \"Message Broker\"\n        MB[(RabbitMQ/Kafka)]\n    end\n    subgraph \"Service B\"\n        B1[Message Consumer] --> B2[Inbox]\n        B2 --> B3[Command Handler]\n        B3 --> B4[Aggregate]\n    end\n    A5 --> MB\n    MB --> B1\n    style MB fill:#0066cc,color:#fff\n`\nImplementation Guide\nDocumentation in progress - This page demonstrates the structure for distributed messaging patterns with Whizbang.\nTopics to Cover:\nOutbox Pattern Implementation\nTransactional outbox\nMessage publishing\nRetry mechanisms\nInbox Pattern Implementation\nDuplicate detection\nMessage ordering\nIdempotent processing\nMessage Broker Integration\nRabbitMQ configuration\nKafka setup\nAzure Service Bus\nError Handling\nDead letter queues\nRetry policies\nCompensation\nMonitoring\nMessage tracking\nLatency metrics\nHealth checks\nRelated Patterns\nEvent Sourcing Basics - Foundation for event-driven messaging\nSaga Orchestration - Coordinate distributed workflows\nMicroservices Integration - Complete microservices setup\nNext Steps\nReview Distributed Messaging Roadmap for upcoming features\nExplore Saga Orchestration for complex workflows\nCheck Getting Started Guide for basics",
        "startIndex": 0,
        "preview": "Distributed Messaging\nOverview\nDistributed Messaging enables reliable communication between services in a microservices architecture. Whizbang provide..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "usage-patterns/event-sourcing-basics",
    "title": "Event Sourcing Basics",
    "category": "Usage Patterns",
    "url": "/docs/usage-patterns/event-sourcing-basics",
    "chunks": [
      {
        "id": "usage-patterns/event-sourcing-basics-chunk-0",
        "text": "Event Sourcing Basics\nOverview\nEvent Sourcing is a powerful pattern where instead of storing the current state of your domain objects, you store the sequence of events that led to that state Whizbang makes event sourcing approachable and practical for NET applications What is Event Sourcing Instead of updating a record in place, event sourcing:\nCaptures every state change as an immutable event\nStores events in an append-only log\nRebuilds current state by replaying events\nProvides a complete audit trail and time-travel capabilities\nWhen to Use Event Sourcing\nEvent sourcing is ideal when you need:\nComplete audit trails - Every change is recorded with who, what, when\nTime travel - Ability to see state at any point in time\nEvent replay - Rebuild state, fix bugs, or create new projections\nComplex workflows - Track multi-step processes with compensation\nCompliance - Immutable history for regulatory requirements\nArchitecture Diagram\n`mermaid\nsequenceDiagram\n    participant API as API Controller\n    participant M as Mediator\n    participant H as Command Handler\n    participant A as Aggregate\n    participant R as Repository\n    participant ES as Event Store\n    participant P as Projections\n    API->>M: Send Command\n    M->>H: Route to Handler\n    H->>R: Load Aggregate\n    R->>ES: Read Event Stream\n    ES-->>R: Events\n    R->>A: Rebuild from Events\n    R-->>H: Aggregate\n    H->>A: Execute Command\n    A->>A: Apply Business Rules\n    A->>A: Generate Event(s)\n    H->>R: Save Aggregate\n    R->>ES: Append Events\n    ES->>P: Publish Events\n    P->>P: Update Read Models\n    H-->>API: Command Result\n`\nCore Components\nRequired Packages\n`xml\n<PackageReference Include=\"Whizbang Core\" Version=\"1 0 0\" />\n<PackageReference Include=\"Whizbang EventSourcing\" Version=\"1 0",
        "startIndex": 0,
        "preview": "Event Sourcing Basics\nOverview\nEvent Sourcing is a powerful pattern where instead of storing the current state of your domain objects, you store the s..."
      },
      {
        "id": "usage-patterns/event-sourcing-basics-chunk-1",
        "text": "R->>A: Rebuild from Events R-->>H: Aggregate H->>A: Execute Command A->>A: Apply Business Rules A->>A: Generate Event(s) H->>R: Save Aggregate R->>ES: Append Events ES->>P: Publish Events P->>P: Update Read Models H-->>API: Command Result ` Core Components Required Packages `xml <PackageReference Include=\"Whizbang Core\" Version=\"1 0 0\" /> <PackageReference Include=\"Whizbang EventSourcing\" Version=\"1 0 0\" />\n`\nKey Concepts\nEvent - Immutable record of something that happened\nAggregate - Domain object that enforces business rules\nEvent Stream - Ordered sequence of events for an aggregate\nEvent Store - Database optimized for append-only event storage\nSnapshot - Periodic state capture to optimize replay\nStep-by-Step Implementation\nStep 1: Define Your Events\n`csharp{\ntitle: \"Event Definitions\"\ndescription: \"Define domain events that represent state changes\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Events\", \"Domain Events\", \"Event Sourcing\"]\nnugetPackages: [\"Whizbang EventSourcing\"]\nfilename: \"OrderEvents cs\"\nshowLineNumbers: true\nhighlightLines: [10, 19, 27]\nusingStatements: [\"Whizbang EventSourcing\", \"System\"]\n}\nusing Whizbang EventSourcing;\nusing System;\nusing System Collections Generic;\nnamespace MyApp Orders",
        "startIndex": 1779,
        "preview": "R->>A: Rebuild from Events R-->>H: Aggregate H->>A: Execute Command A->>A: Apply Business Rules A->>A: Generate Event(s) H->>R: Save Aggregate R->>ES:..."
      },
      {
        "id": "usage-patterns/event-sourcing-basics-chunk-2",
        "text": "description: \"Define domain events that represent state changes\" framework: \"NET8\" category: \"Event Sourcing\" difficulty: \"INTERMEDIATE\" tags: [\"Events\", \"Domain Events\", \"Event Sourcing\"] nugetPackages: [\"Whizbang EventSourcing\"] filename: \"OrderEvents cs\" showLineNumbers: true highlightLines: [10, 19, 27] usingStatements: [\"Whizbang EventSourcing\", \"System\"] } using Whizbang EventSourcing; using System; using System Collections Generic; namespace MyApp Orders Events;\n// Base event with common metadata\npublic abstract record OrderEvent : DomainEvent;\n// Event: Order was created\npublic record OrderCreated(\n    Guid OrderId,\n    Guid CustomerId,\n    List<OrderItem> Items,\n    decimal TotalAmount,\n    string ShippingAddress,\n    DateTime CreatedAt\n) : OrderEvent;\n// Event: Item was added to order\npublic record OrderItemAdded(\n    Guid OrderId,\n    OrderItem Item,\n    decimal NewTotalAmount\n) : OrderEvent;\n// Event: Order was shipped\npublic record OrderShipped(\n    Guid OrderId,\n    string TrackingNumber,\n    string Carrier,\n    DateTime ShippedAt\n) : OrderEvent;\n// Event: Order was cancelled\npublic record OrderCancelled(\n    Guid OrderId,\n    string Reason,\n    DateTime CancelledAt\n) : OrderEvent;\n// Value objects\npublic record OrderItem(\n    string ProductId,\n    string ProductName,\n    int Quantity,\n    decimal UnitPrice\n);\n`\nStep 2: Create Your Aggregate\n`csharp{\ntitle: \"Aggregate Implementation\"\ndescription: \"Build an aggregate that applies events and enforces business rules\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aggregate\", \"Domain Model\", \"Business Rules\"]\nnugetPackages: [\"Whizbang EventSourcing\"]\nfilename: \"OrderAggregate cs\"\nshowLineNumbers: true\nhighlightLines: [25, 44, 67, 82]\nusingStatements: [\"Whizbang EventSourcing\", \"System\", \"System Collections Generic\"]\n}\nusing Whizbang EventSourcing;\nusing System;\nusing System Collections Generic;\nusing System Linq;\nusing MyApp Orders Events;\nnamespace MyApp Orders Aggregates;\npublic class OrderAggregate : Aggregate {\n    // Current state (rebuilt from events)\n    public Guid CustomerId { get; private set; }\n    public List<OrderItem> Items { get; private set; } = new();\n    public decimal TotalAmount { get; private set; }\n    public string ShippingAddress { get; private set; }\n    public OrderStatus Status { get; private set; }\n    public string TrackingNumber { get; private set; }\n    public DateTime",
        "startIndex": 2639,
        "preview": "description: \"Define domain events that represent state changes\" framework: \"NET8\" category: \"Event Sourcing\" difficulty: \"INTERMEDIATE\" tags: [\"Event..."
      },
      {
        "id": "usage-patterns/event-sourcing-basics-chunk-3",
        "text": "CustomerId { get; private set; } public List<OrderItem> Items { get; private set; } = new(); public decimal TotalAmount { get; private set; } public string ShippingAddress { get; private set; } public OrderStatus Status { get; private set; } public string TrackingNumber { get; private set; } public DateTime ShippedAt { get; private set; }\n    // Constructor for existing aggregate (loaded from events)\n    public OrderAggregate() { }\n    // Constructor for new aggregate\n    public OrderAggregate(Guid orderId, Guid customerId, List<OrderItem> items, string shippingAddress) {\n        if (items == null || items Any()) {\n            throw new DomainException(\"Order must have at least one item\");\n        }\n        var totalAmount = items Sum(i => i Quantity * i UnitPrice);\n        // Apply event (this both raises it and updates our state)\n        Apply(new OrderCreated(\n            orderId,\n            customerId,\n            items,\n            totalAmount,\n            shippingAddress,\n            DateTime UtcNow\n        ));\n    }\n    // Command: Add item to order\n    public void AddItem(OrderItem item) {\n        if (Status = OrderStatus Pending) {\n            throw new DomainException($\"Cannot add items to {Status} order\");\n        }\n        if (item Quantity <= 0) {\n            throw new DomainException(\"Quantity must be positive\");\n        }\n        var newTotal = TotalAmount + (item Quantity * item UnitPrice);\n        Apply(new OrderItemAdded(Id, item, newTotal));\n    }\n    // Command: Ship the order\n    public void Ship(string trackingNumber, string carrier) {\n        if (Status = OrderStatus Pending) {\n            throw new DomainException($\"Cannot ship order in {Status} status\");\n        }\n        if (string IsNullOrEmpty(trackingNumber)) {\n            throw new DomainException(\"Tracking number is required\");\n        }\n        Apply(new OrderShipped(Id, trackingNumber, carrier, DateTime UtcNow));\n    }\n    // Command: Cancel the order\n    public void Cancel(string reason) {\n        if (Status == OrderStatus Shipped) {\n            throw new DomainException(\"Cannot cancel shipped order\");\n        }\n        if (Status == OrderStatus Cancelled) {\n            return; // Idempotent\n        }\n        Apply(new OrderCancelled(Id, reason, DateTime UtcNow));\n    }\n    // Event handlers - Update state when events are applied\n    protected void When(OrderCreated @event) {\n        Id = @event OrderId;\n        CustomerId = @event CustomerId;\n        Items = @event Items",
        "startIndex": 4609,
        "preview": "CustomerId { get; private set; } public List<OrderItem> Items { get; private set; } = new(); public decimal TotalAmount { get; private set; } public s..."
      },
      {
        "id": "usage-patterns/event-sourcing-basics-chunk-4",
        "text": "throw new DomainException(\"Cannot cancel shipped order\"); } if (Status == OrderStatus Cancelled) { return; // Idempotent } Apply(new OrderCancelled(Id, reason, DateTime UtcNow)); } // Event handlers - Update state when events are applied protected void When(OrderCreated @event) { Id = @event OrderId; CustomerId = @event CustomerId; Items = @event Items ToList();\n        TotalAmount = @event TotalAmount;\n        ShippingAddress = @event ShippingAddress;\n        Status = OrderStatus Pending;\n    }\n    protected void When(OrderItemAdded @event) {\n        Items Add(@event Item);\n        TotalAmount = @event NewTotalAmount;\n    }\n    protected void When(OrderShipped @event) {\n        Status = OrderStatus Shipped;\n        TrackingNumber = @event TrackingNumber;\n        ShippedAt = @event ShippedAt;\n    }\n    protected void When(OrderCancelled @event) {\n        Status = OrderStatus Cancelled;\n    }\n}\npublic enum OrderStatus {\n    Pending,\n    Shipped,\n    Delivered,\n    Cancelled\n}\n`\nStep 3: Implement Command Handlers\n`csharp{\ntitle: \"Event-Sourced Command Handler\"\ndescription: \"Command handlers that work with aggregates and event stores\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Command Handler\", \"Event Store\", \"Repository\"]\nnugetPackages: [\"Whizbang EventSourcing\"]\nfilename: \"CreateOrderHandler cs\"\nshowLineNumbers: true\nhighlightLines: [20, 25, 28]\nusingStatements: [\"Whizbang EventSourcing\", \"System\", \"System Threading Tasks\"]\n}\nusing Whizbang EventSourcing;\nusing System;\nusing System Threading;\nusing System Threading Tasks;\nusing MyApp Orders Aggregates;\nusing MyApp Orders Commands;\nnamespace MyApp Orders Handlers;\npublic class CreateOrderHandler : ICommandHandler<CreateOrderCommand, OrderCreatedResult> {\n    private readonly IAggregateRepository<OrderAggregate> _repository;\n    private readonly IInventoryService _inventoryService;\n    public CreateOrderHandler(\n        IAggregateRepository<OrderAggregate> repository,\n        IInventoryService inventoryService) {\n        _repository = repository;\n        _inventoryService = inventoryService;\n    }\n    public async Task<OrderCreatedResult> Handle(\n        CreateOrderCommand command,\n        CancellationToken cancellationToken) {\n        // Check inventory before creating order\n        await _inventoryService ValidateAvailability(command Items, cancellationToken);\n        // Create new aggregate (generates OrderCreated event)\n        var orderId = Guid NewGuid();\n        var order = new OrderAggregate(\n            orderId,\n            command CustomerId,\n            command Items,\n            command ShippingAddress\n        );\n        // Save aggregate (persists events to event store)\n        await _repository SaveAsync(order, cancellationToken);\n        // Reserve inventory (side effect after event is saved)\n        await _inventoryService ReserveItems(orderId, command Items, cancellationToken);\n        return new OrderCreatedResult(\n            orderId,\n            order",
        "startIndex": 6804,
        "preview": "throw new DomainException(\"Cannot cancel shipped order\"); } if (Status == OrderStatus Cancelled) { return; // Idempotent } Apply(new OrderCancelled(Id..."
      },
      {
        "id": "usage-patterns/event-sourcing-basics-chunk-5",
        "text": "var orderId = Guid NewGuid(); var order = new OrderAggregate( orderId, command CustomerId, command Items, command ShippingAddress ); // Save aggregate (persists events to event store) await _repository SaveAsync(order, cancellationToken); // Reserve inventory (side effect after event is saved) await _inventoryService ReserveItems(orderId, command Items, cancellationToken); return new OrderCreatedResult( orderId, order TotalAmount,\n            EstimateDelivery(command ShippingAddress)\n        );\n    }\n    private DateTime EstimateDelivery(string address) {\n        // Simple estimation logic\n        return DateTime UtcNow AddDays(3);\n    }\n}\npublic class ShipOrderHandler : ICommandHandler<ShipOrderCommand, ShipmentResult> {\n    private readonly IAggregateRepository<OrderAggregate> _repository;\n    private readonly IShippingService _shippingService;\n    public ShipOrderHandler(\n        IAggregateRepository<OrderAggregate> repository,\n        IShippingService shippingService) {\n        _repository = repository;\n        _shippingService = shippingService;\n    }\n    public async Task<ShipmentResult> Handle(\n        ShipOrderCommand command,\n        CancellationToken cancellationToken) {\n        // Load aggregate from event store\n        var order = await _repository GetByIdAsync(command OrderId, cancellationToken);\n        if (order == null) {\n            throw new NotFoundException($\"Order {command OrderId} not found\");\n        }\n        // Request shipment\n        var shipment = await _shippingService CreateShipment(\n            order Id,\n            order ShippingAddress,\n            cancellationToken\n        );\n        // Apply ship command to aggregate (generates OrderShipped event)\n        order Ship(shipment TrackingNumber, shipment Carrier);\n        // Save aggregate (appends new event to stream)\n        await _repository SaveAsync(order, cancellationToken);\n        return new ShipmentResult(\n            shipment TrackingNumber,\n            shipment Carrier,\n            shipment EstimatedDelivery\n        );\n    }\n}\n`\nStep 4: Configure Event Store\n`csharp{\ntitle: \"Event Store Configuration\"\ndescription: \"Configure Whizbang with event sourcing and storage\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Configuration\", \"Event Store\", \"PostgreSQL\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang PostgreSQL\"]\nfilename: \"Program cs\"\nshowLineNumbers: true\nhighlightLines: [9, 14, 19]\nusingStatements: [\"Whizbang EventSourcing\", \"Microsoft Extensions DependencyInjection\"]\n}\nusing Whizbang EventSourcing;\nusing Microsoft AspNetCore Builder;\nusing Microsoft Extensions DependencyInjection;\nusing MyApp Orders Handlers;\nvar builder = WebApplication CreateBuilder(args);\n// Configure Whizbang with event sourcing\nbuilder Services AddWhizbang(config => {\n    // Use event sourcing with PostgreSQL\n    config UseEventSourcing(options => {\n        options UsePostgreSQL(builder Configuration GetConnectionString(\"EventStore\"));\n        // Configure snapshots (optional optimization)\n        options EnableSnapshots(snapshot => {\n            snapshot",
        "startIndex": 9458,
        "preview": "var orderId = Guid NewGuid(); var order = new OrderAggregate( orderId, command CustomerId, command Items, command ShippingAddress ); // Save aggregate..."
      },
      {
        "id": "usage-patterns/event-sourcing-basics-chunk-6",
        "text": "AspNetCore Builder; using Microsoft Extensions DependencyInjection; using MyApp Orders Handlers; var builder = WebApplication CreateBuilder(args); // Configure Whizbang with event sourcing builder Services AddWhizbang(config => { // Use event sourcing with PostgreSQL config UseEventSourcing(options => { options UsePostgreSQL(builder Configuration GetConnectionString(\"EventStore\")); // Configure snapshots (optional optimization) options EnableSnapshots(snapshot => { snapshot Frequency = 10; // Create snapshot every 10 events\n            snapshot KeepSnapshots = 3; // Keep last 3 snapshots\n        });\n        // Configure event serialization\n        options UseJsonSerialization(json => {\n            json UseSystemTextJson();\n            json IncludeTypeInformation = true;\n        });\n    });\n    // Register handlers\n    config RegisterHandlersFromAssembly(typeof(Program) Assembly);\n    // Add projections (read models)\n    config RegisterProjectionsFromAssembly(typeof(Program) Assembly);\n});\n// Register domain services\nbuilder Services AddScoped<IInventoryService, InventoryService>();\nbuilder Services AddScoped<IShippingService, ShippingService>();\nbuilder Services AddControllers();\nvar app = builder Build();\n// Initialize event store schema\nawait app InitializeEventStore();\napp UseRouting();\napp MapControllers();\napp Run();\n`\nComplete Example\n`csharp{\ntitle: \"Complete Event Sourcing Example\"\ndescription: \"Full working example showing event sourcing from API to persistence\"\nframework: \"NET8\"\ncategory: \"Complete Example\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Event Sourcing\", \"Complete\", \"API\", \"Aggregate\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Microsoft AspNetCore Mvc\"]\nfilename: \"EventSourcedOrdersController cs\"\nshowLineNumbers: true\nhighlightLines: [22, 35, 50, 68]\ntestFile: \"EventSourcedOrdersTests cs\"\ntestMethod: \"CreateOrder_StoresEvents_AndRebuildsState\"\nusingStatements: [\"Whizbang EventSourcing\", \"Microsoft AspNetCore Mvc\", \"System Threading Tasks\"]\n}\nusing Whizbang EventSourcing;\nusing Microsoft AspNetCore Mvc;\nusing System;\nusing System Threading;\nusing System Threading Tasks;\nusing MyApp Orders Commands;\nusing MyApp Orders Queries;\nnamespace MyApp Controllers;\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class OrdersController : ControllerBase {\n    private readonly IMediator _mediator;\n    private readonly IEventStore _eventStore;\n    public OrdersController(IMediator mediator, IEventStore eventStore) {\n        _mediator = mediator;\n        _eventStore = eventStore;\n    }\n    [HttpPost]\n    public async Task<ActionResult<OrderCreatedResult>> CreateOrder(\n        [FromBody] CreateOrderRequest request,\n        CancellationToken cancellationToken) {\n        var command = new CreateOrderCommand(\n            request CustomerId,\n            request Items,\n            request ShippingAddress\n        );\n        var result = await _mediator Send(command, cancellationToken);\n        return CreatedAtAction(\n            nameof(GetOrder),\n            new { orderId = result",
        "startIndex": 12152,
        "preview": "AspNetCore Builder; using Microsoft Extensions DependencyInjection; using MyApp Orders Handlers; var builder = WebApplication CreateBuilder(args); // ..."
      },
      {
        "id": "usage-patterns/event-sourcing-basics-chunk-7",
        "text": "OrdersController(IMediator mediator, IEventStore eventStore) { _mediator = mediator; _eventStore = eventStore; } [HttpPost] public async Task<ActionResult<OrderCreatedResult>> CreateOrder( [FromBody] CreateOrderRequest request, CancellationToken cancellationToken) { var command = new CreateOrderCommand( request CustomerId, request Items, request ShippingAddress ); var result = await _mediator Send(command, cancellationToken); return CreatedAtAction( nameof(GetOrder), new { orderId = result OrderId },\n            result\n        );\n    }\n    [HttpPost(\"{orderId}/ship\")]\n    public async Task<ActionResult<ShipmentResult>> ShipOrder(\n        Guid orderId,\n        [FromBody] ShipOrderRequest request,\n        CancellationToken cancellationToken) {\n        var command = new ShipOrderCommand(orderId);\n        var result = await _mediator Send(command, cancellationToken);\n        return Ok(result);\n    }\n    [HttpGet(\"{orderId}\")]\n    public async Task<ActionResult<OrderDetails>> GetOrder(\n        Guid orderId,\n        CancellationToken cancellationToken) {\n        // Query uses projection (read model)\n        var query = new GetOrderByIdQuery(orderId);\n        var result = await _mediator Send(query, cancellationToken);\n        if (result == null) {\n            return NotFound();\n        }\n        return Ok(result);\n    }\n    [HttpGet(\"{orderId}/history\")]\n    public async Task<ActionResult<OrderHistory>> GetOrderHistory(\n        Guid orderId,\n        CancellationToken cancellationToken) {\n        // Get all events for this aggregate\n        var events = await _eventStore GetEvents(\n            $\"Order-{orderId}\",\n            cancellationToken\n        );\n        // Map events to history entries\n        var history = events Select(e => new HistoryEntry {\n            EventType = e GetType() Name,\n            OccurredAt = e OccurredAt,\n            Data = e,\n            Version = e Version\n        }) ToList();\n        return Ok(new OrderHistory {\n            OrderId = orderId,\n            Events = history,\n            CurrentVersion = events LastOrDefault() Version 0\n        });\n    }\n    [HttpGet(\"{orderId}/at/{timestamp}\")]\n    public async Task<ActionResult<OrderSnapshot>> GetOrderAtPointInTime(\n        Guid orderId,\n        DateTime timestamp,\n        CancellationToken cancellationToken) {\n        // Replay events up to specific point in time\n        var events = await _eventStore GetEvents(\n            $\"Order-{orderId}\",\n            upTo: timestamp,\n            cancellationToken\n        );\n        // Rebuild aggregate state at that point\n        var aggregate = new OrderAggregate();\n        aggregate LoadFromHistory(events);\n        return Ok(new OrderSnapshot {\n            OrderId = orderId,\n            AsOf = timestamp,\n            State = aggregate,\n            Version = events LastOrDefault() Version 0\n        });\n    }\n}\n`\nTesting Strategy\nTesting Aggregates\n`csharp{\ntitle: \"Aggregate Unit Tests\"\ndescription: \"Test aggregate behavior and event generation\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Unit Testing\", \"Aggregates\", \"Events\"]\nnugetPackages: [\"Whizbang",
        "startIndex": 14703,
        "preview": "OrdersController(IMediator mediator, IEventStore eventStore) { _mediator = mediator; _eventStore = eventStore; } [HttpPost] public async Task<ActionRe..."
      },
      {
        "id": "usage-patterns/event-sourcing-basics-chunk-8",
        "text": "OrderSnapshot { OrderId = orderId, AsOf = timestamp, State = aggregate, Version = events LastOrDefault() Version 0 }); } } ` Testing Strategy Testing Aggregates `csharp{ title: \"Aggregate Unit Tests\" description: \"Test aggregate behavior and event generation\" framework: \"NET8\" category: \"Testing\" difficulty: \"INTERMEDIATE\" tags: [\"Unit Testing\", \"Aggregates\", \"Events\"] nugetPackages: [\"Whizbang EventSourcing\", \"xUnit\"]\nfilename: \"OrderAggregateTests cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang EventSourcing\", \"Xunit\", \"System\"]\n}\nusing Whizbang EventSourcing;\nusing Xunit;\nusing System;\nusing System Collections Generic;\nusing System Linq;\nusing MyApp Orders Aggregates;\nusing MyApp Orders Events;\nnamespace MyApp Tests Orders;\npublic class OrderAggregateTests {\n    [Fact]\n    public void Constructor_ValidOrder_GeneratesOrderCreatedEvent() {\n        // Arrange\n        var orderId = Guid NewGuid();\n        var customerId = Guid NewGuid();\n        var items = new List<OrderItem> {\n            new OrderItem(\"PROD-1\", \"Widget\", 2, 10 00m)\n        };\n        // Act\n        var aggregate = new OrderAggregate(orderId, customerId, items, \"123 Main St\");\n        // Assert\n        var events = aggregate GetUncommittedEvents();\n        Assert Single(events);\n        var createdEvent = Assert IsType<OrderCreated>(events First());\n        Assert Equal(orderId, createdEvent OrderId);\n        Assert Equal(customerId, createdEvent CustomerId);\n        Assert Equal(20 00m, createdEvent TotalAmount);\n    }\n    [Fact]\n    public void Ship_ValidOrder_GeneratesOrderShippedEvent() {\n        // Arrange\n        var aggregate = CreateTestAggregate();\n        // Act\n        aggregate Ship(\"TRACK123\", \"FedEx\");\n        // Assert\n        var events = aggregate GetUncommittedEvents();\n        var shippedEvent = Assert IsType<OrderShipped>(events Last());\n        Assert Equal(\"TRACK123\", shippedEvent TrackingNumber);\n        Assert Equal(OrderStatus Shipped, aggregate Status);\n    }\n    [Fact]\n    public void Cancel_ShippedOrder_ThrowsException() {\n        // Arrange\n        var aggregate = CreateTestAggregate();\n        aggregate Ship(\"TRACK123\", \"FedEx\");\n        aggregate MarkEventsAsCommitted();\n        // Act & Assert\n        var exception = Assert Throws<DomainException>(\n            () => aggregate Cancel(\"Customer request\")\n        );\n        Assert Contains(\"Cannot cancel shipped order\", exception Message);\n    }\n    [Fact]\n    public void LoadFromHistory_RebuildsState() {\n        // Arrange\n        var orderId = Guid NewGuid();\n        var events = new List<DomainEvent> {\n            new OrderCreated(\n                orderId,\n                Guid NewGuid(),\n                new List<OrderItem> { new OrderItem(\"P1\", \"Widget\", 1, 10 00m) },\n                10 00m,\n                \"123 Main St\",\n                DateTime UtcNow\n            ),\n            new OrderItemAdded(\n                orderId,\n                new OrderItem(\"P2\", \"Gadget\", 2, 5 00m),\n                20",
        "startIndex": 17363,
        "preview": "OrderSnapshot { OrderId = orderId, AsOf = timestamp, State = aggregate, Version = events LastOrDefault() Version 0 }); } } ` Testing Strategy Testing ..."
      },
      {
        "id": "usage-patterns/event-sourcing-basics-chunk-9",
        "text": "public void LoadFromHistory_RebuildsState() { // Arrange var orderId = Guid NewGuid(); var events = new List<DomainEvent> { new OrderCreated( orderId, Guid NewGuid(), new List<OrderItem> { new OrderItem(\"P1\", \"Widget\", 1, 10 00m) }, 10 00m, \"123 Main St\", DateTime UtcNow ), new OrderItemAdded( orderId, new OrderItem(\"P2\", \"Gadget\", 2, 5 00m), 20 00m\n            ),\n            new OrderShipped(\n                orderId,\n                \"TRACK123\",\n                \"UPS\",\n                DateTime UtcNow\n            )\n        };\n        // Act\n        var aggregate = new OrderAggregate();\n        aggregate LoadFromHistory(events);\n        // Assert\n        Assert Equal(orderId, aggregate Id);\n        Assert Equal(2, aggregate Items Count);\n        Assert Equal(20 00m, aggregate TotalAmount);\n        Assert Equal(OrderStatus Shipped, aggregate Status);\n        Assert Equal(\"TRACK123\", aggregate TrackingNumber);\n    }\n    private OrderAggregate CreateTestAggregate() {\n        return new OrderAggregate(\n            Guid NewGuid(),\n            Guid NewGuid(),\n            new List<OrderItem> { new OrderItem(\"P1\", \"Widget\", 1, 10 00m) },\n            \"123 Main St\"\n        );\n    }\n}\n`\nCommon Pitfalls\nDon't Modify Events After Creation\n`csharp\n// ❌ BAD - Events are immutable\nvar @event = new OrderCreated( );\n@event TotalAmount = 100; // Compiler error - records are immutable\n// ✅ GOOD - Create new event with correct data\nvar @event = new OrderCreated( , TotalAmount: 100, );\n`\nAvoid Side Effects in Event Handlers\n`csharp\n// ❌ BAD - Side effects in When method\nprotected void When(OrderShipped @event) {\n    Status = OrderStatus Shipped;\n    EmailService SendNotification( ); // NO Side effects don't belong here\n}\n// ✅ GOOD - Pure state updates only\nprotected void When(OrderShipped @event) {\n    Status = OrderStatus Shipped;\n    TrackingNumber = @event TrackingNumber;\n}\n`\nDon't Query in Aggregates\n`csharp\n// ❌ BAD - Aggregate querying external data\npublic class OrderAggregate : Aggregate {\n    public async Task Ship() {\n        var inventory = await _inventoryService Check(); // NO Aggregates are pure\n    }\n}\n// ✅ GOOD - Pass data to aggregate methods\npublic void Ship(bool inventoryAvailable) {\n    if ( inventoryAvailable) {\n        throw new DomainException(\"Insufficient inventory\");\n    }\n    Apply(new OrderShipped(",
        "startIndex": 19973,
        "preview": "public void LoadFromHistory_RebuildsState() { // Arrange var orderId = Guid NewGuid(); var events = new List<DomainEvent> { new OrderCreated( orderId,..."
      },
      {
        "id": "usage-patterns/event-sourcing-basics-chunk-10",
        "text": "data public class OrderAggregate : Aggregate { public async Task Ship() { var inventory = await _inventoryService Check(); // NO Aggregates are pure } } // ✅ GOOD - Pass data to aggregate methods public void Ship(bool inventoryAvailable) { if ( inventoryAvailable) { throw new DomainException(\"Insufficient inventory\"); } Apply(new OrderShipped( ));\n}\n`\nProgressive Enhancement\nAdd Snapshots for Performance\n`csharp\n// Configure snapshot strategy\noptions EnableSnapshots(snapshot => {\n    snapshot Frequency = 10; // Every 10 events\n    snapshot Strategy = SnapshotStrategy Automatic;\n});\n// Implement snapshot interface\npublic class OrderAggregate : Aggregate, ISnapshotable {\n    public Snapshot TakeSnapshot() {\n        return new OrderSnapshot {\n            Id = Id,\n            CustomerId = CustomerId,\n            Items = Items ToList(),\n            Status = Status,\n            Version = Version\n        };\n    }\n    public void RestoreFromSnapshot(Snapshot snapshot) {\n        var orderSnapshot = (OrderSnapshot)snapshot;\n        Id = orderSnapshot Id;\n        CustomerId = orderSnapshot CustomerId;\n        Items = orderSnapshot Items;\n        Status = orderSnapshot Status;\n        Version = orderSnapshot Version;\n    }\n}\n`\nAdd Projections for Queries\nSee CQRS Implementation for detailed projection patterns Scale with Event Streams\n`csharp\n// Configure multiple streams\nconfig UseEventSourcing(options => {\n    options ConfigureStreams(streams => {\n        streams PartitionBy<OrderAggregate>(a => a CustomerId);\n        streams EnableParallelProcessing(maxDegree: 4);\n    });\n});\n`\nRelated Patterns\nSimple Mediator Pattern - Start without persistence\nCQRS Implementation - Optimize reads with projections\nSaga Orchestration - Coordinate multi-aggregate workflows\nProduction Considerations\nEvent Schema Evolution\n`csharp\n// Version your events\npublic record OrderCreatedV2(\n    // New fields",
        "startIndex": 21980,
        "preview": "data public class OrderAggregate : Aggregate { public async Task Ship() { var inventory = await _inventoryService Check(); // NO Aggregates are pure }..."
      },
      {
        "id": "usage-patterns/event-sourcing-basics-chunk-11",
        "text": "{ streams PartitionBy<OrderAggregate>(a => a CustomerId); streams EnableParallelProcessing(maxDegree: 4); }); }); ` Related Patterns Simple Mediator Pattern - Start without persistence CQRS Implementation - Optimize reads with projections Saga Orchestration - Coordinate multi-aggregate workflows Production Considerations Event Schema Evolution `csharp // Version your events public record OrderCreatedV2( // New fields ) : OrderEvent, IUpgradeFrom<OrderCreated> {\n    public OrderCreatedV2 UpgradeFrom(OrderCreated old) {\n        // Migration logic\n    }\n}\n`\nEvent Store Maintenance\nRegular backups of event store\nMonitor stream sizes\nArchive old events if needed\nIndex frequently queried streams\nPerformance Optimization\nUse snapshots for aggregates with many events\nImplement caching for frequently accessed aggregates\nConsider async projections for read models\nMonitor event replay times\nNext Steps\nLearn about CQRS Implementation for read model optimization\nExplore Saga Orchestration for complex workflows\nReview Aggregates Documentation for advanced patterns\nCheck out Projections for building read models",
        "startIndex": 23543,
        "preview": "{ streams PartitionBy<OrderAggregate>(a => a CustomerId); streams EnableParallelProcessing(maxDegree: 4); }); }); ` Related Patterns Simple Mediator P..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "usage-patterns/microservices-integration",
    "title": "Microservices Integration",
    "category": "Usage Patterns",
    "url": "/docs/usage-patterns/microservices-integration",
    "chunks": [
      {
        "id": "usage-patterns/microservices-integration-chunk-0",
        "text": "Microservices Integration\nOverview\nWhizbang provides first-class support for building microservices with NET Aspire, Microsoft's opinionated stack for cloud-native applications This pattern shows how to structure, deploy, and operate Whizbang-based microservices in production Key Components\nService Boundaries: Define bounded contexts and aggregates NET Aspire Integration: Orchestration and observability\nService Discovery: Automatic service registration and discovery\nHealth Monitoring: Liveness and readiness probes\nDistributed Tracing: End-to-end request tracking\nArchitecture Diagram\n`mermaid\ngraph TB\n    subgraph \"API Gateway\"\n        GW[Gateway]\n    end\n    subgraph \"Order Service\"\n        OS[Order API]\n        OE[(Event Store)]\n        OP[Projections]\n    end\n    subgraph \"Inventory Service\"\n        IS[Inventory API]\n        IE[(Event Store)]\n        IP[Projections]\n    end\n    subgraph \"Payment Service\"\n        PS[Payment API]\n        PE[(Event Store)]\n        PP[Projections]\n    end\n    subgraph \"Infrastructure\"\n        SD[Service Discovery]\n        MB[Message Broker]\n        TR[Tracing]\n    end\n    GW --> OS\n    GW --> IS\n    GW --> PS\n    OS - -> MB\n    IS - -> MB\n    PS - -> MB\n    OS --> SD\n    IS --> SD\n    PS --> SD\n    style MB fill:#0066cc,color:#fff\n    style SD fill:#28a745,color:#fff\n`\nImplementation Guide\nDocumentation in progress - This page demonstrates the structure for microservices integration patterns with Whizbang Topics to Cover:\nService Design\nBounded context definition\nAPI contracts\nEvent contracts\nShared kernels NET Aspire Setup\nApp host configuration\nService registration\nResource provisioning\nEnvironment configuration\nService Communication\nSynchronous HTTP calls\nAsynchronous messaging\ngRPC integration\nCircuit breakers\nData Management\nDatabase per service\nEvent store partitioning\nCross-service queries\nData consistency\nDeployment Strategies\nKubernetes deployment\nContainer orchestration\nBlue-green deployments\nCanary releases\nExample: Aspire Configuration\n`csharp\n// Placeholder for Aspire app host configuration\nvar builder = DistributedApplication",
        "startIndex": 0,
        "preview": "Microservices Integration\nOverview\nWhizbang provides first-class support for building microservices with NET Aspire, Microsoft's opinionated stack for..."
      },
      {
        "id": "usage-patterns/microservices-integration-chunk-1",
        "text": "Environment configuration Service Communication Synchronous HTTP calls Asynchronous messaging gRPC integration Circuit breakers Data Management Database per service Event store partitioning Cross-service queries Data consistency Deployment Strategies Kubernetes deployment Container orchestration Blue-green deployments Canary releases Example: Aspire Configuration `csharp // Placeholder for Aspire app host configuration var builder = DistributedApplication CreateBuilder(args);\n// Service configuration coming soon\n`\nRelated Patterns\nDistributed Messaging - Service communication patterns\nSaga Orchestration - Multi-service workflows\nEvent Sourcing Basics - Service data patterns\nProduction Considerations\nObservability\nDistributed tracing with OpenTelemetry\nCentralized logging with structured logs\nMetrics aggregation and alerting\nService dependency mapping\nResilience\nCircuit breaker patterns\nRetry policies with exponential backoff\nBulkhead isolation\nTimeout configuration\nSecurity\nService-to-service authentication\nAPI gateway security\nSecret management\nNetwork policies\nNext Steps\nReview NET Aspire Integration for setup details\nExplore Advanced Configuration for production settings\nCheck Dashboard Documentation for monitoring",
        "startIndex": 2114,
        "preview": "Environment configuration Service Communication Synchronous HTTP calls Asynchronous messaging gRPC integration Circuit breakers Data Management Databa..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "usage-patterns/policy-composition",
    "title": "Policy Composition",
    "category": "Usage Patterns",
    "url": "/docs/usage-patterns/policy-composition",
    "chunks": [
      {
        "id": "usage-patterns/policy-composition-chunk-0",
        "text": "Policy Composition\nOverview\nPolicy Composition in Whizbang allows you to build resilient applications by combining multiple policies like retry, circuit breaker, timeout, and fallback Inspired by Polly's approach but integrated seamlessly with our aspect-oriented architecture Core Concepts\nPolicies as Aspects\nIn Whizbang, resilience policies are first-class aspects that can be composed declaratively:\n`csharp{\ntitle: \"Declarative Policy Composition\"\ndescription: \"Combine multiple resilience policies via attributes\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Policies\", \"Resilience\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"ResilientHandler cs\"\nshowLineNumbers: true\nhighlightLines: [1, 2, 3, 4]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[Retry(3, Backoff = \"exponential\", DelayMs = 100)]\n[CircuitBreaker(Threshold = 5, Duration = \"30s\")]\n[Timeout(Seconds = 10)]\n[Fallback(typeof(OrderFallbackHandler))]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd, IOrderService service) {\n        // This handler is automatically wrapped with:\n        // 1 Exponential backoff retry (3 attempts)\n        // 2 Circuit breaker (opens after 5 failures)\n        // 3 10-second timeout\n        // 4 Fallback handler if all else fails\n        var order = service CreateOrder(cmd);\n        return new OrderCreated(order Id);\n    }\n}\n`\nBasic Policies\nRetry Policy\n`csharp{\ntitle: \"Retry Policy Examples\"\ndescription: \"Different retry strategies for various scenarios\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"BEGINNER\"\ntags: [\"Retry\", \"Resilience\", \"Error Handling\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"RetryExamples cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Simple retry with fixed delay\n[Retry(3, DelayMs = 1000)]\npublic class SimpleRetryHandler : IHandle<ProcessPayment> {\n    public PaymentProcessed Handle(ProcessPayment cmd) {\n        return paymentGateway Process(cmd);\n    }\n}\n// Exponential backoff\n[Retry(5, Backoff = \"exponential\", DelayMs = 100, MaxDelayMs = 10000)]\npublic class ExponentialRetryHandler : IHandle<CallExternalApi> {\n    // Delays: 100ms, 200ms, 400ms, 800ms, 1600ms\n    public ApiResponse Handle(CallExternalApi cmd) {\n        return externalApi",
        "startIndex": 0,
        "preview": "Policy Composition\nOverview\nPolicy Composition in Whizbang allows you to build resilient applications by combining multiple policies like retry, circu..."
      },
      {
        "id": "usage-patterns/policy-composition-chunk-1",
        "text": "1000)] public class SimpleRetryHandler : IHandle<ProcessPayment> { public PaymentProcessed Handle(ProcessPayment cmd) { return paymentGateway Process(cmd); } } // Exponential backoff [Retry(5, Backoff = \"exponential\", DelayMs = 100, MaxDelayMs = 10000)] public class ExponentialRetryHandler : IHandle<CallExternalApi> { // Delays: 100ms, 200ms, 400ms, 800ms, 1600ms public ApiResponse Handle(CallExternalApi cmd) { return externalApi Call(cmd);\n    }\n}\n// Retry only specific exceptions\n[Retry(3, \n    RetryOn = new[] { typeof(TransientException), typeof(TimeoutException) },\n    SkipOn = new[] { typeof(ValidationException) }\n)]\npublic class SelectiveRetryHandler : IHandle<UpdateInventory> {\n    public InventoryUpdated Handle(UpdateInventory cmd) {\n        return inventory Update(cmd);\n    }\n}\n// Retry with jitter to prevent thundering herd\n[Retry(3, Backoff = \"exponential-jitter\", DelayMs = 100)]\npublic class JitteredRetryHandler : IHandle<BulkOperation> {\n    // Adds randomization to prevent synchronized retries\n    public BulkResult Handle(BulkOperation cmd) {\n        return bulkService Process(cmd);\n    }\n}\n`\nCircuit Breaker\n`csharp{\ntitle: \"Circuit Breaker Policy\"\ndescription: \"Prevent cascading failures with circuit breaker pattern\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Circuit Breaker\", \"Resilience\", \"Fault Tolerance\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"CircuitBreakerExamples cs\"\nshowLineNumbers: true\nhighlightLines: [1, 15, 29]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Basic circuit breaker\n[CircuitBreaker(\n    Threshold = 5,           // Open after 5 failures\n    Duration = \"30s\",        // Stay open for 30 seconds\n    SuccessesRequired = 2    // Need 2 successes to close\n)]\npublic class ProtectedHandler : IHandle<CallDownstreamService> {\n    public ServiceResponse Handle(CallDownstreamService cmd) {\n        return downstreamService Call(cmd);\n    }\n}\n// Advanced circuit breaker with sampling\n[CircuitBreaker(\n    SamplingDuration = \"10s\",     // Sample over 10 seconds\n    FailureRate = 0 5,            // Open if 50% of calls fail\n    MinimumThroughput = 10,       // Need at least 10 calls in window\n    Duration = \"60s\"               // Stay open for 60 seconds\n)]\npublic class AdvancedCircuitHandler : IHandle<HighVolumeOperation> {\n    public OperationResult Handle(HighVolumeOperation cmd) {\n        return highVolumeService",
        "startIndex": 2314,
        "preview": "1000)] public class SimpleRetryHandler : IHandle<ProcessPayment> { public PaymentProcessed Handle(ProcessPayment cmd) { return paymentGateway Process(..."
      },
      {
        "id": "usage-patterns/policy-composition-chunk-2",
        "text": "// Sample over 10 seconds FailureRate = 0 5, // Open if 50% of calls fail MinimumThroughput = 10, // Need at least 10 calls in window Duration = \"60s\" // Stay open for 60 seconds )] public class AdvancedCircuitHandler : IHandle<HighVolumeOperation> { public OperationResult Handle(HighVolumeOperation cmd) { return highVolumeService Execute(cmd);\n    }\n}\n// Circuit breaker with custom break condition\n[CircuitBreaker(\n    BreakOn = result => result is ErrorResult { Code: \"CRITICAL\" },\n    Duration = \"120s\"\n)]\npublic class CustomBreakHandler : IHandle<CriticalOperation> {\n    public Result<OperationSuccess> Handle(CriticalOperation cmd) {\n        return criticalService Execute(cmd);\n    }\n}\n`\nTimeout Policy\n`csharp{\ntitle: \"Timeout Policy\"\ndescription: \"Prevent operations from running indefinitely\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"BEGINNER\"\ntags: [\"Timeout\", \"Resilience\", \"Performance\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"TimeoutExamples cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\", \"System Threading\"]\n}\n// Simple timeout\n[Timeout(Seconds = 5)]\npublic class TimeoutHandler : IHandle<LongRunningQuery> {\n    public QueryResult Handle(LongRunningQuery query) {\n        return database ExecuteComplexQuery(query);\n    }\n}\n// Pessimistic timeout (cancels the operation)\n[Timeout(Seconds = 10, Mode = \"pessimistic\")]\npublic class PessimisticTimeoutHandler : IHandle<CancellableOperation> {\n    public async Task<Result> Handle(CancellableOperation cmd, CancellationToken ct) {\n        // Operation receives cancellation token\n        return await longService ExecuteAsync(cmd, ct);\n    }\n}\n// Optimistic timeout (just gives up waiting)\n[Timeout(Seconds = 3, Mode = \"optimistic\")]\npublic class OptimisticTimeoutHandler : IHandle<FireAndForget> {\n    public void Handle(FireAndForget cmd) {\n        // We stop waiting after 3 seconds, but operation continues\n        backgroundService Process(cmd);\n    }\n}\n`\nFallback Policy\n`csharp{\ntitle: \"Fallback Policy\"\ndescription: \"Provide alternative results when primary operation fails\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Fallback\", \"Resilience\", \"Error Recovery\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"FallbackExamples cs\"\nshowLineNumbers: true\nhighlightLines: [1, 12, 23]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Fallback to another handler\n[Fallback(typeof(CachedDataHandler))]\npublic class LiveDataHandler : IHandle<GetProductData> {\n    public ProductData Handle(GetProductData query) {\n        return liveService GetProduct(query",
        "startIndex": 4297,
        "preview": "// Sample over 10 seconds FailureRate = 0 5, // Open if 50% of calls fail MinimumThroughput = 10, // Need at least 10 calls in window Duration = \"60s\"..."
      },
      {
        "id": "usage-patterns/policy-composition-chunk-3",
        "text": "primary operation fails\" framework: \"NET8\" category: \"Resilience\" difficulty: \"INTERMEDIATE\" tags: [\"Fallback\", \"Resilience\", \"Error Recovery\"] nugetPackages: [\"Whizbang Core\"] filename: \"FallbackExamples cs\" showLineNumbers: true highlightLines: [1, 12, 23] usingStatements: [\"Whizbang\", \"System\"] } // Fallback to another handler [Fallback(typeof(CachedDataHandler))] public class LiveDataHandler : IHandle<GetProductData> { public ProductData Handle(GetProductData query) { return liveService GetProduct(query ProductId);\n    }\n}\n// Fallback with inline value\n[Fallback(Value = \"DefaultResponse\")]\npublic class ServiceHandler : IHandle<GetConfiguration> {\n    public string Handle(GetConfiguration query) {\n        return configService Get(query Key);\n    }\n}\n// Fallback with factory method\n[Fallback(Factory = nameof(CreateDefaultOrder))]\npublic class OrderHandler : IHandle<GetOrder> {\n    public Order Handle(GetOrder query) {\n        return orderService Get(query OrderId);\n    }\n    private Order CreateDefaultOrder(GetOrder query) {\n        return new Order { \n            Id = query OrderId, \n            Status = \"Unknown\",\n            Items = new List<OrderItem>()\n        };\n    }\n}\n`\nAdvanced Composition\nPolicy Wrapping\n`csharp{\ntitle: \"Advanced Policy Composition\"\ndescription: \"Combine multiple policies for comprehensive resilience\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"ADVANCED\"\ntags: [\"Policy Composition\", \"Resilience\", \"Advanced\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"AdvancedComposition cs\"\nshowLineNumbers: true\nhighlightLines: [1, 2, 3, 4, 5]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Policies execute in order: Retry -> CircuitBreaker -> Timeout -> Fallback\n[Retry(3, Backoff = \"exponential\")]\n[CircuitBreaker(Threshold = 10, Duration = \"60s\")]\n[Timeout(Seconds = 5)]\n[Fallback(typeof(CachedInventoryHandler))]\n[Logged(OnError = true)]\npublic class ResilientInventoryHandler : IHandle<CheckInventory> {\n    public InventoryStatus Handle(CheckInventory query) {\n        // Execution flow:\n        // 1 Timeout wraps the actual call\n        // 2 Circuit breaker tracks failures\n        // 3 Retry handles transient failures\n        // 4 Fallback provides last resort\n        // 5 Everything is logged\n        return inventoryService Check(query);\n    }\n}\n// Conditional policies based on context\n[ConditionalPolicy(typeof(PeakHoursPolicy), Condition = nameof(IsPeakHours))]\n[ConditionalPolicy(typeof(StandardPolicy), Condition = nameof(IsStandardHours))]\npublic class AdaptiveHandler : IHandle<ProcessOrder> {\n    public OrderProcessed Handle(ProcessOrder cmd) {\n        return orderProcessor Process(cmd);\n    }\n    private bool IsPeakHours() => DateTime Now Hour >= 9 && DateTime Now Hour <= 17;\n    private bool IsStandardHours() =>",
        "startIndex": 6549,
        "preview": "primary operation fails\" framework: \"NET8\" category: \"Resilience\" difficulty: \"INTERMEDIATE\" tags: [\"Fallback\", \"Resilience\", \"Error Recovery\"] nugetP..."
      },
      {
        "id": "usage-patterns/policy-composition-chunk-4",
        "text": "} } // Conditional policies based on context [ConditionalPolicy(typeof(PeakHoursPolicy), Condition = nameof(IsPeakHours))] [ConditionalPolicy(typeof(StandardPolicy), Condition = nameof(IsStandardHours))] public class AdaptiveHandler : IHandle<ProcessOrder> { public OrderProcessed Handle(ProcessOrder cmd) { return orderProcessor Process(cmd); } private bool IsPeakHours() => DateTime Now Hour >= 9 && DateTime Now Hour <= 17; private bool IsStandardHours() => IsPeakHours();\n}\n`\nBulkhead Isolation\n`csharp{\ntitle: \"Bulkhead Pattern\"\ndescription: \"Isolate resources to prevent total system failure\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"ADVANCED\"\ntags: [\"Bulkhead\", \"Isolation\", \"Resilience\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"BulkheadExamples cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Limit concurrent executions\n[Bulkhead(\n    MaxConcurrency = 10,\n    MaxQueueLength = 100\n)]\npublic class ThrottledHandler : IHandle<HighLoadOperation> {\n    public Result Handle(HighLoadOperation cmd) {\n        // Only 10 concurrent executions allowed\n        // Up to 100 can queue, rest rejected immediately\n        return service Execute(cmd);\n    }\n}\n// Separate bulkheads for different operations\n[Bulkhead(Name = \"critical\", MaxConcurrency = 20)]\npublic class CriticalHandler : IHandle<CriticalOperation> {\n    public Result Handle(CriticalOperation cmd) {\n        return criticalService Execute(cmd);\n    }\n}\n[Bulkhead(Name = \"standard\", MaxConcurrency = 5)]\npublic class StandardHandler : IHandle<StandardOperation> {\n    public Result Handle(StandardOperation cmd) {\n        return standardService Execute(cmd);\n    }\n}\n`\nRate Limiting\n`csharp{\ntitle: \"Rate Limiting\"\ndescription: \"Control the rate of operations to prevent overload\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Rate Limiting\", \"Throttling\", \"Resilience\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"RateLimitExamples cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Fixed window rate limiting\n[RateLimit(\n    Permits = 100,\n    Window = \"1m\"  // 100 requests per minute\n)]\npublic class RateLimitedHandler : IHandle<ApiCall> {\n    public ApiResponse Handle(ApiCall cmd) {\n        return api Call(cmd);\n    }\n}\n// Sliding window rate limiting\n[RateLimit(\n    Permits = 1000,\n    Window = \"1h\",\n    Mode = \"sliding\"\n)]\npublic class SlidingWindowHandler : IHandle<BulkOperation> {\n    public BulkResult Handle(BulkOperation cmd) {\n        return bulkService",
        "startIndex": 8830,
        "preview": "} } // Conditional policies based on context [ConditionalPolicy(typeof(PeakHoursPolicy), Condition = nameof(IsPeakHours))] [ConditionalPolicy(typeof(S..."
      },
      {
        "id": "usage-patterns/policy-composition-chunk-5",
        "text": "100 requests per minute )] public class RateLimitedHandler : IHandle<ApiCall> { public ApiResponse Handle(ApiCall cmd) { return api Call(cmd); } } // Sliding window rate limiting [RateLimit( Permits = 1000, Window = \"1h\", Mode = \"sliding\" )] public class SlidingWindowHandler : IHandle<BulkOperation> { public BulkResult Handle(BulkOperation cmd) { return bulkService Process(cmd);\n    }\n}\n// Token bucket rate limiting\n[RateLimit(\n    Mode = \"token-bucket\",\n    Capacity = 100,\n    RefillRate = 10,      // 10 tokens per second\n    RefillInterval = \"1s\"\n)]\npublic class TokenBucketHandler : IHandle<StreamingOperation> {\n    public StreamResult Handle(StreamingOperation cmd) {\n        return streamService Process(cmd);\n    }\n}\n`\nCustom Policies\nCreating Custom Policies\n`csharp{\ntitle: \"Custom Policy Implementation\"\ndescription: \"Build your own resilience policies\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"ADVANCED\"\ntags: [\"Custom Policies\", \"Extensibility\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"CustomPolicyExamples cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Define custom policy attribute\n[AttributeUsage(AttributeTargets Class | AttributeTargets Method)]\npublic class CacheAsideAttribute : PolicyAttribute {\n    public int DurationSeconds { get; set; } = 300;\n    public string CacheKey { get; set; }\n    public override IPolicy CreatePolicy() {\n        return new CacheAsidePolicy(DurationSeconds, CacheKey);\n    }\n}\n// Implement the policy\npublic class CacheAsidePolicy : IPolicy {\n    private readonly int _durationSeconds;\n    private readonly string _cacheKey;\n    public async Task<T> ExecuteAsync<T>(\n        Func<Task<T>> action,\n        PolicyContext context) {\n        // Try cache first\n        var cached = await cache GetAsync<T>(_cacheKey);\n        if (cached = null) {\n            return cached;\n        }\n        // Execute action\n        var result = await action();\n        // Cache result\n        await cache SetAsync(_cacheKey, result, _durationSeconds);\n        return result;\n    }\n}\n// Use custom policy\n[CacheAside(DurationSeconds = 600, CacheKey = \"products\")]\npublic class ProductHandler : IHandle<GetProducts> {\n    public Products Handle(GetProducts query) {\n        return productService GetAll();\n    }\n}\n`\nPolicy Context and Telemetry\n`csharp{\ntitle: \"Policy Context and Observability\"\ndescription: \"Track and monitor policy execution\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"ADVANCED\"\ntags: [\"Telemetry\", \"Monitoring\", \"Context\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"PolicyTelemetry",
        "startIndex": 10894,
        "preview": "100 requests per minute )] public class RateLimitedHandler : IHandle<ApiCall> { public ApiResponse Handle(ApiCall cmd) { return api Call(cmd); } } // ..."
      },
      {
        "id": "usage-patterns/policy-composition-chunk-6",
        "text": "= \"products\")] public class ProductHandler : IHandle<GetProducts> { public Products Handle(GetProducts query) { return productService GetAll(); } } ` Policy Context and Telemetry `csharp{ title: \"Policy Context and Observability\" description: \"Track and monitor policy execution\" framework: \"NET8\" category: \"Resilience\" difficulty: \"ADVANCED\" tags: [\"Telemetry\", \"Monitoring\", \"Context\"] nugetPackages: [\"Whizbang Core\"] filename: \"PolicyTelemetry cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Policy with detailed telemetry\n[Retry(3, \n    OnRetry = nameof(LogRetry),\n    OnSuccess = nameof(LogSuccess),\n    OnFailure = nameof(LogFailure)\n)]\npublic class ObservableHandler : IHandle<CriticalOperation> {\n    private readonly ILogger _logger;\n    private readonly IMetrics _metrics;\n    public Result Handle(CriticalOperation cmd) {\n        return service Execute(cmd);\n    }\n    private void LogRetry(RetryContext context) {\n        _logger Warning(\"Retry {Attempt} after {Delay}ms: {Error}\",\n            context AttemptNumber,\n            context Delay TotalMilliseconds,\n            context LastException Message);\n        _metrics Increment(\"handler retries\", \n            tags: new { handler = nameof(ObservableHandler) });\n    }\n    private void LogSuccess(PolicyContext context) {\n        _logger Information(\"Operation succeeded after {Attempts} attempts\",\n            context Attempts);\n        _metrics RecordDuration(\"handler duration\", \n            context Duration,\n            tags: new { status = \"success\" });\n    }\n    private void LogFailure(PolicyContext context) {\n        _logger Error(\"Operation failed after {Attempts} attempts: {Error}\",\n            context Attempts,\n            context LastException Message);\n        _metrics Increment(\"handler failures\",\n            tags: new { handler = nameof(ObservableHandler) });\n    }\n}\n`\nTesting Policies\n`csharp{\ntitle: \"Testing Resilience Policies\"\ndescription: \"Verify policy behavior under various failure scenarios\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Testing\", \"Resilience\", \"Policies\"]\nnugetPackages: [\"Whizbang Core\", \"xUnit\"]\nfilename: \"PolicyTests cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang Testing\", \"Xunit\"]\n}\n[Fact]\npublic async Task RetryPolicy_RetriesOnTransientFailure() {\n    // Arrange\n    var test = await Whizbang Test<OrderHandler>() WithPolicy<RetryPolicy>() SimulateFailures(2)  // Fail twice, then succeed Given(new CreateOrder { });\n    // Act\n    var result = await test WhenHandled();\n    // Assert\n    result Should() BeSuccess();\n    test Policy<RetryPolicy>() Should() HaveRetried(2) WithDelays(\"100ms\", \"200ms\");\n}\n[Fact]\npublic async Task CircuitBreaker_OpensAfterThreshold() {\n    // Arrange\n    var test = await Whizbang Test<ServiceHandler>() WithPolicy<CircuitBreakerPolicy>();\n    // Act - Trigger failures\n    for (int i = 0; i < 5; i++) {\n        await test SimulateFailure()",
        "startIndex": 13119,
        "preview": "= \"products\")] public class ProductHandler : IHandle<GetProducts> { public Products Handle(GetProducts query) { return productService GetAll(); } } ` ..."
      },
      {
        "id": "usage-patterns/policy-composition-chunk-7",
        "text": "result = await test WhenHandled(); // Assert result Should() BeSuccess(); test Policy<RetryPolicy>() Should() HaveRetried(2) WithDelays(\"100ms\", \"200ms\"); } [Fact] public async Task CircuitBreaker_OpensAfterThreshold() { // Arrange var test = await Whizbang Test<ServiceHandler>() WithPolicy<CircuitBreakerPolicy>(); // Act - Trigger failures for (int i = 0; i < 5; i++) { await test SimulateFailure() WhenHandled(new CallService { });\n    }\n    // Assert - Circuit should be open\n    test Policy<CircuitBreakerPolicy>() Should() BeOpen() For(\"30s\");\n    // Further calls should fail immediately\n    await test WhenHandled(new CallService { }) Should() FailImmediately() WithException<CircuitBreakerOpenException>();\n}\n[Fact]\npublic async Task Fallback_ProvidesAlternativeValue() {\n    // Arrange\n    var test = await Whizbang Test<DataHandler>() WithPolicy<FallbackPolicy>() SimulateFailure();\n    // Act\n    var result = await test WhenHandled(new GetData { });\n    // Assert\n    result Should() BeFromFallback();\n    test Policy<FallbackPolicy>() Should() HaveExecutedFallback() WithValue(\"DefaultData\");\n}\n`\nBest Practices\nDo's\n✅ Layer policies appropriately\n`csharp\n[Retry(3)]           // Inner - handles transient failures\n[CircuitBreaker(5)]  // Middle - prevents cascading failures\n[Timeout(10)]        // Outer - ensures bounded execution time\n`\n✅ Use specific exception handling\n`csharp\n[Retry(3, RetryOn = new[] { typeof(TransientException) })]\n`\n✅ Monitor and log policy actions\n`csharp\n[Retry(3, OnRetry = nameof(LogRetry))]\n`\n✅ Test failure scenarios\n`csharp\nawait test SimulateFailures(3) WhenHandled();\n`\nDon'ts\n❌ Don't retry non-idempotent operations\n`csharp\n// Bad: Payment might be charged multiple times\n[Retry(3)]\npublic PaymentCharged ChargePayment(ChargeCard cmd)\n`\n❌ Don't set timeouts shorter than retries\n`csharp\n// Bad: Timeout will trigger before retries complete\n[Retry(3, DelayMs = 5000)]\n[Timeout(Seconds = 10)]\n`\n❌ Don't ignore circuit breaker state\n`csharp\n// Bad: No monitoring of circuit breaker health\n[CircuitBreaker(5)]\n// Should add telemetry to track circuit state\n`\nReal-World Examples\nE-Commerce Order Processing\n`csharp{\ntitle: \"E-Commerce Resilience Pattern\"\ndescription: \"Complete resilience strategy for order processing\"\nframework: \"NET8\"\ncategory: \"Real World\"\ndifficulty: \"ADVANCED\"\ntags: [\"E-Commerce\", \"Order Processing\", \"Resilience\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"ECommerceResilience",
        "startIndex": 15700,
        "preview": "result = await test WhenHandled(); // Assert result Should() BeSuccess(); test Policy<RetryPolicy>() Should() HaveRetried(2) WithDelays(\"100ms\", \"200m..."
      },
      {
        "id": "usage-patterns/policy-composition-chunk-8",
        "text": "No monitoring of circuit breaker health [CircuitBreaker(5)] // Should add telemetry to track circuit state ` Real-World Examples E-Commerce Order Processing `csharp{ title: \"E-Commerce Resilience Pattern\" description: \"Complete resilience strategy for order processing\" framework: \"NET8\" category: \"Real World\" difficulty: \"ADVANCED\" tags: [\"E-Commerce\", \"Order Processing\", \"Resilience\"] nugetPackages: [\"Whizbang Core\"] filename: \"ECommerceResilience cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Payment processing with comprehensive resilience\n[Retry(3, Backoff = \"exponential\", DelayMs = 1000)]\n[CircuitBreaker(Threshold = 10, Duration = \"60s\")]\n[Timeout(Seconds = 30)]\n[Fallback(typeof(QueuePaymentForManualProcessing))]\n[Logged]\n[Metered]\npublic class PaymentProcessor : IHandle<ProcessPayment> {\n    public PaymentProcessed Handle(ProcessPayment cmd, IPaymentGateway gateway) {\n        // This is protected by:\n        // - 3 retries with exponential backoff\n        // - Circuit breaker to prevent hammering failed gateway\n        // - 30 second timeout to prevent hanging\n        // - Fallback to queue for manual processing\n        // - Full logging and metrics\n        var result = gateway ChargeCard(\n            cmd CardNumber,\n            cmd Amount,\n            cmd Currency\n        );\n        return new PaymentProcessed(result TransactionId, result Status);\n    }\n}\n// Inventory check with caching fallback\n[CircuitBreaker(FailureRate = 0 5, SamplingDuration = \"30s\")]\n[Timeout(Seconds = 5)]\n[Fallback(typeof(CachedInventoryChecker))]\npublic class LiveInventoryChecker : IHandle<CheckInventory> {\n    public InventoryStatus Handle(CheckInventory query) {\n        return inventoryService GetRealTimeStatus(query ProductIds);\n    }\n}\n// Order fulfillment saga with resilience\n[Saga]\n[Retry(5, Backoff = \"linear\", DelayMs = 2000)]\n[Timeout(Seconds = 120)]\npublic class OrderFulfillmentSaga : IHandle<OrderPlaced> {\n    public async Task<SagaResult> Handle(OrderPlaced @event) {\n        // Each step has its own resilience policies\n        await Send(new ReserveInventory(@event OrderId)) WithRetry(3) WithTimeout(10);\n        await Send(new ProcessPayment(@event OrderId)) WithRetry(5) WithCircuitBreaker() WithFallback(new QueuePayment(@event OrderId));\n        await Send(new ShipOrder(@event OrderId)) WithRetry(3) WithTimeout(30);\n        return SagaResult Completed();\n    }\n}\n`\nNext Steps\nLearn about Aspect-Oriented Handlers for more aspects\nExplore Testing Strategies for policy testing\nReview Distributed Messaging for cross-service resilience\nSee Production Deployment for monitoring setup",
        "startIndex": 17834,
        "preview": "No monitoring of circuit breaker health [CircuitBreaker(5)] // Should add telemetry to track circuit state ` Real-World Examples E-Commerce Order Proc..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "usage-patterns/progressive-enhancement",
    "title": "Progressive Enhancement",
    "category": "Usage Patterns",
    "url": "/docs/usage-patterns/progressive-enhancement",
    "chunks": [
      {
        "id": "usage-patterns/progressive-enhancement-chunk-0",
        "text": "Progressive Enhancement\nOverview\nProgressive Enhancement is Whizbang's superpower - the ability to evolve your application from a simple monolith to a distributed, event-sourced system without changing your handler code This pattern allows you to start simple and add complexity only when needed, maintaining the same business logic throughout your application's growth The Journey\n`mermaid\ngraph LR\n    A[In-Process<br/>Development] --> B[Durable<br/>Single Service]\n    B --> C[Distributed<br/>Microservices]\n    C --> D[Event-Sourced<br/>CQRS/ES]\n    style A fill:#28a745,color:#fff\n    style B fill:#17a2b8,color:#fff\n    style C fill:#ffc107,color:#000\n    style D fill:#dc3545,color:#fff\n`\nThe Same Handler, Every Mode\nThis is the key insight - one handler implementation works across all modes:\n`csharp{\ntitle: \"Universal Handler\"\ndescription: \"This exact handler works in ALL deployment modes\"\nframework: \"NET8\"\ncategory: \"Core Concept\"\ndifficulty: \"BEGINNER\"\ntags: [\"Handler\", \"Universal\", \"Progressive Enhancement\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"OrderHandler cs\"\nshowLineNumbers: true\nhighlightLines: [1, 2, 3]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[Logged]\n[Validated]\n[Transactional]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd, IOrderRepository repository) {\n        // This EXACT code works in:\n        // ✅ Local development (in-process)\n        // ✅ Production monolith (durable)\n        // ✅ Microservices (distributed)\n        // ✅ Event-sourced system (CQRS/ES)\n        var order = new Order {\n            Id = Guid NewGuid(),\n            CustomerId = cmd CustomerId,\n            Items = cmd Items,\n            Total = cmd Items Sum(i => i Quantity * i Price),\n            Status = OrderStatus Pending,\n            CreatedAt = DateTime UtcNow\n        };\n        repository Save(order);\n        return new OrderCreated(\n            order Id,\n            order CustomerId,\n            order Total,\n            order CreatedAt\n        );\n    }\n}\n`\nMode 1: In-Process (Development)\nConfiguration\n`csharp{\ntitle: \"In-Process Mode Configuration\"\ndescription: \"Perfect for development and testing - zero infrastructure\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"BEGINNER\"\ntags: [\"In-Process\", \"Development\", \"Configuration\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"Program InProcess cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Program cs - Development mode\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbang() UseInProcessMode()  // Everything runs in-memory RegisterHandlersFromAssembly(typeof(Program)",
        "startIndex": 0,
        "preview": "Progressive Enhancement\nOverview\nProgressive Enhancement is Whizbang's superpower - the ability to evolve your application from a simple monolith to a..."
      },
      {
        "id": "usage-patterns/progressive-enhancement-chunk-1",
        "text": "and testing - zero infrastructure\" framework: \"NET8\" category: \"Configuration\" difficulty: \"BEGINNER\" tags: [\"In-Process\", \"Development\", \"Configuration\"] nugetPackages: [\"Whizbang Core\"] filename: \"Program InProcess cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"] } // Program cs - Development mode var builder = WebApplication CreateBuilder(args); builder Services AddWhizbang() UseInProcessMode() // Everything runs in-memory RegisterHandlersFromAssembly(typeof(Program) Assembly);\n// No database required for development\nbuilder Services AddSingleton<IOrderRepository, InMemoryOrderRepository>();\nvar app = builder Build();\napp MapPost(\"/orders\", async (CreateOrder cmd, IWhizbang whizbang) => {\n    // Executes immediately, synchronously\n    var result = await whizbang Send(cmd);\n    return Results Ok(result);\n});\napp Run();\n`\nCharacteristics\n`csharp{\ntitle: \"In-Process Mode Behavior\"\ndescription: \"How handlers execute in development mode\"\nframework: \"NET8\"\ncategory: \"Behavior\"\ndifficulty: \"BEGINNER\"\ntags: [\"In-Process\", \"Execution\", \"Development\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"InProcessBehavior cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System Diagnostics\"]\n}\npublic class InProcessExample {\n    public async Task DemonstrateInProcess(IWhizbang whizbang) {\n        var stopwatch = Stopwatch StartNew();\n        // Immediate, synchronous execution\n        var result = await whizbang Send(new CreateOrder {\n            CustomerId = Guid NewGuid(),\n            Items = new[] { new OrderItem(\"SKU-1\", 2, 10 00m) }\n        });\n        // Handler executed in same thread\n        Console WriteLine($\"Thread: {Thread CurrentThread ManagedThreadId}\");\n        Console WriteLine($\"Duration: {stopwatch ElapsedMilliseconds}ms\");\n        // Output: Thread: 1, Duration: 5ms\n        // Events published synchronously\n        // All subscribers notified immediately\n        // No persistence, no retries\n    }\n}\n// Testing is simple\n[Fact]\npublic async Task InProcessMode_ExecutesImmediately() {\n    var whizbang = new WhizbangBuilder() UseInProcessMode() Build();\n    var result = await whizbang Send(new CreateOrder());\n    Assert NotNull(result);\n    Assert IsType<OrderCreated>(result);\n}\n`\nWhen to Use\nLocal development - Fast feedback loop\nUnit testing - No infrastructure dependencies\nPrototyping - Rapid iteration\nSimple applications - When you don't need durability\nMode 2: Durable (Single Service)\nConfiguration\n`csharp{\ntitle: \"Durable Mode Configuration\"\ndescription: \"Add persistence and retry capabilities to your monolith\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Durable\", \"Persistence\", \"Monolith\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang",
        "startIndex": 2708,
        "preview": "and testing - zero infrastructure\" framework: \"NET8\" category: \"Configuration\" difficulty: \"BEGINNER\" tags: [\"In-Process\", \"Development\", \"Configurati..."
      },
      {
        "id": "usage-patterns/progressive-enhancement-chunk-2",
        "text": "- No infrastructure dependencies Prototyping - Rapid iteration Simple applications - When you don't need durability Mode 2: Durable (Single Service) Configuration `csharp{ title: \"Durable Mode Configuration\" description: \"Add persistence and retry capabilities to your monolith\" framework: \"NET8\" category: \"Configuration\" difficulty: \"INTERMEDIATE\" tags: [\"Durable\", \"Persistence\", \"Monolith\"] nugetPackages: [\"Whizbang Core\", \"Whizbang PostgreSQL\"]\nfilename: \"Program Durable cs\"\nshowLineNumbers: true\nhighlightLines: [5, 6, 7, 8]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Program cs - Production monolith\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbang() UseDurableMode()  // Adds persistence and retry UsePostgreSQL(connectionString) WithOutbox()  // Ensures message delivery WithRetry(3, backoff: \"exponential\") RegisterHandlersFromAssembly(typeof(Program) Assembly);\n// Real database for production\nbuilder Services AddScoped<IOrderRepository, PostgresOrderRepository>();\n// Background service for processing\nbuilder Services AddHostedService<WhizbangProcessor>();\nvar app = builder Build();\napp MapPost(\"/orders\", async (CreateOrder cmd, IWhizbang whizbang) => {\n    // Queued for durable processing\n    await whizbang Publish(cmd);\n    return Results Accepted();  // Returns immediately\n});\napp Run();\n`\nMessage Flow\n`csharp{\ntitle: \"Durable Mode Message Flow\"\ndescription: \"How messages are persisted and processed\"\nframework: \"NET8\"\ncategory: \"Message Flow\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Durability\", \"Outbox\", \"Retry\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"DurableFlow cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\npublic class DurableExample {\n    public async Task DemonstrateDurable(IWhizbang whizbang) {\n        // 1 Message persisted to outbox\n        await whizbang Publish(new CreateOrder { });\n        // Returns immediately after persisting\n        // 2 Background processor picks up message\n        // - Dequeues from outbox\n        // - Executes handler\n        // - On success: Marks complete\n        // - On failure: Retries with backoff\n        // 3",
        "startIndex": 4978,
        "preview": "- No infrastructure dependencies Prototyping - Rapid iteration Simple applications - When you don't need durability Mode 2: Durable (Single Service) C..."
      },
      {
        "id": "usage-patterns/progressive-enhancement-chunk-3",
        "text": "whizbang) { // 1 Message persisted to outbox await whizbang Publish(new CreateOrder { }); // Returns immediately after persisting // 2 Background processor picks up message // - Dequeues from outbox // - Executes handler // - On success: Marks complete // - On failure: Retries with backoff // 3 Events from handler also go through outbox\n        // - Ensures exactly-once delivery\n        // - Maintains order guarantees\n    }\n}\n// Automatic retry on failure\n[Retry(3, Backoff = \"exponential\")]\npublic class ResilientHandler : IHandle<ProcessPayment> {\n    public PaymentProcessed Handle(ProcessPayment cmd) {\n        // If this fails, automatically retried\n        // 1st retry: 1 second delay\n        // 2nd retry: 2 second delay  \n        // 3rd retry: 4 second delay\n        return ProcessPaymentWithGateway(cmd);\n    }\n}\n`\nDatabase Schema\n`sql\n-- Outbox table for durable messaging\nCREATE TABLE whizbang_outbox (\n    id BIGSERIAL PRIMARY KEY,\n    message_id UUID NOT NULL UNIQUE,\n    message_type VARCHAR(500) NOT NULL,\n    payload JSONB NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    processed_at TIMESTAMPTZ,\n    attempts INT NOT NULL DEFAULT 0,\n    error TEXT\n);\n-- Inbox for idempotency\nCREATE TABLE whizbang_inbox (\n    message_id UUID PRIMARY KEY,\n    processed_at TIMESTAMPTZ NOT NULL,\n    handler_type VARCHAR(500) NOT NULL\n);\n`\nWhen to Use\nProduction monoliths - Reliability without distribution\nHigh-value operations - Can't afford to lose messages\nBackground processing - Decouple API from processing\nRetry requirements - Handle transient failures\nMode 3: Distributed (Microservices)\nConfiguration\n`csharp{\ntitle: \"Distributed Mode Configuration\"\ndescription: \"Scale across multiple services with message brokers\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Distributed\", \"Microservices\", \"Kafka\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Kafka\"]\nfilename: \"Program Distributed cs\"\nshowLineNumbers: true\nhighlightLines: [5, 6, 7, 8, 9]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Program cs - Orders Service\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbang() UseDistributedMode() UseKafka(config => {\n        config BootstrapServers = \"kafka:9092\";\n        config ConsumerGroup = \"orders-service\";\n    }) UsePostgreSQL(connectionString)  // Local event store",
        "startIndex": 6748,
        "preview": "whizbang) { // 1 Message persisted to outbox await whizbang Publish(new CreateOrder { }); // Returns immediately after persisting // 2 Background proc..."
      },
      {
        "id": "usage-patterns/progressive-enhancement-chunk-4",
        "text": "filename: \"Program Distributed cs\" showLineNumbers: true highlightLines: [5, 6, 7, 8, 9] usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"] } // Program cs - Orders Service var builder = WebApplication CreateBuilder(args); builder Services AddWhizbang() UseDistributedMode() UseKafka(config => { config BootstrapServers = \"kafka:9092\"; config ConsumerGroup = \"orders-service\"; }) UsePostgreSQL(connectionString) // Local event store WithSagaOrchestration()          // Distributed transactions WithDistributedTracing()         // OpenTelemetry RegisterHandlersFromAssembly(typeof(Program) Assembly);\n// Domain ownership configuration\nbuilder Services ConfigureDomain(\"Orders\", domain => {\n    domain OwnsAggregate<Order>();\n    domain PublishesEvents<OrderCreated, OrderShipped, OrderCancelled>();\n    domain HandlesCommands<CreateOrder, ShipOrder, CancelOrder>();\n});\nvar app = builder Build();\n// Health checks for service discovery\napp MapHealthChecks(\"/health\");\napp Run();\n`\nService Communication\n`csharp{\ntitle: \"Cross-Service Communication\"\ndescription: \"How services communicate in distributed mode\"\nframework: \"NET8\"\ncategory: \"Communication\"\ndifficulty: \"ADVANCED\"\ntags: [\"Service Communication\", \"Events\", \"Commands\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"DistributedCommunication cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Orders Service - Publishes events\n[OwnedBy(\"Orders\")]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        var order = CreateOrder(cmd);\n        // This event is automatically published to Kafka\n        // Other services can subscribe\n        return new OrderCreated(order Id, order Total);\n    }\n}\n// Inventory Service - Subscribes to events\n[Service(\"Inventory\")]\npublic class InventoryHandler : IHandle<OrderCreated> {\n    public InventoryReserved Handle(OrderCreated @event) {\n        // Receives event from Kafka\n        // Reserves inventory for the order\n        var reservation = ReserveInventory(@event OrderId);\n        // Publishes its own event\n        return new InventoryReserved(\n            @event OrderId, \n            reservation Id\n        );\n    }\n}\n// Payment Service - Part of saga\n[Service(\"Payment\")]\npublic class PaymentSaga : Saga<PaymentState> {\n    public SagaAction Handle(OrderCreated @event) {\n        State OrderId = @event OrderId;\n        State Amount = @event Total;\n        // Orchestrate payment process\n        return SagaAction Send(new ChargeCard(State Amount)) OnSuccess(new PaymentCompleted(State OrderId)) OnFailure(new PaymentFailed(State OrderId)) WithTimeout(TimeSpan",
        "startIndex": 8864,
        "preview": "filename: \"Program Distributed cs\" showLineNumbers: true highlightLines: [5, 6, 7, 8, 9] usingStatements: [\"Whizbang\", \"Microsoft Extensions Dependenc..."
      },
      {
        "id": "usage-patterns/progressive-enhancement-chunk-5",
        "text": "reservation Id ); } } // Payment Service - Part of saga [Service(\"Payment\")] public class PaymentSaga : Saga<PaymentState> { public SagaAction Handle(OrderCreated @event) { State OrderId = @event OrderId; State Amount = @event Total; // Orchestrate payment process return SagaAction Send(new ChargeCard(State Amount)) OnSuccess(new PaymentCompleted(State OrderId)) OnFailure(new PaymentFailed(State OrderId)) WithTimeout(TimeSpan FromMinutes(5));\n    }\n}\n`\nService Discovery\n`csharp{\ntitle: \"Service Discovery and Routing\"\ndescription: \"Automatic service discovery and message routing\"\nframework: \"NET8\"\ncategory: \"Service Discovery\"\ndifficulty: \"ADVANCED\"\ntags: [\"Service Discovery\", \"Routing\", \"Consul\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang ServiceDiscovery\"]\nfilename: \"ServiceDiscovery cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Automatic service registration\nbuilder Services AddWhizbang() UseDistributedMode() UseServiceDiscovery(options => {\n        options UseConsul(\"http://consul:8500\");\n        options ServiceName = \"orders-service\";\n        options ServiceId = Environment MachineName;\n        options HealthCheckInterval = TimeSpan FromSeconds(10);\n    });\n// Commands routed to owning service\npublic class OrderClient {\n    private readonly IWhizbang _whizbang;\n    public async Task<OrderCreated> CreateOrder(CreateOrder cmd) {\n        // Whizbang knows Orders service owns this command\n        // Automatically routes via service discovery\n        return await _whizbang Send(cmd);\n    }\n}\n// Load balancing across instances\n[LoadBalanced(Strategy = \"round-robin\")]\npublic class DistributedQuery : IHandle<GetOrderStatus> {\n    public OrderStatus Handle(GetOrderStatus query) {\n        // Queries can be handled by any instance\n        return GetStatus(query OrderId);\n    }\n}\n`\nWhen to Use\nMicroservice architecture - Independent service scaling\nTeam boundaries - Different teams own different services  \nTechnology diversity - Services in different languages\nGeographic distribution - Services in different regions\nMode 4: Event-Sourced (CQRS/ES)\nConfiguration\n`csharp{\ntitle: \"Event-Sourced Mode Configuration\"\ndescription: \"Full event sourcing with projections and time travel\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Event Sourcing\", \"CQRS\", \"Projections\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventStore\"]\nfilename: \"Program EventSourced cs\"\nshowLineNumbers: true\nhighlightLines: [5, 6, 7, 8, 9, 10]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Program cs - Event-sourced system\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbang() UseEventSourcedMode() UseEventStore(config => {\n        config",
        "startIndex": 11132,
        "preview": "reservation Id ); } } // Payment Service - Part of saga [Service(\"Payment\")] public class PaymentSaga : Saga<PaymentState> { public SagaAction Handle(..."
      },
      {
        "id": "usage-patterns/progressive-enhancement-chunk-6",
        "text": "difficulty: \"ADVANCED\" tags: [\"Event Sourcing\", \"CQRS\", \"Projections\"] nugetPackages: [\"Whizbang Core\", \"Whizbang EventStore\"] filename: \"Program EventSourced cs\" showLineNumbers: true highlightLines: [5, 6, 7, 8, 9, 10] usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"] } // Program cs - Event-sourced system var builder = WebApplication CreateBuilder(args); builder Services AddWhizbang() UseEventSourcedMode() UseEventStore(config => { config ConnectionString = eventStoreConnection;\n        config SnapshotFrequency = 100;  // Snapshot every 100 events\n    }) UseProjections(config => {\n        config UsePostgreSQL(readModelConnection);\n        config RebuildOnStartup = false;\n    }) WithTimeTravel()  // Enable historical queries RegisterHandlersFromAssembly(typeof(Program) Assembly);\n// Register aggregates\nbuilder Services RegisterAggregate<Order>();\nbuilder Services RegisterAggregate<Customer>();\n// Register projections\nbuilder Services RegisterProjection<OrderListProjection>();\nbuilder Services RegisterProjection<CustomerOrderHistoryProjection>();\nbuilder Services RegisterProjection<RevenueProjection>();\nvar app = builder Build();\n// Projection management endpoints\napp MapProjectionManagement(\"/projections\");\napp Run();\n`\nEvent-Sourced Aggregates\n`csharp{\ntitle: \"Event-Sourced Aggregate\"\ndescription: \"Domain aggregates that emit events\"\nframework: \"NET8\"\ncategory: \"Aggregates\"\ndifficulty: \"ADVANCED\"\ntags: [\"Aggregates\", \"Domain\", \"Events\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"OrderAggregate cs\"\nshowLineNumbers: true\nhighlightLines: [1, 10, 20, 30]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[EventSourced]\npublic class Order : Aggregate {\n    public Guid CustomerId { get; private set; }\n    public List<OrderItem> Items { get; private set; }\n    public decimal Total { get; private set; }\n    public OrderStatus Status { get; private set; }\n    // Command handler - returns events\n    public OrderCreated Handle(CreateOrder cmd) {\n        if (cmd Items Any() = true) {\n            throw new InvalidOperationException(\"Order must have items\");\n        }\n        var total = cmd Items Sum(i => i Quantity * i Price);\n        // Return event - automatically appended to event stream\n        return new OrderCreated {\n            OrderId = Guid NewGuid(),\n            CustomerId = cmd CustomerId,\n            Items = cmd Items,\n            Total = total,\n            CreatedAt = DateTime UtcNow\n        };\n    }\n    // Event handler - updates state\n    [Pure]  // No side effects allowed\n    public void Apply(OrderCreated @event) {\n        Id = @event OrderId;\n        CustomerId = @event CustomerId;\n        Items = @event Items ToList();\n        Total = @event",
        "startIndex": 13477,
        "preview": "difficulty: \"ADVANCED\" tags: [\"Event Sourcing\", \"CQRS\", \"Projections\"] nugetPackages: [\"Whizbang Core\", \"Whizbang EventStore\"] filename: \"Program Even..."
      },
      {
        "id": "usage-patterns/progressive-enhancement-chunk-7",
        "text": "CustomerId = cmd CustomerId, Items = cmd Items, Total = total, CreatedAt = DateTime UtcNow }; } // Event handler - updates state [Pure] // No side effects allowed public void Apply(OrderCreated @event) { Id = @event OrderId; CustomerId = @event CustomerId; Items = @event Items ToList(); Total = @event Total;\n        Status = OrderStatus Pending;\n    }\n    // Another command\n    public OrderShipped Ship(ShipOrder cmd) {\n        if (Status = OrderStatus Paid) {\n            throw new InvalidOperationException(\"Can only ship paid orders\");\n        }\n        return new OrderShipped {\n            OrderId = Id,\n            ShippedAt = DateTime UtcNow,\n            TrackingNumber = cmd TrackingNumber\n        };\n    }\n    public void Apply(OrderShipped @event) {\n        Status = OrderStatus Shipped;\n    }\n}\n`\nProjections\n`csharp{\ntitle: \"Event Projections\"\ndescription: \"Building read models from event streams\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Read Models\", \"CQRS\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"Projections cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Order list projection\n[Projection(\"OrderList\")]\npublic class OrderListProjection : \n    IProject<OrderCreated>,\n    IProject<OrderShipped>,\n    IProject<OrderCancelled> {\n    private readonly IDocumentStore _store;\n    public async Task Project(OrderCreated @event) {\n        await _store Upsert(new OrderListItem {\n            OrderId = @event OrderId,\n            CustomerId = @event CustomerId,\n            Total = @event Total,\n            Status = \"Created\",\n            CreatedAt = @event CreatedAt\n        });\n    }\n    public async Task Project(OrderShipped @event) {\n        await _store Update<OrderListItem>(@event OrderId, item => {\n            item Status = \"Shipped\";\n            item ShippedAt = @event ShippedAt;\n        });\n    }\n    public async Task Project(OrderCancelled @event) {\n        await _store Update<OrderListItem>(@event OrderId, item => {\n            item Status = \"Cancelled\";\n            item CancelledAt = @event CancelledAt;\n        });\n    }\n}\n// Revenue projection with time windows\n[Projection(\"Revenue\")]\npublic class RevenueProjection : IProject<OrderCreated> {\n    public async Task Project(OrderCreated @event) {\n        // Update daily revenue\n        await _store Increment(\n            $\"revenue:daily:{@event CreatedAt:yyyy-MM-dd}\",\n            @event Total\n        );\n        // Update monthly revenue\n        await _store Increment(\n            $\"revenue:monthly:{@event CreatedAt:yyyy-MM}\",\n            @event Total\n        );\n        // Update customer lifetime value\n        await _store Increment(\n            $\"customer:ltv:{@event CustomerId}\",\n            @event",
        "startIndex": 15741,
        "preview": "CustomerId = cmd CustomerId, Items = cmd Items, Total = total, CreatedAt = DateTime UtcNow }; } // Event handler - updates state [Pure] // No side eff..."
      },
      {
        "id": "usage-patterns/progressive-enhancement-chunk-8",
        "text": "time windows [Projection(\"Revenue\")] public class RevenueProjection : IProject<OrderCreated> { public async Task Project(OrderCreated @event) { // Update daily revenue await _store Increment( $\"revenue:daily:{@event CreatedAt:yyyy-MM-dd}\", @event Total ); // Update monthly revenue await _store Increment( $\"revenue:monthly:{@event CreatedAt:yyyy-MM}\", @event Total ); // Update customer lifetime value await _store Increment( $\"customer:ltv:{@event CustomerId}\", @event Total\n        );\n    }\n}\n`\nTime Travel Queries\n`csharp{\ntitle: \"Time Travel and Historical Queries\"\ndescription: \"Query system state at any point in time\"\nframework: \"NET8\"\ncategory: \"Time Travel\"\ndifficulty: \"ADVANCED\"\ntags: [\"Time Travel\", \"Historical\", \"Debugging\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"TimeTravel cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\npublic class TimeTravelExample {\n    private readonly IWhizbang _whizbang;\n    public async Task<Order> GetOrderAtPointInTime(\n        Guid orderId, \n        DateTime pointInTime) {\n        // Replay events up to specific time\n        var order = await _whizbang AsOf(pointInTime) Get<Order>(orderId);\n        return order;\n    }\n    public async Task<decimal> GetRevenueOnDate(DateTime date) {\n        // Query projection as it was on specific date\n        var revenue = await _whizbang AsOf(date AddDays(1) AddSeconds(-1)) Query<RevenueProjection>() GetDailyRevenue(date);\n        return revenue;\n    }\n    public async Task DebugOrderHistory(Guid orderId) {\n        // Get all events for an aggregate\n        var events = await _whizbang EventStream(orderId) ToListAsync();\n        Console WriteLine($\"Order {orderId} history:\");\n        foreach (var @event in events) {\n            Console WriteLine($\"  {@event Timestamp}: {@event GetType() Name}\");\n            // Replay to this point\n            var orderAtPoint = await _whizbang AsOf(@event Timestamp) Get<Order>(orderId);\n            Console WriteLine($\"    Status: {orderAtPoint Status}\");\n            Console WriteLine($\"    Total: {orderAtPoint",
        "startIndex": 18209,
        "preview": "time windows [Projection(\"Revenue\")] public class RevenueProjection : IProject<OrderCreated> { public async Task Project(OrderCreated @event) { // Upd..."
      },
      {
        "id": "usage-patterns/progressive-enhancement-chunk-9",
        "text": "events for an aggregate var events = await _whizbang EventStream(orderId) ToListAsync(); Console WriteLine($\"Order {orderId} history:\"); foreach (var @event in events) { Console WriteLine($\" {@event Timestamp}: {@event GetType() Name}\"); // Replay to this point var orderAtPoint = await _whizbang AsOf(@event Timestamp) Get<Order>(orderId); Console WriteLine($\" Status: {orderAtPoint Status}\"); Console WriteLine($\" Total: {orderAtPoint Total}\");\n        }\n    }\n}\n`\nWhen to Use\nAudit requirements - Complete history of all changes\nComplex domains - Rich business logic with many state transitions\nDebugging needs - Replay events to understand issues\nAnalytics - Build new projections from historical data\nCompliance - Prove system state at any point in time\nMigration Strategies\nFrom In-Process to Durable\n`csharp{\ntitle: \"Migrating to Durable Mode\"\ndescription: \"Steps to add durability to existing application\"\nframework: \"NET8\"\ncategory: \"Migration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Migration\", \"Durability\", \"Evolution\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"MigrateToDurable cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Step 1: Change configuration (no handler changes )\n// Before:\nbuilder Services AddWhizbang() UseInProcessMode();\n// After:\nbuilder Services AddWhizbang() UseDurableMode() UsePostgreSQL(connectionString);\n// Step 2: Add background processor\nbuilder Services AddHostedService<WhizbangProcessor>();\n// Step 3: Update message sending (optional)\n// Change from Send (synchronous) to Publish (async)\n// Before:\nvar result = await whizbang Send(command);\n// After (for background processing):\nawait whizbang Publish(command);\n// Your handlers remain EXACTLY the same `\nFrom Durable to Distributed\n`csharp{\ntitle: \"Migrating to Distributed Mode\"\ndescription: \"Steps to split monolith into microservices\"\nframework: \"NET8\"\ncategory: \"Migration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Migration\", \"Microservices\", \"Distribution\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Kafka\"]\nfilename: \"MigrateToDistributed cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Step 1: Define service boundaries\n// Orders Service\nbuilder Services ConfigureDomain(\"Orders\", domain => {\n    domain OwnsAggregate<Order>();\n    domain HandlesCommands<CreateOrder, ShipOrder>();\n});\n// Inventory Service  \nbuilder Services ConfigureDomain(\"Inventory\", domain => {\n    domain OwnsAggregate<Product>();\n    domain",
        "startIndex": 19934,
        "preview": "events for an aggregate var events = await _whizbang EventStream(orderId) ToListAsync(); Console WriteLine($\"Order {orderId} history:\"); foreach (var ..."
      },
      {
        "id": "usage-patterns/progressive-enhancement-chunk-10",
        "text": "\"Distribution\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Kafka\"] filename: \"MigrateToDistributed cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"] } // Step 1: Define service boundaries // Orders Service builder Services ConfigureDomain(\"Orders\", domain => { domain OwnsAggregate<Order>(); domain HandlesCommands<CreateOrder, ShipOrder>(); }); // Inventory Service builder Services ConfigureDomain(\"Inventory\", domain => { domain OwnsAggregate<Product>(); domain HandlesCommands<ReserveStock, ReleaseStock>();\n});\n// Step 2: Add message broker\nbuilder Services AddWhizbang() UseDistributedMode() UseKafka(kafkaConfig);\n// Step 3: Deploy services independently\n// Each service has its own database\n// Communication via Kafka\n// Handlers remain EXACTLY the same `\nFrom Distributed to Event-Sourced\n`csharp{\ntitle: \"Migrating to Event Sourcing\"\ndescription: \"Steps to add event sourcing to existing system\"\nframework: \"NET8\"\ncategory: \"Migration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Migration\", \"Event Sourcing\", \"CQRS\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventStore\"]\nfilename: \"MigrateToEventSourced cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Step 1: Convert entities to aggregates\n// Before:\npublic class Order {\n    public void UpdateStatus(OrderStatus status) {\n        Status = status;\n        repository Save(this);\n    }\n}\n// After:\n[EventSourced]\npublic class Order : Aggregate {\n    public OrderStatusChanged UpdateStatus(ChangeOrderStatus cmd) {\n        // Return event instead of saving directly\n        return new OrderStatusChanged(Id, cmd NewStatus);\n    }\n    public void Apply(OrderStatusChanged @event) {\n        Status = @event NewStatus;\n    }\n}\n// Step 2: Update configuration\nbuilder Services AddWhizbang() UseEventSourcedMode() UseEventStore(config);\n// Step 3: Build projections for queries\nbuilder Services RegisterProjection<OrderListProjection>();\n// Step 4: Migrate historical data (optional)\nawait migrator MigrateToEventStore(existingOrders);\n// Core handler logic remains similar `\nTesting Across Modes\n`csharp{\ntitle: \"Testing Progressive Enhancement\"\ndescription: \"Verify handlers work correctly in all modes\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Testing\", \"Cross-Mode\", \"Verification\"]\nnugetPackages: [\"Whizbang Core\", \"xUnit\"]\nfilename: \"ProgressiveTests cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang Testing\", \"Xunit\"]\n}\npublic class CrossModeTests {\n    private readonly CreateOrder _command = new() {\n        CustomerId = Guid NewGuid(),\n        Items = new[] { new OrderItem(\"SKU-1\", 2, 10",
        "startIndex": 22036,
        "preview": "\"Distribution\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Kafka\"] filename: \"MigrateToDistributed cs\" showLineNumbers: true usingStatements: [\"Whizba..."
      },
      {
        "id": "usage-patterns/progressive-enhancement-chunk-11",
        "text": "in all modes\" framework: \"NET8\" category: \"Testing\" difficulty: \"INTERMEDIATE\" tags: [\"Testing\", \"Cross-Mode\", \"Verification\"] nugetPackages: [\"Whizbang Core\", \"xUnit\"] filename: \"ProgressiveTests cs\" showLineNumbers: true usingStatements: [\"Whizbang Testing\", \"Xunit\"] } public class CrossModeTests { private readonly CreateOrder _command = new() { CustomerId = Guid NewGuid(), Items = new[] { new OrderItem(\"SKU-1\", 2, 10 00m) }\n    };\n    [Theory]\n    [InlineData(\"InProcess\")]\n    [InlineData(\"Durable\")]\n    [InlineData(\"Distributed\")]\n    [InlineData(\"EventSourced\")]\n    public async Task Handler_WorksInAllModes(string mode) {\n        // Arrange\n        var whizbang = BuildWhizbang(mode);\n        // Act\n        var result = await whizbang Send(_command);\n        // Assert - Same expectations regardless of mode\n        Assert NotNull(result);\n        Assert IsType<OrderCreated>(result);\n        var orderCreated = (OrderCreated)result;\n        Assert Equal(_command CustomerId, orderCreated CustomerId);\n        Assert Equal(20 00m, orderCreated Total);\n    }\n    private IWhizbang BuildWhizbang(string mode) {\n        return mode switch {\n            \"InProcess\" => new WhizbangBuilder() UseInProcessMode() Build(),\n            \"Durable\" => new WhizbangBuilder() UseDurableMode() UseInMemoryPersistence() Build(),\n            \"Distributed\" => new WhizbangBuilder() UseDistributedMode() UseInMemoryMessageBroker() Build(),\n            \"EventSourced\" => new WhizbangBuilder() UseEventSourcedMode() UseInMemoryEventStore() Build(),\n            _ => throw new ArgumentException($\"Unknown mode: {mode}\")\n        };\n    }\n}\n// Performance comparison across modes\n[Benchmark]\npublic class ModeBenchmarks {\n    [Params(\"InProcess\", \"Durable\", \"Distributed\", \"EventSourced\")]\n    public string Mode { get; set; }\n    private IWhizbang _whizbang;\n    [GlobalSetup]\n    public void Setup() {\n        _whizbang = BuildWhizbang(Mode);\n    }\n    [Benchmark]\n    public async Task ProcessOrder() {\n        await _whizbang Send(new CreateOrder {",
        "startIndex": 24196,
        "preview": "in all modes\" framework: \"NET8\" category: \"Testing\" difficulty: \"INTERMEDIATE\" tags: [\"Testing\", \"Cross-Mode\", \"Verification\"] nugetPackages: [\"Whizba..."
      },
      {
        "id": "usage-patterns/progressive-enhancement-chunk-12",
        "text": "ArgumentException($\"Unknown mode: {mode}\") }; } } // Performance comparison across modes [Benchmark] public class ModeBenchmarks { [Params(\"InProcess\", \"Durable\", \"Distributed\", \"EventSourced\")] public string Mode { get; set; } private IWhizbang _whizbang; [GlobalSetup] public void Setup() { _whizbang = BuildWhizbang(Mode); } [Benchmark] public async Task ProcessOrder() { await _whizbang Send(new CreateOrder { });\n    }\n}\n`\nBest Practices\nDo's\n✅ Start with the simplest mode that works\n`csharp\n// Development: UseInProcessMode()\n// Production: Start with UseDurableMode()\n// Scale when needed\n`\n✅ Keep handlers focused on business logic\n`csharp\npublic OrderCreated Handle(CreateOrder cmd) {\n    // Only business logic, no infrastructure\n}\n`\n✅ Use aspects for cross-cutting concerns\n`csharp\n[Logged]\n[Validated]\n[Transactional]\npublic class OrderHandler : IHandle<CreateOrder>\n`\n✅ Test handlers independently of mode\n`csharp\n[Theory]\n[InlineData(\"InProcess\")]\n[InlineData(\"Durable\")]\npublic async Task TestAcrossModes(string mode)\n`\nDon'ts\n❌ Don't add mode-specific logic to handlers\n`csharp\n// BAD\nif (IsDistributedMode()) {\n    // Special distributed logic\n}\n`\n❌ Don't skip modes unnecessarily\n`csharp\n// BAD: Jumping straight to event sourcing\n// GOOD: Progress through modes as needed\n`\n❌ Don't mix modes in same deployment\n`csharp\n// BAD: Some handlers durable, others distributed\n// GOOD: Consistent mode across application\n`\nReal-World Evolution\n`csharp{\ntitle: \"E-Commerce Platform Evolution\"\ndescription: \"Real example of progressive enhancement over time\"\nframework: \"NET8\"\ncategory: \"Real World\"\ndifficulty: \"ADVANCED\"\ntags: [\"Case Study\", \"E-Commerce\", \"Evolution\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"ECommercePlatform cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Year 1: Startup - In-Process Mode\n// Simple monolith, 100 orders/day\npublic class StartupPhase {\n    public void Configure(IServiceCollection services) {\n        services AddWhizbang() UseInProcessMode() RegisterHandlers();\n        // Simple, fast, easy to debug\n        // No infrastructure complexity\n    }\n}\n// Year 2: Growth - Durable Mode\n// Need reliability, 1,000 orders/day\npublic class GrowthPhase {\n    public void Configure(IServiceCollection services) {\n        services AddWhizbang() UseDurableMode() UsePostgreSQL(connectionString) WithOutbox()",
        "startIndex": 26006,
        "preview": "ArgumentException($\"Unknown mode: {mode}\") }; } } // Performance comparison across modes [Benchmark] public class ModeBenchmarks { [Params(\"InProcess\"..."
      },
      {
        "id": "usage-patterns/progressive-enhancement-chunk-13",
        "text": "class StartupPhase { public void Configure(IServiceCollection services) { services AddWhizbang() UseInProcessMode() RegisterHandlers(); // Simple, fast, easy to debug // No infrastructure complexity } } // Year 2: Growth - Durable Mode // Need reliability, 1,000 orders/day public class GrowthPhase { public void Configure(IServiceCollection services) { services AddWhizbang() UseDurableMode() UsePostgreSQL(connectionString) WithOutbox() WithRetry();\n        // Same handlers, added durability\n        // Background processing for emails\n        // Retry for payment processing\n    }\n}\n// Year 3: Scale - Distributed Mode\n// Multiple teams, 10,000 orders/day\npublic class ScalePhase {\n    // Orders Service\n    public class OrdersService {\n        public void Configure(IServiceCollection services) {\n            services AddWhizbang() UseDistributedMode() UseKafka(kafkaConfig) ConfigureDomain(\"Orders\");\n        }\n    }\n    // Inventory Service (different team)\n    public class InventoryService {\n        public void Configure(IServiceCollection services) {\n            services AddWhizbang() UseDistributedMode() UseKafka(kafkaConfig) ConfigureDomain(\"Inventory\");\n        }\n    }\n    // Same handler code, now distributed\n    // Independent deployment and scaling\n}\n// Year 4: Enterprise - Event-Sourced Mode\n// Compliance requirements, 100,000 orders/day\npublic class EnterprisePhase {\n    public void Configure(IServiceCollection services) {\n        services AddWhizbang() UseEventSourcedMode() UseEventStore(eventStoreConfig) UseProjections(projectionConfig) WithTimeTravel() WithSnapshots();\n        // Complete audit trail\n        // Time-travel debugging\n        // Complex analytics from event stream\n        // STILL the same handler patterns }\n}\n`\nSummary\nProgressive Enhancement in Whizbang allows you to:\nStart simple with in-process mode\nAdd durability when you need reliability\nScale to microservices when teams grow\nEmbrace event sourcing when the domain demands it\nAll without changing your handler code This is the power of Whizbang's unified architecture - write once, scale infinitely Next Steps\nReview Simple Mediator Pattern to start with basics\nExplore Event Sourcing Basics for advanced patterns\nLearn about Distributed Messaging for microservices\nSee CQRS Implementation for read/write separation",
        "startIndex": 28043,
        "preview": "class StartupPhase { public void Configure(IServiceCollection services) { services AddWhizbang() UseInProcessMode() RegisterHandlers(); // Simple, fas..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "usage-patterns/saga-orchestration",
    "title": "Saga Orchestration",
    "category": "Usage Patterns",
    "url": "/docs/usage-patterns/saga-orchestration",
    "chunks": [
      {
        "id": "usage-patterns/saga-orchestration-chunk-0",
        "text": "Saga Orchestration\nOverview\nThe Saga pattern manages long-running business transactions that span multiple aggregates or services. Whizbang provides comprehensive support for both orchestration and choreography-based sagas, with built-in compensation for handling failures.\nWhat is a Saga?\nA saga is a sequence of local transactions where each transaction updates data within a single service. If a step fails, the saga executes compensating transactions to undo the impact of preceding transactions.\nWhen to Use Sagas\nMulti-step workflows: Order fulfillment, payment processing\nCross-service transactions: Operations spanning multiple bounded contexts\nLong-running processes: Approval workflows, batch processing\nCompensatable operations: Actions that can be reversed or compensated\nArchitecture Diagram\n`mermaid\nstateDiagram-v2\n    [*] --> OrderPlaced\n    OrderPlaced --> PaymentProcessed: Process Payment\n    OrderPlaced --> OrderCancelled: Cancel\n    PaymentProcessed --> InventoryReserved: Reserve Inventory\n    PaymentProcessed --> PaymentRefunded: Fail\n    InventoryReserved --> OrderShipped: Ship Order\n    InventoryReserved --> InventoryReleased: Fail\n    OrderShipped --> [*]: Success\n    PaymentRefunded --> OrderCancelled: Compensate\n    InventoryReleased --> PaymentRefunded: Compensate\n    OrderCancelled --> [*]: Cancelled\n`\nImplementation Guide\nDocumentation in progress - This page demonstrates the structure for saga orchestration patterns with Whizbang.\nTopics to Cover:\nSaga Definition\nState machine configuration\nStep definitions\nCompensation logic\nOrchestration Pattern\nCentral coordinator\nState management\nStep execution\nChoreography Pattern\nEvent-driven coordination\nDecentralized flow\nEvent subscriptions\nCompensation Strategies\nBackward recovery\nForward recovery\nPivot transactions\nError Handling\nTimeout management\nRetry policies\nManual intervention\nExample: Order Fulfillment Saga\n`csharp\n// Placeholder for comprehensive saga implementation example\npublic class OrderFulfillmentSaga : Saga<OrderFulfillmentState> {\n    // Implementation details coming soon\n}\n`\nRelated Patterns\nEvent Sourcing Basics - Event-driven foundation\nCQRS Implementation - Query side for saga state\nDistributed Messaging - Cross-service communication\nNext Steps\nExplore Microservices Integration for deployment patterns\nReview Advanced Scenarios for production tips\nCheck Command Handling for command patterns",
        "startIndex": 0,
        "preview": "Saga Orchestration\nOverview\nThe Saga pattern manages long-running business transactions that span multiple aggregates or services. Whizbang provides c..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "usage-patterns/simple-mediator",
    "title": "Event-Driven Dispatcher Pattern",
    "category": "Usage Patterns",
    "url": "/docs/usage-patterns/simple-mediator",
    "chunks": [
      {
        "id": "usage-patterns/simple-mediator-chunk-0",
        "text": "Event-Driven Dispatcher Pattern\nOverview\nThe Event-Driven Dispatcher pattern is your entry point into the Whizbang library It provides a clean way to handle commands and queries using event-driven architecture, where all state changes flow through events This pattern is perfect for:\nGetting started with event-driven concepts\nBuilding applications with clear separation between reads and writes\nLearning the receptor/perspective/lens pattern\nStarting with Event-Driven mode before adding Event Sourcing\nKey Benefits\nProgressive Enhancement: Same code works from monolith to microservices\nConvention Over Configuration: Return types determine behavior\nAspect-Oriented: Cross-cutting concerns via declarative attributes\nCompile-Time Safety: Source generators catch errors at build time\nZero Overhead: Generated code performs like hand-written code\nArchitecture Diagram\n`mermaid\ngraph LR\n    Client[Client/Controller] --> Dispatcher[Whizbang Dispatcher]\n    Dispatcher --> Receptor[Receptor]\n    Receptor --> Event[Event]\n    Event --> Perspective[Perspective]\n    Perspective --> DB[Database]\n    Client --> Lens[Lens]\n    Lens --> DB\n    style Dispatcher fill:#0066cc,color:#fff\n    style Receptor fill:#28a745,color:#fff\n    style Perspective fill:#ffc107,color:#000\n    style Lens fill:#17a2b8,color:#fff\n`\nCore Components\nRequired Packages\n`xml\n<PackageReference Include=\"Whizbang Core\" Version=\"1 0 0\" />\n`\nThe Event-Driven Approach\nWhizbang uses a unified event-driven pattern:\nReceptors: Receive commands and emit events\nPerspectives: React to events and update views\nLenses: Provide read-only access to data\nAll writes through events: Even in non-event-sourced mode\nReturn Type Semantics: What you return determines what happens\nStep-by-Step Implementation\nStep 1: Define Your Messages\n`csharp{\ntitle: \"Message Definitions\"\ndescription: \"Simple message types - no special interfaces required\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Messages\", \"Commands\", \"Queries\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"OrderMessages cs\"\nshowLineNumbers: true\nusingStatements: [\"System\", \"System Collections Generic\"]\n}\nusing System;\nusing System Collections Generic;\nnamespace MyApp",
        "startIndex": 0,
        "preview": "Event-Driven Dispatcher Pattern\nOverview\nThe Event-Driven Dispatcher pattern is your entry point into the Whizbang library It provides a clean way to ..."
      },
      {
        "id": "usage-patterns/simple-mediator-chunk-1",
        "text": "1: Define Your Messages `csharp{ title: \"Message Definitions\" description: \"Simple message types - no special interfaces required\" framework: \"NET8\" category: \"Domain Logic\" difficulty: \"BEGINNER\" tags: [\"Messages\", \"Commands\", \"Queries\"] nugetPackages: [\"Whizbang Core\"] filename: \"OrderMessages cs\" showLineNumbers: true usingStatements: [\"System\", \"System Collections Generic\"] } using System; using System Collections Generic; namespace MyApp Orders;\n// Command: A message that changes state\npublic record CreateOrder(\n    Guid CustomerId,\n    List<OrderItem> Items,\n    string ShippingAddress\n);\n// Query: A message that reads data\npublic record GetOrderById(Guid OrderId);\n// Event: Something that happened\npublic record OrderCreated(\n    Guid OrderId,\n    Guid CustomerId,\n    decimal TotalAmount,\n    DateTime CreatedAt\n);\n// Response types\npublic record OrderDetails(\n    Guid OrderId,\n    Guid CustomerId,\n    List<OrderItem> Items,\n    decimal TotalAmount,\n    string Status,\n    DateTime CreatedAt\n);\n// Domain model\npublic record OrderItem(\n    string ProductId,\n    string ProductName,\n    int Quantity,\n    decimal UnitPrice\n);\n`\nStep 2: Implement Receptors with Return Type Semantics\n`csharp{\ntitle: \"Receptor Implementation - Event-Driven Approach\"\ndescription: \"Receptors emit events, perspectives handle writes\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Events\", \"Perspectives\", \"Lenses\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"OrderReceptors cs\"\nshowLineNumbers: true\nhighlightLines: [8, 13, 29, 45]\nusingStatements: [\"Whizbang\", \"System\", \"System Linq\"]\n}\nusing Whizbang;\nusing System;\nusing System Linq;\nnamespace MyApp Orders Receptors;\n// Receptor with aspects - receives commands, emits events\n[Logged]\n[Validated]\n[Transactional]\npublic class CreateOrderReceptor : IReceptor<CreateOrder> {\n    // Return type determines behavior: OrderCreated event flows to perspectives\n    public OrderCreated Receive(CreateOrder cmd, IOrderLens lens) {\n        // Validate using lens (read-only)\n        if ( lens CustomerExists(cmd CustomerId)) {\n            throw new CustomerNotFoundException();\n        }\n        // Calculate total\n        var totalAmount = cmd Items Sum(i => i Quantity * i UnitPrice);\n        // Emit event - perspectives handle all writes\n        return new OrderCreated(\n            Guid NewGuid(),\n            cmd CustomerId,\n            totalAmount,\n            DateTime",
        "startIndex": 2218,
        "preview": "1: Define Your Messages `csharp{ title: \"Message Definitions\" description: \"Simple message types - no special interfaces required\" framework: \"NET8\" c..."
      },
      {
        "id": "usage-patterns/simple-mediator-chunk-2",
        "text": "IOrderLens lens) { // Validate using lens (read-only) if ( lens CustomerExists(cmd CustomerId)) { throw new CustomerNotFoundException(); } // Calculate total var totalAmount = cmd Items Sum(i => i Quantity * i UnitPrice); // Emit event - perspectives handle all writes return new OrderCreated( Guid NewGuid(), cmd CustomerId, totalAmount, DateTime UtcNow\n        );\n    }\n}\n// Lens provides read-only queries\npublic class OrderLens : IOrderLens {\n    private readonly IDatabase db;\n    [Cached(Duration = \"5m\")]\n    public OrderDetails Focus(Guid orderId) {\n        var order = db Orders Find(orderId);\n        if (order == null) {\n            throw new NotFoundException($\"Order {orderId} not found\");\n        }\n        // Return read-only view\n        return new OrderDetails(\n            order Id,\n            order CustomerId,\n            order Items,\n            order TotalAmount,\n            order Status,\n            order CreatedAt\n        );\n    }\n    public bool CustomerExists(Guid customerId) {\n        return db Customers Any(c => c Id == customerId);\n    }\n}\n// Receptor returning multiple events via tuple\npublic class ProcessOrderReceptor : IReceptor<ProcessOrder> {\n    // Tuple return = multiple events flow to perspectives\n    public (OrderProcessed, EmailQueued, InventoryReserved) Receive(ProcessOrder cmd) {\n        // Make decisions, emit events\n        return (\n            new OrderProcessed(cmd OrderId),\n            new EmailQueued(cmd CustomerEmail, \"Order confirmed\"),\n            new InventoryReserved(cmd Items)\n        );\n    }\n}\n`\nStep 3: Implement Perspectives for Write Operations\n`csharp{\ntitle: \"Perspective Implementation - Handle All Writes\"\ndescription: \"Perspectives react to events and update storage\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Perspectives\", \"Events\", \"Database Updates\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"OrderPerspectives cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\"]\n}\nusing Whizbang;\nusing System;\nusing System Threading Tasks;\nnamespace MyApp Orders Perspectives;\n// Perspective handles all database writes\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> {\n    private readonly IDatabase db;\n    public async Task Update(OrderCreated e) {\n        // Create order in database\n        await db Orders Add(new Order {\n            Id = e OrderId,\n            CustomerId = e CustomerId,\n            Total = e TotalAmount,\n            Status = \"Pending\",\n            CreatedAt = e CreatedAt\n        });\n        await db",
        "startIndex": 4231,
        "preview": "IOrderLens lens) { // Validate using lens (read-only) if ( lens CustomerExists(cmd CustomerId)) { throw new CustomerNotFoundException(); } // Calculat..."
      },
      {
        "id": "usage-patterns/simple-mediator-chunk-3",
        "text": "writes public class OrderPerspective : IPerspectiveOf<OrderCreated> { private readonly IDatabase db; public async Task Update(OrderCreated e) { // Create order in database await db Orders Add(new Order { Id = e OrderId, CustomerId = e CustomerId, Total = e TotalAmount, Status = \"Pending\", CreatedAt = e CreatedAt }); await db SaveChanges();\n    }\n}\n// Multiple perspectives can react to same event\npublic class CustomerStatsPerspective : IPerspectiveOf<OrderCreated> {\n    private readonly IDatabase db;\n    public async Task Update(OrderCreated e) {\n        await db CustomerStats IncrementOrderCount(e CustomerId);\n        await db CustomerStats UpdateLastOrderDate(e CustomerId, e CreatedAt);\n    }\n}\n// Cache perspective\npublic class CachePerspective : IPerspectiveOf<OrderCreated> {\n    private readonly ICache cache;\n    public async Task Update(OrderCreated e) {\n        // Invalidate customer cache\n        await cache Remove($\"customer:{e CustomerId}:orders\");\n    }\n}\n`\nStep 4: Wire Up Your Application\n`csharp{\ntitle: \"Service Configuration\"\ndescription: \"Configure dispatcher with receptors, perspectives, and lenses\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"BEGINNER\"\ntags: [\"DI\", \"Configuration\", \"Progressive Enhancement\"]\nnugetPackages: [\"Whizbang Core\", \"Microsoft Extensions DependencyInjection\"]\nfilename: \"Program cs\"\nshowLineNumbers: true\nhighlightLines: [8, 11, 20, 28]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\nusing Whizbang;\nusing Microsoft AspNetCore Builder;\nusing Microsoft Extensions DependencyInjection;\nusing MyApp Orders Receptors;\nusing MyApp Orders Perspectives;\nvar builder = WebApplication CreateBuilder(args);\n// Configure Event-Driven mode\nbuilder Services AddWhizbang() UseDispatcher(dispatcher => {\n        dispatcher DefaultPolicy = new EventDrivenPolicy();\n        // Register components\n        dispatcher RegisterReceptorsFromAssembly(typeof(Program) Assembly);\n        dispatcher RegisterPerspectivesFromAssembly(typeof(Program) Assembly);\n        dispatcher RegisterLensesFromAssembly(typeof(Program) Assembly);\n    });\n// Register lenses (read-only queries)\nbuilder Services AddScoped<IOrderLens, OrderLens>();\nbuilder Services AddScoped<ICustomerLens, CustomerLens>();\n// When ready for Event-Sourcing\n// dispatcher ForReceptor<Order>() UsePolicy(new EventSourcedPolicy());\n// When scaling to distributed\n// dispatcher UseRelay<KafkaRelay>();\nbuilder Services AddControllers();\nvar app = builder Build();\napp UseRouting();\napp MapControllers();\napp Run();\n`\nComplete Example\n`csharp{\ntitle: \"Complete Event-Driven Example\"\ndescription: \"Full working example with receptors, perspectives, and lenses\"\nframework: \"NET8\"\ncategory: \"Complete Example\"\ndifficulty: \"BEGINNER\"\ntags: [\"API\", \"Controller\", \"Dispatcher\", \"Event-Driven\", \"Complete\"]\nnugetPackages: [\"Whizbang",
        "startIndex": 6463,
        "preview": "writes public class OrderPerspective : IPerspectiveOf<OrderCreated> { private readonly IDatabase db; public async Task Update(OrderCreated e) { // Cre..."
      },
      {
        "id": "usage-patterns/simple-mediator-chunk-4",
        "text": "distributed // dispatcher UseRelay<KafkaRelay>(); builder Services AddControllers(); var app = builder Build(); app UseRouting(); app MapControllers(); app Run(); ` Complete Example `csharp{ title: \"Complete Event-Driven Example\" description: \"Full working example with receptors, perspectives, and lenses\" framework: \"NET8\" category: \"Complete Example\" difficulty: \"BEGINNER\" tags: [\"API\", \"Controller\", \"Dispatcher\", \"Event-Driven\", \"Complete\"] nugetPackages: [\"Whizbang Core\", \"Microsoft AspNetCore Mvc\"]\nfilename: \"OrdersController cs\"\nshowLineNumbers: true\nhighlightLines: [14, 23, 33]\ntestFile: \"OrdersControllerTests cs\"\ntestMethod: \"CreateOrder_ValidCommand_ReturnsOrderId\"\nusingStatements: [\"Whizbang\", \"Microsoft AspNetCore Mvc\", \"System\"]\n}\nusing Whizbang;\nusing Microsoft AspNetCore Mvc;\nusing System;\nusing MyApp Orders;\nnamespace MyApp Controllers;\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class OrdersController : ControllerBase {\n    private readonly IDispatcher _dispatcher;\n    private readonly IOrderLens _orderLens;\n    public OrdersController(IDispatcher dispatcher, IOrderLens orderLens) {\n        _dispatcher = dispatcher;\n        _orderLens = orderLens;\n    }\n    [HttpPost]\n    public async Task<ActionResult<OrderCreated>> CreateOrder(\n        [FromBody] CreateOrderRequest request) {\n        // Map request to command\n        var command = new CreateOrder(\n            request CustomerId,\n            request Items,\n            request ShippingAddress\n        );\n        try {\n            // Dispatcher routes to receptor, event flows to perspectives\n            var @event = await _dispatcher Dispatch(command);\n            return Ok(@event);\n        }\n        catch (ValidationException ex) {\n            return BadRequest(new { error = ex Message });\n        }\n        catch (InsufficientInventoryException ex) {\n            return Conflict(new { error = ex Message });\n        }\n    }\n    [HttpGet(\"{orderId}\")]\n    public async Task<ActionResult<OrderDetails>> GetOrder(Guid orderId) {\n        try {\n            // Use lens for queries (read-only)\n            var order = _orderLens Focus(orderId);\n            return Ok(order);\n        }\n        catch (NotFoundException ex) {\n            return NotFound(new { error = ex Message });\n        }\n    }\n    [HttpPost(\"{orderId}/process\")]\n    public async Task<ActionResult> ProcessOrder(Guid orderId) {\n        // Receptor returns tuple - all events flow to perspectives\n        var (orderProcessed, emailQueued, inventoryReserved) = \n            await _dispatcher Dispatch(new ProcessOrder(orderId));\n        return Ok(new {\n            orderId = orderProcessed OrderId,\n            emailQueued = emailQueued QueueId,\n            inventoryReserved = inventoryReserved",
        "startIndex": 7417,
        "preview": "distributed // dispatcher UseRelay<KafkaRelay>(); builder Services AddControllers(); var app = builder Build(); app UseRouting(); app MapControllers()..."
      },
      {
        "id": "usage-patterns/simple-mediator-chunk-5",
        "text": "return NotFound(new { error = ex Message }); } } [HttpPost(\"{orderId}/process\")] public async Task<ActionResult> ProcessOrder(Guid orderId) { // Receptor returns tuple - all events flow to perspectives var (orderProcessed, emailQueued, inventoryReserved) = await _dispatcher Dispatch(new ProcessOrder(orderId)); return Ok(new { orderId = orderProcessed OrderId, emailQueued = emailQueued QueueId, inventoryReserved = inventoryReserved ReservationId\n        });\n    }\n}\n// Request DTOs\npublic record CreateOrderRequest(\n    Guid CustomerId,\n    List<OrderItem> Items,\n    string ShippingAddress\n);\n`\nTesting Strategy\nUnit Testing Receptors and Perspectives\n`csharp{\ntitle: \"Receptor and Perspective Unit Tests\"\ndescription: \"Test receptors and perspectives in isolation\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"BEGINNER\"\ntags: [\"Unit Testing\", \"xUnit\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\", \"xUnit\"]\nfilename: \"CreateOrderHandlerTests cs\"\nshowLineNumbers: true\nhighlightLines: [15, 25, 40]\nusingStatements: [\"Whizbang\", \"Xunit\"]\n}\nusing Whizbang;\nusing Xunit;\nusing System;\nusing System Collections Generic;\nusing MyApp Orders;\nusing MyApp Orders Receptors;\nusing MyApp Orders Perspectives;\nnamespace MyApp Tests Orders;\npublic class CreateOrderReceptorTests {\n    [Fact]\n    public void Receive_ValidCommand_ReturnsOrderCreatedEvent() {\n        // Arrange\n        var receptor = new CreateOrderReceptor();\n        var command = new CreateOrder(\n            Guid NewGuid(),\n            new List<OrderItem> {\n                new OrderItem(\"PROD-1\", \"Widget\", 2, 10 00m)\n            },\n            \"123 Main St\"\n        );\n        var lens = Mock Of<IOrderLens>(l => \n            l CustomerExists(It IsAny<Guid>()) == true\n        );\n        // Act - Receptor emits event\n        var @event = receptor Receive(command, lens);\n        // Assert - Event emitted\n        Assert NotNull(@event);\n        Assert IsType<OrderCreated>(@event);\n        Assert Equal(20 00m, @event TotalAmount);\n    }\n    [Fact]\n    public void Receive_ProcessOrder_ReturnsMultipleEvents() {\n        // Arrange\n        var receptor = new ProcessOrderReceptor();\n        var command = new ProcessOrder(Guid NewGuid());\n        // Act - Receptor returns tuple of events\n        var (processed, emailQueued, inventoryReserved) = receptor Receive(command);\n        // Assert - All events emitted\n        Assert NotNull(processed);\n        Assert NotNull(emailQueued);\n        Assert NotNull(inventoryReserved);\n        Assert Equal(command OrderId, processed",
        "startIndex": 11293,
        "preview": "return NotFound(new { error = ex Message }); } } [HttpPost(\"{orderId}/process\")] public async Task<ActionResult> ProcessOrder(Guid orderId) { // Recep..."
      },
      {
        "id": "usage-patterns/simple-mediator-chunk-6",
        "text": "} [Fact] public void Receive_ProcessOrder_ReturnsMultipleEvents() { // Arrange var receptor = new ProcessOrderReceptor(); var command = new ProcessOrder(Guid NewGuid()); // Act - Receptor returns tuple of events var (processed, emailQueued, inventoryReserved) = receptor Receive(command); // Assert - All events emitted Assert NotNull(processed); Assert NotNull(emailQueued); Assert NotNull(inventoryReserved); Assert Equal(command OrderId, processed OrderId);\n    }\n}\n// Test Perspectives\npublic class PerspectiveTests {\n    [Fact]\n    public async Task OrderPerspective_UpdatesDatabase_WhenOrderCreatedReceived() {\n        // Arrange\n        var db = new InMemoryDatabase();\n        var perspective = new OrderPerspective(db);\n        var @event = new OrderCreated {\n            OrderId = Guid NewGuid(),\n            CustomerId = Guid NewGuid(),\n            TotalAmount = 100 00m\n        };\n        // Act - Perspective handles write\n        await perspective Update(@event);\n        // Assert - Database updated\n        var order = await db Orders Find(@event OrderId);\n        Assert NotNull(order);\n        Assert Equal(@event CustomerId, order CustomerId);\n        Assert Equal(@event TotalAmount, order Total);\n    }\n    [Fact]\n    public async Task Handler_WithLoggingAspect_LogsExecution() {\n        // Test logging aspect\n        await Whizbang Test<CreateOrderHandler>() Given(new CreateOrder { }) WithAspects() WhenHandled() ThenAspect<LoggingAspect>(logs => {\n                logs ShouldContain(\"Executing CreateOrderHandler\");\n                logs ShouldContain(\"Completed in\");\n            });\n    }\n}\n`\nCommon Pitfalls\nAvoid Direct Handler Calls\n`csharp\n// ❌ BAD - Don't inject and call handlers directly\npublic class OrderService {\n    private readonly CreateOrderHandler _handler;\n    public OrderService(CreateOrderHandler handler) {\n        _handler = handler;\n    }\n}\n// ✅ GOOD - Always use Whizbang for routing\npublic class OrderService {\n    private readonly IWhizbang _whizbang;\n    public OrderService(IWhizbang whizbang) {\n        _whizbang = whizbang;\n    }\n}\n`\nUse Return Types to Express Intent\n`csharp\n// ❌ BAD - Unclear what happens with the result\npublic object Handle(CreateOrder cmd) {\n    return new { OrderId = Guid NewGuid() };\n}\n// ✅ GOOD - Return type makes intent clear\npublic OrderCreated Handle(CreateOrder cmd) {\n    return new OrderCreated(Guid",
        "startIndex": 13402,
        "preview": "} [Fact] public void Receive_ProcessOrder_ReturnsMultipleEvents() { // Arrange var receptor = new ProcessOrderReceptor(); var command = new ProcessOrd..."
      },
      {
        "id": "usage-patterns/simple-mediator-chunk-7",
        "text": "} ` Use Return Types to Express Intent `csharp // ❌ BAD - Unclear what happens with the result public object Handle(CreateOrder cmd) { return new { OrderId = Guid NewGuid() }; } // ✅ GOOD - Return type makes intent clear public OrderCreated Handle(CreateOrder cmd) { return new OrderCreated(Guid NewGuid());\n}\n// ✅ GOOD - Multiple effects via tuple\npublic (OrderCreated, SendEmail) Handle(CreateOrder cmd) {\n    return (new OrderCreated(), new SendEmail());\n}\n`\nAvoid Business Logic in Controllers\n`csharp\n// ❌ BAD - Business logic in controller\n[HttpPost]\npublic async Task<IActionResult> CreateOrder(CreateOrderRequest request) {\n    if (request Items Sum(i => i Quantity * i UnitPrice) > 1000) {\n        // Business logic doesn't belong here request RequiresApproval = true;\n    }\n}\n// ✅ GOOD - All logic in handler\n[HttpPost]\npublic async Task<IActionResult> CreateOrder(CreateOrderRequest request) {\n    var command = MapToCommand(request);\n    var result = await _whizbang Send(command);\n    return Ok(result);\n}\n`\nProgressive Enhancement\nStart Simple\n`csharp\n// Phase 1: Simple in-process (like MediatR)\nbuilder Services AddWhizbang() UseInProcessMode();\n`\nAdd Durability When Needed\n`csharp\n// Phase 2: Add persistence and retry (like Wolverine)\nbuilder Services AddWhizbang() UseDurableMode() UsePostgreSQL(connectionString) WithOutbox();\n`\nScale to Distributed\n`csharp\n// Phase 3: Microservices (like MassTransit)\nbuilder Services AddWhizbang() UseDistributedMode() UseKafka(kafkaConfig) WithSagaOrchestration();\n`\nEnable Event Sourcing\n`csharp\n// Phase 4: Full event sourcing (unique to Whizbang)\nbuilder Services AddWhizbang() UseEventSourcedMode() UseEventStore(eventStoreConfig) WithProjections() WithSnapshots();\n`\nThe same handler code works in ALL modes",
        "startIndex": 15396,
        "preview": "} ` Use Return Types to Express Intent `csharp // ❌ BAD - Unclear what happens with the result public object Handle(CreateOrder cmd) { return new { Or..."
      },
      {
        "id": "usage-patterns/simple-mediator-chunk-8",
        "text": "UseDurableMode() UsePostgreSQL(connectionString) WithOutbox(); ` Scale to Distributed `csharp // Phase 3: Microservices (like MassTransit) builder Services AddWhizbang() UseDistributedMode() UseKafka(kafkaConfig) WithSagaOrchestration(); ` Enable Event Sourcing `csharp // Phase 4: Full event sourcing (unique to Whizbang) builder Services AddWhizbang() UseEventSourcedMode() UseEventStore(eventStoreConfig) WithProjections() WithSnapshots(); ` The same handler code works in ALL modes Related Patterns\nEvent Sourcing Basics - Add persistence and event history\nCQRS Implementation - Separate read and write models\nDistributed Messaging - Scale across services\nProduction Considerations\nPerformance\nZero-overhead aspects via source generation\nHandler pooling for reduced allocations\nCompile-time optimizations\nAdaptive runtime optimization\nMonitoring with Aspects\n`csharp\n// Built-in observability via aspects\n[Observed] // Automatic telemetry\n[Timed]    // Performance metrics\n[Logged]   // Structured logging\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Automatically generates:\n        // - Distributed trace spans\n        // - Metrics (count, duration, errors)\n        // - Structured logs with correlation IDs\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nError Handling with Result Types\n`csharp\npublic Result<OrderCreated> Handle(CreateOrder cmd) {\n    if ( IsValid(cmd)) {\n        return Result Failure<OrderCreated>(\"Validation failed\");\n    }\n    try {\n        var order = CreateOrder(cmd);\n        return Result Success(new OrderCreated(order Id));\n    }\n    catch (Exception ex) {\n        return Result Failure<OrderCreated>(ex Message);\n    }\n}\n`\nNext Steps\nExplore Progressive Enhancement to scale your application\nLearn about Aspect-Oriented Handlers for cross-cutting concerns\nReview Return Type Semantics for advanced patterns\nCheck out Event Sourcing Basics when ready for event sourcing\nSee CQRS Implementation for read/write separation",
        "startIndex": 16936,
        "preview": "UseDurableMode() UsePostgreSQL(connectionString) WithOutbox(); ` Scale to Distributed `csharp // Phase 3: Microservices (like MassTransit) builder Ser..."
      }
    ]
  }
]