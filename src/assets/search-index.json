[
  {
    "type": "document",
    "slug": "advanced/advanced-scenarios",
    "title": "Advanced Scenarios",
    "category": "Advanced",
    "url": "/docs/advanced/advanced-scenarios",
    "chunks": [
      {
        "id": "advanced/advanced-scenarios-chunk-0",
        "text": "Advanced Scenarios\nThis document covers advanced scenarios for production deployments, including data seeding, Backend-for-Frontend (BFF) patterns, and central control commands Data Seeding in Scaled Environments\nWhen deploying to scaled-out environments (Kubernetes, multiple replicas), data seeding must be coordinated to avoid duplicates or race conditions Coordinated Seeding\n`csharp{\ntitle: \"Coordinated Data Seeding\"\ndescription: \"Seed data in scaled environments without duplicates\"\nframework: \"NET8\"\ncategory: \"Deployment\"\ndifficulty: \"ADVANCED\"\ntags: [\"Seeding\", \"Deployment\", \"Kubernetes\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\"]\nusingStatements: [\"Microsoft Extensions Hosting\", \"Whizbang\", \"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Microsoft Extensions Hosting;\nusing Whizbang;\npublic class DataSeeder : IHostedService {\n    private readonly IWhizbang _whizbang;\n    private readonly IDistributedLock _distributedLock;\n    public DataSeeder(IWhizbang whizbang, IDistributedLock distributedLock) {\n        _whizbang = whizbang;\n        _distributedLock = distributedLock;\n    }\n    public async Task StartAsync(CancellationToken cancellationToken) {\n        // Only ONE replica seeds data (distributed lock)\n        await using var @lock = await _distributedLock AcquireAsync(\"data-seeding\", TimeSpan FromMinutes(5));\n        if (@lock = null) {\n            await SeedDataAsync();\n        }\n    }\n    private async Task SeedDataAsync() {\n        // Check if already seeded\n        var alreadySeeded = await CheckIfSeededAsync();\n        if (alreadySeeded) {\n            return;\n        }\n        // Seed master data\n        await SeedProductCatalogAsync();\n        await SeedDefaultTenantsAsync();\n        await SeedReferenceDataAsync();\n        // Mark as seeded\n        await MarkAsSeededAsync();\n    }\n    public Task StopAsync(CancellationToken cancellationToken) => Task CompletedTask;\n}\n`\nIdempotent Seeding\nMake seeding operations idempotent:\n`csharp{\ntitle: \"Idempotent Seeding\"\ndescription: \"Seed data that can be run multiple times safely\"\nframework: \"NET8\"\ncategory: \"Deployment\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Seeding\", \"Idempotence\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\npublic class ProductCatalogSeeder {\n    private readonly IRepository<ProductCatalog> _repository;\n    public ProductCatalogSeeder(IRepository<ProductCatalog> repository) {\n        _repository = repository;\n    }\n    public async Task SeedAsync() {\n        // Idempotent: only create if doesn't exist\n        var catalog = await _repository FindAsync(WellKnownIds DefaultCatalog);\n        if (catalog == null) {\n            catalog = new ProductCatalog(WellKnownIds",
        "startIndex": 0,
        "preview": "Advanced Scenarios\nThis document covers advanced scenarios for production deployments, including data seeding, Backend-for-Frontend (BFF) patterns, an..."
      },
      {
        "id": "advanced/advanced-scenarios-chunk-1",
        "text": "using System Threading Tasks; using Whizbang; public class ProductCatalogSeeder { private readonly IRepository<ProductCatalog> _repository; public ProductCatalogSeeder(IRepository<ProductCatalog> repository) { _repository = repository; } public async Task SeedAsync() { // Idempotent: only create if doesn't exist var catalog = await _repository FindAsync(WellKnownIds DefaultCatalog); if (catalog == null) { catalog = new ProductCatalog(WellKnownIds DefaultCatalog, \"Default Catalog\");\n            catalog AddProduct(new Product(\"Widget\", 19 99m));\n            catalog AddProduct(new Product(\"Gadget\", 29 99m));\n            catalog AddProduct(new Product(\"Doohickey\", 39 99m));\n            await _repository SaveAsync(catalog);\n        }\n    }\n}\n`\nEnvironment-Specific Seeding\nDifferent data for dev/staging/production:\n`csharp{\ntitle: \"Environment-Specific Seeding\"\ndescription: \"Seed different data per environment\"\nframework: \"NET8\"\ncategory: \"Deployment\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Seeding\", \"Environments\"]\nnugetPackages: [\"Whizbang Core\", \"Microsoft Extensions Hosting\"]\nusingStatements: [\"Microsoft Extensions Hosting\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System Threading Tasks;\nusing Microsoft Extensions Hosting;\npublic class EnvironmentSeeder : IHostedService {\n    private readonly IHostEnvironment _env;\n    private readonly IDataSeeder _seeder;\n    public EnvironmentSeeder(IHostEnvironment env, IDataSeeder seeder) {\n        _env = env;\n        _seeder = seeder;\n    }\n    public async Task StartAsync(CancellationToken cancellationToken) {\n        if (_env IsDevelopment()) {\n            // Seed lots of test data for local development\n            await _seeder SeedDevelopmentDataAsync();\n            await _seeder SeedTestTenantsAsync(count: 10);\n            await _seeder SeedSampleOrdersAsync(count: 1000);\n        }\n        else if (_env IsStaging()) {\n            // Seed realistic production-like data\n            await _seeder SeedProductionLikeDataAsync();\n            await _seeder SeedTestTenantsAsync(count: 2);  // Fewer test tenants\n        }\n        else if (_env IsProduction()) {\n            // Only seed essential master data\n            await _seeder SeedMasterDataAsync();\n            // Do NOT seed test data in production\n        }\n    }\n    public Task StopAsync(CancellationToken cancellationToken) => Task CompletedTask;\n}\n`\nKubernetes Init Container Seeding\nUse Kubernetes init containers for pre-startup seeding:\n`yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: orders-service\nspec:\n  replicas: 3\n  template:\n    spec:\n      Init container runs BEFORE main container\n      initContainers:\nname: seed-data\n        image: myapp/orders-service:latest\n        command: [\"dotnet\", \"OrdersService dll\", \"--seed-only\"]\n        env:\nname: ASPNETCORE_ENVIRONMENT\n          value: \"Production\"\n      Main application container\n      containers:\nname: orders-service\n        image: myapp/orders-service:latest\n`\nApplication code:\n`csharp\n// In Program cs\nif (args",
        "startIndex": 2926,
        "preview": "using System Threading Tasks; using Whizbang; public class ProductCatalogSeeder { private readonly IRepository<ProductCatalog> _repository; public Pro..."
      },
      {
        "id": "advanced/advanced-scenarios-chunk-2",
        "text": "apps/v1 kind: Deployment metadata: name: orders-service spec: replicas: 3 template: spec: Init container runs BEFORE main container initContainers: name: seed-data image: myapp/orders-service:latest command: [\"dotnet\", \"OrdersService dll\", \"--seed-only\"] env: name: ASPNETCORE_ENVIRONMENT value: \"Production\" Main application container containers: name: orders-service image: myapp/orders-service:latest ` Application code: `csharp // In Program cs if (args Contains(\"--seed-only\")) {\n    await SeedDataAsync(app Services);\n    return;  // Exit after seeding\n}\nawait app RunAsync();  // Normal startup\n`\n---\nBackend-for-Frontend (BFF) Support\nBFF pattern creates backend APIs tailored to specific frontend applications (web, mobile, desktop) BFF Architecture\n`\n┌─────────────┐       ┌─────────────┐       ┌─────────────┐\n│  Web App    │       │ Mobile App  │       │ Desktop App │\n│  (React)    │       │  (Swift)    │       │  (WinUI)    │\n└──────┬──────┘       └──────┬──────┘       └──────┬──────┘\n       │                     │                     │\n       ↓                     ↓                     ↓\n┌─────────────┐       ┌─────────────┐       ┌─────────────┐\n│   Web BFF   │       │  Mobile BFF │       │ Desktop BFF │\n│  (GraphQL)  │       │   (REST)    │       │  (gRPC)     │\n└──────┬──────┘       └──────┬──────┘       └──────┬──────┘\n       │                     │                     │\n       └─────────────┬───────┴─────────────────────┘\n                     ↓\n              ┌──────────────┐\n              │   Whizbang   │\n              │  Microservices│\n              └──────────────┘\n`\nCreating a BFF with Whizbang\n`csharp{\ntitle: \"Web BFF Implementation\"\ndescription: \"Backend-for-Frontend for web application\"\nframework: \"NET8\"\ncategory: \"BFF\"\ndifficulty: \"ADVANCED\"\ntags: [\"BFF\", \"GraphQL\", \"Web\"]\nnugetPackages: [\"Whizbang Core\", \"HotChocolate\"]\nfilename: \"WebBFF/Program cs\"\nusingStatements: [\"Microsoft AspNetCore Builder\", \"Whizbang\", \"HotChocolate\"]\nshowLineNumbers: true\n}\nusing Microsoft AspNetCore Builder;\nusing Whizbang;\nusing HotChocolate;\nvar builder = WebApplication CreateBuilder(args);\n// Add Whizbang as client (sends commands/queries to backend services)\nbuilder Services AddWhizbangClient(options => {\n    options UseDomainOwnership(domains => {\n        domains RegisterDomain(\"Orders\", \"http://orders-service\");\n        domains RegisterDomain(\"Inventory\", \"http://inventory-service\");\n        domains RegisterDomain(\"Customers\", \"http://customers-service\");\n    });\n});\n// Add GraphQL for web frontend\nbuilder Services AddGraphQLServer() AddQueryType<WebQuery>() AddMutationType<WebMutation>();\nvar app = builder Build();\napp MapGraphQL();\napp Run();\n// GraphQL types optimized for web UI\npublic class WebQuery {\n    public async Task<CustomerDashboard> GetDashboardAsync(\n        [Service] IWhizbang whizbang,\n        Guid customerId\n    ) {\n        // Aggregate data from multiple services\n        var customer = await whizbang",
        "startIndex": 5512,
        "preview": "apps/v1 kind: Deployment metadata: name: orders-service spec: replicas: 3 template: spec: Init container runs BEFORE main container initContainers: na..."
      },
      {
        "id": "advanced/advanced-scenarios-chunk-3",
        "text": "for web frontend builder Services AddGraphQLServer() AddQueryType<WebQuery>() AddMutationType<WebMutation>(); var app = builder Build(); app MapGraphQL(); app Run(); // GraphQL types optimized for web UI public class WebQuery { public async Task<CustomerDashboard> GetDashboardAsync( [Service] IWhizbang whizbang, Guid customerId ) { // Aggregate data from multiple services var customer = await whizbang QueryAsync(new GetCustomer(customerId));\n        var orders = await whizbang QueryAsync(new GetCustomerOrders(customerId));\n        var recommendations = await whizbang QueryAsync(new GetRecommendations(customerId));\n        // Return web-optimized payload\n        return new CustomerDashboard(customer, orders, recommendations);\n    }\n}\n`\nMobile BFF (Optimized for Bandwidth)\n`csharp{\ntitle: \"Mobile BFF Implementation\"\ndescription: \"Backend-for-Frontend for mobile apps (minimal payloads)\"\nframework: \"NET8\"\ncategory: \"BFF\"\ndifficulty: \"ADVANCED\"\ntags: [\"BFF\", \"Mobile\", \"REST\"]\nnugetPackages: [\"Whizbang Core\", \"Microsoft AspNetCore\"]\nfilename: \"MobileBFF/Program cs\"\nusingStatements: [\"Microsoft AspNetCore Builder\", \"Microsoft AspNetCore Http\", \"Whizbang\", \"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Microsoft AspNetCore Builder;\nusing Microsoft AspNetCore Http;\nusing Whizbang;\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbangClient(/ /);\nvar app = builder Build();\n// Mobile-optimized endpoints (minimal payloads, pagination)\napp MapGet(\"/mobile/orders\", async (IWhizbang whizbang, Guid customerId, int page) => {\n    var orders = await whizbang QueryAsync(new GetCustomerOrders(customerId) {\n        Page = page,\n        PageSize = 20,  // Mobile shows 20 at a time\n        IncludeFields = new[] { \"id\", \"status\", \"total\", \"placedAt\" }  // Minimal fields\n    });\n    // Return mobile-friendly response\n    return Results Ok(new {\n        orders = orders Select(o => new {\n            id = o Id,\n            status = o Status,\n            total = $\"${o Total:F2}\",  // Pre-formatted for display\n            date = o PlacedAt ToString(\"MMM dd\")\n        }),\n        hasMore = orders Count == 20\n    });\n});\napp Run();\n`\nBFF Aggregation Pattern\nBFFs aggregate data from multiple services:\n`csharp{\ntitle: \"BFF Data Aggregation\"\ndescription: \"Aggregate data from multiple services in BFF\"\nframework: \"NET8\"\ncategory: \"BFF\"\ndifficulty: \"ADVANCED\"\ntags: [\"BFF\", \"Aggregation\", \"Microservices\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System",
        "startIndex": 8039,
        "preview": "for web frontend builder Services AddGraphQLServer() AddQueryType<WebQuery>() AddMutationType<WebMutation>(); var app = builder Build(); app MapGraphQ..."
      },
      {
        "id": "advanced/advanced-scenarios-chunk-4",
        "text": "orders Count == 20 }); }); app Run(); ` BFF Aggregation Pattern BFFs aggregate data from multiple services: `csharp{ title: \"BFF Data Aggregation\" description: \"Aggregate data from multiple services in BFF\" framework: \"NET8\" category: \"BFF\" difficulty: \"ADVANCED\" tags: [\"BFF\", \"Aggregation\", \"Microservices\"] nugetPackages: [\"Whizbang Core\"] usingStatements: [\"System\", \"System Threading Tasks\", \"System Linq\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Linq;\nusing System Threading Tasks;\nusing Whizbang;\npublic class OrderDetailsAggregator {\n    private readonly IWhizbang _whizbang;\n    public OrderDetailsAggregator(IWhizbang whizbang) {\n        _whizbang = whizbang;\n    }\n    public async Task<OrderDetailsViewModel> GetOrderDetailsAsync(Guid orderId) {\n        // Query multiple services in parallel\n        var orderTask = _whizbang QueryAsync(new GetOrder(orderId));\n        var customerTask = _whizbang QueryAsync(new GetCustomer(/ customerId from order /));\n        var inventoryTask = _whizbang QueryAsync(new GetInventoryStatus(orderId));\n        var shippingTask = _whizbang QueryAsync(new GetShippingStatus(orderId));\n        await Task WhenAll(orderTask, customerTask, inventoryTask, shippingTask);\n        // Aggregate into view model\n        return new OrderDetailsViewModel {\n            Order = orderTask Result,\n            Customer = customerTask Result,\n            Inventory = inventoryTask Result,\n            Shipping = shippingTask Result,\n            EstimatedDelivery = CalculateEstimatedDelivery(shippingTask Result)\n        };\n    }\n}\n`\n---\nCentral Control Commands\nCentral control plane for managing distributed services (configuration changes, projection rebuilds, diagnostics) Control Plane Architecture\n`\n┌────────────────────────────────────────┐\n│      Whizbang Control Dashboard        │\n│  (Web UI for operators/administrators) │\n└───────────────┬────────────────────────┘\n                │\n                ↓\n┌───────────────────────────────────────┐\n│       Control Plane Service           │\n│   (Sends control commands to services)│\n└───────────────┬───────────────────────┘\n                │\n       ┌────────┴────────┬──────────┐\n       ↓                 ↓          ↓\n┌──────────┐      ┌──────────┐  ┌──────────┐\n│ Orders   │      │Inventory │  │ Shipping │\n│ Service  │      │ Service  │  │ Service  │\n└──────────┘      └──────────┘  └──────────┘\n`\nControl Commands\n`csharp{\ntitle: \"Control Command Definitions\"\ndescription: \"Central commands for managing services\"\nframework: \"NET8\"\ncategory: \"Control Plane\"\ndifficulty: \"ADVANCED\"\ntags: [\"Control Plane\", \"Operations\", \"Commands\"]\nnugetPackages: [\"Whizbang ControlPlane\"]\nusingStatements: [\"System\", \"Whizbang ControlPlane\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang ControlPlane;\n// Rebuild a projection across all services\npublic record RebuildProjection(\n    string ProjectionName,\n    DateTimeOffset",
        "startIndex": 10230,
        "preview": "orders Count == 20 }); }); app Run(); ` BFF Aggregation Pattern BFFs aggregate data from multiple services: `csharp{ title: \"BFF Data Aggregation\" des..."
      },
      {
        "id": "advanced/advanced-scenarios-chunk-5",
        "text": "title: \"Control Command Definitions\" description: \"Central commands for managing services\" framework: \"NET8\" category: \"Control Plane\" difficulty: \"ADVANCED\" tags: [\"Control Plane\", \"Operations\", \"Commands\"] nugetPackages: [\"Whizbang ControlPlane\"] usingStatements: [\"System\", \"Whizbang ControlPlane\"] showLineNumbers: true } using System; using Whizbang ControlPlane; // Rebuild a projection across all services public record RebuildProjection( string ProjectionName, DateTimeOffset StartFrom = null\n) : ControlCommand;\n// Change log level dynamically\npublic record SetLogLevel(\n    string Category,\n    LogLevel Level\n) : ControlCommand;\n// Enable/disable feature flags\npublic record ToggleFeature(\n    string FeatureName,\n    bool Enabled\n) : ControlCommand;\n// Trigger health check\npublic record RunHealthCheck() : ControlCommand;\n// Clear caches\npublic record ClearCaches(\n    string[] CacheNames\n) : ControlCommand;\n`\nControl Command Handler\nServices implement handlers for control commands:\n`csharp{\ntitle: \"Control Command Handler\"\ndescription: \"Handle central control commands in services\"\nframework: \"NET8\"\ncategory: \"Control Plane\"\ndifficulty: \"ADVANCED\"\ntags: [\"Control Plane\", \"Handlers\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang ControlPlane\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Microsoft Extensions Logging\", \"Whizbang ControlPlane\", \"Whizbang Projections\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Microsoft Extensions Logging;\nusing Whizbang ControlPlane;\nusing Whizbang Projections;\npublic class RebuildProjectionHandler {\n    private readonly IProjectionEngine _projectionEngine;\n    private readonly ILogger _logger;\n    public RebuildProjectionHandler(IProjectionEngine projectionEngine, ILogger logger) {\n        _projectionEngine = projectionEngine;\n        _logger = logger;\n    }\n    public async Task Handle(RebuildProjection command) {\n        _logger LogWarning(\"Rebuilding projection {ProjectionName} from {StartFrom}\",\n            command ProjectionName,\n            command StartFrom DateTimeOffset MinValue\n        );\n        // Stop projection\n        await _projectionEngine StopProjectionAsync(command ProjectionName);\n        // Clear projection data\n        await _projectionEngine ClearProjectionAsync(command ProjectionName);\n        // Restart from specified point\n        await _projectionEngine StartProjectionAsync(command ProjectionName, command StartFrom);\n        _logger LogInformation(\"Projection {ProjectionName} rebuild started\", command ProjectionName);\n    }\n}\n`\nSending Control Commands\nFrom the control dashboard:\n`csharp{\ntitle: \"Sending Control Commands\"\ndescription: \"Send control commands from central dashboard\"\nframework: \"NET8\"\ncategory: \"Control Plane\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Control Plane\", \"Dashboard\"]\nnugetPackages: [\"Whizbang ControlPlane\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang",
        "startIndex": 12758,
        "preview": "title: \"Control Command Definitions\" description: \"Central commands for managing services\" framework: \"NET8\" category: \"Control Plane\" difficulty: \"AD..."
      },
      {
        "id": "advanced/advanced-scenarios-chunk-6",
        "text": "StartFrom); _logger LogInformation(\"Projection {ProjectionName} rebuild started\", command ProjectionName); } } ` Sending Control Commands From the control dashboard: `csharp{ title: \"Sending Control Commands\" description: \"Send control commands from central dashboard\" framework: \"NET8\" category: \"Control Plane\" difficulty: \"INTERMEDIATE\" tags: [\"Control Plane\", \"Dashboard\"] nugetPackages: [\"Whizbang ControlPlane\"] usingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang ControlPlane\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang ControlPlane;\npublic class ControlPlaneClient {\n    private readonly IWhizbangControlPlane _controlPlane;\n    public ControlPlaneClient(IWhizbangControlPlane controlPlane) {\n        _controlPlane = controlPlane;\n    }\n    public async Task RebuildProjectionAcrossAllServicesAsync(string projectionName) {\n        // Send command to ALL services that have this projection\n        await _controlPlane BroadcastAsync(new RebuildProjection(projectionName));\n    }\n    public async Task RebuildProjectionOnSpecificServiceAsync(string service, string projection) {\n        // Send command to specific service only\n        await _controlPlane SendToServiceAsync(service, new RebuildProjection(projection));\n    }\n    public async Task SetLogLevelGloballyAsync(string category, LogLevel level) {\n        // Change log level across all services\n        await _controlPlane BroadcastAsync(new SetLogLevel(category, level));\n    }\n}\n`\nNext Steps\nWhizbang Dashboard - Visual control plane\nObservability - Monitoring and tracing\nDistributed Messaging - Microservices architecture",
        "startIndex": 15240,
        "preview": "StartFrom); _logger LogInformation(\"Projection {ProjectionName} rebuild started\", command ProjectionName); } } ` Sending Control Commands From the con..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "advanced/configuration",
    "title": "Configuration",
    "category": "Advanced",
    "url": "/docs/advanced/configuration",
    "chunks": [
      {
        "id": "advanced/configuration-chunk-0",
        "text": "Configuration\nWhizbang provides a comprehensive configuration system that allows you to customize every aspect of the runtime, from storage backends to messaging systems, observability, and performance tuning Basic Configuration\nMinimal Setup\n`csharp\n// Program cs\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbang(options => {\n    // Scan assemblies for handlers, aggregates, and projections\n    options ScanAssembly(typeof(Program) Assembly);\n});\nvar app = builder Build();\napp Run();\n`\nWith Storage Backend\n`csharp\nbuilder Services AddWhizbang(options => {\n    options ScanAssembly(typeof(Program) Assembly);\n    // Configure event store\n    options UseEventSourcing(es => {\n        es UsePostgres(connectionString);\n        // or es UseSqlServer(connectionString);\n        // or es UseInMemory(); // for testing\n    });\n});\n`\nStorage Configuration\nEvent Store Options\n`csharp\noptions UseEventSourcing(es => {\n    es UsePostgres(connectionString, postgres => {\n        postgres SchemaName = \"events\";\n        postgres TableName = \"event_store\";\n        postgres SnapshotInterval = 100;\n        postgres EnableAutomaticMigrations = true;\n    });\n});\n`\nProjection Store Options\n`csharp\noptions UseProjections(proj => {\n    // Use same database as event store\n    proj UseSameStoreAsEvents();\n    // Or use different database\n    proj UsePostgres(projectionConnectionString, postgres => {\n        postgres SchemaName = \"projections\";\n        postgres EnableAutomaticMigrations = true;\n    });\n    // Or use MongoDB for projections\n    proj UseMongoDb(mongoConnectionString, mongo => {\n        mongo DatabaseName = \"whizbang_projections\";\n    });\n});\n`\nMessaging Configuration\nIn-Process Messaging\n`csharp\noptions UseMessaging(msg => {\n    msg UseInProcess(); // Default - all handlers run in same process\n});\n`\nDistributed Messaging\n`csharp\noptions UseMessaging(msg => {\n    msg UseKafka(kafka => {\n        kafka BootstrapServers = \"localhost:9092\";\n        kafka ConsumerGroup = \"whizbang-consumers\";\n        kafka EnableIdempotency = true;\n        kafka RetryPolicy = RetryPolicy ExponentialBackoff(\n            maxRetries: 5,\n            baseDelay: TimeSpan FromSeconds(1)\n        );\n    });\n    // or msg UseRabbitMQ( );\n    // or msg UseAzureServiceBus( );\n});\n`\nOutbox Pattern\n`csharp\noptions UseMessaging(msg => {\n    msg UseOutbox(outbox => {\n        outbox ProcessingInterval = TimeSpan FromSeconds(5);\n        outbox BatchSize = 100;\n        outbox RetryFailedMessages = true;\n        outbox MaxRetries = 3;\n    });\n});\n`\nHandler Configuration\nAssembly Scanning\n`csharp\noptions ScanAssembly(typeof(Program) Assembly);\noptions ScanAssemblies(\n    typeof(OrderHandlers)",
        "startIndex": 0,
        "preview": "Configuration\nWhizbang provides a comprehensive configuration system that allows you to customize every aspect of the runtime, from storage backends t..."
      },
      {
        "id": "advanced/configuration-chunk-1",
        "text": "); // or msg UseAzureServiceBus( ); }); ` Outbox Pattern `csharp options UseMessaging(msg => { msg UseOutbox(outbox => { outbox ProcessingInterval = TimeSpan FromSeconds(5); outbox BatchSize = 100; outbox RetryFailedMessages = true; outbox MaxRetries = 3; }); }); ` Handler Configuration Assembly Scanning `csharp options ScanAssembly(typeof(Program) Assembly); options ScanAssemblies( typeof(OrderHandlers) Assembly,\n    typeof(PaymentHandlers) Assembly\n);\n// Scan all assemblies in current directory\noptions ScanCurrentDirectory();\n`\nManual Registration\n`csharp\noptions RegisterHandlers(handlers => {\n    handlers RegisterCommandHandler<PlaceOrderHandler>();\n    handlers RegisterEventHandler<OrderPlacedHandler>();\n    handlers RegisterQueryHandler<GetOrderHandler>();\n});\n`\nHandler Lifetime\n`csharp\noptions ConfigureHandlers(handlers => {\n    handlers DefaultLifetime = ServiceLifetime Scoped;\n    // Override specific handlers\n    handlers SetLifetime<ExpensiveHandler>(ServiceLifetime Singleton);\n});\n`\nProjection Configuration\nRegistration and Subscriptions\n`csharp\noptions UseProjections(proj => {\n    proj RegisterProjection<OrderSummaryProjection>(p => {\n        p Subscribe<OrderPlacedEvent>();\n        p Subscribe<OrderShippedEvent>();\n        p Subscribe<OrderCancelledEvent>();\n        // Backfill from specific point\n        p BackfillFrom = DateTimeOffset UtcNow AddDays(-30);\n        // Partition by customer for parallel processing\n        p PartitionBy = @event => ((dynamic)@event) CustomerId;\n    });\n});\n`\nPerformance Tuning\n`csharp\nproj ConfigurePerformance(perf => {\n    perf BatchSize = 1000;\n    perf ConcurrentPartitions = Environment ProcessorCount;\n    perf CheckpointInterval = TimeSpan FromSeconds(10);\n    perf MaxLagBeforeAlert = TimeSpan FromMinutes(5);\n});\n`\nObservability Configuration\nOpenTelemetry Integration\n`csharp\noptions UseObservability(obs => {\n    obs UseOpenTelemetry(otel => {\n        otel ServiceName = \"my-whizbang-service\";\n        otel ServiceVersion = \"1 0 0\";\n        // Export to Jaeger\n        otel AddJaegerExporter(jaeger => {\n            jaeger Endpoint = new Uri(\"http://localhost:14268\");\n        });\n        // Export to Application Insights\n        otel AddApplicationInsightsExporter(ai => {\n            ai ConnectionString = builder Configuration GetConnectionString(\"ApplicationInsights\");\n        });\n    });\n    // Built-in metrics\n    obs EnableMetrics = true;\n    obs EnableHealthChecks = true;\n});\n`\nLogging Configuration\n`csharp\noptions UseLogging(logging => {\n    logging LogLevel = LogLevel Information;\n    logging LogCommands = true;\n    logging LogEvents = true;\n    logging LogQueries = false; // Can be noisy\n    // Structured logging\n    logging UseStructuredLogging = true;\n    logging IncludeCorrelationIds = true;\n});\n`\nSecurity Configuration\nAuthentication & Authorization\n`csharp\noptions",
        "startIndex": 2712,
        "preview": "); // or msg UseAzureServiceBus( ); }); ` Outbox Pattern `csharp options UseMessaging(msg => { msg UseOutbox(outbox => { outbox ProcessingInterval = T..."
      },
      {
        "id": "advanced/configuration-chunk-2",
        "text": "}); ` Logging Configuration `csharp options UseLogging(logging => { logging LogLevel = LogLevel Information; logging LogCommands = true; logging LogEvents = true; logging LogQueries = false; // Can be noisy // Structured logging logging UseStructuredLogging = true; logging IncludeCorrelationIds = true; }); ` Security Configuration Authentication & Authorization `csharp options UseSecurity(security => {\n    // Require authentication for all commands\n    security RequireAuthentication = true;\n    // Configure permissions\n    security ConfigureAuthorization(auth => {\n        auth RequirePermission<PlaceOrderCommand>(\"orders:write\");\n        auth RequirePermission<GetOrderQuery>(\"orders:read\");\n        // Role-based access\n        auth RequireRole<CancelOrderCommand>(\"OrderManager\");\n    });\n    // Multi-tenancy\n    security UseMultiTenancy(mt => {\n        mt TenantResolutionStrategy = TenantResolutionStrategy FromClaims;\n        mt TenantClaimType = \"tenant_id\";\n        mt IsolateTenantData = true;\n    });\n});\n`\nData Protection\n`csharp\noptions UseSecurity(security => {\n    security UseEncryption(encryption => {\n        encryption EncryptSensitiveFields = true;\n        encryption KeyRotationInterval = TimeSpan FromDays(90);\n        // Azure Key Vault integration\n        encryption UseAzureKeyVault(kv => {\n            kv VaultUri = \"https://my-vault vault azure net/\";\n            kv KeyName = \"whizbang-encryption-key\";\n        });\n    });\n});\n`\nPerformance Configuration\nConnection Pooling\n`csharp\noptions ConfigurePerformance(perf => {\n    perf DatabaseConnections = conn => {\n        conn MaxPoolSize = 100;\n        conn MinPoolSize = 10;\n        conn ConnectionTimeout = TimeSpan FromSeconds(30);\n        conn CommandTimeout = TimeSpan FromSeconds(60);\n    };\n});\n`\nCaching\n`csharp\noptions UseCaching(cache => {\n    cache UseDistributedCache(dist => {\n        dist UseRedis(redis => {\n            redis ConnectionString = \"localhost:6379\";\n            redis DatabaseNumber = 0;\n        });\n    });\n    // Cache aggregates for read-heavy scenarios\n    cache CacheAggregates = true;\n    cache AggregateCacheDuration = TimeSpan FromMinutes(5);\n    // Cache projection results\n    cache CacheProjections = true;\n    cache ProjectionCacheDuration = TimeSpan FromMinutes(1);\n});\n`\nEnvironment-Specific Configuration\nDevelopment Environment\n`csharp\nif (builder Environment IsDevelopment()) {\n    options UseDevelopmentDefaults(dev => {\n        dev UseInMemoryStorage = true;\n        dev EnableDetailedErrors = true;\n        dev LogAllQueries = true;\n        dev EnableSwagger = true;\n    });\n}\n`\nProduction Environment\n`csharp\nif (builder Environment IsProduction()) {\n    options UseProductionDefaults(prod => {\n        prod EnableOptimizations = true;\n        prod UseConnectionPooling = true;\n        prod EnableMetrics = true;\n        prod EnableHealthChecks = true;\n        prod",
        "startIndex": 5177,
        "preview": "}); ` Logging Configuration `csharp options UseLogging(logging => { logging LogLevel = LogLevel Information; logging LogCommands = true; logging LogEv..."
      },
      {
        "id": "advanced/configuration-chunk-3",
        "text": "=> { dev UseInMemoryStorage = true; dev EnableDetailedErrors = true; dev LogAllQueries = true; dev EnableSwagger = true; }); } ` Production Environment `csharp if (builder Environment IsProduction()) { options UseProductionDefaults(prod => { prod EnableOptimizations = true; prod UseConnectionPooling = true; prod EnableMetrics = true; prod EnableHealthChecks = true; prod LogLevel = LogLevel Warning;\n    });\n}\n`\nConfiguration from appsettings json\n`json\n{\n  \"Whizbang\": {\n    \"EventStore\": {\n      \"Provider\": \"Postgres\",\n      \"ConnectionString\": \"Host=localhost;Database=events;Username=user;Password=pass\",\n      \"SchemaName\": \"events\",\n      \"SnapshotInterval\": 100\n    },\n    \"Messaging\": {\n      \"Provider\": \"Kafka\",\n      \"BootstrapServers\": \"localhost:9092\",\n      \"ConsumerGroup\": \"my-service-consumers\"\n    },\n    \"Projections\": {\n      \"BatchSize\": 1000,\n      \"ConcurrentPartitions\": 4,\n      \"CheckpointInterval\": \"00:00:10\"\n    },\n    \"Observability\": {\n      \"ServiceName\": \"my-whizbang-service\",\n      \"EnableMetrics\": true,\n      \"LogLevel\": \"Information\"\n    }\n  }\n}\n`\n`csharp\n// Load from configuration\noptions ConfigureFromSection(builder Configuration GetSection(\"Whizbang\"));\n`\nValidation and Diagnostics\nConfiguration Validation\n`csharp\noptions ValidateConfiguration = true;\noptions ValidateOnStartup = true;\n// Custom validation\noptions AddConfigurationValidator<CustomConfigValidator>();\n`\nHealth Checks\n`csharp\nbuilder Services AddHealthChecks() AddWhizbangHealthChecks(); // Adds event store, projections, messaging health checks\n`\nRelated Topics\nGetting Started - Basic setup and configuration\nPackage Structure - Available NuGet packages and adapters NET Aspire Integration - Cloud-native configuration\nAdvanced Scenarios - Complex configuration patterns\nNext Steps\nThis page covers the core configuration options in Whizbang For specific deployment scenarios and advanced patterns, refer to the specialized documentation sections",
        "startIndex": 4849,
        "preview": "=> { dev UseInMemoryStorage = true; dev EnableDetailedErrors = true; dev LogAllQueries = true; dev EnableSwagger = true; }); } ` Production Environmen..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "architecture-design/architecture",
    "title": "Architecture Overview",
    "category": "Architecture & Design",
    "url": "/docs/architecture-design/architecture",
    "chunks": [
      {
        "id": "architecture-design/architecture-chunk-0",
        "text": "Architecture Overview\nWhizbang is built on a layered architecture that supports scaling from a simple in-process mediator to a full distributed event-sourced system Architectural Layers\n`\n┌─────────────────────────────────────────────────────────────┐\n│                     Application Layer                       │\n│  (Your Domain Code: Aggregates, Projections, Handlers)      │\n└─────────────────────────────────────────────────────────────┘\n                            ↓\n┌─────────────────────────────────────────────────────────────┐\n│                    Whizbang Runtime                          │\n│  • Message Routing        • Event Sourcing Engine            │\n│  • Command Handling       • Projection Management            │\n│  • Event Publishing       • Saga Coordination                │\n│  • Idempotence            • Observability Pipeline           │\n└─────────────────────────────────────────────────────────────┘\n                            ↓\n┌─────────────────────────────────────────────────────────────┐\n│                      Driver Layer                            │\n│  • Persistence Drivers    • Message Broker Adapters          │\n│  • Serialization Drivers  • Telemetry Drivers                │\n└─────────────────────────────────────────────────────────────┘\n                            ↓\n┌─────────────────────────────────────────────────────────────┐\n│                   Infrastructure                             │\n│  • Databases              • Message Brokers                  │\n│  • Telemetry Backends     • Service Discovery                │\n└─────────────────────────────────────────────────────────────┘\n`\nCore Components\nMessage Router\nThe Message Router is the heart of Whizbang It:\nRoutes commands to their owning domain's handlers\nPublishes events to all interested subscribers\nExecutes queries against projections\nCoordinates sagas across long-running processes\nAll message routing respects domain ownership—commands must be sent to the service that owns that aggregate, while events are broadcast from the owning domain to subscribers Event Store\nThe Event Store is the source of truth for all state changes It:\nAppends events to immutable streams (one stream per aggregate)\nSupports time-based queries (get all events before/after a timestamp)\nEnables backfilling new projections from historical events\nProvides global ordering for cross-aggregate event streams\nImplements optimistic concurrency for aggregate updates\nThe Event Store is driver-based, supporting:\nPostgres (JSONB + sequential IDs)\nSQL Server (JSON columns + IDENTITY)\nMySQL (JSON columns + auto-increment)\nCosmos DB (native event streams)\nLiteFS/SQLite (binary codec for edge deployments)\nProjection Engine\nThe Projection Engine builds read models from event streams",
        "startIndex": 0,
        "preview": "Architecture Overview\nWhizbang is built on a layered architecture that supports scaling from a simple in-process mediator to a full distributed event-..."
      },
      {
        "id": "architecture-design/architecture-chunk-1",
        "text": "Implements optimistic concurrency for aggregate updates The Event Store is driver-based, supporting: Postgres (JSONB + sequential IDs) SQL Server (JSON columns + IDENTITY) MySQL (JSON columns + auto-increment) Cosmos DB (native event streams) LiteFS/SQLite (binary codec for edge deployments) Projection Engine The Projection Engine builds read models from event streams It:\nSubscribes to event streams (local or from remote services)\nApplies events to projection handlers in order\nTracks checkpoint positions to resume after restarts\nSupports parallel processing across partitions\nHandles schema migrations for evolving projections\nProjections can be:\nInline - Updated synchronously within the same transaction as event append\nAsync - Updated in background workers for eventual consistency\nCached - Materialized in-memory for ultra-low latency\nExternal - Pushed to Elasticsearch, Redis, or other specialized stores\nCommand & Event Pipeline\nThe Pipeline provides hooks for cross-cutting concerns:\n`\nIncoming Message\n      ↓\n  Validation\n      ↓\n  Authorization\n      ↓\n  Idempotence Check\n      ↓\n  OpenTelemetry Trace\n      ↓\n  Handler Execution\n      ↓\n  Event Append / Projection Update\n      ↓\n  Outbox Write (if distributed)\n      ↓\n  Response / New Messages\n`\nEvery stage is pluggable and observable Saga Coordinator\nSagas orchestrate long-running processes across multiple aggregates or services Whizbang supports two saga styles:\nOrchestration - A central coordinator issues commands and listens for events:\n`csharp\npublic class OrderFulfillmentSaga : Saga {\n    public async Task Handle(OrderPlaced @event) {\n        await Send(new ReserveInventory(@event OrderId));\n    }\n    public async Task Handle(InventoryReserved @event) {\n        await Send(new ChargePayment(@event OrderId));\n    }\n    public async Task Handle(PaymentCharged @event) {\n        await Send(new ShipOrder(@event OrderId));\n    }\n}\n`\nChoreography - Each service reacts to events and publishes new ones (no central coordinator) Sagas are persisted as event streams and can be replayed or debugged like any other aggregate",
        "startIndex": 2774,
        "preview": "Implements optimistic concurrency for aggregate updates The Event Store is driver-based, supporting: Postgres (JSONB + sequential IDs) SQL Server (JSO..."
      },
      {
        "id": "architecture-design/architecture-chunk-2",
        "text": "@event) { await Send(new ChargePayment(@event OrderId)); } public async Task Handle(PaymentCharged @event) { await Send(new ShipOrder(@event OrderId)); } } ` Choreography - Each service reacts to events and publishes new ones (no central coordinator) Sagas are persisted as event streams and can be replayed or debugged like any other aggregate Outbox/Inbox Pattern\nFor distributed messaging, Whizbang implements the Outbox/Inbox pattern to ensure exactly-once delivery:\nOutbox (Publishing Service):\nHandler executes and appends events to event store\nEvents also written to outbox table in same transaction\nBackground worker publishes outbox messages to message broker\nMessages marked as published after broker confirms\nInbox (Subscribing Service):\nMessage arrives from broker\nStored in inbox table with unique message ID\nIf message ID exists (duplicate), skip processing\nOtherwise, process handler and mark message as complete\nPeriodic cleanup of old inbox entries\nThis pattern guarantees at-least-once delivery from the broker combined with idempotent handling for exactly-once semantics Domain Ownership Model\nWhizbang enforces explicit domain ownership to prevent distributed system chaos Commands\nCommands are sent TO the service that owns the aggregate:\n`csharp\n[OwnedBy(\"Orders\")]  // This command belongs to the Orders service\npublic record PlaceOrder(Guid OrderId, Guid CustomerId, List<OrderItem> Items);\n`\nWhen you send a command:\nIn a monolith, it's routed to the local handler\nIn microservices, it's routed to the Orders service via the message broker\nEvents\nEvents are emitted FROM the service that owns the domain:\n`csharp\n[OwnedBy(\"Orders\")]  // This event comes from the Orders service\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt);\n`\nOther services can subscribe to OrderPlaced events:\nIn a monolith, subscribers get events via in-process pub/sub\nIn microservices, subscribers get events from the message broker topic\nBackfilling Projections\nWhen a new service subscribes to events for the first time, it can backfill from the beginning:\n`csharp\nservices AddProjection<OrderHistoryProjection>(options => {\n    options",
        "startIndex": 4509,
        "preview": "@event) { await Send(new ChargePayment(@event OrderId)); } public async Task Handle(PaymentCharged @event) { await Send(new ShipOrder(@event OrderId))..."
      },
      {
        "id": "architecture-design/architecture-chunk-3",
        "text": "services can subscribe to OrderPlaced events: In a monolith, subscribers get events via in-process pub/sub In microservices, subscribers get events from the message broker topic Backfilling Projections When a new service subscribes to events for the first time, it can backfill from the beginning: `csharp services AddProjection<OrderHistoryProjection>(options => { options Subscribe<OrderPlaced>();\n    options Subscribe<OrderShipped>();\n    options BackfillFrom = DateTimeOffset MinValue;  // Start from the beginning\n});\n`\nThe projection engine will:\nQuery the Orders service's event store for all historical events\nApply them to the projection in order\nContinue processing new events as they arrive\nThis allows new projections to be built from existing event history Scaling Patterns\nSingle Process (Mediator Mode)\n`\n┌─────────────────────────────┐\n│   ASP",
        "startIndex": 6338,
        "preview": "services can subscribe to OrderPlaced events: In a monolith, subscribers get events via in-process pub/sub In microservices, subscribers get events fr..."
      },
      {
        "id": "architecture-design/architecture-chunk-4",
        "text": "` The projection engine will: Query the Orders service's event store for all historical events Apply them to the projection in order Continue processing new events as they arrive This allows new projections to be built from existing event history Scaling Patterns Single Process (Mediator Mode) ` ┌─────────────────────────────┐ │ ASP NET Core Web API      │\n│                             │\n│  ┌──────────────────────┐   │\n│  │  Whizbang Runtime    │   │\n│  │  (In-Memory)         │   │\n│  └──────────────────────┘   │\n│           ↓                 │\n│  ┌──────────────────────┐   │\n│  │  SQLite / Postgres   │   │\n│  └──────────────────────┘   │\n└─────────────────────────────┘\n`\nPerfect for:\nMonolithic applications\nLocal development\nSimple CQRS without microservices\nMulti-Service (Distributed)\n`\n┌─────────────┐      ┌─────────────┐      ┌─────────────┐\n│   Orders    │      │  Inventory  │      │  Shipping   │\n│   Service   │      │   Service   │      │   Service   │\n│             │      │             │      │             │\n│  Whizbang   │      │  Whizbang   │      │  Whizbang   │\n│             │      │             │      │             │\n│  Postgres   │      │  Postgres   │      │  Postgres   │\n└──────┬──────┘      └──────┬──────┘      └──────┬──────┘\n       │                    │                    │\n       └────────────┬───────┴────────────────────┘\n                    ↓\n          ┌──────────────────┐\n          │  Kafka / RabbitMQ│\n          │  (Message Broker)│\n          └──────────────────┘\n`\nEach service:\nHas its own event store for database isolation\nPublishes events to the shared message broker\nSubscribes to events from other services\nRoutes commands to owning services\nMulti-Region (Disaster Recovery)\n`\n        Region 1                         Region 2\n┌─────────────────────┐         ┌─────────────────────┐\n│  Primary Services   │         │  Replica Services   │\n│                     │         │                     │\n│  Event Stores       │◄───────►│  Event Stores       │\n│  (Postgres)         │  Sync   │  (Postgres)         │\n└─────────────────────┘         └─────────────────────┘\n         ↓                               ↓\n┌─────────────────────┐         ┌─────────────────────┐\n│  Kafka Cluster      │◄───────►│  Kafka Cluster      │\n│  (Region 1)         │  Mirror │  (Region 2)         │\n└─────────────────────┘         └─────────────────────┘\n`\nEvent streams are replicated across regions for disaster recovery Region 2 can take over if Region 1 fails",
        "startIndex": 6826,
        "preview": "` The projection engine will: Query the Orders service's event store for all historical events Apply them to the projection in order Continue processi..."
      },
      {
        "id": "architecture-design/architecture-chunk-5",
        "text": "│ (Postgres) │ Sync │ (Postgres) │ └─────────────────────┘ └─────────────────────┘ ↓ ↓ ┌─────────────────────┐ ┌─────────────────────┐ │ Kafka Cluster │◄───────►│ Kafka Cluster │ │ (Region 1) │ Mirror │ (Region 2) │ └─────────────────────┘ └─────────────────────┘ ` Event streams are replicated across regions for disaster recovery Region 2 can take over if Region 1 fails Message Execution Modes\nWhizbang supports three execution modes, all using the same handler code:\nInline Mode\nHandler executes synchronously within the caller's transaction:\n`csharp\nvar result = await whizbang Send(new PlaceOrder( ));\n// Handler executed, events appended, projections updated—all before returning\n`\nBest for:\nStrong consistency requirements\nSimple CRUD operations\nLocal development\nDurable Mode\nHandler executes asynchronously in a background worker:\n`csharp\nawait whizbang Publish(new PlaceOrder( ));\n// Command written to queue, returns immediately\n// Handler executes in background worker\n`\nBest for:\nHigh throughput\nNon-blocking operations\nEventual consistency scenarios\nBatched Mode\nMultiple messages batched together for efficiency:\n`csharp\nawait whizbang PublishBatch(new[] {\n    new PlaceOrder( ),\n    new PlaceOrder( ),\n    new PlaceOrder( )\n});\n// All three commands processed in one batch for better throughput\n`\nBest for:\nBulk imports\nScheduled jobs\nData migration\nThe same handler code works in all three modes Toggle via configuration, not code changes Next Steps\nNow that you understand the overall architecture, dive into:\nCore Concepts - Deep dive into Events, Commands, Aggregates, Projections\nPackage Structure - Which NuGet packages to install\nGetting Started - Build your first Whizbang application",
        "startIndex": 8987,
        "preview": "│ (Postgres) │ Sync │ (Postgres) │ └─────────────────────┘ └─────────────────────┘ ↓ ↓ ┌─────────────────────┐ ┌─────────────────────┐ │ Kafka Cluster..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "architecture-design/philosophy",
    "title": "Philosophy & Design Principles",
    "category": "Architecture & Design",
    "url": "/docs/architecture-design/philosophy",
    "chunks": [
      {
        "id": "architecture-design/philosophy-chunk-0",
        "text": "Philosophy & Design Principles\nWhizbang is a unified event-sourced data and messaging runtime for NET that collapses the complexity of MartenDB, Wolverine, MassTransit, and MediatR into a single cohesive platform with one mental model Core Philosophy\nEvents as the Source of Truth\nEvents are immutable facts that have happened In Whizbang, events are not just notifications—they are the authoritative record of everything that has occurred in your system All aggregates and projections can be rebuilt or reimagined from the event stream at any time, even years after initial deployment This approach provides:\nComplete audit trail - Every state change is recorded forever\nTime travel debugging - Replay events to understand how state evolved\nFlexible projections - Build new read models from existing events\nMigration freedom - Refactor your domain model without losing history\nSingle Surface Area\nTeams waste cognitive energy context-switching between different APIs, patterns, and abstractions Whizbang provides one set of primitives for:\nAggregates - Write-side domain models that enforce business rules\nProjections - Read-side models optimized for queries\nCommands - Requests to change state, routed to domain owners\nQueries - Requests for data, executed against projections\nSagas - Long-running processes that coordinate across domains\nAll of these concepts share the same handler model, dependency injection patterns, and testing approaches Learn once, apply everywhere From Simple to Scale\nWhizbang is designed for the full spectrum:\nSimple Start: Use Whizbang as an in-process mediator for CQRS without any infrastructure dependencies Perfect for small apps or getting started Growth Path: Add event sourcing, projections, and persistence as your needs grow Every feature is opt-in Enterprise Scale: Deploy across microservices with message brokers, multiple databases, multi-region disaster recovery, and Kubernetes auto-scaling The same code works at every scale Your simple mediator handlers become distributed message handlers without rewrites",
        "startIndex": 0,
        "preview": "Philosophy & Design Principles\nWhizbang is a unified event-sourced data and messaging runtime for NET that collapses the complexity of MartenDB, Wolve..."
      },
      {
        "id": "architecture-design/philosophy-chunk-1",
        "text": "started Growth Path: Add event sourcing, projections, and persistence as your needs grow Every feature is opt-in Enterprise Scale: Deploy across microservices with message brokers, multiple databases, multi-region disaster recovery, and Kubernetes auto-scaling The same code works at every scale Your simple mediator handlers become distributed message handlers without rewrites Design Principles\nDriver-Based Architecture\nNever lock into a specific technology Whizbang uses a driver-based system for:\nPersistence - Postgres, SQL Server, MySQL, Cosmos DB, LiteFS/SQLite\nMessaging - Kafka, RabbitMQ, Azure Service Bus, AWS SQS, in-memory\nSerialization - JSON, Protobuf, MessagePack, custom formats\nObservability - OpenTelemetry, Application Insights, custom telemetry\nSwap drivers through configuration, not code changes Start with SQLite for local dev, move to Postgres in staging, scale to Cosmos DB in production—all with the same domain code Domain Ownership\nEvery event and command has a home In distributed systems, clarity about ownership prevents chaos:\nCommands are sent TO the domain that owns them\nEvents are emitted FROM the domain that owns them\nNew services can subscribe to events and backfill projections from the entire event stream\nDomain boundaries are explicit in code and configuration\nThis prevents the \"event spaghetti\" problem where no one knows who publishes what, or where to send commands Handlers as Pure Functions\nHandlers are just Cmethods that return results or new messages No magic base classes, no required interfaces (unless you want them), no framework coupling Mark a handler as pure and the Roslyn analyzer forbids hidden side effects—guaranteeing your handler is a true function from input to output Observable by Default\nProblems found in production are 10x more expensive than problems found in development",
        "startIndex": 2071,
        "preview": "started Growth Path: Add event sourcing, projections, and persistence as your needs grow Every feature is opt-in Enterprise Scale: Deploy across micro..."
      },
      {
        "id": "architecture-design/philosophy-chunk-2",
        "text": "classes, no required interfaces (unless you want them), no framework coupling Mark a handler as pure and the Roslyn analyzer forbids hidden side effects—guaranteeing your handler is a true function from input to output Observable by Default Problems found in production are 10x more expensive than problems found in development Whizbang includes:\nOpenTelemetry traces for every message, event, and projection\nLive dashboard showing message lag, projection health, and error rates\nDistributed tracing across services and message brokers\nPerformance budgets that alert when handlers exceed latency targets\nObservability is not bolted on—it's built into the core runtime Idempotence Everywhere\nMessages may be delivered more than once Whizbang ensures:\nExactly-once semantics for event handling and projection updates\nAutomatic deduplication based on message IDs\nOutbox/Inbox pattern for reliable message delivery across service boundaries\nIdempotent consumers that can safely process the same event multiple times\nYour domain logic never needs to worry about duplicate messages AOT-Safe and Trimming-Friendly\nModern NET deployments demand small binaries and fast startup Whizbang is designed for:\nNative AOT compilation - No reflection tricks that break AOT\nAssembly trimming - Only include what you use\nFast startup - No slow reflection-based scanning\nSource generators - Compile-time code generation for wire-up\nDeploy as a tiny container or serverless function without compromise Security and Multi-Tenancy First\nSecurity is not an afterthought Whizbang provides built-in support for:\nMulti-tenancy - Tenant isolation at the event stream, projection, and command level\nPermission scoping - Fine-grained authorization for commands, queries, and events\nTrusted/untrusted boundaries - Separate handling for internal vs external services\nAudit logging - Track who did what, when, and why\nData encryption - At-rest and in-transit encryption support\nMulti-tenant architecture:\nTenant ID propagated through all message contexts\nTenant-scoped event streams (e g",
        "startIndex": 3548,
        "preview": "classes, no required interfaces (unless you want them), no framework coupling Mark a handler as pure and the Roslyn analyzer forbids hidden side effec..."
      },
      {
        "id": "architecture-design/philosophy-chunk-3",
        "text": "- Fine-grained authorization for commands, queries, and events Trusted/untrusted boundaries - Separate handling for internal vs external services Audit logging - Track who did what, when, and why Data encryption - At-rest and in-transit encryption support Multi-tenant architecture: Tenant ID propagated through all message contexts Tenant-scoped event streams (e g , Tenant-{tenantId}-Order-{orderId})\nTenant-specific projections and read models\nCross-tenant operations prevented by default\nPermission model:\nCommands require explicit permissions (e g , orders:place, inventory:reserve)\nQueries can be scoped to accessible data only\nEvents carry identity context for audit trails\nRoslyn analyzer enforces authorization checks\nService trust boundaries:\nInternal services (trusted) can access raw event streams\nExternal services (untrusted) receive filtered, sanitized events\nAPI gateways enforce authentication and authorization\nService-to-service authentication via mutual TLS or tokens\nOpinionated Recipes, Flexible Foundation\nWhizbang provides opinionated recipes to prevent analysis paralysis:\nStarter templates for common scenarios (web API, worker service, microservice)\nBest practice examples for aggregates, sagas, projections\nConvention-based configuration that \"just works\" out of the box\nBut under the hood, everything is pluggable:\nSwap drivers\nOverride conventions\nCustomize serialization\nExtend the pipeline\nYou're not locked into our opinions if your scenario demands something different Comparison to Existing Tools\nvs Marten + Wolverine (The \"Critter Stack\")\nWhat they are: Marten is a document database and event store for PostgreSQL Wolverine is a messaging and mediator framework Together they form the \"Critter Stack\"—the most mature CQRS/ES stack in NET as of 2025 Strengths:\nBattle-tested in production since 2016\nExcellent PostgreSQL integration with partitioning, snapshotting, and \"Quick Append\"\nFull OpenTelemetry and metrics support\n\"Aggregate handler workflow\" for clean CQRS\nWhizbang Differences:\nMulti-database: Marten is PostgreSQL-only Whizbang supports Postgres, SQL Server, MySQL, Cosmos DB, and SQLite through drivers Unified runtime: Marten + Wolverine are two separate libraries Whizbang is a single, cohesive runtime",
        "startIndex": 5282,
        "preview": "- Fine-grained authorization for commands, queries, and events Trusted/untrusted boundaries - Separate handling for internal vs external services Audi..."
      },
      {
        "id": "architecture-design/philosophy-chunk-4",
        "text": "with partitioning, snapshotting, and \"Quick Append\" Full OpenTelemetry and metrics support \"Aggregate handler workflow\" for clean CQRS Whizbang Differences: Multi-database: Marten is PostgreSQL-only Whizbang supports Postgres, SQL Server, MySQL, Cosmos DB, and SQLite through drivers Unified runtime: Marten + Wolverine are two separate libraries Whizbang is a single, cohesive runtime Domain ownership: Whizbang enforces explicit domain ownership for distributed systems (commands TO owner, events FROM owner) Multi-tenancy first: Built-in tenant isolation at the event stream, projection, and command level Aspire integration: First-class NET Aspire support with one-command local dev setup Lakehouse streaming: Stream events to Delta Lake, Iceberg, or Parquet for analytics Dashboard: Dedicated web dashboard for message journey visualization and control plane When to choose Marten + Wolverine: You're committed to PostgreSQL and want the most mature, proven stack When to choose Whizbang: You need multi-database support, tighter integration, multi-tenancy, or advanced features like lakehouse streaming ---\nvs MediatR\nWhat it is: MediatR is a simple in-process mediator for implementing CQRS in a single application Used by thousands of NET projects Strengths:\nExtremely simple and lightweight\nNo infrastructure dependencies\nPerfect for monolithic applications\nMinimal learning curve\nWhizbang Differences:\nEvent sourcing: MediatR has no event sourcing Whizbang includes full event store support Projections: MediatR has no read model support Whizbang includes projection engine Distributed messaging: MediatR is in-process only Whizbang scales to microservices Growth path: With MediatR, scaling to distributed requires a complete rewrite With Whizbang, the same handler code works at every scale When to choose MediatR: You're building a simple monolith and will never need event sourcing or microservices When to choose Whizbang: You want a growth path from simple to complex without rewrites ---\nvs MassTransit\nWhat it is: MassTransit is a mature distributed messaging framework for NET Supports RabbitMQ, Azure Service Bus, Amazon SQS, and more",
        "startIndex": 7182,
        "preview": "with partitioning, snapshotting, and \"Quick Append\" Full OpenTelemetry and metrics support \"Aggregate handler workflow\" for clean CQRS Whizbang Differ..."
      },
      {
        "id": "architecture-design/philosophy-chunk-5",
        "text": "a simple monolith and will never need event sourcing or microservices When to choose Whizbang: You want a growth path from simple to complex without rewrites --- vs MassTransit What it is: MassTransit is a mature distributed messaging framework for NET Supports RabbitMQ, Azure Service Bus, Amazon SQS, and more Open source (Apache 2 0) Strengths:\nMature message routing, retries, and error handling\nExcellent transport abstraction (RabbitMQ, Azure Service Bus, etc )\nSaga support for long-running processes\nFree for production use\nWhizbang Differences:\nEvent sourcing: MassTransit has no event sourcing Whizbang includes event store Projections: MassTransit has no read model support Whizbang includes projection engine All-in-one: MassTransit focuses on messaging Whizbang integrates messaging + event sourcing + projections Mediator: MassTransit requires a broker even for in-process Whizbang starts as a simple mediator When to choose MassTransit: You only need messaging and already have event sourcing/projections handled separately When to choose Whizbang: You want a unified platform for CQRS/ES with messaging built-in ---\nvs NServiceBus\nWhat it is: NServiceBus is the enterprise-grade service bus for NET from Particular Software The most feature-rich messaging framework Strengths:\nComprehensive tooling (ServicePulse, ServiceInsight for monitoring)\nEnterprise support and training available\nBattle-tested in large-scale systems\nAdvanced error handling and sagas\nWhizbang Differences:\nLicensing: NServiceBus requires paid license for production Whizbang is open source Event sourcing: NServiceBus has no event sourcing Whizbang includes event store Projections: NServiceBus has no read model engine Whizbang includes projection engine Dashboard: NServiceBus has separate tools (ServicePulse, ServiceInsight) Whizbang has integrated dashboard When to choose NServiceBus: You need enterprise support and are willing to pay for it When to choose Whizbang: You want open-source, all-in-one CQRS/ES with messaging ---\nvs Equinox\nWhat it is: Equinox is an event sourcing library from Jet com (Walmart) Supports CosmosDB, DynamoDB, EventStoreDB, and SqlStreamStore backends",
        "startIndex": 8977,
        "preview": "a simple monolith and will never need event sourcing or microservices When to choose Whizbang: You want a growth path from simple to complex without r..."
      },
      {
        "id": "architecture-design/philosophy-chunk-6",
        "text": "dashboard When to choose NServiceBus: You need enterprise support and are willing to pay for it When to choose Whizbang: You want open-source, all-in-one CQRS/ES with messaging --- vs Equinox What it is: Equinox is an event sourcing library from Jet com (Walmart) Supports CosmosDB, DynamoDB, EventStoreDB, and SqlStreamStore backends F#-first design Strengths:\nPolyglot storage (CosmosDB, DynamoDB, EventStoreDB, etc )\nSophisticated caching strategies\nFunctional programming approach (Ffirst)\nLibrary, not framework (lightweight coupling)\nWhizbang Differences:\nC#-first: Equinox is F#-first Whizbang is designed for Cdevelopers Messaging: Equinox has no built-in messaging Whizbang includes distributed messaging Projections: Equinox requires separate Propulsion library Whizbang includes projection engine Dashboard: Equinox has no dashboard Whizbang includes web dashboard Aspire: Equinox has no Aspire integration Whizbang has first-class Aspire support When to choose Equinox: You're building in Fand want a lightweight library When to choose Whizbang: You're building in Cand want an integrated framework ---\nvs EventStoreDB\nWhat it is: EventStoreDB is a purpose-built event store database The gold standard for event sourcing since 2012 Strengths:\nPurpose-built for event sourcing\nProjections built into the database\nCatchup subscriptions and persistent subscriptions\nMature and proven\nWhizbang Differences:\nDatabase dependency: EventStoreDB is a separate database to run Whizbang works with databases you already have (Postgres, SQL Server, etc ) CQRS framework: EventStoreDB is just storage Whizbang includes mediator, messaging, projections, and dashboard Driver-based: Whizbang isn't locked to one database EventStoreDB is a single product When to choose EventStoreDB: You want the absolute best event store and are willing to run a dedicated database When to choose Whizbang: You want an all-in-one framework using databases you already have",
        "startIndex": 10871,
        "preview": "dashboard When to choose NServiceBus: You need enterprise support and are willing to pay for it When to choose Whizbang: You want open-source, all-in-..."
      },
      {
        "id": "architecture-design/philosophy-chunk-7",
        "text": "mediator, messaging, projections, and dashboard Driver-based: Whizbang isn't locked to one database EventStoreDB is a single product When to choose EventStoreDB: You want the absolute best event store and are willing to run a dedicated database When to choose Whizbang: You want an all-in-one framework using databases you already have ---\nSummary Comparison\n| Feature | Whizbang | Marten + Wolverine | MediatR | MassTransit | NServiceBus | Equinox | EventStoreDB |\n|---------|----------|-------------------|---------|-------------|-------------|---------|--------------|\n| Event Sourcing | ✅ Built-in | ✅ Marten | ❌ | ❌ | ❌ | ✅ Library | ✅ Database |\n| Projections | ✅ Built-in | ✅ Marten | ❌ | ❌ | ❌ | ⚠️ Propulsion | ✅ Built-in |\n| Messaging | ✅ Built-in | ✅ Wolverine | ❌ | ✅ Core focus | ✅ Core focus | ❌ | ❌ |\n| Mediator | ✅ Built-in | ✅ Wolverine | ✅ Core focus | ⚠️ Via broker | ❌ | ❌ | ❌ |\n| Multi-database | ✅ Yes | ❌ Postgres only | N/A | N/A | N/A | ✅ Yes | ❌ Own DB |\n| Dashboard | ✅ Included | ❌ | ❌ | ❌ | ✅ Paid tools | ❌ | ✅ UI |\n| Multi-tenancy | ✅ First-class | ⚠️ Manual | ❌ | ❌ | ❌ | ❌ | ❌ |\n| Aspire | ✅ First-class | ⚠️ Community | ❌ | ⚠️ Community | ❌ | ❌ | ⚠️ Community |\n| License | 🟢 Open source | 🟢 Open source | 🟢 Open source | 🟢 Apache 2 0 | 🔴 Commercial | 🟢 Apache 2",
        "startIndex": 12514,
        "preview": "mediator, messaging, projections, and dashboard Driver-based: Whizbang isn't locked to one database EventStoreDB is a single product When to choose Ev..."
      },
      {
        "id": "architecture-design/philosophy-chunk-8",
        "text": "| ❌ | | Aspire | ✅ First-class | ⚠️ Community | ❌ | ⚠️ Community | ❌ | ❌ | ⚠️ Community | | License | 🟢 Open source | 🟢 Open source | 🟢 Open source | 🟢 Apache 2 0 | 🔴 Commercial | 🟢 Apache 2 0 | 🟡 Free/Paid |\n| Cvs F# | C#-first | C#-first | C#-first | C#-first | C#-first | F#-first | Language-agnostic |\nKey Insight: Whizbang is the only library that combines event sourcing, projections, messaging, mediator, multi-tenancy, and dashboard into a single, cohesive runtime with multi-database support Our Stance\nWe believe:\nEvents are more valuable than current state\nDomain ownership prevents distributed system chaos\nPure functions are easier to test and reason about\nObservability must be built in, not bolted on\nAOT and small binaries matter for modern deployments\nDevelopers should never be locked into a specific database or message broker\nSimple scenarios should stay simple; complex scenarios should be possible\nNext Steps\nNow that you understand Whizbang's philosophy and design principles:\nGetting Started - Build your first Whizbang application with a step-by-step tutorial\nPackage Structure - Learn about all available NuGet packages and their dependencies\nCore Concepts - Deep dive into commands, events, projections, and aggregates\nWe are building Whizbang to be the pit of success for event-sourced, message-driven systems in NET",
        "startIndex": 13481,
        "preview": "| ❌ | | Aspire | ✅ First-class | ⚠️ Community | ❌ | ⚠️ Community | ❌ | ❌ | ⚠️ Community | | License | 🟢 Open source | 🟢 Open source | 🟢 Open source..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "commands/command-handling",
    "title": "Command Handling",
    "category": "Commands",
    "url": "/docs/commands/command-handling",
    "chunks": [
      {
        "id": "commands/command-handling-chunk-0",
        "text": "Command Handling\nCommands represent intent or actions in your system Command handlers contain business logic, validate commands, apply business rules, and emit events to record what happened CRITICAL: Events Can ONLY Be Emitted via Command Handling\nEvents are the result of command processing - they cannot be created directly You must send a command to emit an event `mermaid\nsequenceDiagram\n    participant User\n    participant API as API/Service\n    participant Handler as Command Handler\n    participant Context as CommandContext\n    participant EventStore as Event Store\n    participant Projection as Projections\n    User->>API: Send Command<br/>(PlaceOrder)\n    API->>Handler: Handle(command, context)\n    Note over Handler: ✅ Validate command<br/>✅ Apply business rules<br/>✅ Make decisions\n    Handler->>Context: EmitEvent(OrderPlaced)<br/>⚠️ ONLY way to create events\n    Context->>Context: Populate EventContext<br/>(user, tenant, timestamp)\n    Context->>EventStore: Append event\n    EventStore-->>Context: Event persisted\n    Context-->>Handler: Event emitted\n    Handler->>Context: Send(ReserveInventory)<br/>✅ Emit follow-up commands\n    Context->>API: Route command\n    Handler-->>API: Return event\n    API-->>User: Success\n    EventStore->>Projection: Notify subscribers\n    Note over Projection: ✅ Pure transformation<br/>❌ NO event emission\n`\nThis constraint ensures:\nSingle Source of Truth: All events originate from command handling - clear causation\nAuditability: Every event has a corresponding command that caused it\nAuthorization: Commands are the authorization boundary - validate before creating events\nBusiness Logic Encapsulation: Events are created only after business rules pass\nTransaction Boundary: Command handling is the transaction boundary for event emission\nEvent Context: CommandContext automatically populates EventContext metadata (user, tenant, etc",
        "startIndex": 0,
        "preview": "Command Handling\nCommands represent intent or actions in your system Command handlers contain business logic, validate commands, apply business rules,..."
      },
      {
        "id": "commands/command-handling-chunk-1",
        "text": "has a corresponding command that caused it Authorization: Commands are the authorization boundary - validate before creating events Business Logic Encapsulation: Events are created only after business rules pass Transaction Boundary: Command handling is the transaction boundary for event emission Event Context: CommandContext automatically populates EventContext metadata (user, tenant, etc )\nCommandContext Structure\n`csharp\npublic class CommandContext {\n    // Command metadata\n    public CommandMetadata Command { get; init; }\n    // Security context (from command initiator)\n    public SecurityContext Security { get; init; }\n    // Emit events - ONLY way to create events\n    public TEvent EmitEvent<TEvent>(TEvent @event) where TEvent : class;\n    // Emit follow-up commands\n    public Task Send<TCommand>(TCommand command, CancellationToken ct = default) where TCommand : class;\n    // Access to stores for reading (not writing - use events for that)\n    public IEventStore EventStore { get; init; }\n}\npublic class CommandMetadata {\n    public Guid CommandId { get; init; }\n    public string CommandType { get; init; }\n    public DateTime ReceivedAt { get; init; }\n    public Guid CorrelationId { get; init; }\n}\n`\nBasic Command Handler\n`csharp{\ntitle: \"Basic Command Handler with Event Emission\"\ndescription: \"Command handler that validates, applies business logic, and emits events\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"Command Handlers\", \"Events\", \"Business Logic\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n// ✅ CORRECT: Command handler contains business logic\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderPlaced> {\n    public async Task<OrderPlaced> Handle(\n        PlaceOrder command,\n        CommandContext context,  // ✅ Context for emitting events and commands\n        CancellationToken ct) {\n        // ✅ Business logic happens HERE\n        // - Validate the order\n        // - Check inventory\n        // - Calculate totals\n        // - Apply business rules\n        // - Decide if order should be marked as expired\n        var expiresAt = DateTime UtcNow",
        "startIndex": 1894,
        "preview": "has a corresponding command that caused it Authorization: Commands are the authorization boundary - validate before creating events Business Logic Enc..."
      },
      {
        "id": "commands/command-handling-chunk-2",
        "text": "// ✅ Context for emitting events and commands CancellationToken ct) { // ✅ Business logic happens HERE // - Validate the order // - Check inventory // - Calculate totals // - Apply business rules // - Decide if order should be marked as expired var expiresAt = DateTime UtcNow AddDays(90);  // ✅ Business decision\n        var isExpired = false;  // ✅ Business decision\n        var status = \"Placed\";   // ✅ Business decision\n        // ✅ Emit event via CommandContext - the ONLY way to create events\n        var @event = context EmitEvent(new OrderPlaced {\n            OrderId = command OrderId,\n            CustomerId = command CustomerId,\n            Total = command Total,\n            ExpiresAt = expiresAt,      // ✅ Set by handler\n            IsExpired = isExpired,       // ✅ Set by handler\n            Status = status              // ✅ Set by handler\n        });\n        return @event;\n    }\n}\n// ✅ CORRECT: Command is a POCO (Plain Old CLR Object)\npublic record PlaceOrder {\n    public Guid OrderId { get; init; }\n    public Guid CustomerId { get; init; }\n    public decimal Total { get; init; }\n    public List<OrderItem> Items { get; init; }\n}\n// ✅ CORRECT: Event is a POCO - describes what happened\npublic record OrderPlaced {\n    public Guid OrderId { get; init; }\n    public Guid CustomerId { get; init; }\n    public decimal Total { get; init; }\n    public DateTime ExpiresAt { get; init; }     // ✅ Data only (set by handler)\n    public bool IsExpired { get; init; }         // ✅ Data only (set by handler)\n    public string Status { get; init; }          // ✅ Data only (set by handler)\n    // ❌ NO business logic methods like:\n    // public bool ShouldExpire() => DateTime",
        "startIndex": 3797,
        "preview": "// ✅ Context for emitting events and commands CancellationToken ct) { // ✅ Business logic happens HERE // - Validate the order // - Check inventory //..."
      },
      {
        "id": "commands/command-handling-chunk-3",
        "text": "init; } // ✅ Data only (set by handler) public bool IsExpired { get; init; } // ✅ Data only (set by handler) public string Status { get; init; } // ✅ Data only (set by handler) // ❌ NO business logic methods like: // public bool ShouldExpire() => DateTime UtcNow > ExpiresAt;\n    // Events are immutable data - handlers make decisions, events record them\n}\npublic record OrderItem {\n    public Guid ProductId { get; init; }\n    public int Quantity { get; init; }\n}\n`\nWhat You CAN and CANNOT Do\n✅ In Command Handlers (Business Logic Layer)\n`csharp\n// ✅ CAN use DateTime UtcNow for business decisions\nvar expiresAt = DateTime UtcNow AddDays(90);\n// ✅ CAN use Random or Guid NewGuid()\nvar confirmationCode = Random Shared Next(100000, 999999);\n// ✅ CAN call external APIs\nvar customerData = await _customerService GetCustomerAsync(command CustomerId, ct);\n// ✅ CAN read from databases\nvar product = await _productRepository GetAsync(command ProductId, ct);\n// ✅ CAN perform calculations and validations\nif (command Total <= 0) {\n    throw new InvalidOperationException(\"Order total must be positive\");\n}\n// ✅ CAN make business decisions\nvar needsApproval = command Total > 10000;\nvar discount = customer IsPremium 0 10m : 0;\n// ✅ CAN emit events via CommandContext\nvar @event = context EmitEvent(new OrderPlaced { });\n// ✅ CAN emit follow-up commands via CommandContext\nawait context Send(new ReserveInventory { }, ct);\n`\n❌ Outside Command Handlers\n`csharp\n// ❌ CANNOT emit events directly - no CommandContext\npublic class SomeService {\n    private readonly IEventStore _eventStore;\n    public async Task DoSomething() {\n        // ❌ FORBIDDEN: Cannot create events outside of command handling\n        var @event = new OrderPlaced { };\n        await _eventStore AppendAsync(@event);  // 💥 Compile error - not allowed // ✅ CORRECT: Must send a command instead\n        await _whizbang Send(new PlaceOrder {",
        "startIndex": 5209,
        "preview": "init; } // ✅ Data only (set by handler) public bool IsExpired { get; init; } // ✅ Data only (set by handler) public string Status { get; init; } // ✅ ..."
      },
      {
        "id": "commands/command-handling-chunk-4",
        "text": "{ private readonly IEventStore _eventStore; public async Task DoSomething() { // ❌ FORBIDDEN: Cannot create events outside of command handling var @event = new OrderPlaced { }; await _eventStore AppendAsync(@event); // 💥 Compile error - not allowed // ✅ CORRECT: Must send a command instead await _whizbang Send(new PlaceOrder { });\n        // The command handler will emit the event via CommandContext\n    }\n}\n// ❌ CANNOT emit events from projections\n[WhizbangProjection]\npublic class BadProjection {\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        CancellationToken ct) {\n        // ❌ FORBIDDEN: Projections cannot emit events\n        // No CommandContext available - projections are read-side only\n        var newEvent = new OrderProcessed { };  // 💥 Cannot emit\n        // ✅ CORRECT: If you need to trigger something, emit a command\n        await _whizbang Send(new ProcessOrder { });\n        // The command handler will emit events\n    }\n}\n`\nCommand Emission (Sagas and Process Managers)\nHandlers can emit follow-up commands to coordinate workflows:\n`csharp{\ntitle: \"Command Emission in Handlers\"\ndescription: \"Emitting follow-up commands for workflow coordination\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"Sagas\", \"Workflows\", \"Process Managers\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n// Command handler emits both events and commands\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderPlaced> {\n    public async Task<OrderPlaced> Handle(\n        PlaceOrder command,\n        CommandContext context,\n        CancellationToken ct) {\n        // Business logic\n        var expiresAt = DateTime UtcNow AddDays(90);\n        // ✅ Emit event via CommandContext\n        var @event = context EmitEvent(new OrderPlaced {\n            OrderId = command OrderId,\n            CustomerId = command CustomerId,\n            Total = command Total,\n            ExpiresAt = expiresAt\n        });\n        // ✅ Emit follow-up commands to coordinate workflow\n        await context Send(new ReserveInventory {\n            OrderId = command OrderId,\n            Items = command Items\n        }, ct);\n        await context Send(new NotifyCustomer {\n            CustomerId = command",
        "startIndex": 6883,
        "preview": "{ private readonly IEventStore _eventStore; public async Task DoSomething() { // ❌ FORBIDDEN: Cannot create events outside of command handling var @ev..."
      },
      {
        "id": "commands/command-handling-chunk-5",
        "text": "EmitEvent(new OrderPlaced { OrderId = command OrderId, CustomerId = command CustomerId, Total = command Total, ExpiresAt = expiresAt }); // ✅ Emit follow-up commands to coordinate workflow await context Send(new ReserveInventory { OrderId = command OrderId, Items = command Items }, ct); await context Send(new NotifyCustomer { CustomerId = command CustomerId,\n            Message = \"Your order has been placed\"\n        }, ct);\n        return @event;\n    }\n}\n// Saga pattern - event handlers emit commands to orchestrate workflow\npublic class OrderSagaHandler : IEventHandler<OrderPlaced> {\n    private readonly IWhizbang _whizbang;\n    public async Task Handle(OrderPlaced @event, CancellationToken ct) {\n        // ✅ Event handler can emit commands (but NOT events)\n        // Step 1: Reserve inventory\n        await _whizbang Send(new ReserveInventory {\n            OrderId = @event OrderId,\n            Items = @event Items\n        }, ct);\n        // Step 2: Authorize payment\n        await _whizbang Send(new AuthorizePayment {\n            OrderId = @event OrderId,\n            Amount = @event Total,\n            CustomerId = @event CustomerId\n        }, ct);\n    }\n}\n`\nAggregate Command Handling\nAggregates can also emit events via CommandContext:\n`csharp{\ntitle: \"Aggregate Command Handling\"\ndescription: \"Using aggregates to handle commands and emit events\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"ADVANCED\"\ntags: [\"Aggregates\", \"Commands\", \"Events\", \"DDD\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\n// Aggregate can emit events via CommandContext\npublic class OrderAggregate : Aggregate {\n    private Guid _orderId;\n    private OrderStatus _status;\n    private List<OrderItem> _items = new();\n    public async Task PlaceOrder(PlaceOrder command, CommandContext context) {\n        // Apply business rules\n        if (_status = OrderStatus None) {\n            throw new InvalidOperationException(\"Order already placed\");\n        }\n        var expiresAt = DateTime UtcNow AddDays(90);\n        // ✅ Emit event via CommandContext\n        var @event = context EmitEvent(new OrderPlaced {\n            OrderId = command OrderId,\n            CustomerId = command CustomerId,\n            Total = command",
        "startIndex": 8990,
        "preview": "EmitEvent(new OrderPlaced { OrderId = command OrderId, CustomerId = command CustomerId, Total = command Total, ExpiresAt = expiresAt }); // ✅ Emit fol..."
      },
      {
        "id": "commands/command-handling-chunk-6",
        "text": "command, CommandContext context) { // Apply business rules if (_status = OrderStatus None) { throw new InvalidOperationException(\"Order already placed\"); } var expiresAt = DateTime UtcNow AddDays(90); // ✅ Emit event via CommandContext var @event = context EmitEvent(new OrderPlaced { OrderId = command OrderId, CustomerId = command CustomerId, Total = command Total,\n            ExpiresAt = expiresAt\n        });\n        // Apply event to aggregate state\n        Apply(@event);\n        // ✅ Aggregate can also emit follow-up commands via CommandContext\n        await context Send(new SendOrderConfirmationEmail {\n            OrderId = command OrderId,\n            CustomerEmail = command CustomerEmail\n        });\n    }\n    public async Task ShipOrder(ShipOrder command, CommandContext context) {\n        // Validate state\n        if (_status = OrderStatus Placed) {\n            throw new InvalidOperationException(\"Order cannot be shipped in current state\");\n        }\n        // ✅ Emit event via CommandContext\n        var @event = context EmitEvent(new OrderShipped {\n            OrderId = command OrderId,\n            TrackingNumber = command TrackingNumber\n        });\n        Apply(@event);\n        // ✅ Emit follow-up command\n        await context Send(new NotifyCustomerOfShipment {\n            OrderId = command OrderId,\n            TrackingNumber = command TrackingNumber\n        });\n    }\n    // Event handlers update aggregate state\n    private void Apply(OrderPlaced @event) {\n        _orderId = @event OrderId;\n        _status = OrderStatus Placed;\n    }\n    private void Apply(OrderShipped @event) {\n        _status = OrderStatus",
        "startIndex": 11060,
        "preview": "command, CommandContext context) { // Apply business rules if (_status = OrderStatus None) { throw new InvalidOperationException(\"Order already placed..."
      },
      {
        "id": "commands/command-handling-chunk-7",
        "text": "}); Apply(@event); // ✅ Emit follow-up command await context Send(new NotifyCustomerOfShipment { OrderId = command OrderId, TrackingNumber = command TrackingNumber }); } // Event handlers update aggregate state private void Apply(OrderPlaced @event) { _orderId = @event OrderId; _status = OrderStatus Placed; } private void Apply(OrderShipped @event) { _status = OrderStatus Shipped;\n    }\n}\npublic enum OrderStatus {\n    None,\n    Placed,\n    Shipped,\n    Delivered,\n    Cancelled\n}\n`\nUse Cases for Command Emission\nSagas / Process Managers: Orchestrate multi-step workflows across aggregates/services\nCommand Chaining: Break complex operations into smaller, coordinated commands\nSide Effects: Trigger notifications, emails, integrations\nCompensating Actions: Send rollback commands if a step fails\nDistributed Transactions: Coordinate actions across multiple bounded contexts\nWorkflow Automation: Trigger next steps in business processes\nSaga Workflow Example\n`mermaid\nsequenceDiagram\n    participant User\n    participant OrderService\n    participant OrderSaga\n    participant InventoryService\n    participant PaymentService\n    participant ShippingService\n    User->>OrderService: PlaceOrder Command\n    OrderService->>OrderService: Validate & Emit OrderPlaced Event\n    OrderService-->>User: Order Created\n    OrderService->>OrderSaga: OrderPlaced Event\n    Note over OrderSaga: Saga orchestrates<br/>multi-step workflow\n    OrderSaga->>InventoryService: ReserveInventory Command\n    InventoryService->>InventoryService: Reserve & Emit InventoryReserved\n    InventoryService-->>OrderSaga: Success\n    OrderSaga->>PaymentService: AuthorizePayment Command\n    PaymentService->>PaymentService: Authorize & Emit PaymentAuthorized\n    PaymentService-->>OrderSaga: Success\n    OrderSaga->>ShippingService: ScheduleShipment Command\n    ShippingService->>ShippingService: Schedule & Emit ShipmentScheduled\n    ShippingService-->>OrderSaga: Success\n    Note over OrderSaga: Workflow complete <br/>All steps succeeded\n    alt Payment Fails\n        PaymentService-->>OrderSaga: Payment Failed\n        OrderSaga->>InventoryService: ReleaseInventory Command\n        Note over OrderSaga: Compensating action<br/>rollback inventory\n    end\n`\nThe Three-Layer Architecture\n`mermaid\ngraph TB\n    subgraph BusinessLogic[\"Command Handler / Aggregate (Business Logic Layer)\"]\n        BL1[\"✅ Validates commands\"]\n        BL2[\"✅ Applies business rules\"]\n        BL3[\"✅ Makes decisions\"]\n        BL4[\"✅ Creates event POCOs with results\"]\n        BL5[\"✅ CAN emit commands (sagas)\"]\n        BL6[\"✅ CAN use DateTime UtcNow, Random, APIs\"]\n    end\n    subgraph DataLayer[\"Data Layer (POCOs - No Logic)\"]\n        Event[\"Event<br/>- Properties only<br/>- NO methods<br/>- Describes what happened\"]\n        Command[\"Command<br/>- Properties only<br/>- NO methods<br/>- Describes intent\"]\n    end\n    subgraph ReadModel[\"Projection (Read Model Layer)\"]\n        P1[\"✅ Pure transformation of event data\"]\n        P2[\"❌ NO business logic\"]\n        P3[\"❌ NO DateTime",
        "startIndex": 12346,
        "preview": "}); Apply(@event); // ✅ Emit follow-up command await context Send(new NotifyCustomerOfShipment { OrderId = command OrderId, TrackingNumber = command T..."
      },
      {
        "id": "commands/command-handling-chunk-8",
        "text": "(sagas)\"] BL6[\"✅ CAN use DateTime UtcNow, Random, APIs\"] end subgraph DataLayer[\"Data Layer (POCOs - No Logic)\"] Event[\"Event<br/>- Properties only<br/>- NO methods<br/>- Describes what happened\"] Command[\"Command<br/>- Properties only<br/>- NO methods<br/>- Describes intent\"] end subgraph ReadModel[\"Projection (Read Model Layer)\"] P1[\"✅ Pure transformation of event data\"] P2[\"❌ NO business logic\"] P3[\"❌ NO DateTime UtcNow, Random, APIs\"]\n        P4[\"✅ ONLY event data or EventContext\"]\n        P5[\"✅ Deterministic and replayable\"]\n    end\n    BusinessLogic -->|Emits Events| Event\n    BusinessLogic -->|Emits Commands| Command\n    Event -->|Consumed by| ReadModel\n    Command -->|Handled by| BusinessLogic\n    style BusinessLogic fill:#d4edda,stroke:#28a745,stroke-width:2px\n    style DataLayer fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    style ReadModel fill:#cce5ff,stroke:#004085,stroke-width:2px\n    style Event fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    style Command fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n`\nCommands vs Events vs Queries\n| Aspect | Command | Event | Query |\n|--------|---------|-------|-------|\n| Purpose | Express intent | Record what happened | Retrieve data |\n| Tense | Imperative (PlaceOrder) | Past tense (OrderPlaced) | Question (GetOrder) |\n| Business Logic | Handler contains logic | NO logic - POCO | NO logic - handler reads data |\n| Side Effects | YES - creates events | NO - immutable data | NO - read-only |\n| Can Fail | YES - validation errors | NO - fact that happened | NO - returns null/empty |\n| Emit Events | YES - via CommandContext | N/A | NO |\n| Emit Commands | YES - via CommandContext | Via event handlers | NO |\nValidation and Error Handling\n`csharp{\ntitle: \"Command Validation and Error Handling\"\ndescription: \"Proper validation and error handling in command handlers\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Validation\", \"Error Handling\", \"Commands\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading",
        "startIndex": 15006,
        "preview": "(sagas)\"] BL6[\"✅ CAN use DateTime UtcNow, Random, APIs\"] end subgraph DataLayer[\"Data Layer (POCOs - No Logic)\"] Event[\"Event<br/>- Properties only<br..."
      },
      {
        "id": "commands/command-handling-chunk-9",
        "text": "Error Handling `csharp{ title: \"Command Validation and Error Handling\" description: \"Proper validation and error handling in command handlers\" framework: \"NET8\" category: \"Commands\" difficulty: \"INTERMEDIATE\" tags: [\"Validation\", \"Error Handling\", \"Commands\"] nugetPackages: [\"Whizbang Core\"] usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading; using System Threading Tasks;\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderPlaced> {\n    private readonly IProductRepository _products;\n    private readonly ICustomerRepository _customers;\n    public PlaceOrderHandler(IProductRepository products, ICustomerRepository customers) {\n        _products = products;\n        _customers = customers;\n    }\n    public async Task<OrderPlaced> Handle(\n        PlaceOrder command,\n        CommandContext context,\n        CancellationToken ct) {\n        // ✅ Validate command data\n        if (command OrderId == Guid Empty) {\n            throw new ArgumentException(\"OrderId is required\", nameof(command OrderId));\n        }\n        if (command Items == null || command Items Count == 0) {\n            throw new ArgumentException(\"Order must have at least one item\", nameof(command Items));\n        }\n        // ✅ Validate business rules\n        var customer = await _customers GetAsync(command CustomerId, ct);\n        if (customer == null) {\n            throw new InvalidOperationException($\"Customer {command CustomerId} not found\");\n        }\n        if ( customer IsActive) {\n            throw new InvalidOperationException(\"Cannot place order for inactive customer\");\n        }\n        // ✅ Check availability\n        foreach (var item in command Items) {\n            var product = await _products GetAsync(item ProductId, ct);\n            if (product == null) {\n                throw new InvalidOperationException($\"Product {item ProductId} not found\");\n            }\n            if (product Stock < item Quantity) {\n                throw new InvalidOperationException(\n                    $\"Insufficient stock for product {product Name} \" +\n                    $\"Available: {product Stock}, Requested: {item Quantity}\");\n            }\n        }\n        // ✅ Calculate totals\n        decimal total = 0;\n        foreach (var item in command Items) {\n            var product = await _products GetAsync(item ProductId, ct);\n            total += product Price * item Quantity;\n        }\n        // ✅ Apply business rules\n        var discount = customer IsPremium total * 0 10m : 0;\n        var finalTotal = total - discount;\n        // ✅ Emit event with all business decisions made\n        var @event = context",
        "startIndex": 16735,
        "preview": "Error Handling `csharp{ title: \"Command Validation and Error Handling\" description: \"Proper validation and error handling in command handlers\" framewo..."
      },
      {
        "id": "commands/command-handling-chunk-10",
        "text": "product = await _products GetAsync(item ProductId, ct); total += product Price * item Quantity; } // ✅ Apply business rules var discount = customer IsPremium total * 0 10m : 0; var finalTotal = total - discount; // ✅ Emit event with all business decisions made var @event = context EmitEvent(new OrderPlaced {\n            OrderId = command OrderId,\n            CustomerId = command CustomerId,\n            Total = finalTotal,\n            Discount = discount,\n            ExpiresAt = DateTime UtcNow AddDays(90),\n            IsExpired = false,\n            Status = \"Placed\"\n        });\n        return @event;\n    }\n}\n`\nSummary\nEvents can ONLY be emitted via CommandContext during command handling\nCommand handlers contain business logic - validation, rules, decisions\nEvents are POCOs describing what happened (no logic)\nCommands are POCOs describing intent (no logic)\nHandlers can emit follow-up commands for sagas and workflows\nCommandContext provides authorization boundary - events created after validation\nProjections cannot emit events - they're read-side only\nNext Steps\nCommand Validation - Advanced validation patterns\nSagas and Process Managers - Workflow orchestration\nAggregates - Domain-driven design with aggregates\nProjection Purity - Maintaining pure projections",
        "startIndex": 4049,
        "preview": "product = await _products GetAsync(item ProductId, ct); total += product Price * item Quantity; } // ✅ Apply business rules var discount = customer Is..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "contributors/coding-standards",
    "title": "Coding Standards",
    "category": "Contributors",
    "url": "/docs/contributors/coding-standards",
    "chunks": [
      {
        "id": "contributors/coding-standards-chunk-0",
        "text": "Coding Standards\nWhizbang follows strict coding standards to ensure consistency, maintainability, and AOT compatibility EditorConfig\nAll code MUST follow the editorconfig rules in the repository Documentation examples follow CODE_SAMPLES editorconfig CVersion\nMinimum: C12\nTarget: Latest stable Cversion\nUse modern language features (pattern matching, records, file-scoped namespaces, etc )\nBrace Style\nUse K&R/Egyptian braces (opening brace on same line):\n`csharp\n// ✅ CORRECT - K&R/Egyptian style\npublic class Order {\n    public void Ship() {\n        if (Status == OrderStatus Placed) {\n            Status = OrderStatus Shipped;\n        }\n    }\n}\n// ❌ WRONG - Allman style\npublic class Order\n{\n    public void Ship()\n    {\n        if (Status == OrderStatus Placed)\n        {\n            Status = OrderStatus Shipped;\n        }\n    }\n}\n`\nNaming Conventions\nTypes\nPascalCase for classes, interfaces, records, enums, structs:\n`csharp\npublic class OrderProcessor { }\npublic interface IOrderRepository { }\npublic record OrderPlaced(Guid OrderId);\npublic enum OrderStatus { Placed, Shipped }\n`\nI-prefix for interfaces:\n`csharp\npublic interface IEventStore { }\npublic interface IProjection { }\n`\nMethods and Properties\nPascalCase:\n`csharp\npublic class Order {\n    public Guid Id { get; private set; }\n    public decimal Total { get; private set; }\n    public void Ship(string trackingNumber) {\n        // }\n}\n`\nAsync suffix for async methods:\n`csharp\npublic async Task<Order> GetOrderAsync(Guid orderId) {\n    // }\npublic async Task SaveAsync(Order order) {\n    // }\n`\nParameters and Local Variables\ncamelCase:\n`csharp\npublic void ProcessOrder(Guid orderId, List<OrderItem> items) {\n    var total = items Sum(i => i Price * i",
        "startIndex": 0,
        "preview": "Coding Standards\nWhizbang follows strict coding standards to ensure consistency, maintainability, and AOT compatibility EditorConfig\nAll code MUST fol..."
      },
      {
        "id": "contributors/coding-standards-chunk-1",
        "text": "// } } ` Async suffix for async methods: `csharp public async Task<Order> GetOrderAsync(Guid orderId) { // } public async Task SaveAsync(Order order) { // } ` Parameters and Local Variables camelCase: `csharp public void ProcessOrder(Guid orderId, List<OrderItem> items) { var total = items Sum(i => i Price * i Quantity);\n    var customerId = GetCustomerId(orderId);\n}\n`\nFields\n_camelCase (underscore prefix) for private fields:\n`csharp\npublic class OrderProcessor {\n    private readonly IOrderRepository _repository;\n    private readonly ILogger _logger;\n    public OrderProcessor(IOrderRepository repository, ILogger logger) {\n        _repository = repository;\n        _logger = logger;\n    }\n}\n`\nConstants\nALL_CAPS with underscores:\n`csharp\npublic class EventStoreConstants {\n    public const string DEFAULT_STREAM_PREFIX = \"whizbang-\";\n    public const int MAX_BATCH_SIZE = 1000;\n}\n`\nvar Keyword\nAlways use var for local variables when the type is obvious:\n`csharp\n// ✅ CORRECT\nvar order = new Order(customerId, items);\nvar total = items Sum(i => i Price);\nvar repository = serviceProvider GetRequiredService<IOrderRepository>();\n// ❌ WRONG\nOrder order = new Order(customerId, items);\ndecimal total = items Sum(i => i Price);\nIOrderRepository repository = serviceProvider GetRequiredService<IOrderRepository>();\n`\nException: Use explicit type when it aids clarity:\n`csharp\n// OK - explicit type makes intent clear\nIEnumerable<Order> activeOrders = GetOrders() Where(o => o IsActive);\n`\nFile-Scoped Namespaces\nAlways use file-scoped namespaces (C10+):\n`csharp\n// ✅ CORRECT\nusing System;\nusing Whizbang;\nnamespace MyApp Orders;\npublic class Order {\n    // }\n// ❌ WRONG\nusing System;\nusing Whizbang;\nnamespace MyApp Orders {\n    public class Order {\n        // }\n}\n`\nUsing Directives\nPlace outside namespace, System directives first:\n`csharp\n// ✅ CORRECT\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nnamespace MyApp Orders;\npublic class OrderService {\n    // }\n// ❌ WRONG - using inside namespace\nnamespace MyApp Orders {\n    using System;\n    using Whizbang;\n    public class OrderService {\n        //",
        "startIndex": 1741,
        "preview": "// } } ` Async suffix for async methods: `csharp public async Task<Order> GetOrderAsync(Guid orderId) { // } public async Task SaveAsync(Order order) ..."
      },
      {
        "id": "contributors/coding-standards-chunk-2",
        "text": "first: `csharp // ✅ CORRECT using System; using System Collections Generic; using System Threading Tasks; using Microsoft Extensions DependencyInjection; using Whizbang; namespace MyApp Orders; public class OrderService { // } // ❌ WRONG - using inside namespace namespace MyApp Orders { using System; using Whizbang; public class OrderService { // }\n}\n`\nRecords for DTOs and Events\nUse records for immutable data:\n`csharp\n// ✅ CORRECT - Events as records\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt);\npublic record PlaceOrder(Guid CustomerId, List<OrderItem> Items);\n// ❌ WRONG - Events as classes with setters\npublic class OrderPlaced {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    public DateTimeOffset PlacedAt { get; set; }\n}\n`\nNullable Reference Types\nEnable nullable reference types in all projects:\n`xml\n<PropertyGroup>\n    <Nullable>enable</Nullable>\n</PropertyGroup>\n`\nAnnotate nullability explicitly:\n`csharp\npublic class OrderRepository {\n    // Non-nullable - must never be null\n    private readonly IEventStore _eventStore;\n    // Nullable - can be null\n    private Order _cachedOrder;\n    public async Task<Order > FindAsync(Guid orderId) {\n        // Returns null if not found\n        return await _eventStore LoadAsync<Order>(orderId);\n    }\n    public async Task<Order> GetAsync(Guid orderId) {\n        // Throws if not found (non-nullable return)\n        var order = await FindAsync(orderId);\n        return order throw new OrderNotFoundException(orderId);\n    }\n}\n`\nException Handling\nThrow Specific Exceptions\n`csharp\n// ✅ CORRECT\nthrow new OrderNotFoundException(orderId);\nthrow new InvalidOperationException(\"Cannot ship a cancelled order\");\n// ❌ WRONG\nthrow new Exception(\"Order not found\");\n`\nDon't Swallow Exceptions\n`csharp\n// ✅ CORRECT\ntry {\n    await processor ProcessAsync(order);\n} catch (InvalidOrderException ex) {\n    _logger LogError(ex, \"Order validation failed: {OrderId}\", order Id);\n    throw;  // Re-throw to propagate\n}\n// ❌ WRONG\ntry {\n    await processor ProcessAsync(order);\n} catch {\n    // Silent failure - very bad",
        "startIndex": 3655,
        "preview": "first: `csharp // ✅ CORRECT using System; using System Collections Generic; using System Threading Tasks; using Microsoft Extensions DependencyInjecti..."
      },
      {
        "id": "contributors/coding-standards-chunk-3",
        "text": "found\"); ` Don't Swallow Exceptions `csharp // ✅ CORRECT try { await processor ProcessAsync(order); } catch (InvalidOrderException ex) { _logger LogError(ex, \"Order validation failed: {OrderId}\", order Id); throw; // Re-throw to propagate } // ❌ WRONG try { await processor ProcessAsync(order); } catch { // Silent failure - very bad }\n`\nUse Specific Catches\n`csharp\n// ✅ CORRECT\ntry {\n    await SaveAsync(order);\n} catch (DbUpdateConcurrencyException ex) {\n    throw new OptimisticConcurrencyException(\"Order was modified\", ex);\n} catch (DbException ex) {\n    _logger LogError(ex, \"Database error saving order\");\n    throw;\n}\n// ❌ WRONG - catching everything\ntry {\n    await SaveAsync(order);\n} catch (Exception ex) {\n    _logger LogError(ex, \"Error\");\n    throw;\n}\n`\nAsync/Await\nAlways Async All the Way\n`csharp\n// ✅ CORRECT\npublic async Task<Order> GetOrderAsync(Guid orderId) {\n    var events = await _eventStore LoadStreamAsync($\"Order-{orderId}\");\n    return await ReconstructAsync(events);\n}\n// ❌ WRONG - mixing sync and async\npublic Order GetOrder(Guid orderId) {\n    var events = _eventStore LoadStreamAsync($\"Order-{orderId}\") Result;  // Deadlock risk return ReconstructAsync(events) Result;\n}\n`\nUse ConfigureAwait(false) in Libraries\n`csharp\n// ✅ CORRECT - library code\npublic async Task SaveAsync(Order order) {\n    var events = order GetUncommittedEvents();\n    await _eventStore AppendAsync(streamId, events) ConfigureAwait(false);\n}\n// Application code can omit ConfigureAwait\n`\nAOT Compatibility\nNever use reflection that breaks AOT:\n`csharp\n// ❌ WRONG - breaks AOT\nvar type = Type GetType(\"MyApp Orders Order\");\nvar instance = Activator CreateInstance(type);\n// ✅ CORRECT - use source generators\n[GenerateHandlers]  // Source generator creates handler registry\npublic partial class HandlerRegistry { }\n`\nUse generic constraints instead of runtime type checks:\n`csharp\n// ❌ WRONG\npublic void Process(object message) {\n    if (message GetType() == typeof(PlaceOrder)) {\n        //",
        "startIndex": 5448,
        "preview": "found\"); ` Don't Swallow Exceptions `csharp // ✅ CORRECT try { await processor ProcessAsync(order); } catch (InvalidOrderException ex) { _logger LogEr..."
      },
      {
        "id": "contributors/coding-standards-chunk-4",
        "text": "var instance = Activator CreateInstance(type); // ✅ CORRECT - use source generators [GenerateHandlers] // Source generator creates handler registry public partial class HandlerRegistry { } ` Use generic constraints instead of runtime type checks: `csharp // ❌ WRONG public void Process(object message) { if (message GetType() == typeof(PlaceOrder)) { // }\n}\n// ✅ CORRECT\npublic void Process<TMessage>(TMessage message) where TMessage : class {\n    // Compile-time type safety\n}\n`\nDependency Injection\nConstructor Injection\n`csharp\n// ✅ CORRECT\npublic class OrderService {\n    private readonly IOrderRepository _repository;\n    private readonly IEventPublisher _publisher;\n    public OrderService(IOrderRepository repository, IEventPublisher publisher) {\n        _repository = repository;\n        _publisher = publisher;\n    }\n}\n// ❌ WRONG - property injection\npublic class OrderService {\n    public IOrderRepository Repository { get; set; }\n}\n`\nRegister Services Explicitly\n`csharp\n// ✅ CORRECT - explicit registration\nservices AddScoped<IOrderRepository, OrderRepository>();\nservices AddSingleton<IEventStore, PostgresEventStore>();\n// ❌ WRONG - magic scanning that breaks AOT\nservices Scan(scan => scan FromAssemblyOf<Order>() AddClasses() AsImplementedInterfaces());\n`\nPerformance\nUse ValueTask for Hot Paths\n`csharp\n// ✅ CORRECT - high-frequency method\npublic ValueTask<bool> TryGetFromCacheAsync(string key) {\n    if (_cache TryGetValue(key, out var value)) {\n        return new ValueTask<bool>(true);  // Synchronous completion\n    }\n    return LoadFromDatabaseAsync(key);  // Async completion\n}\n`\nAvoid Allocations in Hot Paths\n`csharp\n// ✅ CORRECT - reuse span/memory\npublic void ProcessEvents(ReadOnlySpan<Event> events) {\n    foreach (var @event in events) {\n        // Process without allocation\n    }\n}\n// ❌ WRONG - allocates array\npublic void ProcessEvents(Event[] events) {\n    // }\n`\nTesting Conventions\nTest Method Naming\nFormat: MethodName_Scenario_ExpectedBehavior\n`csharp\n[Fact]\npublic void Ship_WhenOrderIsPlaced_UpdatesStatusToShipped() {\n    // Arrange\n    var order = new Order(customerId, items);\n    // Act\n    order Ship(trackingNumber);\n    // Assert\n    order Status Should() Be(OrderStatus Shipped);\n}\n[Fact]\npublic void Ship_WhenOrderIsCancelled_ThrowsInvalidOperationException() {\n    // Arrange\n    var order = new Order(customerId, items);\n    order Cancel(\"Customer requested\");\n    // Act & Assert\n    var act = () => order Ship(trackingNumber);\n    act Should()",
        "startIndex": 7124,
        "preview": "var instance = Activator CreateInstance(type); // ✅ CORRECT - use source generators [GenerateHandlers] // Source generator creates handler registry pu..."
      },
      {
        "id": "contributors/coding-standards-chunk-5",
        "text": "{ // Arrange var order = new Order(customerId, items); // Act order Ship(trackingNumber); // Assert order Status Should() Be(OrderStatus Shipped); } [Fact] public void Ship_WhenOrderIsCancelled_ThrowsInvalidOperationException() { // Arrange var order = new Order(customerId, items); order Cancel(\"Customer requested\"); // Act & Assert var act = () => order Ship(trackingNumber); act Should() Throw<InvalidOperationException>();\n}\n`\nUse FluentAssertions\n`csharp\n// ✅ CORRECT - readable assertions\nresult Should() NotBeNull();\nresult OrderId Should() Be(expectedId);\nresult Items Should() HaveCount(2);\n// ❌ WRONG - xUnit asserts (less readable)\nAssert NotNull(result);\nAssert Equal(expectedId, result OrderId);\nAssert Equal(2, result Items Count);\n`\nComments\nExplain Why, Not What\n`csharp\n// ✅ CORRECT - explains non-obvious decision\n// Use pessimistic locking here because optimistic concurrency\n// causes too many retries under high contention\nawait _connection ExecuteAsync(\"SELECT FOR UPDATE\");\n// ❌ WRONG - states the obvious\n// Get the order\nvar order = await GetOrderAsync(orderId);\n`\nXML Documentation for Public APIs\n`csharp\n/// <summary>\n/// Appends events to an aggregate stream with optimistic concurrency /// </summary>\n/// <param name=\"streamId\">The unique identifier for the event stream </param>\n/// <param name=\"events\">The events to append </param>\n/// <param name=\"expectedVersion\">\n/// The expected current version of the stream If the actual version\n/// does not match, throws <see cref=\"ConcurrencyException\"/> /// </param>\n/// <exception cref=\"ConcurrencyException\">\n/// Thrown when the stream has been modified since it was loaded /// </exception>\npublic async Task AppendAsync(string streamId, IEnumerable<object> events, long expectedVersion) {\n    // }\n`\nAnalyzer Configuration\nWhizbang uses Roslyn analyzers to enforce standards",
        "startIndex": 9272,
        "preview": "{ // Arrange var order = new Order(customerId, items); // Act order Ship(trackingNumber); // Assert order Status Should() Be(OrderStatus Shipped); } [..."
      },
      {
        "id": "contributors/coding-standards-chunk-6",
        "text": "actual version /// does not match, throws <see cref=\"ConcurrencyException\"/> /// </param> /// <exception cref=\"ConcurrencyException\"> /// Thrown when the stream has been modified since it was loaded /// </exception> public async Task AppendAsync(string streamId, IEnumerable<object> events, long expectedVersion) { // } ` Analyzer Configuration Whizbang uses Roslyn analyzers to enforce standards Key rules:\nWBZ001: Command/event must have [OwnedBy] attribute\nWBZ002: Handler marked [Pure] must not have side effects\nWBZ003: Async method must have Async suffix\nWBZ004: Event must be immutable (record or readonly properties)\nSuppress warnings only when absolutely necessary:\n`csharp\n#pragma warning disable WBZ001 // Justification: Internal command, ownership not needed\npublic record InternalCleanupCommand();\n#pragma warning restore WBZ001\n`\nSummary Checklist\nBefore submitting code, verify:\n[ ] K&R/Egyptian braces used\n[ ] var used for local variables\n[ ] File-scoped namespaces\n[ ] Nullable reference types enabled and annotated\n[ ] Async methods have Async suffix\n[ ] No reflection that breaks AOT\n[ ] All public APIs have XML documentation\n[ ] Tests follow naming convention\n[ ] Code passes all analyzer rules\nQuestions If you're unsure about any convention, ask in GitHub Discussions",
        "startIndex": 10749,
        "preview": "actual version /// does not match, throws <see cref=\"ConcurrencyException\"/> /// </param> /// <exception cref=\"ConcurrencyException\"> /// Thrown when ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "contributors/contributing",
    "title": "Contributing to Whizbang",
    "category": "Contributors",
    "url": "/docs/contributors/contributing",
    "chunks": [
      {
        "id": "contributors/contributing-chunk-0",
        "text": "Contributing to Whizbang\nThank you for your interest in contributing to Whizbang This guide will help you get started Code of Conduct\nWe are committed to providing a welcoming and inclusive environment Please read and follow our Code of Conduct Ways to Contribute\n🐛 Report Bugs\nFound a bug Open an issue with:\nClear description of the problem\nSteps to reproduce\nExpected vs actual behavior\nWhizbang version and NET version\nRelevant code samples\n💡 Suggest Features\nHave an idea Start a discussion to:\nDescribe the use case\nExplain why existing features don't solve it\nPropose an API design\nDiscuss tradeoffs and alternatives\n📝 Improve Documentation\nDocumentation improvements are always welcome:\nFix typos or unclear explanations\nAdd missing examples\nImprove code samples\nTranslate to other languages\nDocumentation lives in this repository at src/assets/docs/ 🔨 Submit Code\nReady to code Great Please:\nDiscuss first - For non-trivial changes, open an issue or discussion first\nFollow conventions - See Coding Standards\nWrite tests - All new features need tests\nUpdate docs - Documentation is part of the PR, not an afterthought\nKeep it focused - One feature/fix per PR\nDevelopment Setup\nPrerequisites NET 8 0 SDK or later\nDocker (for running test databases)\nGit\nYour favorite IDE (Visual Studio, Rider, VS Code)\nClone the Repository\n`bash\ngit clone https://github com/whizbang-lib/whizbang git\ncd whizbang\n`\nBuild the Solution\n`bash\ndotnet build\n`\nRun Tests\n`bash\nRun all tests\ndotnet test\nRun with coverage\ndotnet test /p:CollectCoverage=true\n`\nStart Local Infrastructure\nFor integration tests, you'll need Postgres and Kafka:\n`bash\ndocker-compose up -d\n`\nThis starts:\nPostgres on localhost:5432\nKafka on localhost:9092\nZookeeper on localhost:2181\nProject Structure\n`\nwhizbang/\n├── src/\n│   ├── Whizbang Core/              Core mediator and messaging\n│   ├── Whizbang EventSourcing/     Event store and aggregates\n│   ├── Whizbang",
        "startIndex": 0,
        "preview": "Contributing to Whizbang\nThank you for your interest in contributing to Whizbang This guide will help you get started Code of Conduct\nWe are committed..."
      },
      {
        "id": "contributors/contributing-chunk-1",
        "text": "Infrastructure For integration tests, you'll need Postgres and Kafka: `bash docker-compose up -d ` This starts: Postgres on localhost:5432 Kafka on localhost:9092 Zookeeper on localhost:2181 Project Structure ` whizbang/ ├── src/ │ ├── Whizbang Core/ Core mediator and messaging │ ├── Whizbang EventSourcing/ Event store and aggregates │ ├── Whizbang Projections/       Projection engine\n│   ├── Whizbang Messaging/         Distributed messaging\n│   ├── Whizbang Postgres/          Postgres driver\n│   ├── Whizbang Kafka/             Kafka driver\n│   ├── Whizbang OpenTelemetry/     Observability\n│   └── Whizbang Analyzers/         Roslyn analyzers\n├── tests/\n│   ├── Whizbang Core Tests/\n│   ├── Whizbang EventSourcing Tests/\n│   ├── Integration Tests/          Multi-package integration tests\n│   └── Documentation/              Tests for documentation examples\n├── samples/\n│   ├── SimpleMediator/             Basic mediator sample\n│   ├── EventSourcedMonolith/       Event sourcing sample\n│   └── Microservices/              Distributed messaging sample\n└── docs/\n    └── (Documentation website - separate repo)\n`\nBranching Strategy\nmain - Stable, released code\ndevelop - Active development\nfeature/xyz - New features (branch from develop)\nfix/xyz - Bug fixes (branch from develop or main for hotfixes)\nPull Request Process\nCreate a Branch\n`bash\ngit checkout develop\ngit pull origin develop\ngit checkout -b feature/my-awesome-feature\n`\nMake Changes\nWrite code following Coding Standards\nAdd tests for new functionality\nUpdate documentation\nEnsure all tests pass\nCommit Changes\nWe use Conventional Commits:\n`bash\ngit commit -m \"feat: add support for SQL Server driver\"\ngit commit -m \"fix: correct optimistic concurrency check\"\ngit commit -m \"docs: add examples for projections\"\n`\nCommit types:\nfeat: - New feature\nfix: - Bug fix\ndocs: - Documentation changes\ntest: - Adding or updating tests\nrefactor: - Code refactoring\nperf: - Performance improvements\nchore: - Build/tooling changes\nPush and Create PR\n`bash\ngit push origin feature/my-awesome-feature\n`\nThen open a PR on GitHub targeting develop branch PR Review\nMaintainers will review your PR",
        "startIndex": 1946,
        "preview": "Infrastructure For integration tests, you'll need Postgres and Kafka: `bash docker-compose up -d ` This starts: Postgres on localhost:5432 Kafka on lo..."
      },
      {
        "id": "contributors/contributing-chunk-2",
        "text": "Bug fix docs: - Documentation changes test: - Adding or updating tests refactor: - Code refactoring perf: - Performance improvements chore: - Build/tooling changes Push and Create PR `bash git push origin feature/my-awesome-feature ` Then open a PR on GitHub targeting develop branch PR Review Maintainers will review your PR Please:\nRespond to feedback promptly\nMake requested changes\nKeep the PR focused (split large PRs if needed)\nBe patient - we review PRs as quickly as we can\nMerge\nOnce approved, a maintainer will merge your PR Congrats 🎉\nTesting Guidelines\nUnit Tests\nTest individual classes in isolation\nUse mocks for dependencies\nFast execution (<100ms per test)\nLocated in * Tests projects\nExample:\n`csharp\npublic class OrderTests {\n    [Fact]\n    public void PlaceOrder_WithValidItems_EmitsOrderPlacedEvent() {\n        // Arrange\n        var order = new Order(customerId, items);\n        // Act\n        var events = order GetUncommittedEvents();\n        // Assert\n        var placed = events Should() ContainSingle() Which Should() BeOfType<OrderPlaced>();\n        placed CustomerId Should() Be(customerId);\n    }\n}\n`\nIntegration Tests\nTest multiple components together\nUse real databases (Docker containers)\nSlower execution (can be seconds)\nLocated in Integration Tests project\nExample:\n`csharp\npublic class EventStoreIntegrationTests : IClassFixture<PostgresFixture> {\n    [Fact]\n    public async Task AppendAndLoad_RoundTrip_PreservesEvents() {\n        // Arrange\n        var store = new PostgresEventStore(connectionString);\n        var events = new[] { new OrderPlaced( ), new OrderShipped( ) };\n        // Act\n        await store AppendAsync(\"Order-123\", events);\n        var loaded = await store LoadStreamAsync(\"Order-123\");\n        // Assert\n        loaded Should() BeEquivalentTo(events);\n    }\n}\n`\nDocumentation Tests\nCRITICAL: All complete code examples in documentation MUST have corresponding tests Located in tests/Documentation/, these tests:\nExtract code from documentation\nVerify examples compile\nValidate examples actually work\nPrevent documentation from becoming stale\nSee Test-Driven Examples for details Documentation Standards\nAll Code Examples Must:\nInclude complete using statements\nFollow CODE_SAMPLES editorconfig (K&R/Egyptian braces)\nUse Cnaming conventions (PascalCase, camelCase, etc",
        "startIndex": 3748,
        "preview": "Bug fix docs: - Documentation changes test: - Adding or updating tests refactor: - Code refactoring perf: - Performance improvements chore: - Build/to..."
      },
      {
        "id": "contributors/contributing-chunk-3",
        "text": "have corresponding tests Located in tests/Documentation/, these tests: Extract code from documentation Verify examples compile Validate examples actually work Prevent documentation from becoming stale See Test-Driven Examples for details Documentation Standards All Code Examples Must: Include complete using statements Follow CODE_SAMPLES editorconfig (K&R/Egyptian braces) Use Cnaming conventions (PascalCase, camelCase, etc )\nBe compilable - No pseudo-code or placeholders\nInclude metadata for enhanced code blocks\nExample Format\nmarkdown\n`csharp{\ntitle: \"Order Command Handler\"\ndescription: \"Processes order placement commands\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"Handlers\", \"Orders\"]\nnugetPackages: [\"Whizbang Core\"]\ntestFile: \"OrderHandlerTests cs\"\ntestMethod: \"HandlePlaceOrder_ValidOrder_ReturnsSuccess\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\npublic class PlaceOrderHandler {\n    public async Task<OrderPlacedResult> Handle(PlaceOrder command) {\n        // Implementation\n    }\n}\n`\nSee DOCUMENTATION-STANDARDS md for complete guidelines Coding Standards\nSee Coding Standards for detailed Cconventions Key Points:\nBrace Style: K&R/Egyptian (opening brace on same line)\nvar: Always use var for local variables\nNaming: PascalCase for public, camelCase for private, _camelCase for fields\nAsync: Suffix async methods with Async\nNullability: Enable nullable reference types\nAOT-Safe: No reflection tricks that break native AOT\nDesign Philosophy\nWhen contributing, keep these principles in mind:\nEvents are the source of truth - Always\nSimple things should be simple - Don't overcomplicate the basic mediator scenario\nComplex things should be possible - But with clear opt-in\nAOT-first - All features must work with native AOT\nDriver-based - Never lock users into a specific technology\nObservable by default - Telemetry is built-in, not bolted-on\nIdempotent - Message handlers should be safe to retry\nGetting Help\nQuestions Ask in GitHub Discussions\nStuck Ping us on Discord (coming soon)\nFound a bug Open an issue\nRecognition\nContributors are recognized in:\nRelease notes for the version their PR shipped in\nCONTRIBUTORS",
        "startIndex": 5759,
        "preview": "have corresponding tests Located in tests/Documentation/, these tests: Extract code from documentation Verify examples compile Validate examples actua..."
      },
      {
        "id": "contributors/contributing-chunk-4",
        "text": "- Telemetry is built-in, not bolted-on Idempotent - Message handlers should be safe to retry Getting Help Questions Ask in GitHub Discussions Stuck Ping us on Discord (coming soon) Found a bug Open an issue Recognition Contributors are recognized in: Release notes for the version their PR shipped in CONTRIBUTORS md file\nOur gratitude and appreciation 🙏\nThank you for making Whizbang better",
        "startIndex": 7625,
        "preview": "- Telemetry is built-in, not bolted-on Idempotent - Message handlers should be safe to retry Getting Help Questions Ask in GitHub Discussions Stuck Pi..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "core-concepts/aggregates",
    "title": "Aggregates",
    "category": "Core Concepts",
    "url": "/docs/core-concepts/aggregates",
    "chunks": [
      {
        "id": "core-concepts/aggregates-chunk-0",
        "text": "Aggregates\nAggregates are the fundamental building blocks of Whizbang's event-sourced architecture They serve as consistency boundaries that encapsulate business logic and ensure data integrity What are Aggregates An aggregate is a cluster of domain objects that can be treated as a single unit for data changes In Whizbang:\nConsistency Boundary: All changes within an aggregate are atomic\nEvent Source: Aggregates generate events when their state changes\nBusiness Logic Container: They encapsulate domain rules and invariants\nIdentity: Each aggregate has a unique identifier\nKey Characteristics\nEvent-Sourced State\nAggregates don't store current state directly Instead, they:\nStore a sequence of events that represent state changes\nRebuild current state by replaying events from the event store\nAppend new events when commands are processed\nCommand Processing\nAggregates receive commands and:\nValidate the command against current state\nApply business rules and invariants\nGenerate domain events if the command is valid\nThrow exceptions if the command violates business rules\nOptimistic Concurrency\nWhizbang aggregates use optimistic concurrency control:\nEach aggregate has a version number\nConcurrent modifications are detected and handled\nPrevents lost update problems in distributed scenarios\nExample Structure\n`csharp\npublic class OrderAggregate : Aggregate {\n    public Guid Id { get; private set; }\n    public OrderStatus Status { get; private set; }\n    public List<OrderItem> Items { get; private set; } = new();\n    // Constructor for new aggregates\n    public OrderAggregate(PlaceOrderCommand command) {\n        // Validate and apply business rules\n        Apply(new OrderPlacedEvent(command OrderId, command Items));\n    }\n    // Event handler (rebuilds state)\n    private void When(OrderPlacedEvent @event) {\n        Id = @event OrderId;\n        Status = OrderStatus Placed;\n        Items = @event Items;\n    }\n    // Command method\n    public void Ship(ShipOrderCommand command) {\n        if (Status = OrderStatus Placed) {\n            throw new InvalidOperationException(\"Order must be placed to ship\");\n        }\n        Apply(new OrderShippedEvent(Id, command",
        "startIndex": 0,
        "preview": "Aggregates\nAggregates are the fundamental building blocks of Whizbang's event-sourced architecture They serve as consistency boundaries that encapsula..."
      },
      {
        "id": "core-concepts/aggregates-chunk-1",
        "text": "} // Event handler (rebuilds state) private void When(OrderPlacedEvent @event) { Id = @event OrderId; Status = OrderStatus Placed; Items = @event Items; } // Command method public void Ship(ShipOrderCommand command) { if (Status = OrderStatus Placed) { throw new InvalidOperationException(\"Order must be placed to ship\"); } Apply(new OrderShippedEvent(Id, command TrackingNumber));\n    }\n}\n`\nBest Practices\nKeep Aggregates Small\nFocus on a single business concept\nAvoid large, complex aggregates\nConsider splitting if aggregate becomes unwieldy\nDesign Around Invariants\nIdentify what must remain consistent\nEncapsulate related data that changes together\nUse domain events to communicate between aggregates\nAvoid Cross-Aggregate Transactions\nOne aggregate per transaction\nUse eventual consistency between aggregates\nCommunicate via domain events and sagas\nIntegration with Whizbang\nWhizbang provides:\nRepository pattern for loading and saving aggregates\nAutomatic event publishing when aggregates are saved\nOptimistic concurrency handling out of the box\nMultiple storage backends (Postgres, SQL Server, etc )\nRelated Topics\nCore Concepts - Overview of Whizbang's architectural patterns\nRepositories and CQRS Helpers - Working with aggregate repositories\nCommand Handling - Processing commands in aggregates\nGetting Started - Hands-on tutorial building aggregates\nNext Steps\nThis page provides an overview of aggregates in Whizbang For detailed implementation examples and advanced patterns, see the comprehensive documentation linked above",
        "startIndex": 2182,
        "preview": "} // Event handler (rebuilds state) private void When(OrderPlacedEvent @event) { Id = @event OrderId; Status = OrderStatus Placed; Items = @event Item..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "core-concepts/core-concepts",
    "title": "Core Concepts",
    "category": "Core Concepts",
    "url": "/docs/core-concepts/core-concepts",
    "chunks": [
      {
        "id": "core-concepts/core-concepts-chunk-0",
        "text": "Core Concepts\nWhizbang is built on four foundational concepts: Events, Commands, Aggregates, and Projections Understanding these primitives is essential to using Whizbang effectively Events\nEvents are immutable facts that have happened in your system They represent state changes and are the source of truth in event-sourced architectures Characteristics\nPast tense naming - OrderPlaced, PaymentProcessed, InventoryReserved\nImmutable - Once written, never modified\nAppend-only - New events are added to the stream, old events remain forever\nDomain-owned - Each event belongs to a specific domain/service\nExample\n`csharp{\ntitle: \"Order Domain Events\"\ndescription: \"Events representing state changes in the order lifecycle\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Events\", \"Domain Events\", \"Order Management\"]\nusingStatements: [\"System\"]\nshowLineNumbers: true\n}\nusing System;\nnamespace MyApp Orders Events;\n// Event: Order was placed by a customer\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset PlacedAt,\n    List<OrderItem> Items,\n    decimal Total\n);\n// Event: Order was shipped\npublic record OrderShipped(\n    Guid OrderId,\n    DateTimeOffset ShippedAt,\n    string TrackingNumber\n);\n// Event: Order was cancelled\npublic record OrderCancelled(\n    Guid OrderId,\n    DateTimeOffset CancelledAt,\n    string Reason\n);\n`\nEvent Streams\nEvents are stored in streams, one stream per aggregate instance:\n`\nStream: \"Order-{orderId}\"\n  [0] OrderPlaced\n  [1] OrderItemAdded\n  [2] OrderShipped\n  [3] OrderDelivered\n`\nEach event has a position (sequence number) in the stream, enabling:\nReplaying the stream to rebuild aggregate state\nOptimistic concurrency - Detect conflicting concurrent updates\nPoint-in-time queries - Get state as of a specific event\nDomain Ownership\nEvents are owned by the domain that publishes them:\n`csharp{\ntitle: \"Domain-Owned Events\"\ndescription: \"Marking events with their owning domain\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Events\", \"Domain Ownership\", \"Distributed Systems\"]\nusingStatements: [\"Whizbang\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nnamespace MyApp Orders",
        "startIndex": 0,
        "preview": "Core Concepts\nWhizbang is built on four foundational concepts: Events, Commands, Aggregates, and Projections Understanding these primitives is essenti..."
      },
      {
        "id": "core-concepts/core-concepts-chunk-1",
        "text": "specific event Domain Ownership Events are owned by the domain that publishes them: `csharp{ title: \"Domain-Owned Events\" description: \"Marking events with their owning domain\" framework: \"NET8\" category: \"Domain Logic\" difficulty: \"INTERMEDIATE\" tags: [\"Events\", \"Domain Ownership\", \"Distributed Systems\"] usingStatements: [\"Whizbang\", \"System\"] showLineNumbers: true } using System; using Whizbang; namespace MyApp Orders Events;\n[OwnedBy(\"Orders\")]  // This event comes from the Orders domain\npublic record OrderPlaced(Guid OrderId, Guid CustomerId);\n[OwnedBy(\"Inventory\")]  // This event comes from the Inventory domain\npublic record InventoryReserved(Guid OrderId, List<Guid> ProductIds);\n`\nWhen other services subscribe to these events:\nThey're consuming a public API from the owning domain\nThe owning domain controls the event schema\nSubscribers can backfill from the entire event history\nCommands\nCommands are requests to change state They represent intent and are sent to the domain that owns the aggregate Characteristics\nImperative naming - PlaceOrder, ProcessPayment, ReserveInventory\nValidated - Can be rejected if invalid\nRouted - Sent to the owning domain's handlers\nSingle recipient - Unlike events, commands go to exactly one handler\nExample\n`csharp{\ntitle: \"Order Domain Commands\"\ndescription: \"Commands representing requests to change order state\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"CQRS\", \"Order Management\"]\nusingStatements: [\"System\"]\nshowLineNumbers: true\n}\nusing System;\nnamespace MyApp Orders Commands;\n// Command: Request to place a new order\npublic record PlaceOrder(\n    Guid CustomerId,\n    List<OrderItem> Items\n);\n// Command: Request to cancel an order\npublic record CancelOrder(\n    Guid OrderId,\n    string Reason\n);\n// Command: Request to update shipping address\npublic record UpdateShippingAddress(\n    Guid OrderId,\n    Address NewAddress\n);\n`\nCommand Handlers\nHandlers receive commands, validate them, and produce events:\n`csharp{\ntitle: \"Order Command Handler\"\ndescription: \"Handler that validates commands and produces events\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"Handlers\", \"Validation\", \"Events\"]\nusingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading",
        "startIndex": 2227,
        "preview": "specific event Domain Ownership Events are owned by the domain that publishes them: `csharp{ title: \"Domain-Owned Events\" description: \"Marking events..."
      },
      {
        "id": "core-concepts/core-concepts-chunk-2",
        "text": "` Command Handlers Handlers receive commands, validate them, and produce events: `csharp{ title: \"Order Command Handler\" description: \"Handler that validates commands and produces events\" framework: \"NET8\" category: \"Domain Logic\" difficulty: \"INTERMEDIATE\" tags: [\"Commands\", \"Handlers\", \"Validation\", \"Events\"] usingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading Tasks;\nusing Whizbang;\nnamespace MyApp Orders Handlers;\npublic class PlaceOrderHandler {\n    private readonly IOrderRepository _repository;\n    public PlaceOrderHandler(IOrderRepository repository) {\n        _repository = repository;\n    }\n    public async Task<OrderPlaced> Handle(PlaceOrder command) {\n        // Validate command\n        if (command Items Count == 0) {\n            throw new InvalidOperationException(\"Order must have at least one item\");\n        }\n        // Create aggregate\n        var order = new Order(\n            Guid NewGuid(),\n            command CustomerId,\n            command Items\n        );\n        // Persist aggregate (events are appended)\n        await _repository SaveAsync(order);\n        // Return event (auto-published by Whizbang)\n        return new OrderPlaced(\n            order Id,\n            command CustomerId,\n            DateTimeOffset UtcNow,\n            command Items,\n            order Total\n        );\n    }\n}\n`\nCommand Routing\nCommands are routed to the owning domain:\n`csharp{\ntitle: \"Sending Commands\"\ndescription: \"How to send commands to their owning domain\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"Routing\", \"Distributed Systems\"]\nusingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\npublic class CheckoutService {\n    private readonly IWhizbang _whizbang;\n    public CheckoutService(IWhizbang whizbang) {\n        _whizbang = whizbang;\n    }\n    public async Task CheckoutAsync(Guid customerId, List<OrderItem> items) {\n        // Send command to Orders domain\n        var placed = await _whizbang Send(new PlaceOrder(customerId, items));\n        // Send command to Inventory domain\n        await _whizbang Send(new ReserveInventory(placed OrderId, items));\n        // Send command to Payment domain\n        await _whizbang Send(new ProcessPayment(placed OrderId, placed Total));\n    }\n}\n`\nIn a monolith, these commands are routed to local handlers In microservices, they're routed to the owning service via message broker Aggregates\nAggregates are the write-side domain models that enforce business rules",
        "startIndex": 4174,
        "preview": "` Command Handlers Handlers receive commands, validate them, and produce events: `csharp{ title: \"Order Command Handler\" description: \"Handler that va..."
      },
      {
        "id": "core-concepts/core-concepts-chunk-3",
        "text": "OrderId, items)); // Send command to Payment domain await _whizbang Send(new ProcessPayment(placed OrderId, placed Total)); } } ` In a monolith, these commands are routed to local handlers In microservices, they're routed to the owning service via message broker Aggregates Aggregates are the write-side domain models that enforce business rules They are the consistency boundary for commands and events Characteristics\nConsistency boundary - All changes within an aggregate are transactional\nEvent-sourced - State is built by replaying events\nValidated - Enforce invariants before producing events\nSingle writer - Only one command can modify an aggregate at a time (optimistic concurrency)\nExample\n`csharp{\ntitle: \"Order Aggregate\"\ndescription: \"Event-sourced aggregate that enforces order business rules\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aggregates\", \"Event Sourcing\", \"Domain-Driven Design\"]\nusingStatements: [\"Whizbang\", \"System\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing Whizbang;\nnamespace MyApp Orders Domain;\npublic class Order : Aggregate {\n    public Guid Id { get; private set; }\n    public Guid CustomerId { get; private set; }\n    public OrderStatus Status { get; private set; }\n    public List<OrderItem> Items { get; private set; } = new();\n    public decimal Total { get; private set; }\n    // Constructor for new aggregates\n    public Order(Guid id, Guid customerId, List<OrderItem> items) {\n        // Validate business rules\n        if (items Count == 0) {\n            throw new InvalidOperationException(\"Order must have items\");\n        }\n        // Produce event\n        Apply(new OrderPlaced(\n            id,\n            customerId,\n            DateTimeOffset UtcNow,\n            items,\n            items Sum(i => i Price * i Quantity)\n        ));\n    }\n    // Event handler - updates state\n    private void When(OrderPlaced @event) {\n        Id = @event OrderId;\n        CustomerId = @event CustomerId;\n        Status = OrderStatus Placed;\n        Items = @event Items;\n        Total = @event Total;\n    }\n    // Command method - enforces business rules\n    public void Ship(string trackingNumber) {\n        if (Status = OrderStatus",
        "startIndex": 6389,
        "preview": "OrderId, items)); // Send command to Payment domain await _whizbang Send(new ProcessPayment(placed OrderId, placed Total)); } } ` In a monolith, these..."
      },
      {
        "id": "core-concepts/core-concepts-chunk-4",
        "text": ")); } // Event handler - updates state private void When(OrderPlaced @event) { Id = @event OrderId; CustomerId = @event CustomerId; Status = OrderStatus Placed; Items = @event Items; Total = @event Total; } // Command method - enforces business rules public void Ship(string trackingNumber) { if (Status = OrderStatus Placed) {\n            throw new InvalidOperationException(\"Can only ship placed orders\");\n        }\n        Apply(new OrderShipped(Id, DateTimeOffset UtcNow, trackingNumber));\n    }\n    // Event handler - updates state\n    private void When(OrderShipped @event) {\n        Status = OrderStatus Shipped;\n    }\n    // Command method - enforces business rules\n    public void Cancel(string reason) {\n        if (Status == OrderStatus Shipped || Status == OrderStatus Delivered) {\n            throw new InvalidOperationException(\"Cannot cancel shipped/delivered orders\");\n        }\n        Apply(new OrderCancelled(Id, DateTimeOffset UtcNow, reason));\n    }\n    // Event handler - updates state\n    private void When(OrderCancelled @event) {\n        Status = OrderStatus Cancelled;\n    }\n}\npublic enum OrderStatus {\n    Placed,\n    Shipped,\n    Delivered,\n    Cancelled\n}\n`\nEvent Sourcing Pattern\nAggregates follow this pattern:\nLoad aggregate by replaying events from the stream\nExecute command method, which validates business rules\nApply events to update state\nSave new events to the stream\n`csharp{\ntitle: \"Loading and Saving Aggregates\"\ndescription: \"How aggregates are loaded from and saved to event streams\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"ADVANCED\"\ntags: [\"Aggregates\", \"Event Sourcing\", \"Repositories\"]\nusingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nusing Whizbang;\npublic class OrderRepository : IOrderRepository {\n    private readonly IEventStore _eventStore;\n    public OrderRepository(IEventStore eventStore) {\n        _eventStore = eventStore;\n    }\n    public async Task<Order> GetAsync(Guid orderId) {\n        // Load events from stream\n        var events = await _eventStore LoadStreamAsync($\"Order-{orderId}\");\n        // Reconstitute aggregate by replaying events\n        var order = new Order();\n        foreach (var @event in events) {\n            order",
        "startIndex": 8314,
        "preview": ")); } // Event handler - updates state private void When(OrderPlaced @event) { Id = @event OrderId; CustomerId = @event CustomerId; Status = OrderStat..."
      },
      {
        "id": "core-concepts/core-concepts-chunk-5",
        "text": ": IOrderRepository { private readonly IEventStore _eventStore; public OrderRepository(IEventStore eventStore) { _eventStore = eventStore; } public async Task<Order> GetAsync(Guid orderId) { // Load events from stream var events = await _eventStore LoadStreamAsync($\"Order-{orderId}\"); // Reconstitute aggregate by replaying events var order = new Order(); foreach (var @event in events) { order ApplyEvent(@event);  // Calls private When() methods\n        }\n        return order;\n    }\n    public async Task SaveAsync(Order order) {\n        // Get uncommitted events from aggregate\n        var newEvents = order GetUncommittedEvents();\n        // Append to event stream with optimistic concurrency check\n        await _eventStore AppendToStreamAsync(\n            $\"Order-{order Id}\",\n            newEvents,\n            expectedVersion: order Version\n        );\n        // Mark events as committed\n        order MarkEventsAsCommitted();\n    }\n}\n`\nProjections\nProjections are read-side models optimized for queries They are built by subscribing to events and updating denormalized views Characteristics\nEventually consistent - Updated asynchronously as events arrive\nDenormalized - Optimized for specific query patterns\nRebuildable - Can be deleted and rebuilt from event history\nIsolated - Each projection has its own data model\nExample\n`csharp{\ntitle: \"Order History Projection\"\ndescription: \"Projection that maintains a queryable order history\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"CQRS\", \"Read Models\"]\nusingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\nnamespace MyApp Orders Projections;\n// Read model - optimized for queries\npublic class OrderHistoryItem {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    public DateTimeOffset PlacedAt { get; set; }\n    public DateTimeOffset ShippedAt { get; set; }\n    public decimal Total { get; set; }\n    public string Status { get; set; }\n}\n// Projection handler - subscribes to events\npublic class OrderHistoryProjection {\n    private readonly IOrderHistoryStore _store;\n    public OrderHistoryProjection(IOrderHistoryStore store) {\n        _store = store;\n    }\n    // Event handler - updates read model\n    public async Task Handle(OrderPlaced @event) {\n        await _store",
        "startIndex": 10359,
        "preview": ": IOrderRepository { private readonly IEventStore _eventStore; public OrderRepository(IEventStore eventStore) { _eventStore = eventStore; } public asy..."
      },
      {
        "id": "core-concepts/core-concepts-chunk-6",
        "text": "{ get; set; } public string Status { get; set; } } // Projection handler - subscribes to events public class OrderHistoryProjection { private readonly IOrderHistoryStore _store; public OrderHistoryProjection(IOrderHistoryStore store) { _store = store; } // Event handler - updates read model public async Task Handle(OrderPlaced @event) { await _store InsertAsync(new OrderHistoryItem {\n            OrderId = @event OrderId,\n            CustomerId = @event CustomerId,\n            PlacedAt = @event PlacedAt,\n            Total = @event Total,\n            Status = \"Placed\"\n        });\n    }\n    // Event handler - updates read model\n    public async Task Handle(OrderShipped @event) {\n        await _store UpdateAsync(@event OrderId, item => {\n            item ShippedAt = @event ShippedAt;\n            item Status = \"Shipped\";\n        });\n    }\n    // Event handler - updates read model\n    public async Task Handle(OrderCancelled @event) {\n        await _store UpdateAsync(@event OrderId, item => {\n            item Status = \"Cancelled\";\n        });\n    }\n}\n`\nQuerying Projections\nProjections are queried directly, not through the event store:\n`csharp{\ntitle: \"Querying Order History\"\ndescription: \"How to query projections for read-side data\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Projections\", \"Queries\", \"CQRS\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\npublic class OrderQueryService {\n    private readonly IOrderHistoryStore _store;\n    public OrderQueryService(IOrderHistoryStore store) {\n        _store = store;\n    }\n    public async Task<List<OrderHistoryItem>> GetCustomerOrdersAsync(Guid customerId) {\n        // Query the projection (fast, optimized for reads)\n        return await _store QueryAsync(item => item CustomerId == customerId);\n    }\n    public async Task<OrderHistoryItem> GetOrderDetailsAsync(Guid orderId) {\n        return await _store GetAsync(orderId);\n    }\n}\n`\nProjection Backfilling\nWhen a projection is added to a new service, it can backfill from historical events:\n`csharp{\ntitle: \"Backfilling a Projection\"\ndescription: \"Configure a projection to rebuild from historical events\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Backfilling\", \"Event Sourcing\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Microsoft Extensions",
        "startIndex": 12379,
        "preview": "{ get; set; } public string Status { get; set; } } // Projection handler - subscribes to events public class OrderHistoryProjection { private readonly..."
      },
      {
        "id": "core-concepts/core-concepts-chunk-7",
        "text": "to a new service, it can backfill from historical events: `csharp{ title: \"Backfilling a Projection\" description: \"Configure a projection to rebuild from historical events\" framework: \"NET8\" category: \"Domain Logic\" difficulty: \"ADVANCED\" tags: [\"Projections\", \"Backfilling\", \"Event Sourcing\"] usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"] showLineNumbers: true } using System; using Microsoft Extensions DependencyInjection;\nusing Whizbang;\npublic static class ServiceCollectionExtensions {\n    public static IServiceCollection AddOrderProjections(this IServiceCollection services) {\n        services AddProjection<OrderHistoryProjection>(options => {\n            // Subscribe to events from the Orders domain\n            options Subscribe<OrderPlaced>();\n            options Subscribe<OrderShipped>();\n            options Subscribe<OrderCancelled>();\n            // Backfill from the beginning of time\n            options BackfillFrom = DateTimeOffset MinValue;\n            // Process in parallel across order IDs (partitioned by OrderId)\n            options PartitionBy = @event => ((dynamic)@event) OrderId;\n        });\n        return services;\n    }\n}\n`\nWhen this projection starts:\nIt queries the Orders service for all historical OrderPlaced, OrderShipped, and OrderCancelled events\nIt applies them in order to build the initial projection state\nIt continues processing new events as they arrive\nCQRS Pattern\nCQRS (Command Query Responsibility Segregation) separates writes from reads:\nCommands → Aggregates (write side)\nQueries → Projections (read side)\n`\n     Command                   Event                   Query\n        ↓                        ↓                        ↓\n   ┌─────────┐             ┌──────────┐            ┌──────────┐\n   │Aggregate│ ─Events→    │Event     │ ─Events→   │Projection│\n   │         │             │Store     │            │          │\n   └─────────┘             └──────────┘            └──────────┘\n   Write Model             Source of Truth          Read Model\n   (Normalized)            (Immutable)              (Denormalized)\n`\nBenefits:\nOptimized models - Write and read models can have different schemas\nScalability - Scale reads independently from writes\nFlexibility - Multiple projections can be built from the same events\nNext Steps\nNow that you understand the core concepts, learn how to:\nGet Started - Build your first Whizbang application\nPackage Structure - Choose the right NuGet packages\nDriver System - Understand how to swap persistence and messaging backends",
        "startIndex": 14594,
        "preview": "to a new service, it can backfill from historical events: `csharp{ title: \"Backfilling a Projection\" description: \"Configure a projection to rebuild f..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "core-concepts/projections",
    "title": "Projections",
    "category": "Core Concepts",
    "url": "/docs/core-concepts/projections",
    "chunks": [
      {
        "id": "core-concepts/projections-chunk-0",
        "text": "Projections\nProjections are the read-side component of CQRS in Whizbang They create optimized, denormalized views of your data by subscribing to domain events and building read models tailored for specific query patterns What are Projections Projections transform events from the write-side (aggregates) into read models optimized for queries:\nEvent Subscribers: Listen to domain events as they occur\nRead Model Builders: Create denormalized views optimized for queries\nEventually Consistent: Updated asynchronously as events are processed\nRebuildable: Can be deleted and rebuilt from event history\nKey Benefits\nQuery Optimization\nDenormalized Data: Flatten complex relationships for fast reads\nIndexed Views: Create optimal indexes for specific query patterns\nMultiple Formats: Same events can feed different projection formats\nScalability\nIndependent Scaling: Scale read and write sides independently\nCaching Friendly: Read models can be heavily cached\nDistributed Reads: Replicate read models across regions\nFlexibility\nMultiple Projections: Create different views from same events\nTechnology Choice: Use different databases for different projections\nSchema Evolution: Add new projections without affecting writes\nHow Projections Work\n`mermaid\nsequenceDiagram\n    participant Aggregate\n    participant EventStore as Event Store\n    participant Projection\n    participant ReadDB as Read Database\n    participant Query as Query Handler\n    Aggregate->>EventStore: Save Events\n    EventStore->>Projection: Publish Events\n    Projection->>Projection: Process Events\n    Projection->>ReadDB: Update Read Model\n    Query->>ReadDB: Query Read Model\n    ReadDB->>Query: Return Results\n`\nExample Projection\n`csharp\npublic class OrderSummaryProjection {\n    private readonly IProjectionStore<OrderSummary> _store;\n    public OrderSummaryProjection(IProjectionStore<OrderSummary> store) {\n        _store = store;\n    }\n    // Event handler - creates new read model\n    public async Task Handle(OrderPlacedEvent @event) {\n        await _store UpsertAsync(@event OrderId, new OrderSummary {\n            OrderId = @event OrderId,\n            CustomerId = @event CustomerId,\n            Total = @event Total,\n            Status = \"Placed\",\n            PlacedAt = @event PlacedAt\n        });\n    }\n    // Event handler - updates existing read model\n    public async Task Handle(OrderShippedEvent @event) {\n        await _store UpdateAsync(@event OrderId, summary => {\n            summary Status = \"Shipped\";\n            summary ShippedAt = @event ShippedAt;\n            summary",
        "startIndex": 0,
        "preview": "Projections\nProjections are the read-side component of CQRS in Whizbang They create optimized, denormalized views of your data by subscribing to domai..."
      },
      {
        "id": "core-concepts/projections-chunk-1",
        "text": "@event OrderId, CustomerId = @event CustomerId, Total = @event Total, Status = \"Placed\", PlacedAt = @event PlacedAt }); } // Event handler - updates existing read model public async Task Handle(OrderShippedEvent @event) { await _store UpdateAsync(@event OrderId, summary => { summary Status = \"Shipped\"; summary ShippedAt = @event ShippedAt; summary TrackingNumber = @event TrackingNumber;\n        });\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    public decimal Total { get; set; }\n    public string Status { get; set; }\n    public DateTime PlacedAt { get; set; }\n    public DateTime ShippedAt { get; set; }\n    public string TrackingNumber { get; set; }\n}\n`\nProjection Types\nSimple Projections\nSingle Entity: One event stream → One read model\nDirect Mapping: Events map directly to read model properties\nUse Case: Basic CRUD operations, simple reporting\nComposite Projections\nMultiple Streams: Events from multiple aggregates\nJoined Data: Combine data from different domains\nUse Case: Complex reports, dashboards, analytics\nCached Projections\nMemory-Based: Keep frequently accessed data in memory\nHigh Performance: Sub-millisecond query times\nUse Case: Real-time dashboards, autocomplete\nConfiguration\n`csharp\nservices AddWhizbang(options => {\n    options UseProjections(proj => {\n        // Register projection\n        proj RegisterProjection<OrderSummaryProjection>(p => {\n            p Subscribe<OrderPlacedEvent>();\n            p Subscribe<OrderShippedEvent>();\n            p Subscribe<OrderCancelledEvent>();\n        });\n        // Configure backfilling\n        proj BackfillFromBeginning = true;\n        // Configure partitioning\n        proj PartitionBy = @event => ((dynamic)@event)",
        "startIndex": 2568,
        "preview": "@event OrderId, CustomerId = @event CustomerId, Total = @event Total, Status = \"Placed\", PlacedAt = @event PlacedAt }); } // Event handler - updates e..."
      },
      {
        "id": "core-concepts/projections-chunk-2",
        "text": "High Performance: Sub-millisecond query times Use Case: Real-time dashboards, autocomplete Configuration `csharp services AddWhizbang(options => { options UseProjections(proj => { // Register projection proj RegisterProjection<OrderSummaryProjection>(p => { p Subscribe<OrderPlacedEvent>(); p Subscribe<OrderShippedEvent>(); p Subscribe<OrderCancelledEvent>(); }); // Configure backfilling proj BackfillFromBeginning = true; // Configure partitioning proj PartitionBy = @event => ((dynamic)@event) OrderId;\n    });\n});\n`\nAdvanced Features\nBackfilling\nHistorical Data: Process events from before projection was created\nIncremental: Resume from last processed event\nParallel: Process multiple partitions concurrently\nEvent Filtering\nSelective Processing: Only process relevant events\nPattern Matching: Subscribe to events by type or properties\nPerformance: Reduce unnecessary processing\nSchema Evolution\nVersioning: Handle projection schema changes\nMigration: Update existing read models\nBackward Compatibility: Support multiple projection versions\nBest Practices\nDesign for Queries\nQuery-First: Design projections around actual query needs\nDenormalize: Include all data needed for queries\nIndex Appropriately: Add indexes for query patterns\nHandle Failures\nRetry Logic: Handle transient failures\nDead Letter Queues: Capture failed events\nMonitoring: Track projection health and lag\nPerformance Optimization\nBatch Processing: Process events in batches\nAsync Processing: Use async/await throughout\nConnection Pooling: Optimize database connections\nStorage Options\nWhizbang supports multiple projection storage backends:\nSQL Databases: Postgres, SQL Server, MySQL\nDocument Stores: MongoDB, CosmosDB\nSearch Engines: Elasticsearch, Azure Search\nKey-Value Stores: Redis, DynamoDB\nMemory: In-memory caching\nRelated Topics\nCore Concepts - Overview of CQRS and event sourcing\nProjection Subscriptions - Configuring event subscriptions\nProjection Contexts - Managing projection lifecycle\nGetting Started - Tutorial building your first projection\nNext Steps\nThis page provides an overview of projections in Whizbang For detailed implementation patterns and advanced scenarios, explore the specialized projection documentation in the Projections section",
        "startIndex": 3986,
        "preview": "High Performance: Sub-millisecond query times Use Case: Real-time dashboards, autocomplete Configuration `csharp services AddWhizbang(options => { opt..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "core-concepts/repositories-and-helpers",
    "title": "Repositories and CQRS Helpers",
    "category": "Core Concepts",
    "url": "/docs/core-concepts/repositories-and-helpers",
    "chunks": [
      {
        "id": "core-concepts/repositories-and-helpers-chunk-0",
        "text": "Repositories and CQRS Helpers\nWhizbang provides rich framework support for implementing CQRS patterns through repositories, query handlers, and helper classes that separate concerns across the write and read sides of your application Repository Patterns\nWrite-Side Repository (Aggregates)\nThe IRepository<TAggregate> interface handles loading and saving event-sourced aggregates:\n`csharp{\ntitle: \"Aggregate Repository Interface\"\ndescription: \"Core interface for aggregate persistence\"\nframework: \"NET8\"\ncategory: \"Repositories\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Repositories\", \"Aggregates\", \"Event Sourcing\"]\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nnamespace Whizbang EventSourcing;\npublic interface IRepository<TAggregate> where TAggregate : Aggregate {\n    /// <summary>\n    /// Loads an aggregate by replaying its event stream /// </summary>\n    Task<TAggregate > FindAsync(Guid id, CancellationToken ct = default);\n    /// <summary>\n    /// Loads an aggregate, throwing if not found /// </summary>\n    Task<TAggregate> GetAsync(Guid id, CancellationToken ct = default);\n    /// <summary>\n    /// Saves uncommitted events from the aggregate to the event store /// </summary>\n    Task SaveAsync(TAggregate aggregate, CancellationToken ct = default);\n    /// <summary>\n    /// Loads aggregate as of a specific version (point-in-time query) /// </summary>\n    Task<TAggregate > GetAsOfAsync(Guid id, long version, CancellationToken ct = default);\n    /// <summary>\n    /// Loads aggregate as of a specific timestamp (time-travel debugging) /// </summary>\n    Task<TAggregate > GetAsOfAsync(Guid id, DateTimeOffset timestamp, CancellationToken ct = default);\n}\n`\nUsage:\n`csharp{\ntitle: \"Using Aggregate Repository\"\ndescription: \"Load, modify, and save an aggregate\"\nframework: \"NET8\"\ncategory: \"Repositories\"\ndifficulty: \"BEGINNER\"\ntags: [\"Repositories\", \"Aggregates\", \"Commands\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\npublic class PlaceOrderHandler {\n    private readonly IRepository<Order> _orderRepository;\n    public PlaceOrderHandler(IRepository<Order> orderRepository) {\n        _orderRepository = orderRepository;\n    }\n    public async Task<OrderPlaced> Handle(PlaceOrder command) {\n        // Create new aggregate\n        var order = new Order(command CustomerId, command Items);\n        // Save (appends events to stream)\n        await _orderRepository SaveAsync(order);\n        return new OrderPlaced(order Id, command CustomerId, order",
        "startIndex": 0,
        "preview": "Repositories and CQRS Helpers\nWhizbang provides rich framework support for implementing CQRS patterns through repositories, query handlers, and helper..."
      },
      {
        "id": "core-concepts/repositories-and-helpers-chunk-1",
        "text": "public class PlaceOrderHandler { private readonly IRepository<Order> _orderRepository; public PlaceOrderHandler(IRepository<Order> orderRepository) { _orderRepository = orderRepository; } public async Task<OrderPlaced> Handle(PlaceOrder command) { // Create new aggregate var order = new Order(command CustomerId, command Items); // Save (appends events to stream) await _orderRepository SaveAsync(order); return new OrderPlaced(order Id, command CustomerId, order Total);\n    }\n}\n`\nRead-Side Repository (Projections)\nThe IProjectionStore<TProjection> interface handles querying denormalized read models:\n`csharp{\ntitle: \"Projection Store Interface\"\ndescription: \"Interface for querying read models\"\nframework: \"NET8\"\ncategory: \"Repositories\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Queries\", \"CQRS\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\", \"System Linq Expressions\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Linq Expressions;\nusing System Threading Tasks;\nnamespace Whizbang Projections;\npublic interface IProjectionStore<TProjection> where TProjection : class {\n    /// <summary>\n    /// Gets a projection by ID /// </summary>\n    Task<TProjection > GetAsync(Guid id, CancellationToken ct = default);\n    /// <summary>\n    /// Queries projections using a predicate /// </summary>\n    Task<List<TProjection>> QueryAsync(\n        Expression<Func<TProjection, bool>> predicate,\n        CancellationToken ct = default\n    );\n    /// <summary>\n    /// Paged query for large result sets /// </summary>\n    Task<PagedResult<TProjection>> QueryPagedAsync(\n        Expression<Func<TProjection, bool>> predicate,\n        int page,\n        int pageSize,\n        CancellationToken ct = default\n    );\n    /// <summary>\n    /// Inserts or updates a projection /// </summary>\n    Task UpsertAsync(Guid id, TProjection projection, CancellationToken ct = default);\n    /// <summary>\n    /// Updates an existing projection /// </summary>\n    Task UpdateAsync(Guid id, Action<TProjection> update, CancellationToken ct = default);\n    /// <summary>\n    /// Deletes a projection /// </summary>\n    Task DeleteAsync(Guid id, CancellationToken ct = default);\n}\n`\nUsage:\n`csharp{\ntitle: \"Querying Projection Store\"\ndescription: \"Query read models for customer orders\"\nframework: \"NET8\"\ncategory: \"Repositories\"\ndifficulty: \"BEGINNER\"\ntags: [\"Projections\", \"Queries\", \"CQRS\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\", \"Whizbang Projections\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nusing Whizbang",
        "startIndex": 2668,
        "preview": "public class PlaceOrderHandler { private readonly IRepository<Order> _orderRepository; public PlaceOrderHandler(IRepository<Order> orderRepository) { ..."
      },
      {
        "id": "core-concepts/repositories-and-helpers-chunk-2",
        "text": "} ` Usage: `csharp{ title: \"Querying Projection Store\" description: \"Query read models for customer orders\" framework: \"NET8\" category: \"Repositories\" difficulty: \"BEGINNER\" tags: [\"Projections\", \"Queries\", \"CQRS\"] usingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\", \"Whizbang Projections\"] showLineNumbers: true } using System; using System Collections Generic; using System Threading Tasks; using Whizbang Projections;\npublic class OrderQueryService {\n    private readonly IProjectionStore<OrderHistoryItem> _store;\n    public OrderQueryService(IProjectionStore<OrderHistoryItem> store) {\n        _store = store;\n    }\n    public async Task<List<OrderHistoryItem>> GetCustomerOrdersAsync(Guid customerId) {\n        return await _store QueryAsync(order => order CustomerId == customerId);\n    }\n    public async Task<PagedResult<OrderHistoryItem>> GetRecentOrdersAsync(int page, int pageSize) {\n        return await _store QueryPagedAsync(\n            order => order Status = \"Cancelled\",\n            page,\n            pageSize\n        );\n    }\n}\n`\nCQRS Helper Classes\nCommand Bus\nThe ICommandBus sends commands to their handlers:\n`csharp{\ntitle: \"Command Bus Interface\"\ndescription: \"Send commands and receive results\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"CQRS\", \"Messaging\"]\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nnamespace Whizbang;\npublic interface ICommandBus {\n    /// <summary>\n    /// Sends a command and waits for result /// </summary>\n    Task<TResult> SendAsync<TResult>(object command, CancellationToken ct = default);\n    /// <summary>\n    /// Sends a command without waiting for result (fire-and-forget) /// </summary>\n    Task PublishAsync(object command, CancellationToken ct = default);\n    /// <summary>\n    /// Sends multiple commands in a batch /// </summary>\n    Task PublishBatchAsync(IEnumerable<object> commands, CancellationToken ct = default);\n}\n`\nQuery Bus\nThe IQueryBus executes queries against projections:\n`csharp{\ntitle: \"Query Bus Interface\"\ndescription: \"Execute queries and return results\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Queries\", \"CQRS\", \"Projections\"]\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nnamespace Whizbang;\npublic interface IQueryBus {\n    /// <summary>\n    /// Executes a query and returns result",
        "startIndex": 4910,
        "preview": "} ` Usage: `csharp{ title: \"Querying Projection Store\" description: \"Query read models for customer orders\" framework: \"NET8\" category: \"Repositories\"..."
      },
      {
        "id": "core-concepts/repositories-and-helpers-chunk-3",
        "text": "`csharp{ title: \"Query Bus Interface\" description: \"Execute queries and return results\" framework: \"NET8\" category: \"CQRS\" difficulty: \"INTERMEDIATE\" tags: [\"Queries\", \"CQRS\", \"Projections\"] usingStatements: [\"System\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading Tasks; namespace Whizbang; public interface IQueryBus { /// <summary> /// Executes a query and returns result /// </summary>\n    Task<TResult> QueryAsync<TResult>(object query, CancellationToken ct = default);\n}\n`\nUsage:\n`csharp{\ntitle: \"Using Query Bus\"\ndescription: \"Execute queries via query bus\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"BEGINNER\"\ntags: [\"Queries\", \"CQRS\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nusing Whizbang;\n// Define query\npublic record GetCustomerOrders(Guid CustomerId);\n// Define query handler\npublic class GetCustomerOrdersHandler {\n    private readonly IProjectionStore<OrderHistoryItem> _store;\n    public GetCustomerOrdersHandler(IProjectionStore<OrderHistoryItem> store) {\n        _store = store;\n    }\n    public async Task<List<OrderHistoryItem>> Handle(GetCustomerOrders query) {\n        return await _store QueryAsync(o => o CustomerId == query CustomerId);\n    }\n}\n// Execute query\npublic class OrderController {\n    private readonly IQueryBus _queryBus;\n    public OrderController(IQueryBus queryBus) {\n        _queryBus = queryBus;\n    }\n    public async Task<IActionResult> GetOrders(Guid customerId) {\n        var orders = await _queryBus QueryAsync<List<OrderHistoryItem>>(\n            new GetCustomerOrders(customerId)\n        );\n        return Ok(orders);\n    }\n}\n`\nEvent Publisher\nThe IEventPublisher publishes domain events to subscribers:\n`csharp{\ntitle: \"Event Publisher Interface\"\ndescription: \"Publish events to subscribers\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Events\", \"Publishing\", \"Messaging\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nnamespace Whizbang;\npublic interface IEventPublisher {\n    /// <summary>\n    /// Publishes a single event to all subscribers /// </summary>\n    Task PublishAsync(object @event, CancellationToken ct = default);\n    /// <summary>\n    /// Publishes multiple events in order /// </summary>\n    Task PublishBatchAsync(IEnumerable<object> events, CancellationToken ct = default);\n    /// <summary>\n    /// Publishes event to specific subscribers (filtered)",
        "startIndex": 7012,
        "preview": "`csharp{ title: \"Query Bus Interface\" description: \"Execute queries and return results\" framework: \"NET8\" category: \"CQRS\" difficulty: \"INTERMEDIATE\" ..."
      },
      {
        "id": "core-concepts/repositories-and-helpers-chunk-4",
        "text": "Whizbang; public interface IEventPublisher { /// <summary> /// Publishes a single event to all subscribers /// </summary> Task PublishAsync(object @event, CancellationToken ct = default); /// <summary> /// Publishes multiple events in order /// </summary> Task PublishBatchAsync(IEnumerable<object> events, CancellationToken ct = default); /// <summary> /// Publishes event to specific subscribers (filtered) /// </summary>\n    Task PublishToAsync(object @event, string subscriberFilter, CancellationToken ct = default);\n}\n`\nSpecialized Helpers\nUnit of Work Pattern\nFor scenarios requiring transactional consistency across multiple aggregates:\n`csharp{\ntitle: \"Unit of Work Interface\"\ndescription: \"Transactional boundary for multiple aggregates\"\nframework: \"NET8\"\ncategory: \"Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Unit of Work\", \"Transactions\", \"Aggregates\"]\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nnamespace Whizbang EventSourcing;\npublic interface IUnitOfWork : IDisposable {\n    /// <summary>\n    /// Gets a repository for an aggregate type /// </summary>\n    IRepository<TAggregate> Repository<TAggregate>() where TAggregate : Aggregate;\n    /// <summary>\n    /// Commits all changes across all aggregates /// </summary>\n    Task CommitAsync(CancellationToken ct = default);\n    /// <summary>\n    /// Rolls back all changes /// </summary>\n    Task RollbackAsync(CancellationToken ct = default);\n}\n`\nUsage (use sparingly - violates aggregate boundaries):\n`csharp{\ntitle: \"Using Unit of Work\"\ndescription: \"Transactional update across multiple aggregates\"\nframework: \"NET8\"\ncategory: \"Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Unit of Work\", \"Transactions\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang EventSourcing\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang EventSourcing;\npublic class TransferInventoryHandler {\n    private readonly IUnitOfWork _unitOfWork;\n    public TransferInventoryHandler(IUnitOfWork unitOfWork) {\n        _unitOfWork = unitOfWork;\n    }\n    public async Task Handle(TransferInventory command) {\n        var sourceWarehouse = await _unitOfWork Repository<Warehouse>() GetAsync(command SourceWarehouseId);\n        var destWarehouse = await _unitOfWork Repository<Warehouse>() GetAsync(command DestinationWarehouseId);\n        // Both aggregates modified in same transaction\n        sourceWarehouse RemoveInventory(command ProductId, command Quantity);\n        destWarehouse AddInventory(command ProductId, command Quantity);\n        await _unitOfWork Repository<Warehouse>() SaveAsync(sourceWarehouse);\n        await _unitOfWork Repository<Warehouse>() SaveAsync(destWarehouse);\n        // Atomic commit\n        await _unitOfWork",
        "startIndex": 9302,
        "preview": "Whizbang; public interface IEventPublisher { /// <summary> /// Publishes a single event to all subscribers /// </summary> Task PublishAsync(object @ev..."
      },
      {
        "id": "core-concepts/repositories-and-helpers-chunk-5",
        "text": "Task Handle(TransferInventory command) { var sourceWarehouse = await _unitOfWork Repository<Warehouse>() GetAsync(command SourceWarehouseId); var destWarehouse = await _unitOfWork Repository<Warehouse>() GetAsync(command DestinationWarehouseId); // Both aggregates modified in same transaction sourceWarehouse RemoveInventory(command ProductId, command Quantity); destWarehouse AddInventory(command ProductId, command Quantity); await _unitOfWork Repository<Warehouse>() SaveAsync(sourceWarehouse); await _unitOfWork Repository<Warehouse>() SaveAsync(destWarehouse); // Atomic commit await _unitOfWork CommitAsync();\n    }\n}\n`\nWarning: Use sagas instead when possible to maintain aggregate boundaries Specification Pattern\nFor complex query logic:\n`csharp{\ntitle: \"Specification Pattern\"\ndescription: \"Reusable query specifications\"\nframework: \"NET8\"\ncategory: \"Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Specification\", \"Queries\", \"Patterns\"]\nusingStatements: [\"System\", \"System Linq Expressions\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Linq Expressions;\nnamespace Whizbang Projections;\npublic interface ISpecification<TProjection> {\n    Expression<Func<TProjection, bool>> Predicate { get; }\n}\npublic class ActiveOrdersSpecification : ISpecification<OrderHistoryItem> {\n    public Expression<Func<OrderHistoryItem, bool>> Predicate =>\n        order => order Status = \"Cancelled\" && order Status = \"Delivered\";\n}\npublic class CustomerOrdersSpecification : ISpecification<OrderHistoryItem> {\n    private readonly Guid _customerId;\n    public CustomerOrdersSpecification(Guid customerId) {\n        _customerId = customerId;\n    }\n    public Expression<Func<OrderHistoryItem, bool>> Predicate =>\n        order => order CustomerId == _customerId;\n}\n`\nUsage:\n`csharp{\ntitle: \"Using Specifications\"\ndescription: \"Compose reusable query specifications\"\nframework: \"NET8\"\ncategory: \"Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Specification\", \"Queries\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\", \"Whizbang Projections\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nusing Whizbang Projections;\npublic class OrderQueryService {\n    private readonly IProjectionStore<OrderHistoryItem> _store;\n    public OrderQueryService(IProjectionStore<OrderHistoryItem> store) {\n        _store = store;\n    }\n    public async Task<List<OrderHistoryItem>> GetActiveCustomerOrdersAsync(Guid customerId) {\n        var spec = new ActiveOrdersSpecification() And(new CustomerOrdersSpecification(customerId));\n        return await _store QueryAsync(spec Predicate);\n    }\n}\n`\nProjection Builder\nHelper for building complex projections:\n`csharp{\ntitle: \"Projection Builder\"\ndescription: \"Fluent API for building projections\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Builder Pattern\"]\nusingStatements: [\"System\", \"Whizbang Projections\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang",
        "startIndex": 11761,
        "preview": "Task Handle(TransferInventory command) { var sourceWarehouse = await _unitOfWork Repository<Warehouse>() GetAsync(command SourceWarehouseId); var dest..."
      },
      {
        "id": "core-concepts/repositories-and-helpers-chunk-6",
        "text": "new ActiveOrdersSpecification() And(new CustomerOrdersSpecification(customerId)); return await _store QueryAsync(spec Predicate); } } ` Projection Builder Helper for building complex projections: `csharp{ title: \"Projection Builder\" description: \"Fluent API for building projections\" framework: \"NET8\" category: \"Projections\" difficulty: \"ADVANCED\" tags: [\"Projections\", \"Builder Pattern\"] usingStatements: [\"System\", \"Whizbang Projections\"] showLineNumbers: true } using System; using Whizbang Projections;\npublic class OrderSummaryProjectionBuilder : ProjectionBuilder<OrderSummary> {\n    public OrderSummaryProjectionBuilder() {\n        // Subscribe to events\n        On<OrderPlaced>(@event => {\n            Upsert(@event OrderId, new OrderSummary {\n                OrderId = @event OrderId,\n                CustomerId = @event CustomerId,\n                Total = @event Total,\n                Status = \"Placed\"\n            });\n        });\n        On<OrderShipped>(@event => {\n            Update(@event OrderId, summary => {\n                summary Status = \"Shipped\";\n                summary ShippedAt = @event ShippedAt;\n            });\n        });\n        On<OrderCancelled>(@event => {\n            Update(@event OrderId, summary => summary Status = \"Cancelled\");\n        });\n    }\n}\n`\nMulti-Tenant Repository Support\nAll repository interfaces support tenant scoping:\n`csharp{\ntitle: \"Multi-Tenant Repository\"\ndescription: \"Tenant-scoped aggregate repository\"\nframework: \"NET8\"\ncategory: \"Multi-Tenancy\"\ndifficulty: \"ADVANCED\"\ntags: [\"Multi-Tenancy\", \"Repositories\", \"Security\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang EventSourcing\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang EventSourcing;\npublic interface ITenantRepository<TAggregate> where TAggregate : Aggregate {\n    /// <summary>\n    /// Loads aggregate for specific tenant /// </summary>\n    Task<TAggregate > FindAsync(Guid tenantId, Guid aggregateId, CancellationToken ct = default);\n    /// <summary>\n    /// Saves aggregate with tenant isolation /// Stream ID: \"Tenant-{tenantId}-Order-{orderId}\"\n    /// </summary>\n    Task SaveAsync(Guid tenantId, TAggregate aggregate, CancellationToken ct = default);\n}\n// Usage with tenant context\npublic class PlaceOrderHandler {\n    private readonly ITenantRepository<Order> _repository;\n    private readonly ITenantContext _tenantContext;\n    public PlaceOrderHandler(ITenantRepository<Order> repository, ITenantContext tenantContext) {\n        _repository = repository;\n        _tenantContext = tenantContext;\n    }\n    public async Task<OrderPlaced> Handle(PlaceOrder command) {\n        var order = new Order(command CustomerId, command Items);\n        // Tenant ID from context (claims, header, etc )\n        await _repository SaveAsync(_tenantContext TenantId, order);\n        return new OrderPlaced(order Id, command CustomerId, order",
        "startIndex": 14195,
        "preview": "new ActiveOrdersSpecification() And(new CustomerOrdersSpecification(customerId)); return await _store QueryAsync(spec Predicate); } } ` Projection Bui..."
      },
      {
        "id": "core-concepts/repositories-and-helpers-chunk-7",
        "text": "ITenantContext _tenantContext; public PlaceOrderHandler(ITenantRepository<Order> repository, ITenantContext tenantContext) { _repository = repository; _tenantContext = tenantContext; } public async Task<OrderPlaced> Handle(PlaceOrder command) { var order = new Order(command CustomerId, command Items); // Tenant ID from context (claims, header, etc ) await _repository SaveAsync(_tenantContext TenantId, order); return new OrderPlaced(order Id, command CustomerId, order Total);\n    }\n}\n`\nPermission-Scoped Repositories\nRepositories can enforce permissions:\n`csharp{\ntitle: \"Permission-Scoped Repository\"\ndescription: \"Repository with built-in authorization\"\nframework: \"NET8\"\ncategory: \"Security\"\ndifficulty: \"ADVANCED\"\ntags: [\"Security\", \"Authorization\", \"Repositories\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang EventSourcing\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang EventSourcing;\npublic interface ISecureRepository<TAggregate> where TAggregate : Aggregate {\n    /// <summary>\n    /// Loads aggregate only if user has read permission /// </summary>\n    Task<TAggregate > FindAsync(Guid id, CancellationToken ct = default);\n    /// <summary>\n    /// Saves aggregate only if user has write permission /// Throws UnauthorizedAccessException if permission denied /// </summary>\n    Task SaveAsync(TAggregate aggregate, CancellationToken ct = default);\n}\n// Configuration\nservices AddWhizbang(options => {\n    options UseRepositories(repos => {\n        repos EnforcePermissions = true;\n        repos RequirePermission<Order>(\"orders:read\", \"orders:write\");\n        repos RequirePermission<Inventory>(\"inventory:read\", \"inventory:write\");\n    });\n});\n`\nNext Steps\nTesting - Test repositories and handlers\nMulti-Tenancy - Deep dive into tenant isolation\nSecurity - Authorization and authentication patterns",
        "startIndex": 16625,
        "preview": "ITenantContext _tenantContext; public PlaceOrderHandler(ITenantRepository<Order> repository, ITenantContext tenantContext) { _repository = repository;..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "design/open-questions",
    "title": "Open Design Questions",
    "category": "Architecture & Design",
    "url": "/docs/design/open-questions",
    "chunks": [
      {
        "id": "design/open-questions-chunk-0",
        "text": "Open Design Questions\nThis document captures open questions and architectural decisions that need to be resolved for Whizbang These questions are organized by priority and domain area 🔴 Critical Decisions (Blocking MVP)\nHandler Discovery Mechanism\nQuestion: How should Whizbang discover command/event handlers Options:\nA Assembly Scanning (Runtime)\n`csharp\noptions ScanAssembly(typeof(Program) Assembly);\n`\n✅ Simple, developer-friendly\n✅ Works with any handler signature\n❌ Breaks AOT compilation\n❌ Slow startup time\nB Source Generators (Compile-Time)\n`csharp\n// Generated code creates handler registry\n[WhizbangHandlers]  // Triggers source generator\npublic partial class HandlerRegistry { }\n`\n✅ AOT-safe\n✅ Fast startup\n✅ Compile-time errors for misconfigurations\n❌ More complex implementation\n❌ Less flexible\nC Explicit Registration\n`csharp\noptions RegisterHandler<PlaceOrder, PlaceOrderHandler>();\noptions RegisterHandler<OrderPlaced, OrderHistoryProjection>();\n`\n✅ AOT-safe\n✅ Explicit and clear\n❌ Tedious for large applications\n❌ Easy to forget handlers\nHybrid Approach Source generators for AOT builds\nAssembly scanning for non-AOT builds\nAutomatic detection based on publish settings\nDecision Needed: Which approach for MVP Can we support multiple modes ---\nHandler Method Signature Conventions\nQuestion: What method signatures should handlers support Option A: Explicit Interface\n`csharp\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderPlaced> {\n    public async Task<OrderPlaced> Handle(PlaceOrder command) {\n        //",
        "startIndex": 0,
        "preview": "Open Design Questions\nThis document captures open questions and architectural decisions that need to be resolved for Whizbang These questions are orga..."
      },
      {
        "id": "design/open-questions-chunk-1",
        "text": "non-AOT builds Automatic detection based on publish settings Decision Needed: Which approach for MVP Can we support multiple modes --- Handler Method Signature Conventions Question: What method signatures should handlers support Option A: Explicit Interface `csharp public class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderPlaced> { public async Task<OrderPlaced> Handle(PlaceOrder command) { // }\n}\n`\n✅ Type-safe\n✅ Easy to discover via interfaces\n❌ Verbose\n❌ Couples to framework\nOption B: Convention-Based (Method Name)\n`csharp\npublic class PlaceOrderHandler {\n    public async Task<OrderPlaced> Handle(PlaceOrder command) {\n        // Any method named 'Handle' with correct signature\n    }\n}\n`\n✅ Minimal framework coupling\n✅ Flexible\n❌ Harder to discover (needs scanning or source gen)\n❌ Runtime errors if signature is wrong\nOption C: Attribute-Based\n`csharp\npublic class OrderHandlers {\n    [CommandHandler]\n    public async Task<OrderPlaced> PlaceOrder(PlaceOrder command) {\n        // Any method name, attribute marks it as handler\n    }\n}\n`\n✅ Flexible naming\n✅ Easy to discover via attributes\n❌ Attribute noise\nDecision Needed: Which convention Should we support multiple conventions ---\nEvent Store Schema Design\nQuestion: How should events be stored in the database",
        "startIndex": 1564,
        "preview": "non-AOT builds Automatic detection based on publish settings Decision Needed: Which approach for MVP Can we support multiple modes --- Handler Method ..."
      },
      {
        "id": "design/open-questions-chunk-2",
        "text": "PlaceOrder(PlaceOrder command) { // Any method name, attribute marks it as handler } } ` ✅ Flexible naming ✅ Easy to discover via attributes ❌ Attribute noise Decision Needed: Which convention Should we support multiple conventions --- Event Store Schema Design Question: How should events be stored in the database Option A: Single Events Table (All Domains)\n`sql\nCREATE TABLE events (\n    event_id BIGSERIAL PRIMARY KEY,\n    stream_id VARCHAR(255) NOT NULL,\n    stream_version INT NOT NULL,\n    event_type VARCHAR(255) NOT NULL,\n    event_data JSONB NOT NULL,\n    metadata JSONB,\n    created_at TIMESTAMPTZ NOT NULL,\n    UNIQUE(stream_id, stream_version)\n);\nCREATE INDEX idx_stream ON events(stream_id);\nCREATE INDEX idx_type ON events(event_type);\n`\n✅ Simple\n✅ Global event ordering\n✅ Easy cross-aggregate queries\n❌ Single table can become huge\n❌ Harder to shard/partition\nOption B: Per-Aggregate-Type Tables\n`sql\nCREATE TABLE order_events (\n    event_id BIGSERIAL PRIMARY KEY,\n    order_id UUID NOT NULL,\n    version INT NOT NULL,\n    event_type VARCHAR(255) NOT NULL,\n    event_data JSONB NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL,\n    UNIQUE(order_id, version)\n);\n`\n✅ Better partitioning\n✅ Aggregate-level isolation\n❌ Complex global event queries\n❌ Harder to implement projections across aggregates\nOption C: Hybrid (Events Table + Projection Tables)\n`sql\n-- Single events table for event sourcing\nCREATE TABLE events ( );\n-- Separate projection tables for queries\nCREATE TABLE order_history ( );\n`\n✅ Best of both worlds\n✅ Optimized for both writes and reads\n❌ More complex setup\nDecision Needed: Which schema for MVP Document migration path ---\nOptimistic Concurrency Strategy\nQuestion: How should Whizbang handle concurrent updates to the same aggregate Option A: Expected Version\n`csharp\nawait eventStore AppendAsync(streamId, events, expectedVersion: 5);\n// Throws if current version = 5\n`\n✅ Standard event sourcing pattern\n✅ Detects all conflicts\n❌ Requires aggregate to track version\n❌ Developer must handle retry logic\nOption B: Timestamp-Based\n`csharp\nawait eventStore",
        "startIndex": 2446,
        "preview": "PlaceOrder(PlaceOrder command) { // Any method name, attribute marks it as handler } } ` ✅ Flexible naming ✅ Easy to discover via attributes ❌ Attribu..."
      },
      {
        "id": "design/open-questions-chunk-3",
        "text": "to the same aggregate Option A: Expected Version `csharp await eventStore AppendAsync(streamId, events, expectedVersion: 5); // Throws if current version = 5 ` ✅ Standard event sourcing pattern ✅ Detects all conflicts ❌ Requires aggregate to track version ❌ Developer must handle retry logic Option B: Timestamp-Based `csharp await eventStore AppendAsync(streamId, events, ifNotModifiedSince: lastRead);\n`\n✅ Familiar HTTP-style semantics\n❌ Less precise than version numbers\n❌ Clock skew issues\nOption C: Automatic Retry with Conflict Resolution\n`csharp\noptions UseOptimisticConcurrency(opt => {\n    opt RetryAttempts = 3;\n    opt ConflictResolver<Order>((current, attempted) => {\n        // Custom merge logic\n    });\n});\n`\n✅ Handles most conflicts automatically\n✅ Better developer experience\n❌ Complex to implement\n❌ Not all conflicts can be auto-resolved\nDecision Needed: Start with Option A (expected version), add Option C later ---\nDomain Ownership Declaration\nQuestion: How should domain ownership be declared for commands and events Option A: Attributes\n`csharp\n[OwnedBy(\"Orders\")]\npublic record PlaceOrder( );\n[OwnedBy(\"Orders\")]\npublic record OrderPlaced( );\n`\n✅ Clear and explicit\n✅ Easy to find via reflection/source gen\n❌ Can be forgotten\nOption B: Namespace Convention\n`csharp\nnamespace MyApp Orders Commands {\n    public record PlaceOrder( );  // Implicitly owned by \"Orders\"\n}\n`\n✅ No attributes needed\n✅ Convention-based\n❌ Less flexible\n❌ What if namespace doesn't match domain Option C: Configuration\n`csharp\noptions RegisterDomain(\"Orders\", domain => {\n    domain OwnsCommand<PlaceOrder>();\n    domain OwnsEvent<OrderPlaced>();\n});\n`\n✅ Centralized ownership declaration\n✅ Can override conventions\n❌ Tedious for large systems\nHybrid Approach Attributes by default\nNamespace convention as fallback\nConfiguration for overrides\nDecision Needed: Which approach Should we enforce domain ownership at compile-time (analyzer) ---\n🟡 Important (Nice to Have for MVP)\nProjection Checkpoint Storage\nQuestion: Where should projection checkpoint positions be stored Option A: Same Database as Projection\n`csharp\n// Checkpoint and projection data in same transaction\nawait tx UpdateProjection(",
        "startIndex": 4225,
        "preview": "to the same aggregate Option A: Expected Version `csharp await eventStore AppendAsync(streamId, events, expectedVersion: 5); // Throws if current vers..."
      },
      {
        "id": "design/open-questions-chunk-4",
        "text": "overrides Decision Needed: Which approach Should we enforce domain ownership at compile-time (analyzer) --- 🟡 Important (Nice to Have for MVP) Projection Checkpoint Storage Question: Where should projection checkpoint positions be stored Option A: Same Database as Projection `csharp // Checkpoint and projection data in same transaction await tx UpdateProjection( );\nawait tx UpdateCheckpoint(position);\nawait tx CommitAsync();\n`\n✅ Transactional consistency\n✅ Simple\n❌ Tight coupling\nOption B: Separate Metadata Store\n`csharp\n// Projection in Postgres, checkpoints in Redis/Cosmos\nawait projectionStore UpdateAsync( );\nawait checkpointStore SaveAsync(position);\n`\n✅ Flexible\n✅ Can optimize checkpoint storage separately\n❌ Two-phase commit problem\n❌ More complex\nDecision Needed: Option A for MVP, support Option B later ---\nSnapshot Strategy\nQuestion: Should Whizbang support aggregate snapshots to avoid replaying thousands of events Current: Always replay all events from stream start\nOption A: Automatic Snapshots\n`csharp\noptions UseSnapshots(snap => {\n    snap SnapshotEvery = 100 events;  // Auto-snapshot every N events\n});\n`\nOption B: Manual Snapshots\n`csharp\npublic class Order : Aggregate {\n    [Snapshot]  // Mark method as snapshot creator\n    public OrderSnapshot CreateSnapshot() {\n        return new OrderSnapshot(Id, Status, Items, Total);\n    }\n}\n`\nOption C: No Snapshots (Events Only)\n✅ Simpler\n✅ No snapshot versioning issues\n❌ Poor performance for long-lived aggregates\nDecision Needed: Defer snapshots until post-MVP Or include basic support ---\nProjection Backfilling API\nQuestion: What's the API for backfilling projections from historical events Option A: Declarative (Start Position)\n`csharp\nservices AddProjection<OrderHistoryProjection>(options => {\n    options BackfillFrom = DateTimeOffset Parse(\"2024-01-01\");\n    // Or: options BackfillFromBeginning = true;\n});\n`\n✅ Simple\n✅ Automatic\n❌ No progress visibility\nOption B: Imperative (Manual Control)\n`csharp\nvar projection = provider GetRequiredService<OrderHistoryProjection>();\nawait projection RebuildAsync(from: DateTimeOffset MinValue, onProgress: pos => {\n    Console",
        "startIndex": 6094,
        "preview": "overrides Decision Needed: Which approach Should we enforce domain ownership at compile-time (analyzer) --- 🟡 Important (Nice to Have for MVP) Projec..."
      },
      {
        "id": "design/open-questions-chunk-5",
        "text": "Declarative (Start Position) `csharp services AddProjection<OrderHistoryProjection>(options => { options BackfillFrom = DateTimeOffset Parse(\"2024-01-01\"); // Or: options BackfillFromBeginning = true; }); ` ✅ Simple ✅ Automatic ❌ No progress visibility Option B: Imperative (Manual Control) `csharp var projection = provider GetRequiredService<OrderHistoryProjection>(); await projection RebuildAsync(from: DateTimeOffset MinValue, onProgress: pos => { Console WriteLine($\"Rebuilt up to {pos}\");\n});\n`\n✅ Full control\n✅ Progress reporting\n❌ More complex\nDecision Needed: Support both Option A for common case, Option B for advanced scenarios ---\nSaga State Persistence\nQuestion: How should saga state be persisted Option A: Event-Sourced Sagas\n`csharp\npublic class OrderFulfillmentSaga : EventSourcedSaga {\n    // Saga state rebuilt from events\n}\n`\n✅ Consistent with aggregate pattern\n✅ Audit trail of saga execution\n❌ More complex\nOption B: State-Based Sagas\n`csharp\npublic class OrderFulfillmentSaga : StatefulSaga<OrderFulfillmentState> {\n    // Saga state stored as document\n}\n`\n✅ Simpler\n✅ Direct state queries\n❌ Less audit trail\nDecision Needed: Support both Which is primary pattern ---\n🟢 Future Considerations (Post-MVP)\nMulti-Tenancy Support\nQuestion: How should Whizbang support multi-tenant applications Per-tenant databases Tenant ID in event streams Isolation at projection level Schema Evolution & Event Versioning\nQuestion: How should we handle evolving event schemas over time `csharp\n// V1\npublic record OrderPlaced(Guid OrderId, Guid CustomerId);\n// V2 - Added field\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt);\n`\nOptions:\nUpcasting (convert old events to new schema on read)\nMultiple versions supported simultaneously\nSchema registry\nBlue/Green Projection Deployments\nQuestion: How can projections be updated without downtime Scenario: We want to change a projection's schema How do we:\nDeploy new projection version\nBackfill it from events\nSwitch traffic to new version\nDelete old version\nNeeds: Projection versioning, parallel execution, traffic switching\nCross-Aggregate Transactions\nQuestion: Should Whizbang support transactions across multiple aggregates",
        "startIndex": 7889,
        "preview": "Declarative (Start Position) `csharp services AddProjection<OrderHistoryProjection>(options => { options BackfillFrom = DateTimeOffset Parse(\"2024-01-..."
      },
      {
        "id": "design/open-questions-chunk-6",
        "text": "can projections be updated without downtime Scenario: We want to change a projection's schema How do we: Deploy new projection version Backfill it from events Switch traffic to new version Delete old version Needs: Projection versioning, parallel execution, traffic switching Cross-Aggregate Transactions Question: Should Whizbang support transactions across multiple aggregates Current Guidance: Don't do it (sagas instead)\nBut What If: Use case demands it Options:\nUnit of Work pattern\nDistributed transactions (2PC)\nJust say no and enforce single-aggregate boundaries\nOutbox/Inbox Table Schema\nQuestion: What should outbox/inbox tables look like for distributed messaging Outbox (events waiting to be published):\n`sql\nCREATE TABLE outbox (\n    message_id UUID PRIMARY KEY,\n    aggregate_id UUID NOT NULL,\n    event_type VARCHAR(255) NOT NULL,\n    event_data JSONB NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL,\n    published_at TIMESTAMPTZ,\n    destination_topic VARCHAR(255)\n);\n`\nInbox (messages received from broker):\n`sql\nCREATE TABLE inbox (\n    message_id UUID PRIMARY KEY,\n    source_domain VARCHAR(255) NOT NULL,\n    event_type VARCHAR(255) NOT NULL,\n    event_data JSONB NOT NULL,\n    received_at TIMESTAMPTZ NOT NULL,\n    processed_at TIMESTAMPTZ\n);\n`\nDecision Needed: Is this schema sufficient What about dead-letter handling Distributed Tracing Context\nQuestion: How should distributed traces propagate across services W3C Trace Context Headers:\n`\ntraceparent: 00-{trace-id}-{parent-id}-01\ntracestate: whizbang=correlation-id\n`\nOpenTelemetry Automatic Instrumentation Performance Budgets & SLOs\nQuestion: Should Whizbang support performance budgets for handlers `csharp\n[PerformanceBudget(MaxLatency = \"100ms\")]\npublic class PlaceOrderHandler {\n    // Alert if handler takes > 100ms\n}\n`\nCould integrate with OpenTelemetry to alert on violations Kubernetes Operator Features\nQuestion: What should the Whizbang Kubernetes Operator do Ideas:\nAuto-scale projection workers based on lag\nPartition-aware pod placement\nBlue/green deployments for projections\nAutomatic backfilling on projection updates\nNo-Code Projection Designer\nQuestion: Can we build a visual tool for designing projections without writing code",
        "startIndex": 9659,
        "preview": "can projections be updated without downtime Scenario: We want to change a projection's schema How do we: Deploy new projection version Backfill it fro..."
      },
      {
        "id": "design/open-questions-chunk-7",
        "text": "to alert on violations Kubernetes Operator Features Question: What should the Whizbang Kubernetes Operator do Ideas: Auto-scale projection workers based on lag Partition-aware pod placement Blue/green deployments for projections Automatic backfilling on projection updates No-Code Projection Designer Question: Can we build a visual tool for designing projections without writing code Concept: Drag-and-drop UI to:\nSelect event types to subscribe to\nMap event fields to projection properties\nDefine aggregations/transformations\nGenerate Ccode or config\nFeasibility: Doable for simple projections, hard for complex logic ---\nHow to Use This Document\nFor Contributors\nReview open questions before starting major work If your work intersects with an open question:\nComment with your perspective\nPropose a concrete solution\nCreate a spike/POC if needed\nFor Maintainers\nPrioritize resolving 🔴 Critical questions before MVP release 🟡 Important questions can be decided during MVP development 🟢 Future questions are for post-MVP planning Decision Process\nDiscuss in GitHub Issues or Discussions\nPrototype if uncertain (spike branch)\nDocument decision in ADR (Architecture Decision Record)\nUpdate documentation and code to match decision\nRemove question from this file once resolved\n---\nRelated Resources\nPhilosophy - Core principles that should guide decisions\nArchitecture - Current architecture overview\nRoadmap - Planned features and timeline\n---\nQuestions or Ideas Open a GitHub Discussion or Issue",
        "startIndex": 11511,
        "preview": "to alert on violations Kubernetes Operator Features Question: What should the Whizbang Kubernetes Operator do Ideas: Auto-scale projection workers bas..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "examples/enhanced-csharp-examples",
    "title": "C# Code Examples",
    "category": "Examples",
    "url": "/docs/examples/enhanced-csharp-examples",
    "chunks": [
      {
        "id": "examples/enhanced-csharp-examples-chunk-0",
        "text": "CCode Examples\nThis document demonstrates comprehensive Ccode examples with rich metadata, interactive features, and professional styling Basic Examples\nSimple Console Application\n`csharp{\ntitle: \"Hello World Console App\"\ndescription: \"A simple console application demonstrating basic Csyntax\"\nframework: \"NET8\"\ndifficulty: \"BEGINNER\"\nfilename: \"Program cs\"\n}\nusing System;\nnamespace HelloWorld {\n    class Program {\n        static void Main(string[] args) {\n            Console WriteLine(\"Hello, World \");\n            Console WriteLine(\"Welcome to enhanced Ccode viewing \");\n            var message = GetWelcomeMessage(\"Developer\");\n            Console WriteLine(message);\n        }\n        static string GetWelcomeMessage(string name) {\n            return $\"Hello, {name} Today is {DateTime Now:yyyy-MM-dd}\";\n        }\n    }\n}\n`\nBasic Class Example\n`csharp{\ntitle: \"Person Class\"\ndescription: \"Simple class with properties and methods\"\ncategory: \"ENTITY\"\ndifficulty: \"BEGINNER\"\ntags: [\"Class\", \"Properties\", \"Methods\"]\nfilename: \"Person cs\"\n}\npublic class Person {\n    public string Name { get; set; }\n    public int Age { get; set; }\n    public string Email { get; set; }\n    public Person(string name, int age, string email) {\n        Name = name;\n        Age = age;\n        Email = email;\n    }\n    public void DisplayInfo() {\n        Console WriteLine($\"Name: {Name}\");\n        Console WriteLine($\"Age: {Age}\");\n        Console WriteLine($\"Email: {Email}\");\n    }\n    public bool IsAdult() {\n        return Age >= 18;\n    }\n}\n`\nNuGet Package Example\n`csharp{\ntitle: \"JSON Serialization Example\"\ndescription: \"Using Newtonsoft Json for JSON operations\"\nframework: \"NET8\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"JSON\", \"Serialization\", \"NuGet\"]\nnugetPackages: [\"Newtonsoft Json\"]\nfilename: \"JsonExample cs\"\n}\nusing Newtonsoft Json;\nusing System Collections Generic;\npublic class JsonExample {\n    public void SerializeExample() {\n        var person = new Person(\"John Doe\", 30, \"john@example com\");\n        // Serialize to JSON\n        string json = JsonConvert SerializeObject(person, Formatting Indented);\n        Console WriteLine(\"Serialized JSON:\");\n        Console WriteLine(json);\n        // Deserialize from JSON\n        var deserializedPerson = JsonConvert DeserializeObject<Person>(json);\n        Console WriteLine(\"\\nDeserialized object:\");\n        deserializedPerson",
        "startIndex": 0,
        "preview": "CCode Examples\nThis document demonstrates comprehensive Ccode examples with rich metadata, interactive features, and professional styling Basic Exampl..."
      },
      {
        "id": "examples/enhanced-csharp-examples-chunk-1",
        "text": "using System Collections Generic; public class JsonExample { public void SerializeExample() { var person = new Person(\"John Doe\", 30, \"john@example com\"); // Serialize to JSON string json = JsonConvert SerializeObject(person, Formatting Indented); Console WriteLine(\"Serialized JSON:\"); Console WriteLine(json); // Deserialize from JSON var deserializedPerson = JsonConvert DeserializeObject<Person>(json); Console WriteLine(\"\\nDeserialized object:\"); deserializedPerson DisplayInfo();\n    }\n}\n`\nAdvanced Examples\nBasic API Controller Example\n`csharp{\ntitle: \"User Management API Controller\"\ndescription: \"A comprehensive REST API controller for user management with CRUD operations\"\nframework: \"NET8\"\ncategory: \"API\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Web API\", \"REST\", \"CRUD\", \"Authentication\"]\ngithubUrl: \"https://github com/example/user-api\"\ndocsUrl: \"https://docs microsoft com/aspnet/core/web-api\"\nnugetPackages: [\"Microsoft AspNetCore Mvc\", \"Microsoft EntityFrameworkCore\", \"Microsoft AspNetCore Authorization\"]\nfilename: \"UserController cs\"\nshowLineNumbers: true\nshowLinesOnly: [1, 2, 3, 8, 9, 12, 13, 14, 15, 18, 19] \nhighlightLines: [12, 15, 28, 45]\nusingStatements: [\"Microsoft AspNetCore Mvc\", \"Microsoft EntityFrameworkCore\", \"Microsoft AspNetCore Authorization\", \"System Threading Tasks\", \"System Collections Generic\"]\n}\nusing Microsoft AspNetCore Mvc;\nusing Microsoft EntityFrameworkCore;\nusing Microsoft AspNetCore Authorization;\nnamespace UserManagement Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public class UserController : ControllerBase\n    {\n        private readonly UserDbContext _context;\n        private readonly ILogger<UserController> _logger;\n        public UserController(UserDbContext context, ILogger<UserController> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n        [HttpGet]\n        public async Task<ActionResult<IEnumerable<UserDto>>> GetUsers()\n        {\n            try\n            {\n                var users = await _context Users Where(u => u IsActive) Select(u => new UserDto\n                    {\n                        Id = u Id,\n                        Name = u Name,\n                        Email = u Email,\n                        CreatedAt = u CreatedAt\n                    }) ToListAsync();\n                return Ok(users);\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error retrieving users\");\n                return StatusCode(500, \"Internal server error\");\n            }\n        }\n        [HttpGet(\"{id}\")]\n        public async Task<ActionResult<UserDto>> GetUser(int id)\n        {\n            var user = await _context Users FindAsync(id);\n            if (user == null)\n            {\n                return NotFound($\"User with ID {id} not found\");\n            }\n            return Ok(new UserDto\n            {\n                Id = user Id,\n                Name = user Name,\n                Email = user Email,\n                CreatedAt = user",
        "startIndex": 2380,
        "preview": "using System Collections Generic; public class JsonExample { public void SerializeExample() { var person = new Person(\"John Doe\", 30, \"john@example co..."
      },
      {
        "id": "examples/enhanced-csharp-examples-chunk-2",
        "text": "server error\"); } } [HttpGet(\"{id}\")] public async Task<ActionResult<UserDto>> GetUser(int id) { var user = await _context Users FindAsync(id); if (user == null) { return NotFound($\"User with ID {id} not found\"); } return Ok(new UserDto { Id = user Id, Name = user Name, Email = user Email, CreatedAt = user CreatedAt\n            });\n        }\n        [HttpPost]\n        public async Task<ActionResult<UserDto>> CreateUser([FromBody] CreateUserRequest request)\n        {\n            if ( ModelState IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n            var user = new User\n            {\n                Name = request Name,\n                Email = request Email,\n                CreatedAt = DateTime UtcNow,\n                IsActive = true\n            };\n            _context Users Add(user);\n            await _context SaveChangesAsync();\n            var userDto = new UserDto\n            {\n                Id = user Id,\n                Name = user Name,\n                Email = user Email,\n                CreatedAt = user CreatedAt\n            };\n            return CreatedAtAction(nameof(GetUser), new { id = user Id }, userDto);\n        }\n    }\n}\n`\nEntity Framework Model Example\n`csharp{\ntitle: \"User Entity Model\"\ndescription: \"Entity Framework model with relationships and validation attributes\"\nframework: \"NET8\"\ncategory: \"ENTITY\"\ndifficulty: \"BEGINNER\"\ntags: [\"Entity Framework\", \"Models\", \"Data Annotations\"]\nnugetPackages: [\"Microsoft EntityFrameworkCore\", \"System ComponentModel Annotations\"]\nfilename: \"User cs\"\n}\nusing System ComponentModel DataAnnotations;\nusing System ComponentModel DataAnnotations Schema;\nnamespace UserManagement Models\n{\n    [Table(\"Users\")]\n    public class User\n    {\n        [Key]\n        [DatabaseGenerated(DatabaseGeneratedOption Identity)]\n        public int Id { get; set; }\n        [Required]\n        [StringLength(100, MinimumLength = 2)]\n        public string Name { get; set; } = string Empty;\n        [Required]\n        [EmailAddress]\n        [StringLength(255)]\n        public string Email { get; set; } = string Empty;\n        [Required]\n        public DateTime CreatedAt { get; set; }\n        public DateTime",
        "startIndex": 5016,
        "preview": "server error\"); } } [HttpGet(\"{id}\")] public async Task<ActionResult<UserDto>> GetUser(int id) { var user = await _context Users FindAsync(id); if (us..."
      },
      {
        "id": "examples/enhanced-csharp-examples-chunk-3",
        "text": "User { [Key] [DatabaseGenerated(DatabaseGeneratedOption Identity)] public int Id { get; set; } [Required] [StringLength(100, MinimumLength = 2)] public string Name { get; set; } = string Empty; [Required] [EmailAddress] [StringLength(255)] public string Email { get; set; } = string Empty; [Required] public DateTime CreatedAt { get; set; } public DateTime UpdatedAt { get; set; }\n        [Required]\n        public bool IsActive { get; set; } = true;\n        // Navigation properties\n        public virtual ICollection<UserRole> UserRoles { get; set; } = new List<UserRole>();\n        public virtual ICollection<UserProfile> UserProfiles { get; set; } = new List<UserProfile>();\n    }\n    public class UserDto\n    {\n        public int Id { get; set; }\n        public string Name { get; set; } = string Empty;\n        public string Email { get; set; } = string Empty;\n        public DateTime CreatedAt { get; set; }\n    }\n    public class CreateUserRequest\n    {\n        [Required]\n        [StringLength(100, MinimumLength = 2)]\n        public string Name { get; set; } = string Empty;\n        [Required]\n        [EmailAddress]\n        public string Email { get; set; } = string Empty;\n    }\n}\n`\nAdvanced Service Pattern Example\n`csharp{\ntitle: \"User Service with Repository Pattern\"\ndescription: \"Implementation of service layer with dependency injection and error handling\"\nframework: \"NET8\"\ncategory: \"SERVICE\"\ndifficulty: \"ADVANCED\"\ntags: [\"Service Pattern\", \"Repository\", \"Dependency Injection\", \"Error Handling\"]\ngithubUrl: \"https://github com/example/user-service\"\nnugetPackages: [\"Microsoft Extensions Logging\", \"AutoMapper\"]\nfilename: \"UserService cs\"\nshowLinesOnly: [1, 2, 3, 4, 9, 10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 24, 25]\ncollapsible: false\n}\nusing AutoMapper;\nusing Microsoft Extensions Logging;\nusing UserManagement Models;\nusing UserManagement Repositories;\nusing UserManagement Exceptions;\nnamespace UserManagement Services\n{\n    public interface IUserService\n    {\n        Task<IEnumerable<UserDto>> GetAllUsersAsync();\n        Task<UserDto > GetUserByIdAsync(int id);\n        Task<UserDto> CreateUserAsync(CreateUserRequest request);\n        Task<UserDto",
        "startIndex": 6914,
        "preview": "User { [Key] [DatabaseGenerated(DatabaseGeneratedOption Identity)] public int Id { get; set; } [Required] [StringLength(100, MinimumLength = 2)] publi..."
      },
      {
        "id": "examples/enhanced-csharp-examples-chunk-4",
        "text": "4, 9, 10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 24, 25] collapsible: false } using AutoMapper; using Microsoft Extensions Logging; using UserManagement Models; using UserManagement Repositories; using UserManagement Exceptions; namespace UserManagement Services { public interface IUserService { Task<IEnumerable<UserDto>> GetAllUsersAsync(); Task<UserDto > GetUserByIdAsync(int id); Task<UserDto> CreateUserAsync(CreateUserRequest request); Task<UserDto > UpdateUserAsync(int id, UpdateUserRequest request);\n        Task<bool> DeleteUserAsync(int id);\n        Task<bool> UserExistsAsync(string email);\n    }\n    public class UserService : IUserService\n    {\n        private readonly IUserRepository _userRepository;\n        private readonly IMapper _mapper;\n        private readonly ILogger<UserService> _logger;\n        public UserService(\n            IUserRepository userRepository,\n            IMapper mapper,\n            ILogger<UserService> logger)\n        {\n            _userRepository = userRepository throw new ArgumentNullException(nameof(userRepository));\n            _mapper = mapper throw new ArgumentNullException(nameof(mapper));\n            _logger = logger throw new ArgumentNullException(nameof(logger));\n        }\n        public async Task<IEnumerable<UserDto>> GetAllUsersAsync()\n        {\n            try\n            {\n                _logger LogInformation(\"Retrieving all active users\");\n                var users = await _userRepository GetActiveUsersAsync();\n                var userDtos = _mapper Map<IEnumerable<UserDto>>(users);\n                _logger LogInformation(\"Retrieved {UserCount} active users\", users Count());\n                return userDtos;\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error occurred while retrieving users\");\n                throw new ServiceException(\"Failed to retrieve users\", ex);\n            }\n        }\n        public async Task<UserDto > GetUserByIdAsync(int id)\n        {\n            try\n            {\n                _logger LogInformation(\"Retrieving user with ID: {UserId}\", id);\n                var user = await _userRepository GetByIdAsync(id);\n                if (user == null)\n                {\n                    _logger LogWarning(\"User with ID {UserId} not found\", id);\n                    return null;\n                }\n                var userDto = _mapper Map<UserDto>(user);\n                _logger LogInformation(\"Successfully retrieved user: {UserEmail}\", user Email);\n                return userDto;\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error occurred while retrieving user with ID: {UserId}\", id);\n                throw new ServiceException($\"Failed to retrieve user with ID: {id}\", ex);\n            }\n        }\n        public async Task<UserDto> CreateUserAsync(CreateUserRequest request)\n        {\n            try\n            {\n                _logger LogInformation(\"Creating new user with email: {Email}\", request Email);\n                // Check if user already exists\n                if (await UserExistsAsync(request Email))\n                {\n                    throw new DuplicateUserException($\"User with email {request Email} already exists\");\n                }\n                var user = _mapper Map<User>(request);\n                user CreatedAt = DateTime UtcNow;\n                user IsActive = true;\n                var createdUser = await _userRepository",
        "startIndex": 8735,
        "preview": "4, 9, 10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 24, 25] collapsible: false } using AutoMapper; using Microsoft Extensions Logging; using UserManagement ..."
      },
      {
        "id": "examples/enhanced-csharp-examples-chunk-5",
        "text": "{ _logger LogInformation(\"Creating new user with email: {Email}\", request Email); // Check if user already exists if (await UserExistsAsync(request Email)) { throw new DuplicateUserException($\"User with email {request Email} already exists\"); } var user = _mapper Map<User>(request); user CreatedAt = DateTime UtcNow; user IsActive = true; var createdUser = await _userRepository CreateAsync(user);\n                var userDto = _mapper Map<UserDto>(createdUser);\n                _logger LogInformation(\"Successfully created user with ID: {UserId}\", createdUser Id);\n                return userDto;\n            }\n            catch (DuplicateUserException)\n            {\n                throw; // Re-throw business logic exceptions\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error occurred while creating user with email: {Email}\", request Email);\n                throw new ServiceException(\"Failed to create user\", ex);\n            }\n        }\n        public async Task<bool> UserExistsAsync(string email)\n        {\n            try\n            {\n                return await _userRepository ExistsByEmailAsync(email);\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error checking if user exists with email: {Email}\", email);\n                throw new ServiceException(\"Failed to check user existence\", ex);\n            }\n        }\n    }\n}\n`\nMiddleware Configuration Example\n`csharp{\ntitle: \"Custom Authentication Middleware\"\ndescription: \"JWT authentication middleware with custom claims handling\"\nframework: \"NET8\"\ncategory: \"MIDDLEWARE\"\ndifficulty: \"ADVANCED\"\ntags: [\"Middleware\", \"JWT\", \"Authentication\", \"Security\"]\ndocsUrl: \"https://docs microsoft com/aspnet/core/fundamentals/middleware\"\nnugetPackages: [\"Microsoft AspNetCore Authentication JwtBearer\", \"System IdentityModel Tokens Jwt\"]\nfilename: \"JwtAuthenticationMiddleware cs\"\n}\nusing Microsoft AspNetCore Authentication;\nusing Microsoft Extensions Options;\nusing System IdentityModel Tokens Jwt;\nusing System Security Claims;\nusing System Text Encodings Web;\nusing Microsoft IdentityModel Tokens;\nusing System Text;\nnamespace UserManagement Middleware\n{\n    public class JwtAuthenticationMiddleware\n    {\n        private readonly RequestDelegate _next;\n        private readonly JwtSettings _jwtSettings;\n        private readonly ILogger<JwtAuthenticationMiddleware> _logger;\n        public JwtAuthenticationMiddleware(\n            RequestDelegate next,\n            IOptions<JwtSettings> jwtSettings,\n            ILogger<JwtAuthenticationMiddleware> logger)\n        {\n            _next = next;\n            _jwtSettings = jwtSettings Value;\n            _logger = logger;\n        }\n        public async Task InvokeAsync(HttpContext context)\n        {\n            var token = ExtractTokenFromHeader(context);\n            if ( string IsNullOrEmpty(token))\n            {\n                await ValidateAndSetUser(context, token);\n            }\n            await _next(context);\n        }\n        private string ExtractTokenFromHeader(HttpContext context)\n        {\n            var authHeader = context Request Headers[\"Authorization\"] FirstOrDefault();\n            if (authHeader = null && authHeader",
        "startIndex": 11764,
        "preview": "{ _logger LogInformation(\"Creating new user with email: {Email}\", request Email); // Check if user already exists if (await UserExistsAsync(request Em..."
      },
      {
        "id": "examples/enhanced-csharp-examples-chunk-6",
        "text": "= next; _jwtSettings = jwtSettings Value; _logger = logger; } public async Task InvokeAsync(HttpContext context) { var token = ExtractTokenFromHeader(context); if ( string IsNullOrEmpty(token)) { await ValidateAndSetUser(context, token); } await _next(context); } private string ExtractTokenFromHeader(HttpContext context) { var authHeader = context Request Headers[\"Authorization\"] FirstOrDefault(); if (authHeader = null && authHeader StartsWith(\"Bearer \"))\n            {\n                return authHeader Substring(\"Bearer \" Length) Trim();\n            }\n            return null;\n        }\n        private async Task ValidateAndSetUser(HttpContext context, string token)\n        {\n            try\n            {\n                var tokenHandler = new JwtSecurityTokenHandler();\n                var key = Encoding ASCII GetBytes(_jwtSettings SecretKey);\n                var validationParameters = new TokenValidationParameters\n                {\n                    ValidateIssuerSigningKey = true,\n                    IssuerSigningKey = new SymmetricSecurityKey(key),\n                    ValidateIssuer = true,\n                    ValidIssuer = _jwtSettings Issuer,\n                    ValidateAudience = true,\n                    ValidAudience = _jwtSettings Audience,\n                    ValidateLifetime = true,\n                    ClockSkew = TimeSpan Zero\n                };\n                var principal = tokenHandler ValidateToken(token, validationParameters, out SecurityToken validatedToken);\n                // Set the user context\n                context User = principal;\n                _logger LogInformation(\"JWT token validated successfully for user: {UserId}\", \n                    principal FindFirst(ClaimTypes NameIdentifier) Value);\n            }\n            catch (SecurityTokenException ex)\n            {\n                _logger LogWarning(\"Invalid JWT token: {Error}\", ex Message);\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error validating JWT token\");\n            }\n        }\n    }\n    public class JwtSettings\n    {\n        public string SecretKey { get; set; } = string Empty;\n        public string Issuer { get; set; } = string Empty;\n        public string Audience { get; set; } = string Empty;\n        public int ExpirationMinutes { get; set; } = 60;\n    }\n}\n`\nConfiguration and Startup Example\n`csharp{\ntitle: \"Program cs Configuration\"\ndescription: \"Modern NET 8 minimal hosting model with comprehensive service configuration\"\nframework: \"NET8\"\ncategory: \"CONFIG\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Configuration\", \"Dependency Injection\", \"Startup\", \"Minimal API\"]\nfilename: \"Program cs\"\n}\nusing Microsoft EntityFrameworkCore;\nusing Microsoft AspNetCore Authentication JwtBearer;\nusing Microsoft IdentityModel Tokens;\nusing System Text;\nusing UserManagement Data;\nusing UserManagement Services;\nusing UserManagement Repositories;\nusing UserManagement Middleware;\nvar builder = WebApplication CreateBuilder(args);\n// Configuration\nvar jwtSettings = builder Configuration",
        "startIndex": 14649,
        "preview": "= next; _jwtSettings = jwtSettings Value; _logger = logger; } public async Task InvokeAsync(HttpContext context) { var token = ExtractTokenFromHeader(..."
      },
      {
        "id": "examples/enhanced-csharp-examples-chunk-7",
        "text": "tags: [\"Configuration\", \"Dependency Injection\", \"Startup\", \"Minimal API\"] filename: \"Program cs\" } using Microsoft EntityFrameworkCore; using Microsoft AspNetCore Authentication JwtBearer; using Microsoft IdentityModel Tokens; using System Text; using UserManagement Data; using UserManagement Services; using UserManagement Repositories; using UserManagement Middleware; var builder = WebApplication CreateBuilder(args); // Configuration var jwtSettings = builder Configuration GetSection(\"JwtSettings\");\nvar connectionString = builder Configuration GetConnectionString(\"DefaultConnection\");\n// Add services to the container\nbuilder Services AddDbContext<UserDbContext>(options =>\n    options UseSqlServer(connectionString));\n// JWT Authentication\nbuilder Services Configure<JwtSettings>(jwtSettings);\nbuilder Services AddAuthentication(JwtBearerDefaults AuthenticationScheme) AddJwtBearer(options =>\n    {\n        options TokenValidationParameters = new TokenValidationParameters\n        {\n            ValidateIssuerSigningKey = true,\n            IssuerSigningKey = new SymmetricSecurityKey(\n                Encoding ASCII GetBytes(jwtSettings[\"SecretKey\"] )),\n            ValidateIssuer = true,\n            ValidIssuer = jwtSettings[\"Issuer\"],\n            ValidateAudience = true,\n            ValidAudience = jwtSettings[\"Audience\"],\n            ValidateLifetime = true,\n            ClockSkew = TimeSpan Zero\n        };\n    });\nbuilder Services AddAuthorization();\n// Register application services\nbuilder Services AddScoped<IUserRepository, UserRepository>();\nbuilder Services AddScoped<IUserService, UserService>();\n// AutoMapper\nbuilder Services AddAutoMapper(typeof(Program));\n// API Controllers\nbuilder Services AddControllers();\n// API Documentation\nbuilder Services AddEndpointsApiExplorer();\nbuilder Services AddSwaggerGen(c =>\n{\n    c SwaggerDoc(\"v1\", new() { Title = \"User Management API\", Version = \"v1\" });\n    c AddSecurityDefinition(\"Bearer\", new()\n    {\n        Description = \"JWT Authorization header using the Bearer scheme \",\n        Name = \"Authorization\",\n        In = Microsoft OpenApi Models ParameterLocation Header,\n        Type = Microsoft OpenApi Models SecuritySchemeType Http,\n        Scheme = \"bearer\"\n    });\n});\n// CORS\nbuilder Services AddCors(options =>\n{\n    options AddPolicy(\"AllowSpecificOrigins\", policy =>\n    {\n        policy WithOrigins(\"https://localhost:4200\", \"https://myapp com\") AllowAnyHeader() AllowAnyMethod();\n    });\n});\n// Logging\nbuilder Services AddLogging(config =>\n{\n    config AddConsole();\n    config AddDebug();\n});\nvar app = builder Build();\n// Configure the HTTP request pipeline\nif (app Environment IsDevelopment())\n{\n    app UseSwagger();\n    app UseSwaggerUI();\n    app UseDeveloperExceptionPage();\n}\napp UseHttpsRedirection();\napp UseCors(\"AllowSpecificOrigins\");\n// Custom JWT middleware\napp UseMiddleware<JwtAuthenticationMiddleware>();\napp UseAuthentication();\napp UseAuthorization();\napp MapControllers();\napp",
        "startIndex": 17276,
        "preview": "tags: [\"Configuration\", \"Dependency Injection\", \"Startup\", \"Minimal API\"] filename: \"Program cs\" } using Microsoft EntityFrameworkCore; using Microsof..."
      },
      {
        "id": "examples/enhanced-csharp-examples-chunk-8",
        "text": "builder Services AddLogging(config => { config AddConsole(); config AddDebug(); }); var app = builder Build(); // Configure the HTTP request pipeline if (app Environment IsDevelopment()) { app UseSwagger(); app UseSwaggerUI(); app UseDeveloperExceptionPage(); } app UseHttpsRedirection(); app UseCors(\"AllowSpecificOrigins\"); // Custom JWT middleware app UseMiddleware<JwtAuthenticationMiddleware>(); app UseAuthentication(); app UseAuthorization(); app MapControllers(); app Run();\n`\nThis documentation showcases the enhanced Ccode viewing capabilities with:\nRich Metadata: Titles, descriptions, framework versions, categories, difficulty levels\nInteractive Features: Copy, download, GitHub links, NuGet package integration\nVisual Enhancements: Syntax highlighting, line numbers, code folding\nProfessional Styling: VS Code-inspired themes, hover effects, responsive design\nDeveloper Tools: Line highlighting, collapsible sections, tag categorization",
        "startIndex": 19814,
        "preview": "builder Services AddLogging(config => { config AddConsole(); config AddDebug(); }); var app = builder Build(); // Configure the HTTP request pipeline ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "getting-started/aspire-integration",
    "title": ".NET Aspire Integration",
    "category": "Getting Started",
    "url": "/docs/getting-started/aspire-integration",
    "chunks": [
      {
        "id": "getting-started/aspire-integration-chunk-0",
        "text": "NET Aspire Integration\nWhizbang provides first-class support for NET Aspire, Microsoft's opinionated stack for building observable, production-ready cloud-native applications Overview\nWith Aspire integration, you get:\nLocal emulation of Postgres, Kafka, Redis, and other infrastructure\nOne-command setup for end-to-end development environment\nService discovery for microservices communication\nBuilt-in observability with OpenTelemetry dashboards\nResource orchestration with Docker containers\nConfiguration management across services\nQuick Start\nInstall Aspire Workload\n`bash\ndotnet workload install aspire\n`\nAdd Whizbang Aspire Package\n`bash\ndotnet add package Whizbang Aspire\n`\nConfigure AppHost\nCreate an Aspire AppHost project:\n`csharp{\ntitle: \"Aspire AppHost Configuration\"\ndescription: \"Configure Whizbang services with Aspire\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"BEGINNER\"\ntags: [\"Aspire\", \"Configuration\", \"Local Development\"]\nnugetPackages: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nfilename: \"Program cs\"\nusingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting;\nusing Whizbang Aspire;\nvar builder = DistributedApplication CreateBuilder(args);\n// Add Whizbang infrastructure\nvar whizbang = builder AddWhizbang(\"whizbang\") WithPostgres()       // Event store WithKafka()          // Message broker WithRedis()          // Caching WithOpenTelemetry(); // Observability\n// Add your services\nvar ordersService = builder AddProject<Projects OrdersService>(\"orders\") WithReference(whizbang);\nvar inventoryService = builder AddProject<Projects InventoryService>(\"inventory\") WithReference(whizbang);\nvar apiGateway = builder AddProject<Projects ApiGateway>(\"api\") WithReference(ordersService) WithReference(inventoryService);\nbuilder Build() Run();\n`\nConfigure Service\nIn your service's Program cs:\n`csharp{\ntitle: \"Service Configuration with Aspire\"\ndescription: \"Wire up Whizbang in a service using Aspire\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"BEGINNER\"\ntags: [\"Aspire\", \"Configuration\", \"Microservices\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Messaging\", \"Whizbang Aspire\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions Hosting\", \"Whizbang\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions Hosting;\nusing Whizbang;\nusing Whizbang Aspire;\nvar builder = WebApplication CreateBuilder(args);\n// Add Aspire service defaults (observability, health checks, etc )\nbuilder AddServiceDefaults();\n// Add Whizbang with Aspire integration\nbuilder Services AddWhizbangWithAspire(options => {\n    options ScanAssembly(typeof(Program) Assembly);\n    // Infrastructure auto-configured from Aspire\n    options UseAspireEventStore();      // Connects to Aspire-managed Postgres\n    options",
        "startIndex": 0,
        "preview": "NET Aspire Integration\nWhizbang provides first-class support for NET Aspire, Microsoft's opinionated stack for building observable, production-ready c..."
      },
      {
        "id": "getting-started/aspire-integration-chunk-1",
        "text": "Hosting; using Whizbang; using Whizbang Aspire; var builder = WebApplication CreateBuilder(args); // Add Aspire service defaults (observability, health checks, etc ) builder AddServiceDefaults(); // Add Whizbang with Aspire integration builder Services AddWhizbangWithAspire(options => { options ScanAssembly(typeof(Program) Assembly); // Infrastructure auto-configured from Aspire options UseAspireEventStore(); // Connects to Aspire-managed Postgres options UseAspireMessaging();       // Connects to Aspire-managed Kafka\n    options UseAspireProjectionCache(); // Connects to Aspire-managed Redis\n});\nvar app = builder Build();\napp MapDefaultEndpoints();  // Aspire health/metrics endpoints\napp Run();\n`\nRun Everything\n`bash\ndotnet run --project AppHost\n`\nThis single command:\nStarts Postgres container for event store\nStarts Kafka + Zookeeper containers for messaging\nStarts Redis container for caching\nStarts all your microservices\nOpens Aspire dashboard with logs, metrics, and traces\nAspire Dashboard\nNavigate to http://localhost:15000 (or the URL shown in console) to see:\nResources - All running containers and services\nLogs - Structured logs from all services\nTraces - Distributed tracing across services\nMetrics - Real-time metrics (event throughput, projection lag, etc )\nHealth - Service health status\nOut-of-the-Box Infrastructure\nPostgres (Event Store)\nWhizbang automatically configures Postgres for event storage:\n`csharp{\ntitle: \"Aspire Postgres Configuration\"\ndescription: \"Auto-configured Postgres event store\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aspire\", \"Postgres\", \"Event Store\"]\nnugetPackages: [\"Whizbang Aspire\", \"Whizbang Postgres\"]\nusingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting;\nusing Whizbang Aspire;\nvar builder = DistributedApplication CreateBuilder(args);\nvar whizbang = builder AddWhizbang(\"whizbang\") WithPostgres(postgres => {\n        postgres DatabaseName = \"whizbang_events\";\n        postgres WithPgAdmin();  // Optional: PgAdmin UI\n        postgres WithInitialData(\" /seed-data",
        "startIndex": 2854,
        "preview": "Hosting; using Whizbang; using Whizbang Aspire; var builder = WebApplication CreateBuilder(args); // Add Aspire service defaults (observability, healt..."
      },
      {
        "id": "getting-started/aspire-integration-chunk-2",
        "text": "tags: [\"Aspire\", \"Postgres\", \"Event Store\"] nugetPackages: [\"Whizbang Aspire\", \"Whizbang Postgres\"] usingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"] showLineNumbers: true } using Aspire Hosting; using Whizbang Aspire; var builder = DistributedApplication CreateBuilder(args); var whizbang = builder AddWhizbang(\"whizbang\") WithPostgres(postgres => { postgres DatabaseName = \"whizbang_events\"; postgres WithPgAdmin(); // Optional: PgAdmin UI postgres WithInitialData(\" /seed-data sql\");  // Optional: Seed data\n    });\n`\nWhat it does:\nStarts Postgres 16 container\nCreates whizbang_events database\nApplies Whizbang event store schema automatically\nConfigures connection string in all services\nEnables OpenTelemetry instrumentation\nKafka (Message Broker)\nWhizbang sets up Kafka for distributed messaging:\n`csharp{\ntitle: \"Aspire Kafka Configuration\"\ndescription: \"Auto-configured Kafka message broker\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aspire\", \"Kafka\", \"Messaging\"]\nnugetPackages: [\"Whizbang Aspire\", \"Whizbang Kafka\"]\nusingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting;\nusing Whizbang Aspire;\nvar whizbang = builder AddWhizbang(\"whizbang\") WithKafka(kafka => {\n        kafka WithKafkaUI();  // Optional: Kafka UI for topic inspection\n        kafka WithTopics(\n            \"whizbang orders events\",\n            \"whizbang inventory events\",\n            \"whizbang shipping events\"\n        );\n    });\n`\nWhat it does:\nStarts Kafka + Zookeeper containers\nCreates topics for each domain\nConfigures producers and consumers\nEnables distributed tracing for messages\nProvides Kafka UI at http://localhost:8080\nRedis (Caching & Projections)\nOptional Redis for projection caching:\n`csharp{\ntitle: \"Aspire Redis Configuration\"\ndescription: \"Auto-configured Redis for caching\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aspire\", \"Redis\", \"Caching\"]\nnugetPackages: [\"Whizbang Aspire\"]\nusingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting;\nusing Whizbang Aspire;\nvar whizbang = builder AddWhizbang(\"whizbang\") WithRedis(redis => {\n        redis WithRedisInsight();  // Optional: Redis UI\n        redis",
        "startIndex": 4503,
        "preview": "tags: [\"Aspire\", \"Postgres\", \"Event Store\"] nugetPackages: [\"Whizbang Aspire\", \"Whizbang Postgres\"] usingStatements: [\"Aspire Hosting\", \"Whizbang Aspi..."
      },
      {
        "id": "getting-started/aspire-integration-chunk-3",
        "text": "\"Aspire Redis Configuration\" description: \"Auto-configured Redis for caching\" framework: \"NET8\" category: \"Aspire\" difficulty: \"INTERMEDIATE\" tags: [\"Aspire\", \"Redis\", \"Caching\"] nugetPackages: [\"Whizbang Aspire\"] usingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"] showLineNumbers: true } using Aspire Hosting; using Whizbang Aspire; var whizbang = builder AddWhizbang(\"whizbang\") WithRedis(redis => { redis WithRedisInsight(); // Optional: Redis UI redis WithPersistence();   // Optional: Persist to disk\n    });\n`\nWhat it does:\nStarts Redis container\nConfigures projection caching\nEnables distributed locks for projection processing\nProvides Redis Insight UI\nService Discovery\nServices automatically discover each other through Aspire:\n`csharp{\ntitle: \"Service Discovery with Aspire\"\ndescription: \"Services discover each other automatically\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aspire\", \"Service Discovery\", \"Microservices\"]\nnugetPackages: [\"Whizbang Aspire\", \"Whizbang Messaging\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nusing Whizbang Aspire;\n// In API Gateway\nbuilder Services AddWhizbangWithAspire(options => {\n    options UseMessaging(msg => {\n        // Service URLs automatically resolved via Aspire\n        msg UseDomainOwnership(domains => {\n            domains RegisterDomain(\"Orders\", \"http://orders\");        // Aspire resolves to actual URL\n            domains RegisterDomain(\"Inventory\", \"http://inventory\");  // Aspire resolves to actual URL\n        });\n    });\n});\n// Commands automatically routed to correct service\nawait whizbang Send(new PlaceOrder( ));  // Routes to http://orders (resolved by Aspire)\n`\nEnd-to-End Example\nComplete Aspire setup for microservices:\n`csharp{\ntitle: \"Complete Aspire Setup\"\ndescription: \"Full microservices setup with Whizbang and Aspire\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"ADVANCED\"\ntags: [\"Aspire\", \"Microservices\", \"Complete Example\"]\nnugetPackages: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nfilename: \"AppHost/Program cs\"\nusingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting;\nusing Whizbang Aspire;\nvar builder = DistributedApplication CreateBuilder(args);\n// Shared infrastructure\nvar whizbang = builder AddWhizbang(\"whizbang\") WithPostgres(pg => {\n        pg DatabaseName = \"whizbang_events\";\n        pg WithPgAdmin();\n    }) WithKafka(kafka => {\n        kafka WithKafkaUI();\n        kafka WithTopics(\n            \"whizbang orders events\",\n            \"whizbang inventory events\",\n            \"whizbang shipping events\",\n            \"whizbang payments events\"\n        );\n    }) WithRedis(redis => {\n        redis",
        "startIndex": 6281,
        "preview": "\"Aspire Redis Configuration\" description: \"Auto-configured Redis for caching\" framework: \"NET8\" category: \"Aspire\" difficulty: \"INTERMEDIATE\" tags: [\"..."
      },
      {
        "id": "getting-started/aspire-integration-chunk-4",
        "text": "Whizbang Aspire; var builder = DistributedApplication CreateBuilder(args); // Shared infrastructure var whizbang = builder AddWhizbang(\"whizbang\") WithPostgres(pg => { pg DatabaseName = \"whizbang_events\"; pg WithPgAdmin(); }) WithKafka(kafka => { kafka WithKafkaUI(); kafka WithTopics( \"whizbang orders events\", \"whizbang inventory events\", \"whizbang shipping events\", \"whizbang payments events\" ); }) WithRedis(redis => { redis WithRedisInsight();\n    }) WithOpenTelemetry();\n// Microservices (each has own event store partition)\nvar orders = builder AddProject<Projects OrdersService>(\"orders\") WithReference(whizbang) WithReplicas(3);  // Scale out\nvar inventory = builder AddProject<Projects InventoryService>(\"inventory\") WithReference(whizbang) WithReplicas(2);\nvar shipping = builder AddProject<Projects ShippingService>(\"shipping\") WithReference(whizbang);\nvar payments = builder AddProject<Projects PaymentsService>(\"payments\") WithReference(whizbang);\n// Analytics service (subscribes to all events)\nvar analytics = builder AddProject<Projects AnalyticsService>(\"analytics\") WithReference(whizbang);\n// API Gateway\nvar api = builder AddProject<Projects ApiGateway>(\"api\") WithReference(orders) WithReference(inventory) WithReference(shipping) WithReference(payments) WithHttpsEndpoint(port: 5000);\nbuilder Build() Run();\n`\nRunning:\n`bash\ndotnet run --project AppHost\n`\nStarts:\n1 Postgres container (shared event store)\n1 Kafka + Zookeeper (shared message broker)\n1 Redis (shared cache)\n3 replicas of Orders service\n2 replicas of Inventory service\n1 Shipping service\n1 Payments service\n1 Analytics service\n1 API Gateway\nAspire Dashboard with full observability\nConfiguration Management\nAspire manages configuration across all services:\n`json\n{\n  \"Aspire\": {\n    \"Whizbang\": {\n      \"EventStore\": {\n        \"ConnectionString\": \" auto-configured \",\n        \"SchemaName\": \"whizbang\",\n        \"AutoMigrate\": true\n      },\n      \"Messaging\": {\n        \"Kafka\": {\n          \"BootstrapServers\": \" auto-configured \",\n          \"ConsumerGroup\": \"orders-service\"\n        }\n      },\n      \"Projections\": {\n        \"Redis\": {\n          \"ConnectionString\": \" auto-configured \"\n        }\n      }\n    }\n  }\n}\n`\nConnection strings and URLs are automatically injected from Aspire infrastructure Testing with Aspire\nRun integration tests against Aspire-managed infrastructure:\n`csharp{\ntitle: \"Integration Tests with Aspire\"\ndescription: \"Test against real infrastructure via Aspire\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"ADVANCED\"\ntags: [\"Testing\", \"Aspire\", \"Integration Tests\"]\nnugetPackages: [\"Aspire Hosting Testing\", \"Whizbang Aspire\", \"xUnit\"]\nusingStatements: [\"Aspire Hosting Testing\", \"Xunit\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting Testing;\nusing System Threading",
        "startIndex": 8648,
        "preview": "Whizbang Aspire; var builder = DistributedApplication CreateBuilder(args); // Shared infrastructure var whizbang = builder AddWhizbang(\"whizbang\") Wit..."
      },
      {
        "id": "getting-started/aspire-integration-chunk-5",
        "text": "infrastructure: `csharp{ title: \"Integration Tests with Aspire\" description: \"Test against real infrastructure via Aspire\" framework: \"NET8\" category: \"Testing\" difficulty: \"ADVANCED\" tags: [\"Testing\", \"Aspire\", \"Integration Tests\"] nugetPackages: [\"Aspire Hosting Testing\", \"Whizbang Aspire\", \"xUnit\"] usingStatements: [\"Aspire Hosting Testing\", \"Xunit\", \"System Threading Tasks\"] showLineNumbers: true } using Aspire Hosting Testing; using System Threading Tasks;\nusing Xunit;\npublic class OrderServiceTests : IClassFixture<DistributedApplicationFixture> {\n    private readonly DistributedApplicationFixture _fixture;\n    public OrderServiceTests(DistributedApplicationFixture fixture) {\n        _fixture = fixture;\n    }\n    [Fact]\n    public async Task PlaceOrder_PersistsToEventStore() {\n        // Aspire starts Postgres, Kafka, and services\n        await using var app = await _fixture CreateApplicationAsync();\n        await app StartAsync();\n        var ordersService = app GetHttpClient(\"orders\");\n        // Test against real service with real infrastructure\n        var response = await ordersService PostAsJsonAsync(\"/orders\", new {\n            CustomerId = Guid NewGuid(),\n            Items = new[] { new { ProductId = Guid NewGuid(), Quantity = 2, Price = 19 99 } }\n        });\n        response EnsureSuccessStatusCode();\n        // Events are actually persisted to Postgres\n        // Projections are actually updated via Kafka\n    }\n}\n`\nTests run against real infrastructure (Postgres, Kafka, etc ) managed by Aspire Benefits of Aspire Integration\nFor Local Development\nOne command starts everything (databases, message brokers, services)\nNo manual Docker Compose management\nAutomatic configuration (connection strings, URLs)\nLive reload with hot reload support\nObservability dashboard out of the box\nFor Team Onboarding\nNew developers clone repo and run dotnet run --project AppHost\nEverything \"just works\" - no manual setup\nConsistent environment across team members\nSelf-documenting infrastructure (defined in code)\nFor Production\nSame infrastructure configuration in dev and prod\nAspire generates Kubernetes manifests\nEasy transition from local to cloud\nAzure Container Apps / AKS deployment support\nDeployment\nGenerate deployment artifacts from Aspire:\n`bash\nGenerate Kubernetes manifests\ndotnet run --project AppHost -- publish --output-path /deploy/k8s\nGenerate Docker Compose\ndotnet run --project AppHost -- publish --output-path",
        "startIndex": 11096,
        "preview": "infrastructure: `csharp{ title: \"Integration Tests with Aspire\" description: \"Test against real infrastructure via Aspire\" framework: \"NET8\" category:..."
      },
      {
        "id": "getting-started/aspire-integration-chunk-6",
        "text": "configuration in dev and prod Aspire generates Kubernetes manifests Easy transition from local to cloud Azure Container Apps / AKS deployment support Deployment Generate deployment artifacts from Aspire: `bash Generate Kubernetes manifests dotnet run --project AppHost -- publish --output-path /deploy/k8s Generate Docker Compose dotnet run --project AppHost -- publish --output-path /deploy/docker --format docker-compose\nDeploy to Azure Container Apps\nazd init\nazd up\n`\nNext Steps\nDistributed Messaging - Microservices with Kafka\nObservability - OpenTelemetry and monitoring\nTesting - Test with Aspire infrastructure\nResources NET Aspire Documentation\nWhizbang Aspire Samples\nAspire Dashboard Guide",
        "startIndex": 13095,
        "preview": "configuration in dev and prod Aspire generates Kubernetes manifests Easy transition from local to cloud Azure Container Apps / AKS deployment support ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "getting-started/getting-started",
    "title": "Getting Started",
    "category": "Getting Started",
    "url": "/docs/getting-started/getting-started",
    "chunks": [
      {
        "id": "getting-started/getting-started-chunk-0",
        "text": "Getting Started\nThis is a hands-on tutorial that walks you through building your first Whizbang application, starting with a simple in-process mediator and progressively adding event sourcing, projections, and distributed messaging What you'll build:\n✅ Simple CQRS - Command handlers with Whizbang Core (in-process mediator)\n✅ Event Sourcing - Aggregates and event streams with Whizbang EventSourcing\n✅ Read Models - Projections for efficient queries with Whizbang Projections\n`mermaid\ngraph LR\n    A[Simple CQRS] -->|Add Event Store| B[Event Sourcing]\n    B -->|Add Projections| C[Full CQRS/ES]\n    class A layer-command\n    class B layer-event\n    class C layer-read\n`\nCompanion guides:\n📦 Package Structure - Reference guide for all NuGet packages, ORMs, and message broker adapters\n🧠 Philosophy - Understand Whizbang's design principles and architectural decisions\n📚 Core Concepts - Deep dive into commands, events, aggregates, and projections\nPrerequisites NET 8 0 SDK or later\nC12 or later\nYour favorite IDE (Visual Studio, Rider, VS Code)\nInstallation\n> 📦 Want to understand all available packages See the Package Structure Reference for a complete guide to Whizbang's NuGet packages, ORM integrations, and message broker adapters Step 1: Create a New Project\n`bash\ndotnet new webapi -n MyApp\ncd MyApp\n`\nStep 2: Install Whizbang\nFor this tutorial, we'll start with just the core package:\n`bash\ndotnet add package Whizbang Core\n`\nWhat is Whizbang Core The minimal foundation - just an in-process mediator with handler routing Perfect for learning CQRS basics We'll add event sourcing and projections later in this tutorial ---\nYour First Command and Handler\nLet's build a simple order system with CQRS (Command Query Responsibility Segregation)",
        "startIndex": 0,
        "preview": "Getting Started\nThis is a hands-on tutorial that walks you through building your first Whizbang application, starting with a simple in-process mediato..."
      },
      {
        "id": "getting-started/getting-started-chunk-1",
        "text": "Core ` What is Whizbang Core The minimal foundation - just an in-process mediator with handler routing Perfect for learning CQRS basics We'll add event sourcing and projections later in this tutorial --- Your First Command and Handler Let's build a simple order system with CQRS (Command Query Responsibility Segregation) `mermaid\nsequenceDiagram\n    participant API as API Endpoint\n    participant WB as Whizbang Mediator\n    participant H as PlaceOrderHandler\n    API->>WB: Send(PlaceOrder)\n    WB->>H: Handle(PlaceOrder)\n    H->>H: Validate command\n    H->>H: Create order\n    H-->>WB: OrderPlacedResult\n    WB-->>API: OrderPlacedResult\n    Note over API,H: In-memory mediator pattern<br/>No persistence yet\n`\nStep 1: Define a Command\nCreate Commands/PlaceOrder cs:\n`csharp{\ntitle: \"PlaceOrder Command\"\ndescription: \"Command to place a new order\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"CQRS\"]\nfilename: \"Commands/PlaceOrder cs\"\nusingStatements: [\"System\"]\nshowLineNumbers: true\n}\nusing System;\nnamespace MyApp Commands;\npublic record PlaceOrder(\n    Guid CustomerId,\n    List<OrderItem> Items\n);\npublic record OrderItem(\n    Guid ProductId,\n    int Quantity,\n    decimal Price\n);\n`\nStep 2: Create a Handler\nCreate Handlers/PlaceOrderHandler cs:\n`csharp{\ntitle: \"PlaceOrder Handler\"\ndescription: \"Handler that processes PlaceOrder commands\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Handlers\", \"CQRS\", \"Commands\"]\nfilename: \"Handlers/PlaceOrderHandler cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"MyApp Commands\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing MyApp Commands;\nnamespace MyApp Handlers;\npublic class PlaceOrderHandler {\n    public async Task<OrderPlacedResult> Handle(PlaceOrder command) {\n        // Validate\n        if (command Items Count == 0) {\n            throw new InvalidOperationException(\"Order must have at least one item\");\n        }\n        // Create order\n        var orderId = Guid NewGuid();\n        var total = command Items Sum(i => i Price * i Quantity);\n        // TODO: Persist to database\n        // Return result\n        return new OrderPlacedResult(orderId, total);\n    }\n}\npublic record OrderPlacedResult(Guid OrderId, decimal Total);\n`\nStep 3: Configure Whizbang\nUpdate Program cs:\n`csharp{\ntitle: \"Whizbang Configuration\"\ndescription: \"Configure Whizbang in ASP",
        "startIndex": 1763,
        "preview": "Core ` What is Whizbang Core The minimal foundation - just an in-process mediator with handler routing Perfect for learning CQRS basics We'll add even..."
      },
      {
        "id": "getting-started/getting-started-chunk-2",
        "text": "NewGuid(); var total = command Items Sum(i => i Price * i Quantity); // TODO: Persist to database // Return result return new OrderPlacedResult(orderId, total); } } public record OrderPlacedResult(Guid OrderId, decimal Total); ` Step 3: Configure Whizbang Update Program cs: `csharp{ title: \"Whizbang Configuration\" description: \"Configure Whizbang in ASP NET Core\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Configuration\", \"Setup\", \"ASP NET Core\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nvar builder = WebApplication CreateBuilder(args);\n// Add Whizbang\nbuilder Services AddWhizbang(options => {\n    // Scan this assembly for handlers\n    options ScanAssembly(typeof(Program) Assembly);\n});\nvar app = builder Build();\napp MapPost(\"/orders\", async (PlaceOrder command, IWhizbang whizbang) => {\n    var result = await whizbang Send(command);\n    return Results Ok(result);\n});\napp Run();\n`\nStep 4: Run the Application\n`bash\ndotnet run\n`\nTest with curl:\n`bash\ncurl -X POST http://localhost:5000/orders \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"customerId\": \"123e4567-e89b-12d3-a456-426614174000\",\n    \"items\": [\n      { \"productId\": \"prod-1\", \"quantity\": 2, \"price\": 19 99 }\n    ]\n  }'\n`\nCongratulations You've created your first Whizbang command handler Right now it's just an in-process mediator, but we'll add event sourcing next ---\nAdding Event Sourcing\nLet's upgrade to event sourcing so we have a complete audit trail of all orders `mermaid\nsequenceDiagram\n    participant API as API Endpoint\n    participant H as Handler\n    participant A as Order Aggregate\n    participant R as Repository\n    participant ES as Event Store\n    API->>H: Handle(PlaceOrder)\n    H->>A: new Order(customerId, items)\n    A->>A: Validate business rules\n    A->>A: Apply(OrderPlaced)\n    Note over A: Event updates<br/>aggregate state\n    H->>R: SaveAsync(order)\n    R->>ES: Append events to stream\n    ES-->>R: Saved\n    R-->>H: Success\n    H-->>API: OrderPlacedResult\n    Note over API,ES: Events stored as immutable log<br/>Complete audit trail\n`\n> 📦 Learn more: See Whizbang EventSourcing in the Package Structure guide for ORM options, database support, and advanced configuration",
        "startIndex": 3874,
        "preview": "NewGuid(); var total = command Items Sum(i => i Price * i Quantity); // TODO: Persist to database // Return result return new OrderPlacedResult(orderI..."
      },
      {
        "id": "getting-started/getting-started-chunk-3",
        "text": "Note over A: Event updates<br/>aggregate state H->>R: SaveAsync(order) R->>ES: Append events to stream ES-->>R: Saved R-->>H: Success H-->>API: OrderPlacedResult Note over API,ES: Events stored as immutable log<br/>Complete audit trail ` > 📦 Learn more: See Whizbang EventSourcing in the Package Structure guide for ORM options, database support, and advanced configuration Step 1: Install Event Sourcing Package\n`bash\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang Postgres  Or Whizbang SqlServer, Whizbang EntityFramework, etc `\nStep 2: Define Events\nCreate Events/OrderEvents cs:\n`csharp{\ntitle: \"Order Domain Events\"\ndescription: \"Events representing order lifecycle state changes\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"BEGINNER\"\ntags: [\"Events\", \"Event Sourcing\", \"Domain Events\"]\nfilename: \"Events/OrderEvents cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nnamespace MyApp Events;\n[OwnedBy(\"Orders\")]  // This event comes from the Orders domain\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset PlacedAt,\n    List<OrderItem> Items,\n    decimal Total\n);\n[OwnedBy(\"Orders\")]\npublic record OrderShipped(\n    Guid OrderId,\n    DateTimeOffset ShippedAt,\n    string TrackingNumber\n);\n`\nStep 3: Create an Aggregate\nCreate Domain/Order cs:\n`csharp{\ntitle: \"Order Aggregate\"\ndescription: \"Event-sourced aggregate for orders\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aggregates\", \"Event Sourcing\", \"Domain-Driven Design\"]\nfilename: \"Domain/Order cs\"\nusingStatements: [\"System\", \"Whizbang\", \"MyApp Events\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing MyApp Events;\nnamespace MyApp Domain;\npublic class Order : Aggregate {\n    public Guid Id { get; private set; }\n    public Guid CustomerId { get; private set; }\n    public OrderStatus Status { get; private set; }\n    public List<OrderItem> Items { get; private set; } = new();\n    public decimal Total { get; private set; }\n    // Constructor for new orders\n    public Order(Guid customerId, List<OrderItem> items) {\n        if (items Count == 0) {\n            throw new InvalidOperationException(\"Order must have items\");\n        }\n        var total = items Sum(i => i Price * i Quantity);\n        Apply(new OrderPlaced(\n            Guid NewGuid(),\n            customerId,\n            DateTimeOffset",
        "startIndex": 5838,
        "preview": "Note over A: Event updates<br/>aggregate state H->>R: SaveAsync(order) R->>ES: Append events to stream ES-->>R: Saved R-->>H: Success H-->>API: OrderP..."
      },
      {
        "id": "getting-started/getting-started-chunk-4",
        "text": "new(); public decimal Total { get; private set; } // Constructor for new orders public Order(Guid customerId, List<OrderItem> items) { if (items Count == 0) { throw new InvalidOperationException(\"Order must have items\"); } var total = items Sum(i => i Price * i Quantity); Apply(new OrderPlaced( Guid NewGuid(), customerId, DateTimeOffset UtcNow,\n            items,\n            total\n        ));\n    }\n    // Event handler - updates state when event is applied\n    private void When(OrderPlaced @event) {\n        Id = @event OrderId;\n        CustomerId = @event CustomerId;\n        Status = OrderStatus Placed;\n        Items = @event Items;\n        Total = @event Total;\n    }\n    // Command method - ship the order\n    public void Ship(string trackingNumber) {\n        if (Status = OrderStatus Placed) {\n            throw new InvalidOperationException(\"Only placed orders can be shipped\");\n        }\n        Apply(new OrderShipped(Id, DateTimeOffset UtcNow, trackingNumber));\n    }\n    // Event handler\n    private void When(OrderShipped @event) {\n        Status = OrderStatus Shipped;\n    }\n}\npublic enum OrderStatus {\n    Placed,\n    Shipped,\n    Delivered,\n    Cancelled\n}\n`\nStep 4: Update Handler to Use Aggregate\nUpdate Handlers/PlaceOrderHandler cs:\n`csharp{\ntitle: \"Updated PlaceOrder Handler\"\ndescription: \"Handler using event-sourced aggregate\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Handlers\", \"Aggregates\", \"Event Sourcing\"]\nfilename: \"Handlers/PlaceOrderHandler cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\", \"MyApp Commands\", \"MyApp Domain\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\nusing MyApp Commands;\nusing MyApp Domain;\nnamespace MyApp Handlers;\npublic class PlaceOrderHandler {\n    private readonly IRepository<Order> _repository;\n    public PlaceOrderHandler(IRepository<Order> repository) {\n        _repository = repository;\n    }\n    public async Task<OrderPlacedResult> Handle(PlaceOrder command) {\n        // Create aggregate (generates OrderPlaced event)\n        var order = new Order(command CustomerId, command Items);\n        // Save aggregate (events appended to event store)\n        await _repository SaveAsync(order);\n        return new OrderPlacedResult(order Id, order Total);\n    }\n}\n`\nStep 5: Configure Event Sourcing\nUpdate Program",
        "startIndex": 7896,
        "preview": "new(); public decimal Total { get; private set; } // Constructor for new orders public Order(Guid customerId, List<OrderItem> items) { if (items Count..."
      },
      {
        "id": "getting-started/getting-started-chunk-5",
        "text": "= repository; } public async Task<OrderPlacedResult> Handle(PlaceOrder command) { // Create aggregate (generates OrderPlaced event) var order = new Order(command CustomerId, command Items); // Save aggregate (events appended to event store) await _repository SaveAsync(order); return new OrderPlacedResult(order Id, order Total); } } ` Step 5: Configure Event Sourcing Update Program cs:\n`csharp{\ntitle: \"Event Sourcing Configuration\"\ndescription: \"Configure Whizbang with event sourcing and Postgres\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Configuration\", \"Event Sourcing\", \"Postgres\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbang(options => {\n    options ScanAssembly(typeof(Program) Assembly);\n    // Enable event sourcing\n    options UseEventSourcing(es => {\n        es UsePostgres(builder Configuration GetConnectionString(\"EventStore\"));\n    });\n});\nvar app = builder Build();\napp MapPost(\"/orders\", async (PlaceOrder command, IWhizbang whizbang) => {\n    var result = await whizbang Send(command);\n    return Results Ok(result);\n});\napp Run();\n`\nAdd connection string to appsettings json:\n`json\n{\n  \"ConnectionStrings\": {\n    \"EventStore\": \"Host=localhost;Database=myapp;Username=user;Password=pass\"\n  }\n}\n`\nNow you have full event sourcing Every order is stored as a stream of events, providing a complete audit trail ---\nAdding Projections (Read Models)\nLet's add a projection to efficiently query order history `mermaid\ngraph TB\n    subgraph \"Write Side (Commands)\"\n        CMD[PlaceOrder Command]\n        AGG[Order Aggregate]\n        ES[Event Store]\n    end\n    subgraph \"Event Bus\"\n        EVT[OrderPlaced Event]\n    end\n    subgraph \"Read Side (Queries)\"\n        PROJ[OrderHistoryProjection]\n        RM[Read Model DB]\n        QUERY[Query: Get Orders]\n    end\n    CMD -->|Creates| AGG\n    AGG -->|Stores events| ES\n    ES -->|Publishes| EVT\n    EVT -->|Subscribes| PROJ\n    PROJ -->|Updates| RM\n    QUERY -->|Reads from| RM\n    class CMD layer-command\n    class AGG layer-core\n    class ES layer-event\n    class PROJ layer-read\n    class RM layer-read\n`\n> 📦 Learn more: See Whizbang Projections in the Package Structure guide for advanced projection patterns, subscription options, and database integration Step 1: Install Projections Package\n`bash\ndotnet add package Whizbang Projections\n`\nStep 2: Define Read Model\nCreate Projections/OrderHistoryItem",
        "startIndex": 9934,
        "preview": "= repository; } public async Task<OrderPlacedResult> Handle(PlaceOrder command) { // Create aggregate (generates OrderPlaced event) var order = new Or..."
      },
      {
        "id": "getting-started/getting-started-chunk-6",
        "text": "class ES layer-event class PROJ layer-read class RM layer-read ` > 📦 Learn more: See Whizbang Projections in the Package Structure guide for advanced projection patterns, subscription options, and database integration Step 1: Install Projections Package `bash dotnet add package Whizbang Projections ` Step 2: Define Read Model Create Projections/OrderHistoryItem cs:\n`csharp{\ntitle: \"Order History Read Model\"\ndescription: \"Denormalized read model for querying order history\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"BEGINNER\"\ntags: [\"Projections\", \"Read Models\", \"CQRS\"]\nfilename: \"Projections/OrderHistoryItem cs\"\nusingStatements: [\"System\"]\nshowLineNumbers: true\n}\nusing System;\nnamespace MyApp Projections;\npublic class OrderHistoryItem {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    public DateTimeOffset PlacedAt { get; set; }\n    public DateTimeOffset ShippedAt { get; set; }\n    public decimal Total { get; set; }\n    public string Status { get; set; }\n}\n`\nStep 3: Create Projection Handler\nCreate Projections/OrderHistoryProjection cs:\n`csharp{\ntitle: \"Order History Projection\"\ndescription: \"Projection that builds order history from events\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Event Handlers\", \"CQRS\"]\nfilename: \"Projections/OrderHistoryProjection cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\", \"MyApp Events\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\nusing MyApp Events;\nnamespace MyApp Projections;\npublic class OrderHistoryProjection {\n    private readonly IProjectionStore<OrderHistoryItem> _store;\n    public OrderHistoryProjection(IProjectionStore<OrderHistoryItem> store) {\n        _store = store;\n    }\n    public async Task Handle(OrderPlaced @event) {\n        await _store UpsertAsync(@event OrderId, new OrderHistoryItem {\n            OrderId = @event OrderId,\n            CustomerId = @event CustomerId,\n            PlacedAt = @event PlacedAt,\n            Total = @event Total,\n            Status = \"Placed\"\n        });\n    }\n    public async Task Handle(OrderShipped @event) {\n        await _store UpdateAsync(@event OrderId, item => {\n            item ShippedAt = @event ShippedAt;\n            item Status = \"Shipped\";\n        });\n    }\n}\n`\nStep 4: Configure Projection\nUpdate Program cs:\n`csharp{\ntitle: \"Projection Configuration\"\ndescription: \"Configure projections in Whizbang\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Configuration\", \"Projections\"]\nfilename: \"Program",
        "startIndex": 12132,
        "preview": "class ES layer-event class PROJ layer-read class RM layer-read ` > 📦 Learn more: See Whizbang Projections in the Package Structure guide for advanced..."
      },
      {
        "id": "getting-started/getting-started-chunk-7",
        "text": "Handle(OrderShipped @event) { await _store UpdateAsync(@event OrderId, item => { item ShippedAt = @event ShippedAt; item Status = \"Shipped\"; }); } } ` Step 4: Configure Projection Update Program cs: `csharp{ title: \"Projection Configuration\" description: \"Configure projections in Whizbang\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Configuration\", \"Projections\"] filename: \"Program cs\"\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"MyApp Events\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nbuilder Services AddWhizbang(options => {\n    options ScanAssembly(typeof(Program) Assembly);\n    options UseEventSourcing(es => es UsePostgres(connectionString));\n    // Add projections\n    options UseProjections(proj => {\n        proj RegisterProjection<OrderHistoryProjection>(p => {\n            p Subscribe<OrderPlaced>();\n            p Subscribe<OrderShipped>();\n        });\n    });\n});\n`\nStep 5: Query the Projection\nAdd query endpoint:\n`csharp{\ntitle: \"Query Order History\"\ndescription: \"Query endpoint for order history projection\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"BEGINNER\"\ntags: [\"Queries\", \"Projections\", \"API\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang\", \"Microsoft AspNetCore Builder\", \"System\"]\nshowLineNumbers: true\n}\napp MapGet(\"/customers/{customerId}/orders\", async (\n    Guid customerId,\n    IProjectionStore<OrderHistoryItem> store\n) => {\n    var orders = await store QueryAsync(o => o CustomerId == customerId);\n    return Results Ok(orders);\n});\n`\nNow you have CQRS Commands go to aggregates (write side), queries go to projections (read side) ---\nNext Steps\nYou've built a complete CQRS/Event Sourcing application with Whizbang Here's what to explore next:\nPhilosophy - Understand Whizbang's design principles and architectural philosophy\nCore Concepts - Deep dive into events, commands, aggregates, and projections\nPackage Structure - Learn about all available packages\nTesting - Test your event-sourced applications\nDistributed Messaging - Scale to microservices with message brokers\nSagas - Coordinate long-running processes across aggregates\nObservability - Monitor your event-sourced systems",
        "startIndex": 4021,
        "preview": "Handle(OrderShipped @event) { await _store UpdateAsync(@event OrderId, item => { item ShippedAt = @event ShippedAt; item Status = \"Shipped\"; }); } } `..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "getting-started/package-structure",
    "title": "Package Structure",
    "category": "Getting Started",
    "url": "/docs/getting-started/package-structure",
    "chunks": [
      {
        "id": "getting-started/package-structure-chunk-0",
        "text": "Package Structure\nThis is a reference guide to all available Whizbang NuGet packages, their capabilities, and how to choose the right ones for your application > 💡 New to Whizbang Start with the Getting Started Tutorial for hands-on, step-by-step learning Come back here when you need detailed package information Overview\nWhizbang is distributed as a suite of NuGet packages, allowing you to install only what you need This keeps your application lean and supports AOT compilation Package Philosophy:\nStart minimal - Begin with Whizbang Core (just the mediator)\nAdd as needed - Install event sourcing, projections, messaging only when required\nChoose your stack - Pick your preferred ORM (EF Core, Dapper, NHibernate) and message broker\nStay lean - No forced dependencies, excellent for AOT compilation\n`mermaid\n%%{init: {'flowchart': {'nodeSpacing': 800}, 'themeVariables': {'fontSize': '200px'}}}%%\ngraph LR\n    subgraph ORM[\"ORM Integrations\"]\n        WhizEF[Whizbang EntityFramework<br/>EF Core Integration]\n        WhizDapper[Whizbang Dapper<br/>Dapper Integration]\n        WhizNH[Whizbang NHibernate<br/>NHibernate Integration]\n    end\n    subgraph Core[\"Core Packages\"]\n        WhizCore[Whizbang Core<br/>Mediator, Handlers, Pipeline]\n        WhizES[Whizbang EventSourcing<br/>Event Store, Aggregates]\n        WhizProj[Whizbang Projections<br/>Read Models, Subscriptions]\n        WhizMsg[Whizbang Messaging<br/>Distributed Messaging, Outbox/Inbox]\n    end\n    subgraph Messaging[\"Message Broker Adapters\"]\n        WhizKafka[Whizbang Kafka]\n        WhizRabbit[Whizbang RabbitMQ]\n        WhizASB[Whizbang AzureServiceBus]\n        WhizSQS[Whizbang AWSSQS]\n    end\n    subgraph Observability[\"Observability\"]\n        WhizOTel[Whizbang OpenTelemetry<br/>Tracing, Metrics]\n        WhizDash[Whizbang Dashboard<br/>Monitoring UI]\n    end\n    subgraph Dev[\"Developer Tools\"]\n        WhizAnalyzers[Whizbang Analyzers<br/>Roslyn Analyzers, Purity Checks]\n        WhizTesting[Whizbang Testing<br/>In-Memory Doubles, Test Helpers]\n    end\n    ORM - ->|Require| WhizES\n    Messaging -",
        "startIndex": 0,
        "preview": "Package Structure\nThis is a reference guide to all available Whizbang NuGet packages, their capabilities, and how to choose the right ones for your ap..."
      },
      {
        "id": "getting-started/package-structure-chunk-1",
        "text": "Projections<br/>Read Models, Subscriptions] WhizMsg[Whizbang Messaging<br/>Distributed Messaging, Outbox/Inbox] end subgraph Messaging[\"Message Broker Adapters\"] WhizKafka[Whizbang Kafka] WhizRabbit[Whizbang RabbitMQ] WhizASB[Whizbang AzureServiceBus] WhizSQS[Whizbang AWSSQS] end subgraph Observability[\"Observability\"] WhizOTel[Whizbang OpenTelemetry<br/>Tracing, Metrics] WhizDash[Whizbang Dashboard<br/>Monitoring UI] end subgraph Dev[\"Developer Tools\"] WhizAnalyzers[Whizbang Analyzers<br/>Roslyn Analyzers, Purity Checks] WhizTesting[Whizbang Testing<br/>In-Memory Doubles, Test Helpers] end ORM - ->|Require| WhizES Messaging - ->|Require| WhizMsg\n    WhizES --> WhizCore\n    WhizProj --> WhizCore\n    WhizProj --> WhizES\n    WhizMsg --> WhizCore\n`\nFunctional Area Color Key\nThe diagram uses color-coded edges to indicate functional areas:\n🟢 Green (Core) - Core business logic and domain functionality\n🔴 Red (Event) - Event sourcing, data persistence, and event handling\n🔵 Blue (Read) - Read models, projections, and query operations\n🟡 Yellow (Command) - Commands, write operations, and distributed messaging\n🔷 Teal (Observability) - Telemetry, metrics, tracing, and monitoring\n🟣 Purple (Infrastructure) - Developer tools, analyzers, and testing utilities\nCore Packages\nWhizbang Core\nThe minimal foundation for all Whizbang applications `bash\ndotnet add package Whizbang Core\n`\nIncludes:\nMessage routing (commands, events, queries)\nIn-memory mediator\nHandler discovery and execution\nBasic pipeline (validation, authorization hooks)\nNo persistence, no external messaging\nUse when:\nBuilding a simple CQRS application\nYou don't need event sourcing or projections\nIn-process messaging is sufficient\nLearning Whizbang\nExample:\n`csharp{\ntitle: \"Simple Mediator Setup - Complete Program cs\"\ndescription: \"Complete example showing Whizbang Core as an in-process mediator with handler discovery\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Mediator\", \"CQRS\", \"Setup\", \"Program cs\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\"]\nshowLineNumbers: true\ncollapsedLines: [1-3, 25-35]\n}\n// Stage 1: Imports\nusing Microsoft Extensions DependencyInjection;\nusing Microsoft Extensions Hosting;\nusing Whizbang;\n// Stage 2: Host builder setup\nvar builder = Host CreateApplicationBuilder(args);\n// Stage 3: Register Whizbang mediator (in-memory only)\nbuilder Services",
        "startIndex": 2086,
        "preview": "Projections<br/>Read Models, Subscriptions] WhizMsg[Whizbang Messaging<br/>Distributed Messaging, Outbox/Inbox] end subgraph Messaging[\"Message Broker..."
      },
      {
        "id": "getting-started/package-structure-chunk-2",
        "text": "Core\"] usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\"] showLineNumbers: true collapsedLines: [1-3, 25-35] } // Stage 1: Imports using Microsoft Extensions DependencyInjection; using Microsoft Extensions Hosting; using Whizbang; // Stage 2: Host builder setup var builder = Host CreateApplicationBuilder(args); // Stage 3: Register Whizbang mediator (in-memory only) builder Services AddWhizbang(options => {\n    // OPTION A: Source generator approach (recommended)\n    // Handlers decorated with [WhizbangHandler] are auto-discovered at compile time\n    options RegisterGeneratedHandlers();\n    // OPTION B: Explicit registration\n    // Manually register each handler for fine-grained control\n    // options RegisterHandler<PlaceOrder, PlaceOrderHandler>();\n    // options RegisterHandler<CancelOrder, CancelOrderHandler>();\n});\n// Stage 4: Build and run\nvar app = builder Build();\nawait app RunAsync();\n// Stage 5: Example handler decorated with [WhizbangHandler]\n[WhizbangHandler]  // Source generator picks this up\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderResult> {\n    public async Task<OrderResult> Handle(PlaceOrder command, CancellationToken ct) {\n        // Business logic here\n        return new OrderResult(command OrderId);\n    }\n}\n`\nHandler Discovery Approaches:\nWhizbang is 100% AOT-compatible and supports two ways to register handlers:\nSource Generator (Recommended): Decorate handlers with [WhizbangHandler] attribute At compile time, a source generator discovers all marked handlers and generates registration code Call options RegisterGeneratedHandlers() to use them `csharp\n   // Handler definition\n   [WhizbangHandler]\n   public class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderResult> { }\n   // Registration\n   options RegisterGeneratedHandlers();\n   `\n   Benefits:\nZero runtime reflection\nAOT-safe\nAutomatic discovery at compile time\nNo manual registration needed\nExplicit Registration: Manually register each handler Gives you full control and is AOT-safe `csharp\n   options RegisterHandler<PlaceOrder, PlaceOrderHandler>();\n   options RegisterHandler<CancelOrder, CancelOrderHandler>();\n   `\n   Benefits:\nFine-grained control over registration\nNo attributes in domain code\nExplicit and obvious\nAOT-safe\nNote: The [WhizbangHandler] attribute can be placed on:\nThe handler class itself\nA base class the handler inherits from\nAn interface the handler implements\nThe source generator will discover handlers through any of these paths",
        "startIndex": 3938,
        "preview": "Core\"] usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\"] showLineNumbers: true collapsedLines:..."
      },
      {
        "id": "getting-started/package-structure-chunk-3",
        "text": "` Benefits: Fine-grained control over registration No attributes in domain code Explicit and obvious AOT-safe Note: The [WhizbangHandler] attribute can be placed on: The handler class itself A base class the handler inherits from An interface the handler implements The source generator will discover handlers through any of these paths Attribute Naming: All Whizbang attributes use the Whizbang prefix for consistency and to avoid naming collisions ([WhizbangHandler], [WhizbangProjection], [WhizbangSubscribe]) ---\nWhizbang EventSourcing\nEvent sourcing and aggregate support `bash\ndotnet add package Whizbang EventSourcing\n`\nIncludes:\nEvent store abstraction\nAggregate base classes\nEvent stream management\nOptimistic concurrency\nEvent versioning\nRequires a persistence driver (see below)\nUse when:\nYou need event sourcing\nBuilding event-sourced aggregates\nYou want complete audit trails\nExample:\n`csharp{\ntitle: \"Event Sourcing Setup - Complete Program cs\"\ndescription: \"Complete example adding event sourcing to your application\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Event Sourcing\", \"Aggregates\", \"Setup\", \"Program cs\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\"]\nshowLineNumbers: true\ncollapsedLines: [1-3, 7-8]\n}\n// Stage 1: Imports\nusing Microsoft Extensions DependencyInjection;\nusing Microsoft Extensions Hosting;\nusing Whizbang;\n// Stage 2: Host builder setup\nvar builder = Host CreateApplicationBuilder(args);\n// Stage 3: Register Whizbang with event sourcing\nbuilder Services AddWhizbang(options => {\n    // Register handlers (using source generator)\n    options RegisterGeneratedHandlers();\n    // Stage 4: Enable event sourcing\n    options UseEventSourcing(es => {\n        // For production, use an ORM integration (see ORM Integrations section)\n        // es UseEntityFramework(ef => ef UseNpgsql(connectionString));\n        // es UseDapper(d => d UseNpgsql(connectionString));\n        // For development/testing, use in-memory store\n        es UseInMemoryStore();\n    });\n});\n// Stage 5: Build and run\nvar app = builder Build();\nawait app RunAsync();\n`\n---\nWhizbang Projections\nRead-side projections and CQRS queries `bash\ndotnet add package Whizbang",
        "startIndex": 6060,
        "preview": "` Benefits: Fine-grained control over registration No attributes in domain code Explicit and obvious AOT-safe Note: The [WhizbangHandler] attribute ca..."
      },
      {
        "id": "getting-started/package-structure-chunk-4",
        "text": "// es UseEntityFramework(ef => ef UseNpgsql(connectionString)); // es UseDapper(d => d UseNpgsql(connectionString)); // For development/testing, use in-memory store es UseInMemoryStore(); }); }); // Stage 5: Build and run var app = builder Build(); await app RunAsync(); ` --- Whizbang Projections Read-side projections and CQRS queries `bash dotnet add package Whizbang Projections\n`\nIncludes:\nProjection engine\nEvent subscription management\nCheckpoint tracking\nBackfilling from event history\nParallel processing across partitions\nUse when:\nBuilding read models from events\nImplementing CQRS\nYou need denormalized views for queries\nExample:\n`csharp{\ntitle: \"Projections Setup - Complete Program cs\"\ndescription: \"Complete example adding projection support with attribute-based registration\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"CQRS\", \"Read Models\", \"Program cs\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Projections\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\", \"System Threading Tasks\", \"System Threading\"]\nshowLineNumbers: true\ncollapsedLines: [1-3, 7-8, 28-30]\n}\n// Stage 1: Imports\nusing Microsoft Extensions DependencyInjection;\nusing Microsoft Extensions Hosting;\nusing Whizbang;\n// Stage 2: Host builder setup\nvar builder = Host CreateApplicationBuilder(args);\n// Stage 3: Register Whizbang with projections\nbuilder Services AddWhizbang(options => {\n    options RegisterGeneratedHandlers();\n    options UseEventSourcing(es => es UseInMemoryStore());\n    // Stage 4: Enable projections\n    options UseProjections(proj => {\n        // OPTION A: Attribute-based registration (recommended)\n        // Projections decorated with [Projection] are auto-discovered\n        proj RegisterGeneratedProjections();\n        // OPTION B: Manual registration\n        // proj RegisterProjection<OrderHistoryProjection>();\n        // proj RegisterProjection<CustomerSummaryProjection>();\n    });\n});\n// Stage 5: Build and run\nvar app = builder Build();\nawait app RunAsync();\n// Stage 6: Example projection with attribute-based event subscriptions\n[WhizbangProjection]  // Source generator picks this up\npublic class OrderHistoryProjection {\n    private readonly List<OrderSummary> _orders = new();\n    // Subscribe to events using [WhizbangSubscribe] attribute on method parameter\n    public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) {\n        _orders Add(new OrderSummary(\n            @event OrderId,\n            @event CustomerId,\n            @event Total,\n            \"Placed\"\n        ));\n        return Task",
        "startIndex": 8057,
        "preview": "// es UseEntityFramework(ef => ef UseNpgsql(connectionString)); // es UseDapper(d => d UseNpgsql(connectionString)); // For development/testing, use i..."
      },
      {
        "id": "getting-started/package-structure-chunk-5",
        "text": "event subscriptions [WhizbangProjection] // Source generator picks this up public class OrderHistoryProjection { private readonly List<OrderSummary> _orders = new(); // Subscribe to events using [WhizbangSubscribe] attribute on method parameter public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) { _orders Add(new OrderSummary( @event OrderId, @event CustomerId, @event Total, \"Placed\" )); return Task CompletedTask;\n    }\n    public Task Handle([WhizbangSubscribe] OrderShipped @event, CancellationToken ct) {\n        var order = _orders First(o => o OrderId == @event OrderId);\n        order Status = \"Shipped\";\n        return Task CompletedTask;\n    }\n    // Query method (not a subscription)\n    public IEnumerable<OrderSummary> GetOrders() => _orders;\n}\npublic record OrderSummary(Guid OrderId, Guid CustomerId, decimal Total, string Status) {\n    public string Status { get; set; } = Status;\n}\n`\nProjection Registration Approaches:\nWhizbang supports two ways to register projections:\nAttribute-Based (Recommended for AOT): Decorate projection classes with [WhizbangProjection] and mark event handler parameters with [WhizbangSubscribe] `csharp\n   [WhizbangProjection]  // Can be on class, base class, or interface\n   public class OrderHistoryProjection {\n       public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) {\n           // Handle event\n       }\n   }\n   // Registration\n   proj RegisterGeneratedProjections();\n   `\nManual Registration: Explicitly register each projection `csharp\n   proj RegisterProjection<OrderHistoryProjection>();\n   proj",
        "startIndex": 10366,
        "preview": "event subscriptions [WhizbangProjection] // Source generator picks this up public class OrderHistoryProjection { private readonly List<OrderSummary> _..."
      },
      {
        "id": "getting-started/package-structure-chunk-6",
        "text": "and mark event handler parameters with [WhizbangSubscribe] `csharp [WhizbangProjection] // Can be on class, base class, or interface public class OrderHistoryProjection { public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) { // Handle event } } // Registration proj RegisterGeneratedProjections(); ` Manual Registration: Explicitly register each projection `csharp proj RegisterProjection<OrderHistoryProjection>(); proj RegisterProjection<CustomerSummaryProjection>();\n   `\nEvent Subscription with [WhizbangSubscribe] Attribute:\nPlace [WhizbangSubscribe] directly on the method parameter representing the event\nOnly one parameter per method can have [WhizbangSubscribe]\nAdditional parameters (like CancellationToken, injected services, EventContext, ProjectionContext) are allowed\nMethod names are flexible: Use Handle, On, When, or any descriptive name you prefer\nAuto-registration: The source generator automatically wires subscriptions to service configuration\nThe source generator validates subscription rules at compile time\nSupports polymorphism: Subscribe to base classes or interfaces to handle multiple event types\nFor complete projection documentation, see:\nProjection Subscriptions - Event subscription patterns, polymorphism, generics, flexible method naming\nProjection Contexts - EventContext and ProjectionContext injection for metadata and CRUD operations\nProjection Purity - Maintaining pure, deterministic projections with compile-time enforcement\nProjection Return Values - Using return values for observability and metrics\nFor command handling documentation, see:\nCommand Handling - Business logic, CommandContext, event emission, sagas, and workflows\nWhizbang Messaging\nDistributed messaging and outbox/inbox patterns `bash\ndotnet add package Whizbang Messaging\n`\nIncludes:\nMessage broker abstraction\nOutbox/Inbox pattern for exactly-once delivery\nDomain ownership routing\nSaga coordination\nRequires a message broker adapter (see below)\nUse when:\nBuilding microservices\nYou need distributed messaging\nCommands/events cross service boundaries\nExample:\n`csharp{\ntitle: \"Distributed Messaging Setup - Complete Program cs\"\ndescription: \"Complete example configuring Whizbang for microservices with message broker\"\nframework: \"NET8\"\ncategory: \"Distributed Systems\"\ndifficulty: \"ADVANCED\"\ntags: [\"Messaging\", \"Microservices\", \"Distributed Systems\", \"Program cs\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Messaging\", \"Whizbang Kafka\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions",
        "startIndex": 11555,
        "preview": "and mark event handler parameters with [WhizbangSubscribe] `csharp [WhizbangProjection] // Can be on class, base class, or interface public class Orde..."
      },
      {
        "id": "getting-started/package-structure-chunk-7",
        "text": "cross service boundaries Example: `csharp{ title: \"Distributed Messaging Setup - Complete Program cs\" description: \"Complete example configuring Whizbang for microservices with message broker\" framework: \"NET8\" category: \"Distributed Systems\" difficulty: \"ADVANCED\" tags: [\"Messaging\", \"Microservices\", \"Distributed Systems\", \"Program cs\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Messaging\", \"Whizbang Kafka\"] usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\"]\nshowLineNumbers: true\ncollapsedLines: [1-3, 7-8, 36-38]\n}\n// Stage 1: Imports\nusing Microsoft Extensions DependencyInjection;\nusing Microsoft Extensions Hosting;\nusing Whizbang;\n// Stage 2: Host builder setup\nvar builder = Host CreateApplicationBuilder(args);\n// Stage 3: Register Whizbang with distributed messaging\nbuilder Services AddWhizbang(options => {\n    options RegisterGeneratedHandlers();\n    options UseEventSourcing(es => es UseInMemoryStore());\n    // Stage 4: Enable distributed messaging\n    options UseMessaging(msg => {\n        // Register logical domain ownership (no URLs - services communicate via broker)\n        msg UseDomainOwnership(domains => {\n            // Declare which domains THIS service owns\n            domains RegisterDomain(\"Orders\");    // This service owns Orders domain\n            domains RegisterDomain(\"Payments\");  // This service owns Payments domain\n            // Other domains owned by other services:\n            // - \"Inventory\" owned by Inventory service\n            // - \"Shipping\" owned by Shipping service\n        });\n        // Configure message broker (how services actually communicate)\n        msg UseKafka(kafka => {\n            kafka BootstrapServers = \"localhost:9092\";\n            // Topic routing based on domain ownership\n            kafka CommandTopicPattern = \"commands {domain}\";  // commands Orders, commands Inventory\n            kafka EventTopicPattern = \"events {domain}\";      // events Orders, events Payments\n        });\n        // Enable exactly-once semantics\n        msg UseOutbox();  // Reliable message publishing (transactional)\n        msg UseInbox();   // Idempotent message consumption (deduplication)\n    });\n});\n// Stage 5: Build and run\nvar app = builder Build();\nawait app RunAsync();\n`\nDomain Ownership Explained:\nDomain ownership is logical, not physical",
        "startIndex": 13670,
        "preview": "cross service boundaries Example: `csharp{ title: \"Distributed Messaging Setup - Complete Program cs\" description: \"Complete example configuring Whizb..."
      },
      {
        "id": "getting-started/package-structure-chunk-8",
        "text": "// events Orders, events Payments }); // Enable exactly-once semantics msg UseOutbox(); // Reliable message publishing (transactional) msg UseInbox(); // Idempotent message consumption (deduplication) }); }); // Stage 5: Build and run var app = builder Build(); await app RunAsync(); ` Domain Ownership Explained: Domain ownership is logical, not physical Services declare which domains they own, and Whizbang routes messages based on ownership:\nCommands are sent TO the domain owner\nEvents are published BY the domain owner\nServices communicate via message broker (not HTTP endpoints)\nExample Message Flow:\n`csharp\n// Inventory service sends PlaceOrder command\n// → Whizbang routes to Kafka topic \"commands Orders\"\n// → Orders service (domain owner) receives and handles it\nawait whizbang Send(new PlaceOrder( ));\n// Orders service publishes OrderPlaced event\n// → Whizbang publishes to Kafka topic \"events Orders\"\n// → All interested services (Inventory, Shipping, etc ) receive it\nawait whizbang Publish(new OrderPlaced( ));\n`\nRouting Configuration:\nThe message broker adapter handles physical routing Different deployment scenarios use different configurations:\nIn-Process (Monolith): All domains in one service, in-memory routing\nMicroservices (Kafka): Domains in separate services, Kafka topics\nKubernetes (RabbitMQ): Pods communicate via RabbitMQ exchanges\nHybrid: Some domains in-process, others distributed\nThe domain registration stays the same—only the message broker adapter configuration changes ---\nORM Integrations\nWhizbang uses ORMs (not custom database drivers) for persistence, allowing you to leverage existing tools and database compatibility Whizbang EntityFramework\nEntity Framework Core integration for event store and projections `bash\ndotnet add package Whizbang EntityFramework\n`\nFeatures:\nWorks with ANY EF Core database provider (Postgres, SQL Server, MySQL, SQLite, Cosmos DB, etc",
        "startIndex": 15537,
        "preview": "// events Orders, events Payments }); // Enable exactly-once semantics msg UseOutbox(); // Reliable message publishing (transactional) msg UseInbox();..."
      },
      {
        "id": "getting-started/package-structure-chunk-9",
        "text": "ORMs (not custom database drivers) for persistence, allowing you to leverage existing tools and database compatibility Whizbang EntityFramework Entity Framework Core integration for event store and projections `bash dotnet add package Whizbang EntityFramework ` Features: Works with ANY EF Core database provider (Postgres, SQL Server, MySQL, SQLite, Cosmos DB, etc )\nAutomatic migrations for event store schema\nDbContext integration for projections\nChange tracking for optimistic concurrency\nFull LINQ query support for projections\nShadow properties for metadata\nUse when:\nYou're already using Entity Framework Core\nYou want automatic migrations and schema management\nYou need complex LINQ queries in projections\nYou prefer convention-over-configuration\nExample with Postgres:\n`csharp{\ntitle: \"Entity Framework with Postgres\"\ndescription: \"Using EF Core with Postgres for event store and projections\"\nframework: \"NET8\"\ncategory: \"Persistence\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Entity Framework\", \"Postgres\", \"Event Store\", \"ORM\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang EntityFramework\", \"Npgsql EntityFrameworkCore PostgreSQL\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseEntityFramework(ef => {\n            // Use any EF Core database provider\n            ef UseNpgsql(\"Host=localhost;Database=myapp;Username=user;Password=pass\");\n            // Optional: customize event store schema\n            ef EventStoreSchema = \"events\";\n            ef EnableSensitiveDataLogging = false;\n        });\n    });\n});\n`\nExample with SQL Server:\n`csharp{\ntitle: \"Entity Framework with SQL Server\"\ndescription: \"Using EF Core with SQL Server for event store\"\nframework: \"NET8\"\ncategory: \"Persistence\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Entity Framework\", \"SQL Server\", \"Event Store\", \"ORM\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang EntityFramework\", \"Microsoft EntityFrameworkCore SqlServer\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseEntityFramework(ef => {\n            ef UseSqlServer(\"Server=localhost;Database=myapp;Trusted_Connection=True;\");\n        });\n    });\n});\n`\n---\nWhizbang Dapper\nDapper integration for high-performance event store and projections `bash\ndotnet add package Whizbang",
        "startIndex": 17099,
        "preview": "ORMs (not custom database drivers) for persistence, allowing you to leverage existing tools and database compatibility Whizbang EntityFramework Entity..."
      },
      {
        "id": "getting-started/package-structure-chunk-10",
        "text": "DependencyInjection\", \"Whizbang\"] showLineNumbers: true } using Microsoft Extensions DependencyInjection; using Whizbang; var services = new ServiceCollection(); services AddWhizbang(options => { options UseEventSourcing(es => { es UseEntityFramework(ef => { ef UseSqlServer(\"Server=localhost;Database=myapp;Trusted_Connection=True;\"); }); }); }); ` --- Whizbang Dapper Dapper integration for high-performance event store and projections `bash dotnet add package Whizbang Dapper\n`\nFeatures:\nWorks with ANY ADO NET database provider (Postgres, SQL Server, MySQL, SQLite, Oracle, etc )\nMinimal overhead - nearly raw SQL performance\nExplicit control over SQL queries\nBulk insert optimizations for event batches\nCustom type handlers for domain types\nMulti-database support in single application\nUse when:\nPerformance is critical\nYou want explicit control over SQL\nYou're comfortable writing queries\nYou need the absolute fastest event sourcing\nYou're using multiple database types\nExample with Postgres:\n`csharp{\ntitle: \"Dapper with Postgres\"\ndescription: \"Using Dapper with Postgres for high-performance event store\"\nframework: \"NET8\"\ncategory: \"Persistence\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Dapper\", \"Postgres\", \"Event Store\", \"Performance\", \"ORM\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Dapper\", \"Npgsql\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseDapper(dapper => {\n            dapper UseNpgsql(\"Host=localhost;Database=myapp;Username=user;Password=pass\");\n            // Optional: customize SQL queries for specific database optimizations\n            dapper UseJsonBinaryFormat = true;  // Postgres JSONB\n            dapper BatchSize = 1000;            // Bulk insert optimization\n        });\n    });\n});\n`\nExample with SQL Server:\n`csharp{\ntitle: \"Dapper with SQL Server\"\ndescription: \"Using Dapper with SQL Server for event store\"\nframework: \"NET8\"\ncategory: \"Persistence\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Dapper\", \"SQL Server\", \"Event Store\", \"Performance\", \"ORM\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Dapper\", \"Microsoft Data SqlClient\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseDapper(dapper => {\n            dapper",
        "startIndex": 19463,
        "preview": "DependencyInjection\", \"Whizbang\"] showLineNumbers: true } using Microsoft Extensions DependencyInjection; using Whizbang; var services = new ServiceCo..."
      },
      {
        "id": "getting-started/package-structure-chunk-11",
        "text": "tags: [\"Dapper\", \"SQL Server\", \"Event Store\", \"Performance\", \"ORM\"] nugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Dapper\", \"Microsoft Data SqlClient\"] usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"] showLineNumbers: true } using Microsoft Extensions DependencyInjection; using Whizbang; var services = new ServiceCollection(); services AddWhizbang(options => { options UseEventSourcing(es => { es UseDapper(dapper => { dapper UseSqlServer(\"Server=localhost;Database=myapp;Trusted_Connection=True;\");\n            // SQL Server optimizations\n            dapper UseMemoryOptimizedTables = true;\n            dapper EnableChangeTracking = true;\n        });\n    });\n});\n`\n---\nWhizbang NHibernate\nNHibernate integration for event store and projections `bash\ndotnet add package Whizbang NHibernate\n`\nFeatures:\nWorks with ANY NHibernate-supported database (Postgres, SQL Server, MySQL, Oracle, SQLite, etc )\nMature ORM with extensive database support\nXML or fluent mapping configuration\nAdvanced caching strategies (first-level, second-level, query cache)\nLazy loading and eager fetching strategies\nSupports legacy database schemas\nUse when:\nYou're already using NHibernate\nYou need advanced caching strategies\nYou're working with legacy database schemas\nYou require complex mapping scenarios\nYou want mature, battle-tested ORM\nExample with Postgres:\n`csharp{\ntitle: \"NHibernate with Postgres\"\ndescription: \"Using NHibernate with Postgres for event store\"\nframework: \"NET8\"\ncategory: \"Persistence\"\ndifficulty: \"ADVANCED\"\ntags: [\"NHibernate\", \"Postgres\", \"Event Store\", \"ORM\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang NHibernate\", \"NHibernate\", \"NHibernate Driver NpgsqlDriver\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\", \"NHibernate Cfg\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing NHibernate Cfg;\nusing Whizbang;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseNHibernate(nh => {\n            nh ConfigureWith(cfg => {\n                cfg DataBaseIntegration(db => {\n                    db ConnectionString = \"Host=localhost;Database=myapp;Username=user;Password=pass\";\n                    db Driver<NpgsqlDriver>();\n                    db Dialect<PostgreSQLDialect>();\n                });\n                // Optional: enable second-level cache\n                cfg Cache(c => {\n                    c UseSecondLevelCache = true;\n                    c UseQueryCache = true;\n                });\n            });\n        });\n    });\n});\n`\n---\nChoosing an ORM\nEntity Framework - Best for:\nGeneral-purpose applications\nAutomatic migrations\nConvention-over-configuration\nComplex LINQ queries\nMost",
        "startIndex": 21670,
        "preview": "tags: [\"Dapper\", \"SQL Server\", \"Event Store\", \"Performance\", \"ORM\"] nugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Dapper\", \"Mic..."
      },
      {
        "id": "getting-started/package-structure-chunk-12",
        "text": "db ConnectionString = \"Host=localhost;Database=myapp;Username=user;Password=pass\"; db Driver<NpgsqlDriver>(); db Dialect<PostgreSQLDialect>(); }); // Optional: enable second-level cache cfg Cache(c => { c UseSecondLevelCache = true; c UseQueryCache = true; }); }); }); }); }); ` --- Choosing an ORM Entity Framework - Best for: General-purpose applications Automatic migrations Convention-over-configuration Complex LINQ queries Most NET developers (familiar)\nDapper - Best for:\nHigh-performance scenarios\nExplicit SQL control\nMinimal overhead\nLarge event volumes\nPolyglot persistence (multiple databases)\nNHibernate - Best for:\nLegacy database integration\nAdvanced caching requirements\nComplex mapping scenarios\nEnterprise applications with existing NHibernate usage\n---\nMessage Broker Adapters\nWhizbang Kafka\nApache Kafka adapter for distributed messaging `bash\ndotnet add package Whizbang Kafka\n`\nFeatures:\nHigh throughput\nPartition-aware consumers\nCompacted topics for snapshots\nExactly-once semantics\nUse when:\nBuilding event-driven microservices at scale\nYou need event replay and time-travel capabilities\n---\nWhizbang RabbitMQ\nRabbitMQ adapter for distributed messaging `bash\ndotnet add package Whizbang RabbitMQ\n`\nFeatures:\nFlexible routing\nPriority queues\nDead-letter exchanges\nPublisher confirms\n---\nWhizbang AzureServiceBus\nAzure Service Bus adapter `bash\ndotnet add package Whizbang AzureServiceBus\n`\nFeatures:\nManaged service (no infrastructure)\nSessions for ordered processing\nDuplicate detection\nIntegration with Azure ecosystem\n---\nWhizbang AWSSQS\nAWS SQS/SNS adapter `bash\ndotnet add package Whizbang AWSSQS\n`\nFeatures:\nManaged service\nFIFO queues for ordering\nIntegration with AWS ecosystem\n---\nObservability Packages\nWhizbang OpenTelemetry\nOpenTelemetry integration `bash\ndotnet add package Whizbang OpenTelemetry\n`\nIncludes:\nAutomatic tracing for all messages\nMetrics for throughput, latency, errors\nDistributed context propagation\n---\nWhizbang Dashboard\nWeb-based monitoring dashboard `bash\ndotnet add package Whizbang Dashboard\n`\nFeatures:\nLive message flow visualization\nProjection lag monitoring\nError tracking\nPerformance metrics\n---\nDeveloper Packages\nWhizbang Analyzers\nRoslyn analyzers for compile-time validation `bash\ndotnet add package Whizbang",
        "startIndex": 23997,
        "preview": "db ConnectionString = \"Host=localhost;Database=myapp;Username=user;Password=pass\"; db Driver<NpgsqlDriver>(); db Dialect<PostgreSQLDialect>(); }); // ..."
      },
      {
        "id": "getting-started/package-structure-chunk-13",
        "text": "all messages Metrics for throughput, latency, errors Distributed context propagation --- Whizbang Dashboard Web-based monitoring dashboard `bash dotnet add package Whizbang Dashboard ` Features: Live message flow visualization Projection lag monitoring Error tracking Performance metrics --- Developer Packages Whizbang Analyzers Roslyn analyzers for compile-time validation `bash dotnet add package Whizbang Analyzers\n`\nIncludes:\nProjection Purity Checks: Enforce pure functions in projections\nNo field/property mutations outside method scope\nNo I/O operations (file system, network, database writes)\nNo static mutation\nNo logging or side effects in projection handlers\nHandler Validation: Enforce [Pure] attribute on command/query handlers\nDomain Ownership: Detect missing domain ownership attributes\nNaming Conventions: Validate event and command naming conventions\nAsync Patterns: Check for synchronous I/O in async handlers\nSubscription Rules: Validate [WhizbangSubscribe] usage (one per method, etc )\nSecurity Context: Warn when security-sensitive operations lack tenant/user validation\nPurity Enforcement Example:\n`csharp\n[WhizbangProjection]\npublic class OrderProjection {\n    private readonly ILogger _logger;  // ⚠️ Warning: Injected services should be read-only\n    // ✅ VALID - Pure projection handler\n    public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) {\n        // Pure state updates only\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - Side effect detected (logging)\n    public Task Handle([WhizbangSubscribe] OrderShipped @event, CancellationToken ct) {\n        _logger LogInformation(\"Order shipped\");  // 💥 Compile error: Side effect in projection\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - I/O operation detected\n    public async Task Handle([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) {\n        await File WriteAllTextAsync(\"log txt\", \"cancelled\");  // 💥 Compile error: I/O in projection\n    }\n}\n`\n---\nWhizbang Testing\nTesting utilities and in-memory doubles `bash\ndotnet add package Whizbang Testing\n`\nIncludes:\nIn-memory event store\nFake message bus\nProjection test helpers\nAggregate test fixtures\n---\nCustomizable Attributes\nWhizbang uses attributes for source generator discovery ([WhizbangHandler], [WhizbangProjection], [WhizbangSubscribe]), and these attributes are customizable to fit your team's preferences or naming conventions",
        "startIndex": 25846,
        "preview": "all messages Metrics for throughput, latency, errors Distributed context propagation --- Whizbang Dashboard Web-based monitoring dashboard `bash dotne..."
      },
      {
        "id": "getting-started/package-structure-chunk-14",
        "text": "utilities and in-memory doubles `bash dotnet add package Whizbang Testing ` Includes: In-memory event store Fake message bus Projection test helpers Aggregate test fixtures --- Customizable Attributes Whizbang uses attributes for source generator discovery ([WhizbangHandler], [WhizbangProjection], [WhizbangSubscribe]), and these attributes are customizable to fit your team's preferences or naming conventions Why the Whizbang prefix All attributes use consistent Whizbang prefix to:\nAvoid naming collisions with other frameworks (e g , generic [Handler] attribute)\nProvide clear visual indication of framework-specific attributes\nEnable easy searching across codebase (grep \"WhizbangHandler\")\nMaintain consistent naming convention\nUsing Custom Attribute Names\nYou can configure Whizbang to recognize alternate attribute names:\n`csharp{\ntitle: \"Custom Attribute Names Configuration\"\ndescription: \"Configure Whizbang to use custom attribute names\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Attributes\", \"Source Generator\", \"Configuration\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nvar builder = Host CreateApplicationBuilder(args);\nbuilder Services AddWhizbang(options => {\n    // Configure custom attribute names\n    options Attributes(attr => {\n        // Use your own handler attribute name\n        attr HandlerAttribute = \"MyCompany CommandHandlerAttribute\";\n        // Use your own projection attribute name\n        attr ProjectionAttribute = \"MyCompany ProjectionAttribute\";\n        // Use your own subscription attribute name\n        attr SubscribeAttribute = \"MyCompany EventSubscriptionAttribute\";\n    });\n    options RegisterGeneratedHandlers();\n    options UseProjections(proj => proj RegisterGeneratedProjections());\n});\n`\nSource-Generated Attributes (Future)\nIn future versions, Whizbang may provide source-generated attributes that are automatically created in your project:\n`csharp\n// Auto-generated by Whizbang source generator\nnamespace MyCompany;\n[AttributeUsage(AttributeTargets Class | AttributeTargets Interface)]\npublic class CommandHandlerAttribute : Attribute { }\n[AttributeUsage(AttributeTargets Class | AttributeTargets Interface)]\npublic class ProjectionAttribute : Attribute { }\n[AttributeUsage(AttributeTargets Parameter)]\npublic class EventSubscriptionAttribute : Attribute { }\n`\nBenefits:\nNo dependency on Whizbang",
        "startIndex": 27879,
        "preview": "utilities and in-memory doubles `bash dotnet add package Whizbang Testing ` Includes: In-memory event store Fake message bus Projection test helpers A..."
      },
      {
        "id": "getting-started/package-structure-chunk-15",
        "text": "your project: `csharp // Auto-generated by Whizbang source generator namespace MyCompany; [AttributeUsage(AttributeTargets Class | AttributeTargets Interface)] public class CommandHandlerAttribute : Attribute { } [AttributeUsage(AttributeTargets Class | AttributeTargets Interface)] public class ProjectionAttribute : Attribute { } [AttributeUsage(AttributeTargets Parameter)] public class EventSubscriptionAttribute : Attribute { } ` Benefits: No dependency on Whizbang Core in your domain layer\nYour own namespace and naming conventions\nStill compatible with Whizbang's source generator\nEnables clean architecture (domain doesn't reference framework)\nWhy Customizable Attributes Team Conventions: Match your existing attribute naming patterns\nClean Architecture: Keep framework attributes out of domain layer\nLegacy Integration: Reuse existing attributes from other frameworks\nMulti-Framework: Use same attributes with multiple frameworks\n---\nPackage Decision Tree\n`\nDo you need event sourcing ├─ NO → Whizbang Core (mediator only)\n└─ YES → Whizbang Core + Whizbang EventSourcing\n          └─ Choose an ORM integration:\n              ├─ Whizbang EntityFramework (recommended for most)\n              ├─ Whizbang Dapper (high performance)\n              └─ Whizbang NHibernate (enterprise/legacy)\nDo you need read models └─ YES → Add Whizbang Projections\nAre you building microservices └─ YES → Add Whizbang Messaging\n          └─ Choose a message broker adapter:\n              ├─ Whizbang Kafka\n              ├─ Whizbang RabbitMQ\n              ├─ Whizbang AzureServiceBus\n              └─ Whizbang AWSSQS\nDo you need observability └─ YES → Add Whizbang OpenTelemetry or Whizbang Dashboard\nAre you developing/testing └─ YES → Add Whizbang Testing and Whizbang Analyzers\n`\n---\nTypical Configurations\nSimple Monolith\n`bash\ndotnet add package Whizbang Core\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang EntityFramework\ndotnet add package Npgsql EntityFrameworkCore PostgreSQL\n`\n---\nMonolith with Read Models\n`bash\ndotnet add package Whizbang Core\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang Projections\ndotnet add package Whizbang EntityFramework\ndotnet add package Npgsql EntityFrameworkCore PostgreSQL\n`\n---\nHigh-Performance Monolith\n`bash\ndotnet add package Whizbang Core\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang",
        "startIndex": 30002,
        "preview": "your project: `csharp // Auto-generated by Whizbang source generator namespace MyCompany; [AttributeUsage(AttributeTargets Class | AttributeTargets In..."
      },
      {
        "id": "getting-started/package-structure-chunk-16",
        "text": "Monolith with Read Models `bash dotnet add package Whizbang Core dotnet add package Whizbang EventSourcing dotnet add package Whizbang Projections dotnet add package Whizbang EntityFramework dotnet add package Npgsql EntityFrameworkCore PostgreSQL ` --- High-Performance Monolith `bash dotnet add package Whizbang Core dotnet add package Whizbang EventSourcing dotnet add package Whizbang Projections\ndotnet add package Whizbang Dapper\ndotnet add package Npgsql\n`\n---\nMicroservices with Kafka\n`bash\ndotnet add package Whizbang Core\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang Projections\ndotnet add package Whizbang Messaging\ndotnet add package Whizbang EntityFramework\ndotnet add package Npgsql EntityFrameworkCore PostgreSQL\ndotnet add package Whizbang Kafka\ndotnet add package Whizbang OpenTelemetry\n`\n---\nEnterprise with SQL Server\n`bash\ndotnet add package Whizbang Core\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang Projections\ndotnet add package Whizbang NHibernate\ndotnet add package NHibernate\ndotnet add package NHibernate Driver MicrosoftDataSqlClientDriver\n`\n---\nNext Steps\nGetting Started - Build your first Whizbang application\nPhilosophy - Understand Whizbang's design principles and architectural philosophy\nCore Concepts - Deep dive into commands, events, projections, and aggregates\nDriver System - Learn how to implement custom drivers\nTesting - Test your event-sourced applications",
        "startIndex": 31674,
        "preview": "Monolith with Read Models `bash dotnet add package Whizbang Core dotnet add package Whizbang EventSourcing dotnet add package Whizbang Projections dot..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "observability/dashboard",
    "title": "Whizbang Dashboard",
    "category": "Observability",
    "url": "/docs/observability/dashboard",
    "chunks": [
      {
        "id": "observability/dashboard-chunk-0",
        "text": "Whizbang Dashboard\nThe Whizbang Dashboard is a separate web application (package: Whizbang Dashboard) that provides real-time visualization of your event-sourced, message-driven system Overview\nThe dashboard offers:\nMessage Journey Visualization - See the complete lifecycle of commands and events\nDistributed Tracing - Track messages across microservices\nProjection Health - Monitor projection lag and errors\nEvent Stream Explorer - Browse aggregate event streams\nPerformance Metrics - Throughput, latency, error rates\nControl Plane - Send control commands to services\nInstallation\nNuGet Package\n`bash\ndotnet add package Whizbang Dashboard\n`\nStandalone Dashboard Application\nOr run as a separate service:\n`bash\ndotnet tool install --global Whizbang Dashboard\nwhizbang-dashboard --port 5050\n`\nEmbedded in Application\nAdd to your ASP NET Core application:\n`csharp{\ntitle: \"Embed Dashboard in Application\"\ndescription: \"Add dashboard to existing ASP NET Core app\"\nframework: \"NET8\"\ncategory: \"Observability\"\ndifficulty: \"BEGINNER\"\ntags: [\"Dashboard\", \"Setup\"]\nnugetPackages: [\"Whizbang Dashboard\", \"Microsoft AspNetCore\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft AspNetCore Builder\", \"Whizbang Dashboard\"]\nshowLineNumbers: true\n}\nusing Microsoft AspNetCore Builder;\nusing Whizbang Dashboard;\nvar builder = WebApplication CreateBuilder(args);\n// Add Whizbang Dashboard\nbuilder Services AddWhizbangDashboard(options => {\n    options EnableRealTimeUpdates = true;\n    options RetentionPeriod = TimeSpan FromHours(24);  // Keep traces for 24 hours\n    options RequireAuthentication = true;              // Protect dashboard\n});\nvar app = builder Build();\n// Mount dashboard at /whizbang\napp MapWhizbangDashboard(\"/whizbang\");\napp",
        "startIndex": 0,
        "preview": "Whizbang Dashboard\nThe Whizbang Dashboard is a separate web application (package: Whizbang Dashboard) that provides real-time visualization of your ev..."
      },
      {
        "id": "observability/dashboard-chunk-1",
        "text": "var builder = WebApplication CreateBuilder(args); // Add Whizbang Dashboard builder Services AddWhizbangDashboard(options => { options EnableRealTimeUpdates = true; options RetentionPeriod = TimeSpan FromHours(24); // Keep traces for 24 hours options RequireAuthentication = true; // Protect dashboard }); var app = builder Build(); // Mount dashboard at /whizbang app MapWhizbangDashboard(\"/whizbang\"); app Run();\n`\nAccess at: http://localhost:5000/whizbang\nMessage Journey Visualization\nEnd-to-End Flow\nSee the complete journey of a command through your system:\n`\nPlaceOrder (Command)\n  ↓\nOrderCommandHandler\n  ↓\nOrderPlaced (Event)\n  ├─→ OrderHistoryProjection (updated)\n  ├─→ InventoryReservationSaga (triggered)\n  │   ↓\n  │   ReserveInventory (Command) → InventoryService\n  │   ↓\n  │   InventoryReserved (Event)\n  │   ↓\n  │   ProcessPayment (Command) → PaymentService\n  │   ↓\n  │   PaymentProcessed (Event)\n  └─→ CustomerNotificationHandler (email sent)\n`\nDashboard Visualization:\n`\n┌────────────────────────────────────────────────────────────┐\n│  Message Journey: PlaceOrder                               │\n├────────────────────────────────────────────────────────────┤\n│                                                             │\n│  [PlaceOrder] ──→ [OrderHandler] ──→ [OrderPlaced]         │\n│      ↓ 42ms          ↓ 120ms           ↓                   │\n│      │               │                 ├─→ [OrderHistory]  │\n│      │               │                 │    ↓ 15ms         │\n│      │               │                 │                   │\n│      │               │                 ├─→ [ReserveSaga]   │\n│      │               │                 │    ↓ 200ms        │\n│      │               │                 │    └─→ [Inventory]│\n│      │               │                 │         ↓ 350ms   │\n│      │               │                 │         └─→ [Pay] │\n│      │               │                 │              ↓    │\n│      │               │                 └─→ [Notify] ✓      │\n│                                                             │\n│  Total Duration: 727ms                                      │\n│  Status: ✓ Success                                          │\n└────────────────────────────────────────────────────────────┘\n`\nInteractive Trace Explorer\nClick on any message to drill down:\n`\n┌────────────────────────────────────────────────────────────┐\n│  OrderPlaced Event Details                                 │\n├────────────────────────────────────────────────────────────┤\n│  Event ID: evt_01J7G3KZ9P │\n│  Timestamp: 2025-10-18 14:32:15 234 UTC                    │\n│  Correlation ID: cmd_01J7G3KZ8N │\n│  Causation ID: cmd_01J7G3KZ8N │\n│                                                             │\n│  Payload:                                                   │\n│  {                                                          │\n│    \"orderId\": \"ord_123\",                                    │\n│    \"customerId\": \"cust_456\",                                │\n│    \"total\": 99 99,                                          │\n│    \"items\": [ /",
        "startIndex": 1736,
        "preview": "var builder = WebApplication CreateBuilder(args); // Add Whizbang Dashboard builder Services AddWhizbangDashboard(options => { options EnableRealTimeU..."
      },
      {
        "id": "observability/dashboard-chunk-2",
        "text": "Details │ ├────────────────────────────────────────────────────────────┤ │ Event ID: evt_01J7G3KZ9P │ │ Timestamp: 2025-10-18 14:32:15 234 UTC │ │ Correlation ID: cmd_01J7G3KZ8N │ │ Causation ID: cmd_01J7G3KZ8N │ │ │ │ Payload: │ │ { │ │ \"orderId\": \"ord_123\", │ │ \"customerId\": \"cust_456\", │ │ \"total\": 99 99, │ │ \"items\": [ / / ]                                   │\n│  }                                                          │\n│                                                             │\n│  Metadata:                                                  │\n│  - Tenant: acme-corp                                        │\n│  - User: john doe@acme com                                  │\n│  - Source: orders-service-pod-3                             │\n│  - Trace ID: 4bf92f3577b34da6a3ce929d0e0e4736              │\n│                                                             │\n│  Subscribers (3):                                           │\n│  ✓ OrderHistoryProjection (15ms)                           │\n│  ✓ InventoryReservationSaga (200ms)                        │\n│  ✓ CustomerNotificationHandler (42ms)                      │\n└────────────────────────────────────────────────────────────┘\n`\nDistributed Tracing\nCross-Service Traces\nVisualize messages flowing across microservices:\n`\nAPI Gateway         Orders Service      Inventory Service    Payment Service\n    │                     │                     │                   │\n    ├─ PlaceOrder ──────→ │                     │                   │\n    │                     ├─ OrderPlaced ──────→│                   │\n    │                     │                     ├─ ReserveInventory │\n    │                     │                     │                   │\n    │                     │ ←── InventoryReserved                   │\n    │                     ├─ ProcessPayment ────────────────────→  │\n    │                     │                     │                   │\n    │                     │ ←─────────────────── PaymentProcessed ─┤\n    │ ←── OrderConfirmed ─┤                     │                   │\n    │                     │                     │                   │\n`\nOpenTelemetry Integration:\nThe dashboard integrates with OpenTelemetry traces:\n`csharp{\ntitle: \"OpenTelemetry Integration\"\ndescription: \"Dashboard reads OpenTelemetry traces\"\nframework: \"NET8\"\ncategory: \"Observability\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"OpenTelemetry\", \"Tracing\", \"Dashboard\"]\nnugetPackages: [\"Whizbang Dashboard\", \"Whizbang OpenTelemetry\"]\nusingStatements: [\"Whizbang Dashboard\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang Dashboard;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbangDashboard(options => {\n    // Read traces from OpenTelemetry collector\n    options UseOpenTelemetry(otel => {\n        otel Endpoint = \"http://otel-collector:4317\";\n        otel Protocol = OpenTelemetryProtocol Grpc;\n    });\n    // Or from Jaeger\n    options UseJaeger(jaeger => {\n        jaeger Endpoint = \"http://jaeger:16686\";\n    });\n    // Or from Zipkin\n    options UseZipkin(zipkin => {\n        zipkin",
        "startIndex": 4494,
        "preview": "Details │ ├────────────────────────────────────────────────────────────┤ │ Event ID: evt_01J7G3KZ9P │ │ Timestamp: 2025-10-18 14:32:15 234 UTC │ │ Cor..."
      },
      {
        "id": "observability/dashboard-chunk-3",
        "text": "using Microsoft Extensions DependencyInjection; services AddWhizbangDashboard(options => { // Read traces from OpenTelemetry collector options UseOpenTelemetry(otel => { otel Endpoint = \"http://otel-collector:4317\"; otel Protocol = OpenTelemetryProtocol Grpc; }); // Or from Jaeger options UseJaeger(jaeger => { jaeger Endpoint = \"http://jaeger:16686\"; }); // Or from Zipkin options UseZipkin(zipkin => { zipkin Endpoint = \"http://zipkin:9411\";\n    });\n});\n`\nTrace Timeline View\nWaterfall chart showing message timing:\n`\nTime ──────────────────────────────────────────────────→\n0ms   100ms  200ms  300ms  400ms  500ms  600ms  700ms\nPlaceOrder\n│────────────│ (120ms)\n             OrderPlaced\n             │──────────────────│ (200ms - saga processing)\n                                ReserveInventory\n                                │──────────────│ (150ms)\n                                               InventoryReserved\n                                               │────────────│ (100ms)\n                                                           ProcessPayment\n                                                           │──────────────│ (150ms)\n                                                                         PaymentProcessed\n                                                                         │─│ (5ms - notification)\n═══════════════════════════════════════════════════════════════════════════\nTotal: 727ms\n`\nProjection Health Monitoring\nProjection Dashboard\nReal-time view of all projections:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Projections                                                      │\n├──────────────────────────────────────────────────────────────────┤\n│                                                                   │\n│  Name                   Status    Lag      Throughput    Errors  │\n│  ────────────────────   ──────    ────     ──────────    ──────  │\n│  OrderHistory           🟢 OK     2ms      450 evt/sec   0       │\n│  CustomerStats          🟢 OK     5ms      320 evt/sec   0       │\n│  InventorySummary       🟡 WARN   2 5s     180 evt/sec   0       │\n│  ProductRecommendations 🔴 ERROR  45s      0 evt/sec     15      │\n│                                                                   │\n│  [Rebuild] [Pause] [Reset Checkpoint]                            │\n└──────────────────────────────────────────────────────────────────┘\n`\nLag Alert: Visual indicator when projection falls behind event stream Projection Details\nDrill into individual projection:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Projection: ProductRecommendations                               │\n├──────────────────────────────────────────────────────────────────┤\n│  Status: 🔴 ERROR                                                 │\n│  Last Processed Event: evt_01J7G3KZ9P",
        "startIndex": 7270,
        "preview": "using Microsoft Extensions DependencyInjection; services AddWhizbangDashboard(options => { // Read traces from OpenTelemetry collector options UseOpen..."
      },
      {
        "id": "observability/dashboard-chunk-4",
        "text": "🔴 ERROR 45s 0 evt/sec 15 │ │ │ │ [Rebuild] [Pause] [Reset Checkpoint] │ └──────────────────────────────────────────────────────────────────┘ ` Lag Alert: Visual indicator when projection falls behind event stream Projection Details Drill into individual projection: ` ┌──────────────────────────────────────────────────────────────────┐ │ Projection: ProductRecommendations │ ├──────────────────────────────────────────────────────────────────┤ │ Status: 🔴 ERROR │ │ Last Processed Event: evt_01J7G3KZ9P (45 seconds ago)        │\n│  Current Checkpoint: 123,456                                      │\n│  Latest Event Position: 125,890                                   │\n│  Lag: 2,434 events (~45 seconds)                                  │\n│                                                                   │\n│  Recent Errors (15):                                              │\n│  - NullReferenceException at UpdateRecommendations:42            │\n│  - NullReferenceException at UpdateRecommendations:42            │\n│  - NullReferenceException at UpdateRecommendations:42            │\n│  [View Stack Trace]                                               │\n│                                                                   │\n│  Actions:                                                         │\n│  [Rebuild from Start] [Rebuild from Checkpoint] [Skip Failed]    │\n└──────────────────────────────────────────────────────────────────┘\n`\nActions:\nRebuild: Clear projection and replay all events\nSkip: Skip the failing event and continue\nPause: Stop projection processing\nEvent Stream Explorer\nBrowse aggregate event streams:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Event Stream: Order-ord_123                                      │\n├──────────────────────────────────────────────────────────────────┤\n│                                                                   │\n│  [0] OrderPlaced              2025-10-18 14:32:15 UTC            │\n│      Customer: cust_456       Total: $99 99                       │\n│                                                                   │\n│  [1] OrderItemAdded           2025-10-18 14:33:02 UTC            │\n│      Product: Widget          Quantity: 2                         │\n│                                                                   │\n│  [2] OrderShipped             2025-10-18 14:45:10 UTC            │\n│      Carrier: UPS             Tracking: 1Z999AA10123456789        │\n│                                                                   │\n│  [3] OrderDelivered           2025-10-20 10:15:33 UTC            │\n│      Signature: J",
        "startIndex": 9723,
        "preview": "🔴 ERROR 45s 0 evt/sec 15 │ │ │ │ [Rebuild] [Pause] [Reset Checkpoint] │ └──────────────────────────────────────────────────────────────────┘ ` Lag Al..."
      },
      {
        "id": "observability/dashboard-chunk-5",
        "text": "│ │ Customer: cust_456 Total: $99 99 │ │ │ │ [1] OrderItemAdded 2025-10-18 14:33:02 UTC │ │ Product: Widget Quantity: 2 │ │ │ │ [2] OrderShipped 2025-10-18 14:45:10 UTC │ │ Carrier: UPS Tracking: 1Z999AA10123456789 │ │ │ │ [3] OrderDelivered 2025-10-20 10:15:33 UTC │ │ Signature: J Doe        Location: Front door                │\n│                                                                   │\n│  Total Events: 4              Aggregate Version: 3                │\n│                                                                   │\n│  [Replay] [Download JSON] [View Snapshots]                        │\n└──────────────────────────────────────────────────────────────────┘\n`\nFeatures:\nView full event stream for any aggregate\nDownload events as JSON\nReplay events (time-travel debugging)\nView snapshots (if enabled)\nPerformance Metrics\nThroughput Dashboard\nReal-time metrics:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Throughput (Last 5 Minutes)                                      │\n├──────────────────────────────────────────────────────────────────┤\n│                                                                   │\n│  Commands/sec:  ████████████████░░░░  120/sec                    │\n│  Events/sec:    ██████████████████░░  450/sec                    │\n│  Queries/sec:   ████████████░░░░░░░░  80/sec                     │\n│                                                                   │\n│  Avg Latency:                                                     │\n│  - Commands:    42ms   (p50: 35ms, p95: 120ms, p99: 250ms)       │\n│  - Events:      15ms   (p50: 12ms, p95: 45ms, p99: 80ms)         │\n│  - Queries:     8ms    (p50: 5ms, p95: 25ms, p99: 50ms)          │\n│                                                                   │\n│  Error Rate:    0 02%  (3 errors in 15,000 messages)             │\n└──────────────────────────────────────────────────────────────────┘\n`\nService Health\nMonitor individual services:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Services                                                         │\n├──────────────────────────────────────────────────────────────────┤\n│  Name              Status    CPU    Memory   Replicas   Requests │\n│  ──────────────    ──────    ───    ──────   ────────   ──────── │\n│  orders-service    🟢 OK     23%    1 2 GB   3/3        450/sec  │\n│  inventory-service 🟢 OK     45%    800 MB   2/2        320/sec  │\n│  payment-service   🟡 WARN   78%    1",
        "startIndex": 11840,
        "preview": "│ │ Customer: cust_456 Total: $99 99 │ │ │ │ [1] OrderItemAdded 2025-10-18 14:33:02 UTC │ │ Product: Widget Quantity: 2 │ │ │ │ [2] OrderShipped 2025-..."
      },
      {
        "id": "observability/dashboard-chunk-6",
        "text": "services: ` ┌──────────────────────────────────────────────────────────────────┐ │ Services │ ├──────────────────────────────────────────────────────────────────┤ │ Name Status CPU Memory Replicas Requests │ │ ────────────── ────── ─── ────── ──────── ──────── │ │ orders-service 🟢 OK 23% 1 2 GB 3/3 450/sec │ │ inventory-service 🟢 OK 45% 800 MB 2/2 320/sec │ │ payment-service 🟡 WARN 78% 1 8 GB   2/2        180/sec  │\n│  shipping-service  🟢 OK     12%    600 MB   1/1        80/sec   │\n└──────────────────────────────────────────────────────────────────┘\n`\nControl Plane UI\nSend Control Commands\nFrom the dashboard UI:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Control Commands                                                 │\n├──────────────────────────────────────────────────────────────────┤\n│                                                                   │\n│  Command: [Rebuild Projection ▼]                                 │\n│                                                                   │\n│  Projection Name: [OrderHistory_____________]                     │\n│  Target Service:  [All Services ▼]                                │\n│  Start From:      [Beginning of Time ▼]                           │\n│                                                                   │\n│  ⚠️  Warning: This will clear and rebuild the projection │\n│      Queries may return incomplete data during rebuild │\n│                                                                   │\n│  [Cancel]  [Execute Command]                                      │\n└──────────────────────────────────────────────────────────────────┘\n`\nAvailable Commands:\nRebuild Projection\nSet Log Level\nClear Caches\nRun Health Check\nToggle Feature Flags\nPause/Resume Message Processing\nCommand History\nTrack what control commands were executed:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Command History                                                  │\n├──────────────────────────────────────────────────────────────────┤\n│  Time                Command                   User      Status  │\n│  ──────────────────  ────────────────────────  ────────  ──────  │\n│  14:52:10 UTC        Rebuild OrderHistory      admin     ✓ Done  │\n│  14:45:33 UTC        Set Log Level=Debug       john doe  ✓ Done  │\n│  14:32:15 UTC        Clear Cache               admin     ✗ Failed│\n│  14:18:02 UTC        Pause Projection          jane doe  ✓ Done  │\n└──────────────────────────────────────────────────────────────────┘\n`\nSearch and Filtering\nSearch Messages\nFind specific messages:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Search Messages                                                  │\n├──────────────────────────────────────────────────────────────────┤\n│  Query: [customer_id:cust_456 AND status:shipped_____________]   │\n│  Time Range: [Last 24 Hours ▼]                                   │\n│  [Search]                                                         │\n│                                                                   │\n│  Results (42):                                                    │\n│  ────────────────────────────────────────────────────────────────│\n│  OrderShipped - ord_123 - 2025-10-18 14:45:10                    │\n│  OrderShipped - ord_789 - 2025-10-18 12:15:33                    │\n│  OrderShipped - ord_456 - 2025-10-17 16:32:45                    │\n│",
        "startIndex": 14055,
        "preview": "services: ` ┌──────────────────────────────────────────────────────────────────┐ │ Services │ ├───────────────────────────────────────────────────────..."
      },
      {
        "id": "observability/dashboard-chunk-7",
        "text": "│ Query: [customer_id:cust_456 AND status:shipped_____________] │ │ Time Range: [Last 24 Hours ▼] │ │ [Search] │ │ │ │ Results (42): │ │ ────────────────────────────────────────────────────────────────│ │ OrderShipped - ord_123 - 2025-10-18 14:45:10 │ │ OrderShipped - ord_789 - 2025-10-18 12:15:33 │ │ OrderShipped - ord_456 - 2025-10-17 16:32:45 │ │ │\n└──────────────────────────────────────────────────────────────────┘\n`\nQuery Syntax:\nevent_type:OrderPlaced\ntenant_id:acme-corp\ntimestamp > 2025-10-18\nstatus:error AND service:payment\nReal-Time Updates\nDashboard updates in real-time via SignalR:\n`csharp{\ntitle: \"Real-Time Dashboard Updates\"\ndescription: \"Dashboard receives live updates via SignalR\"\nframework: \"NET8\"\ncategory: \"Observability\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Dashboard\", \"SignalR\", \"Real-Time\"]\nnugetPackages: [\"Whizbang Dashboard\", \"Microsoft AspNetCore SignalR\"]\nusingStatements: [\"Whizbang Dashboard\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang Dashboard;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbangDashboard(options => {\n    // Real-time updates via SignalR\n    options EnableRealTimeUpdates = true;\n    // Push notifications for important events\n    options PushNotifications(notify => {\n        notify OnProjectionError = true;\n        notify OnHighLatency = true;\n        notify OnErrorRateThreshold = 0 05;  // Alert if error rate > 5%\n    });\n});\n`\nFeatures:\nLive message journey updates\nReal-time projection lag updates\nInstant error notifications\nThroughput graphs update every second\nSecurity\nAuthentication\nProtect the dashboard:\n`csharp{\ntitle: \"Dashboard Authentication\"\ndescription: \"Secure dashboard with authentication\"\nframework: \"NET8\"\ncategory: \"Security\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Dashboard\", \"Authentication\", \"Security\"]\nnugetPackages: [\"Whizbang Dashboard\", \"Microsoft AspNetCore Authentication\"]\nusingStatements: [\"Whizbang Dashboard\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang Dashboard;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbangDashboard(options => {\n    // Require authentication\n    options RequireAuthentication = true;\n    // Role-based access\n    options RequireRole(\"WhizbangAdmin\");\n    // Or custom authorization policy\n    options RequirePolicy(\"WhizbangDashboardAccess\");\n});\n`\nAudit Log\nTrack who accessed the dashboard:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Audit Log                                                        │\n├──────────────────────────────────────────────────────────────────┤\n│  Timestamp           User         Action                          │\n│  ──────────────────  ───────────  ─────────────────────────────  │\n│  14:52:10 UTC        admin        Rebuilt projection OrderHistory│\n│  14:45:33 UTC        john",
        "startIndex": 17189,
        "preview": "│ Query: [customer_id:cust_456 AND status:shipped_____________] │ │ Time Range: [Last 24 Hours ▼] │ │ [Search] │ │ │ │ Results (42): │ │ ─────────────..."
      },
      {
        "id": "observability/dashboard-chunk-8",
        "text": "true; // Role-based access options RequireRole(\"WhizbangAdmin\"); // Or custom authorization policy options RequirePolicy(\"WhizbangDashboardAccess\"); }); ` Audit Log Track who accessed the dashboard: ` ┌──────────────────────────────────────────────────────────────────┐ │ Audit Log │ ├──────────────────────────────────────────────────────────────────┤ │ Timestamp User Action │ │ ────────────────── ─────────── ───────────────────────────── │ │ 14:52:10 UTC admin Rebuilt projection OrderHistory│ │ 14:45:33 UTC john doe     Viewed order stream ord_123    │\n│  14:32:15 UTC        admin        Set log level to Debug         │\n│  14:18:02 UTC        jane doe     Paused projection              │\n└──────────────────────────────────────────────────────────────────┘\n`\nNext Steps\nObservability - OpenTelemetry integration\nAdvanced Scenarios - Control plane commands\nDistributed Messaging - Cross-service tracing",
        "startIndex": 19710,
        "preview": "true; // Role-based access options RequireRole(\"WhizbangAdmin\"); // Or custom authorization policy options RequirePolicy(\"WhizbangDashboardAccess\"); }..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "projections/projection-contexts",
    "title": "Projection Contexts",
    "category": "Projections",
    "url": "/docs/projections/projection-contexts",
    "chunks": [
      {
        "id": "projections/projection-contexts-chunk-0",
        "text": "Projection Contexts\nWhizbang provides two types of context for projections:\nEventContext - Rich event metadata (pure data, no side effects)\nProjectionContext - Projection-specific operations and metadata (CRUD operations, projection info)\nBoth can be injected at the method level or constructor level `mermaid\ngraph LR\n    Event[Event] --> Handler[Projection Handler]\n    subgraph Contexts[\"Injected Contexts\"]\n        EC[EventContext<br/>Pure Data Only]\n        PC[ProjectionContext<br/>With CRUD Operations]\n    end\n    subgraph ECData[\"EventContext Contents\"]\n        System[System Data<br/>Timestamp, Machine, etc ]\n        Security[Security Context<br/>User, Tenant, Roles]\n        EventMeta[Event Metadata<br/>EventId, Causation]\n        Tracing[Tracing Context<br/>CorrelationId, TraceId]\n    end\n    subgraph PCData[\"ProjectionContext Contents\"]\n        ProjMeta[Projection Metadata<br/>Name, Version, Type]\n        ServiceMeta[Service Metadata<br/>Environment, Machine]\n        Store[Projection Store<br/>Create, Update, Patch, Delete]\n    end\n    EC --> ECData\n    PC --> PCData\n    Handler --> EC\n    Handler --> PC\n    PC --> Store\n    style Event fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    style Handler fill:#cce5ff,stroke:#004085,stroke-width:2px\n    style EC fill:#d4edda,stroke:#28a745,stroke-width:2px\n    style PC fill:#d1ecf1,stroke:#0c5460,stroke-width:2px\n    style Store fill:#f8d7da,stroke:#dc3545,stroke-width:2px\n`\nEventContext Injection\nEventContext is pure data (no side effects) that provides rich metadata about every event EventContext Structure\n`csharp\npublic class EventContext {\n    // System metadata\n    public SystemData System { get; init; }\n    // Security and multi-tenancy context\n    public SecurityContext Security { get; init; }\n    // Event-specific metadata\n    public EventMetadata Event { get; init; }\n    // Distributed tracing information\n    public TracingContext Tracing { get; init; }\n}\npublic class SystemData {\n    // System-generated metadata\n    public DateTime Timestamp { get; init; }\n    public string MachineName { get; init; }\n    public string Environment { get; init; }\n    public long EventSequenceNumber { get; init; }\n    // Custom system metadata (extensible)\n    public IReadOnlyDictionary<string, object> CustomMetadata { get; init; }\n}\npublic class SecurityContext {\n    // User information\n    public Guid UserId { get; init; }\n    public string UserName { get; init; }\n    public IReadOnlyList<string> Roles { get; init; }\n    // Multi-tenancy\n    public Guid",
        "startIndex": 0,
        "preview": "Projection Contexts\nWhizbang provides two types of context for projections:\nEventContext - Rich event metadata (pure data, no side effects)\nProjection..."
      },
      {
        "id": "projections/projection-contexts-chunk-1",
        "text": "{ get; init; } // Custom system metadata (extensible) public IReadOnlyDictionary<string, object> CustomMetadata { get; init; } } public class SecurityContext { // User information public Guid UserId { get; init; } public string UserName { get; init; } public IReadOnlyList<string> Roles { get; init; } // Multi-tenancy public Guid TenantId { get; init; }\n    public string TenantName { get; init; }\n    // Permissions (evaluated at command/event creation time)\n    public IReadOnlyList<string> Permissions { get; init; }\n    // Service trust boundary\n    public bool IsTrustedService { get; init; }\n    public string ServiceName { get; init; }\n}\npublic class EventMetadata {\n    // Event identification\n    public Guid EventId { get; init; }\n    public string EventType { get; init; }\n    public int EventVersion { get; init; }\n    // Causation (what caused this event)\n    public Guid CausationId { get; init; }  // Command that caused this event\n    public string CausationType { get; init; }\n    // Custom event metadata\n    public IReadOnlyDictionary<string, object> CustomMetadata { get; init; }\n}\npublic class TracingContext {\n    // Distributed tracing\n    public string CorrelationId { get; init; }  // End-to-end request tracking\n    public string TraceId { get; init; }        // OpenTelemetry trace ID\n    public string SpanId { get; init; }         // OpenTelemetry span ID\n    // Message journey\n    public int HopCount { get; init; }          // Number of services traversed\n    public DateTime InitiatedAt { get; init; }  // When the original request started\n}\n`\nEventContext Usage Example\n`csharp{\ntitle: \"EventContext Usage in Projections\"\ndescription: \"Accessing system metadata, security context, and tracing information\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"EventContext\", \"Security\", \"Multi-Tenancy\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading",
        "startIndex": 2543,
        "preview": "{ get; init; } // Custom system metadata (extensible) public IReadOnlyDictionary<string, object> CustomMetadata { get; init; } } public class Security..."
      },
      {
        "id": "projections/projection-contexts-chunk-2",
        "text": "Example `csharp{ title: \"EventContext Usage in Projections\" description: \"Accessing system metadata, security context, and tracing information\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Projections\", \"EventContext\", \"Security\", \"Multi-Tenancy\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"] usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading; using System Threading Tasks;\n[WhizbangProjection]\npublic class TenantOrderHistoryProjection {\n    private readonly Dictionary<Guid, List<TenantOrderRecord>> _ordersByTenant = new();\n    public Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        EventContext context,\n        CancellationToken ct) {\n        // Use security context for tenant isolation\n        if ( context Security TenantId HasValue) {\n            throw new InvalidOperationException(\"TenantId is required for order events\");\n        }\n        var tenantId = context Security TenantId Value;\n        // Create tenant-scoped record with rich context\n        var record = new TenantOrderRecord {\n            OrderId = @event OrderId,\n            TenantId = tenantId,\n            TenantName = context Security TenantName,\n            CustomerId = @event CustomerId,\n            Total = @event Total,\n            // System metadata\n            PlacedAt = context System Timestamp,\n            PlacedBy = context Security UserName,\n            PlacedByUserId = context Security UserId,\n            // Tracing\n            CorrelationId = context Tracing CorrelationId,\n            OriginatedAt = context Tracing InitiatedAt,\n            // Event metadata\n            EventId = context Event EventId,\n            CausationId = context Event CausationId  // The PlaceOrder command ID\n        };\n        if ( _ordersByTenant ContainsKey(tenantId)) {\n            _ordersByTenant[tenantId] = new List<TenantOrderRecord>();\n        }\n        _ordersByTenant[tenantId] Add(record);\n        return Task CompletedTask;\n    }\n    // Query methods (tenant-scoped)\n    public IEnumerable<TenantOrderRecord> GetOrdersForTenant(Guid tenantId) {\n        return _ordersByTenant TryGetValue(tenantId, out var orders) orders\n            : Enumerable Empty<TenantOrderRecord>();\n    }\n}\npublic record TenantOrderRecord {\n    public Guid OrderId { get; init; }\n    public Guid TenantId { get; init; }\n    public string TenantName { get; init; }\n    public Guid CustomerId { get; init; }\n    public decimal Total { get; init; }\n    // System metadata\n    public DateTime PlacedAt { get; init; }\n    public string PlacedBy { get; init; }\n    public Guid",
        "startIndex": 4306,
        "preview": "Example `csharp{ title: \"EventContext Usage in Projections\" description: \"Accessing system metadata, security context, and tracing information\" framew..."
      },
      {
        "id": "projections/projection-contexts-chunk-3",
        "text": "get; init; } public Guid TenantId { get; init; } public string TenantName { get; init; } public Guid CustomerId { get; init; } public decimal Total { get; init; } // System metadata public DateTime PlacedAt { get; init; } public string PlacedBy { get; init; } public Guid PlacedByUserId { get; init; }\n    // Tracing\n    public string CorrelationId { get; init; }\n    public DateTime OriginatedAt { get; init; }\n    // Event lineage\n    public Guid EventId { get; init; }\n    public Guid CausationId { get; init; }\n}\n`\nEventContext Benefits\nMulti-Tenancy: Access tenant context for data isolation\nSecurity: User, roles, permissions available for authorization\nAuditing: Track who did what and when\nTracing: End-to-end request tracking with correlation IDs\nCausation: Link events back to originating commands\nPure Data: All context is immutable, enabling pure function projections\nExtensible: Custom metadata dictionaries for app-specific data\nPurity Guarantees\nEventContext is designed to maintain projection purity:\nImmutable: All properties are init-only\nNo side effects: Contains only data, no methods with side effects\nNo I/O: No database, file system, or network access\nDeterministic: Same event + context always produces same projection state\nRoslyn Analyzers: Whizbang Analyzers enforces purity rules at compile time\n---\nProjectionContext Injection\nWhile EventContext is pure data, ProjectionContext provides database operations and projection metadata It can be injected at the method level or constructor level",
        "startIndex": 6516,
        "preview": "get; init; } public Guid TenantId { get; init; } public string TenantName { get; init; } public Guid CustomerId { get; init; } public decimal Total { ..."
      },
      {
        "id": "projections/projection-contexts-chunk-4",
        "text": "system, or network access Deterministic: Same event + context always produces same projection state Roslyn Analyzers: Whizbang Analyzers enforces purity rules at compile time --- ProjectionContext Injection While EventContext is pure data, ProjectionContext provides database operations and projection metadata It can be injected at the method level or constructor level ProjectionContext Structure\n`csharp\npublic class ProjectionContext {\n    // Projection metadata\n    public ProjectionMetadata Projection { get; init; }\n    // Service information\n    public ServiceMetadata Service { get; init; }\n    // Database operations (Create, Update, Patch, Delete)\n    public IProjectionStore Store { get; init; }\n}\npublic class ProjectionMetadata {\n    public string ProjectionName { get; init; }\n    public string ProjectionVersion { get; init; }\n    public Type ProjectionType { get; init; }\n    public DateTime StartedAt { get; init; }\n    // Custom projection metadata\n    public IReadOnlyDictionary<string, object> CustomMetadata { get; init; }\n}\npublic class ServiceMetadata {\n    public string ServiceName { get; init; }\n    public string ServiceVersion { get; init; }\n    public string Environment { get; init; }\n    public string MachineName { get; init; }\n}\npublic interface IProjectionStore {\n    // Create\n    Task CreateAsync<TProjection>(TProjection projection, CancellationToken ct = default)\n        where TProjection : class;\n    // Read (for checking existence or retrieving current state)\n    Task<TProjection",
        "startIndex": 7767,
        "preview": "system, or network access Deterministic: Same event + context always produces same projection state Roslyn Analyzers: Whizbang Analyzers enforces puri..."
      },
      {
        "id": "projections/projection-contexts-chunk-5",
        "text": "} public string ServiceVersion { get; init; } public string Environment { get; init; } public string MachineName { get; init; } } public interface IProjectionStore { // Create Task CreateAsync<TProjection>(TProjection projection, CancellationToken ct = default) where TProjection : class; // Read (for checking existence or retrieving current state) Task<TProjection > GetAsync<TProjection>(object key, CancellationToken ct = default)\n        where TProjection : class;\n    // Update (replace entire document)\n    Task UpdateAsync<TProjection>(object key, TProjection projection, CancellationToken ct = default)\n        where TProjection : class;\n    // Patch (partial update)\n    Task PatchAsync<TProjection>(object key, Action<TProjection> patchAction, CancellationToken ct = default)\n        where TProjection : class;\n    // Delete\n    Task DeleteAsync<TProjection>(object key, CancellationToken ct = default)\n        where TProjection : class;\n    // Batch operations\n    Task CreateManyAsync<TProjection>(IEnumerable<TProjection> projections, CancellationToken ct = default)\n        where TProjection : class;\n}\n// Return values for projection methods\npublic enum ProjectionReturnType {\n    Accepted,  // Event was processed successfully (default)\n    Ignored    // Event was intentionally ignored/skipped\n}\npublic static class ProjectionContextExtensions {\n    // Return a projection outcome (metadata only, no side effects)\n    public static Task Return(this ProjectionContext context, ProjectionReturnType returnType) {\n        context RecordOutcome(returnType);\n        return Task CompletedTask;\n    }\n}\n`\nProjectionContext Usage Examples\nSee the complete examples in Projection Return Values ProjectionContext Benefits\nDatabase Operations: Built-in CRUD operations (Create, Update, Patch, Delete)\nProjection Metadata: Access projection name, version, and custom metadata\nService Context: Know which service and environment the projection is running in\nFlexible Injection: Inject at method or constructor level based on your needs\nBatch Operations: Efficient bulk creates for high-throughput scenarios\nReturn Values: Signal processing outcomes with Return() method\n---\nNext Steps\nProjection Subscriptions - Event subscription patterns\nProjection Purity - Maintaining pure, deterministic projections\nProjection Return Values - Using return values for observability",
        "startIndex": 8920,
        "preview": "} public string ServiceVersion { get; init; } public string Environment { get; init; } public string MachineName { get; init; } } public interface IPr..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "projections/projection-purity",
    "title": "Projection Purity",
    "category": "Projections",
    "url": "/docs/projections/projection-purity",
    "chunks": [
      {
        "id": "projections/projection-purity-chunk-0",
        "text": "Projection Purity\nCRITICAL: Projections must be pure functions and deterministic The same event must ALWAYS produce the same projection state, regardless of when it's processed The Purity Rule\nProjections are read-side transformations that convert event data into queryable read models They must:\nBe deterministic (same input = same output)\nHave no side effects\nUse only data from events or EventContext\nNever perform business logic\nGood vs Bad Projections\n✅ Good Projection (Pure)\n`csharp{\ntitle: \"Pure Projection Example\"\ndescription: \"Correct projection using only event data and EventContext\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Purity\", \"Best Practices\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class GoodProjection {\n    // ✅ CORRECT: Use event timestamp from EventContext\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        EventContext eventContext,\n        CancellationToken ct) {\n        var summary = new OrderSummary {\n            OrderId = @event OrderId,\n            PlacedAt = eventContext System Timestamp,  // ✅ Deterministic\n            ExpiresAt = @event ExpiresAt,              // ✅ From event (business logic set this)\n            CustomerId = @event CustomerId,\n            Total = @event Total\n        };\n        await projection Store CreateAsync(summary, ct);\n    }\n    // ✅ CORRECT: Business logic decision in event, not projection\n    public Task OnOrderPlaced2(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // Event already contains IsExpired flag (set by business logic)\n        if (@event IsExpired) {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Process non-expired order\n        return Task CompletedTask;\n    }\n    // ✅ CORRECT: Use data from event or context\n    public async Task OnOrderShipped(\n        [WhizbangSubscribe] OrderShipped @event,\n        ProjectionContext projection,\n        EventContext eventContext,\n        CancellationToken ct) {\n        await projection Store PatchAsync<OrderSummary>(\n            @event OrderId,\n            order => {\n                order Status = \"Shipped\";\n                order ShippedAt = eventContext System Timestamp;  // ✅ From context\n                order TrackingNumber = @event",
        "startIndex": 0,
        "preview": "Projection Purity\nCRITICAL: Projections must be pure functions and deterministic The same event must ALWAYS produce the same projection state, regardl..."
      },
      {
        "id": "projections/projection-purity-chunk-1",
        "text": "// ✅ CORRECT: Use data from event or context public async Task OnOrderShipped( [WhizbangSubscribe] OrderShipped @event, ProjectionContext projection, EventContext eventContext, CancellationToken ct) { await projection Store PatchAsync<OrderSummary>( @event OrderId, order => { order Status = \"Shipped\"; order ShippedAt = eventContext System Timestamp; // ✅ From context order TrackingNumber = @event TrackingNumber;      // ✅ From event\n            },\n            ct);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public DateTime PlacedAt { get; set; }\n    public DateTime ExpiresAt { get; set; }\n    public Guid CustomerId { get; set; }\n    public decimal Total { get; set; }\n    public string Status { get; set; }\n    public DateTime ShippedAt { get; set; }\n    public string TrackingNumber { get; set; }\n}\n`\n❌ Bad Projection (Impure)\n`csharp{\ntitle: \"Impure Projection Example\"\ndescription: \"Common purity violations and how to avoid them\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Anti-Patterns\", \"Common Mistakes\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System IO\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System IO;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class BadProjection {\n    // ❌ WRONG: DateTime UtcNow is non-deterministic\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        var summary = new OrderSummary {\n            OrderId = @event OrderId,\n            PlacedAt = DateTime UtcNow,  // ❌ NON-DETERMINISTIC - Will be different on replay };\n        await projection Store CreateAsync(summary, ct);\n        // 💥 Whizbang Analyzers will flag this as a compile error\n    }\n    // ❌ WRONG: Business logic in projection\n    public Task OnOrderPlaced2(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        EventContext eventContext,\n        CancellationToken ct) {\n        // ❌ WRONG: Calculating expiration in projection is business logic\n        var age = DateTime UtcNow - eventContext System Timestamp;  // ❌ Non-deterministic\n        if (age > TimeSpan FromDays(90)) {\n            return projection Return(ProjectionReturnType",
        "startIndex": 2639,
        "preview": "// ✅ CORRECT: Use data from event or context public async Task OnOrderShipped( [WhizbangSubscribe] OrderShipped @event, ProjectionContext projection, ..."
      },
      {
        "id": "projections/projection-purity-chunk-2",
        "text": "❌ WRONG: Business logic in projection public Task OnOrderPlaced2( [WhizbangSubscribe] OrderPlaced @event, ProjectionContext projection, EventContext eventContext, CancellationToken ct) { // ❌ WRONG: Calculating expiration in projection is business logic var age = DateTime UtcNow - eventContext System Timestamp; // ❌ Non-deterministic if (age > TimeSpan FromDays(90)) { return projection Return(ProjectionReturnType Ignored);\n        }\n        // Business logic belongs in command handler or aggregate, not projection return Task CompletedTask;\n        // 💥 Whizbang Analyzers will flag DateTime UtcNow usage\n    }\n    // ❌ WRONG: Random values\n    public async Task OnOrderPlaced3(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        var summary = new OrderSummary {\n            OrderId = @event OrderId,\n            RandomValue = Random Shared Next()  // ❌ NON-DETERMINISTIC\n        };\n        await projection Store CreateAsync(summary, ct);\n        // 💥 Whizbang Analyzers will flag Random usage\n    }\n    // ❌ WRONG: External I/O in projection\n    public async Task OnOrderPlaced4(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        HttpClient httpClient,\n        CancellationToken ct) {\n        // ❌ WRONG: Calling external API is non-deterministic\n        var customerData = await httpClient GetAsync($\"https://api/customers/{@event CustomerId}\");\n        // External data can change - not deterministic // 💥 Whizbang Analyzers will flag external I/O\n    }\n    // ❌ WRONG: File I/O in projection\n    public async Task OnOrderPlaced5(\n        [WhizbangSubscribe] OrderPlaced @event,\n        CancellationToken ct) {\n        // ❌ WRONG: File writes are side effects\n        await File WriteAllTextAsync(\"orders log\", @event OrderId ToString());\n        // 💥 Whizbang Analyzers will flag file I/O\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public DateTime PlacedAt { get; set; }\n    public int RandomValue { get; set; }\n}\n`\nPurity Rules\nProjections must follow these rules to remain pure and deterministic:\n| ❌ NEVER Use | ✅ Instead Use | Why |\n|-----------------|-------------------|---------|\n| DateTime UtcNow | eventContext System Timestamp | Current time is non-deterministic |\n| DateTime Now | eventContext System",
        "startIndex": 4666,
        "preview": "❌ WRONG: Business logic in projection public Task OnOrderPlaced2( [WhizbangSubscribe] OrderPlaced @event, ProjectionContext projection, EventContext e..."
      },
      {
        "id": "projections/projection-purity-chunk-3",
        "text": "RandomValue { get; set; } } ` Purity Rules Projections must follow these rules to remain pure and deterministic: | ❌ NEVER Use | ✅ Instead Use | Why | |-----------------|-------------------|---------| | DateTime UtcNow | eventContext System Timestamp | Current time is non-deterministic | | DateTime Now | eventContext System Timestamp | Current time is non-deterministic |\n| Random / Guid NewGuid() | Data from event or context | Random values are non-deterministic |\n| External API calls | Data in event | External data can change |\n| Database reads (outside projection store) | Data in event | External data can change |\n| File I/O | Data in event | External data can change |\n| Environment variables | eventContext or config in event | Environment can change |\n| Business logic calculations | Business logic sets flags in event | Projections transform, don't decide |\nWhere Business Logic Belongs\nBusiness logic must live in command handlers and aggregates, NOT in projections ✅ Correct: Business Logic in Command Handler\n`csharp{\ntitle: \"Business Logic in Command Handler\"\ndescription: \"Correct placement of business logic and decision-making\"\nframework: \"NET8\"\ncategory: \"Command Handling\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Command Handlers\", \"Business Logic\", \"Best Practices\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n// ✅ CORRECT: Business logic in command handler or aggregate\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderPlaced> {\n    public async Task<OrderPlaced> Handle(\n        PlaceOrder command,\n        CommandContext context,\n        CancellationToken ct) {\n        // ✅ Business logic happens HERE\n        // - Validate the order\n        // - Check inventory\n        // - Calculate totals\n        // - Apply business rules\n        // - Decide if order should be marked as expired\n        var expiresAt = DateTime UtcNow",
        "startIndex": 6647,
        "preview": "RandomValue { get; set; } } ` Purity Rules Projections must follow these rules to remain pure and deterministic: | ❌ NEVER Use | ✅ Instead Use | Why |..."
      },
      {
        "id": "projections/projection-purity-chunk-4",
        "text": "public async Task<OrderPlaced> Handle( PlaceOrder command, CommandContext context, CancellationToken ct) { // ✅ Business logic happens HERE // - Validate the order // - Check inventory // - Calculate totals // - Apply business rules // - Decide if order should be marked as expired var expiresAt = DateTime UtcNow AddDays(90);  // ✅ Business decision\n        var isExpired = false;  // ✅ Business decision\n        var status = \"Placed\";   // ✅ Business decision\n        // Create event POCO with results of business logic\n        // Event is just a data container - NO logic in the event class itself\n        var @event = context EmitEvent(new OrderPlaced {\n            OrderId = command OrderId,\n            CustomerId = command CustomerId,\n            Total = command Total,\n            ExpiresAt = expiresAt,      // ✅ Set by handler\n            IsExpired = isExpired,       // ✅ Set by handler\n            Status = status              // ✅ Set by handler\n        });\n        return @event;\n    }\n}\n// ✅ CORRECT: Event is just a POCO (Plain Old CLR Object)\n// NO business logic, NO methods (except maybe ToString for debugging)\n// Just immutable data describing what happened\npublic record OrderPlaced {\n    public Guid OrderId { get; init; }\n    public Guid CustomerId { get; init; }\n    public decimal Total { get; init; }\n    public DateTime ExpiresAt { get; init; }     // ✅ Data only\n    public bool IsExpired { get; init; }         // ✅ Data only\n    public string Status { get; init; }          // ✅ Data only\n    // ❌ NO business logic methods like:\n    // public bool ShouldExpire() => DateTime",
        "startIndex": 8342,
        "preview": "public async Task<OrderPlaced> Handle( PlaceOrder command, CommandContext context, CancellationToken ct) { // ✅ Business logic happens HERE // - Valid..."
      },
      {
        "id": "projections/projection-purity-chunk-5",
        "text": "{ get; init; } public DateTime ExpiresAt { get; init; } // ✅ Data only public bool IsExpired { get; init; } // ✅ Data only public string Status { get; init; } // ✅ Data only // ❌ NO business logic methods like: // public bool ShouldExpire() => DateTime UtcNow > ExpiresAt;\n    // public void MarkAsExpired() => IsExpired = true;\n    // Events are immutable data - handlers make decisions, events record them\n}\n// ✅ CORRECT: Projection just transforms event data\n[WhizbangProjection]\npublic class OrderProjection {\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // ✅ No business logic - just transform POCO event to read model\n        var summary = new OrderSummary {\n            OrderId = @event OrderId,\n            ExpiresAt = @event ExpiresAt,    // ✅ Copy from event (handler set this)\n            IsExpired = @event IsExpired,     // ✅ Copy from event (handler set this)\n            Status = @event Status            // ✅ Copy from event (handler set this)\n        };\n        if (@event IsExpired) {\n            // Simple filtering based on event data (not a business decision)\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        await projection Store CreateAsync(summary, ct);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public DateTime ExpiresAt { get; set; }\n    public bool IsExpired { get; set; }\n    public string Status { get; set; }\n}\n`\nThe Three-Layer Architecture\nWhizbang enforces a clear separation of concerns:\n`mermaid\ngraph TB\n    subgraph BusinessLogic[\"Command Handler / Aggregate (Business Logic Layer)\"]\n        BL1[\"✅ Validates commands\"]\n        BL2[\"✅ Applies business rules\"]\n        BL3[\"✅ Makes decisions\"]\n        BL4[\"✅ Creates event POCOs with results\"]\n        BL5[\"✅ CAN emit commands (sagas)\"]\n        BL6[\"✅ CAN use DateTime",
        "startIndex": 9635,
        "preview": "{ get; init; } public DateTime ExpiresAt { get; init; } // ✅ Data only public bool IsExpired { get; init; } // ✅ Data only public string Status { get;..."
      },
      {
        "id": "projections/projection-purity-chunk-6",
        "text": "set; } } ` The Three-Layer Architecture Whizbang enforces a clear separation of concerns: `mermaid graph TB subgraph BusinessLogic[\"Command Handler / Aggregate (Business Logic Layer)\"] BL1[\"✅ Validates commands\"] BL2[\"✅ Applies business rules\"] BL3[\"✅ Makes decisions\"] BL4[\"✅ Creates event POCOs with results\"] BL5[\"✅ CAN emit commands (sagas)\"] BL6[\"✅ CAN use DateTime UtcNow, Random, APIs\"]\n    end\n    subgraph DataLayer[\"Data Layer (POCOs - No Logic)\"]\n        Event[\"Event<br/>- Properties only<br/>- NO methods<br/>- Describes what happened\"]\n        Command[\"Command<br/>- Properties only<br/>- NO methods<br/>- Describes intent\"]\n    end\n    subgraph ReadModel[\"Projection (Read Model Layer)\"]\n        P1[\"✅ Pure transformation of event data\"]\n        P2[\"❌ NO business logic\"]\n        P3[\"❌ NO DateTime UtcNow, Random, APIs\"]\n        P4[\"✅ ONLY event data or EventContext\"]\n        P5[\"✅ Deterministic and replayable\"]\n    end\n    BusinessLogic -->|Emits Events| Event\n    BusinessLogic -->|Emits Commands| Command\n    Event -->|Consumed by| ReadModel\n    Command -->|Handled by| BusinessLogic\n    style BusinessLogic fill:#d4edda,stroke:#28a745,stroke-width:2px\n    style DataLayer fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    style ReadModel fill:#cce5ff,stroke:#004085,stroke-width:2px\n    style Event fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    style Command fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n`\nWhy Purity Matters\nReplay: Events can be replayed to rebuild projections - must produce same result\nTesting: Pure functions are easy to test - same input, same output\nDebugging: Deterministic behavior makes bugs reproducible\nScaling: Multiple projection instances can process same events safely\nTime Travel: Can replay events from any point in time\nAuditing: Projection state is always verifiable from event stream\nDisaster Recovery: Projections can be rebuilt from events after data loss\nBlue/Green Deployments: New projection version can process same events\nWhizbang Analyzers Enforcement\nThe Whizbang Analyzers package enforces purity at compile time:\n`csharp{\ntitle: \"Analyzer Enforcement Example\"\ndescription: \"Compile-time purity validation with Whizbang Analyzers\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Analyzers\", \"Purity\", \"Compile-Time Validation\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\", \"Whizbang Analyzers\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading",
        "startIndex": 11329,
        "preview": "set; } } ` The Three-Layer Architecture Whizbang enforces a clear separation of concerns: `mermaid graph TB subgraph BusinessLogic[\"Command Handler / ..."
      },
      {
        "id": "projections/projection-purity-chunk-7",
        "text": "compile time: `csharp{ title: \"Analyzer Enforcement Example\" description: \"Compile-time purity validation with Whizbang Analyzers\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Analyzers\", \"Purity\", \"Compile-Time Validation\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\", \"Whizbang Analyzers\"] usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading; using System Threading Tasks;\n[WhizbangProjection]\npublic class OrderProjection {\n    private readonly ILogger _logger;  // ⚠️ Warning: Injected services should be read-only\n    // ✅ VALID - Pure projection handler\n    public Task Handle([WhizbangSubscribe] OrderPlaced @event, EventContext context, CancellationToken ct) {\n        // Pure state updates only\n        var summary = new OrderSummary {\n            PlacedAt = context System Timestamp  // ✅ OK - from context\n        };\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - Side effect detected (logging)\n    public Task Handle([WhizbangSubscribe] OrderShipped @event, CancellationToken ct) {\n        _logger LogInformation(\"Order shipped\");  // 💥 WBG001: Side effect in projection\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - DateTime UtcNow usage\n    public Task Handle([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) {\n        var cancelledAt = DateTime UtcNow;  // 💥 WBG002: Non-deterministic time source\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - Random value generation\n    public Task Handle([WhizbangSubscribe] OrderCompleted @event, CancellationToken ct) {\n        var random = Random Shared Next();  // 💥 WBG003: Non-deterministic random source\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - External I/O detected\n    public async Task Handle([WhizbangSubscribe] OrderRefunded @event, CancellationToken ct) {\n        await File WriteAllTextAsync(\"log txt\", \"refunded\");  // 💥 WBG004: I/O in projection\n    }\n}\npublic class OrderSummary {\n    public DateTime PlacedAt { get; set; }\n}\n`\nAnalyzer Error Codes\nWBG001: Side effect detected in projection (logging, console writes, etc )\nWBG002: Non-deterministic time source (DateTime UtcNow, DateTime Now)\nWBG003: Non-deterministic random source (Random, Guid NewGuid())\nWBG004: I/O operation detected (file system, network, external database)\nWBG005: Database operation outside ProjectionContext",
        "startIndex": 13523,
        "preview": "compile time: `csharp{ title: \"Analyzer Enforcement Example\" description: \"Compile-time purity validation with Whizbang Analyzers\" framework: \"NET8\" c..."
      },
      {
        "id": "projections/projection-purity-chunk-8",
        "text": "PlacedAt { get; set; } } ` Analyzer Error Codes WBG001: Side effect detected in projection (logging, console writes, etc ) WBG002: Non-deterministic time source (DateTime UtcNow, DateTime Now) WBG003: Non-deterministic random source (Random, Guid NewGuid()) WBG004: I/O operation detected (file system, network, external database) WBG005: Database operation outside ProjectionContext Store\nWBG006: Environment variable access\nWBG007: Complex business logic detected in projection (warning)\nPurity Checklist\nBefore merging projection code, verify:\n[ ] No DateTime UtcNow or DateTime Now usage\n[ ] No Random or Guid NewGuid() calls\n[ ] No external API calls (HTTP, gRPC, etc )\n[ ] No file system operations\n[ ] No logging or console writes\n[ ] No database operations outside ProjectionContext Store\n[ ] No environment variable reads\n[ ] All timestamps from EventContext System Timestamp\n[ ] All business decisions from event data (not calculated in projection)\n[ ] Whizbang Analyzers passes with no errors\nSummary\nProjections = Pure transformations of event data into read models\nBusiness Logic = Command handlers and aggregates that make decisions and emit events\nEvents = POCOs describing what happened (no logic)\nDeterminism = Same event always produces same projection state\nWhizbang Analyzers = Compile-time enforcement of purity rules\nNext Steps\nProjection Subscriptions - Event subscription patterns\nProjection Contexts - EventContext and ProjectionContext injection\nProjection Return Values - Using return values for observability",
        "startIndex": 15479,
        "preview": "PlacedAt { get; set; } } ` Analyzer Error Codes WBG001: Side effect detected in projection (logging, console writes, etc ) WBG002: Non-deterministic t..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "projections/projection-return-values",
    "title": "Projection Return Values",
    "category": "Projections",
    "url": "/docs/projections/projection-return-values",
    "chunks": [
      {
        "id": "projections/projection-return-values-chunk-0",
        "text": "Projection Return Values\nProjection methods can return metadata about the processing outcome using ProjectionContext Return() This is metadata only with no side effects - it's purely for observability and metrics ProjectionReturnType Enum\n`csharp\npublic enum ProjectionReturnType {\n    Accepted,  // Event was processed successfully (default)\n    Ignored    // Event was intentionally ignored/skipped\n}\n`\nReturn Value Semantics\n| Return Type | Meaning | Use When | Metrics Impact |\n|------------|---------|----------|----------------|\n| Accepted | Event was processed successfully | Default behavior, projection state updated | Increments events_processed counter |\n| Ignored | Event was intentionally skipped | Filtering, tenant isolation, deduplication | Increments events_ignored counter |\nBasic Usage\n`csharp{\ntitle: \"Basic Projection Return Values\"\ndescription: \"Using return values to signal projection processing outcomes\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"BEGINNER\"\ntags: [\"Projections\", \"Return Values\", \"Observability\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class OrderProjection {\n    // Example 1: Explicit Accepted return (default behavior)\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        await projection Store CreateAsync(new OrderSummary {\n            OrderId = @event OrderId,\n            Status = \"Placed\"\n        }, ct);\n        // Explicitly signal success (optional - this is the default)\n        return projection Return(ProjectionReturnType Accepted);\n    }\n    // Example 2: Implicit Accepted (no return statement)\n    public async Task OnOrderShipped(\n        [WhizbangSubscribe] OrderShipped @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        await projection Store PatchAsync<OrderSummary>(\n            @event OrderId,\n            order => order Status = \"Shipped\",\n            ct);\n        // No explicit return = Accepted (default)\n    }\n    // Example 3: Ignored return (event intentionally skipped)\n    public Task OnOrderEvent(\n        [WhizbangSubscribe] OrderEvent @event,\n        ProjectionContext projection,\n        EventContext eventContext,\n        CancellationToken ct) {\n        // Only process events for current tenant\n        if (eventContext Security TenantId = projection Service CurrentTenantId) {\n            // Different tenant - ignore this event\n            return projection Return(ProjectionReturnType",
        "startIndex": 0,
        "preview": "Projection Return Values\nProjection methods can return metadata about the processing outcome using ProjectionContext Return() This is metadata only wi..."
      },
      {
        "id": "projections/projection-return-values-chunk-1",
        "text": "Accepted (default) } // Example 3: Ignored return (event intentionally skipped) public Task OnOrderEvent( [WhizbangSubscribe] OrderEvent @event, ProjectionContext projection, EventContext eventContext, CancellationToken ct) { // Only process events for current tenant if (eventContext Security TenantId = projection Service CurrentTenantId) { // Different tenant - ignore this event return projection Return(ProjectionReturnType Ignored);\n        }\n        // Process the event\n        // return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public string Status { get; set; }\n}\n`\nCommon Use Cases for Ignored\nTenant Isolation\n`csharp{\ntitle: \"Tenant Isolation with Return Values\"\ndescription: \"Using Ignored to skip events for different tenants\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Multi-Tenancy\", \"Filtering\", \"Return Values\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class TenantOrderProjection {\n    private readonly Guid _currentTenantId;\n    public TenantOrderProjection(Guid currentTenantId) {\n        _currentTenantId = currentTenantId;\n    }\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        EventContext eventContext,\n        CancellationToken ct) {\n        // Skip events for other tenants\n        if (eventContext Security TenantId = _currentTenantId) {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Process event for current tenant\n        await projection Store CreateAsync(new OrderSummary {\n            OrderId = @event OrderId,\n            TenantId = _currentTenantId,\n            Status = \"Placed\"\n        }, ct);\n        return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public Guid TenantId { get; set; }\n    public string Status { get; set; }\n}\n`\nVersion Checking and Deduplication\n`csharp{\ntitle: \"Version Checking and Deduplication\"\ndescription: \"Using Ignored to skip out-of-order or duplicate events\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Deduplication\", \"Versioning\", \"Return Values\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading",
        "startIndex": 2742,
        "preview": "Accepted (default) } // Example 3: Ignored return (event intentionally skipped) public Task OnOrderEvent( [WhizbangSubscribe] OrderEvent @event, Proje..."
      },
      {
        "id": "projections/projection-return-values-chunk-2",
        "text": "Deduplication `csharp{ title: \"Version Checking and Deduplication\" description: \"Using Ignored to skip out-of-order or duplicate events\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Deduplication\", \"Versioning\", \"Return Values\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"] usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading; using System Threading Tasks;\n[WhizbangProjection]\npublic class VersionedOrderProjection {\n    public async Task OnOrderUpdated(\n        [WhizbangSubscribe] OrderUpdated @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // Get current projection state\n        var current = await projection Store GetAsync<OrderSummary>(@event OrderId, ct);\n        // Ignore if projection doesn't exist (might be deleted)\n        if (current == null) {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Ignore if event is older than current state (out-of-order delivery)\n        if (@event Version <= current Version) {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Update the projection\n        await projection Store UpdateAsync(@event OrderId, new OrderSummary {\n            OrderId = @event OrderId,\n            Version = @event Version,\n            Status = @event Status\n        }, ct);\n        return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public int Version { get; set; }\n    public string Status { get; set; }\n}\n`\nEvent Data Filtering\n`csharp{\ntitle: \"Event Data Filtering\"\ndescription: \"Using Ignored to filter based on event flags set by business logic\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Filtering\", \"Event Data\", \"Return Values\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class ActiveOrderProjection {\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // ✅ CORRECT: Business logic already set IsExpired in the event\n        // The command handler made this decision, projection just filters\n        if (@event IsExpired) {\n            // Event already marked as expired by business logic\n            return projection Return(ProjectionReturnType",
        "startIndex": 5034,
        "preview": "Deduplication `csharp{ title: \"Version Checking and Deduplication\" description: \"Using Ignored to skip out-of-order or duplicate events\" framework: \"N..."
      },
      {
        "id": "projections/projection-return-values-chunk-3",
        "text": "{ public async Task OnOrderPlaced( [WhizbangSubscribe] OrderPlaced @event, ProjectionContext projection, CancellationToken ct) { // ✅ CORRECT: Business logic already set IsExpired in the event // The command handler made this decision, projection just filters if (@event IsExpired) { // Event already marked as expired by business logic return projection Return(ProjectionReturnType Ignored);\n        }\n        // Process non-expired event\n        await projection Store CreateAsync(new OrderSummary {\n            OrderId = @event OrderId,\n            Status = \"Active\"\n        }, ct);\n        return projection Return(ProjectionReturnType Accepted);\n    }\n    public async Task OnOrderStatusChanged(\n        [WhizbangSubscribe] OrderStatusChanged @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // Only track \"active\" status changes\n        if (@event NewStatus = \"Active\") {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        await projection Store PatchAsync<OrderSummary>(\n            @event OrderId,\n            order => order Status = @event NewStatus,\n            ct);\n        return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public string Status { get; set; }\n}\n`\nFeature Flag Filtering\n`csharp{\ntitle: \"Feature Flag Filtering\"\ndescription: \"Using Ignored to skip events when features are disabled\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"ADVANCED\"\ntags: [\"Feature Flags\", \"Configuration\", \"Return Values\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class NotificationProjection {\n    private readonly IFeatureFlagService _featureFlags;\n    public NotificationProjection(IFeatureFlagService featureFlags) {\n        _featureFlags = featureFlags;\n    }\n    public async Task OnOrderShipped(\n        [WhizbangSubscribe] OrderShipped @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // Skip if shipping notifications are disabled\n        // Feature flag is from config, not time-based (deterministic for replay)\n        if ( _featureFlags IsEnabled(\"ShippingNotifications\")) {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        await projection Store CreateAsync(new NotificationRecord {\n            EventId = @event OrderId,\n            Type = \"ShippingNotification\",\n            CreatedAt = DateTime UtcNow\n        }, ct);\n        return projection Return(ProjectionReturnType",
        "startIndex": 7225,
        "preview": "{ public async Task OnOrderPlaced( [WhizbangSubscribe] OrderPlaced @event, ProjectionContext projection, CancellationToken ct) { // ✅ CORRECT: Busines..."
      },
      {
        "id": "projections/projection-return-values-chunk-4",
        "text": "// Skip if shipping notifications are disabled // Feature flag is from config, not time-based (deterministic for replay) if ( _featureFlags IsEnabled(\"ShippingNotifications\")) { return projection Return(ProjectionReturnType Ignored); } await projection Store CreateAsync(new NotificationRecord { EventId = @event OrderId, Type = \"ShippingNotification\", CreatedAt = DateTime UtcNow }, ct); return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic interface IFeatureFlagService {\n    bool IsEnabled(string featureName);\n}\npublic class NotificationRecord {\n    public Guid EventId { get; set; }\n    public string Type { get; set; }\n    public DateTime CreatedAt { get; set; }\n}\n`\nProjection Existence Checking\n`csharp{\ntitle: \"Projection Existence Checking\"\ndescription: \"Using Ignored to skip updates to deleted projections\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Existence Checks\", \"Deleted Projections\", \"Return Values\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class OrderHistoryProjection {\n    public async Task OnOrderUpdated(\n        [WhizbangSubscribe] OrderUpdated @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // Check if projection exists\n        var existing = await projection Store GetAsync<OrderHistory>(@event OrderId, ct);\n        if (existing == null) {\n            // Projection was deleted or never created - ignore this update\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Update existing projection\n        await projection Store PatchAsync<OrderHistory>(\n            @event OrderId,\n            history => history UpdatedAt = DateTime UtcNow,\n            ct);\n        return projection Return(ProjectionReturnType Accepted);\n    }\n    public async Task OnOrderDeleted(\n        [WhizbangSubscribe] OrderDeleted @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        await projection Store DeleteAsync<OrderHistory>(@event OrderId, ct);\n        return projection Return(ProjectionReturnType",
        "startIndex": 9580,
        "preview": "// Skip if shipping notifications are disabled // Feature flag is from config, not time-based (deterministic for replay) if ( _featureFlags IsEnabled(..."
      },
      {
        "id": "projections/projection-return-values-chunk-5",
        "text": "update return projection Return(ProjectionReturnType Ignored); } // Update existing projection await projection Store PatchAsync<OrderHistory>( @event OrderId, history => history UpdatedAt = DateTime UtcNow, ct); return projection Return(ProjectionReturnType Accepted); } public async Task OnOrderDeleted( [WhizbangSubscribe] OrderDeleted @event, ProjectionContext projection, CancellationToken ct) { await projection Store DeleteAsync<OrderHistory>(@event OrderId, ct); return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic class OrderHistory {\n    public Guid OrderId { get; set; }\n    public DateTime UpdatedAt { get; set; }\n}\n`\nImportant Notes\nNo Side Effects: Return values are metadata only - they don't affect event flow or projection state\nDefault is Accepted: If you don't explicitly return, Accepted is assumed\nObservability: Return values are recorded for metrics, logging, and dashboard visualization\nNo Error Return: Errors should throw exceptions, not return a status code\nPure Metadata: Return values don't trigger any framework behavior - they're for observability\nMetrics and Observability\nReturn values enable rich metrics and dashboards:\n`csharp\n// Whizbang automatically tracks these metrics:\n// - whizbang_projection_events_accepted{projection=\"OrderProjection\", event=\"OrderPlaced\"}\n// - whizbang_projection_events_ignored{projection=\"OrderProjection\", event=\"OrderPlaced\"}\n// - whizbang_projection_acceptance_rate{projection=\"OrderProjection\"}\n// - whizbang_projection_throughput{projection=\"OrderProjection\"}\n`\nDashboard Visualization\nThe Whizbang Dashboard uses return values to show:\nProjection Health: Acceptance rate over time\nEvent Filtering: Which events are commonly ignored\nTenant Metrics: Events processed per tenant\nPerformance: Throughput and latency per projection\nDebugging: Identify misconfigured filters\nExample Metrics Query\n`promql\nProjection acceptance rate (should be high for normal operations)\nsum(rate(whizbang_projection_events_accepted[5m])) by (projection)\n/\nsum(rate(whizbang_projection_events_total[5m])) by (projection)\nEvents ignored by reason (for debugging)\nsum(rate(whizbang_projection_events_ignored[5m])) by (projection, reason)\nTenant-specific processing rate\nsum(rate(whizbang_projection_events_accepted[5m])) by (tenant_id)\n`\nBest Practices\nBe Explicit When Filtering\n`csharp\n// ✅ GOOD - Explicit and clear\nif (@event IsExpired) {\n    return projection Return(ProjectionReturnType Ignored);\n}\n// ❌ BAD - Implicit, unclear why event is ignored\nif (@event IsExpired) {\n    return Task",
        "startIndex": 11432,
        "preview": "update return projection Return(ProjectionReturnType Ignored); } // Update existing projection await projection Store PatchAsync<OrderHistory>( @event..."
      },
      {
        "id": "projections/projection-return-values-chunk-6",
        "text": "sum(rate(whizbang_projection_events_ignored[5m])) by (projection, reason) Tenant-specific processing rate sum(rate(whizbang_projection_events_accepted[5m])) by (tenant_id) ` Best Practices Be Explicit When Filtering `csharp // ✅ GOOD - Explicit and clear if (@event IsExpired) { return projection Return(ProjectionReturnType Ignored); } // ❌ BAD - Implicit, unclear why event is ignored if (@event IsExpired) { return Task CompletedTask;  // Looks like Accepted, but event wasn't processed\n}\n`\nUse Ignored for Intentional Filtering\n`csharp\n// ✅ GOOD - Intentional filtering (return Ignored)\nif (eventContext Security TenantId = _currentTenantId) {\n    return projection Return(ProjectionReturnType Ignored);\n}\n// ❌ BAD - Errors should throw exceptions, not return Ignored\ntry {\n    await projection Store CreateAsync(summary, ct);\n} catch (Exception) {\n    return projection Return(ProjectionReturnType Ignored);  // Wrong Throw the exception\n}\n`\nDocument Ignored Reasons\n`csharp\n// ✅ GOOD - Comment explains why event is ignored\npublic Task OnOrderPlaced(\n    [WhizbangSubscribe] OrderPlaced @event,\n    ProjectionContext projection,\n    EventContext eventContext,\n    CancellationToken ct) {\n    // Ignore events for other tenants - this projection is tenant-scoped\n    if (eventContext Security TenantId = _currentTenantId) {\n        return projection Return(ProjectionReturnType Ignored);\n    }\n    // Process event }\n`\nMonitor Acceptance Rates\nSet up alerts for low acceptance rates:\n`yaml\nPrometheus alert rule\nalert: LowProjectionAcceptanceRate\n  expr: |\n    sum(rate(whizbang_projection_events_accepted[5m])) by (projection)\n    /\n    sum(rate(whizbang_projection_events_total[5m])) by (projection)\n    < 0 5\n  for: 10m\n  annotations:\n    summary: \"Projection {{ $labels",
        "startIndex": 13477,
        "preview": "sum(rate(whizbang_projection_events_ignored[5m])) by (projection, reason) Tenant-specific processing rate sum(rate(whizbang_projection_events_accepted..."
      },
      {
        "id": "projections/projection-return-values-chunk-7",
        "text": "Security TenantId = _currentTenantId) { return projection Return(ProjectionReturnType Ignored); } // Process event } ` Monitor Acceptance Rates Set up alerts for low acceptance rates: `yaml Prometheus alert rule alert: LowProjectionAcceptanceRate expr: | sum(rate(whizbang_projection_events_accepted[5m])) by (projection) / sum(rate(whizbang_projection_events_total[5m])) by (projection) < 0 5 for: 10m annotations: summary: \"Projection {{ $labels projection }} has low acceptance rate\"\n    description: \"Less than 50% of events are being accepted\"\n`\nSummary\nReturn values are metadata only - no side effects\nDefault is Accepted - explicit return is optional\nUse Ignored for intentional filtering - tenant isolation, versioning, feature flags\nErrors should throw exceptions - not return Ignored\nMetrics enable observability - track acceptance rates, throughput, and health\nDashboard visualization - see projection health and filtering patterns\nNext Steps\nProjection Subscriptions - Event subscription patterns\nProjection Contexts - EventContext and ProjectionContext injection\nProjection Purity - Maintaining pure, deterministic projections",
        "startIndex": 14839,
        "preview": "Security TenantId = _currentTenantId) { return projection Return(ProjectionReturnType Ignored); } // Process event } ` Monitor Acceptance Rates Set up..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "projections/projection-subscriptions",
    "title": "Projection Subscriptions",
    "category": "Projections",
    "url": "/docs/projections/projection-subscriptions",
    "chunks": [
      {
        "id": "projections/projection-subscriptions-chunk-0",
        "text": "Projection Subscriptions\nWhizbang provides flexible event subscription patterns using the [WhizbangSubscribe] attribute Projections can subscribe to specific event types, base classes, interfaces, or use generic methods for maximum reusability Basic Subscription Pattern\nPlace [WhizbangSubscribe] directly on the method parameter representing the event:\n`csharp{\ntitle: \"Basic Event Subscription\"\ndescription: \"Simple event subscription pattern with flexible method naming\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"BEGINNER\"\ntags: [\"Projections\", \"Subscriptions\", \"Events\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class OrderHistoryProjection {\n    private readonly List<OrderSummary> _orders = new();\n    // ✅ Method names are flexible - use what makes sense\n    public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) {\n        _orders Add(new OrderSummary(@event OrderId, \"Placed\"));\n        return Task CompletedTask;\n    }\n    public Task On([WhizbangSubscribe] OrderShipped @event, CancellationToken ct) {\n        var order = _orders First(o => o OrderId == @event OrderId);\n        order Status = \"Shipped\";\n        return Task CompletedTask;\n    }\n    public Task When([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) {\n        _orders RemoveAll(o => o OrderId == @event OrderId);\n        return Task CompletedTask;\n    }\n    // Descriptive names work too\n    public Task OnOrderCompleted([WhizbangSubscribe] OrderCompleted @event, CancellationToken ct) {\n        var order = _orders First(o => o OrderId == @event OrderId);\n        order Status = \"Completed\";\n        return Task",
        "startIndex": 0,
        "preview": "Projection Subscriptions\nWhizbang provides flexible event subscription patterns using the [WhizbangSubscribe] attribute Projections can subscribe to s..."
      },
      {
        "id": "projections/projection-subscriptions-chunk-1",
        "text": "public Task When([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) { _orders RemoveAll(o => o OrderId == @event OrderId); return Task CompletedTask; } // Descriptive names work too public Task OnOrderCompleted([WhizbangSubscribe] OrderCompleted @event, CancellationToken ct) { var order = _orders First(o => o OrderId == @event OrderId); order Status = \"Completed\"; return Task CompletedTask;\n    }\n}\npublic record OrderSummary(Guid OrderId, string Status) {\n    public string Status { get; set; } = Status;\n}\n`\nSubscription Rules\nOne subscription per method: Only one parameter can have [WhizbangSubscribe] attribute\nAdditional parameters allowed: CancellationToken, EventContext, ProjectionContext, injected services\nFlexible naming: Use Handle, On, When, or any descriptive name\nAuto-registration: Source generator automatically wires subscriptions to service configuration\nSupports polymorphism: Subscribe to base classes or interfaces\nPolymorphic Subscriptions\nBase Class Subscriptions\nSubscribe to a base class to handle all derived event types:\n`csharp{\ntitle: \"Base Class Event Subscriptions\"\ndescription: \"Using base classes to handle multiple event types\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Polymorphism\", \"Base Classes\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n// Base class for all order events\npublic abstract record OrderEvent(Guid OrderId, DateTime Timestamp);\n// Derived event types\npublic record OrderPlaced(Guid OrderId, DateTime Timestamp, decimal Total)\n    : OrderEvent(OrderId, Timestamp);\npublic record OrderShipped(Guid OrderId, DateTime Timestamp, string TrackingNumber)\n    : OrderEvent(OrderId, Timestamp);\npublic record OrderCancelled(Guid OrderId, DateTime Timestamp, string Reason)\n    : OrderEvent(OrderId, Timestamp);\n[WhizbangProjection]\npublic class OrderAuditProjection {\n    private readonly List<AuditRecord> _auditLog = new();\n    // Single method handles ALL OrderEvent-derived types\n    public Task Handle([WhizbangSubscribe] OrderEvent @event, CancellationToken ct) {\n        // Common processing for all order events\n        LogAudit(@event OrderId, @event GetType() Name, @event",
        "startIndex": 1857,
        "preview": "public Task When([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) { _orders RemoveAll(o => o OrderId == @event OrderId); return Task C..."
      },
      {
        "id": "projections/projection-subscriptions-chunk-2",
        "text": "public record OrderCancelled(Guid OrderId, DateTime Timestamp, string Reason) : OrderEvent(OrderId, Timestamp); [WhizbangProjection] public class OrderAuditProjection { private readonly List<AuditRecord> _auditLog = new(); // Single method handles ALL OrderEvent-derived types public Task Handle([WhizbangSubscribe] OrderEvent @event, CancellationToken ct) { // Common processing for all order events LogAudit(@event OrderId, @event GetType() Name, @event Timestamp);\n        // Pattern matching for specific handling\n        return @event switch {\n            OrderPlaced placed => HandlePlaced(placed),\n            OrderShipped shipped => HandleShipped(shipped),\n            OrderCancelled cancelled => HandleCancelled(cancelled),\n            _ => Task CompletedTask\n        };\n    }\n    private Task HandlePlaced(OrderPlaced @event) {\n        _auditLog Add(new AuditRecord(\"Order placed with total: \" + @event Total));\n        return Task CompletedTask;\n    }\n    private Task HandleShipped(OrderShipped @event) {\n        _auditLog Add(new AuditRecord(\"Order shipped: \" + @event TrackingNumber));\n        return Task CompletedTask;\n    }\n    private Task HandleCancelled(OrderCancelled @event) {\n        _auditLog Add(new AuditRecord(\"Order cancelled: \" + @event Reason));\n        return Task CompletedTask;\n    }\n    private void LogAudit(Guid orderId, string eventType, DateTime timestamp) {\n        Console WriteLine($\"[{timestamp}] {eventType} - Order {orderId}\");\n    }\n}\npublic record AuditRecord(string Message);\n`\nInterface Subscriptions\nSubscribe to an interface to handle all implementing event types:\n`csharp{\ntitle: \"Interface Event Subscriptions\"\ndescription: \"Using interfaces to handle multiple event types\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Polymorphism\", \"Interfaces\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading;\nusing System Threading",
        "startIndex": 3841,
        "preview": "public record OrderCancelled(Guid OrderId, DateTime Timestamp, string Reason) : OrderEvent(OrderId, Timestamp); [WhizbangProjection] public class Orde..."
      },
      {
        "id": "projections/projection-subscriptions-chunk-3",
        "text": "Event Subscriptions\" description: \"Using interfaces to handle multiple event types\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Projections\", \"Polymorphism\", \"Interfaces\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"] usingStatements: [\"System\", \"System Collections Generic\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Collections Generic; using System Threading; using System Threading Tasks;\n// Interface for all inventory events\npublic interface IInventoryEvent {\n    Guid ProductId { get; }\n}\n// Event implementations\npublic record InventoryAdjusted(Guid ProductId, int Quantity) : IInventoryEvent;\npublic record InventoryReserved(Guid ProductId, int Quantity, Guid OrderId) : IInventoryEvent;\npublic record InventoryReleased(Guid ProductId, int Quantity, Guid OrderId) : IInventoryEvent;\n[WhizbangProjection]\npublic class InventoryProjection {\n    private readonly Dictionary<Guid, int> _stock = new();\n    // Single method handles ALL IInventoryEvent implementations\n    public Task Handle([WhizbangSubscribe] IInventoryEvent @event, CancellationToken ct) {\n        return @event switch {\n            InventoryAdjusted adjusted => HandleAdjusted(adjusted),\n            InventoryReserved reserved => HandleReserved(reserved),\n            InventoryReleased released => HandleReleased(released),\n            _ => Task CompletedTask\n        };\n    }\n    private Task HandleAdjusted(InventoryAdjusted @event) {\n        _stock[@event ProductId] = @event Quantity;\n        return Task CompletedTask;\n    }\n    private Task HandleReserved(InventoryReserved @event) {\n        if (_stock ContainsKey(@event ProductId)) {\n            _stock[@event ProductId] -= @event Quantity;\n        }\n        return Task CompletedTask;\n    }\n    private Task HandleReleased(InventoryReleased @event) {\n        if (_stock ContainsKey(@event ProductId)) {\n            _stock[@event ProductId] += @event Quantity;\n        }\n        return Task CompletedTask;\n    }\n    // Query method\n    public int GetStock(Guid productId) {\n        return _stock TryGetValue(productId, out var stock) stock : 0;\n    }\n}\n`\nGeneric Method Subscriptions\nUse generic methods for maximum flexibility and reusability:\n`csharp{\ntitle: \"Generic Method Subscriptions\"\ndescription: \"Using generic methods to handle multiple event types with shared logic\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Generics\", \"Polymorphism\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading;\nusing System Threading",
        "startIndex": 5512,
        "preview": "Event Subscriptions\" description: \"Using interfaces to handle multiple event types\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIAT..."
      },
      {
        "id": "projections/projection-subscriptions-chunk-4",
        "text": "generic methods to handle multiple event types with shared logic\" framework: \"NET8\" category: \"Projections\" difficulty: \"ADVANCED\" tags: [\"Projections\", \"Generics\", \"Polymorphism\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"] usingStatements: [\"System\", \"System Collections Generic\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Collections Generic; using System Threading; using System Threading Tasks;\n// Marker interface for all events\npublic interface IEvent {\n    Guid EventId { get; }\n    DateTime Timestamp { get; }\n}\n// Base interface for domain events\npublic interface IDomainEvent : IEvent {\n    string Domain { get; }\n}\n// Example events\npublic abstract record OrderEvent(Guid EventId, DateTime Timestamp, string Domain) : IDomainEvent;\npublic record OrderPlaced(Guid EventId, DateTime Timestamp, Guid OrderId, decimal Total)\n    : OrderEvent(EventId, Timestamp, \"Orders\");\npublic record OrderShipped(Guid EventId, DateTime Timestamp, Guid OrderId, string TrackingNumber)\n    : OrderEvent(EventId, Timestamp, \"Orders\");\n// Generic method with interface constraint\n[WhizbangProjection]\npublic class EventAuditProjection {\n    private readonly List<EventAuditRecord> _auditLog = new();\n    // This ONE generic method handles ALL events implementing IEvent\n    public Task OnEvent<TEvent>([WhizbangSubscribe] TEvent @event, EventContext context, CancellationToken ct)\n        where TEvent : IEvent {\n        // Source generator creates separate registration for each concrete event type:\n        // - OnEvent<OrderPlaced>\n        // - OnEvent<OrderShipped>\n        // - OnEvent<InventoryAdjusted>\n        // - etc _auditLog Add(new EventAuditRecord {\n            EventId = @event EventId,\n            EventType = typeof(TEvent) Name,  // Concrete type name\n            Timestamp = @event Timestamp,\n            UserId = context Security UserId,\n            TenantId = context Security TenantId\n        });\n        return Task CompletedTask;\n    }\n}\n// Generic method with base class constraint\n[WhizbangProjection]\npublic class OrderEventLogProjection {\n    private readonly Dictionary<string, List<string>> _logsByDomain = new();\n    // Handles all OrderEvent-derived types\n    public Task LogOrderEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct)\n        where TEvent : OrderEvent {\n        if ( _logsByDomain ContainsKey(@event Domain)) {\n            _logsByDomain[@event Domain] = new List<string>();\n        }\n        _logsByDomain[@event Domain] Add(\n            $\"{@event Timestamp:O} - {typeof(TEvent) Name} - {@event EventId}\"\n        );\n        return Task",
        "startIndex": 7833,
        "preview": "generic methods to handle multiple event types with shared logic\" framework: \"NET8\" category: \"Projections\" difficulty: \"ADVANCED\" tags: [\"Projections..."
      },
      {
        "id": "projections/projection-subscriptions-chunk-5",
        "text": "private readonly Dictionary<string, List<string>> _logsByDomain = new(); // Handles all OrderEvent-derived types public Task LogOrderEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct) where TEvent : OrderEvent { if ( _logsByDomain ContainsKey(@event Domain)) { _logsByDomain[@event Domain] = new List<string>(); } _logsByDomain[@event Domain] Add( $\"{@event Timestamp:O} - {typeof(TEvent) Name} - {@event EventId}\" ); return Task CompletedTask;\n    }\n}\npublic record EventAuditRecord {\n    public Guid EventId { get; init; }\n    public string EventType { get; init; }\n    public DateTime Timestamp { get; init; }\n    public Guid UserId { get; init; }\n    public Guid TenantId { get; init; }\n}\n`\nHow Generic Methods Work\nSource Generator Discovers Generic Methods: At compile time, finds all generic methods with [WhizbangSubscribe]\nCreates Registrations for Each Concrete Type: For every event type matching the generic constraint:\n   `csharp\n   // You write this ONE generic method:\n   public Task OnEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct)\n       where TEvent : IEvent { }\n   // Source generator creates registrations for ALL event types:\n   services Subscribe<OrderPlaced, EventAuditProjection>(p => p OnEvent);\n   services Subscribe<OrderShipped, EventAuditProjection>(p => p OnEvent);\n   services Subscribe<InventoryAdjusted, EventAuditProjection>(p => p OnEvent);\n   // etc `\nType Safety Maintained: Generic constraints ensure only valid event types are registered\nMultiple Constraints Supported: Use where TEvent : class, IEvent, new() or any valid Cconstraint\nCombining Generic and Specific Methods\nMix generic and specific subscriptions in the same projection:\n`csharp{\ntitle: \"Hybrid Generic and Specific Subscriptions\"\ndescription: \"Combining generic catch-all methods with specific handlers\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Generics\", \"Hybrid Patterns\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class HybridProjection {\n    // Generic catch-all for all events\n    public Task OnEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct)\n        where TEvent : IEvent {\n        // Log all events generically\n        Console WriteLine($\"Event received: {typeof(TEvent)",
        "startIndex": 10041,
        "preview": "private readonly Dictionary<string, List<string>> _logsByDomain = new(); // Handles all OrderEvent-derived types public Task LogOrderEvent<TEvent>([Wh..."
      },
      {
        "id": "projections/projection-subscriptions-chunk-6",
        "text": "[\"System\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading; using System Threading Tasks; [WhizbangProjection] public class HybridProjection { // Generic catch-all for all events public Task OnEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct) where TEvent : IEvent { // Log all events generically Console WriteLine($\"Event received: {typeof(TEvent) Name}\");\n        return Task CompletedTask;\n    }\n    // Specific handler for OrderPlaced (takes precedence)\n    public Task OnOrderPlaced([WhizbangSubscribe] OrderPlaced @event, ProjectionContext projection, CancellationToken ct) {\n        // Special handling for OrderPlaced\n        Console WriteLine($\"Special handling for order: {@event OrderId}\");\n        return Task CompletedTask;\n    }\n    // Specific handler for high-priority events\n    public Task OnOrderCancelled([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) {\n        // Alert handling for cancellations\n        Console WriteLine($\"ALERT: Order cancelled - {@event Reason}\");\n        return Task CompletedTask;\n    }\n}\n`\nPrecedence Rules\nWhen multiple methods can handle an event, Whizbang invokes handlers in this order:\nExact type match (e g , OrderPlaced @event)\nBase class match (e g , OrderEvent @event)\nInterface match (e g , IEvent @event)\nGeneric with specific constraint (e g , TEvent where TEvent : OrderEvent)\nGeneric with general constraint (e g , TEvent where TEvent : IEvent)\nAll matching handlers are invoked in precedence order (most specific to least specific) `mermaid\ngraph TD\n    OrderPlaced[\"OrderPlaced Event<br/>(Concrete Type)\"]\n    subgraph Handlers[\"Projection Handlers (Invoked in Order)\"]\n        H1[\"1 OnOrderPlaced<br/>(Exact Match)<br/>⭐ Highest Priority\"]\n        H2[\"2 OnOrderEvent<br/>(Base Class Match)\"]\n        H3[\"3 OnDomainEvent<br/>(Interface Match)\"]\n        H4[\"4 OnEvent&lt;TEvent&gt; where TEvent : OrderEvent<br/>(Generic Specific)\"]\n        H5[\"5 OnEvent&lt;TEvent&gt; where TEvent : IEvent<br/>(Generic General)<br/>⭐ Lowest Priority\"]\n    end\n    OrderPlaced --> H1\n    OrderPlaced - -> H2\n    OrderPlaced - -> H3\n    OrderPlaced - -> H4\n    OrderPlaced - -> H5\n    style OrderPlaced fill:#fff3cd,stroke:#ffc107,stroke-width:3px\n    style H1 fill:#d4edda,stroke:#28a745,stroke-width:2px\n    style H5 fill:#f8d7da,stroke:#dc3545,stroke-width:2px\n`\nBenefits of Polymorphic Subscriptions\nSingle Entry Point: One method handles all related events\nShared Logic: Common processing for all event types (logging, auditing, etc",
        "startIndex": 12108,
        "preview": "[\"System\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading; using System Threading Tasks; [..."
      },
      {
        "id": "projections/projection-subscriptions-chunk-7",
        "text": "OrderPlaced - -> H2 OrderPlaced - -> H3 OrderPlaced - -> H4 OrderPlaced - -> H5 style OrderPlaced fill:#fff3cd,stroke:#ffc107,stroke-width:3px style H1 fill:#d4edda,stroke:#28a745,stroke-width:2px style H5 fill:#f8d7da,stroke:#dc3545,stroke-width:2px ` Benefits of Polymorphic Subscriptions Single Entry Point: One method handles all related events Shared Logic: Common processing for all event types (logging, auditing, etc )\nType Safety: Pattern matching ensures all cases are handled\nFlexibility: Mix polymorphic and specific subscriptions as needed\nClean Code: Reduces boilerplate for related event types\nBenefits of Generic Methods\nDRY Principle: Write once, handle many event types\nShared Logic: Common processing for all events matching constraint\nType Safety: Generic constraints enforce compile-time safety\nAutomatic Registration: Source generator wires up all matching event types\nFlexibility: Combine with non-generic methods for specific overrides\nScalability: New event types automatically get handled without code changes\nValid Subscription Patterns\n`csharp\n// ✅ VALID - Specific event type\npublic Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) { }\n// ✅ VALID - Base class subscription\npublic Task OnOrderEvent([WhizbangSubscribe] OrderEvent @event, CancellationToken ct) { }\n// ✅ VALID - Interface subscription\npublic Task HandleInventoryEvent([WhizbangSubscribe] IInventoryEvent @event, CancellationToken ct) { }\n// ✅ VALID - Generic method\npublic Task OnEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct)\n    where TEvent : IEvent { }\n// ✅ VALID - With EventContext\npublic Task OnOrderPlaced([WhizbangSubscribe] OrderPlaced @event, EventContext context, CancellationToken ct) { }\n// ✅ VALID - With ProjectionContext\npublic Task OnOrderShipped([WhizbangSubscribe] OrderShipped @event, ProjectionContext projection, CancellationToken ct) { }\n// ✅ VALID - With both contexts\npublic Task WhenOrderPlaced(\n    [WhizbangSubscribe] OrderPlaced @event,\n    EventContext eventContext,\n    ProjectionContext projection,\n    CancellationToken ct) { }\n// ✅ VALID - With injected services (for querying, not mutation)\npublic Task ProcessOrder([WhizbangSubscribe] OrderPlaced @event, IOrderRepository repo, CancellationToken ct) { }\n// ❌ INVALID - Multiple subscriptions per method (compile error)\npublic Task OnOrderEvents([WhizbangSubscribe] OrderPlaced order, [WhizbangSubscribe] OrderShipped shipped) { }\n`\nAuto-Registration\nWhen you use [WhizbangSubscribe] on a method parameter, the source generator:\nDiscovers the subscription at compile time\nGenerates registration code linking the event type to the projection method\nAutomatically configures the service to route events to this projection\nNo manual registration needed - just mark with [WhizbangSubscribe]\n`mermaid\nsequenceDiagram\n    participant ES as Event Store\n    participant Router as Event Router\n    participant Proj1 as OrderProjection\n    participant Proj2 as AuditProjection\n    participant Store as Projection Store\n    ES->>Router: OrderPlaced event\n    Note over Router: Routes to all<br/>subscribed projections\n    Router->>Proj1: OnOrderPlaced(event, context)\n    Note over Proj1: ✅ Pure transformation<br/>Uses eventContext",
        "startIndex": 14264,
        "preview": "OrderPlaced - -> H2 OrderPlaced - -> H3 OrderPlaced - -> H4 OrderPlaced - -> H5 style OrderPlaced fill:#fff3cd,stroke:#ffc107,stroke-width:3px style H..."
      },
      {
        "id": "projections/projection-subscriptions-chunk-8",
        "text": "- just mark with [WhizbangSubscribe] `mermaid sequenceDiagram participant ES as Event Store participant Router as Event Router participant Proj1 as OrderProjection participant Proj2 as AuditProjection participant Store as Projection Store ES->>Router: OrderPlaced event Note over Router: Routes to all<br/>subscribed projections Router->>Proj1: OnOrderPlaced(event, context) Note over Proj1: ✅ Pure transformation<br/>Uses eventContext System Timestamp\n    Proj1->>Store: CreateAsync(OrderSummary)\n    Store-->>Proj1: Success\n    Proj1-->>Router: Accepted\n    Router->>Proj2: OnEvent<OrderPlaced>(event, context)\n    Note over Proj2: Generic handler<br/>Logs all events\n    Proj2->>Store: CreateAsync(AuditRecord)\n    Store-->>Proj2: Success\n    Proj2-->>Router: Accepted\n    Router->>Router: All projections complete\n`\n`csharp\n// This subscription is automatically registered\npublic Task OnOrderPlaced([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) {\n    // Source generator creates registration code like:\n    // services Subscribe<OrderPlaced, OrderSummaryProjection>(\n    //     projection => projection OnOrderPlaced);\n}\n`\nNext Steps\nProjection Contexts - EventContext and ProjectionContext injection\nProjection Purity - Maintaining pure, deterministic projections\nProjection Return Values - Using return values for observability",
        "startIndex": 666,
        "preview": "- just mark with [WhizbangSubscribe] `mermaid sequenceDiagram participant ES as Event Store participant Router as Event Router participant Proj1 as Or..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "roadmap/backups-and-snapshots",
    "title": "Backups and Snapshots",
    "category": "Roadmap",
    "url": "/docs/roadmap/backups-and-snapshots",
    "chunks": [
      {
        "id": "roadmap/backups-and-snapshots-chunk-0",
        "text": "Backups and Snapshots\n⚠️ FUTURE FEATURE - NOT YET RELEASED\nThis documentation describes backup and snapshot support planned for v1 1 0 These features are not available in the current release Status: Planned\nTarget Version: 1 1 0\n---\nOverview\nWhizbang will provide comprehensive backup and snapshot capabilities for disaster recovery, point-in-time restoration, and performance optimization Event Store Backups\nContinuous Backup\nAutomatic, incremental backups of event streams:\n`csharp{\ntitle: \"Backup Configuration\"\ndescription: \"Configure automatic event store backups\"\nframework: \"NET8\"\ncategory: \"Backups\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Backups\", \"Disaster Recovery\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang Backups\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UsePostgres(connectionString);\n        // Configure backups\n        es UseBackups(backup => {\n            // Continuous backup to Azure Blob Storage\n            backup UseAzureBlobStorage(config => {\n                config ConnectionString = azureStorageConnectionString;\n                config ContainerName = \"whizbang-backups\";\n            });\n            // Backup every 5 minutes\n            backup Interval = TimeSpan FromMinutes(5);\n            // Retention policy\n            backup RetainFor = TimeSpan FromDays(30);\n            backup PointInTimeRecovery = true;  // Keep transaction logs\n        });\n    });\n});\n`\nBackup Targets:\nAzure Blob Storage\nAWS S3\nGoogle Cloud Storage\nLocal file system\nNetwork share (SMB/NFS)\nPoint-in-Time Recovery (PITR)\nRestore event store to any point in time:\n`csharp{\ntitle: \"Point-in-Time Recovery\"\ndescription: \"Restore event store to specific timestamp\"\nframework: \"NET8\"\ncategory: \"Disaster Recovery\"\ndifficulty: \"ADVANCED\"\ntags: [\"Backups\", \"Disaster Recovery\", \"PITR\"]\nnugetPackages: [\"Whizbang Backups\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang Backups\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang Backups;\npublic class DisasterRecoveryService {\n    private readonly IEventStoreBackupManager _backupManager;\n    public DisasterRecoveryService(IEventStoreBackupManager backupManager) {\n        _backupManager = backupManager;\n    }\n    public async Task RecoverToPointInTimeAsync(DateTimeOffset targetTime) {\n        // Restore event store to specific timestamp\n        await _backupManager",
        "startIndex": 0,
        "preview": "Backups and Snapshots\n⚠️ FUTURE FEATURE - NOT YET RELEASED\nThis documentation describes backup and snapshot support planned for v1 1 0 These features ..."
      },
      {
        "id": "roadmap/backups-and-snapshots-chunk-1",
        "text": "usingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang Backups\"] showLineNumbers: true } using System; using System Threading Tasks; using Whizbang Backups; public class DisasterRecoveryService { private readonly IEventStoreBackupManager _backupManager; public DisasterRecoveryService(IEventStoreBackupManager backupManager) { _backupManager = backupManager; } public async Task RecoverToPointInTimeAsync(DateTimeOffset targetTime) { // Restore event store to specific timestamp await _backupManager RestoreAsync(new RestoreOptions {\n            TargetTime = targetTime,\n            TargetDatabase = \"whizbang_events_restored\",\n            VerifyIntegrity = true\n        });\n        // All events after targetTime are discarded\n        // All events before targetTime are restored\n    }\n    public async Task RecoverLastGoodStateAsync() {\n        // Find last known good backup\n        var lastGood = await _backupManager GetLastHealthyBackupAsync();\n        await _backupManager RestoreAsync(new RestoreOptions {\n            BackupId = lastGood Id,\n            TargetDatabase = \"whizbang_events\"\n        });\n    }\n}\n`\nBackup Verification\nAutomatic verification of backup integrity:\n`csharp{\ntitle: \"Backup Verification\"\ndescription: \"Verify backup integrity automatically\"\nframework: \"NET8\"\ncategory: \"Backups\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Backups\", \"Verification\"]\nnugetPackages: [\"Whizbang Backups\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseBackups(backup => {\n            // Verify backups automatically\n            backup VerifyAfterBackup = true;\n            // Restore to temporary database and validate\n            backup VerificationStrategy = BackupVerificationStrategy FullRestore;\n            // Alert on verification failure\n            backup OnVerificationFailed = async (backupId, error) => {\n                await alertService SendAsync($\"Backup {backupId} verification failed: {error}\");\n            };\n        });\n    });\n});\n`\nAggregate Snapshots\nPerformance Optimization\nSnapshots avoid replaying thousands of events for long-lived aggregates:\n`csharp{\ntitle: \"Aggregate Snapshots\"\ndescription: \"Configure snapshots for aggregates\"\nframework: \"NET8\"\ncategory: \"Snapshots\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Snapshots\", \"Performance\", \"Aggregates\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang Snapshots\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseSnapshots(snap => {\n            // Snapshot every 100 events\n            snap SnapshotEvery = 100;\n            // Store snapshots in same database as events\n            snap",
        "startIndex": 2587,
        "preview": "usingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang Backups\"] showLineNumbers: true } using System; using System Threading Tasks; using Wh..."
      },
      {
        "id": "roadmap/backups-and-snapshots-chunk-2",
        "text": "EventSourcing\", \"Whizbang Snapshots\"] usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"] showLineNumbers: true } using System; using Whizbang; using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseEventSourcing(es => { es UseSnapshots(snap => { // Snapshot every 100 events snap SnapshotEvery = 100; // Store snapshots in same database as events snap UsePostgres(connectionString);\n            // Or use faster storage for snapshots\n            snap UseRedis(redisConnectionString);\n            // Async snapshot creation (doesn't block aggregate saves)\n            snap CreateAsynchronously = true;\n        });\n    });\n});\n`\nManual Snapshots\nCreate snapshots for specific aggregates:\n`csharp{\ntitle: \"Manual Snapshot Creation\"\ndescription: \"Create snapshots on demand\"\nframework: \"NET8\"\ncategory: \"Snapshots\"\ndifficulty: \"ADVANCED\"\ntags: [\"Snapshots\", \"Aggregates\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang Snapshots\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang Snapshots\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang Snapshots;\npublic class SnapshotService {\n    private readonly ISnapshotStore _snapshotStore;\n    private readonly IRepository<Order> _orderRepository;\n    public SnapshotService(ISnapshotStore snapshotStore, IRepository<Order> orderRepository) {\n        _snapshotStore = snapshotStore;\n        _orderRepository = orderRepository;\n    }\n    public async Task CreateSnapshotAsync(Guid orderId) {\n        // Load aggregate\n        var order = await _orderRepository GetAsync(orderId);\n        // Create snapshot\n        await _snapshotStore SaveSnapshotAsync(order);\n    }\n    public async Task RebuildSnapshotsForAllOrdersAsync() {\n        // Rebuild all snapshots (e g , after schema change)\n        var orderIds = await GetAllOrderIdsAsync();\n        foreach (var orderId in orderIds) {\n            await CreateSnapshotAsync(orderId);\n        }\n    }\n}\n`\nSnapshot Schema Versioning\nHandle snapshot schema changes:\n`csharp{\ntitle: \"Snapshot Versioning\"\ndescription: \"Handle evolving snapshot schemas\"\nframework: \"NET8\"\ncategory: \"Snapshots\"\ndifficulty: \"ADVANCED\"\ntags: [\"Snapshots\", \"Versioning\", \"Schema Evolution\"]\nnugetPackages: [\"Whizbang Snapshots\"]\nusingStatements: [\"System\", \"Whizbang Snapshots\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang",
        "startIndex": 5101,
        "preview": "EventSourcing\", \"Whizbang Snapshots\"] usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"] showLineNumbers: true } usin..."
      },
      {
        "id": "roadmap/backups-and-snapshots-chunk-3",
        "text": "in orderIds) { await CreateSnapshotAsync(orderId); } } } ` Snapshot Schema Versioning Handle snapshot schema changes: `csharp{ title: \"Snapshot Versioning\" description: \"Handle evolving snapshot schemas\" framework: \"NET8\" category: \"Snapshots\" difficulty: \"ADVANCED\" tags: [\"Snapshots\", \"Versioning\", \"Schema Evolution\"] nugetPackages: [\"Whizbang Snapshots\"] usingStatements: [\"System\", \"Whizbang Snapshots\"] showLineNumbers: true } using System; using Whizbang Snapshots;\n// V1 snapshot\npublic class OrderSnapshotV1 {\n    public Guid Id { get; set; }\n    public string Status { get; set; }\n    public decimal Total { get; set; }\n}\n// V2 snapshot (added fields)\npublic class OrderSnapshotV2 {\n    public Guid Id { get; set; }\n    public string Status { get; set; }\n    public decimal Total { get; set; }\n    public DateTimeOffset PlacedAt { get; set; }  // New field\n    public string Currency { get; set; }          // New field\n}\n// Upcaster converts V1 → V2\npublic class OrderSnapshotUpcaster : ISnapshotUpcaster<OrderSnapshotV1, OrderSnapshotV2> {\n    public OrderSnapshotV2 Upcast(OrderSnapshotV1 oldSnapshot) {\n        return new OrderSnapshotV2 {\n            Id = oldSnapshot Id,\n            Status = oldSnapshot Status,\n            Total = oldSnapshot Total,\n            PlacedAt = DateTimeOffset MinValue,  // Default for old snapshots\n            Currency = \"USD\"                      // Default currency\n        };\n    }\n}\n`\nProjection Backups\nRebuild vs Backup\nProjections can be rebuilt from events, but backups provide faster recovery:\n`csharp{\ntitle: \"Projection Backup Strategy\"\ndescription: \"Choose between rebuild and backup restore\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Backups\", \"Disaster Recovery\"]\nnugetPackages: [\"Whizbang Projections\", \"Whizbang Backups\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseProjections(proj => {\n        proj RegisterProjection<OrderHistoryProjection>(p => {\n            // Strategy 1: Rebuild from events (slow but always correct)\n            p DisasterRecoveryStrategy = ProjectionRecoveryStrategy RebuildFromEvents;\n            // Strategy 2: Restore from backup (fast but needs regular backups)\n            p DisasterRecoveryStrategy = ProjectionRecoveryStrategy RestoreFromBackup;\n            p BackupInterval = TimeSpan",
        "startIndex": 7099,
        "preview": "in orderIds) { await CreateSnapshotAsync(orderId); } } } ` Snapshot Schema Versioning Handle snapshot schema changes: `csharp{ title: \"Snapshot Versio..."
      },
      {
        "id": "roadmap/backups-and-snapshots-chunk-4",
        "text": "Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseProjections(proj => { proj RegisterProjection<OrderHistoryProjection>(p => { // Strategy 1: Rebuild from events (slow but always correct) p DisasterRecoveryStrategy = ProjectionRecoveryStrategy RebuildFromEvents; // Strategy 2: Restore from backup (fast but needs regular backups) p DisasterRecoveryStrategy = ProjectionRecoveryStrategy RestoreFromBackup; p BackupInterval = TimeSpan FromHours(1);\n            // Strategy 3: Hybrid (restore backup, then replay recent events)\n            p DisasterRecoveryStrategy = ProjectionRecoveryStrategy Hybrid;\n            p BackupInterval = TimeSpan FromHours(6);\n        });\n    });\n});\n`\nProjection Snapshots\nExport projection state for analytics or migration:\n`csharp{\ntitle: \"Projection Export\"\ndescription: \"Export projection state for backup or analytics\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Backups\", \"Export\"]\nnugetPackages: [\"Whizbang Projections\", \"Whizbang Backups\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang Backups\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang Backups;\npublic class ProjectionBackupService {\n    private readonly IProjectionBackupManager _backupManager;\n    public ProjectionBackupService(IProjectionBackupManager backupManager) {\n        _backupManager = backupManager;\n    }\n    public async Task BackupProjectionAsync<TProjection>() {\n        // Export entire projection to Parquet file\n        await _backupManager ExportProjectionAsync<TProjection>(new ExportOptions {\n            Format = ExportFormat Parquet,\n            Destination = \"s3://backups/projections/order-history parquet\",\n            Compression = CompressionType Snappy\n        });\n    }\n    public async Task RestoreProjectionAsync<TProjection>(string backupPath) {\n        // Import projection from backup\n        await _backupManager ImportProjectionAsync<TProjection>(new ImportOptions {\n            Source = backupPath,\n            TruncateExisting = true  // Clear current data first\n        });\n    }\n}\n`\nCross-Region Replication\nReplicate event streams to multiple regions for disaster recovery:\n`csharp{\ntitle: \"Cross-Region Replication\"\ndescription: \"Replicate events to multiple regions\"\nframework: \"NET8\"\ncategory: \"Disaster Recovery\"\ndifficulty: \"ADVANCED\"\ntags: [\"Replication\", \"Multi-Region\", \"Disaster Recovery\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang Replication\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        // Primary region (US East)\n        es UsePostgres(\"Host=us-east postgres azure com; \");\n        // Replicate to secondary regions\n        es UseReplication(repl => {\n            repl ReplicateTo(\"us-west\", \"Host=us-west postgres azure com; \");\n            repl ReplicateTo(\"eu-west\", \"Host=eu-west postgres azure",
        "startIndex": 9160,
        "preview": "Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseProjections(proj => { proj RegisterProjection<OrderHistoryProje..."
      },
      {
        "id": "roadmap/backups-and-snapshots-chunk-5",
        "text": "DependencyInjection\"] showLineNumbers: true } using Whizbang; using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseEventSourcing(es => { // Primary region (US East) es UsePostgres(\"Host=us-east postgres azure com; \"); // Replicate to secondary regions es UseReplication(repl => { repl ReplicateTo(\"us-west\", \"Host=us-west postgres azure com; \"); repl ReplicateTo(\"eu-west\", \"Host=eu-west postgres azure com; \");\n            // Async replication (eventual consistency)\n            repl Mode = ReplicationMode Asynchronous;\n            // Failover configuration\n            repl AutomaticFailover = true;\n            repl HealthCheckInterval = TimeSpan FromSeconds(10);\n        });\n    });\n});\n`\nBackup Monitoring\nMonitor backup health and alert on issues:\n`csharp{\ntitle: \"Backup Monitoring\"\ndescription: \"Monitor and alert on backup health\"\nframework: \"NET8\"\ncategory: \"Observability\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Backups\", \"Monitoring\", \"Alerts\"]\nnugetPackages: [\"Whizbang Backups\", \"Whizbang OpenTelemetry\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseBackups(backup => {\n        // Emit OpenTelemetry metrics\n        backup UseOpenTelemetry();\n        // Alert on backup failures\n        backup OnBackupFailed = async (error) => {\n            await alertService SendAsync($\"Backup failed: {error Message}\");\n        };\n        // Alert if backup hasn't run recently\n        backup AlertIfNoBackupFor = TimeSpan FromHours(2);\n        // Alert on low disk space\n        backup AlertIfStorageBelow = 10  1024  1024 * 1024;  // 10 GB\n    });\n});\n`\nMetrics Emitted:\nwhizbang backup duration - How long backups take\nwhizbang backup size - Backup size in bytes\nwhizbang backup success - Backup success/failure count\nwhizbang backup verification_duration - Verification time\nNext Steps\nLakehouse Streaming - Stream events to data lakes\nObservability - Monitor backup health\nDisaster Recovery - Complete DR strategy\nFeedback Welcome\nWe're designing this feature now What backup strategies do you need Share your thoughts",
        "startIndex": 11553,
        "preview": "DependencyInjection\"] showLineNumbers: true } using Whizbang; using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { option..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "roadmap/distributed-messaging",
    "title": "Distributed Messaging",
    "category": "Roadmap",
    "url": "/docs/roadmap/distributed-messaging",
    "chunks": [
      {
        "id": "roadmap/distributed-messaging-chunk-0",
        "text": "Distributed Messaging\n⚠️ FUTURE FEATURE - NOT YET RELEASED\nThis documentation describes distributed messaging support planned for v1 0 0 This feature is not available in the current release Status: Planned\nTarget Version: 1 0 0\n---\nOverview\nDistributed messaging enables Whizbang applications to scale beyond a single process into microservices architecture Commands and events can be routed across service boundaries using message brokers like Kafka, RabbitMQ, or Azure Service Bus Key Features\nDomain Ownership Routing\nCommands are routed to the service that owns the domain:\n`csharp\n// In the API Gateway service\nawait whizbang Send(new PlaceOrder( ));\n// ↓\n// Command automatically routed to Orders service via message broker\n`\nEvents are broadcast from the owning domain to all subscribers:\n`csharp\n// In the Orders service\nawait repository SaveAsync(order);  // Emits OrderPlaced event\n// ↓\n// Event published to message broker\n// ↓\n// Inventory, Shipping, and Analytics services all receive the event\n`\nOutbox/Inbox Pattern\nEnsures exactly-once semantics for distributed messaging:\nOutbox (publishing side):\nEvents written to outbox table in same transaction as event store append\nBackground worker publishes from outbox to message broker\nMessages marked as published after broker confirms\nInbox (subscribing side):\nMessages received from broker stored in inbox table\nIdempotent handler checks if message ID already processed\nPeriodic cleanup of old inbox entries\nMessage Broker Adapters\nMultiple message broker adapters will be supported:\nKafka - High throughput, event replay, partition awareness\nRabbitMQ - Flexible routing, priority queues\nAzure Service Bus - Managed service, sessions, duplicate detection\nAWS SQS/SNS - Managed service, FIFO queues\nConfiguration\nIntended API:\n`csharp{\ntitle: \"Distributed Messaging Configuration\"\ndescription: \"How distributed messaging will be configured\"\nframework: \"NET8\"\ncategory: \"Distributed Systems\"\ndifficulty: \"ADVANCED\"\ntags: [\"Messaging\", \"Configuration\", \"Microservices\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Messaging\", \"Whizbang Kafka\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions",
        "startIndex": 0,
        "preview": "Distributed Messaging\n⚠️ FUTURE FEATURE - NOT YET RELEASED\nThis documentation describes distributed messaging support planned for v1 0 0 This feature ..."
      },
      {
        "id": "roadmap/distributed-messaging-chunk-1",
        "text": "- Managed service, sessions, duplicate detection AWS SQS/SNS - Managed service, FIFO queues Configuration Intended API: `csharp{ title: \"Distributed Messaging Configuration\" description: \"How distributed messaging will be configured\" framework: \"NET8\" category: \"Distributed Systems\" difficulty: \"ADVANCED\" tags: [\"Messaging\", \"Configuration\", \"Microservices\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Messaging\", \"Whizbang Kafka\"] usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseMessaging(msg => {\n        // Configure domain ownership\n        msg UseDomainOwnership(domains => {\n            domains RegisterDomain(\"Orders\", \"https://orders myapp com\");\n            domains RegisterDomain(\"Inventory\", \"https://inventory myapp com\");\n            domains RegisterDomain(\"Shipping\", \"https://shipping myapp com\");\n        });\n        // Use Kafka as message broker\n        msg UseKafka(kafka => {\n            kafka BootstrapServers = \"kafka:9092\";\n            kafka ConsumerGroup = \"orders-service\";\n        });\n        // Enable outbox for reliable publishing\n        msg UseOutbox(outbox => {\n            outbox PublishInterval = TimeSpan FromSeconds(1);\n        });\n        // Enable inbox for idempotent consumption\n        msg UseInbox(inbox => {\n            inbox CleanupRetention = TimeSpan FromDays(7);\n        });\n    });\n});\n`\nBackfilling Projections\nWhen a new service subscribes to events for the first time, it can backfill from the entire event history:\n`csharp{\ntitle: \"Projection Backfilling\"\ndescription: \"Subscribe to events and backfill from history\"\nframework: \"NET8\"\ncategory: \"Distributed Systems\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Backfilling\", \"Event Sourcing\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Projections\", \"Whizbang Messaging\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseProjections(proj => {\n        proj RegisterProjection<OrderAnalyticsProjection>(p => {\n            // Subscribe to events from Orders domain\n            p Subscribe<OrderPlaced>();\n            p Subscribe<OrderShipped>();\n            p Subscribe<OrderCancelled>();\n            // Backfill from the beginning of time\n            p BackfillFrom = DateTimeOffset MinValue;\n            // Query Orders service for historical events\n            p BackfillSource = \"https://orders myapp",
        "startIndex": 2161,
        "preview": "- Managed service, sessions, duplicate detection AWS SQS/SNS - Managed service, FIFO queues Configuration Intended API: `csharp{ title: \"Distributed M..."
      },
      {
        "id": "roadmap/distributed-messaging-chunk-2",
        "text": "DependencyInjection; services AddWhizbang(options => { options UseProjections(proj => { proj RegisterProjection<OrderAnalyticsProjection>(p => { // Subscribe to events from Orders domain p Subscribe<OrderPlaced>(); p Subscribe<OrderShipped>(); p Subscribe<OrderCancelled>(); // Backfill from the beginning of time p BackfillFrom = DateTimeOffset MinValue; // Query Orders service for historical events p BackfillSource = \"https://orders myapp com/events\";\n        });\n    });\n});\n`\nThe projection engine will:\nQuery the Orders service's event store via HTTP API\nFetch all historical events matching subscribed types\nApply them to the projection in order\nSwitch to real-time message broker consumption\nContinue processing new events as they arrive\nFeedback Welcome\nWe're designing this feature now and welcome your input What message brokers do you need supported What edge cases should we handle What API would be most intuitive Open a discussion to share your thoughts",
        "startIndex": 4398,
        "preview": "DependencyInjection; services AddWhizbang(options => { options UseProjections(proj => { proj RegisterProjection<OrderAnalyticsProjection>(p => { // Su..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "roadmap/lakehouse-streaming",
    "title": "Lakehouse Streaming",
    "category": "Roadmap",
    "url": "/docs/roadmap/lakehouse-streaming",
    "chunks": [
      {
        "id": "roadmap/lakehouse-streaming-chunk-0",
        "text": "Lakehouse Streaming\n⚠️ FUTURE FEATURE - NOT YET RELEASED\nThis documentation describes lakehouse streaming support planned for v1 2 0 This feature is not available in the current release Status: Planned\nTarget Version: 1 2 0\n---\nOverview\nWhizbang will provide first-class integration with data lakehouses (Delta Lake, Apache Iceberg, Apache Hudi), enabling real-time streaming of events for analytics, ML, and business intelligence Why Lakehouse Streaming Event Store as Operational Database\nThe event store is optimized for transactional workloads (fast writes, point queries):\nWrite new events\nLoad aggregate streams\nSupport projections\nLakehouse as Analytical Database\nLakehouses are optimized for analytical workloads (complex queries, aggregations):\nAd-hoc SQL queries across all events\nTime-series analytics\nMachine learning feature extraction\nBusiness intelligence dashboards\nStream events from Whizbang → Lakehouse for the best of both worlds Supported Lakehouses\nDelta Lake (Databricks, Azure Synapse, AWS EMR)\nApache Iceberg (Snowflake, AWS Athena, Google BigQuery)\nApache Hudi (AWS EMR, Google Dataproc)\nParquet files (S3, Azure Data Lake, Google Cloud Storage)\nConfiguration\nDelta Lake Streaming\n`csharp{\ntitle: \"Delta Lake Streaming Configuration\"\ndescription: \"Stream events to Delta Lake\"\nframework: \"NET8\"\ncategory: \"Analytics\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Delta Lake\", \"Streaming\", \"Analytics\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UsePostgres(connectionString);\n        // Stream events to Delta Lake\n        es StreamToLakehouse(lake => {\n            lake UseDeltaLake(delta => {\n                delta StoragePath = \"s3://my-data-lake/whizbang/events\";\n                delta PartitionBy = \"event_date\";  // Partition by date for performance\n                delta MergeSchema = true;          // Handle schema evolution\n            });\n            // Stream continuously\n            lake StreamingMode = StreamingMode Continuous;\n            // Batch events for efficiency\n            lake BatchSize = 1000;\n            lake FlushInterval = TimeSpan",
        "startIndex": 0,
        "preview": "Lakehouse Streaming\n⚠️ FUTURE FEATURE - NOT YET RELEASED\nThis documentation describes lakehouse streaming support planned for v1 2 0 This feature is n..."
      },
      {
        "id": "roadmap/lakehouse-streaming-chunk-1",
        "text": "=> { lake UseDeltaLake(delta => { delta StoragePath = \"s3://my-data-lake/whizbang/events\"; delta PartitionBy = \"event_date\"; // Partition by date for performance delta MergeSchema = true; // Handle schema evolution }); // Stream continuously lake StreamingMode = StreamingMode Continuous; // Batch events for efficiency lake BatchSize = 1000; lake FlushInterval = TimeSpan FromSeconds(30);\n        });\n    });\n});\n`\nWhat happens:\nEvents written to Postgres event store\nBackground worker batches events\nEvents written to Delta Lake as Parquet files\nPartitioned by date for efficient queries\nSchema automatically detected and evolved\nApache Iceberg Streaming\n`csharp{\ntitle: \"Apache Iceberg Streaming Configuration\"\ndescription: \"Stream events to Apache Iceberg\"\nframework: \"NET8\"\ncategory: \"Analytics\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Iceberg\", \"Streaming\", \"Analytics\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es StreamToLakehouse(lake => {\n            lake UseIceberg(iceberg => {\n                iceberg Catalog = \"glue\";  // AWS Glue catalog\n                iceberg Database = \"whizbang\";\n                iceberg TableName = \"events\";\n                iceberg WarehousePath = \"s3://my-warehouse/whizbang\";\n            });\n        });\n    });\n});\n`\nEvent Filtering\nStream only specific events to lakehouse:\n`csharp{\ntitle: \"Event Filtering for Lakehouse\"\ndescription: \"Stream only specific events\"\nframework: \"NET8\"\ncategory: \"Analytics\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Filtering\", \"Streaming\", \"Analytics\"]\nnugetPackages: [\"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es StreamToLakehouse(lake => {\n            lake UseDeltaLake(delta => { / / });\n            // Stream only certain event types\n            lake IncludeEvents(\n                typeof(OrderPlaced),\n                typeof(OrderShipped),\n                typeof(PaymentProcessed)\n            );\n            // Exclude sensitive events\n            lake ExcludeEvents(typeof(PaymentMethodUpdated));\n            // Custom filter\n            lake Filter = @event => {\n                // Don't stream test tenant data\n                return @event Metadata TenantId",
        "startIndex": 2349,
        "preview": "=> { lake UseDeltaLake(delta => { delta StoragePath = \"s3://my-data-lake/whizbang/events\"; delta PartitionBy = \"event_date\"; // Partition by date for ..."
      },
      {
        "id": "roadmap/lakehouse-streaming-chunk-2",
        "text": "=> { es StreamToLakehouse(lake => { lake UseDeltaLake(delta => { / / }); // Stream only certain event types lake IncludeEvents( typeof(OrderPlaced), typeof(OrderShipped), typeof(PaymentProcessed) ); // Exclude sensitive events lake ExcludeEvents(typeof(PaymentMethodUpdated)); // Custom filter lake Filter = @event => { // Don't stream test tenant data return @event Metadata TenantId StartsWith(\"test-\");\n            };\n        });\n    });\n});\n`\nEvent Schema Mapping\nMap events to lakehouse schema:\n`csharp{\ntitle: \"Event Schema Mapping\"\ndescription: \"Map events to lakehouse table schema\"\nframework: \"NET8\"\ncategory: \"Analytics\"\ndifficulty: \"ADVANCED\"\ntags: [\"Schema\", \"Mapping\", \"Analytics\"]\nnugetPackages: [\"Whizbang Lakehouse\"]\nusingStatements: [\"System\", \"Whizbang Lakehouse\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang Lakehouse;\npublic class OrderPlacedEventMapper : IEventMapper<OrderPlaced> {\n    public LakehouseRow Map(OrderPlaced @event) {\n        return new LakehouseRow {\n            // Standard fields\n            [\"event_id\"] = @event EventId,\n            [\"event_type\"] = \"OrderPlaced\",\n            [\"event_timestamp\"] = @event Timestamp,\n            [\"aggregate_id\"] = @event OrderId,\n            [\"tenant_id\"] = @event TenantId,\n            // Event-specific fields\n            [\"customer_id\"] = @event CustomerId,\n            [\"order_total\"] = @event Total,\n            [\"order_status\"] = \"Placed\",\n            [\"item_count\"] = @event Items Count,\n            // Denormalized for analytics\n            [\"year\"] = @event PlacedAt Year,\n            [\"month\"] = @event PlacedAt Month,\n            [\"day\"] = @event PlacedAt Day,\n            [\"hour\"] = @event PlacedAt Hour\n        };\n    }\n}\n`\nQuerying Lakehouse Data\nSQL Queries (Delta Lake)\nOnce events are in the lakehouse, query with SQL:\n`sql\n-- Total orders by day\nSELECT\n    event_date,\n    COUNT(*) as order_count,\n    SUM(order_total) as total_revenue\nFROM whizbang events\nWHERE event_type = 'OrderPlaced'\nGROUP BY event_date\nORDER BY event_date DESC;\n-- Customer lifetime value\nSELECT\n    customer_id,\n    COUNT(DISTINCT aggregate_id) as total_orders,\n    SUM(order_total) as lifetime_value\nFROM whizbang events\nWHERE event_type = 'OrderPlaced'\nGROUP BY customer_id\nORDER BY lifetime_value DESC\nLIMIT 100;\n-- Hourly order trends\nSELECT\n    DATE_TRUNC('hour', event_timestamp) as hour,\n    COUNT(*) as order_count\nFROM whizbang",
        "startIndex": 4595,
        "preview": "=> { es StreamToLakehouse(lake => { lake UseDeltaLake(delta => { / / }); // Stream only certain event types lake IncludeEvents( typeof(OrderPlaced), t..."
      },
      {
        "id": "roadmap/lakehouse-streaming-chunk-3",
        "text": "GROUP BY event_date ORDER BY event_date DESC; -- Customer lifetime value SELECT customer_id, COUNT(DISTINCT aggregate_id) as total_orders, SUM(order_total) as lifetime_value FROM whizbang events WHERE event_type = 'OrderPlaced' GROUP BY customer_id ORDER BY lifetime_value DESC LIMIT 100; -- Hourly order trends SELECT DATE_TRUNC('hour', event_timestamp) as hour, COUNT(*) as order_count FROM whizbang events\nWHERE event_type = 'OrderPlaced'\n  AND event_date >= CURRENT_DATE - INTERVAL '7 days'\nGROUP BY hour\nORDER BY hour;\n`\nDataFrames (Spark/Databricks)\n`python\nLoad events from Delta Lake\nevents = spark read format(\"delta\") load(\"s3://my-data-lake/whizbang/events\")\nFilter to order events\norders = events filter(events event_type == \"OrderPlaced\")\nAggregate by customer\ncustomer_stats = orders groupBy(\"customer_id\") agg(\n    count(\"*\") alias(\"order_count\"),\n    sum(\"order_total\") alias(\"total_spend\"),\n    avg(\"order_total\") alias(\"avg_order_value\")\n)\nWrite to feature store for ML\ncustomer_stats write format(\"delta\") mode(\"overwrite\") save(\"s3://features/customers\")\n`\nTime Travel Queries\nLakehouse time travel enables querying historical data:\n`sql\n-- Query events as of yesterday\nSELECT * FROM whizbang events TIMESTAMP AS OF '2025-10-17 00:00:00';\n-- Query events from specific version\nSELECT * FROM whizbang events VERSION AS OF 123;\n-- See all changes between versions\nSELECT * FROM whizbang events VERSION AS OF 100\nEXCEPT\nSELECT * FROM whizbang events VERSION AS OF 150;\n`\nSchema Evolution\nLakehouses handle schema changes gracefully:\n`csharp{\ntitle: \"Schema Evolution\"\ndescription: \"Handle evolving event schemas in lakehouse\"\nframework: \"NET8\"\ncategory: \"Analytics\"\ndifficulty: \"ADVANCED\"\ntags: [\"Schema\", \"Evolution\", \"Analytics\"]\nnugetPackages: [\"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es StreamToLakehouse(lake => {\n            lake UseDeltaLake(delta => {\n                // Automatically add new columns when event schema changes\n                delta MergeSchema = true;\n                // Or use strict mode (fail on schema mismatch)\n                delta MergeSchema = false;\n                delta OnSchemaMismatch = SchemaMismatchPolicy",
        "startIndex": 6624,
        "preview": "GROUP BY event_date ORDER BY event_date DESC; -- Customer lifetime value SELECT customer_id, COUNT(DISTINCT aggregate_id) as total_orders, SUM(order_t..."
      },
      {
        "id": "roadmap/lakehouse-streaming-chunk-4",
        "text": "using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseEventSourcing(es => { es StreamToLakehouse(lake => { lake UseDeltaLake(delta => { // Automatically add new columns when event schema changes delta MergeSchema = true; // Or use strict mode (fail on schema mismatch) delta MergeSchema = false; delta OnSchemaMismatch = SchemaMismatchPolicy Fail;\n            });\n        });\n    });\n});\n`\nExample:\n`csharp\n// V1 event\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, decimal Total);\n// V2 event (added field)\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, decimal Total, string Currency);\n`\nWith MergeSchema = true:\nOld events have Currency = null\nNew events have all fields\nNo data migration needed\nPerformance Optimization\nPartitioning Strategy\n`csharp{\ntitle: \"Lakehouse Partitioning\"\ndescription: \"Optimize queries with partitioning\"\nframework: \"NET8\"\ncategory: \"Performance\"\ndifficulty: \"ADVANCED\"\ntags: [\"Partitioning\", \"Performance\", \"Analytics\"]\nnugetPackages: [\"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es StreamToLakehouse(lake => {\n            lake UseDeltaLake(delta => {\n                // Partition by date and tenant for fast queries\n                delta PartitionBy = new[] { \"event_date\", \"tenant_id\" };\n                // Z-order for co-located data\n                delta ZOrderBy = new[] { \"customer_id\", \"event_type\" };\n                // Optimize file sizes\n                delta TargetFileSize = 128  1024  1024;  // 128 MB\n            });\n        });\n    });\n});\n`\nQuery optimization:\n`sql\n-- Fast (partition pruning)\nSELECT * FROM events\nWHERE event_date = '2025-10-18'\n  AND tenant_id = 'acme-corp';\n-- Slow (full table scan)\nSELECT * FROM events\nWHERE customer_id = '12345';\n`\nCompaction\nPeriodically compact small files:\n`csharp{\ntitle: \"Lakehouse Compaction\"\ndescription: \"Compact small files for better performance\"\nframework: \"NET8\"\ncategory: \"Performance\"\ndifficulty: \"ADVANCED\"\ntags: [\"Compaction\", \"Performance\", \"Analytics\"]\nnugetPackages: [\"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es StreamToLakehouse(lake => {\n            lake",
        "startIndex": 8608,
        "preview": "using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseEventSourcing(es => { es StreamToLakehouse(lake => { lake..."
      },
      {
        "id": "roadmap/lakehouse-streaming-chunk-5",
        "text": "description: \"Compact small files for better performance\" framework: \"NET8\" category: \"Performance\" difficulty: \"ADVANCED\" tags: [\"Compaction\", \"Performance\", \"Analytics\"] nugetPackages: [\"Whizbang Lakehouse\"] usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"] showLineNumbers: true } using System; using Whizbang; using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseEventSourcing(es => { es StreamToLakehouse(lake => { lake UseDeltaLake(delta => {\n                // Auto-compact small files\n                delta AutoCompact = true;\n                delta CompactInterval = TimeSpan FromHours(6);\n                delta TargetFileSize = 128  1024  1024;  // 128 MB\n            });\n        });\n    });\n});\n`\nIntegration with BI Tools\nDatabricks\nEvents in Delta Lake are queryable from Databricks notebooks:\n`python\nConnect to lakehouse\nevents = spark read format(\"delta\") load(\"s3://my-data-lake/whizbang/events\")\nCreate temp view for SQL\nevents createOrReplaceTempView(\"events\")\nQuery with Spark SQL\nresults = spark sql(\"\"\"\n    SELECT event_date, COUNT(*) as event_count\n    FROM events\n    GROUP BY event_date\n    ORDER BY event_date DESC\n\"\"\")\nVisualize in notebook\ndisplay(results)\n`\nPower BI / Tableau\nConnect via ODBC/JDBC:\n`plaintext\nConnection: Delta Lake (S3)\nPath: s3://my-data-lake/whizbang/events\nTable: events\n`\ndbt (Data Build Tool)\nCreate analytics models from events:\n`sql\n-- models/orders_daily sql\n{{ config(materialized='table') }}\nSELECT\n    DATE(event_timestamp) as date,\n    COUNT(DISTINCT aggregate_id) as order_count,\n    SUM(order_total) as revenue,\n    AVG(order_total) as avg_order_value\nFROM {{ source('whizbang', 'events') }}\nWHERE event_type = 'OrderPlaced'\nGROUP BY date\n`\nStreaming Guarantees\nAt-Least-Once Delivery\nEvents are guaranteed to be delivered to the lakehouse at least once:\nIdempotent writes (duplicate events filtered by event_id)\nCheckpointing for crash recovery\nTransactional writes to lakehouse\nExactly-Once Semantics\nFor critical analytics, enable exactly-once:\n`csharp{\ntitle: \"Exactly-Once Lakehouse Streaming\"\ndescription: \"Ensure no duplicate events in lakehouse\"\nframework: \"NET8\"\ncategory: \"Reliability\"\ndifficulty: \"ADVANCED\"\ntags: [\"Exactly-Once\", \"Reliability\", \"Streaming\"]\nnugetPackages: [\"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es StreamToLakehouse(lake => {\n            lake UseDeltaLake(delta => { / / });\n            // Exactly-once semantics\n            lake",
        "startIndex": 10817,
        "preview": "description: \"Compact small files for better performance\" framework: \"NET8\" category: \"Performance\" difficulty: \"ADVANCED\" tags: [\"Compaction\", \"Perfo..."
      },
      {
        "id": "roadmap/lakehouse-streaming-chunk-6",
        "text": "framework: \"NET8\" category: \"Reliability\" difficulty: \"ADVANCED\" tags: [\"Exactly-Once\", \"Reliability\", \"Streaming\"] nugetPackages: [\"Whizbang Lakehouse\"] usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"] showLineNumbers: true } using Whizbang; using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseEventSourcing(es => { es StreamToLakehouse(lake => { lake UseDeltaLake(delta => { / / }); // Exactly-once semantics lake DeliveryGuarantee = DeliveryGuarantee ExactlyOnce;\n            // Deduplication by event ID\n            lake DeduplicateBy = \"event_id\";\n        });\n    });\n});\n`\nNext Steps\nBackups and Snapshots - Backup strategies\nObservability - Monitor streaming health\nAnalytics - Query patterns and examples\nFeedback Welcome\nWhat analytics use cases do you have for event data Share your thoughts",
        "startIndex": 13041,
        "preview": "framework: \"NET8\" category: \"Reliability\" difficulty: \"ADVANCED\" tags: [\"Exactly-Once\", \"Reliability\", \"Streaming\"] nugetPackages: [\"Whizbang Lakehous..."
      }
    ]
  }
]