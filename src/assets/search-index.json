[
  {
    "type": "document",
    "slug": "backlog/_folder",
    "title": "backlog/_folder",
    "category": "General",
    "url": "/docs/backlog/_folder",
    "chunks": [
      {
        "id": "backlog/_folder-chunk-0",
        "text": "Development Backlog\nThis section contains documentation for features that have been approved for development but not yet scheduled for a specific release. These features are prioritized and will be assigned to future versions.\nGuidelines\nFeatures approved for development\nAwaiting scheduling to specific version\nPrioritized based on roadmap\nWill be moved to version folders when scheduled",
        "startIndex": 0,
        "preview": "Development Backlog\nThis section contains documentation for features that have been approved for development but not yet scheduled for a specific rele..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "declined/_folder",
    "title": "declined/_folder",
    "category": "General",
    "url": "/docs/declined/_folder",
    "chunks": [
      {
        "id": "declined/_folder-chunk-0",
        "text": "Declined Proposals\nThis section contains documentation for features and proposals that have been evaluated and declined. These are archived for historical reference and decision context.\nGuidelines\nFeatures evaluated and declined\nArchived for reference only\nHidden from main navigation\nAccessible via direct URL only",
        "startIndex": 0,
        "preview": "Declined Proposals\nThis section contains documentation for features and proposals that have been evaluated and declined. These are archived for histor..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "drafts/_folder",
    "title": "drafts/_folder",
    "category": "General",
    "url": "/docs/drafts/_folder",
    "chunks": [
      {
        "id": "drafts/_folder-chunk-0",
        "text": "Draft Documentation\nThis section contains documentation that is currently being written and developed. Content here may be incomplete, contain placeholder text, or be subject to significant changes.\nGuidelines\nContent is work-in-progress\nMay contain incomplete sections\nSubject to review and revision\nNot suitable for production reference",
        "startIndex": 0,
        "preview": "Draft Documentation\nThis section contains documentation that is currently being written and developed. Content here may be incomplete, contain placeho..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "drafts/test-error-display",
    "title": "Test Error Display",
    "category": "Test",
    "url": "/docs/drafts/test-error-display",
    "chunks": [
      {
        "id": "drafts/test-error-display-chunk-0",
        "text": "Test Error Display\nThis is a test page to verify that our front-matter error display is working.\nCode with Front-Matter (Should be fine)\n`csharp{\ntitle: \"Good Example\"\ndescription: \"This has proper front-matter\"\nframework: \"NET8\"\ncategory: \"Test\"\ndifficulty: \"BEGINNER\"\ntags: [\"Test\"]\n}\npublic class GoodExample {\n    public string Message { get; set; } = \"I have front-matter!\";\n}\n`\nCode WITHOUT Front-Matter (Should show error)\n`csharp\npublic class BadExample {\n    public string Message { get; set; } = \"I need front-matter!\";\n}\n`\nAnother Bad Example\n`javascript\nfunction badFunction() {\n    console.log(\"This JS code also needs front-matter!\");\n}\n`\nNon-Code Block (Should be fine)\n`text\nThis is just text, no error needed.\n`",
        "startIndex": 0,
        "preview": "Test Error Display\nThis is a test page to verify that our front-matter error display is working.\nCode with Front-Matter (Should be fine)\n`csharp{\ntitl..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "future/README",
    "title": "Future Versions Roadmap",
    "category": "Roadmap",
    "url": "/docs/future/README",
    "chunks": [
      {
        "id": "future/README-chunk-0",
        "text": "Future Versions Roadmap\nOverview\nThese versions represent the long-term vision for Whizbang, building on the solid foundation established in v0 1 0-v0 5 0 Each future version focuses on a specific theme while maintaining backward compatibility Version Timeline\nv0 6 0 - Production Hardening\nTheme: Enterprise-ready features  \nTarget: Q3 2025\nKey Features:\nOpenTelemetry Integration: Full observability\nSecurity: Encryption, authorization, audit logging\nCompliance: GDPR, data retention, PII handling\nAdvanced Policies: Caching, rate limiting, authorization\nMonitoring Dashboard: Real-time metrics and health\nv0 7 0 - Performance & Scale\nTheme: High-performance optimizations  \nTarget: Q4 2025\nKey Features:\nZero Allocation: Memory-efficient operations\nAOT Support: Full trimming compatibility\nSIMD Operations: Vectorized processing\nPartitioning: Event stream partitioning\nLoad Balancing: Smart work distribution\nv0 8 0 - Cloud Native\nTheme: Cloud-native capabilities  \nTarget: Q1 2026\nKey Features:\nKubernetes Operator: Auto-scaling, management\nServerless Adapters: Lambda, Azure Functions\nCloud Storage: S3, Azure Blob integration\nService Mesh: Istio/Linkerd integration\nMulti-Region: Cross-region replication\nv0 9 0 - Innovation\nTheme: Advanced and experimental features  \nTarget: Q2 2026\nKey Features:\nEffect System: Track and control side effects\nPure Function Verification: Compile-time purity\nAI Integration: Intelligent routing and optimization\nTime Travel Debugging: Production replay\nVisual Programming: Node-based workflow editor\nFeature Deep Dives\nProduction Hardening (v0 6 0)\nObservability\n`csharp\n[Trace]\n[Metric(\"order processing time\")]\n[Log(Level Debug)]\npublic class OrderReceptor : IReceptor<CreateOrder> {\n    // Automatic instrumentation via attributes\n}\n`\nSecurity\n`csharp\n[Authorize(Policy = \"OrderAdmin\")]\n[Audit(Level = AuditLevel Full)]\n[EncryptPII]\npublic class OrderReceptor : IReceptor<CreateOrder> {\n    // Security policies applied automatically\n}\n`\nPerformance & Scale (v0 7",
        "startIndex": 0,
        "preview": "Future Versions Roadmap\nOverview\nThese versions represent the long-term vision for Whizbang, building on the solid foundation established in v0 1 0-v0..."
      },
      {
        "id": "future/README-chunk-1",
        "text": "0) Observability `csharp [Trace] [Metric(\"order processing time\")] [Log(Level Debug)] public class OrderReceptor : IReceptor<CreateOrder> { // Automatic instrumentation via attributes } ` Security `csharp [Authorize(Policy = \"OrderAdmin\")] [Audit(Level = AuditLevel Full)] [EncryptPII] public class OrderReceptor : IReceptor<CreateOrder> { // Security policies applied automatically } ` Performance & Scale (v0 7 0)\nZero Allocation\n`csharp\n// All operations use object pooling and spans\npublic readonly struct OrderCommand {\n    public ReadOnlySpan<byte> CustomerId { get; }\n    public ReadOnlySpan<OrderItem> Items { get; }\n}\n`\nAOT Support\n`csharp\n// Full trimming and native AOT compilation\n[JsonSerializable(typeof(OrderCreated))]\n[WhizbangAot]\npublic partial class OrderContext : JsonSerializerContext { }\n`\nCloud Native (v0 8 0)\nKubernetes Operator\n`yaml\napiVersion: whizbang io/v1\nkind: WhizbangDeployment\nmetadata:\n  name: order-service\nspec:\n  replicas:\n    min: 2\n    max: 10\n  autoscaling:\n    metric: eventLag\n    target: 1000\n`\nServerless\n`csharp\n[Lambda]\npublic class OrderFunction : WhizbangFunction<CreateOrder, OrderCreated> {\n    // Automatically deployed as Lambda function\n}\n`\nInnovation (v0 9 0)\nEffect System\n`csharp\n[Pure]  // Verified at compile time\npublic Effect<OrderCreated> CreateOrder(CreateOrder cmd) {\n    return Effect Validate(cmd) Map(c => new OrderCreated(c Id))",
        "startIndex": 2009,
        "preview": "0) Observability `csharp [Trace] [Metric(\"order processing time\")] [Log(Level Debug)] public class OrderReceptor : IReceptor<CreateOrder> { // Automat..."
      },
      {
        "id": "future/README-chunk-2",
        "text": "autoscaling: metric: eventLag target: 1000 ` Serverless `csharp [Lambda] public class OrderFunction : WhizbangFunction<CreateOrder, OrderCreated> { // Automatically deployed as Lambda function } ` Innovation (v0 9 0) Effect System `csharp [Pure] // Verified at compile time public Effect<OrderCreated> CreateOrder(CreateOrder cmd) { return Effect Validate(cmd) Map(c => new OrderCreated(c Id)) Tap(e => Log(e));  // Effects tracked\n}\n`\nAI Integration\n`csharp\n[AIOptimized]\npublic class SmartDispatcher : IDispatcher {\n    // Uses ML to predict best routing path\n    // Learns from historical performance data\n    // Automatically optimizes over time\n}\n`\nResearch Areas\nPerformance Research\nHardware acceleration (GPU/FPGA)\nCustom memory allocators\nLock-free data structures\nio_uring integration\nDistributed Systems Research\nConsensus algorithms (Raft/Paxos)\nCRDTs for conflict resolution\nByzantine fault tolerance\nQuantum-resistant cryptography\nLanguage Research\nLinear types for resource management\nDependent types for correctness\nEffect handlers\nAlgebraic effects\nAI/ML Research\nPredictive scaling\nAnomaly detection\nAutomated optimization\nNatural language queries\nCommunity Involvement\nThese future versions will be shaped by community feedback:\nRFC Process\nEach major feature will have an RFC (Request for Comments):\nProposal published\nCommunity discussion (30 days)\nRevision based on feedback\nFinal decision\nImplementation\nExperimental Flags\nFeatures can be tried early via experimental flags:\n`csharp\nservices AddWhizbang(options => {\n    options EnableExperimental(Features EffectSystem);\n    options EnableExperimental(Features AIRouting);\n});\n`\nBeta Program\nEarly access to future versions:\nBeta releases 3 months before GA\nDedicated support channel\nInfluence final design\nRecognition in release notes\nSuccess Metrics\nAdoption Goals\nv0 6 0: 100+ production deployments\nv0 7 0: 1M+ messages/second achieved\nv0 8 0: 50+ Kubernetes deployments\nv0 9 0: Industry innovation award\nTechnical Goals\nZero security vulnerabilities\n99 999% uptime achieved\n< 1ms p99 latency maintained\n100% backward compatibility\nMigration Strategy\nEach version maintains compatibility:\n`csharp\n// v0 6 0 code still works in v0 9 0\nservices AddWhizbang() UsePostgreSQL()",
        "startIndex": 3021,
        "preview": "autoscaling: metric: eventLag target: 1000 ` Serverless `csharp [Lambda] public class OrderFunction : WhizbangFunction<CreateOrder, OrderCreated> { //..."
      },
      {
        "id": "future/README-chunk-3",
        "text": "v0 8 0: 50+ Kubernetes deployments v0 9 0: Industry innovation award Technical Goals Zero security vulnerabilities 99 999% uptime achieved < 1ms p99 latency maintained 100% backward compatibility Migration Strategy Each version maintains compatibility: `csharp // v0 6 0 code still works in v0 9 0 services AddWhizbang() UsePostgreSQL() UseKafka();\n`\nNew features are additive:\n`csharp\n// v0 9 0 with new features\nservices AddWhizbang() UsePostgreSQL() UseKafka() UseEffects()  // New in v0 9 0 UseAI();      // New in v0 9 0\n`\nGet Involved\nHelp shape the future of Whizbang:\nJoin discussions: https://github com/whizbang/whizbang/discussions\nPropose features: https://github com/whizbang/whizbang/rfcs\nContribute code: https://github com/whizbang/whizbang\nShare feedback: feedback@whizbang dev\nSummary\nThe future of Whizbang is:\nProduction Ready (v0 6 0)\nBlazing Fast (v0 7 0)\nCloud Native (v0 8 0)\nInnovative (v0 9 0)\nAll while maintaining our core principles:\nZero reflection\nProgressive enhancement\nExceptional developer experience\nComprehensive testing\nPerformance by default",
        "startIndex": 4888,
        "preview": "v0 8 0: 50+ Kubernetes deployments v0 9 0: Industry innovation award Technical Goals Zero security vulnerabilities 99 999% uptime achieved < 1ms p99 l..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/_folder",
    "title": "old-v1.0.0/_folder",
    "category": "General",
    "url": "/docs/old-v1.0.0/_folder",
    "chunks": [
      {
        "id": "old-v1.0.0/_folder-chunk-0",
        "text": "Release v1.0.0 - Initial Release\nRelease Notes\nCore Whizbang functionality\nEvent sourcing foundation\nBasic projection system\nCommand and query handling\nInitial documentation\nFeatures\nComplete CQRS implementation\nEvent sourcing with aggregates\nProjection management\nAspect-oriented programming support\nBasic repository patterns\nThis is the initial stable release of the Whizbang .NET library providing the foundational event sourcing and CQRS capabilities.",
        "startIndex": 0,
        "preview": "Release v1.0.0 - Initial Release\nRelease Notes\nCore Whizbang functionality\nEvent sourcing foundation\nBasic projection system\nCommand and query handlin..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/advanced/advanced-scenarios",
    "title": "Advanced Scenarios",
    "category": "Advanced",
    "url": "/docs/old-v1.0.0/advanced/advanced-scenarios",
    "chunks": [
      {
        "id": "old-v1.0.0/advanced/advanced-scenarios-chunk-0",
        "text": "Advanced Scenarios\nThis document covers advanced scenarios for production deployments, including data seeding, Backend-for-Frontend (BFF) patterns, and central control commands Data Seeding in Scaled Environments\nWhen deploying to scaled-out environments (Kubernetes, multiple replicas), data seeding must be coordinated to avoid duplicates or race conditions Coordinated Seeding\n`csharp{\ntitle: \"Coordinated Data Seeding\"\ndescription: \"Seed data in scaled environments without duplicates\"\nframework: \"NET8\"\ncategory: \"Deployment\"\ndifficulty: \"ADVANCED\"\ntags: [\"Seeding\", \"Deployment\", \"Kubernetes\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\"]\nusingStatements: [\"Microsoft Extensions Hosting\", \"Whizbang\", \"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Microsoft Extensions Hosting;\nusing Whizbang;\npublic class DataSeeder : IHostedService {\n    private readonly IWhizbang _whizbang;\n    private readonly IDistributedLock _distributedLock;\n    public DataSeeder(IWhizbang whizbang, IDistributedLock distributedLock) {\n        _whizbang = whizbang;\n        _distributedLock = distributedLock;\n    }\n    public async Task StartAsync(CancellationToken cancellationToken) {\n        // Only ONE replica seeds data (distributed lock)\n        await using var @lock = await _distributedLock AcquireAsync(\"data-seeding\", TimeSpan FromMinutes(5));\n        if (@lock = null) {\n            await SeedDataAsync();\n        }\n    }\n    private async Task SeedDataAsync() {\n        // Check if already seeded\n        var alreadySeeded = await CheckIfSeededAsync();\n        if (alreadySeeded) {\n            return;\n        }\n        // Seed master data\n        await SeedProductCatalogAsync();\n        await SeedDefaultTenantsAsync();\n        await SeedReferenceDataAsync();\n        // Mark as seeded\n        await MarkAsSeededAsync();\n    }\n    public Task StopAsync(CancellationToken cancellationToken) => Task CompletedTask;\n}\n`\nIdempotent Seeding\nMake seeding operations idempotent:\n`csharp{\ntitle: \"Idempotent Seeding\"\ndescription: \"Seed data that can be run multiple times safely\"\nframework: \"NET8\"\ncategory: \"Deployment\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Seeding\", \"Idempotence\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\npublic class ProductCatalogSeeder {\n    private readonly IRepository<ProductCatalog> _repository;\n    public ProductCatalogSeeder(IRepository<ProductCatalog> repository) {\n        _repository = repository;\n    }\n    public async Task SeedAsync() {\n        // Idempotent: only create if doesn't exist\n        var catalog = await _repository FindAsync(WellKnownIds DefaultCatalog);\n        if (catalog == null) {\n            catalog = new ProductCatalog(WellKnownIds",
        "startIndex": 0,
        "preview": "Advanced Scenarios\nThis document covers advanced scenarios for production deployments, including data seeding, Backend-for-Frontend (BFF) patterns, an..."
      },
      {
        "id": "old-v1.0.0/advanced/advanced-scenarios-chunk-1",
        "text": "using System Threading Tasks; using Whizbang; public class ProductCatalogSeeder { private readonly IRepository<ProductCatalog> _repository; public ProductCatalogSeeder(IRepository<ProductCatalog> repository) { _repository = repository; } public async Task SeedAsync() { // Idempotent: only create if doesn't exist var catalog = await _repository FindAsync(WellKnownIds DefaultCatalog); if (catalog == null) { catalog = new ProductCatalog(WellKnownIds DefaultCatalog, \"Default Catalog\");\n            catalog AddProduct(new Product(\"Widget\", 19 99m));\n            catalog AddProduct(new Product(\"Gadget\", 29 99m));\n            catalog AddProduct(new Product(\"Doohickey\", 39 99m));\n            await _repository SaveAsync(catalog);\n        }\n    }\n}\n`\nEnvironment-Specific Seeding\nDifferent data for dev/staging/production:\n`csharp{\ntitle: \"Environment-Specific Seeding\"\ndescription: \"Seed different data per environment\"\nframework: \"NET8\"\ncategory: \"Deployment\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Seeding\", \"Environments\"]\nnugetPackages: [\"Whizbang Core\", \"Microsoft Extensions Hosting\"]\nusingStatements: [\"Microsoft Extensions Hosting\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System Threading Tasks;\nusing Microsoft Extensions Hosting;\npublic class EnvironmentSeeder : IHostedService {\n    private readonly IHostEnvironment _env;\n    private readonly IDataSeeder _seeder;\n    public EnvironmentSeeder(IHostEnvironment env, IDataSeeder seeder) {\n        _env = env;\n        _seeder = seeder;\n    }\n    public async Task StartAsync(CancellationToken cancellationToken) {\n        if (_env IsDevelopment()) {\n            // Seed lots of test data for local development\n            await _seeder SeedDevelopmentDataAsync();\n            await _seeder SeedTestTenantsAsync(count: 10);\n            await _seeder SeedSampleOrdersAsync(count: 1000);\n        }\n        else if (_env IsStaging()) {\n            // Seed realistic production-like data\n            await _seeder SeedProductionLikeDataAsync();\n            await _seeder SeedTestTenantsAsync(count: 2);  // Fewer test tenants\n        }\n        else if (_env IsProduction()) {\n            // Only seed essential master data\n            await _seeder SeedMasterDataAsync();\n            // Do NOT seed test data in production\n        }\n    }\n    public Task StopAsync(CancellationToken cancellationToken) => Task CompletedTask;\n}\n`\nKubernetes Init Container Seeding\nUse Kubernetes init containers for pre-startup seeding:\n`yaml{\ntitle: \"Kubernetes Init Container for Data Seeding\"\ndescription: \"Kubernetes deployment configuration with init container for data seeding\"\nframework: \"Kubernetes\"\ncategory: \"Advanced\"\ndifficulty: \"ADVANCED\"\ntags: [\"Kubernetes\", \"Seeding\", \"Deployment\", \"Init Containers\"]\nfilename: \"orders-service-deployment",
        "startIndex": 2926,
        "preview": "using System Threading Tasks; using Whizbang; public class ProductCatalogSeeder { private readonly IRepository<ProductCatalog> _repository; public Pro..."
      },
      {
        "id": "old-v1.0.0/advanced/advanced-scenarios-chunk-2",
        "text": "StopAsync(CancellationToken cancellationToken) => Task CompletedTask; } ` Kubernetes Init Container Seeding Use Kubernetes init containers for pre-startup seeding: `yaml{ title: \"Kubernetes Init Container for Data Seeding\" description: \"Kubernetes deployment configuration with init container for data seeding\" framework: \"Kubernetes\" category: \"Advanced\" difficulty: \"ADVANCED\" tags: [\"Kubernetes\", \"Seeding\", \"Deployment\", \"Init Containers\"] filename: \"orders-service-deployment yaml\"\nshowLineNumbers: true\n}\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: orders-service\nspec:\n  replicas: 3\n  template:\n    spec:\n      Init container runs BEFORE main container\n      initContainers:\nname: seed-data\n        image: myapp/orders-service:latest\n        command: [\"dotnet\", \"OrdersService dll\", \"--seed-only\"]\n        env:\nname: ASPNETCORE_ENVIRONMENT\n          value: \"Production\"\n      Main application container\n      containers:\nname: orders-service\n        image: myapp/orders-service:latest\n`\nApplication code:\n`csharp{\ntitle: \"Program cs Seeding Logic\"\ndescription: \"Application startup logic for seed-only mode\"\nframework: \"NET8\"\ncategory: \"Advanced\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Seeding\", \"Startup\", \"Program cs\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\n// In Program cs\nif (args Contains(\"--seed-only\")) {\n    await SeedDataAsync(app Services);\n    return;  // Exit after seeding\n}\nawait app RunAsync();  // Normal startup\n`\n---\nBackend-for-Frontend (BFF) Support\nBFF pattern creates backend APIs tailored to specific frontend applications (web, mobile, desktop) BFF Architecture\n`\n┌─────────────┐       ┌─────────────┐       ┌─────────────┐\n│  Web App    │       │ Mobile App  │       │ Desktop App │\n│  (React)    │       │  (Swift)    │       │  (WinUI)    │\n└──────┬──────┘       └──────┬──────┘       └──────┬──────┘\n       │                     │                     │\n       ↓                     ↓                     ↓\n┌─────────────┐       ┌─────────────┐       ┌─────────────┐\n│   Web BFF   │       │  Mobile BFF │       │ Desktop BFF │\n│  (GraphQL)  │       │   (REST)    │       │  (gRPC)     │\n└──────┬──────┘       └──────┬──────┘       └──────┬──────┘\n       │                     │                     │\n       └─────────────┬───────┴─────────────────────┘\n                     ↓\n              ┌──────────────┐\n              │   Whizbang   │\n              │  Microservices│\n              └──────────────┘\n`\nCreating a BFF with Whizbang\n`csharp{\ntitle: \"Web BFF Implementation\"\ndescription: \"Backend-for-Frontend for web application\"\nframework: \"NET8\"\ncategory: \"BFF\"\ndifficulty: \"ADVANCED\"\ntags: [\"BFF\", \"GraphQL\", \"Web\"]\nnugetPackages: [\"Whizbang Core\", \"HotChocolate\"]\nfilename: \"WebBFF/Program cs\"\nusingStatements: [\"Microsoft AspNetCore Builder\", \"Whizbang\", \"HotChocolate\"]\nshowLineNumbers: true\n}\nusing Microsoft AspNetCore",
        "startIndex": 5277,
        "preview": "StopAsync(CancellationToken cancellationToken) => Task CompletedTask; } ` Kubernetes Init Container Seeding Use Kubernetes init containers for pre-sta..."
      },
      {
        "id": "old-v1.0.0/advanced/advanced-scenarios-chunk-3",
        "text": "Whizbang │ │ Microservices│ └──────────────┘ ` Creating a BFF with Whizbang `csharp{ title: \"Web BFF Implementation\" description: \"Backend-for-Frontend for web application\" framework: \"NET8\" category: \"BFF\" difficulty: \"ADVANCED\" tags: [\"BFF\", \"GraphQL\", \"Web\"] nugetPackages: [\"Whizbang Core\", \"HotChocolate\"] filename: \"WebBFF/Program cs\" usingStatements: [\"Microsoft AspNetCore Builder\", \"Whizbang\", \"HotChocolate\"] showLineNumbers: true } using Microsoft AspNetCore Builder;\nusing Whizbang;\nusing HotChocolate;\nvar builder = WebApplication CreateBuilder(args);\n// Add Whizbang as client (sends commands/queries to backend services)\nbuilder Services AddWhizbangClient(options => {\n    options UseDomainOwnership(domains => {\n        domains RegisterDomain(\"Orders\", \"http://orders-service\");\n        domains RegisterDomain(\"Inventory\", \"http://inventory-service\");\n        domains RegisterDomain(\"Customers\", \"http://customers-service\");\n    });\n});\n// Add GraphQL for web frontend\nbuilder Services AddGraphQLServer() AddQueryType<WebQuery>() AddMutationType<WebMutation>();\nvar app = builder Build();\napp MapGraphQL();\napp Run();\n// GraphQL types optimized for web UI\npublic class WebQuery {\n    public async Task<CustomerDashboard> GetDashboardAsync(\n        [Service] IWhizbang whizbang,\n        Guid customerId\n    ) {\n        // Aggregate data from multiple services\n        var customer = await whizbang QueryAsync(new GetCustomer(customerId));\n        var orders = await whizbang QueryAsync(new GetCustomerOrders(customerId));\n        var recommendations = await whizbang QueryAsync(new GetRecommendations(customerId));\n        // Return web-optimized payload\n        return new CustomerDashboard(customer, orders, recommendations);\n    }\n}\n`\nMobile BFF (Optimized for Bandwidth)\n`csharp{\ntitle: \"Mobile BFF Implementation\"\ndescription: \"Backend-for-Frontend for mobile apps (minimal payloads)\"\nframework: \"NET8\"\ncategory: \"BFF\"\ndifficulty: \"ADVANCED\"\ntags: [\"BFF\", \"Mobile\", \"REST\"]\nnugetPackages: [\"Whizbang Core\", \"Microsoft AspNetCore\"]\nfilename: \"MobileBFF/Program cs\"\nusingStatements: [\"Microsoft AspNetCore Builder\", \"Microsoft AspNetCore Http\", \"Whizbang\", \"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Microsoft AspNetCore Builder;\nusing Microsoft AspNetCore Http;\nusing Whizbang;\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbangClient(/ /);\nvar app = builder Build();\n// Mobile-optimized endpoints (minimal payloads, pagination)\napp MapGet(\"/mobile/orders\", async (IWhizbang whizbang, Guid customerId, int page) => {\n    var orders = await whizbang",
        "startIndex": 7735,
        "preview": "Whizbang │ │ Microservices│ └──────────────┘ ` Creating a BFF with Whizbang `csharp{ title: \"Web BFF Implementation\" description: \"Backend-for-Fronten..."
      },
      {
        "id": "old-v1.0.0/advanced/advanced-scenarios-chunk-4",
        "text": "using System Threading Tasks; using Microsoft AspNetCore Builder; using Microsoft AspNetCore Http; using Whizbang; var builder = WebApplication CreateBuilder(args); builder Services AddWhizbangClient(/ /); var app = builder Build(); // Mobile-optimized endpoints (minimal payloads, pagination) app MapGet(\"/mobile/orders\", async (IWhizbang whizbang, Guid customerId, int page) => { var orders = await whizbang QueryAsync(new GetCustomerOrders(customerId) {\n        Page = page,\n        PageSize = 20,  // Mobile shows 20 at a time\n        IncludeFields = new[] { \"id\", \"status\", \"total\", \"placedAt\" }  // Minimal fields\n    });\n    // Return mobile-friendly response\n    return Results Ok(new {\n        orders = orders Select(o => new {\n            id = o Id,\n            status = o Status,\n            total = $\"${o Total:F2}\",  // Pre-formatted for display\n            date = o PlacedAt ToString(\"MMM dd\")\n        }),\n        hasMore = orders Count == 20\n    });\n});\napp Run();\n`\nBFF Aggregation Pattern\nBFFs aggregate data from multiple services:\n`csharp{\ntitle: \"BFF Data Aggregation\"\ndescription: \"Aggregate data from multiple services in BFF\"\nframework: \"NET8\"\ncategory: \"BFF\"\ndifficulty: \"ADVANCED\"\ntags: [\"BFF\", \"Aggregation\", \"Microservices\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Linq\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Linq;\nusing System Threading Tasks;\nusing Whizbang;\npublic class OrderDetailsAggregator {\n    private readonly IWhizbang _whizbang;\n    public OrderDetailsAggregator(IWhizbang whizbang) {\n        _whizbang = whizbang;\n    }\n    public async Task<OrderDetailsViewModel> GetOrderDetailsAsync(Guid orderId) {\n        // Query multiple services in parallel\n        var orderTask = _whizbang QueryAsync(new GetOrder(orderId));\n        var customerTask = _whizbang QueryAsync(new GetCustomer(/ customerId from order /));\n        var inventoryTask = _whizbang QueryAsync(new GetInventoryStatus(orderId));\n        var shippingTask = _whizbang QueryAsync(new GetShippingStatus(orderId));\n        await Task WhenAll(orderTask, customerTask, inventoryTask, shippingTask);\n        // Aggregate into view model\n        return new OrderDetailsViewModel {\n            Order = orderTask Result,\n            Customer = customerTask Result,\n            Inventory = inventoryTask Result,\n            Shipping = shippingTask Result,\n            EstimatedDelivery = CalculateEstimatedDelivery(shippingTask Result)\n        };\n    }\n}\n`\n---\nCentral Control Commands\nCentral control plane for managing distributed services (configuration changes, projection rebuilds, diagnostics)",
        "startIndex": 9947,
        "preview": "using System Threading Tasks; using Microsoft AspNetCore Builder; using Microsoft AspNetCore Http; using Whizbang; var builder = WebApplication Create..."
      },
      {
        "id": "old-v1.0.0/advanced/advanced-scenarios-chunk-5",
        "text": "shippingTask); // Aggregate into view model return new OrderDetailsViewModel { Order = orderTask Result, Customer = customerTask Result, Inventory = inventoryTask Result, Shipping = shippingTask Result, EstimatedDelivery = CalculateEstimatedDelivery(shippingTask Result) }; } } ` --- Central Control Commands Central control plane for managing distributed services (configuration changes, projection rebuilds, diagnostics) Control Plane Architecture\n`\n┌────────────────────────────────────────┐\n│      Whizbang Control Dashboard        │\n│  (Web UI for operators/administrators) │\n└───────────────┬────────────────────────┘\n                │\n                ↓\n┌───────────────────────────────────────┐\n│       Control Plane Service           │\n│   (Sends control commands to services)│\n└───────────────┬───────────────────────┘\n                │\n       ┌────────┴────────┬──────────┐\n       ↓                 ↓          ↓\n┌──────────┐      ┌──────────┐  ┌──────────┐\n│ Orders   │      │Inventory │  │ Shipping │\n│ Service  │      │ Service  │  │ Service  │\n└──────────┘      └──────────┘  └──────────┘\n`\nControl Commands\n`csharp{\ntitle: \"Control Command Definitions\"\ndescription: \"Central commands for managing services\"\nframework: \"NET8\"\ncategory: \"Control Plane\"\ndifficulty: \"ADVANCED\"\ntags: [\"Control Plane\", \"Operations\", \"Commands\"]\nnugetPackages: [\"Whizbang ControlPlane\"]\nusingStatements: [\"System\", \"Whizbang ControlPlane\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang ControlPlane;\n// Rebuild a projection across all services\npublic record RebuildProjection(\n    string ProjectionName,\n    DateTimeOffset StartFrom = null\n) : ControlCommand;\n// Change log level dynamically\npublic record SetLogLevel(\n    string Category,\n    LogLevel Level\n) : ControlCommand;\n// Enable/disable feature flags\npublic record ToggleFeature(\n    string FeatureName,\n    bool Enabled\n) : ControlCommand;\n// Trigger health check\npublic record RunHealthCheck() : ControlCommand;\n// Clear caches\npublic record ClearCaches(\n    string[] CacheNames\n) : ControlCommand;\n`\nControl Command Handler\nServices implement handlers for control commands:\n`csharp{\ntitle: \"Control Command Handler\"\ndescription: \"Handle central control commands in services\"\nframework: \"NET8\"\ncategory: \"Control Plane\"\ndifficulty: \"ADVANCED\"\ntags: [\"Control Plane\", \"Handlers\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang ControlPlane\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Microsoft Extensions Logging\", \"Whizbang ControlPlane\", \"Whizbang Projections\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Microsoft Extensions Logging;\nusing Whizbang ControlPlane;\nusing Whizbang",
        "startIndex": 12212,
        "preview": "shippingTask); // Aggregate into view model return new OrderDetailsViewModel { Order = orderTask Result, Customer = customerTask Result, Inventory = i..."
      },
      {
        "id": "old-v1.0.0/advanced/advanced-scenarios-chunk-6",
        "text": "in services\" framework: \"NET8\" category: \"Control Plane\" difficulty: \"ADVANCED\" tags: [\"Control Plane\", \"Handlers\"] nugetPackages: [\"Whizbang Core\", \"Whizbang ControlPlane\", \"Whizbang Projections\"] usingStatements: [\"System\", \"System Threading Tasks\", \"Microsoft Extensions Logging\", \"Whizbang ControlPlane\", \"Whizbang Projections\"] showLineNumbers: true } using System; using System Threading Tasks; using Microsoft Extensions Logging; using Whizbang ControlPlane; using Whizbang Projections;\npublic class RebuildProjectionHandler {\n    private readonly IProjectionEngine _projectionEngine;\n    private readonly ILogger _logger;\n    public RebuildProjectionHandler(IProjectionEngine projectionEngine, ILogger logger) {\n        _projectionEngine = projectionEngine;\n        _logger = logger;\n    }\n    public async Task Handle(RebuildProjection command) {\n        _logger LogWarning(\"Rebuilding projection {ProjectionName} from {StartFrom}\",\n            command ProjectionName,\n            command StartFrom DateTimeOffset MinValue\n        );\n        // Stop projection\n        await _projectionEngine StopProjectionAsync(command ProjectionName);\n        // Clear projection data\n        await _projectionEngine ClearProjectionAsync(command ProjectionName);\n        // Restart from specified point\n        await _projectionEngine StartProjectionAsync(command ProjectionName, command StartFrom);\n        _logger LogInformation(\"Projection {ProjectionName} rebuild started\", command ProjectionName);\n    }\n}\n`\nSending Control Commands\nFrom the control dashboard:\n`csharp{\ntitle: \"Sending Control Commands\"\ndescription: \"Send control commands from central dashboard\"\nframework: \"NET8\"\ncategory: \"Control Plane\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Control Plane\", \"Dashboard\"]\nnugetPackages: [\"Whizbang ControlPlane\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang ControlPlane\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang ControlPlane;\npublic class ControlPlaneClient {\n    private readonly IWhizbangControlPlane _controlPlane;\n    public ControlPlaneClient(IWhizbangControlPlane controlPlane) {\n        _controlPlane = controlPlane;\n    }\n    public async Task RebuildProjectionAcrossAllServicesAsync(string projectionName) {\n        // Send command to ALL services that have this projection\n        await _controlPlane BroadcastAsync(new RebuildProjection(projectionName));\n    }\n    public async Task RebuildProjectionOnSpecificServiceAsync(string service, string projection) {\n        // Send command to specific service only\n        await _controlPlane SendToServiceAsync(service, new RebuildProjection(projection));\n    }\n    public async Task SetLogLevelGloballyAsync(string category, LogLevel level) {\n        // Change log level across all services\n        await _controlPlane BroadcastAsync(new SetLogLevel(category, level));\n    }\n}\n`\nNext Steps\nWhizbang Dashboard - Visual control plane\nObservability - Monitoring and tracing\nDistributed Messaging - Microservices architecture",
        "startIndex": 14495,
        "preview": "in services\" framework: \"NET8\" category: \"Control Plane\" difficulty: \"ADVANCED\" tags: [\"Control Plane\", \"Handlers\"] nugetPackages: [\"Whizbang Core\", \"..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/advanced/configuration",
    "title": "Configuration",
    "category": "Advanced",
    "url": "/docs/old-v1.0.0/advanced/configuration",
    "chunks": [
      {
        "id": "old-v1.0.0/advanced/configuration-chunk-0",
        "text": "Configuration\nWhizbang provides a comprehensive configuration system that allows you to customize every aspect of the runtime, from storage backends to messaging systems, observability, and performance tuning Basic Configuration\nMinimal Setup\n`csharp{\ntitle: \"Minimal Whizbang Setup\"\ndescription: \"Basic Whizbang configuration with assembly scanning\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"BEGINNER\"\ntags: [\"Setup\", \"Configuration\", \"Assembly Scanning\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft AspNetCore Builder\", \"Whizbang\"]\nshowLineNumbers: true\n}\n// Program cs\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbang(options => {\n    // Scan assemblies for handlers, aggregates, and projections\n    options ScanAssembly(typeof(Program) Assembly);\n});\nvar app = builder Build();\napp Run();\n`\nWith Storage Backend\n`csharp{\ntitle: \"Whizbang with Storage Backend\"\ndescription: \"Configuration with PostgreSQL event store\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Event Store\", \"PostgreSQL\", \"Storage\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang\", \"Whizbang EventSourcing\"]\nshowLineNumbers: true\n}\nbuilder Services AddWhizbang(options => {\n    options ScanAssembly(typeof(Program) Assembly);\n    // Configure event store\n    options UseEventSourcing(es => {\n        es UsePostgres(connectionString);\n        // or es UseSqlServer(connectionString);\n        // or es UseInMemory(); // for testing\n    });\n});\n`\nStorage Configuration\nEvent Store Options\n`csharp{\ntitle: \"PostgreSQL Event Store Configuration\"\ndescription: \"Detailed PostgreSQL event store options\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Event Store\", \"PostgreSQL\", \"Schema\", \"Snapshots\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang EventSourcing\"]\nshowLineNumbers: true\n}\noptions UseEventSourcing(es => {\n    es UsePostgres(connectionString, postgres => {\n        postgres SchemaName = \"events\";\n        postgres TableName = \"event_store\";\n        postgres SnapshotInterval = 100;\n        postgres EnableAutomaticMigrations = true;\n    });\n});\n`\nProjection Store Options\n`csharp{\ntitle: \"Projection Store Configuration\"\ndescription: \"Multiple projection store options including PostgreSQL and MongoDB\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"PostgreSQL\", \"MongoDB\", \"Storage\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang Projections\"]\nshowLineNumbers: true\n}\noptions UseProjections(proj => {\n    // Use same database as event store\n    proj UseSameStoreAsEvents();\n    // Or use different database\n    proj UsePostgres(projectionConnectionString, postgres => {\n        postgres SchemaName = \"projections\";\n        postgres",
        "startIndex": 0,
        "preview": "Configuration\nWhizbang provides a comprehensive configuration system that allows you to customize every aspect of the runtime, from storage backends t..."
      },
      {
        "id": "old-v1.0.0/advanced/configuration-chunk-1",
        "text": "and MongoDB\" framework: \"NET8\" category: \"Configuration\" difficulty: \"INTERMEDIATE\" tags: [\"Projections\", \"PostgreSQL\", \"MongoDB\", \"Storage\"] filename: \"Program cs\" usingStatements: [\"Whizbang Projections\"] showLineNumbers: true } options UseProjections(proj => { // Use same database as event store proj UseSameStoreAsEvents(); // Or use different database proj UsePostgres(projectionConnectionString, postgres => { postgres SchemaName = \"projections\"; postgres EnableAutomaticMigrations = true;\n    });\n    // Or use MongoDB for projections\n    proj UseMongoDb(mongoConnectionString, mongo => {\n        mongo DatabaseName = \"whizbang_projections\";\n    });\n});\n`\nMessaging Configuration\nIn-Process Messaging\n`csharp{\ntitle: \"In-Process Messaging Configuration\"\ndescription: \"Configure in-process messaging for single application\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"BEGINNER\"\ntags: [\"Messaging\", \"In-Process\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang Messaging\"]\nshowLineNumbers: true\n}\noptions UseMessaging(msg => {\n    msg UseInProcess(); // Default - all handlers run in same process\n});\n`\nDistributed Messaging\n`csharp{\ntitle: \"Distributed Messaging with Kafka\"\ndescription: \"Configure Kafka for distributed messaging with retry policies\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Messaging\", \"Kafka\", \"Distributed\", \"Retry Policy\"]\nfilename: \"Program cs\"\nusingStatements: [\"System\", \"Whizbang Messaging\"]\nshowLineNumbers: true\n}\noptions UseMessaging(msg => {\n    msg UseKafka(kafka => {\n        kafka BootstrapServers = \"localhost:9092\";\n        kafka ConsumerGroup = \"whizbang-consumers\";\n        kafka EnableIdempotency = true;\n        kafka RetryPolicy = RetryPolicy ExponentialBackoff(\n            maxRetries: 5,\n            baseDelay: TimeSpan FromSeconds(1)\n        );\n    });\n    // or msg UseRabbitMQ( );\n    // or msg UseAzureServiceBus( );\n});\n`\nOutbox Pattern\n`csharp{\ntitle: \"Outbox Pattern Configuration\"\ndescription: \"Configure outbox pattern for reliable message delivery\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Outbox Pattern\", \"Messaging\", \"Reliability\"]\nfilename: \"Program cs\"\nusingStatements: [\"System\", \"Whizbang Messaging\"]\nshowLineNumbers: true\n}\noptions UseMessaging(msg => {\n    msg UseOutbox(outbox => {\n        outbox ProcessingInterval = TimeSpan FromSeconds(5);\n        outbox BatchSize = 100;\n        outbox RetryFailedMessages = true;\n        outbox MaxRetries = 3;\n    });\n});\n`\nHandler Configuration\nAssembly Scanning\n`csharp{\ntitle: \"Assembly Scanning Configuration\"\ndescription: \"Configure assembly scanning for handlers and aggregates\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"BEGINNER\"\ntags: [\"Assembly Scanning\", \"Handlers\", \"Discovery\"]\nfilename: \"Program",
        "startIndex": 2793,
        "preview": "and MongoDB\" framework: \"NET8\" category: \"Configuration\" difficulty: \"INTERMEDIATE\" tags: [\"Projections\", \"PostgreSQL\", \"MongoDB\", \"Storage\"] filename..."
      },
      {
        "id": "old-v1.0.0/advanced/configuration-chunk-2",
        "text": "outbox ProcessingInterval = TimeSpan FromSeconds(5); outbox BatchSize = 100; outbox RetryFailedMessages = true; outbox MaxRetries = 3; }); }); ` Handler Configuration Assembly Scanning `csharp{ title: \"Assembly Scanning Configuration\" description: \"Configure assembly scanning for handlers and aggregates\" framework: \"NET8\" category: \"Configuration\" difficulty: \"BEGINNER\" tags: [\"Assembly Scanning\", \"Handlers\", \"Discovery\"] filename: \"Program cs\"\nusingStatements: [\"Whizbang\"]\nshowLineNumbers: true\n}\noptions ScanAssembly(typeof(Program) Assembly);\noptions ScanAssemblies(\n    typeof(OrderHandlers) Assembly,\n    typeof(PaymentHandlers) Assembly\n);\n// Scan all assemblies in current directory\noptions ScanCurrentDirectory();\n`\nManual Registration\n`csharp{\ntitle: \"Manual Handler Registration\"\ndescription: \"Manually register specific handlers instead of assembly scanning\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Handlers\", \"Registration\", \"Manual\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang\"]\nshowLineNumbers: true\n}\noptions RegisterHandlers(handlers => {\n    handlers RegisterCommandHandler<PlaceOrderHandler>();\n    handlers RegisterEventHandler<OrderPlacedHandler>();\n    handlers RegisterQueryHandler<GetOrderHandler>();\n});\n`\nHandler Lifetime\n`csharp{\ntitle: \"Handler Lifetime Configuration\"\ndescription: \"Configure service lifetimes for handlers\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Handlers\", \"Lifetime\", \"Dependency Injection\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\noptions ConfigureHandlers(handlers => {\n    handlers DefaultLifetime = ServiceLifetime Scoped;\n    // Override specific handlers\n    handlers SetLifetime<ExpensiveHandler>(ServiceLifetime Singleton);\n});\n`\nProjection Configuration\nRegistration and Subscriptions\n`csharp{\ntitle: \"Projection Registration and Subscriptions\"\ndescription: \"Register projections with event subscriptions and partitioning\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Event Subscriptions\", \"Partitioning\", \"Backfill\"]\nfilename: \"Program cs\"\nusingStatements: [\"System\", \"Whizbang Projections\"]\nshowLineNumbers: true\n}\noptions UseProjections(proj => {\n    proj RegisterProjection<OrderSummaryProjection>(p => {\n        p Subscribe<OrderPlacedEvent>();\n        p Subscribe<OrderShippedEvent>();\n        p Subscribe<OrderCancelledEvent>();\n        // Backfill from specific point\n        p BackfillFrom = DateTimeOffset UtcNow AddDays(-30);\n        // Partition by customer for parallel processing\n        p PartitionBy = @event => ((dynamic)@event) CustomerId;\n    });\n});\n`\nPerformance Tuning\n`csharp{\ntitle: \"Projection Performance Tuning\"\ndescription: \"Configure projection performance settings for batch processing\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Performance\", \"Batch Processing\", \"Concurrency\"]\nfilename: \"Program cs\"\nusingStatements: [\"System\", \"Whizbang Projections\"]\nshowLineNumbers: true\n}\nproj ConfigurePerformance(perf => {\n    perf",
        "startIndex": 5150,
        "preview": "outbox ProcessingInterval = TimeSpan FromSeconds(5); outbox BatchSize = 100; outbox RetryFailedMessages = true; outbox MaxRetries = 3; }); }); ` Handl..."
      },
      {
        "id": "old-v1.0.0/advanced/configuration-chunk-3",
        "text": "= @event => ((dynamic)@event) CustomerId; }); }); ` Performance Tuning `csharp{ title: \"Projection Performance Tuning\" description: \"Configure projection performance settings for batch processing\" framework: \"NET8\" category: \"Configuration\" difficulty: \"ADVANCED\" tags: [\"Projections\", \"Performance\", \"Batch Processing\", \"Concurrency\"] filename: \"Program cs\" usingStatements: [\"System\", \"Whizbang Projections\"] showLineNumbers: true } proj ConfigurePerformance(perf => { perf BatchSize = 1000;\n    perf ConcurrentPartitions = Environment ProcessorCount;\n    perf CheckpointInterval = TimeSpan FromSeconds(10);\n    perf MaxLagBeforeAlert = TimeSpan FromMinutes(5);\n});\n`\nObservability Configuration\nOpenTelemetry Integration\n`csharp{\ntitle: \"OpenTelemetry Observability Configuration\"\ndescription: \"Configure OpenTelemetry with Jaeger and Application Insights exporters\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Observability\", \"OpenTelemetry\", \"Jaeger\", \"Application Insights\"]\nfilename: \"Program cs\"\nusingStatements: [\"System\", \"Microsoft Extensions Configuration\", \"Whizbang Observability\"]\nshowLineNumbers: true\n}\noptions UseObservability(obs => {\n    obs UseOpenTelemetry(otel => {\n        otel ServiceName = \"my-whizbang-service\";\n        otel ServiceVersion = \"1 0 0\";\n        // Export to Jaeger\n        otel AddJaegerExporter(jaeger => {\n            jaeger Endpoint = new Uri(\"http://localhost:14268\");\n        });\n        // Export to Application Insights\n        otel AddApplicationInsightsExporter(ai => {\n            ai ConnectionString = builder Configuration GetConnectionString(\"ApplicationInsights\");\n        });\n    });\n    // Built-in metrics\n    obs EnableMetrics = true;\n    obs EnableHealthChecks = true;\n});\n`\nLogging Configuration\n`csharp{\ntitle: \"Logging Configuration\"\ndescription: \"Configure structured logging with correlation IDs\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Logging\", \"Structured Logging\", \"Correlation IDs\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions Logging\", \"Whizbang Logging\"]\nshowLineNumbers: true\n}\noptions UseLogging(logging => {\n    logging LogLevel = LogLevel Information;\n    logging LogCommands = true;\n    logging LogEvents = true;\n    logging LogQueries = false; // Can be noisy\n    // Structured logging\n    logging UseStructuredLogging = true;\n    logging IncludeCorrelationIds = true;\n});\n`\nSecurity Configuration\nAuthentication & Authorization\n`csharp{\ntitle: \"Security and Authorization Configuration\"\ndescription: \"Configure authentication, authorization, and multi-tenancy\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Security\", \"Authentication\", \"Authorization\", \"Multi-Tenancy\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang Security\"]\nshowLineNumbers: true\n}\noptions UseSecurity(security => {\n    // Require authentication for all commands\n    security",
        "startIndex": 7878,
        "preview": "= @event => ((dynamic)@event) CustomerId; }); }); ` Performance Tuning `csharp{ title: \"Projection Performance Tuning\" description: \"Configure project..."
      },
      {
        "id": "old-v1.0.0/advanced/configuration-chunk-4",
        "text": "}); ` Security Configuration Authentication & Authorization `csharp{ title: \"Security and Authorization Configuration\" description: \"Configure authentication, authorization, and multi-tenancy\" framework: \"NET8\" category: \"Configuration\" difficulty: \"ADVANCED\" tags: [\"Security\", \"Authentication\", \"Authorization\", \"Multi-Tenancy\"] filename: \"Program cs\" usingStatements: [\"Whizbang Security\"] showLineNumbers: true } options UseSecurity(security => { // Require authentication for all commands security RequireAuthentication = true;\n    // Configure permissions\n    security ConfigureAuthorization(auth => {\n        auth RequirePermission<PlaceOrderCommand>(\"orders:write\");\n        auth RequirePermission<GetOrderQuery>(\"orders:read\");\n        // Role-based access\n        auth RequireRole<CancelOrderCommand>(\"OrderManager\");\n    });\n    // Multi-tenancy\n    security UseMultiTenancy(mt => {\n        mt TenantResolutionStrategy = TenantResolutionStrategy FromClaims;\n        mt TenantClaimType = \"tenant_id\";\n        mt IsolateTenantData = true;\n    });\n});\n`\nData Protection\n`csharp{\ntitle: \"Data Protection and Encryption\"\ndescription: \"Configure data encryption with Azure Key Vault integration\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Security\", \"Encryption\", \"Azure Key Vault\", \"Data Protection\"]\nfilename: \"Program cs\"\nusingStatements: [\"System\", \"Whizbang Security\"]\nshowLineNumbers: true\n}\noptions UseSecurity(security => {\n    security UseEncryption(encryption => {\n        encryption EncryptSensitiveFields = true;\n        encryption KeyRotationInterval = TimeSpan FromDays(90);\n        // Azure Key Vault integration\n        encryption UseAzureKeyVault(kv => {\n            kv VaultUri = \"https://my-vault vault azure net/\";\n            kv KeyName = \"whizbang-encryption-key\";\n        });\n    });\n});\n`\nPerformance Configuration\nConnection Pooling\n`csharp{\ntitle: \"Database Connection Pooling\"\ndescription: \"Configure database connection pool settings for performance\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Performance\", \"Database\", \"Connection Pooling\"]\nfilename: \"Program cs\"\nusingStatements: [\"System\", \"Whizbang Performance\"]\nshowLineNumbers: true\n}\noptions ConfigurePerformance(perf => {\n    perf DatabaseConnections = conn => {\n        conn MaxPoolSize = 100;\n        conn MinPoolSize = 10;\n        conn ConnectionTimeout = TimeSpan FromSeconds(30);\n        conn CommandTimeout = TimeSpan FromSeconds(60);\n    };\n});\n`\nCaching\n`csharp{\ntitle: \"Distributed Caching Configuration\"\ndescription: \"Configure Redis caching for aggregates and projections\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Caching\", \"Redis\", \"Performance\", \"Distributed Cache\"]\nfilename: \"Program cs\"\nusingStatements: [\"System\", \"Whizbang Caching\"]\nshowLineNumbers: true\n}\noptions UseCaching(cache => {\n    cache UseDistributedCache(dist => {\n        dist UseRedis(redis => {\n            redis ConnectionString = \"localhost:6379\";\n            redis",
        "startIndex": 10349,
        "preview": "}); ` Security Configuration Authentication & Authorization `csharp{ title: \"Security and Authorization Configuration\" description: \"Configure authent..."
      },
      {
        "id": "old-v1.0.0/advanced/configuration-chunk-5",
        "text": "\"Distributed Caching Configuration\" description: \"Configure Redis caching for aggregates and projections\" framework: \"NET8\" category: \"Configuration\" difficulty: \"ADVANCED\" tags: [\"Caching\", \"Redis\", \"Performance\", \"Distributed Cache\"] filename: \"Program cs\" usingStatements: [\"System\", \"Whizbang Caching\"] showLineNumbers: true } options UseCaching(cache => { cache UseDistributedCache(dist => { dist UseRedis(redis => { redis ConnectionString = \"localhost:6379\"; redis DatabaseNumber = 0;\n        });\n    });\n    // Cache aggregates for read-heavy scenarios\n    cache CacheAggregates = true;\n    cache AggregateCacheDuration = TimeSpan FromMinutes(5);\n    // Cache projection results\n    cache CacheProjections = true;\n    cache ProjectionCacheDuration = TimeSpan FromMinutes(1);\n});\n`\nEnvironment-Specific Configuration\nDevelopment Environment\n`csharp{\ntitle: \"Development Environment Configuration\"\ndescription: \"Configure development-specific settings and features\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"BEGINNER\"\ntags: [\"Development\", \"Environment\", \"In-Memory Storage\", \"Swagger\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions Hosting\", \"Whizbang\"]\nshowLineNumbers: true\n}\nif (builder Environment IsDevelopment()) {\n    options UseDevelopmentDefaults(dev => {\n        dev UseInMemoryStorage = true;\n        dev EnableDetailedErrors = true;\n        dev LogAllQueries = true;\n        dev EnableSwagger = true;\n    });\n}\n`\nProduction Environment\n`csharp{\ntitle: \"Production Environment Configuration\"\ndescription: \"Configure production-specific optimizations and monitoring\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Production\", \"Environment\", \"Optimizations\", \"Monitoring\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions Hosting\", \"Microsoft Extensions Logging\", \"Whizbang\"]\nshowLineNumbers: true\n}\nif (builder Environment IsProduction()) {\n    options UseProductionDefaults(prod => {\n        prod EnableOptimizations = true;\n        prod UseConnectionPooling = true;\n        prod EnableMetrics = true;\n        prod EnableHealthChecks = true;\n        prod LogLevel = LogLevel Warning;\n    });\n}\n`\nConfiguration from appsettings json\n`json\n{\n  \"Whizbang\": {\n    \"EventStore\": {\n      \"Provider\": \"Postgres\",\n      \"ConnectionString\": \"Host=localhost;Database=events;Username=user;Password=pass\",\n      \"SchemaName\": \"events\",\n      \"SnapshotInterval\": 100\n    },\n    \"Messaging\": {\n      \"Provider\": \"Kafka\",\n      \"BootstrapServers\": \"localhost:9092\",\n      \"ConsumerGroup\": \"my-service-consumers\"\n    },\n    \"Projections\": {\n      \"BatchSize\": 1000,\n      \"ConcurrentPartitions\": 4,\n      \"CheckpointInterval\": \"00:00:10\"\n    },\n    \"Observability\": {\n      \"ServiceName\": \"my-whizbang-service\",\n      \"EnableMetrics\": true,\n      \"LogLevel\": \"Information\"\n    }\n  }\n}\n`\n`csharp{\ntitle: \"Loading Configuration from appsettings json\"\ndescription: \"Load Whizbang configuration from appsettings json section\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"BEGINNER\"\ntags: [\"Configuration\", \"appsettings json\", \"Settings\"]\nfilename: \"Program",
        "startIndex": 12890,
        "preview": "\"Distributed Caching Configuration\" description: \"Configure Redis caching for aggregates and projections\" framework: \"NET8\" category: \"Configuration\" ..."
      },
      {
        "id": "old-v1.0.0/advanced/configuration-chunk-6",
        "text": "}, \"Projections\": { \"BatchSize\": 1000, \"ConcurrentPartitions\": 4, \"CheckpointInterval\": \"00:00:10\" }, \"Observability\": { \"ServiceName\": \"my-whizbang-service\", \"EnableMetrics\": true, \"LogLevel\": \"Information\" } } } ` `csharp{ title: \"Loading Configuration from appsettings json\" description: \"Load Whizbang configuration from appsettings json section\" framework: \"NET8\" category: \"Configuration\" difficulty: \"BEGINNER\" tags: [\"Configuration\", \"appsettings json\", \"Settings\"] filename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions Configuration\", \"Whizbang\"]\nshowLineNumbers: true\n}\n// Load from configuration\noptions ConfigureFromSection(builder Configuration GetSection(\"Whizbang\"));\n`\nValidation and Diagnostics\nConfiguration Validation\n`csharp{\ntitle: \"Configuration Validation\"\ndescription: \"Enable configuration validation with custom validators\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Validation\", \"Configuration\", \"Startup\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang\"]\nshowLineNumbers: true\n}\noptions ValidateConfiguration = true;\noptions ValidateOnStartup = true;\n// Custom validation\noptions AddConfigurationValidator<CustomConfigValidator>();\n`\nHealth Checks\n`csharp{\ntitle: \"Health Checks Configuration\"\ndescription: \"Add Whizbang health checks for monitoring system components\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Health Checks\", \"Monitoring\", \"Diagnostics\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang HealthChecks\"]\nshowLineNumbers: true\n}\nbuilder Services AddHealthChecks() AddWhizbangHealthChecks(); // Adds event store, projections, messaging health checks\n`\nRelated Topics\nGetting Started - Basic setup and configuration\nPackage Structure - Available NuGet packages and adapters NET Aspire Integration - Cloud-native configuration\nAdvanced Scenarios - Complex configuration patterns\nNext Steps\nThis page covers the core configuration options in Whizbang For specific deployment scenarios and advanced patterns, refer to the specialized documentation sections",
        "startIndex": 492,
        "preview": "}, \"Projections\": { \"BatchSize\": 1000, \"ConcurrentPartitions\": 4, \"CheckpointInterval\": \"00:00:10\" }, \"Observability\": { \"ServiceName\": \"my-whizbang-s..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/architecture-design/architecture",
    "title": "Architecture Overview",
    "category": "Architecture & Design",
    "url": "/docs/old-v1.0.0/architecture-design/architecture",
    "chunks": [
      {
        "id": "old-v1.0.0/architecture-design/architecture-chunk-0",
        "text": "Architecture Overview\nWhizbang is built on a layered architecture that supports scaling from event-driven development to a full distributed event-sourced system with receptors, perspectives, and lenses Architectural Layers\n`text\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Layered-Architecture, System-Design]\ndescription: Layered architecture diagram showing the separation between application layer, Whizbang dispatcher, driver layer, and infrastructure\n---\n┌─────────────────────────────────────────────────────────────┐\n│                     Application Layer                       │\n│  (Your Domain Code: Receptors, Perspectives, Lenses)        │\n└─────────────────────────────────────────────────────────────┘\n                            ↓\n┌─────────────────────────────────────────────────────────────┐\n│                    Whizbang Dispatcher                       │\n│  • Message Routing        • Event Sourcing Engine            │\n│  • Receptor Execution     • Perspective Management           │\n│  • Event Publishing       • Ledger Coordination              │\n│  • Idempotence            • Observability Pipeline           │\n└─────────────────────────────────────────────────────────────┘\n                            ↓\n┌─────────────────────────────────────────────────────────────┐\n│                      Driver Layer                            │\n│  • Persistence Drivers    • Message Broker Adapters          │\n│  • Serialization Drivers  • Telemetry Drivers                │\n└─────────────────────────────────────────────────────────────┘\n                            ↓\n┌─────────────────────────────────────────────────────────────┐\n│                   Infrastructure                             │\n│  • Databases              • Message Brokers                  │\n│  • Telemetry Backends     • Service Discovery                │\n└─────────────────────────────────────────────────────────────┘\n`\nCore Components\nDispatcher with Return Type Semantics\nThe Dispatcher is the heart of Whizbang It interprets receptor return types to determine behavior:\nRoutes commands to their owning domain's receptors\nPublishes events to all interested perspectives  \nExecutes queries against lenses\nCoordinates sagas across long-running processes\nReturn type semantics - What receptors return determines what happens:\nSingle event return → Published to perspectives\nTuple return → Multiple cascading events\nVoid return → Fire-and-forget execution\nResult<T> return → Success/failure handling\nAll message routing respects domain ownership—commands must be sent to the service that owns that receptor, while events are broadcast from the owning domain to perspectives Ledger\nThe Ledger is the source of truth for all state changes in event-sourced mode",
        "startIndex": 0,
        "preview": "Architecture Overview\nWhizbang is built on a layered architecture that supports scaling from event-driven development to a full distributed event-sour..."
      },
      {
        "id": "old-v1.0.0/architecture-design/architecture-chunk-1",
        "text": "return → Fire-and-forget execution Result<T> return → Success/failure handling All message routing respects domain ownership—commands must be sent to the service that owns that receptor, while events are broadcast from the owning domain to perspectives Ledger The Ledger is the source of truth for all state changes in event-sourced mode It:\nAppends events to immutable streams (one stream per receptor)\nSupports time-based queries (get all events before/after a timestamp)\nEnables backfilling new perspectives from historical events\nProvides global ordering for cross-receptor event streams\nImplements optimistic concurrency for receptor updates\nThe Ledger is driver-based, supporting:\nPostgres (JSONB + sequential IDs)\nSQL Server (JSON columns + IDENTITY)\nMySQL (JSON columns + auto-increment)\nCosmos DB (native event streams)\nLiteFS/SQLite (binary codec for edge deployments)\nPerspective Engine\nThe Perspective Engine builds read models from event streams",
        "startIndex": 2777,
        "preview": "return → Fire-and-forget execution Result<T> return → Success/failure handling All message routing respects domain ownership—commands must be sent to ..."
      },
      {
        "id": "old-v1.0.0/architecture-design/architecture-chunk-2",
        "text": "streams Implements optimistic concurrency for receptor updates The Ledger is driver-based, supporting: Postgres (JSONB + sequential IDs) SQL Server (JSON columns + IDENTITY) MySQL (JSON columns + auto-increment) Cosmos DB (native event streams) LiteFS/SQLite (binary codec for edge deployments) Perspective Engine The Perspective Engine builds read models from event streams It:\nSubscribes to event streams (local or from remote services)\nApplies events to perspective handlers in order\nTracks checkpoint positions to resume after restarts\nSupports parallel processing across partitions\nHandles schema migrations for evolving perspectives\nPerspectives can be:\nInline - Updated synchronously within the same transaction as event append\nAsync - Updated in background workers for eventual consistency\nCached - Materialized in-memory for ultra-low latency\nExternal - Pushed to Elasticsearch, Redis, or other specialized stores\nAspect-Oriented Pipeline\nThe AOP Pipeline weaves cross-cutting concerns through source generation:\n`text\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, AOP, Pipeline, Cross-Cutting-Concerns]\ndescription: Aspect-oriented pipeline showing how cross-cutting concerns are applied through message processing\n---\nIncoming Message\n      ↓\n  [Logged] - Structured logging aspect\n      ↓\n  [Validated] - Input validation aspect\n      ↓\n  [Authorized] - Security aspect\n      ↓\n  [Cached] - Result caching aspect\n      ↓\n  [Retry] - Resilience aspect\n      ↓\n  [Timed] - Performance metrics aspect\n      ↓\n  Receptor Execution\n      ↓\n  [Transactional] - Database transaction aspect\n      ↓\n  Event Append / Perspective Update\n      ↓\n  [Outbox] - Distributed messaging aspect\n      ↓\n  Response / New Messages\n`\nAspects are:\nDeclarative - Applied via attributes\nCompiled - Source generators create zero-overhead code\nComposable - Multiple aspects work together\nTestable - Can be verified in isolation\nEvery stage is pluggable and observable Saga Coordinator\nSagas orchestrate long-running processes across multiple receptors or services",
        "startIndex": 3399,
        "preview": "streams Implements optimistic concurrency for receptor updates The Ledger is driver-based, supporting: Postgres (JSONB + sequential IDs) SQL Server (J..."
      },
      {
        "id": "old-v1.0.0/architecture-design/architecture-chunk-3",
        "text": "↓ Response / New Messages ` Aspects are: Declarative - Applied via attributes Compiled - Source generators create zero-overhead code Composable - Multiple aspects work together Testable - Can be verified in isolation Every stage is pluggable and observable Saga Coordinator Sagas orchestrate long-running processes across multiple receptors or services Whizbang supports two saga styles:\nOrchestration - A central coordinator issues commands and listens for events:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Sagas, Orchestration, Long-Running-Processes]\ndescription: Example of saga orchestration pattern for order fulfillment process\n---\npublic class OrderFulfillmentSaga : Saga {\n    public async Task Handle(OrderPlaced @event) {\n        await Send(new ReserveInventory(@event OrderId));\n    }\n    public async Task Handle(InventoryReserved @event) {\n        await Send(new ChargePayment(@event OrderId));\n    }\n    public async Task Handle(PaymentCharged @event) {\n        await Send(new ShipOrder(@event OrderId));\n    }\n}\n`\nChoreography - Each service reacts to events and publishes new ones (no central coordinator) Sagas are persisted as event streams and can be replayed or debugged like any other receptor Outbox/Inbox Pattern\nFor distributed messaging, Whizbang implements the Outbox/Inbox pattern to ensure exactly-once delivery:\nOutbox (Publishing Service):\nReceptor executes and appends events to ledger\nEvents also written to outbox table in same transaction\nBackground worker publishes outbox messages to message broker\nMessages marked as published after broker confirms\nInbox (Subscribing Service):\nMessage arrives from broker\nStored in inbox table with unique message ID\nIf message ID exists (duplicate), skip processing\nOtherwise, process receptor and mark message as complete\nPeriodic cleanup of old inbox entries\nThis pattern guarantees at-least-once delivery from the broker combined with idempotent handling for exactly-once semantics Domain Ownership Model\nWhizbang enforces explicit domain ownership to prevent distributed system chaos",
        "startIndex": 5103,
        "preview": "↓ Response / New Messages ` Aspects are: Declarative - Applied via attributes Compiled - Source generators create zero-overhead code Composable - Mult..."
      },
      {
        "id": "old-v1.0.0/architecture-design/architecture-chunk-4",
        "text": "ID If message ID exists (duplicate), skip processing Otherwise, process receptor and mark message as complete Periodic cleanup of old inbox entries This pattern guarantees at-least-once delivery from the broker combined with idempotent handling for exactly-once semantics Domain Ownership Model Whizbang enforces explicit domain ownership to prevent distributed system chaos Commands\nCommands are sent TO the service that owns the receptor:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Domain-Ownership, Commands, CQRS]\ndescription: Example of command with domain ownership declaration\n---\n[OwnedBy(\"Orders\")]  // This command belongs to the Orders service\npublic record PlaceOrder(Guid OrderId, Guid CustomerId, List<OrderItem> Items);\n`\nWhen you send a command:\nIn a monolith, it's routed to the local receptor\nIn microservices, it's routed to the Orders service via the message broker\nEvents\nEvents are emitted FROM the service that owns the domain:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Domain-Ownership, Events, CQRS]\ndescription: Example of event with domain ownership declaration\n---\n[OwnedBy(\"Orders\")]  // This event comes from the Orders service\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt);\n`\nOther services can subscribe to OrderPlaced events:\nIn a monolith, subscribers get events via in-process pub/sub\nIn microservices, subscribers get events from the message broker topic\nBackfilling Projections\nWhen a new service subscribes to events for the first time, it can backfill from the beginning:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Perspectives, Event-Sourcing, Backfilling]\ndescription: Configuration for perspective with event subscription and backfilling from beginning\n---\nservices AddPerspective<OrderHistoryPerspective>(options => {\n    options Subscribe<OrderPlaced>();\n    options Subscribe<OrderShipped>();\n    options BackfillFrom = DateTimeOffset MinValue;  // Start from the beginning\n});\n`\nThe perspective engine will:\nQuery the Orders service's ledger for all historical events\nApply them to the perspective in order\nContinue processing new events as they arrive\nThis allows new perspectives to be built from existing event history",
        "startIndex": 6854,
        "preview": "ID If message ID exists (duplicate), skip processing Otherwise, process receptor and mark message as complete Periodic cleanup of old inbox entries Th..."
      },
      {
        "id": "old-v1.0.0/architecture-design/architecture-chunk-5",
        "text": "options BackfillFrom = DateTimeOffset MinValue; // Start from the beginning }); ` The perspective engine will: Query the Orders service's ledger for all historical events Apply them to the perspective in order Continue processing new events as they arrive This allows new perspectives to be built from existing event history Scaling Patterns\nSingle Process (Event-Driven Mode)\n`text\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Deployment, Single-Process, Event-Driven]\ndescription: Single process deployment architecture with in-memory runtime and local database\n---\n┌─────────────────────────────┐\n│   ASP",
        "startIndex": 8799,
        "preview": "options BackfillFrom = DateTimeOffset MinValue; // Start from the beginning }); ` The perspective engine will: Query the Orders service's ledger for a..."
      },
      {
        "id": "old-v1.0.0/architecture-design/architecture-chunk-6",
        "text": "Continue processing new events as they arrive This allows new perspectives to be built from existing event history Scaling Patterns Single Process (Event-Driven Mode) `text --- category: Architecture difficulty: INTERMEDIATE tags: [Architecture, Deployment, Single-Process, Event-Driven] description: Single process deployment architecture with in-memory runtime and local database --- ┌─────────────────────────────┐ │ ASP NET Core Web API      │\n│                             │\n│  ┌──────────────────────┐   │\n│  │  Whizbang Runtime    │   │\n│  │  (In-Memory)         │   │\n│  └──────────────────────┘   │\n│           ↓                 │\n│  ┌──────────────────────┐   │\n│  │  SQLite / Postgres   │   │\n│  └──────────────────────┘   │\n└─────────────────────────────┘\n`\nPerfect for:\nEvent-driven applications\nLocal development\nSimple event-driven patterns without event sourcing\nMulti-Service (Distributed)\n`text\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Microservices, Distributed, Event-Driven]\ndescription: Multi-service distributed architecture with dedicated databases and shared message broker\n---\n┌─────────────┐      ┌─────────────┐      ┌─────────────┐\n│   Orders    │      │  Inventory  │      │  Shipping   │\n│   Service   │      │   Service   │      │   Service   │\n│             │      │             │      │             │\n│  Whizbang   │      │  Whizbang   │      │  Whizbang   │\n│             │      │             │      │             │\n│  Postgres   │      │  Postgres   │      │  Postgres   │\n└──────┬──────┘      └──────┬──────┘      └──────┬──────┘\n       │                    │                    │\n       └────────────┬───────┴────────────────────┘\n                    ↓\n          ┌──────────────────┐\n          │  Kafka / RabbitMQ│\n          │  (Message Broker)│\n          └──────────────────┘\n`\nEach service:\nHas its own ledger for database isolation\nPublishes events to the shared message broker\nSubscribes to events from other services\nRoutes commands to owning services\nMulti-Region (Disaster Recovery)\n`text\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [Architecture, Multi-Region, Disaster-Recovery, Replication]\ndescription: Multi-region architecture with synchronized ledgers and mirrored message brokers for disaster recovery\n---\n        Region 1                         Region 2\n┌─────────────────────┐         ┌─────────────────────┐\n│  Primary Services   │         │  Replica Services   │\n│                     │         │                     │\n│  Ledgers            │◄───────►│  Ledgers            │\n│  (Postgres)         │  Sync   │  (Postgres)         │\n└─────────────────────┘         └─────────────────────┘\n         ↓                               ↓\n┌─────────────────────┐         ┌─────────────────────┐\n│  Kafka Cluster      │◄───────►│  Kafka Cluster      │\n│  (Region 1)         │  Mirror │  (Region 2)         │\n└─────────────────────┘         └─────────────────────┘\n`\nEvent streams in ledgers are replicated across regions for disaster recovery",
        "startIndex": 9110,
        "preview": "Continue processing new events as they arrive This allows new perspectives to be built from existing event history Scaling Patterns Single Process (Ev..."
      },
      {
        "id": "old-v1.0.0/architecture-design/architecture-chunk-7",
        "text": "│ │ │ Ledgers │◄───────►│ Ledgers │ │ (Postgres) │ Sync │ (Postgres) │ └─────────────────────┘ └─────────────────────┘ ↓ ↓ ┌─────────────────────┐ ┌─────────────────────┐ │ Kafka Cluster │◄───────►│ Kafka Cluster │ │ (Region 1) │ Mirror │ (Region 2) │ └─────────────────────┘ └─────────────────────┘ ` Event streams in ledgers are replicated across regions for disaster recovery Region 2 can take over if Region 1 fails Progressive Enhancement Modes\nWhizbang provides four deployment modes, all using the exact same receptor code:\nMode 1: Event-Driven Development\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Configuration, Event-Driven, Development]\ndescription: Basic event-driven mode configuration for development scenarios\n---\nservices AddWhizbang(dispatcher => {\n    dispatcher UseEventDrivenMode();\n});\n`\nNo persistence dependencies\nImmediate execution with in-memory perspectives\nPerfect for development and testing\nMode 2: Event-Driven Production\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Configuration, Event-Driven, Production, Persistence]\ndescription: Event-driven production configuration with persistent perspectives\n---\nservices AddWhizbang(dispatcher => {\n    dispatcher UseEventDrivenMode();\n    dispatcher Perspectives UsePostgreSQL(connectionString);\n});\n`\nPersistent perspectives\nAutomatic retry on perspective failures\nDurable event processing\nMode 3: Event-Driven Distributed\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Configuration, Event-Driven, Distributed, Messaging]\ndescription: Event-driven distributed configuration with Kafka relays and persistent perspectives\n---\nservices AddWhizbang(dispatcher => {\n    dispatcher UseEventDrivenMode();\n    dispatcher UseRelays(relays => relays UseKafka(kafkaConfig));\n    dispatcher Perspectives UsePostgreSQL(connectionString);\n});\n`\nCross-service messaging with relays\nService discovery\nDistributed tracing\nMode 4: Event-Sourced with Ledger\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [Architecture, Configuration, Event-Sourcing, Ledger, Advanced]\ndescription: Event-sourced configuration with ledger and persistent perspectives\n---\nservices AddWhizbang(dispatcher => {\n    dispatcher UseEventSourcing(es => {\n        es UseLedger(ledgerConfig);\n    });\n    dispatcher Perspectives",
        "startIndex": 11720,
        "preview": "│ │ │ Ledgers │◄───────►│ Ledgers │ │ (Postgres) │ Sync │ (Postgres) │ └─────────────────────┘ └─────────────────────┘ ↓ ↓ ┌─────────────────────┐ ┌──..."
      },
      {
        "id": "old-v1.0.0/architecture-design/architecture-chunk-8",
        "text": "UsePostgreSQL(connectionString); }); ` Cross-service messaging with relays Service discovery Distributed tracing Mode 4: Event-Sourced with Ledger `csharp --- category: Architecture difficulty: ADVANCED tags: [Architecture, Configuration, Event-Sourcing, Ledger, Advanced] description: Event-sourced configuration with ledger and persistent perspectives --- services AddWhizbang(dispatcher => { dispatcher UseEventSourcing(es => { es UseLedger(ledgerConfig); }); dispatcher Perspectives UsePostgreSQL(connectionString);\n});\n`\nComplete event sourcing with stateful receptors\nTime travel debugging\nPerspective rebuilding from ledger\nMessage Execution Patterns\nWithin any mode, Whizbang supports three execution patterns:\nInline Mode\nReceptor executes synchronously within the caller's transaction:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Execution-Patterns, Inline, Synchronous]\ndescription: Inline execution pattern with synchronous receptor execution and perspective updates\n---\nvar @event = await dispatcher Send(new PlaceOrder( ));\n// Receptor executed, events appended, perspectives updated—all before returning\n`\nBest for:\nStrong consistency requirements\nSimple CRUD operations\nLocal development\nAsync Mode\nReceptor executes asynchronously in a background worker:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Execution-Patterns, Async, Background-Processing]\ndescription: Async execution pattern with background worker processing\n---\nawait dispatcher Publish(new PlaceOrder( ));\n// Command written to queue, returns immediately\n// Receptor executes in background worker\n`\nBest for:\nHigh throughput\nNon-blocking operations\nEventual consistency scenarios\nBatched Mode\nMultiple messages batched together for efficiency:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Execution-Patterns, Batched, Performance]\ndescription: Batched execution pattern for improved throughput with multiple commands\n---\nawait dispatcher PublishBatch(new[] {\n    new PlaceOrder( ),\n    new PlaceOrder( ),\n    new PlaceOrder( )\n});\n// All three commands processed in one batch for better throughput\n`\nBest for:\nBulk imports\nScheduled jobs\nData migration\nThe same receptor code works in all three modes Toggle via configuration, not code changes",
        "startIndex": 13727,
        "preview": "UsePostgreSQL(connectionString); }); ` Cross-service messaging with relays Service discovery Distributed tracing Mode 4: Event-Sourced with Ledger `cs..."
      },
      {
        "id": "old-v1.0.0/architecture-design/architecture-chunk-9",
        "text": "--- await dispatcher PublishBatch(new[] { new PlaceOrder( ), new PlaceOrder( ), new PlaceOrder( ) }); // All three commands processed in one batch for better throughput ` Best for: Bulk imports Scheduled jobs Data migration The same receptor code works in all three modes Toggle via configuration, not code changes Next Steps\nNow that you understand the overall architecture, dive into:\nCore Concepts - Deep dive into Receptors, Perspectives, and Lenses\nPackage Structure - Which NuGet packages to install\nGetting Started - Build your first Whizbang application",
        "startIndex": 15586,
        "preview": "--- await dispatcher PublishBatch(new[] { new PlaceOrder( ), new PlaceOrder( ), new PlaceOrder( ) }); // All three commands processed in one batch for..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/architecture-design/aspect-oriented-programming",
    "title": "Aspect-Oriented Programming in Whizbang",
    "category": "Architecture & Design",
    "url": "/docs/old-v1.0.0/architecture-design/aspect-oriented-programming",
    "chunks": [
      {
        "id": "old-v1.0.0/architecture-design/aspect-oriented-programming-chunk-0",
        "text": "Aspect-Oriented Programming in Whizbang\nOverview\nWhizbang brings true aspect-oriented programming (AOP) to NET messaging through source generators Cross-cutting concerns like logging, caching, retry, and authorization are first-class citizens, not afterthoughts bolted onto your handlers What Makes Whizbang's AOP Different\nTraditional NET AOP approaches suffer from:\nRuntime reflection overhead (Castle DynamicProxy, PostSharp)\nLimited compile-time verification (Attributes without validation)\nPoor IDE support (No IntelliSense for aspects)\nComplex configuration (XML files, registration ceremonies)\nWhizbang solves these with:\nSource generation - Zero runtime overhead\nCompile-time verification - Catch errors during build\nRich IDE integration - Full IntelliSense and refactoring\nConvention-based - Aspects just work\nCore Concepts\nAspects as Attributes\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [AOP, Aspects, Attributes, Handlers]\ndescription: Basic aspect attribute usage on a command handler\n---\n[Logged]                    // Add structured logging\n[Timed]                     // Track execution time\n[Cached(Duration = \"5m\")]   // Cache results\n[Retry(3, Backoff = \"exponential\")]  // Retry on failure\n[Authorized(Role = \"Admin\")]         // Enforce authorization\n[Validated]                 // Validate input\n[Transactional]            // Wrap in transaction\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Your business logic here\n        // All aspects are automatically woven in\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nAspect Execution Pipeline\n`mermaid\ngraph LR\n    Request --> Logged\n    Logged --> Authorized\n    Authorized --> Validated\n    Validated --> Cached{Cache Hit }\n    Cached -->|Yes| Response\n    Cached -->|No| Timed\n    Timed --> Transactional\n    Transactional --> Handler[Business Logic]\n    Handler --> Retry{Success }\n    Retry -->|No| Handler\n    Retry -->|Yes| UpdateCache\n    UpdateCache --> Response\n`\nBuilt-in Aspects\nLogging Aspect\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Logging, Structured-Logging, Configuration]\ndescription: Configured logging aspect with structured output\n---\n[Logged(\n    Level = LogLevel",
        "startIndex": 0,
        "preview": "Aspect-Oriented Programming in Whizbang\nOverview\nWhizbang brings true aspect-oriented programming (AOP) to NET messaging through source generators Cro..."
      },
      {
        "id": "old-v1.0.0/architecture-design/aspect-oriented-programming-chunk-1",
        "text": "-->|No| Timed Timed --> Transactional Transactional --> Handler[Business Logic] Handler --> Retry{Success } Retry -->|No| Handler Retry -->|Yes| UpdateCache UpdateCache --> Response ` Built-in Aspects Logging Aspect `csharp --- category: Architecture difficulty: INTERMEDIATE tags: [AOP, Logging, Structured-Logging, Configuration] description: Configured logging aspect with structured output --- [Logged( Level = LogLevel Information,\n    IncludeParameters = true,\n    IncludeResult = true,\n    IncludeDuration = true,\n    Message = \"Processing order {OrderId}\"\n)]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Automatically logs:\n        // - Method entry with parameters\n        // - Method exit with result\n        // - Execution duration\n        // - Any exceptions\n        return new OrderCreated(cmd OrderId);\n    }\n}\n// Generated structured log output:\n// {\n//   \"timestamp\": \"2024-01-15T10:30:00Z\",\n//   \"level\": \"Information\",\n//   \"message\": \"Processing order 123\",\n//   \"handler\": \"OrderHandler\",\n//   \"method\": \"Handle\",\n//   \"parameters\": { \"orderId\": \"123\", \"customerId\": \"456\" },\n//   \"duration\": 45,\n//   \"result\": { \"orderId\": \"123\", \"success\": true }\n// }\n`\nCaching Aspect\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Caching, Cache-Invalidation, Performance]\ndescription: Caching aspect with custom key and invalidation strategies\n---\n[Cached(\n    Duration = \"5m\",                    // Cache for 5 minutes\n    Key = \"{CustomerId}:{OrderId}\",     // Custom cache key\n    Condition = \"Result Success\",        // Only cache successful results\n    VaryBy = [\"Country\", \"Currency\"],   // Vary cache by these parameters\n    Group = \"Orders\"                     // Cache group for bulk invalidation\n)]\npublic class GetOrderHandler : IHandle<GetOrder> {\n    public Order Handle(GetOrder query) {\n        // First call: execute and cache\n        // Subsequent calls within 5min: return from cache\n        return LoadOrderFromDatabase(query",
        "startIndex": 2285,
        "preview": "-->|No| Timed Timed --> Transactional Transactional --> Handler[Business Logic] Handler --> Retry{Success } Retry -->|No| Handler Retry -->|Yes| Updat..."
      },
      {
        "id": "old-v1.0.0/architecture-design/aspect-oriented-programming-chunk-2",
        "text": "cache successful results VaryBy = [\"Country\", \"Currency\"], // Vary cache by these parameters Group = \"Orders\" // Cache group for bulk invalidation )] public class GetOrderHandler : IHandle<GetOrder> { public Order Handle(GetOrder query) { // First call: execute and cache // Subsequent calls within 5min: return from cache return LoadOrderFromDatabase(query OrderId);\n    }\n}\n// Cache invalidation\n[InvalidatesCache(Group = \"Orders\")]\npublic class UpdateOrderHandler : IHandle<UpdateOrder> {\n    public void Handle(UpdateOrder cmd) {\n        // Automatically invalidates all cached orders\n    }\n}\n`\nRetry Aspect\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Retry, Resilience, Error-Handling]\ndescription: Retry aspect with exponential backoff and conditional logic\n---\n[Retry(\n    MaxAttempts = 3,\n    Backoff = BackoffStrategy Exponential,\n    InitialDelay = \"1s\",\n    MaxDelay = \"30s\",\n    RetryOn = [typeof(TransientException)],\n    AbortOn = [typeof(ValidationException)],\n    OnRetry = nameof(LogRetry)\n)]\npublic class PaymentHandler : IHandle<ProcessPayment> {\n    public PaymentResult Handle(ProcessPayment cmd) {\n        // Automatically retries on TransientException\n        // Aborts immediately on ValidationException\n        return ProcessPayment(cmd);\n    }\n    private void LogRetry(Exception ex, int attempt, TimeSpan delay) {\n        _logger LogWarning($\"Retry {attempt} after {delay}: {ex Message}\");\n    }\n}\n`\nAuthorization Aspect\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Authorization, Security, Role-Based-Security]\ndescription: Authorization aspects with role-based and resource-based access control\n---\n[Authorized(\n    Roles = [\"Admin\", \"Manager\"],\n    Policies = [\"OrderManagement\"],\n    RequireAll = false,  // OR condition\n    FailureMode = AuthFailureMode",
        "startIndex": 3907,
        "preview": "cache successful results VaryBy = [\"Country\", \"Currency\"], // Vary cache by these parameters Group = \"Orders\" // Cache group for bulk invalidation )] ..."
      },
      {
        "id": "old-v1.0.0/architecture-design/aspect-oriented-programming-chunk-3",
        "text": "_logger LogWarning($\"Retry {attempt} after {delay}: {ex Message}\"); } } ` Authorization Aspect `csharp --- category: Architecture difficulty: INTERMEDIATE tags: [AOP, Authorization, Security, Role-Based-Security] description: Authorization aspects with role-based and resource-based access control --- [Authorized( Roles = [\"Admin\", \"Manager\"], Policies = [\"OrderManagement\"], RequireAll = false, // OR condition FailureMode = AuthFailureMode ThrowException\n)]\npublic class DeleteOrderHandler : IHandle<DeleteOrder> {\n    public void Handle(DeleteOrder cmd) {\n        // Only accessible to Admin or Manager roles\n        // Or users with OrderManagement policy\n    }\n}\n// Resource-based authorization\n[ResourceAuthorized(\n    Resource = \"{OrderId}\",\n    Permission = \"Delete\",\n    ResourceType = typeof(Order)\n)]\npublic class DeleteOrderHandler : IHandle<DeleteOrder> {\n    public void Handle(DeleteOrder cmd) {\n        // Checks if user can delete specific order\n    }\n}\n`\nValidation Aspect\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Validation, Data-Annotations, FluentValidation]\ndescription: Validation aspect with data annotations and custom rules\n---\n[Validated(\n    Mode = ValidationMode Strict,\n    ThrowOnFailure = true,\n    ErrorCode = \"VALIDATION_FAILED\"\n)]\npublic class CreateOrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Automatically validates cmd using:\n        // - Data annotations\n        // - FluentValidation rules\n        // - Custom validators\n        return new OrderCreated(cmd OrderId);\n    }\n}\n// The command with validation rules\npublic record CreateOrder(\n    [Required] Guid CustomerId,\n    [MinLength(1)] List<OrderItem> Items,\n    [EmailAddress] string CustomerEmail\n) : ICommand<OrderCreated>;\n`\nTransaction Aspect\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Transactions, ACID, Database]\ndescription: Transactional aspect with custom isolation and rollback rules\n---\n[Transactional(\n    IsolationLevel = IsolationLevel ReadCommitted,\n    Timeout = \"30s\",\n    ReadOnly = false,\n    Propagation = Propagation Required,\n    RollbackOn = [typeof(BusinessException)]\n)]\npublic class TransferMoneyHandler : IHandle<TransferMoney> {\n    public TransferResult Handle(TransferMoney cmd) {\n        // Entire operation wrapped in transaction\n        // Automatically rolled back on exception\n        DebitAccount(cmd FromAccount, cmd Amount);\n        CreditAccount(cmd ToAccount, cmd Amount);\n        return new TransferResult(cmd",
        "startIndex": 5390,
        "preview": "_logger LogWarning($\"Retry {attempt} after {delay}: {ex Message}\"); } } ` Authorization Aspect `csharp --- category: Architecture difficulty: INTERMED..."
      },
      {
        "id": "old-v1.0.0/architecture-design/aspect-oriented-programming-chunk-4",
        "text": "IsolationLevel ReadCommitted, Timeout = \"30s\", ReadOnly = false, Propagation = Propagation Required, RollbackOn = [typeof(BusinessException)] )] public class TransferMoneyHandler : IHandle<TransferMoney> { public TransferResult Handle(TransferMoney cmd) { // Entire operation wrapped in transaction // Automatically rolled back on exception DebitAccount(cmd FromAccount, cmd Amount); CreditAccount(cmd ToAccount, cmd Amount); return new TransferResult(cmd TransferId);\n    }\n}\n`\nMetrics Aspect\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Metrics, Observability, Telemetry]\ndescription: Metrics aspect with counters, histograms and custom tags\n---\n[Metrics(\n    Counter = \"orders created\",\n    Histogram = \"order processing duration\",\n    Tags = [\"country:{Country}\", \"product:{ProductType}\"],\n    IncludeDefaultTags = true\n)]\npublic class CreateOrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Automatically tracks:\n        // - Invocation count\n        // - Duration histogram\n        // - Success/failure rate\n        // - Custom tags from command\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nCreating Custom Aspects\nSimple Custom Aspect\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [AOP, Custom-Aspects, Audit, Interceptors]\ndescription: Custom audit aspect implementation with interception\n---\n[AttributeUsage(AttributeTargets Class | AttributeTargets Method)]\npublic class AuditAttribute : AspectAttribute {\n    public override async Task<T> InterceptAsync<T>(\n        AspectContext context, \n        Func<Task<T>> next) {\n        var audit = new AuditEntry {\n            User = context User Identity Name,\n            Action = context Method Name,\n            Timestamp = DateTime UtcNow,\n            Parameters = context Arguments\n        };\n        try {\n            var result = await next();\n            audit Success = true;\n            audit Result = result;\n            return result;\n        }\n        catch (Exception ex) {\n            audit Success = false;\n            audit Error = ex Message;\n            throw;\n        }\n        finally {\n            await context Services GetService<IAuditLog>()",
        "startIndex": 7510,
        "preview": "IsolationLevel ReadCommitted, Timeout = \"30s\", ReadOnly = false, Propagation = Propagation Required, RollbackOn = [typeof(BusinessException)] )] publi..."
      },
      {
        "id": "old-v1.0.0/architecture-design/aspect-oriented-programming-chunk-5",
        "text": "Method Name, Timestamp = DateTime UtcNow, Parameters = context Arguments }; try { var result = await next(); audit Success = true; audit Result = result; return result; } catch (Exception ex) { audit Success = false; audit Error = ex Message; throw; } finally { await context Services GetService<IAuditLog>() LogAsync(audit);\n        }\n    }\n}\n`\nAdvanced Custom Aspect with Source Generator\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [AOP, Source-Generation, Rate-Limiting, Code-Generation]\ndescription: Advanced aspect with source generator for rate limiting\n---\n// Aspect definition\n[AspectGenerator]\npublic class RateLimitAttribute : AspectAttribute {\n    public int RequestsPerMinute { get; set; }\n    public string Key { get; set; }\n}\n// Source generator creates:\npublic static class RateLimitAspectGenerator {\n    [GeneratedCode]\n    public static async Task<T> Apply<T>(\n        Func<Task<T>> handler,\n        RateLimitAttribute attribute,\n        AspectContext context) {\n        var rateLimiter = context GetService<IRateLimiter>();\n        var key = attribute Key Replace(\"{UserId}\", context User Id);\n        if ( await rateLimiter AllowRequest(key, attribute RequestsPerMinute)) {\n            throw new RateLimitExceededException();\n        }\n        return await handler();\n    }\n}\n`\nAspect Composition\nSequential Composition\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Aspect-Composition, Execution-Order]\ndescription: Sequential aspect composition and execution order\n---\n// Aspects execute in order\n[First]   // Executes first\n[Second]  // Executes second\n[Third]   // Executes third\npublic class Handler : IHandle<Command> {\n    // Execution order: First -> Second -> Third -> Handler -> Third -> Second -> First\n}\n`\nConditional Composition\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [AOP, Conditional-Aspects, Runtime-Configuration]\ndescription: Conditional aspect composition based on runtime conditions\n---\n[ConditionalAspect(When = \"Environment == 'Production'\", Apply = typeof(AuditAspect))]\n[ConditionalAspect(When = \"User",
        "startIndex": 9312,
        "preview": "Method Name, Timestamp = DateTime UtcNow, Parameters = context Arguments }; try { var result = await next(); audit Success = true; audit Result = resu..."
      },
      {
        "id": "old-v1.0.0/architecture-design/aspect-oriented-programming-chunk-6",
        "text": "// Execution order: First -> Second -> Third -> Handler -> Third -> Second -> First } ` Conditional Composition `csharp --- category: Architecture difficulty: ADVANCED tags: [AOP, Conditional-Aspects, Runtime-Configuration] description: Conditional aspect composition based on runtime conditions --- [ConditionalAspect(When = \"Environment == 'Production'\", Apply = typeof(AuditAspect))] [ConditionalAspect(When = \"User IsAdmin\", Apply = typeof(AdminLoggingAspect))]\npublic class Handler : IHandle<Command> {\n    // Aspects applied based on runtime conditions\n}\n`\nComposite Aspects\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Composite-Aspects, Reusability]\ndescription: Composite aspect pattern for reusable aspect combinations\n---\n// Define a composite aspect\n[CompositeAspect]\n[Logged]\n[Timed]\n[Retry(3)]\n[Cached(\"5m\")]\npublic class StandardHandlerAspects : AspectAttribute { }\n// Use the composite\n[StandardHandlerAspects]\npublic class OrderHandler : IHandle<CreateOrder> {\n    // Gets all aspects from composite\n}\n`\nCompile-Time Verification\nPure Function Enforcement\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [AOP, Pure-Functions, Compile-Time-Verification]\ndescription: Pure function enforcement with compile-time verification\n---\n[Pure] // Compile-time verification\npublic class CalculationHandler : IHandle<Calculate> {\n    public Result Handle(Calculate cmd) {\n        // ✅ Allowed: Pure computation\n        var result = cmd A + cmd B;\n        // ❌ Compile error: I/O not allowed\n        // await database SaveAsync(result);\n        // ❌ Compile error: State mutation not allowed  \n        // this",
        "startIndex": 11115,
        "preview": "// Execution order: First -> Second -> Third -> Handler -> Third -> Second -> First } ` Conditional Composition `csharp --- category: Architecture dif..."
      },
      {
        "id": "old-v1.0.0/architecture-design/aspect-oriented-programming-chunk-7",
        "text": "--- [Pure] // Compile-time verification public class CalculationHandler : IHandle<Calculate> { public Result Handle(Calculate cmd) { // ✅ Allowed: Pure computation var result = cmd A + cmd B; // ❌ Compile error: I/O not allowed // await database SaveAsync(result); // ❌ Compile error: State mutation not allowed // this field = result;\n        return new Result(result);\n    }\n}\n`\nEffect Tracking\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [AOP, Effect-Tracking, Compile-Time-Verification]\ndescription: Effect tracking with compile-time verification of side effects\n---\n[Effects(\n    Reads = [\"Database\", \"Cache\"],\n    Writes = [\"Database\"],\n    Publishes = [\"OrderEvents\"],\n    NetworkCalls = [\"PaymentGateway\"]\n)]\npublic class OrderHandler : IHandle<ProcessOrder> {\n    public async Task<Result> Handle(ProcessOrder cmd) {\n        // Source generator verifies declared effects match actual usage\n        var order = await ReadDatabase();      // ✅ Matches Reads\n        await WriteDatabase(order);            // ✅ Matches Writes\n        await PublishEvent(new OrderCreated());// ✅ Matches Publishes\n        // await CallUndeclaredService();      // ❌ Compile error: Undeclared effect\n    }\n}\n`\nAspect Compatibility Checking\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [AOP, Aspect-Compatibility, Compile-Time-Validation]\ndescription: Compile-time detection of incompatible aspect combinations\n---\n// Source generator detects incompatible aspects\n[Cached]        // ❌ Compile error: Cannot cache with [NoCache]\n[NoCache]       \npublic class Handler { }\n[Transactional] // ❌ Compile error: ReadOnly transaction cannot Write\n[ReadOnly]\n[Writes(\"Database\")]\npublic class Handler { }\n`\nPerformance Optimizations\nZero-Overhead Aspects\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [AOP, Source-Generation, Performance-Optimization]\ndescription: Zero-overhead aspect implementation via source generation\n---\n// Source generator creates optimized code\n[Logged]\n[Timed]\npublic class Handler : IHandle<Command> {\n    public Result Handle(Command cmd) => new Result();\n}\n// Generated code (simplified):\npublic class Handler_Generated : IHandle<Command> {\n    private readonly Handler _handler;\n    private readonly ILogger _logger;\n    private readonly IMetrics _metrics;\n    public Result Handle(Command cmd) {\n        var stopwatch = ValueStopwatch StartNew(); // Stack allocated\n        _logger LogDebug(\"Handling {Command}\", cmd);\n        try {\n            var result = _handler Handle(cmd);\n            _logger",
        "startIndex": 12351,
        "preview": "--- [Pure] // Compile-time verification public class CalculationHandler : IHandle<Calculate> { public Result Handle(Calculate cmd) { // ✅ Allowed: Pur..."
      },
      {
        "id": "old-v1.0.0/architecture-design/aspect-oriented-programming-chunk-8",
        "text": "new Result(); } // Generated code (simplified): public class Handler_Generated : IHandle<Command> { private readonly Handler _handler; private readonly ILogger _logger; private readonly IMetrics _metrics; public Result Handle(Command cmd) { var stopwatch = ValueStopwatch StartNew(); // Stack allocated _logger LogDebug(\"Handling {Command}\", cmd); try { var result = _handler Handle(cmd); _logger LogDebug(\"Handled {Command} in {Duration}ms\", cmd, stopwatch ElapsedMilliseconds);\n            _metrics RecordDuration(\"handler duration\", stopwatch Elapsed);\n            return result;\n        }\n        catch (Exception ex) {\n            _logger LogError(ex, \"Error handling {Command}\", cmd);\n            _metrics IncrementCounter(\"handler errors\");\n            throw;\n        }\n    }\n}\n`\nAspect Caching\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Performance, Caching, Optimization]\ndescription: Aspect instance caching for performance optimization\n---\n// Aspects instances are cached and reused\n[Expensive] // This aspect instance is created once and reused\npublic class Handler : IHandle<Command> {\n    // Aspect state is maintained across invocations where appropriate\n}\n`\nTesting with Aspects\nUnit Testing\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Testing, Unit-Tests, Verification]\ndescription: Unit testing handlers with aspect verification\n---\n[Test]\npublic async Task Handler_WithAspects_LogsAndTimes() {\n    // Arrange\n    var handler = new OrderHandler();\n    var context = new TestAspectContext();\n    // Act\n    var result = await AspectRunner RunWithAspects(\n        handler,\n        new CreateOrder { OrderId = \"123\" },\n        context\n    );\n    // Assert\n    result ShouldBeSuccess();\n    context Logs ShouldContain(log => log Message Contains(\"123\"));\n    context Metrics[\"handler duration\"] ShouldBeLessThan(100);\n}\n`\nIntegration Testing\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Testing, Integration-Tests, Production-Testing]\ndescription: Integration testing with production aspect profiles\n---\n[Test]\npublic async Task Handler_WithProductionAspects_WorksCorrectly() {\n    await Whizbang Test<OrderHandler>() Given(new CreateOrder { }) WithAspects(AspectProfile Production) // Use production aspects WhenHandled() Then(result => result ShouldBeSuccess()) AndAspect<CacheAspect>(cache => \n            cache ShouldHaveStored(\"order:123\")) AndAspect<LoggingAspect>(logs => \n            logs ShouldContain(LogLevel",
        "startIndex": 14591,
        "preview": "new Result(); } // Generated code (simplified): public class Handler_Generated : IHandle<Command> { private readonly Handler _handler; private readonl..."
      },
      {
        "id": "old-v1.0.0/architecture-design/aspect-oriented-programming-chunk-9",
        "text": "--- category: Architecture difficulty: INTERMEDIATE tags: [AOP, Testing, Integration-Tests, Production-Testing] description: Integration testing with production aspect profiles --- [Test] public async Task Handler_WithProductionAspects_WorksCorrectly() { await Whizbang Test<OrderHandler>() Given(new CreateOrder { }) WithAspects(AspectProfile Production) // Use production aspects WhenHandled() Then(result => result ShouldBeSuccess()) AndAspect<CacheAspect>(cache => cache ShouldHaveStored(\"order:123\")) AndAspect<LoggingAspect>(logs => logs ShouldContain(LogLevel Info, \"Order created\"));\n}\n`\nIDE Integration\nIntelliSense Support\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [AOP, IDE-Integration, IntelliSense, Tooling]\ndescription: IDE support for aspect suggestions and execution order visualization\n---\n// IDE suggests applicable aspects based on handler type\n[Wh| // IDE suggests: WhizbangCached, WhizbangLogged, WhizbangRetry // IDE shows aspect execution order\n[Logged]    // (1)\n[Cached]    // (2)  \n[Retry]     // (3)\npublic class Handler { \n    // IDE tooltip: \"Execution order: Logged -> Cached -> Retry -> Handler\"\n}\n`\nRefactoring Support\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [AOP, IDE-Integration, Refactoring, Tooling]\ndescription: IDE refactoring support for aspects and composites\n---\n// Rename aspect updates all usages\n[MyCustomAspect] // F2 rename updates everywhere\npublic class Handler { }\n// Extract aspect combination to composite\n[Logged]\n[Timed]\n[Retry] // Right-click -> \"Extract to Composite Aspect\"\n`\nBest Practices\nDo's\n✅ Use aspects for cross-cutting concerns\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [AOP, Best-Practices, Cross-Cutting-Concerns]\ndescription: Using aspects for cross-cutting concerns\n---\n[Logged]\n[Authorized]\n[Transactional]\n`\n✅ Keep aspects focused and single-purpose\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [AOP, Best-Practices, Single-Responsibility]\ndescription: Keeping aspects focused and single-purpose\n---\n[Cached]  // Just caching\n[Logged]  // Just logging\n`\n✅ Compose aspects for complex scenarios\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Best-Practices, Composite-Aspects]\ndescription: Composing aspects for complex scenarios\n---\n[StandardSecurity]  // Composite of auth, audit, encryption\n`\n✅ Test aspects independently\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Best-Practices, Testing]\ndescription: Testing aspects independently\n---\nAspectTester Test<LoggingAspect>()",
        "startIndex": 16770,
        "preview": "--- category: Architecture difficulty: INTERMEDIATE tags: [AOP, Testing, Integration-Tests, Production-Testing] description: Integration testing with ..."
      },
      {
        "id": "old-v1.0.0/architecture-design/aspect-oriented-programming-chunk-10",
        "text": "aspects for complex scenarios `csharp --- category: Architecture difficulty: INTERMEDIATE tags: [AOP, Best-Practices, Composite-Aspects] description: Composing aspects for complex scenarios --- [StandardSecurity] // Composite of auth, audit, encryption ` ✅ Test aspects independently `csharp --- category: Architecture difficulty: INTERMEDIATE tags: [AOP, Best-Practices, Testing] description: Testing aspects independently --- AspectTester Test<LoggingAspect>() VerifyBehavior();\n`\nDon'ts\n❌ Don't put business logic in aspects\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [AOP, Anti-Patterns, Bad-Practices]\ndescription: Anti-pattern - putting business logic in aspects\n---\n[CalculateTax] // Bad: Business logic belongs in handler\n`\n❌ Don't create circular aspect dependencies\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [AOP, Anti-Patterns, Circular-Dependencies]\ndescription: Anti-pattern - circular aspect dependencies\n---\n[AspectA(DependsOn = \"AspectB\")]\n[AspectB(DependsOn = \"AspectA\")] // Circular `\n❌ Don't overuse aspects\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [AOP, Anti-Patterns, Over-Engineering]\ndescription: Anti-pattern - overusing aspects obscures logic\n---\n// Too many aspects obscure logic\n[Aspect1][Aspect2][Aspect3][Aspect4][Aspect5] `\nSummary\nWhizbang's AOP system brings enterprise-grade aspect-oriented programming to NET with:\nZero runtime overhead through source generation\nCompile-time safety with verification\nRich IDE support for productivity  \nComposable aspects for complex scenarios\nTestable aspects for confidence\nThis enables clean separation of cross-cutting concerns from business logic while maintaining performance and type safety Next Steps\nLearn about Return Type Semantics\nExplore Policy Composition\nSee Aspect-Oriented Handlers pattern\nReview Testing Strategies for aspects",
        "startIndex": 18784,
        "preview": "aspects for complex scenarios `csharp --- category: Architecture difficulty: INTERMEDIATE tags: [AOP, Best-Practices, Composite-Aspects] description: ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/architecture-design/event-driven-architecture",
    "title": "Event-Driven Architecture",
    "category": "Architecture & Design",
    "url": "/docs/old-v1.0.0/architecture-design/event-driven-architecture",
    "chunks": [
      {
        "id": "old-v1.0.0/architecture-design/event-driven-architecture-chunk-0",
        "text": "Event-Driven Architecture\nOverview\nWhizbang is built on a universal event-driven architecture where all state changes flow through events, regardless of whether you're using Event-Driven or Event-Sourced mode This fundamental design principle enables seamless progression from simple applications to complex event-sourced systems without changing your core logic The Key Insight\nWrite through events, read through lenses This simple principle unifies all Whizbang applications:\nCommands flow to Receptors which make decisions\nReceptors emit Events representing those decisions  \nEvents flow to Perspectives which update views\nLenses provide read-only access to current state\nEvent-Driven vs Event-Sourced\nBoth modes use the same components and patterns The only difference is whether events are persisted:\n| Aspect | Event-Driven Mode | Event-Sourced Mode |\n|--------|-------------------|-------------------|\n| Events | Transient - drive immediate updates | Persisted - become source of truth |\n| Receptors | Stateless - get state from Lenses | Stateful - maintain state from event stream |\n| Perspectives | Execute inline with receptor | Execute async from event stream |\n| Ledger | Not used | Stores all events permanently |\n| Replay | Not possible | Can rebuild from events |\n| Transaction | Receptor + Perspective together | Event append is the transaction |\nCore Components\nReceptor\nPurpose: Receives commands, makes decisions, emits events\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Receptors, Event-Driven, CQRS]\ndescription: Universal receptor interface that works in both event-driven and event-sourced modes\n---\n// Same interface works in both modes public class OrderReceptor : IReceptor<CreateOrder> {\n    public OrderCreated Receive(CreateOrder cmd, IOrderLens lens) {\n        // Validate using lens (read-only view)\n        var customer = lens GetCustomer(cmd CustomerId);\n        if ( customer IsActive) {\n            throw new InactiveCustomerException();\n        }\n        // Make decision and emit event\n        return new OrderCreated(\n            Guid NewGuid(),\n            cmd CustomerId,\n            cmd Items,\n            DateTime",
        "startIndex": 0,
        "preview": "Event-Driven Architecture\nOverview\nWhizbang is built on a universal event-driven architecture where all state changes flow through events, regardless ..."
      },
      {
        "id": "old-v1.0.0/architecture-design/event-driven-architecture-chunk-1",
        "text": "public class OrderReceptor : IReceptor<CreateOrder> { public OrderCreated Receive(CreateOrder cmd, IOrderLens lens) { // Validate using lens (read-only view) var customer = lens GetCustomer(cmd CustomerId); if ( customer IsActive) { throw new InactiveCustomerException(); } // Make decision and emit event return new OrderCreated( Guid NewGuid(), cmd CustomerId, cmd Items, DateTime UtcNow\n        );\n    }\n}\n`\nPerspective\nPurpose: Updates views and projections from events\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Perspectives, Event-Driven, Projections]\ndescription: Perspective that updates multiple data stores from events, working identically in both modes\n---\n// Perspectives work identically in both modes\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        // Update database\n        await db Orders Add(new Order { \n            Id = e OrderId,\n            CustomerId = e CustomerId \n        });\n        // Update cache\n        await cache Invalidate($\"customer:{e CustomerId}\");\n        // Update search index\n        await search",
        "startIndex": 2198,
        "preview": "public class OrderReceptor : IReceptor<CreateOrder> { public OrderCreated Receive(CreateOrder cmd, IOrderLens lens) { // Validate using lens (read-onl..."
      },
      {
        "id": "old-v1.0.0/architecture-design/event-driven-architecture-chunk-2",
        "text": "// Perspectives work identically in both modes public class OrderPerspective : IPerspectiveOf<OrderCreated> { public async Task Update(OrderCreated e) { // Update database await db Orders Add(new Order { Id = e OrderId, CustomerId = e CustomerId }); // Update cache await cache Invalidate($\"customer:{e CustomerId}\"); // Update search index await search Index(e);\n    }\n}\n`\nLens\nPurpose: Provides read-only access to current state\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Lenses, Read-Model, Query-Interface]\ndescription: Read-only lens interface providing consistent data access regardless of execution mode\n---\n// Lenses provide consistent reads regardless of mode\npublic interface IOrderLens {\n    Order Focus(Guid id);                           // Get single item\n    IEnumerable<Order> View(Expression<Func<Order, bool>> filter);\n    OrderSummary Glimpse(Guid id);                  // Summary view\n    bool Exists(Guid id);                           // Quick check\n}\n`\nDispatcher\nPurpose: Routes commands to receptors and events to perspectives\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Dispatcher, CQRS, Message-Routing]\ndescription: Core dispatcher interface for command routing, event broadcasting, and query execution\n---\npublic interface IDispatcher {\n    Task<TEvent> Dispatch<TEvent>(ICommand<TEvent> command);\n    Task Broadcast(IEvent @event);\n    Task<TResult> Query<TResult>(IQuery<TResult> query);\n}\n`\nThe Universal Pattern\nThis pattern works identically in both modes:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Universal-Pattern, Business-Logic, Event-Driven]\ndescription: Universal pattern showing receptor and perspective working identically in both modes\n---\npublic class TransferMoneyReceptor : IReceptor<TransferMoney> {\n    public MoneyTransferred Receive(TransferMoney cmd, IAccountLens lens) {\n        // Read current state through lens\n        var fromAccount = lens Focus(cmd FromAccountId);\n        var toAccount = lens Focus(cmd ToAccountId);\n        // Make business decision\n        if (fromAccount Balance < cmd Amount) {\n            throw new InsufficientFundsException();\n        }\n        // Emit event - this IS the write operation\n        return new MoneyTransferred(\n            cmd FromAccountId,\n            cmd ToAccountId,\n            cmd Amount,\n            DateTime",
        "startIndex": 2961,
        "preview": "// Perspectives work identically in both modes public class OrderPerspective : IPerspectiveOf<OrderCreated> { public async Task Update(OrderCreated e)..."
      },
      {
        "id": "old-v1.0.0/architecture-design/event-driven-architecture-chunk-3",
        "text": "current state through lens var fromAccount = lens Focus(cmd FromAccountId); var toAccount = lens Focus(cmd ToAccountId); // Make business decision if (fromAccount Balance < cmd Amount) { throw new InsufficientFundsException(); } // Emit event - this IS the write operation return new MoneyTransferred( cmd FromAccountId, cmd ToAccountId, cmd Amount, DateTime UtcNow\n        );\n    }\n}\npublic class AccountPerspective : IPerspectiveOf<MoneyTransferred> {\n    public async Task Update(MoneyTransferred e) {\n        // In Event-Driven: Direct database update\n        // In Event-Sourced: Update from replayed event\n        await db UpdateBalance(e FromAccountId, -e Amount);\n        await db UpdateBalance(e ToAccountId, e Amount);\n        await db AddTransaction(e);\n    }\n}\n`\nMode Selection via Policies\nConfigure behavior per-receptor using policies:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Policy-Configuration, Mode-Selection, Hybrid]\ndescription: Configuration showing mixed modes within same application using policies\n---\nservices AddWhizbang() UseDispatcher(dispatcher => {\n        // Default mode for all receptors\n        dispatcher DefaultPolicy = new EventDrivenPolicy();\n        // Specific receptors use event sourcing\n        dispatcher ForReceptor<PaymentReceptor>() UsePolicy(new EventSourcedPolicy());\n        dispatcher ForReceptor<AuditReceptor>() UsePolicy(new EventSourcedPolicy());\n        // Mix modes in same application });\n`\nEvolution Path\nPhase 1: Event-Driven (Stateless Receptors)\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Event-Driven, Stateless-Receptors, Phase-1]\ndescription: Event-driven mode with stateless receptor getting state from lens\n---\n// Stateless receptor gets state from lens\npublic class OrderReceptor : IReceptor<ShipOrder> {\n    public OrderShipped Receive(ShipOrder cmd, IOrderLens lens) {\n        var order = lens Focus(cmd OrderId);  // Get state from lens\n        if (order Status = \"Paid\") {\n            throw new InvalidOperationException(\"Order must be paid\");\n        }\n        return new OrderShipped(cmd OrderId, DateTime",
        "startIndex": 5036,
        "preview": "current state through lens var fromAccount = lens Focus(cmd FromAccountId); var toAccount = lens Focus(cmd ToAccountId); // Make business decision if ..."
      },
      {
        "id": "old-v1.0.0/architecture-design/event-driven-architecture-chunk-4",
        "text": "--- // Stateless receptor gets state from lens public class OrderReceptor : IReceptor<ShipOrder> { public OrderShipped Receive(ShipOrder cmd, IOrderLens lens) { var order = lens Focus(cmd OrderId); // Get state from lens if (order Status = \"Paid\") { throw new InvalidOperationException(\"Order must be paid\"); } return new OrderShipped(cmd OrderId, DateTime UtcNow);\n    }\n}\n`\nPhase 2: Event-Sourced (Stateful Receptors)\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [Architecture, Event-Sourcing, Stateful-Receptors, Phase-2]\ndescription: Event-sourced mode with stateful receptor maintaining state from events\n---\n// Same receptor, now stateful\n[EventSourced]\npublic class OrderReceptor : IReceptor<ShipOrder> {\n    private OrderStatus status;  // State maintained from events\n    public OrderShipped Receive(ShipOrder cmd) {\n        if (status = OrderStatus Paid) {  // Use internal state\n            throw new InvalidOperationException(\"Order must be paid\");\n        }\n        return new OrderShipped(Id, DateTime UtcNow);\n    }\n    // Apply events to maintain state\n    public void Absorb(OrderCreated e) => status = OrderStatus Created;\n    public void Absorb(OrderPaid e) => status = OrderStatus Paid;\n    public void Absorb(OrderShipped e) => status = OrderStatus Shipped;\n}\n`\nThe Flow\nEvent-Driven Mode\n`text\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Event-Driven, Flow-Diagram, Synchronous]\ndescription: Event-driven mode flow with immediate database updates\n---\nCommand → Dispatcher → Receptor → Event\n                           ↓\n                    Perspective → Database (immediate)\n                           ↓\n                        Lens → Queries\n`\nEvent-Sourced Mode\n`text\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [Architecture, Event-Sourcing, Flow-Diagram, Asynchronous]\ndescription: Event-sourced mode flow with ledger persistence and async perspective updates\n---\nCommand → Dispatcher → Receptor → Event\n                           ↓\n                        Ledger (persist)\n                           ↓\n                    Perspective → Database (async)\n                           ↓\n                        Lens → Queries\n`\nKey Principles\nEvents Are The Write Model\nNo direct database writes",
        "startIndex": 6874,
        "preview": "--- // Stateless receptor gets state from lens public class OrderReceptor : IReceptor<ShipOrder> { public OrderShipped Receive(ShipOrder cmd, IOrderLe..."
      },
      {
        "id": "old-v1.0.0/architecture-design/event-driven-architecture-chunk-5",
        "text": "difficulty: ADVANCED tags: [Architecture, Event-Sourcing, Flow-Diagram, Asynchronous] description: Event-sourced mode flow with ledger persistence and async perspective updates --- Command → Dispatcher → Receptor → Event ↓ Ledger (persist) ↓ Perspective → Database (async) ↓ Lens → Queries ` Key Principles Events Are The Write Model No direct database writes All state changes flow through events:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Best-Practices, Events-As-Write-Model, Anti-Patterns]\ndescription: Comparison showing wrong direct database writes vs correct event-driven approach\n---\n// ❌ WRONG - Direct database write\npublic void Handle(CreateOrder cmd) {\n    var order = new Order { };\n    database Orders Add(order);  // Don't do this database SaveChanges();\n}\n// ✅ RIGHT - Write through events\npublic OrderCreated Receive(CreateOrder cmd) {\n    return new OrderCreated( );  // Perspective handles the write\n}\n`\nLenses Are Read-Only\nLenses never modify state, they only observe:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Best-Practices, Read-Only-Lenses, Anti-Patterns]\ndescription: Comparison showing wrong lens with write methods vs correct read-only lens\n---\n// ❌ WRONG - Lens with write methods\npublic interface IOrderLens {\n    void Save(Order order);  // Don't do this }\n// ✅ RIGHT - Read-only lens\npublic interface IOrderLens {\n    Order Focus(Guid id);\n    bool Exists(Guid id);\n}\n`\nPerspectives Handle All Writes\nAll database updates happen in perspectives:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Best-Practices, Perspective-Writes, Separation-Of-Concerns]\ndescription: Proper perspective implementation handling all database writes\n---\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        // ALL writes happen here\n        await db Orders Add( );\n        await cache Set( );\n        await search Index(",
        "startIndex": 8793,
        "preview": "difficulty: ADVANCED tags: [Architecture, Event-Sourcing, Flow-Diagram, Asynchronous] description: Event-sourced mode flow with ledger persistence and..."
      },
      {
        "id": "old-v1.0.0/architecture-design/event-driven-architecture-chunk-6",
        "text": "perspectives: `csharp --- category: Architecture difficulty: INTERMEDIATE tags: [Architecture, Best-Practices, Perspective-Writes, Separation-Of-Concerns] description: Proper perspective implementation handling all database writes --- public class OrderPerspective : IPerspectiveOf<OrderCreated> { public async Task Update(OrderCreated e) { // ALL writes happen here await db Orders Add( ); await cache Set( ); await search Index( );\n    }\n}\n`\nBenefits\nImmediate Benefits (Event-Driven Mode)\nClear separation between reads and writes\nExplicit side effects - all changes visible as events\nNatural audit trail - events show what happened\nTestability - test receptors without database\nAdditional Benefits (Event-Sourced Mode)\nComplete history - every change is recorded\nTime travel - see state at any point in time\nEvent replay - rebuild projections from events\nDebugging - trace exactly what happened\nMigration Strategy\nMoving from Event-Driven to Event-Sourced is seamless:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Migration-Strategy, Progressive-Enhancement, Evolution]\ndescription: Step-by-step migration from event-driven to event-sourced without code changes\n---\n// Step 1: You're already Event-Driven\nservices AddWhizbang() UseDispatcher(d => d DefaultPolicy = new EventDrivenPolicy());\n// Step 2: Enable Event-Sourcing for specific receptors\nservices AddWhizbang() UseDispatcher(d => {\n        d DefaultPolicy = new EventDrivenPolicy();\n        d ForReceptor<Order>() UsePolicy(new EventSourcedPolicy());\n    });\n// Step 3: Gradually migrate more receptors\n// No code changes needed `\nReal-World Example\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Real-World-Example, Multiple-Perspectives, Checkout-Process]\ndescription: Complete checkout example showing receptor with multiple perspectives handling different concerns\n---\n// This receptor works in BOTH modes without changes\npublic class CheckoutReceptor : IReceptor<Checkout> {\n    public CheckoutCompleted Receive(Checkout cmd, ICheckoutLens lens) {\n        // Validate inventory\n        var inventory = lens GetInventory(cmd Items);\n        if ( inventory IsAvailable()) {\n            throw new OutOfStockException();\n        }\n        // Validate payment\n        var paymentMethod = lens GetPaymentMethod(cmd PaymentId);\n        if ( paymentMethod",
        "startIndex": 10461,
        "preview": "perspectives: `csharp --- category: Architecture difficulty: INTERMEDIATE tags: [Architecture, Best-Practices, Perspective-Writes, Separation-Of-Conce..."
      },
      {
        "id": "old-v1.0.0/architecture-design/event-driven-architecture-chunk-7",
        "text": "receptor works in BOTH modes without changes public class CheckoutReceptor : IReceptor<Checkout> { public CheckoutCompleted Receive(Checkout cmd, ICheckoutLens lens) { // Validate inventory var inventory = lens GetInventory(cmd Items); if ( inventory IsAvailable()) { throw new OutOfStockException(); } // Validate payment var paymentMethod = lens GetPaymentMethod(cmd PaymentId); if ( paymentMethod IsValid()) {\n            throw new InvalidPaymentException();\n        }\n        // Emit event - the perspective handles all writes\n        return new CheckoutCompleted(\n            Guid NewGuid(),\n            cmd CustomerId,\n            cmd Items,\n            cmd PaymentId,\n            DateTime UtcNow\n        );\n    }\n}\n// Multiple perspectives update different concerns\npublic class OrderPerspective : IPerspectiveOf<CheckoutCompleted> {\n    public async Task Update(CheckoutCompleted e) {\n        await db Orders Create(e OrderId, e CustomerId, e Items);\n    }\n}\npublic class InventoryPerspective : IPerspectiveOf<CheckoutCompleted> {\n    public async Task Update(CheckoutCompleted e) {\n        foreach (var item in e Items) {\n            await db Inventory Reserve(item ProductId, item Quantity);\n        }\n    }\n}\npublic class PaymentPerspective : IPerspectiveOf<CheckoutCompleted> {\n    public async Task Update(CheckoutCompleted e) {\n        await paymentGateway Charge(e PaymentId, e Total);\n    }\n}\n`\nSummary\nThe Event-Driven Architecture in Whizbang provides:\nUnified model - Same patterns for Event-Driven and Event-Sourced\nProgressive enhancement - Start simple, add event sourcing when needed\nNo rewrites - Same receptor code works in both modes\nMix and match - Use different modes for different aggregates\nClear semantics - Events for writes, lenses for reads\nThis architecture ensures that you're always thinking in events, whether you choose to persist them or not Next Steps\nLearn about Receptors - The universal command handler\nExplore Perspectives - Event-driven projections\nUnderstand Lenses - Read-only query interfaces\nSee Progressive Enhancement - Evolution strategies",
        "startIndex": 12427,
        "preview": "receptor works in BOTH modes without changes public class CheckoutReceptor : IReceptor<Checkout> { public CheckoutCompleted Receive(Checkout cmd, IChe..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/architecture-design/philosophy",
    "title": "Philosophy & Design Principles",
    "category": "Architecture & Design",
    "url": "/docs/old-v1.0.0/architecture-design/philosophy",
    "chunks": [
      {
        "id": "old-v1.0.0/architecture-design/philosophy-chunk-0",
        "text": "Philosophy & Design Principles\nWhizbang is a unified event-driven and event-sourced runtime for NET that collapses the complexity of MartenDB, Wolverine, MassTransit, and MediatR into a single cohesive platform with receptors, perspectives, and lenses Core Philosophy\nEvents as the Source of Truth\nEvents are immutable facts that have happened In Whizbang, events are not just notifications—they are the authoritative record of everything that has occurred in your system All aggregates and projections can be rebuilt or reimagined from the event stream at any time, even years after initial deployment This approach provides:\nComplete audit trail - Every state change is recorded forever\nTime travel debugging - Replay events to understand how state evolved\nFlexible projections - Build new read models from existing events\nMigration freedom - Refactor your domain model without losing history\nSingle Surface Area\nTeams waste cognitive energy context-switching between different APIs, patterns, and abstractions Whizbang provides one set of primitives for:\nReceptors - Decision-makers that receive commands and emit events\nPerspectives - Event handlers that update read models and external systems\nLenses - Read-only interfaces for querying data\nCommands - Requests to change state, routed to domain owners\nEvents - Immutable facts that represent state changes\nSagas - Long-running processes that coordinate across domains\nAll of these concepts share the same dispatcher model, dependency injection patterns, and testing approaches Learn once, apply everywhere One Runtime Any Mode Every Pattern Write your business logic once Run it anywhere Whizbang provides a unified mental model that scales from event-driven development to complex distributed event-sourced systems—without changing your receptors",
        "startIndex": 0,
        "preview": "Philosophy & Design Principles\nWhizbang is a unified event-driven and event-sourced runtime for NET that collapses the complexity of MartenDB, Wolveri..."
      },
      {
        "id": "old-v1.0.0/architecture-design/philosophy-chunk-1",
        "text": "these concepts share the same dispatcher model, dependency injection patterns, and testing approaches Learn once, apply everywhere One Runtime Any Mode Every Pattern Write your business logic once Run it anywhere Whizbang provides a unified mental model that scales from event-driven development to complex distributed event-sourced systems—without changing your receptors `csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Philosophy, Universal-Design, Mode-Switching, Progressive-Enhancement]\ndescription: Single receptor working across all modes with configuration-based mode switching\n---\n// This SAME receptor works across ALL modes\npublic class OrderReceptor : IReceptor<CreateOrder> {\n    public OrderCreated Receive(CreateOrder cmd) {\n        // Your business logic here\n        return new OrderCreated(cmd OrderId);\n    }\n}\n// Mode switching is just configuration\nservices AddWhizbang(d => d UseEventDrivenMode());     // Development\nservices AddWhizbang(d => d UseEventDrivenMode());     // Production with perspectives\nservices AddWhizbang(d => d UseDistributedMode());     // Microservices with relays\nservices AddWhizbang(d => d UseEventSourcing());       // Event sourcing with ledger\n`\nReturn Type Semantics\nWhat you return determines what happens No configuration files, no routing tables, no ceremony Your intent is clear from your code:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Philosophy, Return-Type-Semantics, Message-Patterns, Railway-Oriented]\ndescription: Return type semantics demonstrating how different return types determine behavior\n---\n// Single return = single effect\nreturn new OrderCreated();                           // Publishes event\n// Tuple return = multiple effects\nreturn (new OrderCreated(), new ProcessPayment());   // Cascading messages\n// Result return = railway-oriented programming\nreturn Result Success(new OrderCreated());          // Success/failure handling\n// Streaming return = real-time processing\nyield return new OrderProcessed();                  // IAsyncEnumerable\n`\nAspect-Oriented by Design\nCross-cutting concerns are first-class citizens",
        "startIndex": 1818,
        "preview": "these concepts share the same dispatcher model, dependency injection patterns, and testing approaches Learn once, apply everywhere One Runtime Any Mod..."
      },
      {
        "id": "old-v1.0.0/architecture-design/philosophy-chunk-2",
        "text": "Publishes event // Tuple return = multiple effects return (new OrderCreated(), new ProcessPayment()); // Cascading messages // Result return = railway-oriented programming return Result Success(new OrderCreated()); // Success/failure handling // Streaming return = real-time processing yield return new OrderProcessed(); // IAsyncEnumerable ` Aspect-Oriented by Design Cross-cutting concerns are first-class citizens Through source generators and compile-time weaving, aspects like logging, retry, caching, and authorization are declarative and performant:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Philosophy, Aspect-Oriented, Cross-Cutting-Concerns, Declarative]\ndescription: Aspect-oriented design with declarative attributes for cross-cutting concerns\n---\n[Logged]\n[Cached(Duration = \"5m\")]\n[Retry(3, Backoff = \"exponential\")]\n[Authorized(Role = \"Admin\")]\npublic class OrderReceptor : IReceptor<CreateOrder> {\n    [Pure] // Compile-time verification of no side effects\n    public OrderCreated Receive(CreateOrder cmd) {\n        // All aspects automatically applied\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nFrom Simple to Scale\nWhizbang is designed for the full spectrum:\nSimple Start: Use Whizbang as event-driven architecture with in-memory perspectives Perfect for development and simple applications Growth Path: Add perspective persistence, event sourcing with ledger, and distributed relays as your needs grow Every feature is opt-in Enterprise Scale: Deploy across microservices with message brokers, multiple databases, multi-region disaster recovery, and Kubernetes auto-scaling The same code works at every scale Your simple receptors become distributed event-sourced receptors without rewrites Progressive Enhancement\nStart simple Add complexity only when needed Every Whizbang application follows the same growth path:\nEvent-Driven Development - Stateless receptors with in-memory perspectives\nEvent-Driven Production - Persistent perspectives with retry\nEvent-Driven Distributed - Scale across services with relays\nEvent-Sourced - Stateful receptors with ledger when needed\nThe same receptor code works at every level No rewrites as you scale Design Principles\nDriver-Based Architecture\nNever lock into a specific technology",
        "startIndex": 3590,
        "preview": "Publishes event // Tuple return = multiple effects return (new OrderCreated(), new ProcessPayment()); // Cascading messages // Result return = railway..."
      },
      {
        "id": "old-v1.0.0/architecture-design/philosophy-chunk-3",
        "text": "receptors with in-memory perspectives Event-Driven Production - Persistent perspectives with retry Event-Driven Distributed - Scale across services with relays Event-Sourced - Stateful receptors with ledger when needed The same receptor code works at every level No rewrites as you scale Design Principles Driver-Based Architecture Never lock into a specific technology Whizbang uses a driver-based system for:\nPersistence - Postgres, SQL Server, MySQL, Cosmos DB, LiteFS/SQLite\nMessaging - Kafka, RabbitMQ, Azure Service Bus, AWS SQS, in-memory\nSerialization - JSON, Protobuf, MessagePack, custom formats\nObservability - OpenTelemetry, Application Insights, custom telemetry\nSwap drivers through configuration, not code changes Start with SQLite for local dev, move to Postgres in staging, scale to Cosmos DB in production—all with the same domain code Domain Ownership\nEvery event and command has a home In distributed systems, clarity about ownership prevents chaos:\nCommands are sent TO the domain that owns them\nEvents are emitted FROM the domain that owns them\nNew services can subscribe to events and backfill projections from the entire event stream\nDomain boundaries are explicit in code and configuration\nThis prevents the \"event spaghetti\" problem where no one knows who publishes what, or where to send commands Receptors as Pure Functions\nReceptors are just Cmethods that return events No magic base classes, no required interfaces (unless you want them), no framework coupling Mark a receptor as pure and the Roslyn analyzer forbids hidden side effects—guaranteeing your receptor is a true function from input to output `csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Philosophy, Pure-Functions, Compile-Time-Safety, Side-Effects]\ndescription: Pure function example with compile-time verification preventing side effects\n---\n[Pure]\npublic OrderCalculated Receive(CalculateOrder cmd) {\n    // ✅ Pure computation allowed\n    return new OrderCalculated(cmd Items Sum(i => i Price));\n    // ❌ Compile error: Side effects not allowed in pure receptor\n    // await database",
        "startIndex": 5466,
        "preview": "receptors with in-memory perspectives Event-Driven Production - Persistent perspectives with retry Event-Driven Distributed - Scale across services wi..."
      },
      {
        "id": "old-v1.0.0/architecture-design/philosophy-chunk-4",
        "text": "INTERMEDIATE tags: [Philosophy, Pure-Functions, Compile-Time-Safety, Side-Effects] description: Pure function example with compile-time verification preventing side effects --- [Pure] public OrderCalculated Receive(CalculateOrder cmd) { // ✅ Pure computation allowed return new OrderCalculated(cmd Items Sum(i => i Price)); // ❌ Compile error: Side effects not allowed in pure receptor // await database SaveAsync(result);\n}\n`\nConvention Over Configuration\nYour code expresses intent through conventions Return types determine behavior Attributes declare aspects Source generators eliminate boilerplate No XML files, no complex registration, no ceremony `csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Philosophy, Convention-Over-Configuration, Return-Types, Declarative]\ndescription: Convention-based programming showing how return types and attributes express intent\n---\n// Return type determines what happens\npublic OrderCreated Receive(CreateOrder cmd) => new OrderCreated();      // Event to perspectives\npublic ProcessPayment Receive(OrderCreated e) => new ProcessPayment();   // Command to other receptor\npublic void Receive(LogActivity cmd) => Console WriteLine(cmd Message);  // Fire-and-forget\n// Attributes declare behavior\n[Idempotent]     // Automatic deduplication\n[Transactional]  // Wrap in transaction\n[Logged]         // Structured logging\n`\nObservable by Default\nProblems found in production are 10x more expensive than problems found in development Whizbang includes:\nOpenTelemetry traces for every command, event, and perspective update\nLive dashboard showing message lag, perspective health, and error rates\nDistributed tracing across services and message brokers\nPerformance budgets that alert when receptors exceed latency targets\nObservability is not bolted on—it's built into the core runtime Idempotence Everywhere\nMessages may be delivered more than once Whizbang ensures:\nExactly-once semantics for event handling and perspective updates\nAutomatic deduplication based on message IDs\nOutbox/Inbox pattern for reliable message delivery across service boundaries\nIdempotent perspectives that can safely process the same event multiple times\nYour domain logic never needs to worry about duplicate messages Compile-Time Safety\nCatch errors during build, not at runtime",
        "startIndex": 7204,
        "preview": "INTERMEDIATE tags: [Philosophy, Pure-Functions, Compile-Time-Safety, Side-Effects] description: Pure function example with compile-time verification p..."
      },
      {
        "id": "old-v1.0.0/architecture-design/philosophy-chunk-5",
        "text": "event handling and perspective updates Automatic deduplication based on message IDs Outbox/Inbox pattern for reliable message delivery across service boundaries Idempotent perspectives that can safely process the same event multiple times Your domain logic never needs to worry about duplicate messages Compile-Time Safety Catch errors during build, not at runtime Through source generators and Roslyn analyzers, Whizbang provides unprecedented compile-time verification:\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [Philosophy, Compile-Time-Safety, Source-Generators, Effect-Tracking]\ndescription: Compile-time safety with pure functions and effect declarations verified by source generators\n---\n[Pure]\npublic class CalculationReceptor : IReceptor<Calculate> {\n    public Result Receive(Calculate cmd) {\n        // ✅ Pure computation allowed\n        var result = cmd A + cmd B;\n        // ❌ Compile error: I/O not allowed in pure function\n        // await database SaveAsync(result);\n        return new Result(result);\n    }\n}\n[Effects(Writes = \"Orders\", Publishes = \"OrderEvents\")]\npublic class OrderReceptor : IReceptor<CreateOrder> {\n    // Source generator verifies declared effects match actual usage\n}\n`\nAOT-Safe and Performance-First\nModern NET demands performance Whizbang achieves both developer experience and runtime performance through:\nSource generation - Zero runtime reflection overhead\nNative AOT - Full trimming and AOT compilation support\nAssembly trimming - Only include what you use\nStruct messages - Stack allocation for small messages\nObject pooling - Automatic pooling of receptors and messages\nSIMD operations - Vectorized operations where applicable\nDeploy as a tiny container or serverless function without compromise Security and Multi-Tenancy First\nSecurity is not an afterthought",
        "startIndex": 9122,
        "preview": "event handling and perspective updates Automatic deduplication based on message IDs Outbox/Inbox pattern for reliable message delivery across service ..."
      },
      {
        "id": "old-v1.0.0/architecture-design/philosophy-chunk-6",
        "text": "trimming - Only include what you use Struct messages - Stack allocation for small messages Object pooling - Automatic pooling of receptors and messages SIMD operations - Vectorized operations where applicable Deploy as a tiny container or serverless function without compromise Security and Multi-Tenancy First Security is not an afterthought Whizbang provides built-in support for:\nMulti-tenancy - Tenant isolation at the event stream, projection, and command level\nPermission scoping - Fine-grained authorization for commands, queries, and events\nTrusted/untrusted boundaries - Separate handling for internal vs external services\nAudit logging - Track who did what, when, and why\nData encryption - At-rest and in-transit encryption support\nMulti-tenant architecture:\nTenant ID propagated through all message contexts\nTenant-scoped event streams (e g , Tenant-{tenantId}-Order-{orderId})\nTenant-specific projections and read models\nCross-tenant operations prevented by default\nPermission model:\nCommands require explicit permissions (e g , orders:place, inventory:reserve)\nQueries can be scoped to accessible data only\nEvents carry identity context for audit trails\nRoslyn analyzer enforces authorization checks\nService trust boundaries:\nInternal services (trusted) can access raw event streams\nExternal services (untrusted) receive filtered, sanitized events\nAPI gateways enforce authentication and authorization\nService-to-service authentication via mutual TLS or tokens\nOpinionated Recipes, Flexible Foundation\nWhizbang provides opinionated recipes to prevent analysis paralysis:\nStarter templates for common scenarios (web API, worker service, microservice)\nBest practice examples for aggregates, sagas, projections\nConvention-based configuration that \"just works\" out of the box\nBut under the hood, everything is pluggable:\nSwap drivers\nOverride conventions\nCustomize serialization\nExtend the pipeline\nYou're not locked into our opinions if your scenario demands something different Comparison to Existing Tools\nvs Marten + Wolverine (The \"Critter Stack\")\nWhat they are: Marten is a document database and event store for PostgreSQL Wolverine is a messaging and mediator framework",
        "startIndex": 10589,
        "preview": "trimming - Only include what you use Struct messages - Stack allocation for small messages Object pooling - Automatic pooling of receptors and message..."
      },
      {
        "id": "old-v1.0.0/architecture-design/philosophy-chunk-7",
        "text": "Override conventions Customize serialization Extend the pipeline You're not locked into our opinions if your scenario demands something different Comparison to Existing Tools vs Marten + Wolverine (The \"Critter Stack\") What they are: Marten is a document database and event store for PostgreSQL Wolverine is a messaging and mediator framework Together they form the \"Critter Stack\"—the most mature CQRS/ES stack in NET as of 2025 Strengths:\nBattle-tested in production since 2016\nExcellent PostgreSQL integration with partitioning, snapshotting, and \"Quick Append\"\nFull OpenTelemetry and metrics support\n\"Aggregate handler workflow\" for clean CQRS\nWhizbang Differences:\nMulti-database: Marten is PostgreSQL-only Whizbang supports Postgres, SQL Server, MySQL, Cosmos DB, and SQLite through drivers Unified runtime: Marten + Wolverine are two separate libraries Whizbang is a single, cohesive runtime Domain ownership: Whizbang enforces explicit domain ownership for distributed systems (commands TO owner, events FROM owner) Multi-tenancy first: Built-in tenant isolation at the event stream, projection, and command level Aspire integration: First-class NET Aspire support with one-command local dev setup Lakehouse streaming: Stream events to Delta Lake, Iceberg, or Parquet for analytics Dashboard: Dedicated web dashboard for message journey visualization and control plane When to choose Marten + Wolverine: You're committed to PostgreSQL and want the most mature, proven stack When to choose Whizbang: You need multi-database support, tighter integration, multi-tenancy, or advanced features like lakehouse streaming ---\nvs MediatR\nWhat it is: MediatR is a simple in-process mediator for implementing CQRS in a single application Used by thousands of NET projects Strengths:\nExtremely simple and lightweight\nNo infrastructure dependencies\nPerfect for monolithic applications\nMinimal learning curve\nWhizbang Differences:\nEvent sourcing: MediatR has no event sourcing Whizbang includes full ledger support Perspectives: MediatR has no read model support Whizbang includes perspective engine Distributed messaging: MediatR is in-process only Whizbang scales to microservices",
        "startIndex": 12436,
        "preview": "Override conventions Customize serialization Extend the pipeline You're not locked into our opinions if your scenario demands something different Comp..."
      },
      {
        "id": "old-v1.0.0/architecture-design/philosophy-chunk-8",
        "text": "Strengths: Extremely simple and lightweight No infrastructure dependencies Perfect for monolithic applications Minimal learning curve Whizbang Differences: Event sourcing: MediatR has no event sourcing Whizbang includes full ledger support Perspectives: MediatR has no read model support Whizbang includes perspective engine Distributed messaging: MediatR is in-process only Whizbang scales to microservices Growth path: With MediatR, scaling to distributed requires a complete rewrite With Whizbang, the same receptor code works at every scale When to choose MediatR: You're building a simple monolith and will never need event sourcing or microservices When to choose Whizbang: You want a growth path from simple to complex without rewrites ---\nvs MassTransit\nWhat it is: MassTransit is a mature distributed messaging framework for NET Supports RabbitMQ, Azure Service Bus, Amazon SQS, and more Open source (Apache 2 0) Strengths:\nMature message routing, retries, and error handling\nExcellent transport abstraction (RabbitMQ, Azure Service Bus, etc )\nSaga support for long-running processes\nFree for production use\nWhizbang Differences:\nEvent sourcing: MassTransit has no event sourcing Whizbang includes ledger Perspectives: MassTransit has no read model support Whizbang includes perspective engine All-in-one: MassTransit focuses on messaging Whizbang integrates messaging + event sourcing + perspectives Event-driven: MassTransit requires a broker even for in-process Whizbang starts as event-driven architecture When to choose MassTransit: You only need messaging and already have event sourcing/projections handled separately When to choose Whizbang: You want a unified platform for CQRS/ES with messaging built-in ---\nvs NServiceBus\nWhat it is: NServiceBus is the enterprise-grade service bus for NET from Particular Software The most feature-rich messaging framework Strengths:\nComprehensive tooling (ServicePulse, ServiceInsight for monitoring)\nEnterprise support and training available\nBattle-tested in large-scale systems\nAdvanced error handling and sagas\nWhizbang Differences:\nLicensing: NServiceBus requires paid license for production Whizbang is open source Event sourcing: NServiceBus has no event sourcing",
        "startIndex": 14294,
        "preview": "Strengths: Extremely simple and lightweight No infrastructure dependencies Perfect for monolithic applications Minimal learning curve Whizbang Differe..."
      },
      {
        "id": "old-v1.0.0/architecture-design/philosophy-chunk-9",
        "text": "NET from Particular Software The most feature-rich messaging framework Strengths: Comprehensive tooling (ServicePulse, ServiceInsight for monitoring) Enterprise support and training available Battle-tested in large-scale systems Advanced error handling and sagas Whizbang Differences: Licensing: NServiceBus requires paid license for production Whizbang is open source Event sourcing: NServiceBus has no event sourcing Whizbang includes ledger Perspectives: NServiceBus has no read model engine Whizbang includes perspective engine Dashboard: NServiceBus has separate tools (ServicePulse, ServiceInsight) Whizbang has integrated dashboard When to choose NServiceBus: You need enterprise support and are willing to pay for it When to choose Whizbang: You want open-source, all-in-one CQRS/ES with messaging ---\nvs Equinox\nWhat it is: Equinox is an event sourcing library from Jet com (Walmart) Supports CosmosDB, DynamoDB, EventStoreDB, and SqlStreamStore backends F#-first design Strengths:\nPolyglot storage (CosmosDB, DynamoDB, EventStoreDB, etc )\nSophisticated caching strategies\nFunctional programming approach (Ffirst)\nLibrary, not framework (lightweight coupling)\nWhizbang Differences:\nC#-first: Equinox is F#-first Whizbang is designed for Cdevelopers Messaging: Equinox has no built-in messaging Whizbang includes distributed messaging Perspectives: Equinox requires separate Propulsion library Whizbang includes perspective engine Dashboard: Equinox has no dashboard Whizbang includes web dashboard Aspire: Equinox has no Aspire integration Whizbang has first-class Aspire support When to choose Equinox: You're building in Fand want a lightweight library When to choose Whizbang: You're building in Cand want an integrated framework ---\nvs EventStoreDB\nWhat it is: EventStoreDB is a purpose-built event store database The gold standard for event sourcing since 2012 Strengths:\nPurpose-built for event sourcing\nProjections built into the database\nCatchup subscriptions and persistent subscriptions\nMature and proven\nWhizbang Differences:\nDatabase dependency: EventStoreDB is a separate database to run Whizbang works with databases you already have (Postgres, SQL Server, etc ) CQRS framework: EventStoreDB is just storage Whizbang includes dispatcher, messaging, perspectives, and dashboard",
        "startIndex": 15085,
        "preview": "NET from Particular Software The most feature-rich messaging framework Strengths: Comprehensive tooling (ServicePulse, ServiceInsight for monitoring) ..."
      },
      {
        "id": "old-v1.0.0/architecture-design/philosophy-chunk-10",
        "text": "sourcing Projections built into the database Catchup subscriptions and persistent subscriptions Mature and proven Whizbang Differences: Database dependency: EventStoreDB is a separate database to run Whizbang works with databases you already have (Postgres, SQL Server, etc ) CQRS framework: EventStoreDB is just storage Whizbang includes dispatcher, messaging, perspectives, and dashboard Driver-based: Whizbang isn't locked to one database EventStoreDB is a single product When to choose EventStoreDB: You want the absolute best event store and are willing to run a dedicated database When to choose Whizbang: You want an all-in-one framework using databases you already have",
        "startIndex": 18048,
        "preview": "sourcing Projections built into the database Catchup subscriptions and persistent subscriptions Mature and proven Whizbang Differences: Database depen..."
      },
      {
        "id": "old-v1.0.0/architecture-design/philosophy-chunk-11",
        "text": "dispatcher, messaging, perspectives, and dashboard Driver-based: Whizbang isn't locked to one database EventStoreDB is a single product When to choose EventStoreDB: You want the absolute best event store and are willing to run a dedicated database When to choose Whizbang: You want an all-in-one framework using databases you already have ---\nSummary Comparison\n| Feature | Whizbang | Marten + Wolverine | MediatR | MassTransit | NServiceBus | Equinox | EventStoreDB |\n|---------|----------|-------------------|---------|-------------|-------------|---------|--------------|\n| Event Sourcing | ✅ Built-in | ✅ Marten | ❌ | ❌ | ❌ | ✅ Library | ✅ Database |\n| Perspectives | ✅ Built-in | ✅ Marten | ❌ | ❌ | ❌ | ⚠️ Propulsion | ✅ Built-in |\n| Messaging | ✅ Built-in | ✅ Wolverine | ❌ | ✅ Core focus | ✅ Core focus | ❌ | ❌ |\n| Event-Driven | ✅ Built-in | ✅ Wolverine | ✅ Core focus | ⚠️ Via broker | ❌ | ❌ | ❌ |\n| Multi-database | ✅ Yes | ❌ Postgres only | N/A | N/A | N/A | ✅ Yes | ❌ Own DB |\n| Dashboard | ✅ Included | ❌ | ❌ | ❌ | ✅ Paid tools | ❌ | ✅ UI |\n| Multi-tenancy | ✅ First-class | ⚠️ Manual | ❌ | ❌ | ❌ | ❌ | ❌ |\n| Aspire | ✅ First-class | ⚠️ Community | ❌ | ⚠️ Community | ❌ | ❌ | ⚠️ Community |\n| License | 🟢 Open source | 🟢 Open source | 🟢 Open source | 🟢 Apache 2 0 | 🔴 Commercial | 🟢 Apache 2",
        "startIndex": 18340,
        "preview": "dispatcher, messaging, perspectives, and dashboard Driver-based: Whizbang isn't locked to one database EventStoreDB is a single product When to choose..."
      },
      {
        "id": "old-v1.0.0/architecture-design/philosophy-chunk-12",
        "text": "| ❌ | | Aspire | ✅ First-class | ⚠️ Community | ❌ | ⚠️ Community | ❌ | ❌ | ⚠️ Community | | License | 🟢 Open source | 🟢 Open source | 🟢 Open source | 🟢 Apache 2 0 | 🔴 Commercial | 🟢 Apache 2 0 | 🟡 Free/Paid |\n| Cvs F# | C#-first | C#-first | C#-first | C#-first | C#-first | F#-first | Language-agnostic |\nKey Insight: Whizbang is the only library that combines event sourcing, perspectives, messaging, event-driven patterns, multi-tenancy, and dashboard into a single, cohesive runtime with multi-database support Our Stance\nWe believe:\nEvents are more valuable than current state\nDomain ownership prevents distributed system chaos\nPure functions are easier to test and reason about\nObservability must be built in, not bolted on\nAOT and small binaries matter for modern deployments\nDevelopers should never be locked into a specific database or message broker\nSimple scenarios should stay simple; complex scenarios should be possible\nNext Steps\nNow that you understand Whizbang's philosophy and design principles:\nGetting Started - Build your first Whizbang application with a step-by-step tutorial\nPackage Structure - Learn about all available NuGet packages and their dependencies\nCore Concepts - Deep dive into receptors, perspectives, lenses, and events\nWe are building Whizbang to be the pit of success for event-sourced, message-driven systems in NET",
        "startIndex": 19312,
        "preview": "| ❌ | | Aspire | ✅ First-class | ⚠️ Community | ❌ | ⚠️ Community | ❌ | ❌ | ⚠️ Community | | License | 🟢 Open source | 🟢 Open source | 🟢 Open source..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/architecture-design/whizbang-unified-vision",
    "title": "Whizbang Unified Vision",
    "category": "Architecture & Design",
    "url": "/docs/old-v1.0.0/architecture-design/whizbang-unified-vision",
    "chunks": [
      {
        "id": "old-v1.0.0/architecture-design/whizbang-unified-vision-chunk-0",
        "text": "Whizbang Unified Vision\nOne Runtime Any Mode Every Pattern Whizbang represents a fundamental shift in how we think about messaging, events, and commands in NET Instead of choosing between different libraries for different needs, Whizbang provides one mental model that scales from simple in-process messaging to complex distributed event-sourced systems—without changing your code The Problem We Solve\nToday's NET developers face an impossible choice:\nMediatR for simple in-process messaging\nWolverine for performance and durability  \nMassTransit for distributed systems\nNServiceBus for enterprise features\nCustom solutions for event sourcing\nEach library requires different patterns, different abstractions, and different mental models Migrating between them means rewriting your entire application layer The Whizbang Solution: Progressive Enhancement\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [Progressive-Enhancement, Unified-Model, Configuration]\ndescription: Same handler code works across all modes with progressive enhancement\n---\n// This SAME handler works across ALL modes\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd, IOrderRepository repo) {\n        var order = repo CreateOrder(cmd);\n        return new OrderCreated(order Id, order Total);\n    }\n}\n// Start simple (like MediatR)\nservices AddWhizbang() UseInProcessMode();\n// Add durability (like Wolverine) - SAME HANDLER\nservices AddWhizbang() UseDurableMode();\n// Scale to distributed (like MassTransit) - SAME HANDLER  \nservices AddWhizbang() UseDistributedMode();\n// Enable event sourcing (unique to Whizbang) - SAME HANDLER\nservices AddWhizbang() UseEventSourcedMode();\n`\nCore Philosophy\nOne Mental Model\nWrite your business logic once The same handlers, same patterns, and same abstractions work whether you're building a monolith or a distributed system Convention Over Configuration\nSmart defaults derived from the best practices of all major libraries Return types determine behavior Attributes declare aspects Source generators eliminate boilerplate Aspect-Oriented by Design\nCross-cutting concerns are first-class citizens, not afterthoughts Logging, retry, caching, authorization—all composable through a powerful aspect system Compile-Time Safety\nSource generators verify correctness at build time Pure functions are enforced",
        "startIndex": 0,
        "preview": "Whizbang Unified Vision\nOne Runtime Any Mode Every Pattern Whizbang represents a fundamental shift in how we think about messaging, events, and comman..."
      },
      {
        "id": "old-v1.0.0/architecture-design/whizbang-unified-vision-chunk-1",
        "text": "best practices of all major libraries Return types determine behavior Attributes declare aspects Source generators eliminate boilerplate Aspect-Oriented by Design Cross-cutting concerns are first-class citizens, not afterthoughts Logging, retry, caching, authorization—all composable through a powerful aspect system Compile-Time Safety Source generators verify correctness at build time Pure functions are enforced Side effects are tracked Mistakes are caught before runtime Performance Without Compromise\nRuntime code generation like Wolverine Zero-allocation patterns Adaptive optimization The convenience of high-level abstractions with the performance of hand-tuned code Learning from the Best\nWhat We Take from Each Library\n| Library | What We Adopt | How We Improve |\n|---------|---------------|----------------|\n| MediatR | Simplicity, pipeline behaviors | Add durability without complexity |\n| Wolverine | Return type semantics, code generation | Extend to distributed scenarios |\n| MassTransit | State machines, routing | Simplify configuration |\n| Brighter | Policy attributes, command processor | Unify with aspects |\n| Rebus | Flexibility, defer patterns | Maintain simplicity at scale |\n| NServiceBus | Saga orchestration, monitoring | Open source with better DX |\nUnique Innovations\nReturn Type Semantics\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Effects, Streaming, Railway-Oriented-Programming]\ndescription: Return type semantics demonstrating different effect patterns\n---\npublic class OrderHandler {\n    // Single return = single effect\n    public OrderCreated Handle(CreateOrder cmd) => \n        new OrderCreated(cmd OrderId);\n    // Tuple return = multiple effects (cascading)\n    public (OrderCreated, ProcessPayment, SendEmail) HandleComplete(CreateOrder cmd) => \n        (new OrderCreated(), new ProcessPayment(), new SendEmail());\n    // Result return = validation with railway-oriented programming\n    public Result<OrderCreated> HandleWithValidation(CreateOrder cmd) =>\n        cmd IsValid() Result Success(new OrderCreated())\n            : Result Failure<OrderCreated>(\"Invalid order\");\n    // IAsyncEnumerable = streaming results\n    public async IAsyncEnumerable<OrderEvent> HandleBatch(ProcessBatch cmd) {\n        foreach (var item in cmd Items) {\n            yield return ProcessItem(item);\n        }\n    }\n    // Void = fire-and-forget\n    public void HandleNotification(NotifyUser cmd) => \n        Console",
        "startIndex": 2393,
        "preview": "best practices of all major libraries Return types determine behavior Attributes declare aspects Source generators eliminate boilerplate Aspect-Orient..."
      },
      {
        "id": "old-v1.0.0/architecture-design/whizbang-unified-vision-chunk-2",
        "text": "with railway-oriented programming public Result<OrderCreated> HandleWithValidation(CreateOrder cmd) => cmd IsValid() Result Success(new OrderCreated()) : Result Failure<OrderCreated>(\"Invalid order\"); // IAsyncEnumerable = streaming results public async IAsyncEnumerable<OrderEvent> HandleBatch(ProcessBatch cmd) { foreach (var item in cmd Items) { yield return ProcessItem(item); } } // Void = fire-and-forget public void HandleNotification(NotifyUser cmd) => Console WriteLine(\"Notified\");\n}\n`\nAspect-Oriented Programming\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Aspects, Source-Generation, Pure-Functions]\ndescription: Aspect-oriented programming with compile-time verification\n---\n[Logged]\n[Timed]\n[Cached(Duration = \"5m\")]\n[Retry(3, Backoff = \"exponential\")]\n[Authorized(Role = \"Admin\")]\npublic class OrderHandler : IHandle<CreateOrder> {\n    [Pure] // Compile-time verification of no side effects\n    public OrderCreated Handle(CreateOrder cmd) {\n        // All aspects automatically applied via source generation\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nPure Functions with Effect Tracking\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [Pure-Functions, Effect-Tracking, Compile-Time-Verification]\ndescription: Pure functions with effect tracking and compile-time enforcement\n---\n[Pure] // Enforced at compile time\npublic OrderCalculated Calculate(Order order) {\n    // ✅ Pure computation allowed\n    return new OrderCalculated(order Items Sum(i => i Price));\n    // ❌ Compile error: I/O not allowed in pure function\n    // await database SaveAsync(order);\n}\n[Effects(Reads = \"Inventory\", Writes = \"Orders\", Publishes = \"OrderEvents\")]\npublic async Task<OrderCreated> Handle(CreateOrder cmd) {\n    // Effects are declared and tracked\n    var inventory = await ReadInventory();\n    var order = await WriteOrder(cmd);\n    await PublishEvent(new OrderCreated());\n    return order;\n}\n`\nCompile-Time Verification\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [Event-Sourcing, Aggregates, Compile-Time-Verification, Pure-Event-Application]\ndescription: Event sourced aggregate with compile-time verification\n---\n[EventSourced]\npublic class Order : Aggregate {\n    [Pure] // Verified: no side effects in event application\n    public void Apply(OrderCreated e) {\n        Id = e OrderId;\n        Total = e Total;\n        // await EmailService Send(); // ❌ Compile error\n    }\n    [Command]\n    public OrderShipped Ship(ShipOrder cmd) {\n        // Business logic with compile-time rule checking\n        if (Status = OrderStatus",
        "startIndex": 4486,
        "preview": "with railway-oriented programming public Result<OrderCreated> HandleWithValidation(CreateOrder cmd) => cmd IsValid() Result Success(new OrderCreated()..."
      },
      {
        "id": "old-v1.0.0/architecture-design/whizbang-unified-vision-chunk-3",
        "text": "Aggregate { [Pure] // Verified: no side effects in event application public void Apply(OrderCreated e) { Id = e OrderId; Total = e Total; // await EmailService Send(); // ❌ Compile error } [Command] public OrderShipped Ship(ShipOrder cmd) { // Business logic with compile-time rule checking if (Status = OrderStatus Paid) {\n            throw new InvalidOperationException(); // ⚠️ Warning: Consider Result<T>\n        }\n        return new OrderShipped(Id);\n    }\n}\n`\nArchitecture Modes\nMode 1: In-Process (Development/Monolith)\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [Configuration, In-Process-Mode, Development]\ndescription: In-process mode configuration for development and monoliths\n---\nservices AddWhizbang() UseInProcessMode() WithInMemoryStorage();\n`\nZero configuration\nImmediate execution\nPerfect for development\nNo infrastructure needed\nMode 2: Durable (Single Service)\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Configuration, Durable-Mode, Persistence, Outbox-Pattern]\ndescription: Durable mode with PostgreSQL and outbox pattern\n---\nservices AddWhizbang() UseDurableMode() UsePostgreSQL(connectionString) WithOutbox();\n`\nAutomatic persistence\nOutbox pattern\nRetry on failure\nTransaction support\nMode 3: Distributed (Microservices)\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [Configuration, Distributed-Mode, Kafka, Saga-Orchestration, Distributed-Tracing]\ndescription: Distributed mode with Kafka, saga orchestration, and tracing\n---\nservices AddWhizbang() UseDistributedMode() UseKafka(config) WithSagaOrchestration() WithDistributedTracing();\n`\nCross-service messaging\nSaga orchestration\nDistributed tracing\nMultiple transports\nMode 4: Event-Sourced (Event-Driven)\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [Configuration, Event-Sourcing, Event-Store, Projections, Snapshots]\ndescription: Event sourced mode with projections and snapshots\n---\nservices AddWhizbang() UseEventSourcedMode() UseEventStore(config) WithProjections()",
        "startIndex": 6620,
        "preview": "Aggregate { [Pure] // Verified: no side effects in event application public void Apply(OrderCreated e) { Id = e OrderId; Total = e Total; // await Ema..."
      },
      {
        "id": "old-v1.0.0/architecture-design/whizbang-unified-vision-chunk-4",
        "text": "saga orchestration, and tracing --- services AddWhizbang() UseDistributedMode() UseKafka(config) WithSagaOrchestration() WithDistributedTracing(); ` Cross-service messaging Saga orchestration Distributed tracing Multiple transports Mode 4: Event-Sourced (Event-Driven) `csharp --- category: Architecture difficulty: ADVANCED tags: [Configuration, Event-Sourcing, Event-Store, Projections, Snapshots] description: Event sourced mode with projections and snapshots --- services AddWhizbang() UseEventSourcedMode() UseEventStore(config) WithProjections() WithSnapshots();\n`\nFull event sourcing\nAutomatic projections\nTime travel debugging\nCQRS patterns\nThe Developer Experience\nIDE Integration\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [IDE-Integration, IntelliSense, Developer-Experience, Tooling]\ndescription: IDE integration with IntelliSense and code generation\n---\n// IntelliSense knows about aspects and suggests appropriate ones\n[Wh| // IDE suggests: WhizbangHandler, WhizbangSaga, WhizbangProjection\npublic class OrderHandler {\n    // Type 'Handle' and IDE generates method with aspects\n    public Handle| // IDE template with return type options\n}\n`\nTesting Excellence\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Testing, Aspects, Production-Testing, Verification]\ndescription: Testing with production aspects and comprehensive verification\n---\n[Test]\npublic async Task OrderHandler_CreatesOrder_WithAllAspects() {\n    await Whizbang Test<OrderHandler>() Given(new CreateOrder { }) WithAspects() // Test with production aspects WhenHandled() Then(result => result ShouldBeSuccess()) AndAspect<LoggingAspect>(logs => logs ShouldContain(\"Order created\")) AndAspect<MetricsAspect>(metrics => metrics[\"orders created\"] ShouldBe(1)) AndAspect<CacheAspect>(cache => cache",
        "startIndex": 8395,
        "preview": "saga orchestration, and tracing --- services AddWhizbang() UseDistributedMode() UseKafka(config) WithSagaOrchestration() WithDistributedTracing(); ` C..."
      },
      {
        "id": "old-v1.0.0/architecture-design/whizbang-unified-vision-chunk-5",
        "text": "[Testing, Aspects, Production-Testing, Verification] description: Testing with production aspects and comprehensive verification --- [Test] public async Task OrderHandler_CreatesOrder_WithAllAspects() { await Whizbang Test<OrderHandler>() Given(new CreateOrder { }) WithAspects() // Test with production aspects WhenHandled() Then(result => result ShouldBeSuccess()) AndAspect<LoggingAspect>(logs => logs ShouldContain(\"Order created\")) AndAspect<MetricsAspect>(metrics => metrics[\"orders created\"] ShouldBe(1)) AndAspect<CacheAspect>(cache => cache ShouldHaveStored(\"order:123\"));\n}\n`\nObservability Built-In\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Observability, OpenTelemetry, Tracing, Metrics, Logging]\ndescription: Built-in observability with automatic OpenTelemetry integration\n---\n// Automatic OpenTelemetry integration\n[Observed]\npublic class OrderHandler {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Automatically generates:\n        // - Distributed trace spans\n        // - Metrics (count, duration, errors)\n        // - Structured logs\n        // - Health checks\n        return new OrderCreated();\n    }\n}\n`\nMigration Path\nFrom MediatR\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [Migration, MediatR, Comparison, Simplification]\ndescription: Migration from MediatR showing simplified interface\n---\n// Before (MediatR)\npublic class Handler : IRequestHandler<Command, Result> {\n    public Task<Result> Handle(Command request, CancellationToken ct) { }\n}\n// After (Whizbang) - Almost identical public class Handler : IHandle<Command> {\n    public Result Handle(Command cmd) { }  // Simpler, no cancellation token\n}\n`\nFrom MassTransit\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [Migration, MassTransit, Comparison, Context-Via-Aspects]\ndescription: Migration from MassTransit with cleaner interface\n---\n// Before (MassTransit)\npublic class Consumer : IConsumer<Message> {\n    public async Task Consume(ConsumeContext<Message> context) { }\n}\n// After (Whizbang) - Cleaner, same power\npublic class Handler : IHandle<Message> {\n    public Response Handle(Message msg) { }  // Context available via aspects\n}\n`\nFrom Wolverine\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [Migration, Wolverine, Return-Type-Semantics, Comparison]\ndescription: Migration from Wolverine preserving return type semantics\n---\n// Before (Wolverine)\npublic static class Handler {\n    public static Result Handle(Command cmd) { }\n}\n// After (Whizbang) - Same return type semantics",
        "startIndex": 9724,
        "preview": "[Testing, Aspects, Production-Testing, Verification] description: Testing with production aspects and comprehensive verification --- [Test] public asy..."
      },
      {
        "id": "old-v1.0.0/architecture-design/whizbang-unified-vision-chunk-6",
        "text": "via aspects } ` From Wolverine `csharp --- category: Architecture difficulty: BEGINNER tags: [Migration, Wolverine, Return-Type-Semantics, Comparison] description: Migration from Wolverine preserving return type semantics --- // Before (Wolverine) public static class Handler { public static Result Handle(Command cmd) { } } // After (Whizbang) - Same return type semantics public class Handler : IHandle<Command> {\n    public Result Handle(Command cmd) { }  // Return type still determines behavior\n}\n`\nPerformance Characteristics\n| Aspect | Implementation | Benefit |\n|--------|---------------|---------|\n| Source Generation | Compile-time code generation | Zero reflection overhead |\n| Struct Messages | Value types for small messages | Reduced allocations |\n| Object Pooling | Automatic for handlers and messages | Lower GC pressure |\n| SIMD Operations | Vectorized operations where applicable | Faster processing |\n| Adaptive Optimization | Runtime profiling and recompilation | Improves over time |\nComparison Matrix\n| Feature | Whizbang | MediatR | Wolverine | MassTransit | NServiceBus |\n|---------|----------|---------|-----------|-------------|-------------|\n| In-Process | ✅ | ✅ | ✅ | ✅ | ✅ |\n| Distributed | ✅ | ❌ | ✅ | ✅ | ✅ |\n| Event Sourcing | ✅ Native | ❌ | ⚠️ | ❌ | ⚠️ |\n| AOP | ✅ First-class | ⚠️ | ⚠️ | ⚠️ | ⚠️ |\n| Return Type Semantics | ✅ | ❌ | ✅ | ❌ | ❌ |\n| Source Generation | ✅ | ❌ | ✅ | ❌ | ❌ |\n| Pure Functions | ✅ | ❌ | ❌ | ❌ | ❌ |\n| Effect Tracking | ✅ | ❌ | ❌ | ❌ | ❌ |\n| Progressive Enhancement | ✅ | ❌ | ⚠️ | ⚠️ | ⚠️ |\n| Time Travel Testing | ✅ | ❌ | ❌ | ❌ | ❌ |\nSummary\nWhizbang is not just another messaging library—it's a unified platform that grows with your application",
        "startIndex": 11733,
        "preview": "via aspects } ` From Wolverine `csharp --- category: Architecture difficulty: BEGINNER tags: [Migration, Wolverine, Return-Type-Semantics, Comparison]..."
      },
      {
        "id": "old-v1.0.0/architecture-design/whizbang-unified-vision-chunk-7",
        "text": "| ❌ | ❌ | | Progressive Enhancement | ✅ | ❌ | ⚠️ | ⚠️ | ⚠️ | | Time Travel Testing | ✅ | ❌ | ❌ | ❌ | ❌ | Summary Whizbang is not just another messaging library—it's a unified platform that grows with your application Start simple like MediatR, add durability like Wolverine, scale like MassTransit, and leverage event sourcing when you need it—all without changing your handlers or learning new patterns Write once Run anywhere Scale infinitely Next Steps\nSee Aspect-Oriented Programming for the AOP system\nLearn about Return Type Semantics \nExplore Progressive Enhancement\nRead the Getting Started guide",
        "startIndex": 13066,
        "preview": "| ❌ | ❌ | | Progressive Enhancement | ✅ | ❌ | ⚠️ | ⚠️ | ⚠️ | | Time Travel Testing | ✅ | ❌ | ❌ | ❌ | ❌ | Summary Whizbang is not just another messagin..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/commands/command-handling",
    "title": "Command Handling",
    "category": "Commands",
    "url": "/docs/old-v1.0.0/commands/command-handling",
    "chunks": [
      {
        "id": "old-v1.0.0/commands/command-handling-chunk-0",
        "text": "Command Handling\nCommands represent intent or actions in your system Command handlers contain business logic, validate commands, apply business rules, and emit events to record what happened CRITICAL: Events Can ONLY Be Emitted via Command Handling\nEvents are the result of command processing - they cannot be created directly You must send a command to emit an event `mermaid\nsequenceDiagram\n    participant User\n    participant API as API/Service\n    participant Handler as Command Handler\n    participant Context as CommandContext\n    participant EventStore as Event Store\n    participant Projection as Projections\n    User->>API: Send Command<br/>(PlaceOrder)\n    API->>Handler: Handle(command, context)\n    Note over Handler: ✅ Validate command<br/>✅ Apply business rules<br/>✅ Make decisions\n    Handler->>Context: EmitEvent(OrderPlaced)<br/>⚠️ ONLY way to create events\n    Context->>Context: Populate EventContext<br/>(user, tenant, timestamp)\n    Context->>EventStore: Append event\n    EventStore-->>Context: Event persisted\n    Context-->>Handler: Event emitted\n    Handler->>Context: Send(ReserveInventory)<br/>✅ Emit follow-up commands\n    Context->>API: Route command\n    Handler-->>API: Return event\n    API-->>User: Success\n    EventStore->>Projection: Notify subscribers\n    Note over Projection: ✅ Pure transformation<br/>❌ NO event emission\n`\nThis constraint ensures:\nSingle Source of Truth: All events originate from command handling - clear causation\nAuditability: Every event has a corresponding command that caused it\nAuthorization: Commands are the authorization boundary - validate before creating events\nBusiness Logic Encapsulation: Events are created only after business rules pass\nTransaction Boundary: Command handling is the transaction boundary for event emission\nEvent Context: CommandContext automatically populates EventContext metadata (user, tenant, etc )\nCommandContext Structure\n`csharp{\ntitle: \"CommandContext Structure\"\ndescription: \"Core structure for command handling context with event emission and security\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"Context\", \"Security\", \"Events\"]\nfilename: \"CommandContext cs\"\nusingStatements: [\"System\", \"System Threading",
        "startIndex": 0,
        "preview": "Command Handling\nCommands represent intent or actions in your system Command handlers contain business logic, validate commands, apply business rules,..."
      },
      {
        "id": "old-v1.0.0/commands/command-handling-chunk-1",
        "text": "for event emission Event Context: CommandContext automatically populates EventContext metadata (user, tenant, etc ) CommandContext Structure `csharp{ title: \"CommandContext Structure\" description: \"Core structure for command handling context with event emission and security\" framework: \"NET8\" category: \"Commands\" difficulty: \"INTERMEDIATE\" tags: [\"Commands\", \"Context\", \"Security\", \"Events\"] filename: \"CommandContext cs\" usingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\npublic class CommandContext {\n    // Command metadata\n    public CommandMetadata Command { get; init; }\n    // Security context (from command initiator)\n    public SecurityContext Security { get; init; }\n    // Emit events - ONLY way to create events\n    public TEvent EmitEvent<TEvent>(TEvent @event) where TEvent : class;\n    // Emit follow-up commands\n    public Task Send<TCommand>(TCommand command, CancellationToken ct = default) where TCommand : class;\n    // Access to stores for reading (not writing - use events for that)\n    public IEventStore EventStore { get; init; }\n}\npublic class CommandMetadata {\n    public Guid CommandId { get; init; }\n    public string CommandType { get; init; }\n    public DateTime ReceivedAt { get; init; }\n    public Guid CorrelationId { get; init; }\n}\n`\nBasic Command Handler\n`csharp{\ntitle: \"Basic Command Handler with Event Emission\"\ndescription: \"Command handler that validates, applies business logic, and emits events\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"Command Handlers\", \"Events\", \"Business Logic\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n// ✅ CORRECT: Command handler contains business logic\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderPlaced> {\n    public async Task<OrderPlaced> Handle(\n        PlaceOrder command,\n        CommandContext context,  // ✅ Context for emitting events and commands\n        CancellationToken ct) {\n        // ✅ Business logic happens HERE\n        // - Validate the order\n        // - Check inventory\n        // - Calculate totals\n        // - Apply business rules\n        // - Decide if order should be marked as expired\n        var expiresAt = DateTime UtcNow",
        "startIndex": 2250,
        "preview": "for event emission Event Context: CommandContext automatically populates EventContext metadata (user, tenant, etc ) CommandContext Structure `csharp{ ..."
      },
      {
        "id": "old-v1.0.0/commands/command-handling-chunk-2",
        "text": "// ✅ Context for emitting events and commands CancellationToken ct) { // ✅ Business logic happens HERE // - Validate the order // - Check inventory // - Calculate totals // - Apply business rules // - Decide if order should be marked as expired var expiresAt = DateTime UtcNow AddDays(90);  // ✅ Business decision\n        var isExpired = false;  // ✅ Business decision\n        var status = \"Placed\";   // ✅ Business decision\n        // ✅ Emit event via CommandContext - the ONLY way to create events\n        var @event = context EmitEvent(new OrderPlaced {\n            OrderId = command OrderId,\n            CustomerId = command CustomerId,\n            Total = command Total,\n            ExpiresAt = expiresAt,      // ✅ Set by handler\n            IsExpired = isExpired,       // ✅ Set by handler\n            Status = status              // ✅ Set by handler\n        });\n        return @event;\n    }\n}\n// ✅ CORRECT: Command is a POCO (Plain Old CLR Object)\npublic record PlaceOrder {\n    public Guid OrderId { get; init; }\n    public Guid CustomerId { get; init; }\n    public decimal Total { get; init; }\n    public List<OrderItem> Items { get; init; }\n}\n// ✅ CORRECT: Event is a POCO - describes what happened\npublic record OrderPlaced {\n    public Guid OrderId { get; init; }\n    public Guid CustomerId { get; init; }\n    public decimal Total { get; init; }\n    public DateTime ExpiresAt { get; init; }     // ✅ Data only (set by handler)\n    public bool IsExpired { get; init; }         // ✅ Data only (set by handler)\n    public string Status { get; init; }          // ✅ Data only (set by handler)\n    // ❌ NO business logic methods like:\n    // public bool ShouldExpire() => DateTime",
        "startIndex": 4150,
        "preview": "// ✅ Context for emitting events and commands CancellationToken ct) { // ✅ Business logic happens HERE // - Validate the order // - Check inventory //..."
      },
      {
        "id": "old-v1.0.0/commands/command-handling-chunk-3",
        "text": "init; } // ✅ Data only (set by handler) public bool IsExpired { get; init; } // ✅ Data only (set by handler) public string Status { get; init; } // ✅ Data only (set by handler) // ❌ NO business logic methods like: // public bool ShouldExpire() => DateTime UtcNow > ExpiresAt;\n    // Events are immutable data - handlers make decisions, events record them\n}\npublic record OrderItem {\n    public Guid ProductId { get; init; }\n    public int Quantity { get; init; }\n}\n`\nWhat You CAN and CANNOT Do\n✅ In Command Handlers (Business Logic Layer)\n`csharp{\ntitle: \"Allowed Operations in Command Handlers\"\ndescription: \"Examples of what you can do within command handlers for business logic\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"Business Logic\", \"Best Practices\"]\nfilename: \"CommandHandlerOperations cs\"\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\n// ✅ CAN use DateTime UtcNow for business decisions\nvar expiresAt = DateTime UtcNow AddDays(90);\n// ✅ CAN use Random or Guid NewGuid()\nvar confirmationCode = Random Shared Next(100000, 999999);\n// ✅ CAN call external APIs\nvar customerData = await _customerService GetCustomerAsync(command CustomerId, ct);\n// ✅ CAN read from databases\nvar product = await _productRepository GetAsync(command ProductId, ct);\n// ✅ CAN perform calculations and validations\nif (command Total <= 0) {\n    throw new InvalidOperationException(\"Order total must be positive\");\n}\n// ✅ CAN make business decisions\nvar needsApproval = command Total > 10000;\nvar discount = customer IsPremium 0 10m : 0;\n// ✅ CAN emit events via CommandContext\nvar @event = context EmitEvent(new OrderPlaced { });\n// ✅ CAN emit follow-up commands via CommandContext\nawait context Send(new ReserveInventory {",
        "startIndex": 5562,
        "preview": "init; } // ✅ Data only (set by handler) public bool IsExpired { get; init; } // ✅ Data only (set by handler) public string Status { get; init; } // ✅ ..."
      },
      {
        "id": "old-v1.0.0/commands/command-handling-chunk-4",
        "text": "// ✅ CAN make business decisions var needsApproval = command Total > 10000; var discount = customer IsPremium 0 10m : 0; // ✅ CAN emit events via CommandContext var @event = context EmitEvent(new OrderPlaced { }); // ✅ CAN emit follow-up commands via CommandContext await context Send(new ReserveInventory { }, ct);\n`\n❌ Outside Command Handlers\n`csharp{\ntitle: \"Forbidden Operations Outside Command Handlers\"\ndescription: \"Examples of what you cannot do outside of command handling context\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"Anti-patterns\", \"Best Practices\", \"Events\"]\nfilename: \"ForbiddenOperations cs\"\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\n// ❌ CANNOT emit events directly - no CommandContext\npublic class SomeService {\n    private readonly IEventStore _eventStore;\n    public async Task DoSomething() {\n        // ❌ FORBIDDEN: Cannot create events outside of command handling\n        var @event = new OrderPlaced { };\n        await _eventStore AppendAsync(@event);  // 💥 Compile error - not allowed // ✅ CORRECT: Must send a command instead\n        await _whizbang Send(new PlaceOrder { });\n        // The command handler will emit the event via CommandContext\n    }\n}\n// ❌ CANNOT emit events from projections\n[WhizbangProjection]\npublic class BadProjection {\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        CancellationToken ct) {\n        // ❌ FORBIDDEN: Projections cannot emit events\n        // No CommandContext available - projections are read-side only\n        var newEvent = new OrderProcessed { };  // 💥 Cannot emit\n        // ✅ CORRECT: If you need to trigger something, emit a command\n        await _whizbang Send(new ProcessOrder { });\n        // The command handler will emit events\n    }\n}\n`\nCommand Emission (Sagas and Process Managers)\nHandlers can emit follow-up commands to coordinate workflows:\n`csharp{\ntitle: \"Command Emission in Handlers\"\ndescription: \"Emitting follow-up commands for workflow coordination\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"Sagas\", \"Workflows\", \"Process Managers\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading",
        "startIndex": 7095,
        "preview": "// ✅ CAN make business decisions var needsApproval = command Total > 10000; var discount = customer IsPremium 0 10m : 0; // ✅ CAN emit events via Comm..."
      },
      {
        "id": "old-v1.0.0/commands/command-handling-chunk-5",
        "text": "} ` Command Emission (Sagas and Process Managers) Handlers can emit follow-up commands to coordinate workflows: `csharp{ title: \"Command Emission in Handlers\" description: \"Emitting follow-up commands for workflow coordination\" framework: \"NET8\" category: \"Commands\" difficulty: \"INTERMEDIATE\" tags: [\"Commands\", \"Sagas\", \"Workflows\", \"Process Managers\"] nugetPackages: [\"Whizbang Core\"] usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n// Command handler emits both events and commands\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderPlaced> {\n    public async Task<OrderPlaced> Handle(\n        PlaceOrder command,\n        CommandContext context,\n        CancellationToken ct) {\n        // Business logic\n        var expiresAt = DateTime UtcNow AddDays(90);\n        // ✅ Emit event via CommandContext\n        var @event = context EmitEvent(new OrderPlaced {\n            OrderId = command OrderId,\n            CustomerId = command CustomerId,\n            Total = command Total,\n            ExpiresAt = expiresAt\n        });\n        // ✅ Emit follow-up commands to coordinate workflow\n        await context Send(new ReserveInventory {\n            OrderId = command OrderId,\n            Items = command Items\n        }, ct);\n        await context Send(new NotifyCustomer {\n            CustomerId = command CustomerId,\n            Message = \"Your order has been placed\"\n        }, ct);\n        return @event;\n    }\n}\n// Saga pattern - event handlers emit commands to orchestrate workflow\npublic class OrderSagaHandler : IEventHandler<OrderPlaced> {\n    private readonly IWhizbang _whizbang;\n    public async Task Handle(OrderPlaced @event, CancellationToken ct) {\n        // ✅ Event handler can emit commands (but NOT events)\n        // Step 1: Reserve inventory\n        await _whizbang Send(new ReserveInventory {\n            OrderId = @event OrderId,\n            Items = @event Items\n        }, ct);\n        // Step 2: Authorize payment\n        await _whizbang Send(new AuthorizePayment {\n            OrderId = @event OrderId,\n            Amount = @event Total,\n            CustomerId = @event CustomerId\n        }, ct);\n    }\n}\n`\nAggregate Command Handling\nAggregates can also emit events via CommandContext:\n`csharp{\ntitle: \"Aggregate Command Handling\"\ndescription: \"Using aggregates to handle commands and emit events\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"ADVANCED\"\ntags: [\"Aggregates\", \"Commands\", \"Events\", \"DDD\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang",
        "startIndex": 3475,
        "preview": "} ` Command Emission (Sagas and Process Managers) Handlers can emit follow-up commands to coordinate workflows: `csharp{ title: \"Command Emission in H..."
      },
      {
        "id": "old-v1.0.0/commands/command-handling-chunk-6",
        "text": "@event Total, CustomerId = @event CustomerId }, ct); } } ` Aggregate Command Handling Aggregates can also emit events via CommandContext: `csharp{ title: \"Aggregate Command Handling\" description: \"Using aggregates to handle commands and emit events\" framework: \"NET8\" category: \"Commands\" difficulty: \"ADVANCED\" tags: [\"Aggregates\", \"Commands\", \"Events\", \"DDD\"] nugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\n// Aggregate can emit events via CommandContext\npublic class OrderAggregate : Aggregate {\n    private Guid _orderId;\n    private OrderStatus _status;\n    private List<OrderItem> _items = new();\n    public async Task PlaceOrder(PlaceOrder command, CommandContext context) {\n        // Apply business rules\n        if (_status = OrderStatus None) {\n            throw new InvalidOperationException(\"Order already placed\");\n        }\n        var expiresAt = DateTime UtcNow AddDays(90);\n        // ✅ Emit event via CommandContext\n        var @event = context EmitEvent(new OrderPlaced {\n            OrderId = command OrderId,\n            CustomerId = command CustomerId,\n            Total = command Total,\n            ExpiresAt = expiresAt\n        });\n        // Apply event to aggregate state\n        Apply(@event);\n        // ✅ Aggregate can also emit follow-up commands via CommandContext\n        await context Send(new SendOrderConfirmationEmail {\n            OrderId = command OrderId,\n            CustomerEmail = command CustomerEmail\n        });\n    }\n    public async Task ShipOrder(ShipOrder command, CommandContext context) {\n        // Validate state\n        if (_status = OrderStatus Placed) {\n            throw new InvalidOperationException(\"Order cannot be shipped in current state\");\n        }\n        // ✅ Emit event via CommandContext\n        var @event = context EmitEvent(new OrderShipped {\n            OrderId = command OrderId,\n            TrackingNumber = command TrackingNumber\n        });\n        Apply(@event);\n        // ✅ Emit follow-up command\n        await context Send(new NotifyCustomerOfShipment {\n            OrderId = command OrderId,\n            TrackingNumber = command TrackingNumber\n        });\n    }\n    // Event handlers update aggregate state\n    private void Apply(OrderPlaced @event) {\n        _orderId = @event OrderId;\n        _status = OrderStatus Placed;\n    }\n    private void Apply(OrderShipped @event) {\n        _status = OrderStatus",
        "startIndex": 11262,
        "preview": "@event Total, CustomerId = @event CustomerId }, ct); } } ` Aggregate Command Handling Aggregates can also emit events via CommandContext: `csharp{ tit..."
      },
      {
        "id": "old-v1.0.0/commands/command-handling-chunk-7",
        "text": "}); Apply(@event); // ✅ Emit follow-up command await context Send(new NotifyCustomerOfShipment { OrderId = command OrderId, TrackingNumber = command TrackingNumber }); } // Event handlers update aggregate state private void Apply(OrderPlaced @event) { _orderId = @event OrderId; _status = OrderStatus Placed; } private void Apply(OrderShipped @event) { _status = OrderStatus Shipped;\n    }\n}\npublic enum OrderStatus {\n    None,\n    Placed,\n    Shipped,\n    Delivered,\n    Cancelled\n}\n`\nUse Cases for Command Emission\nSagas / Process Managers: Orchestrate multi-step workflows across aggregates/services\nCommand Chaining: Break complex operations into smaller, coordinated commands\nSide Effects: Trigger notifications, emails, integrations\nCompensating Actions: Send rollback commands if a step fails\nDistributed Transactions: Coordinate actions across multiple bounded contexts\nWorkflow Automation: Trigger next steps in business processes\nSaga Workflow Example\n`mermaid\nsequenceDiagram\n    participant User\n    participant OrderService\n    participant OrderSaga\n    participant InventoryService\n    participant PaymentService\n    participant ShippingService\n    User->>OrderService: PlaceOrder Command\n    OrderService->>OrderService: Validate & Emit OrderPlaced Event\n    OrderService-->>User: Order Created\n    OrderService->>OrderSaga: OrderPlaced Event\n    Note over OrderSaga: Saga orchestrates<br/>multi-step workflow\n    OrderSaga->>InventoryService: ReserveInventory Command\n    InventoryService->>InventoryService: Reserve & Emit InventoryReserved\n    InventoryService-->>OrderSaga: Success\n    OrderSaga->>PaymentService: AuthorizePayment Command\n    PaymentService->>PaymentService: Authorize & Emit PaymentAuthorized\n    PaymentService-->>OrderSaga: Success\n    OrderSaga->>ShippingService: ScheduleShipment Command\n    ShippingService->>ShippingService: Schedule & Emit ShipmentScheduled\n    ShippingService-->>OrderSaga: Success\n    Note over OrderSaga: Workflow complete <br/>All steps succeeded\n    alt Payment Fails\n        PaymentService-->>OrderSaga: Payment Failed\n        OrderSaga->>InventoryService: ReleaseInventory Command\n        Note over OrderSaga: Compensating action<br/>rollback inventory\n    end\n`\nThe Three-Layer Architecture\n`mermaid\ngraph TB\n    subgraph BusinessLogic[\"Command Handler / Aggregate (Business Logic Layer)\"]\n        BL1[\"✅ Validates commands\"]\n        BL2[\"✅ Applies business rules\"]\n        BL3[\"✅ Makes decisions\"]\n        BL4[\"✅ Creates event POCOs with results\"]\n        BL5[\"✅ CAN emit commands (sagas)\"]\n        BL6[\"✅ CAN use DateTime UtcNow, Random, APIs\"]\n    end\n    subgraph DataLayer[\"Data Layer (POCOs - No Logic)\"]\n        Event[\"Event<br/>- Properties only<br/>- NO methods<br/>- Describes what happened\"]\n        Command[\"Command<br/>- Properties only<br/>- NO methods<br/>- Describes intent\"]\n    end\n    subgraph ReadModel[\"Projection (Read Model Layer)\"]\n        P1[\"✅ Pure transformation of event data\"]\n        P2[\"❌ NO business logic\"]\n        P3[\"❌ NO DateTime",
        "startIndex": 13446,
        "preview": "}); Apply(@event); // ✅ Emit follow-up command await context Send(new NotifyCustomerOfShipment { OrderId = command OrderId, TrackingNumber = command T..."
      },
      {
        "id": "old-v1.0.0/commands/command-handling-chunk-8",
        "text": "(sagas)\"] BL6[\"✅ CAN use DateTime UtcNow, Random, APIs\"] end subgraph DataLayer[\"Data Layer (POCOs - No Logic)\"] Event[\"Event<br/>- Properties only<br/>- NO methods<br/>- Describes what happened\"] Command[\"Command<br/>- Properties only<br/>- NO methods<br/>- Describes intent\"] end subgraph ReadModel[\"Projection (Read Model Layer)\"] P1[\"✅ Pure transformation of event data\"] P2[\"❌ NO business logic\"] P3[\"❌ NO DateTime UtcNow, Random, APIs\"]\n        P4[\"✅ ONLY event data or EventContext\"]\n        P5[\"✅ Deterministic and replayable\"]\n    end\n    BusinessLogic -->|Emits Events| Event\n    BusinessLogic -->|Emits Commands| Command\n    Event -->|Consumed by| ReadModel\n    Command -->|Handled by| BusinessLogic\n    style BusinessLogic fill:#d4edda,stroke:#28a745,stroke-width:2px\n    style DataLayer fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    style ReadModel fill:#cce5ff,stroke:#004085,stroke-width:2px\n    style Event fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    style Command fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n`\nCommands vs Events vs Queries\n| Aspect | Command | Event | Query |\n|--------|---------|-------|-------|\n| Purpose | Express intent | Record what happened | Retrieve data |\n| Tense | Imperative (PlaceOrder) | Past tense (OrderPlaced) | Question (GetOrder) |\n| Business Logic | Handler contains logic | NO logic - POCO | NO logic - handler reads data |\n| Side Effects | YES - creates events | NO - immutable data | NO - read-only |\n| Can Fail | YES - validation errors | NO - fact that happened | NO - returns null/empty |\n| Emit Events | YES - via CommandContext | N/A | NO |\n| Emit Commands | YES - via CommandContext | Via event handlers | NO |\nValidation and Error Handling\n`csharp{\ntitle: \"Command Validation and Error Handling\"\ndescription: \"Proper validation and error handling in command handlers\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Validation\", \"Error Handling\", \"Commands\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading",
        "startIndex": 16106,
        "preview": "(sagas)\"] BL6[\"✅ CAN use DateTime UtcNow, Random, APIs\"] end subgraph DataLayer[\"Data Layer (POCOs - No Logic)\"] Event[\"Event<br/>- Properties only<br..."
      },
      {
        "id": "old-v1.0.0/commands/command-handling-chunk-9",
        "text": "Error Handling `csharp{ title: \"Command Validation and Error Handling\" description: \"Proper validation and error handling in command handlers\" framework: \"NET8\" category: \"Commands\" difficulty: \"INTERMEDIATE\" tags: [\"Validation\", \"Error Handling\", \"Commands\"] nugetPackages: [\"Whizbang Core\"] usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading; using System Threading Tasks;\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderPlaced> {\n    private readonly IProductRepository _products;\n    private readonly ICustomerRepository _customers;\n    public PlaceOrderHandler(IProductRepository products, ICustomerRepository customers) {\n        _products = products;\n        _customers = customers;\n    }\n    public async Task<OrderPlaced> Handle(\n        PlaceOrder command,\n        CommandContext context,\n        CancellationToken ct) {\n        // ✅ Validate command data\n        if (command OrderId == Guid Empty) {\n            throw new ArgumentException(\"OrderId is required\", nameof(command OrderId));\n        }\n        if (command Items == null || command Items Count == 0) {\n            throw new ArgumentException(\"Order must have at least one item\", nameof(command Items));\n        }\n        // ✅ Validate business rules\n        var customer = await _customers GetAsync(command CustomerId, ct);\n        if (customer == null) {\n            throw new InvalidOperationException($\"Customer {command CustomerId} not found\");\n        }\n        if ( customer IsActive) {\n            throw new InvalidOperationException(\"Cannot place order for inactive customer\");\n        }\n        // ✅ Check availability\n        foreach (var item in command Items) {\n            var product = await _products GetAsync(item ProductId, ct);\n            if (product == null) {\n                throw new InvalidOperationException($\"Product {item ProductId} not found\");\n            }\n            if (product Stock < item Quantity) {\n                throw new InvalidOperationException(\n                    $\"Insufficient stock for product {product Name} \" +\n                    $\"Available: {product Stock}, Requested: {item Quantity}\");\n            }\n        }\n        // ✅ Calculate totals\n        decimal total = 0;\n        foreach (var item in command Items) {\n            var product = await _products GetAsync(item ProductId, ct);\n            total += product Price * item Quantity;\n        }\n        // ✅ Apply business rules\n        var discount = customer IsPremium total * 0 10m : 0;\n        var finalTotal = total - discount;\n        // ✅ Emit event with all business decisions made\n        var @event = context",
        "startIndex": 17835,
        "preview": "Error Handling `csharp{ title: \"Command Validation and Error Handling\" description: \"Proper validation and error handling in command handlers\" framewo..."
      },
      {
        "id": "old-v1.0.0/commands/command-handling-chunk-10",
        "text": "product = await _products GetAsync(item ProductId, ct); total += product Price * item Quantity; } // ✅ Apply business rules var discount = customer IsPremium total * 0 10m : 0; var finalTotal = total - discount; // ✅ Emit event with all business decisions made var @event = context EmitEvent(new OrderPlaced {\n            OrderId = command OrderId,\n            CustomerId = command CustomerId,\n            Total = finalTotal,\n            Discount = discount,\n            ExpiresAt = DateTime UtcNow AddDays(90),\n            IsExpired = false,\n            Status = \"Placed\"\n        });\n        return @event;\n    }\n}\n`\nSummary\nEvents can ONLY be emitted via CommandContext during command handling\nCommand handlers contain business logic - validation, rules, decisions\nEvents are POCOs describing what happened (no logic)\nCommands are POCOs describing intent (no logic)\nHandlers can emit follow-up commands for sagas and workflows\nCommandContext provides authorization boundary - events created after validation\nProjections cannot emit events - they're read-side only\nNext Steps\nCommand Validation - Advanced validation patterns\nSagas and Process Managers - Workflow orchestration\nAggregates - Domain-driven design with aggregates\nProjection Purity - Maintaining pure projections",
        "startIndex": 4402,
        "preview": "product = await _products GetAsync(item ProductId, ct); total += product Price * item Quantity; } // ✅ Apply business rules var discount = customer Is..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/contributors/coding-standards",
    "title": "Coding Standards",
    "category": "Contributors",
    "url": "/docs/old-v1.0.0/contributors/coding-standards",
    "chunks": [
      {
        "id": "old-v1.0.0/contributors/coding-standards-chunk-0",
        "text": "Coding Standards\nWhizbang follows strict coding standards to ensure consistency, maintainability, and AOT compatibility EditorConfig\nAll code MUST follow the editorconfig rules in the repository Documentation examples follow CODE_SAMPLES editorconfig CVersion\nMinimum: C12\nTarget: Latest stable Cversion\nUse modern language features (pattern matching, records, file-scoped namespaces, etc )\nBrace Style\nUse K&R/Egyptian braces (opening brace on same line):\n`csharp{\ntitle: \"K&R/Egyptian Brace Style\"\ndescription: \"Correct vs incorrect brace placement\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Code Style\", \"Braces\"]\nnugetPackages: []\nusingStatements: []\nshowLineNumbers: false\n}\n// ✅ CORRECT - K&R/Egyptian style\npublic class Order {\n    public void Ship() {\n        if (Status == OrderStatus Placed) {\n            Status = OrderStatus Shipped;\n        }\n    }\n}\n// ❌ WRONG - Allman style\npublic class Order\n{\n    public void Ship()\n    {\n        if (Status == OrderStatus Placed)\n        {\n            Status = OrderStatus",
        "startIndex": 0,
        "preview": "Coding Standards\nWhizbang follows strict coding standards to ensure consistency, maintainability, and AOT compatibility EditorConfig\nAll code MUST fol..."
      },
      {
        "id": "old-v1.0.0/contributors/coding-standards-chunk-1",
        "text": "// ✅ CORRECT - K&R/Egyptian style public class Order { public void Ship() { if (Status == OrderStatus Placed) { Status = OrderStatus Shipped; } } } // ❌ WRONG - Allman style public class Order { public void Ship() { if (Status == OrderStatus Placed) { Status = OrderStatus Shipped;\n        }\n    }\n}\n`\nNaming Conventions\nTypes\nPascalCase for classes, interfaces, records, enums, structs:\n`csharp{\ntitle: \"Type Naming Conventions\"\ndescription: \"PascalCase for types with I-prefix for interfaces\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Naming\", \"Types\"]\nnugetPackages: []\nusingStatements: [\"System\"]\nshowLineNumbers: false\n}\npublic class OrderProcessor { }\npublic interface IOrderRepository { }\npublic record OrderPlaced(Guid OrderId);\npublic enum OrderStatus { Placed, Shipped }\n`\nI-prefix for interfaces:\n`csharp{\ntitle: \"Interface Naming\"\ndescription: \"I-prefix for all interfaces\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Naming\", \"Interfaces\"]\nnugetPackages: []\nusingStatements: []\nshowLineNumbers: false\n}\npublic interface IEventStore { }\npublic interface IProjection { }\n`\nMethods and Properties\nPascalCase:\n`csharp{\ntitle: \"Method and Property Naming\"\ndescription: \"PascalCase for public methods and properties\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Naming\", \"Methods\", \"Properties\"]\nnugetPackages: []\nusingStatements: [\"System\"]\nshowLineNumbers: false\n}\npublic class Order {\n    public Guid Id { get; private set; }\n    public decimal Total { get; private set; }\n    public void Ship(string trackingNumber) {\n        // }\n}\n`\nAsync suffix for async methods:\n`csharp{\ntitle: \"Async Method Naming\"\ndescription: \"Async suffix for asynchronous methods\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Naming\", \"Async\", \"Methods\"]\nnugetPackages: []\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: false\n}\npublic async Task<Order> GetOrderAsync(Guid orderId) {\n    // }\npublic async Task SaveAsync(Order order) {\n    //",
        "startIndex": 1061,
        "preview": "// ✅ CORRECT - K&R/Egyptian style public class Order { public void Ship() { if (Status == OrderStatus Placed) { Status = OrderStatus Shipped; } } } //..."
      },
      {
        "id": "old-v1.0.0/contributors/coding-standards-chunk-2",
        "text": "suffix for async methods: `csharp{ title: \"Async Method Naming\" description: \"Async suffix for asynchronous methods\" framework: \"NET8\" category: \"Contributors\" difficulty: \"BEGINNER\" tags: [\"Naming\", \"Async\", \"Methods\"] nugetPackages: [] usingStatements: [\"System\", \"System Threading Tasks\"] showLineNumbers: false } public async Task<Order> GetOrderAsync(Guid orderId) { // } public async Task SaveAsync(Order order) { // }\n`\nParameters and Local Variables\ncamelCase:\n`csharp{\ntitle: \"Parameter and Variable Naming\"\ndescription: \"camelCase for parameters and local variables\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Naming\", \"Variables\", \"Parameters\"]\nnugetPackages: []\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq\"]\nshowLineNumbers: false\n}\npublic void ProcessOrder(Guid orderId, List<OrderItem> items) {\n    var total = items Sum(i => i Price * i Quantity);\n    var customerId = GetCustomerId(orderId);\n}\n`\nFields\n_camelCase (underscore prefix) for private fields:\n`csharp{\ntitle: \"Field Naming\"\ndescription: \"_camelCase with underscore prefix for private fields\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Naming\", \"Fields\"]\nnugetPackages: []\nusingStatements: [\"Microsoft Extensions Logging\"]\nshowLineNumbers: false\n}\npublic class OrderProcessor {\n    private readonly IOrderRepository _repository;\n    private readonly ILogger _logger;\n    public OrderProcessor(IOrderRepository repository, ILogger logger) {\n        _repository = repository;\n        _logger = logger;\n    }\n}\n`\nConstants\nALL_CAPS with underscores:\n`csharp{\ntitle: \"Constant Naming\"\ndescription: \"ALL_CAPS with underscores for constants\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Naming\", \"Constants\"]\nnugetPackages: []\nusingStatements: []\nshowLineNumbers: false\n}\npublic class EventStoreConstants {\n    public const string DEFAULT_STREAM_PREFIX = \"whizbang-\";\n    public const int MAX_BATCH_SIZE = 1000;\n}\n`\nvar Keyword\nAlways use var for local variables when the type is obvious:\n`csharp{\ntitle: \"var Keyword Usage\"\ndescription: \"Always use var when type is obvious\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"var\", \"Code Style\"]\nnugetPackages: [\"Microsoft Extensions DependencyInjection\"]\nusingStatements: [\"System Linq\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT\nvar order = new Order(customerId, items);\nvar total = items Sum(i => i Price);\nvar repository = serviceProvider",
        "startIndex": 2878,
        "preview": "suffix for async methods: `csharp{ title: \"Async Method Naming\" description: \"Async suffix for asynchronous methods\" framework: \"NET8\" category: \"Cont..."
      },
      {
        "id": "old-v1.0.0/contributors/coding-standards-chunk-3",
        "text": "use var when type is obvious\" framework: \"NET8\" category: \"Contributors\" difficulty: \"BEGINNER\" tags: [\"var\", \"Code Style\"] nugetPackages: [\"Microsoft Extensions DependencyInjection\"] usingStatements: [\"System Linq\", \"Microsoft Extensions DependencyInjection\"] showLineNumbers: false } // ✅ CORRECT var order = new Order(customerId, items); var total = items Sum(i => i Price); var repository = serviceProvider GetRequiredService<IOrderRepository>();\n// ❌ WRONG\nOrder order = new Order(customerId, items);\ndecimal total = items Sum(i => i Price);\nIOrderRepository repository = serviceProvider GetRequiredService<IOrderRepository>();\n`\nException: Use explicit type when it aids clarity:\n`csharp{\ntitle: \"Explicit Type When Helpful\"\ndescription: \"Use explicit type when it aids clarity\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"var\", \"Code Style\"]\nnugetPackages: []\nusingStatements: [\"System Collections Generic\", \"System Linq\"]\nshowLineNumbers: false\n}\n// OK - explicit type makes intent clear\nIEnumerable<Order> activeOrders = GetOrders() Where(o => o IsActive);\n`\nFile-Scoped Namespaces\nAlways use file-scoped namespaces (C10+):\n`csharp{\ntitle: \"File-Scoped Namespaces\"\ndescription: \"Always use file-scoped namespaces (C10+)\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Namespaces\", \"Code Style\"]\nnugetPackages: [\"Whizbang\"]\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT\nusing System;\nusing Whizbang;\nnamespace MyApp Orders;\npublic class Order {\n    // }\n// ❌ WRONG\nusing System;\nusing Whizbang;\nnamespace MyApp Orders {\n    public class Order {\n        // }\n}\n`\nUsing Directives\nPlace outside namespace, System directives first:\n`csharp{\ntitle: \"Using Directives Placement\"\ndescription: \"Place outside namespace, System directives first\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Using\", \"Code Style\"]\nnugetPackages: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"System Threading Tasks\", \"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nnamespace MyApp Orders;\npublic class OrderService {\n    // }\n// ❌ WRONG - using inside namespace\nnamespace MyApp",
        "startIndex": 5000,
        "preview": "use var when type is obvious\" framework: \"NET8\" category: \"Contributors\" difficulty: \"BEGINNER\" tags: [\"var\", \"Code Style\"] nugetPackages: [\"Microsoft..."
      },
      {
        "id": "old-v1.0.0/contributors/coding-standards-chunk-4",
        "text": "\"System Collections Generic\", \"System Threading Tasks\", \"Microsoft Extensions DependencyInjection\", \"Whizbang\"] showLineNumbers: false } // ✅ CORRECT using System; using System Collections Generic; using System Threading Tasks; using Microsoft Extensions DependencyInjection; using Whizbang; namespace MyApp Orders; public class OrderService { // } // ❌ WRONG - using inside namespace namespace MyApp Orders {\n    using System;\n    using Whizbang;\n    public class OrderService {\n        // }\n}\n`\nRecords for DTOs and Events\nUse records for immutable data:\n`csharp{\ntitle: \"Records for DTOs and Events\"\ndescription: \"Use records for immutable data\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Records\", \"Immutability\", \"Events\"]\nnugetPackages: []\nusingStatements: [\"System\", \"System Collections Generic\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT - Events as records\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt);\npublic record PlaceOrder(Guid CustomerId, List<OrderItem> Items);\n// ❌ WRONG - Events as classes with setters\npublic class OrderPlaced {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    public DateTimeOffset PlacedAt { get; set; }\n}\n`\nNullable Reference Types\nEnable nullable reference types in all projects:\n`xml\n<PropertyGroup>\n    <Nullable>enable</Nullable>\n</PropertyGroup>\n`\nAnnotate nullability explicitly:\n`csharp{\ntitle: \"Nullable Reference Types\"\ndescription: \"Annotate nullability explicitly\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Nullable\", \"Type Safety\"]\nnugetPackages: []\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: false\n}\npublic class OrderRepository {\n    // Non-nullable - must never be null\n    private readonly IEventStore _eventStore;\n    // Nullable - can be null\n    private Order _cachedOrder;\n    public async Task<Order > FindAsync(Guid orderId) {\n        // Returns null if not found\n        return await _eventStore LoadAsync<Order>(orderId);\n    }\n    public async Task<Order> GetAsync(Guid orderId) {\n        // Throws if not found (non-nullable return)\n        var order = await FindAsync(orderId);\n        return order",
        "startIndex": 7041,
        "preview": "\"System Collections Generic\", \"System Threading Tasks\", \"Microsoft Extensions DependencyInjection\", \"Whizbang\"] showLineNumbers: false } // ✅ CORRECT ..."
      },
      {
        "id": "old-v1.0.0/contributors/coding-standards-chunk-5",
        "text": "readonly IEventStore _eventStore; // Nullable - can be null private Order _cachedOrder; public async Task<Order > FindAsync(Guid orderId) { // Returns null if not found return await _eventStore LoadAsync<Order>(orderId); } public async Task<Order> GetAsync(Guid orderId) { // Throws if not found (non-nullable return) var order = await FindAsync(orderId); return order throw new OrderNotFoundException(orderId);\n    }\n}\n`\nException Handling\nThrow Specific Exceptions\n`csharp{\ntitle: \"Specific Exception Types\"\ndescription: \"Throw specific exceptions, not generic Exception\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Exceptions\", \"Error Handling\"]\nnugetPackages: []\nusingStatements: [\"System\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT\nthrow new OrderNotFoundException(orderId);\nthrow new InvalidOperationException(\"Cannot ship a cancelled order\");\n// ❌ WRONG\nthrow new Exception(\"Order not found\");\n`\nDon't Swallow Exceptions\n`csharp{\ntitle: \"Proper Exception Handling\"\ndescription: \"Don't swallow exceptions, re-throw when needed\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Exceptions\", \"Error Handling\", \"Logging\"]\nnugetPackages: [\"Microsoft Extensions Logging\"]\nusingStatements: [\"System Threading Tasks\", \"Microsoft Extensions Logging\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT\ntry {\n    await processor ProcessAsync(order);\n} catch (InvalidOrderException ex) {\n    _logger LogError(ex, \"Order validation failed: {OrderId}\", order Id);\n    throw;  // Re-throw to propagate\n}\n// ❌ WRONG\ntry {\n    await processor ProcessAsync(order);\n} catch {\n    // Silent failure - very bad }\n`\nUse Specific Catches\n`csharp{\ntitle: \"Specific Exception Catches\"\ndescription: \"Catch specific exceptions, not everything\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Exceptions\", \"Error Handling\"]\nnugetPackages: [\"Microsoft EntityFrameworkCore\", \"Microsoft Extensions Logging\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Microsoft EntityFrameworkCore\", \"System Data Common\", \"Microsoft Extensions Logging\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT\ntry {\n    await SaveAsync(order);\n} catch (DbUpdateConcurrencyException ex) {\n    throw new OptimisticConcurrencyException(\"Order was modified\", ex);\n} catch (DbException ex) {\n    _logger LogError(ex, \"Database error saving order\");\n    throw;\n}\n// ❌ WRONG - catching everything\ntry {\n    await SaveAsync(order);\n} catch (Exception ex) {\n    _logger",
        "startIndex": 8884,
        "preview": "readonly IEventStore _eventStore; // Nullable - can be null private Order _cachedOrder; public async Task<Order > FindAsync(Guid orderId) { // Returns..."
      },
      {
        "id": "old-v1.0.0/contributors/coding-standards-chunk-6",
        "text": "showLineNumbers: false } // ✅ CORRECT try { await SaveAsync(order); } catch (DbUpdateConcurrencyException ex) { throw new OptimisticConcurrencyException(\"Order was modified\", ex); } catch (DbException ex) { _logger LogError(ex, \"Database error saving order\"); throw; } // ❌ WRONG - catching everything try { await SaveAsync(order); } catch (Exception ex) { _logger LogError(ex, \"Error\");\n    throw;\n}\n`\nAsync/Await\nAlways Async All the Way\n`csharp{\ntitle: \"Async All the Way\"\ndescription: \"Always use async all the way through the call stack\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Async\", \"Threading\"]\nnugetPackages: []\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT\npublic async Task<Order> GetOrderAsync(Guid orderId) {\n    var events = await _eventStore LoadStreamAsync($\"Order-{orderId}\");\n    return await ReconstructAsync(events);\n}\n// ❌ WRONG - mixing sync and async\npublic Order GetOrder(Guid orderId) {\n    var events = _eventStore LoadStreamAsync($\"Order-{orderId}\") Result;  // Deadlock risk return ReconstructAsync(events) Result;\n}\n`\nUse ConfigureAwait(false) in Libraries\n`csharp{\ntitle: \"ConfigureAwait in Libraries\"\ndescription: \"Use ConfigureAwait(false) in library code\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Async\", \"ConfigureAwait\", \"Libraries\"]\nnugetPackages: []\nusingStatements: [\"System Threading Tasks\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT - library code\npublic async Task SaveAsync(Order order) {\n    var events = order GetUncommittedEvents();\n    await _eventStore AppendAsync(streamId, events) ConfigureAwait(false);\n}\n// Application code can omit ConfigureAwait\n`\nAOT Compatibility\nNever use reflection that breaks AOT:\n`csharp{\ntitle: \"AOT-Safe Code\"\ndescription: \"Avoid reflection that breaks native AOT\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"ADVANCED\"\ntags: [\"AOT\", \"Reflection\", \"Source Generators\"]\nnugetPackages: []\nusingStatements: [\"System\"]\nshowLineNumbers: false\n}\n// ❌ WRONG - breaks AOT\nvar type = Type GetType(\"MyApp Orders Order\");\nvar instance = Activator",
        "startIndex": 11003,
        "preview": "showLineNumbers: false } // ✅ CORRECT try { await SaveAsync(order); } catch (DbUpdateConcurrencyException ex) { throw new OptimisticConcurrencyExcepti..."
      },
      {
        "id": "old-v1.0.0/contributors/coding-standards-chunk-7",
        "text": "reflection that breaks AOT: `csharp{ title: \"AOT-Safe Code\" description: \"Avoid reflection that breaks native AOT\" framework: \"NET8\" category: \"Contributors\" difficulty: \"ADVANCED\" tags: [\"AOT\", \"Reflection\", \"Source Generators\"] nugetPackages: [] usingStatements: [\"System\"] showLineNumbers: false } // ❌ WRONG - breaks AOT var type = Type GetType(\"MyApp Orders Order\"); var instance = Activator CreateInstance(type);\n// ✅ CORRECT - use source generators\n[GenerateHandlers]  // Source generator creates handler registry\npublic partial class HandlerRegistry { }\n`\nUse generic constraints instead of runtime type checks:\n`csharp{\ntitle: \"Generic Constraints vs Runtime Checks\"\ndescription: \"Use generic constraints instead of runtime type checks\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Generics\", \"Type Safety\", \"AOT\"]\nnugetPackages: []\nusingStatements: [\"System\"]\nshowLineNumbers: false\n}\n// ❌ WRONG\npublic void Process(object message) {\n    if (message GetType() == typeof(PlaceOrder)) {\n        // }\n}\n// ✅ CORRECT\npublic void Process<TMessage>(TMessage message) where TMessage : class {\n    // Compile-time type safety\n}\n`\nDependency Injection\nConstructor Injection\n`csharp{\ntitle: \"Constructor Injection\"\ndescription: \"Use constructor injection, not property injection\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Dependency Injection\", \"Constructor\"]\nnugetPackages: []\nusingStatements: []\nshowLineNumbers: false\n}\n// ✅ CORRECT\npublic class OrderService {\n    private readonly IOrderRepository _repository;\n    private readonly IEventPublisher _publisher;\n    public OrderService(IOrderRepository repository, IEventPublisher publisher) {\n        _repository = repository;\n        _publisher = publisher;\n    }\n}\n// ❌ WRONG - property injection\npublic class OrderService {\n    public IOrderRepository Repository { get; set; }\n}\n`\nRegister Services Explicitly\n`csharp{\ntitle: \"Explicit Service Registration\"\ndescription: \"Register services explicitly, avoid magic scanning\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Dependency Injection\", \"AOT\", \"Service Registration\"]\nnugetPackages: [\"Microsoft Extensions DependencyInjection\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT - explicit registration\nservices AddScoped<IOrderRepository, OrderRepository>();\nservices AddSingleton<IEventStore, PostgresEventStore>();\n// ❌ WRONG - magic scanning that breaks AOT\nservices Scan(scan => scan FromAssemblyOf<Order>() AddClasses()",
        "startIndex": 12787,
        "preview": "reflection that breaks AOT: `csharp{ title: \"AOT-Safe Code\" description: \"Avoid reflection that breaks native AOT\" framework: \"NET8\" category: \"Contri..."
      },
      {
        "id": "old-v1.0.0/contributors/coding-standards-chunk-8",
        "text": "framework: \"NET8\" category: \"Contributors\" difficulty: \"INTERMEDIATE\" tags: [\"Dependency Injection\", \"AOT\", \"Service Registration\"] nugetPackages: [\"Microsoft Extensions DependencyInjection\"] usingStatements: [\"Microsoft Extensions DependencyInjection\"] showLineNumbers: false } // ✅ CORRECT - explicit registration services AddScoped<IOrderRepository, OrderRepository>(); services AddSingleton<IEventStore, PostgresEventStore>(); // ❌ WRONG - magic scanning that breaks AOT services Scan(scan => scan FromAssemblyOf<Order>() AddClasses() AsImplementedInterfaces());\n`\nPerformance\nUse ValueTask for Hot Paths\n`csharp{\ntitle: \"ValueTask for Hot Paths\"\ndescription: \"Use ValueTask for high-frequency methods\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"ADVANCED\"\ntags: [\"Performance\", \"ValueTask\", \"Hot Path\"]\nnugetPackages: []\nusingStatements: [\"System Threading Tasks\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT - high-frequency method\npublic ValueTask<bool> TryGetFromCacheAsync(string key) {\n    if (_cache TryGetValue(key, out var value)) {\n        return new ValueTask<bool>(true);  // Synchronous completion\n    }\n    return LoadFromDatabaseAsync(key);  // Async completion\n}\n`\nAvoid Allocations in Hot Paths\n`csharp{\ntitle: \"Avoid Allocations in Hot Paths\"\ndescription: \"Use Span/Memory to avoid allocations\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"ADVANCED\"\ntags: [\"Performance\", \"Memory\", \"Span\", \"Hot Path\"]\nnugetPackages: []\nusingStatements: [\"System\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT - reuse span/memory\npublic void ProcessEvents(ReadOnlySpan<Event> events) {\n    foreach (var @event in events) {\n        // Process without allocation\n    }\n}\n// ❌ WRONG - allocates array\npublic void ProcessEvents(Event[] events) {\n    // }\n`\nTesting Conventions\nTest Method Naming\nFormat: MethodName_Scenario_ExpectedBehavior\n`csharp{\ntitle: \"Test Method Naming Convention\"\ndescription: \"MethodName_Scenario_ExpectedBehavior format\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Testing\", \"Naming\", \"xUnit\"]\nnugetPackages: [\"xunit\", \"FluentAssertions\"]\nusingStatements: [\"Xunit\", \"FluentAssertions\", \"System\"]\nshowLineNumbers: false\n}\n[Fact]\npublic void Ship_WhenOrderIsPlaced_UpdatesStatusToShipped() {\n    // Arrange\n    var order = new Order(customerId, items);\n    // Act\n    order Ship(trackingNumber);\n    // Assert\n    order Status Should() Be(OrderStatus Shipped);\n}\n[Fact]\npublic void Ship_WhenOrderIsCancelled_ThrowsInvalidOperationException() {\n    // Arrange\n    var order = new Order(customerId, items);\n    order Cancel(\"Customer requested\");\n    // Act & Assert\n    var act = () => order Ship(trackingNumber);\n    act Should()",
        "startIndex": 14982,
        "preview": "framework: \"NET8\" category: \"Contributors\" difficulty: \"INTERMEDIATE\" tags: [\"Dependency Injection\", \"AOT\", \"Service Registration\"] nugetPackages: [\"M..."
      },
      {
        "id": "old-v1.0.0/contributors/coding-standards-chunk-9",
        "text": "{ // Arrange var order = new Order(customerId, items); // Act order Ship(trackingNumber); // Assert order Status Should() Be(OrderStatus Shipped); } [Fact] public void Ship_WhenOrderIsCancelled_ThrowsInvalidOperationException() { // Arrange var order = new Order(customerId, items); order Cancel(\"Customer requested\"); // Act & Assert var act = () => order Ship(trackingNumber); act Should() Throw<InvalidOperationException>();\n}\n`\nUse FluentAssertions\n`csharp{\ntitle: \"FluentAssertions vs xUnit Asserts\"\ndescription: \"Use FluentAssertions for better readability\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Testing\", \"FluentAssertions\", \"xUnit\"]\nnugetPackages: [\"FluentAssertions\", \"xunit\"]\nusingStatements: [\"FluentAssertions\", \"Xunit\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT - readable assertions\nresult Should() NotBeNull();\nresult OrderId Should() Be(expectedId);\nresult Items Should() HaveCount(2);\n// ❌ WRONG - xUnit asserts (less readable)\nAssert NotNull(result);\nAssert Equal(expectedId, result OrderId);\nAssert Equal(2, result Items Count);\n`\nComments\nExplain Why, Not What\n`csharp{\ntitle: \"Meaningful Comments\"\ndescription: \"Explain why, not what - focus on non-obvious decisions\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Comments\", \"Documentation\"]\nnugetPackages: []\nusingStatements: [\"System Threading Tasks\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT - explains non-obvious decision\n// Use pessimistic locking here because optimistic concurrency\n// causes too many retries under high contention\nawait _connection ExecuteAsync(\"SELECT FOR UPDATE\");\n// ❌ WRONG - states the obvious\n// Get the order\nvar order = await GetOrderAsync(orderId);\n`\nXML Documentation for Public APIs\n`csharp{\ntitle: \"XML Documentation for Public APIs\"\ndescription: \"Document all public APIs with XML comments\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Documentation\", \"XML Comments\", \"API\"]\nnugetPackages: []\nusingStatements: [\"System Collections Generic\", \"System Threading Tasks\"]\nshowLineNumbers: false\n}\n/// <summary>\n/// Appends events to an aggregate stream with optimistic concurrency /// </summary>\n/// <param name=\"streamId\">The unique identifier for the event stream </param>\n/// <param name=\"events\">The events to append </param>\n/// <param name=\"expectedVersion\">\n/// The expected current version of the stream",
        "startIndex": 17143,
        "preview": "{ // Arrange var order = new Order(customerId, items); // Act order Ship(trackingNumber); // Assert order Status Should() Be(OrderStatus Shipped); } [..."
      },
      {
        "id": "old-v1.0.0/contributors/coding-standards-chunk-10",
        "text": "Collections Generic\", \"System Threading Tasks\"] showLineNumbers: false } /// <summary> /// Appends events to an aggregate stream with optimistic concurrency /// </summary> /// <param name=\"streamId\">The unique identifier for the event stream </param> /// <param name=\"events\">The events to append </param> /// <param name=\"expectedVersion\"> /// The expected current version of the stream If the actual version\n/// does not match, throws <see cref=\"ConcurrencyException\"/> /// </param>\n/// <exception cref=\"ConcurrencyException\">\n/// Thrown when the stream has been modified since it was loaded /// </exception>\npublic async Task AppendAsync(string streamId, IEnumerable<object> events, long expectedVersion) {\n    // }\n`\nAnalyzer Configuration\nWhizbang uses Roslyn analyzers to enforce standards Key rules:\nWBZ001: Command/event must have [OwnedBy] attribute\nWBZ002: Handler marked [Pure] must not have side effects\nWBZ003: Async method must have Async suffix\nWBZ004: Event must be immutable (record or readonly properties)\nSuppress warnings only when absolutely necessary:\n`csharp{\ntitle: \"Analyzer Warning Suppression\"\ndescription: \"Suppress warnings only when absolutely necessary with justification\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Analyzers\", \"Warnings\", \"Code Quality\"]\nnugetPackages: []\nusingStatements: []\nshowLineNumbers: false\n}\n#pragma warning disable WBZ001 // Justification: Internal command, ownership not needed\npublic record InternalCleanupCommand();\n#pragma warning restore WBZ001\n`\nSummary Checklist\nBefore submitting code, verify:\n[ ] K&R/Egyptian braces used\n[ ] var used for local variables\n[ ] File-scoped namespaces\n[ ] Nullable reference types enabled and annotated\n[ ] Async methods have Async suffix\n[ ] No reflection that breaks AOT\n[ ] All public APIs have XML documentation\n[ ] Tests follow naming convention\n[ ] Code passes all analyzer rules\nQuestions If you're unsure about any convention, ask in GitHub Discussions",
        "startIndex": 19163,
        "preview": "Collections Generic\", \"System Threading Tasks\"] showLineNumbers: false } /// <summary> /// Appends events to an aggregate stream with optimistic concu..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/contributors/contributing",
    "title": "Contributing to Whizbang",
    "category": "Contributors",
    "url": "/docs/old-v1.0.0/contributors/contributing",
    "chunks": [
      {
        "id": "old-v1.0.0/contributors/contributing-chunk-0",
        "text": "Contributing to Whizbang\nThank you for your interest in contributing to Whizbang This guide will help you get started Code of Conduct\nWe are committed to providing a welcoming and inclusive environment Please read and follow our Code of Conduct Ways to Contribute\n🐛 Report Bugs\nFound a bug Open an issue with:\nClear description of the problem\nSteps to reproduce\nExpected vs actual behavior\nWhizbang version and NET version\nRelevant code samples\n💡 Suggest Features\nHave an idea Start a discussion to:\nDescribe the use case\nExplain why existing features don't solve it\nPropose an API design\nDiscuss tradeoffs and alternatives\n📝 Improve Documentation\nDocumentation improvements are always welcome:\nFix typos or unclear explanations\nAdd missing examples\nImprove code samples\nTranslate to other languages\nDocumentation lives in this repository at src/assets/docs/ 🔨 Submit Code\nReady to code Great Please:\nDiscuss first - For non-trivial changes, open an issue or discussion first\nFollow conventions - See Coding Standards\nWrite tests - All new features need tests\nUpdate docs - Documentation is part of the PR, not an afterthought\nKeep it focused - One feature/fix per PR\nDevelopment Setup\nPrerequisites NET 8 0 SDK or later\nDocker (for running test databases)\nGit\nYour favorite IDE (Visual Studio, Rider, VS Code)\nClone the Repository\n`bash{\ntitle: \"Clone Repository\"\ndescription: \"Clone the Whizbang repository locally\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Git\", \"Setup\"]\n}\ngit clone https://github com/whizbang-lib/whizbang",
        "startIndex": 0,
        "preview": "Contributing to Whizbang\nThank you for your interest in contributing to Whizbang This guide will help you get started Code of Conduct\nWe are committed..."
      },
      {
        "id": "old-v1.0.0/contributors/contributing-chunk-1",
        "text": "per PR Development Setup Prerequisites NET 8 0 SDK or later Docker (for running test databases) Git Your favorite IDE (Visual Studio, Rider, VS Code) Clone the Repository `bash{ title: \"Clone Repository\" description: \"Clone the Whizbang repository locally\" category: \"Contributors\" difficulty: \"BEGINNER\" tags: [\"Git\", \"Setup\"] } git clone https://github com/whizbang-lib/whizbang git\ncd whizbang\n`\nBuild the Solution\n`bash{\ntitle: \"Build Solution\"\ndescription: \"Build the entire Whizbang solution\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Build\", \"Setup\"]\n}\ndotnet build\n`\nRun Tests\n`bash{\ntitle: \"Run Tests\"\ndescription: \"Run unit and integration tests with optional coverage\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Testing\", \"Coverage\"]\n}\nRun all tests\ndotnet test\nRun with coverage\ndotnet test /p:CollectCoverage=true\n`\nStart Local Infrastructure\nFor integration tests, you'll need Postgres and Kafka:\n`bash{\ntitle: \"Start Infrastructure\"\ndescription: \"Start Postgres and Kafka for integration tests\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Docker\", \"Infrastructure\", \"Testing\"]\n}\ndocker-compose up -d\n`\nThis starts:\nPostgres on localhost:5432\nKafka on localhost:9092\nZookeeper on localhost:2181\nProject Structure\n`\nwhizbang/\n├── src/\n│   ├── Whizbang Core/              Core mediator and messaging\n│   ├── Whizbang EventSourcing/     Event store and aggregates\n│   ├── Whizbang Projections/       Projection engine\n│   ├── Whizbang Messaging/         Distributed messaging\n│   ├── Whizbang Postgres/          Postgres driver\n│   ├── Whizbang Kafka/             Kafka driver\n│   ├── Whizbang OpenTelemetry/     Observability\n│   └── Whizbang Analyzers/         Roslyn analyzers\n├── tests/\n│   ├── Whizbang Core Tests/\n│   ├── Whizbang EventSourcing Tests/\n│   ├── Integration",
        "startIndex": 1557,
        "preview": "per PR Development Setup Prerequisites NET 8 0 SDK or later Docker (for running test databases) Git Your favorite IDE (Visual Studio, Rider, VS Code) ..."
      },
      {
        "id": "old-v1.0.0/contributors/contributing-chunk-2",
        "text": "│ ├── Whizbang Projections/ Projection engine │ ├── Whizbang Messaging/ Distributed messaging │ ├── Whizbang Postgres/ Postgres driver │ ├── Whizbang Kafka/ Kafka driver │ ├── Whizbang OpenTelemetry/ Observability │ └── Whizbang Analyzers/ Roslyn analyzers ├── tests/ │ ├── Whizbang Core Tests/ │ ├── Whizbang EventSourcing Tests/ │ ├── Integration Tests/          Multi-package integration tests\n│   └── Documentation/              Tests for documentation examples\n├── samples/\n│   ├── SimpleMediator/             Basic mediator sample\n│   ├── EventSourcedMonolith/       Event sourcing sample\n│   └── Microservices/              Distributed messaging sample\n└── docs/\n    └── (Documentation website - separate repo)\n`\nBranching Strategy\nmain - Stable, released code\ndevelop - Active development\nfeature/xyz - New features (branch from develop)\nfix/xyz - Bug fixes (branch from develop or main for hotfixes)\nPull Request Process\nCreate a Branch\n`bash{\ntitle: \"Create Feature Branch\"\ndescription: \"Create a new feature branch from develop\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Git\", \"Branching\"]\n}\ngit checkout develop\ngit pull origin develop\ngit checkout -b feature/my-awesome-feature\n`\nMake Changes\nWrite code following Coding Standards\nAdd tests for new functionality\nUpdate documentation\nEnsure all tests pass\nCommit Changes\nWe use Conventional Commits:\n`bash{\ntitle: \"Conventional Commits\"\ndescription: \"Examples of conventional commit messages\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Git\", \"Commits\", \"Conventional Commits\"]\n}\ngit commit -m \"feat: add support for SQL Server driver\"\ngit commit -m \"fix: correct optimistic concurrency check\"\ngit commit -m \"docs: add examples for projections\"\n`\nCommit types:\nfeat: - New feature\nfix: - Bug fix\ndocs: - Documentation changes\ntest: - Adding or updating tests\nrefactor: - Code refactoring\nperf: - Performance improvements\nchore: - Build/tooling changes\nPush and Create PR\n`bash{\ntitle: \"Push Feature Branch\"\ndescription: \"Push feature branch to origin for PR creation\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Git\", \"Push\"]\n}\ngit push origin feature/my-awesome-feature\n`\nThen open a PR on GitHub targeting develop branch",
        "startIndex": 3004,
        "preview": "│ ├── Whizbang Projections/ Projection engine │ ├── Whizbang Messaging/ Distributed messaging │ ├── Whizbang Postgres/ Postgres driver │ ├── Whizbang ..."
      },
      {
        "id": "old-v1.0.0/contributors/contributing-chunk-3",
        "text": "Code refactoring perf: - Performance improvements chore: - Build/tooling changes Push and Create PR `bash{ title: \"Push Feature Branch\" description: \"Push feature branch to origin for PR creation\" category: \"Contributors\" difficulty: \"BEGINNER\" tags: [\"Git\", \"Push\"] } git push origin feature/my-awesome-feature ` Then open a PR on GitHub targeting develop branch PR Review\nMaintainers will review your PR Please:\nRespond to feedback promptly\nMake requested changes\nKeep the PR focused (split large PRs if needed)\nBe patient - we review PRs as quickly as we can\nMerge\nOnce approved, a maintainer will merge your PR Congrats 🎉\nTesting Guidelines\nUnit Tests\nTest individual classes in isolation\nUse mocks for dependencies\nFast execution (<100ms per test)\nLocated in * Tests projects\nExample:\n`csharp{\ntitle: \"Unit Test Example\"\ndescription: \"Example unit test for domain logic\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Testing\", \"Unit Tests\", \"xUnit\"]\nnugetPackages: [\"xunit\", \"FluentAssertions\"]\nusingStatements: [\"Xunit\", \"FluentAssertions\"]\nshowLineNumbers: false\n}\npublic class OrderTests {\n    [Fact]\n    public void PlaceOrder_WithValidItems_EmitsOrderPlacedEvent() {\n        // Arrange\n        var order = new Order(customerId, items);\n        // Act\n        var events = order GetUncommittedEvents();\n        // Assert\n        var placed = events Should() ContainSingle() Which Should() BeOfType<OrderPlaced>();\n        placed CustomerId Should() Be(customerId);\n    }\n}\n`\nIntegration Tests\nTest multiple components together\nUse real databases (Docker containers)\nSlower execution (can be seconds)\nLocated in Integration Tests project\nExample:\n`csharp{\ntitle: \"Integration Test Example\"\ndescription: \"Example integration test for event store\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Testing\", \"Integration Tests\", \"Event Store\"]\nnugetPackages: [\"xunit\", \"FluentAssertions\"]\nusingStatements: [\"System Threading Tasks\", \"Xunit\", \"FluentAssertions\"]\nshowLineNumbers: false\n}\npublic class EventStoreIntegrationTests : IClassFixture<PostgresFixture> {\n    [Fact]\n    public async Task AppendAndLoad_RoundTrip_PreservesEvents() {\n        // Arrange\n        var store = new PostgresEventStore(connectionString);\n        var events = new[] { new OrderPlaced( ), new OrderShipped( ) };\n        // Act\n        await store AppendAsync(\"Order-123\", events);\n        var loaded = await store LoadStreamAsync(\"Order-123\");\n        // Assert\n        loaded Should()",
        "startIndex": 4880,
        "preview": "Code refactoring perf: - Performance improvements chore: - Build/tooling changes Push and Create PR `bash{ title: \"Push Feature Branch\" description: \"..."
      },
      {
        "id": "old-v1.0.0/contributors/contributing-chunk-4",
        "text": "showLineNumbers: false } public class EventStoreIntegrationTests : IClassFixture<PostgresFixture> { [Fact] public async Task AppendAndLoad_RoundTrip_PreservesEvents() { // Arrange var store = new PostgresEventStore(connectionString); var events = new[] { new OrderPlaced( ), new OrderShipped( ) }; // Act await store AppendAsync(\"Order-123\", events); var loaded = await store LoadStreamAsync(\"Order-123\"); // Assert loaded Should() BeEquivalentTo(events);\n    }\n}\n`\nDocumentation Tests\nCRITICAL: All complete code examples in documentation MUST have corresponding tests Located in tests/Documentation/, these tests:\nExtract code from documentation\nVerify examples compile\nValidate examples actually work\nPrevent documentation from becoming stale\nSee Test-Driven Examples for details Documentation Standards\nAll Code Examples Must:\nInclude complete using statements\nFollow CODE_SAMPLES editorconfig (K&R/Egyptian braces)\nUse Cnaming conventions (PascalCase, camelCase, etc )\nBe compilable - No pseudo-code or placeholders\nInclude metadata for enhanced code blocks\nExample Format\nmarkdown\n`csharp{\ntitle: \"Order Command Handler\"\ndescription: \"Processes order placement commands\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"Handlers\", \"Orders\"]\nnugetPackages: [\"Whizbang Core\"]\ntestFile: \"OrderHandlerTests cs\"\ntestMethod: \"HandlePlaceOrder_ValidOrder_ReturnsSuccess\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\npublic class PlaceOrderHandler {\n    public async Task<OrderPlacedResult> Handle(PlaceOrder command) {\n        // Implementation\n    }\n}\n`\nSee DOCUMENTATION-STANDARDS md for complete guidelines Coding Standards\nSee Coding Standards for detailed Cconventions",
        "startIndex": 7056,
        "preview": "showLineNumbers: false } public class EventStoreIntegrationTests : IClassFixture<PostgresFixture> { [Fact] public async Task AppendAndLoad_RoundTrip_P..."
      },
      {
        "id": "old-v1.0.0/contributors/contributing-chunk-5",
        "text": "\"OrderHandlerTests cs\" testMethod: \"HandlePlaceOrder_ValidOrder_ReturnsSuccess\" usingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"] showLineNumbers: true } using System; using System Threading Tasks; using Whizbang; public class PlaceOrderHandler { public async Task<OrderPlacedResult> Handle(PlaceOrder command) { // Implementation } } ` See DOCUMENTATION-STANDARDS md for complete guidelines Coding Standards See Coding Standards for detailed Cconventions Key Points:\nBrace Style: K&R/Egyptian (opening brace on same line)\nvar: Always use var for local variables\nNaming: PascalCase for public, camelCase for private, _camelCase for fields\nAsync: Suffix async methods with Async\nNullability: Enable nullable reference types\nAOT-Safe: No reflection tricks that break native AOT\nDesign Philosophy\nWhen contributing, keep these principles in mind:\nEvents are the source of truth - Always\nSimple things should be simple - Don't overcomplicate the basic mediator scenario\nComplex things should be possible - But with clear opt-in\nAOT-first - All features must work with native AOT\nDriver-based - Never lock users into a specific technology\nObservable by default - Telemetry is built-in, not bolted-on\nIdempotent - Message handlers should be safe to retry\nGetting Help\nQuestions Ask in GitHub Discussions\nStuck Ping us on Discord (coming soon)\nFound a bug Open an issue\nRecognition\nContributors are recognized in:\nRelease notes for the version their PR shipped in\nCONTRIBUTORS md file\nOur gratitude and appreciation 🙏\nThank you for making Whizbang better",
        "startIndex": 8447,
        "preview": "\"OrderHandlerTests cs\" testMethod: \"HandlePlaceOrder_ValidOrder_ReturnsSuccess\" usingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"] show..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/core-concepts/aggregates",
    "title": "Aggregates",
    "category": "Core Concepts",
    "url": "/docs/old-v1.0.0/core-concepts/aggregates",
    "chunks": [
      {
        "id": "old-v1.0.0/core-concepts/aggregates-chunk-0",
        "text": "Aggregates\nAggregates are the fundamental building blocks of Whizbang's event-sourced architecture They serve as consistency boundaries that encapsulate business logic and ensure data integrity What are Aggregates An aggregate is a cluster of domain objects that can be treated as a single unit for data changes In Whizbang:\nConsistency Boundary: All changes within an aggregate are atomic\nEvent Source: Aggregates generate events when their state changes\nBusiness Logic Container: They encapsulate domain rules and invariants\nIdentity: Each aggregate has a unique identifier\nKey Characteristics\nEvent-Sourced State\nAggregates don't store current state directly Instead, they:\nStore a sequence of events that represent state changes\nRebuild current state by replaying events from the event store\nAppend new events when commands are processed\nCommand Processing\nAggregates receive commands and:\nValidate the command against current state\nApply business rules and invariants\nGenerate domain events if the command is valid\nThrow exceptions if the command violates business rules\nOptimistic Concurrency\nWhizbang aggregates use optimistic concurrency control:\nEach aggregate has a version number\nConcurrent modifications are detected and handled\nPrevents lost update problems in distributed scenarios\nExample Structure\n`csharp{\ntitle: \"Order Aggregate Example\"\ndescription: \"Complete aggregate structure showing event sourcing, command handling, and state management\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aggregates\", \"Event Sourcing\", \"DDD\", \"Order Management\"]\nfilename: \"OrderAggregate cs\"\nnugetPackages: [\"Whizbang EventSourcing\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class OrderAggregate : Aggregate {\n    public Guid Id { get; private set; }\n    public OrderStatus Status { get; private set; }\n    public List<OrderItem> Items { get; private set; } = new();\n    // Constructor for new aggregates\n    public OrderAggregate(PlaceOrderCommand command) {\n        // Validate and apply business rules\n        Apply(new OrderPlacedEvent(command OrderId, command Items));\n    }\n    // Event handler (rebuilds state)\n    private void When(OrderPlacedEvent @event) {\n        Id = @event OrderId;\n        Status = OrderStatus",
        "startIndex": 0,
        "preview": "Aggregates\nAggregates are the fundamental building blocks of Whizbang's event-sourced architecture They serve as consistency boundaries that encapsula..."
      },
      {
        "id": "old-v1.0.0/core-concepts/aggregates-chunk-1",
        "text": "set; } public List<OrderItem> Items { get; private set; } = new(); // Constructor for new aggregates public OrderAggregate(PlaceOrderCommand command) { // Validate and apply business rules Apply(new OrderPlacedEvent(command OrderId, command Items)); } // Event handler (rebuilds state) private void When(OrderPlacedEvent @event) { Id = @event OrderId; Status = OrderStatus Placed;\n        Items = @event Items;\n    }\n    // Command method\n    public void Ship(ShipOrderCommand command) {\n        if (Status = OrderStatus Placed) {\n            throw new InvalidOperationException(\"Order must be placed to ship\");\n        }\n        Apply(new OrderShippedEvent(Id, command TrackingNumber));\n    }\n}\n`\nBest Practices\nKeep Aggregates Small\nFocus on a single business concept\nAvoid large, complex aggregates\nConsider splitting if aggregate becomes unwieldy\nDesign Around Invariants\nIdentify what must remain consistent\nEncapsulate related data that changes together\nUse domain events to communicate between aggregates\nAvoid Cross-Aggregate Transactions\nOne aggregate per transaction\nUse eventual consistency between aggregates\nCommunicate via domain events and sagas\nIntegration with Whizbang\nWhizbang provides:\nRepository pattern for loading and saving aggregates\nAutomatic event publishing when aggregates are saved\nOptimistic concurrency handling out of the box\nMultiple storage backends (Postgres, SQL Server, etc )\nRelated Topics\nCore Concepts - Overview of Whizbang's architectural patterns\nRepositories and CQRS Helpers - Working with aggregate repositories\nCommand Handling - Processing commands in aggregates\nGetting Started - Hands-on tutorial building aggregates\nNext Steps\nThis page provides an overview of aggregates in Whizbang For detailed implementation examples and advanced patterns, see the comprehensive documentation linked above",
        "startIndex": 2328,
        "preview": "set; } public List<OrderItem> Items { get; private set; } = new(); // Constructor for new aggregates public OrderAggregate(PlaceOrderCommand command) ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/core-concepts/core-concepts",
    "title": "Core Concepts",
    "category": "Core Concepts",
    "url": "/docs/old-v1.0.0/core-concepts/core-concepts",
    "chunks": [
      {
        "id": "old-v1.0.0/core-concepts/core-concepts-chunk-0",
        "text": "Core Concepts\nWhizbang is built on four foundational concepts: Events, Commands, Aggregates, and Projections Understanding these primitives is essential to using Whizbang effectively Events\nEvents are immutable facts that have happened in your system They represent state changes and are the source of truth in event-sourced architectures Characteristics\nPast tense naming - OrderPlaced, PaymentProcessed, InventoryReserved\nImmutable - Once written, never modified\nAppend-only - New events are added to the stream, old events remain forever\nDomain-owned - Each event belongs to a specific domain/service\nExample\n`csharp{\ntitle: \"Order Domain Events\"\ndescription: \"Events representing state changes in the order lifecycle\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Events\", \"Domain Events\", \"Order Management\"]\nusingStatements: [\"System\"]\nshowLineNumbers: true\n}\nusing System;\nnamespace MyApp Orders Events;\n// Event: Order was placed by a customer\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset PlacedAt,\n    List<OrderItem> Items,\n    decimal Total\n);\n// Event: Order was shipped\npublic record OrderShipped(\n    Guid OrderId,\n    DateTimeOffset ShippedAt,\n    string TrackingNumber\n);\n// Event: Order was cancelled\npublic record OrderCancelled(\n    Guid OrderId,\n    DateTimeOffset CancelledAt,\n    string Reason\n);\n`\nEvent Streams\nEvents are stored in streams, one stream per aggregate instance:\n`text{\ntitle: \"Event Stream Structure\"\ndescription: \"Visual representation of how events are stored in streams with sequence numbers\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Events\", \"Streams\", \"Event Sourcing\"]\nfilename: \"event-stream-example",
        "startIndex": 0,
        "preview": "Core Concepts\nWhizbang is built on four foundational concepts: Events, Commands, Aggregates, and Projections Understanding these primitives is essenti..."
      },
      {
        "id": "old-v1.0.0/core-concepts/core-concepts-chunk-1",
        "text": "DateTimeOffset CancelledAt, string Reason ); ` Event Streams Events are stored in streams, one stream per aggregate instance: `text{ title: \"Event Stream Structure\" description: \"Visual representation of how events are stored in streams with sequence numbers\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"BEGINNER\" tags: [\"Events\", \"Streams\", \"Event Sourcing\"] filename: \"event-stream-example txt\"\nshowLineNumbers: false\n}\nStream: \"Order-{orderId}\"\n  [0] OrderPlaced\n  [1] OrderItemAdded\n  [2] OrderShipped\n  [3] OrderDelivered\n`\nEach event has a position (sequence number) in the stream, enabling:\nReplaying the stream to rebuild aggregate state\nOptimistic concurrency - Detect conflicting concurrent updates\nPoint-in-time queries - Get state as of a specific event\nDomain Ownership\nEvents are owned by the domain that publishes them:\n`csharp{\ntitle: \"Domain-Owned Events\"\ndescription: \"Marking events with their owning domain\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Events\", \"Domain Ownership\", \"Distributed Systems\"]\nusingStatements: [\"Whizbang\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nnamespace MyApp Orders Events;\n[OwnedBy(\"Orders\")]  // This event comes from the Orders domain\npublic record OrderPlaced(Guid OrderId, Guid CustomerId);\n[OwnedBy(\"Inventory\")]  // This event comes from the Inventory domain\npublic record InventoryReserved(Guid OrderId, List<Guid> ProductIds);\n`\nWhen other services subscribe to these events:\nThey're consuming a public API from the owning domain\nThe owning domain controls the event schema\nSubscribers can backfill from the entire event history\nCommands\nCommands are requests to change state They represent intent and are sent to the domain that owns the aggregate Characteristics\nImperative naming - PlaceOrder, ProcessPayment, ReserveInventory\nValidated - Can be rejected if invalid\nRouted - Sent to the owning domain's handlers\nSingle recipient - Unlike events, commands go to exactly one handler\nExample\n`csharp{\ntitle: \"Order Domain Commands\"\ndescription: \"Commands representing requests to change order state\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"CQRS\", \"Order Management\"]\nusingStatements: [\"System\"]\nshowLineNumbers: true\n}\nusing System;\nnamespace MyApp Orders",
        "startIndex": 1751,
        "preview": "DateTimeOffset CancelledAt, string Reason ); ` Event Streams Events are stored in streams, one stream per aggregate instance: `text{ title: \"Event Str..."
      },
      {
        "id": "old-v1.0.0/core-concepts/core-concepts-chunk-2",
        "text": "owning domain's handlers Single recipient - Unlike events, commands go to exactly one handler Example `csharp{ title: \"Order Domain Commands\" description: \"Commands representing requests to change order state\" framework: \"NET8\" category: \"Domain Logic\" difficulty: \"BEGINNER\" tags: [\"Commands\", \"CQRS\", \"Order Management\"] usingStatements: [\"System\"] showLineNumbers: true } using System; namespace MyApp Orders Commands;\n// Command: Request to place a new order\npublic record PlaceOrder(\n    Guid CustomerId,\n    List<OrderItem> Items\n);\n// Command: Request to cancel an order\npublic record CancelOrder(\n    Guid OrderId,\n    string Reason\n);\n// Command: Request to update shipping address\npublic record UpdateShippingAddress(\n    Guid OrderId,\n    Address NewAddress\n);\n`\nCommand Handlers\nHandlers receive commands, validate them, and produce events:\n`csharp{\ntitle: \"Order Command Handler\"\ndescription: \"Handler that validates commands and produces events\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"Handlers\", \"Validation\", \"Events\"]\nusingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\nnamespace MyApp Orders Handlers;\npublic class PlaceOrderHandler {\n    private readonly IOrderRepository _repository;\n    public PlaceOrderHandler(IOrderRepository repository) {\n        _repository = repository;\n    }\n    public async Task<OrderPlaced> Handle(PlaceOrder command) {\n        // Validate command\n        if (command Items Count == 0) {\n            throw new InvalidOperationException(\"Order must have at least one item\");\n        }\n        // Create aggregate\n        var order = new Order(\n            Guid NewGuid(),\n            command CustomerId,\n            command Items\n        );\n        // Persist aggregate (events are appended)\n        await _repository SaveAsync(order);\n        // Return event (auto-published by Whizbang)\n        return new OrderPlaced(\n            order Id,\n            command CustomerId,\n            DateTimeOffset UtcNow,\n            command Items,\n            order Total\n        );\n    }\n}\n`\nCommand Routing\nCommands are routed to the owning domain:\n`csharp{\ntitle: \"Sending Commands\"\ndescription: \"How to send commands to their owning domain\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"Routing\", \"Distributed Systems\"]\nusingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading",
        "startIndex": 3681,
        "preview": "owning domain's handlers Single recipient - Unlike events, commands go to exactly one handler Example `csharp{ title: \"Order Domain Commands\" descript..."
      },
      {
        "id": "old-v1.0.0/core-concepts/core-concepts-chunk-3",
        "text": "} ` Command Routing Commands are routed to the owning domain: `csharp{ title: \"Sending Commands\" description: \"How to send commands to their owning domain\" framework: \"NET8\" category: \"Domain Logic\" difficulty: \"INTERMEDIATE\" tags: [\"Commands\", \"Routing\", \"Distributed Systems\"] usingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading Tasks;\nusing Whizbang;\npublic class CheckoutService {\n    private readonly IWhizbang _whizbang;\n    public CheckoutService(IWhizbang whizbang) {\n        _whizbang = whizbang;\n    }\n    public async Task CheckoutAsync(Guid customerId, List<OrderItem> items) {\n        // Send command to Orders domain\n        var placed = await _whizbang Send(new PlaceOrder(customerId, items));\n        // Send command to Inventory domain\n        await _whizbang Send(new ReserveInventory(placed OrderId, items));\n        // Send command to Payment domain\n        await _whizbang Send(new ProcessPayment(placed OrderId, placed Total));\n    }\n}\n`\nIn a monolith, these commands are routed to local handlers In microservices, they're routed to the owning service via message broker Aggregates\nAggregates are the write-side domain models that enforce business rules They are the consistency boundary for commands and events Characteristics\nConsistency boundary - All changes within an aggregate are transactional\nEvent-sourced - State is built by replaying events\nValidated - Enforce invariants before producing events\nSingle writer - Only one command can modify an aggregate at a time (optimistic concurrency)\nExample\n`csharp{\ntitle: \"Order Aggregate\"\ndescription: \"Event-sourced aggregate that enforces order business rules\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aggregates\", \"Event Sourcing\", \"Domain-Driven Design\"]\nusingStatements: [\"Whizbang\", \"System\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing Whizbang;\nnamespace MyApp Orders",
        "startIndex": 5848,
        "preview": "} ` Command Routing Commands are routed to the owning domain: `csharp{ title: \"Sending Commands\" description: \"How to send commands to their owning do..."
      },
      {
        "id": "old-v1.0.0/core-concepts/core-concepts-chunk-4",
        "text": "a time (optimistic concurrency) Example `csharp{ title: \"Order Aggregate\" description: \"Event-sourced aggregate that enforces order business rules\" framework: \"NET8\" category: \"Domain Logic\" difficulty: \"INTERMEDIATE\" tags: [\"Aggregates\", \"Event Sourcing\", \"Domain-Driven Design\"] usingStatements: [\"Whizbang\", \"System\", \"System Collections Generic\"] showLineNumbers: true } using System; using System Collections Generic; using Whizbang; namespace MyApp Orders Domain;\npublic class Order : Aggregate {\n    public Guid Id { get; private set; }\n    public Guid CustomerId { get; private set; }\n    public OrderStatus Status { get; private set; }\n    public List<OrderItem> Items { get; private set; } = new();\n    public decimal Total { get; private set; }\n    // Constructor for new aggregates\n    public Order(Guid id, Guid customerId, List<OrderItem> items) {\n        // Validate business rules\n        if (items Count == 0) {\n            throw new InvalidOperationException(\"Order must have items\");\n        }\n        // Produce event\n        Apply(new OrderPlaced(\n            id,\n            customerId,\n            DateTimeOffset UtcNow,\n            items,\n            items Sum(i => i Price * i Quantity)\n        ));\n    }\n    // Event handler - updates state\n    private void When(OrderPlaced @event) {\n        Id = @event OrderId;\n        CustomerId = @event CustomerId;\n        Status = OrderStatus Placed;\n        Items = @event Items;\n        Total = @event Total;\n    }\n    // Command method - enforces business rules\n    public void Ship(string trackingNumber) {\n        if (Status = OrderStatus Placed) {\n            throw new InvalidOperationException(\"Can only ship placed orders\");\n        }\n        Apply(new OrderShipped(Id, DateTimeOffset UtcNow, trackingNumber));\n    }\n    // Event handler - updates state\n    private void When(OrderShipped @event) {\n        Status = OrderStatus Shipped;\n    }\n    // Command method - enforces business rules\n    public void Cancel(string reason) {\n        if (Status == OrderStatus Shipped || Status == OrderStatus Delivered) {\n            throw new InvalidOperationException(\"Cannot cancel shipped/delivered orders\");\n        }\n        Apply(new OrderCancelled(Id, DateTimeOffset UtcNow, reason));\n    }\n    // Event handler - updates state\n    private void When(OrderCancelled @event) {\n        Status = OrderStatus",
        "startIndex": 7472,
        "preview": "a time (optimistic concurrency) Example `csharp{ title: \"Order Aggregate\" description: \"Event-sourced aggregate that enforces order business rules\" fr..."
      },
      {
        "id": "old-v1.0.0/core-concepts/core-concepts-chunk-5",
        "text": "// Command method - enforces business rules public void Cancel(string reason) { if (Status == OrderStatus Shipped || Status == OrderStatus Delivered) { throw new InvalidOperationException(\"Cannot cancel shipped/delivered orders\"); } Apply(new OrderCancelled(Id, DateTimeOffset UtcNow, reason)); } // Event handler - updates state private void When(OrderCancelled @event) { Status = OrderStatus Cancelled;\n    }\n}\npublic enum OrderStatus {\n    Placed,\n    Shipped,\n    Delivered,\n    Cancelled\n}\n`\nEvent Sourcing Pattern\nAggregates follow this pattern:\nLoad aggregate by replaying events from the stream\nExecute command method, which validates business rules\nApply events to update state\nSave new events to the stream\n`csharp{\ntitle: \"Loading and Saving Aggregates\"\ndescription: \"How aggregates are loaded from and saved to event streams\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"ADVANCED\"\ntags: [\"Aggregates\", \"Event Sourcing\", \"Repositories\"]\nusingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nusing Whizbang;\npublic class OrderRepository : IOrderRepository {\n    private readonly IEventStore _eventStore;\n    public OrderRepository(IEventStore eventStore) {\n        _eventStore = eventStore;\n    }\n    public async Task<Order> GetAsync(Guid orderId) {\n        // Load events from stream\n        var events = await _eventStore LoadStreamAsync($\"Order-{orderId}\");\n        // Reconstitute aggregate by replaying events\n        var order = new Order();\n        foreach (var @event in events) {\n            order ApplyEvent(@event);  // Calls private When() methods\n        }\n        return order;\n    }\n    public async Task SaveAsync(Order order) {\n        // Get uncommitted events from aggregate\n        var newEvents = order GetUncommittedEvents();\n        // Append to event stream with optimistic concurrency check\n        await _eventStore AppendToStreamAsync(\n            $\"Order-{order Id}\",\n            newEvents,\n            expectedVersion: order Version\n        );\n        // Mark events as committed\n        order MarkEventsAsCommitted();\n    }\n}\n`\nProjections\nProjections are read-side models optimized for queries They are built by subscribing to events and updating denormalized views",
        "startIndex": 9387,
        "preview": "// Command method - enforces business rules public void Cancel(string reason) { if (Status == OrderStatus Shipped || Status == OrderStatus Delivered) ..."
      },
      {
        "id": "old-v1.0.0/core-concepts/core-concepts-chunk-6",
        "text": "order GetUncommittedEvents(); // Append to event stream with optimistic concurrency check await _eventStore AppendToStreamAsync( $\"Order-{order Id}\", newEvents, expectedVersion: order Version ); // Mark events as committed order MarkEventsAsCommitted(); } } ` Projections Projections are read-side models optimized for queries They are built by subscribing to events and updating denormalized views Characteristics\nEventually consistent - Updated asynchronously as events arrive\nDenormalized - Optimized for specific query patterns\nRebuildable - Can be deleted and rebuilt from event history\nIsolated - Each projection has its own data model\nExample\n`csharp{\ntitle: \"Order History Projection\"\ndescription: \"Projection that maintains a queryable order history\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"CQRS\", \"Read Models\"]\nusingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\nnamespace MyApp Orders Projections;\n// Read model - optimized for queries\npublic class OrderHistoryItem {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    public DateTimeOffset PlacedAt { get; set; }\n    public DateTimeOffset ShippedAt { get; set; }\n    public decimal Total { get; set; }\n    public string Status { get; set; }\n}\n// Projection handler - subscribes to events\npublic class OrderHistoryProjection {\n    private readonly IOrderHistoryStore _store;\n    public OrderHistoryProjection(IOrderHistoryStore store) {\n        _store = store;\n    }\n    // Event handler - updates read model\n    public async Task Handle(OrderPlaced @event) {\n        await _store InsertAsync(new OrderHistoryItem {\n            OrderId = @event OrderId,\n            CustomerId = @event CustomerId,\n            PlacedAt = @event PlacedAt,\n            Total = @event Total,\n            Status = \"Placed\"\n        });\n    }\n    // Event handler - updates read model\n    public async Task Handle(OrderShipped @event) {\n        await _store UpdateAsync(@event OrderId, item => {\n            item ShippedAt = @event ShippedAt;\n            item Status = \"Shipped\";\n        });\n    }\n    // Event handler - updates read model\n    public async Task Handle(OrderCancelled @event) {\n        await _store UpdateAsync(@event OrderId, item => {\n            item",
        "startIndex": 11358,
        "preview": "order GetUncommittedEvents(); // Append to event stream with optimistic concurrency check await _eventStore AppendToStreamAsync( $\"Order-{order Id}\", ..."
      },
      {
        "id": "old-v1.0.0/core-concepts/core-concepts-chunk-7",
        "text": "handler - updates read model public async Task Handle(OrderShipped @event) { await _store UpdateAsync(@event OrderId, item => { item ShippedAt = @event ShippedAt; item Status = \"Shipped\"; }); } // Event handler - updates read model public async Task Handle(OrderCancelled @event) { await _store UpdateAsync(@event OrderId, item => { item Status = \"Cancelled\";\n        });\n    }\n}\n`\nQuerying Projections\nProjections are queried directly, not through the event store:\n`csharp{\ntitle: \"Querying Order History\"\ndescription: \"How to query projections for read-side data\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Projections\", \"Queries\", \"CQRS\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\npublic class OrderQueryService {\n    private readonly IOrderHistoryStore _store;\n    public OrderQueryService(IOrderHistoryStore store) {\n        _store = store;\n    }\n    public async Task<List<OrderHistoryItem>> GetCustomerOrdersAsync(Guid customerId) {\n        // Query the projection (fast, optimized for reads)\n        return await _store QueryAsync(item => item CustomerId == customerId);\n    }\n    public async Task<OrderHistoryItem> GetOrderDetailsAsync(Guid orderId) {\n        return await _store GetAsync(orderId);\n    }\n}\n`\nProjection Backfilling\nWhen a projection is added to a new service, it can backfill from historical events:\n`csharp{\ntitle: \"Backfilling a Projection\"\ndescription: \"Configure a projection to rebuild from historical events\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Backfilling\", \"Event Sourcing\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\npublic static class ServiceCollectionExtensions {\n    public static IServiceCollection AddOrderProjections(this IServiceCollection services) {\n        services AddProjection<OrderHistoryProjection>(options => {\n            // Subscribe to events from the Orders domain\n            options Subscribe<OrderPlaced>();\n            options Subscribe<OrderShipped>();\n            options Subscribe<OrderCancelled>();\n            // Backfill from the beginning of time\n            options BackfillFrom = DateTimeOffset MinValue;\n            // Process in parallel across order IDs (partitioned by OrderId)\n            options PartitionBy = @event => ((dynamic)@event)",
        "startIndex": 13352,
        "preview": "handler - updates read model public async Task Handle(OrderShipped @event) { await _store UpdateAsync(@event OrderId, item => { item ShippedAt = @even..."
      },
      {
        "id": "old-v1.0.0/core-concepts/core-concepts-chunk-8",
        "text": "AddOrderProjections(this IServiceCollection services) { services AddProjection<OrderHistoryProjection>(options => { // Subscribe to events from the Orders domain options Subscribe<OrderPlaced>(); options Subscribe<OrderShipped>(); options Subscribe<OrderCancelled>(); // Backfill from the beginning of time options BackfillFrom = DateTimeOffset MinValue; // Process in parallel across order IDs (partitioned by OrderId) options PartitionBy = @event => ((dynamic)@event) OrderId;\n        });\n        return services;\n    }\n}\n`\nWhen this projection starts:\nIt queries the Orders service for all historical OrderPlaced, OrderShipped, and OrderCancelled events\nIt applies them in order to build the initial projection state\nIt continues processing new events as they arrive\nCQRS Pattern\nCQRS (Command Query Responsibility Segregation) separates writes from reads:\nCommands → Aggregates (write side)\nQueries → Projections (read side)\n`text{\ntitle: \"CQRS Architecture Pattern\"\ndescription: \"Visual diagram showing command-query separation with aggregates and projections\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"CQRS\", \"Architecture\", \"Commands\", \"Queries\", \"Projections\"]\nfilename: \"cqrs-diagram txt\"\nshowLineNumbers: false\n}\n     Command                   Event                   Query\n        ↓                        ↓                        ↓\n   ┌─────────┐             ┌──────────┐            ┌──────────┐\n   │Aggregate│ ─Events→    │Event     │ ─Events→   │Projection│\n   │         │             │Store     │            │          │\n   └─────────┘             └──────────┘            └──────────┘\n   Write Model             Source of Truth          Read Model\n   (Normalized)            (Immutable)              (Denormalized)\n`\nBenefits:\nOptimized models - Write and read models can have different schemas\nScalability - Scale reads independently from writes\nFlexibility - Multiple projections can be built from the same events\nNext Steps\nNow that you understand the core concepts, learn how to:\nGet Started - Build your first Whizbang application\nPackage Structure - Choose the right NuGet packages\nDriver System - Understand how to swap persistence and messaging backends",
        "startIndex": 15599,
        "preview": "AddOrderProjections(this IServiceCollection services) { services AddProjection<OrderHistoryProjection>(options => { // Subscribe to events from the Or..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/core-concepts/dispatcher",
    "title": "Dispatcher & Policies",
    "category": "Core Concepts",
    "url": "/docs/old-v1.0.0/core-concepts/dispatcher",
    "chunks": [
      {
        "id": "old-v1.0.0/core-concepts/dispatcher-chunk-0",
        "text": "Dispatcher & Policies\nOverview\nThe Dispatcher is the central nervous system of Whizbang It coordinates message flow between receptors, perspectives, and lenses, while Policies define how components behave and execute Together, they provide a unified runtime that scales from event-driven development to complex event-sourced systems What is the Dispatcher The Dispatcher:\nRoutes commands to the appropriate receptors\nPublishes events from receptors to interested perspectives\nExecutes queries against lenses\nCoordinates saga workflows\nApplies policies to control behavior\nManages the execution pipeline\nThink of the dispatcher as an intelligent router that understands your domain and ensures messages reach the right destinations Core Dispatcher Responsibilities\nMessage Routing\n`csharp{\ntitle: \"Message Routing\"\ndescription: \"How the dispatcher routes different message types\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Dispatcher\", \"Routing\", \"Messages\"]\nfilename: \"MessageRouting cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class OrderDispatcherExample {\n    private readonly IDispatcher dispatcher;\n    public async Task DemonstrateRouting() {\n        // Commands routed to owning receptors\n        var orderEvent = await dispatcher Send(new CreateOrder( ));\n        // Events published to interested perspectives\n        // OrderPerspective, AnalyticsPerspective, etc all receive the event\n        // Queries executed against lenses\n        var orderLens = dispatcher GetLens<IOrderLens>();\n        var orders = orderLens ViewByCustomer(customerId);\n    }\n}\n`\nReturn Type Interpretation\nThe dispatcher uses return types to determine what happens next:\n`csharp{\ntitle: \"Return Type Semantics\"\ndescription: \"How return types control dispatcher behavior\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Dispatcher\", \"Return Types\", \"Semantics\"]\nfilename: \"ReturnTypeSemantics cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class ReturnTypeExamples {\n    // Single event → Published to perspectives\n    public OrderCreated Receive(CreateOrder cmd) {\n        return new OrderCreated( );\n    }\n    // Multiple events → All published in sequence\n    public (OrderCreated, EmailQueued, InventoryReserved) Receive(PlaceOrder cmd) {\n        return (\n            new OrderCreated( ),\n            new EmailQueued( ),\n            new InventoryReserved(",
        "startIndex": 0,
        "preview": "Dispatcher & Policies\nOverview\nThe Dispatcher is the central nervous system of Whizbang It coordinates message flow between receptors, perspectives, a..."
      },
      {
        "id": "old-v1.0.0/core-concepts/dispatcher-chunk-1",
        "text": "\"Whizbang\"] showLineNumbers: true } public class ReturnTypeExamples { // Single event → Published to perspectives public OrderCreated Receive(CreateOrder cmd) { return new OrderCreated( ); } // Multiple events → All published in sequence public (OrderCreated, EmailQueued, InventoryReserved) Receive(PlaceOrder cmd) { return ( new OrderCreated( ), new EmailQueued( ), new InventoryReserved( )\n        );\n    }\n    // Result type → Success/failure handling\n    public Result<PaymentProcessed> Receive(ProcessPayment cmd) {\n        if (cmd Amount <= 0) {\n            return Result Failure<PaymentProcessed>(\"Invalid amount\");\n        }\n        return Result Success(new PaymentProcessed( ));\n    }\n    // Void → Fire-and-forget\n    public void Receive(LogActivity cmd) {\n        Console WriteLine(cmd Message);\n    }\n}\n`\nPipeline Coordination\n`csharp{\ntitle: \"Execution Pipeline\"\ndescription: \"The dispatcher coordinates the entire execution pipeline\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"ADVANCED\"\ntags: [\"Dispatcher\", \"Pipeline\", \"Coordination\"]\nfilename: \"ExecutionPipeline cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\n// Simplified view of dispatcher pipeline\npublic class DispatcherPipeline {\n    public async Task<TResult> Execute<TResult>(object message) {\n        // 1 Apply pre-execution policies\n        await ApplyPolicies(message, PolicyStage PreExecution);\n        // 2 Route to appropriate receptor\n        var receptor = ResolveReceptor(message);\n        // 3 Execute receptor with lens injection\n        var result = await ExecuteReceptor(receptor, message);\n        // 4 Handle return value based on type\n        await ProcessReturnValue(result);\n        // 5 Apply post-execution policies\n        await ApplyPolicies(message, PolicyStage PostExecution);\n        return (TResult)result;\n    }\n}\n`\nPolicies\nPolicies define how the dispatcher and components behave They control execution strategies, error handling, performance characteristics, and more Policy Types\nExecution Policies\nControl how and when receptors execute:\n`csharp{\ntitle: \"Execution Policies\"\ndescription: \"Policies that control receptor execution behavior\"\nframework: \"NET8\"\ncategory: \"Policies\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Policies\", \"Execution\", \"Configuration\"]\nfilename: \"ExecutionPolicies cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\nservices AddWhizbang(dispatcher => {\n    // Event-driven execution policy\n    dispatcher ForReceptor<OrderReceptor>() UsePolicy(new EventDrivenPolicy {\n            ExecutionMode = ExecutionMode Synchronous,\n            MaxConcurrency = 1,\n            Timeout = TimeSpan FromSeconds(30)\n        });\n    // Event-sourced execution policy\n    dispatcher ForReceptor<PaymentReceptor>()",
        "startIndex": 2488,
        "preview": "\"Whizbang\"] showLineNumbers: true } public class ReturnTypeExamples { // Single event → Published to perspectives public OrderCreated Receive(CreateOr..."
      },
      {
        "id": "old-v1.0.0/core-concepts/dispatcher-chunk-2",
        "text": "framework: \"NET8\" category: \"Policies\" difficulty: \"INTERMEDIATE\" tags: [\"Policies\", \"Execution\", \"Configuration\"] filename: \"ExecutionPolicies cs\" usingStatements: [\"System\", \"Whizbang\"] showLineNumbers: true } services AddWhizbang(dispatcher => { // Event-driven execution policy dispatcher ForReceptor<OrderReceptor>() UsePolicy(new EventDrivenPolicy { ExecutionMode = ExecutionMode Synchronous, MaxConcurrency = 1, Timeout = TimeSpan FromSeconds(30) }); // Event-sourced execution policy dispatcher ForReceptor<PaymentReceptor>() UsePolicy(new EventSourcedPolicy {\n            SnapshotFrequency = 100,\n            CacheDuration = TimeSpan FromMinutes(5),\n            ReplayOptimization = true\n        });\n});\n`\nResilience Policies\nHandle failures and ensure reliability:\n`csharp{\ntitle: \"Resilience Policies\"\ndescription: \"Policies for handling failures and ensuring reliability\"\nframework: \"NET8\"\ncategory: \"Policies\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Policies\", \"Resilience\", \"Error Handling\"]\nfilename: \"ResiliencePolicies cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\ndispatcher ForReceptor<PaymentReceptor>() UsePolicy(new ResiliencePolicy {\n        RetryCount = 3,\n        RetryBackoff = BackoffStrategy Exponential,\n        CircuitBreakerThreshold = 5,\n        CircuitBreakerDuration = TimeSpan FromMinutes(1),\n        FallbackAction = FallbackAction DeadLetter\n    });\n// Perspective resilience\ndispatcher Perspectives UsePolicy(new PerspectiveResiliencePolicy {\n        RetryCount = 5,\n        RetryBackoff = BackoffStrategy Linear,\n        DeadLetterAfter = 10,\n        BatchSize = 50\n    });\n`\nPerformance Policies\nOptimize for throughput and latency:\n`csharp{\ntitle: \"Performance Policies\"\ndescription: \"Policies for optimizing performance characteristics\"\nframework: \"NET8\"\ncategory: \"Policies\"\ndifficulty: \"ADVANCED\"\ntags: [\"Policies\", \"Performance\", \"Optimization\"]\nfilename: \"PerformancePolicies cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\ndispatcher ForReceptor<HighVolumeReceptor>() UsePolicy(new PerformancePolicy {\n        // Enable object pooling\n        UseObjectPooling = true,\n        PoolSize = 100,\n        // Batching configuration\n        EnableBatching = true,\n        BatchSize = 50,\n        BatchTimeout = TimeSpan FromMilliseconds(100),\n        // Caching configuration\n        EnableCaching = true,\n        CacheSize = 1000,\n        CacheTTL = TimeSpan FromMinutes(5)\n    });\n`\nSecurity Policies\nControl access and enforce authorization:\n`csharp{\ntitle: \"Security Policies\"\ndescription: \"Policies for access control and authorization\"\nframework: \"NET8\"\ncategory: \"Policies\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Policies\", \"Security\", \"Authorization\"]\nfilename: \"SecurityPolicies cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\ndispatcher ForReceptor<SensitiveReceptor>() UsePolicy(new SecurityPolicy {\n        RequireAuthentication = true,\n        RequiredRoles = new[] { \"Admin\", \"Manager\" },\n        RequiredPermissions = new[] { \"orders:create\", \"payments:process\" },\n        AuditLevel = AuditLevel",
        "startIndex": 4902,
        "preview": "framework: \"NET8\" category: \"Policies\" difficulty: \"INTERMEDIATE\" tags: [\"Policies\", \"Execution\", \"Configuration\"] filename: \"ExecutionPolicies cs\" us..."
      },
      {
        "id": "old-v1.0.0/core-concepts/dispatcher-chunk-3",
        "text": "\"Policies for access control and authorization\" framework: \"NET8\" category: \"Policies\" difficulty: \"INTERMEDIATE\" tags: [\"Policies\", \"Security\", \"Authorization\"] filename: \"SecurityPolicies cs\" usingStatements: [\"System\", \"Whizbang\"] showLineNumbers: true } dispatcher ForReceptor<SensitiveReceptor>() UsePolicy(new SecurityPolicy { RequireAuthentication = true, RequiredRoles = new[] { \"Admin\", \"Manager\" }, RequiredPermissions = new[] { \"orders:create\", \"payments:process\" }, AuditLevel = AuditLevel Full,\n        EncryptSensitiveData = true\n    });\n// Multi-tenant security\ndispatcher UseTenantIsolation(tenant => {\n    tenant IsolateEventStreams = true;\n    tenant IsolatePerspectives = true;\n    tenant RequireTenantScope = true;\n});\n`\nPolicy Configuration Patterns\nGlobal Policies\nApply to all components:\n`csharp{\ntitle: \"Global Policy Configuration\"\ndescription: \"Applying policies globally across all components\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Policies\", \"Global\", \"Configuration\"]\nfilename: \"GlobalPolicies cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\nservices AddWhizbang(dispatcher => {\n    // Global logging policy\n    dispatcher UseGlobalPolicy(new LoggingPolicy {\n        LogLevel = LogLevel Information,\n        IncludePerformanceMetrics = true,\n        IncludePayload = false // For security\n    });\n    // Global resilience policy\n    dispatcher UseGlobalPolicy(new GlobalResiliencePolicy {\n        DefaultRetryCount = 3,\n        DefaultTimeout = TimeSpan FromSeconds(30),\n        EnableCircuitBreaker = true\n    });\n});\n`\nComponent-Specific Policies\nApply to specific receptors, perspectives, or lenses:\n`csharp{\ntitle: \"Component-Specific Policies\"\ndescription: \"Applying policies to specific components\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Policies\", \"Component-Specific\", \"Configuration\"]\nfilename: \"ComponentPolicies cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\nservices AddWhizbang(dispatcher => {\n    // Receptor-specific policies\n    dispatcher ForReceptor<OrderReceptor>() UseEventSourcedPolicy() WithSnapshotting(frequency: 50) WithCaching(duration: TimeSpan FromMinutes(10));\n    // Perspective-specific policies\n    dispatcher ForPerspective<AnalyticsPerspective>() UseAsyncExecution() WithBatching(size: 100) WithLowPriority();\n    // Lens-specific policies\n    dispatcher ForLens<IOrderLens>() UseCaching(duration: TimeSpan FromMinutes(5)) WithReadReplica();\n});\n`\nConditional Policies\nApply policies based on runtime conditions:\n`csharp{\ntitle: \"Conditional Policy Application\"\ndescription: \"Applying policies based on runtime conditions\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Policies\", \"Conditional\", \"Runtime\"]\nfilename: \"ConditionalPolicies cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\ndispatcher UseConditionalPolicy(context => {\n    // Apply different policies based on message type\n    if (context Message is HighPriorityCommand) {\n        return new HighPriorityPolicy {\n            MaxLatency = TimeSpan",
        "startIndex": 7493,
        "preview": "\"Policies for access control and authorization\" framework: \"NET8\" category: \"Policies\" difficulty: \"INTERMEDIATE\" tags: [\"Policies\", \"Security\", \"Auth..."
      },
      {
        "id": "old-v1.0.0/core-concepts/dispatcher-chunk-4",
        "text": "\"Applying policies based on runtime conditions\" framework: \"NET8\" category: \"Configuration\" difficulty: \"ADVANCED\" tags: [\"Policies\", \"Conditional\", \"Runtime\"] filename: \"ConditionalPolicies cs\" usingStatements: [\"System\", \"Whizbang\"] showLineNumbers: true } dispatcher UseConditionalPolicy(context => { // Apply different policies based on message type if (context Message is HighPriorityCommand) { return new HighPriorityPolicy { MaxLatency = TimeSpan FromMilliseconds(100),\n            PreferredThreads = 4\n        };\n    }\n    // Apply policies based on tenant\n    if (context TenantId == \"enterprise-customer\") {\n        return new EnterprisePolicy {\n            SLA = TimeSpan FromSeconds(1),\n            BackupReplicas = 3\n        };\n    }\n    return new StandardPolicy();\n});\n`\nPolicy Composition\nPolicies can be composed and layered:\n`csharp{\ntitle: \"Policy Composition\"\ndescription: \"Composing multiple policies for complex behavior\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Policies\", \"Composition\", \"Layering\"]\nfilename: \"PolicyComposition cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\ndispatcher ForReceptor<CriticalReceptor>() UsePolicy(new SecurityPolicy { RequireAuthentication = true }) UsePolicy(new PerformancePolicy { EnableCaching = true }) UsePolicy(new ResiliencePolicy { RetryCount = 5 }) UsePolicy(new AuditPolicy { LogLevel = AuditLevel Full }) UsePolicy(new CompliancePolicy { EncryptData = true });\n// Policies are applied in order, with later policies able to override earlier ones\n`\nDispatcher Modes\nThe dispatcher supports different execution modes:\nEvent-Driven Mode\n`csharp{\ntitle: \"Event-Driven Mode Configuration\"\ndescription: \"Configuring the dispatcher for event-driven execution\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Dispatcher\", \"Event-Driven\", \"Configuration\"]\nfilename: \"EventDrivenMode cs\"\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nservices AddWhizbang(dispatcher => {\n    // Event-driven mode with stateless receptors\n    dispatcher UseEventDrivenMode(options => {\n        options DefaultExecutionMode = ExecutionMode Synchronous;\n        options EnablePerspectivePersistence = true;\n        options MaxConcurrentReceptors = Environment ProcessorCount;\n    });\n    // Perspective configuration\n    dispatcher Perspectives UsePostgreSQL(connectionString) WithBatching(size: 50) WithRetry(count: 3);\n});\n`\nEvent-Sourced Mode\n`csharp{\ntitle: \"Event-Sourced Mode Configuration\"\ndescription: \"Configuring the dispatcher for event sourcing\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Dispatcher\", \"Event-Sourced\", \"Configuration\"]\nfilename: \"EventSourcedMode cs\"\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nservices",
        "startIndex": 10206,
        "preview": "\"Applying policies based on runtime conditions\" framework: \"NET8\" category: \"Configuration\" difficulty: \"ADVANCED\" tags: [\"Policies\", \"Conditional\", \"..."
      },
      {
        "id": "old-v1.0.0/core-concepts/dispatcher-chunk-5",
        "text": "ProcessorCount; }); // Perspective configuration dispatcher Perspectives UsePostgreSQL(connectionString) WithBatching(size: 50) WithRetry(count: 3); }); ` Event-Sourced Mode `csharp{ title: \"Event-Sourced Mode Configuration\" description: \"Configuring the dispatcher for event sourcing\" framework: \"NET8\" category: \"Configuration\" difficulty: \"ADVANCED\" tags: [\"Dispatcher\", \"Event-Sourced\", \"Configuration\"] filename: \"EventSourcedMode cs\" usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"] showLineNumbers: true } services AddWhizbang(dispatcher => {\n    // Event-sourced mode with stateful receptors\n    dispatcher UseEventSourcing(es => {\n        es UseLedger(ledger => {\n            ledger UsePostgreSQL(connectionString);\n            ledger EnableSnapshots(frequency: 100);\n            ledger ConfigurePartitioning(partitions: 8);\n        });\n        es EnableTimeTravel();\n        es EnableReplay();\n    });\n    // Receptor policies for event sourcing\n    dispatcher UseGlobalPolicy(new EventSourcedPolicy {\n        DefaultSnapshotFrequency = 50,\n        DefaultCacheDuration = TimeSpan FromMinutes(5)\n    });\n});\n`\nDistributed Mode\n`csharp{\ntitle: \"Distributed Mode Configuration\"\ndescription: \"Configuring the dispatcher for distributed execution\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Dispatcher\", \"Distributed\", \"Configuration\"]\nfilename: \"DistributedMode cs\"\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nservices AddWhizbang(dispatcher => {\n    // Distributed mode with relays\n    dispatcher UseRelays(relays => {\n        relays UseKafka(kafka => {\n            kafka BootstrapServers = \"localhost:9092\";\n            kafka EnableIdempotence = true;\n            kafka Partitions = 12;\n        });\n    });\n    // Service ownership configuration\n    dispatcher ConfigureDomain(\"Orders\", domain => {\n        domain OwnsReceptor<OrderReceptor>();\n        domain PublishesEvents<OrderCreated, OrderShipped>();\n        domain SubscribesToEvents<PaymentProcessed, InventoryReserved>();\n    });\n});\n`\nPolicy Best Practices\nDo's\n✅ Start with sensible defaults\n`csharp{\ntitle: \"Sensible Defaults Pattern\"\ndescription: \"Start with framework defaults and override only what's needed\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Policies\", \"Configuration\", \"Best Practices\"]\nfilename: \"DefaultPolicies cs\"\nusingStatements: [\"Whizbang\"]\n}\n// Use framework defaults first\ndispatcher UseDefaults();\n// Override only what you need\ndispatcher ForReceptor<SpecialReceptor>() UseCustomPolicy(mySpecialPolicy);\n`\n✅ Layer policies logically\n`csharp{\ntitle: \"Policy Layering Pattern\"\ndescription: \"Layer policies from general to specific\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Policies\", \"Layering\", \"Best Practices\"]\nfilename: \"PolicyLayering cs\"\nusingStatements: [\"Whizbang\"]\n}\n// Layer from general to specific\ndispatcher UseGlobalPolicy(globalSecurity) ForReceptor<PaymentReceptor>()",
        "startIndex": 12697,
        "preview": "ProcessorCount; }); // Perspective configuration dispatcher Perspectives UsePostgreSQL(connectionString) WithBatching(size: 50) WithRetry(count: 3); }..."
      },
      {
        "id": "old-v1.0.0/core-concepts/dispatcher-chunk-6",
        "text": "what you need dispatcher ForReceptor<SpecialReceptor>() UseCustomPolicy(mySpecialPolicy); ` ✅ Layer policies logically `csharp{ title: \"Policy Layering Pattern\" description: \"Layer policies from general to specific\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"INTERMEDIATE\" tags: [\"Policies\", \"Layering\", \"Best Practices\"] filename: \"PolicyLayering cs\" usingStatements: [\"Whizbang\"] } // Layer from general to specific dispatcher UseGlobalPolicy(globalSecurity) ForReceptor<PaymentReceptor>() UsePolicy(paymentSpecificSecurity);\n`\n✅ Test policy behavior\n`csharp{\ntitle: \"Policy Testing Pattern\"\ndescription: \"Test that policies are applied correctly\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Testing\", \"Policies\", \"Verification\"]\nfilename: \"PolicyTests cs\"\nusingStatements: [\"Xunit\", \"Whizbang\"]\n}\n[Fact]\npublic async Task PolicyAppliesCorrectly() {\n    var dispatcher = CreateTestDispatcher() WithPolicy(testPolicy);\n    // Verify policy behavior\n    var result = await dispatcher Send(testCommand);\n    Assert True(testPolicy WasApplied);\n}\n`\nDon'ts\n❌ Don't over-configure\n`csharp{\ntitle: \"Anti-Pattern: Over-Configuration\"\ndescription: \"Don't add too many policies to simple components\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Anti-Pattern\", \"Over-Configuration\", \"Policies\"]\nfilename: \"OverConfiguration cs\"\nusingStatements: [\"Whizbang\"]\n}\n// BAD - Too many specific policies\ndispatcher ForReceptor<SimpleReceptor>() UsePolicy(policy1) UsePolicy(policy2) UsePolicy(policy3) UsePolicy(policy4); // Overkill for simple receptors\n`\n❌ Don't ignore policy conflicts\n`csharp{\ntitle: \"Anti-Pattern: Policy Conflicts\"\ndescription: \"Don't create conflicting policy configurations\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Anti-Pattern\", \"Policy Conflicts\", \"Configuration\"]\nfilename: \"PolicyConflicts cs\"\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// BAD - Conflicting timeout policies\ndispatcher UseGlobalPolicy(new TimeoutPolicy { Timeout = TimeSpan FromSeconds(30) }) ForReceptor<MyReceptor>() UsePolicy(new TimeoutPolicy { Timeout = TimeSpan FromSeconds(5) }); // Which one wins `\nSummary\nThe Dispatcher and Policies system provides:\nUnified coordination of all message flow\nFlexible execution strategies through policies\nProgressive enhancement from simple to complex\nFine-grained control over behavior and performance\nComposition of multiple policies for complex scenarios\nThe dispatcher ensures that receptors, perspectives, and lenses work together seamlessly, while policies give you precise control over how they behave",
        "startIndex": 15229,
        "preview": "what you need dispatcher ForReceptor<SpecialReceptor>() UseCustomPolicy(mySpecialPolicy); ` ✅ Layer policies logically `csharp{ title: \"Policy Layerin..."
      },
      {
        "id": "old-v1.0.0/core-concepts/dispatcher-chunk-7",
        "text": "coordination of all message flow Flexible execution strategies through policies Progressive enhancement from simple to complex Fine-grained control over behavior and performance Composition of multiple policies for complex scenarios The dispatcher ensures that receptors, perspectives, and lenses work together seamlessly, while policies give you precise control over how they behave Next Steps\nExplore Receptors - Decision-making components\nLearn about Perspectives - Event handlers and read models\nSee Lenses - Read-only query interfaces\nReview Event-Driven Architecture - The bigger picture",
        "startIndex": 17417,
        "preview": "coordination of all message flow Flexible execution strategies through policies Progressive enhancement from simple to complex Fine-grained control ov..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/core-concepts/lenses",
    "title": "Lenses",
    "category": "Core Concepts",
    "url": "/docs/old-v1.0.0/core-concepts/lenses",
    "chunks": [
      {
        "id": "old-v1.0.0/core-concepts/lenses-chunk-0",
        "text": "Lenses\nOverview\nLenses provide focused, read-only views into your data They are the query side of Whizbang's CQRS implementation, offering a clean separation between reads and writes Lenses work consistently across Event-Driven and Event-Sourced modes, always providing the current view of data regardless of how it's stored What is a Lens A Lens:\nProvides read-only access to data\nFocuses on specific query needs\nNever modifies state\nAbstracts the underlying storage mechanism\nThink of a lens as a window into your data - you can look through it from different angles to see different views, but you can't reach through it to change what you see The Lens Interface Pattern\n`csharp{\ntitle: \"Order Lens Interface\"\ndescription: \"Basic lens interface pattern with core query methods\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Lenses\", \"Interfaces\", \"CQRS\"]\nfilename: \"IOrderLens cs\"\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq Expressions\"]\nshowLineNumbers: true\n}\npublic interface IOrderLens {\n    // Focus on a single item\n    Order Focus(Guid id);\n    // View a filtered collection\n    IEnumerable<Order> View(Expression<Func<Order, bool>> filter);\n    // Glimpse a summary or partial view\n    OrderSummary Glimpse(Guid id);\n    // Check existence\n    bool Exists(Guid id);\n    // Scan all items (use sparingly)\n    IEnumerable<Order> Scan();\n}\n`\nCore Lens Methods\nFocus - Single Item Retrieval\n`csharp{\ntitle: \"Customer Lens Focus Method\"\ndescription: \"Implementing the Focus method for single item retrieval\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Lenses\", \"Focus\", \"Single Item\"]\nfilename: \"CustomerLens cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Linq\"]\nshowLineNumbers: true\n}\npublic interface ICustomerLens {\n    Customer Focus(Guid customerId);\n    Task<Customer> FocusAsync(Guid customerId);\n}\n// Implementation\npublic class CustomerLens : ICustomerLens {\n    private readonly IDatabase db;\n    public Customer Focus(Guid customerId) {\n        return db Customers FirstOrDefault(c => c",
        "startIndex": 0,
        "preview": "Lenses\nOverview\nLenses provide focused, read-only views into your data They are the query side of Whizbang's CQRS implementation, offering a clean sep..."
      },
      {
        "id": "old-v1.0.0/core-concepts/lenses-chunk-1",
        "text": "\"Focus\", \"Single Item\"] filename: \"CustomerLens cs\" usingStatements: [\"System\", \"System Threading Tasks\", \"System Linq\"] showLineNumbers: true } public interface ICustomerLens { Customer Focus(Guid customerId); Task<Customer> FocusAsync(Guid customerId); } // Implementation public class CustomerLens : ICustomerLens { private readonly IDatabase db; public Customer Focus(Guid customerId) { return db Customers FirstOrDefault(c => c Id == customerId);\n    }\n}\n`\nView - Filtered Collections\n`csharp{\ntitle: \"Order Lens View Methods\"\ndescription: \"Implementing View methods for filtered collections\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Lenses\", \"View\", \"Filtering\"]\nfilename: \"OrderLens cs\"\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq Expressions\", \"System Linq\"]\nshowLineNumbers: true\n}\npublic interface IOrderLens {\n    IEnumerable<Order> View(Expression<Func<Order, bool>> filter);\n    IEnumerable<Order> ViewByCustomer(Guid customerId);\n    IEnumerable<Order> ViewByStatus(OrderStatus status);\n}\n// Implementation\npublic class OrderLens : IOrderLens {\n    public IEnumerable<Order> View(Expression<Func<Order, bool>> filter) {\n        return db Orders Where(filter);\n    }\n    public IEnumerable<Order> ViewByCustomer(Guid customerId) {\n        return db Orders Where(o => o CustomerId == customerId);\n    }\n}\n`\nGlimpse - Summaries and Projections\n`csharp{\ntitle: \"Inventory Lens Glimpse Methods\"\ndescription: \"Implementing Glimpse methods for summaries and projections\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Glimpse\", \"Inventory\", \"Summaries\"]\nfilename: \"InventoryLens cs\"\nusingStatements: [\"System\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\npublic interface IInventoryLens {\n    InventorySummary Glimpse(Guid productId);\n    StockLevel GlimpseStock(Guid productId);\n    IEnumerable<LowStockItem> GlimpseLowStock();\n}\n// Implementation  \npublic class InventoryLens : IInventoryLens {\n    public InventorySummary Glimpse(Guid productId) {\n        var product = db Products Find(productId);\n        return new InventorySummary {\n            ProductId = product Id,\n            Name = product Name,\n            InStock = product Quantity,\n            Reserved = product ReservedQuantity,\n            Available = product Quantity - product ReservedQuantity\n        };\n    }\n}\n`\nExists - Efficient Existence Checks\n`csharp{\ntitle: \"Product Lens Exists Methods\"\ndescription: \"Efficient existence checks with conditions\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Lenses\", \"Exists\", \"Efficiency\"]\nfilename: \"ProductLens cs\"\nusingStatements: [\"System\", \"System Linq Expressions\", \"System",
        "startIndex": 2117,
        "preview": "\"Focus\", \"Single Item\"] filename: \"CustomerLens cs\" usingStatements: [\"System\", \"System Threading Tasks\", \"System Linq\"] showLineNumbers: true } publi..."
      },
      {
        "id": "old-v1.0.0/core-concepts/lenses-chunk-2",
        "text": "product ReservedQuantity, Available = product Quantity - product ReservedQuantity }; } } ` Exists - Efficient Existence Checks `csharp{ title: \"Product Lens Exists Methods\" description: \"Efficient existence checks with conditions\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"BEGINNER\" tags: [\"Lenses\", \"Exists\", \"Efficiency\"] filename: \"ProductLens cs\" usingStatements: [\"System\", \"System Linq Expressions\", \"System Linq\"]\nshowLineNumbers: true\n}\npublic interface IProductLens {\n    bool Exists(Guid productId);\n    bool Exists(Expression<Func<Product, bool>> condition);\n}\n// Implementation\npublic class ProductLens : IProductLens {\n    public bool Exists(Guid productId) {\n        return db Products Any(p => p Id == productId);\n    }\n    public bool Exists(Expression<Func<Product, bool>> condition) {\n        return db Products Any(condition);\n    }\n}\n`\nLens Usage in Receptors\nLenses provide state for stateless receptors:\n`csharp{\ntitle: \"Lens Usage in Receptors\"\ndescription: \"Using lenses to provide state for stateless receptors\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Receptors\", \"Validation\"]\nfilename: \"OrderReceptor cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class OrderReceptor : IReceptor<CreateOrder> {\n    public OrderCreated Receive(CreateOrder cmd, IOrderLens orderLens, ICustomerLens customerLens) {\n        // Use lenses to validate\n        if ( customerLens Exists(cmd CustomerId)) {\n            throw new CustomerNotFoundException();\n        }\n        var customer = customerLens Focus(cmd CustomerId);\n        if ( customer IsActive) {\n            throw new InactiveCustomerException();\n        }\n        // Check for duplicate orders\n        if (orderLens Exists(o => o CustomerId == cmd CustomerId && o IsPending)) {\n            throw new PendingOrderExistsException();\n        }\n        // Make decision based on lens data\n        return new OrderCreated(\n            Guid NewGuid(),\n            cmd CustomerId,\n            cmd Items,\n            CalculateTotal(cmd Items, customer Tier)\n        );\n    }\n}\n`\nComposite Lenses\nCombine multiple data sources into a unified view:\n`csharp{\ntitle: \"Composite Checkout Lens\"\ndescription: \"Combining multiple data sources into a unified view for checkout\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Composite\", \"Checkout\"]\nfilename: \"CheckoutLens cs\"\nusingStatements: [\"System\", \"System Collections",
        "startIndex": 4429,
        "preview": "product ReservedQuantity, Available = product Quantity - product ReservedQuantity }; } } ` Exists - Efficient Existence Checks `csharp{ title: \"Produc..."
      },
      {
        "id": "old-v1.0.0/core-concepts/lenses-chunk-3",
        "text": "customer Tier) ); } } ` Composite Lenses Combine multiple data sources into a unified view: `csharp{ title: \"Composite Checkout Lens\" description: \"Combining multiple data sources into a unified view for checkout\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"INTERMEDIATE\" tags: [\"Lenses\", \"Composite\", \"Checkout\"] filename: \"CheckoutLens cs\" usingStatements: [\"System\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\npublic interface ICheckoutLens {\n    CheckoutContext PrepareCheckout(Guid customerId, List<CartItem> items);\n}\npublic class CheckoutLens : ICheckoutLens {\n    private readonly ICustomerLens customerLens;\n    private readonly IInventoryLens inventoryLens;\n    private readonly IPromotionLens promotionLens;\n    private readonly ITaxLens taxLens;\n    public CheckoutContext PrepareCheckout(Guid customerId, List<CartItem> items) {\n        var customer = customerLens Focus(customerId);\n        var inventory = inventoryLens CheckAvailability(items);\n        var promotions = promotionLens GetApplicable(customer, items);\n        var tax = taxLens Calculate(customer Address, items);\n        return new CheckoutContext {\n            Customer = customer,\n            Items = items,\n            InventoryStatus = inventory,\n            AppliedPromotions = promotions,\n            TaxAmount = tax,\n            Total = CalculateTotal(items, promotions, tax)\n        };\n    }\n}\n`\nCached Lenses\nOptimize read performance with caching:\n`csharp{\ntitle: \"Cached Product Lens\"\ndescription: \"Optimizing read performance with caching decorator pattern\"\nframework: \"NET8\"\ncategory: \"Performance\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Caching\", \"Performance\"]\nfilename: \"CachedProductLens cs\"\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq\"]\nshowLineNumbers: true\n}\npublic class CachedProductLens : IProductLens {\n    private readonly IProductLens innerLens;\n    private readonly ICache cache;\n    public Product Focus(Guid productId) {\n        var cacheKey = $\"product:{productId}\";\n        return cache GetOrSet(cacheKey, () => {\n            return innerLens Focus(productId);\n        }, TimeSpan FromMinutes(5));\n    }\n    public IEnumerable<Product> ViewByCategory(string category) {\n        var cacheKey = $\"products:category:{category}\";\n        return cache GetOrSet(cacheKey, () => {\n            return innerLens ViewByCategory(category) ToList();\n        }, TimeSpan FromMinutes(1));\n    }\n}\n`\nPaged Queries\nSupport pagination for large result sets:\n`csharp{\ntitle: \"Paged Query Lens\"\ndescription: \"Supporting pagination for large result sets\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Pagination\", \"Performance\"]\nfilename: \"OrderLens cs\"\nusingStatements: [\"System\", \"System Linq\", \"System Linq",
        "startIndex": 6510,
        "preview": "customer Tier) ); } } ` Composite Lenses Combine multiple data sources into a unified view: `csharp{ title: \"Composite Checkout Lens\" description: \"Co..."
      },
      {
        "id": "old-v1.0.0/core-concepts/lenses-chunk-4",
        "text": "return innerLens ViewByCategory(category) ToList(); }, TimeSpan FromMinutes(1)); } } ` Paged Queries Support pagination for large result sets: `csharp{ title: \"Paged Query Lens\" description: \"Supporting pagination for large result sets\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"INTERMEDIATE\" tags: [\"Lenses\", \"Pagination\", \"Performance\"] filename: \"OrderLens cs\" usingStatements: [\"System\", \"System Linq\", \"System Linq Expressions\"]\nshowLineNumbers: true\n}\npublic interface IOrderLens {\n    PagedResult<Order> ViewPaged(int page, int pageSize, Expression<Func<Order, bool>> filter = null);\n}\npublic class OrderLens : IOrderLens {\n    public PagedResult<Order> ViewPaged(int page, int pageSize, Expression<Func<Order, bool>> filter = null) {\n        var query = db Orders AsQueryable();\n        if (filter = null) {\n            query = query Where(filter);\n        }\n        var totalCount = query Count();\n        var items = query OrderByDescending(o => o CreatedAt) Skip((page - 1) * pageSize) Take(pageSize) ToList();\n        return new PagedResult<Order> {\n            Items = items,\n            Page = page,\n            PageSize = pageSize,\n            TotalCount = totalCount,\n            TotalPages = (int)Math Ceiling(totalCount / (double)pageSize)\n        };\n    }\n}\n`\nAggregate Queries\nProvide pre-calculated aggregations:\n`csharp{\ntitle: \"Statistics Aggregate Lens\"\ndescription: \"Providing pre-calculated aggregations and metrics\"\nframework: \"NET8\"\ncategory: \"Analytics\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Statistics\", \"Aggregation\"]\nfilename: \"StatisticsLens cs\"\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq\"]\nshowLineNumbers: true\n}\npublic interface IStatisticsLens {\n    OrderStatistics GetOrderStats(DateTime from, DateTime to);\n    CustomerMetrics GetCustomerMetrics(Guid customerId);\n    IEnumerable<TopProduct> GetTopProducts(int count);\n}\npublic class StatisticsLens : IStatisticsLens {\n    public OrderStatistics GetOrderStats(DateTime from, DateTime to) {\n        var orders = db Orders Where(o => o CreatedAt >= from && o CreatedAt <= to);\n        return new OrderStatistics {\n            TotalOrders = orders Count(),\n            TotalRevenue = orders Sum(o => o Total),\n            AverageOrderValue = orders Average(o => o Total),\n            OrdersByStatus = orders GroupBy(o => o Status) Select(g => new StatusCount { \n                    Status = g Key, \n                    Count = g Count() \n                })",
        "startIndex": 8909,
        "preview": "return innerLens ViewByCategory(category) ToList(); }, TimeSpan FromMinutes(1)); } } ` Paged Queries Support pagination for large result sets: `csharp..."
      },
      {
        "id": "old-v1.0.0/core-concepts/lenses-chunk-5",
        "text": ">= from && o CreatedAt <= to); return new OrderStatistics { TotalOrders = orders Count(), TotalRevenue = orders Sum(o => o Total), AverageOrderValue = orders Average(o => o Total), OrdersByStatus = orders GroupBy(o => o Status) Select(g => new StatusCount { Status = g Key, Count = g Count() }) ToList()\n        };\n    }\n}\n`\nSearch Lenses\nIntegrate with search infrastructure:\n`csharp{\ntitle: \"ElasticSearch Lens\"\ndescription: \"Integrating with search infrastructure for advanced queries\"\nframework: \"NET8\"\ncategory: \"Search\"\ndifficulty: \"ADVANCED\"\ntags: [\"Lenses\", \"Search\", \"ElasticSearch\"]\nfilename: \"ElasticSearchLens cs\"\nnugetPackages: [\"Elasticsearch Net\", \"NEST\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"Nest\"]\nshowLineNumbers: true\n}\npublic interface ISearchLens {\n    SearchResults<Product> SearchProducts(string query, SearchOptions options);\n    IEnumerable<SearchSuggestion> GetSuggestions(string prefix);\n}\npublic class ElasticSearchLens : ISearchLens {\n    private readonly IElasticClient elastic;\n    public SearchResults<Product> SearchProducts(string query, SearchOptions options) {\n        var searchRequest = new SearchRequest<Product> {\n            Query = new MultiMatchQuery {\n                Query = query,\n                Fields = new[] { \"name\", \"description\", \"category\" }\n            },\n            From = options Offset,\n            Size = options Limit,\n            Aggregations = new TermsAggregation(\"categories\") {\n                Field = \"category keyword\"\n            }\n        };\n        var response = elastic Search<Product>(searchRequest);\n        return new SearchResults<Product> {\n            Items = response Documents,\n            TotalCount = response Total,\n            Facets = ExtractFacets(response Aggregations),\n            HighlightedTerms = ExtractHighlights(response Hits)\n        };\n    }\n}\n`\nLens Configuration\nConfigure lenses with the dispatcher:\n`csharp{\ntitle: \"Lens Configuration\"\ndescription: \"Configuring lenses with the Whizbang dispatcher\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Configuration\", \"Dependency Injection\"]\nfilename: \"Program cs\"\nnugetPackages: [\"Whizbang Core\", \"Microsoft Extensions DependencyInjection\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nservices AddWhizbang() UseDispatcher(dispatcher => {\n        // Register lenses\n        dispatcher RegisterLensesFromAssembly(typeof(Program) Assembly);\n        // Configure caching for all lenses\n        dispatcher Lenses EnableCaching(TimeSpan FromMinutes(5)) UseCacheProvider<RedisCache>();\n        // Specific lens configuration\n        dispatcher ForLens<IProductLens>() UseCaching(TimeSpan FromMinutes(10)) WithImplementation<CachedProductLens>();\n    });\n// Manual registration\nservices AddScoped<IOrderLens, OrderLens>();\nservices AddScoped<ICustomerLens, CustomerLens>();\nservices",
        "startIndex": 11037,
        "preview": ">= from && o CreatedAt <= to); return new OrderStatistics { TotalOrders = orders Count(), TotalRevenue = orders Sum(o => o Total), AverageOrderValue =..."
      },
      {
        "id": "old-v1.0.0/core-concepts/lenses-chunk-6",
        "text": "usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"] showLineNumbers: true } services AddWhizbang() UseDispatcher(dispatcher => { // Register lenses dispatcher RegisterLensesFromAssembly(typeof(Program) Assembly); // Configure caching for all lenses dispatcher Lenses EnableCaching(TimeSpan FromMinutes(5)) UseCacheProvider<RedisCache>(); // Specific lens configuration dispatcher ForLens<IProductLens>() UseCaching(TimeSpan FromMinutes(10)) WithImplementation<CachedProductLens>(); }); // Manual registration services AddScoped<IOrderLens, OrderLens>(); services AddScoped<ICustomerLens, CustomerLens>(); services Decorate<IProductLens, CachedProductLens>();\n`\nTesting Lenses\nLenses are easy to test and mock:\n`csharp{\ntitle: \"Testing Lenses\"\ndescription: \"Unit testing lenses with in-memory data and mocking\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Testing\", \"Unit Tests\", \"Mocking\"]\nfilename: \"OrderLensTests cs\"\nnugetPackages: [\"xunit\", \"Moq\"]\ntestFile: \"OrderLensTests cs\"\ntestMethod: \"OrderLens_ViewByCustomer_ReturnsCustomerOrders\"\nusingStatements: [\"System\", \"System Linq\", \"Xunit\", \"Moq\"]\nshowLineNumbers: true\n}\n[Fact]\npublic void OrderLens_ViewByCustomer_ReturnsCustomerOrders() {\n    // Arrange\n    var db = new InMemoryDatabase();\n    var customerId = Guid NewGuid();\n    db Orders Add(new Order { CustomerId = customerId });\n    db Orders Add(new Order { CustomerId = customerId });\n    db Orders Add(new Order { CustomerId = Guid NewGuid() });\n    var lens = new OrderLens(db);\n    // Act\n    var orders = lens ViewByCustomer(customerId);\n    // Assert\n    Assert Equal(2, orders Count());\n    Assert All(orders, o => Assert Equal(customerId, o CustomerId));\n}\n// Mocking in receptor tests\n[Fact]\npublic void OrderReceptor_ThrowsException_WhenCustomerNotFound() {\n    // Arrange\n    var customerLens = Mock Of<ICustomerLens>(l => \n        l Exists(It IsAny<Guid>()) == false\n    );\n    var receptor = new OrderReceptor();\n    // Act & Assert\n    Assert Throws<CustomerNotFoundException>(() =>\n        receptor Receive(new CreateOrder(), null, customerLens)\n    );\n}\n`\nBest Practices\nDo's\n✅ Keep lenses read-only\n`csharp{\ntitle: \"Read-Only Lens Interface\"\ndescription: \"Best practice: Keep lenses read-only\"\nframework: \"NET8\"\ncategory: \"Best Practices\"\ndifficulty: \"BEGINNER\"\ntags: [\"Lenses\", \"Best Practices\", \"Read-Only\"]\nfilename: \"IOrderLens",
        "startIndex": 13739,
        "preview": "usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"] showLineNumbers: true } services AddWhizbang() UseDispatcher(dispatcher => {..."
      },
      {
        "id": "old-v1.0.0/core-concepts/lenses-chunk-7",
        "text": "= new OrderReceptor(); // Act & Assert Assert Throws<CustomerNotFoundException>(() => receptor Receive(new CreateOrder(), null, customerLens) ); } ` Best Practices Do's ✅ Keep lenses read-only `csharp{ title: \"Read-Only Lens Interface\" description: \"Best practice: Keep lenses read-only\" framework: \"NET8\" category: \"Best Practices\" difficulty: \"BEGINNER\" tags: [\"Lenses\", \"Best Practices\", \"Read-Only\"] filename: \"IOrderLens cs\"\nusingStatements: [\"System\"]\n}\npublic interface IOrderLens {\n    Order Focus(Guid id);  // Read-only methods only\n}\n`\n✅ Use specific method names\n`csharp{\ntitle: \"Specific Method Names\"\ndescription: \"Best practice: Use specific method names for clear intent\"\nframework: \"NET8\"\ncategory: \"Best Practices\"\ndifficulty: \"BEGINNER\"\ntags: [\"Lenses\", \"Best Practices\", \"Method Naming\"]\nfilename: \"IOrderLens cs\"\nusingStatements: [\"System\", \"System Collections Generic\"]\n}\nIEnumerable<Order> ViewPending();      // Clear intent\nIEnumerable<Order> ViewByDateRange(DateTime from, DateTime to);\n`\n✅ Optimize for common queries\n`csharp{\ntitle: \"Optimized Common Queries\"\ndescription: \"Best practice: Optimize for common query patterns\"\nframework: \"NET8\"\ncategory: \"Best Practices\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Best Practices\", \"Performance\"]\nfilename: \"ICustomerLens cs\"\nusingStatements: [\"System\"]\n}\n// Pre-calculate common aggregations\nCustomerDashboard GetCustomerDashboard(Guid customerId);\n`\n✅ Return immutable data\n`csharp{\ntitle: \"Return Immutable Data\"\ndescription: \"Best practice: Return immutable data collections\"\nframework: \"NET8\"\ncategory: \"Best Practices\"\ndifficulty: \"BEGINNER\"\ntags: [\"Lenses\", \"Best Practices\", \"Immutable\"]\nfilename: \"OrderLens cs\"\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq\"]\n}\npublic IReadOnlyList<Order> ViewRecent() {\n    return db Orders OrderByDescending(o => o CreatedAt) Take(10) ToList() AsReadOnly();\n}\n`\nDon'ts\n❌ Don't include write operations\n`csharp{\ntitle: \"Anti-Pattern: Write Operations\"\ndescription: \"DON'T include write operations in lenses\"\nframework: \"NET8\"\ncategory: \"Anti-Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Lenses\", \"Anti-Patterns\", \"Read-Only\"]\nfilename: \"IOrderLens cs\"\nusingStatements: [\"System\"]\n}\n// BAD - Lenses are read-only\npublic interface IOrderLens {\n    void Save(Order order);  // Don't do this",
        "startIndex": 15527,
        "preview": "= new OrderReceptor(); // Act & Assert Assert Throws<CustomerNotFoundException>(() => receptor Receive(new CreateOrder(), null, customerLens) ); } ` B..."
      },
      {
        "id": "old-v1.0.0/core-concepts/lenses-chunk-8",
        "text": "❌ Don't include write operations `csharp{ title: \"Anti-Pattern: Write Operations\" description: \"DON'T include write operations in lenses\" framework: \"NET8\" category: \"Anti-Patterns\" difficulty: \"BEGINNER\" tags: [\"Lenses\", \"Anti-Patterns\", \"Read-Only\"] filename: \"IOrderLens cs\" usingStatements: [\"System\"] } // BAD - Lenses are read-only public interface IOrderLens { void Save(Order order); // Don't do this }\n`\n❌ Don't return mutable entities\n`csharp{\ntitle: \"Mutable vs Immutable Returns\"\ndescription: \"BAD: Mutable entities vs GOOD: Immutable views\"\nframework: \"NET8\"\ncategory: \"Anti-Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Anti-Patterns\", \"Immutable\"]\nfilename: \"OrderLens cs\"\nusingStatements: [\"System\"]\n}\n// BAD - Returns mutable entity\npublic Order Focus(Guid id) {\n    return db Orders Find(id);  // Can be modified\n}\n// GOOD - Return immutable view\npublic OrderView Focus(Guid id) {\n    var order = db Orders Find(id);\n    return new OrderView(order);  // Immutable copy\n}\n`\n❌ Don't perform business logic\n`csharp{\ntitle: \"Anti-Pattern: Business Logic\"\ndescription: \"DON'T perform business logic in lenses\"\nframework: \"NET8\"\ncategory: \"Anti-Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Anti-Patterns\", \"Business Logic\"]\nfilename: \"OrderLens cs\"\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq\"]\n}\n// BAD - Business logic in lens\npublic IEnumerable<Order> ViewDiscounted() {\n    return db Orders Where(o => {\n        if (o Total > 100) {  // Business rule return true;\n        }\n    });\n}\n`\nAdvanced Patterns\nMaterialized View Lenses\nRead from pre-computed materialized views:\n`csharp{\ntitle: \"Materialized View Lens\"\ndescription: \"Reading from pre-computed materialized views\"\nframework: \"NET8\"\ncategory: \"Advanced\"\ndifficulty: \"ADVANCED\"\ntags: [\"Lenses\", \"Materialized Views\", \"Performance\"]\nfilename: \"MaterializedOrderLens cs\"\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq\"]\nshowLineNumbers: true\n}\npublic class MaterializedOrderLens : IOrderLens {\n    // Read from denormalized view maintained by perspectives\n    public OrderSummary Glimpse(Guid orderId) {\n        return db OrderSummaries Find(orderId);  // Pre-computed\n    }\n    public IEnumerable<Order> ViewTopOrders(int count) {\n        return db TopOrdersView",
        "startIndex": 17460,
        "preview": "❌ Don't include write operations `csharp{ title: \"Anti-Pattern: Write Operations\" description: \"DON'T include write operations in lenses\" framework: \"..."
      },
      {
        "id": "old-v1.0.0/core-concepts/lenses-chunk-9",
        "text": "\"Materialized Views\", \"Performance\"] filename: \"MaterializedOrderLens cs\" usingStatements: [\"System\", \"System Collections Generic\", \"System Linq\"] showLineNumbers: true } public class MaterializedOrderLens : IOrderLens { // Read from denormalized view maintained by perspectives public OrderSummary Glimpse(Guid orderId) { return db OrderSummaries Find(orderId); // Pre-computed } public IEnumerable<Order> ViewTopOrders(int count) { return db TopOrdersView Take(count);  // Maintained by perspective\n    }\n}\n`\nCross-Service Lenses\nQuery data from multiple services:\n`csharp{\ntitle: \"Cross-Service Lens\"\ndescription: \"Querying data from multiple distributed services\"\nframework: \"NET8\"\ncategory: \"Advanced\"\ndifficulty: \"ADVANCED\"\ntags: [\"Lenses\", \"Distributed\", \"Microservices\"]\nfilename: \"DistributedCustomerLens cs\"\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\npublic class DistributedCustomerLens : ICustomerLens {\n    private readonly IOrderService orderService;\n    private readonly IPaymentService paymentService;\n    public async Task<CustomerProfile> GetCompleteProfile(Guid customerId) {\n        var customerTask = db Customers FindAsync(customerId);\n        var ordersTask = orderService GetCustomerOrders(customerId);\n        var paymentsTask = paymentService GetPaymentHistory(customerId);\n        await Task WhenAll(customerTask, ordersTask, paymentsTask);\n        return new CustomerProfile {\n            Customer = customerTask Result,\n            RecentOrders = ordersTask Result,\n            PaymentHistory = paymentsTask Result\n        };\n    }\n}\n`\nTime-Travel Lenses\nIn Event-Sourced mode, query historical state:\n`csharp{\ntitle: \"Time-Travel Lens\"\ndescription: \"Querying historical state in event-sourced systems\"\nframework: \"NET8\"\ncategory: \"Advanced\"\ndifficulty: \"ADVANCED\"\ntags: [\"Lenses\", \"Event Sourcing\", \"Time Travel\"]\nfilename: \"HistoricalOrderLens cs\"\nnugetPackages: [\"Whizbang EventSourcing\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic interface IHistoricalLens {\n    Order FocusAsOf(Guid orderId, DateTime pointInTime);\n    IEnumerable<Order> ViewAsOf(DateTime pointInTime);\n}\npublic class HistoricalOrderLens : IHistoricalLens {\n    private readonly IEventStore eventStore;\n    public Order FocusAsOf(Guid orderId, DateTime pointInTime) {\n        var events = eventStore GetEvents(orderId, untilTime: pointInTime);\n        return RebuildOrder(events);\n    }\n}\n`\nSummary\nLenses provide the read side of Whizbang's architecture:\nRead-only interfaces maintain clear separation of concerns\nFocused methods optimize for specific query needs  \nWork consistently across Event-Driven and Event-Sourced modes\nEasy to test and mock\nComposable for complex query scenarios\nLenses ensure that reading data is simple, efficient, and completely separate from writing data",
        "startIndex": 19369,
        "preview": "\"Materialized Views\", \"Performance\"] filename: \"MaterializedOrderLens cs\" usingStatements: [\"System\", \"System Collections Generic\", \"System Linq\"] sho..."
      },
      {
        "id": "old-v1.0.0/core-concepts/lenses-chunk-10",
        "text": "read side of Whizbang's architecture: Read-only interfaces maintain clear separation of concerns Focused methods optimize for specific query needs Work consistently across Event-Driven and Event-Sourced modes Easy to test and mock Composable for complex query scenarios Lenses ensure that reading data is simple, efficient, and completely separate from writing data Next Steps\nExplore Receptors - How commands are processed\nLearn about Perspectives - How data is written\nSee Event-Driven Architecture - Complete architecture\nReview CQRS Implementation - Query patterns",
        "startIndex": 21792,
        "preview": "read side of Whizbang's architecture: Read-only interfaces maintain clear separation of concerns Focused methods optimize for specific query needs Wor..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/core-concepts/perspectives",
    "title": "Perspectives",
    "category": "Core Concepts",
    "url": "/docs/old-v1.0.0/core-concepts/perspectives",
    "chunks": [
      {
        "id": "old-v1.0.0/core-concepts/perspectives-chunk-0",
        "text": "Perspectives\nOverview\nPerspectives are the components that react to events and update various views of your data They handle all write operations in Whizbang, ensuring that state changes flow consistently from events to storage The same perspective code works in both Event-Driven and Event-Sourced modes, making them a key part of Whizbang's unified architecture What is a Perspective A Perspective:\nReacts to events emitted by receptors\nUpdates databases, caches, search indexes, and other stores\nMaintains different views of the same data\nExecutes all write operations in the system\nThink of perspectives as event handlers that maintain materialized views Each perspective provides a different \"perspective\" on the events flowing through your system The Core Interface\n`csharp{\ntitle: \"Core Perspective Interface\"\ndescription: \"The fundamental interface for all perspectives in Whizbang\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Perspectives\", \"Interface\", \"Events\"]\nfilename: \"IPerspectiveOf cs\"\nusingStatements: [\"System Threading Tasks\"]\nshowLineNumbers: true\n}\npublic interface IPerspectiveOf<TEvent> {\n    Task Update(TEvent @event);\n}\n`\nSimple, yet powerful - perspectives react to specific events and update their views accordingly How Perspectives Work\nIn Event-Driven Mode\nEvents flow directly from receptors to perspectives in the same transaction:\n`csharp{\ntitle: \"Event-Driven Mode Flow\"\ndescription: \"How events flow from receptors to perspectives in Event-Driven mode\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Event-Driven\", \"Receptors\"]\nfilename: \"OrderPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\n// Receptor emits event\npublic OrderCreated Receive(CreateOrder cmd) {\n    return new OrderCreated(Guid NewGuid(), cmd CustomerId);\n}\n// Perspective immediately updates database\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await db Orders Add(new Order { \n            Id = e OrderId,\n            CustomerId = e CustomerId \n        });\n        await db",
        "startIndex": 0,
        "preview": "Perspectives\nOverview\nPerspectives are the components that react to events and update various views of your data They handle all write operations in W..."
      },
      {
        "id": "old-v1.0.0/core-concepts/perspectives-chunk-1",
        "text": "// Receptor emits event public OrderCreated Receive(CreateOrder cmd) { return new OrderCreated(Guid NewGuid(), cmd CustomerId); } // Perspective immediately updates database public class OrderPerspective : IPerspectiveOf<OrderCreated> { public async Task Update(OrderCreated e) { await db Orders Add(new Order { Id = e OrderId, CustomerId = e CustomerId }); await db SaveChanges();  // Immediate write\n    }\n}\n`\nIn Event-Sourced Mode\nEvents are first persisted to the ledger, then perspectives update asynchronously:\n`csharp{\ntitle: \"Event-Sourced Mode Execution\"\ndescription: \"Same perspective code executed asynchronously from event stream\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Event-Sourced\", \"Asynchronous\"]\nfilename: \"OrderPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\n// Same perspective code, different execution model\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        // Exact same code, but executed async from event stream\n        await db Orders Add(new Order { \n            Id = e OrderId,\n            CustomerId = e CustomerId \n        });\n        await db SaveChanges();\n    }\n}\n`\nMultiple Perspectives Pattern\nDifferent perspectives provide different views of the same events:\n`csharp{\ntitle: \"Multiple Perspectives Pattern\"\ndescription: \"Different perspectives provide different views of the same events\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Multiple Views\", \"Data Projection\"]\nfilename: \"OrderPerspectives cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\n// Order list for display\npublic class OrderListPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await db OrderList Add(new OrderListItem {\n            Id = e OrderId,\n            CustomerName = await GetCustomerName(e CustomerId),\n            Total = e Total,\n            Status = \"New\",\n            CreatedAt = e Timestamp\n        });\n    }\n}\n// Customer statistics\npublic class CustomerStatsPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await db CustomerStats IncrementOrderCount(e CustomerId);\n        await db CustomerStats AddToTotalSpent(e CustomerId, e Total);\n        await db CustomerStats UpdateLastOrderDate(e CustomerId, e",
        "startIndex": 2197,
        "preview": "// Receptor emits event public OrderCreated Receive(CreateOrder cmd) { return new OrderCreated(Guid NewGuid(), cmd CustomerId); } // Perspective immed..."
      },
      {
        "id": "old-v1.0.0/core-concepts/perspectives-chunk-2",
        "text": "await GetCustomerName(e CustomerId), Total = e Total, Status = \"New\", CreatedAt = e Timestamp }); } } // Customer statistics public class CustomerStatsPerspective : IPerspectiveOf<OrderCreated> { public async Task Update(OrderCreated e) { await db CustomerStats IncrementOrderCount(e CustomerId); await db CustomerStats AddToTotalSpent(e CustomerId, e Total); await db CustomerStats UpdateLastOrderDate(e CustomerId, e Timestamp);\n    }\n}\n// Search index\npublic class SearchPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await searchIndex Index(new SearchDocument {\n            Id = e OrderId ToString(),\n            Type = \"order\",\n            CustomerId = e CustomerId,\n            Timestamp = e Timestamp,\n            Searchable = $\"Order {e OrderId} Customer {e CustomerId}\"\n        });\n    }\n}\n// Analytics/reporting\npublic class AnalyticsPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await analytics Track(\"OrderCreated\", new {\n            OrderId = e OrderId,\n            CustomerId = e CustomerId,\n            Total = e Total,\n            ItemCount = e Items Count\n        });\n    }\n}\n`\nComplex Perspective Patterns\nMulti-Event Perspectives\nPerspectives can handle multiple event types to maintain complex views:\n`csharp{\ntitle: \"Multi-Event Perspective\"\ndescription: \"Perspective handling multiple event types to maintain complex views\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"ADVANCED\"\ntags: [\"Perspectives\", \"Multi-Event\", \"Order Status\"]\nfilename: \"OrderStatusPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class OrderStatusPerspective : \n    IPerspectiveOf<OrderCreated>,\n    IPerspectiveOf<OrderPaid>,\n    IPerspectiveOf<OrderShipped>,\n    IPerspectiveOf<OrderCancelled> {\n    public async Task Update(OrderCreated e) {\n        await db OrderStatus Add(new OrderStatus {\n            OrderId = e OrderId,\n            Status = \"Created\",\n            UpdatedAt = e Timestamp\n        });\n    }\n    public async Task Update(OrderPaid e) {\n        await db OrderStatus UpdateStatus(e OrderId, \"Paid\", e Timestamp);\n        await db PaymentRecords Add(new PaymentRecord {\n            OrderId = e OrderId,\n            Amount = e Amount,\n            Method = e PaymentMethod\n        });\n    }\n    public async Task Update(OrderShipped e) {\n        await db OrderStatus UpdateStatus(e OrderId, \"Shipped\", e Timestamp);\n        await db ShippingRecords Add(new ShippingRecord {\n            OrderId = e OrderId,\n            Carrier = e Carrier,\n            TrackingNumber = e",
        "startIndex": 4332,
        "preview": "await GetCustomerName(e CustomerId), Total = e Total, Status = \"New\", CreatedAt = e Timestamp }); } } // Customer statistics public class CustomerStat..."
      },
      {
        "id": "old-v1.0.0/core-concepts/perspectives-chunk-3",
        "text": "db PaymentRecords Add(new PaymentRecord { OrderId = e OrderId, Amount = e Amount, Method = e PaymentMethod }); } public async Task Update(OrderShipped e) { await db OrderStatus UpdateStatus(e OrderId, \"Shipped\", e Timestamp); await db ShippingRecords Add(new ShippingRecord { OrderId = e OrderId, Carrier = e Carrier, TrackingNumber = e TrackingNumber\n        });\n    }\n    public async Task Update(OrderCancelled e) {\n        await db OrderStatus UpdateStatus(e OrderId, \"Cancelled\", e Timestamp);\n        await db CancellationReasons Add(new CancellationReason {\n            OrderId = e OrderId,\n            Reason = e Reason,\n            RefundAmount = e RefundAmount\n        });\n    }\n}\n`\nDenormalized Views\nPerspectives excel at maintaining denormalized views for query performance:\n`csharp{\ntitle: \"Denormalized Order Summary Perspective\"\ndescription: \"Perspective maintaining denormalized views with customer data for query performance\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"ADVANCED\"\ntags: [\"Perspectives\", \"Denormalization\", \"Performance\", \"Views\"]\nfilename: \"OrderSummaryPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class OrderSummaryPerspective : \n    IPerspectiveOf<OrderCreated>,\n    IPerspectiveOf<ItemAdded>,\n    IPerspectiveOf<ItemRemoved> {\n    public async Task Update(OrderCreated e) {\n        // Create denormalized summary\n        var customer = await customerService GetCustomer(e CustomerId);\n        await db OrderSummaries Add(new OrderSummary {\n            OrderId = e OrderId,\n            CustomerId = e CustomerId,\n            CustomerName = customer Name,\n            CustomerEmail = customer Email,\n            CustomerTier = customer Tier,\n            ItemCount = e Items Count,\n            TotalAmount = e Total,\n            CreatedAt = e Timestamp\n        });\n    }\n    public async Task Update(ItemAdded e) {\n        var summary = await db OrderSummaries Get(e OrderId);\n        summary ItemCount++;\n        summary TotalAmount = e NewTotal;\n        summary LastModified = e Timestamp;\n        await db OrderSummaries Update(summary);\n    }\n}\n`\nCache Invalidation\nPerspectives handle cache updates and invalidation:\n`csharp{\ntitle: \"Cache Management Perspective\"\ndescription: \"Perspective handling cache updates and invalidation patterns\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Caching\", \"Invalidation\", \"Performance\"]\nfilename: \"CachePerspective cs\"\nusingStatements: [\"System\", \"System Threading",
        "startIndex": 6581,
        "preview": "db PaymentRecords Add(new PaymentRecord { OrderId = e OrderId, Amount = e Amount, Method = e PaymentMethod }); } public async Task Update(OrderShipped..."
      },
      {
        "id": "old-v1.0.0/core-concepts/perspectives-chunk-4",
        "text": "= e Timestamp; await db OrderSummaries Update(summary); } } ` Cache Invalidation Perspectives handle cache updates and invalidation: `csharp{ title: \"Cache Management Perspective\" description: \"Perspective handling cache updates and invalidation patterns\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"INTERMEDIATE\" tags: [\"Perspectives\", \"Caching\", \"Invalidation\", \"Performance\"] filename: \"CachePerspective cs\" usingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class CachePerspective : \n    IPerspectiveOf<OrderCreated>,\n    IPerspectiveOf<OrderUpdated> {\n    private readonly ICache cache;\n    public async Task Update(OrderCreated e) {\n        // Invalidate customer's order list cache\n        await cache Remove($\"customer:{e CustomerId}:orders\");\n        // Pre-warm order cache\n        var order = new OrderCache {\n            Id = e OrderId,\n            CustomerId = e CustomerId,\n            Total = e Total\n        };\n        await cache Set($\"order:{e OrderId}\", order, TimeSpan FromHours(1));\n    }\n    public async Task Update(OrderUpdated e) {\n        // Invalidate all related caches\n        await cache Remove($\"order:{e OrderId}\");\n        await cache Remove($\"customer:{e CustomerId}:orders\");\n        await cache Remove(\"orders:recent\");\n    }\n}\n`\nPerspective Configuration\nConfigure perspectives behavior via the dispatcher:\n`csharp{\ntitle: \"Perspective Configuration\"\ndescription: \"Configuring perspective behavior via the dispatcher with buffering, concurrency, and error handling\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Configuration\", \"Dispatcher\", \"Performance\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nservices AddWhizbang() UseDispatcher(dispatcher => {\n        // Register all perspectives\n        dispatcher RegisterPerspectivesFromAssembly(typeof(Program) Assembly);\n        // Configure perspective execution\n        dispatcher Perspectives BufferSize(100)           // Buffer events for batch processing MaxConcurrency(10)         // Parallel perspective execution RetryPolicy(3, \"exponential\") ErrorHandling(ErrorStrategy DeadLetter);\n        // Specific perspective configuration\n        dispatcher ForPerspective<AnalyticsPerspective>() ExecuteAsync()             // Always async WithPriority(Priority Low);\n    });\n`\nBatch Processing\nPerspectives can process events in batches for efficiency:\n`csharp{\ntitle: \"Batched Processing Perspective\"\ndescription: \"Perspective processing multiple events in batches for improved efficiency\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"ADVANCED\"\ntags: [\"Perspectives\", \"Batching\", \"Performance\", \"Bulk Operations\"]\nfilename: \"BatchedPerspective cs\"\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq\", \"System Threading",
        "startIndex": 8818,
        "preview": "= e Timestamp; await db OrderSummaries Update(summary); } } ` Cache Invalidation Perspectives handle cache updates and invalidation: `csharp{ title: \"..."
      },
      {
        "id": "old-v1.0.0/core-concepts/perspectives-chunk-5",
        "text": "Batch Processing Perspectives can process events in batches for efficiency: `csharp{ title: \"Batched Processing Perspective\" description: \"Perspective processing multiple events in batches for improved efficiency\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"ADVANCED\" tags: [\"Perspectives\", \"Batching\", \"Performance\", \"Bulk Operations\"] filename: \"BatchedPerspective cs\" usingStatements: [\"System\", \"System Collections Generic\", \"System Linq\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class BatchedPerspective : IBatchPerspectiveOf<OrderCreated> {\n    public async Task UpdateBatch(IEnumerable<OrderCreated> events) {\n        // Process multiple events efficiently\n        var orders = events Select(e => new Order {\n            Id = e OrderId,\n            CustomerId = e CustomerId,\n            Total = e Total\n        }) ToList();\n        // Single database round-trip\n        await db Orders BulkInsert(orders);\n        // Batch cache update\n        var cacheUpdates = orders Select(o => \n            new CacheEntry($\"order:{o Id}\", o, TimeSpan FromHours(1))\n        );\n        await cache SetMany(cacheUpdates);\n    }\n}\n`\nIdempotent Perspectives\nEnsure perspectives are idempotent for reliability:\n`csharp{\ntitle: \"Idempotent Perspective Pattern\"\ndescription: \"Ensuring perspectives are idempotent for reliability and duplicate event handling\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Idempotency\", \"Reliability\", \"Error Handling\"]\nfilename: \"IdempotentOrderPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class IdempotentOrderPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        // Check if already processed\n        var exists = await db Orders Exists(e OrderId);\n        if (exists) {\n            return;  // Already processed, skip\n        }\n        // Process event\n        await db Orders Add(new Order {\n            Id = e OrderId,\n            CustomerId = e CustomerId,\n            ProcessedAt = DateTime UtcNow\n        });\n    }\n}\n`\nTesting Perspectives\nPerspectives are easy to test in isolation:\n`csharp{\ntitle: \"Testing Perspectives in Isolation\"\ndescription: \"Unit tests demonstrating how to test perspectives independently with mocked dependencies\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Testing\", \"Unit Tests\", \"Mocking\"]\nfilename: \"OrderPerspectiveTests cs\"\nusingStatements: [\"System\", \"System Threading",
        "startIndex": 11354,
        "preview": "Batch Processing Perspectives can process events in batches for efficiency: `csharp{ title: \"Batched Processing Perspective\" description: \"Perspective..."
      },
      {
        "id": "old-v1.0.0/core-concepts/perspectives-chunk-6",
        "text": "} } ` Testing Perspectives Perspectives are easy to test in isolation: `csharp{ title: \"Testing Perspectives in Isolation\" description: \"Unit tests demonstrating how to test perspectives independently with mocked dependencies\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"INTERMEDIATE\" tags: [\"Perspectives\", \"Testing\", \"Unit Tests\", \"Mocking\"] filename: \"OrderPerspectiveTests cs\" usingStatements: [\"System\", \"System Threading Tasks\", \"Xunit\", \"Whizbang\"]\nshowLineNumbers: true\n}\n[Fact]\npublic async Task OrderPerspective_CreatesOrder_WhenOrderCreatedEventReceived() {\n    // Arrange\n    var db = new InMemoryDatabase();\n    var perspective = new OrderPerspective(db);\n    var @event = new OrderCreated {\n        OrderId = Guid NewGuid(),\n        CustomerId = Guid NewGuid(),\n        Total = 100 00m\n    };\n    // Act\n    await perspective Update(@event);\n    // Assert\n    var order = await db Orders Get(@event OrderId);\n    Assert NotNull(order);\n    Assert Equal(@event CustomerId, order CustomerId);\n    Assert Equal(@event Total, order Total);\n}\n[Fact]\npublic async Task CachePerspective_InvalidatesCache_WhenOrderUpdated() {\n    // Arrange\n    var cache = new MockCache();\n    cache Set(\"order:123\", new Order());\n    var perspective = new CachePerspective(cache);\n    // Act\n    await perspective Update(new OrderUpdated { OrderId = Guid Parse(\"123\") });\n    // Assert\n    Assert False(await cache Exists(\"order:123\"));\n}\n`\nBest Practices\nDo's\n✅ Make perspectives idempotent\n`csharp{\ntitle: \"Idempotent Perspective Best Practice\"\ndescription: \"Using upsert operations to ensure perspectives can safely handle duplicate events\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Perspectives\", \"Best Practices\", \"Idempotency\"]\nfilename: \"IdempotentPerspective cs\"\nusingStatements: [\"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic async Task Update(OrderCreated e) {\n    await db Orders Upsert(e OrderId, order);  // Idempotent\n}\n`\n✅ Handle failures gracefully\n`csharp{\ntitle: \"Graceful Error Handling in Perspectives\"\ndescription: \"Implementing error handling and dead letter patterns for perspective failures\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Error Handling\", \"Dead Letter\", \"Resilience\"]\nfilename: \"ResilientPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic async Task Update(OrderCreated e) {\n    try {\n        await externalService Notify(e);\n    } catch (Exception ex) {\n        await deadLetter",
        "startIndex": 13466,
        "preview": "} } ` Testing Perspectives Perspectives are easy to test in isolation: `csharp{ title: \"Testing Perspectives in Isolation\" description: \"Unit tests de..."
      },
      {
        "id": "old-v1.0.0/core-concepts/perspectives-chunk-7",
        "text": "dead letter patterns for perspective failures\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"INTERMEDIATE\" tags: [\"Perspectives\", \"Error Handling\", \"Dead Letter\", \"Resilience\"] filename: \"ResilientPerspective cs\" usingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"] showLineNumbers: true } public async Task Update(OrderCreated e) { try { await externalService Notify(e); } catch (Exception ex) { await deadLetter Queue(e, ex);\n    }\n}\n`\n✅ Keep perspectives focused\n`csharp{\ntitle: \"Single Responsibility Perspectives\"\ndescription: \"Keeping perspectives focused on a single responsibility for maintainability\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Perspectives\", \"Single Responsibility\", \"Best Practices\"]\nfilename: \"FocusedPerspectives cs\"\nusingStatements: [\"Whizbang\"]\nshowLineNumbers: true\n}\n// Each perspective has a single responsibility\npublic class EmailPerspective : IPerspectiveOf<OrderCreated> { }\npublic class InventoryPerspective : IPerspectiveOf<OrderCreated> { }\n`\n✅ Use batching for performance\n`csharp{\ntitle: \"Batching for Performance\"\ndescription: \"Using batch operations to improve perspective performance with bulk database operations\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Batching\", \"Performance\", \"Best Practices\"]\nfilename: \"BatchPerspective cs\"\nusingStatements: [\"System Collections Generic\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic async Task UpdateBatch(IEnumerable<OrderCreated> events) {\n    await db BulkInsert(events);\n}\n`\nDon'ts\n❌ Don't emit events from perspectives\n`csharp{\ntitle: \"Anti-Pattern: Emitting Events from Perspectives\"\ndescription: \"What NOT to do - perspectives should react to events, not emit them\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Perspectives\", \"Anti-Patterns\", \"Best Practices\"]\nfilename: \"BadPerspective cs\"\nusingStatements: [\"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\n// BAD - Perspectives react, they don't decide\npublic async Task Update(OrderCreated e) {\n    await dispatcher Send(new SendEmail());  // Don't do this }\n`\n❌ Don't call other perspectives directly\n`csharp{\ntitle: \"Anti-Pattern: Direct Perspective Calls\"\ndescription: \"What NOT to do - let the dispatcher handle perspective coordination\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Perspectives\", \"Anti-Patterns\", \"Dispatcher\"]\nfilename: \"BadPerspectiveCoordination cs\"\nusingStatements: [\"System Threading",
        "startIndex": 15617,
        "preview": "dead letter patterns for perspective failures\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"INTERMEDIATE\" tags: [\"Perspectives\", \"Error Ha..."
      },
      {
        "id": "old-v1.0.0/core-concepts/perspectives-chunk-8",
        "text": "dispatcher Send(new SendEmail()); // Don't do this } ` ❌ Don't call other perspectives directly `csharp{ title: \"Anti-Pattern: Direct Perspective Calls\" description: \"What NOT to do - let the dispatcher handle perspective coordination\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"BEGINNER\" tags: [\"Perspectives\", \"Anti-Patterns\", \"Dispatcher\"] filename: \"BadPerspectiveCoordination cs\" usingStatements: [\"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\n// BAD - Let the dispatcher handle coordination\npublic async Task Update(OrderCreated e) {\n    await otherPerspective Update(e);  // Don't do this }\n`\n❌ Don't make business decisions\n`csharp{\ntitle: \"Anti-Pattern: Business Logic in Perspectives\"\ndescription: \"What NOT to do - business decisions belong in receptors, not perspectives\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Perspectives\", \"Anti-Patterns\", \"Business Logic\"]\nfilename: \"BadBusinessLogicPerspective cs\"\nusingStatements: [\"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\n// BAD - Business logic belongs in receptors\npublic async Task Update(OrderCreated e) {\n    if (e Total > 1000) {  // Business rule doesn't belong here\n        await db VipOrders Add(e);\n    }\n}\n`\nAdvanced Patterns\nTemporal Perspectives\nMaintain time-based views:\n`csharp{\ntitle: \"Temporal Statistics Perspective\"\ndescription: \"Maintaining time-based views with daily statistics and aggregations\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"ADVANCED\"\ntags: [\"Perspectives\", \"Temporal\", \"Statistics\", \"Aggregation\"]\nfilename: \"DailyStatsPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class DailyStatsPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        var date = e Timestamp Date;\n        await db DailyStats Increment(date, stats => {\n            stats OrderCount++;\n            stats TotalRevenue += e Total;\n            stats AverageOrderValue = stats TotalRevenue / stats OrderCount;\n        });\n    }\n}\n`\nGraph Perspectives\nUpdate graph databases or relationship stores:\n`csharp{\ntitle: \"Graph Database Perspective\"\ndescription: \"Updating graph databases and relationship stores from events\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"ADVANCED\"\ntags: [\"Perspectives\", \"Graph Database\", \"Relationships\", \"Neo4j\"]\nfilename: \"GraphPerspective cs\"\nusingStatements: [\"System\", \"System Threading",
        "startIndex": 17746,
        "preview": "dispatcher Send(new SendEmail()); // Don't do this } ` ❌ Don't call other perspectives directly `csharp{ title: \"Anti-Pattern: Direct Perspective Call..."
      },
      {
        "id": "old-v1.0.0/core-concepts/perspectives-chunk-9",
        "text": "TotalRevenue / stats OrderCount; }); } } ` Graph Perspectives Update graph databases or relationship stores: `csharp{ title: \"Graph Database Perspective\" description: \"Updating graph databases and relationship stores from events\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"ADVANCED\" tags: [\"Perspectives\", \"Graph Database\", \"Relationships\", \"Neo4j\"] filename: \"GraphPerspective cs\" usingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class GraphPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await graph CreateNode(\"Order\", e OrderId);\n        await graph CreateNode(\"Customer\", e CustomerId);\n        await graph CreateRelationship(\"PLACED_BY\", e OrderId, e CustomerId);\n        foreach (var item in e Items) {\n            await graph CreateRelationship(\"CONTAINS\", e OrderId, item ProductId);\n        }\n    }\n}\n`\nMachine Learning Perspectives\nFeed ML models or feature stores:\n`csharp{\ntitle: \"Machine Learning Feature Store Perspective\"\ndescription: \"Feeding ML models and feature stores with event data for customer analytics\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"ADVANCED\"\ntags: [\"Perspectives\", \"Machine Learning\", \"Feature Store\", \"Analytics\"]\nfilename: \"MLPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class MLPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await featureStore Update(\"customer_features\", e CustomerId, new {\n            LastOrderDate = e Timestamp,\n            OrderCount = await GetOrderCount(e CustomerId) + 1,\n            TotalSpent = await GetTotalSpent(e CustomerId) + e Total,\n            PreferredCategory = await DeterminePreferredCategory(e Items)\n        });\n        await mlPipeline TriggerRetrain(\"customer_segmentation\");\n    }\n}\n`\nSummary\nPerspectives are the write-side workhorses of Whizbang:\nReact to events and update various stores\nSame code works in Event-Driven and Event-Sourced modes\nMultiple perspectives provide different views of the same data\nIdempotent and resilient by design\nTestable in isolation\nPerspectives ensure that all state changes flow from events to storage in a consistent, maintainable way Next Steps\nLearn about Lenses - Read-only query interfaces\nExplore Receptors - Event producers\nSee Event-Driven Architecture - Complete picture\nReview Testing Strategies - Testing perspectives",
        "startIndex": 19809,
        "preview": "TotalRevenue / stats OrderCount; }); } } ` Graph Perspectives Update graph databases or relationship stores: `csharp{ title: \"Graph Database Perspecti..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/core-concepts/projections",
    "title": "Projections",
    "category": "Core Concepts",
    "url": "/docs/old-v1.0.0/core-concepts/projections",
    "chunks": [
      {
        "id": "old-v1.0.0/core-concepts/projections-chunk-0",
        "text": "Projections\nProjections are the read-side component of CQRS in Whizbang They create optimized, denormalized views of your data by subscribing to domain events and building read models tailored for specific query patterns What are Projections Projections transform events from the write-side (aggregates) into read models optimized for queries:\nEvent Subscribers: Listen to domain events as they occur\nRead Model Builders: Create denormalized views optimized for queries\nEventually Consistent: Updated asynchronously as events are processed\nRebuildable: Can be deleted and rebuilt from event history\nKey Benefits\nQuery Optimization\nDenormalized Data: Flatten complex relationships for fast reads\nIndexed Views: Create optimal indexes for specific query patterns\nMultiple Formats: Same events can feed different projection formats\nScalability\nIndependent Scaling: Scale read and write sides independently\nCaching Friendly: Read models can be heavily cached\nDistributed Reads: Replicate read models across regions\nFlexibility\nMultiple Projections: Create different views from same events\nTechnology Choice: Use different databases for different projections\nSchema Evolution: Add new projections without affecting writes\nHow Projections Work\n`mermaid\nsequenceDiagram\n    participant Aggregate\n    participant EventStore as Event Store\n    participant Projection\n    participant ReadDB as Read Database\n    participant Query as Query Handler\n    Aggregate->>EventStore: Save Events\n    EventStore->>Projection: Publish Events\n    Projection->>Projection: Process Events\n    Projection->>ReadDB: Update Read Model\n    Query->>ReadDB: Query Read Model\n    ReadDB->>Query: Return Results\n`\nExample Projection\n`csharp{\ntitle: \"Order Summary Projection\"\ndescription: \"Example projection that creates read models from domain events\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Read Models\", \"CQRS\", \"Order Summary\"]\nfilename: \"OrderSummaryProjection cs\"\nnugetPackages: [\"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class OrderSummaryProjection {\n    private readonly IProjectionStore<OrderSummary> _store;\n    public OrderSummaryProjection(IProjectionStore<OrderSummary> store) {\n        _store = store;\n    }\n    // Event handler - creates new read model\n    public async Task Handle(OrderPlacedEvent @event) {\n        await _store UpsertAsync(@event OrderId, new OrderSummary {\n            OrderId = @event OrderId,\n            CustomerId = @event",
        "startIndex": 0,
        "preview": "Projections\nProjections are the read-side component of CQRS in Whizbang They create optimized, denormalized views of your data by subscribing to domai..."
      },
      {
        "id": "old-v1.0.0/core-concepts/projections-chunk-1",
        "text": "Threading Tasks\", \"Whizbang\"] showLineNumbers: true } public class OrderSummaryProjection { private readonly IProjectionStore<OrderSummary> _store; public OrderSummaryProjection(IProjectionStore<OrderSummary> store) { _store = store; } // Event handler - creates new read model public async Task Handle(OrderPlacedEvent @event) { await _store UpsertAsync(@event OrderId, new OrderSummary { OrderId = @event OrderId, CustomerId = @event CustomerId,\n            Total = @event Total,\n            Status = \"Placed\",\n            PlacedAt = @event PlacedAt\n        });\n    }\n    // Event handler - updates existing read model\n    public async Task Handle(OrderShippedEvent @event) {\n        await _store UpdateAsync(@event OrderId, summary => {\n            summary Status = \"Shipped\";\n            summary ShippedAt = @event ShippedAt;\n            summary TrackingNumber = @event TrackingNumber;\n        });\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    public decimal Total { get; set; }\n    public string Status { get; set; }\n    public DateTime PlacedAt { get; set; }\n    public DateTime ShippedAt { get; set; }\n    public string TrackingNumber { get; set; }\n}\n`\nProjection Types\nSimple Projections\nSingle Entity: One event stream → One read model\nDirect Mapping: Events map directly to read model properties\nUse Case: Basic CRUD operations, simple reporting\nComposite Projections\nMultiple Streams: Events from multiple aggregates\nJoined Data: Combine data from different domains\nUse Case: Complex reports, dashboards, analytics\nCached Projections\nMemory-Based: Keep frequently accessed data in memory\nHigh Performance: Sub-millisecond query times\nUse Case: Real-time dashboards, autocomplete\nConfiguration\n`csharp{\ntitle: \"Projection Configuration\"\ndescription: \"Configuring projections with event subscriptions and backfilling\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Configuration\", \"Event Subscriptions\"]\nfilename: \"Program cs\"\nnugetPackages: [\"Whizbang Core\", \"Microsoft Extensions DependencyInjection\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nservices AddWhizbang(options => {\n    options UseProjections(proj => {\n        // Register projection\n        proj RegisterProjection<OrderSummaryProjection>(p => {\n            p Subscribe<OrderPlacedEvent>();\n            p Subscribe<OrderShippedEvent>();\n            p Subscribe<OrderCancelledEvent>();\n        });\n        // Configure backfilling\n        proj BackfillFromBeginning = true;\n        // Configure partitioning\n        proj",
        "startIndex": 2568,
        "preview": "Threading Tasks\", \"Whizbang\"] showLineNumbers: true } public class OrderSummaryProjection { private readonly IProjectionStore<OrderSummary> _store; pu..."
      },
      {
        "id": "old-v1.0.0/core-concepts/projections-chunk-2",
        "text": "filename: \"Program cs\" nugetPackages: [\"Whizbang Core\", \"Microsoft Extensions DependencyInjection\"] usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"] showLineNumbers: true } services AddWhizbang(options => { options UseProjections(proj => { // Register projection proj RegisterProjection<OrderSummaryProjection>(p => { p Subscribe<OrderPlacedEvent>(); p Subscribe<OrderShippedEvent>(); p Subscribe<OrderCancelledEvent>(); }); // Configure backfilling proj BackfillFromBeginning = true; // Configure partitioning proj PartitionBy = @event => ((dynamic)@event) OrderId;\n    });\n});\n`\nAdvanced Features\nBackfilling\nHistorical Data: Process events from before projection was created\nIncremental: Resume from last processed event\nParallel: Process multiple partitions concurrently\nEvent Filtering\nSelective Processing: Only process relevant events\nPattern Matching: Subscribe to events by type or properties\nPerformance: Reduce unnecessary processing\nSchema Evolution\nVersioning: Handle projection schema changes\nMigration: Update existing read models\nBackward Compatibility: Support multiple projection versions\nBest Practices\nDesign for Queries\nQuery-First: Design projections around actual query needs\nDenormalize: Include all data needed for queries\nIndex Appropriately: Add indexes for query patterns\nHandle Failures\nRetry Logic: Handle transient failures\nDead Letter Queues: Capture failed events\nMonitoring: Track projection health and lag\nPerformance Optimization\nBatch Processing: Process events in batches\nAsync Processing: Use async/await throughout\nConnection Pooling: Optimize database connections\nStorage Options\nWhizbang supports multiple projection storage backends:\nSQL Databases: Postgres, SQL Server, MySQL\nDocument Stores: MongoDB, CosmosDB\nSearch Engines: Elasticsearch, Azure Search\nKey-Value Stores: Redis, DynamoDB\nMemory: In-memory caching\nRelated Topics\nCore Concepts - Overview of CQRS and event sourcing\nProjection Subscriptions - Configuring event subscriptions\nProjection Contexts - Managing projection lifecycle\nGetting Started - Tutorial building your first projection\nNext Steps\nThis page provides an overview of projections in Whizbang For detailed implementation patterns and advanced scenarios, explore the specialized projection documentation in the Projections section",
        "startIndex": 4804,
        "preview": "filename: \"Program cs\" nugetPackages: [\"Whizbang Core\", \"Microsoft Extensions DependencyInjection\"] usingStatements: [\"Microsoft Extensions Dependency..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/core-concepts/receptors",
    "title": "Receptors",
    "category": "Core Concepts",
    "url": "/docs/old-v1.0.0/core-concepts/receptors",
    "chunks": [
      {
        "id": "old-v1.0.0/core-concepts/receptors-chunk-0",
        "text": "Receptors\nOverview\nReceptors are the decision-making components in Whizbang They receive commands, apply business rules, and emit events representing the decisions made The same receptor interface works in both Event-Driven (stateless) and Event-Sourced (stateful) modes, making them the cornerstone of Whizbang's progressive enhancement philosophy What is a Receptor A Receptor:\nReceives commands from external sources\nDecides what should happen based on business rules\nEmits events representing those decisions\nNever performs side effects directly\nThink of a receptor as a pure decision function: given a command and current state, what event(s) should occur The Universal Interface\n`csharp{\ntitle: \"Universal Receptor Interface\"\ndescription: \"The core interface that works for both Event-Driven and Event-Sourced modes\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Interface\", \"Universal\"]\nfilename: \"IReceptor cs\"\nusingStatements: [\"System\"]\nshowLineNumbers: true\n}\npublic interface IReceptor<TCommand> {\n    object Receive(TCommand command);\n}\n`\nThe return type determines what happens:\nSingle event → Published to perspectives\nMultiple events (tuple) → All published\nResult<TEvent> → Success/failure handling\nvoid → No events (rare)\nStateless Receptors (Event-Driven Mode)\nIn Event-Driven mode, receptors are stateless and get current state from Lenses:\n`csharp{\ntitle: \"Stateless Receptor with Lens\"\ndescription: \"Event-Driven mode receptor that gets state from lens parameters\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Receptors\", \"Stateless\", \"Event-Driven\", \"Lenses\"]\nfilename: \"OrderReceptor cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class OrderReceptor : IReceptor<CreateOrder> {\n    // Stateless - gets state from lens parameter\n    public OrderCreated Receive(CreateOrder cmd, IOrderLens lens) {\n        // Validate using lens (read-only)\n        var customer = lens GetCustomer(cmd CustomerId);\n        if ( customer IsActive) {\n            throw new InactiveCustomerException();\n        }\n        // Check inventory through lens\n        var inventory = lens GetInventory(cmd Items);\n        if ( inventory HasStock()) {\n            throw new OutOfStockException();\n        }\n        // Make decision and emit event\n        return new OrderCreated(\n            Guid NewGuid(),\n            cmd CustomerId,\n            cmd Items,\n            CalculateTotal(cmd Items),\n            DateTime",
        "startIndex": 0,
        "preview": "Receptors\nOverview\nReceptors are the decision-making components in Whizbang They receive commands, apply business rules, and emit events representing ..."
      },
      {
        "id": "old-v1.0.0/core-concepts/receptors-chunk-1",
        "text": "lens GetCustomer(cmd CustomerId); if ( customer IsActive) { throw new InactiveCustomerException(); } // Check inventory through lens var inventory = lens GetInventory(cmd Items); if ( inventory HasStock()) { throw new OutOfStockException(); } // Make decision and emit event return new OrderCreated( Guid NewGuid(), cmd CustomerId, cmd Items, CalculateTotal(cmd Items), DateTime UtcNow\n        );\n    }\n}\n`\nCharacteristics of Stateless Receptors\nGet state from Lens parameters\nCreated per request (transient lifetime)\nNo internal state between calls\nPerfect for simple CRUD operations\nStateful Receptors (Event-Sourced Mode)\nIn Event-Sourced mode, receptors maintain internal state rebuilt from events:\n`csharp{\ntitle: \"Stateful Event-Sourced Receptor\"\ndescription: \"Event-Sourced mode receptor with internal state maintained from events\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"ADVANCED\"\ntags: [\"Receptors\", \"Stateful\", \"Event-Sourced\", \"State Management\"]\nfilename: \"OrderReceptor cs\"\nnugetPackages: [\"Whizbang EventSourcing\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq\", \"Whizbang\"]\nshowLineNumbers: true\nhighlightLines: [1, 17, 29, 46]\n}\n[EventSourced]\npublic class OrderReceptor : \n    IReceptor<CreateOrder>,\n    IReceptor<AddItem>,\n    IReceptor<RemoveItem>,\n    IReceptor<ShipOrder> {\n    // Internal state maintained from events\n    private Guid id;\n    private Guid customerId;\n    private List<OrderItem> items = new();\n    private OrderStatus status;\n    private decimal total;\n    // Command handlers - no lens needed\n    public OrderCreated Receive(CreateOrder cmd) {\n        if (id = Guid Empty) {\n            throw new InvalidOperationException(\"Order already created\");\n        }\n        return new OrderCreated(\n            Guid NewGuid(),\n            cmd CustomerId,\n            cmd Items,\n            cmd Items Sum(i => i Quantity * i Price),\n            DateTime UtcNow\n        );\n    }\n    public ItemAdded Receive(AddItem cmd) {\n        if (status = OrderStatus Pending) {\n            throw new InvalidOperationException(\"Cannot modify shipped order\");\n        }\n        var newTotal = total + (cmd Quantity * cmd Price);\n        return new ItemAdded(id, cmd ProductId, cmd Quantity, cmd Price, newTotal);\n    }\n    public OrderShipped Receive(ShipOrder cmd) {\n        if (status = OrderStatus Paid) {\n            throw new InvalidOperationException(\"Order must be paid before shipping\");\n        }\n        return new OrderShipped(id, cmd TrackingNumber, DateTime",
        "startIndex": 2522,
        "preview": "lens GetCustomer(cmd CustomerId); if ( customer IsActive) { throw new InactiveCustomerException(); } // Check inventory through lens var inventory = l..."
      },
      {
        "id": "old-v1.0.0/core-concepts/receptors-chunk-2",
        "text": "shipped order\"); } var newTotal = total + (cmd Quantity * cmd Price); return new ItemAdded(id, cmd ProductId, cmd Quantity, cmd Price, newTotal); } public OrderShipped Receive(ShipOrder cmd) { if (status = OrderStatus Paid) { throw new InvalidOperationException(\"Order must be paid before shipping\"); } return new OrderShipped(id, cmd TrackingNumber, DateTime UtcNow);\n    }\n    // Event handlers - update internal state\n    public void Absorb(OrderCreated e) {\n        id = e OrderId;\n        customerId = e CustomerId;\n        items = e Items ToList();\n        total = e Total;\n        status = OrderStatus Pending;\n    }\n    public void Absorb(ItemAdded e) {\n        items Add(new OrderItem(e ProductId, e Quantity, e Price));\n        total = e NewTotal;\n    }\n    public void Absorb(OrderShipped e) {\n        status = OrderStatus Shipped;\n    }\n}\n`\nCharacteristics of Stateful Receptors\nMaintain internal state from event stream\nState rebuilt by replaying events\nLong-lived (cached between requests)\nPerfect for complex domain logic\nReturn Type Semantics\nWhat you return determines what happens:\n`csharp{\ntitle: \"Return Type Semantics\"\ndescription: \"Different return types control how events are published\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Receptors\", \"Return Types\", \"Events\"]\nfilename: \"PaymentReceptor cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class PaymentReceptor : IReceptor<ProcessPayment> {\n    // Single event - published to perspectives\n    public PaymentProcessed Receive(ProcessPayment cmd) {\n        return new PaymentProcessed(cmd OrderId, cmd Amount);\n    }\n    // Multiple events - all published\n    public (PaymentProcessed, EmailQueued, InventoryReserved) ReceiveWithEffects(ProcessPayment cmd) {\n        return (\n            new PaymentProcessed(cmd OrderId, cmd Amount),\n            new EmailQueued(cmd CustomerEmail, \"Payment received\"),\n            new InventoryReserved(cmd OrderId, cmd Items)\n        );\n    }\n    // Result type - success/failure handling\n    public Result<PaymentProcessed> ReceiveWithValidation(ProcessPayment cmd) {\n        if (cmd Amount <= 0) {\n            return Result Failure<PaymentProcessed>(\"Invalid amount\");\n        }\n        return Result Success(new PaymentProcessed(cmd OrderId, cmd",
        "startIndex": 4678,
        "preview": "shipped order\"); } var newTotal = total + (cmd Quantity * cmd Price); return new ItemAdded(id, cmd ProductId, cmd Quantity, cmd Price, newTotal); } pu..."
      },
      {
        "id": "old-v1.0.0/core-concepts/receptors-chunk-3",
        "text": "ReceiveWithEffects(ProcessPayment cmd) { return ( new PaymentProcessed(cmd OrderId, cmd Amount), new EmailQueued(cmd CustomerEmail, \"Payment received\"), new InventoryReserved(cmd OrderId, cmd Items) ); } // Result type - success/failure handling public Result<PaymentProcessed> ReceiveWithValidation(ProcessPayment cmd) { if (cmd Amount <= 0) { return Result Failure<PaymentProcessed>(\"Invalid amount\"); } return Result Success(new PaymentProcessed(cmd OrderId, cmd Amount));\n    }\n}\n`\nEvolution Pattern\nReceptors naturally evolve from stateless to stateful as complexity grows:\nStage 1: Simple Stateless\n`csharp{\ntitle: \"Evolution Stage 1: Simple Stateless\"\ndescription: \"Starting with a simple stateless receptor\"\nframework: \"NET8\"\ncategory: \"Evolution\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Evolution\", \"Simple\"]\nfilename: \"ProductReceptor cs\"\nusingStatements: [\"System\", \"Whizbang\"]\n}\npublic class ProductReceptor : IReceptor<CreateProduct> {\n    public ProductCreated Receive(CreateProduct cmd) {\n        return new ProductCreated(Guid NewGuid(), cmd Name, cmd Price);\n    }\n}\n`\nStage 2: Stateless with Validation\n`csharp{\ntitle: \"Evolution Stage 2: Stateless with Validation\"\ndescription: \"Adding validation using lens for state access\"\nframework: \"NET8\"\ncategory: \"Evolution\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Receptors\", \"Evolution\", \"Validation\", \"Lenses\"]\nfilename: \"ProductReceptor cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class ProductReceptor : IReceptor<CreateProduct> {\n    public ProductCreated Receive(CreateProduct cmd, IProductLens lens) {\n        if (lens Exists(p => p Name == cmd Name)) {\n            throw new DuplicateProductException();\n        }\n        return new ProductCreated(Guid NewGuid(), cmd Name, cmd Price);\n    }\n}\n`\nStage 3: Multiple Commands\n`csharp{\ntitle: \"Evolution Stage 3: Multiple Commands\"\ndescription: \"Multiple related commands suggesting need for state\"\nframework: \"NET8\"\ncategory: \"Evolution\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Receptors\", \"Evolution\", \"Multiple Commands\"]\nfilename: \"ProductReceptor cs\"\nusingStatements: [\"Whizbang\"]\n}\npublic class ProductReceptor : \n    IReceptor<CreateProduct>,\n    IReceptor<UpdatePrice>,\n    IReceptor<Discontinue> {\n    // Multiple related commands suggest need for state\n}\n`\nStage 4: Stateful (Event-Sourced)\n`csharp{\ntitle: \"Evolution Stage 4: Stateful Event-Sourced\"\ndescription: \"Final evolution to stateful receptor with internal state\"\nframework: \"NET8\"\ncategory: \"Evolution\"\ndifficulty: \"ADVANCED\"\ntags: [\"Receptors\", \"Evolution\", \"Event-Sourced\", \"Stateful\"]\nfilename: \"ProductReceptor cs\"\nnugetPackages: [\"Whizbang",
        "startIndex": 6641,
        "preview": "ReceiveWithEffects(ProcessPayment cmd) { return ( new PaymentProcessed(cmd OrderId, cmd Amount), new EmailQueued(cmd CustomerEmail, \"Payment received\"..."
      },
      {
        "id": "old-v1.0.0/core-concepts/receptors-chunk-4",
        "text": "IReceptor<CreateProduct>, IReceptor<UpdatePrice>, IReceptor<Discontinue> { // Multiple related commands suggest need for state } ` Stage 4: Stateful (Event-Sourced) `csharp{ title: \"Evolution Stage 4: Stateful Event-Sourced\" description: \"Final evolution to stateful receptor with internal state\" framework: \"NET8\" category: \"Evolution\" difficulty: \"ADVANCED\" tags: [\"Receptors\", \"Evolution\", \"Event-Sourced\", \"Stateful\"] filename: \"ProductReceptor cs\" nugetPackages: [\"Whizbang EventSourcing\"]\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\n[EventSourced]\npublic class ProductReceptor : \n    IReceptor<CreateProduct>,\n    IReceptor<UpdatePrice>,\n    IReceptor<Discontinue> {\n    private Guid id;\n    private decimal price;\n    private bool isDiscontinued;\n    // Now maintains state across commands\n}\n`\nReceptor Configuration\nConfigure receptors via policies:\n`csharp{\ntitle: \"Receptor Configuration\"\ndescription: \"Configuring receptors with policies and assembly scanning\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Receptors\", \"Configuration\", \"Policies\"]\nfilename: \"Program cs\"\nnugetPackages: [\"Whizbang Core\", \"Microsoft Extensions DependencyInjection\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\nservices AddWhizbang() UseDispatcher(dispatcher => {\n        // Register all receptors\n        dispatcher RegisterReceptorsFromAssembly(typeof(Program) Assembly);\n        // Configure specific receptors\n        dispatcher ForReceptor<OrderReceptor>() UsePolicy(new EventSourcedPolicy {\n                SnapshotFrequency = 100,\n                CacheDuration = TimeSpan FromMinutes(5)\n            });\n        dispatcher ForReceptor<NotificationReceptor>() UsePolicy(new EventDrivenPolicy {\n                MaxConcurrency = 10\n            });\n    });\n`\nBest Practices\nDo's\n✅ Keep receptors focused on decisions\n`csharp{\ntitle: \"Best Practice: Focus on Decisions\"\ndescription: \"Keep receptors focused on business logic and decisions\"\nframework: \"NET8\"\ncategory: \"Best Practices\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Best Practices\", \"Business Logic\"]\nfilename: \"OrderReceptor cs\"\nusingStatements: [\"Whizbang\"]\n}\npublic OrderCreated Receive(CreateOrder cmd) {\n    // Only business logic and decision making\n    return new OrderCreated( );\n}\n`\n✅ Use descriptive event names\n`csharp{\ntitle: \"Best Practice: Descriptive Event Names\"\ndescription: \"Use clear, descriptive names for events\"\nframework: \"NET8\"\ncategory: \"Best Practices\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Best Practices\", \"Event Naming\"]\nfilename: \"OrderReceptor cs\"\nusingStatements: [\"Whizbang\"]\n}\nreturn new OrderShipmentInitiated(",
        "startIndex": 8830,
        "preview": "IReceptor<CreateProduct>, IReceptor<UpdatePrice>, IReceptor<Discontinue> { // Multiple related commands suggest need for state } ` Stage 4: Stateful (..."
      },
      {
        "id": "old-v1.0.0/core-concepts/receptors-chunk-5",
        "text": "and decision making return new OrderCreated( ); } ` ✅ Use descriptive event names `csharp{ title: \"Best Practice: Descriptive Event Names\" description: \"Use clear, descriptive names for events\" framework: \"NET8\" category: \"Best Practices\" difficulty: \"BEGINNER\" tags: [\"Receptors\", \"Best Practices\", \"Event Naming\"] filename: \"OrderReceptor cs\" usingStatements: [\"Whizbang\"] } return new OrderShipmentInitiated( );  // Clear what happened\n`\n✅ Validate business rules\n`csharp{\ntitle: \"Best Practice: Validate Business Rules\"\ndescription: \"Enforce business rules with clear validation\"\nframework: \"NET8\"\ncategory: \"Best Practices\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Best Practices\", \"Validation\"]\nfilename: \"OrderReceptor cs\"\nusingStatements: [\"System\"]\n}\nif (status = OrderStatus Paid) {\n    throw new BusinessRuleViolationException(\"Order must be paid\");\n}\n`\n✅ Return events for all state changes\n`csharp{\ntitle: \"Best Practice: Return Events for State Changes\"\ndescription: \"Always return events for state changes\"\nframework: \"NET8\"\ncategory: \"Best Practices\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Best Practices\", \"Events\"]\nfilename: \"ProductReceptor cs\"\nusingStatements: [\"Whizbang\"]\n}\npublic PriceUpdated Receive(UpdatePrice cmd) {\n    return new PriceUpdated(id, oldPrice, cmd NewPrice);\n}\n`\nDon'ts\n❌ Don't perform side effects\n`csharp{\ntitle: \"Anti-Pattern: Side Effects\"\ndescription: \"DON'T perform side effects in receptors\"\nframework: \"NET8\"\ncategory: \"Anti-Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Anti-Patterns\", \"Side Effects\"]\nfilename: \"OrderReceptor cs\"\nusingStatements: [\"Whizbang\"]\n}\n// BAD - Side effect in receptor\npublic OrderCreated Receive(CreateOrder cmd) {\n    emailService SendEmail( );  // Don't do this database Save( );           // Don't do this return new OrderCreated( );\n}\n`\n❌ Don't mix read and write concerns\n`csharp{\ntitle: \"Anti-Pattern: Read/Write Mixing\"\ndescription: \"DON'T mix read and write concerns in receptors\"\nframework: \"NET8\"\ncategory: \"Anti-Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Anti-Patterns\", \"CQRS\"]\nfilename: \"OrderReceptor",
        "startIndex": 11111,
        "preview": "and decision making return new OrderCreated( ); } ` ✅ Use descriptive event names `csharp{ title: \"Best Practice: Descriptive Event Names\" description..."
      },
      {
        "id": "old-v1.0.0/core-concepts/receptors-chunk-6",
        "text": "// Don't do this database Save( ); // Don't do this return new OrderCreated( ); } ` ❌ Don't mix read and write concerns `csharp{ title: \"Anti-Pattern: Read/Write Mixing\" description: \"DON'T mix read and write concerns in receptors\" framework: \"NET8\" category: \"Anti-Patterns\" difficulty: \"BEGINNER\" tags: [\"Receptors\", \"Anti-Patterns\", \"CQRS\"] filename: \"OrderReceptor cs\"\nusingStatements: [\"Whizbang\"]\n}\n// BAD - Receptor shouldn't query\npublic OrderList Receive(GetOrders query) {  // Use Lens instead\n`\n❌ Don't mutate command parameters\n`csharp{\ntitle: \"Anti-Pattern: Mutating Commands\"\ndescription: \"DON'T mutate command parameters\"\nframework: \"NET8\"\ncategory: \"Anti-Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Anti-Patterns\", \"Immutability\"]\nfilename: \"OrderReceptor cs\"\nusingStatements: [\"System Collections Generic\"]\n}\n// BAD - Commands are immutable\ncmd Items Add(newItem);  // Don't modify `\nTesting Receptors\nReceptors are easy to test because they're pure decision functions:\n`csharp{\ntitle: \"Testing Receptors\"\ndescription: \"Unit testing receptors as pure decision functions\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Receptors\", \"Testing\", \"Unit Tests\"]\nfilename: \"OrderReceptorTests cs\"\nnugetPackages: [\"xunit\"]\ntestFile: \"OrderReceptorTests cs\"\ntestMethod: \"CreateOrder_ValidCommand_ReturnsOrderCreatedEvent\"\nusingStatements: [\"System\", \"Xunit\", \"Whizbang\"]\nshowLineNumbers: true\n}\n[Fact]\npublic void CreateOrder_ValidCommand_ReturnsOrderCreatedEvent() {\n    // Arrange\n    var receptor = new OrderReceptor();\n    var command = new CreateOrder {\n        CustomerId = Guid NewGuid(),\n        Items = new[] { new OrderItem(\"SKU-1\", 2, 10 00m) }\n    };\n    // Act\n    var @event = receptor Receive(command);\n    // Assert\n    Assert IsType<OrderCreated>(@event);\n    var orderCreated = (OrderCreated)@event;\n    Assert Equal(command CustomerId, orderCreated CustomerId);\n    Assert Equal(20 00m, orderCreated Total);\n}\n[Fact]\npublic void ShipOrder_UnpaidOrder_ThrowsException() {\n    // Arrange\n    var receptor = new OrderReceptor();\n    receptor Absorb(new OrderCreated( ));  // Not paid\n    // Act & Assert\n    Assert Throws<BusinessRuleViolationException>(\n        () => receptor Receive(new ShipOrder( ))\n    );\n}\n`\nAdvanced Patterns\nCompensating Events\n`csharp{\ntitle: \"Compensating Events Pattern\"\ndescription: \"Returning compensating events for complex operations\"\nframework: \"NET8\"\ncategory: \"Advanced\"\ndifficulty: \"ADVANCED\"\ntags: [\"Receptors\", \"Compensating Events\", \"Advanced\"]\nfilename: \"PaymentReceptor",
        "startIndex": 12836,
        "preview": "// Don't do this database Save( ); // Don't do this return new OrderCreated( ); } ` ❌ Don't mix read and write concerns `csharp{ title: \"Anti-Pattern:..."
      },
      {
        "id": "old-v1.0.0/core-concepts/receptors-chunk-7",
        "text": "Absorb(new OrderCreated( )); // Not paid // Act & Assert Assert Throws<BusinessRuleViolationException>( () => receptor Receive(new ShipOrder( )) ); } ` Advanced Patterns Compensating Events `csharp{ title: \"Compensating Events Pattern\" description: \"Returning compensating events for complex operations\" framework: \"NET8\" category: \"Advanced\" difficulty: \"ADVANCED\" tags: [\"Receptors\", \"Compensating Events\", \"Advanced\"] filename: \"PaymentReceptor cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class PaymentReceptor : IReceptor<RefundPayment> {\n    public (PaymentRefunded, InventoryReleased) Receive(RefundPayment cmd) {\n        if (status = PaymentStatus Completed) {\n            throw new InvalidOperationException(\"Can only refund completed payments\");\n        }\n        // Return compensating events\n        return (\n            new PaymentRefunded(id, amount, DateTime UtcNow),\n            new InventoryReleased(orderId, items)  // Compensate inventory\n        );\n    }\n}\n`\nConditional Events\n`csharp{\ntitle: \"Conditional Events Pattern\"\ndescription: \"Returning different events based on current state\"\nframework: \"NET8\"\ncategory: \"Advanced\"\ndifficulty: \"ADVANCED\"\ntags: [\"Receptors\", \"Conditional Events\", \"State-Based\"]\nfilename: \"OrderReceptor cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class OrderReceptor : IReceptor<CompleteOrder> {\n    public object Receive(CompleteOrder cmd) {\n        return status switch {\n            OrderStatus Pending => new OrderCompleted(id),\n            OrderStatus OnHold => (object)(\n                new OrderReleased(id),\n                new OrderCompleted(id)\n            ),\n            _ => throw new InvalidOperationException($\"Cannot complete order in {status} status\")\n        };\n    }\n}\n`\nSaga Initiation\n`csharp{\ntitle: \"Saga Initiation Pattern\"\ndescription: \"Starting distributed transactions with multiple events\"\nframework: \"NET8\"\ncategory: \"Advanced\"\ndifficulty: \"ADVANCED\"\ntags: [\"Receptors\", \"Sagas\", \"Distributed Transactions\"]\nfilename: \"CheckoutReceptor cs\"\nusingStatements: [\"Whizbang\"]\nshowLineNumbers: true\n}\npublic class CheckoutReceptor : IReceptor<Checkout> {\n    public (CheckoutStarted, ReserveInventory, ProcessPayment) Receive(Checkout cmd) {\n        // Start a distributed transaction\n        return (\n            new CheckoutStarted(cmd OrderId),\n            new ReserveInventory(cmd OrderId, cmd Items),\n            new ProcessPayment(cmd OrderId, cmd PaymentMethod, cmd",
        "startIndex": 15042,
        "preview": "Absorb(new OrderCreated( )); // Not paid // Act & Assert Assert Throws<BusinessRuleViolationException>( () => receptor Receive(new ShipOrder( )) ); } ..."
      },
      {
        "id": "old-v1.0.0/core-concepts/receptors-chunk-8",
        "text": "\"Advanced\" difficulty: \"ADVANCED\" tags: [\"Receptors\", \"Sagas\", \"Distributed Transactions\"] filename: \"CheckoutReceptor cs\" usingStatements: [\"Whizbang\"] showLineNumbers: true } public class CheckoutReceptor : IReceptor<Checkout> { public (CheckoutStarted, ReserveInventory, ProcessPayment) Receive(Checkout cmd) { // Start a distributed transaction return ( new CheckoutStarted(cmd OrderId), new ReserveInventory(cmd OrderId, cmd Items), new ProcessPayment(cmd OrderId, cmd PaymentMethod, cmd Total)\n        );\n    }\n}\n`\nSummary\nReceptors are the heart of Whizbang's decision-making:\nUniversal interface works in both Event-Driven and Event-Sourced modes\nPure functions that transform commands into events\nProgressive enhancement from stateless to stateful\nTestable without infrastructure dependencies\nComposable through return type semantics\nWhether stateless or stateful, receptors ensure your business logic remains clean, testable, and portable across different deployment modes Next Steps\nExplore Perspectives - How events update views\nLearn about Lenses - Read-only state access\nSee Event-Driven Architecture - The bigger picture\nReview Testing Strategies - Testing receptors",
        "startIndex": 17099,
        "preview": "\"Advanced\" difficulty: \"ADVANCED\" tags: [\"Receptors\", \"Sagas\", \"Distributed Transactions\"] filename: \"CheckoutReceptor cs\" usingStatements: [\"Whizbang..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/core-concepts/repositories-and-helpers",
    "title": "Repositories and CQRS Helpers",
    "category": "Core Concepts",
    "url": "/docs/old-v1.0.0/core-concepts/repositories-and-helpers",
    "chunks": [
      {
        "id": "old-v1.0.0/core-concepts/repositories-and-helpers-chunk-0",
        "text": "Repositories and CQRS Helpers\nWhizbang provides rich framework support for implementing CQRS patterns through repositories, query handlers, and helper classes that separate concerns across the write and read sides of your application Repository Patterns\nWrite-Side Repository (Aggregates)\nThe IRepository<TAggregate> interface handles loading and saving event-sourced aggregates:\n`csharp{\ntitle: \"Aggregate Repository Interface\"\ndescription: \"Core interface for aggregate persistence\"\nframework: \"NET8\"\ncategory: \"Repositories\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Repositories\", \"Aggregates\", \"Event Sourcing\"]\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nnamespace Whizbang EventSourcing;\npublic interface IRepository<TAggregate> where TAggregate : Aggregate {\n    /// <summary>\n    /// Loads an aggregate by replaying its event stream /// </summary>\n    Task<TAggregate > FindAsync(Guid id, CancellationToken ct = default);\n    /// <summary>\n    /// Loads an aggregate, throwing if not found /// </summary>\n    Task<TAggregate> GetAsync(Guid id, CancellationToken ct = default);\n    /// <summary>\n    /// Saves uncommitted events from the aggregate to the event store /// </summary>\n    Task SaveAsync(TAggregate aggregate, CancellationToken ct = default);\n    /// <summary>\n    /// Loads aggregate as of a specific version (point-in-time query) /// </summary>\n    Task<TAggregate > GetAsOfAsync(Guid id, long version, CancellationToken ct = default);\n    /// <summary>\n    /// Loads aggregate as of a specific timestamp (time-travel debugging) /// </summary>\n    Task<TAggregate > GetAsOfAsync(Guid id, DateTimeOffset timestamp, CancellationToken ct = default);\n}\n`\nUsage:\n`csharp{\ntitle: \"Using Aggregate Repository\"\ndescription: \"Load, modify, and save an aggregate\"\nframework: \"NET8\"\ncategory: \"Repositories\"\ndifficulty: \"BEGINNER\"\ntags: [\"Repositories\", \"Aggregates\", \"Commands\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\npublic class PlaceOrderHandler {\n    private readonly IRepository<Order> _orderRepository;\n    public PlaceOrderHandler(IRepository<Order> orderRepository) {\n        _orderRepository = orderRepository;\n    }\n    public async Task<OrderPlaced> Handle(PlaceOrder command) {\n        // Create new aggregate\n        var order = new Order(command CustomerId, command Items);\n        // Save (appends events to stream)\n        await _orderRepository SaveAsync(order);\n        return new OrderPlaced(order Id, command CustomerId, order",
        "startIndex": 0,
        "preview": "Repositories and CQRS Helpers\nWhizbang provides rich framework support for implementing CQRS patterns through repositories, query handlers, and helper..."
      },
      {
        "id": "old-v1.0.0/core-concepts/repositories-and-helpers-chunk-1",
        "text": "public class PlaceOrderHandler { private readonly IRepository<Order> _orderRepository; public PlaceOrderHandler(IRepository<Order> orderRepository) { _orderRepository = orderRepository; } public async Task<OrderPlaced> Handle(PlaceOrder command) { // Create new aggregate var order = new Order(command CustomerId, command Items); // Save (appends events to stream) await _orderRepository SaveAsync(order); return new OrderPlaced(order Id, command CustomerId, order Total);\n    }\n}\n`\nRead-Side Repository (Projections)\nThe IProjectionStore<TProjection> interface handles querying denormalized read models:\n`csharp{\ntitle: \"Projection Store Interface\"\ndescription: \"Interface for querying read models\"\nframework: \"NET8\"\ncategory: \"Repositories\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Queries\", \"CQRS\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\", \"System Linq Expressions\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Linq Expressions;\nusing System Threading Tasks;\nnamespace Whizbang Projections;\npublic interface IProjectionStore<TProjection> where TProjection : class {\n    /// <summary>\n    /// Gets a projection by ID /// </summary>\n    Task<TProjection > GetAsync(Guid id, CancellationToken ct = default);\n    /// <summary>\n    /// Queries projections using a predicate /// </summary>\n    Task<List<TProjection>> QueryAsync(\n        Expression<Func<TProjection, bool>> predicate,\n        CancellationToken ct = default\n    );\n    /// <summary>\n    /// Paged query for large result sets /// </summary>\n    Task<PagedResult<TProjection>> QueryPagedAsync(\n        Expression<Func<TProjection, bool>> predicate,\n        int page,\n        int pageSize,\n        CancellationToken ct = default\n    );\n    /// <summary>\n    /// Inserts or updates a projection /// </summary>\n    Task UpsertAsync(Guid id, TProjection projection, CancellationToken ct = default);\n    /// <summary>\n    /// Updates an existing projection /// </summary>\n    Task UpdateAsync(Guid id, Action<TProjection> update, CancellationToken ct = default);\n    /// <summary>\n    /// Deletes a projection /// </summary>\n    Task DeleteAsync(Guid id, CancellationToken ct = default);\n}\n`\nUsage:\n`csharp{\ntitle: \"Querying Projection Store\"\ndescription: \"Query read models for customer orders\"\nframework: \"NET8\"\ncategory: \"Repositories\"\ndifficulty: \"BEGINNER\"\ntags: [\"Projections\", \"Queries\", \"CQRS\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\", \"Whizbang Projections\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nusing Whizbang",
        "startIndex": 2668,
        "preview": "public class PlaceOrderHandler { private readonly IRepository<Order> _orderRepository; public PlaceOrderHandler(IRepository<Order> orderRepository) { ..."
      },
      {
        "id": "old-v1.0.0/core-concepts/repositories-and-helpers-chunk-2",
        "text": "} ` Usage: `csharp{ title: \"Querying Projection Store\" description: \"Query read models for customer orders\" framework: \"NET8\" category: \"Repositories\" difficulty: \"BEGINNER\" tags: [\"Projections\", \"Queries\", \"CQRS\"] usingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\", \"Whizbang Projections\"] showLineNumbers: true } using System; using System Collections Generic; using System Threading Tasks; using Whizbang Projections;\npublic class OrderQueryService {\n    private readonly IProjectionStore<OrderHistoryItem> _store;\n    public OrderQueryService(IProjectionStore<OrderHistoryItem> store) {\n        _store = store;\n    }\n    public async Task<List<OrderHistoryItem>> GetCustomerOrdersAsync(Guid customerId) {\n        return await _store QueryAsync(order => order CustomerId == customerId);\n    }\n    public async Task<PagedResult<OrderHistoryItem>> GetRecentOrdersAsync(int page, int pageSize) {\n        return await _store QueryPagedAsync(\n            order => order Status = \"Cancelled\",\n            page,\n            pageSize\n        );\n    }\n}\n`\nCQRS Helper Classes\nCommand Bus\nThe ICommandBus sends commands to their handlers:\n`csharp{\ntitle: \"Command Bus Interface\"\ndescription: \"Send commands and receive results\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"CQRS\", \"Messaging\"]\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nnamespace Whizbang;\npublic interface ICommandBus {\n    /// <summary>\n    /// Sends a command and waits for result /// </summary>\n    Task<TResult> SendAsync<TResult>(object command, CancellationToken ct = default);\n    /// <summary>\n    /// Sends a command without waiting for result (fire-and-forget) /// </summary>\n    Task PublishAsync(object command, CancellationToken ct = default);\n    /// <summary>\n    /// Sends multiple commands in a batch /// </summary>\n    Task PublishBatchAsync(IEnumerable<object> commands, CancellationToken ct = default);\n}\n`\nQuery Bus\nThe IQueryBus executes queries against projections:\n`csharp{\ntitle: \"Query Bus Interface\"\ndescription: \"Execute queries and return results\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Queries\", \"CQRS\", \"Projections\"]\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nnamespace Whizbang;\npublic interface IQueryBus {\n    /// <summary>\n    /// Executes a query and returns result",
        "startIndex": 4910,
        "preview": "} ` Usage: `csharp{ title: \"Querying Projection Store\" description: \"Query read models for customer orders\" framework: \"NET8\" category: \"Repositories\"..."
      },
      {
        "id": "old-v1.0.0/core-concepts/repositories-and-helpers-chunk-3",
        "text": "`csharp{ title: \"Query Bus Interface\" description: \"Execute queries and return results\" framework: \"NET8\" category: \"CQRS\" difficulty: \"INTERMEDIATE\" tags: [\"Queries\", \"CQRS\", \"Projections\"] usingStatements: [\"System\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading Tasks; namespace Whizbang; public interface IQueryBus { /// <summary> /// Executes a query and returns result /// </summary>\n    Task<TResult> QueryAsync<TResult>(object query, CancellationToken ct = default);\n}\n`\nUsage:\n`csharp{\ntitle: \"Using Query Bus\"\ndescription: \"Execute queries via query bus\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"BEGINNER\"\ntags: [\"Queries\", \"CQRS\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nusing Whizbang;\n// Define query\npublic record GetCustomerOrders(Guid CustomerId);\n// Define query handler\npublic class GetCustomerOrdersHandler {\n    private readonly IProjectionStore<OrderHistoryItem> _store;\n    public GetCustomerOrdersHandler(IProjectionStore<OrderHistoryItem> store) {\n        _store = store;\n    }\n    public async Task<List<OrderHistoryItem>> Handle(GetCustomerOrders query) {\n        return await _store QueryAsync(o => o CustomerId == query CustomerId);\n    }\n}\n// Execute query\npublic class OrderController {\n    private readonly IQueryBus _queryBus;\n    public OrderController(IQueryBus queryBus) {\n        _queryBus = queryBus;\n    }\n    public async Task<IActionResult> GetOrders(Guid customerId) {\n        var orders = await _queryBus QueryAsync<List<OrderHistoryItem>>(\n            new GetCustomerOrders(customerId)\n        );\n        return Ok(orders);\n    }\n}\n`\nEvent Publisher\nThe IEventPublisher publishes domain events to subscribers:\n`csharp{\ntitle: \"Event Publisher Interface\"\ndescription: \"Publish events to subscribers\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Events\", \"Publishing\", \"Messaging\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nnamespace Whizbang;\npublic interface IEventPublisher {\n    /// <summary>\n    /// Publishes a single event to all subscribers /// </summary>\n    Task PublishAsync(object @event, CancellationToken ct = default);\n    /// <summary>\n    /// Publishes multiple events in order /// </summary>\n    Task PublishBatchAsync(IEnumerable<object> events, CancellationToken ct = default);\n    /// <summary>\n    /// Publishes event to specific subscribers (filtered)",
        "startIndex": 7012,
        "preview": "`csharp{ title: \"Query Bus Interface\" description: \"Execute queries and return results\" framework: \"NET8\" category: \"CQRS\" difficulty: \"INTERMEDIATE\" ..."
      },
      {
        "id": "old-v1.0.0/core-concepts/repositories-and-helpers-chunk-4",
        "text": "Whizbang; public interface IEventPublisher { /// <summary> /// Publishes a single event to all subscribers /// </summary> Task PublishAsync(object @event, CancellationToken ct = default); /// <summary> /// Publishes multiple events in order /// </summary> Task PublishBatchAsync(IEnumerable<object> events, CancellationToken ct = default); /// <summary> /// Publishes event to specific subscribers (filtered) /// </summary>\n    Task PublishToAsync(object @event, string subscriberFilter, CancellationToken ct = default);\n}\n`\nSpecialized Helpers\nUnit of Work Pattern\nFor scenarios requiring transactional consistency across multiple aggregates:\n`csharp{\ntitle: \"Unit of Work Interface\"\ndescription: \"Transactional boundary for multiple aggregates\"\nframework: \"NET8\"\ncategory: \"Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Unit of Work\", \"Transactions\", \"Aggregates\"]\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nnamespace Whizbang EventSourcing;\npublic interface IUnitOfWork : IDisposable {\n    /// <summary>\n    /// Gets a repository for an aggregate type /// </summary>\n    IRepository<TAggregate> Repository<TAggregate>() where TAggregate : Aggregate;\n    /// <summary>\n    /// Commits all changes across all aggregates /// </summary>\n    Task CommitAsync(CancellationToken ct = default);\n    /// <summary>\n    /// Rolls back all changes /// </summary>\n    Task RollbackAsync(CancellationToken ct = default);\n}\n`\nUsage (use sparingly - violates aggregate boundaries):\n`csharp{\ntitle: \"Using Unit of Work\"\ndescription: \"Transactional update across multiple aggregates\"\nframework: \"NET8\"\ncategory: \"Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Unit of Work\", \"Transactions\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang EventSourcing\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang EventSourcing;\npublic class TransferInventoryHandler {\n    private readonly IUnitOfWork _unitOfWork;\n    public TransferInventoryHandler(IUnitOfWork unitOfWork) {\n        _unitOfWork = unitOfWork;\n    }\n    public async Task Handle(TransferInventory command) {\n        var sourceWarehouse = await _unitOfWork Repository<Warehouse>() GetAsync(command SourceWarehouseId);\n        var destWarehouse = await _unitOfWork Repository<Warehouse>() GetAsync(command DestinationWarehouseId);\n        // Both aggregates modified in same transaction\n        sourceWarehouse RemoveInventory(command ProductId, command Quantity);\n        destWarehouse AddInventory(command ProductId, command Quantity);\n        await _unitOfWork Repository<Warehouse>() SaveAsync(sourceWarehouse);\n        await _unitOfWork Repository<Warehouse>() SaveAsync(destWarehouse);\n        // Atomic commit\n        await _unitOfWork",
        "startIndex": 9302,
        "preview": "Whizbang; public interface IEventPublisher { /// <summary> /// Publishes a single event to all subscribers /// </summary> Task PublishAsync(object @ev..."
      },
      {
        "id": "old-v1.0.0/core-concepts/repositories-and-helpers-chunk-5",
        "text": "Task Handle(TransferInventory command) { var sourceWarehouse = await _unitOfWork Repository<Warehouse>() GetAsync(command SourceWarehouseId); var destWarehouse = await _unitOfWork Repository<Warehouse>() GetAsync(command DestinationWarehouseId); // Both aggregates modified in same transaction sourceWarehouse RemoveInventory(command ProductId, command Quantity); destWarehouse AddInventory(command ProductId, command Quantity); await _unitOfWork Repository<Warehouse>() SaveAsync(sourceWarehouse); await _unitOfWork Repository<Warehouse>() SaveAsync(destWarehouse); // Atomic commit await _unitOfWork CommitAsync();\n    }\n}\n`\nWarning: Use sagas instead when possible to maintain aggregate boundaries Specification Pattern\nFor complex query logic:\n`csharp{\ntitle: \"Specification Pattern\"\ndescription: \"Reusable query specifications\"\nframework: \"NET8\"\ncategory: \"Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Specification\", \"Queries\", \"Patterns\"]\nusingStatements: [\"System\", \"System Linq Expressions\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Linq Expressions;\nnamespace Whizbang Projections;\npublic interface ISpecification<TProjection> {\n    Expression<Func<TProjection, bool>> Predicate { get; }\n}\npublic class ActiveOrdersSpecification : ISpecification<OrderHistoryItem> {\n    public Expression<Func<OrderHistoryItem, bool>> Predicate =>\n        order => order Status = \"Cancelled\" && order Status = \"Delivered\";\n}\npublic class CustomerOrdersSpecification : ISpecification<OrderHistoryItem> {\n    private readonly Guid _customerId;\n    public CustomerOrdersSpecification(Guid customerId) {\n        _customerId = customerId;\n    }\n    public Expression<Func<OrderHistoryItem, bool>> Predicate =>\n        order => order CustomerId == _customerId;\n}\n`\nUsage:\n`csharp{\ntitle: \"Using Specifications\"\ndescription: \"Compose reusable query specifications\"\nframework: \"NET8\"\ncategory: \"Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Specification\", \"Queries\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\", \"Whizbang Projections\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nusing Whizbang Projections;\npublic class OrderQueryService {\n    private readonly IProjectionStore<OrderHistoryItem> _store;\n    public OrderQueryService(IProjectionStore<OrderHistoryItem> store) {\n        _store = store;\n    }\n    public async Task<List<OrderHistoryItem>> GetActiveCustomerOrdersAsync(Guid customerId) {\n        var spec = new ActiveOrdersSpecification() And(new CustomerOrdersSpecification(customerId));\n        return await _store QueryAsync(spec Predicate);\n    }\n}\n`\nProjection Builder\nHelper for building complex projections:\n`csharp{\ntitle: \"Projection Builder\"\ndescription: \"Fluent API for building projections\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Builder Pattern\"]\nusingStatements: [\"System\", \"Whizbang Projections\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang",
        "startIndex": 11761,
        "preview": "Task Handle(TransferInventory command) { var sourceWarehouse = await _unitOfWork Repository<Warehouse>() GetAsync(command SourceWarehouseId); var dest..."
      },
      {
        "id": "old-v1.0.0/core-concepts/repositories-and-helpers-chunk-6",
        "text": "new ActiveOrdersSpecification() And(new CustomerOrdersSpecification(customerId)); return await _store QueryAsync(spec Predicate); } } ` Projection Builder Helper for building complex projections: `csharp{ title: \"Projection Builder\" description: \"Fluent API for building projections\" framework: \"NET8\" category: \"Projections\" difficulty: \"ADVANCED\" tags: [\"Projections\", \"Builder Pattern\"] usingStatements: [\"System\", \"Whizbang Projections\"] showLineNumbers: true } using System; using Whizbang Projections;\npublic class OrderSummaryProjectionBuilder : ProjectionBuilder<OrderSummary> {\n    public OrderSummaryProjectionBuilder() {\n        // Subscribe to events\n        On<OrderPlaced>(@event => {\n            Upsert(@event OrderId, new OrderSummary {\n                OrderId = @event OrderId,\n                CustomerId = @event CustomerId,\n                Total = @event Total,\n                Status = \"Placed\"\n            });\n        });\n        On<OrderShipped>(@event => {\n            Update(@event OrderId, summary => {\n                summary Status = \"Shipped\";\n                summary ShippedAt = @event ShippedAt;\n            });\n        });\n        On<OrderCancelled>(@event => {\n            Update(@event OrderId, summary => summary Status = \"Cancelled\");\n        });\n    }\n}\n`\nMulti-Tenant Repository Support\nAll repository interfaces support tenant scoping:\n`csharp{\ntitle: \"Multi-Tenant Repository\"\ndescription: \"Tenant-scoped aggregate repository\"\nframework: \"NET8\"\ncategory: \"Multi-Tenancy\"\ndifficulty: \"ADVANCED\"\ntags: [\"Multi-Tenancy\", \"Repositories\", \"Security\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang EventSourcing\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang EventSourcing;\npublic interface ITenantRepository<TAggregate> where TAggregate : Aggregate {\n    /// <summary>\n    /// Loads aggregate for specific tenant /// </summary>\n    Task<TAggregate > FindAsync(Guid tenantId, Guid aggregateId, CancellationToken ct = default);\n    /// <summary>\n    /// Saves aggregate with tenant isolation /// Stream ID: \"Tenant-{tenantId}-Order-{orderId}\"\n    /// </summary>\n    Task SaveAsync(Guid tenantId, TAggregate aggregate, CancellationToken ct = default);\n}\n// Usage with tenant context\npublic class PlaceOrderHandler {\n    private readonly ITenantRepository<Order> _repository;\n    private readonly ITenantContext _tenantContext;\n    public PlaceOrderHandler(ITenantRepository<Order> repository, ITenantContext tenantContext) {\n        _repository = repository;\n        _tenantContext = tenantContext;\n    }\n    public async Task<OrderPlaced> Handle(PlaceOrder command) {\n        var order = new Order(command CustomerId, command Items);\n        // Tenant ID from context (claims, header, etc )\n        await _repository SaveAsync(_tenantContext TenantId, order);\n        return new OrderPlaced(order Id, command CustomerId, order",
        "startIndex": 14195,
        "preview": "new ActiveOrdersSpecification() And(new CustomerOrdersSpecification(customerId)); return await _store QueryAsync(spec Predicate); } } ` Projection Bui..."
      },
      {
        "id": "old-v1.0.0/core-concepts/repositories-and-helpers-chunk-7",
        "text": "ITenantContext _tenantContext; public PlaceOrderHandler(ITenantRepository<Order> repository, ITenantContext tenantContext) { _repository = repository; _tenantContext = tenantContext; } public async Task<OrderPlaced> Handle(PlaceOrder command) { var order = new Order(command CustomerId, command Items); // Tenant ID from context (claims, header, etc ) await _repository SaveAsync(_tenantContext TenantId, order); return new OrderPlaced(order Id, command CustomerId, order Total);\n    }\n}\n`\nPermission-Scoped Repositories\nRepositories can enforce permissions:\n`csharp{\ntitle: \"Permission-Scoped Repository\"\ndescription: \"Repository with built-in authorization\"\nframework: \"NET8\"\ncategory: \"Security\"\ndifficulty: \"ADVANCED\"\ntags: [\"Security\", \"Authorization\", \"Repositories\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang EventSourcing\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang EventSourcing;\npublic interface ISecureRepository<TAggregate> where TAggregate : Aggregate {\n    /// <summary>\n    /// Loads aggregate only if user has read permission /// </summary>\n    Task<TAggregate > FindAsync(Guid id, CancellationToken ct = default);\n    /// <summary>\n    /// Saves aggregate only if user has write permission /// Throws UnauthorizedAccessException if permission denied /// </summary>\n    Task SaveAsync(TAggregate aggregate, CancellationToken ct = default);\n}\n// Configuration\nservices AddWhizbang(options => {\n    options UseRepositories(repos => {\n        repos EnforcePermissions = true;\n        repos RequirePermission<Order>(\"orders:read\", \"orders:write\");\n        repos RequirePermission<Inventory>(\"inventory:read\", \"inventory:write\");\n    });\n});\n`\nNext Steps\nTesting - Test repositories and handlers\nMulti-Tenancy - Deep dive into tenant isolation\nSecurity - Authorization and authentication patterns",
        "startIndex": 16625,
        "preview": "ITenantContext _tenantContext; public PlaceOrderHandler(ITenantRepository<Order> repository, ITenantContext tenantContext) { _repository = repository;..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/core-concepts/return-type-semantics",
    "title": "Return Type Semantics",
    "category": "Core Concepts",
    "url": "/docs/old-v1.0.0/core-concepts/return-type-semantics",
    "chunks": [
      {
        "id": "old-v1.0.0/core-concepts/return-type-semantics-chunk-0",
        "text": "Return Type Semantics\nOverview\nIn Whizbang, what you return determines what happens next This simple yet powerful concept eliminates configuration and makes your code's intent crystal clear Inspired by Wolverine's approach but extended to cover all messaging patterns Core Philosophy\nTraditional messaging libraries require explicit configuration:\n`csharp\n---\ncategory: Core Concepts\ndifficulty: BEGINNER\ntags: [Traditional-Messaging, Configuration, Explicit-Calls]\ndescription: Traditional messaging approach with explicit method calls\n---\n// Traditional approach - configuration separate from logic\nawait bus Publish(event1);\nawait bus Send(command1);\nawait bus Reply(response1);\nawait bus Defer(message1, TimeSpan FromMinutes(5));\n`\nWhizbang's approach - return values drive behavior:\n`csharp\n---\ncategory: Core Concepts\ndifficulty: BEGINNER\ntags: [Return-Type-Semantics, Convention-Over-Configuration, Intent]\ndescription: Whizbang's return-based messaging with clear intent\n---\n// Whizbang - intent is clear from return type\nreturn event1;                                    // Publishes event\nreturn command1;                                  // Sends command  \nreturn response1;                                 // Replies to sender\nreturn message1 After(TimeSpan FromMinutes(5));  // Defers message\n`\nBasic Return Types\nSingle Message Return\n`csharp\n---\ncategory: Core Concepts\ndifficulty: BEGINNER\ntags: [Return-Type-Semantics, Single-Message, Event-Publishing]\ndescription: Single message return publishes event automatically\n---\npublic class OrderHandler : IHandle<CreateOrder> {\n    // Returning a single message publishes it as an event\n    public OrderCreated Handle(CreateOrder cmd) {\n        var order = CreateOrder(cmd);\n        return new OrderCreated(order Id, order Total);\n    }\n}\n`\nBehavior:\nIf return type implements IEvent → Publish to all subscribers\nIf return type implements ICommand → Send to single handler\nIf return type implements IResponse → Reply to original sender\nVoid Return (Fire-and-Forget)\n`csharp\n---\ncategory: Core Concepts\ndifficulty: BEGINNER\ntags: [Return-Type-Semantics, Void-Return, Fire-And-Forget]\ndescription: Void return for fire-and-forget operations\n---\npublic class NotificationHandler : IHandle<SendNotification> {\n    // Void means no follow-up messages\n    public void Handle(SendNotification cmd) {\n        Console WriteLine($\"Notification: {cmd",
        "startIndex": 0,
        "preview": "Return Type Semantics\nOverview\nIn Whizbang, what you return determines what happens next This simple yet powerful concept eliminates configuration and..."
      },
      {
        "id": "old-v1.0.0/core-concepts/return-type-semantics-chunk-1",
        "text": "return type implements IResponse → Reply to original sender Void Return (Fire-and-Forget) `csharp --- category: Core Concepts difficulty: BEGINNER tags: [Return-Type-Semantics, Void-Return, Fire-And-Forget] description: Void return for fire-and-forget operations --- public class NotificationHandler : IHandle<SendNotification> { // Void means no follow-up messages public void Handle(SendNotification cmd) { Console WriteLine($\"Notification: {cmd Message}\");\n        // No return = no cascading messages\n    }\n}\n`\nBehavior: Handler executes with no subsequent messages\nTask Return (Async Void)\n`csharp\n---\ncategory: Core Concepts\ndifficulty: BEGINNER\ntags: [Return-Type-Semantics, Async-Void, Task-Return]\ndescription: Async Task return for asynchronous fire-and-forget operations\n---\npublic class EmailHandler : IHandle<SendEmail> {\n    // Async with no result\n    public async Task Handle(SendEmail cmd) {\n        await emailService SendAsync(cmd To, cmd Subject, cmd Body);\n        // No return value = no cascading messages\n    }\n}\n`\nBehavior: Async execution with no follow-up messages\nAdvanced Return Types\nTuple Return (Multiple Effects)\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Tuple-Return, Multiple-Effects]\ndescription: Tuple return for multiple cascading messages\n---\npublic class OrderHandler : IHandle<CreateOrder> {\n    // Return multiple messages in one operation\n    public (OrderCreated, ProcessPayment, SendConfirmation) Handle(CreateOrder cmd) {\n        var order = CreateOrder(cmd);\n        return (\n            new OrderCreated(order Id, order Total),           // Publish event\n            new ProcessPayment(order Id, order Total),         // Send command\n            new SendConfirmation(order CustomerEmail, order Id) // Send command\n        );\n    }\n}\n`\nBehavior: All messages in tuple are processed according to their type\nResult Type (Railway-Oriented Programming)\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Result-Type, Railway-Oriented-Programming]\ndescription: Result type for success/failure handling with railway-oriented programming\n---\npublic class OrderHandler : IHandle<CreateOrder> {\n    // Result<T> for success/failure handling\n    public Result<OrderCreated> Handle(CreateOrder cmd) {\n        if ( IsValid(cmd)) {\n            return Result Failure<OrderCreated>(\"Invalid order data\");\n        }\n        var order = CreateOrder(cmd);\n        return Result Success(new OrderCreated(order",
        "startIndex": 2405,
        "preview": "return type implements IResponse → Reply to original sender Void Return (Fire-and-Forget) `csharp --- category: Core Concepts difficulty: BEGINNER tag..."
      },
      {
        "id": "old-v1.0.0/core-concepts/return-type-semantics-chunk-2",
        "text": "difficulty: INTERMEDIATE tags: [Return-Type-Semantics, Result-Type, Railway-Oriented-Programming] description: Result type for success/failure handling with railway-oriented programming --- public class OrderHandler : IHandle<CreateOrder> { // Result<T> for success/failure handling public Result<OrderCreated> Handle(CreateOrder cmd) { if ( IsValid(cmd)) { return Result Failure<OrderCreated>(\"Invalid order data\"); } var order = CreateOrder(cmd); return Result Success(new OrderCreated(order Id));\n    }\n}\n// Alternative with custom error type\npublic class PaymentHandler : IHandle<ProcessPayment> {\n    public Result<PaymentProcessed, PaymentError> Handle(ProcessPayment cmd) {\n        try {\n            var transaction = ProcessPayment(cmd);\n            return Result Success(new PaymentProcessed(transaction Id));\n        }\n        catch (InsufficientFundsException ex) {\n            return Result Failure(new PaymentError(\"Insufficient funds\", ex));\n        }\n    }\n}\n`\nBehavior:\nOn Success → Process success value\nOn Failure → Handle error (can trigger compensation)\nIAsyncEnumerable (Streaming Results)\n`csharp\n---\ncategory: Core Concepts\ndifficulty: ADVANCED\ntags: [Return-Type-Semantics, Streaming, IAsyncEnumerable, Yield]\ndescription: IAsyncEnumerable return for streaming results as they're processed\n---\npublic class BatchHandler : IHandle<ProcessBatch> {\n    // Stream results as they're processed\n    public async IAsyncEnumerable<OrderProcessed> Handle(ProcessBatch cmd) {\n        foreach (var item in cmd Items) {\n            await Task Delay(100); // Simulate processing\n            var result = ProcessItem(item);\n            yield return new OrderProcessed(result Id, result Status);\n            // Each yielded item is immediately published\n        }\n    }\n}\n`\nBehavior: Each yielded item is processed as it's produced (streaming)\nOption Type (Maybe Monad)\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Option-Type, Maybe-Monad, Null-Safety]\ndescription: Option type for queries that might return nothing\n---\npublic class QueryHandler : IHandle<GetOrder> {\n    // Option<T> for queries that might return nothing\n    public Option<Order> Handle(GetOrder query) {\n        var order = repository FindById(query OrderId);\n        return order = null Option Some(order)\n            : Option",
        "startIndex": 4484,
        "preview": "difficulty: INTERMEDIATE tags: [Return-Type-Semantics, Result-Type, Railway-Oriented-Programming] description: Result type for success/failure handlin..."
      },
      {
        "id": "old-v1.0.0/core-concepts/return-type-semantics-chunk-3",
        "text": "difficulty: INTERMEDIATE tags: [Return-Type-Semantics, Option-Type, Maybe-Monad, Null-Safety] description: Option type for queries that might return nothing --- public class QueryHandler : IHandle<GetOrder> { // Option<T> for queries that might return nothing public Option<Order> Handle(GetOrder query) { var order = repository FindById(query OrderId); return order = null Option Some(order) : Option None<Order>();\n    }\n}\n`\nBehavior:\nSome(value) → Process the value\nNone → Handle absence (no error)\nSpecialized Return Types\nDeferred Messages\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Deferred-Messages, Scheduling, Time-Based]\ndescription: Deferred message return for scheduled future delivery\n---\npublic class ReminderHandler : IHandle<ScheduleReminder> {\n    // Defer message with fluent syntax\n    public Deferred<SendReminder> Handle(ScheduleReminder cmd) {\n        return new SendReminder(cmd UserId, cmd Message) After(TimeSpan FromHours(24));\n    }\n    // Or with specific time\n    public Deferred<SendReminder> HandleAt(ScheduleReminder cmd) {\n        return new SendReminder(cmd UserId, cmd Message) At(DateTime UtcNow AddDays(1) Date AddHours(9)); // Tomorrow 9 AM\n    }\n}\n`\nBehavior: Message is scheduled for future delivery\nSaga Instructions\n`csharp\n---\ncategory: Core Concepts\ndifficulty: ADVANCED\ntags: [Return-Type-Semantics, Saga, Orchestration, Timeout-Handling]\ndescription: Saga action return for complex orchestration with timeout handling\n---\npublic class OrderSaga : Saga<OrderState> {\n    // Return saga instructions\n    public SagaAction Handle(OrderCreated @event) {\n        State OrderId = @event OrderId;\n        State Status = \"Created\";\n        return SagaAction Send(new ProcessPayment(@event OrderId, @event Total)) After(TimeSpan FromSeconds(5)) WithTimeout(TimeSpan FromMinutes(10)) OnTimeout(new CancelOrder(@event OrderId));\n    }\n}\n`\nBehavior: Complex saga orchestration with timeout handling\nBatched Returns\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Batch-Processing, Collections, LINQ]\ndescription: Collection return for batch message processing\n---\npublic class BatchHandler : IHandle<ProcessOrders> {\n    // Return collection of messages\n    public IEnumerable<IMessage> Handle(ProcessOrders cmd) {\n        var messages = new List<IMessage>();\n        foreach (var orderId in cmd OrderIds) {\n            messages Add(new ProcessOrder(orderId));\n            messages Add(new LogOrderProcessing(orderId));\n        }\n        return messages;\n    }\n    // Or with LINQ\n    public IEnumerable<ProcessOrder> HandleLinq(ProcessOrders cmd) {\n        return cmd OrderIds",
        "startIndex": 6359,
        "preview": "difficulty: INTERMEDIATE tags: [Return-Type-Semantics, Option-Type, Maybe-Monad, Null-Safety] description: Option type for queries that might return n..."
      },
      {
        "id": "old-v1.0.0/core-concepts/return-type-semantics-chunk-4",
        "text": "public class BatchHandler : IHandle<ProcessOrders> { // Return collection of messages public IEnumerable<IMessage> Handle(ProcessOrders cmd) { var messages = new List<IMessage>(); foreach (var orderId in cmd OrderIds) { messages Add(new ProcessOrder(orderId)); messages Add(new LogOrderProcessing(orderId)); } return messages; } // Or with LINQ public IEnumerable<ProcessOrder> HandleLinq(ProcessOrders cmd) { return cmd OrderIds Select(id => new ProcessOrder(id));\n    }\n}\n`\nBehavior: All messages in collection are processed\nConditional Returns\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Pattern-Matching, Conditional-Logic, Switch-Expressions]\ndescription: Conditional return using pattern matching and switch expressions\n---\npublic class ConditionalHandler : IHandle<ProcessOrder> {\n    // Use pattern matching for conditional returns\n    public IMessage Handle(ProcessOrder cmd) {\n        return cmd Priority switch {\n            Priority High => new ProcessImmediately(cmd OrderId),\n            Priority Normal => new ProcessOrder(cmd OrderId) After(\"5m\"),\n            Priority Low => new QueueForBatch(cmd OrderId),\n            _ => new LogUnknownPriority(cmd OrderId)\n        };\n    }\n}\n`\nBehavior: Different messages based on conditions\nComplex Return Patterns\nNested Tuples for Grouping\n`csharp\n---\ncategory: Core Concepts\ndifficulty: ADVANCED\ntags: [Return-Type-Semantics, Nested-Tuples, Message-Grouping, Complex-Returns]\ndescription: Nested tuples for grouping related messages logically\n---\npublic class ComplexHandler : IHandle<ComplexCommand> {\n    // Group related messages\n    public ((OrderCreated, InventoryReserved), (SendEmail, LogActivity)) Handle(ComplexCommand cmd) {\n        var order = CreateOrder(cmd);\n        var inventory = ReserveInventory(cmd);\n        return (\n            // Business events\n            (new OrderCreated(order Id), new InventoryReserved(inventory Id)),\n            // Side effects\n            (new SendEmail(cmd Email), new LogActivity(\"Order created\"))\n        );\n    }\n}\n`\nDiscriminated Unions\n`csharp\n---\ncategory: Core Concepts\ndifficulty: ADVANCED\ntags: [Return-Type-Semantics, Discriminated-Unions, OneOf, Outcome-Based-Returns]\ndescription: Discriminated union return for different outcomes\n---\npublic class PaymentHandler : IHandle<ProcessPayment> {\n    // Return different types based on outcome\n    public OneOf<PaymentSucceeded, PaymentFailed, PaymentPending> Handle(ProcessPayment cmd) {\n        var result = paymentGateway Process(cmd);\n        return result Status switch {\n            \"succeeded\" => new PaymentSucceeded(result TransactionId),\n            \"failed\" => new PaymentFailed(result ErrorCode),\n            \"pending\" => new PaymentPending(result PendingId),\n            _ => throw new UnknownPaymentStatus(result",
        "startIndex": 8738,
        "preview": "public class BatchHandler : IHandle<ProcessOrders> { // Return collection of messages public IEnumerable<IMessage> Handle(ProcessOrders cmd) { var mes..."
      },
      {
        "id": "old-v1.0.0/core-concepts/return-type-semantics-chunk-5",
        "text": "public class PaymentHandler : IHandle<ProcessPayment> { // Return different types based on outcome public OneOf<PaymentSucceeded, PaymentFailed, PaymentPending> Handle(ProcessPayment cmd) { var result = paymentGateway Process(cmd); return result Status switch { \"succeeded\" => new PaymentSucceeded(result TransactionId), \"failed\" => new PaymentFailed(result ErrorCode), \"pending\" => new PaymentPending(result PendingId), _ => throw new UnknownPaymentStatus(result Status)\n        };\n    }\n}\n`\nRecursive Returns\n`csharp\n---\ncategory: Core Concepts\ndifficulty: ADVANCED\ntags: [Return-Type-Semantics, Recursive-Processing, Tree-Structures]\ndescription: Recursive handler return for tree/graph processing\n---\npublic class RecursiveHandler : IHandle<ProcessNode> {\n    // Return can trigger same handler recursively\n    public IEnumerable<ProcessNode> Handle(ProcessNode cmd) {\n        ProcessCurrentNode(cmd);\n        // Return child nodes for recursive processing\n        return cmd Children Select(child => new ProcessNode(child));\n    }\n}\n`\nReturn Type Metadata\nPriority and Headers\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Message-Metadata, Priority, Headers]\ndescription: Message with metadata for priority and header configuration\n---\npublic class PriorityHandler : IHandle<CreateOrder> {\n    public MessageWithMetadata<OrderCreated> Handle(CreateOrder cmd) {\n        var order = CreateOrder(cmd);\n        return new OrderCreated(order Id) WithPriority(MessagePriority High) WithHeader(\"CustomerId\", cmd CustomerId) WithHeader(\"Source\", \"WebAPI\") WithCorrelationId(cmd CorrelationId);\n    }\n}\n`\nRouting Instructions\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Message-Routing, Regional-Routing, Queue-Selection]\ndescription: Routed message return for regional queue selection\n---\npublic class RoutingHandler : IHandle<RouteOrder> {\n    public RoutedMessage Handle(RouteOrder cmd) {\n        return new ProcessOrder(cmd OrderId) RouteTo(cmd Region switch {\n                \"US\" => \"us-queue\",\n                \"EU\" => \"eu-queue\",\n                \"ASIA\" => \"asia-queue\",\n                _ => \"global-queue\"\n            }) WithRoutingKey($\"orders {cmd Priority} {cmd",
        "startIndex": 11146,
        "preview": "public class PaymentHandler : IHandle<ProcessPayment> { // Return different types based on outcome public OneOf<PaymentSucceeded, PaymentFailed, Payme..."
      },
      {
        "id": "old-v1.0.0/core-concepts/return-type-semantics-chunk-6",
        "text": "tags: [Return-Type-Semantics, Message-Routing, Regional-Routing, Queue-Selection] description: Routed message return for regional queue selection --- public class RoutingHandler : IHandle<RouteOrder> { public RoutedMessage Handle(RouteOrder cmd) { return new ProcessOrder(cmd OrderId) RouteTo(cmd Region switch { \"US\" => \"us-queue\", \"EU\" => \"eu-queue\", \"ASIA\" => \"asia-queue\", _ => \"global-queue\" }) WithRoutingKey($\"orders {cmd Priority} {cmd Region}\");\n    }\n}\n`\nCompile-Time Verification\nReturn Type Validation\n`csharp\n---\ncategory: Core Concepts\ndifficulty: ADVANCED\ntags: [Return-Type-Semantics, Compile-Time-Validation, Pure-Functions]\ndescription: Compile-time validation of return types and pure function constraints\n---\n// Source generator validates return types\npublic class InvalidHandler : IHandle<CreateOrder> {\n    // ❌ Compile error: Handler must return a message type\n    public string Handle(CreateOrder cmd) {\n        return \"This won't compile\";\n    }\n}\n[Pure]\npublic class PureHandler : IHandle<Calculate> {\n    // ❌ Compile error: Pure handlers cannot return commands\n    public SendEmail Handle(Calculate cmd) {\n        return new SendEmail(); // Side effect not allowed\n    }\n    // ✅ Valid: Pure handlers can return events\n    public Calculated Handle(Calculate cmd) {\n        return new Calculated(cmd A + cmd B);\n    }\n}\n`\nEffect Tracking\n`csharp\n---\ncategory: Core Concepts\ndifficulty: ADVANCED\ntags: [Return-Type-Semantics, Effect-Tracking, Compile-Time-Validation]\ndescription: Effect tracking validation of return types against declared effects\n---\n[Effects(Publishes = \"OrderEvents\")]\npublic class TrackedHandler : IHandle<CreateOrder> {\n    // ✅ Valid: Return type matches declared effects\n    public OrderCreated Handle(CreateOrder cmd) {\n        return new OrderCreated();\n    }\n    // ❌ Compile error: PaymentProcessed not in declared effects\n    public PaymentProcessed HandlePayment(ProcessPayment cmd) {\n        return new PaymentProcessed();\n    }\n}\n`\nPerformance Optimizations\nStack-Allocated Returns\n`csharp\n// Small structs are stack-allocated for performance\npublic readonly struct LightweightEvent : IEvent {\n    public readonly Guid Id;\n    public readonly DateTime Timestamp;\n    public LightweightEvent(Guid id) {\n        Id = id;\n        Timestamp = DateTime UtcNow;\n    }\n}\npublic class PerformantHandler : IHandle<QuickCommand> {\n    // Returns struct without heap allocation\n    public LightweightEvent Handle(QuickCommand cmd) {\n        return new LightweightEvent(cmd",
        "startIndex": 13021,
        "preview": "tags: [Return-Type-Semantics, Message-Routing, Regional-Routing, Queue-Selection] description: Routed message return for regional queue selection --- ..."
      },
      {
        "id": "old-v1.0.0/core-concepts/return-type-semantics-chunk-7",
        "text": "for performance public readonly struct LightweightEvent : IEvent { public readonly Guid Id; public readonly DateTime Timestamp; public LightweightEvent(Guid id) { Id = id; Timestamp = DateTime UtcNow; } } public class PerformantHandler : IHandle<QuickCommand> { // Returns struct without heap allocation public LightweightEvent Handle(QuickCommand cmd) { return new LightweightEvent(cmd Id);\n    }\n}\n`\nPooled Returns\n`csharp\n[PooledReturns] // Source generator creates pooling\npublic class PooledHandler : IHandle<FrequentCommand> {\n    public FrequentEvent Handle(FrequentCommand cmd) {\n        // Return value is automatically pooled and reused\n        return new FrequentEvent { Id = cmd Id };\n    }\n}\n`\nTesting Return Types\n`csharp\n[Test]\npublic async Task Handler_ReturnsCorrectMessageTypes() {\n    // Given\n    var handler = new OrderHandler();\n    var command = new CreateOrder { };\n    // When\n    var result = handler Handle(command);\n    // Then - Verify return types\n    result Should() BeOfType<(OrderCreated, ProcessPayment, SendEmail)>() Which Should() Satisfy(\n            r => r Item1 OrderId == command OrderId,\n            r => r Item2 Amount == command Total,\n            r => r Item3 Recipient == command CustomerEmail\n        );\n}\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Testing, Streaming, IAsyncEnumerable]\ndescription: Testing streaming return values with IAsyncEnumerable\n---\n[Test]\npublic async Task Handler_StreamingReturn_YieldsAllItems() {\n    var handler = new BatchHandler();\n    var items = new[] { item1, item2, item3 };\n    var results = await handler Handle(new ProcessBatch { Items = items }) ToListAsync();\n    results Should() HaveCount(3);\n    results Should()",
        "startIndex": 15098,
        "preview": "for performance public readonly struct LightweightEvent : IEvent { public readonly Guid Id; public readonly DateTime Timestamp; public LightweightEven..."
      },
      {
        "id": "old-v1.0.0/core-concepts/return-type-semantics-chunk-8",
        "text": "[Return-Type-Semantics, Testing, Streaming, IAsyncEnumerable] description: Testing streaming return values with IAsyncEnumerable --- [Test] public async Task Handler_StreamingReturn_YieldsAllItems() { var handler = new BatchHandler(); var items = new[] { item1, item2, item3 }; var results = await handler Handle(new ProcessBatch { Items = items }) ToListAsync(); results Should() HaveCount(3); results Should() AllBeOfType<OrderProcessed>();\n}\n`\nBest Practices\nDo's\n✅ Use specific return types for clarity\n`csharp\n---\ncategory: Core Concepts\ndifficulty: BEGINNER\ntags: [Return-Type-Semantics, Best-Practices, Clear-Intent]\ndescription: Using specific return types for clarity\n---\npublic OrderCreated Handle(CreateOrder cmd)  // Clear intent\n`\n✅ Leverage tuples for related messages\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Best-Practices, Tuple-Returns]\ndescription: Leveraging tuples for related messages\n---\npublic (OrderCreated, SendEmail) Handle(CreateOrder cmd)\n`\n✅ Use Result<T> for fallible operations\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Best-Practices, Result-Type, Error-Handling]\ndescription: Using Result<T> for fallible operations\n---\npublic Result<PaymentProcessed> Handle(ProcessPayment cmd)\n`\n✅ Stream large result sets\n`csharp\n---\ncategory: Core Concepts\ndifficulty: ADVANCED\ntags: [Return-Type-Semantics, Best-Practices, Streaming, Large-Results]\ndescription: Streaming large result sets with IAsyncEnumerable\n---\npublic async IAsyncEnumerable<Result> Handle(LargeQuery query)\n`\nDon'ts\n❌ Don't use generic object returns\n`csharp\n---\ncategory: Core Concepts\ndifficulty: BEGINNER\ntags: [Return-Type-Semantics, Anti-Patterns, Type-Safety]\ndescription: Anti-pattern - using generic object returns loses type safety\n---\npublic object Handle(Command cmd)  // Loses type safety\n`\n❌ Don't mix unrelated messages in tuples\n`csharp\n---\ncategory: Core Concepts\ndifficulty: BEGINNER\ntags: [Return-Type-Semantics, Anti-Patterns, Unrelated-Messages]\ndescription: Anti-pattern - mixing unrelated messages in tuples\n---\npublic (OrderCreated, UnrelatedUserLogout) Handle(CreateOrder cmd)\n`\n❌ Don't ignore return values in tests\n`csharp\n---\ncategory: Core Concepts\ndifficulty: BEGINNER\ntags: [Return-Type-Semantics, Anti-Patterns, Testing, Ignored-Returns]\ndescription: Anti-pattern - ignoring return values in tests\n---\nhandler",
        "startIndex": 16502,
        "preview": "[Return-Type-Semantics, Testing, Streaming, IAsyncEnumerable] description: Testing streaming return values with IAsyncEnumerable --- [Test] public asy..."
      },
      {
        "id": "old-v1.0.0/core-concepts/return-type-semantics-chunk-9",
        "text": "difficulty: BEGINNER tags: [Return-Type-Semantics, Anti-Patterns, Unrelated-Messages] description: Anti-pattern - mixing unrelated messages in tuples --- public (OrderCreated, UnrelatedUserLogout) Handle(CreateOrder cmd) ` ❌ Don't ignore return values in tests `csharp --- category: Core Concepts difficulty: BEGINNER tags: [Return-Type-Semantics, Anti-Patterns, Testing, Ignored-Returns] description: Anti-pattern - ignoring return values in tests --- handler Handle(cmd);  // Should verify return value\n`\nSummary\nReturn type semantics in Whizbang provide:\nClear intent from method signatures\nZero configuration message routing\nType safety with compile-time verification\nFlexibility through various return patterns\nPerformance with optimized return handling\nThis approach makes your handlers self-documenting and eliminates the impedance mismatch between your domain logic and messaging infrastructure Next Steps\nExplore Policy Composition for resilience\nLearn about Aspect-Oriented Handlers\nSee Progressive Enhancement patterns\nReview Testing Strategies",
        "startIndex": 18524,
        "preview": "difficulty: BEGINNER tags: [Return-Type-Semantics, Anti-Patterns, Unrelated-Messages] description: Anti-pattern - mixing unrelated messages in tuples ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/examples/enhanced-csharp-examples",
    "title": "C# Code Examples",
    "category": "Examples",
    "url": "/docs/old-v1.0.0/examples/enhanced-csharp-examples",
    "chunks": [
      {
        "id": "old-v1.0.0/examples/enhanced-csharp-examples-chunk-0",
        "text": "CCode Examples\nThis document demonstrates comprehensive Ccode examples with rich metadata, interactive features, and professional styling Basic Examples\nSimple Console Application\n`csharp{\ntitle: \"Hello World Console App\"\ndescription: \"A simple console application demonstrating basic Csyntax\"\nframework: \"NET8\"\ndifficulty: \"BEGINNER\"\nfilename: \"Program cs\"\n}\nusing System;\nnamespace HelloWorld {\n    class Program {\n        static void Main(string[] args) {\n            Console WriteLine(\"Hello, World \");\n            Console WriteLine(\"Welcome to enhanced Ccode viewing \");\n            var message = GetWelcomeMessage(\"Developer\");\n            Console WriteLine(message);\n        }\n        static string GetWelcomeMessage(string name) {\n            return $\"Hello, {name} Today is {DateTime Now:yyyy-MM-dd}\";\n        }\n    }\n}\n`\nBasic Class Example\n`csharp{\ntitle: \"Person Class\"\ndescription: \"Simple class with properties and methods\"\ncategory: \"ENTITY\"\ndifficulty: \"BEGINNER\"\ntags: [\"Class\", \"Properties\", \"Methods\"]\nfilename: \"Person cs\"\n}\npublic class Person {\n    public string Name { get; set; }\n    public int Age { get; set; }\n    public string Email { get; set; }\n    public Person(string name, int age, string email) {\n        Name = name;\n        Age = age;\n        Email = email;\n    }\n    public void DisplayInfo() {\n        Console WriteLine($\"Name: {Name}\");\n        Console WriteLine($\"Age: {Age}\");\n        Console WriteLine($\"Email: {Email}\");\n    }\n    public bool IsAdult() {\n        return Age >= 18;\n    }\n}\n`\nNuGet Package Example\n`csharp{\ntitle: \"JSON Serialization Example\"\ndescription: \"Using Newtonsoft Json for JSON operations\"\nframework: \"NET8\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"JSON\", \"Serialization\", \"NuGet\"]\nnugetPackages: [\"Newtonsoft Json\"]\nfilename: \"JsonExample cs\"\n}\nusing Newtonsoft Json;\nusing System Collections Generic;\npublic class JsonExample {\n    public void SerializeExample() {\n        var person = new Person(\"John Doe\", 30, \"john@example com\");\n        // Serialize to JSON\n        string json = JsonConvert SerializeObject(person, Formatting Indented);\n        Console WriteLine(\"Serialized JSON:\");\n        Console WriteLine(json);\n        // Deserialize from JSON\n        var deserializedPerson = JsonConvert DeserializeObject<Person>(json);\n        Console WriteLine(\"\\nDeserialized object:\");\n        deserializedPerson",
        "startIndex": 0,
        "preview": "CCode Examples\nThis document demonstrates comprehensive Ccode examples with rich metadata, interactive features, and professional styling Basic Exampl..."
      },
      {
        "id": "old-v1.0.0/examples/enhanced-csharp-examples-chunk-1",
        "text": "using System Collections Generic; public class JsonExample { public void SerializeExample() { var person = new Person(\"John Doe\", 30, \"john@example com\"); // Serialize to JSON string json = JsonConvert SerializeObject(person, Formatting Indented); Console WriteLine(\"Serialized JSON:\"); Console WriteLine(json); // Deserialize from JSON var deserializedPerson = JsonConvert DeserializeObject<Person>(json); Console WriteLine(\"\\nDeserialized object:\"); deserializedPerson DisplayInfo();\n    }\n}\n`\nAdvanced Examples\nBasic API Controller Example\n`csharp{\ntitle: \"User Management API Controller\"\ndescription: \"A comprehensive REST API controller for user management with CRUD operations\"\nframework: \"NET8\"\ncategory: \"API\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Web API\", \"REST\", \"CRUD\", \"Authentication\"]\ngithubUrl: \"https://github com/example/user-api\"\ndocsUrl: \"https://docs microsoft com/aspnet/core/web-api\"\nnugetPackages: [\"Microsoft AspNetCore Mvc\", \"Microsoft EntityFrameworkCore\", \"Microsoft AspNetCore Authorization\"]\nfilename: \"UserController cs\"\nshowLineNumbers: true\nshowLinesOnly: [1, 2, 3, 8, 9, 12, 13, 14, 15, 18, 19] \nhighlightLines: [12, 15, 28, 45]\nusingStatements: [\"Microsoft AspNetCore Mvc\", \"Microsoft EntityFrameworkCore\", \"Microsoft AspNetCore Authorization\", \"System Threading Tasks\", \"System Collections Generic\"]\n}\nusing Microsoft AspNetCore Mvc;\nusing Microsoft EntityFrameworkCore;\nusing Microsoft AspNetCore Authorization;\nnamespace UserManagement Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public class UserController : ControllerBase\n    {\n        private readonly UserDbContext _context;\n        private readonly ILogger<UserController> _logger;\n        public UserController(UserDbContext context, ILogger<UserController> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n        [HttpGet]\n        public async Task<ActionResult<IEnumerable<UserDto>>> GetUsers()\n        {\n            try\n            {\n                var users = await _context Users Where(u => u IsActive) Select(u => new UserDto\n                    {\n                        Id = u Id,\n                        Name = u Name,\n                        Email = u Email,\n                        CreatedAt = u CreatedAt\n                    }) ToListAsync();\n                return Ok(users);\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error retrieving users\");\n                return StatusCode(500, \"Internal server error\");\n            }\n        }\n        [HttpGet(\"{id}\")]\n        public async Task<ActionResult<UserDto>> GetUser(int id)\n        {\n            var user = await _context Users FindAsync(id);\n            if (user == null)\n            {\n                return NotFound($\"User with ID {id} not found\");\n            }\n            return Ok(new UserDto\n            {\n                Id = user Id,\n                Name = user Name,\n                Email = user Email,\n                CreatedAt = user",
        "startIndex": 2380,
        "preview": "using System Collections Generic; public class JsonExample { public void SerializeExample() { var person = new Person(\"John Doe\", 30, \"john@example co..."
      },
      {
        "id": "old-v1.0.0/examples/enhanced-csharp-examples-chunk-2",
        "text": "server error\"); } } [HttpGet(\"{id}\")] public async Task<ActionResult<UserDto>> GetUser(int id) { var user = await _context Users FindAsync(id); if (user == null) { return NotFound($\"User with ID {id} not found\"); } return Ok(new UserDto { Id = user Id, Name = user Name, Email = user Email, CreatedAt = user CreatedAt\n            });\n        }\n        [HttpPost]\n        public async Task<ActionResult<UserDto>> CreateUser([FromBody] CreateUserRequest request)\n        {\n            if ( ModelState IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n            var user = new User\n            {\n                Name = request Name,\n                Email = request Email,\n                CreatedAt = DateTime UtcNow,\n                IsActive = true\n            };\n            _context Users Add(user);\n            await _context SaveChangesAsync();\n            var userDto = new UserDto\n            {\n                Id = user Id,\n                Name = user Name,\n                Email = user Email,\n                CreatedAt = user CreatedAt\n            };\n            return CreatedAtAction(nameof(GetUser), new { id = user Id }, userDto);\n        }\n    }\n}\n`\nEntity Framework Model Example\n`csharp{\ntitle: \"User Entity Model\"\ndescription: \"Entity Framework model with relationships and validation attributes\"\nframework: \"NET8\"\ncategory: \"ENTITY\"\ndifficulty: \"BEGINNER\"\ntags: [\"Entity Framework\", \"Models\", \"Data Annotations\"]\nnugetPackages: [\"Microsoft EntityFrameworkCore\", \"System ComponentModel Annotations\"]\nfilename: \"User cs\"\n}\nusing System ComponentModel DataAnnotations;\nusing System ComponentModel DataAnnotations Schema;\nnamespace UserManagement Models\n{\n    [Table(\"Users\")]\n    public class User\n    {\n        [Key]\n        [DatabaseGenerated(DatabaseGeneratedOption Identity)]\n        public int Id { get; set; }\n        [Required]\n        [StringLength(100, MinimumLength = 2)]\n        public string Name { get; set; } = string Empty;\n        [Required]\n        [EmailAddress]\n        [StringLength(255)]\n        public string Email { get; set; } = string Empty;\n        [Required]\n        public DateTime CreatedAt { get; set; }\n        public DateTime",
        "startIndex": 5016,
        "preview": "server error\"); } } [HttpGet(\"{id}\")] public async Task<ActionResult<UserDto>> GetUser(int id) { var user = await _context Users FindAsync(id); if (us..."
      },
      {
        "id": "old-v1.0.0/examples/enhanced-csharp-examples-chunk-3",
        "text": "User { [Key] [DatabaseGenerated(DatabaseGeneratedOption Identity)] public int Id { get; set; } [Required] [StringLength(100, MinimumLength = 2)] public string Name { get; set; } = string Empty; [Required] [EmailAddress] [StringLength(255)] public string Email { get; set; } = string Empty; [Required] public DateTime CreatedAt { get; set; } public DateTime UpdatedAt { get; set; }\n        [Required]\n        public bool IsActive { get; set; } = true;\n        // Navigation properties\n        public virtual ICollection<UserRole> UserRoles { get; set; } = new List<UserRole>();\n        public virtual ICollection<UserProfile> UserProfiles { get; set; } = new List<UserProfile>();\n    }\n    public class UserDto\n    {\n        public int Id { get; set; }\n        public string Name { get; set; } = string Empty;\n        public string Email { get; set; } = string Empty;\n        public DateTime CreatedAt { get; set; }\n    }\n    public class CreateUserRequest\n    {\n        [Required]\n        [StringLength(100, MinimumLength = 2)]\n        public string Name { get; set; } = string Empty;\n        [Required]\n        [EmailAddress]\n        public string Email { get; set; } = string Empty;\n    }\n}\n`\nAdvanced Service Pattern Example\n`csharp{\ntitle: \"User Service with Repository Pattern\"\ndescription: \"Implementation of service layer with dependency injection and error handling\"\nframework: \"NET8\"\ncategory: \"SERVICE\"\ndifficulty: \"ADVANCED\"\ntags: [\"Service Pattern\", \"Repository\", \"Dependency Injection\", \"Error Handling\"]\ngithubUrl: \"https://github com/example/user-service\"\nnugetPackages: [\"Microsoft Extensions Logging\", \"AutoMapper\"]\nfilename: \"UserService cs\"\nshowLinesOnly: [1, 2, 3, 4, 9, 10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 24, 25]\ncollapsible: false\n}\nusing AutoMapper;\nusing Microsoft Extensions Logging;\nusing UserManagement Models;\nusing UserManagement Repositories;\nusing UserManagement Exceptions;\nnamespace UserManagement Services\n{\n    public interface IUserService\n    {\n        Task<IEnumerable<UserDto>> GetAllUsersAsync();\n        Task<UserDto > GetUserByIdAsync(int id);\n        Task<UserDto> CreateUserAsync(CreateUserRequest request);\n        Task<UserDto",
        "startIndex": 6914,
        "preview": "User { [Key] [DatabaseGenerated(DatabaseGeneratedOption Identity)] public int Id { get; set; } [Required] [StringLength(100, MinimumLength = 2)] publi..."
      },
      {
        "id": "old-v1.0.0/examples/enhanced-csharp-examples-chunk-4",
        "text": "4, 9, 10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 24, 25] collapsible: false } using AutoMapper; using Microsoft Extensions Logging; using UserManagement Models; using UserManagement Repositories; using UserManagement Exceptions; namespace UserManagement Services { public interface IUserService { Task<IEnumerable<UserDto>> GetAllUsersAsync(); Task<UserDto > GetUserByIdAsync(int id); Task<UserDto> CreateUserAsync(CreateUserRequest request); Task<UserDto > UpdateUserAsync(int id, UpdateUserRequest request);\n        Task<bool> DeleteUserAsync(int id);\n        Task<bool> UserExistsAsync(string email);\n    }\n    public class UserService : IUserService\n    {\n        private readonly IUserRepository _userRepository;\n        private readonly IMapper _mapper;\n        private readonly ILogger<UserService> _logger;\n        public UserService(\n            IUserRepository userRepository,\n            IMapper mapper,\n            ILogger<UserService> logger)\n        {\n            _userRepository = userRepository throw new ArgumentNullException(nameof(userRepository));\n            _mapper = mapper throw new ArgumentNullException(nameof(mapper));\n            _logger = logger throw new ArgumentNullException(nameof(logger));\n        }\n        public async Task<IEnumerable<UserDto>> GetAllUsersAsync()\n        {\n            try\n            {\n                _logger LogInformation(\"Retrieving all active users\");\n                var users = await _userRepository GetActiveUsersAsync();\n                var userDtos = _mapper Map<IEnumerable<UserDto>>(users);\n                _logger LogInformation(\"Retrieved {UserCount} active users\", users Count());\n                return userDtos;\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error occurred while retrieving users\");\n                throw new ServiceException(\"Failed to retrieve users\", ex);\n            }\n        }\n        public async Task<UserDto > GetUserByIdAsync(int id)\n        {\n            try\n            {\n                _logger LogInformation(\"Retrieving user with ID: {UserId}\", id);\n                var user = await _userRepository GetByIdAsync(id);\n                if (user == null)\n                {\n                    _logger LogWarning(\"User with ID {UserId} not found\", id);\n                    return null;\n                }\n                var userDto = _mapper Map<UserDto>(user);\n                _logger LogInformation(\"Successfully retrieved user: {UserEmail}\", user Email);\n                return userDto;\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error occurred while retrieving user with ID: {UserId}\", id);\n                throw new ServiceException($\"Failed to retrieve user with ID: {id}\", ex);\n            }\n        }\n        public async Task<UserDto> CreateUserAsync(CreateUserRequest request)\n        {\n            try\n            {\n                _logger LogInformation(\"Creating new user with email: {Email}\", request Email);\n                // Check if user already exists\n                if (await UserExistsAsync(request Email))\n                {\n                    throw new DuplicateUserException($\"User with email {request Email} already exists\");\n                }\n                var user = _mapper Map<User>(request);\n                user CreatedAt = DateTime UtcNow;\n                user IsActive = true;\n                var createdUser = await _userRepository",
        "startIndex": 8735,
        "preview": "4, 9, 10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 24, 25] collapsible: false } using AutoMapper; using Microsoft Extensions Logging; using UserManagement ..."
      },
      {
        "id": "old-v1.0.0/examples/enhanced-csharp-examples-chunk-5",
        "text": "{ _logger LogInformation(\"Creating new user with email: {Email}\", request Email); // Check if user already exists if (await UserExistsAsync(request Email)) { throw new DuplicateUserException($\"User with email {request Email} already exists\"); } var user = _mapper Map<User>(request); user CreatedAt = DateTime UtcNow; user IsActive = true; var createdUser = await _userRepository CreateAsync(user);\n                var userDto = _mapper Map<UserDto>(createdUser);\n                _logger LogInformation(\"Successfully created user with ID: {UserId}\", createdUser Id);\n                return userDto;\n            }\n            catch (DuplicateUserException)\n            {\n                throw; // Re-throw business logic exceptions\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error occurred while creating user with email: {Email}\", request Email);\n                throw new ServiceException(\"Failed to create user\", ex);\n            }\n        }\n        public async Task<bool> UserExistsAsync(string email)\n        {\n            try\n            {\n                return await _userRepository ExistsByEmailAsync(email);\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error checking if user exists with email: {Email}\", email);\n                throw new ServiceException(\"Failed to check user existence\", ex);\n            }\n        }\n    }\n}\n`\nMiddleware Configuration Example\n`csharp{\ntitle: \"Custom Authentication Middleware\"\ndescription: \"JWT authentication middleware with custom claims handling\"\nframework: \"NET8\"\ncategory: \"MIDDLEWARE\"\ndifficulty: \"ADVANCED\"\ntags: [\"Middleware\", \"JWT\", \"Authentication\", \"Security\"]\ndocsUrl: \"https://docs microsoft com/aspnet/core/fundamentals/middleware\"\nnugetPackages: [\"Microsoft AspNetCore Authentication JwtBearer\", \"System IdentityModel Tokens Jwt\"]\nfilename: \"JwtAuthenticationMiddleware cs\"\n}\nusing Microsoft AspNetCore Authentication;\nusing Microsoft Extensions Options;\nusing System IdentityModel Tokens Jwt;\nusing System Security Claims;\nusing System Text Encodings Web;\nusing Microsoft IdentityModel Tokens;\nusing System Text;\nnamespace UserManagement Middleware\n{\n    public class JwtAuthenticationMiddleware\n    {\n        private readonly RequestDelegate _next;\n        private readonly JwtSettings _jwtSettings;\n        private readonly ILogger<JwtAuthenticationMiddleware> _logger;\n        public JwtAuthenticationMiddleware(\n            RequestDelegate next,\n            IOptions<JwtSettings> jwtSettings,\n            ILogger<JwtAuthenticationMiddleware> logger)\n        {\n            _next = next;\n            _jwtSettings = jwtSettings Value;\n            _logger = logger;\n        }\n        public async Task InvokeAsync(HttpContext context)\n        {\n            var token = ExtractTokenFromHeader(context);\n            if ( string IsNullOrEmpty(token))\n            {\n                await ValidateAndSetUser(context, token);\n            }\n            await _next(context);\n        }\n        private string ExtractTokenFromHeader(HttpContext context)\n        {\n            var authHeader = context Request Headers[\"Authorization\"] FirstOrDefault();\n            if (authHeader = null && authHeader",
        "startIndex": 11764,
        "preview": "{ _logger LogInformation(\"Creating new user with email: {Email}\", request Email); // Check if user already exists if (await UserExistsAsync(request Em..."
      },
      {
        "id": "old-v1.0.0/examples/enhanced-csharp-examples-chunk-6",
        "text": "= next; _jwtSettings = jwtSettings Value; _logger = logger; } public async Task InvokeAsync(HttpContext context) { var token = ExtractTokenFromHeader(context); if ( string IsNullOrEmpty(token)) { await ValidateAndSetUser(context, token); } await _next(context); } private string ExtractTokenFromHeader(HttpContext context) { var authHeader = context Request Headers[\"Authorization\"] FirstOrDefault(); if (authHeader = null && authHeader StartsWith(\"Bearer \"))\n            {\n                return authHeader Substring(\"Bearer \" Length) Trim();\n            }\n            return null;\n        }\n        private async Task ValidateAndSetUser(HttpContext context, string token)\n        {\n            try\n            {\n                var tokenHandler = new JwtSecurityTokenHandler();\n                var key = Encoding ASCII GetBytes(_jwtSettings SecretKey);\n                var validationParameters = new TokenValidationParameters\n                {\n                    ValidateIssuerSigningKey = true,\n                    IssuerSigningKey = new SymmetricSecurityKey(key),\n                    ValidateIssuer = true,\n                    ValidIssuer = _jwtSettings Issuer,\n                    ValidateAudience = true,\n                    ValidAudience = _jwtSettings Audience,\n                    ValidateLifetime = true,\n                    ClockSkew = TimeSpan Zero\n                };\n                var principal = tokenHandler ValidateToken(token, validationParameters, out SecurityToken validatedToken);\n                // Set the user context\n                context User = principal;\n                _logger LogInformation(\"JWT token validated successfully for user: {UserId}\", \n                    principal FindFirst(ClaimTypes NameIdentifier) Value);\n            }\n            catch (SecurityTokenException ex)\n            {\n                _logger LogWarning(\"Invalid JWT token: {Error}\", ex Message);\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error validating JWT token\");\n            }\n        }\n    }\n    public class JwtSettings\n    {\n        public string SecretKey { get; set; } = string Empty;\n        public string Issuer { get; set; } = string Empty;\n        public string Audience { get; set; } = string Empty;\n        public int ExpirationMinutes { get; set; } = 60;\n    }\n}\n`\nConfiguration and Startup Example\n`csharp{\ntitle: \"Program cs Configuration\"\ndescription: \"Modern NET 8 minimal hosting model with comprehensive service configuration\"\nframework: \"NET8\"\ncategory: \"CONFIG\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Configuration\", \"Dependency Injection\", \"Startup\", \"Minimal API\"]\nfilename: \"Program cs\"\n}\nusing Microsoft EntityFrameworkCore;\nusing Microsoft AspNetCore Authentication JwtBearer;\nusing Microsoft IdentityModel Tokens;\nusing System Text;\nusing UserManagement Data;\nusing UserManagement Services;\nusing UserManagement Repositories;\nusing UserManagement Middleware;\nvar builder = WebApplication CreateBuilder(args);\n// Configuration\nvar jwtSettings = builder Configuration",
        "startIndex": 14649,
        "preview": "= next; _jwtSettings = jwtSettings Value; _logger = logger; } public async Task InvokeAsync(HttpContext context) { var token = ExtractTokenFromHeader(..."
      },
      {
        "id": "old-v1.0.0/examples/enhanced-csharp-examples-chunk-7",
        "text": "tags: [\"Configuration\", \"Dependency Injection\", \"Startup\", \"Minimal API\"] filename: \"Program cs\" } using Microsoft EntityFrameworkCore; using Microsoft AspNetCore Authentication JwtBearer; using Microsoft IdentityModel Tokens; using System Text; using UserManagement Data; using UserManagement Services; using UserManagement Repositories; using UserManagement Middleware; var builder = WebApplication CreateBuilder(args); // Configuration var jwtSettings = builder Configuration GetSection(\"JwtSettings\");\nvar connectionString = builder Configuration GetConnectionString(\"DefaultConnection\");\n// Add services to the container\nbuilder Services AddDbContext<UserDbContext>(options =>\n    options UseSqlServer(connectionString));\n// JWT Authentication\nbuilder Services Configure<JwtSettings>(jwtSettings);\nbuilder Services AddAuthentication(JwtBearerDefaults AuthenticationScheme) AddJwtBearer(options =>\n    {\n        options TokenValidationParameters = new TokenValidationParameters\n        {\n            ValidateIssuerSigningKey = true,\n            IssuerSigningKey = new SymmetricSecurityKey(\n                Encoding ASCII GetBytes(jwtSettings[\"SecretKey\"] )),\n            ValidateIssuer = true,\n            ValidIssuer = jwtSettings[\"Issuer\"],\n            ValidateAudience = true,\n            ValidAudience = jwtSettings[\"Audience\"],\n            ValidateLifetime = true,\n            ClockSkew = TimeSpan Zero\n        };\n    });\nbuilder Services AddAuthorization();\n// Register application services\nbuilder Services AddScoped<IUserRepository, UserRepository>();\nbuilder Services AddScoped<IUserService, UserService>();\n// AutoMapper\nbuilder Services AddAutoMapper(typeof(Program));\n// API Controllers\nbuilder Services AddControllers();\n// API Documentation\nbuilder Services AddEndpointsApiExplorer();\nbuilder Services AddSwaggerGen(c =>\n{\n    c SwaggerDoc(\"v1\", new() { Title = \"User Management API\", Version = \"v1\" });\n    c AddSecurityDefinition(\"Bearer\", new()\n    {\n        Description = \"JWT Authorization header using the Bearer scheme \",\n        Name = \"Authorization\",\n        In = Microsoft OpenApi Models ParameterLocation Header,\n        Type = Microsoft OpenApi Models SecuritySchemeType Http,\n        Scheme = \"bearer\"\n    });\n});\n// CORS\nbuilder Services AddCors(options =>\n{\n    options AddPolicy(\"AllowSpecificOrigins\", policy =>\n    {\n        policy WithOrigins(\"https://localhost:4200\", \"https://myapp com\") AllowAnyHeader() AllowAnyMethod();\n    });\n});\n// Logging\nbuilder Services AddLogging(config =>\n{\n    config AddConsole();\n    config AddDebug();\n});\nvar app = builder Build();\n// Configure the HTTP request pipeline\nif (app Environment IsDevelopment())\n{\n    app UseSwagger();\n    app UseSwaggerUI();\n    app UseDeveloperExceptionPage();\n}\napp UseHttpsRedirection();\napp UseCors(\"AllowSpecificOrigins\");\n// Custom JWT middleware\napp UseMiddleware<JwtAuthenticationMiddleware>();\napp UseAuthentication();\napp UseAuthorization();\napp MapControllers();\napp",
        "startIndex": 17276,
        "preview": "tags: [\"Configuration\", \"Dependency Injection\", \"Startup\", \"Minimal API\"] filename: \"Program cs\" } using Microsoft EntityFrameworkCore; using Microsof..."
      },
      {
        "id": "old-v1.0.0/examples/enhanced-csharp-examples-chunk-8",
        "text": "builder Services AddLogging(config => { config AddConsole(); config AddDebug(); }); var app = builder Build(); // Configure the HTTP request pipeline if (app Environment IsDevelopment()) { app UseSwagger(); app UseSwaggerUI(); app UseDeveloperExceptionPage(); } app UseHttpsRedirection(); app UseCors(\"AllowSpecificOrigins\"); // Custom JWT middleware app UseMiddleware<JwtAuthenticationMiddleware>(); app UseAuthentication(); app UseAuthorization(); app MapControllers(); app Run();\n`\nThis documentation showcases the enhanced Ccode viewing capabilities with:\nRich Metadata: Titles, descriptions, framework versions, categories, difficulty levels\nInteractive Features: Copy, download, GitHub links, NuGet package integration\nVisual Enhancements: Syntax highlighting, line numbers, code folding\nProfessional Styling: VS Code-inspired themes, hover effects, responsive design\nDeveloper Tools: Line highlighting, collapsible sections, tag categorization",
        "startIndex": 19814,
        "preview": "builder Services AddLogging(config => { config AddConsole(); config AddDebug(); }); var app = builder Build(); // Configure the HTTP request pipeline ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/getting-started/aspire-integration",
    "title": ".NET Aspire Integration",
    "category": "Getting Started",
    "url": "/docs/old-v1.0.0/getting-started/aspire-integration",
    "chunks": [
      {
        "id": "old-v1.0.0/getting-started/aspire-integration-chunk-0",
        "text": "NET Aspire Integration\nWhizbang provides first-class support for NET Aspire, Microsoft's opinionated stack for building observable, production-ready cloud-native applications Overview\nWith Aspire integration, you get:\nLocal emulation of Postgres, Kafka, Redis, and other infrastructure\nOne-command setup for end-to-end development environment\nService discovery for microservices communication\nBuilt-in observability with OpenTelemetry dashboards\nResource orchestration with Docker containers\nConfiguration management across services\nQuick Start\nInstall Aspire Workload\n`bash{\ntitle: \"Install Aspire Workload\"\ndescription: \"Install the NET Aspire workload for local development\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Getting Started\", \"Aspire\", \"Installation\", \"Setup\"]\nshowLineNumbers: false\n}\ndotnet workload install aspire\n`\nAdd Whizbang Aspire Package\n`bash{\ntitle: \"Add Whizbang Aspire Package\"\ndescription: \"Install the Whizbang Aspire integration package\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Getting Started\", \"Aspire\", \"Installation\", \"NuGet\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang Aspire\n`\nConfigure AppHost\nCreate an Aspire AppHost project:\n`csharp{\ntitle: \"Aspire AppHost Configuration\"\ndescription: \"Configure Whizbang services with Aspire\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"BEGINNER\"\ntags: [\"Aspire\", \"Configuration\", \"Local Development\"]\nnugetPackages: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nfilename: \"Program cs\"\nusingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting;\nusing Whizbang Aspire;\nvar builder = DistributedApplication CreateBuilder(args);\n// Add Whizbang infrastructure\nvar whizbang = builder AddWhizbang(\"whizbang\") WithPostgres()       // Event store WithKafka()          // Message broker WithRedis()          // Caching WithOpenTelemetry(); // Observability\n// Add your services\nvar ordersService = builder AddProject<Projects OrdersService>(\"orders\") WithReference(whizbang);\nvar inventoryService = builder AddProject<Projects InventoryService>(\"inventory\") WithReference(whizbang);\nvar apiGateway = builder AddProject<Projects ApiGateway>(\"api\") WithReference(ordersService) WithReference(inventoryService);\nbuilder Build() Run();\n`\nConfigure Service\nIn your service's Program cs:\n`csharp{\ntitle: \"Service Configuration with Aspire\"\ndescription: \"Wire up Whizbang in a service using Aspire\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"BEGINNER\"\ntags: [\"Aspire\", \"Configuration\", \"Microservices\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Messaging\", \"Whizbang Aspire\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions Hosting\", \"Whizbang\", \"Whizbang",
        "startIndex": 0,
        "preview": "NET Aspire Integration\nWhizbang provides first-class support for NET Aspire, Microsoft's opinionated stack for building observable, production-ready c..."
      },
      {
        "id": "old-v1.0.0/getting-started/aspire-integration-chunk-1",
        "text": "Configure Service In your service's Program cs: `csharp{ title: \"Service Configuration with Aspire\" description: \"Wire up Whizbang in a service using Aspire\" framework: \"NET8\" category: \"Aspire\" difficulty: \"BEGINNER\" tags: [\"Aspire\", \"Configuration\", \"Microservices\"] nugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Messaging\", \"Whizbang Aspire\"] filename: \"Program cs\" usingStatements: [\"Microsoft Extensions Hosting\", \"Whizbang\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions Hosting;\nusing Whizbang;\nusing Whizbang Aspire;\nvar builder = WebApplication CreateBuilder(args);\n// Add Aspire service defaults (observability, health checks, etc )\nbuilder AddServiceDefaults();\n// Add Whizbang with Aspire integration\nbuilder Services AddWhizbangWithAspire(options => {\n    options ScanAssembly(typeof(Program) Assembly);\n    // Infrastructure auto-configured from Aspire\n    options UseAspireEventStore();      // Connects to Aspire-managed Postgres\n    options UseAspireMessaging();       // Connects to Aspire-managed Kafka\n    options UseAspireProjectionCache(); // Connects to Aspire-managed Redis\n});\nvar app = builder Build();\napp MapDefaultEndpoints();  // Aspire health/metrics endpoints\napp Run();\n`\nRun Everything\n`bash{\ntitle: \"Run Aspire AppHost\"\ndescription: \"Start all services and infrastructure with a single command\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Getting Started\", \"Aspire\", \"Local Development\", \"Orchestration\"]\nshowLineNumbers: false\n}\ndotnet run --project AppHost\n`\nThis single command:\nStarts Postgres container for event store\nStarts Kafka + Zookeeper containers for messaging\nStarts Redis container for caching\nStarts all your microservices\nOpens Aspire dashboard with logs, metrics, and traces\nAspire Dashboard\nNavigate to http://localhost:15000 (or the URL shown in console) to see:\nResources - All running containers and services\nLogs - Structured logs from all services\nTraces - Distributed tracing across services\nMetrics - Real-time metrics (event throughput, projection lag, etc )\nHealth - Service health status\nOut-of-the-Box Infrastructure\nPostgres (Event Store)\nWhizbang automatically configures Postgres for event storage:\n`csharp{\ntitle: \"Aspire Postgres Configuration\"\ndescription: \"Auto-configured Postgres event store\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aspire\", \"Postgres\", \"Event Store\"]\nnugetPackages: [\"Whizbang Aspire\", \"Whizbang Postgres\"]\nusingStatements: [\"Aspire Hosting\", \"Whizbang",
        "startIndex": 2828,
        "preview": "Configure Service In your service's Program cs: `csharp{ title: \"Service Configuration with Aspire\" description: \"Wire up Whizbang in a service using ..."
      },
      {
        "id": "old-v1.0.0/getting-started/aspire-integration-chunk-2",
        "text": "lag, etc ) Health - Service health status Out-of-the-Box Infrastructure Postgres (Event Store) Whizbang automatically configures Postgres for event storage: `csharp{ title: \"Aspire Postgres Configuration\" description: \"Auto-configured Postgres event store\" framework: \"NET8\" category: \"Aspire\" difficulty: \"INTERMEDIATE\" tags: [\"Aspire\", \"Postgres\", \"Event Store\"] nugetPackages: [\"Whizbang Aspire\", \"Whizbang Postgres\"] usingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting;\nusing Whizbang Aspire;\nvar builder = DistributedApplication CreateBuilder(args);\nvar whizbang = builder AddWhizbang(\"whizbang\") WithPostgres(postgres => {\n        postgres DatabaseName = \"whizbang_events\";\n        postgres WithPgAdmin();  // Optional: PgAdmin UI\n        postgres WithInitialData(\" /seed-data sql\");  // Optional: Seed data\n    });\n`\nWhat it does:\nStarts Postgres 16 container\nCreates whizbang_events database\nApplies Whizbang event store schema automatically\nConfigures connection string in all services\nEnables OpenTelemetry instrumentation\nKafka (Message Broker)\nWhizbang sets up Kafka for distributed messaging:\n`csharp{\ntitle: \"Aspire Kafka Configuration\"\ndescription: \"Auto-configured Kafka message broker\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aspire\", \"Kafka\", \"Messaging\"]\nnugetPackages: [\"Whizbang Aspire\", \"Whizbang Kafka\"]\nusingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting;\nusing Whizbang Aspire;\nvar whizbang = builder AddWhizbang(\"whizbang\") WithKafka(kafka => {\n        kafka WithKafkaUI();  // Optional: Kafka UI for topic inspection\n        kafka WithTopics(\n            \"whizbang orders events\",\n            \"whizbang inventory events\",\n            \"whizbang shipping events\"\n        );\n    });\n`\nWhat it does:\nStarts Kafka + Zookeeper containers\nCreates topics for each domain\nConfigures producers and consumers\nEnables distributed tracing for messages\nProvides Kafka UI at http://localhost:8080\nRedis (Caching & Projections)\nOptional Redis for projection caching:\n`csharp{\ntitle: \"Aspire Redis Configuration\"\ndescription: \"Auto-configured Redis for caching\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aspire\", \"Redis\", \"Caching\"]\nnugetPackages: [\"Whizbang Aspire\"]\nusingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting;\nusing Whizbang Aspire;\nvar whizbang = builder AddWhizbang(\"whizbang\") WithRedis(redis => {\n        redis WithRedisInsight();  // Optional: Redis UI\n        redis",
        "startIndex": 1588,
        "preview": "lag, etc ) Health - Service health status Out-of-the-Box Infrastructure Postgres (Event Store) Whizbang automatically configures Postgres for event st..."
      },
      {
        "id": "old-v1.0.0/getting-started/aspire-integration-chunk-3",
        "text": "\"Aspire Redis Configuration\" description: \"Auto-configured Redis for caching\" framework: \"NET8\" category: \"Aspire\" difficulty: \"INTERMEDIATE\" tags: [\"Aspire\", \"Redis\", \"Caching\"] nugetPackages: [\"Whizbang Aspire\"] usingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"] showLineNumbers: true } using Aspire Hosting; using Whizbang Aspire; var whizbang = builder AddWhizbang(\"whizbang\") WithRedis(redis => { redis WithRedisInsight(); // Optional: Redis UI redis WithPersistence();   // Optional: Persist to disk\n    });\n`\nWhat it does:\nStarts Redis container\nConfigures projection caching\nEnables distributed locks for projection processing\nProvides Redis Insight UI\nService Discovery\nServices automatically discover each other through Aspire:\n`csharp{\ntitle: \"Service Discovery with Aspire\"\ndescription: \"Services discover each other automatically\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aspire\", \"Service Discovery\", \"Microservices\"]\nnugetPackages: [\"Whizbang Aspire\", \"Whizbang Messaging\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nusing Whizbang Aspire;\n// In API Gateway\nbuilder Services AddWhizbangWithAspire(options => {\n    options UseMessaging(msg => {\n        // Service URLs automatically resolved via Aspire\n        msg UseDomainOwnership(domains => {\n            domains RegisterDomain(\"Orders\", \"http://orders\");        // Aspire resolves to actual URL\n            domains RegisterDomain(\"Inventory\", \"http://inventory\");  // Aspire resolves to actual URL\n        });\n    });\n});\n// Commands automatically routed to correct service\nawait whizbang Send(new PlaceOrder( ));  // Routes to http://orders (resolved by Aspire)\n`\nEnd-to-End Example\nComplete Aspire setup for microservices:\n`csharp{\ntitle: \"Complete Aspire Setup\"\ndescription: \"Full microservices setup with Whizbang and Aspire\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"ADVANCED\"\ntags: [\"Aspire\", \"Microservices\", \"Complete Example\"]\nnugetPackages: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nfilename: \"AppHost/Program cs\"\nusingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting;\nusing Whizbang Aspire;\nvar builder = DistributedApplication CreateBuilder(args);\n// Shared infrastructure\nvar whizbang = builder AddWhizbang(\"whizbang\") WithPostgres(pg => {\n        pg DatabaseName = \"whizbang_events\";\n        pg WithPgAdmin();\n    }) WithKafka(kafka => {\n        kafka WithKafkaUI();\n        kafka WithTopics(\n            \"whizbang orders events\",\n            \"whizbang inventory events\",\n            \"whizbang shipping events\",\n            \"whizbang payments events\"\n        );\n    }) WithRedis(redis => {\n        redis",
        "startIndex": 7068,
        "preview": "\"Aspire Redis Configuration\" description: \"Auto-configured Redis for caching\" framework: \"NET8\" category: \"Aspire\" difficulty: \"INTERMEDIATE\" tags: [\"..."
      },
      {
        "id": "old-v1.0.0/getting-started/aspire-integration-chunk-4",
        "text": "Whizbang Aspire; var builder = DistributedApplication CreateBuilder(args); // Shared infrastructure var whizbang = builder AddWhizbang(\"whizbang\") WithPostgres(pg => { pg DatabaseName = \"whizbang_events\"; pg WithPgAdmin(); }) WithKafka(kafka => { kafka WithKafkaUI(); kafka WithTopics( \"whizbang orders events\", \"whizbang inventory events\", \"whizbang shipping events\", \"whizbang payments events\" ); }) WithRedis(redis => { redis WithRedisInsight();\n    }) WithOpenTelemetry();\n// Microservices (each has own event store partition)\nvar orders = builder AddProject<Projects OrdersService>(\"orders\") WithReference(whizbang) WithReplicas(3);  // Scale out\nvar inventory = builder AddProject<Projects InventoryService>(\"inventory\") WithReference(whizbang) WithReplicas(2);\nvar shipping = builder AddProject<Projects ShippingService>(\"shipping\") WithReference(whizbang);\nvar payments = builder AddProject<Projects PaymentsService>(\"payments\") WithReference(whizbang);\n// Analytics service (subscribes to all events)\nvar analytics = builder AddProject<Projects AnalyticsService>(\"analytics\") WithReference(whizbang);\n// API Gateway\nvar api = builder AddProject<Projects ApiGateway>(\"api\") WithReference(orders) WithReference(inventory) WithReference(shipping) WithReference(payments) WithHttpsEndpoint(port: 5000);\nbuilder Build() Run();\n`\nRunning:\n`bash{\ntitle: \"Run Complete Microservices Setup\"\ndescription: \"Start the full microservices architecture with Aspire\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Aspire\", \"Microservices\", \"Orchestration\"]\nshowLineNumbers: false\n}\ndotnet run --project AppHost\n`\nStarts:\n1 Postgres container (shared event store)\n1 Kafka + Zookeeper (shared message broker)\n1 Redis (shared cache)\n3 replicas of Orders service\n2 replicas of Inventory service\n1 Shipping service\n1 Payments service\n1 Analytics service\n1 API Gateway\nAspire Dashboard with full observability\nConfiguration Management\nAspire manages configuration across all services:\n`json{\ntitle: \"Aspire Configuration Structure\"\ndescription: \"Example of how Aspire auto-configures Whizbang settings\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Getting Started\", \"Aspire\", \"Configuration\", \"JSON\"]\nfilename: \"appsettings json\"\nshowLineNumbers: true\n}\n{\n  \"Aspire\": {\n    \"Whizbang\": {\n      \"EventStore\": {\n        \"ConnectionString\": \" auto-configured \",\n        \"SchemaName\": \"whizbang\",\n        \"AutoMigrate\": true\n      },\n      \"Messaging\": {\n        \"Kafka\": {\n          \"BootstrapServers\": \" auto-configured \",\n          \"ConsumerGroup\": \"orders-service\"\n        }\n      },\n      \"Projections\": {\n        \"Redis\": {\n          \"ConnectionString\": \" auto-configured \"\n        }\n      }\n    }\n  }\n}\n`\nConnection strings and URLs are automatically injected from Aspire infrastructure",
        "startIndex": 9435,
        "preview": "Whizbang Aspire; var builder = DistributedApplication CreateBuilder(args); // Shared infrastructure var whizbang = builder AddWhizbang(\"whizbang\") Wit..."
      },
      {
        "id": "old-v1.0.0/getting-started/aspire-integration-chunk-5",
        "text": "{ \"Whizbang\": { \"EventStore\": { \"ConnectionString\": \" auto-configured \", \"SchemaName\": \"whizbang\", \"AutoMigrate\": true }, \"Messaging\": { \"Kafka\": { \"BootstrapServers\": \" auto-configured \", \"ConsumerGroup\": \"orders-service\" } }, \"Projections\": { \"Redis\": { \"ConnectionString\": \" auto-configured \" } } } } } ` Connection strings and URLs are automatically injected from Aspire infrastructure Testing with Aspire\nRun integration tests against Aspire-managed infrastructure:\n`csharp{\ntitle: \"Integration Tests with Aspire\"\ndescription: \"Test against real infrastructure via Aspire\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"ADVANCED\"\ntags: [\"Testing\", \"Aspire\", \"Integration Tests\"]\nnugetPackages: [\"Aspire Hosting Testing\", \"Whizbang Aspire\", \"xUnit\"]\nusingStatements: [\"Aspire Hosting Testing\", \"Xunit\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting Testing;\nusing System Threading Tasks;\nusing Xunit;\npublic class OrderServiceTests : IClassFixture<DistributedApplicationFixture> {\n    private readonly DistributedApplicationFixture _fixture;\n    public OrderServiceTests(DistributedApplicationFixture fixture) {\n        _fixture = fixture;\n    }\n    [Fact]\n    public async Task PlaceOrder_PersistsToEventStore() {\n        // Aspire starts Postgres, Kafka, and services\n        await using var app = await _fixture CreateApplicationAsync();\n        await app StartAsync();\n        var ordersService = app GetHttpClient(\"orders\");\n        // Test against real service with real infrastructure\n        var response = await ordersService PostAsJsonAsync(\"/orders\", new {\n            CustomerId = Guid NewGuid(),\n            Items = new[] { new { ProductId = Guid NewGuid(), Quantity = 2, Price = 19 99 } }\n        });\n        response EnsureSuccessStatusCode();\n        // Events are actually persisted to Postgres\n        // Projections are actually updated via Kafka\n    }\n}\n`\nTests run against real infrastructure (Postgres, Kafka, etc ) managed by Aspire",
        "startIndex": 11934,
        "preview": "{ \"Whizbang\": { \"EventStore\": { \"ConnectionString\": \" auto-configured \", \"SchemaName\": \"whizbang\", \"AutoMigrate\": true }, \"Messaging\": { \"Kafka\": { \"B..."
      },
      {
        "id": "old-v1.0.0/getting-started/aspire-integration-chunk-6",
        "text": "= new[] { new { ProductId = Guid NewGuid(), Quantity = 2, Price = 19 99 } } }); response EnsureSuccessStatusCode(); // Events are actually persisted to Postgres // Projections are actually updated via Kafka } } ` Tests run against real infrastructure (Postgres, Kafka, etc ) managed by Aspire Benefits of Aspire Integration\nFor Local Development\nOne command starts everything (databases, message brokers, services)\nNo manual Docker Compose management\nAutomatic configuration (connection strings, URLs)\nLive reload with hot reload support\nObservability dashboard out of the box\nFor Team Onboarding\nNew developers clone repo and run dotnet run --project AppHost\nEverything \"just works\" - no manual setup\nConsistent environment across team members\nSelf-documenting infrastructure (defined in code)\nFor Production\nSame infrastructure configuration in dev and prod\nAspire generates Kubernetes manifests\nEasy transition from local to cloud\nAzure Container Apps / AKS deployment support\nDeployment\nGenerate deployment artifacts from Aspire:\n`bash{\ntitle: \"Aspire Deployment Commands\"\ndescription: \"Generate deployment artifacts and deploy with Aspire\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Aspire\", \"Deployment\", \"Kubernetes\", \"Docker\"]\nshowLineNumbers: true\n}\nGenerate Kubernetes manifests\ndotnet run --project AppHost -- publish --output-path /deploy/k8s\nGenerate Docker Compose\ndotnet run --project AppHost -- publish --output-path /deploy/docker --format docker-compose\nDeploy to Azure Container Apps\nazd init\nazd up\n`\nNext Steps\nDistributed Messaging - Microservices with Kafka\nObservability - OpenTelemetry and monitoring\nTesting - Test with Aspire infrastructure\nResources NET Aspire Documentation\nWhizbang Aspire Samples\nAspire Dashboard Guide",
        "startIndex": 13534,
        "preview": "= new[] { new { ProductId = Guid NewGuid(), Quantity = 2, Price = 19 99 } } }); response EnsureSuccessStatusCode(); // Events are actually persisted t..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/getting-started/getting-started",
    "title": "Getting Started",
    "category": "Getting Started",
    "url": "/docs/old-v1.0.0/getting-started/getting-started",
    "chunks": [
      {
        "id": "old-v1.0.0/getting-started/getting-started-chunk-0",
        "text": "Getting Started\nThis is a hands-on tutorial that walks you through building your first Whizbang application, starting with a simple in-process mediator and progressively adding event sourcing, projections, and distributed messaging What you'll build:\n✅ Event-Driven Architecture - Receptors, Perspectives, and Lenses with Whizbang Core\n✅ Event Sourcing - Stateful receptors and ledger with Whizbang EventSourcing\n✅ Multiple Perspectives - Different views of the same events for efficient queries\n`mermaid\ngraph LR\n    A[Event-Driven] -->|Add Ledger| B[Event-Sourced]\n    B -->|Add Perspectives| C[Full Event Architecture]\n    class A layer-command\n    class B layer-event\n    class C layer-read\n`\nCompanion guides:\n📦 Package Structure - Reference guide for all NuGet packages, ORMs, and message broker adapters\n🧠 Philosophy - Understand Whizbang's design principles and architectural decisions\n📚 Core Concepts - Deep dive into commands, events, aggregates, and projections\nPrerequisites NET 8 0 SDK or later\nC12 or later\nYour favorite IDE (Visual Studio, Rider, VS Code)\nInstallation\n> 📦 Want to understand all available packages See the Package Structure Reference for a complete guide to Whizbang's NuGet packages, ORM integrations, and message broker adapters Step 1: Create a New Project\n`bash{\ntitle: \"Create New Web API Project\"\ndescription: \"Create a new ASP NET Core Web API project named MyApp\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"Setup\", \"dotnet\", \"Project Creation\"]\n}\ndotnet new webapi -n MyApp\ncd MyApp\n`\nStep 2: Install Whizbang\nFor this tutorial, we'll start with just the core package:\n`bash{\ntitle: \"Install Whizbang Core Package\"\ndescription: \"Add the Whizbang Core NuGet package for event-driven architecture\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"Installation\", \"dotnet\", \"Package Management\"]\n}\ndotnet add package Whizbang Core\n`\nWhat is Whizbang Core The foundation for event-driven architecture - includes dispatcher, receptors, perspectives, and lenses",
        "startIndex": 0,
        "preview": "Getting Started\nThis is a hands-on tutorial that walks you through building your first Whizbang application, starting with a simple in-process mediato..."
      },
      {
        "id": "old-v1.0.0/getting-started/getting-started-chunk-1",
        "text": "\"Install Whizbang Core Package\" description: \"Add the Whizbang Core NuGet package for event-driven architecture\" framework: \"NET8\" category: \"Getting Started\" difficulty: \"BEGINNER\" tags: [\"Commands\", \"Installation\", \"dotnet\", \"Package Management\"] } dotnet add package Whizbang Core ` What is Whizbang Core The foundation for event-driven architecture - includes dispatcher, receptors, perspectives, and lenses Perfect for learning event-driven patterns where all writes flow through events We'll add event sourcing later in this tutorial ---\nYour First Command and Receptor\nLet's build a simple order system with event-driven architecture `mermaid\nsequenceDiagram\n    participant API as API Endpoint\n    participant D as Dispatcher\n    participant R as OrderReceptor\n    participant P as OrderPerspective\n    participant DB as Database\n    API->>D: Dispatch(PlaceOrder)\n    D->>R: Receive(PlaceOrder)\n    R->>R: Validate with Lens\n    R-->>D: OrderPlaced event\n    D->>P: Update(OrderPlaced)\n    P->>DB: Write order\n    D-->>API: OrderPlaced event\n    Note over API,DB: Event-driven pattern<br/>All writes through events\n`\nStep 1: Define a Command\nCreate Commands/PlaceOrder cs:\n`csharp{\ntitle: \"PlaceOrder Command\"\ndescription: \"Command to place a new order\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"CQRS\"]\nfilename: \"Commands/PlaceOrder cs\"\nusingStatements: [\"System\"]\nshowLineNumbers: true\n}\nusing System;\nnamespace MyApp Commands;\npublic record PlaceOrder(\n    Guid CustomerId,\n    List<OrderItem> Items\n);\npublic record OrderItem(\n    Guid ProductId,\n    int Quantity,\n    decimal Price\n);\n`\nStep 2: Create a Receptor\nCreate Receptors/PlaceOrderReceptor cs:\n`csharp{\ntitle: \"PlaceOrder Receptor\"\ndescription: \"Receptor that processes PlaceOrder commands\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Event-Driven\", \"Commands\"]\nfilename: \"Receptors/PlaceOrderReceptor cs\"\nusingStatements: [\"System\", \"Whizbang\", \"MyApp Commands\", \"MyApp Events\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing MyApp Commands;\nusing MyApp Events;\nnamespace MyApp Receptors;\npublic class PlaceOrderReceptor : IReceptor<PlaceOrder> {\n    public OrderPlaced Receive(PlaceOrder command) {\n        // Validate\n        if (command Items Count == 0) {\n            throw new InvalidOperationException(\"Order must have at least one item\");\n        }\n        // Create event\n        var orderId = Guid NewGuid();\n        var total = command Items Sum(i => i Price * i",
        "startIndex": 2091,
        "preview": "\"Install Whizbang Core Package\" description: \"Add the Whizbang Core NuGet package for event-driven architecture\" framework: \"NET8\" category: \"Getting ..."
      },
      {
        "id": "old-v1.0.0/getting-started/getting-started-chunk-2",
        "text": "Receptors; public class PlaceOrderReceptor : IReceptor<PlaceOrder> { public OrderPlaced Receive(PlaceOrder command) { // Validate if (command Items Count == 0) { throw new InvalidOperationException(\"Order must have at least one item\"); } // Create event var orderId = Guid NewGuid(); var total = command Items Sum(i => i Price * i Quantity);\n        // Return event - perspective will handle persistence\n        return new OrderPlaced(\n            orderId,\n            command CustomerId,\n            DateTimeOffset UtcNow,\n            command Items,\n            total\n        );\n    }\n}\n`\nStep 3: Create a Perspective\nCreate Perspectives/OrderPerspective cs:\n`csharp{\ntitle: \"Order Perspective\"\ndescription: \"Perspective that handles OrderPlaced events\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Perspectives\", \"Event-Driven\", \"Database\"]\nfilename: \"Perspectives/OrderPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\", \"MyApp Events\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\nusing MyApp Events;\nnamespace MyApp Perspectives;\npublic class OrderPerspective : IPerspectiveOf<OrderPlaced> {\n    private readonly IOrderDatabase db;\n    public OrderPerspective(IOrderDatabase db) {\n        _db = db;\n    }\n    public async Task Update(OrderPlaced @event) {\n        // Perspective handles all writes\n        await _db Orders Add(new Order {\n            Id = @event OrderId,\n            CustomerId = @event CustomerId,\n            PlacedAt = @event PlacedAt,\n            Total = @event Total,\n            Status = \"Placed\"\n        });\n        await _db SaveChanges();\n    }\n}\n`\nStep 4: Configure Whizbang\nUpdate Program cs:\n`csharp{\ntitle: \"Whizbang Configuration\"\ndescription: \"Configure Whizbang dispatcher in ASP NET Core\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Configuration\", \"Setup\", \"ASP NET Core\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nvar builder = WebApplication CreateBuilder(args);\n// Add Whizbang dispatcher\nbuilder Services AddWhizbang(options => {\n    // Scan this assembly for receptors and perspectives\n    options ScanAssembly(typeof(Program) Assembly);\n});\nvar app = builder Build();\napp MapPost(\"/orders\", async (PlaceOrder command, IDispatcher dispatcher) => {\n    var @event = await dispatcher Send(command);\n    return Results Ok(new { OrderId = @event OrderId, Total = @event Total });\n});\napp",
        "startIndex": 4234,
        "preview": "Receptors; public class PlaceOrderReceptor : IReceptor<PlaceOrder> { public OrderPlaced Receive(PlaceOrder command) { // Validate if (command Items Co..."
      },
      {
        "id": "old-v1.0.0/getting-started/getting-started-chunk-3",
        "text": "AddWhizbang(options => { // Scan this assembly for receptors and perspectives options ScanAssembly(typeof(Program) Assembly); }); var app = builder Build(); app MapPost(\"/orders\", async (PlaceOrder command, IDispatcher dispatcher) => { var @event = await dispatcher Send(command); return Results Ok(new { OrderId = @event OrderId, Total = @event Total }); }); app Run();\n`\nStep 5: Run the Application\n`bash{\ntitle: \"Run the Application\"\ndescription: \"Start the ASP NET Core Web API application\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"dotnet\", \"Execution\"]\n}\ndotnet run\n`\nTest with curl:\n`bash{\ntitle: \"Test Order API Endpoint\"\ndescription: \"Send a POST request to create a new order using curl\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"Testing\", \"API\", \"curl\"]\n}\ncurl -X POST http://localhost:5000/orders \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"customerId\": \"123e4567-e89b-12d3-a456-426614174000\",\n    \"items\": [\n      { \"productId\": \"prod-1\", \"quantity\": 2, \"price\": 19 99 }\n    ]\n  }'\n`\nCongratulations You've created your first Whizbang event-driven application with receptors and perspectives All writes flow through events, making the transition to event sourcing seamless ---\nAdding Event Sourcing\nLet's upgrade to event sourcing with stateful receptors and a ledger for complete audit trail `mermaid\nsequenceDiagram\n    participant API as API Endpoint\n    participant D as Dispatcher\n    participant R as OrderReceptor\n    participant L as Ledger\n    participant P as Perspective\n    API->>D: Send(PlaceOrder)\n    D->>R: Receive(PlaceOrder)\n    R->>R: Validate business rules\n    R->>R: Apply(OrderPlaced)\n    Note over R: Event updates<br/>receptor state\n    D->>L: Append events to stream\n    L-->>D: Events saved\n    D->>P: Update(OrderPlaced)\n    P->>P: Update read models\n    D-->>API: OrderPlaced event\n    Note over API,P: Events stored as immutable log<br/>Complete audit trail\n`\n> 📦 Learn more: See Whizbang EventSourcing in the Package Structure guide for ORM options, database support, and advanced configuration Step 1: Install Event Sourcing Package\n`bash{\ntitle: \"Install Event Sourcing Packages\"\ndescription: \"Add Whizbang",
        "startIndex": 6461,
        "preview": "AddWhizbang(options => { // Scan this assembly for receptors and perspectives options ScanAssembly(typeof(Program) Assembly); }); var app = builder Bu..."
      },
      {
        "id": "old-v1.0.0/getting-started/getting-started-chunk-4",
        "text": "models D-->>API: OrderPlaced event Note over API,P: Events stored as immutable log<br/>Complete audit trail ` > 📦 Learn more: See Whizbang EventSourcing in the Package Structure guide for ORM options, database support, and advanced configuration Step 1: Install Event Sourcing Package `bash{ title: \"Install Event Sourcing Packages\" description: \"Add Whizbang EventSourcing and database provider packages\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"Installation\", \"dotnet\", \"Package Management\", \"Event Sourcing\"]\n}\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang Postgres  Or Whizbang SqlServer, Whizbang EntityFramework, etc `\nStep 2: Define Events\nCreate Events/OrderEvents cs:\n`csharp{\ntitle: \"Order Domain Events\"\ndescription: \"Events representing order lifecycle state changes\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"BEGINNER\"\ntags: [\"Events\", \"Event Sourcing\", \"Domain Events\"]\nfilename: \"Events/OrderEvents cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nnamespace MyApp Events;\n[OwnedBy(\"Orders\")]  // This event comes from the Orders domain\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset PlacedAt,\n    List<OrderItem> Items,\n    decimal Total\n);\n[OwnedBy(\"Orders\")]\npublic record OrderShipped(\n    Guid OrderId,\n    DateTimeOffset ShippedAt,\n    string TrackingNumber\n);\n`\nStep 3: Create a Stateful Receptor\nCreate Receptors/OrderReceptor cs:\n`csharp{\ntitle: \"Event-Sourced Order Receptor\"\ndescription: \"Stateful receptor for event-sourced orders\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Receptors\", \"Event Sourcing\", \"Stateful\"]\nfilename: \"Receptors/OrderReceptor cs\"\nusingStatements: [\"System\", \"Whizbang\", \"MyApp Commands\", \"MyApp Events\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing MyApp Commands;\nusing MyApp Events;\nnamespace MyApp Receptors;\n[EventSourced]\npublic class OrderReceptor : \n    IReceptor<PlaceOrder>,\n    IReceptor<ShipOrder> {\n    private Guid id;\n    private Guid customerId;\n    private OrderStatus status;\n    private List<OrderItem> items = new();\n    private decimal total;\n    // Command handler for new orders\n    public OrderPlaced Receive(PlaceOrder command) {\n        if (id = Guid Empty) {\n            throw new InvalidOperationException(\"Order already exists\");\n        }\n        if (command Items Count == 0) {\n            throw new InvalidOperationException(\"Order must have items\");\n        }\n        var orderTotal = command Items Sum(i => i",
        "startIndex": 8361,
        "preview": "models D-->>API: OrderPlaced event Note over API,P: Events stored as immutable log<br/>Complete audit trail ` > 📦 Learn more: See Whizbang EventSourc..."
      },
      {
        "id": "old-v1.0.0/getting-started/getting-started-chunk-5",
        "text": "= new(); private decimal total; // Command handler for new orders public OrderPlaced Receive(PlaceOrder command) { if (id = Guid Empty) { throw new InvalidOperationException(\"Order already exists\"); } if (command Items Count == 0) { throw new InvalidOperationException(\"Order must have items\"); } var orderTotal = command Items Sum(i => i Price * i Quantity);\n        return new OrderPlaced(\n            Guid NewGuid(),\n            command CustomerId,\n            DateTimeOffset UtcNow,\n            command Items,\n            orderTotal\n        );\n    }\n    // Command handler for shipping\n    public OrderShipped Receive(ShipOrder command) {\n        if (status = OrderStatus Placed) {\n            throw new InvalidOperationException(\"Only placed orders can be shipped\");\n        }\n        return new OrderShipped(id, DateTimeOffset UtcNow, command TrackingNumber);\n    }\n    // Event handler - updates internal state\n    public void Absorb(OrderPlaced @event) {\n        id = @event OrderId;\n        customerId = @event CustomerId;\n        status = OrderStatus Placed;\n        items = @event Items ToList();\n        total = @event Total;\n    }\n    // Event handler - updates internal state\n    public void Absorb(OrderShipped @event) {\n        status = OrderStatus Shipped;\n    }\n}\npublic enum OrderStatus {\n    Placed,\n    Shipped,\n    Delivered,\n    Cancelled\n}\npublic record ShipOrder(Guid OrderId, string TrackingNumber);\n`\nStep 4: Add Event Definitions\nUpdate Events/OrderEvents cs with shipping event:\n`csharp{\ntitle: \"Complete Order Domain Events\"\ndescription: \"Events representing complete order lifecycle\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"BEGINNER\"\ntags: [\"Events\", \"Event Sourcing\", \"Domain Events\"]\nfilename: \"Events/OrderEvents cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nnamespace MyApp Events;\n[OwnedBy(\"Orders\")]\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset PlacedAt,\n    List<OrderItem> Items,\n    decimal Total\n);\n[OwnedBy(\"Orders\")]\npublic record OrderShipped(\n    Guid OrderId,\n    DateTimeOffset ShippedAt,\n    string TrackingNumber\n);\n`\nStep 5: Configure Event Sourcing\nUpdate Program cs:\n`csharp{\ntitle: \"Event Sourcing Configuration\"\ndescription: \"Configure Whizbang dispatcher with event sourcing and ledger\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Configuration\", \"Event Sourcing\", \"Postgres\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nvar builder = WebApplication",
        "startIndex": 4224,
        "preview": "= new(); private decimal total; // Command handler for new orders public OrderPlaced Receive(PlaceOrder command) { if (id = Guid Empty) { throw new In..."
      },
      {
        "id": "old-v1.0.0/getting-started/getting-started-chunk-6",
        "text": "5: Configure Event Sourcing Update Program cs: `csharp{ title: \"Event Sourcing Configuration\" description: \"Configure Whizbang dispatcher with event sourcing and ledger\" framework: \"NET8\" category: \"Event Sourcing\" difficulty: \"INTERMEDIATE\" tags: [\"Configuration\", \"Event Sourcing\", \"Postgres\"] filename: \"Program cs\" usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"] showLineNumbers: true } using Whizbang; var builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbang(dispatcher => {\n    dispatcher RegisterReceptorsFromAssembly(typeof(Program) Assembly);\n    dispatcher RegisterPerspectivesFromAssembly(typeof(Program) Assembly);\n    // Enable event sourcing with ledger\n    dispatcher UseEventSourcing(es => {\n        es UseLedger(ledger => {\n            ledger UsePostgres(builder Configuration GetConnectionString(\"EventStore\"));\n        });\n    });\n});\nvar app = builder Build();\napp MapPost(\"/orders\", async (PlaceOrder command, IDispatcher dispatcher) => {\n    var @event = await dispatcher Send(command);\n    return Results Ok(new { OrderId = @event OrderId, Total = @event Total });\n});\napp Run();\n`\nAdd connection string to appsettings json:\n`json\n{\n  \"ConnectionStrings\": {\n    \"EventStore\": \"Host=localhost;Database=myapp;Username=user;Password=pass\"\n  }\n}\n`\nNow you have full event sourcing Receptors maintain state from events stored in the ledger, providing a complete audit trail and the ability to replay state from any point in time ---\nAdding Multiple Perspectives (Read Models)\nLet's add additional perspectives to maintain different views of order data for efficient queries `mermaid\ngraph TB\n    subgraph \"Write Side (Commands)\"\n        CMD[PlaceOrder Command]\n        AGG[Order Aggregate]\n        ES[Event Store]\n    end\n    subgraph \"Event Bus\"\n        EVT[OrderPlaced Event]\n    end\n    subgraph \"Read Side (Queries)\"\n        PROJ[OrderHistoryProjection]\n        RM[Read Model DB]\n        QUERY[Query: Get Orders]\n    end\n    CMD -->|Creates| AGG\n    AGG -->|Stores events| ES\n    ES -->|Publishes| EVT\n    EVT -->|Subscribes| PROJ\n    PROJ -->|Updates| RM\n    QUERY -->|Reads from| RM\n    class CMD layer-command\n    class AGG layer-core\n    class ES layer-event\n    class PROJ layer-read\n    class RM layer-read\n`\n> 📦 Learn more: See Whizbang Perspectives in the Package Structure guide for advanced perspective patterns and database integration Step 1: Create Order History Lens\nCreate Lenses/IOrderLens",
        "startIndex": 12930,
        "preview": "5: Configure Event Sourcing Update Program cs: `csharp{ title: \"Event Sourcing Configuration\" description: \"Configure Whizbang dispatcher with event s..."
      },
      {
        "id": "old-v1.0.0/getting-started/getting-started-chunk-7",
        "text": "PROJ -->|Updates| RM QUERY -->|Reads from| RM class CMD layer-command class AGG layer-core class ES layer-event class PROJ layer-read class RM layer-read ` > 📦 Learn more: See Whizbang Perspectives in the Package Structure guide for advanced perspective patterns and database integration Step 1: Create Order History Lens Create Lenses/IOrderLens cs:\n`csharp{\ntitle: \"Order Lens Interface\"\ndescription: \"Read-only lens for querying orders\"\nframework: \"NET8\"\ncategory: \"Lenses\"\ndifficulty: \"BEGINNER\"\ntags: [\"Lenses\", \"Queries\", \"Read-Only\"]\nfilename: \"Lenses/IOrderLens cs\"\nusingStatements: [\"System\", \"System Linq Expressions\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Linq Expressions;\nnamespace MyApp Lenses;\npublic interface IOrderLens {\n    OrderSummary Focus(Guid orderId);\n    IEnumerable<OrderSummary> ViewByCustomer(Guid customerId);\n    IEnumerable<OrderSummary> View(Expression<Func<OrderSummary, bool>> filter);\n    bool Exists(Guid orderId);\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    public DateTimeOffset PlacedAt { get; set; }\n    public DateTimeOffset ShippedAt { get; set; }\n    public decimal Total { get; set; }\n    public string Status { get; set; }\n}\n`\nStep 2: Create Order History Perspective\nCreate Perspectives/OrderHistoryPerspective cs:\n`csharp{\ntitle: \"Order History Perspective\"\ndescription: \"Perspective that maintains order history for queries\"\nframework: \"NET8\"\ncategory: \"Perspectives\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Read Models\", \"Multiple Views\"]\nfilename: \"Perspectives/OrderHistoryPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\", \"MyApp Events\", \"MyApp Lenses\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\nusing MyApp Events;\nusing MyApp Lenses;\nnamespace MyApp Perspectives;\npublic class OrderHistoryPerspective : \n    IPerspectiveOf<OrderPlaced>,\n    IPerspectiveOf<OrderShipped> {\n    private readonly IOrderHistoryDatabase db;\n    public OrderHistoryPerspective(IOrderHistoryDatabase db) {\n        _db = db;\n    }\n    public async Task Update(OrderPlaced @event) {\n        await _db OrderHistory Add(new OrderSummary {\n            OrderId = @event OrderId,\n            CustomerId = @event CustomerId,\n            PlacedAt = @event PlacedAt,\n            Total = @event Total,\n            Status = \"Placed\"\n        });\n        await _db SaveChanges();\n    }\n    public async Task Update(OrderShipped @event) {\n        var order = await _db OrderHistory Get(@event OrderId);\n        order ShippedAt = @event ShippedAt;\n        order",
        "startIndex": 14949,
        "preview": "PROJ -->|Updates| RM QUERY -->|Reads from| RM class CMD layer-command class AGG layer-core class ES layer-event class PROJ layer-read class RM layer-r..."
      },
      {
        "id": "old-v1.0.0/getting-started/getting-started-chunk-8",
        "text": "await _db OrderHistory Add(new OrderSummary { OrderId = @event OrderId, CustomerId = @event CustomerId, PlacedAt = @event PlacedAt, Total = @event Total, Status = \"Placed\" }); await _db SaveChanges(); } public async Task Update(OrderShipped @event) { var order = await _db OrderHistory Get(@event OrderId); order ShippedAt = @event ShippedAt; order Status = \"Shipped\";\n        await _db SaveChanges();\n    }\n}\n`\nStep 3: Implement Order Lens\nCreate Lenses/OrderLens cs:\n`csharp{\ntitle: \"Order Lens Implementation\"\ndescription: \"Lens implementation for querying order history\"\nframework: \"NET8\"\ncategory: \"Lenses\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Implementation\", \"Database\"]\nfilename: \"Lenses/OrderLens cs\"\nusingStatements: [\"System\", \"System Linq Expressions\", \"MyApp Lenses\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Linq Expressions;\nusing MyApp Lenses;\nnamespace MyApp Lenses;\npublic class OrderLens : IOrderLens {\n    private readonly IOrderHistoryDatabase db;\n    public OrderLens(IOrderHistoryDatabase db) {\n        _db = db;\n    }\n    public OrderSummary Focus(Guid orderId) {\n        return _db OrderHistory FirstOrDefault(o => o OrderId == orderId);\n    }\n    public IEnumerable<OrderSummary> ViewByCustomer(Guid customerId) {\n        return _db OrderHistory Where(o => o CustomerId == customerId) OrderByDescending(o => o PlacedAt);\n    }\n    public IEnumerable<OrderSummary> View(Expression<Func<OrderSummary, bool>> filter) {\n        return _db OrderHistory Where(filter);\n    }\n    public bool Exists(Guid orderId) {\n        return _db OrderHistory Any(o => o OrderId == orderId);\n    }\n}\n`\nStep 4: Configure Multiple Perspectives\nUpdate Program cs:\n`csharp{\ntitle: \"Multiple Perspectives Configuration\"\ndescription: \"Configure multiple perspectives in Whizbang dispatcher\"\nframework: \"NET8\"\ncategory: \"Perspectives\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Configuration\", \"Perspectives\", \"Multiple Views\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"MyApp Lenses\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing MyApp Lenses;\nbuilder Services AddWhizbang(dispatcher => {\n    dispatcher RegisterReceptorsFromAssembly(typeof(Program) Assembly);\n    dispatcher RegisterPerspectivesFromAssembly(typeof(Program) Assembly);\n    // Register lenses\n    dispatcher RegisterLensesFromAssembly(typeof(Program) Assembly);\n    dispatcher UseEventSourcing(es => {\n        es UseLedger(ledger => {\n            ledger UsePostgres(connectionString);\n        });\n    });\n});\n// Register lens implementations\nbuilder Services",
        "startIndex": 17247,
        "preview": "await _db OrderHistory Add(new OrderSummary { OrderId = @event OrderId, CustomerId = @event CustomerId, PlacedAt = @event PlacedAt, Total = @event Tot..."
      },
      {
        "id": "old-v1.0.0/getting-started/getting-started-chunk-9",
        "text": "[\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"MyApp Lenses\"] showLineNumbers: true } using Whizbang; using MyApp Lenses; builder Services AddWhizbang(dispatcher => { dispatcher RegisterReceptorsFromAssembly(typeof(Program) Assembly); dispatcher RegisterPerspectivesFromAssembly(typeof(Program) Assembly); // Register lenses dispatcher RegisterLensesFromAssembly(typeof(Program) Assembly); dispatcher UseEventSourcing(es => { es UseLedger(ledger => { ledger UsePostgres(connectionString); }); }); }); // Register lens implementations builder Services AddScoped<IOrderLens, OrderLens>();\n`\nStep 5: Query via Lens\nAdd query endpoint:\n`csharp{\ntitle: \"Query Order History via Lens\"\ndescription: \"Query endpoint using order lens for read operations\"\nframework: \"NET8\"\ncategory: \"Lenses\"\ndifficulty: \"BEGINNER\"\ntags: [\"Queries\", \"Lenses\", \"API\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft AspNetCore Builder\", \"System\", \"MyApp Lenses\"]\nshowLineNumbers: true\n}\napp MapGet(\"/customers/{customerId}/orders\", (\n    Guid customerId,\n    IOrderLens lens\n) => {\n    var orders = lens ViewByCustomer(customerId);\n    return Results Ok(orders);\n});\napp MapGet(\"/orders/{orderId}\", (\n    Guid orderId,\n    IOrderLens lens\n) => {\n    var order = lens Focus(orderId);\n    return order = null Results Ok(order) : Results NotFound();\n});\n`\nNow you have complete CQRS Commands go to receptors (decision-making), events flow to perspectives (write side), and queries use lenses (read side) Multiple perspectives can maintain different views of the same events ---\nNext Steps\nYou've built a complete Event-Driven and Event-Sourced application with Whizbang Here's what to explore next:\nPhilosophy - Understand Whizbang's design principles and architectural philosophy\nCore Concepts - Deep dive into receptors, perspectives, lenses, and events\nPackage Structure - Learn about all available packages\nTesting - Test your event-driven and event-sourced applications\nDistributed Messaging - Scale to microservices with relays and message brokers\nSagas - Coordinate long-running processes across receptors\nObservability - Monitor your event-driven systems",
        "startIndex": 19515,
        "preview": "[\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"MyApp Lenses\"] showLineNumbers: true } using Whizbang; using MyApp Lenses; builder Services ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/getting-started/package-structure",
    "title": "Package Structure",
    "category": "Getting Started",
    "url": "/docs/old-v1.0.0/getting-started/package-structure",
    "chunks": [
      {
        "id": "old-v1.0.0/getting-started/package-structure-chunk-0",
        "text": "Package Structure\nThis is a reference guide to all available Whizbang NuGet packages, their capabilities, and how to choose the right ones for your application > 💡 New to Whizbang Start with the Getting Started Tutorial for hands-on, step-by-step learning Come back here when you need detailed package information Overview\nWhizbang is distributed as a suite of NuGet packages, allowing you to install only what you need This keeps your application lean and supports AOT compilation Package Philosophy:\nStart minimal - Begin with Whizbang Core (just the mediator)\nAdd as needed - Install event sourcing, projections, messaging only when required\nChoose your stack - Pick your preferred ORM (EF Core, Dapper, NHibernate) and message broker\nStay lean - No forced dependencies, excellent for AOT compilation\n`mermaid\n%%{init: {'flowchart': {'nodeSpacing': 800}, 'themeVariables': {'fontSize': '200px'}}}%%\ngraph LR\n    subgraph ORM[\"ORM Integrations\"]\n        WhizEF[Whizbang EntityFramework<br/>EF Core Integration]\n        WhizDapper[Whizbang Dapper<br/>Dapper Integration]\n        WhizNH[Whizbang NHibernate<br/>NHibernate Integration]\n    end\n    subgraph Core[\"Core Packages\"]\n        WhizCore[Whizbang Core<br/>Mediator, Handlers, Pipeline]\n        WhizES[Whizbang EventSourcing<br/>Event Store, Aggregates]\n        WhizProj[Whizbang Projections<br/>Read Models, Subscriptions]\n        WhizMsg[Whizbang Messaging<br/>Distributed Messaging, Outbox/Inbox]\n    end\n    subgraph Messaging[\"Message Broker Adapters\"]\n        WhizKafka[Whizbang Kafka]\n        WhizRabbit[Whizbang RabbitMQ]\n        WhizASB[Whizbang AzureServiceBus]\n        WhizSQS[Whizbang AWSSQS]\n    end\n    subgraph Observability[\"Observability\"]\n        WhizOTel[Whizbang OpenTelemetry<br/>Tracing, Metrics]\n        WhizDash[Whizbang Dashboard<br/>Monitoring UI]\n    end\n    subgraph Dev[\"Developer Tools\"]\n        WhizAnalyzers[Whizbang Analyzers<br/>Roslyn Analyzers, Purity Checks]\n        WhizTesting[Whizbang Testing<br/>In-Memory Doubles, Test Helpers]\n    end\n    ORM - ->|Require| WhizES\n    Messaging -",
        "startIndex": 0,
        "preview": "Package Structure\nThis is a reference guide to all available Whizbang NuGet packages, their capabilities, and how to choose the right ones for your ap..."
      },
      {
        "id": "old-v1.0.0/getting-started/package-structure-chunk-1",
        "text": "Projections<br/>Read Models, Subscriptions] WhizMsg[Whizbang Messaging<br/>Distributed Messaging, Outbox/Inbox] end subgraph Messaging[\"Message Broker Adapters\"] WhizKafka[Whizbang Kafka] WhizRabbit[Whizbang RabbitMQ] WhizASB[Whizbang AzureServiceBus] WhizSQS[Whizbang AWSSQS] end subgraph Observability[\"Observability\"] WhizOTel[Whizbang OpenTelemetry<br/>Tracing, Metrics] WhizDash[Whizbang Dashboard<br/>Monitoring UI] end subgraph Dev[\"Developer Tools\"] WhizAnalyzers[Whizbang Analyzers<br/>Roslyn Analyzers, Purity Checks] WhizTesting[Whizbang Testing<br/>In-Memory Doubles, Test Helpers] end ORM - ->|Require| WhizES Messaging - ->|Require| WhizMsg\n    WhizES --> WhizCore\n    WhizProj --> WhizCore\n    WhizProj --> WhizES\n    WhizMsg --> WhizCore\n`\nFunctional Area Color Key\nThe diagram uses color-coded edges to indicate functional areas:\n🟢 Green (Core) - Core business logic and domain functionality\n🔴 Red (Event) - Event sourcing, data persistence, and event handling\n🔵 Blue (Read) - Read models, projections, and query operations\n🟡 Yellow (Command) - Commands, write operations, and distributed messaging\n🔷 Teal (Observability) - Telemetry, metrics, tracing, and monitoring\n🟣 Purple (Infrastructure) - Developer tools, analyzers, and testing utilities\nCore Packages\nWhizbang Core\nThe minimal foundation for all Whizbang applications `bash{\ntitle: \"Install Whizbang Core Package\"\ndescription: \"Install the minimal foundation package for Whizbang applications\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Core\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang Core\n`\nIncludes:\nMessage routing (commands, events, queries)\nIn-memory mediator\nHandler discovery and execution\nBasic pipeline (validation, authorization hooks)\nNo persistence, no external messaging\nUse when:\nBuilding a simple CQRS application\nYou don't need event sourcing or projections\nIn-process messaging is sufficient\nLearning Whizbang\nExample:\n`csharp{\ntitle: \"Simple Mediator Setup - Complete Program cs\"\ndescription: \"Complete example showing Whizbang Core as an in-process mediator with handler discovery\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Mediator\", \"CQRS\", \"Setup\", \"Program cs\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\"]\nshowLineNumbers: true\ncollapsedLines: [1-3, 25-35]\n}\n// Stage 1: Imports\nusing Microsoft Extensions DependencyInjection;\nusing Microsoft Extensions",
        "startIndex": 2086,
        "preview": "Projections<br/>Read Models, Subscriptions] WhizMsg[Whizbang Messaging<br/>Distributed Messaging, Outbox/Inbox] end subgraph Messaging[\"Message Broker..."
      },
      {
        "id": "old-v1.0.0/getting-started/package-structure-chunk-2",
        "text": "Whizbang Core as an in-process mediator with handler discovery\" framework: \"NET8\" category: \"Getting Started\" difficulty: \"BEGINNER\" tags: [\"Mediator\", \"CQRS\", \"Setup\", \"Program cs\"] nugetPackages: [\"Whizbang Core\"] usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\"] showLineNumbers: true collapsedLines: [1-3, 25-35] } // Stage 1: Imports using Microsoft Extensions DependencyInjection; using Microsoft Extensions Hosting;\nusing Whizbang;\n// Stage 2: Host builder setup\nvar builder = Host CreateApplicationBuilder(args);\n// Stage 3: Register Whizbang mediator (in-memory only)\nbuilder Services AddWhizbang(options => {\n    // OPTION A: Source generator approach (recommended)\n    // Handlers decorated with [WhizbangHandler] are auto-discovered at compile time\n    options RegisterGeneratedHandlers();\n    // OPTION B: Explicit registration\n    // Manually register each handler for fine-grained control\n    // options RegisterHandler<PlaceOrder, PlaceOrderHandler>();\n    // options RegisterHandler<CancelOrder, CancelOrderHandler>();\n});\n// Stage 4: Build and run\nvar app = builder Build();\nawait app RunAsync();\n// Stage 5: Example handler decorated with [WhizbangHandler]\n[WhizbangHandler]  // Source generator picks this up\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderResult> {\n    public async Task<OrderResult> Handle(PlaceOrder command, CancellationToken ct) {\n        // Business logic here\n        return new OrderResult(command OrderId);\n    }\n}\n`\nHandler Discovery Approaches:\nWhizbang is 100% AOT-compatible and supports two ways to register handlers:\nSource Generator (Recommended): Decorate handlers with [WhizbangHandler] attribute At compile time, a source generator discovers all marked handlers and generates registration code Call options RegisterGeneratedHandlers() to use them `csharp\n   // Handler definition\n   [WhizbangHandler]\n   public class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderResult> { }\n   // Registration\n   options RegisterGeneratedHandlers();\n   `\n   Benefits:\nZero runtime reflection\nAOT-safe\nAutomatic discovery at compile time\nNo manual registration needed\nExplicit Registration: Manually register each handler Gives you full control and is AOT-safe `csharp\n   options RegisterHandler<PlaceOrder, PlaceOrderHandler>();\n   options",
        "startIndex": 4034,
        "preview": "Whizbang Core as an in-process mediator with handler discovery\" framework: \"NET8\" category: \"Getting Started\" difficulty: \"BEGINNER\" tags: [\"Mediator\"..."
      },
      {
        "id": "old-v1.0.0/getting-started/package-structure-chunk-3",
        "text": "`csharp // Handler definition [WhizbangHandler] public class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderResult> { } // Registration options RegisterGeneratedHandlers(); ` Benefits: Zero runtime reflection AOT-safe Automatic discovery at compile time No manual registration needed Explicit Registration: Manually register each handler Gives you full control and is AOT-safe `csharp options RegisterHandler<PlaceOrder, PlaceOrderHandler>(); options RegisterHandler<CancelOrder, CancelOrderHandler>();\n   `\n   Benefits:\nFine-grained control over registration\nNo attributes in domain code\nExplicit and obvious\nAOT-safe\nNote: The [WhizbangHandler] attribute can be placed on:\nThe handler class itself\nA base class the handler inherits from\nAn interface the handler implements\nThe source generator will discover handlers through any of these paths Attribute Naming: All Whizbang attributes use the Whizbang prefix for consistency and to avoid naming collisions ([WhizbangHandler], [WhizbangProjection], [WhizbangSubscribe]) ---\nWhizbang EventSourcing\nEvent sourcing and aggregate support `bash{\ntitle: \"Install Whizbang EventSourcing Package\"\ndescription: \"Add event sourcing and aggregate support to your application\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Event Sourcing\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang EventSourcing\n`\nIncludes:\nEvent store abstraction\nAggregate base classes\nEvent stream management\nOptimistic concurrency\nEvent versioning\nRequires a persistence driver (see below)\nUse when:\nYou need event sourcing\nBuilding event-sourced aggregates\nYou want complete audit trails\nExample:\n`csharp{\ntitle: \"Event Sourcing Setup - Complete Program cs\"\ndescription: \"Complete example adding event sourcing to your application\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Event Sourcing\", \"Aggregates\", \"Setup\", \"Program cs\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\"]\nshowLineNumbers: true\ncollapsedLines: [1-3, 7-8]\n}\n// Stage 1: Imports\nusing Microsoft Extensions DependencyInjection;\nusing Microsoft Extensions Hosting;\nusing Whizbang;\n// Stage 2: Host builder setup\nvar builder = Host CreateApplicationBuilder(args);\n// Stage 3: Register Whizbang with event sourcing\nbuilder Services AddWhizbang(options => {\n    // Register handlers (using source generator)\n    options",
        "startIndex": 5940,
        "preview": "`csharp // Handler definition [WhizbangHandler] public class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderResult> { } // Registration options ..."
      },
      {
        "id": "old-v1.0.0/getting-started/package-structure-chunk-4",
        "text": "true collapsedLines: [1-3, 7-8] } // Stage 1: Imports using Microsoft Extensions DependencyInjection; using Microsoft Extensions Hosting; using Whizbang; // Stage 2: Host builder setup var builder = Host CreateApplicationBuilder(args); // Stage 3: Register Whizbang with event sourcing builder Services AddWhizbang(options => { // Register handlers (using source generator) options RegisterGeneratedHandlers();\n    // Stage 4: Enable event sourcing\n    options UseEventSourcing(es => {\n        // For production, use an ORM integration (see ORM Integrations section)\n        // es UseEntityFramework(ef => ef UseNpgsql(connectionString));\n        // es UseDapper(d => d UseNpgsql(connectionString));\n        // For development/testing, use in-memory store\n        es UseInMemoryStore();\n    });\n});\n// Stage 5: Build and run\nvar app = builder Build();\nawait app RunAsync();\n`\n---\nWhizbang Projections\nRead-side projections and CQRS queries `bash{\ntitle: \"Install Whizbang Projections Package\"\ndescription: \"Add read-side projections and CQRS query support\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Projections\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang Projections\n`\nIncludes:\nProjection engine\nEvent subscription management\nCheckpoint tracking\nBackfilling from event history\nParallel processing across partitions\nUse when:\nBuilding read models from events\nImplementing CQRS\nYou need denormalized views for queries\nExample:\n`csharp{\ntitle: \"Projections Setup - Complete Program cs\"\ndescription: \"Complete example adding projection support with attribute-based registration\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"CQRS\", \"Read Models\", \"Program cs\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Projections\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\", \"System Threading Tasks\", \"System Threading\"]\nshowLineNumbers: true\ncollapsedLines: [1-3, 7-8, 28-30]\n}\n// Stage 1: Imports\nusing Microsoft Extensions DependencyInjection;\nusing Microsoft Extensions Hosting;\nusing Whizbang;\n// Stage 2: Host builder setup\nvar builder = Host CreateApplicationBuilder(args);\n// Stage 3: Register Whizbang with projections\nbuilder Services AddWhizbang(options => {\n    options RegisterGeneratedHandlers();\n    options UseEventSourcing(es => es UseInMemoryStore());\n    // Stage 4: Enable projections\n    options",
        "startIndex": 8035,
        "preview": "true collapsedLines: [1-3, 7-8] } // Stage 1: Imports using Microsoft Extensions DependencyInjection; using Microsoft Extensions Hosting; using Whizba..."
      },
      {
        "id": "old-v1.0.0/getting-started/package-structure-chunk-5",
        "text": "// Stage 1: Imports using Microsoft Extensions DependencyInjection; using Microsoft Extensions Hosting; using Whizbang; // Stage 2: Host builder setup var builder = Host CreateApplicationBuilder(args); // Stage 3: Register Whizbang with projections builder Services AddWhizbang(options => { options RegisterGeneratedHandlers(); options UseEventSourcing(es => es UseInMemoryStore()); // Stage 4: Enable projections options UseProjections(proj => {\n        // OPTION A: Attribute-based registration (recommended)\n        // Projections decorated with [Projection] are auto-discovered\n        proj RegisterGeneratedProjections();\n        // OPTION B: Manual registration\n        // proj RegisterProjection<OrderHistoryProjection>();\n        // proj RegisterProjection<CustomerSummaryProjection>();\n    });\n});\n// Stage 5: Build and run\nvar app = builder Build();\nawait app RunAsync();\n// Stage 6: Example projection with attribute-based event subscriptions\n[WhizbangProjection]  // Source generator picks this up\npublic class OrderHistoryProjection {\n    private readonly List<OrderSummary> _orders = new();\n    // Subscribe to events using [WhizbangSubscribe] attribute on method parameter\n    public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) {\n        _orders Add(new OrderSummary(\n            @event OrderId,\n            @event CustomerId,\n            @event Total,\n            \"Placed\"\n        ));\n        return Task CompletedTask;\n    }\n    public Task Handle([WhizbangSubscribe] OrderShipped @event, CancellationToken ct) {\n        var order = _orders First(o => o OrderId == @event OrderId);\n        order Status = \"Shipped\";\n        return Task CompletedTask;\n    }\n    // Query method (not a subscription)\n    public IEnumerable<OrderSummary> GetOrders() => _orders;\n}\npublic record OrderSummary(Guid OrderId, Guid CustomerId, decimal Total, string Status) {\n    public string Status { get; set; } = Status;\n}\n`\nProjection Registration Approaches:\nWhizbang supports two ways to register projections:\nAttribute-Based (Recommended for AOT): Decorate projection classes with [WhizbangProjection] and mark event handler parameters with [WhizbangSubscribe] `csharp\n   [WhizbangProjection]  // Can be on class, base class, or interface\n   public class OrderHistoryProjection {\n       public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) {\n           // Handle event\n       }\n   }\n   // Registration\n   proj RegisterGeneratedProjections();\n   `\nManual Registration: Explicitly register each projection `csharp\n   proj RegisterProjection<OrderHistoryProjection>();\n   proj",
        "startIndex": 10186,
        "preview": "// Stage 1: Imports using Microsoft Extensions DependencyInjection; using Microsoft Extensions Hosting; using Whizbang; // Stage 2: Host builder setup..."
      },
      {
        "id": "old-v1.0.0/getting-started/package-structure-chunk-6",
        "text": "and mark event handler parameters with [WhizbangSubscribe] `csharp [WhizbangProjection] // Can be on class, base class, or interface public class OrderHistoryProjection { public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) { // Handle event } } // Registration proj RegisterGeneratedProjections(); ` Manual Registration: Explicitly register each projection `csharp proj RegisterProjection<OrderHistoryProjection>(); proj RegisterProjection<CustomerSummaryProjection>();\n   `\nEvent Subscription with [WhizbangSubscribe] Attribute:\nPlace [WhizbangSubscribe] directly on the method parameter representing the event\nOnly one parameter per method can have [WhizbangSubscribe]\nAdditional parameters (like CancellationToken, injected services, EventContext, ProjectionContext) are allowed\nMethod names are flexible: Use Handle, On, When, or any descriptive name you prefer\nAuto-registration: The source generator automatically wires subscriptions to service configuration\nThe source generator validates subscription rules at compile time\nSupports polymorphism: Subscribe to base classes or interfaces to handle multiple event types\nFor complete projection documentation, see:\nProjection Subscriptions - Event subscription patterns, polymorphism, generics, flexible method naming\nProjection Contexts - EventContext and ProjectionContext injection for metadata and CRUD operations\nProjection Purity - Maintaining pure, deterministic projections with compile-time enforcement\nProjection Return Values - Using return values for observability and metrics\nFor command handling documentation, see:\nCommand Handling - Business logic, CommandContext, event emission, sagas, and workflows\nWhizbang Messaging\nDistributed messaging and outbox/inbox patterns `bash{\ntitle: \"Install Whizbang Messaging Package\"\ndescription: \"Add distributed messaging and outbox/inbox patterns for microservices\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Messaging\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang Messaging\n`\nIncludes:\nMessage broker abstraction\nOutbox/Inbox pattern for exactly-once delivery\nDomain ownership routing\nSaga coordination\nRequires a message broker adapter (see below)\nUse when:\nBuilding microservices\nYou need distributed messaging\nCommands/events cross service boundaries\nExample:\n`csharp{\ntitle: \"Distributed Messaging Setup - Complete Program",
        "startIndex": 12404,
        "preview": "and mark event handler parameters with [WhizbangSubscribe] `csharp [WhizbangProjection] // Can be on class, base class, or interface public class Orde..."
      },
      {
        "id": "old-v1.0.0/getting-started/package-structure-chunk-7",
        "text": "false } dotnet add package Whizbang Messaging ` Includes: Message broker abstraction Outbox/Inbox pattern for exactly-once delivery Domain ownership routing Saga coordination Requires a message broker adapter (see below) Use when: Building microservices You need distributed messaging Commands/events cross service boundaries Example: `csharp{ title: \"Distributed Messaging Setup - Complete Program cs\"\ndescription: \"Complete example configuring Whizbang for microservices with message broker\"\nframework: \"NET8\"\ncategory: \"Distributed Systems\"\ndifficulty: \"ADVANCED\"\ntags: [\"Messaging\", \"Microservices\", \"Distributed Systems\", \"Program cs\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Messaging\", \"Whizbang Kafka\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\"]\nshowLineNumbers: true\ncollapsedLines: [1-3, 7-8, 36-38]\n}\n// Stage 1: Imports\nusing Microsoft Extensions DependencyInjection;\nusing Microsoft Extensions Hosting;\nusing Whizbang;\n// Stage 2: Host builder setup\nvar builder = Host CreateApplicationBuilder(args);\n// Stage 3: Register Whizbang with distributed messaging\nbuilder Services AddWhizbang(options => {\n    options RegisterGeneratedHandlers();\n    options UseEventSourcing(es => es UseInMemoryStore());\n    // Stage 4: Enable distributed messaging\n    options UseMessaging(msg => {\n        // Register logical domain ownership (no URLs - services communicate via broker)\n        msg UseDomainOwnership(domains => {\n            // Declare which domains THIS service owns\n            domains RegisterDomain(\"Orders\");    // This service owns Orders domain\n            domains RegisterDomain(\"Payments\");  // This service owns Payments domain\n            // Other domains owned by other services:\n            // - \"Inventory\" owned by Inventory service\n            // - \"Shipping\" owned by Shipping service\n        });\n        // Configure message broker (how services actually communicate)\n        msg UseKafka(kafka => {\n            kafka BootstrapServers = \"localhost:9092\";\n            // Topic routing based on domain ownership\n            kafka CommandTopicPattern = \"commands {domain}\";  // commands Orders, commands Inventory\n            kafka EventTopicPattern = \"events {domain}\";      // events Orders, events Payments\n        });\n        // Enable exactly-once semantics\n        msg UseOutbox();  // Reliable message publishing (transactional)\n        msg UseInbox();   // Idempotent message consumption (deduplication)\n    });\n});\n// Stage 5: Build and run\nvar app = builder Build();\nawait app",
        "startIndex": 14411,
        "preview": "false } dotnet add package Whizbang Messaging ` Includes: Message broker abstraction Outbox/Inbox pattern for exactly-once delivery Domain ownership r..."
      },
      {
        "id": "old-v1.0.0/getting-started/package-structure-chunk-8",
        "text": "{domain}\"; // commands Orders, commands Inventory kafka EventTopicPattern = \"events {domain}\"; // events Orders, events Payments }); // Enable exactly-once semantics msg UseOutbox(); // Reliable message publishing (transactional) msg UseInbox(); // Idempotent message consumption (deduplication) }); }); // Stage 5: Build and run var app = builder Build(); await app RunAsync();\n`\nDomain Ownership Explained:\nDomain ownership is logical, not physical Services declare which domains they own, and Whizbang routes messages based on ownership:\nCommands are sent TO the domain owner\nEvents are published BY the domain owner\nServices communicate via message broker (not HTTP endpoints)\nExample Message Flow:\n`csharp\n// Inventory service sends PlaceOrder command\n// → Whizbang routes to Kafka topic \"commands Orders\"\n// → Orders service (domain owner) receives and handles it\nawait whizbang Send(new PlaceOrder( ));\n// Orders service publishes OrderPlaced event\n// → Whizbang publishes to Kafka topic \"events Orders\"\n// → All interested services (Inventory, Shipping, etc ) receive it\nawait whizbang Publish(new OrderPlaced( ));\n`\nRouting Configuration:\nThe message broker adapter handles physical routing Different deployment scenarios use different configurations:\nIn-Process (Monolith): All domains in one service, in-memory routing\nMicroservices (Kafka): Domains in separate services, Kafka topics\nKubernetes (RabbitMQ): Pods communicate via RabbitMQ exchanges\nHybrid: Some domains in-process, others distributed\nThe domain registration stays the same—only the message broker adapter configuration changes ---\nORM Integrations\nWhizbang uses ORMs (not custom database drivers) for persistence, allowing you to leverage existing tools and database compatibility Whizbang EntityFramework\nEntity Framework Core integration for event store and projections `bash{\ntitle: \"Install Whizbang EntityFramework Package\"\ndescription: \"Add Entity Framework Core integration for event store and projections\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Entity Framework\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang",
        "startIndex": 16592,
        "preview": "{domain}\"; // commands Orders, commands Inventory kafka EventTopicPattern = \"events {domain}\"; // events Orders, events Payments }); // Enable exactly..."
      },
      {
        "id": "old-v1.0.0/getting-started/package-structure-chunk-9",
        "text": "compatibility Whizbang EntityFramework Entity Framework Core integration for event store and projections `bash{ title: \"Install Whizbang EntityFramework Package\" description: \"Add Entity Framework Core integration for event store and projections\" framework: \"NET8\" category: \"Getting Started\" difficulty: \"INTERMEDIATE\" tags: [\"Getting Started\", \"Packages\", \"Installation\", \"Entity Framework\"] showLineNumbers: false } dotnet add package Whizbang EntityFramework\n`\nFeatures:\nWorks with ANY EF Core database provider (Postgres, SQL Server, MySQL, SQLite, Cosmos DB, etc )\nAutomatic migrations for event store schema\nDbContext integration for projections\nChange tracking for optimistic concurrency\nFull LINQ query support for projections\nShadow properties for metadata\nUse when:\nYou're already using Entity Framework Core\nYou want automatic migrations and schema management\nYou need complex LINQ queries in projections\nYou prefer convention-over-configuration\nExample with Postgres:\n`csharp{\ntitle: \"Entity Framework with Postgres\"\ndescription: \"Using EF Core with Postgres for event store and projections\"\nframework: \"NET8\"\ncategory: \"Persistence\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Entity Framework\", \"Postgres\", \"Event Store\", \"ORM\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang EntityFramework\", \"Npgsql EntityFrameworkCore PostgreSQL\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseEntityFramework(ef => {\n            // Use any EF Core database provider\n            ef UseNpgsql(\"Host=localhost;Database=myapp;Username=user;Password=pass\");\n            // Optional: customize event store schema\n            ef EventStoreSchema = \"events\";\n            ef EnableSensitiveDataLogging = false;\n        });\n    });\n});\n`\nExample with SQL Server:\n`csharp{\ntitle: \"Entity Framework with SQL Server\"\ndescription: \"Using EF Core with SQL Server for event store\"\nframework: \"NET8\"\ncategory: \"Persistence\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Entity Framework\", \"SQL Server\", \"Event Store\", \"ORM\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang EntityFramework\", \"Microsoft EntityFrameworkCore SqlServer\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseEntityFramework(ef => {\n            ef",
        "startIndex": 18425,
        "preview": "compatibility Whizbang EntityFramework Entity Framework Core integration for event store and projections `bash{ title: \"Install Whizbang EntityFramewo..."
      },
      {
        "id": "old-v1.0.0/getting-started/package-structure-chunk-10",
        "text": "tags: [\"Entity Framework\", \"SQL Server\", \"Event Store\", \"ORM\"] nugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang EntityFramework\", \"Microsoft EntityFrameworkCore SqlServer\"] usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"] showLineNumbers: true } using Microsoft Extensions DependencyInjection; using Whizbang; var services = new ServiceCollection(); services AddWhizbang(options => { options UseEventSourcing(es => { es UseEntityFramework(ef => { ef UseSqlServer(\"Server=localhost;Database=myapp;Trusted_Connection=True;\");\n        });\n    });\n});\n`\n---\nWhizbang Dapper\nDapper integration for high-performance event store and projections `bash{\ntitle: \"Install Whizbang Dapper Package\"\ndescription: \"Add high-performance Dapper integration for event store and projections\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Dapper\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang Dapper\n`\nFeatures:\nWorks with ANY ADO NET database provider (Postgres, SQL Server, MySQL, SQLite, Oracle, etc )\nMinimal overhead - nearly raw SQL performance\nExplicit control over SQL queries\nBulk insert optimizations for event batches\nCustom type handlers for domain types\nMulti-database support in single application\nUse when:\nPerformance is critical\nYou want explicit control over SQL\nYou're comfortable writing queries\nYou need the absolute fastest event sourcing\nYou're using multiple database types\nExample with Postgres:\n`csharp{\ntitle: \"Dapper with Postgres\"\ndescription: \"Using Dapper with Postgres for high-performance event store\"\nframework: \"NET8\"\ncategory: \"Persistence\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Dapper\", \"Postgres\", \"Event Store\", \"Performance\", \"ORM\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Dapper\", \"Npgsql\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseDapper(dapper => {\n            dapper UseNpgsql(\"Host=localhost;Database=myapp;Username=user;Password=pass\");\n            // Optional: customize SQL queries for specific database optimizations\n            dapper UseJsonBinaryFormat = true;  // Postgres JSONB\n            dapper",
        "startIndex": 20688,
        "preview": "tags: [\"Entity Framework\", \"SQL Server\", \"Event Store\", \"ORM\"] nugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang EntityFramework\", ..."
      },
      {
        "id": "old-v1.0.0/getting-started/package-structure-chunk-11",
        "text": "usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"] showLineNumbers: true } using Microsoft Extensions DependencyInjection; using Whizbang; var services = new ServiceCollection(); services AddWhizbang(options => { options UseEventSourcing(es => { es UseDapper(dapper => { dapper UseNpgsql(\"Host=localhost;Database=myapp;Username=user;Password=pass\"); // Optional: customize SQL queries for specific database optimizations dapper UseJsonBinaryFormat = true; // Postgres JSONB dapper BatchSize = 1000;            // Bulk insert optimization\n        });\n    });\n});\n`\nExample with SQL Server:\n`csharp{\ntitle: \"Dapper with SQL Server\"\ndescription: \"Using Dapper with SQL Server for event store\"\nframework: \"NET8\"\ncategory: \"Persistence\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Dapper\", \"SQL Server\", \"Event Store\", \"Performance\", \"ORM\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Dapper\", \"Microsoft Data SqlClient\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseDapper(dapper => {\n            dapper UseSqlServer(\"Server=localhost;Database=myapp;Trusted_Connection=True;\");\n            // SQL Server optimizations\n            dapper UseMemoryOptimizedTables = true;\n            dapper EnableChangeTracking = true;\n        });\n    });\n});\n`\n---\nWhizbang NHibernate\nNHibernate integration for event store and projections `bash{\ntitle: \"Install Whizbang NHibernate Package\"\ndescription: \"Add NHibernate integration for event store and projections\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"NHibernate\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang NHibernate\n`\nFeatures:\nWorks with ANY NHibernate-supported database (Postgres, SQL Server, MySQL, Oracle, SQLite, etc )\nMature ORM with extensive database support\nXML or fluent mapping configuration\nAdvanced caching strategies (first-level, second-level, query cache)\nLazy loading and eager fetching strategies\nSupports legacy database schemas\nUse when:\nYou're already using NHibernate\nYou need advanced caching strategies\nYou're working with legacy database schemas\nYou require complex mapping scenarios\nYou want mature, battle-tested ORM\nExample with Postgres:\n`csharp{\ntitle: \"NHibernate with Postgres\"\ndescription: \"Using NHibernate with Postgres for event store\"\nframework: \"NET8\"\ncategory: \"Persistence\"\ndifficulty: \"ADVANCED\"\ntags: [\"NHibernate\", \"Postgres\", \"Event Store\", \"ORM\"]\nnugetPackages: [\"Whizbang",
        "startIndex": 22632,
        "preview": "usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"] showLineNumbers: true } using Microsoft Extensions DependencyInjection; usin..."
      },
      {
        "id": "old-v1.0.0/getting-started/package-structure-chunk-12",
        "text": "need advanced caching strategies You're working with legacy database schemas You require complex mapping scenarios You want mature, battle-tested ORM Example with Postgres: `csharp{ title: \"NHibernate with Postgres\" description: \"Using NHibernate with Postgres for event store\" framework: \"NET8\" category: \"Persistence\" difficulty: \"ADVANCED\" tags: [\"NHibernate\", \"Postgres\", \"Event Store\", \"ORM\"] nugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang NHibernate\", \"NHibernate\", \"NHibernate Driver NpgsqlDriver\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\", \"NHibernate Cfg\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing NHibernate Cfg;\nusing Whizbang;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseNHibernate(nh => {\n            nh ConfigureWith(cfg => {\n                cfg DataBaseIntegration(db => {\n                    db ConnectionString = \"Host=localhost;Database=myapp;Username=user;Password=pass\";\n                    db Driver<NpgsqlDriver>();\n                    db Dialect<PostgreSQLDialect>();\n                });\n                // Optional: enable second-level cache\n                cfg Cache(c => {\n                    c UseSecondLevelCache = true;\n                    c UseQueryCache = true;\n                });\n            });\n        });\n    });\n});\n`\n---\nChoosing an ORM\nEntity Framework - Best for:\nGeneral-purpose applications\nAutomatic migrations\nConvention-over-configuration\nComplex LINQ queries\nMost NET developers (familiar)\nDapper - Best for:\nHigh-performance scenarios\nExplicit SQL control\nMinimal overhead\nLarge event volumes\nPolyglot persistence (multiple databases)\nNHibernate - Best for:\nLegacy database integration\nAdvanced caching requirements\nComplex mapping scenarios\nEnterprise applications with existing NHibernate usage\n---\nMessage Broker Adapters\nWhizbang Kafka\nApache Kafka adapter for distributed messaging `bash{\ntitle: \"Install Whizbang Kafka Package\"\ndescription: \"Add Apache Kafka adapter for distributed messaging\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Kafka\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang Kafka\n`\nFeatures:\nHigh throughput\nPartition-aware consumers\nCompacted topics for snapshots\nExactly-once semantics\nUse when:\nBuilding event-driven microservices at scale\nYou need event replay and time-travel capabilities\n---\nWhizbang RabbitMQ\nRabbitMQ adapter for distributed messaging `bash{\ntitle: \"Install Whizbang",
        "startIndex": 7489,
        "preview": "need advanced caching strategies You're working with legacy database schemas You require complex mapping scenarios You want mature, battle-tested ORM ..."
      },
      {
        "id": "old-v1.0.0/getting-started/package-structure-chunk-13",
        "text": "Started\", \"Packages\", \"Installation\", \"Kafka\"] showLineNumbers: false } dotnet add package Whizbang Kafka ` Features: High throughput Partition-aware consumers Compacted topics for snapshots Exactly-once semantics Use when: Building event-driven microservices at scale You need event replay and time-travel capabilities --- Whizbang RabbitMQ RabbitMQ adapter for distributed messaging `bash{ title: \"Install Whizbang RabbitMQ Package\"\ndescription: \"Add RabbitMQ adapter for distributed messaging\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"RabbitMQ\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang RabbitMQ\n`\nFeatures:\nFlexible routing\nPriority queues\nDead-letter exchanges\nPublisher confirms\n---\nWhizbang AzureServiceBus\nAzure Service Bus adapter `bash{\ntitle: \"Install Whizbang AzureServiceBus Package\"\ndescription: \"Add Azure Service Bus adapter for distributed messaging\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Azure Service Bus\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang AzureServiceBus\n`\nFeatures:\nManaged service (no infrastructure)\nSessions for ordered processing\nDuplicate detection\nIntegration with Azure ecosystem\n---\nWhizbang AWSSQS\nAWS SQS/SNS adapter `bash{\ntitle: \"Install Whizbang AWSSQS Package\"\ndescription: \"Add AWS SQS/SNS adapter for distributed messaging\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"AWS SQS\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang AWSSQS\n`\nFeatures:\nManaged service\nFIFO queues for ordering\nIntegration with AWS ecosystem\n---\nObservability Packages\nWhizbang OpenTelemetry\nOpenTelemetry integration `bash{\ntitle: \"Install Whizbang OpenTelemetry Package\"\ndescription: \"Add OpenTelemetry integration for tracing and metrics\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"OpenTelemetry\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang OpenTelemetry\n`\nIncludes:\nAutomatic tracing for all messages\nMetrics for throughput, latency, errors\nDistributed context propagation\n---\nWhizbang Dashboard\nWeb-based monitoring dashboard `bash{\ntitle: \"Install Whizbang",
        "startIndex": 27059,
        "preview": "Started\", \"Packages\", \"Installation\", \"Kafka\"] showLineNumbers: false } dotnet add package Whizbang Kafka ` Features: High throughput Partition-aware ..."
      },
      {
        "id": "old-v1.0.0/getting-started/package-structure-chunk-14",
        "text": "for tracing and metrics\" framework: \"NET8\" category: \"Getting Started\" difficulty: \"INTERMEDIATE\" tags: [\"Getting Started\", \"Packages\", \"Installation\", \"OpenTelemetry\"] showLineNumbers: false } dotnet add package Whizbang OpenTelemetry ` Includes: Automatic tracing for all messages Metrics for throughput, latency, errors Distributed context propagation --- Whizbang Dashboard Web-based monitoring dashboard `bash{ title: \"Install Whizbang Dashboard Package\"\ndescription: \"Add web-based monitoring dashboard for Whizbang applications\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Dashboard\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang Dashboard\n`\nFeatures:\nLive message flow visualization\nProjection lag monitoring\nError tracking\nPerformance metrics\n---\nDeveloper Packages\nWhizbang Analyzers\nRoslyn analyzers for compile-time validation `bash{\ntitle: \"Install Whizbang Analyzers Package\"\ndescription: \"Add Roslyn analyzers for compile-time validation and purity checks\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Analyzers\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang Analyzers\n`\nIncludes:\nProjection Purity Checks: Enforce pure functions in projections\nNo field/property mutations outside method scope\nNo I/O operations (file system, network, database writes)\nNo static mutation\nNo logging or side effects in projection handlers\nHandler Validation: Enforce [Pure] attribute on command/query handlers\nDomain Ownership: Detect missing domain ownership attributes\nNaming Conventions: Validate event and command naming conventions\nAsync Patterns: Check for synchronous I/O in async handlers\nSubscription Rules: Validate [WhizbangSubscribe] usage (one per method, etc )\nSecurity Context: Warn when security-sensitive operations lack tenant/user validation\nPurity Enforcement Example:\n`csharp\n[WhizbangProjection]\npublic class OrderProjection {\n    private readonly ILogger _logger;  // ⚠️ Warning: Injected services should be read-only\n    // ✅ VALID - Pure projection handler\n    public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) {\n        // Pure state updates only\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - Side effect detected (logging)\n    public Task Handle([WhizbangSubscribe] OrderShipped @event, CancellationToken ct) {\n        _logger",
        "startIndex": 29002,
        "preview": "for tracing and metrics\" framework: \"NET8\" category: \"Getting Started\" difficulty: \"INTERMEDIATE\" tags: [\"Getting Started\", \"Packages\", \"Installation\"..."
      },
      {
        "id": "old-v1.0.0/getting-started/package-structure-chunk-15",
        "text": "_logger; // ⚠️ Warning: Injected services should be read-only // ✅ VALID - Pure projection handler public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) { // Pure state updates only return Task CompletedTask; } // ❌ ERROR - Side effect detected (logging) public Task Handle([WhizbangSubscribe] OrderShipped @event, CancellationToken ct) { _logger LogInformation(\"Order shipped\");  // 💥 Compile error: Side effect in projection\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - I/O operation detected\n    public async Task Handle([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) {\n        await File WriteAllTextAsync(\"log txt\", \"cancelled\");  // 💥 Compile error: I/O in projection\n    }\n}\n`\n---\nWhizbang Testing\nTesting utilities and in-memory doubles `bash{\ntitle: \"Install Whizbang Testing Package\"\ndescription: \"Add testing utilities and in-memory doubles for development\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Testing\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang Testing\n`\nIncludes:\nIn-memory event store\nFake message bus\nProjection test helpers\nAggregate test fixtures\n---\nCustomizable Attributes\nWhizbang uses attributes for source generator discovery ([WhizbangHandler], [WhizbangProjection], [WhizbangSubscribe]), and these attributes are customizable to fit your team's preferences or naming conventions Why the Whizbang prefix All attributes use consistent Whizbang prefix to:\nAvoid naming collisions with other frameworks (e g , generic [Handler] attribute)\nProvide clear visual indication of framework-specific attributes\nEnable easy searching across codebase (grep \"WhizbangHandler\")\nMaintain consistent naming convention\nUsing Custom Attribute Names\nYou can configure Whizbang to recognize alternate attribute names:\n`csharp{\ntitle: \"Custom Attribute Names Configuration\"\ndescription: \"Configure Whizbang to use custom attribute names\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Attributes\", \"Source Generator\", \"Configuration\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nvar builder = Host CreateApplicationBuilder(args);\nbuilder Services AddWhizbang(options => {\n    // Configure custom attribute names\n    options",
        "startIndex": 31039,
        "preview": "_logger; // ⚠️ Warning: Injected services should be read-only // ✅ VALID - Pure projection handler public Task Handle([WhizbangSubscribe] OrderPlaced ..."
      },
      {
        "id": "old-v1.0.0/getting-started/package-structure-chunk-16",
        "text": "Whizbang to use custom attribute names\" framework: \"NET8\" category: \"Configuration\" difficulty: \"ADVANCED\" tags: [\"Attributes\", \"Source Generator\", \"Configuration\"] nugetPackages: [\"Whizbang Core\"] usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"] showLineNumbers: true } using Microsoft Extensions DependencyInjection; using Whizbang; var builder = Host CreateApplicationBuilder(args); builder Services AddWhizbang(options => { // Configure custom attribute names options Attributes(attr => {\n        // Use your own handler attribute name\n        attr HandlerAttribute = \"MyCompany CommandHandlerAttribute\";\n        // Use your own projection attribute name\n        attr ProjectionAttribute = \"MyCompany ProjectionAttribute\";\n        // Use your own subscription attribute name\n        attr SubscribeAttribute = \"MyCompany EventSubscriptionAttribute\";\n    });\n    options RegisterGeneratedHandlers();\n    options UseProjections(proj => proj RegisterGeneratedProjections());\n});\n`\nSource-Generated Attributes (Future)\nIn future versions, Whizbang may provide source-generated attributes that are automatically created in your project:\n`csharp\n// Auto-generated by Whizbang source generator\nnamespace MyCompany;\n[AttributeUsage(AttributeTargets Class | AttributeTargets Interface)]\npublic class CommandHandlerAttribute : Attribute { }\n[AttributeUsage(AttributeTargets Class | AttributeTargets Interface)]\npublic class ProjectionAttribute : Attribute { }\n[AttributeUsage(AttributeTargets Parameter)]\npublic class EventSubscriptionAttribute : Attribute { }\n`\nBenefits:\nNo dependency on Whizbang Core in your domain layer\nYour own namespace and naming conventions\nStill compatible with Whizbang's source generator\nEnables clean architecture (domain doesn't reference framework)\nWhy Customizable Attributes Team Conventions: Match your existing attribute naming patterns\nClean Architecture: Keep framework attributes out of domain layer\nLegacy Integration: Reuse existing attributes from other frameworks\nMulti-Framework: Use same attributes with multiple frameworks\n---\nPackage Decision Tree\n`\nDo you need event sourcing ├─ NO → Whizbang Core (mediator only)\n└─ YES → Whizbang Core + Whizbang EventSourcing\n          └─ Choose an ORM integration:\n              ├─ Whizbang EntityFramework (recommended for most)\n              ├─ Whizbang Dapper (high performance)\n              └─ Whizbang NHibernate (enterprise/legacy)\nDo you need read models └─ YES → Add Whizbang Projections\nAre you building microservices └─ YES → Add Whizbang Messaging\n          └─ Choose a message broker adapter:\n              ├─ Whizbang",
        "startIndex": 33136,
        "preview": "Whizbang to use custom attribute names\" framework: \"NET8\" category: \"Configuration\" difficulty: \"ADVANCED\" tags: [\"Attributes\", \"Source Generator\", \"C..."
      },
      {
        "id": "old-v1.0.0/getting-started/package-structure-chunk-17",
        "text": "EventSourcing └─ Choose an ORM integration: ├─ Whizbang EntityFramework (recommended for most) ├─ Whizbang Dapper (high performance) └─ Whizbang NHibernate (enterprise/legacy) Do you need read models └─ YES → Add Whizbang Projections Are you building microservices └─ YES → Add Whizbang Messaging └─ Choose a message broker adapter: ├─ Whizbang Kafka\n              ├─ Whizbang RabbitMQ\n              ├─ Whizbang AzureServiceBus\n              └─ Whizbang AWSSQS\nDo you need observability └─ YES → Add Whizbang OpenTelemetry or Whizbang Dashboard\nAre you developing/testing └─ YES → Add Whizbang Testing and Whizbang Analyzers\n`\n---\nTypical Configurations\nSimple Monolith\n`bash{\ntitle: \"Simple Monolith Package Installation\"\ndescription: \"Install packages for a simple monolithic application with event sourcing\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Monolith\"]\nshowLineNumbers: true\n}\ndotnet add package Whizbang Core\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang EntityFramework\ndotnet add package Npgsql EntityFrameworkCore PostgreSQL\n`\n---\nMonolith with Read Models\n`bash{\ntitle: \"Monolith with Read Models Package Installation\"\ndescription: \"Install packages for a monolith with event sourcing and read model projections\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Monolith\", \"CQRS\"]\nshowLineNumbers: true\n}\ndotnet add package Whizbang Core\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang Projections\ndotnet add package Whizbang EntityFramework\ndotnet add package Npgsql EntityFrameworkCore PostgreSQL\n`\n---\nHigh-Performance Monolith\n`bash{\ntitle: \"High-Performance Monolith Package Installation\"\ndescription: \"Install packages for a high-performance monolith using Dapper for optimal speed\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Performance\", \"Dapper\"]\nshowLineNumbers: true\n}\ndotnet add package Whizbang Core\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang Projections\ndotnet add package Whizbang",
        "startIndex": 35278,
        "preview": "EventSourcing └─ Choose an ORM integration: ├─ Whizbang EntityFramework (recommended for most) ├─ Whizbang Dapper (high performance) └─ Whizbang NHibe..."
      },
      {
        "id": "old-v1.0.0/getting-started/package-structure-chunk-18",
        "text": "Package Installation\" description: \"Install packages for a high-performance monolith using Dapper for optimal speed\" framework: \"NET8\" category: \"Getting Started\" difficulty: \"ADVANCED\" tags: [\"Getting Started\", \"Packages\", \"Installation\", \"Performance\", \"Dapper\"] showLineNumbers: true } dotnet add package Whizbang Core dotnet add package Whizbang EventSourcing dotnet add package Whizbang Projections dotnet add package Whizbang Dapper\ndotnet add package Npgsql\n`\n---\nMicroservices with Kafka\n`bash{\ntitle: \"Microservices with Kafka Package Installation\"\ndescription: \"Install packages for microservices architecture with Kafka messaging and observability\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Microservices\", \"Kafka\"]\nshowLineNumbers: true\n}\ndotnet add package Whizbang Core\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang Projections\ndotnet add package Whizbang Messaging\ndotnet add package Whizbang EntityFramework\ndotnet add package Npgsql EntityFrameworkCore PostgreSQL\ndotnet add package Whizbang Kafka\ndotnet add package Whizbang OpenTelemetry\n`\n---\nEnterprise with SQL Server\n`bash{\ntitle: \"Enterprise with SQL Server Package Installation\"\ndescription: \"Install packages for enterprise applications using NHibernate and SQL Server\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Enterprise\", \"SQL Server\"]\nshowLineNumbers: true\n}\ndotnet add package Whizbang Core\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang Projections\ndotnet add package Whizbang NHibernate\ndotnet add package NHibernate\ndotnet add package NHibernate Driver MicrosoftDataSqlClientDriver\n`\n---\nNext Steps\nGetting Started - Build your first Whizbang application\nPhilosophy - Understand Whizbang's design principles and architectural philosophy\nCore Concepts - Deep dive into commands, events, projections, and aggregates\nDriver System - Learn how to implement custom drivers\nTesting - Test your event-sourced applications",
        "startIndex": 37162,
        "preview": "Package Installation\" description: \"Install packages for a high-performance monolith using Dapper for optimal speed\" framework: \"NET8\" category: \"Gett..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/observability/dashboard",
    "title": "Whizbang Dashboard",
    "category": "Observability",
    "url": "/docs/old-v1.0.0/observability/dashboard",
    "chunks": [
      {
        "id": "old-v1.0.0/observability/dashboard-chunk-0",
        "text": "Whizbang Dashboard\nThe Whizbang Dashboard is a separate web application (package: Whizbang Dashboard) that provides real-time visualization of your event-sourced, message-driven system Overview\nThe dashboard offers:\nMessage Journey Visualization - See the complete lifecycle of commands and events\nDistributed Tracing - Track messages across microservices\nProjection Health - Monitor projection lag and errors\nEvent Stream Explorer - Browse aggregate event streams\nPerformance Metrics - Throughput, latency, error rates\nControl Plane - Send control commands to services\nInstallation\nNuGet Package\n`bash\n---\ncategory: Observability\ndifficulty: BEGINNER\ntags: [Installation, NuGet, Dashboard, Package-Management]\ndescription: Install Whizbang Dashboard NuGet package\n---\ndotnet add package Whizbang Dashboard\n`\nStandalone Dashboard Application\nOr run as a separate service:\n`bash\n---\ncategory: Observability\ndifficulty: BEGINNER\ntags: [Global-Tool, Dashboard, Standalone, CLI]\ndescription: Install and run dashboard as standalone global tool\n---\ndotnet tool install --global Whizbang Dashboard\nwhizbang-dashboard --port 5050\n`\nEmbedded in Application\nAdd to your ASP NET Core application:\n`csharp\n---\ncategory: Observability\ndifficulty: BEGINNER\ntags: [Dashboard, Setup, ASP NET-Core, Configuration]\ndescription: Embed dashboard in existing ASP NET Core application\n---\nusing Microsoft AspNetCore Builder;\nusing Whizbang Dashboard;\nvar builder = WebApplication CreateBuilder(args);\n// Add Whizbang Dashboard\nbuilder Services AddWhizbangDashboard(options => {\n    options EnableRealTimeUpdates = true;\n    options RetentionPeriod = TimeSpan FromHours(24);  // Keep traces for 24 hours\n    options RequireAuthentication = true;              // Protect dashboard\n});\nvar app = builder Build();\n// Mount dashboard at /whizbang\napp MapWhizbangDashboard(\"/whizbang\");\napp",
        "startIndex": 0,
        "preview": "Whizbang Dashboard\nThe Whizbang Dashboard is a separate web application (package: Whizbang Dashboard) that provides real-time visualization of your ev..."
      },
      {
        "id": "old-v1.0.0/observability/dashboard-chunk-1",
        "text": "var builder = WebApplication CreateBuilder(args); // Add Whizbang Dashboard builder Services AddWhizbangDashboard(options => { options EnableRealTimeUpdates = true; options RetentionPeriod = TimeSpan FromHours(24); // Keep traces for 24 hours options RequireAuthentication = true; // Protect dashboard }); var app = builder Build(); // Mount dashboard at /whizbang app MapWhizbangDashboard(\"/whizbang\"); app Run();\n`\nAccess at: http://localhost:5000/whizbang\nMessage Journey Visualization\nEnd-to-End Flow\nSee the complete journey of a command through your system:\n`\nPlaceOrder (Command)\n  ↓\nOrderCommandHandler\n  ↓\nOrderPlaced (Event)\n  ├─→ OrderHistoryProjection (updated)\n  ├─→ InventoryReservationSaga (triggered)\n  │   ↓\n  │   ReserveInventory (Command) → InventoryService\n  │   ↓\n  │   InventoryReserved (Event)\n  │   ↓\n  │   ProcessPayment (Command) → PaymentService\n  │   ↓\n  │   PaymentProcessed (Event)\n  └─→ CustomerNotificationHandler (email sent)\n`\nDashboard Visualization:\n`\n┌────────────────────────────────────────────────────────────┐\n│  Message Journey: PlaceOrder                               │\n├────────────────────────────────────────────────────────────┤\n│                                                             │\n│  [PlaceOrder] ──→ [OrderHandler] ──→ [OrderPlaced]         │\n│      ↓ 42ms          ↓ 120ms           ↓                   │\n│      │               │                 ├─→ [OrderHistory]  │\n│      │               │                 │    ↓ 15ms         │\n│      │               │                 │                   │\n│      │               │                 ├─→ [ReserveSaga]   │\n│      │               │                 │    ↓ 200ms        │\n│      │               │                 │    └─→ [Inventory]│\n│      │               │                 │         ↓ 350ms   │\n│      │               │                 │         └─→ [Pay] │\n│      │               │                 │              ↓    │\n│      │               │                 └─→ [Notify] ✓      │\n│                                                             │\n│  Total Duration: 727ms                                      │\n│  Status: ✓ Success                                          │\n└────────────────────────────────────────────────────────────┘\n`\nInteractive Trace Explorer\nClick on any message to drill down:\n`\n┌────────────────────────────────────────────────────────────┐\n│  OrderPlaced Event Details                                 │\n├────────────────────────────────────────────────────────────┤\n│  Event ID: evt_01J7G3KZ9P │\n│  Timestamp: 2025-10-18 14:32:15 234 UTC                    │\n│  Correlation ID: cmd_01J7G3KZ8N │\n│  Causation ID: cmd_01J7G3KZ8N │\n│                                                             │\n│  Payload:                                                   │\n│  {                                                          │\n│    \"orderId\": \"ord_123\",                                    │\n│    \"customerId\": \"cust_456\",                                │\n│    \"total\": 99 99,                                          │\n│    \"items\": [ /",
        "startIndex": 1865,
        "preview": "var builder = WebApplication CreateBuilder(args); // Add Whizbang Dashboard builder Services AddWhizbangDashboard(options => { options EnableRealTimeU..."
      },
      {
        "id": "old-v1.0.0/observability/dashboard-chunk-2",
        "text": "Details │ ├────────────────────────────────────────────────────────────┤ │ Event ID: evt_01J7G3KZ9P │ │ Timestamp: 2025-10-18 14:32:15 234 UTC │ │ Correlation ID: cmd_01J7G3KZ8N │ │ Causation ID: cmd_01J7G3KZ8N │ │ │ │ Payload: │ │ { │ │ \"orderId\": \"ord_123\", │ │ \"customerId\": \"cust_456\", │ │ \"total\": 99 99, │ │ \"items\": [ / / ]                                   │\n│  }                                                          │\n│                                                             │\n│  Metadata:                                                  │\n│  - Tenant: acme-corp                                        │\n│  - User: john doe@acme com                                  │\n│  - Source: orders-service-pod-3                             │\n│  - Trace ID: 4bf92f3577b34da6a3ce929d0e0e4736              │\n│                                                             │\n│  Subscribers (3):                                           │\n│  ✓ OrderHistoryProjection (15ms)                           │\n│  ✓ InventoryReservationSaga (200ms)                        │\n│  ✓ CustomerNotificationHandler (42ms)                      │\n└────────────────────────────────────────────────────────────┘\n`\nDistributed Tracing\nCross-Service Traces\nVisualize messages flowing across microservices:\n`\nAPI Gateway         Orders Service      Inventory Service    Payment Service\n    │                     │                     │                   │\n    ├─ PlaceOrder ──────→ │                     │                   │\n    │                     ├─ OrderPlaced ──────→│                   │\n    │                     │                     ├─ ReserveInventory │\n    │                     │                     │                   │\n    │                     │ ←── InventoryReserved                   │\n    │                     ├─ ProcessPayment ────────────────────→  │\n    │                     │                     │                   │\n    │                     │ ←─────────────────── PaymentProcessed ─┤\n    │ ←── OrderConfirmed ─┤                     │                   │\n    │                     │                     │                   │\n`\nOpenTelemetry Integration:\nThe dashboard integrates with OpenTelemetry traces:\n`csharp\n---\ncategory: Observability\ndifficulty: INTERMEDIATE\ntags: [OpenTelemetry, Tracing, Dashboard, Integration, Jaeger, Zipkin]\ndescription: Dashboard integration with OpenTelemetry, Jaeger, and Zipkin\n---\nusing Whizbang Dashboard;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbangDashboard(options => {\n    // Read traces from OpenTelemetry collector\n    options UseOpenTelemetry(otel => {\n        otel Endpoint = \"http://otel-collector:4317\";\n        otel Protocol = OpenTelemetryProtocol Grpc;\n    });\n    // Or from Jaeger\n    options UseJaeger(jaeger => {\n        jaeger Endpoint = \"http://jaeger:16686\";\n    });\n    // Or from Zipkin\n    options UseZipkin(zipkin => {\n        zipkin",
        "startIndex": 4623,
        "preview": "Details │ ├────────────────────────────────────────────────────────────┤ │ Event ID: evt_01J7G3KZ9P │ │ Timestamp: 2025-10-18 14:32:15 234 UTC │ │ Cor..."
      },
      {
        "id": "old-v1.0.0/observability/dashboard-chunk-3",
        "text": "using Microsoft Extensions DependencyInjection; services AddWhizbangDashboard(options => { // Read traces from OpenTelemetry collector options UseOpenTelemetry(otel => { otel Endpoint = \"http://otel-collector:4317\"; otel Protocol = OpenTelemetryProtocol Grpc; }); // Or from Jaeger options UseJaeger(jaeger => { jaeger Endpoint = \"http://jaeger:16686\"; }); // Or from Zipkin options UseZipkin(zipkin => { zipkin Endpoint = \"http://zipkin:9411\";\n    });\n});\n`\nTrace Timeline View\nWaterfall chart showing message timing:\n`\nTime ──────────────────────────────────────────────────→\n0ms   100ms  200ms  300ms  400ms  500ms  600ms  700ms\nPlaceOrder\n│────────────│ (120ms)\n             OrderPlaced\n             │──────────────────│ (200ms - saga processing)\n                                ReserveInventory\n                                │──────────────│ (150ms)\n                                               InventoryReserved\n                                               │────────────│ (100ms)\n                                                           ProcessPayment\n                                                           │──────────────│ (150ms)\n                                                                         PaymentProcessed\n                                                                         │─│ (5ms - notification)\n═══════════════════════════════════════════════════════════════════════════\nTotal: 727ms\n`\nProjection Health Monitoring\nProjection Dashboard\nReal-time view of all projections:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Projections                                                      │\n├──────────────────────────────────────────────────────────────────┤\n│                                                                   │\n│  Name                   Status    Lag      Throughput    Errors  │\n│  ────────────────────   ──────    ────     ──────────    ──────  │\n│  OrderHistory           🟢 OK     2ms      450 evt/sec   0       │\n│  CustomerStats          🟢 OK     5ms      320 evt/sec   0       │\n│  InventorySummary       🟡 WARN   2 5s     180 evt/sec   0       │\n│  ProductRecommendations 🔴 ERROR  45s      0 evt/sec     15      │\n│                                                                   │\n│  [Rebuild] [Pause] [Reset Checkpoint]                            │\n└──────────────────────────────────────────────────────────────────┘\n`\nLag Alert: Visual indicator when projection falls behind event stream Projection Details\nDrill into individual projection:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Projection: ProductRecommendations                               │\n├──────────────────────────────────────────────────────────────────┤\n│  Status: 🔴 ERROR                                                 │\n│  Last Processed Event: evt_01J7G3KZ9P",
        "startIndex": 7222,
        "preview": "using Microsoft Extensions DependencyInjection; services AddWhizbangDashboard(options => { // Read traces from OpenTelemetry collector options UseOpen..."
      },
      {
        "id": "old-v1.0.0/observability/dashboard-chunk-4",
        "text": "🔴 ERROR 45s 0 evt/sec 15 │ │ │ │ [Rebuild] [Pause] [Reset Checkpoint] │ └──────────────────────────────────────────────────────────────────┘ ` Lag Alert: Visual indicator when projection falls behind event stream Projection Details Drill into individual projection: ` ┌──────────────────────────────────────────────────────────────────┐ │ Projection: ProductRecommendations │ ├──────────────────────────────────────────────────────────────────┤ │ Status: 🔴 ERROR │ │ Last Processed Event: evt_01J7G3KZ9P (45 seconds ago)        │\n│  Current Checkpoint: 123,456                                      │\n│  Latest Event Position: 125,890                                   │\n│  Lag: 2,434 events (~45 seconds)                                  │\n│                                                                   │\n│  Recent Errors (15):                                              │\n│  - NullReferenceException at UpdateRecommendations:42            │\n│  - NullReferenceException at UpdateRecommendations:42            │\n│  - NullReferenceException at UpdateRecommendations:42            │\n│  [View Stack Trace]                                               │\n│                                                                   │\n│  Actions:                                                         │\n│  [Rebuild from Start] [Rebuild from Checkpoint] [Skip Failed]    │\n└──────────────────────────────────────────────────────────────────┘\n`\nActions:\nRebuild: Clear projection and replay all events\nSkip: Skip the failing event and continue\nPause: Stop projection processing\nEvent Stream Explorer\nBrowse aggregate event streams:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Event Stream: Order-ord_123                                      │\n├──────────────────────────────────────────────────────────────────┤\n│                                                                   │\n│  [0] OrderPlaced              2025-10-18 14:32:15 UTC            │\n│      Customer: cust_456       Total: $99 99                       │\n│                                                                   │\n│  [1] OrderItemAdded           2025-10-18 14:33:02 UTC            │\n│      Product: Widget          Quantity: 2                         │\n│                                                                   │\n│  [2] OrderShipped             2025-10-18 14:45:10 UTC            │\n│      Carrier: UPS             Tracking: 1Z999AA10123456789        │\n│                                                                   │\n│  [3] OrderDelivered           2025-10-20 10:15:33 UTC            │\n│      Signature: J",
        "startIndex": 9675,
        "preview": "🔴 ERROR 45s 0 evt/sec 15 │ │ │ │ [Rebuild] [Pause] [Reset Checkpoint] │ └──────────────────────────────────────────────────────────────────┘ ` Lag Al..."
      },
      {
        "id": "old-v1.0.0/observability/dashboard-chunk-5",
        "text": "│ │ Customer: cust_456 Total: $99 99 │ │ │ │ [1] OrderItemAdded 2025-10-18 14:33:02 UTC │ │ Product: Widget Quantity: 2 │ │ │ │ [2] OrderShipped 2025-10-18 14:45:10 UTC │ │ Carrier: UPS Tracking: 1Z999AA10123456789 │ │ │ │ [3] OrderDelivered 2025-10-20 10:15:33 UTC │ │ Signature: J Doe        Location: Front door                │\n│                                                                   │\n│  Total Events: 4              Aggregate Version: 3                │\n│                                                                   │\n│  [Replay] [Download JSON] [View Snapshots]                        │\n└──────────────────────────────────────────────────────────────────┘\n`\nFeatures:\nView full event stream for any aggregate\nDownload events as JSON\nReplay events (time-travel debugging)\nView snapshots (if enabled)\nPerformance Metrics\nThroughput Dashboard\nReal-time metrics:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Throughput (Last 5 Minutes)                                      │\n├──────────────────────────────────────────────────────────────────┤\n│                                                                   │\n│  Commands/sec:  ████████████████░░░░  120/sec                    │\n│  Events/sec:    ██████████████████░░  450/sec                    │\n│  Queries/sec:   ████████████░░░░░░░░  80/sec                     │\n│                                                                   │\n│  Avg Latency:                                                     │\n│  - Commands:    42ms   (p50: 35ms, p95: 120ms, p99: 250ms)       │\n│  - Events:      15ms   (p50: 12ms, p95: 45ms, p99: 80ms)         │\n│  - Queries:     8ms    (p50: 5ms, p95: 25ms, p99: 50ms)          │\n│                                                                   │\n│  Error Rate:    0 02%  (3 errors in 15,000 messages)             │\n└──────────────────────────────────────────────────────────────────┘\n`\nService Health\nMonitor individual services:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Services                                                         │\n├──────────────────────────────────────────────────────────────────┤\n│  Name              Status    CPU    Memory   Replicas   Requests │\n│  ──────────────    ──────    ───    ──────   ────────   ──────── │\n│  orders-service    🟢 OK     23%    1 2 GB   3/3        450/sec  │\n│  inventory-service 🟢 OK     45%    800 MB   2/2        320/sec  │\n│  payment-service   🟡 WARN   78%    1",
        "startIndex": 11792,
        "preview": "│ │ Customer: cust_456 Total: $99 99 │ │ │ │ [1] OrderItemAdded 2025-10-18 14:33:02 UTC │ │ Product: Widget Quantity: 2 │ │ │ │ [2] OrderShipped 2025-..."
      },
      {
        "id": "old-v1.0.0/observability/dashboard-chunk-6",
        "text": "services: ` ┌──────────────────────────────────────────────────────────────────┐ │ Services │ ├──────────────────────────────────────────────────────────────────┤ │ Name Status CPU Memory Replicas Requests │ │ ────────────── ────── ─── ────── ──────── ──────── │ │ orders-service 🟢 OK 23% 1 2 GB 3/3 450/sec │ │ inventory-service 🟢 OK 45% 800 MB 2/2 320/sec │ │ payment-service 🟡 WARN 78% 1 8 GB   2/2        180/sec  │\n│  shipping-service  🟢 OK     12%    600 MB   1/1        80/sec   │\n└──────────────────────────────────────────────────────────────────┘\n`\nControl Plane UI\nSend Control Commands\nFrom the dashboard UI:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Control Commands                                                 │\n├──────────────────────────────────────────────────────────────────┤\n│                                                                   │\n│  Command: [Rebuild Projection ▼]                                 │\n│                                                                   │\n│  Projection Name: [OrderHistory_____________]                     │\n│  Target Service:  [All Services ▼]                                │\n│  Start From:      [Beginning of Time ▼]                           │\n│                                                                   │\n│  ⚠️  Warning: This will clear and rebuild the projection │\n│      Queries may return incomplete data during rebuild │\n│                                                                   │\n│  [Cancel]  [Execute Command]                                      │\n└──────────────────────────────────────────────────────────────────┘\n`\nAvailable Commands:\nRebuild Projection\nSet Log Level\nClear Caches\nRun Health Check\nToggle Feature Flags\nPause/Resume Message Processing\nCommand History\nTrack what control commands were executed:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Command History                                                  │\n├──────────────────────────────────────────────────────────────────┤\n│  Time                Command                   User      Status  │\n│  ──────────────────  ────────────────────────  ────────  ──────  │\n│  14:52:10 UTC        Rebuild OrderHistory      admin     ✓ Done  │\n│  14:45:33 UTC        Set Log Level=Debug       john doe  ✓ Done  │\n│  14:32:15 UTC        Clear Cache               admin     ✗ Failed│\n│  14:18:02 UTC        Pause Projection          jane doe  ✓ Done  │\n└──────────────────────────────────────────────────────────────────┘\n`\nSearch and Filtering\nSearch Messages\nFind specific messages:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Search Messages                                                  │\n├──────────────────────────────────────────────────────────────────┤\n│  Query: [customer_id:cust_456 AND status:shipped_____________]   │\n│  Time Range: [Last 24 Hours ▼]                                   │\n│  [Search]                                                         │\n│                                                                   │\n│  Results (42):                                                    │\n│  ────────────────────────────────────────────────────────────────│\n│  OrderShipped - ord_123 - 2025-10-18 14:45:10                    │\n│  OrderShipped - ord_789 - 2025-10-18 12:15:33                    │\n│  OrderShipped - ord_456 - 2025-10-17 16:32:45                    │\n│",
        "startIndex": 14007,
        "preview": "services: ` ┌──────────────────────────────────────────────────────────────────┐ │ Services │ ├───────────────────────────────────────────────────────..."
      },
      {
        "id": "old-v1.0.0/observability/dashboard-chunk-7",
        "text": "│ Query: [customer_id:cust_456 AND status:shipped_____________] │ │ Time Range: [Last 24 Hours ▼] │ │ [Search] │ │ │ │ Results (42): │ │ ────────────────────────────────────────────────────────────────│ │ OrderShipped - ord_123 - 2025-10-18 14:45:10 │ │ OrderShipped - ord_789 - 2025-10-18 12:15:33 │ │ OrderShipped - ord_456 - 2025-10-17 16:32:45 │ │ │\n└──────────────────────────────────────────────────────────────────┘\n`\nQuery Syntax:\nevent_type:OrderPlaced\ntenant_id:acme-corp\ntimestamp > 2025-10-18\nstatus:error AND service:payment\nReal-Time Updates\nDashboard updates in real-time via SignalR:\n`csharp\n---\ncategory: Observability\ndifficulty: INTERMEDIATE\ntags: [Dashboard, SignalR, Real-Time, Push-Notifications]\ndescription: Real-time dashboard updates with SignalR and push notifications\n---\nusing Whizbang Dashboard;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbangDashboard(options => {\n    // Real-time updates via SignalR\n    options EnableRealTimeUpdates = true;\n    // Push notifications for important events\n    options PushNotifications(notify => {\n        notify OnProjectionError = true;\n        notify OnHighLatency = true;\n        notify OnErrorRateThreshold = 0 05;  // Alert if error rate > 5%\n    });\n});\n`\nFeatures:\nLive message journey updates\nReal-time projection lag updates\nInstant error notifications\nThroughput graphs update every second\nSecurity\nAuthentication\nProtect the dashboard:\n`csharp\n---\ncategory: Observability\ndifficulty: INTERMEDIATE\ntags: [Dashboard, Authentication, Security, Authorization]\ndescription: Secure dashboard with authentication and role-based access\n---\nusing Whizbang Dashboard;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbangDashboard(options => {\n    // Require authentication\n    options RequireAuthentication = true;\n    // Role-based access\n    options RequireRole(\"WhizbangAdmin\");\n    // Or custom authorization policy\n    options RequirePolicy(\"WhizbangDashboardAccess\");\n});\n`\nAudit Log\nTrack who accessed the dashboard:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Audit Log                                                        │\n├──────────────────────────────────────────────────────────────────┤\n│  Timestamp           User         Action                          │\n│  ──────────────────  ───────────  ─────────────────────────────  │\n│  14:52:10 UTC        admin        Rebuilt projection OrderHistory│\n│  14:45:33 UTC        john doe     Viewed order stream ord_123    │\n│  14:32:15 UTC        admin        Set log level to Debug         │\n│  14:18:02 UTC        jane doe     Paused projection              │\n└──────────────────────────────────────────────────────────────────┘\n`\nNext Steps\nObservability - OpenTelemetry integration\nAdvanced Scenarios - Control plane commands\nDistributed Messaging - Cross-service tracing",
        "startIndex": 17141,
        "preview": "│ Query: [customer_id:cust_456 AND status:shipped_____________] │ │ Time Range: [Last 24 Hours ▼] │ │ [Search] │ │ │ │ Results (42): │ │ ─────────────..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/projections/projection-contexts",
    "title": "Projection Contexts",
    "category": "Projections",
    "url": "/docs/old-v1.0.0/projections/projection-contexts",
    "chunks": [
      {
        "id": "old-v1.0.0/projections/projection-contexts-chunk-0",
        "text": "Projection Contexts\nWhizbang provides two types of context for projections:\nEventContext - Rich event metadata (pure data, no side effects)\nProjectionContext - Projection-specific operations and metadata (CRUD operations, projection info)\nBoth can be injected at the method level or constructor level `mermaid\ngraph LR\n    Event[Event] --> Handler[Projection Handler]\n    subgraph Contexts[\"Injected Contexts\"]\n        EC[EventContext<br/>Pure Data Only]\n        PC[ProjectionContext<br/>With CRUD Operations]\n    end\n    subgraph ECData[\"EventContext Contents\"]\n        System[System Data<br/>Timestamp, Machine, etc ]\n        Security[Security Context<br/>User, Tenant, Roles]\n        EventMeta[Event Metadata<br/>EventId, Causation]\n        Tracing[Tracing Context<br/>CorrelationId, TraceId]\n    end\n    subgraph PCData[\"ProjectionContext Contents\"]\n        ProjMeta[Projection Metadata<br/>Name, Version, Type]\n        ServiceMeta[Service Metadata<br/>Environment, Machine]\n        Store[Projection Store<br/>Create, Update, Patch, Delete]\n    end\n    EC --> ECData\n    PC --> PCData\n    Handler --> EC\n    Handler --> PC\n    PC --> Store\n    style Event fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    style Handler fill:#cce5ff,stroke:#004085,stroke-width:2px\n    style EC fill:#d4edda,stroke:#28a745,stroke-width:2px\n    style PC fill:#d1ecf1,stroke:#0c5460,stroke-width:2px\n    style Store fill:#f8d7da,stroke:#dc3545,stroke-width:2px\n`\nEventContext Injection\nEventContext is pure data (no side effects) that provides rich metadata about every event EventContext Structure\n`csharp{\ntitle: \"EventContext Structure\"\ndescription: \"Complete structure of EventContext with system metadata, security context, event metadata, and tracing information\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"EventContext\", \"Structure\", \"Metadata\"]\nfilename: \"EventContext cs\"\nusingStatements: [\"System\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\npublic class EventContext {\n    // System metadata\n    public SystemData System { get; init; }\n    // Security and multi-tenancy context\n    public SecurityContext Security { get; init; }\n    // Event-specific metadata\n    public EventMetadata Event { get; init; }\n    // Distributed tracing information\n    public TracingContext Tracing { get; init; }\n}\npublic class SystemData {\n    // System-generated metadata\n    public DateTime Timestamp { get; init; }\n    public string MachineName { get; init; }\n    public string Environment { get; init; }\n    public long EventSequenceNumber { get; init; }\n    // Custom system metadata (extensible)\n    public IReadOnlyDictionary<string, object> CustomMetadata { get; init; }\n}\npublic class SecurityContext {\n    // User information\n    public Guid",
        "startIndex": 0,
        "preview": "Projection Contexts\nWhizbang provides two types of context for projections:\nEventContext - Rich event metadata (pure data, no side effects)\nProjection..."
      },
      {
        "id": "old-v1.0.0/projections/projection-contexts-chunk-1",
        "text": "DateTime Timestamp { get; init; } public string MachineName { get; init; } public string Environment { get; init; } public long EventSequenceNumber { get; init; } // Custom system metadata (extensible) public IReadOnlyDictionary<string, object> CustomMetadata { get; init; } } public class SecurityContext { // User information public Guid UserId { get; init; }\n    public string UserName { get; init; }\n    public IReadOnlyList<string> Roles { get; init; }\n    // Multi-tenancy\n    public Guid TenantId { get; init; }\n    public string TenantName { get; init; }\n    // Permissions (evaluated at command/event creation time)\n    public IReadOnlyList<string> Permissions { get; init; }\n    // Service trust boundary\n    public bool IsTrustedService { get; init; }\n    public string ServiceName { get; init; }\n}\npublic class EventMetadata {\n    // Event identification\n    public Guid EventId { get; init; }\n    public string EventType { get; init; }\n    public int EventVersion { get; init; }\n    // Causation (what caused this event)\n    public Guid CausationId { get; init; }  // Command that caused this event\n    public string CausationType { get; init; }\n    // Custom event metadata\n    public IReadOnlyDictionary<string, object> CustomMetadata { get; init; }\n}\npublic class TracingContext {\n    // Distributed tracing\n    public string CorrelationId { get; init; }  // End-to-end request tracking\n    public string TraceId { get; init; }        // OpenTelemetry trace ID\n    public string SpanId { get; init; }         // OpenTelemetry span ID\n    // Message journey\n    public int HopCount { get; init; }          // Number of services traversed\n    public DateTime InitiatedAt { get; init; }  // When the original request started\n}\n`\nEventContext Usage Example\n`csharp{\ntitle: \"EventContext Usage in Projections\"\ndescription: \"Accessing system metadata, security context, and tracing information\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"EventContext\", \"Security\", \"Multi-Tenancy\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading",
        "startIndex": 2792,
        "preview": "DateTime Timestamp { get; init; } public string MachineName { get; init; } public string Environment { get; init; } public long EventSequenceNumber { ..."
      },
      {
        "id": "old-v1.0.0/projections/projection-contexts-chunk-2",
        "text": "init; } // When the original request started } ` EventContext Usage Example `csharp{ title: \"EventContext Usage in Projections\" description: \"Accessing system metadata, security context, and tracing information\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Projections\", \"EventContext\", \"Security\", \"Multi-Tenancy\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"] usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class TenantOrderHistoryProjection {\n    private readonly Dictionary<Guid, List<TenantOrderRecord>> _ordersByTenant = new();\n    public Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        EventContext context,\n        CancellationToken ct) {\n        // Use security context for tenant isolation\n        if ( context Security TenantId HasValue) {\n            throw new InvalidOperationException(\"TenantId is required for order events\");\n        }\n        var tenantId = context Security TenantId Value;\n        // Create tenant-scoped record with rich context\n        var record = new TenantOrderRecord {\n            OrderId = @event OrderId,\n            TenantId = tenantId,\n            TenantName = context Security TenantName,\n            CustomerId = @event CustomerId,\n            Total = @event Total,\n            // System metadata\n            PlacedAt = context System Timestamp,\n            PlacedBy = context Security UserName,\n            PlacedByUserId = context Security UserId,\n            // Tracing\n            CorrelationId = context Tracing CorrelationId,\n            OriginatedAt = context Tracing InitiatedAt,\n            // Event metadata\n            EventId = context Event EventId,\n            CausationId = context Event CausationId  // The PlaceOrder command ID\n        };\n        if ( _ordersByTenant ContainsKey(tenantId)) {\n            _ordersByTenant[tenantId] = new List<TenantOrderRecord>();\n        }\n        _ordersByTenant[tenantId] Add(record);\n        return Task CompletedTask;\n    }\n    // Query methods (tenant-scoped)\n    public IEnumerable<TenantOrderRecord> GetOrdersForTenant(Guid tenantId) {\n        return _ordersByTenant TryGetValue(tenantId, out var orders) orders\n            : Enumerable Empty<TenantOrderRecord>();\n    }\n}\npublic record TenantOrderRecord {\n    public Guid OrderId { get; init; }\n    public Guid TenantId { get; init; }\n    public string TenantName { get; init; }\n    public Guid CustomerId { get; init; }\n    public decimal Total { get; init; }\n    // System metadata\n    public DateTime PlacedAt { get; init; }\n    public string PlacedBy { get; init; }\n    public Guid",
        "startIndex": 4618,
        "preview": "init; } // When the original request started } ` EventContext Usage Example `csharp{ title: \"EventContext Usage in Projections\" description: \"Accessin..."
      },
      {
        "id": "old-v1.0.0/projections/projection-contexts-chunk-3",
        "text": "get; init; } public Guid TenantId { get; init; } public string TenantName { get; init; } public Guid CustomerId { get; init; } public decimal Total { get; init; } // System metadata public DateTime PlacedAt { get; init; } public string PlacedBy { get; init; } public Guid PlacedByUserId { get; init; }\n    // Tracing\n    public string CorrelationId { get; init; }\n    public DateTime OriginatedAt { get; init; }\n    // Event lineage\n    public Guid EventId { get; init; }\n    public Guid CausationId { get; init; }\n}\n`\nEventContext Benefits\nMulti-Tenancy: Access tenant context for data isolation\nSecurity: User, roles, permissions available for authorization\nAuditing: Track who did what and when\nTracing: End-to-end request tracking with correlation IDs\nCausation: Link events back to originating commands\nPure Data: All context is immutable, enabling pure function projections\nExtensible: Custom metadata dictionaries for app-specific data\nPurity Guarantees\nEventContext is designed to maintain projection purity:\nImmutable: All properties are init-only\nNo side effects: Contains only data, no methods with side effects\nNo I/O: No database, file system, or network access\nDeterministic: Same event + context always produces same projection state\nRoslyn Analyzers: Whizbang Analyzers enforces purity rules at compile time\n---\nProjectionContext Injection\nWhile EventContext is pure data, ProjectionContext provides database operations and projection metadata It can be injected at the method level or constructor level ProjectionContext Structure\n`csharp{\ntitle: \"ProjectionContext Structure\"\ndescription: \"Complete structure of ProjectionContext with projection metadata, service information, and projection store operations\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"ProjectionContext\", \"Structure\", \"CRUD Operations\"]\nfilename: \"ProjectionContext cs\"\nusingStatements: [\"System\", \"System Collections Generic\", \"System Threading\", \"System Threading",
        "startIndex": 6921,
        "preview": "get; init; } public Guid TenantId { get; init; } public string TenantName { get; init; } public Guid CustomerId { get; init; } public decimal Total { ..."
      },
      {
        "id": "old-v1.0.0/projections/projection-contexts-chunk-4",
        "text": "the method level or constructor level ProjectionContext Structure `csharp{ title: \"ProjectionContext Structure\" description: \"Complete structure of ProjectionContext with projection metadata, service information, and projection store operations\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Projections\", \"ProjectionContext\", \"Structure\", \"CRUD Operations\"] filename: \"ProjectionContext cs\" usingStatements: [\"System\", \"System Collections Generic\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\npublic class ProjectionContext {\n    // Projection metadata\n    public ProjectionMetadata Projection { get; init; }\n    // Service information\n    public ServiceMetadata Service { get; init; }\n    // Database operations (Create, Update, Patch, Delete)\n    public IProjectionStore Store { get; init; }\n}\npublic class ProjectionMetadata {\n    public string ProjectionName { get; init; }\n    public string ProjectionVersion { get; init; }\n    public Type ProjectionType { get; init; }\n    public DateTime StartedAt { get; init; }\n    // Custom projection metadata\n    public IReadOnlyDictionary<string, object> CustomMetadata { get; init; }\n}\npublic class ServiceMetadata {\n    public string ServiceName { get; init; }\n    public string ServiceVersion { get; init; }\n    public string Environment { get; init; }\n    public string MachineName { get; init; }\n}\npublic interface IProjectionStore {\n    // Create\n    Task CreateAsync<TProjection>(TProjection projection, CancellationToken ct = default)\n        where TProjection : class;\n    // Read (for checking existence or retrieving current state)\n    Task<TProjection",
        "startIndex": 8653,
        "preview": "the method level or constructor level ProjectionContext Structure `csharp{ title: \"ProjectionContext Structure\" description: \"Complete structure of Pr..."
      },
      {
        "id": "old-v1.0.0/projections/projection-contexts-chunk-5",
        "text": "} public string ServiceVersion { get; init; } public string Environment { get; init; } public string MachineName { get; init; } } public interface IProjectionStore { // Create Task CreateAsync<TProjection>(TProjection projection, CancellationToken ct = default) where TProjection : class; // Read (for checking existence or retrieving current state) Task<TProjection > GetAsync<TProjection>(object key, CancellationToken ct = default)\n        where TProjection : class;\n    // Update (replace entire document)\n    Task UpdateAsync<TProjection>(object key, TProjection projection, CancellationToken ct = default)\n        where TProjection : class;\n    // Patch (partial update)\n    Task PatchAsync<TProjection>(object key, Action<TProjection> patchAction, CancellationToken ct = default)\n        where TProjection : class;\n    // Delete\n    Task DeleteAsync<TProjection>(object key, CancellationToken ct = default)\n        where TProjection : class;\n    // Batch operations\n    Task CreateManyAsync<TProjection>(IEnumerable<TProjection> projections, CancellationToken ct = default)\n        where TProjection : class;\n}\n// Return values for projection methods\npublic enum ProjectionReturnType {\n    Accepted,  // Event was processed successfully (default)\n    Ignored    // Event was intentionally ignored/skipped\n}\npublic static class ProjectionContextExtensions {\n    // Return a projection outcome (metadata only, no side effects)\n    public static Task Return(this ProjectionContext context, ProjectionReturnType returnType) {\n        context RecordOutcome(returnType);\n        return Task CompletedTask;\n    }\n}\n`\nProjectionContext Usage Examples\nSee the complete examples in Projection Return Values ProjectionContext Benefits\nDatabase Operations: Built-in CRUD operations (Create, Update, Patch, Delete)\nProjection Metadata: Access projection name, version, and custom metadata\nService Context: Know which service and environment the projection is running in\nFlexible Injection: Inject at method or constructor level based on your needs\nBatch Operations: Efficient bulk creates for high-throughput scenarios\nReturn Values: Signal processing outcomes with Return() method\n---\nNext Steps\nProjection Subscriptions - Event subscription patterns\nProjection Purity - Maintaining pure, deterministic projections\nProjection Return Values - Using return values for observability",
        "startIndex": 9802,
        "preview": "} public string ServiceVersion { get; init; } public string Environment { get; init; } public string MachineName { get; init; } } public interface IPr..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/projections/projection-purity",
    "title": "Projection Purity",
    "category": "Projections",
    "url": "/docs/old-v1.0.0/projections/projection-purity",
    "chunks": [
      {
        "id": "old-v1.0.0/projections/projection-purity-chunk-0",
        "text": "Projection Purity\nCRITICAL: Projections must be pure functions and deterministic The same event must ALWAYS produce the same projection state, regardless of when it's processed The Purity Rule\nProjections are read-side transformations that convert event data into queryable read models They must:\nBe deterministic (same input = same output)\nHave no side effects\nUse only data from events or EventContext\nNever perform business logic\nGood vs Bad Projections\n✅ Good Projection (Pure)\n`csharp{\ntitle: \"Pure Projection Example\"\ndescription: \"Correct projection using only event data and EventContext\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Purity\", \"Best Practices\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class GoodProjection {\n    // ✅ CORRECT: Use event timestamp from EventContext\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        EventContext eventContext,\n        CancellationToken ct) {\n        var summary = new OrderSummary {\n            OrderId = @event OrderId,\n            PlacedAt = eventContext System Timestamp,  // ✅ Deterministic\n            ExpiresAt = @event ExpiresAt,              // ✅ From event (business logic set this)\n            CustomerId = @event CustomerId,\n            Total = @event Total\n        };\n        await projection Store CreateAsync(summary, ct);\n    }\n    // ✅ CORRECT: Business logic decision in event, not projection\n    public Task OnOrderPlaced2(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // Event already contains IsExpired flag (set by business logic)\n        if (@event IsExpired) {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Process non-expired order\n        return Task CompletedTask;\n    }\n    // ✅ CORRECT: Use data from event or context\n    public async Task OnOrderShipped(\n        [WhizbangSubscribe] OrderShipped @event,\n        ProjectionContext projection,\n        EventContext eventContext,\n        CancellationToken ct) {\n        await projection Store PatchAsync<OrderSummary>(\n            @event OrderId,\n            order => {\n                order Status = \"Shipped\";\n                order ShippedAt = eventContext System Timestamp;  // ✅ From context\n                order TrackingNumber = @event",
        "startIndex": 0,
        "preview": "Projection Purity\nCRITICAL: Projections must be pure functions and deterministic The same event must ALWAYS produce the same projection state, regardl..."
      },
      {
        "id": "old-v1.0.0/projections/projection-purity-chunk-1",
        "text": "// ✅ CORRECT: Use data from event or context public async Task OnOrderShipped( [WhizbangSubscribe] OrderShipped @event, ProjectionContext projection, EventContext eventContext, CancellationToken ct) { await projection Store PatchAsync<OrderSummary>( @event OrderId, order => { order Status = \"Shipped\"; order ShippedAt = eventContext System Timestamp; // ✅ From context order TrackingNumber = @event TrackingNumber;      // ✅ From event\n            },\n            ct);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public DateTime PlacedAt { get; set; }\n    public DateTime ExpiresAt { get; set; }\n    public Guid CustomerId { get; set; }\n    public decimal Total { get; set; }\n    public string Status { get; set; }\n    public DateTime ShippedAt { get; set; }\n    public string TrackingNumber { get; set; }\n}\n`\n❌ Bad Projection (Impure)\n`csharp{\ntitle: \"Impure Projection Example\"\ndescription: \"Common purity violations and how to avoid them\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Anti-Patterns\", \"Common Mistakes\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System IO\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System IO;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class BadProjection {\n    // ❌ WRONG: DateTime UtcNow is non-deterministic\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        var summary = new OrderSummary {\n            OrderId = @event OrderId,\n            PlacedAt = DateTime UtcNow,  // ❌ NON-DETERMINISTIC - Will be different on replay };\n        await projection Store CreateAsync(summary, ct);\n        // 💥 Whizbang Analyzers will flag this as a compile error\n    }\n    // ❌ WRONG: Business logic in projection\n    public Task OnOrderPlaced2(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        EventContext eventContext,\n        CancellationToken ct) {\n        // ❌ WRONG: Calculating expiration in projection is business logic\n        var age = DateTime UtcNow - eventContext System Timestamp;  // ❌ Non-deterministic\n        if (age > TimeSpan FromDays(90)) {\n            return projection Return(ProjectionReturnType",
        "startIndex": 2639,
        "preview": "// ✅ CORRECT: Use data from event or context public async Task OnOrderShipped( [WhizbangSubscribe] OrderShipped @event, ProjectionContext projection, ..."
      },
      {
        "id": "old-v1.0.0/projections/projection-purity-chunk-2",
        "text": "❌ WRONG: Business logic in projection public Task OnOrderPlaced2( [WhizbangSubscribe] OrderPlaced @event, ProjectionContext projection, EventContext eventContext, CancellationToken ct) { // ❌ WRONG: Calculating expiration in projection is business logic var age = DateTime UtcNow - eventContext System Timestamp; // ❌ Non-deterministic if (age > TimeSpan FromDays(90)) { return projection Return(ProjectionReturnType Ignored);\n        }\n        // Business logic belongs in command handler or aggregate, not projection return Task CompletedTask;\n        // 💥 Whizbang Analyzers will flag DateTime UtcNow usage\n    }\n    // ❌ WRONG: Random values\n    public async Task OnOrderPlaced3(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        var summary = new OrderSummary {\n            OrderId = @event OrderId,\n            RandomValue = Random Shared Next()  // ❌ NON-DETERMINISTIC\n        };\n        await projection Store CreateAsync(summary, ct);\n        // 💥 Whizbang Analyzers will flag Random usage\n    }\n    // ❌ WRONG: External I/O in projection\n    public async Task OnOrderPlaced4(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        HttpClient httpClient,\n        CancellationToken ct) {\n        // ❌ WRONG: Calling external API is non-deterministic\n        var customerData = await httpClient GetAsync($\"https://api/customers/{@event CustomerId}\");\n        // External data can change - not deterministic // 💥 Whizbang Analyzers will flag external I/O\n    }\n    // ❌ WRONG: File I/O in projection\n    public async Task OnOrderPlaced5(\n        [WhizbangSubscribe] OrderPlaced @event,\n        CancellationToken ct) {\n        // ❌ WRONG: File writes are side effects\n        await File WriteAllTextAsync(\"orders log\", @event OrderId ToString());\n        // 💥 Whizbang Analyzers will flag file I/O\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public DateTime PlacedAt { get; set; }\n    public int RandomValue { get; set; }\n}\n`\nPurity Rules\nProjections must follow these rules to remain pure and deterministic:\n| ❌ NEVER Use | ✅ Instead Use | Why |\n|-----------------|-------------------|---------|\n| DateTime UtcNow | eventContext System Timestamp | Current time is non-deterministic |\n| DateTime Now | eventContext System",
        "startIndex": 4666,
        "preview": "❌ WRONG: Business logic in projection public Task OnOrderPlaced2( [WhizbangSubscribe] OrderPlaced @event, ProjectionContext projection, EventContext e..."
      },
      {
        "id": "old-v1.0.0/projections/projection-purity-chunk-3",
        "text": "RandomValue { get; set; } } ` Purity Rules Projections must follow these rules to remain pure and deterministic: | ❌ NEVER Use | ✅ Instead Use | Why | |-----------------|-------------------|---------| | DateTime UtcNow | eventContext System Timestamp | Current time is non-deterministic | | DateTime Now | eventContext System Timestamp | Current time is non-deterministic |\n| Random / Guid NewGuid() | Data from event or context | Random values are non-deterministic |\n| External API calls | Data in event | External data can change |\n| Database reads (outside projection store) | Data in event | External data can change |\n| File I/O | Data in event | External data can change |\n| Environment variables | eventContext or config in event | Environment can change |\n| Business logic calculations | Business logic sets flags in event | Projections transform, don't decide |\nWhere Business Logic Belongs\nBusiness logic must live in command handlers and aggregates, NOT in projections ✅ Correct: Business Logic in Command Handler\n`csharp{\ntitle: \"Business Logic in Command Handler\"\ndescription: \"Correct placement of business logic and decision-making\"\nframework: \"NET8\"\ncategory: \"Command Handling\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Command Handlers\", \"Business Logic\", \"Best Practices\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n// ✅ CORRECT: Business logic in command handler or aggregate\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderPlaced> {\n    public async Task<OrderPlaced> Handle(\n        PlaceOrder command,\n        CommandContext context,\n        CancellationToken ct) {\n        // ✅ Business logic happens HERE\n        // - Validate the order\n        // - Check inventory\n        // - Calculate totals\n        // - Apply business rules\n        // - Decide if order should be marked as expired\n        var expiresAt = DateTime UtcNow",
        "startIndex": 6647,
        "preview": "RandomValue { get; set; } } ` Purity Rules Projections must follow these rules to remain pure and deterministic: | ❌ NEVER Use | ✅ Instead Use | Why |..."
      },
      {
        "id": "old-v1.0.0/projections/projection-purity-chunk-4",
        "text": "public async Task<OrderPlaced> Handle( PlaceOrder command, CommandContext context, CancellationToken ct) { // ✅ Business logic happens HERE // - Validate the order // - Check inventory // - Calculate totals // - Apply business rules // - Decide if order should be marked as expired var expiresAt = DateTime UtcNow AddDays(90);  // ✅ Business decision\n        var isExpired = false;  // ✅ Business decision\n        var status = \"Placed\";   // ✅ Business decision\n        // Create event POCO with results of business logic\n        // Event is just a data container - NO logic in the event class itself\n        var @event = context EmitEvent(new OrderPlaced {\n            OrderId = command OrderId,\n            CustomerId = command CustomerId,\n            Total = command Total,\n            ExpiresAt = expiresAt,      // ✅ Set by handler\n            IsExpired = isExpired,       // ✅ Set by handler\n            Status = status              // ✅ Set by handler\n        });\n        return @event;\n    }\n}\n// ✅ CORRECT: Event is just a POCO (Plain Old CLR Object)\n// NO business logic, NO methods (except maybe ToString for debugging)\n// Just immutable data describing what happened\npublic record OrderPlaced {\n    public Guid OrderId { get; init; }\n    public Guid CustomerId { get; init; }\n    public decimal Total { get; init; }\n    public DateTime ExpiresAt { get; init; }     // ✅ Data only\n    public bool IsExpired { get; init; }         // ✅ Data only\n    public string Status { get; init; }          // ✅ Data only\n    // ❌ NO business logic methods like:\n    // public bool ShouldExpire() => DateTime",
        "startIndex": 8342,
        "preview": "public async Task<OrderPlaced> Handle( PlaceOrder command, CommandContext context, CancellationToken ct) { // ✅ Business logic happens HERE // - Valid..."
      },
      {
        "id": "old-v1.0.0/projections/projection-purity-chunk-5",
        "text": "{ get; init; } public DateTime ExpiresAt { get; init; } // ✅ Data only public bool IsExpired { get; init; } // ✅ Data only public string Status { get; init; } // ✅ Data only // ❌ NO business logic methods like: // public bool ShouldExpire() => DateTime UtcNow > ExpiresAt;\n    // public void MarkAsExpired() => IsExpired = true;\n    // Events are immutable data - handlers make decisions, events record them\n}\n// ✅ CORRECT: Projection just transforms event data\n[WhizbangProjection]\npublic class OrderProjection {\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // ✅ No business logic - just transform POCO event to read model\n        var summary = new OrderSummary {\n            OrderId = @event OrderId,\n            ExpiresAt = @event ExpiresAt,    // ✅ Copy from event (handler set this)\n            IsExpired = @event IsExpired,     // ✅ Copy from event (handler set this)\n            Status = @event Status            // ✅ Copy from event (handler set this)\n        };\n        if (@event IsExpired) {\n            // Simple filtering based on event data (not a business decision)\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        await projection Store CreateAsync(summary, ct);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public DateTime ExpiresAt { get; set; }\n    public bool IsExpired { get; set; }\n    public string Status { get; set; }\n}\n`\nThe Three-Layer Architecture\nWhizbang enforces a clear separation of concerns:\n`mermaid\ngraph TB\n    subgraph BusinessLogic[\"Command Handler / Aggregate (Business Logic Layer)\"]\n        BL1[\"✅ Validates commands\"]\n        BL2[\"✅ Applies business rules\"]\n        BL3[\"✅ Makes decisions\"]\n        BL4[\"✅ Creates event POCOs with results\"]\n        BL5[\"✅ CAN emit commands (sagas)\"]\n        BL6[\"✅ CAN use DateTime",
        "startIndex": 9635,
        "preview": "{ get; init; } public DateTime ExpiresAt { get; init; } // ✅ Data only public bool IsExpired { get; init; } // ✅ Data only public string Status { get;..."
      },
      {
        "id": "old-v1.0.0/projections/projection-purity-chunk-6",
        "text": "set; } } ` The Three-Layer Architecture Whizbang enforces a clear separation of concerns: `mermaid graph TB subgraph BusinessLogic[\"Command Handler / Aggregate (Business Logic Layer)\"] BL1[\"✅ Validates commands\"] BL2[\"✅ Applies business rules\"] BL3[\"✅ Makes decisions\"] BL4[\"✅ Creates event POCOs with results\"] BL5[\"✅ CAN emit commands (sagas)\"] BL6[\"✅ CAN use DateTime UtcNow, Random, APIs\"]\n    end\n    subgraph DataLayer[\"Data Layer (POCOs - No Logic)\"]\n        Event[\"Event<br/>- Properties only<br/>- NO methods<br/>- Describes what happened\"]\n        Command[\"Command<br/>- Properties only<br/>- NO methods<br/>- Describes intent\"]\n    end\n    subgraph ReadModel[\"Projection (Read Model Layer)\"]\n        P1[\"✅ Pure transformation of event data\"]\n        P2[\"❌ NO business logic\"]\n        P3[\"❌ NO DateTime UtcNow, Random, APIs\"]\n        P4[\"✅ ONLY event data or EventContext\"]\n        P5[\"✅ Deterministic and replayable\"]\n    end\n    BusinessLogic -->|Emits Events| Event\n    BusinessLogic -->|Emits Commands| Command\n    Event -->|Consumed by| ReadModel\n    Command -->|Handled by| BusinessLogic\n    style BusinessLogic fill:#d4edda,stroke:#28a745,stroke-width:2px\n    style DataLayer fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    style ReadModel fill:#cce5ff,stroke:#004085,stroke-width:2px\n    style Event fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    style Command fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n`\nWhy Purity Matters\nReplay: Events can be replayed to rebuild projections - must produce same result\nTesting: Pure functions are easy to test - same input, same output\nDebugging: Deterministic behavior makes bugs reproducible\nScaling: Multiple projection instances can process same events safely\nTime Travel: Can replay events from any point in time\nAuditing: Projection state is always verifiable from event stream\nDisaster Recovery: Projections can be rebuilt from events after data loss\nBlue/Green Deployments: New projection version can process same events\nWhizbang Analyzers Enforcement\nThe Whizbang Analyzers package enforces purity at compile time:\n`csharp{\ntitle: \"Analyzer Enforcement Example\"\ndescription: \"Compile-time purity validation with Whizbang Analyzers\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Analyzers\", \"Purity\", \"Compile-Time Validation\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\", \"Whizbang Analyzers\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading",
        "startIndex": 11329,
        "preview": "set; } } ` The Three-Layer Architecture Whizbang enforces a clear separation of concerns: `mermaid graph TB subgraph BusinessLogic[\"Command Handler / ..."
      },
      {
        "id": "old-v1.0.0/projections/projection-purity-chunk-7",
        "text": "compile time: `csharp{ title: \"Analyzer Enforcement Example\" description: \"Compile-time purity validation with Whizbang Analyzers\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Analyzers\", \"Purity\", \"Compile-Time Validation\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\", \"Whizbang Analyzers\"] usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading; using System Threading Tasks;\n[WhizbangProjection]\npublic class OrderProjection {\n    private readonly ILogger _logger;  // ⚠️ Warning: Injected services should be read-only\n    // ✅ VALID - Pure projection handler\n    public Task Handle([WhizbangSubscribe] OrderPlaced @event, EventContext context, CancellationToken ct) {\n        // Pure state updates only\n        var summary = new OrderSummary {\n            PlacedAt = context System Timestamp  // ✅ OK - from context\n        };\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - Side effect detected (logging)\n    public Task Handle([WhizbangSubscribe] OrderShipped @event, CancellationToken ct) {\n        _logger LogInformation(\"Order shipped\");  // 💥 WBG001: Side effect in projection\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - DateTime UtcNow usage\n    public Task Handle([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) {\n        var cancelledAt = DateTime UtcNow;  // 💥 WBG002: Non-deterministic time source\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - Random value generation\n    public Task Handle([WhizbangSubscribe] OrderCompleted @event, CancellationToken ct) {\n        var random = Random Shared Next();  // 💥 WBG003: Non-deterministic random source\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - External I/O detected\n    public async Task Handle([WhizbangSubscribe] OrderRefunded @event, CancellationToken ct) {\n        await File WriteAllTextAsync(\"log txt\", \"refunded\");  // 💥 WBG004: I/O in projection\n    }\n}\npublic class OrderSummary {\n    public DateTime PlacedAt { get; set; }\n}\n`\nAnalyzer Error Codes\nWBG001: Side effect detected in projection (logging, console writes, etc )\nWBG002: Non-deterministic time source (DateTime UtcNow, DateTime Now)\nWBG003: Non-deterministic random source (Random, Guid NewGuid())\nWBG004: I/O operation detected (file system, network, external database)\nWBG005: Database operation outside ProjectionContext",
        "startIndex": 13523,
        "preview": "compile time: `csharp{ title: \"Analyzer Enforcement Example\" description: \"Compile-time purity validation with Whizbang Analyzers\" framework: \"NET8\" c..."
      },
      {
        "id": "old-v1.0.0/projections/projection-purity-chunk-8",
        "text": "PlacedAt { get; set; } } ` Analyzer Error Codes WBG001: Side effect detected in projection (logging, console writes, etc ) WBG002: Non-deterministic time source (DateTime UtcNow, DateTime Now) WBG003: Non-deterministic random source (Random, Guid NewGuid()) WBG004: I/O operation detected (file system, network, external database) WBG005: Database operation outside ProjectionContext Store\nWBG006: Environment variable access\nWBG007: Complex business logic detected in projection (warning)\nPurity Checklist\nBefore merging projection code, verify:\n[ ] No DateTime UtcNow or DateTime Now usage\n[ ] No Random or Guid NewGuid() calls\n[ ] No external API calls (HTTP, gRPC, etc )\n[ ] No file system operations\n[ ] No logging or console writes\n[ ] No database operations outside ProjectionContext Store\n[ ] No environment variable reads\n[ ] All timestamps from EventContext System Timestamp\n[ ] All business decisions from event data (not calculated in projection)\n[ ] Whizbang Analyzers passes with no errors\nSummary\nProjections = Pure transformations of event data into read models\nBusiness Logic = Command handlers and aggregates that make decisions and emit events\nEvents = POCOs describing what happened (no logic)\nDeterminism = Same event always produces same projection state\nWhizbang Analyzers = Compile-time enforcement of purity rules\nNext Steps\nProjection Subscriptions - Event subscription patterns\nProjection Contexts - EventContext and ProjectionContext injection\nProjection Return Values - Using return values for observability",
        "startIndex": 15479,
        "preview": "PlacedAt { get; set; } } ` Analyzer Error Codes WBG001: Side effect detected in projection (logging, console writes, etc ) WBG002: Non-deterministic t..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/projections/projection-return-values",
    "title": "Projection Return Values",
    "category": "Projections",
    "url": "/docs/old-v1.0.0/projections/projection-return-values",
    "chunks": [
      {
        "id": "old-v1.0.0/projections/projection-return-values-chunk-0",
        "text": "Projection Return Values\nProjection methods can return metadata about the processing outcome using ProjectionContext Return() This is metadata only with no side effects - it's purely for observability and metrics ProjectionReturnType Enum\n`csharp{\ntitle: \"ProjectionReturnType Enum\"\ndescription: \"Enumeration defining the possible return values for projection methods\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"BEGINNER\"\ntags: [\"Projections\", \"Return Values\", \"Enums\"]\nfilename: \"ProjectionReturnType cs\"\nusingStatements: [\"System\"]\nshowLineNumbers: true\n}\npublic enum ProjectionReturnType {\n    Accepted,  // Event was processed successfully (default)\n    Ignored    // Event was intentionally ignored/skipped\n}\n`\nReturn Value Semantics\n| Return Type | Meaning | Use When | Metrics Impact |\n|------------|---------|----------|----------------|\n| Accepted | Event was processed successfully | Default behavior, projection state updated | Increments events_processed counter |\n| Ignored | Event was intentionally skipped | Filtering, tenant isolation, deduplication | Increments events_ignored counter |\nBasic Usage\n`csharp{\ntitle: \"Basic Projection Return Values\"\ndescription: \"Using return values to signal projection processing outcomes\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"BEGINNER\"\ntags: [\"Projections\", \"Return Values\", \"Observability\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class OrderProjection {\n    // Example 1: Explicit Accepted return (default behavior)\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        await projection Store CreateAsync(new OrderSummary {\n            OrderId = @event OrderId,\n            Status = \"Placed\"\n        }, ct);\n        // Explicitly signal success (optional - this is the default)\n        return projection Return(ProjectionReturnType Accepted);\n    }\n    // Example 2: Implicit Accepted (no return statement)\n    public async Task OnOrderShipped(\n        [WhizbangSubscribe] OrderShipped @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        await projection Store PatchAsync<OrderSummary>(\n            @event OrderId,\n            order => order",
        "startIndex": 0,
        "preview": "Projection Return Values\nProjection methods can return metadata about the processing outcome using ProjectionContext Return() This is metadata only wi..."
      },
      {
        "id": "old-v1.0.0/projections/projection-return-values-chunk-1",
        "text": "OrderId, Status = \"Placed\" }, ct); // Explicitly signal success (optional - this is the default) return projection Return(ProjectionReturnType Accepted); } // Example 2: Implicit Accepted (no return statement) public async Task OnOrderShipped( [WhizbangSubscribe] OrderShipped @event, ProjectionContext projection, CancellationToken ct) { await projection Store PatchAsync<OrderSummary>( @event OrderId, order => order Status = \"Shipped\",\n            ct);\n        // No explicit return = Accepted (default)\n    }\n    // Example 3: Ignored return (event intentionally skipped)\n    public Task OnOrderEvent(\n        [WhizbangSubscribe] OrderEvent @event,\n        ProjectionContext projection,\n        EventContext eventContext,\n        CancellationToken ct) {\n        // Only process events for current tenant\n        if (eventContext Security TenantId = projection Service CurrentTenantId) {\n            // Different tenant - ignore this event\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Process the event\n        // return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public string Status { get; set; }\n}\n`\nCommon Use Cases for Ignored\nTenant Isolation\n`csharp{\ntitle: \"Tenant Isolation with Return Values\"\ndescription: \"Using Ignored to skip events for different tenants\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Multi-Tenancy\", \"Filtering\", \"Return Values\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class TenantOrderProjection {\n    private readonly Guid _currentTenantId;\n    public TenantOrderProjection(Guid currentTenantId) {\n        _currentTenantId = currentTenantId;\n    }\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        EventContext eventContext,\n        CancellationToken ct) {\n        // Skip events for other tenants\n        if (eventContext Security TenantId = _currentTenantId) {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Process event for current tenant\n        await projection Store CreateAsync(new OrderSummary {\n            OrderId = @event OrderId,\n            TenantId = _currentTenantId,\n            Status = \"Placed\"\n        }, ct);\n        return projection Return(ProjectionReturnType",
        "startIndex": 2482,
        "preview": "OrderId, Status = \"Placed\" }, ct); // Explicitly signal success (optional - this is the default) return projection Return(ProjectionReturnType Accepte..."
      },
      {
        "id": "old-v1.0.0/projections/projection-return-values-chunk-2",
        "text": "EventContext eventContext, CancellationToken ct) { // Skip events for other tenants if (eventContext Security TenantId = _currentTenantId) { return projection Return(ProjectionReturnType Ignored); } // Process event for current tenant await projection Store CreateAsync(new OrderSummary { OrderId = @event OrderId, TenantId = _currentTenantId, Status = \"Placed\" }, ct); return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public Guid TenantId { get; set; }\n    public string Status { get; set; }\n}\n`\nVersion Checking and Deduplication\n`csharp{\ntitle: \"Version Checking and Deduplication\"\ndescription: \"Using Ignored to skip out-of-order or duplicate events\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Deduplication\", \"Versioning\", \"Return Values\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class VersionedOrderProjection {\n    public async Task OnOrderUpdated(\n        [WhizbangSubscribe] OrderUpdated @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // Get current projection state\n        var current = await projection Store GetAsync<OrderSummary>(@event OrderId, ct);\n        // Ignore if projection doesn't exist (might be deleted)\n        if (current == null) {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Ignore if event is older than current state (out-of-order delivery)\n        if (@event Version <= current Version) {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Update the projection\n        await projection Store UpdateAsync(@event OrderId, new OrderSummary {\n            OrderId = @event OrderId,\n            Version = @event Version,\n            Status = @event Status\n        }, ct);\n        return projection Return(ProjectionReturnType",
        "startIndex": 4692,
        "preview": "EventContext eventContext, CancellationToken ct) { // Skip events for other tenants if (eventContext Security TenantId = _currentTenantId) { return pr..."
      },
      {
        "id": "old-v1.0.0/projections/projection-return-values-chunk-3",
        "text": "if event is older than current state (out-of-order delivery) if (@event Version <= current Version) { return projection Return(ProjectionReturnType Ignored); } // Update the projection await projection Store UpdateAsync(@event OrderId, new OrderSummary { OrderId = @event OrderId, Version = @event Version, Status = @event Status }, ct); return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public int Version { get; set; }\n    public string Status { get; set; }\n}\n`\nEvent Data Filtering\n`csharp{\ntitle: \"Event Data Filtering\"\ndescription: \"Using Ignored to filter based on event flags set by business logic\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Filtering\", \"Event Data\", \"Return Values\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class ActiveOrderProjection {\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // ✅ CORRECT: Business logic already set IsExpired in the event\n        // The command handler made this decision, projection just filters\n        if (@event IsExpired) {\n            // Event already marked as expired by business logic\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Process non-expired event\n        await projection Store CreateAsync(new OrderSummary {\n            OrderId = @event OrderId,\n            Status = \"Active\"\n        }, ct);\n        return projection Return(ProjectionReturnType Accepted);\n    }\n    public async Task OnOrderStatusChanged(\n        [WhizbangSubscribe] OrderStatusChanged @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // Only track \"active\" status changes\n        if (@event NewStatus = \"Active\") {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        await projection Store PatchAsync<OrderSummary>(\n            @event OrderId,\n            order => order Status = @event NewStatus,\n            ct);\n        return projection Return(ProjectionReturnType",
        "startIndex": 6383,
        "preview": "if event is older than current state (out-of-order delivery) if (@event Version <= current Version) { return projection Return(ProjectionReturnType Ig..."
      },
      {
        "id": "old-v1.0.0/projections/projection-return-values-chunk-4",
        "text": "projection Return(ProjectionReturnType Accepted); } public async Task OnOrderStatusChanged( [WhizbangSubscribe] OrderStatusChanged @event, ProjectionContext projection, CancellationToken ct) { // Only track \"active\" status changes if (@event NewStatus = \"Active\") { return projection Return(ProjectionReturnType Ignored); } await projection Store PatchAsync<OrderSummary>( @event OrderId, order => order Status = @event NewStatus, ct); return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public string Status { get; set; }\n}\n`\nFeature Flag Filtering\n`csharp{\ntitle: \"Feature Flag Filtering\"\ndescription: \"Using Ignored to skip events when features are disabled\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"ADVANCED\"\ntags: [\"Feature Flags\", \"Configuration\", \"Return Values\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class NotificationProjection {\n    private readonly IFeatureFlagService _featureFlags;\n    public NotificationProjection(IFeatureFlagService featureFlags) {\n        _featureFlags = featureFlags;\n    }\n    public async Task OnOrderShipped(\n        [WhizbangSubscribe] OrderShipped @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // Skip if shipping notifications are disabled\n        // Feature flag is from config, not time-based (deterministic for replay)\n        if ( _featureFlags IsEnabled(\"ShippingNotifications\")) {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        await projection Store CreateAsync(new NotificationRecord {\n            EventId = @event OrderId,\n            Type = \"ShippingNotification\",\n            CreatedAt = DateTime UtcNow\n        }, ct);\n        return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic interface IFeatureFlagService {\n    bool IsEnabled(string featureName);\n}\npublic class NotificationRecord {\n    public Guid EventId { get; set; }\n    public string Type { get; set; }\n    public DateTime CreatedAt { get; set; }\n}\n`\nProjection Existence Checking\n`csharp{\ntitle: \"Projection Existence Checking\"\ndescription: \"Using Ignored to skip updates to deleted projections\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Existence Checks\", \"Deleted Projections\", \"Return Values\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading",
        "startIndex": 8369,
        "preview": "projection Return(ProjectionReturnType Accepted); } public async Task OnOrderStatusChanged( [WhizbangSubscribe] OrderStatusChanged @event, ProjectionC..."
      },
      {
        "id": "old-v1.0.0/projections/projection-return-values-chunk-5",
        "text": "`csharp{ title: \"Projection Existence Checking\" description: \"Using Ignored to skip updates to deleted projections\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Existence Checks\", \"Deleted Projections\", \"Return Values\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"] usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading; using System Threading Tasks;\n[WhizbangProjection]\npublic class OrderHistoryProjection {\n    public async Task OnOrderUpdated(\n        [WhizbangSubscribe] OrderUpdated @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // Check if projection exists\n        var existing = await projection Store GetAsync<OrderHistory>(@event OrderId, ct);\n        if (existing == null) {\n            // Projection was deleted or never created - ignore this update\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Update existing projection\n        await projection Store PatchAsync<OrderHistory>(\n            @event OrderId,\n            history => history UpdatedAt = DateTime UtcNow,\n            ct);\n        return projection Return(ProjectionReturnType Accepted);\n    }\n    public async Task OnOrderDeleted(\n        [WhizbangSubscribe] OrderDeleted @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        await projection Store DeleteAsync<OrderHistory>(@event OrderId, ct);\n        return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic class OrderHistory {\n    public Guid OrderId { get; set; }\n    public DateTime UpdatedAt { get; set; }\n}\n`\nImportant Notes\nNo Side Effects: Return values are metadata only - they don't affect event flow or projection state\nDefault is Accepted: If you don't explicitly return, Accepted is assumed\nObservability: Return values are recorded for metrics, logging, and dashboard visualization\nNo Error Return: Errors should throw exceptions, not return a status code\nPure Metadata: Return values don't trigger any framework behavior - they're for observability\nMetrics and Observability\nReturn values enable rich metrics and dashboards:\n`csharp{\ntitle: \"Automatic Metrics Tracking\"\ndescription: \"Example metrics automatically tracked by Whizbang for projection return values\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Metrics\", \"Observability\", \"Monitoring\"]\nfilename: \"MetricsExample",
        "startIndex": 10658,
        "preview": "`csharp{ title: \"Projection Existence Checking\" description: \"Using Ignored to skip updates to deleted projections\" framework: \"NET8\" category: \"Proje..."
      },
      {
        "id": "old-v1.0.0/projections/projection-return-values-chunk-6",
        "text": "Metadata: Return values don't trigger any framework behavior - they're for observability Metrics and Observability Return values enable rich metrics and dashboards: `csharp{ title: \"Automatic Metrics Tracking\" description: \"Example metrics automatically tracked by Whizbang for projection return values\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Metrics\", \"Observability\", \"Monitoring\"] filename: \"MetricsExample cs\"\nusingStatements: [\"System\"]\nshowLineNumbers: true\n}\n// Whizbang automatically tracks these metrics:\n// - whizbang_projection_events_accepted{projection=\"OrderProjection\", event=\"OrderPlaced\"}\n// - whizbang_projection_events_ignored{projection=\"OrderProjection\", event=\"OrderPlaced\"}\n// - whizbang_projection_acceptance_rate{projection=\"OrderProjection\"}\n// - whizbang_projection_throughput{projection=\"OrderProjection\"}\n`\nDashboard Visualization\nThe Whizbang Dashboard uses return values to show:\nProjection Health: Acceptance rate over time\nEvent Filtering: Which events are commonly ignored\nTenant Metrics: Events processed per tenant\nPerformance: Throughput and latency per projection\nDebugging: Identify misconfigured filters\nExample Metrics Query\n`promql\nProjection acceptance rate (should be high for normal operations)\nsum(rate(whizbang_projection_events_accepted[5m])) by (projection)\n/\nsum(rate(whizbang_projection_events_total[5m])) by (projection)\nEvents ignored by reason (for debugging)\nsum(rate(whizbang_projection_events_ignored[5m])) by (projection, reason)\nTenant-specific processing rate\nsum(rate(whizbang_projection_events_accepted[5m])) by (tenant_id)\n`\nBest Practices\nBe Explicit When Filtering\n`csharp{\ntitle: \"Explicit Filtering Best Practice\"\ndescription: \"Best practices for explicit return value usage vs implicit behavior\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"BEGINNER\"\ntags: [\"Best Practices\", \"Return Values\", \"Explicit Programming\"]\nfilename: \"ExplicitFilteringExample cs\"\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\n// ✅ GOOD - Explicit and clear\nif (@event IsExpired) {\n    return projection Return(ProjectionReturnType Ignored);\n}\n// ❌ BAD - Implicit, unclear why event is ignored\nif (@event IsExpired) {\n    return Task CompletedTask;  // Looks like Accepted, but event wasn't processed\n}\n`\nUse Ignored for Intentional Filtering\n`csharp{\ntitle: \"Intentional Filtering vs Error Handling\"\ndescription: \"Correct usage of Ignored for filtering vs incorrect usage for error handling\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Best Practices\", \"Error Handling\", \"Filtering\"]\nfilename: \"FilteringVsErrorHandling cs\"\nusingStatements: [\"System\", \"System Threading\", \"System Threading",
        "startIndex": 12696,
        "preview": "Metadata: Return values don't trigger any framework behavior - they're for observability Metrics and Observability Return values enable rich metrics a..."
      },
      {
        "id": "old-v1.0.0/projections/projection-return-values-chunk-7",
        "text": "wasn't processed } ` Use Ignored for Intentional Filtering `csharp{ title: \"Intentional Filtering vs Error Handling\" description: \"Correct usage of Ignored for filtering vs incorrect usage for error handling\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Best Practices\", \"Error Handling\", \"Filtering\"] filename: \"FilteringVsErrorHandling cs\" usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\n// ✅ GOOD - Intentional filtering (return Ignored)\nif (eventContext Security TenantId = _currentTenantId) {\n    return projection Return(ProjectionReturnType Ignored);\n}\n// ❌ BAD - Errors should throw exceptions, not return Ignored\ntry {\n    await projection Store CreateAsync(summary, ct);\n} catch (Exception) {\n    return projection Return(ProjectionReturnType Ignored);  // Wrong Throw the exception\n}\n`\nDocument Ignored Reasons\n`csharp{\ntitle: \"Documented Filtering Reasons\"\ndescription: \"Best practice for documenting why events are ignored with clear comments\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"BEGINNER\"\ntags: [\"Best Practices\", \"Documentation\", \"Code Comments\"]\nfilename: \"DocumentedFilteringExample cs\"\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\n// ✅ GOOD - Comment explains why event is ignored\npublic Task OnOrderPlaced(\n    [WhizbangSubscribe] OrderPlaced @event,\n    ProjectionContext projection,\n    EventContext eventContext,\n    CancellationToken ct) {\n    // Ignore events for other tenants - this projection is tenant-scoped\n    if (eventContext Security TenantId = _currentTenantId) {\n        return projection Return(ProjectionReturnType Ignored);\n    }\n    // Process event }\n`\nMonitor Acceptance Rates\nSet up alerts for low acceptance rates:\n`yaml\nPrometheus alert rule\nalert: LowProjectionAcceptanceRate\n  expr: |\n    sum(rate(whizbang_projection_events_accepted[5m])) by (projection)\n    /\n    sum(rate(whizbang_projection_events_total[5m])) by (projection)\n    < 0 5\n  for: 10m\n  annotations:\n    summary: \"Projection {{ $labels",
        "startIndex": 15016,
        "preview": "wasn't processed } ` Use Ignored for Intentional Filtering `csharp{ title: \"Intentional Filtering vs Error Handling\" description: \"Correct usage of Ig..."
      },
      {
        "id": "old-v1.0.0/projections/projection-return-values-chunk-8",
        "text": "Security TenantId = _currentTenantId) { return projection Return(ProjectionReturnType Ignored); } // Process event } ` Monitor Acceptance Rates Set up alerts for low acceptance rates: `yaml Prometheus alert rule alert: LowProjectionAcceptanceRate expr: | sum(rate(whizbang_projection_events_accepted[5m])) by (projection) / sum(rate(whizbang_projection_events_total[5m])) by (projection) < 0 5 for: 10m annotations: summary: \"Projection {{ $labels projection }} has low acceptance rate\"\n    description: \"Less than 50% of events are being accepted\"\n`\nSummary\nReturn values are metadata only - no side effects\nDefault is Accepted - explicit return is optional\nUse Ignored for intentional filtering - tenant isolation, versioning, feature flags\nErrors should throw exceptions - not return Ignored\nMetrics enable observability - track acceptance rates, throughput, and health\nDashboard visualization - see projection health and filtering patterns\nNext Steps\nProjection Subscriptions - Event subscription patterns\nProjection Contexts - EventContext and ProjectionContext injection\nProjection Purity - Maintaining pure, deterministic projections",
        "startIndex": 16684,
        "preview": "Security TenantId = _currentTenantId) { return projection Return(ProjectionReturnType Ignored); } // Process event } ` Monitor Acceptance Rates Set up..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/projections/projection-subscriptions",
    "title": "Projection Subscriptions",
    "category": "Projections",
    "url": "/docs/old-v1.0.0/projections/projection-subscriptions",
    "chunks": [
      {
        "id": "old-v1.0.0/projections/projection-subscriptions-chunk-0",
        "text": "Projection Subscriptions\nWhizbang provides flexible event subscription patterns using the [WhizbangSubscribe] attribute Projections can subscribe to specific event types, base classes, interfaces, or use generic methods for maximum reusability Basic Subscription Pattern\nPlace [WhizbangSubscribe] directly on the method parameter representing the event:\n`csharp{\ntitle: \"Basic Event Subscription\"\ndescription: \"Simple event subscription pattern with flexible method naming\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"BEGINNER\"\ntags: [\"Projections\", \"Subscriptions\", \"Events\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class OrderHistoryProjection {\n    private readonly List<OrderSummary> _orders = new();\n    // ✅ Method names are flexible - use what makes sense\n    public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) {\n        _orders Add(new OrderSummary(@event OrderId, \"Placed\"));\n        return Task CompletedTask;\n    }\n    public Task On([WhizbangSubscribe] OrderShipped @event, CancellationToken ct) {\n        var order = _orders First(o => o OrderId == @event OrderId);\n        order Status = \"Shipped\";\n        return Task CompletedTask;\n    }\n    public Task When([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) {\n        _orders RemoveAll(o => o OrderId == @event OrderId);\n        return Task CompletedTask;\n    }\n    // Descriptive names work too\n    public Task OnOrderCompleted([WhizbangSubscribe] OrderCompleted @event, CancellationToken ct) {\n        var order = _orders First(o => o OrderId == @event OrderId);\n        order Status = \"Completed\";\n        return Task",
        "startIndex": 0,
        "preview": "Projection Subscriptions\nWhizbang provides flexible event subscription patterns using the [WhizbangSubscribe] attribute Projections can subscribe to s..."
      },
      {
        "id": "old-v1.0.0/projections/projection-subscriptions-chunk-1",
        "text": "public Task When([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) { _orders RemoveAll(o => o OrderId == @event OrderId); return Task CompletedTask; } // Descriptive names work too public Task OnOrderCompleted([WhizbangSubscribe] OrderCompleted @event, CancellationToken ct) { var order = _orders First(o => o OrderId == @event OrderId); order Status = \"Completed\"; return Task CompletedTask;\n    }\n}\npublic record OrderSummary(Guid OrderId, string Status) {\n    public string Status { get; set; } = Status;\n}\n`\nSubscription Rules\nOne subscription per method: Only one parameter can have [WhizbangSubscribe] attribute\nAdditional parameters allowed: CancellationToken, EventContext, ProjectionContext, injected services\nFlexible naming: Use Handle, On, When, or any descriptive name\nAuto-registration: Source generator automatically wires subscriptions to service configuration\nSupports polymorphism: Subscribe to base classes or interfaces\nPolymorphic Subscriptions\nBase Class Subscriptions\nSubscribe to a base class to handle all derived event types:\n`csharp{\ntitle: \"Base Class Event Subscriptions\"\ndescription: \"Using base classes to handle multiple event types\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Polymorphism\", \"Base Classes\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n// Base class for all order events\npublic abstract record OrderEvent(Guid OrderId, DateTime Timestamp);\n// Derived event types\npublic record OrderPlaced(Guid OrderId, DateTime Timestamp, decimal Total)\n    : OrderEvent(OrderId, Timestamp);\npublic record OrderShipped(Guid OrderId, DateTime Timestamp, string TrackingNumber)\n    : OrderEvent(OrderId, Timestamp);\npublic record OrderCancelled(Guid OrderId, DateTime Timestamp, string Reason)\n    : OrderEvent(OrderId, Timestamp);\n[WhizbangProjection]\npublic class OrderAuditProjection {\n    private readonly List<AuditRecord> _auditLog = new();\n    // Single method handles ALL OrderEvent-derived types\n    public Task Handle([WhizbangSubscribe] OrderEvent @event, CancellationToken ct) {\n        // Common processing for all order events\n        LogAudit(@event OrderId, @event GetType() Name, @event",
        "startIndex": 1857,
        "preview": "public Task When([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) { _orders RemoveAll(o => o OrderId == @event OrderId); return Task C..."
      },
      {
        "id": "old-v1.0.0/projections/projection-subscriptions-chunk-2",
        "text": "public record OrderCancelled(Guid OrderId, DateTime Timestamp, string Reason) : OrderEvent(OrderId, Timestamp); [WhizbangProjection] public class OrderAuditProjection { private readonly List<AuditRecord> _auditLog = new(); // Single method handles ALL OrderEvent-derived types public Task Handle([WhizbangSubscribe] OrderEvent @event, CancellationToken ct) { // Common processing for all order events LogAudit(@event OrderId, @event GetType() Name, @event Timestamp);\n        // Pattern matching for specific handling\n        return @event switch {\n            OrderPlaced placed => HandlePlaced(placed),\n            OrderShipped shipped => HandleShipped(shipped),\n            OrderCancelled cancelled => HandleCancelled(cancelled),\n            _ => Task CompletedTask\n        };\n    }\n    private Task HandlePlaced(OrderPlaced @event) {\n        _auditLog Add(new AuditRecord(\"Order placed with total: \" + @event Total));\n        return Task CompletedTask;\n    }\n    private Task HandleShipped(OrderShipped @event) {\n        _auditLog Add(new AuditRecord(\"Order shipped: \" + @event TrackingNumber));\n        return Task CompletedTask;\n    }\n    private Task HandleCancelled(OrderCancelled @event) {\n        _auditLog Add(new AuditRecord(\"Order cancelled: \" + @event Reason));\n        return Task CompletedTask;\n    }\n    private void LogAudit(Guid orderId, string eventType, DateTime timestamp) {\n        Console WriteLine($\"[{timestamp}] {eventType} - Order {orderId}\");\n    }\n}\npublic record AuditRecord(string Message);\n`\nInterface Subscriptions\nSubscribe to an interface to handle all implementing event types:\n`csharp{\ntitle: \"Interface Event Subscriptions\"\ndescription: \"Using interfaces to handle multiple event types\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Polymorphism\", \"Interfaces\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading;\nusing System Threading",
        "startIndex": 3841,
        "preview": "public record OrderCancelled(Guid OrderId, DateTime Timestamp, string Reason) : OrderEvent(OrderId, Timestamp); [WhizbangProjection] public class Orde..."
      },
      {
        "id": "old-v1.0.0/projections/projection-subscriptions-chunk-3",
        "text": "Event Subscriptions\" description: \"Using interfaces to handle multiple event types\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Projections\", \"Polymorphism\", \"Interfaces\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"] usingStatements: [\"System\", \"System Collections Generic\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Collections Generic; using System Threading; using System Threading Tasks;\n// Interface for all inventory events\npublic interface IInventoryEvent {\n    Guid ProductId { get; }\n}\n// Event implementations\npublic record InventoryAdjusted(Guid ProductId, int Quantity) : IInventoryEvent;\npublic record InventoryReserved(Guid ProductId, int Quantity, Guid OrderId) : IInventoryEvent;\npublic record InventoryReleased(Guid ProductId, int Quantity, Guid OrderId) : IInventoryEvent;\n[WhizbangProjection]\npublic class InventoryProjection {\n    private readonly Dictionary<Guid, int> _stock = new();\n    // Single method handles ALL IInventoryEvent implementations\n    public Task Handle([WhizbangSubscribe] IInventoryEvent @event, CancellationToken ct) {\n        return @event switch {\n            InventoryAdjusted adjusted => HandleAdjusted(adjusted),\n            InventoryReserved reserved => HandleReserved(reserved),\n            InventoryReleased released => HandleReleased(released),\n            _ => Task CompletedTask\n        };\n    }\n    private Task HandleAdjusted(InventoryAdjusted @event) {\n        _stock[@event ProductId] = @event Quantity;\n        return Task CompletedTask;\n    }\n    private Task HandleReserved(InventoryReserved @event) {\n        if (_stock ContainsKey(@event ProductId)) {\n            _stock[@event ProductId] -= @event Quantity;\n        }\n        return Task CompletedTask;\n    }\n    private Task HandleReleased(InventoryReleased @event) {\n        if (_stock ContainsKey(@event ProductId)) {\n            _stock[@event ProductId] += @event Quantity;\n        }\n        return Task CompletedTask;\n    }\n    // Query method\n    public int GetStock(Guid productId) {\n        return _stock TryGetValue(productId, out var stock) stock : 0;\n    }\n}\n`\nGeneric Method Subscriptions\nUse generic methods for maximum flexibility and reusability:\n`csharp{\ntitle: \"Generic Method Subscriptions\"\ndescription: \"Using generic methods to handle multiple event types with shared logic\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Generics\", \"Polymorphism\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading;\nusing System Threading",
        "startIndex": 5512,
        "preview": "Event Subscriptions\" description: \"Using interfaces to handle multiple event types\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIAT..."
      },
      {
        "id": "old-v1.0.0/projections/projection-subscriptions-chunk-4",
        "text": "generic methods to handle multiple event types with shared logic\" framework: \"NET8\" category: \"Projections\" difficulty: \"ADVANCED\" tags: [\"Projections\", \"Generics\", \"Polymorphism\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"] usingStatements: [\"System\", \"System Collections Generic\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Collections Generic; using System Threading; using System Threading Tasks;\n// Marker interface for all events\npublic interface IEvent {\n    Guid EventId { get; }\n    DateTime Timestamp { get; }\n}\n// Base interface for domain events\npublic interface IDomainEvent : IEvent {\n    string Domain { get; }\n}\n// Example events\npublic abstract record OrderEvent(Guid EventId, DateTime Timestamp, string Domain) : IDomainEvent;\npublic record OrderPlaced(Guid EventId, DateTime Timestamp, Guid OrderId, decimal Total)\n    : OrderEvent(EventId, Timestamp, \"Orders\");\npublic record OrderShipped(Guid EventId, DateTime Timestamp, Guid OrderId, string TrackingNumber)\n    : OrderEvent(EventId, Timestamp, \"Orders\");\n// Generic method with interface constraint\n[WhizbangProjection]\npublic class EventAuditProjection {\n    private readonly List<EventAuditRecord> _auditLog = new();\n    // This ONE generic method handles ALL events implementing IEvent\n    public Task OnEvent<TEvent>([WhizbangSubscribe] TEvent @event, EventContext context, CancellationToken ct)\n        where TEvent : IEvent {\n        // Source generator creates separate registration for each concrete event type:\n        // - OnEvent<OrderPlaced>\n        // - OnEvent<OrderShipped>\n        // - OnEvent<InventoryAdjusted>\n        // - etc _auditLog Add(new EventAuditRecord {\n            EventId = @event EventId,\n            EventType = typeof(TEvent) Name,  // Concrete type name\n            Timestamp = @event Timestamp,\n            UserId = context Security UserId,\n            TenantId = context Security TenantId\n        });\n        return Task CompletedTask;\n    }\n}\n// Generic method with base class constraint\n[WhizbangProjection]\npublic class OrderEventLogProjection {\n    private readonly Dictionary<string, List<string>> _logsByDomain = new();\n    // Handles all OrderEvent-derived types\n    public Task LogOrderEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct)\n        where TEvent : OrderEvent {\n        if ( _logsByDomain ContainsKey(@event Domain)) {\n            _logsByDomain[@event Domain] = new List<string>();\n        }\n        _logsByDomain[@event Domain] Add(\n            $\"{@event Timestamp:O} - {typeof(TEvent) Name} - {@event EventId}\"\n        );\n        return Task",
        "startIndex": 7833,
        "preview": "generic methods to handle multiple event types with shared logic\" framework: \"NET8\" category: \"Projections\" difficulty: \"ADVANCED\" tags: [\"Projections..."
      },
      {
        "id": "old-v1.0.0/projections/projection-subscriptions-chunk-5",
        "text": "private readonly Dictionary<string, List<string>> _logsByDomain = new(); // Handles all OrderEvent-derived types public Task LogOrderEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct) where TEvent : OrderEvent { if ( _logsByDomain ContainsKey(@event Domain)) { _logsByDomain[@event Domain] = new List<string>(); } _logsByDomain[@event Domain] Add( $\"{@event Timestamp:O} - {typeof(TEvent) Name} - {@event EventId}\" ); return Task CompletedTask;\n    }\n}\npublic record EventAuditRecord {\n    public Guid EventId { get; init; }\n    public string EventType { get; init; }\n    public DateTime Timestamp { get; init; }\n    public Guid UserId { get; init; }\n    public Guid TenantId { get; init; }\n}\n`\nHow Generic Methods Work\nSource Generator Discovers Generic Methods: At compile time, finds all generic methods with [WhizbangSubscribe]\nCreates Registrations for Each Concrete Type: For every event type matching the generic constraint:\n   `csharp{\n   title: \"Generic Method Registration Example\"\n   description: \"How source generator creates registrations for generic subscription methods\"\n   framework: \"NET8\"\n   category: \"Projections\"\n   difficulty: \"ADVANCED\"\n   tags: [\"Projections\", \"Source Generation\", \"Generic Methods\"]\n   filename: \"SourceGenerationExample cs\"\n   usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\n   showLineNumbers: true\n   }\n   // You write this ONE generic method:\n   public Task OnEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct)\n       where TEvent : IEvent { }\n   // Source generator creates registrations for ALL event types:\n   services Subscribe<OrderPlaced, EventAuditProjection>(p => p OnEvent);\n   services Subscribe<OrderShipped, EventAuditProjection>(p => p OnEvent);\n   services Subscribe<InventoryAdjusted, EventAuditProjection>(p => p OnEvent);\n   // etc `\nType Safety Maintained: Generic constraints ensure only valid event types are registered\nMultiple Constraints Supported: Use where TEvent : class, IEvent, new() or any valid Cconstraint\nCombining Generic and Specific Methods\nMix generic and specific subscriptions in the same projection:\n`csharp{\ntitle: \"Hybrid Generic and Specific Subscriptions\"\ndescription: \"Combining generic catch-all methods with specific handlers\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Generics\", \"Hybrid Patterns\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading",
        "startIndex": 10041,
        "preview": "private readonly Dictionary<string, List<string>> _logsByDomain = new(); // Handles all OrderEvent-derived types public Task LogOrderEvent<TEvent>([Wh..."
      },
      {
        "id": "old-v1.0.0/projections/projection-subscriptions-chunk-6",
        "text": "Generic and Specific Methods Mix generic and specific subscriptions in the same projection: `csharp{ title: \"Hybrid Generic and Specific Subscriptions\" description: \"Combining generic catch-all methods with specific handlers\" framework: \"NET8\" category: \"Projections\" difficulty: \"ADVANCED\" tags: [\"Projections\", \"Generics\", \"Hybrid Patterns\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"] usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class HybridProjection {\n    // Generic catch-all for all events\n    public Task OnEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct)\n        where TEvent : IEvent {\n        // Log all events generically\n        Console WriteLine($\"Event received: {typeof(TEvent) Name}\");\n        return Task CompletedTask;\n    }\n    // Specific handler for OrderPlaced (takes precedence)\n    public Task OnOrderPlaced([WhizbangSubscribe] OrderPlaced @event, ProjectionContext projection, CancellationToken ct) {\n        // Special handling for OrderPlaced\n        Console WriteLine($\"Special handling for order: {@event OrderId}\");\n        return Task CompletedTask;\n    }\n    // Specific handler for high-priority events\n    public Task OnOrderCancelled([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) {\n        // Alert handling for cancellations\n        Console WriteLine($\"ALERT: Order cancelled - {@event Reason}\");\n        return Task CompletedTask;\n    }\n}\n`\nPrecedence Rules\nWhen multiple methods can handle an event, Whizbang invokes handlers in this order:\nExact type match (e g , OrderPlaced @event)\nBase class match (e g , OrderEvent @event)\nInterface match (e g , IEvent @event)\nGeneric with specific constraint (e g , TEvent where TEvent : OrderEvent)\nGeneric with general constraint (e g , TEvent where TEvent : IEvent)\nAll matching handlers are invoked in precedence order (most specific to least specific) `mermaid\ngraph TD\n    OrderPlaced[\"OrderPlaced Event<br/>(Concrete Type)\"]\n    subgraph Handlers[\"Projection Handlers (Invoked in Order)\"]\n        H1[\"1 OnOrderPlaced<br/>(Exact Match)<br/>⭐ Highest Priority\"]\n        H2[\"2 OnOrderEvent<br/>(Base Class Match)\"]\n        H3[\"3 OnDomainEvent<br/>(Interface Match)\"]\n        H4[\"4 OnEvent&lt;TEvent&gt; where TEvent : OrderEvent<br/>(Generic Specific)\"]\n        H5[\"5 OnEvent&lt;TEvent&gt; where TEvent : IEvent<br/>(Generic General)<br/>⭐ Lowest Priority\"]\n    end\n    OrderPlaced --> H1\n    OrderPlaced - -> H2\n    OrderPlaced - -> H3\n    OrderPlaced - -> H4\n    OrderPlaced -",
        "startIndex": 713,
        "preview": "Generic and Specific Methods Mix generic and specific subscriptions in the same projection: `csharp{ title: \"Hybrid Generic and Specific Subscriptions..."
      },
      {
        "id": "old-v1.0.0/projections/projection-subscriptions-chunk-7",
        "text": "Handlers (Invoked in Order)\"] H1[\"1 OnOrderPlaced<br/>(Exact Match)<br/>⭐ Highest Priority\"] H2[\"2 OnOrderEvent<br/>(Base Class Match)\"] H3[\"3 OnDomainEvent<br/>(Interface Match)\"] H4[\"4 OnEvent&lt;TEvent&gt; where TEvent : OrderEvent<br/>(Generic Specific)\"] H5[\"5 OnEvent&lt;TEvent&gt; where TEvent : IEvent<br/>(Generic General)<br/>⭐ Lowest Priority\"] end OrderPlaced --> H1 OrderPlaced - -> H2 OrderPlaced - -> H3 OrderPlaced - -> H4 OrderPlaced - -> H5\n    style OrderPlaced fill:#fff3cd,stroke:#ffc107,stroke-width:3px\n    style H1 fill:#d4edda,stroke:#28a745,stroke-width:2px\n    style H5 fill:#f8d7da,stroke:#dc3545,stroke-width:2px\n`\nBenefits of Polymorphic Subscriptions\nSingle Entry Point: One method handles all related events\nShared Logic: Common processing for all event types (logging, auditing, etc )\nType Safety: Pattern matching ensures all cases are handled\nFlexibility: Mix polymorphic and specific subscriptions as needed\nClean Code: Reduces boilerplate for related event types\nBenefits of Generic Methods\nDRY Principle: Write once, handle many event types\nShared Logic: Common processing for all events matching constraint\nType Safety: Generic constraints enforce compile-time safety\nAutomatic Registration: Source generator wires up all matching event types\nFlexibility: Combine with non-generic methods for specific overrides\nScalability: New event types automatically get handled without code changes\nValid Subscription Patterns\n`csharp{\ntitle: \"Valid Subscription Patterns\"\ndescription: \"Examples of all valid projection subscription patterns supported by Whizbang\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Subscriptions\", \"Patterns\", \"Examples\"]\nfilename: \"SubscriptionPatterns cs\"\nusingStatements: [\"System\", \"System Threading\", \"System Threading",
        "startIndex": 14332,
        "preview": "Handlers (Invoked in Order)\"] H1[\"1 OnOrderPlaced<br/>(Exact Match)<br/>⭐ Highest Priority\"] H2[\"2 OnOrderEvent<br/>(Base Class Match)\"] H3[\"3 OnDomai..."
      },
      {
        "id": "old-v1.0.0/projections/projection-subscriptions-chunk-8",
        "text": "overrides Scalability: New event types automatically get handled without code changes Valid Subscription Patterns `csharp{ title: \"Valid Subscription Patterns\" description: \"Examples of all valid projection subscription patterns supported by Whizbang\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Projections\", \"Subscriptions\", \"Patterns\", \"Examples\"] filename: \"SubscriptionPatterns cs\" usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\n// ✅ VALID - Specific event type\npublic Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) { }\n// ✅ VALID - Base class subscription\npublic Task OnOrderEvent([WhizbangSubscribe] OrderEvent @event, CancellationToken ct) { }\n// ✅ VALID - Interface subscription\npublic Task HandleInventoryEvent([WhizbangSubscribe] IInventoryEvent @event, CancellationToken ct) { }\n// ✅ VALID - Generic method\npublic Task OnEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct)\n    where TEvent : IEvent { }\n// ✅ VALID - With EventContext\npublic Task OnOrderPlaced([WhizbangSubscribe] OrderPlaced @event, EventContext context, CancellationToken ct) { }\n// ✅ VALID - With ProjectionContext\npublic Task OnOrderShipped([WhizbangSubscribe] OrderShipped @event, ProjectionContext projection, CancellationToken ct) { }\n// ✅ VALID - With both contexts\npublic Task WhenOrderPlaced(\n    [WhizbangSubscribe] OrderPlaced @event,\n    EventContext eventContext,\n    ProjectionContext projection,\n    CancellationToken ct) { }\n// ✅ VALID - With injected services (for querying, not mutation)\npublic Task ProcessOrder([WhizbangSubscribe] OrderPlaced @event, IOrderRepository repo, CancellationToken ct) { }\n// ❌ INVALID - Multiple subscriptions per method (compile error)\npublic Task OnOrderEvents([WhizbangSubscribe] OrderPlaced order, [WhizbangSubscribe] OrderShipped shipped) { }\n`\nAuto-Registration\nWhen you use [WhizbangSubscribe] on a method parameter, the source generator:\nDiscovers the subscription at compile time\nGenerates registration code linking the event type to the projection method\nAutomatically configures the service to route events to this projection\nNo manual registration needed - just mark with [WhizbangSubscribe]\n`mermaid\nsequenceDiagram\n    participant ES as Event Store\n    participant Router as Event Router\n    participant Proj1 as OrderProjection\n    participant Proj2 as AuditProjection\n    participant Store as Projection Store\n    ES->>Router: OrderPlaced event\n    Note over Router: Routes to all<br/>subscribed projections\n    Router->>Proj1: OnOrderPlaced(event, context)\n    Note over Proj1: ✅ Pure transformation<br/>Uses eventContext",
        "startIndex": 15706,
        "preview": "overrides Scalability: New event types automatically get handled without code changes Valid Subscription Patterns `csharp{ title: \"Valid Subscription ..."
      },
      {
        "id": "old-v1.0.0/projections/projection-subscriptions-chunk-9",
        "text": "- just mark with [WhizbangSubscribe] `mermaid sequenceDiagram participant ES as Event Store participant Router as Event Router participant Proj1 as OrderProjection participant Proj2 as AuditProjection participant Store as Projection Store ES->>Router: OrderPlaced event Note over Router: Routes to all<br/>subscribed projections Router->>Proj1: OnOrderPlaced(event, context) Note over Proj1: ✅ Pure transformation<br/>Uses eventContext System Timestamp\n    Proj1->>Store: CreateAsync(OrderSummary)\n    Store-->>Proj1: Success\n    Proj1-->>Router: Accepted\n    Router->>Proj2: OnEvent<OrderPlaced>(event, context)\n    Note over Proj2: Generic handler<br/>Logs all events\n    Proj2->>Store: CreateAsync(AuditRecord)\n    Store-->>Proj2: Success\n    Proj2-->>Router: Accepted\n    Router->>Router: All projections complete\n`\n`csharp{\ntitle: \"Auto-Registration Example\"\ndescription: \"How subscriptions are automatically registered by the source generator\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Auto-Registration\", \"Source Generation\"]\nfilename: \"AutoRegistrationExample cs\"\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\n// This subscription is automatically registered\npublic Task OnOrderPlaced([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) {\n    // Source generator creates registration code like:\n    // services Subscribe<OrderPlaced, OrderSummaryProjection>(\n    //     projection => projection OnOrderPlaced);\n}\n`\nNext Steps\nProjection Contexts - EventContext and ProjectionContext injection\nProjection Purity - Maintaining pure, deterministic projections\nProjection Return Values - Using return values for observability",
        "startIndex": 666,
        "preview": "- just mark with [WhizbangSubscribe] `mermaid sequenceDiagram participant ES as Event Store participant Router as Event Router participant Proj1 as Or..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/test-features",
    "title": "Test New Features",
    "category": "Test",
    "url": "/docs/old-v1.0.0/test-features",
    "chunks": [
      {
        "id": "old-v1.0.0/test-features-chunk-0",
        "text": "Test New Features\nThis page demonstrates the new interactive header and callout functionality.\nInteractive Headers\nEach header should have a link icon that appears on hover and allows copying the link to that section.\nSubsection with Custom ID {#custom-test-id}\nThis header has a custom ID defined in the markdown.\nNew Callout Examples\n:::new\nEnhanced Configuration\nThis is a new feature that provides advanced configuration options.\n:::\n:::updated\nConnection Pooling \nConnection pooling has been enhanced to support better performance.\n:::\n:::new{type=\"breaking\"}\nBreaking Change: API Format\nThe API format has changed in this version and requires migration.\n:::\n:::deprecated\nLegacy Configuration\nThe old configuration method is now deprecated and will be removed in future versions.\n:::\n:::planned{version=\"v1.2.0\" header=\"advanced-features\"}\nFuture Advanced Features\nThese features are planned for v1.2.0 and will provide advanced capabilities.\n:::\nRegular Content\nThis is regular markdown content that should render normally alongside the enhanced features.\nThe interactive headers allow users to:\nCopy direct links to any section\nShare specific parts of documentation\nNavigate more efficiently\nThe callouts provide clear visual indicators for:\nNew functionality\nUpdated features  \nBreaking changes\nDeprecated features\nPlanned future features",
        "startIndex": 0,
        "preview": "Test New Features\nThis page demonstrates the new interactive header and callout functionality.\nInteractive Headers\nEach header should have a link icon..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/usage-patterns/aspect-oriented-handlers",
    "title": "Aspect-Oriented Handlers",
    "category": "Usage Patterns",
    "url": "/docs/old-v1.0.0/usage-patterns/aspect-oriented-handlers",
    "chunks": [
      {
        "id": "old-v1.0.0/usage-patterns/aspect-oriented-handlers-chunk-0",
        "text": "Aspect-Oriented Handlers\nOverview\nAspect-Oriented Programming (AOP) in Whizbang allows you to cleanly separate cross-cutting concerns from your business logic Through source generators and declarative attributes, you can add logging, caching, validation, authorization, and other behaviors without cluttering your handler code Core Concepts\nAspects vs Traditional Approaches\nTraditional approach with manual cross-cutting concerns:\n`csharp\n// ❌ Traditional: Business logic mixed with infrastructure concerns\npublic class OrderHandler {\n    private readonly ILogger _logger;\n    private readonly ICache _cache;\n    private readonly IMetrics _metrics;\n    private readonly IValidator _validator;\n    public async Task<Result> Handle(CreateOrder cmd) {\n        // Validation\n        var validationResult = _validator Validate(cmd);\n        if ( validationResult IsValid) {\n            _logger Warning(\"Validation failed: {Errors}\", validationResult Errors);\n            return Result Failure(validationResult Errors);\n        }\n        // Logging\n        _logger Information(\"Processing order for customer {CustomerId}\", cmd CustomerId);\n        var stopwatch = Stopwatch StartNew();\n        try {\n            // Check cache\n            var cacheKey = $\"order:{cmd CustomerId}\";\n            var cached = await _cache GetAsync<Order>(cacheKey);\n            if (cached = null) {\n                _logger Debug(\"Cache hit for {CacheKey}\", cacheKey);\n                return Result Success(cached);\n            }\n            // FINALLY: Actual business logic (buried in infrastructure)\n            var order = CreateOrder(cmd);\n            // Update cache\n            await _cache SetAsync(cacheKey, order);\n            // Metrics\n            _metrics Increment(\"orders created\");\n            _metrics RecordDuration(\"order processing\", stopwatch Elapsed);\n            _logger Information(\"Order {OrderId} created successfully\", order Id);\n            return Result Success(order);\n        }\n        catch (Exception ex) {\n            _logger Error(ex, \"Failed to create order\");\n            _metrics Increment(\"orders failed\");\n            throw;\n        }\n    }\n}\n`\nWhizbang approach with aspects:\n`csharp\n// ✅ Whizbang: Pure business logic with declarative aspects\n[Validated]\n[Logged]\n[Cached(Duration = \"5m\")]\n[Timed]\n[Metered(\"orders\")]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // ONLY business logic - clean and focused\n        var order = CreateOrder(cmd);\n        return new OrderCreated(order Id, order Total);\n    }\n}\n`\nBuilt-in Aspects\nLogging Aspect\n`csharp{\ntitle: \"Logging Aspect\"\ndescription: \"Automatic structured logging for handlers\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"BEGINNER\"\ntags: [\"Logging\", \"Observability\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"LoggingAspect",
        "startIndex": 0,
        "preview": "Aspect-Oriented Handlers\nOverview\nAspect-Oriented Programming (AOP) in Whizbang allows you to cleanly separate cross-cutting concerns from your busine..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/aspect-oriented-handlers-chunk-1",
        "text": "// ONLY business logic - clean and focused var order = CreateOrder(cmd); return new OrderCreated(order Id, order Total); } } ` Built-in Aspects Logging Aspect `csharp{ title: \"Logging Aspect\" description: \"Automatic structured logging for handlers\" framework: \"NET8\" category: \"Aspects\" difficulty: \"BEGINNER\" tags: [\"Logging\", \"Observability\", \"Aspects\"] nugetPackages: [\"Whizbang Core\"] filename: \"LoggingAspect cs\"\nshowLineNumbers: true\nhighlightLines: [1, 2, 3]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Basic logging\n[Logged]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Automatically logs:\n        // - Handler execution start\n        // - Input parameters (redacted sensitive data)\n        // - Execution duration\n        // - Success/failure status\n        // - Return value summary\n        return new OrderCreated(cmd OrderId);\n    }\n}\n// Detailed logging with custom levels\n[Logged(\n    Level = LogLevel Debug,\n    LogInputs = true,\n    LogOutputs = true,\n    LogDuration = true\n)]\npublic class DetailedHandler : IHandle<ComplexOperation> {\n    public Result Handle(ComplexOperation cmd) {\n        return ProcessComplex(cmd);\n    }\n}\n// Conditional logging\n[Logged(\n    OnlyOnError = true,\n    IncludeStackTrace = true,\n    MaxDepth = 3  // How deep to serialize objects\n)]\npublic class ErrorFocusedHandler : IHandle<RiskyOperation> {\n    public Result Handle(RiskyOperation cmd) {\n        // Only logs when exception occurs\n        return PerformRiskyOperation(cmd);\n    }\n}\n// Custom log enrichment\n[Logged(Enricher = nameof(EnrichLog))]\npublic class EnrichedHandler : IHandle<BusinessOperation> {\n    public Result Handle(BusinessOperation cmd) {\n        return Process(cmd);\n    }\n    private void EnrichLog(LogContext context, BusinessOperation cmd) {\n        context AddProperty(\"TenantId\", cmd TenantId);\n        context AddProperty(\"Region\", GetRegion(cmd));\n        context AddProperty(\"Priority\", cmd Priority);\n    }\n}\n`\nValidation Aspect\n`csharp{\ntitle: \"Validation Aspect\"\ndescription: \"Automatic input validation using FluentValidation or DataAnnotations\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"BEGINNER\"\ntags: [\"Validation\", \"Input Validation\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"ValidationAspect cs\"\nshowLineNumbers: true\nhighlightLines: [1, 14, 27]\nusingStatements: [\"Whizbang\", \"System\", \"System ComponentModel",
        "startIndex": 2880,
        "preview": "// ONLY business logic - clean and focused var order = CreateOrder(cmd); return new OrderCreated(order Id, order Total); } } ` Built-in Aspects Loggin..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/aspect-oriented-handlers-chunk-2",
        "text": "GetRegion(cmd)); context AddProperty(\"Priority\", cmd Priority); } } ` Validation Aspect `csharp{ title: \"Validation Aspect\" description: \"Automatic input validation using FluentValidation or DataAnnotations\" framework: \"NET8\" category: \"Aspects\" difficulty: \"BEGINNER\" tags: [\"Validation\", \"Input Validation\", \"Aspects\"] nugetPackages: [\"Whizbang Core\"] filename: \"ValidationAspect cs\" showLineNumbers: true highlightLines: [1, 14, 27] usingStatements: [\"Whizbang\", \"System\", \"System ComponentModel DataAnnotations\"]\n}\n// Automatic validation with conventions\n[Validated]\npublic class CreateUserHandler : IHandle<CreateUser> {\n    public UserCreated Handle(CreateUser cmd) {\n        // Validation happens before this executes\n        // Looks for CreateUserValidator automatically\n        return new UserCreated(cmd Email);\n    }\n}\n// Explicit validator specification\n[Validated(Validator = typeof(CustomOrderValidator))]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        return new OrderCreated(cmd OrderId);\n    }\n}\n// Inline validation rules\n[Validated(\n    Rules = new[] {\n        \"Amount > 0\",\n        \"Currency = null\",\n        \"CustomerId = Guid Empty\"\n    }\n)]\npublic class PaymentHandler : IHandle<ProcessPayment> {\n    public PaymentProcessed Handle(ProcessPayment cmd) {\n        return new PaymentProcessed(cmd Amount);\n    }\n}\n// Combining with FluentValidation\npublic class CreateOrderValidator : AbstractValidator<CreateOrder> {\n    public CreateOrderValidator() {\n        RuleFor(x => x CustomerId) NotEmpty();\n        RuleFor(x => x Items) NotEmpty() Must(items => items All(i => i Quantity > 0));\n        RuleFor(x => x ShippingAddress) NotEmpty() MaximumLength(500);\n    }\n}\n[Validated] // Automatically uses CreateOrderValidator\npublic class ValidatedOrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nCaching Aspect\n`csharp{\ntitle: \"Caching Aspect\"\ndescription: \"Automatic result caching with flexible cache keys\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Caching\", \"Performance\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"CachingAspect cs\"\nshowLineNumbers: true\nhighlightLines: [1, 12, 24, 36]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Simple caching with duration\n[Cached(Duration = \"5m\")]\npublic class ProductHandler : IHandle<GetProduct> {\n    public Product Handle(GetProduct query) {\n        // Result cached for 5 minutes\n        // Cache key auto-generated from query properties\n        return database GetProduct(query",
        "startIndex": 4907,
        "preview": "GetRegion(cmd)); context AddProperty(\"Priority\", cmd Priority); } } ` Validation Aspect `csharp{ title: \"Validation Aspect\" description: \"Automatic in..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/aspect-oriented-handlers-chunk-3",
        "text": "Core\"] filename: \"CachingAspect cs\" showLineNumbers: true highlightLines: [1, 12, 24, 36] usingStatements: [\"Whizbang\", \"System\"] } // Simple caching with duration [Cached(Duration = \"5m\")] public class ProductHandler : IHandle<GetProduct> { public Product Handle(GetProduct query) { // Result cached for 5 minutes // Cache key auto-generated from query properties return database GetProduct(query ProductId);\n    }\n}\n// Custom cache key generation\n[Cached(\n    Duration = \"10m\",\n    KeyGenerator = nameof(GenerateCacheKey)\n)]\npublic class CustomKeyHandler : IHandle<ComplexQuery> {\n    public QueryResult Handle(ComplexQuery query) {\n        return ExecuteComplexQuery(query);\n    }\n    private string GenerateCacheKey(ComplexQuery query) {\n        return $\"complex:{query TenantId}:{query FilterHash}\";\n    }\n}\n// Sliding expiration cache\n[Cached(\n    Duration = \"1h\",\n    Mode = \"sliding\",  // Resets on each access\n    CacheNullResults = false\n)]\npublic class SlidingCacheHandler : IHandle<GetUserPreferences> {\n    public UserPreferences Handle(GetUserPreferences query) {\n        return userService GetPreferences(query UserId);\n    }\n}\n// Conditional caching\n[Cached(\n    Duration = \"30m\",\n    Condition = nameof(ShouldCache),\n    InvalidateOn = new[] { typeof(UserUpdated), typeof(UserDeleted) }\n)]\npublic class ConditionalCacheHandler : IHandle<GetUserProfile> {\n    public UserProfile Handle(GetUserProfile query) {\n        return userService GetProfile(query UserId);\n    }\n    private bool ShouldCache(GetUserProfile query) {\n        // Only cache for non-admin users\n        return query IsAdmin;\n    }\n}\n// Distributed cache\n[Cached(\n    Duration = \"1h\",\n    CacheType = \"distributed\",  // Redis, Memcached, etc SerializationFormat = \"msgpack\"\n)]\npublic class DistributedCacheHandler : IHandle<GetOrderHistory> {\n    public OrderHistory Handle(GetOrderHistory query) {\n        return orderService GetHistory(query CustomerId);\n    }\n}\n`\nAuthorization Aspect\n`csharp{\ntitle: \"Authorization Aspect\"\ndescription: \"Declarative security with fine-grained access control\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Authorization\", \"Security\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"AuthorizationAspect",
        "startIndex": 7083,
        "preview": "Core\"] filename: \"CachingAspect cs\" showLineNumbers: true highlightLines: [1, 12, 24, 36] usingStatements: [\"Whizbang\", \"System\"] } // Simple caching ..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/aspect-oriented-handlers-chunk-4",
        "text": "SerializationFormat = \"msgpack\" )] public class DistributedCacheHandler : IHandle<GetOrderHistory> { public OrderHistory Handle(GetOrderHistory query) { return orderService GetHistory(query CustomerId); } } ` Authorization Aspect `csharp{ title: \"Authorization Aspect\" description: \"Declarative security with fine-grained access control\" framework: \"NET8\" category: \"Aspects\" difficulty: \"INTERMEDIATE\" tags: [\"Authorization\", \"Security\", \"Aspects\"] nugetPackages: [\"Whizbang Core\"] filename: \"AuthorizationAspect cs\"\nshowLineNumbers: true\nhighlightLines: [1, 10, 19, 30]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Role-based authorization\n[Authorized(Roles = \"Admin,Manager\")]\npublic class AdminHandler : IHandle<AdminCommand> {\n    public Result Handle(AdminCommand cmd) {\n        // Only admins and managers can execute\n        return PerformAdminAction(cmd);\n    }\n}\n// Policy-based authorization\n[Authorized(Policy = \"CanEditOrders\")]\npublic class OrderEditHandler : IHandle<EditOrder> {\n    public OrderUpdated Handle(EditOrder cmd) {\n        // Policy evaluated before execution\n        return UpdateOrder(cmd);\n    }\n}\n// Resource-based authorization\n[Authorized(Resource = nameof(GetOrderResource))]\npublic class OrderAccessHandler : IHandle<GetOrder> {\n    public Order Handle(GetOrder query) {\n        return orderService Get(query OrderId);\n    }\n    private object GetOrderResource(GetOrder query) {\n        return new { Type = \"Order\", Id = query OrderId };\n    }\n}\n// Custom authorization logic\n[Authorized(Authorizer = typeof(CustomOrderAuthorizer))]\npublic class CustomAuthHandler : IHandle<SensitiveOperation> {\n    public Result Handle(SensitiveOperation cmd) {\n        return ExecuteSensitive(cmd);\n    }\n}\npublic class CustomOrderAuthorizer : IAuthorizer<SensitiveOperation> {\n    public Task<bool> AuthorizeAsync(SensitiveOperation cmd, IUser user) {\n        // Custom authorization logic\n        if (user IsInRole(\"Admin\")) return Task FromResult(true);\n        if (cmd OwnerId == user Id) return Task FromResult(true);\n        if (user HasPermission(\"sensitive execute\")) return Task FromResult(true);\n        return Task FromResult(false);\n    }\n}\n`\nTransactional Aspect\n`csharp{\ntitle: \"Transactional Aspect\"\ndescription: \"Automatic transaction management with various isolation levels\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Transactions\", \"Database\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"TransactionalAspect cs\"\nshowLineNumbers: true\nhighlightLines: [1, 11, 22, 35]\nusingStatements: [\"Whizbang\", \"System\", \"System Data\"]\n}\n// Simple transaction\n[Transactional]\npublic class TransferHandler : IHandle<TransferMoney> {\n    public TransferCompleted Handle(TransferMoney cmd, IAccountService accounts) {\n        // Entire operation wrapped in transaction\n        accounts Debit(cmd FromAccount, cmd Amount);\n        accounts Credit(cmd ToAccount, cmd",
        "startIndex": 8947,
        "preview": "SerializationFormat = \"msgpack\" )] public class DistributedCacheHandler : IHandle<GetOrderHistory> { public OrderHistory Handle(GetOrderHistory query)..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/aspect-oriented-handlers-chunk-5",
        "text": "[\"Whizbang Core\"] filename: \"TransactionalAspect cs\" showLineNumbers: true highlightLines: [1, 11, 22, 35] usingStatements: [\"Whizbang\", \"System\", \"System Data\"] } // Simple transaction [Transactional] public class TransferHandler : IHandle<TransferMoney> { public TransferCompleted Handle(TransferMoney cmd, IAccountService accounts) { // Entire operation wrapped in transaction accounts Debit(cmd FromAccount, cmd Amount); accounts Credit(cmd ToAccount, cmd Amount);\n        return new TransferCompleted(cmd TransferId);\n    }\n}\n// Transaction with specific isolation level\n[Transactional(\n    IsolationLevel = IsolationLevel ReadCommitted,\n    Timeout = \"30s\"\n)]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Executes with ReadCommitted isolation\n        return CreateOrderWithInventory(cmd);\n    }\n}\n// Nested transaction support\n[Transactional(AllowNested = true)]\npublic class ParentHandler : IHandle<ParentCommand> {\n    public Result Handle(ParentCommand cmd, IWhizbang whizbang) {\n        // Start transaction\n        var result1 = ProcessFirst(cmd);\n        // This creates a nested transaction\n        var result2 = whizbang Send(new ChildCommand());\n        return CombineResults(result1, result2);\n    }\n}\n// Distributed transaction\n[Transactional(\n    Mode = \"distributed\",\n    Coordinator = \"saga\"\n)]\npublic class DistributedHandler : IHandle<CrossServiceCommand> {\n    public async Task<Result> Handle(CrossServiceCommand cmd) {\n        // Coordinates transaction across services\n        await orderService CreateOrder(cmd Order);\n        await inventoryService ReserveStock(cmd Items);\n        await paymentService ProcessPayment(cmd Payment);\n        return Result Success();\n    }\n}\n`\nPerformance Aspects\n`csharp{\ntitle: \"Performance Aspects\"\ndescription: \"Timing, metrics, and performance monitoring\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Performance\", \"Metrics\", \"Monitoring\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"PerformanceAspects",
        "startIndex": 11362,
        "preview": "[\"Whizbang Core\"] filename: \"TransactionalAspect cs\" showLineNumbers: true highlightLines: [1, 11, 22, 35] usingStatements: [\"Whizbang\", \"System\", \"Sy..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/aspect-oriented-handlers-chunk-6",
        "text": "// Coordinates transaction across services await orderService CreateOrder(cmd Order); await inventoryService ReserveStock(cmd Items); await paymentService ProcessPayment(cmd Payment); return Result Success(); } } ` Performance Aspects `csharp{ title: \"Performance Aspects\" description: \"Timing, metrics, and performance monitoring\" framework: \"NET8\" category: \"Aspects\" difficulty: \"INTERMEDIATE\" tags: [\"Performance\", \"Metrics\", \"Monitoring\"] nugetPackages: [\"Whizbang Core\"] filename: \"PerformanceAspects cs\"\nshowLineNumbers: true\nhighlightLines: [1, 2, 3]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Comprehensive performance monitoring\n[Timed]\n[Metered(\"orders\")]\n[Traced]\npublic class MonitoredHandler : IHandle<ProcessOrder> {\n    public OrderProcessed Handle(ProcessOrder cmd) {\n        // Automatically tracks:\n        // - Execution duration (Timed)\n        // - Success/failure counts (Metered)\n        // - Distributed trace span (Traced)\n        return ProcessOrder(cmd);\n    }\n}\n// Detailed timing with percentiles\n[Timed(\n    RecordPercentiles = new[] { 50, 90, 95, 99 },\n    PublishHistogram = true,\n    BucketSize = \"100ms\"\n)]\npublic class DetailedTimingHandler : IHandle<ComplexCalculation> {\n    public CalculationResult Handle(ComplexCalculation cmd) {\n        return PerformCalculation(cmd);\n    }\n}\n// Custom metrics\n[Metered(\n    Namespace = \"business orders\",\n    RecordErrors = true,\n    RecordDuration = true,\n    Tags = new[] { \"region\", \"customer_type\" }\n)]\npublic class MeteredHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Publishes metrics:\n        // - business orders count\n        // - business orders errors\n        // - business orders duration\n        // Tagged with region and customer_type\n        return CreateOrder(cmd);\n    }\n}\n`\nCustom Aspects\nCreating Custom Aspects\n`csharp{\ntitle: \"Custom Aspect Implementation\"\ndescription: \"Build your own aspects for specific concerns\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"ADVANCED\"\ntags: [\"Custom Aspects\", \"Extensibility\", \"Source Generators\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"CustomAspects cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Define custom aspect attribute\n[AttributeUsage(AttributeTargets Class | AttributeTargets",
        "startIndex": 12964,
        "preview": "// Coordinates transaction across services await orderService CreateOrder(cmd Order); await inventoryService ReserveStock(cmd Items); await paymentSer..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/aspect-oriented-handlers-chunk-7",
        "text": "Aspects Creating Custom Aspects `csharp{ title: \"Custom Aspect Implementation\" description: \"Build your own aspects for specific concerns\" framework: \"NET8\" category: \"Aspects\" difficulty: \"ADVANCED\" tags: [\"Custom Aspects\", \"Extensibility\", \"Source Generators\"] nugetPackages: [\"Whizbang Core\"] filename: \"CustomAspects cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"System\"] } // Define custom aspect attribute [AttributeUsage(AttributeTargets Class | AttributeTargets Method)]\npublic class AuditedAttribute : AspectAttribute {\n    public bool IncludeResult { get; set; } = false;\n    public string AuditTable { get; set; } = \"AuditLog\";\n}\n// Source generator creates this implementation\n[SourceGenerated]\ninternal class AuditedAspect : IAspect {\n    private readonly IAuditService _auditService;\n    public async Task<T> InterceptAsync<T>(\n        AspectContext context,\n        Func<Task<T>> next) {\n        // Before execution\n        var auditEntry = new AuditEntry {\n            UserId = context User Id,\n            Operation = context HandlerName,\n            Input = SerializeInput(context Message),\n            Timestamp = DateTime UtcNow\n        };\n        try {\n            // Execute handler\n            var result = await next();\n            // After execution\n            auditEntry Success = true;\n            if (context Attribute IncludeResult) {\n                auditEntry Output = SerializeOutput(result);\n            }\n            return result;\n        }\n        catch (Exception ex) {\n            auditEntry Success = false;\n            auditEntry Error = ex Message;\n            throw;\n        }\n        finally {\n            // Always audit\n            await _auditService LogAsync(\n                context Attribute AuditTable, \n                auditEntry\n            );\n        }\n    }\n}\n// Use custom aspect\n[Audited(IncludeResult = true, AuditTable = \"OrderAudits\")]\npublic class AuditedOrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nAspect Composition\n`csharp{\ntitle: \"Composing Multiple Aspects\"\ndescription: \"Combining aspects for comprehensive behavior\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"ADVANCED\"\ntags: [\"Aspect Composition\", \"Ordering\", \"Dependencies\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"AspectComposition cs\"\nshowLineNumbers: true\nhighlightLines: [1, 2, 3, 4, 5, 6]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Aspects execute in order of declaration\n[Logged]                    // 1 Outermost - logs everything\n[Timed]                     // 2 Times the entire operation\n[Authorized]                // 3 Check authorization\n[Validated]                 // 4 Validate inputs\n[Transactional]            // 5",
        "startIndex": 14764,
        "preview": "Aspects Creating Custom Aspects `csharp{ title: \"Custom Aspect Implementation\" description: \"Build your own aspects for specific concerns\" framework: ..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/aspect-oriented-handlers-chunk-8",
        "text": "filename: \"AspectComposition cs\" showLineNumbers: true highlightLines: [1, 2, 3, 4, 5, 6] usingStatements: [\"Whizbang\", \"System\"] } // Aspects execute in order of declaration [Logged] // 1 Outermost - logs everything [Timed] // 2 Times the entire operation [Authorized] // 3 Check authorization [Validated] // 4 Validate inputs [Transactional] // 5 Start transaction\n[Cached(Duration = \"10m\")]  // 6 Innermost - check cache first\npublic class FullyAspectedHandler : IHandle<ComplexQuery> {\n    public QueryResult Handle(ComplexQuery query) {\n        // Execution flow:\n        // → Logging starts\n        //   → Timer starts\n        //     → Authorization check\n        //       → Input validation\n        //         → Transaction begins\n        //           → Cache check (hit = early return)\n        //             → Handler executes\n        //           ← Cache stores result\n        //         ← Transaction commits\n        //       ← Validation complete\n        //     ← Authorization complete\n        //   ← Timer stops\n        // ← Logging ends\n        return ExecuteComplexQuery(query);\n    }\n}\n// Conditional aspect composition\n[ConditionalAspect(typeof(CachedAttribute), Condition = nameof(IsReadOperation))]\n[ConditionalAspect(typeof(TransactionalAttribute), Condition = nameof(IsWriteOperation))]\npublic class AdaptiveHandler : IHandle<DynamicCommand> {\n    public Result Handle(DynamicCommand cmd) {\n        return ProcessDynamic(cmd);\n    }\n    private bool IsReadOperation(DynamicCommand cmd) => cmd IsQuery;\n    private bool IsWriteOperation(DynamicCommand cmd) => cmd IsQuery;\n}\n// Aspect dependencies\n[RequiresAspect(typeof(LoggedAttribute))]  // Must have Logged\npublic class DependentAuditAttribute : AspectAttribute { }\n[Logged]\n[DependentAudit]  // OK - Logged is present\npublic class ValidHandler : IHandle<Command> { }\n// [DependentAudit]  // Compile error - Missing required Logged aspect\npublic class InvalidHandler : IHandle<Command> { }\n`\nTesting with Aspects\n`csharp{\ntitle: \"Testing Aspect Behavior\"\ndescription: \"Verify aspects work correctly in isolation and composition\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Testing\", \"Aspects\", \"Unit Tests\"]\nnugetPackages: [\"Whizbang Core\", \"xUnit\"]\nfilename: \"AspectTests cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang Testing\", \"Xunit\"]\n}\n[Fact]\npublic async Task CacheAspect_CachesResult() {\n    // Arrange\n    var test = await Whizbang Test<ProductHandler>() WithAspect<CachedAttribute>() Given(new GetProduct { ProductId = \"123\" });\n    // Act - First call\n    var result1 = await test",
        "startIndex": 17064,
        "preview": "filename: \"AspectComposition cs\" showLineNumbers: true highlightLines: [1, 2, 3, 4, 5, 6] usingStatements: [\"Whizbang\", \"System\"] } // Aspects execute..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/aspect-oriented-handlers-chunk-9",
        "text": "[\"Testing\", \"Aspects\", \"Unit Tests\"] nugetPackages: [\"Whizbang Core\", \"xUnit\"] filename: \"AspectTests cs\" showLineNumbers: true usingStatements: [\"Whizbang Testing\", \"Xunit\"] } [Fact] public async Task CacheAspect_CachesResult() { // Arrange var test = await Whizbang Test<ProductHandler>() WithAspect<CachedAttribute>() Given(new GetProduct { ProductId = \"123\" }); // Act - First call var result1 = await test WhenHandled();\n    // Act - Second call\n    var result2 = await test WhenHandled();\n    // Assert\n    Assert Same(result1, result2);  // Same instance\n    test Aspect<CachedAttribute>() Should() HaveHitCache() OnSecondCall();\n    test Handler Should() HaveBeenCalledOnce();  // Not twice\n}\n[Fact]\npublic async Task ValidationAspect_RejectsInvalidInput() {\n    // Arrange\n    var test = await Whizbang Test<CreateUserHandler>() WithAspect<ValidatedAttribute>() Given(new CreateUser { Email = \"invalid\" });\n    // Act & Assert\n    await test WhenHandled() Should() FailValidation() WithError(\"Email\", \"Invalid email format\");\n    test Handler Should() NotHaveBeenCalled();\n}\n[Fact]\npublic async Task TransactionalAspect_RollsBackOnError() {\n    // Arrange\n    var test = await Whizbang Test<TransferHandler>() WithAspect<TransactionalAttribute>() WithDatabase(db) Given(new TransferMoney { Amount = 100 });\n    // Act - Force error\n    test Handler ThrowsOn(2);  // Throw on second operation\n    // Assert\n    await test WhenHandled() Should() Throw<Exception>();\n    test Database Should() HaveNoChanges();  // Rolled back\n    test Aspect<TransactionalAttribute>() Should() HaveRolledBack();\n}\n// Test aspect ordering\n[Fact]\npublic async Task Aspects_ExecuteInCorrectOrder() {\n    // Arrange\n    var test = await Whizbang Test<FullyAspectedHandler>() WithAllAspects() RecordExecutionOrder();\n    // Act\n    await test WhenHandled(new ComplexQuery());\n    // Assert\n    test ExecutionOrder Should() BeInOrder(\n        \"LoggedAspect Before\",\n        \"TimedAspect Before\",\n        \"AuthorizedAspect Before\",\n        \"ValidatedAspect Before\",\n        \"TransactionalAspect Before\",\n        \"CachedAspect Before\",\n        \"Handler Execute\",\n        \"CachedAspect After\",\n        \"TransactionalAspect After\",\n        \"ValidatedAspect After\",\n        \"AuthorizedAspect After\",\n        \"TimedAspect After\",\n        \"LoggedAspect After\"\n    );\n}\n`\nPerformance Considerations\nSource Generation\n`csharp{\ntitle: \"Zero-Overhead Aspects via Source Generation\"\ndescription: \"How source generators eliminate aspect overhead\"\nframework: \"NET8\"\ncategory: \"Performance\"\ndifficulty: \"ADVANCED\"\ntags: [\"Source Generators\", \"Performance\", \"Compilation\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"SourceGeneration",
        "startIndex": 19337,
        "preview": "[\"Testing\", \"Aspects\", \"Unit Tests\"] nugetPackages: [\"Whizbang Core\", \"xUnit\"] filename: \"AspectTests cs\" showLineNumbers: true usingStatements: [\"Whi..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/aspect-oriented-handlers-chunk-10",
        "text": "Execute\", \"CachedAspect After\", \"TransactionalAspect After\", \"ValidatedAspect After\", \"AuthorizedAspect After\", \"TimedAspect After\", \"LoggedAspect After\" ); } ` Performance Considerations Source Generation `csharp{ title: \"Zero-Overhead Aspects via Source Generation\" description: \"How source generators eliminate aspect overhead\" framework: \"NET8\" category: \"Performance\" difficulty: \"ADVANCED\" tags: [\"Source Generators\", \"Performance\", \"Compilation\"] nugetPackages: [\"Whizbang Core\"] filename: \"SourceGeneration cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// What you write\n[Logged]\n[Cached(Duration = \"5m\")]\npublic class UserHandler : IHandle<GetUser> {\n    public User Handle(GetUser query) {\n        return database GetUser(query UserId);\n    }\n}\n// What source generator produces\n[SourceGenerated]\ninternal class UserHandler_Generated : IHandle<GetUser> {\n    private readonly UserHandler _inner;\n    private readonly ILogger _logger;\n    private readonly ICache _cache;\n    public User Handle(GetUser query) {\n        // Inlined logging\n        _logger LogInformation(\"Executing UserHandler with {UserId}\", query UserId);\n        var stopwatch = Stopwatch StartNew();\n        try {\n            // Inlined caching\n            var cacheKey = $\"user:{query UserId}\";\n            if (_cache TryGet<User>(cacheKey, out var cached)) {\n                _logger LogDebug(\"Cache hit for {Key}\", cacheKey);\n                return cached;\n            }\n            // Call actual handler\n            var result = _inner Handle(query);\n            // Store in cache\n            _cache Set(cacheKey, result, TimeSpan FromMinutes(5));\n            _logger LogInformation(\"UserHandler completed in {Duration}ms\", \n                stopwatch ElapsedMilliseconds);\n            return result;\n        }\n        catch (Exception ex) {\n            _logger LogError(ex, \"UserHandler failed\");\n            throw;\n        }\n    }\n}\n`\nBest Practices\nDo's\n✅ Use aspects for cross-cutting concerns\n`csharp{\ntitle: \"Use Aspects for Cross-Cutting Concerns\"\ndescription: \"Apply aspects for infrastructure concerns like logging, validation, and caching\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Usage Patterns\", \"AOP\", \"Cross-Cutting\", \"Best Practices\"]\nfilename: \"AspectUsage cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[Logged]\n[Validated]\n[Cached]\n`\n✅ Keep handlers focused on business logic\n`csharp{\ntitle: \"Keep Handlers Focused on Business Logic\"\ndescription: \"Handlers should contain only business logic with aspects handling infrastructure\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Usage Patterns\", \"AOP\", \"Clean Code\", \"Best Practices\"]\nfilename: \"FocusedHandler",
        "startIndex": 21745,
        "preview": "Execute\", \"CachedAspect After\", \"TransactionalAspect After\", \"ValidatedAspect After\", \"AuthorizedAspect After\", \"TimedAspect After\", \"LoggedAspect Aft..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/aspect-oriented-handlers-chunk-11",
        "text": "[\"Whizbang\", \"System\"] } [Logged] [Validated] [Cached] ` ✅ Keep handlers focused on business logic `csharp{ title: \"Keep Handlers Focused on Business Logic\" description: \"Handlers should contain only business logic with aspects handling infrastructure\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"BEGINNER\" tags: [\"Usage Patterns\", \"AOP\", \"Clean Code\", \"Best Practices\"] filename: \"FocusedHandler cs\"\nshowLineNumbers: true\nusingStatements: [\"System\"]\n}\npublic OrderCreated Handle(CreateOrder cmd) {\n    // Only business logic, no infrastructure\n    return CreateOrder(cmd);\n}\n`\n✅ Order aspects correctly\n`csharp{\ntitle: \"Order Aspects Correctly\"\ndescription: \"Proper ordering of aspects for logical execution flow\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"AOP\", \"Aspect Ordering\", \"Best Practices\"]\nfilename: \"AspectOrdering cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[Logged]        // Outermost - see everything\n[Authorized]    // Check auth before validation\n[Validated]     // Validate before execution\n[Transactional] // Wrap actual work\n`\n✅ Test aspects in isolation\n`csharp{\ntitle: \"Test Aspects in Isolation\"\ndescription: \"Test aspect behavior separately from business logic\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"AOP\", \"Testing\", \"Best Practices\"]\nfilename: \"AspectTesting cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang Testing\", \"System Threading Tasks\"]\n}\nawait Test<Handler>() WithAspect<CachedAttribute>() VerifyBehavior();\n`\nDon'ts\n❌ Don't mix aspects with manual concerns\n`csharp{\ntitle: \"Don't Mix Aspects with Manual Concerns\"\ndescription: \"Avoid redundant manual logging when using logging aspects\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Usage Patterns\", \"AOP\", \"Anti-Patterns\", \"Best Practices\"]\nfilename: \"AspectAntiPatterns cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[Logged]\npublic Result Handle(Command cmd) {\n    _logger Log(\"Starting\");  // Don't - redundant with aspect\n}\n`\n❌ Don't create aspects for business logic\n`csharp{\ntitle: \"Don't Create Aspects for Business Logic\"\ndescription: \"Aspects should be for cross-cutting concerns, not business logic\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Usage Patterns\", \"AOP\", \"Anti-Patterns\", \"Business Logic\"]\nfilename: \"BusinessLogicAspect",
        "startIndex": 23995,
        "preview": "[\"Whizbang\", \"System\"] } [Logged] [Validated] [Cached] ` ✅ Keep handlers focused on business logic `csharp{ title: \"Keep Handlers Focused on Business ..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/aspect-oriented-handlers-chunk-12",
        "text": "Log(\"Starting\"); // Don't - redundant with aspect } ` ❌ Don't create aspects for business logic `csharp{ title: \"Don't Create Aspects for Business Logic\" description: \"Aspects should be for cross-cutting concerns, not business logic\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"BEGINNER\" tags: [\"Usage Patterns\", \"AOP\", \"Anti-Patterns\", \"Business Logic\"] filename: \"BusinessLogicAspect cs\"\nshowLineNumbers: true\nusingStatements: [\"System\"]\n}\n[CalculateTax]  // Bad - business logic not cross-cutting\n`\n❌ Don't ignore aspect overhead in hot paths\n`csharp{\ntitle: \"Consider Aspect Overhead\"\ndescription: \"Be careful with verbose aspects in performance-critical paths\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"AOP\", \"Performance\", \"Best Practices\"]\nfilename: \"AspectPerformance cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[Logged(LogInputs = true)]  // Careful with large objects\npublic Result Handle(LargeDataQuery query)\n`\nReal-World Example\n`csharp{\ntitle: \"Complete E-Commerce Handler with Aspects\"\ndescription: \"Production-ready handler showcasing multiple aspects\"\nframework: \"NET8\"\ncategory: \"Real World\"\ndifficulty: \"ADVANCED\"\ntags: [\"E-Commerce\", \"Production\", \"Complete Example\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"ECommerceHandler cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Order processing with comprehensive aspects\n[Logged(Level = LogLevel Information)]\n[Timed(PublishHistogram = true)]\n[Metered(\"orders checkout\")]\n[Authorized(Policy = \"CanCreateOrders\")]\n[Validated]\n[RateLimited(Permits = 100, Window = \"1m\")]\n[Transactional(IsolationLevel = IsolationLevel ReadCommitted)]\n[Retry(3, Backoff = \"exponential\")]\n[CircuitBreaker(Threshold = 10, Duration = \"30s\")]\n[Traced(IncludeHeaders = true)]\npublic class CheckoutHandler : IHandle<Checkout> {\n    public CheckoutCompleted Handle(Checkout cmd, \n        IInventoryService inventory,\n        IPaymentService payment,\n        IShippingService shipping) {\n        // Pure business logic - all concerns handled by aspects\n        // Reserve inventory\n        var reservation = inventory Reserve(cmd Items);\n        // Process payment\n        var transaction = payment Charge(\n            cmd PaymentMethod, \n            cmd Total\n        );\n        // Create shipment\n        var shipment = shipping CreateShipment(\n            cmd ShippingAddress,\n            cmd Items\n        );\n        // Return completed checkout\n        return new CheckoutCompleted {\n            OrderId = Guid NewGuid(),\n            ReservationId = reservation Id,\n            TransactionId = transaction Id,\n            ShipmentId = shipment Id,\n            EstimatedDelivery = shipment",
        "startIndex": 26065,
        "preview": "Log(\"Starting\"); // Don't - redundant with aspect } ` ❌ Don't create aspects for business logic `csharp{ title: \"Don't Create Aspects for Business Log..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/aspect-oriented-handlers-chunk-13",
        "text": "var transaction = payment Charge( cmd PaymentMethod, cmd Total ); // Create shipment var shipment = shipping CreateShipment( cmd ShippingAddress, cmd Items ); // Return completed checkout return new CheckoutCompleted { OrderId = Guid NewGuid(), ReservationId = reservation Id, TransactionId = transaction Id, ShipmentId = shipment Id, EstimatedDelivery = shipment EstimatedDelivery\n        };\n    }\n}\n// Query handler with read-optimized aspects\n[Logged(OnlyOnError = true)]\n[Cached(Duration = \"15m\", Mode = \"sliding\")]\n[Compressed]\n[Traced]\npublic class OrderHistoryHandler : IHandle<GetOrderHistory> {\n    public OrderHistory Handle(GetOrderHistory query) {\n        // Cached and compressed for performance\n        return orderService GetHistory(\n            query CustomerId,\n            query StartDate,\n            query EndDate\n        );\n    }\n}\n`\nNext Steps\nExplore Progressive Enhancement for scaling patterns\nLearn about Policy Composition for resilience\nReview Testing Strategies for aspect testing\nSee Source Generators for implementation details",
        "startIndex": 28418,
        "preview": "var transaction = payment Charge( cmd PaymentMethod, cmd Total ); // Create shipment var shipment = shipping CreateShipment( cmd ShippingAddress, cmd ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/usage-patterns/cqrs-implementation",
    "title": "CQRS Implementation",
    "category": "Usage Patterns",
    "url": "/docs/old-v1.0.0/usage-patterns/cqrs-implementation",
    "chunks": [
      {
        "id": "old-v1.0.0/usage-patterns/cqrs-implementation-chunk-0",
        "text": "CQRS Implementation\nOverview\nCommand Query Responsibility Segregation (CQRS) is a pattern that uses separate models for reading and writing data Whizbang provides first-class support for CQRS, allowing you to optimize reads and writes independently while maintaining consistency through event-driven projections What is CQRS CQRS separates your application into two distinct paths:\nCommand Side: Handles writes, enforces business rules, generates events\nQuery Side: Handles reads from optimized, denormalized read models\nBenefits of CQRS\nPerformance: Optimize reads and writes independently\nScalability: Scale read and write sides separately\nFlexibility: Different storage technologies for different needs\nSimplicity: Simpler models focused on specific tasks\nEvolution: Change read models without affecting writes\nArchitecture Diagram\n`mermaid\ngraph TB\n    subgraph \"Write Side\"\n        CMD[Commands] --> CH[Command Handlers]\n        CH --> AGG[Aggregates]\n        AGG --> ES[(Event Store)]\n    end\n    subgraph \"Read Side\"\n        ES --> PROJ[Projections]\n        PROJ --> RM1[(Order List)]\n        PROJ --> RM2[(Customer View)]\n        PROJ --> RM3[(Analytics)]\n        Q[Queries] --> QH[Query Handlers]\n        QH --> RM1\n        QH --> RM2\n        QH --> RM3\n    end\n    style ES fill:#0066cc,color:#fff\n    style PROJ fill:#28a745,color:#fff\n`\nCore Components\nRequired Packages\n`xml{\ntitle: \"Required NuGet Packages\"\ndescription: \"Core packages needed for CQRS implementation with Whizbang\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Usage Patterns\", \"CQRS\", \"NuGet Packages\"]\nfilename: \"ProjectFile csproj\"\nshowLineNumbers: true\n}\n<PackageReference Include=\"Whizbang Core\" Version=\"1 0 0\" />\n<PackageReference Include=\"Whizbang EventSourcing\" Version=\"1 0 0\" />\n<PackageReference Include=\"Whizbang Projections\" Version=\"1 0 0\" />\n`\nKey Concepts\nWrite Model: Aggregates that enforce business rules\nRead Model: Denormalized views optimized for queries\nProjection: Process that builds read models from events\nEventually Consistent: Read models update asynchronously\nQuery Handler: Returns data from read models\nStep-by-Step Implementation\nStep 1: Define Read Models\n`csharp{\ntitle: \"Read Model Definitions\"\ndescription: \"Create denormalized read models optimized for specific queries\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Read Models\", \"Projections\", \"Query Models\"]\nnugetPackages: [\"Whizbang Projections\"]\nfilename: \"OrderReadModels",
        "startIndex": 0,
        "preview": "CQRS Implementation\nOverview\nCommand Query Responsibility Segregation (CQRS) is a pattern that uses separate models for reading and writing data Whizb..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/cqrs-implementation-chunk-1",
        "text": "Consistent: Read models update asynchronously Query Handler: Returns data from read models Step-by-Step Implementation Step 1: Define Read Models `csharp{ title: \"Read Model Definitions\" description: \"Create denormalized read models optimized for specific queries\" framework: \"NET8\" category: \"CQRS\" difficulty: \"INTERMEDIATE\" tags: [\"Read Models\", \"Projections\", \"Query Models\"] nugetPackages: [\"Whizbang Projections\"] filename: \"OrderReadModels cs\"\nshowLineNumbers: true\nhighlightLines: [9, 25, 41]\nusingStatements: [\"Whizbang Projections\", \"System\", \"System Collections Generic\"]\n}\nusing Whizbang Projections;\nusing System;\nusing System Collections Generic;\nnamespace MyApp Orders ReadModels;\n// Read model for order list/search\n[ReadModel(\"OrderList\")]\npublic class OrderListItem {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    public string CustomerName { get; set; }\n    public decimal TotalAmount { get; set; }\n    public string Status { get; set; }\n    public DateTime CreatedAt { get; set; }\n    public DateTime",
        "startIndex": 2506,
        "preview": "Consistent: Read models update asynchronously Query Handler: Returns data from read models Step-by-Step Implementation Step 1: Define Read Models `csh..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/cqrs-implementation-chunk-2",
        "text": "list/search [ReadModel(\"OrderList\")] public class OrderListItem { public Guid OrderId { get; set; } public Guid CustomerId { get; set; } public string CustomerName { get; set; } public decimal TotalAmount { get; set; } public string Status { get; set; } public DateTime CreatedAt { get; set; } public DateTime ShippedAt { get; set; }\n    // Denormalized data for fast queries\n    public int ItemCount { get; set; }\n    public string FirstItemName { get; set; }\n    public bool IsHighValue { get; set; } // TotalAmount > 1000\n}\n// Read model for customer order history\n[ReadModel(\"CustomerOrders\")]\npublic class CustomerOrderSummary {\n    public Guid CustomerId { get; set; }\n    public string CustomerName { get; set; }\n    public int TotalOrders { get; set; }\n    public int CompletedOrders { get; set; }\n    public int PendingOrders { get; set; }\n    public decimal LifetimeValue { get; set; }\n    public DateTime LastOrderDate { get; set; }\n    public List<RecentOrder> RecentOrders { get; set; } = new();\n}\npublic class RecentOrder {\n    public Guid OrderId { get; set; }\n    public decimal Amount { get; set; }\n    public string Status { get; set; }\n    public DateTime Date { get; set; }\n}\n// Read model for order details\n[ReadModel(\"OrderDetails\")]\npublic class OrderDetailsView {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    // Customer info (denormalized)\n    public string CustomerName { get; set; }\n    public string CustomerEmail { get; set; }\n    public string CustomerPhone { get; set; }\n    // Order info\n    public List<OrderLineView> Lines { get; set; } = new();\n    public decimal SubTotal { get; set; }\n    public decimal TaxAmount { get; set; }\n    public decimal ShippingCost { get; set; }\n    public decimal TotalAmount { get; set; }\n    // Shipping info\n    public string ShippingAddress { get; set; }\n    public string TrackingNumber { get; set; }\n    public string Carrier { get; set; }\n    // Status and dates\n    public string Status { get; set; }\n    public DateTime CreatedAt { get; set; }\n    public DateTime",
        "startIndex": 3118,
        "preview": "list/search [ReadModel(\"OrderList\")] public class OrderListItem { public Guid OrderId { get; set; } public Guid CustomerId { get; set; } public string..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/cqrs-implementation-chunk-3",
        "text": "decimal TotalAmount { get; set; } // Shipping info public string ShippingAddress { get; set; } public string TrackingNumber { get; set; } public string Carrier { get; set; } // Status and dates public string Status { get; set; } public DateTime CreatedAt { get; set; } public DateTime ShippedAt { get; set; }\n    public DateTime DeliveredAt { get; set; }\n    // Audit trail\n    public List<OrderEvent> EventHistory { get; set; } = new();\n}\npublic class OrderLineView {\n    public string ProductId { get; set; }\n    public string ProductName { get; set; }\n    public string ProductImageUrl { get; set; } // Enriched data\n    public int Quantity { get; set; }\n    public decimal UnitPrice { get; set; }\n    public decimal LineTotal { get; set; }\n}\npublic class OrderEvent {\n    public string EventType { get; set; }\n    public DateTime OccurredAt { get; set; }\n    public string Description { get; set; }\n}\n`\nStep 2: Create Projections\n`csharp{\ntitle: \"Projection Implementation\"\ndescription: \"Build projections that update read models from events\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Event Handlers\", \"Read Model Updates\"]\nnugetPackages: [\"Whizbang Projections\"]\nfilename: \"OrderProjections cs\"\nshowLineNumbers: true\nhighlightLines: [15, 35, 55, 75]\nusingStatements: [\"Whizbang Projections\", \"System\", \"System Threading Tasks\"]\n}\nusing Whizbang Projections;\nusing System;\nusing System Linq;\nusing System Threading;\nusing System Threading Tasks;\nusing MyApp Orders Events;\nusing MyApp Orders ReadModels;\nnamespace MyApp Orders Projections;\n[Projection(\"OrderListProjection\")]\npublic class OrderListProjection : IProjection {\n    private readonly IReadModelStore<OrderListItem> _store;\n    private readonly ICustomerService _customerService;\n    public OrderListProjection(\n        IReadModelStore<OrderListItem> store,\n        ICustomerService customerService) {\n        _store = store;\n        _customerService = customerService;\n    }\n    [Subscribe]\n    public async Task Handle(\n        OrderCreated @event,\n        EventMetadata metadata,\n        CancellationToken cancellationToken) {\n        // Enrich with customer data\n        var customer = await _customerService GetCustomer(\n            @event CustomerId,\n            cancellationToken\n        );\n        // Create read model\n        var item = new OrderListItem {\n            OrderId = @event",
        "startIndex": 4886,
        "preview": "decimal TotalAmount { get; set; } // Shipping info public string ShippingAddress { get; set; } public string TrackingNumber { get; set; } public strin..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/cqrs-implementation-chunk-4",
        "text": "ICustomerService customerService) { _store = store; _customerService = customerService; } [Subscribe] public async Task Handle( OrderCreated @event, EventMetadata metadata, CancellationToken cancellationToken) { // Enrich with customer data var customer = await _customerService GetCustomer( @event CustomerId, cancellationToken ); // Create read model var item = new OrderListItem { OrderId = @event OrderId,\n            CustomerId = @event CustomerId,\n            CustomerName = customer Name \"Unknown\",\n            TotalAmount = @event TotalAmount,\n            Status = \"Pending\",\n            CreatedAt = @event CreatedAt,\n            ItemCount = @event Items Count,\n            FirstItemName = @event Items FirstOrDefault() ProductName,\n            IsHighValue = @event TotalAmount > 1000\n        };\n        await _store Add(item OrderId, item, cancellationToken);\n    }\n    [Subscribe]\n    public async Task Handle(\n        OrderShipped @event,\n        EventMetadata metadata,\n        CancellationToken cancellationToken) {\n        await _store Update(\n            @event OrderId,\n            item => {\n                item Status = \"Shipped\";\n                item ShippedAt = @event ShippedAt;\n            },\n            cancellationToken\n        );\n    }\n    [Subscribe]\n    public async Task Handle(\n        OrderCancelled @event,\n        EventMetadata metadata,\n        CancellationToken cancellationToken) {\n        await _store Update(\n            @event OrderId,\n            item => item Status = \"Cancelled\",\n            cancellationToken\n        );\n    }\n}\n[Projection(\"CustomerOrdersProjection\")]\npublic class CustomerOrdersProjection : IProjection {\n    private readonly IReadModelStore<CustomerOrderSummary> _store;\n    public CustomerOrdersProjection(IReadModelStore<CustomerOrderSummary> store) {\n        _store = store;\n    }\n    [Subscribe]\n    public async Task Handle(\n        OrderCreated @event,\n        EventMetadata metadata,\n        CancellationToken cancellationToken) {\n        var summary = await _store GetById(@event CustomerId, cancellationToken) new CustomerOrderSummary { \n                CustomerId = @event CustomerId \n            };\n        // Update summary\n        summary TotalOrders++;\n        summary PendingOrders++;\n        summary LifetimeValue += @event TotalAmount;\n        summary LastOrderDate = @event CreatedAt;\n        // Add to recent orders (keep last 10)\n        summary RecentOrders Insert(0, new RecentOrder {\n            OrderId = @event OrderId,\n            Amount = @event TotalAmount,\n            Status = \"Pending\",\n            Date = @event CreatedAt\n        });\n        if (summary RecentOrders Count > 10) {\n            summary RecentOrders RemoveAt(10);\n        }\n        await _store Upsert(\n            summary CustomerId, \n            summary, \n            cancellationToken\n        );\n    }\n    [Subscribe]\n    public async Task Handle(\n        OrderShipped @event,\n        EventMetadata metadata,\n        CancellationToken cancellationToken) {\n        // Update customer summary when order ships\n        await _store Update(\n            @event CustomerId,\n            summary => {\n                summary PendingOrders--;\n                summary",
        "startIndex": 7005,
        "preview": "ICustomerService customerService) { _store = store; _customerService = customerService; } [Subscribe] public async Task Handle( OrderCreated @event, E..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/cqrs-implementation-chunk-5",
        "text": "if (summary RecentOrders Count > 10) { summary RecentOrders RemoveAt(10); } await _store Upsert( summary CustomerId, summary, cancellationToken ); } [Subscribe] public async Task Handle( OrderShipped @event, EventMetadata metadata, CancellationToken cancellationToken) { // Update customer summary when order ships await _store Update( @event CustomerId, summary => { summary PendingOrders--; summary CompletedOrders++;\n                var recentOrder = summary RecentOrders FirstOrDefault(o => o OrderId == @event OrderId);\n                if (recentOrder = null) {\n                    recentOrder Status = \"Shipped\";\n                }\n            },\n            cancellationToken\n        );\n    }\n}\n`\nStep 3: Implement Query Handlers\n`csharp{\ntitle: \"Query Handler Implementation\"\ndescription: \"Query handlers that read from optimized read models\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Query Handlers\", \"Read Operations\", \"Performance\"]\nnugetPackages: [\"Whizbang Projections\"]\nfilename: \"OrderQueryHandlers cs\"\nshowLineNumbers: true\nhighlightLines: [18, 40, 65]\nusingStatements: [\"Whizbang Projections\", \"System\", \"System Linq\", \"System Threading Tasks\"]\n}\nusing Whizbang;\nusing Whizbang Projections;\nusing System;\nusing System Collections Generic;\nusing System Linq;\nusing System Threading;\nusing System Threading Tasks;\nusing MyApp Orders Queries;\nusing MyApp Orders ReadModels;\nnamespace MyApp Orders Handlers;\npublic class GetOrderListHandler : IQueryHandler<GetOrderListQuery, PagedResult<OrderListItem>> {\n    private readonly IReadModelStore<OrderListItem> _store;\n    public GetOrderListHandler(IReadModelStore<OrderListItem> store) {\n        _store = store;\n    }\n    public async Task<PagedResult<OrderListItem>> Handle(\n        GetOrderListQuery query,\n        CancellationToken cancellationToken) {\n        // Query read model with filtering, sorting, paging\n        var items = await _store Query(\n            filter: item => {\n                var matches = true;\n                if (query CustomerId HasValue) {\n                    matches &= item CustomerId == query CustomerId;\n                }\n                if ( string IsNullOrEmpty(query Status)) {\n                    matches &= item Status == query Status;\n                }\n                if (query MinAmount HasValue) {\n                    matches &= item TotalAmount >= query MinAmount;\n                }\n                if (query IsHighValue HasValue) {\n                    matches &= item IsHighValue == query IsHighValue;\n                }\n                return matches;\n            },\n            orderBy: query SortBy switch {\n                \"date\" => items => query SortDescending items OrderByDescending(i => i CreatedAt)\n                    : items OrderBy(i => i CreatedAt),\n                \"amount\" => items => query SortDescending items",
        "startIndex": 9844,
        "preview": "if (summary RecentOrders Count > 10) { summary RecentOrders RemoveAt(10); } await _store Upsert( summary CustomerId, summary, cancellationToken ); } [..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/cqrs-implementation-chunk-6",
        "text": "TotalAmount >= query MinAmount; } if (query IsHighValue HasValue) { matches &= item IsHighValue == query IsHighValue; } return matches; }, orderBy: query SortBy switch { \"date\" => items => query SortDescending items OrderByDescending(i => i CreatedAt) : items OrderBy(i => i CreatedAt), \"amount\" => items => query SortDescending items OrderByDescending(i => i TotalAmount)\n                    : items OrderBy(i => i TotalAmount),\n                _ => items => items OrderByDescending(i => i CreatedAt)\n            },\n            skip: (query Page - 1) * query PageSize,\n            take: query PageSize,\n            cancellationToken: cancellationToken\n        );\n        var totalCount = await _store Count(cancellationToken);\n        return new PagedResult<OrderListItem> {\n            Items = items,\n            Page = query Page,\n            PageSize = query PageSize,\n            TotalCount = totalCount,\n            TotalPages = (int)Math Ceiling(totalCount / (double)query PageSize)\n        };\n    }\n}\npublic class GetCustomerOrdersHandler : IQueryHandler<GetCustomerOrdersQuery, CustomerOrderSummary> {\n    private readonly IReadModelStore<CustomerOrderSummary> _store;\n    private readonly ICustomerService _customerService;\n    public GetCustomerOrdersHandler(\n        IReadModelStore<CustomerOrderSummary> store,\n        ICustomerService customerService) {\n        _store = store;\n        _customerService = customerService;\n    }\n    public async Task<CustomerOrderSummary> Handle(\n        GetCustomerOrdersQuery query,\n        CancellationToken cancellationToken) {\n        // Get from read model\n        var summary = await _store GetById(query CustomerId, cancellationToken);\n        if (summary == null) {\n            // No orders yet, return empty summary\n            var customer = await _customerService GetCustomer(\n                query CustomerId,\n                cancellationToken\n            );\n            return new CustomerOrderSummary {\n                CustomerId = query CustomerId,\n                CustomerName = customer Name \"Unknown\",\n                TotalOrders = 0,\n                CompletedOrders = 0,\n                PendingOrders = 0,\n                LifetimeValue = 0,\n                RecentOrders = new List<RecentOrder>()\n            };\n        }\n        return summary;\n    }\n}\npublic class SearchOrdersHandler : IQueryHandler<SearchOrdersQuery, List<OrderListItem>> {\n    private readonly IReadModelStore<OrderListItem> _store;\n    private readonly ISearchService _searchService;\n    public SearchOrdersHandler(\n        IReadModelStore<OrderListItem> store,\n        ISearchService searchService) {\n        _store = store;\n        _searchService = searchService;\n    }\n    public async Task<List<OrderListItem>> Handle(\n        SearchOrdersQuery query,\n        CancellationToken cancellationToken) {\n        // Use search service for full-text search\n        var orderIds = await _searchService SearchOrders(\n            query SearchTerm,\n            limit: query",
        "startIndex": 12195,
        "preview": "TotalAmount >= query MinAmount; } if (query IsHighValue HasValue) { matches &= item IsHighValue == query IsHighValue; } return matches; }, orderBy: qu..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/cqrs-implementation-chunk-7",
        "text": "List<OrderListItem>> { private readonly IReadModelStore<OrderListItem> _store; private readonly ISearchService _searchService; public SearchOrdersHandler( IReadModelStore<OrderListItem> store, ISearchService searchService) { _store = store; _searchService = searchService; } public async Task<List<OrderListItem>> Handle( SearchOrdersQuery query, CancellationToken cancellationToken) { // Use search service for full-text search var orderIds = await _searchService SearchOrders( query SearchTerm, limit: query MaxResults,\n            cancellationToken: cancellationToken\n        );\n        // Get read models for matching orders\n        var orders = new List<OrderListItem>();\n        foreach (var orderId in orderIds) {\n            var order = await _store GetById(orderId, cancellationToken);\n            if (order = null) {\n                orders Add(order);\n            }\n        }\n        return orders;\n    }\n}\n`\nStep 4: Configure CQRS\n`csharp{\ntitle: \"CQRS Configuration\"\ndescription: \"Configure Whizbang with CQRS pattern and projection processing\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Configuration\", \"CQRS Setup\", \"Projections\"]\nnugetPackages: [\"Whizbang Projections\", \"Whizbang EventSourcing\"]\nfilename: \"Program cs\"\nshowLineNumbers: true\nhighlightLines: [9, 16, 23, 33]\nusingStatements: [\"Whizbang\", \"Whizbang Projections\", \"Microsoft Extensions DependencyInjection\"]\n}\nusing Whizbang;\nusing Whizbang Projections;\nusing Microsoft AspNetCore Builder;\nusing Microsoft Extensions DependencyInjection;\nvar builder = WebApplication CreateBuilder(args);\n// Configure Whizbang with CQRS\nbuilder Services AddWhizbang(config => {\n    // Configure event sourcing for write side\n    config UseEventSourcing(options => {\n        options UsePostgreSQL(builder Configuration GetConnectionString(\"EventStore\"));\n    });\n    // Configure projections for read side\n    config UseProjections(options => {\n        // Use separate database for read models\n        options UsePostgreSQL(builder Configuration GetConnectionString(\"ReadModels\"));\n        // Configure projection processing\n        options ProcessingMode = ProjectionProcessingMode Async;\n        options RetryPolicy = RetryPolicy Exponential(3, TimeSpan FromSeconds(1));\n        // Register projections\n        options RegisterProjectionsFromAssembly(typeof(Program) Assembly);\n        // Configure read model stores\n        options ConfigureStore<OrderListItem>(store => {\n            store TableName = \"order_list\";\n            store EnableCaching(TimeSpan FromMinutes(5));\n        });\n        options ConfigureStore<CustomerOrderSummary>(store => {\n            store TableName = \"customer_orders\";\n            store EnableCaching(TimeSpan FromMinutes(10));\n        });\n        options ConfigureStore<OrderDetailsView>(store => {\n            store TableName = \"order_details\";\n            store EnableCaching(TimeSpan FromMinutes(2));\n        });\n    });\n    // Register handlers\n    config RegisterHandlersFromAssembly(typeof(Program) Assembly);\n});\n// Register services\nbuilder Services AddScoped<ICustomerService, CustomerService>();\nbuilder Services AddScoped<ISearchService, ElasticsearchService>();\nbuilder Services AddControllers();\nvar app = builder",
        "startIndex": 15047,
        "preview": "List<OrderListItem>> { private readonly IReadModelStore<OrderListItem> _store; private readonly ISearchService _searchService; public SearchOrdersHand..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/cqrs-implementation-chunk-8",
        "text": "options ConfigureStore<CustomerOrderSummary>(store => { store TableName = \"customer_orders\"; store EnableCaching(TimeSpan FromMinutes(10)); }); options ConfigureStore<OrderDetailsView>(store => { store TableName = \"order_details\"; store EnableCaching(TimeSpan FromMinutes(2)); }); }); // Register handlers config RegisterHandlersFromAssembly(typeof(Program) Assembly); }); // Register services builder Services AddScoped<ICustomerService, CustomerService>(); builder Services AddScoped<ISearchService, ElasticsearchService>(); builder Services AddControllers(); var app = builder Build();\n// Initialize projection infrastructure\nawait app InitializeProjections();\n// Start projection processor\napp UseProjectionProcessor();\napp UseRouting();\napp MapControllers();\napp Run();\n`\nComplete Example\n`csharp{\ntitle: \"Complete CQRS Implementation\"\ndescription: \"Full working example showing CQRS from commands to queries\"\nframework: \"NET8\"\ncategory: \"Complete Example\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"CQRS\", \"Complete\", \"API\", \"Commands\", \"Queries\"]\nnugetPackages: [\"Whizbang Projections\", \"Microsoft AspNetCore Mvc\"]\nfilename: \"CQRSOrdersController cs\"\nshowLineNumbers: true\nhighlightLines: [22, 36, 51, 66, 81]\ntestFile: \"CQRSOrdersTests cs\"\ntestMethod: \"CreateOrder_UpdatesReadModel_QueryReturnsData\"\nusingStatements: [\"Whizbang\", \"Microsoft AspNetCore Mvc\", \"System Threading Tasks\"]\n}\nusing Whizbang;\nusing Microsoft AspNetCore Mvc;\nusing System;\nusing System Threading;\nusing System Threading Tasks;\nusing MyApp Orders Commands;\nusing MyApp Orders Queries;\nusing MyApp Orders ReadModels;\nnamespace MyApp Controllers;\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class OrdersController : ControllerBase {\n    private readonly IMediator _mediator;\n    public OrdersController(IMediator mediator) {\n        _mediator = mediator;\n    }\n    // COMMAND SIDE - Write operations\n    [HttpPost]\n    public async Task<ActionResult<OrderCreatedResult>> CreateOrder(\n        [FromBody] CreateOrderRequest request,\n        CancellationToken cancellationToken) {\n        var command = new CreateOrderCommand(\n            request CustomerId,\n            request Items,\n            request ShippingAddress\n        );\n        var result = await _mediator Send(command, cancellationToken);\n        return CreatedAtAction(nameof(GetOrderDetails), new { orderId = result OrderId }, result);\n    }\n    [HttpPost(\"{orderId}/ship\")]\n    public async Task<ActionResult<ShipmentResult>> ShipOrder(\n        Guid orderId,\n        CancellationToken cancellationToken) {\n        var command = new ShipOrderCommand(orderId);\n        var result = await _mediator Send(command, cancellationToken);\n        return Ok(result);\n    }\n    // QUERY SIDE - Read operations from optimized read models\n    [HttpGet]\n    public async Task<ActionResult<PagedResult<OrderListItem>>> GetOrders(\n        [FromQuery] int page = 1,\n        [FromQuery] int pageSize = 20,\n        [FromQuery] string status = null,\n        [FromQuery] decimal",
        "startIndex": 17796,
        "preview": "options ConfigureStore<CustomerOrderSummary>(store => { store TableName = \"customer_orders\"; store EnableCaching(TimeSpan FromMinutes(10)); }); option..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/cqrs-implementation-chunk-9",
        "text": "CancellationToken cancellationToken) { var command = new ShipOrderCommand(orderId); var result = await _mediator Send(command, cancellationToken); return Ok(result); } // QUERY SIDE - Read operations from optimized read models [HttpGet] public async Task<ActionResult<PagedResult<OrderListItem>>> GetOrders( [FromQuery] int page = 1, [FromQuery] int pageSize = 20, [FromQuery] string status = null, [FromQuery] decimal minAmount = null,\n        [FromQuery] string sortBy = \"date\",\n        [FromQuery] bool sortDescending = true,\n        CancellationToken cancellationToken = default) {\n        var query = new GetOrderListQuery {\n            Page = page,\n            PageSize = pageSize,\n            Status = status,\n            MinAmount = minAmount,\n            SortBy = sortBy,\n            SortDescending = sortDescending\n        };\n        var result = await _mediator Send(query, cancellationToken);\n        return Ok(result);\n    }\n    [HttpGet(\"{orderId}\")]\n    public async Task<ActionResult<OrderDetailsView>> GetOrderDetails(\n        Guid orderId,\n        CancellationToken cancellationToken) {\n        var query = new GetOrderDetailsQuery(orderId);\n        var result = await _mediator Send(query, cancellationToken);\n        if (result == null) {\n            return NotFound();\n        }\n        return Ok(result);\n    }\n    [HttpGet(\"customer/{customerId}\")]\n    public async Task<ActionResult<CustomerOrderSummary>> GetCustomerOrders(\n        Guid customerId,\n        CancellationToken cancellationToken) {\n        var query = new GetCustomerOrdersQuery(customerId);\n        var result = await _mediator Send(query, cancellationToken);\n        return Ok(result);\n    }\n    [HttpGet(\"search\")]\n    public async Task<ActionResult<List<OrderListItem>>> SearchOrders(\n        [FromQuery] string q,\n        [FromQuery] int maxResults = 50,\n        CancellationToken cancellationToken = default) {\n        if (string IsNullOrWhiteSpace(q)) {\n            return BadRequest(\"Search term is required\");\n        }\n        var query = new SearchOrdersQuery {\n            SearchTerm = q,\n            MaxResults = maxResults\n        };\n        var result = await _mediator Send(query, cancellationToken);\n        return Ok(result);\n    }\n    // Analytics queries from specialized read models\n    [HttpGet(\"analytics/top-customers\")]\n    public async Task<ActionResult<List<TopCustomer>>> GetTopCustomers(\n        [FromQuery] int count = 10,\n        CancellationToken cancellationToken = default) {\n        var query = new GetTopCustomersQuery(count);\n        var result = await _mediator Send(query, cancellationToken);\n        return Ok(result);\n    }\n    [HttpGet(\"analytics/sales-by-day\")]\n    public async Task<ActionResult<List<DailySales>>> GetSalesByDay(\n        [FromQuery] DateTime startDate,\n        [FromQuery] DateTime endDate,\n        CancellationToken cancellationToken = default) {\n        var query = new GetSalesByDayQuery(startDate, endDate);\n        var result = await _mediator",
        "startIndex": 20219,
        "preview": "CancellationToken cancellationToken) { var command = new ShipOrderCommand(orderId); var result = await _mediator Send(command, cancellationToken); ret..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/cqrs-implementation-chunk-10",
        "text": "count = 10, CancellationToken cancellationToken = default) { var query = new GetTopCustomersQuery(count); var result = await _mediator Send(query, cancellationToken); return Ok(result); } [HttpGet(\"analytics/sales-by-day\")] public async Task<ActionResult<List<DailySales>>> GetSalesByDay( [FromQuery] DateTime startDate, [FromQuery] DateTime endDate, CancellationToken cancellationToken = default) { var query = new GetSalesByDayQuery(startDate, endDate); var result = await _mediator Send(query, cancellationToken);\n        return Ok(result);\n    }\n}\n// Query definitions\npublic record GetOrderListQuery {\n    public int Page { get; set; } = 1;\n    public int PageSize { get; set; } = 20;\n    public Guid CustomerId { get; set; }\n    public string Status { get; set; }\n    public decimal MinAmount { get; set; }\n    public bool IsHighValue { get; set; }\n    public string SortBy { get; set; } = \"date\";\n    public bool SortDescending { get; set; } = true;\n}\npublic record SearchOrdersQuery {\n    public string SearchTerm { get; set; }\n    public int MaxResults { get; set; } = 50;\n}\n`\nTesting Strategy\nTesting Projections\n`csharp{\ntitle: \"Projection Tests\"\ndescription: \"Test that projections correctly update read models from events\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Unit Testing\", \"Projections\", \"Read Models\"]\nnugetPackages: [\"Whizbang Projections\", \"xUnit\", \"Moq\"]\nfilename: \"OrderProjectionTests cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang Projections\", \"Xunit\", \"Moq\"]\n}\nusing Whizbang Projections;\nusing Xunit;\nusing Moq;\nusing System;\nusing System Threading;\nusing System Threading Tasks;\nusing MyApp Orders Events;\nusing MyApp Orders Projections;\nusing MyApp Orders ReadModels;\nnamespace MyApp Tests Orders;\npublic class OrderListProjectionTests {\n    private readonly Mock<IReadModelStore<OrderListItem>> _storeMock;\n    private readonly Mock<ICustomerService> _customerServiceMock;\n    private readonly OrderListProjection _projection;\n    public OrderListProjectionTests() {\n        _storeMock = new Mock<IReadModelStore<OrderListItem>>();\n        _customerServiceMock = new Mock<ICustomerService>();\n        _projection = new OrderListProjection(\n            _storeMock Object,\n            _customerServiceMock Object\n        );\n    }\n    [Fact]\n    public async Task Handle_OrderCreated_CreatesReadModel() {\n        // Arrange\n        var @event = new OrderCreated(\n            Guid NewGuid(),\n            Guid NewGuid(),\n            new List<OrderItem> {\n                new OrderItem(\"P1\", \"Widget\", 2, 500 00m)\n            },\n            1000 00m,\n            \"123 Main St\",\n            DateTime",
        "startIndex": 22799,
        "preview": "count = 10, CancellationToken cancellationToken = default) { var query = new GetTopCustomersQuery(count); var result = await _mediator Send(query, can..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/cqrs-implementation-chunk-11",
        "text": "= new Mock<IReadModelStore<OrderListItem>>(); _customerServiceMock = new Mock<ICustomerService>(); _projection = new OrderListProjection( _storeMock Object, _customerServiceMock Object ); } [Fact] public async Task Handle_OrderCreated_CreatesReadModel() { // Arrange var @event = new OrderCreated( Guid NewGuid(), Guid NewGuid(), new List<OrderItem> { new OrderItem(\"P1\", \"Widget\", 2, 500 00m) }, 1000 00m, \"123 Main St\", DateTime UtcNow\n        );\n        _customerServiceMock Setup(x => x GetCustomer(It IsAny<Guid>(), It IsAny<CancellationToken>())) ReturnsAsync(new Customer { Name = \"John Doe\" });\n        // Act\n        await _projection Handle(\n            @event,\n            new EventMetadata(),\n            CancellationToken None\n        );\n        // Assert\n        _storeMock Verify(x => x Add(\n            @event OrderId,\n            It Is<OrderListItem>(item =>\n                item OrderId == @event OrderId &&\n                item TotalAmount == 1000 00m &&\n                item Status == \"Pending\" &&\n                item IsHighValue == true &&\n                item CustomerName == \"John Doe\"\n            ),\n            It IsAny<CancellationToken>()\n        ), Times Once);\n    }\n    [Fact]\n    public async Task Handle_OrderShipped_UpdatesStatus() {\n        // Arrange\n        var orderId = Guid NewGuid();\n        var @event = new OrderShipped(\n            orderId,\n            \"TRACK123\",\n            \"FedEx\",\n            DateTime UtcNow\n        );\n        // Act\n        await _projection Handle(\n            @event,\n            new EventMetadata(),\n            CancellationToken None\n        );\n        // Assert\n        _storeMock Verify(x => x Update(\n            orderId,\n            It IsAny<Action<OrderListItem>>(),\n            It IsAny<CancellationToken>()\n        ), Times Once);\n    }\n}\n`\nCommon Pitfalls\nDon't Query Write Models\n`csharp{\ntitle: \"Don't Query Write Models\"\ndescription: \"Avoid querying aggregates for read operations - use optimized read models instead\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"CQRS\", \"Anti-Patterns\", \"Best Practices\"]\nfilename: \"ReadModelVsAggregate cs\"\nshowLineNumbers: true\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq\", \"System Threading Tasks\"]\n}\n// ❌ BAD - Querying aggregates for read operations\npublic async Task<List<Order>> GetOrders() {\n    var aggregates = await _repository GetAll<OrderAggregate>();\n    return aggregates Select(a => MapToDto(a)) ToList();\n}\n// ✅ GOOD - Query optimized read models\npublic async Task<List<OrderListItem>> GetOrders() {\n    return await _readModelStore",
        "startIndex": 24981,
        "preview": "= new Mock<IReadModelStore<OrderListItem>>(); _customerServiceMock = new Mock<ICustomerService>(); _projection = new OrderListProjection( _storeMock O..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/cqrs-implementation-chunk-12",
        "text": "Generic\", \"System Linq\", \"System Threading Tasks\"] } // ❌ BAD - Querying aggregates for read operations public async Task<List<Order>> GetOrders() { var aggregates = await _repository GetAll<OrderAggregate>(); return aggregates Select(a => MapToDto(a)) ToList(); } // ✅ GOOD - Query optimized read models public async Task<List<OrderListItem>> GetOrders() { return await _readModelStore Query<OrderListItem>();\n}\n`\nHandle Eventual Consistency\n`csharp{\ntitle: \"Handle Eventual Consistency\"\ndescription: \"Account for eventual consistency between write and read models in CQRS\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"CQRS\", \"Eventual Consistency\", \"Best Practices\"]\nfilename: \"EventualConsistency cs\"\nshowLineNumbers: true\nusingStatements: [\"System\", \"System Threading Tasks\"]\n}\n// ❌ BAD - Expecting immediate consistency\nvar orderId = await CreateOrder(command);\nvar order = await GetOrder(orderId); // May not exist yet // ✅ GOOD - Handle eventual consistency\nvar orderId = await CreateOrder(command);\nawait Task Delay(100); // Or use polling/SignalR for real-time updates\nvar order = await GetOrder(orderId);\n`\nAvoid Complex Projections\n`csharp{\ntitle: \"Avoid Complex Projections\"\ndescription: \"Keep projections focused on single responsibility rather than doing multiple things\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"CQRS\", \"Projections\", \"Single Responsibility\", \"Best Practices\"]\nfilename: \"ProjectionResponsibility cs\"\nshowLineNumbers: true\nusingStatements: [\"System\", \"System Threading Tasks\"]\n}\n// ❌ BAD - Projection doing too much\npublic async Task Handle(OrderCreated @event) {\n    await UpdateOrderList();\n    await UpdateCustomerSummary();\n    await SendEmail();\n    await UpdateInventory();\n}\n// ✅ GOOD - Single responsibility projections\npublic class OrderListProjection { / Updates order list only / }\npublic class CustomerSummaryProjection { / Updates customer summary only / }\npublic class EmailNotificationHandler { / Sends emails only / }\n`\nProgressive Enhancement\nAdd Multiple Read Stores\n`csharp{\ntitle: \"Multiple Read Stores\"\ndescription: \"Configure different storage technologies for different read model needs\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Usage Patterns\", \"CQRS\", \"Multiple Stores\", \"Storage Options\"]\nfilename: \"MultipleStoresConfiguration",
        "startIndex": 27222,
        "preview": "Generic\", \"System Linq\", \"System Threading Tasks\"] } // ❌ BAD - Querying aggregates for read operations public async Task<List<Order>> GetOrders() { v..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/cqrs-implementation-chunk-13",
        "text": "} public class EmailNotificationHandler { / Sends emails only / } ` Progressive Enhancement Add Multiple Read Stores `csharp{ title: \"Multiple Read Stores\" description: \"Configure different storage technologies for different read model needs\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"ADVANCED\" tags: [\"Usage Patterns\", \"CQRS\", \"Multiple Stores\", \"Storage Options\"] filename: \"MultipleStoresConfiguration cs\"\nshowLineNumbers: true\nusingStatements: [\"System\", \"Whizbang Projections\"]\n}\n// Configure different stores for different needs\nconfig UseProjections(options => {\n    // PostgreSQL for transactional queries\n    options AddStore<OrderListItem>() UsePostgreSQL(connString) WithCaching(TimeSpan FromMinutes(5));\n    // MongoDB for document queries\n    options AddStore<OrderDetailsView>() UseMongoDB(mongoConnection) WithIndexes(\"CustomerId\", \"Status\");\n    // Elasticsearch for search\n    options AddStore<OrderSearchDocument>() UseElasticsearch(elasticUri) WithFullTextSearch();\n});\n`\nImplement Sagas for Complex Workflows\nSee Saga Orchestration for coordinating multi-aggregate operations Add Real-Time Updates\n`csharp{\ntitle: \"Real-Time Updates with SignalR\"\ndescription: \"Add real-time notifications to CQRS projections using SignalR\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Usage Patterns\", \"CQRS\", \"SignalR\", \"Real-Time\", \"Notifications\"]\nfilename: \"RealTimeNotifications cs\"\nshowLineNumbers: true\nusingStatements: [\"Microsoft AspNetCore SignalR\", \"System\", \"System Threading Tasks\"]\n}\n// SignalR for real-time notifications\npublic class OrderHub : Hub {\n    public async Task SubscribeToOrders(Guid customerId) {\n        await Groups AddToGroupAsync(Context ConnectionId, $\"customer-{customerId}\");\n    }\n}\n// In projection\npublic async Task Handle(OrderCreated @event) {\n    await UpdateReadModel(@event);\n    await _hubContext Clients Group($\"customer-{@event CustomerId}\") SendAsync(\"OrderCreated\", @event);\n}\n`\nRelated Patterns\nEvent Sourcing Basics - Foundation for CQRS write side\nSimple Mediator Pattern - Simpler alternative without separation\nDistributed Messaging - Scale CQRS across services\nProduction Considerations\nRead Model Rebuild\n`csharp{\ntitle: \"Read Model Rebuild\"\ndescription: \"Rebuild read models from events for data recovery or schema changes\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"CQRS\", \"Projections\", \"Rebuild\", \"Maintenance\"]\nfilename: \"ReadModelRebuild cs\"\nshowLineNumbers: true\nusingStatements: [\"System\", \"System Threading Tasks\"]\n}\n// Rebuild read models from events\nawait projectionManager RebuildProjection<OrderListProjection>(\n    fromPosition: EventPosition Start,\n    toPosition: EventPosition",
        "startIndex": 29266,
        "preview": "} public class EmailNotificationHandler { / Sends emails only / } ` Progressive Enhancement Add Multiple Read Stores `csharp{ title: \"Multiple Read St..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/cqrs-implementation-chunk-14",
        "text": "\"Rebuild read models from events for data recovery or schema changes\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"INTERMEDIATE\" tags: [\"Usage Patterns\", \"CQRS\", \"Projections\", \"Rebuild\", \"Maintenance\"] filename: \"ReadModelRebuild cs\" showLineNumbers: true usingStatements: [\"System\", \"System Threading Tasks\"] } // Rebuild read models from events await projectionManager RebuildProjection<OrderListProjection>( fromPosition: EventPosition Start, toPosition: EventPosition End\n);\n`\nMonitoring and Health Checks\n`csharp{\ntitle: \"Monitoring and Health Checks\"\ndescription: \"Monitor CQRS projection health and performance\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"CQRS\", \"Monitoring\", \"Health Checks\", \"Production\"]\nfilename: \"CQRSMonitoring cs\"\nshowLineNumbers: true\nusingStatements: [\"Microsoft Extensions DependencyInjection\"]\n}\n// Monitor projection lag\nservices AddHealthChecks() AddCheck<ProjectionLagHealthCheck>(\"projection-lag\") AddCheck<ReadModelConsistencyCheck>(\"read-consistency\");\n`\nPerformance Optimization\nUse appropriate indexes on read models\nImplement caching strategies\nConsider materialized views for complex queries\nMonitor query performance\nNext Steps\nExplore Saga Orchestration for complex workflows\nLearn about Distributed Messaging for microservices\nReview Projections Documentation for advanced patterns\nCheck out Query Optimization techniques",
        "startIndex": 31674,
        "preview": "\"Rebuild read models from events for data recovery or schema changes\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"INTERMEDIATE\" tags: [\"..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/usage-patterns/distributed-messaging",
    "title": "Distributed Messaging",
    "category": "Usage Patterns",
    "url": "/docs/old-v1.0.0/usage-patterns/distributed-messaging",
    "chunks": [
      {
        "id": "old-v1.0.0/usage-patterns/distributed-messaging-chunk-0",
        "text": "Distributed Messaging\nOverview\nDistributed Messaging enables reliable communication between services in a microservices architecture. Whizbang provides robust patterns for handling distributed transactions, ensuring message delivery, and maintaining consistency across service boundaries.\nKey Concepts\nOutbox Pattern: Ensure reliable message publishing\nInbox Pattern: Handle duplicate messages and ensure idempotency\nMessage Routing: Direct messages to appropriate handlers\nSaga Coordination: Orchestrate multi-service workflows\nArchitecture Diagram\n`mermaid\ngraph TB\n    subgraph \"Service A\"\n        A1[Command Handler] --> A2[Aggregate]\n        A2 --> A3[Event Store]\n        A3 --> A4[Outbox]\n        A4 --> A5[Message Publisher]\n    end\n    subgraph \"Message Broker\"\n        MB[(RabbitMQ/Kafka)]\n    end\n    subgraph \"Service B\"\n        B1[Message Consumer] --> B2[Inbox]\n        B2 --> B3[Command Handler]\n        B3 --> B4[Aggregate]\n    end\n    A5 --> MB\n    MB --> B1\n    style MB fill:#0066cc,color:#fff\n`\nImplementation Guide\nDocumentation in progress - This page demonstrates the structure for distributed messaging patterns with Whizbang.\nTopics to Cover:\nOutbox Pattern Implementation\nTransactional outbox\nMessage publishing\nRetry mechanisms\nInbox Pattern Implementation\nDuplicate detection\nMessage ordering\nIdempotent processing\nMessage Broker Integration\nRabbitMQ configuration\nKafka setup\nAzure Service Bus\nError Handling\nDead letter queues\nRetry policies\nCompensation\nMonitoring\nMessage tracking\nLatency metrics\nHealth checks\nRelated Patterns\nEvent Sourcing Basics - Foundation for event-driven messaging\nSaga Orchestration - Coordinate distributed workflows\nMicroservices Integration - Complete microservices setup\nNext Steps\nReview Distributed Messaging Roadmap for upcoming features\nExplore Saga Orchestration for complex workflows\nCheck Getting Started Guide for basics",
        "startIndex": 0,
        "preview": "Distributed Messaging\nOverview\nDistributed Messaging enables reliable communication between services in a microservices architecture. Whizbang provide..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/usage-patterns/event-sourcing-basics",
    "title": "Event Sourcing Basics",
    "category": "Usage Patterns",
    "url": "/docs/old-v1.0.0/usage-patterns/event-sourcing-basics",
    "chunks": [
      {
        "id": "old-v1.0.0/usage-patterns/event-sourcing-basics-chunk-0",
        "text": "Event Sourcing Basics\nOverview\nEvent Sourcing is a powerful pattern where instead of storing the current state of your domain objects, you store the sequence of events that led to that state Whizbang makes event sourcing approachable and practical for NET applications What is Event Sourcing Instead of updating a record in place, event sourcing:\nCaptures every state change as an immutable event\nStores events in an append-only log\nRebuilds current state by replaying events\nProvides a complete audit trail and time-travel capabilities\nWhen to Use Event Sourcing\nEvent sourcing is ideal when you need:\nComplete audit trails - Every change is recorded with who, what, when\nTime travel - Ability to see state at any point in time\nEvent replay - Rebuild state, fix bugs, or create new projections\nComplex workflows - Track multi-step processes with compensation\nCompliance - Immutable history for regulatory requirements\nArchitecture Diagram\n`mermaid\nsequenceDiagram\n    participant API as API Controller\n    participant M as Mediator\n    participant H as Command Handler\n    participant A as Aggregate\n    participant R as Repository\n    participant ES as Event Store\n    participant P as Projections\n    API->>M: Send Command\n    M->>H: Route to Handler\n    H->>R: Load Aggregate\n    R->>ES: Read Event Stream\n    ES-->>R: Events\n    R->>A: Rebuild from Events\n    R-->>H: Aggregate\n    H->>A: Execute Command\n    A->>A: Apply Business Rules\n    A->>A: Generate Event(s)\n    H->>R: Save Aggregate\n    R->>ES: Append Events\n    ES->>P: Publish Events\n    P->>P: Update Read Models\n    H-->>API: Command Result\n`\nCore Components\nRequired Packages\n`xml{\ntitle: \"Required NuGet Packages\"\ndescription: \"Core packages needed for event sourcing with Whizbang\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Usage Patterns\", \"Event Sourcing\", \"NuGet Packages\"]\nfilename: \"ProjectFile csproj\"\nshowLineNumbers: true\n}\n<PackageReference Include=\"Whizbang Core\" Version=\"1 0 0\" />\n<PackageReference Include=\"Whizbang EventSourcing\" Version=\"1 0",
        "startIndex": 0,
        "preview": "Event Sourcing Basics\nOverview\nEvent Sourcing is a powerful pattern where instead of storing the current state of your domain objects, you store the s..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/event-sourcing-basics-chunk-1",
        "text": "Core Components Required Packages `xml{ title: \"Required NuGet Packages\" description: \"Core packages needed for event sourcing with Whizbang\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"BEGINNER\" tags: [\"Usage Patterns\", \"Event Sourcing\", \"NuGet Packages\"] filename: \"ProjectFile csproj\" showLineNumbers: true } <PackageReference Include=\"Whizbang Core\" Version=\"1 0 0\" /> <PackageReference Include=\"Whizbang EventSourcing\" Version=\"1 0 0\" />\n`\nKey Concepts\nEvent - Immutable record of something that happened\nAggregate - Domain object that enforces business rules\nEvent Stream - Ordered sequence of events for an aggregate\nEvent Store - Database optimized for append-only event storage\nSnapshot - Periodic state capture to optimize replay\nStep-by-Step Implementation\nStep 1: Define Your Events\n`csharp{\ntitle: \"Event Definitions\"\ndescription: \"Define domain events that represent state changes\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Events\", \"Domain Events\", \"Event Sourcing\"]\nnugetPackages: [\"Whizbang EventSourcing\"]\nfilename: \"OrderEvents cs\"\nshowLineNumbers: true\nhighlightLines: [10, 19, 27]\nusingStatements: [\"Whizbang EventSourcing\", \"System\"]\n}\nusing Whizbang EventSourcing;\nusing System;\nusing System Collections Generic;\nnamespace MyApp Orders",
        "startIndex": 2066,
        "preview": "Core Components Required Packages `xml{ title: \"Required NuGet Packages\" description: \"Core packages needed for event sourcing with Whizbang\" framewor..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/event-sourcing-basics-chunk-2",
        "text": "description: \"Define domain events that represent state changes\" framework: \"NET8\" category: \"Event Sourcing\" difficulty: \"INTERMEDIATE\" tags: [\"Events\", \"Domain Events\", \"Event Sourcing\"] nugetPackages: [\"Whizbang EventSourcing\"] filename: \"OrderEvents cs\" showLineNumbers: true highlightLines: [10, 19, 27] usingStatements: [\"Whizbang EventSourcing\", \"System\"] } using Whizbang EventSourcing; using System; using System Collections Generic; namespace MyApp Orders Events;\n// Base event with common metadata\npublic abstract record OrderEvent : DomainEvent;\n// Event: Order was created\npublic record OrderCreated(\n    Guid OrderId,\n    Guid CustomerId,\n    List<OrderItem> Items,\n    decimal TotalAmount,\n    string ShippingAddress,\n    DateTime CreatedAt\n) : OrderEvent;\n// Event: Item was added to order\npublic record OrderItemAdded(\n    Guid OrderId,\n    OrderItem Item,\n    decimal NewTotalAmount\n) : OrderEvent;\n// Event: Order was shipped\npublic record OrderShipped(\n    Guid OrderId,\n    string TrackingNumber,\n    string Carrier,\n    DateTime ShippedAt\n) : OrderEvent;\n// Event: Order was cancelled\npublic record OrderCancelled(\n    Guid OrderId,\n    string Reason,\n    DateTime CancelledAt\n) : OrderEvent;\n// Value objects\npublic record OrderItem(\n    string ProductId,\n    string ProductName,\n    int Quantity,\n    decimal UnitPrice\n);\n`\nStep 2: Create Your Aggregate\n`csharp{\ntitle: \"Aggregate Implementation\"\ndescription: \"Build an aggregate that applies events and enforces business rules\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aggregate\", \"Domain Model\", \"Business Rules\"]\nnugetPackages: [\"Whizbang EventSourcing\"]\nfilename: \"OrderAggregate cs\"\nshowLineNumbers: true\nhighlightLines: [25, 44, 67, 82]\nusingStatements: [\"Whizbang EventSourcing\", \"System\", \"System Collections Generic\"]\n}\nusing Whizbang EventSourcing;\nusing System;\nusing System Collections Generic;\nusing System Linq;\nusing MyApp Orders Events;\nnamespace MyApp Orders Aggregates;\npublic class OrderAggregate : Aggregate {\n    // Current state (rebuilt from events)\n    public Guid CustomerId { get; private set; }\n    public List<OrderItem> Items { get; private set; } = new();\n    public decimal TotalAmount { get; private set; }\n    public string ShippingAddress { get; private set; }\n    public OrderStatus Status { get; private set; }\n    public string TrackingNumber { get; private set; }\n    public DateTime",
        "startIndex": 2926,
        "preview": "description: \"Define domain events that represent state changes\" framework: \"NET8\" category: \"Event Sourcing\" difficulty: \"INTERMEDIATE\" tags: [\"Event..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/event-sourcing-basics-chunk-3",
        "text": "CustomerId { get; private set; } public List<OrderItem> Items { get; private set; } = new(); public decimal TotalAmount { get; private set; } public string ShippingAddress { get; private set; } public OrderStatus Status { get; private set; } public string TrackingNumber { get; private set; } public DateTime ShippedAt { get; private set; }\n    // Constructor for existing aggregate (loaded from events)\n    public OrderAggregate() { }\n    // Constructor for new aggregate\n    public OrderAggregate(Guid orderId, Guid customerId, List<OrderItem> items, string shippingAddress) {\n        if (items == null || items Any()) {\n            throw new DomainException(\"Order must have at least one item\");\n        }\n        var totalAmount = items Sum(i => i Quantity * i UnitPrice);\n        // Apply event (this both raises it and updates our state)\n        Apply(new OrderCreated(\n            orderId,\n            customerId,\n            items,\n            totalAmount,\n            shippingAddress,\n            DateTime UtcNow\n        ));\n    }\n    // Command: Add item to order\n    public void AddItem(OrderItem item) {\n        if (Status = OrderStatus Pending) {\n            throw new DomainException($\"Cannot add items to {Status} order\");\n        }\n        if (item Quantity <= 0) {\n            throw new DomainException(\"Quantity must be positive\");\n        }\n        var newTotal = TotalAmount + (item Quantity * item UnitPrice);\n        Apply(new OrderItemAdded(Id, item, newTotal));\n    }\n    // Command: Ship the order\n    public void Ship(string trackingNumber, string carrier) {\n        if (Status = OrderStatus Pending) {\n            throw new DomainException($\"Cannot ship order in {Status} status\");\n        }\n        if (string IsNullOrEmpty(trackingNumber)) {\n            throw new DomainException(\"Tracking number is required\");\n        }\n        Apply(new OrderShipped(Id, trackingNumber, carrier, DateTime UtcNow));\n    }\n    // Command: Cancel the order\n    public void Cancel(string reason) {\n        if (Status == OrderStatus Shipped) {\n            throw new DomainException(\"Cannot cancel shipped order\");\n        }\n        if (Status == OrderStatus Cancelled) {\n            return; // Idempotent\n        }\n        Apply(new OrderCancelled(Id, reason, DateTime UtcNow));\n    }\n    // Event handlers - Update state when events are applied\n    protected void When(OrderCreated @event) {\n        Id = @event OrderId;\n        CustomerId = @event CustomerId;\n        Items = @event Items",
        "startIndex": 4896,
        "preview": "CustomerId { get; private set; } public List<OrderItem> Items { get; private set; } = new(); public decimal TotalAmount { get; private set; } public s..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/event-sourcing-basics-chunk-4",
        "text": "throw new DomainException(\"Cannot cancel shipped order\"); } if (Status == OrderStatus Cancelled) { return; // Idempotent } Apply(new OrderCancelled(Id, reason, DateTime UtcNow)); } // Event handlers - Update state when events are applied protected void When(OrderCreated @event) { Id = @event OrderId; CustomerId = @event CustomerId; Items = @event Items ToList();\n        TotalAmount = @event TotalAmount;\n        ShippingAddress = @event ShippingAddress;\n        Status = OrderStatus Pending;\n    }\n    protected void When(OrderItemAdded @event) {\n        Items Add(@event Item);\n        TotalAmount = @event NewTotalAmount;\n    }\n    protected void When(OrderShipped @event) {\n        Status = OrderStatus Shipped;\n        TrackingNumber = @event TrackingNumber;\n        ShippedAt = @event ShippedAt;\n    }\n    protected void When(OrderCancelled @event) {\n        Status = OrderStatus Cancelled;\n    }\n}\npublic enum OrderStatus {\n    Pending,\n    Shipped,\n    Delivered,\n    Cancelled\n}\n`\nStep 3: Implement Command Handlers\n`csharp{\ntitle: \"Event-Sourced Command Handler\"\ndescription: \"Command handlers that work with aggregates and event stores\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Command Handler\", \"Event Store\", \"Repository\"]\nnugetPackages: [\"Whizbang EventSourcing\"]\nfilename: \"CreateOrderHandler cs\"\nshowLineNumbers: true\nhighlightLines: [20, 25, 28]\nusingStatements: [\"Whizbang EventSourcing\", \"System\", \"System Threading Tasks\"]\n}\nusing Whizbang EventSourcing;\nusing System;\nusing System Threading;\nusing System Threading Tasks;\nusing MyApp Orders Aggregates;\nusing MyApp Orders Commands;\nnamespace MyApp Orders Handlers;\npublic class CreateOrderHandler : ICommandHandler<CreateOrderCommand, OrderCreatedResult> {\n    private readonly IAggregateRepository<OrderAggregate> _repository;\n    private readonly IInventoryService _inventoryService;\n    public CreateOrderHandler(\n        IAggregateRepository<OrderAggregate> repository,\n        IInventoryService inventoryService) {\n        _repository = repository;\n        _inventoryService = inventoryService;\n    }\n    public async Task<OrderCreatedResult> Handle(\n        CreateOrderCommand command,\n        CancellationToken cancellationToken) {\n        // Check inventory before creating order\n        await _inventoryService ValidateAvailability(command Items, cancellationToken);\n        // Create new aggregate (generates OrderCreated event)\n        var orderId = Guid NewGuid();\n        var order = new OrderAggregate(\n            orderId,\n            command CustomerId,\n            command Items,\n            command ShippingAddress\n        );\n        // Save aggregate (persists events to event store)\n        await _repository SaveAsync(order, cancellationToken);\n        // Reserve inventory (side effect after event is saved)\n        await _inventoryService ReserveItems(orderId, command Items, cancellationToken);\n        return new OrderCreatedResult(\n            orderId,\n            order",
        "startIndex": 7091,
        "preview": "throw new DomainException(\"Cannot cancel shipped order\"); } if (Status == OrderStatus Cancelled) { return; // Idempotent } Apply(new OrderCancelled(Id..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/event-sourcing-basics-chunk-5",
        "text": "var orderId = Guid NewGuid(); var order = new OrderAggregate( orderId, command CustomerId, command Items, command ShippingAddress ); // Save aggregate (persists events to event store) await _repository SaveAsync(order, cancellationToken); // Reserve inventory (side effect after event is saved) await _inventoryService ReserveItems(orderId, command Items, cancellationToken); return new OrderCreatedResult( orderId, order TotalAmount,\n            EstimateDelivery(command ShippingAddress)\n        );\n    }\n    private DateTime EstimateDelivery(string address) {\n        // Simple estimation logic\n        return DateTime UtcNow AddDays(3);\n    }\n}\npublic class ShipOrderHandler : ICommandHandler<ShipOrderCommand, ShipmentResult> {\n    private readonly IAggregateRepository<OrderAggregate> _repository;\n    private readonly IShippingService _shippingService;\n    public ShipOrderHandler(\n        IAggregateRepository<OrderAggregate> repository,\n        IShippingService shippingService) {\n        _repository = repository;\n        _shippingService = shippingService;\n    }\n    public async Task<ShipmentResult> Handle(\n        ShipOrderCommand command,\n        CancellationToken cancellationToken) {\n        // Load aggregate from event store\n        var order = await _repository GetByIdAsync(command OrderId, cancellationToken);\n        if (order == null) {\n            throw new NotFoundException($\"Order {command OrderId} not found\");\n        }\n        // Request shipment\n        var shipment = await _shippingService CreateShipment(\n            order Id,\n            order ShippingAddress,\n            cancellationToken\n        );\n        // Apply ship command to aggregate (generates OrderShipped event)\n        order Ship(shipment TrackingNumber, shipment Carrier);\n        // Save aggregate (appends new event to stream)\n        await _repository SaveAsync(order, cancellationToken);\n        return new ShipmentResult(\n            shipment TrackingNumber,\n            shipment Carrier,\n            shipment EstimatedDelivery\n        );\n    }\n}\n`\nStep 4: Configure Event Store\n`csharp{\ntitle: \"Event Store Configuration\"\ndescription: \"Configure Whizbang with event sourcing and storage\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Configuration\", \"Event Store\", \"PostgreSQL\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang PostgreSQL\"]\nfilename: \"Program cs\"\nshowLineNumbers: true\nhighlightLines: [9, 14, 19]\nusingStatements: [\"Whizbang EventSourcing\", \"Microsoft Extensions DependencyInjection\"]\n}\nusing Whizbang EventSourcing;\nusing Microsoft AspNetCore Builder;\nusing Microsoft Extensions DependencyInjection;\nusing MyApp Orders Handlers;\nvar builder = WebApplication CreateBuilder(args);\n// Configure Whizbang with event sourcing\nbuilder Services AddWhizbang(config => {\n    // Use event sourcing with PostgreSQL\n    config UseEventSourcing(options => {\n        options UsePostgreSQL(builder Configuration GetConnectionString(\"EventStore\"));\n        // Configure snapshots (optional optimization)\n        options EnableSnapshots(snapshot => {\n            snapshot",
        "startIndex": 9745,
        "preview": "var orderId = Guid NewGuid(); var order = new OrderAggregate( orderId, command CustomerId, command Items, command ShippingAddress ); // Save aggregate..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/event-sourcing-basics-chunk-6",
        "text": "AspNetCore Builder; using Microsoft Extensions DependencyInjection; using MyApp Orders Handlers; var builder = WebApplication CreateBuilder(args); // Configure Whizbang with event sourcing builder Services AddWhizbang(config => { // Use event sourcing with PostgreSQL config UseEventSourcing(options => { options UsePostgreSQL(builder Configuration GetConnectionString(\"EventStore\")); // Configure snapshots (optional optimization) options EnableSnapshots(snapshot => { snapshot Frequency = 10; // Create snapshot every 10 events\n            snapshot KeepSnapshots = 3; // Keep last 3 snapshots\n        });\n        // Configure event serialization\n        options UseJsonSerialization(json => {\n            json UseSystemTextJson();\n            json IncludeTypeInformation = true;\n        });\n    });\n    // Register handlers\n    config RegisterHandlersFromAssembly(typeof(Program) Assembly);\n    // Add projections (read models)\n    config RegisterProjectionsFromAssembly(typeof(Program) Assembly);\n});\n// Register domain services\nbuilder Services AddScoped<IInventoryService, InventoryService>();\nbuilder Services AddScoped<IShippingService, ShippingService>();\nbuilder Services AddControllers();\nvar app = builder Build();\n// Initialize event store schema\nawait app InitializeEventStore();\napp UseRouting();\napp MapControllers();\napp Run();\n`\nComplete Example\n`csharp{\ntitle: \"Complete Event Sourcing Example\"\ndescription: \"Full working example showing event sourcing from API to persistence\"\nframework: \"NET8\"\ncategory: \"Complete Example\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Event Sourcing\", \"Complete\", \"API\", \"Aggregate\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Microsoft AspNetCore Mvc\"]\nfilename: \"EventSourcedOrdersController cs\"\nshowLineNumbers: true\nhighlightLines: [22, 35, 50, 68]\ntestFile: \"EventSourcedOrdersTests cs\"\ntestMethod: \"CreateOrder_StoresEvents_AndRebuildsState\"\nusingStatements: [\"Whizbang EventSourcing\", \"Microsoft AspNetCore Mvc\", \"System Threading Tasks\"]\n}\nusing Whizbang EventSourcing;\nusing Microsoft AspNetCore Mvc;\nusing System;\nusing System Threading;\nusing System Threading Tasks;\nusing MyApp Orders Commands;\nusing MyApp Orders Queries;\nnamespace MyApp Controllers;\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class OrdersController : ControllerBase {\n    private readonly IMediator _mediator;\n    private readonly IEventStore _eventStore;\n    public OrdersController(IMediator mediator, IEventStore eventStore) {\n        _mediator = mediator;\n        _eventStore = eventStore;\n    }\n    [HttpPost]\n    public async Task<ActionResult<OrderCreatedResult>> CreateOrder(\n        [FromBody] CreateOrderRequest request,\n        CancellationToken cancellationToken) {\n        var command = new CreateOrderCommand(\n            request CustomerId,\n            request Items,\n            request ShippingAddress\n        );\n        var result = await _dispatcher Send(command, cancellationToken);\n        return CreatedAtAction(\n            nameof(GetOrder),\n            new { orderId = result",
        "startIndex": 12439,
        "preview": "AspNetCore Builder; using Microsoft Extensions DependencyInjection; using MyApp Orders Handlers; var builder = WebApplication CreateBuilder(args); // ..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/event-sourcing-basics-chunk-7",
        "text": "OrdersController(IMediator mediator, IEventStore eventStore) { _mediator = mediator; _eventStore = eventStore; } [HttpPost] public async Task<ActionResult<OrderCreatedResult>> CreateOrder( [FromBody] CreateOrderRequest request, CancellationToken cancellationToken) { var command = new CreateOrderCommand( request CustomerId, request Items, request ShippingAddress ); var result = await _dispatcher Send(command, cancellationToken); return CreatedAtAction( nameof(GetOrder), new { orderId = result OrderId },\n            result\n        );\n    }\n    [HttpPost(\"{orderId}/ship\")]\n    public async Task<ActionResult<ShipmentResult>> ShipOrder(\n        Guid orderId,\n        [FromBody] ShipOrderRequest request,\n        CancellationToken cancellationToken) {\n        var command = new ShipOrderCommand(orderId, \"\", \"\"); // TODO: Get tracking details\n        var result = await _dispatcher Send(command, cancellationToken);\n        return Ok(result);\n    }\n    [HttpGet(\"{orderId}\")]\n    public async Task<ActionResult<OrderDetails>> GetOrder(\n        Guid orderId,\n        CancellationToken cancellationToken) {\n        // Query uses projection (read model)\n        var query = new GetOrderByIdQuery(orderId);\n        var result = await _mediator Send(query, cancellationToken);\n        if (result == null) {\n            return NotFound();\n        }\n        return Ok(result);\n    }\n    [HttpGet(\"{orderId}/history\")]\n    public async Task<ActionResult<OrderHistory>> GetOrderHistory(\n        Guid orderId,\n        CancellationToken cancellationToken) {\n        // Get all events for this aggregate\n        var events = await _eventStore GetEvents(\n            $\"Order-{orderId}\",\n            cancellationToken\n        );\n        // Map events to history entries\n        var history = events Select(e => new HistoryEntry {\n            EventType = e GetType() Name,\n            OccurredAt = e OccurredAt,\n            Data = e,\n            Version = e Version\n        }) ToList();\n        return Ok(new OrderHistory {\n            OrderId = orderId,\n            Events = history,\n            CurrentVersion = events LastOrDefault() Version 0\n        });\n    }\n    [HttpGet(\"{orderId}/at/{timestamp}\")]\n    public async Task<ActionResult<OrderSnapshot>> GetOrderAtPointInTime(\n        Guid orderId,\n        DateTime timestamp,\n        CancellationToken cancellationToken) {\n        // Replay events up to specific point in time\n        var events = await _eventStore GetEvents(\n            $\"Order-{orderId}\",\n            upTo: timestamp,\n            cancellationToken\n        );\n        // Rebuild aggregate state at that point\n        var aggregate = new OrderAggregate();\n        aggregate LoadFromHistory(events);\n        return Ok(new OrderSnapshot {\n            OrderId = orderId,\n            AsOf = timestamp,\n            State = aggregate,\n            Version = events LastOrDefault() Version",
        "startIndex": 14992,
        "preview": "OrdersController(IMediator mediator, IEventStore eventStore) { _mediator = mediator; _eventStore = eventStore; } [HttpPost] public async Task<ActionRe..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/event-sourcing-basics-chunk-8",
        "text": "events up to specific point in time var events = await _eventStore GetEvents( $\"Order-{orderId}\", upTo: timestamp, cancellationToken ); // Rebuild aggregate state at that point var aggregate = new OrderAggregate(); aggregate LoadFromHistory(events); return Ok(new OrderSnapshot { OrderId = orderId, AsOf = timestamp, State = aggregate, Version = events LastOrDefault() Version 0\n        });\n    }\n}\n`\nTesting Strategy\nTesting Aggregates\n`csharp{\ntitle: \"Aggregate Unit Tests\"\ndescription: \"Test aggregate behavior and event generation\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Unit Testing\", \"Aggregates\", \"Events\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"xUnit\"]\nfilename: \"OrderAggregateTests cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang EventSourcing\", \"Xunit\", \"System\"]\n}\nusing Whizbang EventSourcing;\nusing Xunit;\nusing System;\nusing System Collections Generic;\nusing System Linq;\nusing MyApp Orders Aggregates;\nusing MyApp Orders Events;\nnamespace MyApp Tests Orders;\npublic class OrderAggregateTests {\n    [Fact]\n    public void Constructor_ValidOrder_GeneratesOrderCreatedEvent() {\n        // Arrange\n        var orderId = Guid NewGuid();\n        var customerId = Guid NewGuid();\n        var items = new List<OrderItem> {\n            new OrderItem(\"PROD-1\", \"Widget\", 2, 10 00m)\n        };\n        // Act\n        var aggregate = new OrderAggregate(orderId, customerId, items, \"123 Main St\");\n        // Assert\n        var events = aggregate GetUncommittedEvents();\n        Assert Single(events);\n        var createdEvent = Assert IsType<OrderCreated>(events First());\n        Assert Equal(orderId, createdEvent OrderId);\n        Assert Equal(customerId, createdEvent CustomerId);\n        Assert Equal(20 00m, createdEvent TotalAmount);\n    }\n    [Fact]\n    public void Ship_ValidOrder_GeneratesOrderShippedEvent() {\n        // Arrange\n        var aggregate = CreateTestAggregate();\n        // Act\n        aggregate Ship(\"TRACK123\", \"FedEx\");\n        // Assert\n        var events = aggregate GetUncommittedEvents();\n        var shippedEvent = Assert IsType<OrderShipped>(events Last());\n        Assert Equal(\"TRACK123\", shippedEvent TrackingNumber);\n        Assert Equal(OrderStatus Shipped, aggregate Status);\n    }\n    [Fact]\n    public void Cancel_ShippedOrder_ThrowsException() {\n        // Arrange\n        var aggregate = CreateTestAggregate();\n        aggregate Ship(\"TRACK123\", \"FedEx\");\n        aggregate MarkEventsAsCommitted();\n        // Act & Assert\n        var exception = Assert Throws<DomainException>(\n            () => aggregate Cancel(\"Customer request\")\n        );\n        Assert Contains(\"Cannot cancel shipped order\", exception Message);\n    }\n    [Fact]\n    public void LoadFromHistory_RebuildsState() {\n        // Arrange\n        var orderId = Guid NewGuid();\n        var events = new List<DomainEvent> {\n            new OrderCreated(\n                orderId,\n                Guid",
        "startIndex": 17395,
        "preview": "events up to specific point in time var events = await _eventStore GetEvents( $\"Order-{orderId}\", upTo: timestamp, cancellationToken ); // Rebuild agg..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/event-sourcing-basics-chunk-9",
        "text": "aggregate Ship(\"TRACK123\", \"FedEx\"); aggregate MarkEventsAsCommitted(); // Act & Assert var exception = Assert Throws<DomainException>( () => aggregate Cancel(\"Customer request\") ); Assert Contains(\"Cannot cancel shipped order\", exception Message); } [Fact] public void LoadFromHistory_RebuildsState() { // Arrange var orderId = Guid NewGuid(); var events = new List<DomainEvent> { new OrderCreated( orderId, Guid NewGuid(),\n                new List<OrderItem> { new OrderItem(\"P1\", \"Widget\", 1, 10 00m) },\n                10 00m,\n                \"123 Main St\",\n                DateTime UtcNow\n            ),\n            new OrderItemAdded(\n                orderId,\n                new OrderItem(\"P2\", \"Gadget\", 2, 5 00m),\n                20 00m\n            ),\n            new OrderShipped(\n                orderId,\n                \"TRACK123\",\n                \"UPS\",\n                DateTime UtcNow\n            )\n        };\n        // Act\n        var aggregate = new OrderAggregate();\n        aggregate LoadFromHistory(events);\n        // Assert\n        Assert Equal(orderId, aggregate Id);\n        Assert Equal(2, aggregate Items Count);\n        Assert Equal(20 00m, aggregate TotalAmount);\n        Assert Equal(OrderStatus Shipped, aggregate Status);\n        Assert Equal(\"TRACK123\", aggregate TrackingNumber);\n    }\n    private OrderAggregate CreateTestAggregate() {\n        return new OrderAggregate(\n            Guid NewGuid(),\n            Guid NewGuid(),\n            new List<OrderItem> { new OrderItem(\"P1\", \"Widget\", 1, 10 00m) },\n            \"123 Main St\"\n        );\n    }\n}\n`\nCommon Pitfalls\nDon't Modify Events After Creation\n`csharp{\ntitle: \"Don't Modify Events After Creation\"\ndescription: \"Events must be immutable - create new events with correct data instead\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Usage Patterns\", \"Event Sourcing\", \"Immutability\", \"Best Practices\"]\nfilename: \"ImmutableEvents cs\"\nshowLineNumbers: true\nusingStatements: [\"System\"]\n}\n// ❌ BAD - Events are immutable\nvar @event = new OrderCreated( );\n@event TotalAmount = 100; // Compiler error - records are immutable\n// ✅ GOOD - Create new event with correct data\nvar @event = new OrderCreated( , TotalAmount: 100, );\n`\nAvoid Side Effects in Event Handlers\n`csharp{\ntitle: \"Avoid Side Effects in Event Handlers\"\ndescription: \"Keep event handlers pure - only update state, no side effects\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"Event Sourcing\", \"Pure Functions\", \"Best Practices\"]\nfilename: \"PureEventHandlers",
        "startIndex": 19974,
        "preview": "aggregate Ship(\"TRACK123\", \"FedEx\"); aggregate MarkEventsAsCommitted(); // Act & Assert var exception = Assert Throws<DomainException>( () => aggregat..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/event-sourcing-basics-chunk-10",
        "text": "OrderCreated( , TotalAmount: 100, ); ` Avoid Side Effects in Event Handlers `csharp{ title: \"Avoid Side Effects in Event Handlers\" description: \"Keep event handlers pure - only update state, no side effects\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"INTERMEDIATE\" tags: [\"Usage Patterns\", \"Event Sourcing\", \"Pure Functions\", \"Best Practices\"] filename: \"PureEventHandlers cs\"\nshowLineNumbers: true\nusingStatements: [\"System\"]\n}\n// ❌ BAD - Side effects in When method\nprotected void When(OrderShipped @event) {\n    Status = OrderStatus Shipped;\n    EmailService SendNotification( ); // NO Side effects don't belong here\n}\n// ✅ GOOD - Pure state updates only\nprotected void When(OrderShipped @event) {\n    Status = OrderStatus Shipped;\n    TrackingNumber = @event TrackingNumber;\n}\n`\nDon't Query in Receptors\n`csharp{\ntitle: \"Don't Query in Receptors\"\ndescription: \"Keep receptors pure by avoiding external queries - use lenses or pass data in commands\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Usage Patterns\", \"Event Sourcing\", \"Receptors\", \"Pure Functions\"]\nfilename: \"PureReceptors cs\"\nshowLineNumbers: true\nusingStatements: [\"System\", \"System Threading Tasks\"]\n}\n// ❌ BAD - Receptor querying external data\npublic class OrderReceptor : IReceptor<ShipOrderCommand> {\n    public async Task<OrderShipped> Receive(ShipOrderCommand cmd) {\n        var inventory = await _inventoryService Check(); // NO Receptors should be pure\n    }\n}\n// ✅ GOOD - Use lenses for validation or pass data in command\npublic OrderShipped Receive(ShipOrderCommand cmd, IInventoryLens lens) {\n    if ( lens IsAvailable(cmd OrderId)) {\n        throw new DomainException(\"Insufficient inventory\");\n    }\n    return new OrderShipped( );\n}\n`\nProgressive Enhancement\nAdd Snapshots for Performance\n`csharp{\ntitle: \"Add Snapshots for Performance\"\ndescription: \"Implement snapshots to optimize event replay for aggregates with many events\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Usage Patterns\", \"Event Sourcing\", \"Snapshots\", \"Performance\"]\nfilename: \"SnapshotOptimization cs\"\nshowLineNumbers: true\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq\"]\n}\n// Configure snapshot strategy\nledger EnableSnapshots(snapshot => {\n    snapshot Frequency = 10; // Every 10 events\n    snapshot",
        "startIndex": 22157,
        "preview": "OrderCreated( , TotalAmount: 100, ); ` Avoid Side Effects in Event Handlers `csharp{ title: \"Avoid Side Effects in Event Handlers\" description: \"Keep ..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/event-sourcing-basics-chunk-11",
        "text": "replay for aggregates with many events\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"ADVANCED\" tags: [\"Usage Patterns\", \"Event Sourcing\", \"Snapshots\", \"Performance\"] filename: \"SnapshotOptimization cs\" showLineNumbers: true usingStatements: [\"System\", \"System Collections Generic\", \"System Linq\"] } // Configure snapshot strategy ledger EnableSnapshots(snapshot => { snapshot Frequency = 10; // Every 10 events snapshot Strategy = SnapshotStrategy Automatic;\n});\n// Implement snapshot interface on receptor\n[EventSourced]\npublic class OrderReceptor : IReceptor<CreateOrderCommand>, ISnapshotable {\n    // receptor implementation public Snapshot TakeSnapshot() {\n        return new OrderSnapshot {\n            Id = id,\n            CustomerId = customerId,\n            Items = items ToList(),\n            Status = status,\n            Version = GetVersion()\n        };\n    }\n    public void RestoreFromSnapshot(Snapshot snapshot) {\n        var orderSnapshot = (OrderSnapshot)snapshot;\n        id = orderSnapshot Id;\n        customerId = orderSnapshot CustomerId;\n        items = orderSnapshot Items;\n        status = orderSnapshot Status;\n        SetVersion(orderSnapshot Version);\n    }\n}\n`\nAdd Perspectives for Queries\nSee Perspectives Documentation for detailed perspective patterns Scale with Event Streams\n`csharp{\ntitle: \"Scale with Event Streams\"\ndescription: \"Configure multiple event streams for better performance and scalability\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Usage Patterns\", \"Event Sourcing\", \"Scaling\", \"Streams\"]\nfilename: \"EventStreamScaling cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Configure multiple streams\ndispatcher UseEventSourcing(es => {\n    es UseLedger(ledger => {\n        ledger ConfigureStreams(streams => {\n            streams PartitionBy<OrderReceptor>(r => r CustomerId);\n            streams EnableParallelProcessing(maxDegree: 4);\n        });\n    });\n});\n`\nRelated Patterns\nEvent-Driven Dispatcher Pattern - Start without event sourcing\nPerspectives Documentation - Optimize reads with multiple views\nSaga Orchestration - Coordinate multi-receptor workflows\nProduction Considerations\nEvent Schema Evolution\n`csharp{\ntitle: \"Event Schema Evolution\"\ndescription: \"Version your events and provide migration logic for schema changes\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Usage Patterns\", \"Event Sourcing\", \"Schema Evolution\", \"Versioning\"]\nfilename: \"EventVersioning cs\"\nshowLineNumbers: true\nusingStatements: [\"System\"]\n}\n// Version your events\npublic record OrderCreatedV2(\n    // New fields",
        "startIndex": 24133,
        "preview": "replay for aggregates with many events\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"ADVANCED\" tags: [\"Usage Patterns\", \"Event Sourcing\",..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/event-sourcing-basics-chunk-12",
        "text": "Evolution `csharp{ title: \"Event Schema Evolution\" description: \"Version your events and provide migration logic for schema changes\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"ADVANCED\" tags: [\"Usage Patterns\", \"Event Sourcing\", \"Schema Evolution\", \"Versioning\"] filename: \"EventVersioning cs\" showLineNumbers: true usingStatements: [\"System\"] } // Version your events public record OrderCreatedV2( // New fields ) : OrderEvent, IUpgradeFrom<OrderCreated> {\n    public OrderCreatedV2 UpgradeFrom(OrderCreated old) {\n        // Migration logic\n    }\n}\n`\nEvent Store Maintenance\nRegular backups of event store\nMonitor stream sizes\nArchive old events if needed\nIndex frequently queried streams\nPerformance Optimization\nUse snapshots for aggregates with many events\nImplement caching for frequently accessed aggregates\nConsider async projections for read models\nMonitor event replay times\nNext Steps\nLearn about Perspectives for read model optimization\nExplore Saga Orchestration for complex workflows\nReview Receptors Documentation for advanced patterns\nCheck out Lenses for building query interfaces",
        "startIndex": 26363,
        "preview": "Evolution `csharp{ title: \"Event Schema Evolution\" description: \"Version your events and provide migration logic for schema changes\" framework: \"NET8\"..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/usage-patterns/microservices-integration",
    "title": "Microservices Integration",
    "category": "Usage Patterns",
    "url": "/docs/old-v1.0.0/usage-patterns/microservices-integration",
    "chunks": [
      {
        "id": "old-v1.0.0/usage-patterns/microservices-integration-chunk-0",
        "text": "Microservices Integration\nOverview\nWhizbang provides first-class support for building microservices with NET Aspire, Microsoft's opinionated stack for cloud-native applications This pattern shows how to structure, deploy, and operate Whizbang-based microservices in production Key Components\nService Boundaries: Define bounded contexts and aggregates NET Aspire Integration: Orchestration and observability\nService Discovery: Automatic service registration and discovery\nHealth Monitoring: Liveness and readiness probes\nDistributed Tracing: End-to-end request tracking\nArchitecture Diagram\n`mermaid\ngraph TB\n    subgraph \"API Gateway\"\n        GW[Gateway]\n    end\n    subgraph \"Order Service\"\n        OS[Order API]\n        OE[(Event Store)]\n        OP[Projections]\n    end\n    subgraph \"Inventory Service\"\n        IS[Inventory API]\n        IE[(Event Store)]\n        IP[Projections]\n    end\n    subgraph \"Payment Service\"\n        PS[Payment API]\n        PE[(Event Store)]\n        PP[Projections]\n    end\n    subgraph \"Infrastructure\"\n        SD[Service Discovery]\n        MB[Message Broker]\n        TR[Tracing]\n    end\n    GW --> OS\n    GW --> IS\n    GW --> PS\n    OS - -> MB\n    IS - -> MB\n    PS - -> MB\n    OS --> SD\n    IS --> SD\n    PS --> SD\n    style MB fill:#0066cc,color:#fff\n    style SD fill:#28a745,color:#fff\n`\nImplementation Guide\nDocumentation in progress - This page demonstrates the structure for microservices integration patterns with Whizbang Topics to Cover:\nService Design\nBounded context definition\nAPI contracts\nEvent contracts\nShared kernels NET Aspire Setup\nApp host configuration\nService registration\nResource provisioning\nEnvironment configuration\nService Communication\nSynchronous HTTP calls\nAsynchronous messaging\ngRPC integration\nCircuit breakers\nData Management\nDatabase per service\nEvent store partitioning\nCross-service queries\nData consistency\nDeployment Strategies\nKubernetes deployment\nContainer orchestration\nBlue-green deployments\nCanary releases\nExample: Aspire Configuration\n`csharp{\ntitle: \"Aspire App Host Configuration\"\ndescription: \"Placeholder for NET Aspire distributed application setup\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Aspire\", \"Microservices\", \"Distributed Applications\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions Hosting\"]\n}\n// Placeholder for Aspire app host configuration\nvar builder = DistributedApplication",
        "startIndex": 0,
        "preview": "Microservices Integration\nOverview\nWhizbang provides first-class support for building microservices with NET Aspire, Microsoft's opinionated stack for..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/microservices-integration-chunk-1",
        "text": "Canary releases Example: Aspire Configuration `csharp{ title: \"Aspire App Host Configuration\" description: \"Placeholder for NET Aspire distributed application setup\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"ADVANCED\" tags: [\"Aspire\", \"Microservices\", \"Distributed Applications\"] filename: \"Program cs\" usingStatements: [\"Microsoft Extensions Hosting\"] } // Placeholder for Aspire app host configuration var builder = DistributedApplication CreateBuilder(args);\n// Service configuration coming soon\n`\nRelated Patterns\nDistributed Messaging - Service communication patterns\nSaga Orchestration - Multi-service workflows\nEvent Sourcing Basics - Service data patterns\nProduction Considerations\nObservability\nDistributed tracing with OpenTelemetry\nCentralized logging with structured logs\nMetrics aggregation and alerting\nService dependency mapping\nResilience\nCircuit breaker patterns\nRetry policies with exponential backoff\nBulkhead isolation\nTimeout configuration\nSecurity\nService-to-service authentication\nAPI gateway security\nSecret management\nNetwork policies\nNext Steps\nReview NET Aspire Integration for setup details\nExplore Advanced Configuration for production settings\nCheck Dashboard Documentation for monitoring",
        "startIndex": 2432,
        "preview": "Canary releases Example: Aspire Configuration `csharp{ title: \"Aspire App Host Configuration\" description: \"Placeholder for NET Aspire distributed app..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/usage-patterns/policy-composition",
    "title": "Policy Composition",
    "category": "Usage Patterns",
    "url": "/docs/old-v1.0.0/usage-patterns/policy-composition",
    "chunks": [
      {
        "id": "old-v1.0.0/usage-patterns/policy-composition-chunk-0",
        "text": "Policy Composition\nOverview\nPolicy Composition in Whizbang allows you to build resilient applications by combining multiple policies like retry, circuit breaker, timeout, and fallback Inspired by Polly's approach but integrated seamlessly with our aspect-oriented architecture Core Concepts\nPolicies as Aspects\nIn Whizbang, resilience policies are first-class aspects that can be composed declaratively:\n`csharp{\ntitle: \"Declarative Policy Composition\"\ndescription: \"Combine multiple resilience policies via attributes\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Policies\", \"Resilience\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"ResilientHandler cs\"\nshowLineNumbers: true\nhighlightLines: [1, 2, 3, 4]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[Retry(3, Backoff = \"exponential\", DelayMs = 100)]\n[CircuitBreaker(Threshold = 5, Duration = \"30s\")]\n[Timeout(Seconds = 10)]\n[Fallback(typeof(OrderFallbackHandler))]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd, IOrderService service) {\n        // This handler is automatically wrapped with:\n        // 1 Exponential backoff retry (3 attempts)\n        // 2 Circuit breaker (opens after 5 failures)\n        // 3 10-second timeout\n        // 4 Fallback handler if all else fails\n        var order = service CreateOrder(cmd);\n        return new OrderCreated(order Id);\n    }\n}\n`\nBasic Policies\nRetry Policy\n`csharp{\ntitle: \"Retry Policy Examples\"\ndescription: \"Different retry strategies for various scenarios\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"BEGINNER\"\ntags: [\"Retry\", \"Resilience\", \"Error Handling\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"RetryExamples cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Simple retry with fixed delay\n[Retry(3, DelayMs = 1000)]\npublic class SimpleRetryHandler : IHandle<ProcessPayment> {\n    public PaymentProcessed Handle(ProcessPayment cmd) {\n        return paymentGateway Process(cmd);\n    }\n}\n// Exponential backoff\n[Retry(5, Backoff = \"exponential\", DelayMs = 100, MaxDelayMs = 10000)]\npublic class ExponentialRetryHandler : IHandle<CallExternalApi> {\n    // Delays: 100ms, 200ms, 400ms, 800ms, 1600ms\n    public ApiResponse Handle(CallExternalApi cmd) {\n        return externalApi",
        "startIndex": 0,
        "preview": "Policy Composition\nOverview\nPolicy Composition in Whizbang allows you to build resilient applications by combining multiple policies like retry, circu..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/policy-composition-chunk-1",
        "text": "1000)] public class SimpleRetryHandler : IHandle<ProcessPayment> { public PaymentProcessed Handle(ProcessPayment cmd) { return paymentGateway Process(cmd); } } // Exponential backoff [Retry(5, Backoff = \"exponential\", DelayMs = 100, MaxDelayMs = 10000)] public class ExponentialRetryHandler : IHandle<CallExternalApi> { // Delays: 100ms, 200ms, 400ms, 800ms, 1600ms public ApiResponse Handle(CallExternalApi cmd) { return externalApi Call(cmd);\n    }\n}\n// Retry only specific exceptions\n[Retry(3, \n    RetryOn = new[] { typeof(TransientException), typeof(TimeoutException) },\n    SkipOn = new[] { typeof(ValidationException) }\n)]\npublic class SelectiveRetryHandler : IHandle<UpdateInventory> {\n    public InventoryUpdated Handle(UpdateInventory cmd) {\n        return inventory Update(cmd);\n    }\n}\n// Retry with jitter to prevent thundering herd\n[Retry(3, Backoff = \"exponential-jitter\", DelayMs = 100)]\npublic class JitteredRetryHandler : IHandle<BulkOperation> {\n    // Adds randomization to prevent synchronized retries\n    public BulkResult Handle(BulkOperation cmd) {\n        return bulkService Process(cmd);\n    }\n}\n`\nCircuit Breaker\n`csharp{\ntitle: \"Circuit Breaker Policy\"\ndescription: \"Prevent cascading failures with circuit breaker pattern\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Circuit Breaker\", \"Resilience\", \"Fault Tolerance\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"CircuitBreakerExamples cs\"\nshowLineNumbers: true\nhighlightLines: [1, 15, 29]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Basic circuit breaker\n[CircuitBreaker(\n    Threshold = 5,           // Open after 5 failures\n    Duration = \"30s\",        // Stay open for 30 seconds\n    SuccessesRequired = 2    // Need 2 successes to close\n)]\npublic class ProtectedHandler : IHandle<CallDownstreamService> {\n    public ServiceResponse Handle(CallDownstreamService cmd) {\n        return downstreamService Call(cmd);\n    }\n}\n// Advanced circuit breaker with sampling\n[CircuitBreaker(\n    SamplingDuration = \"10s\",     // Sample over 10 seconds\n    FailureRate = 0 5,            // Open if 50% of calls fail\n    MinimumThroughput = 10,       // Need at least 10 calls in window\n    Duration = \"60s\"               // Stay open for 60 seconds\n)]\npublic class AdvancedCircuitHandler : IHandle<HighVolumeOperation> {\n    public OperationResult Handle(HighVolumeOperation cmd) {\n        return highVolumeService",
        "startIndex": 2314,
        "preview": "1000)] public class SimpleRetryHandler : IHandle<ProcessPayment> { public PaymentProcessed Handle(ProcessPayment cmd) { return paymentGateway Process(..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/policy-composition-chunk-2",
        "text": "// Sample over 10 seconds FailureRate = 0 5, // Open if 50% of calls fail MinimumThroughput = 10, // Need at least 10 calls in window Duration = \"60s\" // Stay open for 60 seconds )] public class AdvancedCircuitHandler : IHandle<HighVolumeOperation> { public OperationResult Handle(HighVolumeOperation cmd) { return highVolumeService Execute(cmd);\n    }\n}\n// Circuit breaker with custom break condition\n[CircuitBreaker(\n    BreakOn = result => result is ErrorResult { Code: \"CRITICAL\" },\n    Duration = \"120s\"\n)]\npublic class CustomBreakHandler : IHandle<CriticalOperation> {\n    public Result<OperationSuccess> Handle(CriticalOperation cmd) {\n        return criticalService Execute(cmd);\n    }\n}\n`\nTimeout Policy\n`csharp{\ntitle: \"Timeout Policy\"\ndescription: \"Prevent operations from running indefinitely\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"BEGINNER\"\ntags: [\"Timeout\", \"Resilience\", \"Performance\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"TimeoutExamples cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\", \"System Threading\"]\n}\n// Simple timeout\n[Timeout(Seconds = 5)]\npublic class TimeoutHandler : IHandle<LongRunningQuery> {\n    public QueryResult Handle(LongRunningQuery query) {\n        return database ExecuteComplexQuery(query);\n    }\n}\n// Pessimistic timeout (cancels the operation)\n[Timeout(Seconds = 10, Mode = \"pessimistic\")]\npublic class PessimisticTimeoutHandler : IHandle<CancellableOperation> {\n    public async Task<Result> Handle(CancellableOperation cmd, CancellationToken ct) {\n        // Operation receives cancellation token\n        return await longService ExecuteAsync(cmd, ct);\n    }\n}\n// Optimistic timeout (just gives up waiting)\n[Timeout(Seconds = 3, Mode = \"optimistic\")]\npublic class OptimisticTimeoutHandler : IHandle<FireAndForget> {\n    public void Handle(FireAndForget cmd) {\n        // We stop waiting after 3 seconds, but operation continues\n        backgroundService Process(cmd);\n    }\n}\n`\nFallback Policy\n`csharp{\ntitle: \"Fallback Policy\"\ndescription: \"Provide alternative results when primary operation fails\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Fallback\", \"Resilience\", \"Error Recovery\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"FallbackExamples cs\"\nshowLineNumbers: true\nhighlightLines: [1, 12, 23]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Fallback to another handler\n[Fallback(typeof(CachedDataHandler))]\npublic class LiveDataHandler : IHandle<GetProductData> {\n    public ProductData Handle(GetProductData query) {\n        return liveService GetProduct(query",
        "startIndex": 4297,
        "preview": "// Sample over 10 seconds FailureRate = 0 5, // Open if 50% of calls fail MinimumThroughput = 10, // Need at least 10 calls in window Duration = \"60s\"..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/policy-composition-chunk-3",
        "text": "primary operation fails\" framework: \"NET8\" category: \"Resilience\" difficulty: \"INTERMEDIATE\" tags: [\"Fallback\", \"Resilience\", \"Error Recovery\"] nugetPackages: [\"Whizbang Core\"] filename: \"FallbackExamples cs\" showLineNumbers: true highlightLines: [1, 12, 23] usingStatements: [\"Whizbang\", \"System\"] } // Fallback to another handler [Fallback(typeof(CachedDataHandler))] public class LiveDataHandler : IHandle<GetProductData> { public ProductData Handle(GetProductData query) { return liveService GetProduct(query ProductId);\n    }\n}\n// Fallback with inline value\n[Fallback(Value = \"DefaultResponse\")]\npublic class ServiceHandler : IHandle<GetConfiguration> {\n    public string Handle(GetConfiguration query) {\n        return configService Get(query Key);\n    }\n}\n// Fallback with factory method\n[Fallback(Factory = nameof(CreateDefaultOrder))]\npublic class OrderHandler : IHandle<GetOrder> {\n    public Order Handle(GetOrder query) {\n        return orderService Get(query OrderId);\n    }\n    private Order CreateDefaultOrder(GetOrder query) {\n        return new Order { \n            Id = query OrderId, \n            Status = \"Unknown\",\n            Items = new List<OrderItem>()\n        };\n    }\n}\n`\nAdvanced Composition\nPolicy Wrapping\n`csharp{\ntitle: \"Advanced Policy Composition\"\ndescription: \"Combine multiple policies for comprehensive resilience\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"ADVANCED\"\ntags: [\"Policy Composition\", \"Resilience\", \"Advanced\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"AdvancedComposition cs\"\nshowLineNumbers: true\nhighlightLines: [1, 2, 3, 4, 5]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Policies execute in order: Retry -> CircuitBreaker -> Timeout -> Fallback\n[Retry(3, Backoff = \"exponential\")]\n[CircuitBreaker(Threshold = 10, Duration = \"60s\")]\n[Timeout(Seconds = 5)]\n[Fallback(typeof(CachedInventoryHandler))]\n[Logged(OnError = true)]\npublic class ResilientInventoryHandler : IHandle<CheckInventory> {\n    public InventoryStatus Handle(CheckInventory query) {\n        // Execution flow:\n        // 1 Timeout wraps the actual call\n        // 2 Circuit breaker tracks failures\n        // 3 Retry handles transient failures\n        // 4 Fallback provides last resort\n        // 5 Everything is logged\n        return inventoryService Check(query);\n    }\n}\n// Conditional policies based on context\n[ConditionalPolicy(typeof(PeakHoursPolicy), Condition = nameof(IsPeakHours))]\n[ConditionalPolicy(typeof(StandardPolicy), Condition = nameof(IsStandardHours))]\npublic class AdaptiveHandler : IHandle<ProcessOrder> {\n    public OrderProcessed Handle(ProcessOrder cmd) {\n        return orderProcessor Process(cmd);\n    }\n    private bool IsPeakHours() => DateTime Now Hour >= 9 && DateTime Now Hour <= 17;\n    private bool IsStandardHours() =>",
        "startIndex": 6549,
        "preview": "primary operation fails\" framework: \"NET8\" category: \"Resilience\" difficulty: \"INTERMEDIATE\" tags: [\"Fallback\", \"Resilience\", \"Error Recovery\"] nugetP..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/policy-composition-chunk-4",
        "text": "} } // Conditional policies based on context [ConditionalPolicy(typeof(PeakHoursPolicy), Condition = nameof(IsPeakHours))] [ConditionalPolicy(typeof(StandardPolicy), Condition = nameof(IsStandardHours))] public class AdaptiveHandler : IHandle<ProcessOrder> { public OrderProcessed Handle(ProcessOrder cmd) { return orderProcessor Process(cmd); } private bool IsPeakHours() => DateTime Now Hour >= 9 && DateTime Now Hour <= 17; private bool IsStandardHours() => IsPeakHours();\n}\n`\nBulkhead Isolation\n`csharp{\ntitle: \"Bulkhead Pattern\"\ndescription: \"Isolate resources to prevent total system failure\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"ADVANCED\"\ntags: [\"Bulkhead\", \"Isolation\", \"Resilience\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"BulkheadExamples cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Limit concurrent executions\n[Bulkhead(\n    MaxConcurrency = 10,\n    MaxQueueLength = 100\n)]\npublic class ThrottledHandler : IHandle<HighLoadOperation> {\n    public Result Handle(HighLoadOperation cmd) {\n        // Only 10 concurrent executions allowed\n        // Up to 100 can queue, rest rejected immediately\n        return service Execute(cmd);\n    }\n}\n// Separate bulkheads for different operations\n[Bulkhead(Name = \"critical\", MaxConcurrency = 20)]\npublic class CriticalHandler : IHandle<CriticalOperation> {\n    public Result Handle(CriticalOperation cmd) {\n        return criticalService Execute(cmd);\n    }\n}\n[Bulkhead(Name = \"standard\", MaxConcurrency = 5)]\npublic class StandardHandler : IHandle<StandardOperation> {\n    public Result Handle(StandardOperation cmd) {\n        return standardService Execute(cmd);\n    }\n}\n`\nRate Limiting\n`csharp{\ntitle: \"Rate Limiting\"\ndescription: \"Control the rate of operations to prevent overload\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Rate Limiting\", \"Throttling\", \"Resilience\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"RateLimitExamples cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Fixed window rate limiting\n[RateLimit(\n    Permits = 100,\n    Window = \"1m\"  // 100 requests per minute\n)]\npublic class RateLimitedHandler : IHandle<ApiCall> {\n    public ApiResponse Handle(ApiCall cmd) {\n        return api Call(cmd);\n    }\n}\n// Sliding window rate limiting\n[RateLimit(\n    Permits = 1000,\n    Window = \"1h\",\n    Mode = \"sliding\"\n)]\npublic class SlidingWindowHandler : IHandle<BulkOperation> {\n    public BulkResult Handle(BulkOperation cmd) {\n        return bulkService",
        "startIndex": 8830,
        "preview": "} } // Conditional policies based on context [ConditionalPolicy(typeof(PeakHoursPolicy), Condition = nameof(IsPeakHours))] [ConditionalPolicy(typeof(S..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/policy-composition-chunk-5",
        "text": "100 requests per minute )] public class RateLimitedHandler : IHandle<ApiCall> { public ApiResponse Handle(ApiCall cmd) { return api Call(cmd); } } // Sliding window rate limiting [RateLimit( Permits = 1000, Window = \"1h\", Mode = \"sliding\" )] public class SlidingWindowHandler : IHandle<BulkOperation> { public BulkResult Handle(BulkOperation cmd) { return bulkService Process(cmd);\n    }\n}\n// Token bucket rate limiting\n[RateLimit(\n    Mode = \"token-bucket\",\n    Capacity = 100,\n    RefillRate = 10,      // 10 tokens per second\n    RefillInterval = \"1s\"\n)]\npublic class TokenBucketHandler : IHandle<StreamingOperation> {\n    public StreamResult Handle(StreamingOperation cmd) {\n        return streamService Process(cmd);\n    }\n}\n`\nCustom Policies\nCreating Custom Policies\n`csharp{\ntitle: \"Custom Policy Implementation\"\ndescription: \"Build your own resilience policies\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"ADVANCED\"\ntags: [\"Custom Policies\", \"Extensibility\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"CustomPolicyExamples cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Define custom policy attribute\n[AttributeUsage(AttributeTargets Class | AttributeTargets Method)]\npublic class CacheAsideAttribute : PolicyAttribute {\n    public int DurationSeconds { get; set; } = 300;\n    public string CacheKey { get; set; }\n    public override IPolicy CreatePolicy() {\n        return new CacheAsidePolicy(DurationSeconds, CacheKey);\n    }\n}\n// Implement the policy\npublic class CacheAsidePolicy : IPolicy {\n    private readonly int _durationSeconds;\n    private readonly string _cacheKey;\n    public async Task<T> ExecuteAsync<T>(\n        Func<Task<T>> action,\n        PolicyContext context) {\n        // Try cache first\n        var cached = await cache GetAsync<T>(_cacheKey);\n        if (cached = null) {\n            return cached;\n        }\n        // Execute action\n        var result = await action();\n        // Cache result\n        await cache SetAsync(_cacheKey, result, _durationSeconds);\n        return result;\n    }\n}\n// Use custom policy\n[CacheAside(DurationSeconds = 600, CacheKey = \"products\")]\npublic class ProductHandler : IHandle<GetProducts> {\n    public Products Handle(GetProducts query) {\n        return productService GetAll();\n    }\n}\n`\nPolicy Context and Telemetry\n`csharp{\ntitle: \"Policy Context and Observability\"\ndescription: \"Track and monitor policy execution\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"ADVANCED\"\ntags: [\"Telemetry\", \"Monitoring\", \"Context\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"PolicyTelemetry",
        "startIndex": 10894,
        "preview": "100 requests per minute )] public class RateLimitedHandler : IHandle<ApiCall> { public ApiResponse Handle(ApiCall cmd) { return api Call(cmd); } } // ..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/policy-composition-chunk-6",
        "text": "= \"products\")] public class ProductHandler : IHandle<GetProducts> { public Products Handle(GetProducts query) { return productService GetAll(); } } ` Policy Context and Telemetry `csharp{ title: \"Policy Context and Observability\" description: \"Track and monitor policy execution\" framework: \"NET8\" category: \"Resilience\" difficulty: \"ADVANCED\" tags: [\"Telemetry\", \"Monitoring\", \"Context\"] nugetPackages: [\"Whizbang Core\"] filename: \"PolicyTelemetry cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Policy with detailed telemetry\n[Retry(3, \n    OnRetry = nameof(LogRetry),\n    OnSuccess = nameof(LogSuccess),\n    OnFailure = nameof(LogFailure)\n)]\npublic class ObservableHandler : IHandle<CriticalOperation> {\n    private readonly ILogger _logger;\n    private readonly IMetrics _metrics;\n    public Result Handle(CriticalOperation cmd) {\n        return service Execute(cmd);\n    }\n    private void LogRetry(RetryContext context) {\n        _logger Warning(\"Retry {Attempt} after {Delay}ms: {Error}\",\n            context AttemptNumber,\n            context Delay TotalMilliseconds,\n            context LastException Message);\n        _metrics Increment(\"handler retries\", \n            tags: new { handler = nameof(ObservableHandler) });\n    }\n    private void LogSuccess(PolicyContext context) {\n        _logger Information(\"Operation succeeded after {Attempts} attempts\",\n            context Attempts);\n        _metrics RecordDuration(\"handler duration\", \n            context Duration,\n            tags: new { status = \"success\" });\n    }\n    private void LogFailure(PolicyContext context) {\n        _logger Error(\"Operation failed after {Attempts} attempts: {Error}\",\n            context Attempts,\n            context LastException Message);\n        _metrics Increment(\"handler failures\",\n            tags: new { handler = nameof(ObservableHandler) });\n    }\n}\n`\nTesting Policies\n`csharp{\ntitle: \"Testing Resilience Policies\"\ndescription: \"Verify policy behavior under various failure scenarios\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Testing\", \"Resilience\", \"Policies\"]\nnugetPackages: [\"Whizbang Core\", \"xUnit\"]\nfilename: \"PolicyTests cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang Testing\", \"Xunit\"]\n}\n[Fact]\npublic async Task RetryPolicy_RetriesOnTransientFailure() {\n    // Arrange\n    var test = await Whizbang Test<OrderHandler>() WithPolicy<RetryPolicy>() SimulateFailures(2)  // Fail twice, then succeed Given(new CreateOrder { });\n    // Act\n    var result = await test WhenHandled();\n    // Assert\n    result Should() BeSuccess();\n    test Policy<RetryPolicy>() Should() HaveRetried(2) WithDelays(\"100ms\", \"200ms\");\n}\n[Fact]\npublic async Task CircuitBreaker_OpensAfterThreshold() {\n    // Arrange\n    var test = await Whizbang Test<ServiceHandler>() WithPolicy<CircuitBreakerPolicy>();\n    // Act - Trigger failures\n    for (int i = 0; i < 5; i++) {\n        await test SimulateFailure()",
        "startIndex": 13119,
        "preview": "= \"products\")] public class ProductHandler : IHandle<GetProducts> { public Products Handle(GetProducts query) { return productService GetAll(); } } ` ..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/policy-composition-chunk-7",
        "text": "result = await test WhenHandled(); // Assert result Should() BeSuccess(); test Policy<RetryPolicy>() Should() HaveRetried(2) WithDelays(\"100ms\", \"200ms\"); } [Fact] public async Task CircuitBreaker_OpensAfterThreshold() { // Arrange var test = await Whizbang Test<ServiceHandler>() WithPolicy<CircuitBreakerPolicy>(); // Act - Trigger failures for (int i = 0; i < 5; i++) { await test SimulateFailure() WhenHandled(new CallService { });\n    }\n    // Assert - Circuit should be open\n    test Policy<CircuitBreakerPolicy>() Should() BeOpen() For(\"30s\");\n    // Further calls should fail immediately\n    await test WhenHandled(new CallService { }) Should() FailImmediately() WithException<CircuitBreakerOpenException>();\n}\n[Fact]\npublic async Task Fallback_ProvidesAlternativeValue() {\n    // Arrange\n    var test = await Whizbang Test<DataHandler>() WithPolicy<FallbackPolicy>() SimulateFailure();\n    // Act\n    var result = await test WhenHandled(new GetData { });\n    // Assert\n    result Should() BeFromFallback();\n    test Policy<FallbackPolicy>() Should() HaveExecutedFallback() WithValue(\"DefaultData\");\n}\n`\nBest Practices\nDo's\n✅ Layer policies appropriately\n`csharp{\ntitle: \"Layer Policies Appropriately\"\ndescription: \"Proper layering of resilience policies for comprehensive protection\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"Policies\", \"Resilience\", \"Best Practices\"]\nfilename: \"PolicyLayering cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[Retry(3)]           // Inner - handles transient failures\n[CircuitBreaker(5)]  // Middle - prevents cascading failures\n[Timeout(10)]        // Outer - ensures bounded execution time\n`\n✅ Use specific exception handling\n`csharp{\ntitle: \"Use Specific Exception Handling\"\ndescription: \"Configure policies to handle only specific exception types\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"Policies\", \"Exception Handling\", \"Best Practices\"]\nfilename: \"SpecificExceptionHandling cs\"\nshowLineNumbers: true\nusingStatements: [\"System\"]\n}\n[Retry(3, RetryOn = new[] { typeof(TransientException) })]\n`\n✅ Monitor and log policy actions\n`csharp{\ntitle: \"Monitor and Log Policy Actions\"\ndescription: \"Add monitoring and logging to policy executions for observability\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"Policies\", \"Monitoring\", \"Best Practices\"]\nfilename: \"PolicyMonitoring",
        "startIndex": 15700,
        "preview": "result = await test WhenHandled(); // Assert result Should() BeSuccess(); test Policy<RetryPolicy>() Should() HaveRetried(2) WithDelays(\"100ms\", \"200m..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/policy-composition-chunk-8",
        "text": "usingStatements: [\"System\"] } [Retry(3, RetryOn = new[] { typeof(TransientException) })] ` ✅ Monitor and log policy actions `csharp{ title: \"Monitor and Log Policy Actions\" description: \"Add monitoring and logging to policy executions for observability\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"INTERMEDIATE\" tags: [\"Usage Patterns\", \"Policies\", \"Monitoring\", \"Best Practices\"] filename: \"PolicyMonitoring cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[Retry(3, OnRetry = nameof(LogRetry))]\n`\n✅ Test failure scenarios\n`csharp{\ntitle: \"Test Failure Scenarios\"\ndescription: \"Test how policies handle various failure conditions\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"Policies\", \"Testing\", \"Best Practices\"]\nfilename: \"PolicyTesting cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang Testing\", \"System Threading Tasks\"]\n}\nawait test SimulateFailures(3) WhenHandled();\n`\nDon'ts\n❌ Don't retry non-idempotent operations\n`csharp{\ntitle: \"Don't Retry Non-Idempotent Operations\"\ndescription: \"Avoid retrying operations that can cause side effects like duplicate charges\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"Policies\", \"Anti-Patterns\", \"Idempotency\"]\nfilename: \"NonIdempotentRetry cs\"\nshowLineNumbers: true\nusingStatements: [\"System\"]\n}\n// Bad: Payment might be charged multiple times\n[Retry(3)]\npublic PaymentCharged ChargePayment(ChargeCard cmd)\n`\n❌ Don't set timeouts shorter than retries\n`csharp{\ntitle: \"Don't Set Timeouts Shorter Than Retries\"\ndescription: \"Ensure timeout values account for total retry duration\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"Policies\", \"Anti-Patterns\", \"Timeouts\"]\nfilename: \"TimeoutRetryConflict cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Bad: Timeout will trigger before retries complete\n[Retry(3, DelayMs = 5000)]\n[Timeout(Seconds = 10)]\n`\n❌ Don't ignore circuit breaker state\n`csharp{\ntitle: \"Don't Ignore Circuit Breaker State\"\ndescription: \"Always monitor and track circuit breaker health and state changes\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"Policies\", \"Anti-Patterns\", \"Monitoring\"]\nfilename: \"CircuitBreakerMonitoring",
        "startIndex": 17888,
        "preview": "usingStatements: [\"System\"] } [Retry(3, RetryOn = new[] { typeof(TransientException) })] ` ✅ Monitor and log policy actions `csharp{ title: \"Monitor a..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/policy-composition-chunk-9",
        "text": "before retries complete [Retry(3, DelayMs = 5000)] [Timeout(Seconds = 10)] ` ❌ Don't ignore circuit breaker state `csharp{ title: \"Don't Ignore Circuit Breaker State\" description: \"Always monitor and track circuit breaker health and state changes\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"INTERMEDIATE\" tags: [\"Usage Patterns\", \"Policies\", \"Anti-Patterns\", \"Monitoring\"] filename: \"CircuitBreakerMonitoring cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Bad: No monitoring of circuit breaker health\n[CircuitBreaker(5)]\n// Should add telemetry to track circuit state\n`\nReal-World Examples\nE-Commerce Order Processing\n`csharp{\ntitle: \"E-Commerce Resilience Pattern\"\ndescription: \"Complete resilience strategy for order processing\"\nframework: \"NET8\"\ncategory: \"Real World\"\ndifficulty: \"ADVANCED\"\ntags: [\"E-Commerce\", \"Order Processing\", \"Resilience\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"ECommerceResilience cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Payment processing with comprehensive resilience\n[Retry(3, Backoff = \"exponential\", DelayMs = 1000)]\n[CircuitBreaker(Threshold = 10, Duration = \"60s\")]\n[Timeout(Seconds = 30)]\n[Fallback(typeof(QueuePaymentForManualProcessing))]\n[Logged]\n[Metered]\npublic class PaymentProcessor : IHandle<ProcessPayment> {\n    public PaymentProcessed Handle(ProcessPayment cmd, IPaymentGateway gateway) {\n        // This is protected by:\n        // - 3 retries with exponential backoff\n        // - Circuit breaker to prevent hammering failed gateway\n        // - 30 second timeout to prevent hanging\n        // - Fallback to queue for manual processing\n        // - Full logging and metrics\n        var result = gateway ChargeCard(\n            cmd CardNumber,\n            cmd Amount,\n            cmd Currency\n        );\n        return new PaymentProcessed(result TransactionId, result Status);\n    }\n}\n// Inventory check with caching fallback\n[CircuitBreaker(FailureRate = 0 5, SamplingDuration = \"30s\")]\n[Timeout(Seconds = 5)]\n[Fallback(typeof(CachedInventoryChecker))]\npublic class LiveInventoryChecker : IHandle<CheckInventory> {\n    public InventoryStatus Handle(CheckInventory query) {\n        return inventoryService GetRealTimeStatus(query ProductIds);\n    }\n}\n// Order fulfillment saga with resilience\n[Saga]\n[Retry(5, Backoff = \"linear\", DelayMs = 2000)]\n[Timeout(Seconds = 120)]\npublic class OrderFulfillmentSaga : IHandle<OrderPlaced> {\n    public async Task<SagaResult> Handle(OrderPlaced @event) {\n        // Each step has its own resilience policies\n        await Send(new ReserveInventory(@event OrderId)) WithRetry(3) WithTimeout(10);\n        await Send(new ProcessPayment(@event OrderId)) WithRetry(5) WithCircuitBreaker()",
        "startIndex": 19829,
        "preview": "before retries complete [Retry(3, DelayMs = 5000)] [Timeout(Seconds = 10)] ` ❌ Don't ignore circuit breaker state `csharp{ title: \"Don't Ignore Circui..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/policy-composition-chunk-10",
        "text": "} // Order fulfillment saga with resilience [Saga] [Retry(5, Backoff = \"linear\", DelayMs = 2000)] [Timeout(Seconds = 120)] public class OrderFulfillmentSaga : IHandle<OrderPlaced> { public async Task<SagaResult> Handle(OrderPlaced @event) { // Each step has its own resilience policies await Send(new ReserveInventory(@event OrderId)) WithRetry(3) WithTimeout(10); await Send(new ProcessPayment(@event OrderId)) WithRetry(5) WithCircuitBreaker() WithFallback(new QueuePayment(@event OrderId));\n        await Send(new ShipOrder(@event OrderId)) WithRetry(3) WithTimeout(30);\n        return SagaResult Completed();\n    }\n}\n`\nNext Steps\nLearn about Aspect-Oriented Handlers for more aspects\nExplore Testing Strategies for policy testing\nReview Distributed Messaging for cross-service resilience\nSee Production Deployment for monitoring setup",
        "startIndex": 22217,
        "preview": "} // Order fulfillment saga with resilience [Saga] [Retry(5, Backoff = \"linear\", DelayMs = 2000)] [Timeout(Seconds = 120)] public class OrderFulfillme..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/usage-patterns/progressive-enhancement",
    "title": "Progressive Enhancement",
    "category": "Usage Patterns",
    "url": "/docs/old-v1.0.0/usage-patterns/progressive-enhancement",
    "chunks": [
      {
        "id": "old-v1.0.0/usage-patterns/progressive-enhancement-chunk-0",
        "text": "Progressive Enhancement\nOverview\nProgressive Enhancement is Whizbang's superpower - the ability to evolve your application from a simple monolith to a distributed, event-sourced system without changing your handler code This pattern allows you to start simple and add complexity only when needed, maintaining the same business logic throughout your application's growth The Journey\n`mermaid\ngraph LR\n    A[In-Process<br/>Development] --> B[Durable<br/>Single Service]\n    B --> C[Distributed<br/>Microservices]\n    C --> D[Event-Sourced<br/>CQRS/ES]\n    style A fill:#28a745,color:#fff\n    style B fill:#17a2b8,color:#fff\n    style C fill:#ffc107,color:#000\n    style D fill:#dc3545,color:#fff\n`\nThe Same Handler, Every Mode\nThis is the key insight - one handler implementation works across all modes:\n`csharp{\ntitle: \"Universal Handler\"\ndescription: \"This exact handler works in ALL deployment modes\"\nframework: \"NET8\"\ncategory: \"Core Concept\"\ndifficulty: \"BEGINNER\"\ntags: [\"Handler\", \"Universal\", \"Progressive Enhancement\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"OrderHandler cs\"\nshowLineNumbers: true\nhighlightLines: [1, 2, 3]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[Logged]\n[Validated]\n[Transactional]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd, IOrderRepository repository) {\n        // This EXACT code works in:\n        // ✅ Local development (in-process)\n        // ✅ Production monolith (durable)\n        // ✅ Microservices (distributed)\n        // ✅ Event-sourced system (CQRS/ES)\n        var order = new Order {\n            Id = Guid NewGuid(),\n            CustomerId = cmd CustomerId,\n            Items = cmd Items,\n            Total = cmd Items Sum(i => i Quantity * i Price),\n            Status = OrderStatus Pending,\n            CreatedAt = DateTime UtcNow\n        };\n        repository Save(order);\n        return new OrderCreated(\n            order Id,\n            order CustomerId,\n            order Total,\n            order CreatedAt\n        );\n    }\n}\n`\nMode 1: In-Process (Development)\nConfiguration\n`csharp{\ntitle: \"Event-Driven Development Configuration\"\ndescription: \"Perfect for development and testing - in-memory events\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"BEGINNER\"\ntags: [\"Event-Driven\", \"Development\", \"Configuration\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"Program Development cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Program cs - Development mode\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services",
        "startIndex": 0,
        "preview": "Progressive Enhancement\nOverview\nProgressive Enhancement is Whizbang's superpower - the ability to evolve your application from a simple monolith to a..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/progressive-enhancement-chunk-1",
        "text": "\"Event-Driven Development Configuration\" description: \"Perfect for development and testing - in-memory events\" framework: \"NET8\" category: \"Configuration\" difficulty: \"BEGINNER\" tags: [\"Event-Driven\", \"Development\", \"Configuration\"] nugetPackages: [\"Whizbang Core\"] filename: \"Program Development cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"] } // Program cs - Development mode var builder = WebApplication CreateBuilder(args); builder Services AddWhizbang(dispatcher => {\n    // Event-driven mode with in-memory processing\n    dispatcher RegisterReceptorsFromAssembly(typeof(Program) Assembly);\n    dispatcher RegisterPerspectivesFromAssembly(typeof(Program) Assembly);\n    dispatcher RegisterLensesFromAssembly(typeof(Program) Assembly);\n    // No persistence in development\n    dispatcher UseInMemoryPerspectives();\n});\n// In-memory lens implementations\nbuilder Services AddSingleton<IOrderLens, InMemoryOrderLens>();\nvar app = builder Build();\napp MapPost(\"/orders\", async (CreateOrder cmd, IDispatcher dispatcher) => {\n    // Executes immediately, synchronously\n    var @event = await dispatcher Send(cmd);\n    return Results Ok(new { OrderId = @event OrderId, Total = @event Total });\n});\napp Run();\n`\nCharacteristics\n`csharp{\ntitle: \"Event-Driven Development Behavior\"\ndescription: \"How receptors execute in development mode\"\nframework: \"NET8\"\ncategory: \"Behavior\"\ndifficulty: \"BEGINNER\"\ntags: [\"Event-Driven\", \"Execution\", \"Development\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"EventDrivenBehavior cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System Diagnostics\"]\n}\npublic class EventDrivenExample {\n    public async Task DemonstrateEventDriven(IDispatcher dispatcher) {\n        var stopwatch = Stopwatch StartNew();\n        // Immediate, synchronous execution\n        var @event = await dispatcher Send(new CreateOrder {\n            CustomerId = Guid NewGuid(),\n            Items = new[] { new OrderItem(\"SKU-1\", 2, 10 00m) }\n        });\n        // Receptor executed in same thread\n        Console WriteLine($\"Thread: {Thread CurrentThread ManagedThreadId}\");\n        Console WriteLine($\"Duration: {stopwatch ElapsedMilliseconds}ms\");\n        // Output: Thread: 1, Duration: 5ms\n        // Events flow to perspectives synchronously\n        // All perspectives updated immediately\n        // No ledger persistence in development\n    }\n}\n// Testing is simple\n[Fact]\npublic async Task EventDrivenMode_ExecutesImmediately() {\n    var dispatcher = new DispatcherBuilder() UseEventDrivenMode() Build();\n    var @event = await dispatcher Send(new CreateOrder());\n    Assert NotNull(@event);\n    Assert",
        "startIndex": 2600,
        "preview": "\"Event-Driven Development Configuration\" description: \"Perfect for development and testing - in-memory events\" framework: \"NET8\" category: \"Configurat..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/progressive-enhancement-chunk-2",
        "text": "Thread: 1, Duration: 5ms // Events flow to perspectives synchronously // All perspectives updated immediately // No ledger persistence in development } } // Testing is simple [Fact] public async Task EventDrivenMode_ExecutesImmediately() { var dispatcher = new DispatcherBuilder() UseEventDrivenMode() Build(); var @event = await dispatcher Send(new CreateOrder()); Assert NotNull(@event); Assert IsType<OrderCreated>(@event);\n}\n`\nWhen to Use\nLocal development - Fast feedback loop with event-driven patterns\nUnit testing - No infrastructure dependencies, pure receptor testing\nPrototyping - Rapid iteration with event flows\nSimple applications - When you don't need event persistence\nMode 2: Durable (Single Service)\nConfiguration\n`csharp{\ntitle: \"Durable Mode Configuration\"\ndescription: \"Add persistence and retry capabilities to your monolith\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Durable\", \"Persistence\", \"Monolith\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang PostgreSQL\"]\nfilename: \"Program Durable cs\"\nshowLineNumbers: true\nhighlightLines: [5, 6, 7, 8]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Program cs - Production monolith\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbang() UseDurableMode()  // Adds persistence and retry UsePostgreSQL(connectionString) WithOutbox()  // Ensures message delivery WithRetry(3, backoff: \"exponential\") RegisterHandlersFromAssembly(typeof(Program) Assembly);\n// Real database for production\nbuilder Services AddScoped<IOrderRepository, PostgresOrderRepository>();\n// Background service for processing\nbuilder Services AddHostedService<WhizbangProcessor>();\nvar app = builder Build();\napp MapPost(\"/orders\", async (CreateOrder cmd, IWhizbang whizbang) => {\n    // Queued for durable processing\n    await whizbang Publish(cmd);\n    return Results Accepted();  // Returns immediately\n});\napp Run();\n`\nMessage Flow\n`csharp{\ntitle: \"Durable Mode Message Flow\"\ndescription: \"How messages are persisted and processed\"\nframework: \"NET8\"\ncategory: \"Message Flow\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Durability\", \"Outbox\", \"Retry\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"DurableFlow cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\npublic class DurableExample {\n    public async Task DemonstrateDurable(IWhizbang whizbang) {\n        // 1 Message persisted to outbox\n        await whizbang Publish(new CreateOrder { });\n        // Returns immediately after persisting\n        // 2",
        "startIndex": 4793,
        "preview": "Thread: 1, Duration: 5ms // Events flow to perspectives synchronously // All perspectives updated immediately // No ledger persistence in development ..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/progressive-enhancement-chunk-3",
        "text": "category: \"Message Flow\" difficulty: \"INTERMEDIATE\" tags: [\"Durability\", \"Outbox\", \"Retry\"] nugetPackages: [\"Whizbang Core\"] filename: \"DurableFlow cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"System\"] } public class DurableExample { public async Task DemonstrateDurable(IWhizbang whizbang) { // 1 Message persisted to outbox await whizbang Publish(new CreateOrder { }); // Returns immediately after persisting // 2 Background processor picks up message\n        // - Dequeues from outbox\n        // - Executes handler\n        // - On success: Marks complete\n        // - On failure: Retries with backoff\n        // 3 Events from handler also go through outbox\n        // - Ensures exactly-once delivery\n        // - Maintains order guarantees\n    }\n}\n// Automatic retry on failure\n[Retry(3, Backoff = \"exponential\")]\npublic class ResilientHandler : IHandle<ProcessPayment> {\n    public PaymentProcessed Handle(ProcessPayment cmd) {\n        // If this fails, automatically retried\n        // 1st retry: 1 second delay\n        // 2nd retry: 2 second delay  \n        // 3rd retry: 4 second delay\n        return ProcessPaymentWithGateway(cmd);\n    }\n}\n`\nDatabase Schema\n`sql{\ntitle: \"Outbox Pattern Database Schema\"\ndescription: \"Database tables for durable messaging with outbox and inbox patterns\"\nframework: \"PostgreSQL\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Database Schema\", \"Outbox Pattern\", \"Durable Messaging\"]\nfilename: \"whizbang_outbox",
        "startIndex": 6971,
        "preview": "category: \"Message Flow\" difficulty: \"INTERMEDIATE\" tags: [\"Durability\", \"Outbox\", \"Retry\"] nugetPackages: [\"Whizbang Core\"] filename: \"DurableFlow cs..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/progressive-enhancement-chunk-4",
        "text": "retry: 2 second delay // 3rd retry: 4 second delay return ProcessPaymentWithGateway(cmd); } } ` Database Schema `sql{ title: \"Outbox Pattern Database Schema\" description: \"Database tables for durable messaging with outbox and inbox patterns\" framework: \"PostgreSQL\" category: \"Usage Patterns\" difficulty: \"INTERMEDIATE\" tags: [\"Database Schema\", \"Outbox Pattern\", \"Durable Messaging\"] filename: \"whizbang_outbox sql\"\nshowLineNumbers: true\n}\n-- Outbox table for durable messaging\nCREATE TABLE whizbang_outbox (\n    id BIGSERIAL PRIMARY KEY,\n    message_id UUID NOT NULL UNIQUE,\n    message_type VARCHAR(500) NOT NULL,\n    payload JSONB NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    processed_at TIMESTAMPTZ,\n    attempts INT NOT NULL DEFAULT 0,\n    error TEXT\n);\n-- Inbox for idempotency\nCREATE TABLE whizbang_inbox (\n    message_id UUID PRIMARY KEY,\n    processed_at TIMESTAMPTZ NOT NULL,\n    handler_type VARCHAR(500) NOT NULL\n);\n`\nWhen to Use\nProduction systems - Reliability with perspective persistence\nHigh-value operations - Can't afford to lose events\nBackground processing - Decouple API from perspective updates\nRetry requirements - Handle transient perspective failures\nMode 3: Distributed (Microservices)\nConfiguration\n`csharp{\ntitle: \"Distributed Mode Configuration\"\ndescription: \"Scale across multiple services with message brokers\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Distributed\", \"Microservices\", \"Kafka\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Kafka\"]\nfilename: \"Program Distributed cs\"\nshowLineNumbers: true\nhighlightLines: [5, 6, 7, 8, 9]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Program cs - Orders Service\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbang() UseDistributedMode() UseKafka(config => {\n        config BootstrapServers = \"kafka:9092\";\n        config ConsumerGroup = \"orders-service\";\n    }) UsePostgreSQL(connectionString)  // Local event store WithSagaOrchestration()          // Distributed transactions WithDistributedTracing()         // OpenTelemetry RegisterHandlersFromAssembly(typeof(Program) Assembly);\n// Domain ownership configuration\nbuilder Services ConfigureDomain(\"Orders\", domain => {\n    domain OwnsAggregate<Order>();\n    domain PublishesEvents<OrderCreated, OrderShipped, OrderCancelled>();\n    domain HandlesCommands<CreateOrder, ShipOrder, CancelOrder>();\n});\nvar app = builder Build();\n// Health checks for service discovery\napp MapHealthChecks(\"/health\");\napp",
        "startIndex": 8022,
        "preview": "retry: 2 second delay // 3rd retry: 4 second delay return ProcessPaymentWithGateway(cmd); } } ` Database Schema `sql{ title: \"Outbox Pattern Database ..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/progressive-enhancement-chunk-5",
        "text": "}) UsePostgreSQL(connectionString) // Local event store WithSagaOrchestration() // Distributed transactions WithDistributedTracing() // OpenTelemetry RegisterHandlersFromAssembly(typeof(Program) Assembly); // Domain ownership configuration builder Services ConfigureDomain(\"Orders\", domain => { domain OwnsAggregate<Order>(); domain PublishesEvents<OrderCreated, OrderShipped, OrderCancelled>(); domain HandlesCommands<CreateOrder, ShipOrder, CancelOrder>(); }); var app = builder Build(); // Health checks for service discovery app MapHealthChecks(\"/health\"); app Run();\n`\nService Communication\n`csharp{\ntitle: \"Cross-Service Communication\"\ndescription: \"How services communicate in distributed mode\"\nframework: \"NET8\"\ncategory: \"Communication\"\ndifficulty: \"ADVANCED\"\ntags: [\"Service Communication\", \"Events\", \"Commands\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"DistributedCommunication cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Orders Service - Publishes events\n[OwnedBy(\"Orders\")]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        var order = CreateOrder(cmd);\n        // This event is automatically published to Kafka\n        // Other services can subscribe\n        return new OrderCreated(order Id, order Total);\n    }\n}\n// Inventory Service - Subscribes to events\n[Service(\"Inventory\")]\npublic class InventoryHandler : IHandle<OrderCreated> {\n    public InventoryReserved Handle(OrderCreated @event) {\n        // Receives event from Kafka\n        // Reserves inventory for the order\n        var reservation = ReserveInventory(@event OrderId);\n        // Publishes its own event\n        return new InventoryReserved(\n            @event OrderId, \n            reservation Id\n        );\n    }\n}\n// Payment Service - Part of saga\n[Service(\"Payment\")]\npublic class PaymentSaga : Saga<PaymentState> {\n    public SagaAction Handle(OrderCreated @event) {\n        State OrderId = @event OrderId;\n        State Amount = @event Total;\n        // Orchestrate payment process\n        return SagaAction Send(new ChargeCard(State Amount)) OnSuccess(new PaymentCompleted(State OrderId)) OnFailure(new PaymentFailed(State OrderId)) WithTimeout(TimeSpan FromMinutes(5));\n    }\n}\n`\nService Discovery\n`csharp{\ntitle: \"Service Discovery and Routing\"\ndescription: \"Automatic service discovery and message routing\"\nframework: \"NET8\"\ncategory: \"Service Discovery\"\ndifficulty: \"ADVANCED\"\ntags: [\"Service Discovery\", \"Routing\", \"Consul\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang ServiceDiscovery\"]\nfilename: \"ServiceDiscovery cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Automatic service registration\nbuilder Services AddWhizbang() UseDistributedMode() UseServiceDiscovery(options => {\n        options UseConsul(\"http://consul:8500\");\n        options ServiceName = \"orders-service\";\n        options ServiceId = Environment MachineName;\n        options HealthCheckInterval = TimeSpan",
        "startIndex": 10186,
        "preview": "}) UsePostgreSQL(connectionString) // Local event store WithSagaOrchestration() // Distributed transactions WithDistributedTracing() // OpenTelemetry ..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/progressive-enhancement-chunk-6",
        "text": "category: \"Service Discovery\" difficulty: \"ADVANCED\" tags: [\"Service Discovery\", \"Routing\", \"Consul\"] nugetPackages: [\"Whizbang Core\", \"Whizbang ServiceDiscovery\"] filename: \"ServiceDiscovery cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"System\"] } // Automatic service registration builder Services AddWhizbang() UseDistributedMode() UseServiceDiscovery(options => { options UseConsul(\"http://consul:8500\"); options ServiceName = \"orders-service\"; options ServiceId = Environment MachineName; options HealthCheckInterval = TimeSpan FromSeconds(10);\n    });\n// Commands routed to owning service\npublic class OrderClient {\n    private readonly IWhizbang _whizbang;\n    public async Task<OrderCreated> CreateOrder(CreateOrder cmd) {\n        // Whizbang knows Orders service owns this command\n        // Automatically routes via service discovery\n        return await _whizbang Send(cmd);\n    }\n}\n// Load balancing across instances\n[LoadBalanced(Strategy = \"round-robin\")]\npublic class DistributedQuery : IHandle<GetOrderStatus> {\n    public OrderStatus Handle(GetOrderStatus query) {\n        // Queries can be handled by any instance\n        return GetStatus(query OrderId);\n    }\n}\n`\nWhen to Use\nMicroservice architecture - Independent service scaling with relays\nTeam boundaries - Different teams own different receptors/domains  \nTechnology diversity - Services in different languages sharing events\nGeographic distribution - Services in different regions with event streaming\nMode 4: Event-Sourced (CQRS/ES)\nConfiguration\n`csharp{\ntitle: \"Event-Sourced Mode Configuration\"\ndescription: \"Full event sourcing with projections and time travel\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Event Sourcing\", \"CQRS\", \"Projections\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventStore\"]\nfilename: \"Program EventSourced cs\"\nshowLineNumbers: true\nhighlightLines: [5, 6, 7, 8, 9, 10]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Program cs - Event-sourced system\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbang() UseEventSourcedMode() UseEventStore(config => {\n        config ConnectionString = eventStoreConnection;\n        config SnapshotFrequency = 100;  // Snapshot every 100 events\n    }) UseProjections(config => {\n        config UsePostgreSQL(readModelConnection);\n        config RebuildOnStartup = false;\n    }) WithTimeTravel()  // Enable historical queries RegisterHandlersFromAssembly(typeof(Program) Assembly);\n// Register aggregates\nbuilder Services RegisterAggregate<Order>();\nbuilder Services RegisterAggregate<Customer>();\n// Register projections\nbuilder Services RegisterProjection<OrderListProjection>();\nbuilder Services RegisterProjection<CustomerOrderHistoryProjection>();\nbuilder Services RegisterProjection<RevenueProjection>();\nvar app = builder Build();\n// Projection management endpoints\napp MapProjectionManagement(\"/projections\");\napp",
        "startIndex": 12666,
        "preview": "category: \"Service Discovery\" difficulty: \"ADVANCED\" tags: [\"Service Discovery\", \"Routing\", \"Consul\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Servi..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/progressive-enhancement-chunk-7",
        "text": "UseProjections(config => { config UsePostgreSQL(readModelConnection); config RebuildOnStartup = false; }) WithTimeTravel() // Enable historical queries RegisterHandlersFromAssembly(typeof(Program) Assembly); // Register aggregates builder Services RegisterAggregate<Order>(); builder Services RegisterAggregate<Customer>(); // Register projections builder Services RegisterProjection<OrderListProjection>(); builder Services RegisterProjection<CustomerOrderHistoryProjection>(); builder Services RegisterProjection<RevenueProjection>(); var app = builder Build(); // Projection management endpoints app MapProjectionManagement(\"/projections\"); app Run();\n`\nEvent-Sourced Aggregates\n`csharp{\ntitle: \"Event-Sourced Aggregate\"\ndescription: \"Domain aggregates that emit events\"\nframework: \"NET8\"\ncategory: \"Aggregates\"\ndifficulty: \"ADVANCED\"\ntags: [\"Aggregates\", \"Domain\", \"Events\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"OrderAggregate cs\"\nshowLineNumbers: true\nhighlightLines: [1, 10, 20, 30]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[EventSourced]\npublic class Order : Aggregate {\n    public Guid CustomerId { get; private set; }\n    public List<OrderItem> Items { get; private set; }\n    public decimal Total { get; private set; }\n    public OrderStatus Status { get; private set; }\n    // Command handler - returns events\n    public OrderCreated Handle(CreateOrder cmd) {\n        if (cmd Items Any() = true) {\n            throw new InvalidOperationException(\"Order must have items\");\n        }\n        var total = cmd Items Sum(i => i Quantity * i Price);\n        // Return event - automatically appended to event stream\n        return new OrderCreated {\n            OrderId = Guid NewGuid(),\n            CustomerId = cmd CustomerId,\n            Items = cmd Items,\n            Total = total,\n            CreatedAt = DateTime UtcNow\n        };\n    }\n    // Event handler - updates state\n    [Pure]  // No side effects allowed\n    public void Apply(OrderCreated @event) {\n        Id = @event OrderId;\n        CustomerId = @event CustomerId;\n        Items = @event Items ToList();\n        Total = @event Total;\n        Status = OrderStatus Pending;\n    }\n    // Another command\n    public OrderShipped Ship(ShipOrder cmd) {\n        if (Status = OrderStatus Paid) {\n            throw new InvalidOperationException(\"Can only ship paid orders\");\n        }\n        return new OrderShipped {\n            OrderId = Id,\n            ShippedAt = DateTime UtcNow,\n            TrackingNumber = cmd TrackingNumber\n        };\n    }\n    public void Apply(OrderShipped @event) {\n        Status = OrderStatus",
        "startIndex": 15110,
        "preview": "UseProjections(config => { config UsePostgreSQL(readModelConnection); config RebuildOnStartup = false; }) WithTimeTravel() // Enable historical querie..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/progressive-enhancement-chunk-8",
        "text": "OrderStatus Pending; } // Another command public OrderShipped Ship(ShipOrder cmd) { if (Status = OrderStatus Paid) { throw new InvalidOperationException(\"Can only ship paid orders\"); } return new OrderShipped { OrderId = Id, ShippedAt = DateTime UtcNow, TrackingNumber = cmd TrackingNumber }; } public void Apply(OrderShipped @event) { Status = OrderStatus Shipped;\n    }\n}\n`\nProjections\n`csharp{\ntitle: \"Event Projections\"\ndescription: \"Building read models from event streams\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Read Models\", \"CQRS\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"Projections cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Order list projection\n[Projection(\"OrderList\")]\npublic class OrderListProjection : \n    IProject<OrderCreated>,\n    IProject<OrderShipped>,\n    IProject<OrderCancelled> {\n    private readonly IDocumentStore _store;\n    public async Task Project(OrderCreated @event) {\n        await _store Upsert(new OrderListItem {\n            OrderId = @event OrderId,\n            CustomerId = @event CustomerId,\n            Total = @event Total,\n            Status = \"Created\",\n            CreatedAt = @event CreatedAt\n        });\n    }\n    public async Task Project(OrderShipped @event) {\n        await _store Update<OrderListItem>(@event OrderId, item => {\n            item Status = \"Shipped\";\n            item ShippedAt = @event ShippedAt;\n        });\n    }\n    public async Task Project(OrderCancelled @event) {\n        await _store Update<OrderListItem>(@event OrderId, item => {\n            item Status = \"Cancelled\";\n            item CancelledAt = @event CancelledAt;\n        });\n    }\n}\n// Revenue projection with time windows\n[Projection(\"Revenue\")]\npublic class RevenueProjection : IProject<OrderCreated> {\n    public async Task Project(OrderCreated @event) {\n        // Update daily revenue\n        await _store Increment(\n            $\"revenue:daily:{@event CreatedAt:yyyy-MM-dd}\",\n            @event Total\n        );\n        // Update monthly revenue\n        await _store Increment(\n            $\"revenue:monthly:{@event CreatedAt:yyyy-MM}\",\n            @event Total\n        );\n        // Update customer lifetime value\n        await _store Increment(\n            $\"customer:ltv:{@event CustomerId}\",\n            @event Total\n        );\n    }\n}\n`\nTime Travel Queries\n`csharp{\ntitle: \"Time Travel and Historical Queries\"\ndescription: \"Query system state at any point in time\"\nframework: \"NET8\"\ncategory: \"Time Travel\"\ndifficulty: \"ADVANCED\"\ntags: [\"Time Travel\", \"Historical\", \"Debugging\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"TimeTravel",
        "startIndex": 17062,
        "preview": "OrderStatus Pending; } // Another command public OrderShipped Ship(ShipOrder cmd) { if (Status = OrderStatus Paid) { throw new InvalidOperationExcepti..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/progressive-enhancement-chunk-9",
        "text": "customer lifetime value await _store Increment( $\"customer:ltv:{@event CustomerId}\", @event Total ); } } ` Time Travel Queries `csharp{ title: \"Time Travel and Historical Queries\" description: \"Query system state at any point in time\" framework: \"NET8\" category: \"Time Travel\" difficulty: \"ADVANCED\" tags: [\"Time Travel\", \"Historical\", \"Debugging\"] nugetPackages: [\"Whizbang Core\"] filename: \"TimeTravel cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\npublic class TimeTravelExample {\n    private readonly IWhizbang _whizbang;\n    public async Task<Order> GetOrderAtPointInTime(\n        Guid orderId, \n        DateTime pointInTime) {\n        // Replay events up to specific time\n        var order = await _whizbang AsOf(pointInTime) Get<Order>(orderId);\n        return order;\n    }\n    public async Task<decimal> GetRevenueOnDate(DateTime date) {\n        // Query projection as it was on specific date\n        var revenue = await _whizbang AsOf(date AddDays(1) AddSeconds(-1)) Query<RevenueProjection>() GetDailyRevenue(date);\n        return revenue;\n    }\n    public async Task DebugOrderHistory(Guid orderId) {\n        // Get all events for an aggregate\n        var events = await _whizbang EventStream(orderId) ToListAsync();\n        Console WriteLine($\"Order {orderId} history:\");\n        foreach (var @event in events) {\n            Console WriteLine($\"  {@event Timestamp}: {@event GetType() Name}\");\n            // Replay to this point\n            var orderAtPoint = await _whizbang AsOf(@event Timestamp) Get<Order>(orderId);\n            Console WriteLine($\"    Status: {orderAtPoint Status}\");\n            Console WriteLine($\"    Total: {orderAtPoint Total}\");\n        }\n    }\n}\n`\nWhen to Use\nAudit requirements - Complete history of all changes in ledger\nComplex domains - Rich business logic with stateful receptors\nDebugging needs - Replay events to understand receptor state\nAnalytics - Build new perspectives from historical events\nCompliance - Prove receptor state at any point in time\nMigration Strategies\nFrom In-Process to Durable\n`csharp{\ntitle: \"Migrating to Durable Mode\"\ndescription: \"Steps to add durability to existing application\"\nframework: \"NET8\"\ncategory: \"Migration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Migration\", \"Durability\", \"Evolution\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"MigrateToDurable cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Step 1: Change configuration (no handler changes )\n// Before:\nbuilder Services AddWhizbang() UseInProcessMode();\n// After:\nbuilder Services AddWhizbang() UseDurableMode()",
        "startIndex": 19364,
        "preview": "customer lifetime value await _store Increment( $\"customer:ltv:{@event CustomerId}\", @event Total ); } } ` Time Travel Queries `csharp{ title: \"Time T..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/progressive-enhancement-chunk-10",
        "text": "add durability to existing application\" framework: \"NET8\" category: \"Migration\" difficulty: \"INTERMEDIATE\" tags: [\"Migration\", \"Durability\", \"Evolution\"] nugetPackages: [\"Whizbang Core\"] filename: \"MigrateToDurable cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"] } // Step 1: Change configuration (no handler changes ) // Before: builder Services AddWhizbang() UseInProcessMode(); // After: builder Services AddWhizbang() UseDurableMode() UsePostgreSQL(connectionString);\n// Step 2: Add background processor\nbuilder Services AddHostedService<WhizbangProcessor>();\n// Step 3: Update message sending (optional)\n// Change from Send (synchronous) to Publish (async)\n// Before:\nvar result = await whizbang Send(command);\n// After (for background processing):\nawait whizbang Publish(command);\n// Your handlers remain EXACTLY the same `\nFrom Durable to Distributed\n`csharp{\ntitle: \"Migrating to Distributed Mode\"\ndescription: \"Steps to split monolith into microservices\"\nframework: \"NET8\"\ncategory: \"Migration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Migration\", \"Microservices\", \"Distribution\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Kafka\"]\nfilename: \"MigrateToDistributed cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Step 1: Define service boundaries\n// Orders Service\nbuilder Services ConfigureDomain(\"Orders\", domain => {\n    domain OwnsAggregate<Order>();\n    domain HandlesCommands<CreateOrder, ShipOrder>();\n});\n// Inventory Service  \nbuilder Services ConfigureDomain(\"Inventory\", domain => {\n    domain OwnsAggregate<Product>();\n    domain HandlesCommands<ReserveStock, ReleaseStock>();\n});\n// Step 2: Add message broker\nbuilder Services AddWhizbang() UseDistributedMode() UseKafka(kafkaConfig);\n// Step 3: Deploy services independently\n// Each service has its own database\n// Communication via Kafka\n// Handlers remain EXACTLY the same `\nFrom Distributed to Event-Sourced\n`csharp{\ntitle: \"Migrating to Event Sourcing\"\ndescription: \"Steps to add event sourcing to existing system\"\nframework: \"NET8\"\ncategory: \"Migration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Migration\", \"Event Sourcing\", \"CQRS\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventStore\"]\nfilename: \"MigrateToEventSourced cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Step 1: Convert entities to aggregates\n// Before:\npublic class Order {\n    public void UpdateStatus(OrderStatus status) {\n        Status = status;\n        repository",
        "startIndex": 21727,
        "preview": "add durability to existing application\" framework: \"NET8\" category: \"Migration\" difficulty: \"INTERMEDIATE\" tags: [\"Migration\", \"Durability\", \"Evolutio..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/progressive-enhancement-chunk-11",
        "text": "to existing system\" framework: \"NET8\" category: \"Migration\" difficulty: \"ADVANCED\" tags: [\"Migration\", \"Event Sourcing\", \"CQRS\"] nugetPackages: [\"Whizbang Core\", \"Whizbang EventStore\"] filename: \"MigrateToEventSourced cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"System\"] } // Step 1: Convert entities to aggregates // Before: public class Order { public void UpdateStatus(OrderStatus status) { Status = status; repository Save(this);\n    }\n}\n// After:\n[EventSourced]\npublic class Order : Aggregate {\n    public OrderStatusChanged UpdateStatus(ChangeOrderStatus cmd) {\n        // Return event instead of saving directly\n        return new OrderStatusChanged(Id, cmd NewStatus);\n    }\n    public void Apply(OrderStatusChanged @event) {\n        Status = @event NewStatus;\n    }\n}\n// Step 2: Update configuration\nbuilder Services AddWhizbang() UseEventSourcedMode() UseEventStore(config);\n// Step 3: Build projections for queries\nbuilder Services RegisterProjection<OrderListProjection>();\n// Step 4: Migrate historical data (optional)\nawait migrator MigrateToEventStore(existingOrders);\n// Core handler logic remains similar `\nTesting Across Modes\n`csharp{\ntitle: \"Testing Progressive Enhancement\"\ndescription: \"Verify handlers work correctly in all modes\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Testing\", \"Cross-Mode\", \"Verification\"]\nnugetPackages: [\"Whizbang Core\", \"xUnit\"]\nfilename: \"ProgressiveTests cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang Testing\", \"Xunit\"]\n}\npublic class CrossModeTests {\n    private readonly CreateOrder _command = new() {\n        CustomerId = Guid NewGuid(),\n        Items = new[] { new OrderItem(\"SKU-1\", 2, 10 00m) }\n    };\n    [Theory]\n    [InlineData(\"InProcess\")]\n    [InlineData(\"Durable\")]\n    [InlineData(\"Distributed\")]\n    [InlineData(\"EventSourced\")]\n    public async Task Handler_WorksInAllModes(string mode) {\n        // Arrange\n        var whizbang = BuildWhizbang(mode);\n        // Act\n        var result = await whizbang Send(_command);\n        // Assert - Same expectations regardless of mode\n        Assert NotNull(result);\n        Assert IsType<OrderCreated>(result);\n        var orderCreated = (OrderCreated)result;\n        Assert Equal(_command CustomerId, orderCreated CustomerId);\n        Assert Equal(20 00m, orderCreated Total);\n    }\n    private IWhizbang BuildWhizbang(string mode) {\n        return mode switch {\n            \"InProcess\" => new WhizbangBuilder() UseInProcessMode() Build(),\n            \"Durable\" => new WhizbangBuilder() UseDurableMode() UseInMemoryPersistence() Build(),\n            \"Distributed\" => new WhizbangBuilder() UseDistributedMode() UseInMemoryMessageBroker() Build(),\n            \"EventSourced\" => new WhizbangBuilder() UseEventSourcedMode() UseInMemoryEventStore()",
        "startIndex": 23773,
        "preview": "to existing system\" framework: \"NET8\" category: \"Migration\" difficulty: \"ADVANCED\" tags: [\"Migration\", \"Event Sourcing\", \"CQRS\"] nugetPackages: [\"Whiz..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/progressive-enhancement-chunk-12",
        "text": "var orderCreated = (OrderCreated)result; Assert Equal(_command CustomerId, orderCreated CustomerId); Assert Equal(20 00m, orderCreated Total); } private IWhizbang BuildWhizbang(string mode) { return mode switch { \"InProcess\" => new WhizbangBuilder() UseInProcessMode() Build(), \"Durable\" => new WhizbangBuilder() UseDurableMode() UseInMemoryPersistence() Build(), \"Distributed\" => new WhizbangBuilder() UseDistributedMode() UseInMemoryMessageBroker() Build(), \"EventSourced\" => new WhizbangBuilder() UseEventSourcedMode() UseInMemoryEventStore() Build(),\n            _ => throw new ArgumentException($\"Unknown mode: {mode}\")\n        };\n    }\n}\n// Performance comparison across modes\n[Benchmark]\npublic class ModeBenchmarks {\n    [Params(\"InProcess\", \"Durable\", \"Distributed\", \"EventSourced\")]\n    public string Mode { get; set; }\n    private IWhizbang _whizbang;\n    [GlobalSetup]\n    public void Setup() {\n        _whizbang = BuildWhizbang(Mode);\n    }\n    [Benchmark]\n    public async Task ProcessOrder() {\n        await _whizbang Send(new CreateOrder { });\n    }\n}\n`\nBest Practices\nDo's\n✅ Start with the simplest mode that works\n`csharp{\ntitle: \"Progressive Mode Selection\"\ndescription: \"Start simple and scale when needed\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Progressive Enhancement\", \"Mode Selection\", \"Best Practices\"]\nfilename: \"ModeSelection cs\"\nusingStatements: [\"Whizbang\"]\n}\n// Development: UseInProcessMode()\n// Production: Start with UseDurableMode()\n// Scale when needed\n`\n✅ Keep handlers focused on business logic\n`csharp{\ntitle: \"Clean Handler Design\"\ndescription: \"Focus handlers on business logic only\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Handler Design\", \"Best Practices\", \"Clean Code\"]\nfilename: \"CleanHandler cs\"\nusingStatements: [\"Whizbang\"]\n}\npublic OrderCreated Handle(CreateOrder cmd) {\n    // Only business logic, no infrastructure\n}\n`\n✅ Use aspects for cross-cutting concerns\n`csharp{\ntitle: \"Cross-Cutting Concerns with Aspects\"\ndescription: \"Use attributes for logging, validation, and transactions\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Aspects\", \"Cross-Cutting Concerns\", \"Attributes\"]\nfilename: \"OrderHandler cs\"\nusingStatements: [\"Whizbang\"]\n}\n[Logged]\n[Validated]\n[Transactional]\npublic class OrderHandler : IHandle<CreateOrder>\n`\n✅ Test handlers independently of mode\n`csharp{\ntitle: \"Cross-Mode Testing\"\ndescription: \"Test handlers work across all modes\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Testing\", \"Cross-Mode\", \"Theory Tests\"]\nfilename: \"CrossModeTests",
        "startIndex": 26342,
        "preview": "var orderCreated = (OrderCreated)result; Assert Equal(_command CustomerId, orderCreated CustomerId); Assert Equal(20 00m, orderCreated Total); } priva..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/progressive-enhancement-chunk-13",
        "text": "[\"Aspects\", \"Cross-Cutting Concerns\", \"Attributes\"] filename: \"OrderHandler cs\" usingStatements: [\"Whizbang\"] } [Logged] [Validated] [Transactional] public class OrderHandler : IHandle<CreateOrder> ` ✅ Test handlers independently of mode `csharp{ title: \"Cross-Mode Testing\" description: \"Test handlers work across all modes\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"INTERMEDIATE\" tags: [\"Testing\", \"Cross-Mode\", \"Theory Tests\"] filename: \"CrossModeTests cs\"\nusingStatements: [\"Xunit\", \"Whizbang\"]\n}\n[Theory]\n[InlineData(\"InProcess\")]\n[InlineData(\"Durable\")]\npublic async Task TestAcrossModes(string mode)\n`\nDon'ts\n❌ Don't add mode-specific logic to handlers\n`csharp{\ntitle: \"Anti-Pattern: Mode-Specific Logic\"\ndescription: \"Don't add mode-specific logic to handlers\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Anti-Pattern\", \"Bad Practice\", \"Mode-Specific\"]\nfilename: \"BadModeLogic cs\"\n}\n// BAD\nif (IsDistributedMode()) {\n    // Special distributed logic\n}\n`\n❌ Don't skip modes unnecessarily\n`csharp{\ntitle: \"Anti-Pattern: Skipping Modes\"\ndescription: \"Don't jump directly to complex modes\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Anti-Pattern\", \"Progressive Enhancement\", \"Evolution\"]\nfilename: \"ModeProgression cs\"\n}\n// BAD: Jumping straight to event sourcing\n// GOOD: Progress through modes as needed\n`\n❌ Don't mix modes in same deployment\n`csharp{\ntitle: \"Anti-Pattern: Mixed Modes\"\ndescription: \"Don't mix different modes in same deployment\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Anti-Pattern\", \"Deployment\", \"Consistency\"]\nfilename: \"MixedModes cs\"\n}\n// BAD: Some handlers durable, others distributed\n// GOOD: Consistent mode across application\n`\nReal-World Evolution\n`csharp{\ntitle: \"E-Commerce Platform Evolution\"\ndescription: \"Real example of progressive enhancement over time\"\nframework: \"NET8\"\ncategory: \"Real World\"\ndifficulty: \"ADVANCED\"\ntags: [\"Case Study\", \"E-Commerce\", \"Evolution\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"ECommercePlatform cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Year 1: Startup - In-Process Mode\n// Simple monolith, 100 orders/day\npublic class StartupPhase {\n    public void Configure(IServiceCollection services) {\n        services AddWhizbang() UseInProcessMode()",
        "startIndex": 28455,
        "preview": "[\"Aspects\", \"Cross-Cutting Concerns\", \"Attributes\"] filename: \"OrderHandler cs\" usingStatements: [\"Whizbang\"] } [Logged] [Validated] [Transactional] p..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/progressive-enhancement-chunk-14",
        "text": "over time\" framework: \"NET8\" category: \"Real World\" difficulty: \"ADVANCED\" tags: [\"Case Study\", \"E-Commerce\", \"Evolution\"] nugetPackages: [\"Whizbang Core\"] filename: \"ECommercePlatform cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"System\"] } // Year 1: Startup - In-Process Mode // Simple monolith, 100 orders/day public class StartupPhase { public void Configure(IServiceCollection services) { services AddWhizbang() UseInProcessMode() RegisterHandlers();\n        // Simple, fast, easy to debug\n        // No infrastructure complexity\n    }\n}\n// Year 2: Growth - Durable Mode\n// Need reliability, 1,000 orders/day\npublic class GrowthPhase {\n    public void Configure(IServiceCollection services) {\n        services AddWhizbang() UseDurableMode() UsePostgreSQL(connectionString) WithOutbox() WithRetry();\n        // Same handlers, added durability\n        // Background processing for emails\n        // Retry for payment processing\n    }\n}\n// Year 3: Scale - Distributed Mode\n// Multiple teams, 10,000 orders/day\npublic class ScalePhase {\n    // Orders Service\n    public class OrdersService {\n        public void Configure(IServiceCollection services) {\n            services AddWhizbang() UseDistributedMode() UseKafka(kafkaConfig) ConfigureDomain(\"Orders\");\n        }\n    }\n    // Inventory Service (different team)\n    public class InventoryService {\n        public void Configure(IServiceCollection services) {\n            services AddWhizbang() UseDistributedMode() UseKafka(kafkaConfig) ConfigureDomain(\"Inventory\");\n        }\n    }\n    // Same handler code, now distributed\n    // Independent deployment and scaling\n}\n// Year 4: Enterprise - Event-Sourced Mode\n// Compliance requirements, 100,000 orders/day\npublic class EnterprisePhase {\n    public void Configure(IServiceCollection services) {\n        services AddWhizbang() UseEventSourcedMode() UseEventStore(eventStoreConfig) UseProjections(projectionConfig) WithTimeTravel() WithSnapshots();\n        // Complete audit trail\n        // Time-travel debugging\n        // Complex analytics from event stream\n        // STILL the same handler patterns }\n}\n`\nSummary\nProgressive Enhancement in Whizbang allows you to:\nStart simple with event-driven development mode\nAdd persistence when you need reliability with perspectives\nScale to distributed when teams grow with relays\nEmbrace event sourcing when the domain demands stateful receptors\nAll without changing your receptor code This is the power of Whizbang's unified architecture - write once, scale infinitely",
        "startIndex": 30374,
        "preview": "over time\" framework: \"NET8\" category: \"Real World\" difficulty: \"ADVANCED\" tags: [\"Case Study\", \"E-Commerce\", \"Evolution\"] nugetPackages: [\"Whizbang C..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/progressive-enhancement-chunk-15",
        "text": "Start simple with event-driven development mode Add persistence when you need reliability with perspectives Scale to distributed when teams grow with relays Embrace event sourcing when the domain demands stateful receptors All without changing your receptor code This is the power of Whizbang's unified architecture - write once, scale infinitely Next Steps\nReview Event-Driven Dispatcher Pattern to start with basics\nExplore Event Sourcing Basics for stateful receptor patterns\nLearn about Receptors for command handling\nSee Perspectives for event handling and read models",
        "startIndex": 32685,
        "preview": "Start simple with event-driven development mode Add persistence when you need reliability with perspectives Scale to distributed when teams grow with ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/usage-patterns/saga-orchestration",
    "title": "Saga Orchestration",
    "category": "Usage Patterns",
    "url": "/docs/old-v1.0.0/usage-patterns/saga-orchestration",
    "chunks": [
      {
        "id": "old-v1.0.0/usage-patterns/saga-orchestration-chunk-0",
        "text": "Saga Orchestration\nOverview\nThe Saga pattern manages long-running business transactions that span multiple aggregates or services Whizbang provides comprehensive support for both orchestration and choreography-based sagas, with built-in compensation for handling failures What is a Saga A saga is a sequence of local transactions where each transaction updates data within a single service If a step fails, the saga executes compensating transactions to undo the impact of preceding transactions When to Use Sagas\nMulti-step workflows: Order fulfillment, payment processing\nCross-service transactions: Operations spanning multiple bounded contexts\nLong-running processes: Approval workflows, batch processing\nCompensatable operations: Actions that can be reversed or compensated\nArchitecture Diagram\n`mermaid\nstateDiagram-v2\n    [*] --> OrderPlaced\n    OrderPlaced --> PaymentProcessed: Process Payment\n    OrderPlaced --> OrderCancelled: Cancel\n    PaymentProcessed --> InventoryReserved: Reserve Inventory\n    PaymentProcessed --> PaymentRefunded: Fail\n    InventoryReserved --> OrderShipped: Ship Order\n    InventoryReserved --> InventoryReleased: Fail\n    OrderShipped --> [*]: Success\n    PaymentRefunded --> OrderCancelled: Compensate\n    InventoryReleased --> PaymentRefunded: Compensate\n    OrderCancelled --> [*]: Cancelled\n`\nImplementation Guide\nDocumentation in progress - This page demonstrates the structure for saga orchestration patterns with Whizbang Topics to Cover:\nSaga Definition\nState machine configuration\nStep definitions\nCompensation logic\nOrchestration Pattern\nCentral coordinator\nState management\nStep execution\nChoreography Pattern\nEvent-driven coordination\nDecentralized flow\nEvent subscriptions\nCompensation Strategies\nBackward recovery\nForward recovery\nPivot transactions\nError Handling\nTimeout management\nRetry policies\nManual intervention\nExample: Order Fulfillment Saga\n`csharp{\ntitle: \"Order Fulfillment Saga Example\"\ndescription: \"Placeholder for comprehensive saga implementation example\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Sagas\", \"Orchestration\", \"Workflow\"]\nnugetPackages: [\"Whizbang Sagas\"]\nusingStatements: [\"Whizbang",
        "startIndex": 0,
        "preview": "Saga Orchestration\nOverview\nThe Saga pattern manages long-running business transactions that span multiple aggregates or services Whizbang provides co..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/saga-orchestration-chunk-1",
        "text": "subscriptions Compensation Strategies Backward recovery Forward recovery Pivot transactions Error Handling Timeout management Retry policies Manual intervention Example: Order Fulfillment Saga `csharp{ title: \"Order Fulfillment Saga Example\" description: \"Placeholder for comprehensive saga implementation example\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"ADVANCED\" tags: [\"Sagas\", \"Orchestration\", \"Workflow\"] nugetPackages: [\"Whizbang Sagas\"] usingStatements: [\"Whizbang Sagas\"]\nshowLineNumbers: true\n}\n// Placeholder for comprehensive saga implementation example\npublic class OrderFulfillmentSaga : Saga<OrderFulfillmentState> {\n    // Implementation details coming soon\n}\n`\nRelated Patterns\nEvent Sourcing Basics - Event-driven foundation\nCQRS Implementation - Query side for saga state\nDistributed Messaging - Cross-service communication\nNext Steps\nExplore Microservices Integration for deployment patterns\nReview Advanced Scenarios for production tips\nCheck Command Handling for command patterns",
        "startIndex": 2206,
        "preview": "subscriptions Compensation Strategies Backward recovery Forward recovery Pivot transactions Error Handling Timeout management Retry policies Manual in..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0/usage-patterns/simple-mediator",
    "title": "Event-Driven Dispatcher Pattern",
    "category": "Usage Patterns",
    "url": "/docs/old-v1.0.0/usage-patterns/simple-mediator",
    "chunks": [
      {
        "id": "old-v1.0.0/usage-patterns/simple-mediator-chunk-0",
        "text": "Event-Driven Dispatcher Pattern\nOverview\nThe Event-Driven Dispatcher pattern is your entry point into the Whizbang library It provides a clean way to handle commands and queries using event-driven architecture, where all state changes flow through events This pattern is perfect for:\nGetting started with event-driven concepts\nBuilding applications with clear separation between reads and writes\nLearning the receptor/perspective/lens pattern\nStarting with Event-Driven mode before adding Event Sourcing\nKey Benefits\nProgressive Enhancement: Same code works from monolith to microservices\nConvention Over Configuration: Return types determine behavior\nAspect-Oriented: Cross-cutting concerns via declarative attributes\nCompile-Time Safety: Source generators catch errors at build time\nZero Overhead: Generated code performs like hand-written code\nArchitecture Diagram\n`mermaid\ngraph LR\n    Client[Client/Controller] --> Dispatcher[Whizbang Dispatcher]\n    Dispatcher --> Receptor[Receptor]\n    Receptor --> Event[Event]\n    Event --> Perspective[Perspective]\n    Perspective --> DB[Database]\n    Client --> Lens[Lens]\n    Lens --> DB\n    style Dispatcher fill:#0066cc,color:#fff\n    style Receptor fill:#28a745,color:#fff\n    style Perspective fill:#ffc107,color:#000\n    style Lens fill:#17a2b8,color:#fff\n`\nCore Components\nRequired Packages\n`xml{\ntitle: \"Required Package Reference\"\ndescription: \"Add Whizbang Core NuGet package to your project\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Simple Mediator\", \"NuGet\", \"Installation\"]\nfilename: \"YourProject csproj\"\nshowLineNumbers: true\n}\n<PackageReference Include=\"Whizbang Core\" Version=\"1 0 0\" />\n`\nThe Event-Driven Approach\nWhizbang uses a unified event-driven pattern:\nReceptors: Receive commands and emit events\nPerspectives: React to events and update views\nLenses: Provide read-only access to data\nAll writes through events: Even in non-event-sourced mode\nReturn Type Semantics: What you return determines what happens\nStep-by-Step Implementation\nStep 1: Define Your Messages\n`csharp{\ntitle: \"Message Definitions\"\ndescription: \"Simple message types - no special interfaces required\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Messages\", \"Commands\", \"Queries\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"OrderMessages cs\"\nshowLineNumbers: true\nusingStatements: [\"System\", \"System Collections Generic\"]\n}\nusing System;\nusing System Collections Generic;\nnamespace MyApp",
        "startIndex": 0,
        "preview": "Event-Driven Dispatcher Pattern\nOverview\nThe Event-Driven Dispatcher pattern is your entry point into the Whizbang library It provides a clean way to ..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/simple-mediator-chunk-1",
        "text": "1: Define Your Messages `csharp{ title: \"Message Definitions\" description: \"Simple message types - no special interfaces required\" framework: \"NET8\" category: \"Domain Logic\" difficulty: \"BEGINNER\" tags: [\"Messages\", \"Commands\", \"Queries\"] nugetPackages: [\"Whizbang Core\"] filename: \"OrderMessages cs\" showLineNumbers: true usingStatements: [\"System\", \"System Collections Generic\"] } using System; using System Collections Generic; namespace MyApp Orders;\n// Command: A message that changes state\npublic record CreateOrder(\n    Guid CustomerId,\n    List<OrderItem> Items,\n    string ShippingAddress\n);\n// Query: A message that reads data\npublic record GetOrderById(Guid OrderId);\n// Event: Something that happened\npublic record OrderCreated(\n    Guid OrderId,\n    Guid CustomerId,\n    decimal TotalAmount,\n    DateTime CreatedAt\n);\n// Response types\npublic record OrderDetails(\n    Guid OrderId,\n    Guid CustomerId,\n    List<OrderItem> Items,\n    decimal TotalAmount,\n    string Status,\n    DateTime CreatedAt\n);\n// Domain model\npublic record OrderItem(\n    string ProductId,\n    string ProductName,\n    int Quantity,\n    decimal UnitPrice\n);\n`\nStep 2: Implement Receptors with Return Type Semantics\n`csharp{\ntitle: \"Receptor Implementation - Event-Driven Approach\"\ndescription: \"Receptors emit events, perspectives handle writes\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Events\", \"Perspectives\", \"Lenses\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"OrderReceptors cs\"\nshowLineNumbers: true\nhighlightLines: [8, 13, 29, 45]\nusingStatements: [\"Whizbang\", \"System\", \"System Linq\"]\n}\nusing Whizbang;\nusing System;\nusing System Linq;\nnamespace MyApp Orders Receptors;\n// Receptor with aspects - receives commands, emits events\n[Logged]\n[Validated]\n[Transactional]\npublic class CreateOrderReceptor : IReceptor<CreateOrder> {\n    // Return type determines behavior: OrderCreated event flows to perspectives\n    public OrderCreated Receive(CreateOrder cmd, IOrderLens lens) {\n        // Validate using lens (read-only)\n        if ( lens CustomerExists(cmd CustomerId)) {\n            throw new CustomerNotFoundException();\n        }\n        // Calculate total\n        var totalAmount = cmd Items Sum(i => i Quantity * i UnitPrice);\n        // Emit event - perspectives handle all writes\n        return new OrderCreated(\n            Guid NewGuid(),\n            cmd CustomerId,\n            totalAmount,\n            DateTime",
        "startIndex": 2492,
        "preview": "1: Define Your Messages `csharp{ title: \"Message Definitions\" description: \"Simple message types - no special interfaces required\" framework: \"NET8\" c..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/simple-mediator-chunk-2",
        "text": "IOrderLens lens) { // Validate using lens (read-only) if ( lens CustomerExists(cmd CustomerId)) { throw new CustomerNotFoundException(); } // Calculate total var totalAmount = cmd Items Sum(i => i Quantity * i UnitPrice); // Emit event - perspectives handle all writes return new OrderCreated( Guid NewGuid(), cmd CustomerId, totalAmount, DateTime UtcNow\n        );\n    }\n}\n// Lens provides read-only queries\npublic class OrderLens : IOrderLens {\n    private readonly IDatabase db;\n    [Cached(Duration = \"5m\")]\n    public OrderDetails Focus(Guid orderId) {\n        var order = db Orders Find(orderId);\n        if (order == null) {\n            throw new NotFoundException($\"Order {orderId} not found\");\n        }\n        // Return read-only view\n        return new OrderDetails(\n            order Id,\n            order CustomerId,\n            order Items,\n            order TotalAmount,\n            order Status,\n            order CreatedAt\n        );\n    }\n    public bool CustomerExists(Guid customerId) {\n        return db Customers Any(c => c Id == customerId);\n    }\n}\n// Receptor returning multiple events via tuple\npublic class ProcessOrderReceptor : IReceptor<ProcessOrder> {\n    // Tuple return = multiple events flow to perspectives\n    public (OrderProcessed, EmailQueued, InventoryReserved) Receive(ProcessOrder cmd) {\n        // Make decisions, emit events\n        return (\n            new OrderProcessed(cmd OrderId),\n            new EmailQueued(cmd CustomerEmail, \"Order confirmed\"),\n            new InventoryReserved(cmd Items)\n        );\n    }\n}\n`\nStep 3: Implement Perspectives for Write Operations\n`csharp{\ntitle: \"Perspective Implementation - Handle All Writes\"\ndescription: \"Perspectives react to events and update storage\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Perspectives\", \"Events\", \"Database Updates\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"OrderPerspectives cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\"]\n}\nusing Whizbang;\nusing System;\nusing System Threading Tasks;\nnamespace MyApp Orders Perspectives;\n// Perspective handles all database writes\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> {\n    private readonly IDatabase db;\n    public async Task Update(OrderCreated e) {\n        // Create order in database\n        await db Orders Add(new Order {\n            Id = e OrderId,\n            CustomerId = e CustomerId,\n            Total = e TotalAmount,\n            Status = \"Pending\",\n            CreatedAt = e CreatedAt\n        });\n        await db",
        "startIndex": 4505,
        "preview": "IOrderLens lens) { // Validate using lens (read-only) if ( lens CustomerExists(cmd CustomerId)) { throw new CustomerNotFoundException(); } // Calculat..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/simple-mediator-chunk-3",
        "text": "writes public class OrderPerspective : IPerspectiveOf<OrderCreated> { private readonly IDatabase db; public async Task Update(OrderCreated e) { // Create order in database await db Orders Add(new Order { Id = e OrderId, CustomerId = e CustomerId, Total = e TotalAmount, Status = \"Pending\", CreatedAt = e CreatedAt }); await db SaveChanges();\n    }\n}\n// Multiple perspectives can react to same event\npublic class CustomerStatsPerspective : IPerspectiveOf<OrderCreated> {\n    private readonly IDatabase db;\n    public async Task Update(OrderCreated e) {\n        await db CustomerStats IncrementOrderCount(e CustomerId);\n        await db CustomerStats UpdateLastOrderDate(e CustomerId, e CreatedAt);\n    }\n}\n// Cache perspective\npublic class CachePerspective : IPerspectiveOf<OrderCreated> {\n    private readonly ICache cache;\n    public async Task Update(OrderCreated e) {\n        // Invalidate customer cache\n        await cache Remove($\"customer:{e CustomerId}:orders\");\n    }\n}\n`\nStep 4: Wire Up Your Application\n`csharp{\ntitle: \"Service Configuration\"\ndescription: \"Configure dispatcher with receptors, perspectives, and lenses\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"BEGINNER\"\ntags: [\"DI\", \"Configuration\", \"Progressive Enhancement\"]\nnugetPackages: [\"Whizbang Core\", \"Microsoft Extensions DependencyInjection\"]\nfilename: \"Program cs\"\nshowLineNumbers: true\nhighlightLines: [8, 11, 20, 28]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\nusing Whizbang;\nusing Microsoft AspNetCore Builder;\nusing Microsoft Extensions DependencyInjection;\nusing MyApp Orders Receptors;\nusing MyApp Orders Perspectives;\nvar builder = WebApplication CreateBuilder(args);\n// Configure Event-Driven mode\nbuilder Services AddWhizbang() UseDispatcher(dispatcher => {\n        dispatcher DefaultPolicy = new EventDrivenPolicy();\n        // Register components\n        dispatcher RegisterReceptorsFromAssembly(typeof(Program) Assembly);\n        dispatcher RegisterPerspectivesFromAssembly(typeof(Program) Assembly);\n        dispatcher RegisterLensesFromAssembly(typeof(Program) Assembly);\n    });\n// Register lenses (read-only queries)\nbuilder Services AddScoped<IOrderLens, OrderLens>();\nbuilder Services AddScoped<ICustomerLens, CustomerLens>();\n// When ready for Event-Sourcing\n// dispatcher ForReceptor<Order>() UsePolicy(new EventSourcedPolicy());\n// When scaling to distributed\n// dispatcher UseRelay<KafkaRelay>();\nbuilder Services AddControllers();\nvar app = builder Build();\napp UseRouting();\napp MapControllers();\napp Run();\n`\nComplete Example\n`csharp{\ntitle: \"Complete Event-Driven Example\"\ndescription: \"Full working example with receptors, perspectives, and lenses\"\nframework: \"NET8\"\ncategory: \"Complete Example\"\ndifficulty: \"BEGINNER\"\ntags: [\"API\", \"Controller\", \"Dispatcher\", \"Event-Driven\", \"Complete\"]\nnugetPackages: [\"Whizbang",
        "startIndex": 6737,
        "preview": "writes public class OrderPerspective : IPerspectiveOf<OrderCreated> { private readonly IDatabase db; public async Task Update(OrderCreated e) { // Cre..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/simple-mediator-chunk-4",
        "text": "distributed // dispatcher UseRelay<KafkaRelay>(); builder Services AddControllers(); var app = builder Build(); app UseRouting(); app MapControllers(); app Run(); ` Complete Example `csharp{ title: \"Complete Event-Driven Example\" description: \"Full working example with receptors, perspectives, and lenses\" framework: \"NET8\" category: \"Complete Example\" difficulty: \"BEGINNER\" tags: [\"API\", \"Controller\", \"Dispatcher\", \"Event-Driven\", \"Complete\"] nugetPackages: [\"Whizbang Core\", \"Microsoft AspNetCore Mvc\"]\nfilename: \"OrdersController cs\"\nshowLineNumbers: true\nhighlightLines: [14, 23, 33]\ntestFile: \"OrdersControllerTests cs\"\ntestMethod: \"CreateOrder_ValidCommand_ReturnsOrderId\"\nusingStatements: [\"Whizbang\", \"Microsoft AspNetCore Mvc\", \"System\"]\n}\nusing Whizbang;\nusing Microsoft AspNetCore Mvc;\nusing System;\nusing MyApp Orders;\nnamespace MyApp Controllers;\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class OrdersController : ControllerBase {\n    private readonly IDispatcher _dispatcher;\n    private readonly IOrderLens _orderLens;\n    public OrdersController(IDispatcher dispatcher, IOrderLens orderLens) {\n        _dispatcher = dispatcher;\n        _orderLens = orderLens;\n    }\n    [HttpPost]\n    public async Task<ActionResult<OrderCreated>> CreateOrder(\n        [FromBody] CreateOrderRequest request) {\n        // Map request to command\n        var command = new CreateOrder(\n            request CustomerId,\n            request Items,\n            request ShippingAddress\n        );\n        try {\n            // Dispatcher routes to receptor, event flows to perspectives\n            var @event = await _dispatcher Dispatch(command);\n            return Ok(@event);\n        }\n        catch (ValidationException ex) {\n            return BadRequest(new { error = ex Message });\n        }\n        catch (InsufficientInventoryException ex) {\n            return Conflict(new { error = ex Message });\n        }\n    }\n    [HttpGet(\"{orderId}\")]\n    public async Task<ActionResult<OrderDetails>> GetOrder(Guid orderId) {\n        try {\n            // Use lens for queries (read-only)\n            var order = _orderLens Focus(orderId);\n            return Ok(order);\n        }\n        catch (NotFoundException ex) {\n            return NotFound(new { error = ex Message });\n        }\n    }\n    [HttpPost(\"{orderId}/process\")]\n    public async Task<ActionResult> ProcessOrder(Guid orderId) {\n        // Receptor returns tuple - all events flow to perspectives\n        var (orderProcessed, emailQueued, inventoryReserved) = \n            await _dispatcher Dispatch(new ProcessOrder(orderId));\n        return Ok(new {\n            orderId = orderProcessed OrderId,\n            emailQueued = emailQueued QueueId,\n            inventoryReserved = inventoryReserved",
        "startIndex": 7691,
        "preview": "distributed // dispatcher UseRelay<KafkaRelay>(); builder Services AddControllers(); var app = builder Build(); app UseRouting(); app MapControllers()..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/simple-mediator-chunk-5",
        "text": "return NotFound(new { error = ex Message }); } } [HttpPost(\"{orderId}/process\")] public async Task<ActionResult> ProcessOrder(Guid orderId) { // Receptor returns tuple - all events flow to perspectives var (orderProcessed, emailQueued, inventoryReserved) = await _dispatcher Dispatch(new ProcessOrder(orderId)); return Ok(new { orderId = orderProcessed OrderId, emailQueued = emailQueued QueueId, inventoryReserved = inventoryReserved ReservationId\n        });\n    }\n}\n// Request DTOs\npublic record CreateOrderRequest(\n    Guid CustomerId,\n    List<OrderItem> Items,\n    string ShippingAddress\n);\n`\nTesting Strategy\nUnit Testing Receptors and Perspectives\n`csharp{\ntitle: \"Receptor and Perspective Unit Tests\"\ndescription: \"Test receptors and perspectives in isolation\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"BEGINNER\"\ntags: [\"Unit Testing\", \"xUnit\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\", \"xUnit\"]\nfilename: \"CreateOrderHandlerTests cs\"\nshowLineNumbers: true\nhighlightLines: [15, 25, 40]\nusingStatements: [\"Whizbang\", \"Xunit\"]\n}\nusing Whizbang;\nusing Xunit;\nusing System;\nusing System Collections Generic;\nusing MyApp Orders;\nusing MyApp Orders Receptors;\nusing MyApp Orders Perspectives;\nnamespace MyApp Tests Orders;\npublic class CreateOrderReceptorTests {\n    [Fact]\n    public void Receive_ValidCommand_ReturnsOrderCreatedEvent() {\n        // Arrange\n        var receptor = new CreateOrderReceptor();\n        var command = new CreateOrder(\n            Guid NewGuid(),\n            new List<OrderItem> {\n                new OrderItem(\"PROD-1\", \"Widget\", 2, 10 00m)\n            },\n            \"123 Main St\"\n        );\n        var lens = Mock Of<IOrderLens>(l => \n            l CustomerExists(It IsAny<Guid>()) == true\n        );\n        // Act - Receptor emits event\n        var @event = receptor Receive(command, lens);\n        // Assert - Event emitted\n        Assert NotNull(@event);\n        Assert IsType<OrderCreated>(@event);\n        Assert Equal(20 00m, @event TotalAmount);\n    }\n    [Fact]\n    public void Receive_ProcessOrder_ReturnsMultipleEvents() {\n        // Arrange\n        var receptor = new ProcessOrderReceptor();\n        var command = new ProcessOrder(Guid NewGuid());\n        // Act - Receptor returns tuple of events\n        var (processed, emailQueued, inventoryReserved) = receptor Receive(command);\n        // Assert - All events emitted\n        Assert NotNull(processed);\n        Assert NotNull(emailQueued);\n        Assert NotNull(inventoryReserved);\n        Assert Equal(command OrderId, processed",
        "startIndex": 11567,
        "preview": "return NotFound(new { error = ex Message }); } } [HttpPost(\"{orderId}/process\")] public async Task<ActionResult> ProcessOrder(Guid orderId) { // Recep..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/simple-mediator-chunk-6",
        "text": "} [Fact] public void Receive_ProcessOrder_ReturnsMultipleEvents() { // Arrange var receptor = new ProcessOrderReceptor(); var command = new ProcessOrder(Guid NewGuid()); // Act - Receptor returns tuple of events var (processed, emailQueued, inventoryReserved) = receptor Receive(command); // Assert - All events emitted Assert NotNull(processed); Assert NotNull(emailQueued); Assert NotNull(inventoryReserved); Assert Equal(command OrderId, processed OrderId);\n    }\n}\n// Test Perspectives\npublic class PerspectiveTests {\n    [Fact]\n    public async Task OrderPerspective_UpdatesDatabase_WhenOrderCreatedReceived() {\n        // Arrange\n        var db = new InMemoryDatabase();\n        var perspective = new OrderPerspective(db);\n        var @event = new OrderCreated {\n            OrderId = Guid NewGuid(),\n            CustomerId = Guid NewGuid(),\n            TotalAmount = 100 00m\n        };\n        // Act - Perspective handles write\n        await perspective Update(@event);\n        // Assert - Database updated\n        var order = await db Orders Find(@event OrderId);\n        Assert NotNull(order);\n        Assert Equal(@event CustomerId, order CustomerId);\n        Assert Equal(@event TotalAmount, order Total);\n    }\n    [Fact]\n    public async Task Handler_WithLoggingAspect_LogsExecution() {\n        // Test logging aspect\n        await Whizbang Test<CreateOrderHandler>() Given(new CreateOrder { }) WithAspects() WhenHandled() ThenAspect<LoggingAspect>(logs => {\n                logs ShouldContain(\"Executing CreateOrderHandler\");\n                logs ShouldContain(\"Completed in\");\n            });\n    }\n}\n`\nCommon Pitfalls\nAvoid Direct Handler Calls\n`csharp{\ntitle: \"Proper Handler Usage Pattern\"\ndescription: \"Use the dispatcher instead of injecting handlers directly\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Simple Mediator\", \"Best Practices\", \"Anti-Patterns\"]\nfilename: \"OrderService cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\"]\n}\n// ❌ BAD - Don't inject and call handlers directly\npublic class OrderService {\n    private readonly CreateOrderHandler _handler;\n    public OrderService(CreateOrderHandler handler) {\n        _handler = handler;\n    }\n}\n// ✅ GOOD - Always use Whizbang for routing\npublic class OrderService {\n    private readonly IWhizbang _whizbang;\n    public OrderService(IWhizbang whizbang) {\n        _whizbang = whizbang;\n    }\n}\n`\nUse Return Types to Express Intent\n`csharp{\ntitle: \"Return Type Semantics Examples\"\ndescription: \"Express intent clearly through return types for proper event flow\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Simple Mediator\", \"Return Types\", \"Best Practices\", \"Events\"]\nfilename: \"ReturnTypeExamples",
        "startIndex": 13676,
        "preview": "} [Fact] public void Receive_ProcessOrder_ReturnsMultipleEvents() { // Arrange var receptor = new ProcessOrderReceptor(); var command = new ProcessOrd..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/simple-mediator-chunk-7",
        "text": "public OrderService(IWhizbang whizbang) { _whizbang = whizbang; } } ` Use Return Types to Express Intent `csharp{ title: \"Return Type Semantics Examples\" description: \"Express intent clearly through return types for proper event flow\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"BEGINNER\" tags: [\"Simple Mediator\", \"Return Types\", \"Best Practices\", \"Events\"] filename: \"ReturnTypeExamples cs\"\nshowLineNumbers: true\nusingStatements: [\"System\"]\n}\n// ❌ BAD - Unclear what happens with the result\npublic object Handle(CreateOrder cmd) {\n    return new { OrderId = Guid NewGuid() };\n}\n// ✅ GOOD - Return type makes intent clear\npublic OrderCreated Handle(CreateOrder cmd) {\n    return new OrderCreated(Guid NewGuid());\n}\n// ✅ GOOD - Multiple effects via tuple\npublic (OrderCreated, SendEmail) Handle(CreateOrder cmd) {\n    return (new OrderCreated(), new SendEmail());\n}\n`\nAvoid Business Logic in Controllers\n`csharp{\ntitle: \"Controller Logic Separation\"\ndescription: \"Keep business logic in handlers, not controllers\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Simple Mediator\", \"Controllers\", \"Separation of Concerns\", \"Best Practices\"]\nfilename: \"OrderController cs\"\nshowLineNumbers: true\nusingStatements: [\"Microsoft AspNetCore Mvc\", \"System Threading Tasks\"]\n}\n// ❌ BAD - Business logic in controller\n[HttpPost]\npublic async Task<IActionResult> CreateOrder(CreateOrderRequest request) {\n    if (request Items Sum(i => i Quantity * i UnitPrice) > 1000) {\n        // Business logic doesn't belong here request RequiresApproval = true;\n    }\n}\n// ✅ GOOD - All logic in handler\n[HttpPost]\npublic async Task<IActionResult> CreateOrder(CreateOrderRequest request) {\n    var command = MapToCommand(request);\n    var result = await _whizbang Send(command);\n    return Ok(result);\n}\n`\nProgressive Enhancement\nStart Simple\n`csharp{\ntitle: \"Phase 1: Simple In-Process Configuration\"\ndescription: \"Start with simple in-process messaging like MediatR\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Simple Mediator\", \"Configuration\", \"Progressive Enhancement\", \"In-Process\"]\nfilename: \"Program cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Phase 1: Simple in-process (like MediatR)\nbuilder Services AddWhizbang()",
        "startIndex": 16026,
        "preview": "public OrderService(IWhizbang whizbang) { _whizbang = whizbang; } } ` Use Return Types to Express Intent `csharp{ title: \"Return Type Semantics Exampl..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/simple-mediator-chunk-8",
        "text": "`csharp{ title: \"Phase 1: Simple In-Process Configuration\" description: \"Start with simple in-process messaging like MediatR\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"BEGINNER\" tags: [\"Simple Mediator\", \"Configuration\", \"Progressive Enhancement\", \"In-Process\"] filename: \"Program cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"] } // Phase 1: Simple in-process (like MediatR) builder Services AddWhizbang() UseInProcessMode();\n`\nAdd Durability When Needed\n`csharp{\ntitle: \"Phase 2: Durable Mode Configuration\"\ndescription: \"Add persistence and retry capabilities like Wolverine\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Simple Mediator\", \"Configuration\", \"Progressive Enhancement\", \"Durability\", \"PostgreSQL\"]\nfilename: \"Program cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Phase 2: Add persistence and retry (like Wolverine)\nbuilder Services AddWhizbang() UseDurableMode() UsePostgreSQL(connectionString) WithOutbox();\n`\nScale to Distributed\n`csharp{\ntitle: \"Phase 3: Distributed Mode Configuration\"\ndescription: \"Scale to microservices architecture like MassTransit\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Simple Mediator\", \"Configuration\", \"Progressive Enhancement\", \"Distributed\", \"Kafka\", \"Microservices\"]\nfilename: \"Program cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Phase 3: Microservices (like MassTransit)\nbuilder Services AddWhizbang() UseDistributedMode() UseKafka(kafkaConfig) WithSagaOrchestration();\n`\nEnable Event Sourcing\n`csharp{\ntitle: \"Phase 4: Event Sourcing Configuration\"\ndescription: \"Enable full event sourcing capabilities unique to Whizbang\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Simple Mediator\", \"Configuration\", \"Progressive Enhancement\", \"Event Sourcing\", \"Projections\"]\nfilename: \"Program cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Phase 4: Full event sourcing (unique to Whizbang)\nbuilder Services AddWhizbang() UseEventSourcedMode() UseEventStore(eventStoreConfig) WithProjections() WithSnapshots();\n`\nThe same handler code works in ALL modes",
        "startIndex": 17972,
        "preview": "`csharp{ title: \"Phase 1: Simple In-Process Configuration\" description: \"Start with simple in-process messaging like MediatR\" framework: \"NET8\" catego..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/simple-mediator-chunk-9",
        "text": "category: \"Usage Patterns\" difficulty: \"INTERMEDIATE\" tags: [\"Simple Mediator\", \"Configuration\", \"Progressive Enhancement\", \"Event Sourcing\", \"Projections\"] filename: \"Program cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"] } // Phase 4: Full event sourcing (unique to Whizbang) builder Services AddWhizbang() UseEventSourcedMode() UseEventStore(eventStoreConfig) WithProjections() WithSnapshots(); ` The same handler code works in ALL modes Related Patterns\nEvent Sourcing Basics - Add persistence and event history\nCQRS Implementation - Separate read and write models\nDistributed Messaging - Scale across services\nProduction Considerations\nPerformance\nZero-overhead aspects via source generation\nHandler pooling for reduced allocations\nCompile-time optimizations\nAdaptive runtime optimization\nMonitoring with Aspects\n`csharp{\ntitle: \"Monitoring with Aspects\"\ndescription: \"Built-in observability through declarative aspects\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Simple Mediator\", \"Aspects\", \"Monitoring\", \"Observability\", \"Logging\"]\nfilename: \"OrderHandler cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Built-in observability via aspects\n[Observed] // Automatic telemetry\n[Timed]    // Performance metrics\n[Logged]   // Structured logging\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Automatically generates:\n        // - Distributed trace spans\n        // - Metrics (count, duration, errors)\n        // - Structured logs with correlation IDs\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nError Handling with Result Types\n`csharp{\ntitle: \"Error Handling with Result Types\"\ndescription: \"Use Result types for robust error handling without exceptions\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Simple Mediator\", \"Error Handling\", \"Result Types\", \"Best Practices\"]\nfilename: \"OrderHandler cs\"\nshowLineNumbers: true\nusingStatements: [\"System\"]\n}\npublic Result<OrderCreated> Handle(CreateOrder cmd) {\n    if ( IsValid(cmd)) {\n        return Result Failure<OrderCreated>(\"Validation failed\");\n    }\n    try {\n        var order = CreateOrder(cmd);\n        return Result Success(new OrderCreated(order Id));\n    }\n    catch (Exception ex) {\n        return Result Failure<OrderCreated>(ex",
        "startIndex": 19898,
        "preview": "category: \"Usage Patterns\" difficulty: \"INTERMEDIATE\" tags: [\"Simple Mediator\", \"Configuration\", \"Progressive Enhancement\", \"Event Sourcing\", \"Project..."
      },
      {
        "id": "old-v1.0.0/usage-patterns/simple-mediator-chunk-10",
        "text": "tags: [\"Simple Mediator\", \"Error Handling\", \"Result Types\", \"Best Practices\"] filename: \"OrderHandler cs\" showLineNumbers: true usingStatements: [\"System\"] } public Result<OrderCreated> Handle(CreateOrder cmd) { if ( IsValid(cmd)) { return Result Failure<OrderCreated>(\"Validation failed\"); } try { var order = CreateOrder(cmd); return Result Success(new OrderCreated(order Id)); } catch (Exception ex) { return Result Failure<OrderCreated>(ex Message);\n    }\n}\n`\nNext Steps\nExplore Progressive Enhancement to scale your application\nLearn about Aspect-Oriented Handlers for cross-cutting concerns\nReview Return Type Semantics for advanced patterns\nCheck out Event Sourcing Basics when ready for event sourcing\nSee CQRS Implementation for read/write separation",
        "startIndex": 21817,
        "preview": "tags: [\"Simple Mediator\", \"Error Handling\", \"Result Types\", \"Best Practices\"] filename: \"OrderHandler cs\" showLineNumbers: true usingStatements: [\"Sys..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/_folder",
    "title": "old-v1.0.0.0/_folder",
    "category": "General",
    "url": "/docs/old-v1.0.0.0/_folder",
    "chunks": [
      {
        "id": "old-v1.0.0.0/_folder-chunk-0",
        "text": "Release v1.0.0 - Initial Release\nRelease Notes\nCore Whizbang functionality\nEvent sourcing foundation\nBasic projection system\nCommand and query handling\nInitial documentation\nFeatures\nComplete CQRS implementation\nEvent sourcing with aggregates\nProjection management\nAspect-oriented programming support\nBasic repository patterns\nThis is the initial stable release of the Whizbang .NET library providing the foundational event sourcing and CQRS capabilities.",
        "startIndex": 0,
        "preview": "Release v1.0.0 - Initial Release\nRelease Notes\nCore Whizbang functionality\nEvent sourcing foundation\nBasic projection system\nCommand and query handlin..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/advanced/advanced-scenarios",
    "title": "Advanced Scenarios",
    "category": "Advanced",
    "url": "/docs/old-v1.0.0.0/advanced/advanced-scenarios",
    "chunks": [
      {
        "id": "old-v1.0.0.0/advanced/advanced-scenarios-chunk-0",
        "text": "Advanced Scenarios\nThis document covers advanced scenarios for production deployments, including data seeding, Backend-for-Frontend (BFF) patterns, and central control commands Data Seeding in Scaled Environments\nWhen deploying to scaled-out environments (Kubernetes, multiple replicas), data seeding must be coordinated to avoid duplicates or race conditions Coordinated Seeding\n`csharp{\ntitle: \"Coordinated Data Seeding\"\ndescription: \"Seed data in scaled environments without duplicates\"\nframework: \"NET8\"\ncategory: \"Deployment\"\ndifficulty: \"ADVANCED\"\ntags: [\"Seeding\", \"Deployment\", \"Kubernetes\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\"]\nusingStatements: [\"Microsoft Extensions Hosting\", \"Whizbang\", \"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Microsoft Extensions Hosting;\nusing Whizbang;\npublic class DataSeeder : IHostedService {\n    private readonly IWhizbang _whizbang;\n    private readonly IDistributedLock _distributedLock;\n    public DataSeeder(IWhizbang whizbang, IDistributedLock distributedLock) {\n        _whizbang = whizbang;\n        _distributedLock = distributedLock;\n    }\n    public async Task StartAsync(CancellationToken cancellationToken) {\n        // Only ONE replica seeds data (distributed lock)\n        await using var @lock = await _distributedLock AcquireAsync(\"data-seeding\", TimeSpan FromMinutes(5));\n        if (@lock = null) {\n            await SeedDataAsync();\n        }\n    }\n    private async Task SeedDataAsync() {\n        // Check if already seeded\n        var alreadySeeded = await CheckIfSeededAsync();\n        if (alreadySeeded) {\n            return;\n        }\n        // Seed master data\n        await SeedProductCatalogAsync();\n        await SeedDefaultTenantsAsync();\n        await SeedReferenceDataAsync();\n        // Mark as seeded\n        await MarkAsSeededAsync();\n    }\n    public Task StopAsync(CancellationToken cancellationToken) => Task CompletedTask;\n}\n`\nIdempotent Seeding\nMake seeding operations idempotent:\n`csharp{\ntitle: \"Idempotent Seeding\"\ndescription: \"Seed data that can be run multiple times safely\"\nframework: \"NET8\"\ncategory: \"Deployment\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Seeding\", \"Idempotence\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\npublic class ProductCatalogSeeder {\n    private readonly IRepository<ProductCatalog> _repository;\n    public ProductCatalogSeeder(IRepository<ProductCatalog> repository) {\n        _repository = repository;\n    }\n    public async Task SeedAsync() {\n        // Idempotent: only create if doesn't exist\n        var catalog = await _repository FindAsync(WellKnownIds DefaultCatalog);\n        if (catalog == null) {\n            catalog = new ProductCatalog(WellKnownIds",
        "startIndex": 0,
        "preview": "Advanced Scenarios\nThis document covers advanced scenarios for production deployments, including data seeding, Backend-for-Frontend (BFF) patterns, an..."
      },
      {
        "id": "old-v1.0.0.0/advanced/advanced-scenarios-chunk-1",
        "text": "using System Threading Tasks; using Whizbang; public class ProductCatalogSeeder { private readonly IRepository<ProductCatalog> _repository; public ProductCatalogSeeder(IRepository<ProductCatalog> repository) { _repository = repository; } public async Task SeedAsync() { // Idempotent: only create if doesn't exist var catalog = await _repository FindAsync(WellKnownIds DefaultCatalog); if (catalog == null) { catalog = new ProductCatalog(WellKnownIds DefaultCatalog, \"Default Catalog\");\n            catalog AddProduct(new Product(\"Widget\", 19 99m));\n            catalog AddProduct(new Product(\"Gadget\", 29 99m));\n            catalog AddProduct(new Product(\"Doohickey\", 39 99m));\n            await _repository SaveAsync(catalog);\n        }\n    }\n}\n`\nEnvironment-Specific Seeding\nDifferent data for dev/staging/production:\n`csharp{\ntitle: \"Environment-Specific Seeding\"\ndescription: \"Seed different data per environment\"\nframework: \"NET8\"\ncategory: \"Deployment\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Seeding\", \"Environments\"]\nnugetPackages: [\"Whizbang Core\", \"Microsoft Extensions Hosting\"]\nusingStatements: [\"Microsoft Extensions Hosting\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System Threading Tasks;\nusing Microsoft Extensions Hosting;\npublic class EnvironmentSeeder : IHostedService {\n    private readonly IHostEnvironment _env;\n    private readonly IDataSeeder _seeder;\n    public EnvironmentSeeder(IHostEnvironment env, IDataSeeder seeder) {\n        _env = env;\n        _seeder = seeder;\n    }\n    public async Task StartAsync(CancellationToken cancellationToken) {\n        if (_env IsDevelopment()) {\n            // Seed lots of test data for local development\n            await _seeder SeedDevelopmentDataAsync();\n            await _seeder SeedTestTenantsAsync(count: 10);\n            await _seeder SeedSampleOrdersAsync(count: 1000);\n        }\n        else if (_env IsStaging()) {\n            // Seed realistic production-like data\n            await _seeder SeedProductionLikeDataAsync();\n            await _seeder SeedTestTenantsAsync(count: 2);  // Fewer test tenants\n        }\n        else if (_env IsProduction()) {\n            // Only seed essential master data\n            await _seeder SeedMasterDataAsync();\n            // Do NOT seed test data in production\n        }\n    }\n    public Task StopAsync(CancellationToken cancellationToken) => Task CompletedTask;\n}\n`\nKubernetes Init Container Seeding\nUse Kubernetes init containers for pre-startup seeding:\n`yaml{\ntitle: \"Kubernetes Init Container for Data Seeding\"\ndescription: \"Kubernetes deployment configuration with init container for data seeding\"\nframework: \"Kubernetes\"\ncategory: \"Advanced\"\ndifficulty: \"ADVANCED\"\ntags: [\"Kubernetes\", \"Seeding\", \"Deployment\", \"Init Containers\"]\nfilename: \"orders-service-deployment",
        "startIndex": 2926,
        "preview": "using System Threading Tasks; using Whizbang; public class ProductCatalogSeeder { private readonly IRepository<ProductCatalog> _repository; public Pro..."
      },
      {
        "id": "old-v1.0.0.0/advanced/advanced-scenarios-chunk-2",
        "text": "StopAsync(CancellationToken cancellationToken) => Task CompletedTask; } ` Kubernetes Init Container Seeding Use Kubernetes init containers for pre-startup seeding: `yaml{ title: \"Kubernetes Init Container for Data Seeding\" description: \"Kubernetes deployment configuration with init container for data seeding\" framework: \"Kubernetes\" category: \"Advanced\" difficulty: \"ADVANCED\" tags: [\"Kubernetes\", \"Seeding\", \"Deployment\", \"Init Containers\"] filename: \"orders-service-deployment yaml\"\nshowLineNumbers: true\n}\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: orders-service\nspec:\n  replicas: 3\n  template:\n    spec:\n      Init container runs BEFORE main container\n      initContainers:\nname: seed-data\n        image: myapp/orders-service:latest\n        command: [\"dotnet\", \"OrdersService dll\", \"--seed-only\"]\n        env:\nname: ASPNETCORE_ENVIRONMENT\n          value: \"Production\"\n      Main application container\n      containers:\nname: orders-service\n        image: myapp/orders-service:latest\n`\nApplication code:\n`csharp{\ntitle: \"Program cs Seeding Logic\"\ndescription: \"Application startup logic for seed-only mode\"\nframework: \"NET8\"\ncategory: \"Advanced\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Seeding\", \"Startup\", \"Program cs\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\n// In Program cs\nif (args Contains(\"--seed-only\")) {\n    await SeedDataAsync(app Services);\n    return;  // Exit after seeding\n}\nawait app RunAsync();  // Normal startup\n`\n---\nBackend-for-Frontend (BFF) Support\nBFF pattern creates backend APIs tailored to specific frontend applications (web, mobile, desktop) BFF Architecture\n`\n┌─────────────┐       ┌─────────────┐       ┌─────────────┐\n│  Web App    │       │ Mobile App  │       │ Desktop App │\n│  (React)    │       │  (Swift)    │       │  (WinUI)    │\n└──────┬──────┘       └──────┬──────┘       └──────┬──────┘\n       │                     │                     │\n       ↓                     ↓                     ↓\n┌─────────────┐       ┌─────────────┐       ┌─────────────┐\n│   Web BFF   │       │  Mobile BFF │       │ Desktop BFF │\n│  (GraphQL)  │       │   (REST)    │       │  (gRPC)     │\n└──────┬──────┘       └──────┬──────┘       └──────┬──────┘\n       │                     │                     │\n       └─────────────┬───────┴─────────────────────┘\n                     ↓\n              ┌──────────────┐\n              │   Whizbang   │\n              │  Microservices│\n              └──────────────┘\n`\nCreating a BFF with Whizbang\n`csharp{\ntitle: \"Web BFF Implementation\"\ndescription: \"Backend-for-Frontend for web application\"\nframework: \"NET8\"\ncategory: \"BFF\"\ndifficulty: \"ADVANCED\"\ntags: [\"BFF\", \"GraphQL\", \"Web\"]\nnugetPackages: [\"Whizbang Core\", \"HotChocolate\"]\nfilename: \"WebBFF/Program cs\"\nusingStatements: [\"Microsoft AspNetCore Builder\", \"Whizbang\", \"HotChocolate\"]\nshowLineNumbers: true\n}\nusing Microsoft AspNetCore",
        "startIndex": 5277,
        "preview": "StopAsync(CancellationToken cancellationToken) => Task CompletedTask; } ` Kubernetes Init Container Seeding Use Kubernetes init containers for pre-sta..."
      },
      {
        "id": "old-v1.0.0.0/advanced/advanced-scenarios-chunk-3",
        "text": "Whizbang │ │ Microservices│ └──────────────┘ ` Creating a BFF with Whizbang `csharp{ title: \"Web BFF Implementation\" description: \"Backend-for-Frontend for web application\" framework: \"NET8\" category: \"BFF\" difficulty: \"ADVANCED\" tags: [\"BFF\", \"GraphQL\", \"Web\"] nugetPackages: [\"Whizbang Core\", \"HotChocolate\"] filename: \"WebBFF/Program cs\" usingStatements: [\"Microsoft AspNetCore Builder\", \"Whizbang\", \"HotChocolate\"] showLineNumbers: true } using Microsoft AspNetCore Builder;\nusing Whizbang;\nusing HotChocolate;\nvar builder = WebApplication CreateBuilder(args);\n// Add Whizbang as client (sends commands/queries to backend services)\nbuilder Services AddWhizbangClient(options => {\n    options UseDomainOwnership(domains => {\n        domains RegisterDomain(\"Orders\", \"http://orders-service\");\n        domains RegisterDomain(\"Inventory\", \"http://inventory-service\");\n        domains RegisterDomain(\"Customers\", \"http://customers-service\");\n    });\n});\n// Add GraphQL for web frontend\nbuilder Services AddGraphQLServer() AddQueryType<WebQuery>() AddMutationType<WebMutation>();\nvar app = builder Build();\napp MapGraphQL();\napp Run();\n// GraphQL types optimized for web UI\npublic class WebQuery {\n    public async Task<CustomerDashboard> GetDashboardAsync(\n        [Service] IWhizbang whizbang,\n        Guid customerId\n    ) {\n        // Aggregate data from multiple services\n        var customer = await whizbang QueryAsync(new GetCustomer(customerId));\n        var orders = await whizbang QueryAsync(new GetCustomerOrders(customerId));\n        var recommendations = await whizbang QueryAsync(new GetRecommendations(customerId));\n        // Return web-optimized payload\n        return new CustomerDashboard(customer, orders, recommendations);\n    }\n}\n`\nMobile BFF (Optimized for Bandwidth)\n`csharp{\ntitle: \"Mobile BFF Implementation\"\ndescription: \"Backend-for-Frontend for mobile apps (minimal payloads)\"\nframework: \"NET8\"\ncategory: \"BFF\"\ndifficulty: \"ADVANCED\"\ntags: [\"BFF\", \"Mobile\", \"REST\"]\nnugetPackages: [\"Whizbang Core\", \"Microsoft AspNetCore\"]\nfilename: \"MobileBFF/Program cs\"\nusingStatements: [\"Microsoft AspNetCore Builder\", \"Microsoft AspNetCore Http\", \"Whizbang\", \"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Microsoft AspNetCore Builder;\nusing Microsoft AspNetCore Http;\nusing Whizbang;\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbangClient(/ /);\nvar app = builder Build();\n// Mobile-optimized endpoints (minimal payloads, pagination)\napp MapGet(\"/mobile/orders\", async (IWhizbang whizbang, Guid customerId, int page) => {\n    var orders = await whizbang",
        "startIndex": 7735,
        "preview": "Whizbang │ │ Microservices│ └──────────────┘ ` Creating a BFF with Whizbang `csharp{ title: \"Web BFF Implementation\" description: \"Backend-for-Fronten..."
      },
      {
        "id": "old-v1.0.0.0/advanced/advanced-scenarios-chunk-4",
        "text": "using System Threading Tasks; using Microsoft AspNetCore Builder; using Microsoft AspNetCore Http; using Whizbang; var builder = WebApplication CreateBuilder(args); builder Services AddWhizbangClient(/ /); var app = builder Build(); // Mobile-optimized endpoints (minimal payloads, pagination) app MapGet(\"/mobile/orders\", async (IWhizbang whizbang, Guid customerId, int page) => { var orders = await whizbang QueryAsync(new GetCustomerOrders(customerId) {\n        Page = page,\n        PageSize = 20,  // Mobile shows 20 at a time\n        IncludeFields = new[] { \"id\", \"status\", \"total\", \"placedAt\" }  // Minimal fields\n    });\n    // Return mobile-friendly response\n    return Results Ok(new {\n        orders = orders Select(o => new {\n            id = o Id,\n            status = o Status,\n            total = $\"${o Total:F2}\",  // Pre-formatted for display\n            date = o PlacedAt ToString(\"MMM dd\")\n        }),\n        hasMore = orders Count == 20\n    });\n});\napp Run();\n`\nBFF Aggregation Pattern\nBFFs aggregate data from multiple services:\n`csharp{\ntitle: \"BFF Data Aggregation\"\ndescription: \"Aggregate data from multiple services in BFF\"\nframework: \"NET8\"\ncategory: \"BFF\"\ndifficulty: \"ADVANCED\"\ntags: [\"BFF\", \"Aggregation\", \"Microservices\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Linq\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Linq;\nusing System Threading Tasks;\nusing Whizbang;\npublic class OrderDetailsAggregator {\n    private readonly IWhizbang _whizbang;\n    public OrderDetailsAggregator(IWhizbang whizbang) {\n        _whizbang = whizbang;\n    }\n    public async Task<OrderDetailsViewModel> GetOrderDetailsAsync(Guid orderId) {\n        // Query multiple services in parallel\n        var orderTask = _whizbang QueryAsync(new GetOrder(orderId));\n        var customerTask = _whizbang QueryAsync(new GetCustomer(/ customerId from order /));\n        var inventoryTask = _whizbang QueryAsync(new GetInventoryStatus(orderId));\n        var shippingTask = _whizbang QueryAsync(new GetShippingStatus(orderId));\n        await Task WhenAll(orderTask, customerTask, inventoryTask, shippingTask);\n        // Aggregate into view model\n        return new OrderDetailsViewModel {\n            Order = orderTask Result,\n            Customer = customerTask Result,\n            Inventory = inventoryTask Result,\n            Shipping = shippingTask Result,\n            EstimatedDelivery = CalculateEstimatedDelivery(shippingTask Result)\n        };\n    }\n}\n`\n---\nCentral Control Commands\nCentral control plane for managing distributed services (configuration changes, projection rebuilds, diagnostics)",
        "startIndex": 9947,
        "preview": "using System Threading Tasks; using Microsoft AspNetCore Builder; using Microsoft AspNetCore Http; using Whizbang; var builder = WebApplication Create..."
      },
      {
        "id": "old-v1.0.0.0/advanced/advanced-scenarios-chunk-5",
        "text": "shippingTask); // Aggregate into view model return new OrderDetailsViewModel { Order = orderTask Result, Customer = customerTask Result, Inventory = inventoryTask Result, Shipping = shippingTask Result, EstimatedDelivery = CalculateEstimatedDelivery(shippingTask Result) }; } } ` --- Central Control Commands Central control plane for managing distributed services (configuration changes, projection rebuilds, diagnostics) Control Plane Architecture\n`\n┌────────────────────────────────────────┐\n│      Whizbang Control Dashboard        │\n│  (Web UI for operators/administrators) │\n└───────────────┬────────────────────────┘\n                │\n                ↓\n┌───────────────────────────────────────┐\n│       Control Plane Service           │\n│   (Sends control commands to services)│\n└───────────────┬───────────────────────┘\n                │\n       ┌────────┴────────┬──────────┐\n       ↓                 ↓          ↓\n┌──────────┐      ┌──────────┐  ┌──────────┐\n│ Orders   │      │Inventory │  │ Shipping │\n│ Service  │      │ Service  │  │ Service  │\n└──────────┘      └──────────┘  └──────────┘\n`\nControl Commands\n`csharp{\ntitle: \"Control Command Definitions\"\ndescription: \"Central commands for managing services\"\nframework: \"NET8\"\ncategory: \"Control Plane\"\ndifficulty: \"ADVANCED\"\ntags: [\"Control Plane\", \"Operations\", \"Commands\"]\nnugetPackages: [\"Whizbang ControlPlane\"]\nusingStatements: [\"System\", \"Whizbang ControlPlane\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang ControlPlane;\n// Rebuild a projection across all services\npublic record RebuildProjection(\n    string ProjectionName,\n    DateTimeOffset StartFrom = null\n) : ControlCommand;\n// Change log level dynamically\npublic record SetLogLevel(\n    string Category,\n    LogLevel Level\n) : ControlCommand;\n// Enable/disable feature flags\npublic record ToggleFeature(\n    string FeatureName,\n    bool Enabled\n) : ControlCommand;\n// Trigger health check\npublic record RunHealthCheck() : ControlCommand;\n// Clear caches\npublic record ClearCaches(\n    string[] CacheNames\n) : ControlCommand;\n`\nControl Command Handler\nServices implement handlers for control commands:\n`csharp{\ntitle: \"Control Command Handler\"\ndescription: \"Handle central control commands in services\"\nframework: \"NET8\"\ncategory: \"Control Plane\"\ndifficulty: \"ADVANCED\"\ntags: [\"Control Plane\", \"Handlers\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang ControlPlane\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Microsoft Extensions Logging\", \"Whizbang ControlPlane\", \"Whizbang Projections\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Microsoft Extensions Logging;\nusing Whizbang ControlPlane;\nusing Whizbang",
        "startIndex": 12212,
        "preview": "shippingTask); // Aggregate into view model return new OrderDetailsViewModel { Order = orderTask Result, Customer = customerTask Result, Inventory = i..."
      },
      {
        "id": "old-v1.0.0.0/advanced/advanced-scenarios-chunk-6",
        "text": "in services\" framework: \"NET8\" category: \"Control Plane\" difficulty: \"ADVANCED\" tags: [\"Control Plane\", \"Handlers\"] nugetPackages: [\"Whizbang Core\", \"Whizbang ControlPlane\", \"Whizbang Projections\"] usingStatements: [\"System\", \"System Threading Tasks\", \"Microsoft Extensions Logging\", \"Whizbang ControlPlane\", \"Whizbang Projections\"] showLineNumbers: true } using System; using System Threading Tasks; using Microsoft Extensions Logging; using Whizbang ControlPlane; using Whizbang Projections;\npublic class RebuildProjectionHandler {\n    private readonly IProjectionEngine _projectionEngine;\n    private readonly ILogger _logger;\n    public RebuildProjectionHandler(IProjectionEngine projectionEngine, ILogger logger) {\n        _projectionEngine = projectionEngine;\n        _logger = logger;\n    }\n    public async Task Handle(RebuildProjection command) {\n        _logger LogWarning(\"Rebuilding projection {ProjectionName} from {StartFrom}\",\n            command ProjectionName,\n            command StartFrom DateTimeOffset MinValue\n        );\n        // Stop projection\n        await _projectionEngine StopProjectionAsync(command ProjectionName);\n        // Clear projection data\n        await _projectionEngine ClearProjectionAsync(command ProjectionName);\n        // Restart from specified point\n        await _projectionEngine StartProjectionAsync(command ProjectionName, command StartFrom);\n        _logger LogInformation(\"Projection {ProjectionName} rebuild started\", command ProjectionName);\n    }\n}\n`\nSending Control Commands\nFrom the control dashboard:\n`csharp{\ntitle: \"Sending Control Commands\"\ndescription: \"Send control commands from central dashboard\"\nframework: \"NET8\"\ncategory: \"Control Plane\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Control Plane\", \"Dashboard\"]\nnugetPackages: [\"Whizbang ControlPlane\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang ControlPlane\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang ControlPlane;\npublic class ControlPlaneClient {\n    private readonly IWhizbangControlPlane _controlPlane;\n    public ControlPlaneClient(IWhizbangControlPlane controlPlane) {\n        _controlPlane = controlPlane;\n    }\n    public async Task RebuildProjectionAcrossAllServicesAsync(string projectionName) {\n        // Send command to ALL services that have this projection\n        await _controlPlane BroadcastAsync(new RebuildProjection(projectionName));\n    }\n    public async Task RebuildProjectionOnSpecificServiceAsync(string service, string projection) {\n        // Send command to specific service only\n        await _controlPlane SendToServiceAsync(service, new RebuildProjection(projection));\n    }\n    public async Task SetLogLevelGloballyAsync(string category, LogLevel level) {\n        // Change log level across all services\n        await _controlPlane BroadcastAsync(new SetLogLevel(category, level));\n    }\n}\n`\nNext Steps\nWhizbang Dashboard - Visual control plane\nObservability - Monitoring and tracing\nDistributed Messaging - Microservices architecture",
        "startIndex": 14495,
        "preview": "in services\" framework: \"NET8\" category: \"Control Plane\" difficulty: \"ADVANCED\" tags: [\"Control Plane\", \"Handlers\"] nugetPackages: [\"Whizbang Core\", \"..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/advanced/configuration",
    "title": "Configuration",
    "category": "Advanced",
    "url": "/docs/old-v1.0.0.0/advanced/configuration",
    "chunks": [
      {
        "id": "old-v1.0.0.0/advanced/configuration-chunk-0",
        "text": "Configuration\nWhizbang provides a comprehensive configuration system that allows you to customize every aspect of the runtime, from storage backends to messaging systems, observability, and performance tuning Basic Configuration\nMinimal Setup\n`csharp{\ntitle: \"Minimal Whizbang Setup\"\ndescription: \"Basic Whizbang configuration with assembly scanning\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"BEGINNER\"\ntags: [\"Setup\", \"Configuration\", \"Assembly Scanning\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft AspNetCore Builder\", \"Whizbang\"]\nshowLineNumbers: true\n}\n// Program cs\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbang(options => {\n    // Scan assemblies for handlers, aggregates, and projections\n    options ScanAssembly(typeof(Program) Assembly);\n});\nvar app = builder Build();\napp Run();\n`\nWith Storage Backend\n`csharp{\ntitle: \"Whizbang with Storage Backend\"\ndescription: \"Configuration with PostgreSQL event store\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Event Store\", \"PostgreSQL\", \"Storage\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang\", \"Whizbang EventSourcing\"]\nshowLineNumbers: true\n}\nbuilder Services AddWhizbang(options => {\n    options ScanAssembly(typeof(Program) Assembly);\n    // Configure event store\n    options UseEventSourcing(es => {\n        es UsePostgres(connectionString);\n        // or es UseSqlServer(connectionString);\n        // or es UseInMemory(); // for testing\n    });\n});\n`\nStorage Configuration\nEvent Store Options\n`csharp{\ntitle: \"PostgreSQL Event Store Configuration\"\ndescription: \"Detailed PostgreSQL event store options\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Event Store\", \"PostgreSQL\", \"Schema\", \"Snapshots\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang EventSourcing\"]\nshowLineNumbers: true\n}\noptions UseEventSourcing(es => {\n    es UsePostgres(connectionString, postgres => {\n        postgres SchemaName = \"events\";\n        postgres TableName = \"event_store\";\n        postgres SnapshotInterval = 100;\n        postgres EnableAutomaticMigrations = true;\n    });\n});\n`\nProjection Store Options\n`csharp{\ntitle: \"Projection Store Configuration\"\ndescription: \"Multiple projection store options including PostgreSQL and MongoDB\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"PostgreSQL\", \"MongoDB\", \"Storage\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang Projections\"]\nshowLineNumbers: true\n}\noptions UseProjections(proj => {\n    // Use same database as event store\n    proj UseSameStoreAsEvents();\n    // Or use different database\n    proj UsePostgres(projectionConnectionString, postgres => {\n        postgres SchemaName = \"projections\";\n        postgres",
        "startIndex": 0,
        "preview": "Configuration\nWhizbang provides a comprehensive configuration system that allows you to customize every aspect of the runtime, from storage backends t..."
      },
      {
        "id": "old-v1.0.0.0/advanced/configuration-chunk-1",
        "text": "and MongoDB\" framework: \"NET8\" category: \"Configuration\" difficulty: \"INTERMEDIATE\" tags: [\"Projections\", \"PostgreSQL\", \"MongoDB\", \"Storage\"] filename: \"Program cs\" usingStatements: [\"Whizbang Projections\"] showLineNumbers: true } options UseProjections(proj => { // Use same database as event store proj UseSameStoreAsEvents(); // Or use different database proj UsePostgres(projectionConnectionString, postgres => { postgres SchemaName = \"projections\"; postgres EnableAutomaticMigrations = true;\n    });\n    // Or use MongoDB for projections\n    proj UseMongoDb(mongoConnectionString, mongo => {\n        mongo DatabaseName = \"whizbang_projections\";\n    });\n});\n`\nMessaging Configuration\nIn-Process Messaging\n`csharp{\ntitle: \"In-Process Messaging Configuration\"\ndescription: \"Configure in-process messaging for single application\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"BEGINNER\"\ntags: [\"Messaging\", \"In-Process\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang Messaging\"]\nshowLineNumbers: true\n}\noptions UseMessaging(msg => {\n    msg UseInProcess(); // Default - all handlers run in same process\n});\n`\nDistributed Messaging\n`csharp{\ntitle: \"Distributed Messaging with Kafka\"\ndescription: \"Configure Kafka for distributed messaging with retry policies\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Messaging\", \"Kafka\", \"Distributed\", \"Retry Policy\"]\nfilename: \"Program cs\"\nusingStatements: [\"System\", \"Whizbang Messaging\"]\nshowLineNumbers: true\n}\noptions UseMessaging(msg => {\n    msg UseKafka(kafka => {\n        kafka BootstrapServers = \"localhost:9092\";\n        kafka ConsumerGroup = \"whizbang-consumers\";\n        kafka EnableIdempotency = true;\n        kafka RetryPolicy = RetryPolicy ExponentialBackoff(\n            maxRetries: 5,\n            baseDelay: TimeSpan FromSeconds(1)\n        );\n    });\n    // or msg UseRabbitMQ( );\n    // or msg UseAzureServiceBus( );\n});\n`\nOutbox Pattern\n`csharp{\ntitle: \"Outbox Pattern Configuration\"\ndescription: \"Configure outbox pattern for reliable message delivery\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Outbox Pattern\", \"Messaging\", \"Reliability\"]\nfilename: \"Program cs\"\nusingStatements: [\"System\", \"Whizbang Messaging\"]\nshowLineNumbers: true\n}\noptions UseMessaging(msg => {\n    msg UseOutbox(outbox => {\n        outbox ProcessingInterval = TimeSpan FromSeconds(5);\n        outbox BatchSize = 100;\n        outbox RetryFailedMessages = true;\n        outbox MaxRetries = 3;\n    });\n});\n`\nHandler Configuration\nAssembly Scanning\n`csharp{\ntitle: \"Assembly Scanning Configuration\"\ndescription: \"Configure assembly scanning for handlers and aggregates\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"BEGINNER\"\ntags: [\"Assembly Scanning\", \"Handlers\", \"Discovery\"]\nfilename: \"Program",
        "startIndex": 2793,
        "preview": "and MongoDB\" framework: \"NET8\" category: \"Configuration\" difficulty: \"INTERMEDIATE\" tags: [\"Projections\", \"PostgreSQL\", \"MongoDB\", \"Storage\"] filename..."
      },
      {
        "id": "old-v1.0.0.0/advanced/configuration-chunk-2",
        "text": "outbox ProcessingInterval = TimeSpan FromSeconds(5); outbox BatchSize = 100; outbox RetryFailedMessages = true; outbox MaxRetries = 3; }); }); ` Handler Configuration Assembly Scanning `csharp{ title: \"Assembly Scanning Configuration\" description: \"Configure assembly scanning for handlers and aggregates\" framework: \"NET8\" category: \"Configuration\" difficulty: \"BEGINNER\" tags: [\"Assembly Scanning\", \"Handlers\", \"Discovery\"] filename: \"Program cs\"\nusingStatements: [\"Whizbang\"]\nshowLineNumbers: true\n}\noptions ScanAssembly(typeof(Program) Assembly);\noptions ScanAssemblies(\n    typeof(OrderHandlers) Assembly,\n    typeof(PaymentHandlers) Assembly\n);\n// Scan all assemblies in current directory\noptions ScanCurrentDirectory();\n`\nManual Registration\n`csharp{\ntitle: \"Manual Handler Registration\"\ndescription: \"Manually register specific handlers instead of assembly scanning\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Handlers\", \"Registration\", \"Manual\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang\"]\nshowLineNumbers: true\n}\noptions RegisterHandlers(handlers => {\n    handlers RegisterCommandHandler<PlaceOrderHandler>();\n    handlers RegisterEventHandler<OrderPlacedHandler>();\n    handlers RegisterQueryHandler<GetOrderHandler>();\n});\n`\nHandler Lifetime\n`csharp{\ntitle: \"Handler Lifetime Configuration\"\ndescription: \"Configure service lifetimes for handlers\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Handlers\", \"Lifetime\", \"Dependency Injection\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\noptions ConfigureHandlers(handlers => {\n    handlers DefaultLifetime = ServiceLifetime Scoped;\n    // Override specific handlers\n    handlers SetLifetime<ExpensiveHandler>(ServiceLifetime Singleton);\n});\n`\nProjection Configuration\nRegistration and Subscriptions\n`csharp{\ntitle: \"Projection Registration and Subscriptions\"\ndescription: \"Register projections with event subscriptions and partitioning\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Event Subscriptions\", \"Partitioning\", \"Backfill\"]\nfilename: \"Program cs\"\nusingStatements: [\"System\", \"Whizbang Projections\"]\nshowLineNumbers: true\n}\noptions UseProjections(proj => {\n    proj RegisterProjection<OrderSummaryProjection>(p => {\n        p Subscribe<OrderPlacedEvent>();\n        p Subscribe<OrderShippedEvent>();\n        p Subscribe<OrderCancelledEvent>();\n        // Backfill from specific point\n        p BackfillFrom = DateTimeOffset UtcNow AddDays(-30);\n        // Partition by customer for parallel processing\n        p PartitionBy = @event => ((dynamic)@event) CustomerId;\n    });\n});\n`\nPerformance Tuning\n`csharp{\ntitle: \"Projection Performance Tuning\"\ndescription: \"Configure projection performance settings for batch processing\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Performance\", \"Batch Processing\", \"Concurrency\"]\nfilename: \"Program cs\"\nusingStatements: [\"System\", \"Whizbang Projections\"]\nshowLineNumbers: true\n}\nproj ConfigurePerformance(perf => {\n    perf",
        "startIndex": 5150,
        "preview": "outbox ProcessingInterval = TimeSpan FromSeconds(5); outbox BatchSize = 100; outbox RetryFailedMessages = true; outbox MaxRetries = 3; }); }); ` Handl..."
      },
      {
        "id": "old-v1.0.0.0/advanced/configuration-chunk-3",
        "text": "= @event => ((dynamic)@event) CustomerId; }); }); ` Performance Tuning `csharp{ title: \"Projection Performance Tuning\" description: \"Configure projection performance settings for batch processing\" framework: \"NET8\" category: \"Configuration\" difficulty: \"ADVANCED\" tags: [\"Projections\", \"Performance\", \"Batch Processing\", \"Concurrency\"] filename: \"Program cs\" usingStatements: [\"System\", \"Whizbang Projections\"] showLineNumbers: true } proj ConfigurePerformance(perf => { perf BatchSize = 1000;\n    perf ConcurrentPartitions = Environment ProcessorCount;\n    perf CheckpointInterval = TimeSpan FromSeconds(10);\n    perf MaxLagBeforeAlert = TimeSpan FromMinutes(5);\n});\n`\nObservability Configuration\nOpenTelemetry Integration\n`csharp{\ntitle: \"OpenTelemetry Observability Configuration\"\ndescription: \"Configure OpenTelemetry with Jaeger and Application Insights exporters\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Observability\", \"OpenTelemetry\", \"Jaeger\", \"Application Insights\"]\nfilename: \"Program cs\"\nusingStatements: [\"System\", \"Microsoft Extensions Configuration\", \"Whizbang Observability\"]\nshowLineNumbers: true\n}\noptions UseObservability(obs => {\n    obs UseOpenTelemetry(otel => {\n        otel ServiceName = \"my-whizbang-service\";\n        otel ServiceVersion = \"1 0 0\";\n        // Export to Jaeger\n        otel AddJaegerExporter(jaeger => {\n            jaeger Endpoint = new Uri(\"http://localhost:14268\");\n        });\n        // Export to Application Insights\n        otel AddApplicationInsightsExporter(ai => {\n            ai ConnectionString = builder Configuration GetConnectionString(\"ApplicationInsights\");\n        });\n    });\n    // Built-in metrics\n    obs EnableMetrics = true;\n    obs EnableHealthChecks = true;\n});\n`\nLogging Configuration\n`csharp{\ntitle: \"Logging Configuration\"\ndescription: \"Configure structured logging with correlation IDs\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Logging\", \"Structured Logging\", \"Correlation IDs\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions Logging\", \"Whizbang Logging\"]\nshowLineNumbers: true\n}\noptions UseLogging(logging => {\n    logging LogLevel = LogLevel Information;\n    logging LogCommands = true;\n    logging LogEvents = true;\n    logging LogQueries = false; // Can be noisy\n    // Structured logging\n    logging UseStructuredLogging = true;\n    logging IncludeCorrelationIds = true;\n});\n`\nSecurity Configuration\nAuthentication & Authorization\n`csharp{\ntitle: \"Security and Authorization Configuration\"\ndescription: \"Configure authentication, authorization, and multi-tenancy\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Security\", \"Authentication\", \"Authorization\", \"Multi-Tenancy\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang Security\"]\nshowLineNumbers: true\n}\noptions UseSecurity(security => {\n    // Require authentication for all commands\n    security",
        "startIndex": 7878,
        "preview": "= @event => ((dynamic)@event) CustomerId; }); }); ` Performance Tuning `csharp{ title: \"Projection Performance Tuning\" description: \"Configure project..."
      },
      {
        "id": "old-v1.0.0.0/advanced/configuration-chunk-4",
        "text": "}); ` Security Configuration Authentication & Authorization `csharp{ title: \"Security and Authorization Configuration\" description: \"Configure authentication, authorization, and multi-tenancy\" framework: \"NET8\" category: \"Configuration\" difficulty: \"ADVANCED\" tags: [\"Security\", \"Authentication\", \"Authorization\", \"Multi-Tenancy\"] filename: \"Program cs\" usingStatements: [\"Whizbang Security\"] showLineNumbers: true } options UseSecurity(security => { // Require authentication for all commands security RequireAuthentication = true;\n    // Configure permissions\n    security ConfigureAuthorization(auth => {\n        auth RequirePermission<PlaceOrderCommand>(\"orders:write\");\n        auth RequirePermission<GetOrderQuery>(\"orders:read\");\n        // Role-based access\n        auth RequireRole<CancelOrderCommand>(\"OrderManager\");\n    });\n    // Multi-tenancy\n    security UseMultiTenancy(mt => {\n        mt TenantResolutionStrategy = TenantResolutionStrategy FromClaims;\n        mt TenantClaimType = \"tenant_id\";\n        mt IsolateTenantData = true;\n    });\n});\n`\nData Protection\n`csharp{\ntitle: \"Data Protection and Encryption\"\ndescription: \"Configure data encryption with Azure Key Vault integration\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Security\", \"Encryption\", \"Azure Key Vault\", \"Data Protection\"]\nfilename: \"Program cs\"\nusingStatements: [\"System\", \"Whizbang Security\"]\nshowLineNumbers: true\n}\noptions UseSecurity(security => {\n    security UseEncryption(encryption => {\n        encryption EncryptSensitiveFields = true;\n        encryption KeyRotationInterval = TimeSpan FromDays(90);\n        // Azure Key Vault integration\n        encryption UseAzureKeyVault(kv => {\n            kv VaultUri = \"https://my-vault vault azure net/\";\n            kv KeyName = \"whizbang-encryption-key\";\n        });\n    });\n});\n`\nPerformance Configuration\nConnection Pooling\n`csharp{\ntitle: \"Database Connection Pooling\"\ndescription: \"Configure database connection pool settings for performance\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Performance\", \"Database\", \"Connection Pooling\"]\nfilename: \"Program cs\"\nusingStatements: [\"System\", \"Whizbang Performance\"]\nshowLineNumbers: true\n}\noptions ConfigurePerformance(perf => {\n    perf DatabaseConnections = conn => {\n        conn MaxPoolSize = 100;\n        conn MinPoolSize = 10;\n        conn ConnectionTimeout = TimeSpan FromSeconds(30);\n        conn CommandTimeout = TimeSpan FromSeconds(60);\n    };\n});\n`\nCaching\n`csharp{\ntitle: \"Distributed Caching Configuration\"\ndescription: \"Configure Redis caching for aggregates and projections\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Caching\", \"Redis\", \"Performance\", \"Distributed Cache\"]\nfilename: \"Program cs\"\nusingStatements: [\"System\", \"Whizbang Caching\"]\nshowLineNumbers: true\n}\noptions UseCaching(cache => {\n    cache UseDistributedCache(dist => {\n        dist UseRedis(redis => {\n            redis ConnectionString = \"localhost:6379\";\n            redis",
        "startIndex": 10349,
        "preview": "}); ` Security Configuration Authentication & Authorization `csharp{ title: \"Security and Authorization Configuration\" description: \"Configure authent..."
      },
      {
        "id": "old-v1.0.0.0/advanced/configuration-chunk-5",
        "text": "\"Distributed Caching Configuration\" description: \"Configure Redis caching for aggregates and projections\" framework: \"NET8\" category: \"Configuration\" difficulty: \"ADVANCED\" tags: [\"Caching\", \"Redis\", \"Performance\", \"Distributed Cache\"] filename: \"Program cs\" usingStatements: [\"System\", \"Whizbang Caching\"] showLineNumbers: true } options UseCaching(cache => { cache UseDistributedCache(dist => { dist UseRedis(redis => { redis ConnectionString = \"localhost:6379\"; redis DatabaseNumber = 0;\n        });\n    });\n    // Cache aggregates for read-heavy scenarios\n    cache CacheAggregates = true;\n    cache AggregateCacheDuration = TimeSpan FromMinutes(5);\n    // Cache projection results\n    cache CacheProjections = true;\n    cache ProjectionCacheDuration = TimeSpan FromMinutes(1);\n});\n`\nEnvironment-Specific Configuration\nDevelopment Environment\n`csharp{\ntitle: \"Development Environment Configuration\"\ndescription: \"Configure development-specific settings and features\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"BEGINNER\"\ntags: [\"Development\", \"Environment\", \"In-Memory Storage\", \"Swagger\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions Hosting\", \"Whizbang\"]\nshowLineNumbers: true\n}\nif (builder Environment IsDevelopment()) {\n    options UseDevelopmentDefaults(dev => {\n        dev UseInMemoryStorage = true;\n        dev EnableDetailedErrors = true;\n        dev LogAllQueries = true;\n        dev EnableSwagger = true;\n    });\n}\n`\nProduction Environment\n`csharp{\ntitle: \"Production Environment Configuration\"\ndescription: \"Configure production-specific optimizations and monitoring\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Production\", \"Environment\", \"Optimizations\", \"Monitoring\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions Hosting\", \"Microsoft Extensions Logging\", \"Whizbang\"]\nshowLineNumbers: true\n}\nif (builder Environment IsProduction()) {\n    options UseProductionDefaults(prod => {\n        prod EnableOptimizations = true;\n        prod UseConnectionPooling = true;\n        prod EnableMetrics = true;\n        prod EnableHealthChecks = true;\n        prod LogLevel = LogLevel Warning;\n    });\n}\n`\nConfiguration from appsettings json\n`json\n{\n  \"Whizbang\": {\n    \"EventStore\": {\n      \"Provider\": \"Postgres\",\n      \"ConnectionString\": \"Host=localhost;Database=events;Username=user;Password=pass\",\n      \"SchemaName\": \"events\",\n      \"SnapshotInterval\": 100\n    },\n    \"Messaging\": {\n      \"Provider\": \"Kafka\",\n      \"BootstrapServers\": \"localhost:9092\",\n      \"ConsumerGroup\": \"my-service-consumers\"\n    },\n    \"Projections\": {\n      \"BatchSize\": 1000,\n      \"ConcurrentPartitions\": 4,\n      \"CheckpointInterval\": \"00:00:10\"\n    },\n    \"Observability\": {\n      \"ServiceName\": \"my-whizbang-service\",\n      \"EnableMetrics\": true,\n      \"LogLevel\": \"Information\"\n    }\n  }\n}\n`\n`csharp{\ntitle: \"Loading Configuration from appsettings json\"\ndescription: \"Load Whizbang configuration from appsettings json section\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"BEGINNER\"\ntags: [\"Configuration\", \"appsettings json\", \"Settings\"]\nfilename: \"Program",
        "startIndex": 12890,
        "preview": "\"Distributed Caching Configuration\" description: \"Configure Redis caching for aggregates and projections\" framework: \"NET8\" category: \"Configuration\" ..."
      },
      {
        "id": "old-v1.0.0.0/advanced/configuration-chunk-6",
        "text": "}, \"Projections\": { \"BatchSize\": 1000, \"ConcurrentPartitions\": 4, \"CheckpointInterval\": \"00:00:10\" }, \"Observability\": { \"ServiceName\": \"my-whizbang-service\", \"EnableMetrics\": true, \"LogLevel\": \"Information\" } } } ` `csharp{ title: \"Loading Configuration from appsettings json\" description: \"Load Whizbang configuration from appsettings json section\" framework: \"NET8\" category: \"Configuration\" difficulty: \"BEGINNER\" tags: [\"Configuration\", \"appsettings json\", \"Settings\"] filename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions Configuration\", \"Whizbang\"]\nshowLineNumbers: true\n}\n// Load from configuration\noptions ConfigureFromSection(builder Configuration GetSection(\"Whizbang\"));\n`\nValidation and Diagnostics\nConfiguration Validation\n`csharp{\ntitle: \"Configuration Validation\"\ndescription: \"Enable configuration validation with custom validators\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Validation\", \"Configuration\", \"Startup\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang\"]\nshowLineNumbers: true\n}\noptions ValidateConfiguration = true;\noptions ValidateOnStartup = true;\n// Custom validation\noptions AddConfigurationValidator<CustomConfigValidator>();\n`\nHealth Checks\n`csharp{\ntitle: \"Health Checks Configuration\"\ndescription: \"Add Whizbang health checks for monitoring system components\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Health Checks\", \"Monitoring\", \"Diagnostics\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang HealthChecks\"]\nshowLineNumbers: true\n}\nbuilder Services AddHealthChecks() AddWhizbangHealthChecks(); // Adds event store, projections, messaging health checks\n`\nRelated Topics\nGetting Started - Basic setup and configuration\nPackage Structure - Available NuGet packages and adapters NET Aspire Integration - Cloud-native configuration\nAdvanced Scenarios - Complex configuration patterns\nNext Steps\nThis page covers the core configuration options in Whizbang For specific deployment scenarios and advanced patterns, refer to the specialized documentation sections",
        "startIndex": 492,
        "preview": "}, \"Projections\": { \"BatchSize\": 1000, \"ConcurrentPartitions\": 4, \"CheckpointInterval\": \"00:00:10\" }, \"Observability\": { \"ServiceName\": \"my-whizbang-s..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/architecture-design/architecture",
    "title": "Architecture Overview",
    "category": "Architecture & Design",
    "url": "/docs/old-v1.0.0.0/architecture-design/architecture",
    "chunks": [
      {
        "id": "old-v1.0.0.0/architecture-design/architecture-chunk-0",
        "text": "Architecture Overview\nWhizbang is built on a layered architecture that supports scaling from event-driven development to a full distributed event-sourced system with receptors, perspectives, and lenses Architectural Layers\n`text\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Layered-Architecture, System-Design]\ndescription: Layered architecture diagram showing the separation between application layer, Whizbang dispatcher, driver layer, and infrastructure\n---\n┌─────────────────────────────────────────────────────────────┐\n│                     Application Layer                       │\n│  (Your Domain Code: Receptors, Perspectives, Lenses)        │\n└─────────────────────────────────────────────────────────────┘\n                            ↓\n┌─────────────────────────────────────────────────────────────┐\n│                    Whizbang Dispatcher                       │\n│  • Message Routing        • Event Sourcing Engine            │\n│  • Receptor Execution     • Perspective Management           │\n│  • Event Publishing       • Ledger Coordination              │\n│  • Idempotence            • Observability Pipeline           │\n└─────────────────────────────────────────────────────────────┘\n                            ↓\n┌─────────────────────────────────────────────────────────────┐\n│                      Driver Layer                            │\n│  • Persistence Drivers    • Message Broker Adapters          │\n│  • Serialization Drivers  • Telemetry Drivers                │\n└─────────────────────────────────────────────────────────────┘\n                            ↓\n┌─────────────────────────────────────────────────────────────┐\n│                   Infrastructure                             │\n│  • Databases              • Message Brokers                  │\n│  • Telemetry Backends     • Service Discovery                │\n└─────────────────────────────────────────────────────────────┘\n`\nCore Components\nDispatcher with Return Type Semantics\nThe Dispatcher is the heart of Whizbang It interprets receptor return types to determine behavior:\nRoutes commands to their owning domain's receptors\nPublishes events to all interested perspectives  \nExecutes queries against lenses\nCoordinates sagas across long-running processes\nReturn type semantics - What receptors return determines what happens:\nSingle event return → Published to perspectives\nTuple return → Multiple cascading events\nVoid return → Fire-and-forget execution\nResult<T> return → Success/failure handling\nAll message routing respects domain ownership—commands must be sent to the service that owns that receptor, while events are broadcast from the owning domain to perspectives Ledger\nThe Ledger is the source of truth for all state changes in event-sourced mode",
        "startIndex": 0,
        "preview": "Architecture Overview\nWhizbang is built on a layered architecture that supports scaling from event-driven development to a full distributed event-sour..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/architecture-chunk-1",
        "text": "return → Fire-and-forget execution Result<T> return → Success/failure handling All message routing respects domain ownership—commands must be sent to the service that owns that receptor, while events are broadcast from the owning domain to perspectives Ledger The Ledger is the source of truth for all state changes in event-sourced mode It:\nAppends events to immutable streams (one stream per receptor)\nSupports time-based queries (get all events before/after a timestamp)\nEnables backfilling new perspectives from historical events\nProvides global ordering for cross-receptor event streams\nImplements optimistic concurrency for receptor updates\nThe Ledger is driver-based, supporting:\nPostgres (JSONB + sequential IDs)\nSQL Server (JSON columns + IDENTITY)\nMySQL (JSON columns + auto-increment)\nCosmos DB (native event streams)\nLiteFS/SQLite (binary codec for edge deployments)\nPerspective Engine\nThe Perspective Engine builds read models from event streams",
        "startIndex": 2777,
        "preview": "return → Fire-and-forget execution Result<T> return → Success/failure handling All message routing respects domain ownership—commands must be sent to ..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/architecture-chunk-2",
        "text": "streams Implements optimistic concurrency for receptor updates The Ledger is driver-based, supporting: Postgres (JSONB + sequential IDs) SQL Server (JSON columns + IDENTITY) MySQL (JSON columns + auto-increment) Cosmos DB (native event streams) LiteFS/SQLite (binary codec for edge deployments) Perspective Engine The Perspective Engine builds read models from event streams It:\nSubscribes to event streams (local or from remote services)\nApplies events to perspective handlers in order\nTracks checkpoint positions to resume after restarts\nSupports parallel processing across partitions\nHandles schema migrations for evolving perspectives\nPerspectives can be:\nInline - Updated synchronously within the same transaction as event append\nAsync - Updated in background workers for eventual consistency\nCached - Materialized in-memory for ultra-low latency\nExternal - Pushed to Elasticsearch, Redis, or other specialized stores\nAspect-Oriented Pipeline\nThe AOP Pipeline weaves cross-cutting concerns through source generation:\n`text\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, AOP, Pipeline, Cross-Cutting-Concerns]\ndescription: Aspect-oriented pipeline showing how cross-cutting concerns are applied through message processing\n---\nIncoming Message\n      ↓\n  [Logged] - Structured logging aspect\n      ↓\n  [Validated] - Input validation aspect\n      ↓\n  [Authorized] - Security aspect\n      ↓\n  [Cached] - Result caching aspect\n      ↓\n  [Retry] - Resilience aspect\n      ↓\n  [Timed] - Performance metrics aspect\n      ↓\n  Receptor Execution\n      ↓\n  [Transactional] - Database transaction aspect\n      ↓\n  Event Append / Perspective Update\n      ↓\n  [Outbox] - Distributed messaging aspect\n      ↓\n  Response / New Messages\n`\nAspects are:\nDeclarative - Applied via attributes\nCompiled - Source generators create zero-overhead code\nComposable - Multiple aspects work together\nTestable - Can be verified in isolation\nEvery stage is pluggable and observable Saga Coordinator\nSagas orchestrate long-running processes across multiple receptors or services",
        "startIndex": 3399,
        "preview": "streams Implements optimistic concurrency for receptor updates The Ledger is driver-based, supporting: Postgres (JSONB + sequential IDs) SQL Server (J..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/architecture-chunk-3",
        "text": "↓ Response / New Messages ` Aspects are: Declarative - Applied via attributes Compiled - Source generators create zero-overhead code Composable - Multiple aspects work together Testable - Can be verified in isolation Every stage is pluggable and observable Saga Coordinator Sagas orchestrate long-running processes across multiple receptors or services Whizbang supports two saga styles:\nOrchestration - A central coordinator issues commands and listens for events:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Sagas, Orchestration, Long-Running-Processes]\ndescription: Example of saga orchestration pattern for order fulfillment process\n---\npublic class OrderFulfillmentSaga : Saga {\n    public async Task Handle(OrderPlaced @event) {\n        await Send(new ReserveInventory(@event OrderId));\n    }\n    public async Task Handle(InventoryReserved @event) {\n        await Send(new ChargePayment(@event OrderId));\n    }\n    public async Task Handle(PaymentCharged @event) {\n        await Send(new ShipOrder(@event OrderId));\n    }\n}\n`\nChoreography - Each service reacts to events and publishes new ones (no central coordinator) Sagas are persisted as event streams and can be replayed or debugged like any other receptor Outbox/Inbox Pattern\nFor distributed messaging, Whizbang implements the Outbox/Inbox pattern to ensure exactly-once delivery:\nOutbox (Publishing Service):\nReceptor executes and appends events to ledger\nEvents also written to outbox table in same transaction\nBackground worker publishes outbox messages to message broker\nMessages marked as published after broker confirms\nInbox (Subscribing Service):\nMessage arrives from broker\nStored in inbox table with unique message ID\nIf message ID exists (duplicate), skip processing\nOtherwise, process receptor and mark message as complete\nPeriodic cleanup of old inbox entries\nThis pattern guarantees at-least-once delivery from the broker combined with idempotent handling for exactly-once semantics Domain Ownership Model\nWhizbang enforces explicit domain ownership to prevent distributed system chaos",
        "startIndex": 5103,
        "preview": "↓ Response / New Messages ` Aspects are: Declarative - Applied via attributes Compiled - Source generators create zero-overhead code Composable - Mult..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/architecture-chunk-4",
        "text": "ID If message ID exists (duplicate), skip processing Otherwise, process receptor and mark message as complete Periodic cleanup of old inbox entries This pattern guarantees at-least-once delivery from the broker combined with idempotent handling for exactly-once semantics Domain Ownership Model Whizbang enforces explicit domain ownership to prevent distributed system chaos Commands\nCommands are sent TO the service that owns the receptor:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Domain-Ownership, Commands, CQRS]\ndescription: Example of command with domain ownership declaration\n---\n[OwnedBy(\"Orders\")]  // This command belongs to the Orders service\npublic record PlaceOrder(Guid OrderId, Guid CustomerId, List<OrderItem> Items);\n`\nWhen you send a command:\nIn a monolith, it's routed to the local receptor\nIn microservices, it's routed to the Orders service via the message broker\nEvents\nEvents are emitted FROM the service that owns the domain:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Domain-Ownership, Events, CQRS]\ndescription: Example of event with domain ownership declaration\n---\n[OwnedBy(\"Orders\")]  // This event comes from the Orders service\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt);\n`\nOther services can subscribe to OrderPlaced events:\nIn a monolith, subscribers get events via in-process pub/sub\nIn microservices, subscribers get events from the message broker topic\nBackfilling Projections\nWhen a new service subscribes to events for the first time, it can backfill from the beginning:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Perspectives, Event-Sourcing, Backfilling]\ndescription: Configuration for perspective with event subscription and backfilling from beginning\n---\nservices AddPerspective<OrderHistoryPerspective>(options => {\n    options Subscribe<OrderPlaced>();\n    options Subscribe<OrderShipped>();\n    options BackfillFrom = DateTimeOffset MinValue;  // Start from the beginning\n});\n`\nThe perspective engine will:\nQuery the Orders service's ledger for all historical events\nApply them to the perspective in order\nContinue processing new events as they arrive\nThis allows new perspectives to be built from existing event history",
        "startIndex": 6854,
        "preview": "ID If message ID exists (duplicate), skip processing Otherwise, process receptor and mark message as complete Periodic cleanup of old inbox entries Th..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/architecture-chunk-5",
        "text": "options BackfillFrom = DateTimeOffset MinValue; // Start from the beginning }); ` The perspective engine will: Query the Orders service's ledger for all historical events Apply them to the perspective in order Continue processing new events as they arrive This allows new perspectives to be built from existing event history Scaling Patterns\nSingle Process (Event-Driven Mode)\n`text\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Deployment, Single-Process, Event-Driven]\ndescription: Single process deployment architecture with in-memory runtime and local database\n---\n┌─────────────────────────────┐\n│   ASP",
        "startIndex": 8799,
        "preview": "options BackfillFrom = DateTimeOffset MinValue; // Start from the beginning }); ` The perspective engine will: Query the Orders service's ledger for a..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/architecture-chunk-6",
        "text": "Continue processing new events as they arrive This allows new perspectives to be built from existing event history Scaling Patterns Single Process (Event-Driven Mode) `text --- category: Architecture difficulty: INTERMEDIATE tags: [Architecture, Deployment, Single-Process, Event-Driven] description: Single process deployment architecture with in-memory runtime and local database --- ┌─────────────────────────────┐ │ ASP NET Core Web API      │\n│                             │\n│  ┌──────────────────────┐   │\n│  │  Whizbang Runtime    │   │\n│  │  (In-Memory)         │   │\n│  └──────────────────────┘   │\n│           ↓                 │\n│  ┌──────────────────────┐   │\n│  │  SQLite / Postgres   │   │\n│  └──────────────────────┘   │\n└─────────────────────────────┘\n`\nPerfect for:\nEvent-driven applications\nLocal development\nSimple event-driven patterns without event sourcing\nMulti-Service (Distributed)\n`text\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Microservices, Distributed, Event-Driven]\ndescription: Multi-service distributed architecture with dedicated databases and shared message broker\n---\n┌─────────────┐      ┌─────────────┐      ┌─────────────┐\n│   Orders    │      │  Inventory  │      │  Shipping   │\n│   Service   │      │   Service   │      │   Service   │\n│             │      │             │      │             │\n│  Whizbang   │      │  Whizbang   │      │  Whizbang   │\n│             │      │             │      │             │\n│  Postgres   │      │  Postgres   │      │  Postgres   │\n└──────┬──────┘      └──────┬──────┘      └──────┬──────┘\n       │                    │                    │\n       └────────────┬───────┴────────────────────┘\n                    ↓\n          ┌──────────────────┐\n          │  Kafka / RabbitMQ│\n          │  (Message Broker)│\n          └──────────────────┘\n`\nEach service:\nHas its own ledger for database isolation\nPublishes events to the shared message broker\nSubscribes to events from other services\nRoutes commands to owning services\nMulti-Region (Disaster Recovery)\n`text\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [Architecture, Multi-Region, Disaster-Recovery, Replication]\ndescription: Multi-region architecture with synchronized ledgers and mirrored message brokers for disaster recovery\n---\n        Region 1                         Region 2\n┌─────────────────────┐         ┌─────────────────────┐\n│  Primary Services   │         │  Replica Services   │\n│                     │         │                     │\n│  Ledgers            │◄───────►│  Ledgers            │\n│  (Postgres)         │  Sync   │  (Postgres)         │\n└─────────────────────┘         └─────────────────────┘\n         ↓                               ↓\n┌─────────────────────┐         ┌─────────────────────┐\n│  Kafka Cluster      │◄───────►│  Kafka Cluster      │\n│  (Region 1)         │  Mirror │  (Region 2)         │\n└─────────────────────┘         └─────────────────────┘\n`\nEvent streams in ledgers are replicated across regions for disaster recovery",
        "startIndex": 9110,
        "preview": "Continue processing new events as they arrive This allows new perspectives to be built from existing event history Scaling Patterns Single Process (Ev..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/architecture-chunk-7",
        "text": "│ │ │ Ledgers │◄───────►│ Ledgers │ │ (Postgres) │ Sync │ (Postgres) │ └─────────────────────┘ └─────────────────────┘ ↓ ↓ ┌─────────────────────┐ ┌─────────────────────┐ │ Kafka Cluster │◄───────►│ Kafka Cluster │ │ (Region 1) │ Mirror │ (Region 2) │ └─────────────────────┘ └─────────────────────┘ ` Event streams in ledgers are replicated across regions for disaster recovery Region 2 can take over if Region 1 fails Progressive Enhancement Modes\nWhizbang provides four deployment modes, all using the exact same receptor code:\nMode 1: Event-Driven Development\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Configuration, Event-Driven, Development]\ndescription: Basic event-driven mode configuration for development scenarios\n---\nservices AddWhizbang(dispatcher => {\n    dispatcher UseEventDrivenMode();\n});\n`\nNo persistence dependencies\nImmediate execution with in-memory perspectives\nPerfect for development and testing\nMode 2: Event-Driven Production\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Configuration, Event-Driven, Production, Persistence]\ndescription: Event-driven production configuration with persistent perspectives\n---\nservices AddWhizbang(dispatcher => {\n    dispatcher UseEventDrivenMode();\n    dispatcher Perspectives UsePostgreSQL(connectionString);\n});\n`\nPersistent perspectives\nAutomatic retry on perspective failures\nDurable event processing\nMode 3: Event-Driven Distributed\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Configuration, Event-Driven, Distributed, Messaging]\ndescription: Event-driven distributed configuration with Kafka relays and persistent perspectives\n---\nservices AddWhizbang(dispatcher => {\n    dispatcher UseEventDrivenMode();\n    dispatcher UseRelays(relays => relays UseKafka(kafkaConfig));\n    dispatcher Perspectives UsePostgreSQL(connectionString);\n});\n`\nCross-service messaging with relays\nService discovery\nDistributed tracing\nMode 4: Event-Sourced with Ledger\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [Architecture, Configuration, Event-Sourcing, Ledger, Advanced]\ndescription: Event-sourced configuration with ledger and persistent perspectives\n---\nservices AddWhizbang(dispatcher => {\n    dispatcher UseEventSourcing(es => {\n        es UseLedger(ledgerConfig);\n    });\n    dispatcher Perspectives",
        "startIndex": 11720,
        "preview": "│ │ │ Ledgers │◄───────►│ Ledgers │ │ (Postgres) │ Sync │ (Postgres) │ └─────────────────────┘ └─────────────────────┘ ↓ ↓ ┌─────────────────────┐ ┌──..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/architecture-chunk-8",
        "text": "UsePostgreSQL(connectionString); }); ` Cross-service messaging with relays Service discovery Distributed tracing Mode 4: Event-Sourced with Ledger `csharp --- category: Architecture difficulty: ADVANCED tags: [Architecture, Configuration, Event-Sourcing, Ledger, Advanced] description: Event-sourced configuration with ledger and persistent perspectives --- services AddWhizbang(dispatcher => { dispatcher UseEventSourcing(es => { es UseLedger(ledgerConfig); }); dispatcher Perspectives UsePostgreSQL(connectionString);\n});\n`\nComplete event sourcing with stateful receptors\nTime travel debugging\nPerspective rebuilding from ledger\nMessage Execution Patterns\nWithin any mode, Whizbang supports three execution patterns:\nInline Mode\nReceptor executes synchronously within the caller's transaction:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Execution-Patterns, Inline, Synchronous]\ndescription: Inline execution pattern with synchronous receptor execution and perspective updates\n---\nvar @event = await dispatcher Send(new PlaceOrder( ));\n// Receptor executed, events appended, perspectives updated—all before returning\n`\nBest for:\nStrong consistency requirements\nSimple CRUD operations\nLocal development\nAsync Mode\nReceptor executes asynchronously in a background worker:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Execution-Patterns, Async, Background-Processing]\ndescription: Async execution pattern with background worker processing\n---\nawait dispatcher Publish(new PlaceOrder( ));\n// Command written to queue, returns immediately\n// Receptor executes in background worker\n`\nBest for:\nHigh throughput\nNon-blocking operations\nEventual consistency scenarios\nBatched Mode\nMultiple messages batched together for efficiency:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Execution-Patterns, Batched, Performance]\ndescription: Batched execution pattern for improved throughput with multiple commands\n---\nawait dispatcher PublishBatch(new[] {\n    new PlaceOrder( ),\n    new PlaceOrder( ),\n    new PlaceOrder( )\n});\n// All three commands processed in one batch for better throughput\n`\nBest for:\nBulk imports\nScheduled jobs\nData migration\nThe same receptor code works in all three modes Toggle via configuration, not code changes",
        "startIndex": 13727,
        "preview": "UsePostgreSQL(connectionString); }); ` Cross-service messaging with relays Service discovery Distributed tracing Mode 4: Event-Sourced with Ledger `cs..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/architecture-chunk-9",
        "text": "--- await dispatcher PublishBatch(new[] { new PlaceOrder( ), new PlaceOrder( ), new PlaceOrder( ) }); // All three commands processed in one batch for better throughput ` Best for: Bulk imports Scheduled jobs Data migration The same receptor code works in all three modes Toggle via configuration, not code changes Next Steps\nNow that you understand the overall architecture, dive into:\nCore Concepts - Deep dive into Receptors, Perspectives, and Lenses\nPackage Structure - Which NuGet packages to install\nGetting Started - Build your first Whizbang application",
        "startIndex": 15586,
        "preview": "--- await dispatcher PublishBatch(new[] { new PlaceOrder( ), new PlaceOrder( ), new PlaceOrder( ) }); // All three commands processed in one batch for..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/architecture-design/aspect-oriented-programming",
    "title": "Aspect-Oriented Programming in Whizbang",
    "category": "Architecture & Design",
    "url": "/docs/old-v1.0.0.0/architecture-design/aspect-oriented-programming",
    "chunks": [
      {
        "id": "old-v1.0.0.0/architecture-design/aspect-oriented-programming-chunk-0",
        "text": "Aspect-Oriented Programming in Whizbang\nOverview\nWhizbang brings true aspect-oriented programming (AOP) to NET messaging through source generators Cross-cutting concerns like logging, caching, retry, and authorization are first-class citizens, not afterthoughts bolted onto your handlers What Makes Whizbang's AOP Different\nTraditional NET AOP approaches suffer from:\nRuntime reflection overhead (Castle DynamicProxy, PostSharp)\nLimited compile-time verification (Attributes without validation)\nPoor IDE support (No IntelliSense for aspects)\nComplex configuration (XML files, registration ceremonies)\nWhizbang solves these with:\nSource generation - Zero runtime overhead\nCompile-time verification - Catch errors during build\nRich IDE integration - Full IntelliSense and refactoring\nConvention-based - Aspects just work\nCore Concepts\nAspects as Attributes\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [AOP, Aspects, Attributes, Handlers]\ndescription: Basic aspect attribute usage on a command handler\n---\n[Logged]                    // Add structured logging\n[Timed]                     // Track execution time\n[Cached(Duration = \"5m\")]   // Cache results\n[Retry(3, Backoff = \"exponential\")]  // Retry on failure\n[Authorized(Role = \"Admin\")]         // Enforce authorization\n[Validated]                 // Validate input\n[Transactional]            // Wrap in transaction\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Your business logic here\n        // All aspects are automatically woven in\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nAspect Execution Pipeline\n`mermaid\ngraph LR\n    Request --> Logged\n    Logged --> Authorized\n    Authorized --> Validated\n    Validated --> Cached{Cache Hit }\n    Cached -->|Yes| Response\n    Cached -->|No| Timed\n    Timed --> Transactional\n    Transactional --> Handler[Business Logic]\n    Handler --> Retry{Success }\n    Retry -->|No| Handler\n    Retry -->|Yes| UpdateCache\n    UpdateCache --> Response\n`\nBuilt-in Aspects\nLogging Aspect\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Logging, Structured-Logging, Configuration]\ndescription: Configured logging aspect with structured output\n---\n[Logged(\n    Level = LogLevel",
        "startIndex": 0,
        "preview": "Aspect-Oriented Programming in Whizbang\nOverview\nWhizbang brings true aspect-oriented programming (AOP) to NET messaging through source generators Cro..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/aspect-oriented-programming-chunk-1",
        "text": "-->|No| Timed Timed --> Transactional Transactional --> Handler[Business Logic] Handler --> Retry{Success } Retry -->|No| Handler Retry -->|Yes| UpdateCache UpdateCache --> Response ` Built-in Aspects Logging Aspect `csharp --- category: Architecture difficulty: INTERMEDIATE tags: [AOP, Logging, Structured-Logging, Configuration] description: Configured logging aspect with structured output --- [Logged( Level = LogLevel Information,\n    IncludeParameters = true,\n    IncludeResult = true,\n    IncludeDuration = true,\n    Message = \"Processing order {OrderId}\"\n)]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Automatically logs:\n        // - Method entry with parameters\n        // - Method exit with result\n        // - Execution duration\n        // - Any exceptions\n        return new OrderCreated(cmd OrderId);\n    }\n}\n// Generated structured log output:\n// {\n//   \"timestamp\": \"2024-01-15T10:30:00Z\",\n//   \"level\": \"Information\",\n//   \"message\": \"Processing order 123\",\n//   \"handler\": \"OrderHandler\",\n//   \"method\": \"Handle\",\n//   \"parameters\": { \"orderId\": \"123\", \"customerId\": \"456\" },\n//   \"duration\": 45,\n//   \"result\": { \"orderId\": \"123\", \"success\": true }\n// }\n`\nCaching Aspect\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Caching, Cache-Invalidation, Performance]\ndescription: Caching aspect with custom key and invalidation strategies\n---\n[Cached(\n    Duration = \"5m\",                    // Cache for 5 minutes\n    Key = \"{CustomerId}:{OrderId}\",     // Custom cache key\n    Condition = \"Result Success\",        // Only cache successful results\n    VaryBy = [\"Country\", \"Currency\"],   // Vary cache by these parameters\n    Group = \"Orders\"                     // Cache group for bulk invalidation\n)]\npublic class GetOrderHandler : IHandle<GetOrder> {\n    public Order Handle(GetOrder query) {\n        // First call: execute and cache\n        // Subsequent calls within 5min: return from cache\n        return LoadOrderFromDatabase(query",
        "startIndex": 2285,
        "preview": "-->|No| Timed Timed --> Transactional Transactional --> Handler[Business Logic] Handler --> Retry{Success } Retry -->|No| Handler Retry -->|Yes| Updat..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/aspect-oriented-programming-chunk-2",
        "text": "cache successful results VaryBy = [\"Country\", \"Currency\"], // Vary cache by these parameters Group = \"Orders\" // Cache group for bulk invalidation )] public class GetOrderHandler : IHandle<GetOrder> { public Order Handle(GetOrder query) { // First call: execute and cache // Subsequent calls within 5min: return from cache return LoadOrderFromDatabase(query OrderId);\n    }\n}\n// Cache invalidation\n[InvalidatesCache(Group = \"Orders\")]\npublic class UpdateOrderHandler : IHandle<UpdateOrder> {\n    public void Handle(UpdateOrder cmd) {\n        // Automatically invalidates all cached orders\n    }\n}\n`\nRetry Aspect\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Retry, Resilience, Error-Handling]\ndescription: Retry aspect with exponential backoff and conditional logic\n---\n[Retry(\n    MaxAttempts = 3,\n    Backoff = BackoffStrategy Exponential,\n    InitialDelay = \"1s\",\n    MaxDelay = \"30s\",\n    RetryOn = [typeof(TransientException)],\n    AbortOn = [typeof(ValidationException)],\n    OnRetry = nameof(LogRetry)\n)]\npublic class PaymentHandler : IHandle<ProcessPayment> {\n    public PaymentResult Handle(ProcessPayment cmd) {\n        // Automatically retries on TransientException\n        // Aborts immediately on ValidationException\n        return ProcessPayment(cmd);\n    }\n    private void LogRetry(Exception ex, int attempt, TimeSpan delay) {\n        _logger LogWarning($\"Retry {attempt} after {delay}: {ex Message}\");\n    }\n}\n`\nAuthorization Aspect\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Authorization, Security, Role-Based-Security]\ndescription: Authorization aspects with role-based and resource-based access control\n---\n[Authorized(\n    Roles = [\"Admin\", \"Manager\"],\n    Policies = [\"OrderManagement\"],\n    RequireAll = false,  // OR condition\n    FailureMode = AuthFailureMode",
        "startIndex": 3907,
        "preview": "cache successful results VaryBy = [\"Country\", \"Currency\"], // Vary cache by these parameters Group = \"Orders\" // Cache group for bulk invalidation )] ..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/aspect-oriented-programming-chunk-3",
        "text": "_logger LogWarning($\"Retry {attempt} after {delay}: {ex Message}\"); } } ` Authorization Aspect `csharp --- category: Architecture difficulty: INTERMEDIATE tags: [AOP, Authorization, Security, Role-Based-Security] description: Authorization aspects with role-based and resource-based access control --- [Authorized( Roles = [\"Admin\", \"Manager\"], Policies = [\"OrderManagement\"], RequireAll = false, // OR condition FailureMode = AuthFailureMode ThrowException\n)]\npublic class DeleteOrderHandler : IHandle<DeleteOrder> {\n    public void Handle(DeleteOrder cmd) {\n        // Only accessible to Admin or Manager roles\n        // Or users with OrderManagement policy\n    }\n}\n// Resource-based authorization\n[ResourceAuthorized(\n    Resource = \"{OrderId}\",\n    Permission = \"Delete\",\n    ResourceType = typeof(Order)\n)]\npublic class DeleteOrderHandler : IHandle<DeleteOrder> {\n    public void Handle(DeleteOrder cmd) {\n        // Checks if user can delete specific order\n    }\n}\n`\nValidation Aspect\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Validation, Data-Annotations, FluentValidation]\ndescription: Validation aspect with data annotations and custom rules\n---\n[Validated(\n    Mode = ValidationMode Strict,\n    ThrowOnFailure = true,\n    ErrorCode = \"VALIDATION_FAILED\"\n)]\npublic class CreateOrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Automatically validates cmd using:\n        // - Data annotations\n        // - FluentValidation rules\n        // - Custom validators\n        return new OrderCreated(cmd OrderId);\n    }\n}\n// The command with validation rules\npublic record CreateOrder(\n    [Required] Guid CustomerId,\n    [MinLength(1)] List<OrderItem> Items,\n    [EmailAddress] string CustomerEmail\n) : ICommand<OrderCreated>;\n`\nTransaction Aspect\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Transactions, ACID, Database]\ndescription: Transactional aspect with custom isolation and rollback rules\n---\n[Transactional(\n    IsolationLevel = IsolationLevel ReadCommitted,\n    Timeout = \"30s\",\n    ReadOnly = false,\n    Propagation = Propagation Required,\n    RollbackOn = [typeof(BusinessException)]\n)]\npublic class TransferMoneyHandler : IHandle<TransferMoney> {\n    public TransferResult Handle(TransferMoney cmd) {\n        // Entire operation wrapped in transaction\n        // Automatically rolled back on exception\n        DebitAccount(cmd FromAccount, cmd Amount);\n        CreditAccount(cmd ToAccount, cmd Amount);\n        return new TransferResult(cmd",
        "startIndex": 5390,
        "preview": "_logger LogWarning($\"Retry {attempt} after {delay}: {ex Message}\"); } } ` Authorization Aspect `csharp --- category: Architecture difficulty: INTERMED..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/aspect-oriented-programming-chunk-4",
        "text": "IsolationLevel ReadCommitted, Timeout = \"30s\", ReadOnly = false, Propagation = Propagation Required, RollbackOn = [typeof(BusinessException)] )] public class TransferMoneyHandler : IHandle<TransferMoney> { public TransferResult Handle(TransferMoney cmd) { // Entire operation wrapped in transaction // Automatically rolled back on exception DebitAccount(cmd FromAccount, cmd Amount); CreditAccount(cmd ToAccount, cmd Amount); return new TransferResult(cmd TransferId);\n    }\n}\n`\nMetrics Aspect\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Metrics, Observability, Telemetry]\ndescription: Metrics aspect with counters, histograms and custom tags\n---\n[Metrics(\n    Counter = \"orders created\",\n    Histogram = \"order processing duration\",\n    Tags = [\"country:{Country}\", \"product:{ProductType}\"],\n    IncludeDefaultTags = true\n)]\npublic class CreateOrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Automatically tracks:\n        // - Invocation count\n        // - Duration histogram\n        // - Success/failure rate\n        // - Custom tags from command\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nCreating Custom Aspects\nSimple Custom Aspect\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [AOP, Custom-Aspects, Audit, Interceptors]\ndescription: Custom audit aspect implementation with interception\n---\n[AttributeUsage(AttributeTargets Class | AttributeTargets Method)]\npublic class AuditAttribute : AspectAttribute {\n    public override async Task<T> InterceptAsync<T>(\n        AspectContext context, \n        Func<Task<T>> next) {\n        var audit = new AuditEntry {\n            User = context User Identity Name,\n            Action = context Method Name,\n            Timestamp = DateTime UtcNow,\n            Parameters = context Arguments\n        };\n        try {\n            var result = await next();\n            audit Success = true;\n            audit Result = result;\n            return result;\n        }\n        catch (Exception ex) {\n            audit Success = false;\n            audit Error = ex Message;\n            throw;\n        }\n        finally {\n            await context Services GetService<IAuditLog>()",
        "startIndex": 7510,
        "preview": "IsolationLevel ReadCommitted, Timeout = \"30s\", ReadOnly = false, Propagation = Propagation Required, RollbackOn = [typeof(BusinessException)] )] publi..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/aspect-oriented-programming-chunk-5",
        "text": "Method Name, Timestamp = DateTime UtcNow, Parameters = context Arguments }; try { var result = await next(); audit Success = true; audit Result = result; return result; } catch (Exception ex) { audit Success = false; audit Error = ex Message; throw; } finally { await context Services GetService<IAuditLog>() LogAsync(audit);\n        }\n    }\n}\n`\nAdvanced Custom Aspect with Source Generator\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [AOP, Source-Generation, Rate-Limiting, Code-Generation]\ndescription: Advanced aspect with source generator for rate limiting\n---\n// Aspect definition\n[AspectGenerator]\npublic class RateLimitAttribute : AspectAttribute {\n    public int RequestsPerMinute { get; set; }\n    public string Key { get; set; }\n}\n// Source generator creates:\npublic static class RateLimitAspectGenerator {\n    [GeneratedCode]\n    public static async Task<T> Apply<T>(\n        Func<Task<T>> handler,\n        RateLimitAttribute attribute,\n        AspectContext context) {\n        var rateLimiter = context GetService<IRateLimiter>();\n        var key = attribute Key Replace(\"{UserId}\", context User Id);\n        if ( await rateLimiter AllowRequest(key, attribute RequestsPerMinute)) {\n            throw new RateLimitExceededException();\n        }\n        return await handler();\n    }\n}\n`\nAspect Composition\nSequential Composition\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Aspect-Composition, Execution-Order]\ndescription: Sequential aspect composition and execution order\n---\n// Aspects execute in order\n[First]   // Executes first\n[Second]  // Executes second\n[Third]   // Executes third\npublic class Handler : IHandle<Command> {\n    // Execution order: First -> Second -> Third -> Handler -> Third -> Second -> First\n}\n`\nConditional Composition\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [AOP, Conditional-Aspects, Runtime-Configuration]\ndescription: Conditional aspect composition based on runtime conditions\n---\n[ConditionalAspect(When = \"Environment == 'Production'\", Apply = typeof(AuditAspect))]\n[ConditionalAspect(When = \"User",
        "startIndex": 9312,
        "preview": "Method Name, Timestamp = DateTime UtcNow, Parameters = context Arguments }; try { var result = await next(); audit Success = true; audit Result = resu..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/aspect-oriented-programming-chunk-6",
        "text": "// Execution order: First -> Second -> Third -> Handler -> Third -> Second -> First } ` Conditional Composition `csharp --- category: Architecture difficulty: ADVANCED tags: [AOP, Conditional-Aspects, Runtime-Configuration] description: Conditional aspect composition based on runtime conditions --- [ConditionalAspect(When = \"Environment == 'Production'\", Apply = typeof(AuditAspect))] [ConditionalAspect(When = \"User IsAdmin\", Apply = typeof(AdminLoggingAspect))]\npublic class Handler : IHandle<Command> {\n    // Aspects applied based on runtime conditions\n}\n`\nComposite Aspects\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Composite-Aspects, Reusability]\ndescription: Composite aspect pattern for reusable aspect combinations\n---\n// Define a composite aspect\n[CompositeAspect]\n[Logged]\n[Timed]\n[Retry(3)]\n[Cached(\"5m\")]\npublic class StandardHandlerAspects : AspectAttribute { }\n// Use the composite\n[StandardHandlerAspects]\npublic class OrderHandler : IHandle<CreateOrder> {\n    // Gets all aspects from composite\n}\n`\nCompile-Time Verification\nPure Function Enforcement\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [AOP, Pure-Functions, Compile-Time-Verification]\ndescription: Pure function enforcement with compile-time verification\n---\n[Pure] // Compile-time verification\npublic class CalculationHandler : IHandle<Calculate> {\n    public Result Handle(Calculate cmd) {\n        // ✅ Allowed: Pure computation\n        var result = cmd A + cmd B;\n        // ❌ Compile error: I/O not allowed\n        // await database SaveAsync(result);\n        // ❌ Compile error: State mutation not allowed  \n        // this",
        "startIndex": 11115,
        "preview": "// Execution order: First -> Second -> Third -> Handler -> Third -> Second -> First } ` Conditional Composition `csharp --- category: Architecture dif..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/aspect-oriented-programming-chunk-7",
        "text": "--- [Pure] // Compile-time verification public class CalculationHandler : IHandle<Calculate> { public Result Handle(Calculate cmd) { // ✅ Allowed: Pure computation var result = cmd A + cmd B; // ❌ Compile error: I/O not allowed // await database SaveAsync(result); // ❌ Compile error: State mutation not allowed // this field = result;\n        return new Result(result);\n    }\n}\n`\nEffect Tracking\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [AOP, Effect-Tracking, Compile-Time-Verification]\ndescription: Effect tracking with compile-time verification of side effects\n---\n[Effects(\n    Reads = [\"Database\", \"Cache\"],\n    Writes = [\"Database\"],\n    Publishes = [\"OrderEvents\"],\n    NetworkCalls = [\"PaymentGateway\"]\n)]\npublic class OrderHandler : IHandle<ProcessOrder> {\n    public async Task<Result> Handle(ProcessOrder cmd) {\n        // Source generator verifies declared effects match actual usage\n        var order = await ReadDatabase();      // ✅ Matches Reads\n        await WriteDatabase(order);            // ✅ Matches Writes\n        await PublishEvent(new OrderCreated());// ✅ Matches Publishes\n        // await CallUndeclaredService();      // ❌ Compile error: Undeclared effect\n    }\n}\n`\nAspect Compatibility Checking\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [AOP, Aspect-Compatibility, Compile-Time-Validation]\ndescription: Compile-time detection of incompatible aspect combinations\n---\n// Source generator detects incompatible aspects\n[Cached]        // ❌ Compile error: Cannot cache with [NoCache]\n[NoCache]       \npublic class Handler { }\n[Transactional] // ❌ Compile error: ReadOnly transaction cannot Write\n[ReadOnly]\n[Writes(\"Database\")]\npublic class Handler { }\n`\nPerformance Optimizations\nZero-Overhead Aspects\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [AOP, Source-Generation, Performance-Optimization]\ndescription: Zero-overhead aspect implementation via source generation\n---\n// Source generator creates optimized code\n[Logged]\n[Timed]\npublic class Handler : IHandle<Command> {\n    public Result Handle(Command cmd) => new Result();\n}\n// Generated code (simplified):\npublic class Handler_Generated : IHandle<Command> {\n    private readonly Handler _handler;\n    private readonly ILogger _logger;\n    private readonly IMetrics _metrics;\n    public Result Handle(Command cmd) {\n        var stopwatch = ValueStopwatch StartNew(); // Stack allocated\n        _logger LogDebug(\"Handling {Command}\", cmd);\n        try {\n            var result = _handler Handle(cmd);\n            _logger",
        "startIndex": 12351,
        "preview": "--- [Pure] // Compile-time verification public class CalculationHandler : IHandle<Calculate> { public Result Handle(Calculate cmd) { // ✅ Allowed: Pur..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/aspect-oriented-programming-chunk-8",
        "text": "new Result(); } // Generated code (simplified): public class Handler_Generated : IHandle<Command> { private readonly Handler _handler; private readonly ILogger _logger; private readonly IMetrics _metrics; public Result Handle(Command cmd) { var stopwatch = ValueStopwatch StartNew(); // Stack allocated _logger LogDebug(\"Handling {Command}\", cmd); try { var result = _handler Handle(cmd); _logger LogDebug(\"Handled {Command} in {Duration}ms\", cmd, stopwatch ElapsedMilliseconds);\n            _metrics RecordDuration(\"handler duration\", stopwatch Elapsed);\n            return result;\n        }\n        catch (Exception ex) {\n            _logger LogError(ex, \"Error handling {Command}\", cmd);\n            _metrics IncrementCounter(\"handler errors\");\n            throw;\n        }\n    }\n}\n`\nAspect Caching\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Performance, Caching, Optimization]\ndescription: Aspect instance caching for performance optimization\n---\n// Aspects instances are cached and reused\n[Expensive] // This aspect instance is created once and reused\npublic class Handler : IHandle<Command> {\n    // Aspect state is maintained across invocations where appropriate\n}\n`\nTesting with Aspects\nUnit Testing\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Testing, Unit-Tests, Verification]\ndescription: Unit testing handlers with aspect verification\n---\n[Test]\npublic async Task Handler_WithAspects_LogsAndTimes() {\n    // Arrange\n    var handler = new OrderHandler();\n    var context = new TestAspectContext();\n    // Act\n    var result = await AspectRunner RunWithAspects(\n        handler,\n        new CreateOrder { OrderId = \"123\" },\n        context\n    );\n    // Assert\n    result ShouldBeSuccess();\n    context Logs ShouldContain(log => log Message Contains(\"123\"));\n    context Metrics[\"handler duration\"] ShouldBeLessThan(100);\n}\n`\nIntegration Testing\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Testing, Integration-Tests, Production-Testing]\ndescription: Integration testing with production aspect profiles\n---\n[Test]\npublic async Task Handler_WithProductionAspects_WorksCorrectly() {\n    await Whizbang Test<OrderHandler>() Given(new CreateOrder { }) WithAspects(AspectProfile Production) // Use production aspects WhenHandled() Then(result => result ShouldBeSuccess()) AndAspect<CacheAspect>(cache => \n            cache ShouldHaveStored(\"order:123\")) AndAspect<LoggingAspect>(logs => \n            logs ShouldContain(LogLevel",
        "startIndex": 14591,
        "preview": "new Result(); } // Generated code (simplified): public class Handler_Generated : IHandle<Command> { private readonly Handler _handler; private readonl..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/aspect-oriented-programming-chunk-9",
        "text": "--- category: Architecture difficulty: INTERMEDIATE tags: [AOP, Testing, Integration-Tests, Production-Testing] description: Integration testing with production aspect profiles --- [Test] public async Task Handler_WithProductionAspects_WorksCorrectly() { await Whizbang Test<OrderHandler>() Given(new CreateOrder { }) WithAspects(AspectProfile Production) // Use production aspects WhenHandled() Then(result => result ShouldBeSuccess()) AndAspect<CacheAspect>(cache => cache ShouldHaveStored(\"order:123\")) AndAspect<LoggingAspect>(logs => logs ShouldContain(LogLevel Info, \"Order created\"));\n}\n`\nIDE Integration\nIntelliSense Support\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [AOP, IDE-Integration, IntelliSense, Tooling]\ndescription: IDE support for aspect suggestions and execution order visualization\n---\n// IDE suggests applicable aspects based on handler type\n[Wh| // IDE suggests: WhizbangCached, WhizbangLogged, WhizbangRetry // IDE shows aspect execution order\n[Logged]    // (1)\n[Cached]    // (2)  \n[Retry]     // (3)\npublic class Handler { \n    // IDE tooltip: \"Execution order: Logged -> Cached -> Retry -> Handler\"\n}\n`\nRefactoring Support\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [AOP, IDE-Integration, Refactoring, Tooling]\ndescription: IDE refactoring support for aspects and composites\n---\n// Rename aspect updates all usages\n[MyCustomAspect] // F2 rename updates everywhere\npublic class Handler { }\n// Extract aspect combination to composite\n[Logged]\n[Timed]\n[Retry] // Right-click -> \"Extract to Composite Aspect\"\n`\nBest Practices\nDo's\n✅ Use aspects for cross-cutting concerns\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [AOP, Best-Practices, Cross-Cutting-Concerns]\ndescription: Using aspects for cross-cutting concerns\n---\n[Logged]\n[Authorized]\n[Transactional]\n`\n✅ Keep aspects focused and single-purpose\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [AOP, Best-Practices, Single-Responsibility]\ndescription: Keeping aspects focused and single-purpose\n---\n[Cached]  // Just caching\n[Logged]  // Just logging\n`\n✅ Compose aspects for complex scenarios\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Best-Practices, Composite-Aspects]\ndescription: Composing aspects for complex scenarios\n---\n[StandardSecurity]  // Composite of auth, audit, encryption\n`\n✅ Test aspects independently\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Best-Practices, Testing]\ndescription: Testing aspects independently\n---\nAspectTester Test<LoggingAspect>()",
        "startIndex": 16770,
        "preview": "--- category: Architecture difficulty: INTERMEDIATE tags: [AOP, Testing, Integration-Tests, Production-Testing] description: Integration testing with ..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/aspect-oriented-programming-chunk-10",
        "text": "aspects for complex scenarios `csharp --- category: Architecture difficulty: INTERMEDIATE tags: [AOP, Best-Practices, Composite-Aspects] description: Composing aspects for complex scenarios --- [StandardSecurity] // Composite of auth, audit, encryption ` ✅ Test aspects independently `csharp --- category: Architecture difficulty: INTERMEDIATE tags: [AOP, Best-Practices, Testing] description: Testing aspects independently --- AspectTester Test<LoggingAspect>() VerifyBehavior();\n`\nDon'ts\n❌ Don't put business logic in aspects\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [AOP, Anti-Patterns, Bad-Practices]\ndescription: Anti-pattern - putting business logic in aspects\n---\n[CalculateTax] // Bad: Business logic belongs in handler\n`\n❌ Don't create circular aspect dependencies\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [AOP, Anti-Patterns, Circular-Dependencies]\ndescription: Anti-pattern - circular aspect dependencies\n---\n[AspectA(DependsOn = \"AspectB\")]\n[AspectB(DependsOn = \"AspectA\")] // Circular `\n❌ Don't overuse aspects\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [AOP, Anti-Patterns, Over-Engineering]\ndescription: Anti-pattern - overusing aspects obscures logic\n---\n// Too many aspects obscure logic\n[Aspect1][Aspect2][Aspect3][Aspect4][Aspect5] `\nSummary\nWhizbang's AOP system brings enterprise-grade aspect-oriented programming to NET with:\nZero runtime overhead through source generation\nCompile-time safety with verification\nRich IDE support for productivity  \nComposable aspects for complex scenarios\nTestable aspects for confidence\nThis enables clean separation of cross-cutting concerns from business logic while maintaining performance and type safety Next Steps\nLearn about Return Type Semantics\nExplore Policy Composition\nSee Aspect-Oriented Handlers pattern\nReview Testing Strategies for aspects",
        "startIndex": 18784,
        "preview": "aspects for complex scenarios `csharp --- category: Architecture difficulty: INTERMEDIATE tags: [AOP, Best-Practices, Composite-Aspects] description: ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/architecture-design/event-driven-architecture",
    "title": "Event-Driven Architecture",
    "category": "Architecture & Design",
    "url": "/docs/old-v1.0.0.0/architecture-design/event-driven-architecture",
    "chunks": [
      {
        "id": "old-v1.0.0.0/architecture-design/event-driven-architecture-chunk-0",
        "text": "Event-Driven Architecture\nOverview\nWhizbang is built on a universal event-driven architecture where all state changes flow through events, regardless of whether you're using Event-Driven or Event-Sourced mode This fundamental design principle enables seamless progression from simple applications to complex event-sourced systems without changing your core logic The Key Insight\nWrite through events, read through lenses This simple principle unifies all Whizbang applications:\nCommands flow to Receptors which make decisions\nReceptors emit Events representing those decisions  \nEvents flow to Perspectives which update views\nLenses provide read-only access to current state\nEvent-Driven vs Event-Sourced\nBoth modes use the same components and patterns The only difference is whether events are persisted:\n| Aspect | Event-Driven Mode | Event-Sourced Mode |\n|--------|-------------------|-------------------|\n| Events | Transient - drive immediate updates | Persisted - become source of truth |\n| Receptors | Stateless - get state from Lenses | Stateful - maintain state from event stream |\n| Perspectives | Execute inline with receptor | Execute async from event stream |\n| Ledger | Not used | Stores all events permanently |\n| Replay | Not possible | Can rebuild from events |\n| Transaction | Receptor + Perspective together | Event append is the transaction |\nCore Components\nReceptor\nPurpose: Receives commands, makes decisions, emits events\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Receptors, Event-Driven, CQRS]\ndescription: Universal receptor interface that works in both event-driven and event-sourced modes\n---\n// Same interface works in both modes public class OrderReceptor : IReceptor<CreateOrder> {\n    public OrderCreated Receive(CreateOrder cmd, IOrderLens lens) {\n        // Validate using lens (read-only view)\n        var customer = lens GetCustomer(cmd CustomerId);\n        if ( customer IsActive) {\n            throw new InactiveCustomerException();\n        }\n        // Make decision and emit event\n        return new OrderCreated(\n            Guid NewGuid(),\n            cmd CustomerId,\n            cmd Items,\n            DateTime",
        "startIndex": 0,
        "preview": "Event-Driven Architecture\nOverview\nWhizbang is built on a universal event-driven architecture where all state changes flow through events, regardless ..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/event-driven-architecture-chunk-1",
        "text": "public class OrderReceptor : IReceptor<CreateOrder> { public OrderCreated Receive(CreateOrder cmd, IOrderLens lens) { // Validate using lens (read-only view) var customer = lens GetCustomer(cmd CustomerId); if ( customer IsActive) { throw new InactiveCustomerException(); } // Make decision and emit event return new OrderCreated( Guid NewGuid(), cmd CustomerId, cmd Items, DateTime UtcNow\n        );\n    }\n}\n`\nPerspective\nPurpose: Updates views and projections from events\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Perspectives, Event-Driven, Projections]\ndescription: Perspective that updates multiple data stores from events, working identically in both modes\n---\n// Perspectives work identically in both modes\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        // Update database\n        await db Orders Add(new Order { \n            Id = e OrderId,\n            CustomerId = e CustomerId \n        });\n        // Update cache\n        await cache Invalidate($\"customer:{e CustomerId}\");\n        // Update search index\n        await search",
        "startIndex": 2198,
        "preview": "public class OrderReceptor : IReceptor<CreateOrder> { public OrderCreated Receive(CreateOrder cmd, IOrderLens lens) { // Validate using lens (read-onl..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/event-driven-architecture-chunk-2",
        "text": "// Perspectives work identically in both modes public class OrderPerspective : IPerspectiveOf<OrderCreated> { public async Task Update(OrderCreated e) { // Update database await db Orders Add(new Order { Id = e OrderId, CustomerId = e CustomerId }); // Update cache await cache Invalidate($\"customer:{e CustomerId}\"); // Update search index await search Index(e);\n    }\n}\n`\nLens\nPurpose: Provides read-only access to current state\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Lenses, Read-Model, Query-Interface]\ndescription: Read-only lens interface providing consistent data access regardless of execution mode\n---\n// Lenses provide consistent reads regardless of mode\npublic interface IOrderLens {\n    Order Focus(Guid id);                           // Get single item\n    IEnumerable<Order> View(Expression<Func<Order, bool>> filter);\n    OrderSummary Glimpse(Guid id);                  // Summary view\n    bool Exists(Guid id);                           // Quick check\n}\n`\nDispatcher\nPurpose: Routes commands to receptors and events to perspectives\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Dispatcher, CQRS, Message-Routing]\ndescription: Core dispatcher interface for command routing, event broadcasting, and query execution\n---\npublic interface IDispatcher {\n    Task<TEvent> Dispatch<TEvent>(ICommand<TEvent> command);\n    Task Broadcast(IEvent @event);\n    Task<TResult> Query<TResult>(IQuery<TResult> query);\n}\n`\nThe Universal Pattern\nThis pattern works identically in both modes:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Universal-Pattern, Business-Logic, Event-Driven]\ndescription: Universal pattern showing receptor and perspective working identically in both modes\n---\npublic class TransferMoneyReceptor : IReceptor<TransferMoney> {\n    public MoneyTransferred Receive(TransferMoney cmd, IAccountLens lens) {\n        // Read current state through lens\n        var fromAccount = lens Focus(cmd FromAccountId);\n        var toAccount = lens Focus(cmd ToAccountId);\n        // Make business decision\n        if (fromAccount Balance < cmd Amount) {\n            throw new InsufficientFundsException();\n        }\n        // Emit event - this IS the write operation\n        return new MoneyTransferred(\n            cmd FromAccountId,\n            cmd ToAccountId,\n            cmd Amount,\n            DateTime",
        "startIndex": 2961,
        "preview": "// Perspectives work identically in both modes public class OrderPerspective : IPerspectiveOf<OrderCreated> { public async Task Update(OrderCreated e)..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/event-driven-architecture-chunk-3",
        "text": "current state through lens var fromAccount = lens Focus(cmd FromAccountId); var toAccount = lens Focus(cmd ToAccountId); // Make business decision if (fromAccount Balance < cmd Amount) { throw new InsufficientFundsException(); } // Emit event - this IS the write operation return new MoneyTransferred( cmd FromAccountId, cmd ToAccountId, cmd Amount, DateTime UtcNow\n        );\n    }\n}\npublic class AccountPerspective : IPerspectiveOf<MoneyTransferred> {\n    public async Task Update(MoneyTransferred e) {\n        // In Event-Driven: Direct database update\n        // In Event-Sourced: Update from replayed event\n        await db UpdateBalance(e FromAccountId, -e Amount);\n        await db UpdateBalance(e ToAccountId, e Amount);\n        await db AddTransaction(e);\n    }\n}\n`\nMode Selection via Policies\nConfigure behavior per-receptor using policies:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Policy-Configuration, Mode-Selection, Hybrid]\ndescription: Configuration showing mixed modes within same application using policies\n---\nservices AddWhizbang() UseDispatcher(dispatcher => {\n        // Default mode for all receptors\n        dispatcher DefaultPolicy = new EventDrivenPolicy();\n        // Specific receptors use event sourcing\n        dispatcher ForReceptor<PaymentReceptor>() UsePolicy(new EventSourcedPolicy());\n        dispatcher ForReceptor<AuditReceptor>() UsePolicy(new EventSourcedPolicy());\n        // Mix modes in same application });\n`\nEvolution Path\nPhase 1: Event-Driven (Stateless Receptors)\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Event-Driven, Stateless-Receptors, Phase-1]\ndescription: Event-driven mode with stateless receptor getting state from lens\n---\n// Stateless receptor gets state from lens\npublic class OrderReceptor : IReceptor<ShipOrder> {\n    public OrderShipped Receive(ShipOrder cmd, IOrderLens lens) {\n        var order = lens Focus(cmd OrderId);  // Get state from lens\n        if (order Status = \"Paid\") {\n            throw new InvalidOperationException(\"Order must be paid\");\n        }\n        return new OrderShipped(cmd OrderId, DateTime",
        "startIndex": 5036,
        "preview": "current state through lens var fromAccount = lens Focus(cmd FromAccountId); var toAccount = lens Focus(cmd ToAccountId); // Make business decision if ..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/event-driven-architecture-chunk-4",
        "text": "--- // Stateless receptor gets state from lens public class OrderReceptor : IReceptor<ShipOrder> { public OrderShipped Receive(ShipOrder cmd, IOrderLens lens) { var order = lens Focus(cmd OrderId); // Get state from lens if (order Status = \"Paid\") { throw new InvalidOperationException(\"Order must be paid\"); } return new OrderShipped(cmd OrderId, DateTime UtcNow);\n    }\n}\n`\nPhase 2: Event-Sourced (Stateful Receptors)\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [Architecture, Event-Sourcing, Stateful-Receptors, Phase-2]\ndescription: Event-sourced mode with stateful receptor maintaining state from events\n---\n// Same receptor, now stateful\n[EventSourced]\npublic class OrderReceptor : IReceptor<ShipOrder> {\n    private OrderStatus status;  // State maintained from events\n    public OrderShipped Receive(ShipOrder cmd) {\n        if (status = OrderStatus Paid) {  // Use internal state\n            throw new InvalidOperationException(\"Order must be paid\");\n        }\n        return new OrderShipped(Id, DateTime UtcNow);\n    }\n    // Apply events to maintain state\n    public void Absorb(OrderCreated e) => status = OrderStatus Created;\n    public void Absorb(OrderPaid e) => status = OrderStatus Paid;\n    public void Absorb(OrderShipped e) => status = OrderStatus Shipped;\n}\n`\nThe Flow\nEvent-Driven Mode\n`text\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Event-Driven, Flow-Diagram, Synchronous]\ndescription: Event-driven mode flow with immediate database updates\n---\nCommand → Dispatcher → Receptor → Event\n                           ↓\n                    Perspective → Database (immediate)\n                           ↓\n                        Lens → Queries\n`\nEvent-Sourced Mode\n`text\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [Architecture, Event-Sourcing, Flow-Diagram, Asynchronous]\ndescription: Event-sourced mode flow with ledger persistence and async perspective updates\n---\nCommand → Dispatcher → Receptor → Event\n                           ↓\n                        Ledger (persist)\n                           ↓\n                    Perspective → Database (async)\n                           ↓\n                        Lens → Queries\n`\nKey Principles\nEvents Are The Write Model\nNo direct database writes",
        "startIndex": 6874,
        "preview": "--- // Stateless receptor gets state from lens public class OrderReceptor : IReceptor<ShipOrder> { public OrderShipped Receive(ShipOrder cmd, IOrderLe..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/event-driven-architecture-chunk-5",
        "text": "difficulty: ADVANCED tags: [Architecture, Event-Sourcing, Flow-Diagram, Asynchronous] description: Event-sourced mode flow with ledger persistence and async perspective updates --- Command → Dispatcher → Receptor → Event ↓ Ledger (persist) ↓ Perspective → Database (async) ↓ Lens → Queries ` Key Principles Events Are The Write Model No direct database writes All state changes flow through events:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Best-Practices, Events-As-Write-Model, Anti-Patterns]\ndescription: Comparison showing wrong direct database writes vs correct event-driven approach\n---\n// ❌ WRONG - Direct database write\npublic void Handle(CreateOrder cmd) {\n    var order = new Order { };\n    database Orders Add(order);  // Don't do this database SaveChanges();\n}\n// ✅ RIGHT - Write through events\npublic OrderCreated Receive(CreateOrder cmd) {\n    return new OrderCreated( );  // Perspective handles the write\n}\n`\nLenses Are Read-Only\nLenses never modify state, they only observe:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Best-Practices, Read-Only-Lenses, Anti-Patterns]\ndescription: Comparison showing wrong lens with write methods vs correct read-only lens\n---\n// ❌ WRONG - Lens with write methods\npublic interface IOrderLens {\n    void Save(Order order);  // Don't do this }\n// ✅ RIGHT - Read-only lens\npublic interface IOrderLens {\n    Order Focus(Guid id);\n    bool Exists(Guid id);\n}\n`\nPerspectives Handle All Writes\nAll database updates happen in perspectives:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Best-Practices, Perspective-Writes, Separation-Of-Concerns]\ndescription: Proper perspective implementation handling all database writes\n---\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        // ALL writes happen here\n        await db Orders Add( );\n        await cache Set( );\n        await search Index(",
        "startIndex": 8793,
        "preview": "difficulty: ADVANCED tags: [Architecture, Event-Sourcing, Flow-Diagram, Asynchronous] description: Event-sourced mode flow with ledger persistence and..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/event-driven-architecture-chunk-6",
        "text": "perspectives: `csharp --- category: Architecture difficulty: INTERMEDIATE tags: [Architecture, Best-Practices, Perspective-Writes, Separation-Of-Concerns] description: Proper perspective implementation handling all database writes --- public class OrderPerspective : IPerspectiveOf<OrderCreated> { public async Task Update(OrderCreated e) { // ALL writes happen here await db Orders Add( ); await cache Set( ); await search Index( );\n    }\n}\n`\nBenefits\nImmediate Benefits (Event-Driven Mode)\nClear separation between reads and writes\nExplicit side effects - all changes visible as events\nNatural audit trail - events show what happened\nTestability - test receptors without database\nAdditional Benefits (Event-Sourced Mode)\nComplete history - every change is recorded\nTime travel - see state at any point in time\nEvent replay - rebuild projections from events\nDebugging - trace exactly what happened\nMigration Strategy\nMoving from Event-Driven to Event-Sourced is seamless:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Migration-Strategy, Progressive-Enhancement, Evolution]\ndescription: Step-by-step migration from event-driven to event-sourced without code changes\n---\n// Step 1: You're already Event-Driven\nservices AddWhizbang() UseDispatcher(d => d DefaultPolicy = new EventDrivenPolicy());\n// Step 2: Enable Event-Sourcing for specific receptors\nservices AddWhizbang() UseDispatcher(d => {\n        d DefaultPolicy = new EventDrivenPolicy();\n        d ForReceptor<Order>() UsePolicy(new EventSourcedPolicy());\n    });\n// Step 3: Gradually migrate more receptors\n// No code changes needed `\nReal-World Example\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Architecture, Real-World-Example, Multiple-Perspectives, Checkout-Process]\ndescription: Complete checkout example showing receptor with multiple perspectives handling different concerns\n---\n// This receptor works in BOTH modes without changes\npublic class CheckoutReceptor : IReceptor<Checkout> {\n    public CheckoutCompleted Receive(Checkout cmd, ICheckoutLens lens) {\n        // Validate inventory\n        var inventory = lens GetInventory(cmd Items);\n        if ( inventory IsAvailable()) {\n            throw new OutOfStockException();\n        }\n        // Validate payment\n        var paymentMethod = lens GetPaymentMethod(cmd PaymentId);\n        if ( paymentMethod",
        "startIndex": 10461,
        "preview": "perspectives: `csharp --- category: Architecture difficulty: INTERMEDIATE tags: [Architecture, Best-Practices, Perspective-Writes, Separation-Of-Conce..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/event-driven-architecture-chunk-7",
        "text": "receptor works in BOTH modes without changes public class CheckoutReceptor : IReceptor<Checkout> { public CheckoutCompleted Receive(Checkout cmd, ICheckoutLens lens) { // Validate inventory var inventory = lens GetInventory(cmd Items); if ( inventory IsAvailable()) { throw new OutOfStockException(); } // Validate payment var paymentMethod = lens GetPaymentMethod(cmd PaymentId); if ( paymentMethod IsValid()) {\n            throw new InvalidPaymentException();\n        }\n        // Emit event - the perspective handles all writes\n        return new CheckoutCompleted(\n            Guid NewGuid(),\n            cmd CustomerId,\n            cmd Items,\n            cmd PaymentId,\n            DateTime UtcNow\n        );\n    }\n}\n// Multiple perspectives update different concerns\npublic class OrderPerspective : IPerspectiveOf<CheckoutCompleted> {\n    public async Task Update(CheckoutCompleted e) {\n        await db Orders Create(e OrderId, e CustomerId, e Items);\n    }\n}\npublic class InventoryPerspective : IPerspectiveOf<CheckoutCompleted> {\n    public async Task Update(CheckoutCompleted e) {\n        foreach (var item in e Items) {\n            await db Inventory Reserve(item ProductId, item Quantity);\n        }\n    }\n}\npublic class PaymentPerspective : IPerspectiveOf<CheckoutCompleted> {\n    public async Task Update(CheckoutCompleted e) {\n        await paymentGateway Charge(e PaymentId, e Total);\n    }\n}\n`\nSummary\nThe Event-Driven Architecture in Whizbang provides:\nUnified model - Same patterns for Event-Driven and Event-Sourced\nProgressive enhancement - Start simple, add event sourcing when needed\nNo rewrites - Same receptor code works in both modes\nMix and match - Use different modes for different aggregates\nClear semantics - Events for writes, lenses for reads\nThis architecture ensures that you're always thinking in events, whether you choose to persist them or not Next Steps\nLearn about Receptors - The universal command handler\nExplore Perspectives - Event-driven projections\nUnderstand Lenses - Read-only query interfaces\nSee Progressive Enhancement - Evolution strategies",
        "startIndex": 12427,
        "preview": "receptor works in BOTH modes without changes public class CheckoutReceptor : IReceptor<Checkout> { public CheckoutCompleted Receive(Checkout cmd, IChe..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/architecture-design/philosophy",
    "title": "Philosophy & Design Principles",
    "category": "Architecture & Design",
    "url": "/docs/old-v1.0.0.0/architecture-design/philosophy",
    "chunks": [
      {
        "id": "old-v1.0.0.0/architecture-design/philosophy-chunk-0",
        "text": "Philosophy & Design Principles\nWhizbang is a unified event-driven and event-sourced runtime for NET that collapses the complexity of MartenDB, Wolverine, MassTransit, and MediatR into a single cohesive platform with receptors, perspectives, and lenses Core Philosophy\nEvents as the Source of Truth\nEvents are immutable facts that have happened In Whizbang, events are not just notifications—they are the authoritative record of everything that has occurred in your system All aggregates and projections can be rebuilt or reimagined from the event stream at any time, even years after initial deployment This approach provides:\nComplete audit trail - Every state change is recorded forever\nTime travel debugging - Replay events to understand how state evolved\nFlexible projections - Build new read models from existing events\nMigration freedom - Refactor your domain model without losing history\nSingle Surface Area\nTeams waste cognitive energy context-switching between different APIs, patterns, and abstractions Whizbang provides one set of primitives for:\nReceptors - Decision-makers that receive commands and emit events\nPerspectives - Event handlers that update read models and external systems\nLenses - Read-only interfaces for querying data\nCommands - Requests to change state, routed to domain owners\nEvents - Immutable facts that represent state changes\nSagas - Long-running processes that coordinate across domains\nAll of these concepts share the same dispatcher model, dependency injection patterns, and testing approaches Learn once, apply everywhere One Runtime Any Mode Every Pattern Write your business logic once Run it anywhere Whizbang provides a unified mental model that scales from event-driven development to complex distributed event-sourced systems—without changing your receptors",
        "startIndex": 0,
        "preview": "Philosophy & Design Principles\nWhizbang is a unified event-driven and event-sourced runtime for NET that collapses the complexity of MartenDB, Wolveri..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/philosophy-chunk-1",
        "text": "these concepts share the same dispatcher model, dependency injection patterns, and testing approaches Learn once, apply everywhere One Runtime Any Mode Every Pattern Write your business logic once Run it anywhere Whizbang provides a unified mental model that scales from event-driven development to complex distributed event-sourced systems—without changing your receptors `csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Philosophy, Universal-Design, Mode-Switching, Progressive-Enhancement]\ndescription: Single receptor working across all modes with configuration-based mode switching\n---\n// This SAME receptor works across ALL modes\npublic class OrderReceptor : IReceptor<CreateOrder> {\n    public OrderCreated Receive(CreateOrder cmd) {\n        // Your business logic here\n        return new OrderCreated(cmd OrderId);\n    }\n}\n// Mode switching is just configuration\nservices AddWhizbang(d => d UseEventDrivenMode());     // Development\nservices AddWhizbang(d => d UseEventDrivenMode());     // Production with perspectives\nservices AddWhizbang(d => d UseDistributedMode());     // Microservices with relays\nservices AddWhizbang(d => d UseEventSourcing());       // Event sourcing with ledger\n`\nReturn Type Semantics\nWhat you return determines what happens No configuration files, no routing tables, no ceremony Your intent is clear from your code:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Philosophy, Return-Type-Semantics, Message-Patterns, Railway-Oriented]\ndescription: Return type semantics demonstrating how different return types determine behavior\n---\n// Single return = single effect\nreturn new OrderCreated();                           // Publishes event\n// Tuple return = multiple effects\nreturn (new OrderCreated(), new ProcessPayment());   // Cascading messages\n// Result return = railway-oriented programming\nreturn Result Success(new OrderCreated());          // Success/failure handling\n// Streaming return = real-time processing\nyield return new OrderProcessed();                  // IAsyncEnumerable\n`\nAspect-Oriented by Design\nCross-cutting concerns are first-class citizens",
        "startIndex": 1818,
        "preview": "these concepts share the same dispatcher model, dependency injection patterns, and testing approaches Learn once, apply everywhere One Runtime Any Mod..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/philosophy-chunk-2",
        "text": "Publishes event // Tuple return = multiple effects return (new OrderCreated(), new ProcessPayment()); // Cascading messages // Result return = railway-oriented programming return Result Success(new OrderCreated()); // Success/failure handling // Streaming return = real-time processing yield return new OrderProcessed(); // IAsyncEnumerable ` Aspect-Oriented by Design Cross-cutting concerns are first-class citizens Through source generators and compile-time weaving, aspects like logging, retry, caching, and authorization are declarative and performant:\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Philosophy, Aspect-Oriented, Cross-Cutting-Concerns, Declarative]\ndescription: Aspect-oriented design with declarative attributes for cross-cutting concerns\n---\n[Logged]\n[Cached(Duration = \"5m\")]\n[Retry(3, Backoff = \"exponential\")]\n[Authorized(Role = \"Admin\")]\npublic class OrderReceptor : IReceptor<CreateOrder> {\n    [Pure] // Compile-time verification of no side effects\n    public OrderCreated Receive(CreateOrder cmd) {\n        // All aspects automatically applied\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nFrom Simple to Scale\nWhizbang is designed for the full spectrum:\nSimple Start: Use Whizbang as event-driven architecture with in-memory perspectives Perfect for development and simple applications Growth Path: Add perspective persistence, event sourcing with ledger, and distributed relays as your needs grow Every feature is opt-in Enterprise Scale: Deploy across microservices with message brokers, multiple databases, multi-region disaster recovery, and Kubernetes auto-scaling The same code works at every scale Your simple receptors become distributed event-sourced receptors without rewrites Progressive Enhancement\nStart simple Add complexity only when needed Every Whizbang application follows the same growth path:\nEvent-Driven Development - Stateless receptors with in-memory perspectives\nEvent-Driven Production - Persistent perspectives with retry\nEvent-Driven Distributed - Scale across services with relays\nEvent-Sourced - Stateful receptors with ledger when needed\nThe same receptor code works at every level No rewrites as you scale Design Principles\nDriver-Based Architecture\nNever lock into a specific technology",
        "startIndex": 3590,
        "preview": "Publishes event // Tuple return = multiple effects return (new OrderCreated(), new ProcessPayment()); // Cascading messages // Result return = railway..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/philosophy-chunk-3",
        "text": "receptors with in-memory perspectives Event-Driven Production - Persistent perspectives with retry Event-Driven Distributed - Scale across services with relays Event-Sourced - Stateful receptors with ledger when needed The same receptor code works at every level No rewrites as you scale Design Principles Driver-Based Architecture Never lock into a specific technology Whizbang uses a driver-based system for:\nPersistence - Postgres, SQL Server, MySQL, Cosmos DB, LiteFS/SQLite\nMessaging - Kafka, RabbitMQ, Azure Service Bus, AWS SQS, in-memory\nSerialization - JSON, Protobuf, MessagePack, custom formats\nObservability - OpenTelemetry, Application Insights, custom telemetry\nSwap drivers through configuration, not code changes Start with SQLite for local dev, move to Postgres in staging, scale to Cosmos DB in production—all with the same domain code Domain Ownership\nEvery event and command has a home In distributed systems, clarity about ownership prevents chaos:\nCommands are sent TO the domain that owns them\nEvents are emitted FROM the domain that owns them\nNew services can subscribe to events and backfill projections from the entire event stream\nDomain boundaries are explicit in code and configuration\nThis prevents the \"event spaghetti\" problem where no one knows who publishes what, or where to send commands Receptors as Pure Functions\nReceptors are just Cmethods that return events No magic base classes, no required interfaces (unless you want them), no framework coupling Mark a receptor as pure and the Roslyn analyzer forbids hidden side effects—guaranteeing your receptor is a true function from input to output `csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Philosophy, Pure-Functions, Compile-Time-Safety, Side-Effects]\ndescription: Pure function example with compile-time verification preventing side effects\n---\n[Pure]\npublic OrderCalculated Receive(CalculateOrder cmd) {\n    // ✅ Pure computation allowed\n    return new OrderCalculated(cmd Items Sum(i => i Price));\n    // ❌ Compile error: Side effects not allowed in pure receptor\n    // await database",
        "startIndex": 5466,
        "preview": "receptors with in-memory perspectives Event-Driven Production - Persistent perspectives with retry Event-Driven Distributed - Scale across services wi..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/philosophy-chunk-4",
        "text": "INTERMEDIATE tags: [Philosophy, Pure-Functions, Compile-Time-Safety, Side-Effects] description: Pure function example with compile-time verification preventing side effects --- [Pure] public OrderCalculated Receive(CalculateOrder cmd) { // ✅ Pure computation allowed return new OrderCalculated(cmd Items Sum(i => i Price)); // ❌ Compile error: Side effects not allowed in pure receptor // await database SaveAsync(result);\n}\n`\nConvention Over Configuration\nYour code expresses intent through conventions Return types determine behavior Attributes declare aspects Source generators eliminate boilerplate No XML files, no complex registration, no ceremony `csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Philosophy, Convention-Over-Configuration, Return-Types, Declarative]\ndescription: Convention-based programming showing how return types and attributes express intent\n---\n// Return type determines what happens\npublic OrderCreated Receive(CreateOrder cmd) => new OrderCreated();      // Event to perspectives\npublic ProcessPayment Receive(OrderCreated e) => new ProcessPayment();   // Command to other receptor\npublic void Receive(LogActivity cmd) => Console WriteLine(cmd Message);  // Fire-and-forget\n// Attributes declare behavior\n[Idempotent]     // Automatic deduplication\n[Transactional]  // Wrap in transaction\n[Logged]         // Structured logging\n`\nObservable by Default\nProblems found in production are 10x more expensive than problems found in development Whizbang includes:\nOpenTelemetry traces for every command, event, and perspective update\nLive dashboard showing message lag, perspective health, and error rates\nDistributed tracing across services and message brokers\nPerformance budgets that alert when receptors exceed latency targets\nObservability is not bolted on—it's built into the core runtime Idempotence Everywhere\nMessages may be delivered more than once Whizbang ensures:\nExactly-once semantics for event handling and perspective updates\nAutomatic deduplication based on message IDs\nOutbox/Inbox pattern for reliable message delivery across service boundaries\nIdempotent perspectives that can safely process the same event multiple times\nYour domain logic never needs to worry about duplicate messages Compile-Time Safety\nCatch errors during build, not at runtime",
        "startIndex": 7204,
        "preview": "INTERMEDIATE tags: [Philosophy, Pure-Functions, Compile-Time-Safety, Side-Effects] description: Pure function example with compile-time verification p..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/philosophy-chunk-5",
        "text": "event handling and perspective updates Automatic deduplication based on message IDs Outbox/Inbox pattern for reliable message delivery across service boundaries Idempotent perspectives that can safely process the same event multiple times Your domain logic never needs to worry about duplicate messages Compile-Time Safety Catch errors during build, not at runtime Through source generators and Roslyn analyzers, Whizbang provides unprecedented compile-time verification:\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [Philosophy, Compile-Time-Safety, Source-Generators, Effect-Tracking]\ndescription: Compile-time safety with pure functions and effect declarations verified by source generators\n---\n[Pure]\npublic class CalculationReceptor : IReceptor<Calculate> {\n    public Result Receive(Calculate cmd) {\n        // ✅ Pure computation allowed\n        var result = cmd A + cmd B;\n        // ❌ Compile error: I/O not allowed in pure function\n        // await database SaveAsync(result);\n        return new Result(result);\n    }\n}\n[Effects(Writes = \"Orders\", Publishes = \"OrderEvents\")]\npublic class OrderReceptor : IReceptor<CreateOrder> {\n    // Source generator verifies declared effects match actual usage\n}\n`\nAOT-Safe and Performance-First\nModern NET demands performance Whizbang achieves both developer experience and runtime performance through:\nSource generation - Zero runtime reflection overhead\nNative AOT - Full trimming and AOT compilation support\nAssembly trimming - Only include what you use\nStruct messages - Stack allocation for small messages\nObject pooling - Automatic pooling of receptors and messages\nSIMD operations - Vectorized operations where applicable\nDeploy as a tiny container or serverless function without compromise Security and Multi-Tenancy First\nSecurity is not an afterthought",
        "startIndex": 9122,
        "preview": "event handling and perspective updates Automatic deduplication based on message IDs Outbox/Inbox pattern for reliable message delivery across service ..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/philosophy-chunk-6",
        "text": "trimming - Only include what you use Struct messages - Stack allocation for small messages Object pooling - Automatic pooling of receptors and messages SIMD operations - Vectorized operations where applicable Deploy as a tiny container or serverless function without compromise Security and Multi-Tenancy First Security is not an afterthought Whizbang provides built-in support for:\nMulti-tenancy - Tenant isolation at the event stream, projection, and command level\nPermission scoping - Fine-grained authorization for commands, queries, and events\nTrusted/untrusted boundaries - Separate handling for internal vs external services\nAudit logging - Track who did what, when, and why\nData encryption - At-rest and in-transit encryption support\nMulti-tenant architecture:\nTenant ID propagated through all message contexts\nTenant-scoped event streams (e g , Tenant-{tenantId}-Order-{orderId})\nTenant-specific projections and read models\nCross-tenant operations prevented by default\nPermission model:\nCommands require explicit permissions (e g , orders:place, inventory:reserve)\nQueries can be scoped to accessible data only\nEvents carry identity context for audit trails\nRoslyn analyzer enforces authorization checks\nService trust boundaries:\nInternal services (trusted) can access raw event streams\nExternal services (untrusted) receive filtered, sanitized events\nAPI gateways enforce authentication and authorization\nService-to-service authentication via mutual TLS or tokens\nOpinionated Recipes, Flexible Foundation\nWhizbang provides opinionated recipes to prevent analysis paralysis:\nStarter templates for common scenarios (web API, worker service, microservice)\nBest practice examples for aggregates, sagas, projections\nConvention-based configuration that \"just works\" out of the box\nBut under the hood, everything is pluggable:\nSwap drivers\nOverride conventions\nCustomize serialization\nExtend the pipeline\nYou're not locked into our opinions if your scenario demands something different Comparison to Existing Tools\nvs Marten + Wolverine (The \"Critter Stack\")\nWhat they are: Marten is a document database and event store for PostgreSQL Wolverine is a messaging and mediator framework",
        "startIndex": 10589,
        "preview": "trimming - Only include what you use Struct messages - Stack allocation for small messages Object pooling - Automatic pooling of receptors and message..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/philosophy-chunk-7",
        "text": "Override conventions Customize serialization Extend the pipeline You're not locked into our opinions if your scenario demands something different Comparison to Existing Tools vs Marten + Wolverine (The \"Critter Stack\") What they are: Marten is a document database and event store for PostgreSQL Wolverine is a messaging and mediator framework Together they form the \"Critter Stack\"—the most mature CQRS/ES stack in NET as of 2025 Strengths:\nBattle-tested in production since 2016\nExcellent PostgreSQL integration with partitioning, snapshotting, and \"Quick Append\"\nFull OpenTelemetry and metrics support\n\"Aggregate handler workflow\" for clean CQRS\nWhizbang Differences:\nMulti-database: Marten is PostgreSQL-only Whizbang supports Postgres, SQL Server, MySQL, Cosmos DB, and SQLite through drivers Unified runtime: Marten + Wolverine are two separate libraries Whizbang is a single, cohesive runtime Domain ownership: Whizbang enforces explicit domain ownership for distributed systems (commands TO owner, events FROM owner) Multi-tenancy first: Built-in tenant isolation at the event stream, projection, and command level Aspire integration: First-class NET Aspire support with one-command local dev setup Lakehouse streaming: Stream events to Delta Lake, Iceberg, or Parquet for analytics Dashboard: Dedicated web dashboard for message journey visualization and control plane When to choose Marten + Wolverine: You're committed to PostgreSQL and want the most mature, proven stack When to choose Whizbang: You need multi-database support, tighter integration, multi-tenancy, or advanced features like lakehouse streaming ---\nvs MediatR\nWhat it is: MediatR is a simple in-process mediator for implementing CQRS in a single application Used by thousands of NET projects Strengths:\nExtremely simple and lightweight\nNo infrastructure dependencies\nPerfect for monolithic applications\nMinimal learning curve\nWhizbang Differences:\nEvent sourcing: MediatR has no event sourcing Whizbang includes full ledger support Perspectives: MediatR has no read model support Whizbang includes perspective engine Distributed messaging: MediatR is in-process only Whizbang scales to microservices",
        "startIndex": 12436,
        "preview": "Override conventions Customize serialization Extend the pipeline You're not locked into our opinions if your scenario demands something different Comp..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/philosophy-chunk-8",
        "text": "Strengths: Extremely simple and lightweight No infrastructure dependencies Perfect for monolithic applications Minimal learning curve Whizbang Differences: Event sourcing: MediatR has no event sourcing Whizbang includes full ledger support Perspectives: MediatR has no read model support Whizbang includes perspective engine Distributed messaging: MediatR is in-process only Whizbang scales to microservices Growth path: With MediatR, scaling to distributed requires a complete rewrite With Whizbang, the same receptor code works at every scale When to choose MediatR: You're building a simple monolith and will never need event sourcing or microservices When to choose Whizbang: You want a growth path from simple to complex without rewrites ---\nvs MassTransit\nWhat it is: MassTransit is a mature distributed messaging framework for NET Supports RabbitMQ, Azure Service Bus, Amazon SQS, and more Open source (Apache 2 0) Strengths:\nMature message routing, retries, and error handling\nExcellent transport abstraction (RabbitMQ, Azure Service Bus, etc )\nSaga support for long-running processes\nFree for production use\nWhizbang Differences:\nEvent sourcing: MassTransit has no event sourcing Whizbang includes ledger Perspectives: MassTransit has no read model support Whizbang includes perspective engine All-in-one: MassTransit focuses on messaging Whizbang integrates messaging + event sourcing + perspectives Event-driven: MassTransit requires a broker even for in-process Whizbang starts as event-driven architecture When to choose MassTransit: You only need messaging and already have event sourcing/projections handled separately When to choose Whizbang: You want a unified platform for CQRS/ES with messaging built-in ---\nvs NServiceBus\nWhat it is: NServiceBus is the enterprise-grade service bus for NET from Particular Software The most feature-rich messaging framework Strengths:\nComprehensive tooling (ServicePulse, ServiceInsight for monitoring)\nEnterprise support and training available\nBattle-tested in large-scale systems\nAdvanced error handling and sagas\nWhizbang Differences:\nLicensing: NServiceBus requires paid license for production Whizbang is open source Event sourcing: NServiceBus has no event sourcing",
        "startIndex": 14294,
        "preview": "Strengths: Extremely simple and lightweight No infrastructure dependencies Perfect for monolithic applications Minimal learning curve Whizbang Differe..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/philosophy-chunk-9",
        "text": "NET from Particular Software The most feature-rich messaging framework Strengths: Comprehensive tooling (ServicePulse, ServiceInsight for monitoring) Enterprise support and training available Battle-tested in large-scale systems Advanced error handling and sagas Whizbang Differences: Licensing: NServiceBus requires paid license for production Whizbang is open source Event sourcing: NServiceBus has no event sourcing Whizbang includes ledger Perspectives: NServiceBus has no read model engine Whizbang includes perspective engine Dashboard: NServiceBus has separate tools (ServicePulse, ServiceInsight) Whizbang has integrated dashboard When to choose NServiceBus: You need enterprise support and are willing to pay for it When to choose Whizbang: You want open-source, all-in-one CQRS/ES with messaging ---\nvs Equinox\nWhat it is: Equinox is an event sourcing library from Jet com (Walmart) Supports CosmosDB, DynamoDB, EventStoreDB, and SqlStreamStore backends F#-first design Strengths:\nPolyglot storage (CosmosDB, DynamoDB, EventStoreDB, etc )\nSophisticated caching strategies\nFunctional programming approach (Ffirst)\nLibrary, not framework (lightweight coupling)\nWhizbang Differences:\nC#-first: Equinox is F#-first Whizbang is designed for Cdevelopers Messaging: Equinox has no built-in messaging Whizbang includes distributed messaging Perspectives: Equinox requires separate Propulsion library Whizbang includes perspective engine Dashboard: Equinox has no dashboard Whizbang includes web dashboard Aspire: Equinox has no Aspire integration Whizbang has first-class Aspire support When to choose Equinox: You're building in Fand want a lightweight library When to choose Whizbang: You're building in Cand want an integrated framework ---\nvs EventStoreDB\nWhat it is: EventStoreDB is a purpose-built event store database The gold standard for event sourcing since 2012 Strengths:\nPurpose-built for event sourcing\nProjections built into the database\nCatchup subscriptions and persistent subscriptions\nMature and proven\nWhizbang Differences:\nDatabase dependency: EventStoreDB is a separate database to run Whizbang works with databases you already have (Postgres, SQL Server, etc ) CQRS framework: EventStoreDB is just storage Whizbang includes dispatcher, messaging, perspectives, and dashboard",
        "startIndex": 15085,
        "preview": "NET from Particular Software The most feature-rich messaging framework Strengths: Comprehensive tooling (ServicePulse, ServiceInsight for monitoring) ..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/philosophy-chunk-10",
        "text": "sourcing Projections built into the database Catchup subscriptions and persistent subscriptions Mature and proven Whizbang Differences: Database dependency: EventStoreDB is a separate database to run Whizbang works with databases you already have (Postgres, SQL Server, etc ) CQRS framework: EventStoreDB is just storage Whizbang includes dispatcher, messaging, perspectives, and dashboard Driver-based: Whizbang isn't locked to one database EventStoreDB is a single product When to choose EventStoreDB: You want the absolute best event store and are willing to run a dedicated database When to choose Whizbang: You want an all-in-one framework using databases you already have",
        "startIndex": 18048,
        "preview": "sourcing Projections built into the database Catchup subscriptions and persistent subscriptions Mature and proven Whizbang Differences: Database depen..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/philosophy-chunk-11",
        "text": "dispatcher, messaging, perspectives, and dashboard Driver-based: Whizbang isn't locked to one database EventStoreDB is a single product When to choose EventStoreDB: You want the absolute best event store and are willing to run a dedicated database When to choose Whizbang: You want an all-in-one framework using databases you already have ---\nSummary Comparison\n| Feature | Whizbang | Marten + Wolverine | MediatR | MassTransit | NServiceBus | Equinox | EventStoreDB |\n|---------|----------|-------------------|---------|-------------|-------------|---------|--------------|\n| Event Sourcing | ✅ Built-in | ✅ Marten | ❌ | ❌ | ❌ | ✅ Library | ✅ Database |\n| Perspectives | ✅ Built-in | ✅ Marten | ❌ | ❌ | ❌ | ⚠️ Propulsion | ✅ Built-in |\n| Messaging | ✅ Built-in | ✅ Wolverine | ❌ | ✅ Core focus | ✅ Core focus | ❌ | ❌ |\n| Event-Driven | ✅ Built-in | ✅ Wolverine | ✅ Core focus | ⚠️ Via broker | ❌ | ❌ | ❌ |\n| Multi-database | ✅ Yes | ❌ Postgres only | N/A | N/A | N/A | ✅ Yes | ❌ Own DB |\n| Dashboard | ✅ Included | ❌ | ❌ | ❌ | ✅ Paid tools | ❌ | ✅ UI |\n| Multi-tenancy | ✅ First-class | ⚠️ Manual | ❌ | ❌ | ❌ | ❌ | ❌ |\n| Aspire | ✅ First-class | ⚠️ Community | ❌ | ⚠️ Community | ❌ | ❌ | ⚠️ Community |\n| License | 🟢 Open source | 🟢 Open source | 🟢 Open source | 🟢 Apache 2 0 | 🔴 Commercial | 🟢 Apache 2",
        "startIndex": 18340,
        "preview": "dispatcher, messaging, perspectives, and dashboard Driver-based: Whizbang isn't locked to one database EventStoreDB is a single product When to choose..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/philosophy-chunk-12",
        "text": "| ❌ | | Aspire | ✅ First-class | ⚠️ Community | ❌ | ⚠️ Community | ❌ | ❌ | ⚠️ Community | | License | 🟢 Open source | 🟢 Open source | 🟢 Open source | 🟢 Apache 2 0 | 🔴 Commercial | 🟢 Apache 2 0 | 🟡 Free/Paid |\n| Cvs F# | C#-first | C#-first | C#-first | C#-first | C#-first | F#-first | Language-agnostic |\nKey Insight: Whizbang is the only library that combines event sourcing, perspectives, messaging, event-driven patterns, multi-tenancy, and dashboard into a single, cohesive runtime with multi-database support Our Stance\nWe believe:\nEvents are more valuable than current state\nDomain ownership prevents distributed system chaos\nPure functions are easier to test and reason about\nObservability must be built in, not bolted on\nAOT and small binaries matter for modern deployments\nDevelopers should never be locked into a specific database or message broker\nSimple scenarios should stay simple; complex scenarios should be possible\nNext Steps\nNow that you understand Whizbang's philosophy and design principles:\nGetting Started - Build your first Whizbang application with a step-by-step tutorial\nPackage Structure - Learn about all available NuGet packages and their dependencies\nCore Concepts - Deep dive into receptors, perspectives, lenses, and events\nWe are building Whizbang to be the pit of success for event-sourced, message-driven systems in NET",
        "startIndex": 19312,
        "preview": "| ❌ | | Aspire | ✅ First-class | ⚠️ Community | ❌ | ⚠️ Community | ❌ | ❌ | ⚠️ Community | | License | 🟢 Open source | 🟢 Open source | 🟢 Open source..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/architecture-design/whizbang-unified-vision",
    "title": "Whizbang Unified Vision",
    "category": "Architecture & Design",
    "url": "/docs/old-v1.0.0.0/architecture-design/whizbang-unified-vision",
    "chunks": [
      {
        "id": "old-v1.0.0.0/architecture-design/whizbang-unified-vision-chunk-0",
        "text": "Whizbang Unified Vision\nOne Runtime Any Mode Every Pattern Whizbang represents a fundamental shift in how we think about messaging, events, and commands in NET Instead of choosing between different libraries for different needs, Whizbang provides one mental model that scales from simple in-process messaging to complex distributed event-sourced systems—without changing your code The Problem We Solve\nToday's NET developers face an impossible choice:\nMediatR for simple in-process messaging\nWolverine for performance and durability  \nMassTransit for distributed systems\nNServiceBus for enterprise features\nCustom solutions for event sourcing\nEach library requires different patterns, different abstractions, and different mental models Migrating between them means rewriting your entire application layer The Whizbang Solution: Progressive Enhancement\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [Progressive-Enhancement, Unified-Model, Configuration]\ndescription: Same handler code works across all modes with progressive enhancement\n---\n// This SAME handler works across ALL modes\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd, IOrderRepository repo) {\n        var order = repo CreateOrder(cmd);\n        return new OrderCreated(order Id, order Total);\n    }\n}\n// Start simple (like MediatR)\nservices AddWhizbang() UseInProcessMode();\n// Add durability (like Wolverine) - SAME HANDLER\nservices AddWhizbang() UseDurableMode();\n// Scale to distributed (like MassTransit) - SAME HANDLER  \nservices AddWhizbang() UseDistributedMode();\n// Enable event sourcing (unique to Whizbang) - SAME HANDLER\nservices AddWhizbang() UseEventSourcedMode();\n`\nCore Philosophy\nOne Mental Model\nWrite your business logic once The same handlers, same patterns, and same abstractions work whether you're building a monolith or a distributed system Convention Over Configuration\nSmart defaults derived from the best practices of all major libraries Return types determine behavior Attributes declare aspects Source generators eliminate boilerplate Aspect-Oriented by Design\nCross-cutting concerns are first-class citizens, not afterthoughts Logging, retry, caching, authorization—all composable through a powerful aspect system Compile-Time Safety\nSource generators verify correctness at build time Pure functions are enforced",
        "startIndex": 0,
        "preview": "Whizbang Unified Vision\nOne Runtime Any Mode Every Pattern Whizbang represents a fundamental shift in how we think about messaging, events, and comman..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/whizbang-unified-vision-chunk-1",
        "text": "best practices of all major libraries Return types determine behavior Attributes declare aspects Source generators eliminate boilerplate Aspect-Oriented by Design Cross-cutting concerns are first-class citizens, not afterthoughts Logging, retry, caching, authorization—all composable through a powerful aspect system Compile-Time Safety Source generators verify correctness at build time Pure functions are enforced Side effects are tracked Mistakes are caught before runtime Performance Without Compromise\nRuntime code generation like Wolverine Zero-allocation patterns Adaptive optimization The convenience of high-level abstractions with the performance of hand-tuned code Learning from the Best\nWhat We Take from Each Library\n| Library | What We Adopt | How We Improve |\n|---------|---------------|----------------|\n| MediatR | Simplicity, pipeline behaviors | Add durability without complexity |\n| Wolverine | Return type semantics, code generation | Extend to distributed scenarios |\n| MassTransit | State machines, routing | Simplify configuration |\n| Brighter | Policy attributes, command processor | Unify with aspects |\n| Rebus | Flexibility, defer patterns | Maintain simplicity at scale |\n| NServiceBus | Saga orchestration, monitoring | Open source with better DX |\nUnique Innovations\nReturn Type Semantics\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Effects, Streaming, Railway-Oriented-Programming]\ndescription: Return type semantics demonstrating different effect patterns\n---\npublic class OrderHandler {\n    // Single return = single effect\n    public OrderCreated Handle(CreateOrder cmd) => \n        new OrderCreated(cmd OrderId);\n    // Tuple return = multiple effects (cascading)\n    public (OrderCreated, ProcessPayment, SendEmail) HandleComplete(CreateOrder cmd) => \n        (new OrderCreated(), new ProcessPayment(), new SendEmail());\n    // Result return = validation with railway-oriented programming\n    public Result<OrderCreated> HandleWithValidation(CreateOrder cmd) =>\n        cmd IsValid() Result Success(new OrderCreated())\n            : Result Failure<OrderCreated>(\"Invalid order\");\n    // IAsyncEnumerable = streaming results\n    public async IAsyncEnumerable<OrderEvent> HandleBatch(ProcessBatch cmd) {\n        foreach (var item in cmd Items) {\n            yield return ProcessItem(item);\n        }\n    }\n    // Void = fire-and-forget\n    public void HandleNotification(NotifyUser cmd) => \n        Console",
        "startIndex": 2393,
        "preview": "best practices of all major libraries Return types determine behavior Attributes declare aspects Source generators eliminate boilerplate Aspect-Orient..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/whizbang-unified-vision-chunk-2",
        "text": "with railway-oriented programming public Result<OrderCreated> HandleWithValidation(CreateOrder cmd) => cmd IsValid() Result Success(new OrderCreated()) : Result Failure<OrderCreated>(\"Invalid order\"); // IAsyncEnumerable = streaming results public async IAsyncEnumerable<OrderEvent> HandleBatch(ProcessBatch cmd) { foreach (var item in cmd Items) { yield return ProcessItem(item); } } // Void = fire-and-forget public void HandleNotification(NotifyUser cmd) => Console WriteLine(\"Notified\");\n}\n`\nAspect-Oriented Programming\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [AOP, Aspects, Source-Generation, Pure-Functions]\ndescription: Aspect-oriented programming with compile-time verification\n---\n[Logged]\n[Timed]\n[Cached(Duration = \"5m\")]\n[Retry(3, Backoff = \"exponential\")]\n[Authorized(Role = \"Admin\")]\npublic class OrderHandler : IHandle<CreateOrder> {\n    [Pure] // Compile-time verification of no side effects\n    public OrderCreated Handle(CreateOrder cmd) {\n        // All aspects automatically applied via source generation\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nPure Functions with Effect Tracking\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [Pure-Functions, Effect-Tracking, Compile-Time-Verification]\ndescription: Pure functions with effect tracking and compile-time enforcement\n---\n[Pure] // Enforced at compile time\npublic OrderCalculated Calculate(Order order) {\n    // ✅ Pure computation allowed\n    return new OrderCalculated(order Items Sum(i => i Price));\n    // ❌ Compile error: I/O not allowed in pure function\n    // await database SaveAsync(order);\n}\n[Effects(Reads = \"Inventory\", Writes = \"Orders\", Publishes = \"OrderEvents\")]\npublic async Task<OrderCreated> Handle(CreateOrder cmd) {\n    // Effects are declared and tracked\n    var inventory = await ReadInventory();\n    var order = await WriteOrder(cmd);\n    await PublishEvent(new OrderCreated());\n    return order;\n}\n`\nCompile-Time Verification\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [Event-Sourcing, Aggregates, Compile-Time-Verification, Pure-Event-Application]\ndescription: Event sourced aggregate with compile-time verification\n---\n[EventSourced]\npublic class Order : Aggregate {\n    [Pure] // Verified: no side effects in event application\n    public void Apply(OrderCreated e) {\n        Id = e OrderId;\n        Total = e Total;\n        // await EmailService Send(); // ❌ Compile error\n    }\n    [Command]\n    public OrderShipped Ship(ShipOrder cmd) {\n        // Business logic with compile-time rule checking\n        if (Status = OrderStatus",
        "startIndex": 4486,
        "preview": "with railway-oriented programming public Result<OrderCreated> HandleWithValidation(CreateOrder cmd) => cmd IsValid() Result Success(new OrderCreated()..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/whizbang-unified-vision-chunk-3",
        "text": "Aggregate { [Pure] // Verified: no side effects in event application public void Apply(OrderCreated e) { Id = e OrderId; Total = e Total; // await EmailService Send(); // ❌ Compile error } [Command] public OrderShipped Ship(ShipOrder cmd) { // Business logic with compile-time rule checking if (Status = OrderStatus Paid) {\n            throw new InvalidOperationException(); // ⚠️ Warning: Consider Result<T>\n        }\n        return new OrderShipped(Id);\n    }\n}\n`\nArchitecture Modes\nMode 1: In-Process (Development/Monolith)\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [Configuration, In-Process-Mode, Development]\ndescription: In-process mode configuration for development and monoliths\n---\nservices AddWhizbang() UseInProcessMode() WithInMemoryStorage();\n`\nZero configuration\nImmediate execution\nPerfect for development\nNo infrastructure needed\nMode 2: Durable (Single Service)\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Configuration, Durable-Mode, Persistence, Outbox-Pattern]\ndescription: Durable mode with PostgreSQL and outbox pattern\n---\nservices AddWhizbang() UseDurableMode() UsePostgreSQL(connectionString) WithOutbox();\n`\nAutomatic persistence\nOutbox pattern\nRetry on failure\nTransaction support\nMode 3: Distributed (Microservices)\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [Configuration, Distributed-Mode, Kafka, Saga-Orchestration, Distributed-Tracing]\ndescription: Distributed mode with Kafka, saga orchestration, and tracing\n---\nservices AddWhizbang() UseDistributedMode() UseKafka(config) WithSagaOrchestration() WithDistributedTracing();\n`\nCross-service messaging\nSaga orchestration\nDistributed tracing\nMultiple transports\nMode 4: Event-Sourced (Event-Driven)\n`csharp\n---\ncategory: Architecture\ndifficulty: ADVANCED\ntags: [Configuration, Event-Sourcing, Event-Store, Projections, Snapshots]\ndescription: Event sourced mode with projections and snapshots\n---\nservices AddWhizbang() UseEventSourcedMode() UseEventStore(config) WithProjections()",
        "startIndex": 6620,
        "preview": "Aggregate { [Pure] // Verified: no side effects in event application public void Apply(OrderCreated e) { Id = e OrderId; Total = e Total; // await Ema..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/whizbang-unified-vision-chunk-4",
        "text": "saga orchestration, and tracing --- services AddWhizbang() UseDistributedMode() UseKafka(config) WithSagaOrchestration() WithDistributedTracing(); ` Cross-service messaging Saga orchestration Distributed tracing Multiple transports Mode 4: Event-Sourced (Event-Driven) `csharp --- category: Architecture difficulty: ADVANCED tags: [Configuration, Event-Sourcing, Event-Store, Projections, Snapshots] description: Event sourced mode with projections and snapshots --- services AddWhizbang() UseEventSourcedMode() UseEventStore(config) WithProjections() WithSnapshots();\n`\nFull event sourcing\nAutomatic projections\nTime travel debugging\nCQRS patterns\nThe Developer Experience\nIDE Integration\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [IDE-Integration, IntelliSense, Developer-Experience, Tooling]\ndescription: IDE integration with IntelliSense and code generation\n---\n// IntelliSense knows about aspects and suggests appropriate ones\n[Wh| // IDE suggests: WhizbangHandler, WhizbangSaga, WhizbangProjection\npublic class OrderHandler {\n    // Type 'Handle' and IDE generates method with aspects\n    public Handle| // IDE template with return type options\n}\n`\nTesting Excellence\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Testing, Aspects, Production-Testing, Verification]\ndescription: Testing with production aspects and comprehensive verification\n---\n[Test]\npublic async Task OrderHandler_CreatesOrder_WithAllAspects() {\n    await Whizbang Test<OrderHandler>() Given(new CreateOrder { }) WithAspects() // Test with production aspects WhenHandled() Then(result => result ShouldBeSuccess()) AndAspect<LoggingAspect>(logs => logs ShouldContain(\"Order created\")) AndAspect<MetricsAspect>(metrics => metrics[\"orders created\"] ShouldBe(1)) AndAspect<CacheAspect>(cache => cache",
        "startIndex": 8395,
        "preview": "saga orchestration, and tracing --- services AddWhizbang() UseDistributedMode() UseKafka(config) WithSagaOrchestration() WithDistributedTracing(); ` C..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/whizbang-unified-vision-chunk-5",
        "text": "[Testing, Aspects, Production-Testing, Verification] description: Testing with production aspects and comprehensive verification --- [Test] public async Task OrderHandler_CreatesOrder_WithAllAspects() { await Whizbang Test<OrderHandler>() Given(new CreateOrder { }) WithAspects() // Test with production aspects WhenHandled() Then(result => result ShouldBeSuccess()) AndAspect<LoggingAspect>(logs => logs ShouldContain(\"Order created\")) AndAspect<MetricsAspect>(metrics => metrics[\"orders created\"] ShouldBe(1)) AndAspect<CacheAspect>(cache => cache ShouldHaveStored(\"order:123\"));\n}\n`\nObservability Built-In\n`csharp\n---\ncategory: Architecture\ndifficulty: INTERMEDIATE\ntags: [Observability, OpenTelemetry, Tracing, Metrics, Logging]\ndescription: Built-in observability with automatic OpenTelemetry integration\n---\n// Automatic OpenTelemetry integration\n[Observed]\npublic class OrderHandler {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Automatically generates:\n        // - Distributed trace spans\n        // - Metrics (count, duration, errors)\n        // - Structured logs\n        // - Health checks\n        return new OrderCreated();\n    }\n}\n`\nMigration Path\nFrom MediatR\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [Migration, MediatR, Comparison, Simplification]\ndescription: Migration from MediatR showing simplified interface\n---\n// Before (MediatR)\npublic class Handler : IRequestHandler<Command, Result> {\n    public Task<Result> Handle(Command request, CancellationToken ct) { }\n}\n// After (Whizbang) - Almost identical public class Handler : IHandle<Command> {\n    public Result Handle(Command cmd) { }  // Simpler, no cancellation token\n}\n`\nFrom MassTransit\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [Migration, MassTransit, Comparison, Context-Via-Aspects]\ndescription: Migration from MassTransit with cleaner interface\n---\n// Before (MassTransit)\npublic class Consumer : IConsumer<Message> {\n    public async Task Consume(ConsumeContext<Message> context) { }\n}\n// After (Whizbang) - Cleaner, same power\npublic class Handler : IHandle<Message> {\n    public Response Handle(Message msg) { }  // Context available via aspects\n}\n`\nFrom Wolverine\n`csharp\n---\ncategory: Architecture\ndifficulty: BEGINNER\ntags: [Migration, Wolverine, Return-Type-Semantics, Comparison]\ndescription: Migration from Wolverine preserving return type semantics\n---\n// Before (Wolverine)\npublic static class Handler {\n    public static Result Handle(Command cmd) { }\n}\n// After (Whizbang) - Same return type semantics",
        "startIndex": 9724,
        "preview": "[Testing, Aspects, Production-Testing, Verification] description: Testing with production aspects and comprehensive verification --- [Test] public asy..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/whizbang-unified-vision-chunk-6",
        "text": "via aspects } ` From Wolverine `csharp --- category: Architecture difficulty: BEGINNER tags: [Migration, Wolverine, Return-Type-Semantics, Comparison] description: Migration from Wolverine preserving return type semantics --- // Before (Wolverine) public static class Handler { public static Result Handle(Command cmd) { } } // After (Whizbang) - Same return type semantics public class Handler : IHandle<Command> {\n    public Result Handle(Command cmd) { }  // Return type still determines behavior\n}\n`\nPerformance Characteristics\n| Aspect | Implementation | Benefit |\n|--------|---------------|---------|\n| Source Generation | Compile-time code generation | Zero reflection overhead |\n| Struct Messages | Value types for small messages | Reduced allocations |\n| Object Pooling | Automatic for handlers and messages | Lower GC pressure |\n| SIMD Operations | Vectorized operations where applicable | Faster processing |\n| Adaptive Optimization | Runtime profiling and recompilation | Improves over time |\nComparison Matrix\n| Feature | Whizbang | MediatR | Wolverine | MassTransit | NServiceBus |\n|---------|----------|---------|-----------|-------------|-------------|\n| In-Process | ✅ | ✅ | ✅ | ✅ | ✅ |\n| Distributed | ✅ | ❌ | ✅ | ✅ | ✅ |\n| Event Sourcing | ✅ Native | ❌ | ⚠️ | ❌ | ⚠️ |\n| AOP | ✅ First-class | ⚠️ | ⚠️ | ⚠️ | ⚠️ |\n| Return Type Semantics | ✅ | ❌ | ✅ | ❌ | ❌ |\n| Source Generation | ✅ | ❌ | ✅ | ❌ | ❌ |\n| Pure Functions | ✅ | ❌ | ❌ | ❌ | ❌ |\n| Effect Tracking | ✅ | ❌ | ❌ | ❌ | ❌ |\n| Progressive Enhancement | ✅ | ❌ | ⚠️ | ⚠️ | ⚠️ |\n| Time Travel Testing | ✅ | ❌ | ❌ | ❌ | ❌ |\nSummary\nWhizbang is not just another messaging library—it's a unified platform that grows with your application",
        "startIndex": 11733,
        "preview": "via aspects } ` From Wolverine `csharp --- category: Architecture difficulty: BEGINNER tags: [Migration, Wolverine, Return-Type-Semantics, Comparison]..."
      },
      {
        "id": "old-v1.0.0.0/architecture-design/whizbang-unified-vision-chunk-7",
        "text": "| ❌ | ❌ | | Progressive Enhancement | ✅ | ❌ | ⚠️ | ⚠️ | ⚠️ | | Time Travel Testing | ✅ | ❌ | ❌ | ❌ | ❌ | Summary Whizbang is not just another messaging library—it's a unified platform that grows with your application Start simple like MediatR, add durability like Wolverine, scale like MassTransit, and leverage event sourcing when you need it—all without changing your handlers or learning new patterns Write once Run anywhere Scale infinitely Next Steps\nSee Aspect-Oriented Programming for the AOP system\nLearn about Return Type Semantics \nExplore Progressive Enhancement\nRead the Getting Started guide",
        "startIndex": 13066,
        "preview": "| ❌ | ❌ | | Progressive Enhancement | ✅ | ❌ | ⚠️ | ⚠️ | ⚠️ | | Time Travel Testing | ✅ | ❌ | ❌ | ❌ | ❌ | Summary Whizbang is not just another messagin..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/commands/command-handling",
    "title": "Command Handling",
    "category": "Commands",
    "url": "/docs/old-v1.0.0.0/commands/command-handling",
    "chunks": [
      {
        "id": "old-v1.0.0.0/commands/command-handling-chunk-0",
        "text": "Command Handling\nCommands represent intent or actions in your system Command handlers contain business logic, validate commands, apply business rules, and emit events to record what happened CRITICAL: Events Can ONLY Be Emitted via Command Handling\nEvents are the result of command processing - they cannot be created directly You must send a command to emit an event `mermaid\nsequenceDiagram\n    participant User\n    participant API as API/Service\n    participant Handler as Command Handler\n    participant Context as CommandContext\n    participant EventStore as Event Store\n    participant Projection as Projections\n    User->>API: Send Command<br/>(PlaceOrder)\n    API->>Handler: Handle(command, context)\n    Note over Handler: ✅ Validate command<br/>✅ Apply business rules<br/>✅ Make decisions\n    Handler->>Context: EmitEvent(OrderPlaced)<br/>⚠️ ONLY way to create events\n    Context->>Context: Populate EventContext<br/>(user, tenant, timestamp)\n    Context->>EventStore: Append event\n    EventStore-->>Context: Event persisted\n    Context-->>Handler: Event emitted\n    Handler->>Context: Send(ReserveInventory)<br/>✅ Emit follow-up commands\n    Context->>API: Route command\n    Handler-->>API: Return event\n    API-->>User: Success\n    EventStore->>Projection: Notify subscribers\n    Note over Projection: ✅ Pure transformation<br/>❌ NO event emission\n`\nThis constraint ensures:\nSingle Source of Truth: All events originate from command handling - clear causation\nAuditability: Every event has a corresponding command that caused it\nAuthorization: Commands are the authorization boundary - validate before creating events\nBusiness Logic Encapsulation: Events are created only after business rules pass\nTransaction Boundary: Command handling is the transaction boundary for event emission\nEvent Context: CommandContext automatically populates EventContext metadata (user, tenant, etc )\nCommandContext Structure\n`csharp{\ntitle: \"CommandContext Structure\"\ndescription: \"Core structure for command handling context with event emission and security\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"Context\", \"Security\", \"Events\"]\nfilename: \"CommandContext cs\"\nusingStatements: [\"System\", \"System Threading",
        "startIndex": 0,
        "preview": "Command Handling\nCommands represent intent or actions in your system Command handlers contain business logic, validate commands, apply business rules,..."
      },
      {
        "id": "old-v1.0.0.0/commands/command-handling-chunk-1",
        "text": "for event emission Event Context: CommandContext automatically populates EventContext metadata (user, tenant, etc ) CommandContext Structure `csharp{ title: \"CommandContext Structure\" description: \"Core structure for command handling context with event emission and security\" framework: \"NET8\" category: \"Commands\" difficulty: \"INTERMEDIATE\" tags: [\"Commands\", \"Context\", \"Security\", \"Events\"] filename: \"CommandContext cs\" usingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\npublic class CommandContext {\n    // Command metadata\n    public CommandMetadata Command { get; init; }\n    // Security context (from command initiator)\n    public SecurityContext Security { get; init; }\n    // Emit events - ONLY way to create events\n    public TEvent EmitEvent<TEvent>(TEvent @event) where TEvent : class;\n    // Emit follow-up commands\n    public Task Send<TCommand>(TCommand command, CancellationToken ct = default) where TCommand : class;\n    // Access to stores for reading (not writing - use events for that)\n    public IEventStore EventStore { get; init; }\n}\npublic class CommandMetadata {\n    public Guid CommandId { get; init; }\n    public string CommandType { get; init; }\n    public DateTime ReceivedAt { get; init; }\n    public Guid CorrelationId { get; init; }\n}\n`\nBasic Command Handler\n`csharp{\ntitle: \"Basic Command Handler with Event Emission\"\ndescription: \"Command handler that validates, applies business logic, and emits events\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"Command Handlers\", \"Events\", \"Business Logic\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n// ✅ CORRECT: Command handler contains business logic\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderPlaced> {\n    public async Task<OrderPlaced> Handle(\n        PlaceOrder command,\n        CommandContext context,  // ✅ Context for emitting events and commands\n        CancellationToken ct) {\n        // ✅ Business logic happens HERE\n        // - Validate the order\n        // - Check inventory\n        // - Calculate totals\n        // - Apply business rules\n        // - Decide if order should be marked as expired\n        var expiresAt = DateTime UtcNow",
        "startIndex": 2250,
        "preview": "for event emission Event Context: CommandContext automatically populates EventContext metadata (user, tenant, etc ) CommandContext Structure `csharp{ ..."
      },
      {
        "id": "old-v1.0.0.0/commands/command-handling-chunk-2",
        "text": "// ✅ Context for emitting events and commands CancellationToken ct) { // ✅ Business logic happens HERE // - Validate the order // - Check inventory // - Calculate totals // - Apply business rules // - Decide if order should be marked as expired var expiresAt = DateTime UtcNow AddDays(90);  // ✅ Business decision\n        var isExpired = false;  // ✅ Business decision\n        var status = \"Placed\";   // ✅ Business decision\n        // ✅ Emit event via CommandContext - the ONLY way to create events\n        var @event = context EmitEvent(new OrderPlaced {\n            OrderId = command OrderId,\n            CustomerId = command CustomerId,\n            Total = command Total,\n            ExpiresAt = expiresAt,      // ✅ Set by handler\n            IsExpired = isExpired,       // ✅ Set by handler\n            Status = status              // ✅ Set by handler\n        });\n        return @event;\n    }\n}\n// ✅ CORRECT: Command is a POCO (Plain Old CLR Object)\npublic record PlaceOrder {\n    public Guid OrderId { get; init; }\n    public Guid CustomerId { get; init; }\n    public decimal Total { get; init; }\n    public List<OrderItem> Items { get; init; }\n}\n// ✅ CORRECT: Event is a POCO - describes what happened\npublic record OrderPlaced {\n    public Guid OrderId { get; init; }\n    public Guid CustomerId { get; init; }\n    public decimal Total { get; init; }\n    public DateTime ExpiresAt { get; init; }     // ✅ Data only (set by handler)\n    public bool IsExpired { get; init; }         // ✅ Data only (set by handler)\n    public string Status { get; init; }          // ✅ Data only (set by handler)\n    // ❌ NO business logic methods like:\n    // public bool ShouldExpire() => DateTime",
        "startIndex": 4150,
        "preview": "// ✅ Context for emitting events and commands CancellationToken ct) { // ✅ Business logic happens HERE // - Validate the order // - Check inventory //..."
      },
      {
        "id": "old-v1.0.0.0/commands/command-handling-chunk-3",
        "text": "init; } // ✅ Data only (set by handler) public bool IsExpired { get; init; } // ✅ Data only (set by handler) public string Status { get; init; } // ✅ Data only (set by handler) // ❌ NO business logic methods like: // public bool ShouldExpire() => DateTime UtcNow > ExpiresAt;\n    // Events are immutable data - handlers make decisions, events record them\n}\npublic record OrderItem {\n    public Guid ProductId { get; init; }\n    public int Quantity { get; init; }\n}\n`\nWhat You CAN and CANNOT Do\n✅ In Command Handlers (Business Logic Layer)\n`csharp{\ntitle: \"Allowed Operations in Command Handlers\"\ndescription: \"Examples of what you can do within command handlers for business logic\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"Business Logic\", \"Best Practices\"]\nfilename: \"CommandHandlerOperations cs\"\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\n// ✅ CAN use DateTime UtcNow for business decisions\nvar expiresAt = DateTime UtcNow AddDays(90);\n// ✅ CAN use Random or Guid NewGuid()\nvar confirmationCode = Random Shared Next(100000, 999999);\n// ✅ CAN call external APIs\nvar customerData = await _customerService GetCustomerAsync(command CustomerId, ct);\n// ✅ CAN read from databases\nvar product = await _productRepository GetAsync(command ProductId, ct);\n// ✅ CAN perform calculations and validations\nif (command Total <= 0) {\n    throw new InvalidOperationException(\"Order total must be positive\");\n}\n// ✅ CAN make business decisions\nvar needsApproval = command Total > 10000;\nvar discount = customer IsPremium 0 10m : 0;\n// ✅ CAN emit events via CommandContext\nvar @event = context EmitEvent(new OrderPlaced { });\n// ✅ CAN emit follow-up commands via CommandContext\nawait context Send(new ReserveInventory {",
        "startIndex": 5562,
        "preview": "init; } // ✅ Data only (set by handler) public bool IsExpired { get; init; } // ✅ Data only (set by handler) public string Status { get; init; } // ✅ ..."
      },
      {
        "id": "old-v1.0.0.0/commands/command-handling-chunk-4",
        "text": "// ✅ CAN make business decisions var needsApproval = command Total > 10000; var discount = customer IsPremium 0 10m : 0; // ✅ CAN emit events via CommandContext var @event = context EmitEvent(new OrderPlaced { }); // ✅ CAN emit follow-up commands via CommandContext await context Send(new ReserveInventory { }, ct);\n`\n❌ Outside Command Handlers\n`csharp{\ntitle: \"Forbidden Operations Outside Command Handlers\"\ndescription: \"Examples of what you cannot do outside of command handling context\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"Anti-patterns\", \"Best Practices\", \"Events\"]\nfilename: \"ForbiddenOperations cs\"\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\n// ❌ CANNOT emit events directly - no CommandContext\npublic class SomeService {\n    private readonly IEventStore _eventStore;\n    public async Task DoSomething() {\n        // ❌ FORBIDDEN: Cannot create events outside of command handling\n        var @event = new OrderPlaced { };\n        await _eventStore AppendAsync(@event);  // 💥 Compile error - not allowed // ✅ CORRECT: Must send a command instead\n        await _whizbang Send(new PlaceOrder { });\n        // The command handler will emit the event via CommandContext\n    }\n}\n// ❌ CANNOT emit events from projections\n[WhizbangProjection]\npublic class BadProjection {\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        CancellationToken ct) {\n        // ❌ FORBIDDEN: Projections cannot emit events\n        // No CommandContext available - projections are read-side only\n        var newEvent = new OrderProcessed { };  // 💥 Cannot emit\n        // ✅ CORRECT: If you need to trigger something, emit a command\n        await _whizbang Send(new ProcessOrder { });\n        // The command handler will emit events\n    }\n}\n`\nCommand Emission (Sagas and Process Managers)\nHandlers can emit follow-up commands to coordinate workflows:\n`csharp{\ntitle: \"Command Emission in Handlers\"\ndescription: \"Emitting follow-up commands for workflow coordination\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"Sagas\", \"Workflows\", \"Process Managers\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading",
        "startIndex": 7095,
        "preview": "// ✅ CAN make business decisions var needsApproval = command Total > 10000; var discount = customer IsPremium 0 10m : 0; // ✅ CAN emit events via Comm..."
      },
      {
        "id": "old-v1.0.0.0/commands/command-handling-chunk-5",
        "text": "} ` Command Emission (Sagas and Process Managers) Handlers can emit follow-up commands to coordinate workflows: `csharp{ title: \"Command Emission in Handlers\" description: \"Emitting follow-up commands for workflow coordination\" framework: \"NET8\" category: \"Commands\" difficulty: \"INTERMEDIATE\" tags: [\"Commands\", \"Sagas\", \"Workflows\", \"Process Managers\"] nugetPackages: [\"Whizbang Core\"] usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n// Command handler emits both events and commands\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderPlaced> {\n    public async Task<OrderPlaced> Handle(\n        PlaceOrder command,\n        CommandContext context,\n        CancellationToken ct) {\n        // Business logic\n        var expiresAt = DateTime UtcNow AddDays(90);\n        // ✅ Emit event via CommandContext\n        var @event = context EmitEvent(new OrderPlaced {\n            OrderId = command OrderId,\n            CustomerId = command CustomerId,\n            Total = command Total,\n            ExpiresAt = expiresAt\n        });\n        // ✅ Emit follow-up commands to coordinate workflow\n        await context Send(new ReserveInventory {\n            OrderId = command OrderId,\n            Items = command Items\n        }, ct);\n        await context Send(new NotifyCustomer {\n            CustomerId = command CustomerId,\n            Message = \"Your order has been placed\"\n        }, ct);\n        return @event;\n    }\n}\n// Saga pattern - event handlers emit commands to orchestrate workflow\npublic class OrderSagaHandler : IEventHandler<OrderPlaced> {\n    private readonly IWhizbang _whizbang;\n    public async Task Handle(OrderPlaced @event, CancellationToken ct) {\n        // ✅ Event handler can emit commands (but NOT events)\n        // Step 1: Reserve inventory\n        await _whizbang Send(new ReserveInventory {\n            OrderId = @event OrderId,\n            Items = @event Items\n        }, ct);\n        // Step 2: Authorize payment\n        await _whizbang Send(new AuthorizePayment {\n            OrderId = @event OrderId,\n            Amount = @event Total,\n            CustomerId = @event CustomerId\n        }, ct);\n    }\n}\n`\nAggregate Command Handling\nAggregates can also emit events via CommandContext:\n`csharp{\ntitle: \"Aggregate Command Handling\"\ndescription: \"Using aggregates to handle commands and emit events\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"ADVANCED\"\ntags: [\"Aggregates\", \"Commands\", \"Events\", \"DDD\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang",
        "startIndex": 3475,
        "preview": "} ` Command Emission (Sagas and Process Managers) Handlers can emit follow-up commands to coordinate workflows: `csharp{ title: \"Command Emission in H..."
      },
      {
        "id": "old-v1.0.0.0/commands/command-handling-chunk-6",
        "text": "@event Total, CustomerId = @event CustomerId }, ct); } } ` Aggregate Command Handling Aggregates can also emit events via CommandContext: `csharp{ title: \"Aggregate Command Handling\" description: \"Using aggregates to handle commands and emit events\" framework: \"NET8\" category: \"Commands\" difficulty: \"ADVANCED\" tags: [\"Aggregates\", \"Commands\", \"Events\", \"DDD\"] nugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\n// Aggregate can emit events via CommandContext\npublic class OrderAggregate : Aggregate {\n    private Guid _orderId;\n    private OrderStatus _status;\n    private List<OrderItem> _items = new();\n    public async Task PlaceOrder(PlaceOrder command, CommandContext context) {\n        // Apply business rules\n        if (_status = OrderStatus None) {\n            throw new InvalidOperationException(\"Order already placed\");\n        }\n        var expiresAt = DateTime UtcNow AddDays(90);\n        // ✅ Emit event via CommandContext\n        var @event = context EmitEvent(new OrderPlaced {\n            OrderId = command OrderId,\n            CustomerId = command CustomerId,\n            Total = command Total,\n            ExpiresAt = expiresAt\n        });\n        // Apply event to aggregate state\n        Apply(@event);\n        // ✅ Aggregate can also emit follow-up commands via CommandContext\n        await context Send(new SendOrderConfirmationEmail {\n            OrderId = command OrderId,\n            CustomerEmail = command CustomerEmail\n        });\n    }\n    public async Task ShipOrder(ShipOrder command, CommandContext context) {\n        // Validate state\n        if (_status = OrderStatus Placed) {\n            throw new InvalidOperationException(\"Order cannot be shipped in current state\");\n        }\n        // ✅ Emit event via CommandContext\n        var @event = context EmitEvent(new OrderShipped {\n            OrderId = command OrderId,\n            TrackingNumber = command TrackingNumber\n        });\n        Apply(@event);\n        // ✅ Emit follow-up command\n        await context Send(new NotifyCustomerOfShipment {\n            OrderId = command OrderId,\n            TrackingNumber = command TrackingNumber\n        });\n    }\n    // Event handlers update aggregate state\n    private void Apply(OrderPlaced @event) {\n        _orderId = @event OrderId;\n        _status = OrderStatus Placed;\n    }\n    private void Apply(OrderShipped @event) {\n        _status = OrderStatus",
        "startIndex": 11262,
        "preview": "@event Total, CustomerId = @event CustomerId }, ct); } } ` Aggregate Command Handling Aggregates can also emit events via CommandContext: `csharp{ tit..."
      },
      {
        "id": "old-v1.0.0.0/commands/command-handling-chunk-7",
        "text": "}); Apply(@event); // ✅ Emit follow-up command await context Send(new NotifyCustomerOfShipment { OrderId = command OrderId, TrackingNumber = command TrackingNumber }); } // Event handlers update aggregate state private void Apply(OrderPlaced @event) { _orderId = @event OrderId; _status = OrderStatus Placed; } private void Apply(OrderShipped @event) { _status = OrderStatus Shipped;\n    }\n}\npublic enum OrderStatus {\n    None,\n    Placed,\n    Shipped,\n    Delivered,\n    Cancelled\n}\n`\nUse Cases for Command Emission\nSagas / Process Managers: Orchestrate multi-step workflows across aggregates/services\nCommand Chaining: Break complex operations into smaller, coordinated commands\nSide Effects: Trigger notifications, emails, integrations\nCompensating Actions: Send rollback commands if a step fails\nDistributed Transactions: Coordinate actions across multiple bounded contexts\nWorkflow Automation: Trigger next steps in business processes\nSaga Workflow Example\n`mermaid\nsequenceDiagram\n    participant User\n    participant OrderService\n    participant OrderSaga\n    participant InventoryService\n    participant PaymentService\n    participant ShippingService\n    User->>OrderService: PlaceOrder Command\n    OrderService->>OrderService: Validate & Emit OrderPlaced Event\n    OrderService-->>User: Order Created\n    OrderService->>OrderSaga: OrderPlaced Event\n    Note over OrderSaga: Saga orchestrates<br/>multi-step workflow\n    OrderSaga->>InventoryService: ReserveInventory Command\n    InventoryService->>InventoryService: Reserve & Emit InventoryReserved\n    InventoryService-->>OrderSaga: Success\n    OrderSaga->>PaymentService: AuthorizePayment Command\n    PaymentService->>PaymentService: Authorize & Emit PaymentAuthorized\n    PaymentService-->>OrderSaga: Success\n    OrderSaga->>ShippingService: ScheduleShipment Command\n    ShippingService->>ShippingService: Schedule & Emit ShipmentScheduled\n    ShippingService-->>OrderSaga: Success\n    Note over OrderSaga: Workflow complete <br/>All steps succeeded\n    alt Payment Fails\n        PaymentService-->>OrderSaga: Payment Failed\n        OrderSaga->>InventoryService: ReleaseInventory Command\n        Note over OrderSaga: Compensating action<br/>rollback inventory\n    end\n`\nThe Three-Layer Architecture\n`mermaid\ngraph TB\n    subgraph BusinessLogic[\"Command Handler / Aggregate (Business Logic Layer)\"]\n        BL1[\"✅ Validates commands\"]\n        BL2[\"✅ Applies business rules\"]\n        BL3[\"✅ Makes decisions\"]\n        BL4[\"✅ Creates event POCOs with results\"]\n        BL5[\"✅ CAN emit commands (sagas)\"]\n        BL6[\"✅ CAN use DateTime UtcNow, Random, APIs\"]\n    end\n    subgraph DataLayer[\"Data Layer (POCOs - No Logic)\"]\n        Event[\"Event<br/>- Properties only<br/>- NO methods<br/>- Describes what happened\"]\n        Command[\"Command<br/>- Properties only<br/>- NO methods<br/>- Describes intent\"]\n    end\n    subgraph ReadModel[\"Projection (Read Model Layer)\"]\n        P1[\"✅ Pure transformation of event data\"]\n        P2[\"❌ NO business logic\"]\n        P3[\"❌ NO DateTime",
        "startIndex": 13446,
        "preview": "}); Apply(@event); // ✅ Emit follow-up command await context Send(new NotifyCustomerOfShipment { OrderId = command OrderId, TrackingNumber = command T..."
      },
      {
        "id": "old-v1.0.0.0/commands/command-handling-chunk-8",
        "text": "(sagas)\"] BL6[\"✅ CAN use DateTime UtcNow, Random, APIs\"] end subgraph DataLayer[\"Data Layer (POCOs - No Logic)\"] Event[\"Event<br/>- Properties only<br/>- NO methods<br/>- Describes what happened\"] Command[\"Command<br/>- Properties only<br/>- NO methods<br/>- Describes intent\"] end subgraph ReadModel[\"Projection (Read Model Layer)\"] P1[\"✅ Pure transformation of event data\"] P2[\"❌ NO business logic\"] P3[\"❌ NO DateTime UtcNow, Random, APIs\"]\n        P4[\"✅ ONLY event data or EventContext\"]\n        P5[\"✅ Deterministic and replayable\"]\n    end\n    BusinessLogic -->|Emits Events| Event\n    BusinessLogic -->|Emits Commands| Command\n    Event -->|Consumed by| ReadModel\n    Command -->|Handled by| BusinessLogic\n    style BusinessLogic fill:#d4edda,stroke:#28a745,stroke-width:2px\n    style DataLayer fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    style ReadModel fill:#cce5ff,stroke:#004085,stroke-width:2px\n    style Event fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    style Command fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n`\nCommands vs Events vs Queries\n| Aspect | Command | Event | Query |\n|--------|---------|-------|-------|\n| Purpose | Express intent | Record what happened | Retrieve data |\n| Tense | Imperative (PlaceOrder) | Past tense (OrderPlaced) | Question (GetOrder) |\n| Business Logic | Handler contains logic | NO logic - POCO | NO logic - handler reads data |\n| Side Effects | YES - creates events | NO - immutable data | NO - read-only |\n| Can Fail | YES - validation errors | NO - fact that happened | NO - returns null/empty |\n| Emit Events | YES - via CommandContext | N/A | NO |\n| Emit Commands | YES - via CommandContext | Via event handlers | NO |\nValidation and Error Handling\n`csharp{\ntitle: \"Command Validation and Error Handling\"\ndescription: \"Proper validation and error handling in command handlers\"\nframework: \"NET8\"\ncategory: \"Commands\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Validation\", \"Error Handling\", \"Commands\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading",
        "startIndex": 16106,
        "preview": "(sagas)\"] BL6[\"✅ CAN use DateTime UtcNow, Random, APIs\"] end subgraph DataLayer[\"Data Layer (POCOs - No Logic)\"] Event[\"Event<br/>- Properties only<br..."
      },
      {
        "id": "old-v1.0.0.0/commands/command-handling-chunk-9",
        "text": "Error Handling `csharp{ title: \"Command Validation and Error Handling\" description: \"Proper validation and error handling in command handlers\" framework: \"NET8\" category: \"Commands\" difficulty: \"INTERMEDIATE\" tags: [\"Validation\", \"Error Handling\", \"Commands\"] nugetPackages: [\"Whizbang Core\"] usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading; using System Threading Tasks;\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderPlaced> {\n    private readonly IProductRepository _products;\n    private readonly ICustomerRepository _customers;\n    public PlaceOrderHandler(IProductRepository products, ICustomerRepository customers) {\n        _products = products;\n        _customers = customers;\n    }\n    public async Task<OrderPlaced> Handle(\n        PlaceOrder command,\n        CommandContext context,\n        CancellationToken ct) {\n        // ✅ Validate command data\n        if (command OrderId == Guid Empty) {\n            throw new ArgumentException(\"OrderId is required\", nameof(command OrderId));\n        }\n        if (command Items == null || command Items Count == 0) {\n            throw new ArgumentException(\"Order must have at least one item\", nameof(command Items));\n        }\n        // ✅ Validate business rules\n        var customer = await _customers GetAsync(command CustomerId, ct);\n        if (customer == null) {\n            throw new InvalidOperationException($\"Customer {command CustomerId} not found\");\n        }\n        if ( customer IsActive) {\n            throw new InvalidOperationException(\"Cannot place order for inactive customer\");\n        }\n        // ✅ Check availability\n        foreach (var item in command Items) {\n            var product = await _products GetAsync(item ProductId, ct);\n            if (product == null) {\n                throw new InvalidOperationException($\"Product {item ProductId} not found\");\n            }\n            if (product Stock < item Quantity) {\n                throw new InvalidOperationException(\n                    $\"Insufficient stock for product {product Name} \" +\n                    $\"Available: {product Stock}, Requested: {item Quantity}\");\n            }\n        }\n        // ✅ Calculate totals\n        decimal total = 0;\n        foreach (var item in command Items) {\n            var product = await _products GetAsync(item ProductId, ct);\n            total += product Price * item Quantity;\n        }\n        // ✅ Apply business rules\n        var discount = customer IsPremium total * 0 10m : 0;\n        var finalTotal = total - discount;\n        // ✅ Emit event with all business decisions made\n        var @event = context",
        "startIndex": 17835,
        "preview": "Error Handling `csharp{ title: \"Command Validation and Error Handling\" description: \"Proper validation and error handling in command handlers\" framewo..."
      },
      {
        "id": "old-v1.0.0.0/commands/command-handling-chunk-10",
        "text": "product = await _products GetAsync(item ProductId, ct); total += product Price * item Quantity; } // ✅ Apply business rules var discount = customer IsPremium total * 0 10m : 0; var finalTotal = total - discount; // ✅ Emit event with all business decisions made var @event = context EmitEvent(new OrderPlaced {\n            OrderId = command OrderId,\n            CustomerId = command CustomerId,\n            Total = finalTotal,\n            Discount = discount,\n            ExpiresAt = DateTime UtcNow AddDays(90),\n            IsExpired = false,\n            Status = \"Placed\"\n        });\n        return @event;\n    }\n}\n`\nSummary\nEvents can ONLY be emitted via CommandContext during command handling\nCommand handlers contain business logic - validation, rules, decisions\nEvents are POCOs describing what happened (no logic)\nCommands are POCOs describing intent (no logic)\nHandlers can emit follow-up commands for sagas and workflows\nCommandContext provides authorization boundary - events created after validation\nProjections cannot emit events - they're read-side only\nNext Steps\nCommand Validation - Advanced validation patterns\nSagas and Process Managers - Workflow orchestration\nAggregates - Domain-driven design with aggregates\nProjection Purity - Maintaining pure projections",
        "startIndex": 4402,
        "preview": "product = await _products GetAsync(item ProductId, ct); total += product Price * item Quantity; } // ✅ Apply business rules var discount = customer Is..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/contributors/coding-standards",
    "title": "Coding Standards",
    "category": "Contributors",
    "url": "/docs/old-v1.0.0.0/contributors/coding-standards",
    "chunks": [
      {
        "id": "old-v1.0.0.0/contributors/coding-standards-chunk-0",
        "text": "Coding Standards\nWhizbang follows strict coding standards to ensure consistency, maintainability, and AOT compatibility EditorConfig\nAll code MUST follow the editorconfig rules in the repository Documentation examples follow CODE_SAMPLES editorconfig CVersion\nMinimum: C12\nTarget: Latest stable Cversion\nUse modern language features (pattern matching, records, file-scoped namespaces, etc )\nBrace Style\nUse K&R/Egyptian braces (opening brace on same line):\n`csharp{\ntitle: \"K&R/Egyptian Brace Style\"\ndescription: \"Correct vs incorrect brace placement\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Code Style\", \"Braces\"]\nnugetPackages: []\nusingStatements: []\nshowLineNumbers: false\n}\n// ✅ CORRECT - K&R/Egyptian style\npublic class Order {\n    public void Ship() {\n        if (Status == OrderStatus Placed) {\n            Status = OrderStatus Shipped;\n        }\n    }\n}\n// ❌ WRONG - Allman style\npublic class Order\n{\n    public void Ship()\n    {\n        if (Status == OrderStatus Placed)\n        {\n            Status = OrderStatus",
        "startIndex": 0,
        "preview": "Coding Standards\nWhizbang follows strict coding standards to ensure consistency, maintainability, and AOT compatibility EditorConfig\nAll code MUST fol..."
      },
      {
        "id": "old-v1.0.0.0/contributors/coding-standards-chunk-1",
        "text": "// ✅ CORRECT - K&R/Egyptian style public class Order { public void Ship() { if (Status == OrderStatus Placed) { Status = OrderStatus Shipped; } } } // ❌ WRONG - Allman style public class Order { public void Ship() { if (Status == OrderStatus Placed) { Status = OrderStatus Shipped;\n        }\n    }\n}\n`\nNaming Conventions\nTypes\nPascalCase for classes, interfaces, records, enums, structs:\n`csharp{\ntitle: \"Type Naming Conventions\"\ndescription: \"PascalCase for types with I-prefix for interfaces\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Naming\", \"Types\"]\nnugetPackages: []\nusingStatements: [\"System\"]\nshowLineNumbers: false\n}\npublic class OrderProcessor { }\npublic interface IOrderRepository { }\npublic record OrderPlaced(Guid OrderId);\npublic enum OrderStatus { Placed, Shipped }\n`\nI-prefix for interfaces:\n`csharp{\ntitle: \"Interface Naming\"\ndescription: \"I-prefix for all interfaces\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Naming\", \"Interfaces\"]\nnugetPackages: []\nusingStatements: []\nshowLineNumbers: false\n}\npublic interface IEventStore { }\npublic interface IProjection { }\n`\nMethods and Properties\nPascalCase:\n`csharp{\ntitle: \"Method and Property Naming\"\ndescription: \"PascalCase for public methods and properties\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Naming\", \"Methods\", \"Properties\"]\nnugetPackages: []\nusingStatements: [\"System\"]\nshowLineNumbers: false\n}\npublic class Order {\n    public Guid Id { get; private set; }\n    public decimal Total { get; private set; }\n    public void Ship(string trackingNumber) {\n        // }\n}\n`\nAsync suffix for async methods:\n`csharp{\ntitle: \"Async Method Naming\"\ndescription: \"Async suffix for asynchronous methods\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Naming\", \"Async\", \"Methods\"]\nnugetPackages: []\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: false\n}\npublic async Task<Order> GetOrderAsync(Guid orderId) {\n    // }\npublic async Task SaveAsync(Order order) {\n    //",
        "startIndex": 1061,
        "preview": "// ✅ CORRECT - K&R/Egyptian style public class Order { public void Ship() { if (Status == OrderStatus Placed) { Status = OrderStatus Shipped; } } } //..."
      },
      {
        "id": "old-v1.0.0.0/contributors/coding-standards-chunk-2",
        "text": "suffix for async methods: `csharp{ title: \"Async Method Naming\" description: \"Async suffix for asynchronous methods\" framework: \"NET8\" category: \"Contributors\" difficulty: \"BEGINNER\" tags: [\"Naming\", \"Async\", \"Methods\"] nugetPackages: [] usingStatements: [\"System\", \"System Threading Tasks\"] showLineNumbers: false } public async Task<Order> GetOrderAsync(Guid orderId) { // } public async Task SaveAsync(Order order) { // }\n`\nParameters and Local Variables\ncamelCase:\n`csharp{\ntitle: \"Parameter and Variable Naming\"\ndescription: \"camelCase for parameters and local variables\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Naming\", \"Variables\", \"Parameters\"]\nnugetPackages: []\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq\"]\nshowLineNumbers: false\n}\npublic void ProcessOrder(Guid orderId, List<OrderItem> items) {\n    var total = items Sum(i => i Price * i Quantity);\n    var customerId = GetCustomerId(orderId);\n}\n`\nFields\n_camelCase (underscore prefix) for private fields:\n`csharp{\ntitle: \"Field Naming\"\ndescription: \"_camelCase with underscore prefix for private fields\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Naming\", \"Fields\"]\nnugetPackages: []\nusingStatements: [\"Microsoft Extensions Logging\"]\nshowLineNumbers: false\n}\npublic class OrderProcessor {\n    private readonly IOrderRepository _repository;\n    private readonly ILogger _logger;\n    public OrderProcessor(IOrderRepository repository, ILogger logger) {\n        _repository = repository;\n        _logger = logger;\n    }\n}\n`\nConstants\nALL_CAPS with underscores:\n`csharp{\ntitle: \"Constant Naming\"\ndescription: \"ALL_CAPS with underscores for constants\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Naming\", \"Constants\"]\nnugetPackages: []\nusingStatements: []\nshowLineNumbers: false\n}\npublic class EventStoreConstants {\n    public const string DEFAULT_STREAM_PREFIX = \"whizbang-\";\n    public const int MAX_BATCH_SIZE = 1000;\n}\n`\nvar Keyword\nAlways use var for local variables when the type is obvious:\n`csharp{\ntitle: \"var Keyword Usage\"\ndescription: \"Always use var when type is obvious\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"var\", \"Code Style\"]\nnugetPackages: [\"Microsoft Extensions DependencyInjection\"]\nusingStatements: [\"System Linq\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT\nvar order = new Order(customerId, items);\nvar total = items Sum(i => i Price);\nvar repository = serviceProvider",
        "startIndex": 2878,
        "preview": "suffix for async methods: `csharp{ title: \"Async Method Naming\" description: \"Async suffix for asynchronous methods\" framework: \"NET8\" category: \"Cont..."
      },
      {
        "id": "old-v1.0.0.0/contributors/coding-standards-chunk-3",
        "text": "use var when type is obvious\" framework: \"NET8\" category: \"Contributors\" difficulty: \"BEGINNER\" tags: [\"var\", \"Code Style\"] nugetPackages: [\"Microsoft Extensions DependencyInjection\"] usingStatements: [\"System Linq\", \"Microsoft Extensions DependencyInjection\"] showLineNumbers: false } // ✅ CORRECT var order = new Order(customerId, items); var total = items Sum(i => i Price); var repository = serviceProvider GetRequiredService<IOrderRepository>();\n// ❌ WRONG\nOrder order = new Order(customerId, items);\ndecimal total = items Sum(i => i Price);\nIOrderRepository repository = serviceProvider GetRequiredService<IOrderRepository>();\n`\nException: Use explicit type when it aids clarity:\n`csharp{\ntitle: \"Explicit Type When Helpful\"\ndescription: \"Use explicit type when it aids clarity\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"var\", \"Code Style\"]\nnugetPackages: []\nusingStatements: [\"System Collections Generic\", \"System Linq\"]\nshowLineNumbers: false\n}\n// OK - explicit type makes intent clear\nIEnumerable<Order> activeOrders = GetOrders() Where(o => o IsActive);\n`\nFile-Scoped Namespaces\nAlways use file-scoped namespaces (C10+):\n`csharp{\ntitle: \"File-Scoped Namespaces\"\ndescription: \"Always use file-scoped namespaces (C10+)\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Namespaces\", \"Code Style\"]\nnugetPackages: [\"Whizbang\"]\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT\nusing System;\nusing Whizbang;\nnamespace MyApp Orders;\npublic class Order {\n    // }\n// ❌ WRONG\nusing System;\nusing Whizbang;\nnamespace MyApp Orders {\n    public class Order {\n        // }\n}\n`\nUsing Directives\nPlace outside namespace, System directives first:\n`csharp{\ntitle: \"Using Directives Placement\"\ndescription: \"Place outside namespace, System directives first\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Using\", \"Code Style\"]\nnugetPackages: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"System Threading Tasks\", \"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nnamespace MyApp Orders;\npublic class OrderService {\n    // }\n// ❌ WRONG - using inside namespace\nnamespace MyApp",
        "startIndex": 5000,
        "preview": "use var when type is obvious\" framework: \"NET8\" category: \"Contributors\" difficulty: \"BEGINNER\" tags: [\"var\", \"Code Style\"] nugetPackages: [\"Microsoft..."
      },
      {
        "id": "old-v1.0.0.0/contributors/coding-standards-chunk-4",
        "text": "\"System Collections Generic\", \"System Threading Tasks\", \"Microsoft Extensions DependencyInjection\", \"Whizbang\"] showLineNumbers: false } // ✅ CORRECT using System; using System Collections Generic; using System Threading Tasks; using Microsoft Extensions DependencyInjection; using Whizbang; namespace MyApp Orders; public class OrderService { // } // ❌ WRONG - using inside namespace namespace MyApp Orders {\n    using System;\n    using Whizbang;\n    public class OrderService {\n        // }\n}\n`\nRecords for DTOs and Events\nUse records for immutable data:\n`csharp{\ntitle: \"Records for DTOs and Events\"\ndescription: \"Use records for immutable data\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Records\", \"Immutability\", \"Events\"]\nnugetPackages: []\nusingStatements: [\"System\", \"System Collections Generic\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT - Events as records\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt);\npublic record PlaceOrder(Guid CustomerId, List<OrderItem> Items);\n// ❌ WRONG - Events as classes with setters\npublic class OrderPlaced {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    public DateTimeOffset PlacedAt { get; set; }\n}\n`\nNullable Reference Types\nEnable nullable reference types in all projects:\n`xml\n<PropertyGroup>\n    <Nullable>enable</Nullable>\n</PropertyGroup>\n`\nAnnotate nullability explicitly:\n`csharp{\ntitle: \"Nullable Reference Types\"\ndescription: \"Annotate nullability explicitly\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Nullable\", \"Type Safety\"]\nnugetPackages: []\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: false\n}\npublic class OrderRepository {\n    // Non-nullable - must never be null\n    private readonly IEventStore _eventStore;\n    // Nullable - can be null\n    private Order _cachedOrder;\n    public async Task<Order > FindAsync(Guid orderId) {\n        // Returns null if not found\n        return await _eventStore LoadAsync<Order>(orderId);\n    }\n    public async Task<Order> GetAsync(Guid orderId) {\n        // Throws if not found (non-nullable return)\n        var order = await FindAsync(orderId);\n        return order",
        "startIndex": 7041,
        "preview": "\"System Collections Generic\", \"System Threading Tasks\", \"Microsoft Extensions DependencyInjection\", \"Whizbang\"] showLineNumbers: false } // ✅ CORRECT ..."
      },
      {
        "id": "old-v1.0.0.0/contributors/coding-standards-chunk-5",
        "text": "readonly IEventStore _eventStore; // Nullable - can be null private Order _cachedOrder; public async Task<Order > FindAsync(Guid orderId) { // Returns null if not found return await _eventStore LoadAsync<Order>(orderId); } public async Task<Order> GetAsync(Guid orderId) { // Throws if not found (non-nullable return) var order = await FindAsync(orderId); return order throw new OrderNotFoundException(orderId);\n    }\n}\n`\nException Handling\nThrow Specific Exceptions\n`csharp{\ntitle: \"Specific Exception Types\"\ndescription: \"Throw specific exceptions, not generic Exception\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Exceptions\", \"Error Handling\"]\nnugetPackages: []\nusingStatements: [\"System\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT\nthrow new OrderNotFoundException(orderId);\nthrow new InvalidOperationException(\"Cannot ship a cancelled order\");\n// ❌ WRONG\nthrow new Exception(\"Order not found\");\n`\nDon't Swallow Exceptions\n`csharp{\ntitle: \"Proper Exception Handling\"\ndescription: \"Don't swallow exceptions, re-throw when needed\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Exceptions\", \"Error Handling\", \"Logging\"]\nnugetPackages: [\"Microsoft Extensions Logging\"]\nusingStatements: [\"System Threading Tasks\", \"Microsoft Extensions Logging\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT\ntry {\n    await processor ProcessAsync(order);\n} catch (InvalidOrderException ex) {\n    _logger LogError(ex, \"Order validation failed: {OrderId}\", order Id);\n    throw;  // Re-throw to propagate\n}\n// ❌ WRONG\ntry {\n    await processor ProcessAsync(order);\n} catch {\n    // Silent failure - very bad }\n`\nUse Specific Catches\n`csharp{\ntitle: \"Specific Exception Catches\"\ndescription: \"Catch specific exceptions, not everything\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Exceptions\", \"Error Handling\"]\nnugetPackages: [\"Microsoft EntityFrameworkCore\", \"Microsoft Extensions Logging\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Microsoft EntityFrameworkCore\", \"System Data Common\", \"Microsoft Extensions Logging\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT\ntry {\n    await SaveAsync(order);\n} catch (DbUpdateConcurrencyException ex) {\n    throw new OptimisticConcurrencyException(\"Order was modified\", ex);\n} catch (DbException ex) {\n    _logger LogError(ex, \"Database error saving order\");\n    throw;\n}\n// ❌ WRONG - catching everything\ntry {\n    await SaveAsync(order);\n} catch (Exception ex) {\n    _logger",
        "startIndex": 8884,
        "preview": "readonly IEventStore _eventStore; // Nullable - can be null private Order _cachedOrder; public async Task<Order > FindAsync(Guid orderId) { // Returns..."
      },
      {
        "id": "old-v1.0.0.0/contributors/coding-standards-chunk-6",
        "text": "showLineNumbers: false } // ✅ CORRECT try { await SaveAsync(order); } catch (DbUpdateConcurrencyException ex) { throw new OptimisticConcurrencyException(\"Order was modified\", ex); } catch (DbException ex) { _logger LogError(ex, \"Database error saving order\"); throw; } // ❌ WRONG - catching everything try { await SaveAsync(order); } catch (Exception ex) { _logger LogError(ex, \"Error\");\n    throw;\n}\n`\nAsync/Await\nAlways Async All the Way\n`csharp{\ntitle: \"Async All the Way\"\ndescription: \"Always use async all the way through the call stack\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Async\", \"Threading\"]\nnugetPackages: []\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT\npublic async Task<Order> GetOrderAsync(Guid orderId) {\n    var events = await _eventStore LoadStreamAsync($\"Order-{orderId}\");\n    return await ReconstructAsync(events);\n}\n// ❌ WRONG - mixing sync and async\npublic Order GetOrder(Guid orderId) {\n    var events = _eventStore LoadStreamAsync($\"Order-{orderId}\") Result;  // Deadlock risk return ReconstructAsync(events) Result;\n}\n`\nUse ConfigureAwait(false) in Libraries\n`csharp{\ntitle: \"ConfigureAwait in Libraries\"\ndescription: \"Use ConfigureAwait(false) in library code\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Async\", \"ConfigureAwait\", \"Libraries\"]\nnugetPackages: []\nusingStatements: [\"System Threading Tasks\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT - library code\npublic async Task SaveAsync(Order order) {\n    var events = order GetUncommittedEvents();\n    await _eventStore AppendAsync(streamId, events) ConfigureAwait(false);\n}\n// Application code can omit ConfigureAwait\n`\nAOT Compatibility\nNever use reflection that breaks AOT:\n`csharp{\ntitle: \"AOT-Safe Code\"\ndescription: \"Avoid reflection that breaks native AOT\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"ADVANCED\"\ntags: [\"AOT\", \"Reflection\", \"Source Generators\"]\nnugetPackages: []\nusingStatements: [\"System\"]\nshowLineNumbers: false\n}\n// ❌ WRONG - breaks AOT\nvar type = Type GetType(\"MyApp Orders Order\");\nvar instance = Activator",
        "startIndex": 11003,
        "preview": "showLineNumbers: false } // ✅ CORRECT try { await SaveAsync(order); } catch (DbUpdateConcurrencyException ex) { throw new OptimisticConcurrencyExcepti..."
      },
      {
        "id": "old-v1.0.0.0/contributors/coding-standards-chunk-7",
        "text": "reflection that breaks AOT: `csharp{ title: \"AOT-Safe Code\" description: \"Avoid reflection that breaks native AOT\" framework: \"NET8\" category: \"Contributors\" difficulty: \"ADVANCED\" tags: [\"AOT\", \"Reflection\", \"Source Generators\"] nugetPackages: [] usingStatements: [\"System\"] showLineNumbers: false } // ❌ WRONG - breaks AOT var type = Type GetType(\"MyApp Orders Order\"); var instance = Activator CreateInstance(type);\n// ✅ CORRECT - use source generators\n[GenerateHandlers]  // Source generator creates handler registry\npublic partial class HandlerRegistry { }\n`\nUse generic constraints instead of runtime type checks:\n`csharp{\ntitle: \"Generic Constraints vs Runtime Checks\"\ndescription: \"Use generic constraints instead of runtime type checks\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Generics\", \"Type Safety\", \"AOT\"]\nnugetPackages: []\nusingStatements: [\"System\"]\nshowLineNumbers: false\n}\n// ❌ WRONG\npublic void Process(object message) {\n    if (message GetType() == typeof(PlaceOrder)) {\n        // }\n}\n// ✅ CORRECT\npublic void Process<TMessage>(TMessage message) where TMessage : class {\n    // Compile-time type safety\n}\n`\nDependency Injection\nConstructor Injection\n`csharp{\ntitle: \"Constructor Injection\"\ndescription: \"Use constructor injection, not property injection\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Dependency Injection\", \"Constructor\"]\nnugetPackages: []\nusingStatements: []\nshowLineNumbers: false\n}\n// ✅ CORRECT\npublic class OrderService {\n    private readonly IOrderRepository _repository;\n    private readonly IEventPublisher _publisher;\n    public OrderService(IOrderRepository repository, IEventPublisher publisher) {\n        _repository = repository;\n        _publisher = publisher;\n    }\n}\n// ❌ WRONG - property injection\npublic class OrderService {\n    public IOrderRepository Repository { get; set; }\n}\n`\nRegister Services Explicitly\n`csharp{\ntitle: \"Explicit Service Registration\"\ndescription: \"Register services explicitly, avoid magic scanning\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Dependency Injection\", \"AOT\", \"Service Registration\"]\nnugetPackages: [\"Microsoft Extensions DependencyInjection\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT - explicit registration\nservices AddScoped<IOrderRepository, OrderRepository>();\nservices AddSingleton<IEventStore, PostgresEventStore>();\n// ❌ WRONG - magic scanning that breaks AOT\nservices Scan(scan => scan FromAssemblyOf<Order>() AddClasses()",
        "startIndex": 12787,
        "preview": "reflection that breaks AOT: `csharp{ title: \"AOT-Safe Code\" description: \"Avoid reflection that breaks native AOT\" framework: \"NET8\" category: \"Contri..."
      },
      {
        "id": "old-v1.0.0.0/contributors/coding-standards-chunk-8",
        "text": "framework: \"NET8\" category: \"Contributors\" difficulty: \"INTERMEDIATE\" tags: [\"Dependency Injection\", \"AOT\", \"Service Registration\"] nugetPackages: [\"Microsoft Extensions DependencyInjection\"] usingStatements: [\"Microsoft Extensions DependencyInjection\"] showLineNumbers: false } // ✅ CORRECT - explicit registration services AddScoped<IOrderRepository, OrderRepository>(); services AddSingleton<IEventStore, PostgresEventStore>(); // ❌ WRONG - magic scanning that breaks AOT services Scan(scan => scan FromAssemblyOf<Order>() AddClasses() AsImplementedInterfaces());\n`\nPerformance\nUse ValueTask for Hot Paths\n`csharp{\ntitle: \"ValueTask for Hot Paths\"\ndescription: \"Use ValueTask for high-frequency methods\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"ADVANCED\"\ntags: [\"Performance\", \"ValueTask\", \"Hot Path\"]\nnugetPackages: []\nusingStatements: [\"System Threading Tasks\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT - high-frequency method\npublic ValueTask<bool> TryGetFromCacheAsync(string key) {\n    if (_cache TryGetValue(key, out var value)) {\n        return new ValueTask<bool>(true);  // Synchronous completion\n    }\n    return LoadFromDatabaseAsync(key);  // Async completion\n}\n`\nAvoid Allocations in Hot Paths\n`csharp{\ntitle: \"Avoid Allocations in Hot Paths\"\ndescription: \"Use Span/Memory to avoid allocations\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"ADVANCED\"\ntags: [\"Performance\", \"Memory\", \"Span\", \"Hot Path\"]\nnugetPackages: []\nusingStatements: [\"System\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT - reuse span/memory\npublic void ProcessEvents(ReadOnlySpan<Event> events) {\n    foreach (var @event in events) {\n        // Process without allocation\n    }\n}\n// ❌ WRONG - allocates array\npublic void ProcessEvents(Event[] events) {\n    // }\n`\nTesting Conventions\nTest Method Naming\nFormat: MethodName_Scenario_ExpectedBehavior\n`csharp{\ntitle: \"Test Method Naming Convention\"\ndescription: \"MethodName_Scenario_ExpectedBehavior format\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Testing\", \"Naming\", \"xUnit\"]\nnugetPackages: [\"xunit\", \"FluentAssertions\"]\nusingStatements: [\"Xunit\", \"FluentAssertions\", \"System\"]\nshowLineNumbers: false\n}\n[Fact]\npublic void Ship_WhenOrderIsPlaced_UpdatesStatusToShipped() {\n    // Arrange\n    var order = new Order(customerId, items);\n    // Act\n    order Ship(trackingNumber);\n    // Assert\n    order Status Should() Be(OrderStatus Shipped);\n}\n[Fact]\npublic void Ship_WhenOrderIsCancelled_ThrowsInvalidOperationException() {\n    // Arrange\n    var order = new Order(customerId, items);\n    order Cancel(\"Customer requested\");\n    // Act & Assert\n    var act = () => order Ship(trackingNumber);\n    act Should()",
        "startIndex": 14982,
        "preview": "framework: \"NET8\" category: \"Contributors\" difficulty: \"INTERMEDIATE\" tags: [\"Dependency Injection\", \"AOT\", \"Service Registration\"] nugetPackages: [\"M..."
      },
      {
        "id": "old-v1.0.0.0/contributors/coding-standards-chunk-9",
        "text": "{ // Arrange var order = new Order(customerId, items); // Act order Ship(trackingNumber); // Assert order Status Should() Be(OrderStatus Shipped); } [Fact] public void Ship_WhenOrderIsCancelled_ThrowsInvalidOperationException() { // Arrange var order = new Order(customerId, items); order Cancel(\"Customer requested\"); // Act & Assert var act = () => order Ship(trackingNumber); act Should() Throw<InvalidOperationException>();\n}\n`\nUse FluentAssertions\n`csharp{\ntitle: \"FluentAssertions vs xUnit Asserts\"\ndescription: \"Use FluentAssertions for better readability\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Testing\", \"FluentAssertions\", \"xUnit\"]\nnugetPackages: [\"FluentAssertions\", \"xunit\"]\nusingStatements: [\"FluentAssertions\", \"Xunit\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT - readable assertions\nresult Should() NotBeNull();\nresult OrderId Should() Be(expectedId);\nresult Items Should() HaveCount(2);\n// ❌ WRONG - xUnit asserts (less readable)\nAssert NotNull(result);\nAssert Equal(expectedId, result OrderId);\nAssert Equal(2, result Items Count);\n`\nComments\nExplain Why, Not What\n`csharp{\ntitle: \"Meaningful Comments\"\ndescription: \"Explain why, not what - focus on non-obvious decisions\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Comments\", \"Documentation\"]\nnugetPackages: []\nusingStatements: [\"System Threading Tasks\"]\nshowLineNumbers: false\n}\n// ✅ CORRECT - explains non-obvious decision\n// Use pessimistic locking here because optimistic concurrency\n// causes too many retries under high contention\nawait _connection ExecuteAsync(\"SELECT FOR UPDATE\");\n// ❌ WRONG - states the obvious\n// Get the order\nvar order = await GetOrderAsync(orderId);\n`\nXML Documentation for Public APIs\n`csharp{\ntitle: \"XML Documentation for Public APIs\"\ndescription: \"Document all public APIs with XML comments\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Documentation\", \"XML Comments\", \"API\"]\nnugetPackages: []\nusingStatements: [\"System Collections Generic\", \"System Threading Tasks\"]\nshowLineNumbers: false\n}\n/// <summary>\n/// Appends events to an aggregate stream with optimistic concurrency /// </summary>\n/// <param name=\"streamId\">The unique identifier for the event stream </param>\n/// <param name=\"events\">The events to append </param>\n/// <param name=\"expectedVersion\">\n/// The expected current version of the stream",
        "startIndex": 17143,
        "preview": "{ // Arrange var order = new Order(customerId, items); // Act order Ship(trackingNumber); // Assert order Status Should() Be(OrderStatus Shipped); } [..."
      },
      {
        "id": "old-v1.0.0.0/contributors/coding-standards-chunk-10",
        "text": "Collections Generic\", \"System Threading Tasks\"] showLineNumbers: false } /// <summary> /// Appends events to an aggregate stream with optimistic concurrency /// </summary> /// <param name=\"streamId\">The unique identifier for the event stream </param> /// <param name=\"events\">The events to append </param> /// <param name=\"expectedVersion\"> /// The expected current version of the stream If the actual version\n/// does not match, throws <see cref=\"ConcurrencyException\"/> /// </param>\n/// <exception cref=\"ConcurrencyException\">\n/// Thrown when the stream has been modified since it was loaded /// </exception>\npublic async Task AppendAsync(string streamId, IEnumerable<object> events, long expectedVersion) {\n    // }\n`\nAnalyzer Configuration\nWhizbang uses Roslyn analyzers to enforce standards Key rules:\nWBZ001: Command/event must have [OwnedBy] attribute\nWBZ002: Handler marked [Pure] must not have side effects\nWBZ003: Async method must have Async suffix\nWBZ004: Event must be immutable (record or readonly properties)\nSuppress warnings only when absolutely necessary:\n`csharp{\ntitle: \"Analyzer Warning Suppression\"\ndescription: \"Suppress warnings only when absolutely necessary with justification\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Analyzers\", \"Warnings\", \"Code Quality\"]\nnugetPackages: []\nusingStatements: []\nshowLineNumbers: false\n}\n#pragma warning disable WBZ001 // Justification: Internal command, ownership not needed\npublic record InternalCleanupCommand();\n#pragma warning restore WBZ001\n`\nSummary Checklist\nBefore submitting code, verify:\n[ ] K&R/Egyptian braces used\n[ ] var used for local variables\n[ ] File-scoped namespaces\n[ ] Nullable reference types enabled and annotated\n[ ] Async methods have Async suffix\n[ ] No reflection that breaks AOT\n[ ] All public APIs have XML documentation\n[ ] Tests follow naming convention\n[ ] Code passes all analyzer rules\nQuestions If you're unsure about any convention, ask in GitHub Discussions",
        "startIndex": 19163,
        "preview": "Collections Generic\", \"System Threading Tasks\"] showLineNumbers: false } /// <summary> /// Appends events to an aggregate stream with optimistic concu..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/contributors/contributing",
    "title": "Contributing to Whizbang",
    "category": "Contributors",
    "url": "/docs/old-v1.0.0.0/contributors/contributing",
    "chunks": [
      {
        "id": "old-v1.0.0.0/contributors/contributing-chunk-0",
        "text": "Contributing to Whizbang\nThank you for your interest in contributing to Whizbang This guide will help you get started Code of Conduct\nWe are committed to providing a welcoming and inclusive environment Please read and follow our Code of Conduct Ways to Contribute\n🐛 Report Bugs\nFound a bug Open an issue with:\nClear description of the problem\nSteps to reproduce\nExpected vs actual behavior\nWhizbang version and NET version\nRelevant code samples\n💡 Suggest Features\nHave an idea Start a discussion to:\nDescribe the use case\nExplain why existing features don't solve it\nPropose an API design\nDiscuss tradeoffs and alternatives\n📝 Improve Documentation\nDocumentation improvements are always welcome:\nFix typos or unclear explanations\nAdd missing examples\nImprove code samples\nTranslate to other languages\nDocumentation lives in this repository at src/assets/docs/ 🔨 Submit Code\nReady to code Great Please:\nDiscuss first - For non-trivial changes, open an issue or discussion first\nFollow conventions - See Coding Standards\nWrite tests - All new features need tests\nUpdate docs - Documentation is part of the PR, not an afterthought\nKeep it focused - One feature/fix per PR\nDevelopment Setup\nPrerequisites NET 8 0 SDK or later\nDocker (for running test databases)\nGit\nYour favorite IDE (Visual Studio, Rider, VS Code)\nClone the Repository\n`bash{\ntitle: \"Clone Repository\"\ndescription: \"Clone the Whizbang repository locally\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Git\", \"Setup\"]\n}\ngit clone https://github com/whizbang-lib/whizbang",
        "startIndex": 0,
        "preview": "Contributing to Whizbang\nThank you for your interest in contributing to Whizbang This guide will help you get started Code of Conduct\nWe are committed..."
      },
      {
        "id": "old-v1.0.0.0/contributors/contributing-chunk-1",
        "text": "per PR Development Setup Prerequisites NET 8 0 SDK or later Docker (for running test databases) Git Your favorite IDE (Visual Studio, Rider, VS Code) Clone the Repository `bash{ title: \"Clone Repository\" description: \"Clone the Whizbang repository locally\" category: \"Contributors\" difficulty: \"BEGINNER\" tags: [\"Git\", \"Setup\"] } git clone https://github com/whizbang-lib/whizbang git\ncd whizbang\n`\nBuild the Solution\n`bash{\ntitle: \"Build Solution\"\ndescription: \"Build the entire Whizbang solution\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Build\", \"Setup\"]\n}\ndotnet build\n`\nRun Tests\n`bash{\ntitle: \"Run Tests\"\ndescription: \"Run unit and integration tests with optional coverage\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Testing\", \"Coverage\"]\n}\nRun all tests\ndotnet test\nRun with coverage\ndotnet test /p:CollectCoverage=true\n`\nStart Local Infrastructure\nFor integration tests, you'll need Postgres and Kafka:\n`bash{\ntitle: \"Start Infrastructure\"\ndescription: \"Start Postgres and Kafka for integration tests\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Docker\", \"Infrastructure\", \"Testing\"]\n}\ndocker-compose up -d\n`\nThis starts:\nPostgres on localhost:5432\nKafka on localhost:9092\nZookeeper on localhost:2181\nProject Structure\n`\nwhizbang/\n├── src/\n│   ├── Whizbang Core/              Core mediator and messaging\n│   ├── Whizbang EventSourcing/     Event store and aggregates\n│   ├── Whizbang Projections/       Projection engine\n│   ├── Whizbang Messaging/         Distributed messaging\n│   ├── Whizbang Postgres/          Postgres driver\n│   ├── Whizbang Kafka/             Kafka driver\n│   ├── Whizbang OpenTelemetry/     Observability\n│   └── Whizbang Analyzers/         Roslyn analyzers\n├── tests/\n│   ├── Whizbang Core Tests/\n│   ├── Whizbang EventSourcing Tests/\n│   ├── Integration",
        "startIndex": 1557,
        "preview": "per PR Development Setup Prerequisites NET 8 0 SDK or later Docker (for running test databases) Git Your favorite IDE (Visual Studio, Rider, VS Code) ..."
      },
      {
        "id": "old-v1.0.0.0/contributors/contributing-chunk-2",
        "text": "│ ├── Whizbang Projections/ Projection engine │ ├── Whizbang Messaging/ Distributed messaging │ ├── Whizbang Postgres/ Postgres driver │ ├── Whizbang Kafka/ Kafka driver │ ├── Whizbang OpenTelemetry/ Observability │ └── Whizbang Analyzers/ Roslyn analyzers ├── tests/ │ ├── Whizbang Core Tests/ │ ├── Whizbang EventSourcing Tests/ │ ├── Integration Tests/          Multi-package integration tests\n│   └── Documentation/              Tests for documentation examples\n├── samples/\n│   ├── SimpleMediator/             Basic mediator sample\n│   ├── EventSourcedMonolith/       Event sourcing sample\n│   └── Microservices/              Distributed messaging sample\n└── docs/\n    └── (Documentation website - separate repo)\n`\nBranching Strategy\nmain - Stable, released code\ndevelop - Active development\nfeature/xyz - New features (branch from develop)\nfix/xyz - Bug fixes (branch from develop or main for hotfixes)\nPull Request Process\nCreate a Branch\n`bash{\ntitle: \"Create Feature Branch\"\ndescription: \"Create a new feature branch from develop\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Git\", \"Branching\"]\n}\ngit checkout develop\ngit pull origin develop\ngit checkout -b feature/my-awesome-feature\n`\nMake Changes\nWrite code following Coding Standards\nAdd tests for new functionality\nUpdate documentation\nEnsure all tests pass\nCommit Changes\nWe use Conventional Commits:\n`bash{\ntitle: \"Conventional Commits\"\ndescription: \"Examples of conventional commit messages\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Git\", \"Commits\", \"Conventional Commits\"]\n}\ngit commit -m \"feat: add support for SQL Server driver\"\ngit commit -m \"fix: correct optimistic concurrency check\"\ngit commit -m \"docs: add examples for projections\"\n`\nCommit types:\nfeat: - New feature\nfix: - Bug fix\ndocs: - Documentation changes\ntest: - Adding or updating tests\nrefactor: - Code refactoring\nperf: - Performance improvements\nchore: - Build/tooling changes\nPush and Create PR\n`bash{\ntitle: \"Push Feature Branch\"\ndescription: \"Push feature branch to origin for PR creation\"\ncategory: \"Contributors\"\ndifficulty: \"BEGINNER\"\ntags: [\"Git\", \"Push\"]\n}\ngit push origin feature/my-awesome-feature\n`\nThen open a PR on GitHub targeting develop branch",
        "startIndex": 3004,
        "preview": "│ ├── Whizbang Projections/ Projection engine │ ├── Whizbang Messaging/ Distributed messaging │ ├── Whizbang Postgres/ Postgres driver │ ├── Whizbang ..."
      },
      {
        "id": "old-v1.0.0.0/contributors/contributing-chunk-3",
        "text": "Code refactoring perf: - Performance improvements chore: - Build/tooling changes Push and Create PR `bash{ title: \"Push Feature Branch\" description: \"Push feature branch to origin for PR creation\" category: \"Contributors\" difficulty: \"BEGINNER\" tags: [\"Git\", \"Push\"] } git push origin feature/my-awesome-feature ` Then open a PR on GitHub targeting develop branch PR Review\nMaintainers will review your PR Please:\nRespond to feedback promptly\nMake requested changes\nKeep the PR focused (split large PRs if needed)\nBe patient - we review PRs as quickly as we can\nMerge\nOnce approved, a maintainer will merge your PR Congrats 🎉\nTesting Guidelines\nUnit Tests\nTest individual classes in isolation\nUse mocks for dependencies\nFast execution (<100ms per test)\nLocated in * Tests projects\nExample:\n`csharp{\ntitle: \"Unit Test Example\"\ndescription: \"Example unit test for domain logic\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Testing\", \"Unit Tests\", \"xUnit\"]\nnugetPackages: [\"xunit\", \"FluentAssertions\"]\nusingStatements: [\"Xunit\", \"FluentAssertions\"]\nshowLineNumbers: false\n}\npublic class OrderTests {\n    [Fact]\n    public void PlaceOrder_WithValidItems_EmitsOrderPlacedEvent() {\n        // Arrange\n        var order = new Order(customerId, items);\n        // Act\n        var events = order GetUncommittedEvents();\n        // Assert\n        var placed = events Should() ContainSingle() Which Should() BeOfType<OrderPlaced>();\n        placed CustomerId Should() Be(customerId);\n    }\n}\n`\nIntegration Tests\nTest multiple components together\nUse real databases (Docker containers)\nSlower execution (can be seconds)\nLocated in Integration Tests project\nExample:\n`csharp{\ntitle: \"Integration Test Example\"\ndescription: \"Example integration test for event store\"\nframework: \"NET8\"\ncategory: \"Contributors\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Testing\", \"Integration Tests\", \"Event Store\"]\nnugetPackages: [\"xunit\", \"FluentAssertions\"]\nusingStatements: [\"System Threading Tasks\", \"Xunit\", \"FluentAssertions\"]\nshowLineNumbers: false\n}\npublic class EventStoreIntegrationTests : IClassFixture<PostgresFixture> {\n    [Fact]\n    public async Task AppendAndLoad_RoundTrip_PreservesEvents() {\n        // Arrange\n        var store = new PostgresEventStore(connectionString);\n        var events = new[] { new OrderPlaced( ), new OrderShipped( ) };\n        // Act\n        await store AppendAsync(\"Order-123\", events);\n        var loaded = await store LoadStreamAsync(\"Order-123\");\n        // Assert\n        loaded Should()",
        "startIndex": 4880,
        "preview": "Code refactoring perf: - Performance improvements chore: - Build/tooling changes Push and Create PR `bash{ title: \"Push Feature Branch\" description: \"..."
      },
      {
        "id": "old-v1.0.0.0/contributors/contributing-chunk-4",
        "text": "showLineNumbers: false } public class EventStoreIntegrationTests : IClassFixture<PostgresFixture> { [Fact] public async Task AppendAndLoad_RoundTrip_PreservesEvents() { // Arrange var store = new PostgresEventStore(connectionString); var events = new[] { new OrderPlaced( ), new OrderShipped( ) }; // Act await store AppendAsync(\"Order-123\", events); var loaded = await store LoadStreamAsync(\"Order-123\"); // Assert loaded Should() BeEquivalentTo(events);\n    }\n}\n`\nDocumentation Tests\nCRITICAL: All complete code examples in documentation MUST have corresponding tests Located in tests/Documentation/, these tests:\nExtract code from documentation\nVerify examples compile\nValidate examples actually work\nPrevent documentation from becoming stale\nSee Test-Driven Examples for details Documentation Standards\nAll Code Examples Must:\nInclude complete using statements\nFollow CODE_SAMPLES editorconfig (K&R/Egyptian braces)\nUse Cnaming conventions (PascalCase, camelCase, etc )\nBe compilable - No pseudo-code or placeholders\nInclude metadata for enhanced code blocks\nExample Format\nmarkdown\n`csharp{\ntitle: \"Order Command Handler\"\ndescription: \"Processes order placement commands\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"Handlers\", \"Orders\"]\nnugetPackages: [\"Whizbang Core\"]\ntestFile: \"OrderHandlerTests cs\"\ntestMethod: \"HandlePlaceOrder_ValidOrder_ReturnsSuccess\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\npublic class PlaceOrderHandler {\n    public async Task<OrderPlacedResult> Handle(PlaceOrder command) {\n        // Implementation\n    }\n}\n`\nSee DOCUMENTATION-STANDARDS md for complete guidelines Coding Standards\nSee Coding Standards for detailed Cconventions",
        "startIndex": 7056,
        "preview": "showLineNumbers: false } public class EventStoreIntegrationTests : IClassFixture<PostgresFixture> { [Fact] public async Task AppendAndLoad_RoundTrip_P..."
      },
      {
        "id": "old-v1.0.0.0/contributors/contributing-chunk-5",
        "text": "\"OrderHandlerTests cs\" testMethod: \"HandlePlaceOrder_ValidOrder_ReturnsSuccess\" usingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"] showLineNumbers: true } using System; using System Threading Tasks; using Whizbang; public class PlaceOrderHandler { public async Task<OrderPlacedResult> Handle(PlaceOrder command) { // Implementation } } ` See DOCUMENTATION-STANDARDS md for complete guidelines Coding Standards See Coding Standards for detailed Cconventions Key Points:\nBrace Style: K&R/Egyptian (opening brace on same line)\nvar: Always use var for local variables\nNaming: PascalCase for public, camelCase for private, _camelCase for fields\nAsync: Suffix async methods with Async\nNullability: Enable nullable reference types\nAOT-Safe: No reflection tricks that break native AOT\nDesign Philosophy\nWhen contributing, keep these principles in mind:\nEvents are the source of truth - Always\nSimple things should be simple - Don't overcomplicate the basic mediator scenario\nComplex things should be possible - But with clear opt-in\nAOT-first - All features must work with native AOT\nDriver-based - Never lock users into a specific technology\nObservable by default - Telemetry is built-in, not bolted-on\nIdempotent - Message handlers should be safe to retry\nGetting Help\nQuestions Ask in GitHub Discussions\nStuck Ping us on Discord (coming soon)\nFound a bug Open an issue\nRecognition\nContributors are recognized in:\nRelease notes for the version their PR shipped in\nCONTRIBUTORS md file\nOur gratitude and appreciation 🙏\nThank you for making Whizbang better",
        "startIndex": 8447,
        "preview": "\"OrderHandlerTests cs\" testMethod: \"HandlePlaceOrder_ValidOrder_ReturnsSuccess\" usingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"] show..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/core-concepts/aggregates",
    "title": "Aggregates",
    "category": "Core Concepts",
    "url": "/docs/old-v1.0.0.0/core-concepts/aggregates",
    "chunks": [
      {
        "id": "old-v1.0.0.0/core-concepts/aggregates-chunk-0",
        "text": "Aggregates\nAggregates are the fundamental building blocks of Whizbang's event-sourced architecture They serve as consistency boundaries that encapsulate business logic and ensure data integrity What are Aggregates An aggregate is a cluster of domain objects that can be treated as a single unit for data changes In Whizbang:\nConsistency Boundary: All changes within an aggregate are atomic\nEvent Source: Aggregates generate events when their state changes\nBusiness Logic Container: They encapsulate domain rules and invariants\nIdentity: Each aggregate has a unique identifier\nKey Characteristics\nEvent-Sourced State\nAggregates don't store current state directly Instead, they:\nStore a sequence of events that represent state changes\nRebuild current state by replaying events from the event store\nAppend new events when commands are processed\nCommand Processing\nAggregates receive commands and:\nValidate the command against current state\nApply business rules and invariants\nGenerate domain events if the command is valid\nThrow exceptions if the command violates business rules\nOptimistic Concurrency\nWhizbang aggregates use optimistic concurrency control:\nEach aggregate has a version number\nConcurrent modifications are detected and handled\nPrevents lost update problems in distributed scenarios\nExample Structure\n`csharp{\ntitle: \"Order Aggregate Example\"\ndescription: \"Complete aggregate structure showing event sourcing, command handling, and state management\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aggregates\", \"Event Sourcing\", \"DDD\", \"Order Management\"]\nfilename: \"OrderAggregate cs\"\nnugetPackages: [\"Whizbang EventSourcing\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class OrderAggregate : Aggregate {\n    public Guid Id { get; private set; }\n    public OrderStatus Status { get; private set; }\n    public List<OrderItem> Items { get; private set; } = new();\n    // Constructor for new aggregates\n    public OrderAggregate(PlaceOrderCommand command) {\n        // Validate and apply business rules\n        Apply(new OrderPlacedEvent(command OrderId, command Items));\n    }\n    // Event handler (rebuilds state)\n    private void When(OrderPlacedEvent @event) {\n        Id = @event OrderId;\n        Status = OrderStatus",
        "startIndex": 0,
        "preview": "Aggregates\nAggregates are the fundamental building blocks of Whizbang's event-sourced architecture They serve as consistency boundaries that encapsula..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/aggregates-chunk-1",
        "text": "set; } public List<OrderItem> Items { get; private set; } = new(); // Constructor for new aggregates public OrderAggregate(PlaceOrderCommand command) { // Validate and apply business rules Apply(new OrderPlacedEvent(command OrderId, command Items)); } // Event handler (rebuilds state) private void When(OrderPlacedEvent @event) { Id = @event OrderId; Status = OrderStatus Placed;\n        Items = @event Items;\n    }\n    // Command method\n    public void Ship(ShipOrderCommand command) {\n        if (Status = OrderStatus Placed) {\n            throw new InvalidOperationException(\"Order must be placed to ship\");\n        }\n        Apply(new OrderShippedEvent(Id, command TrackingNumber));\n    }\n}\n`\nBest Practices\nKeep Aggregates Small\nFocus on a single business concept\nAvoid large, complex aggregates\nConsider splitting if aggregate becomes unwieldy\nDesign Around Invariants\nIdentify what must remain consistent\nEncapsulate related data that changes together\nUse domain events to communicate between aggregates\nAvoid Cross-Aggregate Transactions\nOne aggregate per transaction\nUse eventual consistency between aggregates\nCommunicate via domain events and sagas\nIntegration with Whizbang\nWhizbang provides:\nRepository pattern for loading and saving aggregates\nAutomatic event publishing when aggregates are saved\nOptimistic concurrency handling out of the box\nMultiple storage backends (Postgres, SQL Server, etc )\nRelated Topics\nCore Concepts - Overview of Whizbang's architectural patterns\nRepositories and CQRS Helpers - Working with aggregate repositories\nCommand Handling - Processing commands in aggregates\nGetting Started - Hands-on tutorial building aggregates\nNext Steps\nThis page provides an overview of aggregates in Whizbang For detailed implementation examples and advanced patterns, see the comprehensive documentation linked above",
        "startIndex": 2328,
        "preview": "set; } public List<OrderItem> Items { get; private set; } = new(); // Constructor for new aggregates public OrderAggregate(PlaceOrderCommand command) ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/core-concepts/core-concepts",
    "title": "Core Concepts",
    "category": "Core Concepts",
    "url": "/docs/old-v1.0.0.0/core-concepts/core-concepts",
    "chunks": [
      {
        "id": "old-v1.0.0.0/core-concepts/core-concepts-chunk-0",
        "text": "Core Concepts\nWhizbang is built on four foundational concepts: Events, Commands, Aggregates, and Projections Understanding these primitives is essential to using Whizbang effectively Events\nEvents are immutable facts that have happened in your system They represent state changes and are the source of truth in event-sourced architectures Characteristics\nPast tense naming - OrderPlaced, PaymentProcessed, InventoryReserved\nImmutable - Once written, never modified\nAppend-only - New events are added to the stream, old events remain forever\nDomain-owned - Each event belongs to a specific domain/service\nExample\n`csharp{\ntitle: \"Order Domain Events\"\ndescription: \"Events representing state changes in the order lifecycle\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Events\", \"Domain Events\", \"Order Management\"]\nusingStatements: [\"System\"]\nshowLineNumbers: true\n}\nusing System;\nnamespace MyApp Orders Events;\n// Event: Order was placed by a customer\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset PlacedAt,\n    List<OrderItem> Items,\n    decimal Total\n);\n// Event: Order was shipped\npublic record OrderShipped(\n    Guid OrderId,\n    DateTimeOffset ShippedAt,\n    string TrackingNumber\n);\n// Event: Order was cancelled\npublic record OrderCancelled(\n    Guid OrderId,\n    DateTimeOffset CancelledAt,\n    string Reason\n);\n`\nEvent Streams\nEvents are stored in streams, one stream per aggregate instance:\n`text{\ntitle: \"Event Stream Structure\"\ndescription: \"Visual representation of how events are stored in streams with sequence numbers\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Events\", \"Streams\", \"Event Sourcing\"]\nfilename: \"event-stream-example",
        "startIndex": 0,
        "preview": "Core Concepts\nWhizbang is built on four foundational concepts: Events, Commands, Aggregates, and Projections Understanding these primitives is essenti..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/core-concepts-chunk-1",
        "text": "DateTimeOffset CancelledAt, string Reason ); ` Event Streams Events are stored in streams, one stream per aggregate instance: `text{ title: \"Event Stream Structure\" description: \"Visual representation of how events are stored in streams with sequence numbers\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"BEGINNER\" tags: [\"Events\", \"Streams\", \"Event Sourcing\"] filename: \"event-stream-example txt\"\nshowLineNumbers: false\n}\nStream: \"Order-{orderId}\"\n  [0] OrderPlaced\n  [1] OrderItemAdded\n  [2] OrderShipped\n  [3] OrderDelivered\n`\nEach event has a position (sequence number) in the stream, enabling:\nReplaying the stream to rebuild aggregate state\nOptimistic concurrency - Detect conflicting concurrent updates\nPoint-in-time queries - Get state as of a specific event\nDomain Ownership\nEvents are owned by the domain that publishes them:\n`csharp{\ntitle: \"Domain-Owned Events\"\ndescription: \"Marking events with their owning domain\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Events\", \"Domain Ownership\", \"Distributed Systems\"]\nusingStatements: [\"Whizbang\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nnamespace MyApp Orders Events;\n[OwnedBy(\"Orders\")]  // This event comes from the Orders domain\npublic record OrderPlaced(Guid OrderId, Guid CustomerId);\n[OwnedBy(\"Inventory\")]  // This event comes from the Inventory domain\npublic record InventoryReserved(Guid OrderId, List<Guid> ProductIds);\n`\nWhen other services subscribe to these events:\nThey're consuming a public API from the owning domain\nThe owning domain controls the event schema\nSubscribers can backfill from the entire event history\nCommands\nCommands are requests to change state They represent intent and are sent to the domain that owns the aggregate Characteristics\nImperative naming - PlaceOrder, ProcessPayment, ReserveInventory\nValidated - Can be rejected if invalid\nRouted - Sent to the owning domain's handlers\nSingle recipient - Unlike events, commands go to exactly one handler\nExample\n`csharp{\ntitle: \"Order Domain Commands\"\ndescription: \"Commands representing requests to change order state\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"CQRS\", \"Order Management\"]\nusingStatements: [\"System\"]\nshowLineNumbers: true\n}\nusing System;\nnamespace MyApp Orders",
        "startIndex": 1751,
        "preview": "DateTimeOffset CancelledAt, string Reason ); ` Event Streams Events are stored in streams, one stream per aggregate instance: `text{ title: \"Event Str..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/core-concepts-chunk-2",
        "text": "owning domain's handlers Single recipient - Unlike events, commands go to exactly one handler Example `csharp{ title: \"Order Domain Commands\" description: \"Commands representing requests to change order state\" framework: \"NET8\" category: \"Domain Logic\" difficulty: \"BEGINNER\" tags: [\"Commands\", \"CQRS\", \"Order Management\"] usingStatements: [\"System\"] showLineNumbers: true } using System; namespace MyApp Orders Commands;\n// Command: Request to place a new order\npublic record PlaceOrder(\n    Guid CustomerId,\n    List<OrderItem> Items\n);\n// Command: Request to cancel an order\npublic record CancelOrder(\n    Guid OrderId,\n    string Reason\n);\n// Command: Request to update shipping address\npublic record UpdateShippingAddress(\n    Guid OrderId,\n    Address NewAddress\n);\n`\nCommand Handlers\nHandlers receive commands, validate them, and produce events:\n`csharp{\ntitle: \"Order Command Handler\"\ndescription: \"Handler that validates commands and produces events\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"Handlers\", \"Validation\", \"Events\"]\nusingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\nnamespace MyApp Orders Handlers;\npublic class PlaceOrderHandler {\n    private readonly IOrderRepository _repository;\n    public PlaceOrderHandler(IOrderRepository repository) {\n        _repository = repository;\n    }\n    public async Task<OrderPlaced> Handle(PlaceOrder command) {\n        // Validate command\n        if (command Items Count == 0) {\n            throw new InvalidOperationException(\"Order must have at least one item\");\n        }\n        // Create aggregate\n        var order = new Order(\n            Guid NewGuid(),\n            command CustomerId,\n            command Items\n        );\n        // Persist aggregate (events are appended)\n        await _repository SaveAsync(order);\n        // Return event (auto-published by Whizbang)\n        return new OrderPlaced(\n            order Id,\n            command CustomerId,\n            DateTimeOffset UtcNow,\n            command Items,\n            order Total\n        );\n    }\n}\n`\nCommand Routing\nCommands are routed to the owning domain:\n`csharp{\ntitle: \"Sending Commands\"\ndescription: \"How to send commands to their owning domain\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"Routing\", \"Distributed Systems\"]\nusingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading",
        "startIndex": 3681,
        "preview": "owning domain's handlers Single recipient - Unlike events, commands go to exactly one handler Example `csharp{ title: \"Order Domain Commands\" descript..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/core-concepts-chunk-3",
        "text": "} ` Command Routing Commands are routed to the owning domain: `csharp{ title: \"Sending Commands\" description: \"How to send commands to their owning domain\" framework: \"NET8\" category: \"Domain Logic\" difficulty: \"INTERMEDIATE\" tags: [\"Commands\", \"Routing\", \"Distributed Systems\"] usingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading Tasks;\nusing Whizbang;\npublic class CheckoutService {\n    private readonly IWhizbang _whizbang;\n    public CheckoutService(IWhizbang whizbang) {\n        _whizbang = whizbang;\n    }\n    public async Task CheckoutAsync(Guid customerId, List<OrderItem> items) {\n        // Send command to Orders domain\n        var placed = await _whizbang Send(new PlaceOrder(customerId, items));\n        // Send command to Inventory domain\n        await _whizbang Send(new ReserveInventory(placed OrderId, items));\n        // Send command to Payment domain\n        await _whizbang Send(new ProcessPayment(placed OrderId, placed Total));\n    }\n}\n`\nIn a monolith, these commands are routed to local handlers In microservices, they're routed to the owning service via message broker Aggregates\nAggregates are the write-side domain models that enforce business rules They are the consistency boundary for commands and events Characteristics\nConsistency boundary - All changes within an aggregate are transactional\nEvent-sourced - State is built by replaying events\nValidated - Enforce invariants before producing events\nSingle writer - Only one command can modify an aggregate at a time (optimistic concurrency)\nExample\n`csharp{\ntitle: \"Order Aggregate\"\ndescription: \"Event-sourced aggregate that enforces order business rules\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aggregates\", \"Event Sourcing\", \"Domain-Driven Design\"]\nusingStatements: [\"Whizbang\", \"System\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing Whizbang;\nnamespace MyApp Orders",
        "startIndex": 5848,
        "preview": "} ` Command Routing Commands are routed to the owning domain: `csharp{ title: \"Sending Commands\" description: \"How to send commands to their owning do..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/core-concepts-chunk-4",
        "text": "a time (optimistic concurrency) Example `csharp{ title: \"Order Aggregate\" description: \"Event-sourced aggregate that enforces order business rules\" framework: \"NET8\" category: \"Domain Logic\" difficulty: \"INTERMEDIATE\" tags: [\"Aggregates\", \"Event Sourcing\", \"Domain-Driven Design\"] usingStatements: [\"Whizbang\", \"System\", \"System Collections Generic\"] showLineNumbers: true } using System; using System Collections Generic; using Whizbang; namespace MyApp Orders Domain;\npublic class Order : Aggregate {\n    public Guid Id { get; private set; }\n    public Guid CustomerId { get; private set; }\n    public OrderStatus Status { get; private set; }\n    public List<OrderItem> Items { get; private set; } = new();\n    public decimal Total { get; private set; }\n    // Constructor for new aggregates\n    public Order(Guid id, Guid customerId, List<OrderItem> items) {\n        // Validate business rules\n        if (items Count == 0) {\n            throw new InvalidOperationException(\"Order must have items\");\n        }\n        // Produce event\n        Apply(new OrderPlaced(\n            id,\n            customerId,\n            DateTimeOffset UtcNow,\n            items,\n            items Sum(i => i Price * i Quantity)\n        ));\n    }\n    // Event handler - updates state\n    private void When(OrderPlaced @event) {\n        Id = @event OrderId;\n        CustomerId = @event CustomerId;\n        Status = OrderStatus Placed;\n        Items = @event Items;\n        Total = @event Total;\n    }\n    // Command method - enforces business rules\n    public void Ship(string trackingNumber) {\n        if (Status = OrderStatus Placed) {\n            throw new InvalidOperationException(\"Can only ship placed orders\");\n        }\n        Apply(new OrderShipped(Id, DateTimeOffset UtcNow, trackingNumber));\n    }\n    // Event handler - updates state\n    private void When(OrderShipped @event) {\n        Status = OrderStatus Shipped;\n    }\n    // Command method - enforces business rules\n    public void Cancel(string reason) {\n        if (Status == OrderStatus Shipped || Status == OrderStatus Delivered) {\n            throw new InvalidOperationException(\"Cannot cancel shipped/delivered orders\");\n        }\n        Apply(new OrderCancelled(Id, DateTimeOffset UtcNow, reason));\n    }\n    // Event handler - updates state\n    private void When(OrderCancelled @event) {\n        Status = OrderStatus",
        "startIndex": 7472,
        "preview": "a time (optimistic concurrency) Example `csharp{ title: \"Order Aggregate\" description: \"Event-sourced aggregate that enforces order business rules\" fr..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/core-concepts-chunk-5",
        "text": "// Command method - enforces business rules public void Cancel(string reason) { if (Status == OrderStatus Shipped || Status == OrderStatus Delivered) { throw new InvalidOperationException(\"Cannot cancel shipped/delivered orders\"); } Apply(new OrderCancelled(Id, DateTimeOffset UtcNow, reason)); } // Event handler - updates state private void When(OrderCancelled @event) { Status = OrderStatus Cancelled;\n    }\n}\npublic enum OrderStatus {\n    Placed,\n    Shipped,\n    Delivered,\n    Cancelled\n}\n`\nEvent Sourcing Pattern\nAggregates follow this pattern:\nLoad aggregate by replaying events from the stream\nExecute command method, which validates business rules\nApply events to update state\nSave new events to the stream\n`csharp{\ntitle: \"Loading and Saving Aggregates\"\ndescription: \"How aggregates are loaded from and saved to event streams\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"ADVANCED\"\ntags: [\"Aggregates\", \"Event Sourcing\", \"Repositories\"]\nusingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nusing Whizbang;\npublic class OrderRepository : IOrderRepository {\n    private readonly IEventStore _eventStore;\n    public OrderRepository(IEventStore eventStore) {\n        _eventStore = eventStore;\n    }\n    public async Task<Order> GetAsync(Guid orderId) {\n        // Load events from stream\n        var events = await _eventStore LoadStreamAsync($\"Order-{orderId}\");\n        // Reconstitute aggregate by replaying events\n        var order = new Order();\n        foreach (var @event in events) {\n            order ApplyEvent(@event);  // Calls private When() methods\n        }\n        return order;\n    }\n    public async Task SaveAsync(Order order) {\n        // Get uncommitted events from aggregate\n        var newEvents = order GetUncommittedEvents();\n        // Append to event stream with optimistic concurrency check\n        await _eventStore AppendToStreamAsync(\n            $\"Order-{order Id}\",\n            newEvents,\n            expectedVersion: order Version\n        );\n        // Mark events as committed\n        order MarkEventsAsCommitted();\n    }\n}\n`\nProjections\nProjections are read-side models optimized for queries They are built by subscribing to events and updating denormalized views",
        "startIndex": 9387,
        "preview": "// Command method - enforces business rules public void Cancel(string reason) { if (Status == OrderStatus Shipped || Status == OrderStatus Delivered) ..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/core-concepts-chunk-6",
        "text": "order GetUncommittedEvents(); // Append to event stream with optimistic concurrency check await _eventStore AppendToStreamAsync( $\"Order-{order Id}\", newEvents, expectedVersion: order Version ); // Mark events as committed order MarkEventsAsCommitted(); } } ` Projections Projections are read-side models optimized for queries They are built by subscribing to events and updating denormalized views Characteristics\nEventually consistent - Updated asynchronously as events arrive\nDenormalized - Optimized for specific query patterns\nRebuildable - Can be deleted and rebuilt from event history\nIsolated - Each projection has its own data model\nExample\n`csharp{\ntitle: \"Order History Projection\"\ndescription: \"Projection that maintains a queryable order history\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"CQRS\", \"Read Models\"]\nusingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\nnamespace MyApp Orders Projections;\n// Read model - optimized for queries\npublic class OrderHistoryItem {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    public DateTimeOffset PlacedAt { get; set; }\n    public DateTimeOffset ShippedAt { get; set; }\n    public decimal Total { get; set; }\n    public string Status { get; set; }\n}\n// Projection handler - subscribes to events\npublic class OrderHistoryProjection {\n    private readonly IOrderHistoryStore _store;\n    public OrderHistoryProjection(IOrderHistoryStore store) {\n        _store = store;\n    }\n    // Event handler - updates read model\n    public async Task Handle(OrderPlaced @event) {\n        await _store InsertAsync(new OrderHistoryItem {\n            OrderId = @event OrderId,\n            CustomerId = @event CustomerId,\n            PlacedAt = @event PlacedAt,\n            Total = @event Total,\n            Status = \"Placed\"\n        });\n    }\n    // Event handler - updates read model\n    public async Task Handle(OrderShipped @event) {\n        await _store UpdateAsync(@event OrderId, item => {\n            item ShippedAt = @event ShippedAt;\n            item Status = \"Shipped\";\n        });\n    }\n    // Event handler - updates read model\n    public async Task Handle(OrderCancelled @event) {\n        await _store UpdateAsync(@event OrderId, item => {\n            item",
        "startIndex": 11358,
        "preview": "order GetUncommittedEvents(); // Append to event stream with optimistic concurrency check await _eventStore AppendToStreamAsync( $\"Order-{order Id}\", ..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/core-concepts-chunk-7",
        "text": "handler - updates read model public async Task Handle(OrderShipped @event) { await _store UpdateAsync(@event OrderId, item => { item ShippedAt = @event ShippedAt; item Status = \"Shipped\"; }); } // Event handler - updates read model public async Task Handle(OrderCancelled @event) { await _store UpdateAsync(@event OrderId, item => { item Status = \"Cancelled\";\n        });\n    }\n}\n`\nQuerying Projections\nProjections are queried directly, not through the event store:\n`csharp{\ntitle: \"Querying Order History\"\ndescription: \"How to query projections for read-side data\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Projections\", \"Queries\", \"CQRS\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\npublic class OrderQueryService {\n    private readonly IOrderHistoryStore _store;\n    public OrderQueryService(IOrderHistoryStore store) {\n        _store = store;\n    }\n    public async Task<List<OrderHistoryItem>> GetCustomerOrdersAsync(Guid customerId) {\n        // Query the projection (fast, optimized for reads)\n        return await _store QueryAsync(item => item CustomerId == customerId);\n    }\n    public async Task<OrderHistoryItem> GetOrderDetailsAsync(Guid orderId) {\n        return await _store GetAsync(orderId);\n    }\n}\n`\nProjection Backfilling\nWhen a projection is added to a new service, it can backfill from historical events:\n`csharp{\ntitle: \"Backfilling a Projection\"\ndescription: \"Configure a projection to rebuild from historical events\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Backfilling\", \"Event Sourcing\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\npublic static class ServiceCollectionExtensions {\n    public static IServiceCollection AddOrderProjections(this IServiceCollection services) {\n        services AddProjection<OrderHistoryProjection>(options => {\n            // Subscribe to events from the Orders domain\n            options Subscribe<OrderPlaced>();\n            options Subscribe<OrderShipped>();\n            options Subscribe<OrderCancelled>();\n            // Backfill from the beginning of time\n            options BackfillFrom = DateTimeOffset MinValue;\n            // Process in parallel across order IDs (partitioned by OrderId)\n            options PartitionBy = @event => ((dynamic)@event)",
        "startIndex": 13352,
        "preview": "handler - updates read model public async Task Handle(OrderShipped @event) { await _store UpdateAsync(@event OrderId, item => { item ShippedAt = @even..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/core-concepts-chunk-8",
        "text": "AddOrderProjections(this IServiceCollection services) { services AddProjection<OrderHistoryProjection>(options => { // Subscribe to events from the Orders domain options Subscribe<OrderPlaced>(); options Subscribe<OrderShipped>(); options Subscribe<OrderCancelled>(); // Backfill from the beginning of time options BackfillFrom = DateTimeOffset MinValue; // Process in parallel across order IDs (partitioned by OrderId) options PartitionBy = @event => ((dynamic)@event) OrderId;\n        });\n        return services;\n    }\n}\n`\nWhen this projection starts:\nIt queries the Orders service for all historical OrderPlaced, OrderShipped, and OrderCancelled events\nIt applies them in order to build the initial projection state\nIt continues processing new events as they arrive\nCQRS Pattern\nCQRS (Command Query Responsibility Segregation) separates writes from reads:\nCommands → Aggregates (write side)\nQueries → Projections (read side)\n`text{\ntitle: \"CQRS Architecture Pattern\"\ndescription: \"Visual diagram showing command-query separation with aggregates and projections\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"CQRS\", \"Architecture\", \"Commands\", \"Queries\", \"Projections\"]\nfilename: \"cqrs-diagram txt\"\nshowLineNumbers: false\n}\n     Command                   Event                   Query\n        ↓                        ↓                        ↓\n   ┌─────────┐             ┌──────────┐            ┌──────────┐\n   │Aggregate│ ─Events→    │Event     │ ─Events→   │Projection│\n   │         │             │Store     │            │          │\n   └─────────┘             └──────────┘            └──────────┘\n   Write Model             Source of Truth          Read Model\n   (Normalized)            (Immutable)              (Denormalized)\n`\nBenefits:\nOptimized models - Write and read models can have different schemas\nScalability - Scale reads independently from writes\nFlexibility - Multiple projections can be built from the same events\nNext Steps\nNow that you understand the core concepts, learn how to:\nGet Started - Build your first Whizbang application\nPackage Structure - Choose the right NuGet packages\nDriver System - Understand how to swap persistence and messaging backends",
        "startIndex": 15599,
        "preview": "AddOrderProjections(this IServiceCollection services) { services AddProjection<OrderHistoryProjection>(options => { // Subscribe to events from the Or..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/core-concepts/dispatcher",
    "title": "Dispatcher & Policies",
    "category": "Core Concepts",
    "url": "/docs/old-v1.0.0.0/core-concepts/dispatcher",
    "chunks": [
      {
        "id": "old-v1.0.0.0/core-concepts/dispatcher-chunk-0",
        "text": "Dispatcher & Policies\nOverview\nThe Dispatcher is the central nervous system of Whizbang It coordinates message flow between receptors, perspectives, and lenses, while Policies define how components behave and execute Together, they provide a unified runtime that scales from event-driven development to complex event-sourced systems What is the Dispatcher The Dispatcher:\nRoutes commands to the appropriate receptors\nPublishes events from receptors to interested perspectives\nExecutes queries against lenses\nCoordinates saga workflows\nApplies policies to control behavior\nManages the execution pipeline\nThink of the dispatcher as an intelligent router that understands your domain and ensures messages reach the right destinations Core Dispatcher Responsibilities\nMessage Routing\n`csharp{\ntitle: \"Message Routing\"\ndescription: \"How the dispatcher routes different message types\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Dispatcher\", \"Routing\", \"Messages\"]\nfilename: \"MessageRouting cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class OrderDispatcherExample {\n    private readonly IDispatcher dispatcher;\n    public async Task DemonstrateRouting() {\n        // Commands routed to owning receptors\n        var orderEvent = await dispatcher Send(new CreateOrder( ));\n        // Events published to interested perspectives\n        // OrderPerspective, AnalyticsPerspective, etc all receive the event\n        // Queries executed against lenses\n        var orderLens = dispatcher GetLens<IOrderLens>();\n        var orders = orderLens ViewByCustomer(customerId);\n    }\n}\n`\nReturn Type Interpretation\nThe dispatcher uses return types to determine what happens next:\n`csharp{\ntitle: \"Return Type Semantics\"\ndescription: \"How return types control dispatcher behavior\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Dispatcher\", \"Return Types\", \"Semantics\"]\nfilename: \"ReturnTypeSemantics cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class ReturnTypeExamples {\n    // Single event → Published to perspectives\n    public OrderCreated Receive(CreateOrder cmd) {\n        return new OrderCreated( );\n    }\n    // Multiple events → All published in sequence\n    public (OrderCreated, EmailQueued, InventoryReserved) Receive(PlaceOrder cmd) {\n        return (\n            new OrderCreated( ),\n            new EmailQueued( ),\n            new InventoryReserved(",
        "startIndex": 0,
        "preview": "Dispatcher & Policies\nOverview\nThe Dispatcher is the central nervous system of Whizbang It coordinates message flow between receptors, perspectives, a..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/dispatcher-chunk-1",
        "text": "\"Whizbang\"] showLineNumbers: true } public class ReturnTypeExamples { // Single event → Published to perspectives public OrderCreated Receive(CreateOrder cmd) { return new OrderCreated( ); } // Multiple events → All published in sequence public (OrderCreated, EmailQueued, InventoryReserved) Receive(PlaceOrder cmd) { return ( new OrderCreated( ), new EmailQueued( ), new InventoryReserved( )\n        );\n    }\n    // Result type → Success/failure handling\n    public Result<PaymentProcessed> Receive(ProcessPayment cmd) {\n        if (cmd Amount <= 0) {\n            return Result Failure<PaymentProcessed>(\"Invalid amount\");\n        }\n        return Result Success(new PaymentProcessed( ));\n    }\n    // Void → Fire-and-forget\n    public void Receive(LogActivity cmd) {\n        Console WriteLine(cmd Message);\n    }\n}\n`\nPipeline Coordination\n`csharp{\ntitle: \"Execution Pipeline\"\ndescription: \"The dispatcher coordinates the entire execution pipeline\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"ADVANCED\"\ntags: [\"Dispatcher\", \"Pipeline\", \"Coordination\"]\nfilename: \"ExecutionPipeline cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\n// Simplified view of dispatcher pipeline\npublic class DispatcherPipeline {\n    public async Task<TResult> Execute<TResult>(object message) {\n        // 1 Apply pre-execution policies\n        await ApplyPolicies(message, PolicyStage PreExecution);\n        // 2 Route to appropriate receptor\n        var receptor = ResolveReceptor(message);\n        // 3 Execute receptor with lens injection\n        var result = await ExecuteReceptor(receptor, message);\n        // 4 Handle return value based on type\n        await ProcessReturnValue(result);\n        // 5 Apply post-execution policies\n        await ApplyPolicies(message, PolicyStage PostExecution);\n        return (TResult)result;\n    }\n}\n`\nPolicies\nPolicies define how the dispatcher and components behave They control execution strategies, error handling, performance characteristics, and more Policy Types\nExecution Policies\nControl how and when receptors execute:\n`csharp{\ntitle: \"Execution Policies\"\ndescription: \"Policies that control receptor execution behavior\"\nframework: \"NET8\"\ncategory: \"Policies\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Policies\", \"Execution\", \"Configuration\"]\nfilename: \"ExecutionPolicies cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\nservices AddWhizbang(dispatcher => {\n    // Event-driven execution policy\n    dispatcher ForReceptor<OrderReceptor>() UsePolicy(new EventDrivenPolicy {\n            ExecutionMode = ExecutionMode Synchronous,\n            MaxConcurrency = 1,\n            Timeout = TimeSpan FromSeconds(30)\n        });\n    // Event-sourced execution policy\n    dispatcher ForReceptor<PaymentReceptor>()",
        "startIndex": 2488,
        "preview": "\"Whizbang\"] showLineNumbers: true } public class ReturnTypeExamples { // Single event → Published to perspectives public OrderCreated Receive(CreateOr..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/dispatcher-chunk-2",
        "text": "framework: \"NET8\" category: \"Policies\" difficulty: \"INTERMEDIATE\" tags: [\"Policies\", \"Execution\", \"Configuration\"] filename: \"ExecutionPolicies cs\" usingStatements: [\"System\", \"Whizbang\"] showLineNumbers: true } services AddWhizbang(dispatcher => { // Event-driven execution policy dispatcher ForReceptor<OrderReceptor>() UsePolicy(new EventDrivenPolicy { ExecutionMode = ExecutionMode Synchronous, MaxConcurrency = 1, Timeout = TimeSpan FromSeconds(30) }); // Event-sourced execution policy dispatcher ForReceptor<PaymentReceptor>() UsePolicy(new EventSourcedPolicy {\n            SnapshotFrequency = 100,\n            CacheDuration = TimeSpan FromMinutes(5),\n            ReplayOptimization = true\n        });\n});\n`\nResilience Policies\nHandle failures and ensure reliability:\n`csharp{\ntitle: \"Resilience Policies\"\ndescription: \"Policies for handling failures and ensuring reliability\"\nframework: \"NET8\"\ncategory: \"Policies\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Policies\", \"Resilience\", \"Error Handling\"]\nfilename: \"ResiliencePolicies cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\ndispatcher ForReceptor<PaymentReceptor>() UsePolicy(new ResiliencePolicy {\n        RetryCount = 3,\n        RetryBackoff = BackoffStrategy Exponential,\n        CircuitBreakerThreshold = 5,\n        CircuitBreakerDuration = TimeSpan FromMinutes(1),\n        FallbackAction = FallbackAction DeadLetter\n    });\n// Perspective resilience\ndispatcher Perspectives UsePolicy(new PerspectiveResiliencePolicy {\n        RetryCount = 5,\n        RetryBackoff = BackoffStrategy Linear,\n        DeadLetterAfter = 10,\n        BatchSize = 50\n    });\n`\nPerformance Policies\nOptimize for throughput and latency:\n`csharp{\ntitle: \"Performance Policies\"\ndescription: \"Policies for optimizing performance characteristics\"\nframework: \"NET8\"\ncategory: \"Policies\"\ndifficulty: \"ADVANCED\"\ntags: [\"Policies\", \"Performance\", \"Optimization\"]\nfilename: \"PerformancePolicies cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\ndispatcher ForReceptor<HighVolumeReceptor>() UsePolicy(new PerformancePolicy {\n        // Enable object pooling\n        UseObjectPooling = true,\n        PoolSize = 100,\n        // Batching configuration\n        EnableBatching = true,\n        BatchSize = 50,\n        BatchTimeout = TimeSpan FromMilliseconds(100),\n        // Caching configuration\n        EnableCaching = true,\n        CacheSize = 1000,\n        CacheTTL = TimeSpan FromMinutes(5)\n    });\n`\nSecurity Policies\nControl access and enforce authorization:\n`csharp{\ntitle: \"Security Policies\"\ndescription: \"Policies for access control and authorization\"\nframework: \"NET8\"\ncategory: \"Policies\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Policies\", \"Security\", \"Authorization\"]\nfilename: \"SecurityPolicies cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\ndispatcher ForReceptor<SensitiveReceptor>() UsePolicy(new SecurityPolicy {\n        RequireAuthentication = true,\n        RequiredRoles = new[] { \"Admin\", \"Manager\" },\n        RequiredPermissions = new[] { \"orders:create\", \"payments:process\" },\n        AuditLevel = AuditLevel",
        "startIndex": 4902,
        "preview": "framework: \"NET8\" category: \"Policies\" difficulty: \"INTERMEDIATE\" tags: [\"Policies\", \"Execution\", \"Configuration\"] filename: \"ExecutionPolicies cs\" us..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/dispatcher-chunk-3",
        "text": "\"Policies for access control and authorization\" framework: \"NET8\" category: \"Policies\" difficulty: \"INTERMEDIATE\" tags: [\"Policies\", \"Security\", \"Authorization\"] filename: \"SecurityPolicies cs\" usingStatements: [\"System\", \"Whizbang\"] showLineNumbers: true } dispatcher ForReceptor<SensitiveReceptor>() UsePolicy(new SecurityPolicy { RequireAuthentication = true, RequiredRoles = new[] { \"Admin\", \"Manager\" }, RequiredPermissions = new[] { \"orders:create\", \"payments:process\" }, AuditLevel = AuditLevel Full,\n        EncryptSensitiveData = true\n    });\n// Multi-tenant security\ndispatcher UseTenantIsolation(tenant => {\n    tenant IsolateEventStreams = true;\n    tenant IsolatePerspectives = true;\n    tenant RequireTenantScope = true;\n});\n`\nPolicy Configuration Patterns\nGlobal Policies\nApply to all components:\n`csharp{\ntitle: \"Global Policy Configuration\"\ndescription: \"Applying policies globally across all components\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Policies\", \"Global\", \"Configuration\"]\nfilename: \"GlobalPolicies cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\nservices AddWhizbang(dispatcher => {\n    // Global logging policy\n    dispatcher UseGlobalPolicy(new LoggingPolicy {\n        LogLevel = LogLevel Information,\n        IncludePerformanceMetrics = true,\n        IncludePayload = false // For security\n    });\n    // Global resilience policy\n    dispatcher UseGlobalPolicy(new GlobalResiliencePolicy {\n        DefaultRetryCount = 3,\n        DefaultTimeout = TimeSpan FromSeconds(30),\n        EnableCircuitBreaker = true\n    });\n});\n`\nComponent-Specific Policies\nApply to specific receptors, perspectives, or lenses:\n`csharp{\ntitle: \"Component-Specific Policies\"\ndescription: \"Applying policies to specific components\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Policies\", \"Component-Specific\", \"Configuration\"]\nfilename: \"ComponentPolicies cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\nservices AddWhizbang(dispatcher => {\n    // Receptor-specific policies\n    dispatcher ForReceptor<OrderReceptor>() UseEventSourcedPolicy() WithSnapshotting(frequency: 50) WithCaching(duration: TimeSpan FromMinutes(10));\n    // Perspective-specific policies\n    dispatcher ForPerspective<AnalyticsPerspective>() UseAsyncExecution() WithBatching(size: 100) WithLowPriority();\n    // Lens-specific policies\n    dispatcher ForLens<IOrderLens>() UseCaching(duration: TimeSpan FromMinutes(5)) WithReadReplica();\n});\n`\nConditional Policies\nApply policies based on runtime conditions:\n`csharp{\ntitle: \"Conditional Policy Application\"\ndescription: \"Applying policies based on runtime conditions\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Policies\", \"Conditional\", \"Runtime\"]\nfilename: \"ConditionalPolicies cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\ndispatcher UseConditionalPolicy(context => {\n    // Apply different policies based on message type\n    if (context Message is HighPriorityCommand) {\n        return new HighPriorityPolicy {\n            MaxLatency = TimeSpan",
        "startIndex": 7493,
        "preview": "\"Policies for access control and authorization\" framework: \"NET8\" category: \"Policies\" difficulty: \"INTERMEDIATE\" tags: [\"Policies\", \"Security\", \"Auth..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/dispatcher-chunk-4",
        "text": "\"Applying policies based on runtime conditions\" framework: \"NET8\" category: \"Configuration\" difficulty: \"ADVANCED\" tags: [\"Policies\", \"Conditional\", \"Runtime\"] filename: \"ConditionalPolicies cs\" usingStatements: [\"System\", \"Whizbang\"] showLineNumbers: true } dispatcher UseConditionalPolicy(context => { // Apply different policies based on message type if (context Message is HighPriorityCommand) { return new HighPriorityPolicy { MaxLatency = TimeSpan FromMilliseconds(100),\n            PreferredThreads = 4\n        };\n    }\n    // Apply policies based on tenant\n    if (context TenantId == \"enterprise-customer\") {\n        return new EnterprisePolicy {\n            SLA = TimeSpan FromSeconds(1),\n            BackupReplicas = 3\n        };\n    }\n    return new StandardPolicy();\n});\n`\nPolicy Composition\nPolicies can be composed and layered:\n`csharp{\ntitle: \"Policy Composition\"\ndescription: \"Composing multiple policies for complex behavior\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Policies\", \"Composition\", \"Layering\"]\nfilename: \"PolicyComposition cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\ndispatcher ForReceptor<CriticalReceptor>() UsePolicy(new SecurityPolicy { RequireAuthentication = true }) UsePolicy(new PerformancePolicy { EnableCaching = true }) UsePolicy(new ResiliencePolicy { RetryCount = 5 }) UsePolicy(new AuditPolicy { LogLevel = AuditLevel Full }) UsePolicy(new CompliancePolicy { EncryptData = true });\n// Policies are applied in order, with later policies able to override earlier ones\n`\nDispatcher Modes\nThe dispatcher supports different execution modes:\nEvent-Driven Mode\n`csharp{\ntitle: \"Event-Driven Mode Configuration\"\ndescription: \"Configuring the dispatcher for event-driven execution\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Dispatcher\", \"Event-Driven\", \"Configuration\"]\nfilename: \"EventDrivenMode cs\"\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nservices AddWhizbang(dispatcher => {\n    // Event-driven mode with stateless receptors\n    dispatcher UseEventDrivenMode(options => {\n        options DefaultExecutionMode = ExecutionMode Synchronous;\n        options EnablePerspectivePersistence = true;\n        options MaxConcurrentReceptors = Environment ProcessorCount;\n    });\n    // Perspective configuration\n    dispatcher Perspectives UsePostgreSQL(connectionString) WithBatching(size: 50) WithRetry(count: 3);\n});\n`\nEvent-Sourced Mode\n`csharp{\ntitle: \"Event-Sourced Mode Configuration\"\ndescription: \"Configuring the dispatcher for event sourcing\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Dispatcher\", \"Event-Sourced\", \"Configuration\"]\nfilename: \"EventSourcedMode cs\"\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nservices",
        "startIndex": 10206,
        "preview": "\"Applying policies based on runtime conditions\" framework: \"NET8\" category: \"Configuration\" difficulty: \"ADVANCED\" tags: [\"Policies\", \"Conditional\", \"..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/dispatcher-chunk-5",
        "text": "ProcessorCount; }); // Perspective configuration dispatcher Perspectives UsePostgreSQL(connectionString) WithBatching(size: 50) WithRetry(count: 3); }); ` Event-Sourced Mode `csharp{ title: \"Event-Sourced Mode Configuration\" description: \"Configuring the dispatcher for event sourcing\" framework: \"NET8\" category: \"Configuration\" difficulty: \"ADVANCED\" tags: [\"Dispatcher\", \"Event-Sourced\", \"Configuration\"] filename: \"EventSourcedMode cs\" usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"] showLineNumbers: true } services AddWhizbang(dispatcher => {\n    // Event-sourced mode with stateful receptors\n    dispatcher UseEventSourcing(es => {\n        es UseLedger(ledger => {\n            ledger UsePostgreSQL(connectionString);\n            ledger EnableSnapshots(frequency: 100);\n            ledger ConfigurePartitioning(partitions: 8);\n        });\n        es EnableTimeTravel();\n        es EnableReplay();\n    });\n    // Receptor policies for event sourcing\n    dispatcher UseGlobalPolicy(new EventSourcedPolicy {\n        DefaultSnapshotFrequency = 50,\n        DefaultCacheDuration = TimeSpan FromMinutes(5)\n    });\n});\n`\nDistributed Mode\n`csharp{\ntitle: \"Distributed Mode Configuration\"\ndescription: \"Configuring the dispatcher for distributed execution\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Dispatcher\", \"Distributed\", \"Configuration\"]\nfilename: \"DistributedMode cs\"\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nservices AddWhizbang(dispatcher => {\n    // Distributed mode with relays\n    dispatcher UseRelays(relays => {\n        relays UseKafka(kafka => {\n            kafka BootstrapServers = \"localhost:9092\";\n            kafka EnableIdempotence = true;\n            kafka Partitions = 12;\n        });\n    });\n    // Service ownership configuration\n    dispatcher ConfigureDomain(\"Orders\", domain => {\n        domain OwnsReceptor<OrderReceptor>();\n        domain PublishesEvents<OrderCreated, OrderShipped>();\n        domain SubscribesToEvents<PaymentProcessed, InventoryReserved>();\n    });\n});\n`\nPolicy Best Practices\nDo's\n✅ Start with sensible defaults\n`csharp{\ntitle: \"Sensible Defaults Pattern\"\ndescription: \"Start with framework defaults and override only what's needed\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Policies\", \"Configuration\", \"Best Practices\"]\nfilename: \"DefaultPolicies cs\"\nusingStatements: [\"Whizbang\"]\n}\n// Use framework defaults first\ndispatcher UseDefaults();\n// Override only what you need\ndispatcher ForReceptor<SpecialReceptor>() UseCustomPolicy(mySpecialPolicy);\n`\n✅ Layer policies logically\n`csharp{\ntitle: \"Policy Layering Pattern\"\ndescription: \"Layer policies from general to specific\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Policies\", \"Layering\", \"Best Practices\"]\nfilename: \"PolicyLayering cs\"\nusingStatements: [\"Whizbang\"]\n}\n// Layer from general to specific\ndispatcher UseGlobalPolicy(globalSecurity) ForReceptor<PaymentReceptor>()",
        "startIndex": 12697,
        "preview": "ProcessorCount; }); // Perspective configuration dispatcher Perspectives UsePostgreSQL(connectionString) WithBatching(size: 50) WithRetry(count: 3); }..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/dispatcher-chunk-6",
        "text": "what you need dispatcher ForReceptor<SpecialReceptor>() UseCustomPolicy(mySpecialPolicy); ` ✅ Layer policies logically `csharp{ title: \"Policy Layering Pattern\" description: \"Layer policies from general to specific\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"INTERMEDIATE\" tags: [\"Policies\", \"Layering\", \"Best Practices\"] filename: \"PolicyLayering cs\" usingStatements: [\"Whizbang\"] } // Layer from general to specific dispatcher UseGlobalPolicy(globalSecurity) ForReceptor<PaymentReceptor>() UsePolicy(paymentSpecificSecurity);\n`\n✅ Test policy behavior\n`csharp{\ntitle: \"Policy Testing Pattern\"\ndescription: \"Test that policies are applied correctly\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Testing\", \"Policies\", \"Verification\"]\nfilename: \"PolicyTests cs\"\nusingStatements: [\"Xunit\", \"Whizbang\"]\n}\n[Fact]\npublic async Task PolicyAppliesCorrectly() {\n    var dispatcher = CreateTestDispatcher() WithPolicy(testPolicy);\n    // Verify policy behavior\n    var result = await dispatcher Send(testCommand);\n    Assert True(testPolicy WasApplied);\n}\n`\nDon'ts\n❌ Don't over-configure\n`csharp{\ntitle: \"Anti-Pattern: Over-Configuration\"\ndescription: \"Don't add too many policies to simple components\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Anti-Pattern\", \"Over-Configuration\", \"Policies\"]\nfilename: \"OverConfiguration cs\"\nusingStatements: [\"Whizbang\"]\n}\n// BAD - Too many specific policies\ndispatcher ForReceptor<SimpleReceptor>() UsePolicy(policy1) UsePolicy(policy2) UsePolicy(policy3) UsePolicy(policy4); // Overkill for simple receptors\n`\n❌ Don't ignore policy conflicts\n`csharp{\ntitle: \"Anti-Pattern: Policy Conflicts\"\ndescription: \"Don't create conflicting policy configurations\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Anti-Pattern\", \"Policy Conflicts\", \"Configuration\"]\nfilename: \"PolicyConflicts cs\"\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// BAD - Conflicting timeout policies\ndispatcher UseGlobalPolicy(new TimeoutPolicy { Timeout = TimeSpan FromSeconds(30) }) ForReceptor<MyReceptor>() UsePolicy(new TimeoutPolicy { Timeout = TimeSpan FromSeconds(5) }); // Which one wins `\nSummary\nThe Dispatcher and Policies system provides:\nUnified coordination of all message flow\nFlexible execution strategies through policies\nProgressive enhancement from simple to complex\nFine-grained control over behavior and performance\nComposition of multiple policies for complex scenarios\nThe dispatcher ensures that receptors, perspectives, and lenses work together seamlessly, while policies give you precise control over how they behave",
        "startIndex": 15229,
        "preview": "what you need dispatcher ForReceptor<SpecialReceptor>() UseCustomPolicy(mySpecialPolicy); ` ✅ Layer policies logically `csharp{ title: \"Policy Layerin..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/dispatcher-chunk-7",
        "text": "coordination of all message flow Flexible execution strategies through policies Progressive enhancement from simple to complex Fine-grained control over behavior and performance Composition of multiple policies for complex scenarios The dispatcher ensures that receptors, perspectives, and lenses work together seamlessly, while policies give you precise control over how they behave Next Steps\nExplore Receptors - Decision-making components\nLearn about Perspectives - Event handlers and read models\nSee Lenses - Read-only query interfaces\nReview Event-Driven Architecture - The bigger picture",
        "startIndex": 17417,
        "preview": "coordination of all message flow Flexible execution strategies through policies Progressive enhancement from simple to complex Fine-grained control ov..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/core-concepts/lenses",
    "title": "Lenses",
    "category": "Core Concepts",
    "url": "/docs/old-v1.0.0.0/core-concepts/lenses",
    "chunks": [
      {
        "id": "old-v1.0.0.0/core-concepts/lenses-chunk-0",
        "text": "Lenses\nOverview\nLenses provide focused, read-only views into your data They are the query side of Whizbang's CQRS implementation, offering a clean separation between reads and writes Lenses work consistently across Event-Driven and Event-Sourced modes, always providing the current view of data regardless of how it's stored What is a Lens A Lens:\nProvides read-only access to data\nFocuses on specific query needs\nNever modifies state\nAbstracts the underlying storage mechanism\nThink of a lens as a window into your data - you can look through it from different angles to see different views, but you can't reach through it to change what you see The Lens Interface Pattern\n`csharp{\ntitle: \"Order Lens Interface\"\ndescription: \"Basic lens interface pattern with core query methods\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Lenses\", \"Interfaces\", \"CQRS\"]\nfilename: \"IOrderLens cs\"\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq Expressions\"]\nshowLineNumbers: true\n}\npublic interface IOrderLens {\n    // Focus on a single item\n    Order Focus(Guid id);\n    // View a filtered collection\n    IEnumerable<Order> View(Expression<Func<Order, bool>> filter);\n    // Glimpse a summary or partial view\n    OrderSummary Glimpse(Guid id);\n    // Check existence\n    bool Exists(Guid id);\n    // Scan all items (use sparingly)\n    IEnumerable<Order> Scan();\n}\n`\nCore Lens Methods\nFocus - Single Item Retrieval\n`csharp{\ntitle: \"Customer Lens Focus Method\"\ndescription: \"Implementing the Focus method for single item retrieval\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Lenses\", \"Focus\", \"Single Item\"]\nfilename: \"CustomerLens cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Linq\"]\nshowLineNumbers: true\n}\npublic interface ICustomerLens {\n    Customer Focus(Guid customerId);\n    Task<Customer> FocusAsync(Guid customerId);\n}\n// Implementation\npublic class CustomerLens : ICustomerLens {\n    private readonly IDatabase db;\n    public Customer Focus(Guid customerId) {\n        return db Customers FirstOrDefault(c => c",
        "startIndex": 0,
        "preview": "Lenses\nOverview\nLenses provide focused, read-only views into your data They are the query side of Whizbang's CQRS implementation, offering a clean sep..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/lenses-chunk-1",
        "text": "\"Focus\", \"Single Item\"] filename: \"CustomerLens cs\" usingStatements: [\"System\", \"System Threading Tasks\", \"System Linq\"] showLineNumbers: true } public interface ICustomerLens { Customer Focus(Guid customerId); Task<Customer> FocusAsync(Guid customerId); } // Implementation public class CustomerLens : ICustomerLens { private readonly IDatabase db; public Customer Focus(Guid customerId) { return db Customers FirstOrDefault(c => c Id == customerId);\n    }\n}\n`\nView - Filtered Collections\n`csharp{\ntitle: \"Order Lens View Methods\"\ndescription: \"Implementing View methods for filtered collections\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Lenses\", \"View\", \"Filtering\"]\nfilename: \"OrderLens cs\"\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq Expressions\", \"System Linq\"]\nshowLineNumbers: true\n}\npublic interface IOrderLens {\n    IEnumerable<Order> View(Expression<Func<Order, bool>> filter);\n    IEnumerable<Order> ViewByCustomer(Guid customerId);\n    IEnumerable<Order> ViewByStatus(OrderStatus status);\n}\n// Implementation\npublic class OrderLens : IOrderLens {\n    public IEnumerable<Order> View(Expression<Func<Order, bool>> filter) {\n        return db Orders Where(filter);\n    }\n    public IEnumerable<Order> ViewByCustomer(Guid customerId) {\n        return db Orders Where(o => o CustomerId == customerId);\n    }\n}\n`\nGlimpse - Summaries and Projections\n`csharp{\ntitle: \"Inventory Lens Glimpse Methods\"\ndescription: \"Implementing Glimpse methods for summaries and projections\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Glimpse\", \"Inventory\", \"Summaries\"]\nfilename: \"InventoryLens cs\"\nusingStatements: [\"System\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\npublic interface IInventoryLens {\n    InventorySummary Glimpse(Guid productId);\n    StockLevel GlimpseStock(Guid productId);\n    IEnumerable<LowStockItem> GlimpseLowStock();\n}\n// Implementation  \npublic class InventoryLens : IInventoryLens {\n    public InventorySummary Glimpse(Guid productId) {\n        var product = db Products Find(productId);\n        return new InventorySummary {\n            ProductId = product Id,\n            Name = product Name,\n            InStock = product Quantity,\n            Reserved = product ReservedQuantity,\n            Available = product Quantity - product ReservedQuantity\n        };\n    }\n}\n`\nExists - Efficient Existence Checks\n`csharp{\ntitle: \"Product Lens Exists Methods\"\ndescription: \"Efficient existence checks with conditions\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Lenses\", \"Exists\", \"Efficiency\"]\nfilename: \"ProductLens cs\"\nusingStatements: [\"System\", \"System Linq Expressions\", \"System",
        "startIndex": 2117,
        "preview": "\"Focus\", \"Single Item\"] filename: \"CustomerLens cs\" usingStatements: [\"System\", \"System Threading Tasks\", \"System Linq\"] showLineNumbers: true } publi..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/lenses-chunk-2",
        "text": "product ReservedQuantity, Available = product Quantity - product ReservedQuantity }; } } ` Exists - Efficient Existence Checks `csharp{ title: \"Product Lens Exists Methods\" description: \"Efficient existence checks with conditions\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"BEGINNER\" tags: [\"Lenses\", \"Exists\", \"Efficiency\"] filename: \"ProductLens cs\" usingStatements: [\"System\", \"System Linq Expressions\", \"System Linq\"]\nshowLineNumbers: true\n}\npublic interface IProductLens {\n    bool Exists(Guid productId);\n    bool Exists(Expression<Func<Product, bool>> condition);\n}\n// Implementation\npublic class ProductLens : IProductLens {\n    public bool Exists(Guid productId) {\n        return db Products Any(p => p Id == productId);\n    }\n    public bool Exists(Expression<Func<Product, bool>> condition) {\n        return db Products Any(condition);\n    }\n}\n`\nLens Usage in Receptors\nLenses provide state for stateless receptors:\n`csharp{\ntitle: \"Lens Usage in Receptors\"\ndescription: \"Using lenses to provide state for stateless receptors\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Receptors\", \"Validation\"]\nfilename: \"OrderReceptor cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class OrderReceptor : IReceptor<CreateOrder> {\n    public OrderCreated Receive(CreateOrder cmd, IOrderLens orderLens, ICustomerLens customerLens) {\n        // Use lenses to validate\n        if ( customerLens Exists(cmd CustomerId)) {\n            throw new CustomerNotFoundException();\n        }\n        var customer = customerLens Focus(cmd CustomerId);\n        if ( customer IsActive) {\n            throw new InactiveCustomerException();\n        }\n        // Check for duplicate orders\n        if (orderLens Exists(o => o CustomerId == cmd CustomerId && o IsPending)) {\n            throw new PendingOrderExistsException();\n        }\n        // Make decision based on lens data\n        return new OrderCreated(\n            Guid NewGuid(),\n            cmd CustomerId,\n            cmd Items,\n            CalculateTotal(cmd Items, customer Tier)\n        );\n    }\n}\n`\nComposite Lenses\nCombine multiple data sources into a unified view:\n`csharp{\ntitle: \"Composite Checkout Lens\"\ndescription: \"Combining multiple data sources into a unified view for checkout\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Composite\", \"Checkout\"]\nfilename: \"CheckoutLens cs\"\nusingStatements: [\"System\", \"System Collections",
        "startIndex": 4429,
        "preview": "product ReservedQuantity, Available = product Quantity - product ReservedQuantity }; } } ` Exists - Efficient Existence Checks `csharp{ title: \"Produc..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/lenses-chunk-3",
        "text": "customer Tier) ); } } ` Composite Lenses Combine multiple data sources into a unified view: `csharp{ title: \"Composite Checkout Lens\" description: \"Combining multiple data sources into a unified view for checkout\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"INTERMEDIATE\" tags: [\"Lenses\", \"Composite\", \"Checkout\"] filename: \"CheckoutLens cs\" usingStatements: [\"System\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\npublic interface ICheckoutLens {\n    CheckoutContext PrepareCheckout(Guid customerId, List<CartItem> items);\n}\npublic class CheckoutLens : ICheckoutLens {\n    private readonly ICustomerLens customerLens;\n    private readonly IInventoryLens inventoryLens;\n    private readonly IPromotionLens promotionLens;\n    private readonly ITaxLens taxLens;\n    public CheckoutContext PrepareCheckout(Guid customerId, List<CartItem> items) {\n        var customer = customerLens Focus(customerId);\n        var inventory = inventoryLens CheckAvailability(items);\n        var promotions = promotionLens GetApplicable(customer, items);\n        var tax = taxLens Calculate(customer Address, items);\n        return new CheckoutContext {\n            Customer = customer,\n            Items = items,\n            InventoryStatus = inventory,\n            AppliedPromotions = promotions,\n            TaxAmount = tax,\n            Total = CalculateTotal(items, promotions, tax)\n        };\n    }\n}\n`\nCached Lenses\nOptimize read performance with caching:\n`csharp{\ntitle: \"Cached Product Lens\"\ndescription: \"Optimizing read performance with caching decorator pattern\"\nframework: \"NET8\"\ncategory: \"Performance\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Caching\", \"Performance\"]\nfilename: \"CachedProductLens cs\"\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq\"]\nshowLineNumbers: true\n}\npublic class CachedProductLens : IProductLens {\n    private readonly IProductLens innerLens;\n    private readonly ICache cache;\n    public Product Focus(Guid productId) {\n        var cacheKey = $\"product:{productId}\";\n        return cache GetOrSet(cacheKey, () => {\n            return innerLens Focus(productId);\n        }, TimeSpan FromMinutes(5));\n    }\n    public IEnumerable<Product> ViewByCategory(string category) {\n        var cacheKey = $\"products:category:{category}\";\n        return cache GetOrSet(cacheKey, () => {\n            return innerLens ViewByCategory(category) ToList();\n        }, TimeSpan FromMinutes(1));\n    }\n}\n`\nPaged Queries\nSupport pagination for large result sets:\n`csharp{\ntitle: \"Paged Query Lens\"\ndescription: \"Supporting pagination for large result sets\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Pagination\", \"Performance\"]\nfilename: \"OrderLens cs\"\nusingStatements: [\"System\", \"System Linq\", \"System Linq",
        "startIndex": 6510,
        "preview": "customer Tier) ); } } ` Composite Lenses Combine multiple data sources into a unified view: `csharp{ title: \"Composite Checkout Lens\" description: \"Co..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/lenses-chunk-4",
        "text": "return innerLens ViewByCategory(category) ToList(); }, TimeSpan FromMinutes(1)); } } ` Paged Queries Support pagination for large result sets: `csharp{ title: \"Paged Query Lens\" description: \"Supporting pagination for large result sets\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"INTERMEDIATE\" tags: [\"Lenses\", \"Pagination\", \"Performance\"] filename: \"OrderLens cs\" usingStatements: [\"System\", \"System Linq\", \"System Linq Expressions\"]\nshowLineNumbers: true\n}\npublic interface IOrderLens {\n    PagedResult<Order> ViewPaged(int page, int pageSize, Expression<Func<Order, bool>> filter = null);\n}\npublic class OrderLens : IOrderLens {\n    public PagedResult<Order> ViewPaged(int page, int pageSize, Expression<Func<Order, bool>> filter = null) {\n        var query = db Orders AsQueryable();\n        if (filter = null) {\n            query = query Where(filter);\n        }\n        var totalCount = query Count();\n        var items = query OrderByDescending(o => o CreatedAt) Skip((page - 1) * pageSize) Take(pageSize) ToList();\n        return new PagedResult<Order> {\n            Items = items,\n            Page = page,\n            PageSize = pageSize,\n            TotalCount = totalCount,\n            TotalPages = (int)Math Ceiling(totalCount / (double)pageSize)\n        };\n    }\n}\n`\nAggregate Queries\nProvide pre-calculated aggregations:\n`csharp{\ntitle: \"Statistics Aggregate Lens\"\ndescription: \"Providing pre-calculated aggregations and metrics\"\nframework: \"NET8\"\ncategory: \"Analytics\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Statistics\", \"Aggregation\"]\nfilename: \"StatisticsLens cs\"\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq\"]\nshowLineNumbers: true\n}\npublic interface IStatisticsLens {\n    OrderStatistics GetOrderStats(DateTime from, DateTime to);\n    CustomerMetrics GetCustomerMetrics(Guid customerId);\n    IEnumerable<TopProduct> GetTopProducts(int count);\n}\npublic class StatisticsLens : IStatisticsLens {\n    public OrderStatistics GetOrderStats(DateTime from, DateTime to) {\n        var orders = db Orders Where(o => o CreatedAt >= from && o CreatedAt <= to);\n        return new OrderStatistics {\n            TotalOrders = orders Count(),\n            TotalRevenue = orders Sum(o => o Total),\n            AverageOrderValue = orders Average(o => o Total),\n            OrdersByStatus = orders GroupBy(o => o Status) Select(g => new StatusCount { \n                    Status = g Key, \n                    Count = g Count() \n                })",
        "startIndex": 8909,
        "preview": "return innerLens ViewByCategory(category) ToList(); }, TimeSpan FromMinutes(1)); } } ` Paged Queries Support pagination for large result sets: `csharp..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/lenses-chunk-5",
        "text": ">= from && o CreatedAt <= to); return new OrderStatistics { TotalOrders = orders Count(), TotalRevenue = orders Sum(o => o Total), AverageOrderValue = orders Average(o => o Total), OrdersByStatus = orders GroupBy(o => o Status) Select(g => new StatusCount { Status = g Key, Count = g Count() }) ToList()\n        };\n    }\n}\n`\nSearch Lenses\nIntegrate with search infrastructure:\n`csharp{\ntitle: \"ElasticSearch Lens\"\ndescription: \"Integrating with search infrastructure for advanced queries\"\nframework: \"NET8\"\ncategory: \"Search\"\ndifficulty: \"ADVANCED\"\ntags: [\"Lenses\", \"Search\", \"ElasticSearch\"]\nfilename: \"ElasticSearchLens cs\"\nnugetPackages: [\"Elasticsearch Net\", \"NEST\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"Nest\"]\nshowLineNumbers: true\n}\npublic interface ISearchLens {\n    SearchResults<Product> SearchProducts(string query, SearchOptions options);\n    IEnumerable<SearchSuggestion> GetSuggestions(string prefix);\n}\npublic class ElasticSearchLens : ISearchLens {\n    private readonly IElasticClient elastic;\n    public SearchResults<Product> SearchProducts(string query, SearchOptions options) {\n        var searchRequest = new SearchRequest<Product> {\n            Query = new MultiMatchQuery {\n                Query = query,\n                Fields = new[] { \"name\", \"description\", \"category\" }\n            },\n            From = options Offset,\n            Size = options Limit,\n            Aggregations = new TermsAggregation(\"categories\") {\n                Field = \"category keyword\"\n            }\n        };\n        var response = elastic Search<Product>(searchRequest);\n        return new SearchResults<Product> {\n            Items = response Documents,\n            TotalCount = response Total,\n            Facets = ExtractFacets(response Aggregations),\n            HighlightedTerms = ExtractHighlights(response Hits)\n        };\n    }\n}\n`\nLens Configuration\nConfigure lenses with the dispatcher:\n`csharp{\ntitle: \"Lens Configuration\"\ndescription: \"Configuring lenses with the Whizbang dispatcher\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Configuration\", \"Dependency Injection\"]\nfilename: \"Program cs\"\nnugetPackages: [\"Whizbang Core\", \"Microsoft Extensions DependencyInjection\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nservices AddWhizbang() UseDispatcher(dispatcher => {\n        // Register lenses\n        dispatcher RegisterLensesFromAssembly(typeof(Program) Assembly);\n        // Configure caching for all lenses\n        dispatcher Lenses EnableCaching(TimeSpan FromMinutes(5)) UseCacheProvider<RedisCache>();\n        // Specific lens configuration\n        dispatcher ForLens<IProductLens>() UseCaching(TimeSpan FromMinutes(10)) WithImplementation<CachedProductLens>();\n    });\n// Manual registration\nservices AddScoped<IOrderLens, OrderLens>();\nservices AddScoped<ICustomerLens, CustomerLens>();\nservices",
        "startIndex": 11037,
        "preview": ">= from && o CreatedAt <= to); return new OrderStatistics { TotalOrders = orders Count(), TotalRevenue = orders Sum(o => o Total), AverageOrderValue =..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/lenses-chunk-6",
        "text": "usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"] showLineNumbers: true } services AddWhizbang() UseDispatcher(dispatcher => { // Register lenses dispatcher RegisterLensesFromAssembly(typeof(Program) Assembly); // Configure caching for all lenses dispatcher Lenses EnableCaching(TimeSpan FromMinutes(5)) UseCacheProvider<RedisCache>(); // Specific lens configuration dispatcher ForLens<IProductLens>() UseCaching(TimeSpan FromMinutes(10)) WithImplementation<CachedProductLens>(); }); // Manual registration services AddScoped<IOrderLens, OrderLens>(); services AddScoped<ICustomerLens, CustomerLens>(); services Decorate<IProductLens, CachedProductLens>();\n`\nTesting Lenses\nLenses are easy to test and mock:\n`csharp{\ntitle: \"Testing Lenses\"\ndescription: \"Unit testing lenses with in-memory data and mocking\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Testing\", \"Unit Tests\", \"Mocking\"]\nfilename: \"OrderLensTests cs\"\nnugetPackages: [\"xunit\", \"Moq\"]\ntestFile: \"OrderLensTests cs\"\ntestMethod: \"OrderLens_ViewByCustomer_ReturnsCustomerOrders\"\nusingStatements: [\"System\", \"System Linq\", \"Xunit\", \"Moq\"]\nshowLineNumbers: true\n}\n[Fact]\npublic void OrderLens_ViewByCustomer_ReturnsCustomerOrders() {\n    // Arrange\n    var db = new InMemoryDatabase();\n    var customerId = Guid NewGuid();\n    db Orders Add(new Order { CustomerId = customerId });\n    db Orders Add(new Order { CustomerId = customerId });\n    db Orders Add(new Order { CustomerId = Guid NewGuid() });\n    var lens = new OrderLens(db);\n    // Act\n    var orders = lens ViewByCustomer(customerId);\n    // Assert\n    Assert Equal(2, orders Count());\n    Assert All(orders, o => Assert Equal(customerId, o CustomerId));\n}\n// Mocking in receptor tests\n[Fact]\npublic void OrderReceptor_ThrowsException_WhenCustomerNotFound() {\n    // Arrange\n    var customerLens = Mock Of<ICustomerLens>(l => \n        l Exists(It IsAny<Guid>()) == false\n    );\n    var receptor = new OrderReceptor();\n    // Act & Assert\n    Assert Throws<CustomerNotFoundException>(() =>\n        receptor Receive(new CreateOrder(), null, customerLens)\n    );\n}\n`\nBest Practices\nDo's\n✅ Keep lenses read-only\n`csharp{\ntitle: \"Read-Only Lens Interface\"\ndescription: \"Best practice: Keep lenses read-only\"\nframework: \"NET8\"\ncategory: \"Best Practices\"\ndifficulty: \"BEGINNER\"\ntags: [\"Lenses\", \"Best Practices\", \"Read-Only\"]\nfilename: \"IOrderLens",
        "startIndex": 13739,
        "preview": "usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"] showLineNumbers: true } services AddWhizbang() UseDispatcher(dispatcher => {..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/lenses-chunk-7",
        "text": "= new OrderReceptor(); // Act & Assert Assert Throws<CustomerNotFoundException>(() => receptor Receive(new CreateOrder(), null, customerLens) ); } ` Best Practices Do's ✅ Keep lenses read-only `csharp{ title: \"Read-Only Lens Interface\" description: \"Best practice: Keep lenses read-only\" framework: \"NET8\" category: \"Best Practices\" difficulty: \"BEGINNER\" tags: [\"Lenses\", \"Best Practices\", \"Read-Only\"] filename: \"IOrderLens cs\"\nusingStatements: [\"System\"]\n}\npublic interface IOrderLens {\n    Order Focus(Guid id);  // Read-only methods only\n}\n`\n✅ Use specific method names\n`csharp{\ntitle: \"Specific Method Names\"\ndescription: \"Best practice: Use specific method names for clear intent\"\nframework: \"NET8\"\ncategory: \"Best Practices\"\ndifficulty: \"BEGINNER\"\ntags: [\"Lenses\", \"Best Practices\", \"Method Naming\"]\nfilename: \"IOrderLens cs\"\nusingStatements: [\"System\", \"System Collections Generic\"]\n}\nIEnumerable<Order> ViewPending();      // Clear intent\nIEnumerable<Order> ViewByDateRange(DateTime from, DateTime to);\n`\n✅ Optimize for common queries\n`csharp{\ntitle: \"Optimized Common Queries\"\ndescription: \"Best practice: Optimize for common query patterns\"\nframework: \"NET8\"\ncategory: \"Best Practices\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Best Practices\", \"Performance\"]\nfilename: \"ICustomerLens cs\"\nusingStatements: [\"System\"]\n}\n// Pre-calculate common aggregations\nCustomerDashboard GetCustomerDashboard(Guid customerId);\n`\n✅ Return immutable data\n`csharp{\ntitle: \"Return Immutable Data\"\ndescription: \"Best practice: Return immutable data collections\"\nframework: \"NET8\"\ncategory: \"Best Practices\"\ndifficulty: \"BEGINNER\"\ntags: [\"Lenses\", \"Best Practices\", \"Immutable\"]\nfilename: \"OrderLens cs\"\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq\"]\n}\npublic IReadOnlyList<Order> ViewRecent() {\n    return db Orders OrderByDescending(o => o CreatedAt) Take(10) ToList() AsReadOnly();\n}\n`\nDon'ts\n❌ Don't include write operations\n`csharp{\ntitle: \"Anti-Pattern: Write Operations\"\ndescription: \"DON'T include write operations in lenses\"\nframework: \"NET8\"\ncategory: \"Anti-Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Lenses\", \"Anti-Patterns\", \"Read-Only\"]\nfilename: \"IOrderLens cs\"\nusingStatements: [\"System\"]\n}\n// BAD - Lenses are read-only\npublic interface IOrderLens {\n    void Save(Order order);  // Don't do this",
        "startIndex": 15527,
        "preview": "= new OrderReceptor(); // Act & Assert Assert Throws<CustomerNotFoundException>(() => receptor Receive(new CreateOrder(), null, customerLens) ); } ` B..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/lenses-chunk-8",
        "text": "❌ Don't include write operations `csharp{ title: \"Anti-Pattern: Write Operations\" description: \"DON'T include write operations in lenses\" framework: \"NET8\" category: \"Anti-Patterns\" difficulty: \"BEGINNER\" tags: [\"Lenses\", \"Anti-Patterns\", \"Read-Only\"] filename: \"IOrderLens cs\" usingStatements: [\"System\"] } // BAD - Lenses are read-only public interface IOrderLens { void Save(Order order); // Don't do this }\n`\n❌ Don't return mutable entities\n`csharp{\ntitle: \"Mutable vs Immutable Returns\"\ndescription: \"BAD: Mutable entities vs GOOD: Immutable views\"\nframework: \"NET8\"\ncategory: \"Anti-Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Anti-Patterns\", \"Immutable\"]\nfilename: \"OrderLens cs\"\nusingStatements: [\"System\"]\n}\n// BAD - Returns mutable entity\npublic Order Focus(Guid id) {\n    return db Orders Find(id);  // Can be modified\n}\n// GOOD - Return immutable view\npublic OrderView Focus(Guid id) {\n    var order = db Orders Find(id);\n    return new OrderView(order);  // Immutable copy\n}\n`\n❌ Don't perform business logic\n`csharp{\ntitle: \"Anti-Pattern: Business Logic\"\ndescription: \"DON'T perform business logic in lenses\"\nframework: \"NET8\"\ncategory: \"Anti-Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Anti-Patterns\", \"Business Logic\"]\nfilename: \"OrderLens cs\"\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq\"]\n}\n// BAD - Business logic in lens\npublic IEnumerable<Order> ViewDiscounted() {\n    return db Orders Where(o => {\n        if (o Total > 100) {  // Business rule return true;\n        }\n    });\n}\n`\nAdvanced Patterns\nMaterialized View Lenses\nRead from pre-computed materialized views:\n`csharp{\ntitle: \"Materialized View Lens\"\ndescription: \"Reading from pre-computed materialized views\"\nframework: \"NET8\"\ncategory: \"Advanced\"\ndifficulty: \"ADVANCED\"\ntags: [\"Lenses\", \"Materialized Views\", \"Performance\"]\nfilename: \"MaterializedOrderLens cs\"\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq\"]\nshowLineNumbers: true\n}\npublic class MaterializedOrderLens : IOrderLens {\n    // Read from denormalized view maintained by perspectives\n    public OrderSummary Glimpse(Guid orderId) {\n        return db OrderSummaries Find(orderId);  // Pre-computed\n    }\n    public IEnumerable<Order> ViewTopOrders(int count) {\n        return db TopOrdersView",
        "startIndex": 17460,
        "preview": "❌ Don't include write operations `csharp{ title: \"Anti-Pattern: Write Operations\" description: \"DON'T include write operations in lenses\" framework: \"..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/lenses-chunk-9",
        "text": "\"Materialized Views\", \"Performance\"] filename: \"MaterializedOrderLens cs\" usingStatements: [\"System\", \"System Collections Generic\", \"System Linq\"] showLineNumbers: true } public class MaterializedOrderLens : IOrderLens { // Read from denormalized view maintained by perspectives public OrderSummary Glimpse(Guid orderId) { return db OrderSummaries Find(orderId); // Pre-computed } public IEnumerable<Order> ViewTopOrders(int count) { return db TopOrdersView Take(count);  // Maintained by perspective\n    }\n}\n`\nCross-Service Lenses\nQuery data from multiple services:\n`csharp{\ntitle: \"Cross-Service Lens\"\ndescription: \"Querying data from multiple distributed services\"\nframework: \"NET8\"\ncategory: \"Advanced\"\ndifficulty: \"ADVANCED\"\ntags: [\"Lenses\", \"Distributed\", \"Microservices\"]\nfilename: \"DistributedCustomerLens cs\"\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\npublic class DistributedCustomerLens : ICustomerLens {\n    private readonly IOrderService orderService;\n    private readonly IPaymentService paymentService;\n    public async Task<CustomerProfile> GetCompleteProfile(Guid customerId) {\n        var customerTask = db Customers FindAsync(customerId);\n        var ordersTask = orderService GetCustomerOrders(customerId);\n        var paymentsTask = paymentService GetPaymentHistory(customerId);\n        await Task WhenAll(customerTask, ordersTask, paymentsTask);\n        return new CustomerProfile {\n            Customer = customerTask Result,\n            RecentOrders = ordersTask Result,\n            PaymentHistory = paymentsTask Result\n        };\n    }\n}\n`\nTime-Travel Lenses\nIn Event-Sourced mode, query historical state:\n`csharp{\ntitle: \"Time-Travel Lens\"\ndescription: \"Querying historical state in event-sourced systems\"\nframework: \"NET8\"\ncategory: \"Advanced\"\ndifficulty: \"ADVANCED\"\ntags: [\"Lenses\", \"Event Sourcing\", \"Time Travel\"]\nfilename: \"HistoricalOrderLens cs\"\nnugetPackages: [\"Whizbang EventSourcing\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic interface IHistoricalLens {\n    Order FocusAsOf(Guid orderId, DateTime pointInTime);\n    IEnumerable<Order> ViewAsOf(DateTime pointInTime);\n}\npublic class HistoricalOrderLens : IHistoricalLens {\n    private readonly IEventStore eventStore;\n    public Order FocusAsOf(Guid orderId, DateTime pointInTime) {\n        var events = eventStore GetEvents(orderId, untilTime: pointInTime);\n        return RebuildOrder(events);\n    }\n}\n`\nSummary\nLenses provide the read side of Whizbang's architecture:\nRead-only interfaces maintain clear separation of concerns\nFocused methods optimize for specific query needs  \nWork consistently across Event-Driven and Event-Sourced modes\nEasy to test and mock\nComposable for complex query scenarios\nLenses ensure that reading data is simple, efficient, and completely separate from writing data",
        "startIndex": 19369,
        "preview": "\"Materialized Views\", \"Performance\"] filename: \"MaterializedOrderLens cs\" usingStatements: [\"System\", \"System Collections Generic\", \"System Linq\"] sho..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/lenses-chunk-10",
        "text": "read side of Whizbang's architecture: Read-only interfaces maintain clear separation of concerns Focused methods optimize for specific query needs Work consistently across Event-Driven and Event-Sourced modes Easy to test and mock Composable for complex query scenarios Lenses ensure that reading data is simple, efficient, and completely separate from writing data Next Steps\nExplore Receptors - How commands are processed\nLearn about Perspectives - How data is written\nSee Event-Driven Architecture - Complete architecture\nReview CQRS Implementation - Query patterns",
        "startIndex": 21792,
        "preview": "read side of Whizbang's architecture: Read-only interfaces maintain clear separation of concerns Focused methods optimize for specific query needs Wor..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/core-concepts/perspectives",
    "title": "Perspectives",
    "category": "Core Concepts",
    "url": "/docs/old-v1.0.0.0/core-concepts/perspectives",
    "chunks": [
      {
        "id": "old-v1.0.0.0/core-concepts/perspectives-chunk-0",
        "text": "Perspectives\nOverview\nPerspectives are the components that react to events and update various views of your data They handle all write operations in Whizbang, ensuring that state changes flow consistently from events to storage The same perspective code works in both Event-Driven and Event-Sourced modes, making them a key part of Whizbang's unified architecture What is a Perspective A Perspective:\nReacts to events emitted by receptors\nUpdates databases, caches, search indexes, and other stores\nMaintains different views of the same data\nExecutes all write operations in the system\nThink of perspectives as event handlers that maintain materialized views Each perspective provides a different \"perspective\" on the events flowing through your system The Core Interface\n`csharp{\ntitle: \"Core Perspective Interface\"\ndescription: \"The fundamental interface for all perspectives in Whizbang\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Perspectives\", \"Interface\", \"Events\"]\nfilename: \"IPerspectiveOf cs\"\nusingStatements: [\"System Threading Tasks\"]\nshowLineNumbers: true\n}\npublic interface IPerspectiveOf<TEvent> {\n    Task Update(TEvent @event);\n}\n`\nSimple, yet powerful - perspectives react to specific events and update their views accordingly How Perspectives Work\nIn Event-Driven Mode\nEvents flow directly from receptors to perspectives in the same transaction:\n`csharp{\ntitle: \"Event-Driven Mode Flow\"\ndescription: \"How events flow from receptors to perspectives in Event-Driven mode\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Event-Driven\", \"Receptors\"]\nfilename: \"OrderPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\n// Receptor emits event\npublic OrderCreated Receive(CreateOrder cmd) {\n    return new OrderCreated(Guid NewGuid(), cmd CustomerId);\n}\n// Perspective immediately updates database\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await db Orders Add(new Order { \n            Id = e OrderId,\n            CustomerId = e CustomerId \n        });\n        await db",
        "startIndex": 0,
        "preview": "Perspectives\nOverview\nPerspectives are the components that react to events and update various views of your data They handle all write operations in W..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/perspectives-chunk-1",
        "text": "// Receptor emits event public OrderCreated Receive(CreateOrder cmd) { return new OrderCreated(Guid NewGuid(), cmd CustomerId); } // Perspective immediately updates database public class OrderPerspective : IPerspectiveOf<OrderCreated> { public async Task Update(OrderCreated e) { await db Orders Add(new Order { Id = e OrderId, CustomerId = e CustomerId }); await db SaveChanges();  // Immediate write\n    }\n}\n`\nIn Event-Sourced Mode\nEvents are first persisted to the ledger, then perspectives update asynchronously:\n`csharp{\ntitle: \"Event-Sourced Mode Execution\"\ndescription: \"Same perspective code executed asynchronously from event stream\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Event-Sourced\", \"Asynchronous\"]\nfilename: \"OrderPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\n// Same perspective code, different execution model\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        // Exact same code, but executed async from event stream\n        await db Orders Add(new Order { \n            Id = e OrderId,\n            CustomerId = e CustomerId \n        });\n        await db SaveChanges();\n    }\n}\n`\nMultiple Perspectives Pattern\nDifferent perspectives provide different views of the same events:\n`csharp{\ntitle: \"Multiple Perspectives Pattern\"\ndescription: \"Different perspectives provide different views of the same events\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Multiple Views\", \"Data Projection\"]\nfilename: \"OrderPerspectives cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\n// Order list for display\npublic class OrderListPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await db OrderList Add(new OrderListItem {\n            Id = e OrderId,\n            CustomerName = await GetCustomerName(e CustomerId),\n            Total = e Total,\n            Status = \"New\",\n            CreatedAt = e Timestamp\n        });\n    }\n}\n// Customer statistics\npublic class CustomerStatsPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await db CustomerStats IncrementOrderCount(e CustomerId);\n        await db CustomerStats AddToTotalSpent(e CustomerId, e Total);\n        await db CustomerStats UpdateLastOrderDate(e CustomerId, e",
        "startIndex": 2197,
        "preview": "// Receptor emits event public OrderCreated Receive(CreateOrder cmd) { return new OrderCreated(Guid NewGuid(), cmd CustomerId); } // Perspective immed..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/perspectives-chunk-2",
        "text": "await GetCustomerName(e CustomerId), Total = e Total, Status = \"New\", CreatedAt = e Timestamp }); } } // Customer statistics public class CustomerStatsPerspective : IPerspectiveOf<OrderCreated> { public async Task Update(OrderCreated e) { await db CustomerStats IncrementOrderCount(e CustomerId); await db CustomerStats AddToTotalSpent(e CustomerId, e Total); await db CustomerStats UpdateLastOrderDate(e CustomerId, e Timestamp);\n    }\n}\n// Search index\npublic class SearchPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await searchIndex Index(new SearchDocument {\n            Id = e OrderId ToString(),\n            Type = \"order\",\n            CustomerId = e CustomerId,\n            Timestamp = e Timestamp,\n            Searchable = $\"Order {e OrderId} Customer {e CustomerId}\"\n        });\n    }\n}\n// Analytics/reporting\npublic class AnalyticsPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await analytics Track(\"OrderCreated\", new {\n            OrderId = e OrderId,\n            CustomerId = e CustomerId,\n            Total = e Total,\n            ItemCount = e Items Count\n        });\n    }\n}\n`\nComplex Perspective Patterns\nMulti-Event Perspectives\nPerspectives can handle multiple event types to maintain complex views:\n`csharp{\ntitle: \"Multi-Event Perspective\"\ndescription: \"Perspective handling multiple event types to maintain complex views\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"ADVANCED\"\ntags: [\"Perspectives\", \"Multi-Event\", \"Order Status\"]\nfilename: \"OrderStatusPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class OrderStatusPerspective : \n    IPerspectiveOf<OrderCreated>,\n    IPerspectiveOf<OrderPaid>,\n    IPerspectiveOf<OrderShipped>,\n    IPerspectiveOf<OrderCancelled> {\n    public async Task Update(OrderCreated e) {\n        await db OrderStatus Add(new OrderStatus {\n            OrderId = e OrderId,\n            Status = \"Created\",\n            UpdatedAt = e Timestamp\n        });\n    }\n    public async Task Update(OrderPaid e) {\n        await db OrderStatus UpdateStatus(e OrderId, \"Paid\", e Timestamp);\n        await db PaymentRecords Add(new PaymentRecord {\n            OrderId = e OrderId,\n            Amount = e Amount,\n            Method = e PaymentMethod\n        });\n    }\n    public async Task Update(OrderShipped e) {\n        await db OrderStatus UpdateStatus(e OrderId, \"Shipped\", e Timestamp);\n        await db ShippingRecords Add(new ShippingRecord {\n            OrderId = e OrderId,\n            Carrier = e Carrier,\n            TrackingNumber = e",
        "startIndex": 4332,
        "preview": "await GetCustomerName(e CustomerId), Total = e Total, Status = \"New\", CreatedAt = e Timestamp }); } } // Customer statistics public class CustomerStat..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/perspectives-chunk-3",
        "text": "db PaymentRecords Add(new PaymentRecord { OrderId = e OrderId, Amount = e Amount, Method = e PaymentMethod }); } public async Task Update(OrderShipped e) { await db OrderStatus UpdateStatus(e OrderId, \"Shipped\", e Timestamp); await db ShippingRecords Add(new ShippingRecord { OrderId = e OrderId, Carrier = e Carrier, TrackingNumber = e TrackingNumber\n        });\n    }\n    public async Task Update(OrderCancelled e) {\n        await db OrderStatus UpdateStatus(e OrderId, \"Cancelled\", e Timestamp);\n        await db CancellationReasons Add(new CancellationReason {\n            OrderId = e OrderId,\n            Reason = e Reason,\n            RefundAmount = e RefundAmount\n        });\n    }\n}\n`\nDenormalized Views\nPerspectives excel at maintaining denormalized views for query performance:\n`csharp{\ntitle: \"Denormalized Order Summary Perspective\"\ndescription: \"Perspective maintaining denormalized views with customer data for query performance\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"ADVANCED\"\ntags: [\"Perspectives\", \"Denormalization\", \"Performance\", \"Views\"]\nfilename: \"OrderSummaryPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class OrderSummaryPerspective : \n    IPerspectiveOf<OrderCreated>,\n    IPerspectiveOf<ItemAdded>,\n    IPerspectiveOf<ItemRemoved> {\n    public async Task Update(OrderCreated e) {\n        // Create denormalized summary\n        var customer = await customerService GetCustomer(e CustomerId);\n        await db OrderSummaries Add(new OrderSummary {\n            OrderId = e OrderId,\n            CustomerId = e CustomerId,\n            CustomerName = customer Name,\n            CustomerEmail = customer Email,\n            CustomerTier = customer Tier,\n            ItemCount = e Items Count,\n            TotalAmount = e Total,\n            CreatedAt = e Timestamp\n        });\n    }\n    public async Task Update(ItemAdded e) {\n        var summary = await db OrderSummaries Get(e OrderId);\n        summary ItemCount++;\n        summary TotalAmount = e NewTotal;\n        summary LastModified = e Timestamp;\n        await db OrderSummaries Update(summary);\n    }\n}\n`\nCache Invalidation\nPerspectives handle cache updates and invalidation:\n`csharp{\ntitle: \"Cache Management Perspective\"\ndescription: \"Perspective handling cache updates and invalidation patterns\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Caching\", \"Invalidation\", \"Performance\"]\nfilename: \"CachePerspective cs\"\nusingStatements: [\"System\", \"System Threading",
        "startIndex": 6581,
        "preview": "db PaymentRecords Add(new PaymentRecord { OrderId = e OrderId, Amount = e Amount, Method = e PaymentMethod }); } public async Task Update(OrderShipped..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/perspectives-chunk-4",
        "text": "= e Timestamp; await db OrderSummaries Update(summary); } } ` Cache Invalidation Perspectives handle cache updates and invalidation: `csharp{ title: \"Cache Management Perspective\" description: \"Perspective handling cache updates and invalidation patterns\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"INTERMEDIATE\" tags: [\"Perspectives\", \"Caching\", \"Invalidation\", \"Performance\"] filename: \"CachePerspective cs\" usingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class CachePerspective : \n    IPerspectiveOf<OrderCreated>,\n    IPerspectiveOf<OrderUpdated> {\n    private readonly ICache cache;\n    public async Task Update(OrderCreated e) {\n        // Invalidate customer's order list cache\n        await cache Remove($\"customer:{e CustomerId}:orders\");\n        // Pre-warm order cache\n        var order = new OrderCache {\n            Id = e OrderId,\n            CustomerId = e CustomerId,\n            Total = e Total\n        };\n        await cache Set($\"order:{e OrderId}\", order, TimeSpan FromHours(1));\n    }\n    public async Task Update(OrderUpdated e) {\n        // Invalidate all related caches\n        await cache Remove($\"order:{e OrderId}\");\n        await cache Remove($\"customer:{e CustomerId}:orders\");\n        await cache Remove(\"orders:recent\");\n    }\n}\n`\nPerspective Configuration\nConfigure perspectives behavior via the dispatcher:\n`csharp{\ntitle: \"Perspective Configuration\"\ndescription: \"Configuring perspective behavior via the dispatcher with buffering, concurrency, and error handling\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Configuration\", \"Dispatcher\", \"Performance\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nservices AddWhizbang() UseDispatcher(dispatcher => {\n        // Register all perspectives\n        dispatcher RegisterPerspectivesFromAssembly(typeof(Program) Assembly);\n        // Configure perspective execution\n        dispatcher Perspectives BufferSize(100)           // Buffer events for batch processing MaxConcurrency(10)         // Parallel perspective execution RetryPolicy(3, \"exponential\") ErrorHandling(ErrorStrategy DeadLetter);\n        // Specific perspective configuration\n        dispatcher ForPerspective<AnalyticsPerspective>() ExecuteAsync()             // Always async WithPriority(Priority Low);\n    });\n`\nBatch Processing\nPerspectives can process events in batches for efficiency:\n`csharp{\ntitle: \"Batched Processing Perspective\"\ndescription: \"Perspective processing multiple events in batches for improved efficiency\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"ADVANCED\"\ntags: [\"Perspectives\", \"Batching\", \"Performance\", \"Bulk Operations\"]\nfilename: \"BatchedPerspective cs\"\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq\", \"System Threading",
        "startIndex": 8818,
        "preview": "= e Timestamp; await db OrderSummaries Update(summary); } } ` Cache Invalidation Perspectives handle cache updates and invalidation: `csharp{ title: \"..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/perspectives-chunk-5",
        "text": "Batch Processing Perspectives can process events in batches for efficiency: `csharp{ title: \"Batched Processing Perspective\" description: \"Perspective processing multiple events in batches for improved efficiency\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"ADVANCED\" tags: [\"Perspectives\", \"Batching\", \"Performance\", \"Bulk Operations\"] filename: \"BatchedPerspective cs\" usingStatements: [\"System\", \"System Collections Generic\", \"System Linq\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class BatchedPerspective : IBatchPerspectiveOf<OrderCreated> {\n    public async Task UpdateBatch(IEnumerable<OrderCreated> events) {\n        // Process multiple events efficiently\n        var orders = events Select(e => new Order {\n            Id = e OrderId,\n            CustomerId = e CustomerId,\n            Total = e Total\n        }) ToList();\n        // Single database round-trip\n        await db Orders BulkInsert(orders);\n        // Batch cache update\n        var cacheUpdates = orders Select(o => \n            new CacheEntry($\"order:{o Id}\", o, TimeSpan FromHours(1))\n        );\n        await cache SetMany(cacheUpdates);\n    }\n}\n`\nIdempotent Perspectives\nEnsure perspectives are idempotent for reliability:\n`csharp{\ntitle: \"Idempotent Perspective Pattern\"\ndescription: \"Ensuring perspectives are idempotent for reliability and duplicate event handling\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Idempotency\", \"Reliability\", \"Error Handling\"]\nfilename: \"IdempotentOrderPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class IdempotentOrderPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        // Check if already processed\n        var exists = await db Orders Exists(e OrderId);\n        if (exists) {\n            return;  // Already processed, skip\n        }\n        // Process event\n        await db Orders Add(new Order {\n            Id = e OrderId,\n            CustomerId = e CustomerId,\n            ProcessedAt = DateTime UtcNow\n        });\n    }\n}\n`\nTesting Perspectives\nPerspectives are easy to test in isolation:\n`csharp{\ntitle: \"Testing Perspectives in Isolation\"\ndescription: \"Unit tests demonstrating how to test perspectives independently with mocked dependencies\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Testing\", \"Unit Tests\", \"Mocking\"]\nfilename: \"OrderPerspectiveTests cs\"\nusingStatements: [\"System\", \"System Threading",
        "startIndex": 11354,
        "preview": "Batch Processing Perspectives can process events in batches for efficiency: `csharp{ title: \"Batched Processing Perspective\" description: \"Perspective..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/perspectives-chunk-6",
        "text": "} } ` Testing Perspectives Perspectives are easy to test in isolation: `csharp{ title: \"Testing Perspectives in Isolation\" description: \"Unit tests demonstrating how to test perspectives independently with mocked dependencies\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"INTERMEDIATE\" tags: [\"Perspectives\", \"Testing\", \"Unit Tests\", \"Mocking\"] filename: \"OrderPerspectiveTests cs\" usingStatements: [\"System\", \"System Threading Tasks\", \"Xunit\", \"Whizbang\"]\nshowLineNumbers: true\n}\n[Fact]\npublic async Task OrderPerspective_CreatesOrder_WhenOrderCreatedEventReceived() {\n    // Arrange\n    var db = new InMemoryDatabase();\n    var perspective = new OrderPerspective(db);\n    var @event = new OrderCreated {\n        OrderId = Guid NewGuid(),\n        CustomerId = Guid NewGuid(),\n        Total = 100 00m\n    };\n    // Act\n    await perspective Update(@event);\n    // Assert\n    var order = await db Orders Get(@event OrderId);\n    Assert NotNull(order);\n    Assert Equal(@event CustomerId, order CustomerId);\n    Assert Equal(@event Total, order Total);\n}\n[Fact]\npublic async Task CachePerspective_InvalidatesCache_WhenOrderUpdated() {\n    // Arrange\n    var cache = new MockCache();\n    cache Set(\"order:123\", new Order());\n    var perspective = new CachePerspective(cache);\n    // Act\n    await perspective Update(new OrderUpdated { OrderId = Guid Parse(\"123\") });\n    // Assert\n    Assert False(await cache Exists(\"order:123\"));\n}\n`\nBest Practices\nDo's\n✅ Make perspectives idempotent\n`csharp{\ntitle: \"Idempotent Perspective Best Practice\"\ndescription: \"Using upsert operations to ensure perspectives can safely handle duplicate events\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Perspectives\", \"Best Practices\", \"Idempotency\"]\nfilename: \"IdempotentPerspective cs\"\nusingStatements: [\"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic async Task Update(OrderCreated e) {\n    await db Orders Upsert(e OrderId, order);  // Idempotent\n}\n`\n✅ Handle failures gracefully\n`csharp{\ntitle: \"Graceful Error Handling in Perspectives\"\ndescription: \"Implementing error handling and dead letter patterns for perspective failures\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Error Handling\", \"Dead Letter\", \"Resilience\"]\nfilename: \"ResilientPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic async Task Update(OrderCreated e) {\n    try {\n        await externalService Notify(e);\n    } catch (Exception ex) {\n        await deadLetter",
        "startIndex": 13466,
        "preview": "} } ` Testing Perspectives Perspectives are easy to test in isolation: `csharp{ title: \"Testing Perspectives in Isolation\" description: \"Unit tests de..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/perspectives-chunk-7",
        "text": "dead letter patterns for perspective failures\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"INTERMEDIATE\" tags: [\"Perspectives\", \"Error Handling\", \"Dead Letter\", \"Resilience\"] filename: \"ResilientPerspective cs\" usingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"] showLineNumbers: true } public async Task Update(OrderCreated e) { try { await externalService Notify(e); } catch (Exception ex) { await deadLetter Queue(e, ex);\n    }\n}\n`\n✅ Keep perspectives focused\n`csharp{\ntitle: \"Single Responsibility Perspectives\"\ndescription: \"Keeping perspectives focused on a single responsibility for maintainability\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Perspectives\", \"Single Responsibility\", \"Best Practices\"]\nfilename: \"FocusedPerspectives cs\"\nusingStatements: [\"Whizbang\"]\nshowLineNumbers: true\n}\n// Each perspective has a single responsibility\npublic class EmailPerspective : IPerspectiveOf<OrderCreated> { }\npublic class InventoryPerspective : IPerspectiveOf<OrderCreated> { }\n`\n✅ Use batching for performance\n`csharp{\ntitle: \"Batching for Performance\"\ndescription: \"Using batch operations to improve perspective performance with bulk database operations\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Batching\", \"Performance\", \"Best Practices\"]\nfilename: \"BatchPerspective cs\"\nusingStatements: [\"System Collections Generic\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic async Task UpdateBatch(IEnumerable<OrderCreated> events) {\n    await db BulkInsert(events);\n}\n`\nDon'ts\n❌ Don't emit events from perspectives\n`csharp{\ntitle: \"Anti-Pattern: Emitting Events from Perspectives\"\ndescription: \"What NOT to do - perspectives should react to events, not emit them\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Perspectives\", \"Anti-Patterns\", \"Best Practices\"]\nfilename: \"BadPerspective cs\"\nusingStatements: [\"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\n// BAD - Perspectives react, they don't decide\npublic async Task Update(OrderCreated e) {\n    await dispatcher Send(new SendEmail());  // Don't do this }\n`\n❌ Don't call other perspectives directly\n`csharp{\ntitle: \"Anti-Pattern: Direct Perspective Calls\"\ndescription: \"What NOT to do - let the dispatcher handle perspective coordination\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Perspectives\", \"Anti-Patterns\", \"Dispatcher\"]\nfilename: \"BadPerspectiveCoordination cs\"\nusingStatements: [\"System Threading",
        "startIndex": 15617,
        "preview": "dead letter patterns for perspective failures\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"INTERMEDIATE\" tags: [\"Perspectives\", \"Error Ha..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/perspectives-chunk-8",
        "text": "dispatcher Send(new SendEmail()); // Don't do this } ` ❌ Don't call other perspectives directly `csharp{ title: \"Anti-Pattern: Direct Perspective Calls\" description: \"What NOT to do - let the dispatcher handle perspective coordination\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"BEGINNER\" tags: [\"Perspectives\", \"Anti-Patterns\", \"Dispatcher\"] filename: \"BadPerspectiveCoordination cs\" usingStatements: [\"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\n// BAD - Let the dispatcher handle coordination\npublic async Task Update(OrderCreated e) {\n    await otherPerspective Update(e);  // Don't do this }\n`\n❌ Don't make business decisions\n`csharp{\ntitle: \"Anti-Pattern: Business Logic in Perspectives\"\ndescription: \"What NOT to do - business decisions belong in receptors, not perspectives\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Perspectives\", \"Anti-Patterns\", \"Business Logic\"]\nfilename: \"BadBusinessLogicPerspective cs\"\nusingStatements: [\"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\n// BAD - Business logic belongs in receptors\npublic async Task Update(OrderCreated e) {\n    if (e Total > 1000) {  // Business rule doesn't belong here\n        await db VipOrders Add(e);\n    }\n}\n`\nAdvanced Patterns\nTemporal Perspectives\nMaintain time-based views:\n`csharp{\ntitle: \"Temporal Statistics Perspective\"\ndescription: \"Maintaining time-based views with daily statistics and aggregations\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"ADVANCED\"\ntags: [\"Perspectives\", \"Temporal\", \"Statistics\", \"Aggregation\"]\nfilename: \"DailyStatsPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class DailyStatsPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        var date = e Timestamp Date;\n        await db DailyStats Increment(date, stats => {\n            stats OrderCount++;\n            stats TotalRevenue += e Total;\n            stats AverageOrderValue = stats TotalRevenue / stats OrderCount;\n        });\n    }\n}\n`\nGraph Perspectives\nUpdate graph databases or relationship stores:\n`csharp{\ntitle: \"Graph Database Perspective\"\ndescription: \"Updating graph databases and relationship stores from events\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"ADVANCED\"\ntags: [\"Perspectives\", \"Graph Database\", \"Relationships\", \"Neo4j\"]\nfilename: \"GraphPerspective cs\"\nusingStatements: [\"System\", \"System Threading",
        "startIndex": 17746,
        "preview": "dispatcher Send(new SendEmail()); // Don't do this } ` ❌ Don't call other perspectives directly `csharp{ title: \"Anti-Pattern: Direct Perspective Call..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/perspectives-chunk-9",
        "text": "TotalRevenue / stats OrderCount; }); } } ` Graph Perspectives Update graph databases or relationship stores: `csharp{ title: \"Graph Database Perspective\" description: \"Updating graph databases and relationship stores from events\" framework: \"NET8\" category: \"Core Concepts\" difficulty: \"ADVANCED\" tags: [\"Perspectives\", \"Graph Database\", \"Relationships\", \"Neo4j\"] filename: \"GraphPerspective cs\" usingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class GraphPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await graph CreateNode(\"Order\", e OrderId);\n        await graph CreateNode(\"Customer\", e CustomerId);\n        await graph CreateRelationship(\"PLACED_BY\", e OrderId, e CustomerId);\n        foreach (var item in e Items) {\n            await graph CreateRelationship(\"CONTAINS\", e OrderId, item ProductId);\n        }\n    }\n}\n`\nMachine Learning Perspectives\nFeed ML models or feature stores:\n`csharp{\ntitle: \"Machine Learning Feature Store Perspective\"\ndescription: \"Feeding ML models and feature stores with event data for customer analytics\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"ADVANCED\"\ntags: [\"Perspectives\", \"Machine Learning\", \"Feature Store\", \"Analytics\"]\nfilename: \"MLPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class MLPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated e) {\n        await featureStore Update(\"customer_features\", e CustomerId, new {\n            LastOrderDate = e Timestamp,\n            OrderCount = await GetOrderCount(e CustomerId) + 1,\n            TotalSpent = await GetTotalSpent(e CustomerId) + e Total,\n            PreferredCategory = await DeterminePreferredCategory(e Items)\n        });\n        await mlPipeline TriggerRetrain(\"customer_segmentation\");\n    }\n}\n`\nSummary\nPerspectives are the write-side workhorses of Whizbang:\nReact to events and update various stores\nSame code works in Event-Driven and Event-Sourced modes\nMultiple perspectives provide different views of the same data\nIdempotent and resilient by design\nTestable in isolation\nPerspectives ensure that all state changes flow from events to storage in a consistent, maintainable way Next Steps\nLearn about Lenses - Read-only query interfaces\nExplore Receptors - Event producers\nSee Event-Driven Architecture - Complete picture\nReview Testing Strategies - Testing perspectives",
        "startIndex": 19809,
        "preview": "TotalRevenue / stats OrderCount; }); } } ` Graph Perspectives Update graph databases or relationship stores: `csharp{ title: \"Graph Database Perspecti..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/core-concepts/projections",
    "title": "Projections",
    "category": "Core Concepts",
    "url": "/docs/old-v1.0.0.0/core-concepts/projections",
    "chunks": [
      {
        "id": "old-v1.0.0.0/core-concepts/projections-chunk-0",
        "text": "Projections\nProjections are the read-side component of CQRS in Whizbang They create optimized, denormalized views of your data by subscribing to domain events and building read models tailored for specific query patterns What are Projections Projections transform events from the write-side (aggregates) into read models optimized for queries:\nEvent Subscribers: Listen to domain events as they occur\nRead Model Builders: Create denormalized views optimized for queries\nEventually Consistent: Updated asynchronously as events are processed\nRebuildable: Can be deleted and rebuilt from event history\nKey Benefits\nQuery Optimization\nDenormalized Data: Flatten complex relationships for fast reads\nIndexed Views: Create optimal indexes for specific query patterns\nMultiple Formats: Same events can feed different projection formats\nScalability\nIndependent Scaling: Scale read and write sides independently\nCaching Friendly: Read models can be heavily cached\nDistributed Reads: Replicate read models across regions\nFlexibility\nMultiple Projections: Create different views from same events\nTechnology Choice: Use different databases for different projections\nSchema Evolution: Add new projections without affecting writes\nHow Projections Work\n`mermaid\nsequenceDiagram\n    participant Aggregate\n    participant EventStore as Event Store\n    participant Projection\n    participant ReadDB as Read Database\n    participant Query as Query Handler\n    Aggregate->>EventStore: Save Events\n    EventStore->>Projection: Publish Events\n    Projection->>Projection: Process Events\n    Projection->>ReadDB: Update Read Model\n    Query->>ReadDB: Query Read Model\n    ReadDB->>Query: Return Results\n`\nExample Projection\n`csharp{\ntitle: \"Order Summary Projection\"\ndescription: \"Example projection that creates read models from domain events\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Read Models\", \"CQRS\", \"Order Summary\"]\nfilename: \"OrderSummaryProjection cs\"\nnugetPackages: [\"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class OrderSummaryProjection {\n    private readonly IProjectionStore<OrderSummary> _store;\n    public OrderSummaryProjection(IProjectionStore<OrderSummary> store) {\n        _store = store;\n    }\n    // Event handler - creates new read model\n    public async Task Handle(OrderPlacedEvent @event) {\n        await _store UpsertAsync(@event OrderId, new OrderSummary {\n            OrderId = @event OrderId,\n            CustomerId = @event",
        "startIndex": 0,
        "preview": "Projections\nProjections are the read-side component of CQRS in Whizbang They create optimized, denormalized views of your data by subscribing to domai..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/projections-chunk-1",
        "text": "Threading Tasks\", \"Whizbang\"] showLineNumbers: true } public class OrderSummaryProjection { private readonly IProjectionStore<OrderSummary> _store; public OrderSummaryProjection(IProjectionStore<OrderSummary> store) { _store = store; } // Event handler - creates new read model public async Task Handle(OrderPlacedEvent @event) { await _store UpsertAsync(@event OrderId, new OrderSummary { OrderId = @event OrderId, CustomerId = @event CustomerId,\n            Total = @event Total,\n            Status = \"Placed\",\n            PlacedAt = @event PlacedAt\n        });\n    }\n    // Event handler - updates existing read model\n    public async Task Handle(OrderShippedEvent @event) {\n        await _store UpdateAsync(@event OrderId, summary => {\n            summary Status = \"Shipped\";\n            summary ShippedAt = @event ShippedAt;\n            summary TrackingNumber = @event TrackingNumber;\n        });\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    public decimal Total { get; set; }\n    public string Status { get; set; }\n    public DateTime PlacedAt { get; set; }\n    public DateTime ShippedAt { get; set; }\n    public string TrackingNumber { get; set; }\n}\n`\nProjection Types\nSimple Projections\nSingle Entity: One event stream → One read model\nDirect Mapping: Events map directly to read model properties\nUse Case: Basic CRUD operations, simple reporting\nComposite Projections\nMultiple Streams: Events from multiple aggregates\nJoined Data: Combine data from different domains\nUse Case: Complex reports, dashboards, analytics\nCached Projections\nMemory-Based: Keep frequently accessed data in memory\nHigh Performance: Sub-millisecond query times\nUse Case: Real-time dashboards, autocomplete\nConfiguration\n`csharp{\ntitle: \"Projection Configuration\"\ndescription: \"Configuring projections with event subscriptions and backfilling\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Configuration\", \"Event Subscriptions\"]\nfilename: \"Program cs\"\nnugetPackages: [\"Whizbang Core\", \"Microsoft Extensions DependencyInjection\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nservices AddWhizbang(options => {\n    options UseProjections(proj => {\n        // Register projection\n        proj RegisterProjection<OrderSummaryProjection>(p => {\n            p Subscribe<OrderPlacedEvent>();\n            p Subscribe<OrderShippedEvent>();\n            p Subscribe<OrderCancelledEvent>();\n        });\n        // Configure backfilling\n        proj BackfillFromBeginning = true;\n        // Configure partitioning\n        proj",
        "startIndex": 2568,
        "preview": "Threading Tasks\", \"Whizbang\"] showLineNumbers: true } public class OrderSummaryProjection { private readonly IProjectionStore<OrderSummary> _store; pu..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/projections-chunk-2",
        "text": "filename: \"Program cs\" nugetPackages: [\"Whizbang Core\", \"Microsoft Extensions DependencyInjection\"] usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"] showLineNumbers: true } services AddWhizbang(options => { options UseProjections(proj => { // Register projection proj RegisterProjection<OrderSummaryProjection>(p => { p Subscribe<OrderPlacedEvent>(); p Subscribe<OrderShippedEvent>(); p Subscribe<OrderCancelledEvent>(); }); // Configure backfilling proj BackfillFromBeginning = true; // Configure partitioning proj PartitionBy = @event => ((dynamic)@event) OrderId;\n    });\n});\n`\nAdvanced Features\nBackfilling\nHistorical Data: Process events from before projection was created\nIncremental: Resume from last processed event\nParallel: Process multiple partitions concurrently\nEvent Filtering\nSelective Processing: Only process relevant events\nPattern Matching: Subscribe to events by type or properties\nPerformance: Reduce unnecessary processing\nSchema Evolution\nVersioning: Handle projection schema changes\nMigration: Update existing read models\nBackward Compatibility: Support multiple projection versions\nBest Practices\nDesign for Queries\nQuery-First: Design projections around actual query needs\nDenormalize: Include all data needed for queries\nIndex Appropriately: Add indexes for query patterns\nHandle Failures\nRetry Logic: Handle transient failures\nDead Letter Queues: Capture failed events\nMonitoring: Track projection health and lag\nPerformance Optimization\nBatch Processing: Process events in batches\nAsync Processing: Use async/await throughout\nConnection Pooling: Optimize database connections\nStorage Options\nWhizbang supports multiple projection storage backends:\nSQL Databases: Postgres, SQL Server, MySQL\nDocument Stores: MongoDB, CosmosDB\nSearch Engines: Elasticsearch, Azure Search\nKey-Value Stores: Redis, DynamoDB\nMemory: In-memory caching\nRelated Topics\nCore Concepts - Overview of CQRS and event sourcing\nProjection Subscriptions - Configuring event subscriptions\nProjection Contexts - Managing projection lifecycle\nGetting Started - Tutorial building your first projection\nNext Steps\nThis page provides an overview of projections in Whizbang For detailed implementation patterns and advanced scenarios, explore the specialized projection documentation in the Projections section",
        "startIndex": 4804,
        "preview": "filename: \"Program cs\" nugetPackages: [\"Whizbang Core\", \"Microsoft Extensions DependencyInjection\"] usingStatements: [\"Microsoft Extensions Dependency..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/core-concepts/receptors",
    "title": "Receptors",
    "category": "Core Concepts",
    "url": "/docs/old-v1.0.0.0/core-concepts/receptors",
    "chunks": [
      {
        "id": "old-v1.0.0.0/core-concepts/receptors-chunk-0",
        "text": "Receptors\nOverview\nReceptors are the decision-making components in Whizbang They receive commands, apply business rules, and emit events representing the decisions made The same receptor interface works in both Event-Driven (stateless) and Event-Sourced (stateful) modes, making them the cornerstone of Whizbang's progressive enhancement philosophy What is a Receptor A Receptor:\nReceives commands from external sources\nDecides what should happen based on business rules\nEmits events representing those decisions\nNever performs side effects directly\nThink of a receptor as a pure decision function: given a command and current state, what event(s) should occur The Universal Interface\n`csharp{\ntitle: \"Universal Receptor Interface\"\ndescription: \"The core interface that works for both Event-Driven and Event-Sourced modes\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Interface\", \"Universal\"]\nfilename: \"IReceptor cs\"\nusingStatements: [\"System\"]\nshowLineNumbers: true\n}\npublic interface IReceptor<TCommand> {\n    object Receive(TCommand command);\n}\n`\nThe return type determines what happens:\nSingle event → Published to perspectives\nMultiple events (tuple) → All published\nResult<TEvent> → Success/failure handling\nvoid → No events (rare)\nStateless Receptors (Event-Driven Mode)\nIn Event-Driven mode, receptors are stateless and get current state from Lenses:\n`csharp{\ntitle: \"Stateless Receptor with Lens\"\ndescription: \"Event-Driven mode receptor that gets state from lens parameters\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Receptors\", \"Stateless\", \"Event-Driven\", \"Lenses\"]\nfilename: \"OrderReceptor cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class OrderReceptor : IReceptor<CreateOrder> {\n    // Stateless - gets state from lens parameter\n    public OrderCreated Receive(CreateOrder cmd, IOrderLens lens) {\n        // Validate using lens (read-only)\n        var customer = lens GetCustomer(cmd CustomerId);\n        if ( customer IsActive) {\n            throw new InactiveCustomerException();\n        }\n        // Check inventory through lens\n        var inventory = lens GetInventory(cmd Items);\n        if ( inventory HasStock()) {\n            throw new OutOfStockException();\n        }\n        // Make decision and emit event\n        return new OrderCreated(\n            Guid NewGuid(),\n            cmd CustomerId,\n            cmd Items,\n            CalculateTotal(cmd Items),\n            DateTime",
        "startIndex": 0,
        "preview": "Receptors\nOverview\nReceptors are the decision-making components in Whizbang They receive commands, apply business rules, and emit events representing ..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/receptors-chunk-1",
        "text": "lens GetCustomer(cmd CustomerId); if ( customer IsActive) { throw new InactiveCustomerException(); } // Check inventory through lens var inventory = lens GetInventory(cmd Items); if ( inventory HasStock()) { throw new OutOfStockException(); } // Make decision and emit event return new OrderCreated( Guid NewGuid(), cmd CustomerId, cmd Items, CalculateTotal(cmd Items), DateTime UtcNow\n        );\n    }\n}\n`\nCharacteristics of Stateless Receptors\nGet state from Lens parameters\nCreated per request (transient lifetime)\nNo internal state between calls\nPerfect for simple CRUD operations\nStateful Receptors (Event-Sourced Mode)\nIn Event-Sourced mode, receptors maintain internal state rebuilt from events:\n`csharp{\ntitle: \"Stateful Event-Sourced Receptor\"\ndescription: \"Event-Sourced mode receptor with internal state maintained from events\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"ADVANCED\"\ntags: [\"Receptors\", \"Stateful\", \"Event-Sourced\", \"State Management\"]\nfilename: \"OrderReceptor cs\"\nnugetPackages: [\"Whizbang EventSourcing\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq\", \"Whizbang\"]\nshowLineNumbers: true\nhighlightLines: [1, 17, 29, 46]\n}\n[EventSourced]\npublic class OrderReceptor : \n    IReceptor<CreateOrder>,\n    IReceptor<AddItem>,\n    IReceptor<RemoveItem>,\n    IReceptor<ShipOrder> {\n    // Internal state maintained from events\n    private Guid id;\n    private Guid customerId;\n    private List<OrderItem> items = new();\n    private OrderStatus status;\n    private decimal total;\n    // Command handlers - no lens needed\n    public OrderCreated Receive(CreateOrder cmd) {\n        if (id = Guid Empty) {\n            throw new InvalidOperationException(\"Order already created\");\n        }\n        return new OrderCreated(\n            Guid NewGuid(),\n            cmd CustomerId,\n            cmd Items,\n            cmd Items Sum(i => i Quantity * i Price),\n            DateTime UtcNow\n        );\n    }\n    public ItemAdded Receive(AddItem cmd) {\n        if (status = OrderStatus Pending) {\n            throw new InvalidOperationException(\"Cannot modify shipped order\");\n        }\n        var newTotal = total + (cmd Quantity * cmd Price);\n        return new ItemAdded(id, cmd ProductId, cmd Quantity, cmd Price, newTotal);\n    }\n    public OrderShipped Receive(ShipOrder cmd) {\n        if (status = OrderStatus Paid) {\n            throw new InvalidOperationException(\"Order must be paid before shipping\");\n        }\n        return new OrderShipped(id, cmd TrackingNumber, DateTime",
        "startIndex": 2522,
        "preview": "lens GetCustomer(cmd CustomerId); if ( customer IsActive) { throw new InactiveCustomerException(); } // Check inventory through lens var inventory = l..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/receptors-chunk-2",
        "text": "shipped order\"); } var newTotal = total + (cmd Quantity * cmd Price); return new ItemAdded(id, cmd ProductId, cmd Quantity, cmd Price, newTotal); } public OrderShipped Receive(ShipOrder cmd) { if (status = OrderStatus Paid) { throw new InvalidOperationException(\"Order must be paid before shipping\"); } return new OrderShipped(id, cmd TrackingNumber, DateTime UtcNow);\n    }\n    // Event handlers - update internal state\n    public void Absorb(OrderCreated e) {\n        id = e OrderId;\n        customerId = e CustomerId;\n        items = e Items ToList();\n        total = e Total;\n        status = OrderStatus Pending;\n    }\n    public void Absorb(ItemAdded e) {\n        items Add(new OrderItem(e ProductId, e Quantity, e Price));\n        total = e NewTotal;\n    }\n    public void Absorb(OrderShipped e) {\n        status = OrderStatus Shipped;\n    }\n}\n`\nCharacteristics of Stateful Receptors\nMaintain internal state from event stream\nState rebuilt by replaying events\nLong-lived (cached between requests)\nPerfect for complex domain logic\nReturn Type Semantics\nWhat you return determines what happens:\n`csharp{\ntitle: \"Return Type Semantics\"\ndescription: \"Different return types control how events are published\"\nframework: \"NET8\"\ncategory: \"Core Concepts\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Receptors\", \"Return Types\", \"Events\"]\nfilename: \"PaymentReceptor cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class PaymentReceptor : IReceptor<ProcessPayment> {\n    // Single event - published to perspectives\n    public PaymentProcessed Receive(ProcessPayment cmd) {\n        return new PaymentProcessed(cmd OrderId, cmd Amount);\n    }\n    // Multiple events - all published\n    public (PaymentProcessed, EmailQueued, InventoryReserved) ReceiveWithEffects(ProcessPayment cmd) {\n        return (\n            new PaymentProcessed(cmd OrderId, cmd Amount),\n            new EmailQueued(cmd CustomerEmail, \"Payment received\"),\n            new InventoryReserved(cmd OrderId, cmd Items)\n        );\n    }\n    // Result type - success/failure handling\n    public Result<PaymentProcessed> ReceiveWithValidation(ProcessPayment cmd) {\n        if (cmd Amount <= 0) {\n            return Result Failure<PaymentProcessed>(\"Invalid amount\");\n        }\n        return Result Success(new PaymentProcessed(cmd OrderId, cmd",
        "startIndex": 4678,
        "preview": "shipped order\"); } var newTotal = total + (cmd Quantity * cmd Price); return new ItemAdded(id, cmd ProductId, cmd Quantity, cmd Price, newTotal); } pu..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/receptors-chunk-3",
        "text": "ReceiveWithEffects(ProcessPayment cmd) { return ( new PaymentProcessed(cmd OrderId, cmd Amount), new EmailQueued(cmd CustomerEmail, \"Payment received\"), new InventoryReserved(cmd OrderId, cmd Items) ); } // Result type - success/failure handling public Result<PaymentProcessed> ReceiveWithValidation(ProcessPayment cmd) { if (cmd Amount <= 0) { return Result Failure<PaymentProcessed>(\"Invalid amount\"); } return Result Success(new PaymentProcessed(cmd OrderId, cmd Amount));\n    }\n}\n`\nEvolution Pattern\nReceptors naturally evolve from stateless to stateful as complexity grows:\nStage 1: Simple Stateless\n`csharp{\ntitle: \"Evolution Stage 1: Simple Stateless\"\ndescription: \"Starting with a simple stateless receptor\"\nframework: \"NET8\"\ncategory: \"Evolution\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Evolution\", \"Simple\"]\nfilename: \"ProductReceptor cs\"\nusingStatements: [\"System\", \"Whizbang\"]\n}\npublic class ProductReceptor : IReceptor<CreateProduct> {\n    public ProductCreated Receive(CreateProduct cmd) {\n        return new ProductCreated(Guid NewGuid(), cmd Name, cmd Price);\n    }\n}\n`\nStage 2: Stateless with Validation\n`csharp{\ntitle: \"Evolution Stage 2: Stateless with Validation\"\ndescription: \"Adding validation using lens for state access\"\nframework: \"NET8\"\ncategory: \"Evolution\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Receptors\", \"Evolution\", \"Validation\", \"Lenses\"]\nfilename: \"ProductReceptor cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class ProductReceptor : IReceptor<CreateProduct> {\n    public ProductCreated Receive(CreateProduct cmd, IProductLens lens) {\n        if (lens Exists(p => p Name == cmd Name)) {\n            throw new DuplicateProductException();\n        }\n        return new ProductCreated(Guid NewGuid(), cmd Name, cmd Price);\n    }\n}\n`\nStage 3: Multiple Commands\n`csharp{\ntitle: \"Evolution Stage 3: Multiple Commands\"\ndescription: \"Multiple related commands suggesting need for state\"\nframework: \"NET8\"\ncategory: \"Evolution\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Receptors\", \"Evolution\", \"Multiple Commands\"]\nfilename: \"ProductReceptor cs\"\nusingStatements: [\"Whizbang\"]\n}\npublic class ProductReceptor : \n    IReceptor<CreateProduct>,\n    IReceptor<UpdatePrice>,\n    IReceptor<Discontinue> {\n    // Multiple related commands suggest need for state\n}\n`\nStage 4: Stateful (Event-Sourced)\n`csharp{\ntitle: \"Evolution Stage 4: Stateful Event-Sourced\"\ndescription: \"Final evolution to stateful receptor with internal state\"\nframework: \"NET8\"\ncategory: \"Evolution\"\ndifficulty: \"ADVANCED\"\ntags: [\"Receptors\", \"Evolution\", \"Event-Sourced\", \"Stateful\"]\nfilename: \"ProductReceptor cs\"\nnugetPackages: [\"Whizbang",
        "startIndex": 6641,
        "preview": "ReceiveWithEffects(ProcessPayment cmd) { return ( new PaymentProcessed(cmd OrderId, cmd Amount), new EmailQueued(cmd CustomerEmail, \"Payment received\"..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/receptors-chunk-4",
        "text": "IReceptor<CreateProduct>, IReceptor<UpdatePrice>, IReceptor<Discontinue> { // Multiple related commands suggest need for state } ` Stage 4: Stateful (Event-Sourced) `csharp{ title: \"Evolution Stage 4: Stateful Event-Sourced\" description: \"Final evolution to stateful receptor with internal state\" framework: \"NET8\" category: \"Evolution\" difficulty: \"ADVANCED\" tags: [\"Receptors\", \"Evolution\", \"Event-Sourced\", \"Stateful\"] filename: \"ProductReceptor cs\" nugetPackages: [\"Whizbang EventSourcing\"]\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\n[EventSourced]\npublic class ProductReceptor : \n    IReceptor<CreateProduct>,\n    IReceptor<UpdatePrice>,\n    IReceptor<Discontinue> {\n    private Guid id;\n    private decimal price;\n    private bool isDiscontinued;\n    // Now maintains state across commands\n}\n`\nReceptor Configuration\nConfigure receptors via policies:\n`csharp{\ntitle: \"Receptor Configuration\"\ndescription: \"Configuring receptors with policies and assembly scanning\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Receptors\", \"Configuration\", \"Policies\"]\nfilename: \"Program cs\"\nnugetPackages: [\"Whizbang Core\", \"Microsoft Extensions DependencyInjection\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\nservices AddWhizbang() UseDispatcher(dispatcher => {\n        // Register all receptors\n        dispatcher RegisterReceptorsFromAssembly(typeof(Program) Assembly);\n        // Configure specific receptors\n        dispatcher ForReceptor<OrderReceptor>() UsePolicy(new EventSourcedPolicy {\n                SnapshotFrequency = 100,\n                CacheDuration = TimeSpan FromMinutes(5)\n            });\n        dispatcher ForReceptor<NotificationReceptor>() UsePolicy(new EventDrivenPolicy {\n                MaxConcurrency = 10\n            });\n    });\n`\nBest Practices\nDo's\n✅ Keep receptors focused on decisions\n`csharp{\ntitle: \"Best Practice: Focus on Decisions\"\ndescription: \"Keep receptors focused on business logic and decisions\"\nframework: \"NET8\"\ncategory: \"Best Practices\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Best Practices\", \"Business Logic\"]\nfilename: \"OrderReceptor cs\"\nusingStatements: [\"Whizbang\"]\n}\npublic OrderCreated Receive(CreateOrder cmd) {\n    // Only business logic and decision making\n    return new OrderCreated( );\n}\n`\n✅ Use descriptive event names\n`csharp{\ntitle: \"Best Practice: Descriptive Event Names\"\ndescription: \"Use clear, descriptive names for events\"\nframework: \"NET8\"\ncategory: \"Best Practices\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Best Practices\", \"Event Naming\"]\nfilename: \"OrderReceptor cs\"\nusingStatements: [\"Whizbang\"]\n}\nreturn new OrderShipmentInitiated(",
        "startIndex": 8830,
        "preview": "IReceptor<CreateProduct>, IReceptor<UpdatePrice>, IReceptor<Discontinue> { // Multiple related commands suggest need for state } ` Stage 4: Stateful (..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/receptors-chunk-5",
        "text": "and decision making return new OrderCreated( ); } ` ✅ Use descriptive event names `csharp{ title: \"Best Practice: Descriptive Event Names\" description: \"Use clear, descriptive names for events\" framework: \"NET8\" category: \"Best Practices\" difficulty: \"BEGINNER\" tags: [\"Receptors\", \"Best Practices\", \"Event Naming\"] filename: \"OrderReceptor cs\" usingStatements: [\"Whizbang\"] } return new OrderShipmentInitiated( );  // Clear what happened\n`\n✅ Validate business rules\n`csharp{\ntitle: \"Best Practice: Validate Business Rules\"\ndescription: \"Enforce business rules with clear validation\"\nframework: \"NET8\"\ncategory: \"Best Practices\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Best Practices\", \"Validation\"]\nfilename: \"OrderReceptor cs\"\nusingStatements: [\"System\"]\n}\nif (status = OrderStatus Paid) {\n    throw new BusinessRuleViolationException(\"Order must be paid\");\n}\n`\n✅ Return events for all state changes\n`csharp{\ntitle: \"Best Practice: Return Events for State Changes\"\ndescription: \"Always return events for state changes\"\nframework: \"NET8\"\ncategory: \"Best Practices\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Best Practices\", \"Events\"]\nfilename: \"ProductReceptor cs\"\nusingStatements: [\"Whizbang\"]\n}\npublic PriceUpdated Receive(UpdatePrice cmd) {\n    return new PriceUpdated(id, oldPrice, cmd NewPrice);\n}\n`\nDon'ts\n❌ Don't perform side effects\n`csharp{\ntitle: \"Anti-Pattern: Side Effects\"\ndescription: \"DON'T perform side effects in receptors\"\nframework: \"NET8\"\ncategory: \"Anti-Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Anti-Patterns\", \"Side Effects\"]\nfilename: \"OrderReceptor cs\"\nusingStatements: [\"Whizbang\"]\n}\n// BAD - Side effect in receptor\npublic OrderCreated Receive(CreateOrder cmd) {\n    emailService SendEmail( );  // Don't do this database Save( );           // Don't do this return new OrderCreated( );\n}\n`\n❌ Don't mix read and write concerns\n`csharp{\ntitle: \"Anti-Pattern: Read/Write Mixing\"\ndescription: \"DON'T mix read and write concerns in receptors\"\nframework: \"NET8\"\ncategory: \"Anti-Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Anti-Patterns\", \"CQRS\"]\nfilename: \"OrderReceptor",
        "startIndex": 11111,
        "preview": "and decision making return new OrderCreated( ); } ` ✅ Use descriptive event names `csharp{ title: \"Best Practice: Descriptive Event Names\" description..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/receptors-chunk-6",
        "text": "// Don't do this database Save( ); // Don't do this return new OrderCreated( ); } ` ❌ Don't mix read and write concerns `csharp{ title: \"Anti-Pattern: Read/Write Mixing\" description: \"DON'T mix read and write concerns in receptors\" framework: \"NET8\" category: \"Anti-Patterns\" difficulty: \"BEGINNER\" tags: [\"Receptors\", \"Anti-Patterns\", \"CQRS\"] filename: \"OrderReceptor cs\"\nusingStatements: [\"Whizbang\"]\n}\n// BAD - Receptor shouldn't query\npublic OrderList Receive(GetOrders query) {  // Use Lens instead\n`\n❌ Don't mutate command parameters\n`csharp{\ntitle: \"Anti-Pattern: Mutating Commands\"\ndescription: \"DON'T mutate command parameters\"\nframework: \"NET8\"\ncategory: \"Anti-Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Anti-Patterns\", \"Immutability\"]\nfilename: \"OrderReceptor cs\"\nusingStatements: [\"System Collections Generic\"]\n}\n// BAD - Commands are immutable\ncmd Items Add(newItem);  // Don't modify `\nTesting Receptors\nReceptors are easy to test because they're pure decision functions:\n`csharp{\ntitle: \"Testing Receptors\"\ndescription: \"Unit testing receptors as pure decision functions\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Receptors\", \"Testing\", \"Unit Tests\"]\nfilename: \"OrderReceptorTests cs\"\nnugetPackages: [\"xunit\"]\ntestFile: \"OrderReceptorTests cs\"\ntestMethod: \"CreateOrder_ValidCommand_ReturnsOrderCreatedEvent\"\nusingStatements: [\"System\", \"Xunit\", \"Whizbang\"]\nshowLineNumbers: true\n}\n[Fact]\npublic void CreateOrder_ValidCommand_ReturnsOrderCreatedEvent() {\n    // Arrange\n    var receptor = new OrderReceptor();\n    var command = new CreateOrder {\n        CustomerId = Guid NewGuid(),\n        Items = new[] { new OrderItem(\"SKU-1\", 2, 10 00m) }\n    };\n    // Act\n    var @event = receptor Receive(command);\n    // Assert\n    Assert IsType<OrderCreated>(@event);\n    var orderCreated = (OrderCreated)@event;\n    Assert Equal(command CustomerId, orderCreated CustomerId);\n    Assert Equal(20 00m, orderCreated Total);\n}\n[Fact]\npublic void ShipOrder_UnpaidOrder_ThrowsException() {\n    // Arrange\n    var receptor = new OrderReceptor();\n    receptor Absorb(new OrderCreated( ));  // Not paid\n    // Act & Assert\n    Assert Throws<BusinessRuleViolationException>(\n        () => receptor Receive(new ShipOrder( ))\n    );\n}\n`\nAdvanced Patterns\nCompensating Events\n`csharp{\ntitle: \"Compensating Events Pattern\"\ndescription: \"Returning compensating events for complex operations\"\nframework: \"NET8\"\ncategory: \"Advanced\"\ndifficulty: \"ADVANCED\"\ntags: [\"Receptors\", \"Compensating Events\", \"Advanced\"]\nfilename: \"PaymentReceptor",
        "startIndex": 12836,
        "preview": "// Don't do this database Save( ); // Don't do this return new OrderCreated( ); } ` ❌ Don't mix read and write concerns `csharp{ title: \"Anti-Pattern:..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/receptors-chunk-7",
        "text": "Absorb(new OrderCreated( )); // Not paid // Act & Assert Assert Throws<BusinessRuleViolationException>( () => receptor Receive(new ShipOrder( )) ); } ` Advanced Patterns Compensating Events `csharp{ title: \"Compensating Events Pattern\" description: \"Returning compensating events for complex operations\" framework: \"NET8\" category: \"Advanced\" difficulty: \"ADVANCED\" tags: [\"Receptors\", \"Compensating Events\", \"Advanced\"] filename: \"PaymentReceptor cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class PaymentReceptor : IReceptor<RefundPayment> {\n    public (PaymentRefunded, InventoryReleased) Receive(RefundPayment cmd) {\n        if (status = PaymentStatus Completed) {\n            throw new InvalidOperationException(\"Can only refund completed payments\");\n        }\n        // Return compensating events\n        return (\n            new PaymentRefunded(id, amount, DateTime UtcNow),\n            new InventoryReleased(orderId, items)  // Compensate inventory\n        );\n    }\n}\n`\nConditional Events\n`csharp{\ntitle: \"Conditional Events Pattern\"\ndescription: \"Returning different events based on current state\"\nframework: \"NET8\"\ncategory: \"Advanced\"\ndifficulty: \"ADVANCED\"\ntags: [\"Receptors\", \"Conditional Events\", \"State-Based\"]\nfilename: \"OrderReceptor cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\npublic class OrderReceptor : IReceptor<CompleteOrder> {\n    public object Receive(CompleteOrder cmd) {\n        return status switch {\n            OrderStatus Pending => new OrderCompleted(id),\n            OrderStatus OnHold => (object)(\n                new OrderReleased(id),\n                new OrderCompleted(id)\n            ),\n            _ => throw new InvalidOperationException($\"Cannot complete order in {status} status\")\n        };\n    }\n}\n`\nSaga Initiation\n`csharp{\ntitle: \"Saga Initiation Pattern\"\ndescription: \"Starting distributed transactions with multiple events\"\nframework: \"NET8\"\ncategory: \"Advanced\"\ndifficulty: \"ADVANCED\"\ntags: [\"Receptors\", \"Sagas\", \"Distributed Transactions\"]\nfilename: \"CheckoutReceptor cs\"\nusingStatements: [\"Whizbang\"]\nshowLineNumbers: true\n}\npublic class CheckoutReceptor : IReceptor<Checkout> {\n    public (CheckoutStarted, ReserveInventory, ProcessPayment) Receive(Checkout cmd) {\n        // Start a distributed transaction\n        return (\n            new CheckoutStarted(cmd OrderId),\n            new ReserveInventory(cmd OrderId, cmd Items),\n            new ProcessPayment(cmd OrderId, cmd PaymentMethod, cmd",
        "startIndex": 15042,
        "preview": "Absorb(new OrderCreated( )); // Not paid // Act & Assert Assert Throws<BusinessRuleViolationException>( () => receptor Receive(new ShipOrder( )) ); } ..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/receptors-chunk-8",
        "text": "\"Advanced\" difficulty: \"ADVANCED\" tags: [\"Receptors\", \"Sagas\", \"Distributed Transactions\"] filename: \"CheckoutReceptor cs\" usingStatements: [\"Whizbang\"] showLineNumbers: true } public class CheckoutReceptor : IReceptor<Checkout> { public (CheckoutStarted, ReserveInventory, ProcessPayment) Receive(Checkout cmd) { // Start a distributed transaction return ( new CheckoutStarted(cmd OrderId), new ReserveInventory(cmd OrderId, cmd Items), new ProcessPayment(cmd OrderId, cmd PaymentMethod, cmd Total)\n        );\n    }\n}\n`\nSummary\nReceptors are the heart of Whizbang's decision-making:\nUniversal interface works in both Event-Driven and Event-Sourced modes\nPure functions that transform commands into events\nProgressive enhancement from stateless to stateful\nTestable without infrastructure dependencies\nComposable through return type semantics\nWhether stateless or stateful, receptors ensure your business logic remains clean, testable, and portable across different deployment modes Next Steps\nExplore Perspectives - How events update views\nLearn about Lenses - Read-only state access\nSee Event-Driven Architecture - The bigger picture\nReview Testing Strategies - Testing receptors",
        "startIndex": 17099,
        "preview": "\"Advanced\" difficulty: \"ADVANCED\" tags: [\"Receptors\", \"Sagas\", \"Distributed Transactions\"] filename: \"CheckoutReceptor cs\" usingStatements: [\"Whizbang..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/core-concepts/repositories-and-helpers",
    "title": "Repositories and CQRS Helpers",
    "category": "Core Concepts",
    "url": "/docs/old-v1.0.0.0/core-concepts/repositories-and-helpers",
    "chunks": [
      {
        "id": "old-v1.0.0.0/core-concepts/repositories-and-helpers-chunk-0",
        "text": "Repositories and CQRS Helpers\nWhizbang provides rich framework support for implementing CQRS patterns through repositories, query handlers, and helper classes that separate concerns across the write and read sides of your application Repository Patterns\nWrite-Side Repository (Aggregates)\nThe IRepository<TAggregate> interface handles loading and saving event-sourced aggregates:\n`csharp{\ntitle: \"Aggregate Repository Interface\"\ndescription: \"Core interface for aggregate persistence\"\nframework: \"NET8\"\ncategory: \"Repositories\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Repositories\", \"Aggregates\", \"Event Sourcing\"]\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nnamespace Whizbang EventSourcing;\npublic interface IRepository<TAggregate> where TAggregate : Aggregate {\n    /// <summary>\n    /// Loads an aggregate by replaying its event stream /// </summary>\n    Task<TAggregate > FindAsync(Guid id, CancellationToken ct = default);\n    /// <summary>\n    /// Loads an aggregate, throwing if not found /// </summary>\n    Task<TAggregate> GetAsync(Guid id, CancellationToken ct = default);\n    /// <summary>\n    /// Saves uncommitted events from the aggregate to the event store /// </summary>\n    Task SaveAsync(TAggregate aggregate, CancellationToken ct = default);\n    /// <summary>\n    /// Loads aggregate as of a specific version (point-in-time query) /// </summary>\n    Task<TAggregate > GetAsOfAsync(Guid id, long version, CancellationToken ct = default);\n    /// <summary>\n    /// Loads aggregate as of a specific timestamp (time-travel debugging) /// </summary>\n    Task<TAggregate > GetAsOfAsync(Guid id, DateTimeOffset timestamp, CancellationToken ct = default);\n}\n`\nUsage:\n`csharp{\ntitle: \"Using Aggregate Repository\"\ndescription: \"Load, modify, and save an aggregate\"\nframework: \"NET8\"\ncategory: \"Repositories\"\ndifficulty: \"BEGINNER\"\ntags: [\"Repositories\", \"Aggregates\", \"Commands\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\npublic class PlaceOrderHandler {\n    private readonly IRepository<Order> _orderRepository;\n    public PlaceOrderHandler(IRepository<Order> orderRepository) {\n        _orderRepository = orderRepository;\n    }\n    public async Task<OrderPlaced> Handle(PlaceOrder command) {\n        // Create new aggregate\n        var order = new Order(command CustomerId, command Items);\n        // Save (appends events to stream)\n        await _orderRepository SaveAsync(order);\n        return new OrderPlaced(order Id, command CustomerId, order",
        "startIndex": 0,
        "preview": "Repositories and CQRS Helpers\nWhizbang provides rich framework support for implementing CQRS patterns through repositories, query handlers, and helper..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/repositories-and-helpers-chunk-1",
        "text": "public class PlaceOrderHandler { private readonly IRepository<Order> _orderRepository; public PlaceOrderHandler(IRepository<Order> orderRepository) { _orderRepository = orderRepository; } public async Task<OrderPlaced> Handle(PlaceOrder command) { // Create new aggregate var order = new Order(command CustomerId, command Items); // Save (appends events to stream) await _orderRepository SaveAsync(order); return new OrderPlaced(order Id, command CustomerId, order Total);\n    }\n}\n`\nRead-Side Repository (Projections)\nThe IProjectionStore<TProjection> interface handles querying denormalized read models:\n`csharp{\ntitle: \"Projection Store Interface\"\ndescription: \"Interface for querying read models\"\nframework: \"NET8\"\ncategory: \"Repositories\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Queries\", \"CQRS\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\", \"System Linq Expressions\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Linq Expressions;\nusing System Threading Tasks;\nnamespace Whizbang Projections;\npublic interface IProjectionStore<TProjection> where TProjection : class {\n    /// <summary>\n    /// Gets a projection by ID /// </summary>\n    Task<TProjection > GetAsync(Guid id, CancellationToken ct = default);\n    /// <summary>\n    /// Queries projections using a predicate /// </summary>\n    Task<List<TProjection>> QueryAsync(\n        Expression<Func<TProjection, bool>> predicate,\n        CancellationToken ct = default\n    );\n    /// <summary>\n    /// Paged query for large result sets /// </summary>\n    Task<PagedResult<TProjection>> QueryPagedAsync(\n        Expression<Func<TProjection, bool>> predicate,\n        int page,\n        int pageSize,\n        CancellationToken ct = default\n    );\n    /// <summary>\n    /// Inserts or updates a projection /// </summary>\n    Task UpsertAsync(Guid id, TProjection projection, CancellationToken ct = default);\n    /// <summary>\n    /// Updates an existing projection /// </summary>\n    Task UpdateAsync(Guid id, Action<TProjection> update, CancellationToken ct = default);\n    /// <summary>\n    /// Deletes a projection /// </summary>\n    Task DeleteAsync(Guid id, CancellationToken ct = default);\n}\n`\nUsage:\n`csharp{\ntitle: \"Querying Projection Store\"\ndescription: \"Query read models for customer orders\"\nframework: \"NET8\"\ncategory: \"Repositories\"\ndifficulty: \"BEGINNER\"\ntags: [\"Projections\", \"Queries\", \"CQRS\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\", \"Whizbang Projections\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nusing Whizbang",
        "startIndex": 2668,
        "preview": "public class PlaceOrderHandler { private readonly IRepository<Order> _orderRepository; public PlaceOrderHandler(IRepository<Order> orderRepository) { ..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/repositories-and-helpers-chunk-2",
        "text": "} ` Usage: `csharp{ title: \"Querying Projection Store\" description: \"Query read models for customer orders\" framework: \"NET8\" category: \"Repositories\" difficulty: \"BEGINNER\" tags: [\"Projections\", \"Queries\", \"CQRS\"] usingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\", \"Whizbang Projections\"] showLineNumbers: true } using System; using System Collections Generic; using System Threading Tasks; using Whizbang Projections;\npublic class OrderQueryService {\n    private readonly IProjectionStore<OrderHistoryItem> _store;\n    public OrderQueryService(IProjectionStore<OrderHistoryItem> store) {\n        _store = store;\n    }\n    public async Task<List<OrderHistoryItem>> GetCustomerOrdersAsync(Guid customerId) {\n        return await _store QueryAsync(order => order CustomerId == customerId);\n    }\n    public async Task<PagedResult<OrderHistoryItem>> GetRecentOrdersAsync(int page, int pageSize) {\n        return await _store QueryPagedAsync(\n            order => order Status = \"Cancelled\",\n            page,\n            pageSize\n        );\n    }\n}\n`\nCQRS Helper Classes\nCommand Bus\nThe ICommandBus sends commands to their handlers:\n`csharp{\ntitle: \"Command Bus Interface\"\ndescription: \"Send commands and receive results\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Commands\", \"CQRS\", \"Messaging\"]\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nnamespace Whizbang;\npublic interface ICommandBus {\n    /// <summary>\n    /// Sends a command and waits for result /// </summary>\n    Task<TResult> SendAsync<TResult>(object command, CancellationToken ct = default);\n    /// <summary>\n    /// Sends a command without waiting for result (fire-and-forget) /// </summary>\n    Task PublishAsync(object command, CancellationToken ct = default);\n    /// <summary>\n    /// Sends multiple commands in a batch /// </summary>\n    Task PublishBatchAsync(IEnumerable<object> commands, CancellationToken ct = default);\n}\n`\nQuery Bus\nThe IQueryBus executes queries against projections:\n`csharp{\ntitle: \"Query Bus Interface\"\ndescription: \"Execute queries and return results\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Queries\", \"CQRS\", \"Projections\"]\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nnamespace Whizbang;\npublic interface IQueryBus {\n    /// <summary>\n    /// Executes a query and returns result",
        "startIndex": 4910,
        "preview": "} ` Usage: `csharp{ title: \"Querying Projection Store\" description: \"Query read models for customer orders\" framework: \"NET8\" category: \"Repositories\"..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/repositories-and-helpers-chunk-3",
        "text": "`csharp{ title: \"Query Bus Interface\" description: \"Execute queries and return results\" framework: \"NET8\" category: \"CQRS\" difficulty: \"INTERMEDIATE\" tags: [\"Queries\", \"CQRS\", \"Projections\"] usingStatements: [\"System\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading Tasks; namespace Whizbang; public interface IQueryBus { /// <summary> /// Executes a query and returns result /// </summary>\n    Task<TResult> QueryAsync<TResult>(object query, CancellationToken ct = default);\n}\n`\nUsage:\n`csharp{\ntitle: \"Using Query Bus\"\ndescription: \"Execute queries via query bus\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"BEGINNER\"\ntags: [\"Queries\", \"CQRS\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nusing Whizbang;\n// Define query\npublic record GetCustomerOrders(Guid CustomerId);\n// Define query handler\npublic class GetCustomerOrdersHandler {\n    private readonly IProjectionStore<OrderHistoryItem> _store;\n    public GetCustomerOrdersHandler(IProjectionStore<OrderHistoryItem> store) {\n        _store = store;\n    }\n    public async Task<List<OrderHistoryItem>> Handle(GetCustomerOrders query) {\n        return await _store QueryAsync(o => o CustomerId == query CustomerId);\n    }\n}\n// Execute query\npublic class OrderController {\n    private readonly IQueryBus _queryBus;\n    public OrderController(IQueryBus queryBus) {\n        _queryBus = queryBus;\n    }\n    public async Task<IActionResult> GetOrders(Guid customerId) {\n        var orders = await _queryBus QueryAsync<List<OrderHistoryItem>>(\n            new GetCustomerOrders(customerId)\n        );\n        return Ok(orders);\n    }\n}\n`\nEvent Publisher\nThe IEventPublisher publishes domain events to subscribers:\n`csharp{\ntitle: \"Event Publisher Interface\"\ndescription: \"Publish events to subscribers\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Events\", \"Publishing\", \"Messaging\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nnamespace Whizbang;\npublic interface IEventPublisher {\n    /// <summary>\n    /// Publishes a single event to all subscribers /// </summary>\n    Task PublishAsync(object @event, CancellationToken ct = default);\n    /// <summary>\n    /// Publishes multiple events in order /// </summary>\n    Task PublishBatchAsync(IEnumerable<object> events, CancellationToken ct = default);\n    /// <summary>\n    /// Publishes event to specific subscribers (filtered)",
        "startIndex": 7012,
        "preview": "`csharp{ title: \"Query Bus Interface\" description: \"Execute queries and return results\" framework: \"NET8\" category: \"CQRS\" difficulty: \"INTERMEDIATE\" ..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/repositories-and-helpers-chunk-4",
        "text": "Whizbang; public interface IEventPublisher { /// <summary> /// Publishes a single event to all subscribers /// </summary> Task PublishAsync(object @event, CancellationToken ct = default); /// <summary> /// Publishes multiple events in order /// </summary> Task PublishBatchAsync(IEnumerable<object> events, CancellationToken ct = default); /// <summary> /// Publishes event to specific subscribers (filtered) /// </summary>\n    Task PublishToAsync(object @event, string subscriberFilter, CancellationToken ct = default);\n}\n`\nSpecialized Helpers\nUnit of Work Pattern\nFor scenarios requiring transactional consistency across multiple aggregates:\n`csharp{\ntitle: \"Unit of Work Interface\"\ndescription: \"Transactional boundary for multiple aggregates\"\nframework: \"NET8\"\ncategory: \"Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Unit of Work\", \"Transactions\", \"Aggregates\"]\nusingStatements: [\"System\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nnamespace Whizbang EventSourcing;\npublic interface IUnitOfWork : IDisposable {\n    /// <summary>\n    /// Gets a repository for an aggregate type /// </summary>\n    IRepository<TAggregate> Repository<TAggregate>() where TAggregate : Aggregate;\n    /// <summary>\n    /// Commits all changes across all aggregates /// </summary>\n    Task CommitAsync(CancellationToken ct = default);\n    /// <summary>\n    /// Rolls back all changes /// </summary>\n    Task RollbackAsync(CancellationToken ct = default);\n}\n`\nUsage (use sparingly - violates aggregate boundaries):\n`csharp{\ntitle: \"Using Unit of Work\"\ndescription: \"Transactional update across multiple aggregates\"\nframework: \"NET8\"\ncategory: \"Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Unit of Work\", \"Transactions\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang EventSourcing\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang EventSourcing;\npublic class TransferInventoryHandler {\n    private readonly IUnitOfWork _unitOfWork;\n    public TransferInventoryHandler(IUnitOfWork unitOfWork) {\n        _unitOfWork = unitOfWork;\n    }\n    public async Task Handle(TransferInventory command) {\n        var sourceWarehouse = await _unitOfWork Repository<Warehouse>() GetAsync(command SourceWarehouseId);\n        var destWarehouse = await _unitOfWork Repository<Warehouse>() GetAsync(command DestinationWarehouseId);\n        // Both aggregates modified in same transaction\n        sourceWarehouse RemoveInventory(command ProductId, command Quantity);\n        destWarehouse AddInventory(command ProductId, command Quantity);\n        await _unitOfWork Repository<Warehouse>() SaveAsync(sourceWarehouse);\n        await _unitOfWork Repository<Warehouse>() SaveAsync(destWarehouse);\n        // Atomic commit\n        await _unitOfWork",
        "startIndex": 9302,
        "preview": "Whizbang; public interface IEventPublisher { /// <summary> /// Publishes a single event to all subscribers /// </summary> Task PublishAsync(object @ev..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/repositories-and-helpers-chunk-5",
        "text": "Task Handle(TransferInventory command) { var sourceWarehouse = await _unitOfWork Repository<Warehouse>() GetAsync(command SourceWarehouseId); var destWarehouse = await _unitOfWork Repository<Warehouse>() GetAsync(command DestinationWarehouseId); // Both aggregates modified in same transaction sourceWarehouse RemoveInventory(command ProductId, command Quantity); destWarehouse AddInventory(command ProductId, command Quantity); await _unitOfWork Repository<Warehouse>() SaveAsync(sourceWarehouse); await _unitOfWork Repository<Warehouse>() SaveAsync(destWarehouse); // Atomic commit await _unitOfWork CommitAsync();\n    }\n}\n`\nWarning: Use sagas instead when possible to maintain aggregate boundaries Specification Pattern\nFor complex query logic:\n`csharp{\ntitle: \"Specification Pattern\"\ndescription: \"Reusable query specifications\"\nframework: \"NET8\"\ncategory: \"Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Specification\", \"Queries\", \"Patterns\"]\nusingStatements: [\"System\", \"System Linq Expressions\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Linq Expressions;\nnamespace Whizbang Projections;\npublic interface ISpecification<TProjection> {\n    Expression<Func<TProjection, bool>> Predicate { get; }\n}\npublic class ActiveOrdersSpecification : ISpecification<OrderHistoryItem> {\n    public Expression<Func<OrderHistoryItem, bool>> Predicate =>\n        order => order Status = \"Cancelled\" && order Status = \"Delivered\";\n}\npublic class CustomerOrdersSpecification : ISpecification<OrderHistoryItem> {\n    private readonly Guid _customerId;\n    public CustomerOrdersSpecification(Guid customerId) {\n        _customerId = customerId;\n    }\n    public Expression<Func<OrderHistoryItem, bool>> Predicate =>\n        order => order CustomerId == _customerId;\n}\n`\nUsage:\n`csharp{\ntitle: \"Using Specifications\"\ndescription: \"Compose reusable query specifications\"\nframework: \"NET8\"\ncategory: \"Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Specification\", \"Queries\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"System Collections Generic\", \"Whizbang Projections\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading Tasks;\nusing Whizbang Projections;\npublic class OrderQueryService {\n    private readonly IProjectionStore<OrderHistoryItem> _store;\n    public OrderQueryService(IProjectionStore<OrderHistoryItem> store) {\n        _store = store;\n    }\n    public async Task<List<OrderHistoryItem>> GetActiveCustomerOrdersAsync(Guid customerId) {\n        var spec = new ActiveOrdersSpecification() And(new CustomerOrdersSpecification(customerId));\n        return await _store QueryAsync(spec Predicate);\n    }\n}\n`\nProjection Builder\nHelper for building complex projections:\n`csharp{\ntitle: \"Projection Builder\"\ndescription: \"Fluent API for building projections\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Builder Pattern\"]\nusingStatements: [\"System\", \"Whizbang Projections\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang",
        "startIndex": 11761,
        "preview": "Task Handle(TransferInventory command) { var sourceWarehouse = await _unitOfWork Repository<Warehouse>() GetAsync(command SourceWarehouseId); var dest..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/repositories-and-helpers-chunk-6",
        "text": "new ActiveOrdersSpecification() And(new CustomerOrdersSpecification(customerId)); return await _store QueryAsync(spec Predicate); } } ` Projection Builder Helper for building complex projections: `csharp{ title: \"Projection Builder\" description: \"Fluent API for building projections\" framework: \"NET8\" category: \"Projections\" difficulty: \"ADVANCED\" tags: [\"Projections\", \"Builder Pattern\"] usingStatements: [\"System\", \"Whizbang Projections\"] showLineNumbers: true } using System; using Whizbang Projections;\npublic class OrderSummaryProjectionBuilder : ProjectionBuilder<OrderSummary> {\n    public OrderSummaryProjectionBuilder() {\n        // Subscribe to events\n        On<OrderPlaced>(@event => {\n            Upsert(@event OrderId, new OrderSummary {\n                OrderId = @event OrderId,\n                CustomerId = @event CustomerId,\n                Total = @event Total,\n                Status = \"Placed\"\n            });\n        });\n        On<OrderShipped>(@event => {\n            Update(@event OrderId, summary => {\n                summary Status = \"Shipped\";\n                summary ShippedAt = @event ShippedAt;\n            });\n        });\n        On<OrderCancelled>(@event => {\n            Update(@event OrderId, summary => summary Status = \"Cancelled\");\n        });\n    }\n}\n`\nMulti-Tenant Repository Support\nAll repository interfaces support tenant scoping:\n`csharp{\ntitle: \"Multi-Tenant Repository\"\ndescription: \"Tenant-scoped aggregate repository\"\nframework: \"NET8\"\ncategory: \"Multi-Tenancy\"\ndifficulty: \"ADVANCED\"\ntags: [\"Multi-Tenancy\", \"Repositories\", \"Security\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang EventSourcing\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang EventSourcing;\npublic interface ITenantRepository<TAggregate> where TAggregate : Aggregate {\n    /// <summary>\n    /// Loads aggregate for specific tenant /// </summary>\n    Task<TAggregate > FindAsync(Guid tenantId, Guid aggregateId, CancellationToken ct = default);\n    /// <summary>\n    /// Saves aggregate with tenant isolation /// Stream ID: \"Tenant-{tenantId}-Order-{orderId}\"\n    /// </summary>\n    Task SaveAsync(Guid tenantId, TAggregate aggregate, CancellationToken ct = default);\n}\n// Usage with tenant context\npublic class PlaceOrderHandler {\n    private readonly ITenantRepository<Order> _repository;\n    private readonly ITenantContext _tenantContext;\n    public PlaceOrderHandler(ITenantRepository<Order> repository, ITenantContext tenantContext) {\n        _repository = repository;\n        _tenantContext = tenantContext;\n    }\n    public async Task<OrderPlaced> Handle(PlaceOrder command) {\n        var order = new Order(command CustomerId, command Items);\n        // Tenant ID from context (claims, header, etc )\n        await _repository SaveAsync(_tenantContext TenantId, order);\n        return new OrderPlaced(order Id, command CustomerId, order",
        "startIndex": 14195,
        "preview": "new ActiveOrdersSpecification() And(new CustomerOrdersSpecification(customerId)); return await _store QueryAsync(spec Predicate); } } ` Projection Bui..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/repositories-and-helpers-chunk-7",
        "text": "ITenantContext _tenantContext; public PlaceOrderHandler(ITenantRepository<Order> repository, ITenantContext tenantContext) { _repository = repository; _tenantContext = tenantContext; } public async Task<OrderPlaced> Handle(PlaceOrder command) { var order = new Order(command CustomerId, command Items); // Tenant ID from context (claims, header, etc ) await _repository SaveAsync(_tenantContext TenantId, order); return new OrderPlaced(order Id, command CustomerId, order Total);\n    }\n}\n`\nPermission-Scoped Repositories\nRepositories can enforce permissions:\n`csharp{\ntitle: \"Permission-Scoped Repository\"\ndescription: \"Repository with built-in authorization\"\nframework: \"NET8\"\ncategory: \"Security\"\ndifficulty: \"ADVANCED\"\ntags: [\"Security\", \"Authorization\", \"Repositories\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang EventSourcing\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang EventSourcing;\npublic interface ISecureRepository<TAggregate> where TAggregate : Aggregate {\n    /// <summary>\n    /// Loads aggregate only if user has read permission /// </summary>\n    Task<TAggregate > FindAsync(Guid id, CancellationToken ct = default);\n    /// <summary>\n    /// Saves aggregate only if user has write permission /// Throws UnauthorizedAccessException if permission denied /// </summary>\n    Task SaveAsync(TAggregate aggregate, CancellationToken ct = default);\n}\n// Configuration\nservices AddWhizbang(options => {\n    options UseRepositories(repos => {\n        repos EnforcePermissions = true;\n        repos RequirePermission<Order>(\"orders:read\", \"orders:write\");\n        repos RequirePermission<Inventory>(\"inventory:read\", \"inventory:write\");\n    });\n});\n`\nNext Steps\nTesting - Test repositories and handlers\nMulti-Tenancy - Deep dive into tenant isolation\nSecurity - Authorization and authentication patterns",
        "startIndex": 16625,
        "preview": "ITenantContext _tenantContext; public PlaceOrderHandler(ITenantRepository<Order> repository, ITenantContext tenantContext) { _repository = repository;..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/core-concepts/return-type-semantics",
    "title": "Return Type Semantics",
    "category": "Core Concepts",
    "url": "/docs/old-v1.0.0.0/core-concepts/return-type-semantics",
    "chunks": [
      {
        "id": "old-v1.0.0.0/core-concepts/return-type-semantics-chunk-0",
        "text": "Return Type Semantics\nOverview\nIn Whizbang, what you return determines what happens next This simple yet powerful concept eliminates configuration and makes your code's intent crystal clear Inspired by Wolverine's approach but extended to cover all messaging patterns Core Philosophy\nTraditional messaging libraries require explicit configuration:\n`csharp\n---\ncategory: Core Concepts\ndifficulty: BEGINNER\ntags: [Traditional-Messaging, Configuration, Explicit-Calls]\ndescription: Traditional messaging approach with explicit method calls\n---\n// Traditional approach - configuration separate from logic\nawait bus Publish(event1);\nawait bus Send(command1);\nawait bus Reply(response1);\nawait bus Defer(message1, TimeSpan FromMinutes(5));\n`\nWhizbang's approach - return values drive behavior:\n`csharp\n---\ncategory: Core Concepts\ndifficulty: BEGINNER\ntags: [Return-Type-Semantics, Convention-Over-Configuration, Intent]\ndescription: Whizbang's return-based messaging with clear intent\n---\n// Whizbang - intent is clear from return type\nreturn event1;                                    // Publishes event\nreturn command1;                                  // Sends command  \nreturn response1;                                 // Replies to sender\nreturn message1 After(TimeSpan FromMinutes(5));  // Defers message\n`\nBasic Return Types\nSingle Message Return\n`csharp\n---\ncategory: Core Concepts\ndifficulty: BEGINNER\ntags: [Return-Type-Semantics, Single-Message, Event-Publishing]\ndescription: Single message return publishes event automatically\n---\npublic class OrderHandler : IHandle<CreateOrder> {\n    // Returning a single message publishes it as an event\n    public OrderCreated Handle(CreateOrder cmd) {\n        var order = CreateOrder(cmd);\n        return new OrderCreated(order Id, order Total);\n    }\n}\n`\nBehavior:\nIf return type implements IEvent → Publish to all subscribers\nIf return type implements ICommand → Send to single handler\nIf return type implements IResponse → Reply to original sender\nVoid Return (Fire-and-Forget)\n`csharp\n---\ncategory: Core Concepts\ndifficulty: BEGINNER\ntags: [Return-Type-Semantics, Void-Return, Fire-And-Forget]\ndescription: Void return for fire-and-forget operations\n---\npublic class NotificationHandler : IHandle<SendNotification> {\n    // Void means no follow-up messages\n    public void Handle(SendNotification cmd) {\n        Console WriteLine($\"Notification: {cmd",
        "startIndex": 0,
        "preview": "Return Type Semantics\nOverview\nIn Whizbang, what you return determines what happens next This simple yet powerful concept eliminates configuration and..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/return-type-semantics-chunk-1",
        "text": "return type implements IResponse → Reply to original sender Void Return (Fire-and-Forget) `csharp --- category: Core Concepts difficulty: BEGINNER tags: [Return-Type-Semantics, Void-Return, Fire-And-Forget] description: Void return for fire-and-forget operations --- public class NotificationHandler : IHandle<SendNotification> { // Void means no follow-up messages public void Handle(SendNotification cmd) { Console WriteLine($\"Notification: {cmd Message}\");\n        // No return = no cascading messages\n    }\n}\n`\nBehavior: Handler executes with no subsequent messages\nTask Return (Async Void)\n`csharp\n---\ncategory: Core Concepts\ndifficulty: BEGINNER\ntags: [Return-Type-Semantics, Async-Void, Task-Return]\ndescription: Async Task return for asynchronous fire-and-forget operations\n---\npublic class EmailHandler : IHandle<SendEmail> {\n    // Async with no result\n    public async Task Handle(SendEmail cmd) {\n        await emailService SendAsync(cmd To, cmd Subject, cmd Body);\n        // No return value = no cascading messages\n    }\n}\n`\nBehavior: Async execution with no follow-up messages\nAdvanced Return Types\nTuple Return (Multiple Effects)\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Tuple-Return, Multiple-Effects]\ndescription: Tuple return for multiple cascading messages\n---\npublic class OrderHandler : IHandle<CreateOrder> {\n    // Return multiple messages in one operation\n    public (OrderCreated, ProcessPayment, SendConfirmation) Handle(CreateOrder cmd) {\n        var order = CreateOrder(cmd);\n        return (\n            new OrderCreated(order Id, order Total),           // Publish event\n            new ProcessPayment(order Id, order Total),         // Send command\n            new SendConfirmation(order CustomerEmail, order Id) // Send command\n        );\n    }\n}\n`\nBehavior: All messages in tuple are processed according to their type\nResult Type (Railway-Oriented Programming)\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Result-Type, Railway-Oriented-Programming]\ndescription: Result type for success/failure handling with railway-oriented programming\n---\npublic class OrderHandler : IHandle<CreateOrder> {\n    // Result<T> for success/failure handling\n    public Result<OrderCreated> Handle(CreateOrder cmd) {\n        if ( IsValid(cmd)) {\n            return Result Failure<OrderCreated>(\"Invalid order data\");\n        }\n        var order = CreateOrder(cmd);\n        return Result Success(new OrderCreated(order",
        "startIndex": 2405,
        "preview": "return type implements IResponse → Reply to original sender Void Return (Fire-and-Forget) `csharp --- category: Core Concepts difficulty: BEGINNER tag..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/return-type-semantics-chunk-2",
        "text": "difficulty: INTERMEDIATE tags: [Return-Type-Semantics, Result-Type, Railway-Oriented-Programming] description: Result type for success/failure handling with railway-oriented programming --- public class OrderHandler : IHandle<CreateOrder> { // Result<T> for success/failure handling public Result<OrderCreated> Handle(CreateOrder cmd) { if ( IsValid(cmd)) { return Result Failure<OrderCreated>(\"Invalid order data\"); } var order = CreateOrder(cmd); return Result Success(new OrderCreated(order Id));\n    }\n}\n// Alternative with custom error type\npublic class PaymentHandler : IHandle<ProcessPayment> {\n    public Result<PaymentProcessed, PaymentError> Handle(ProcessPayment cmd) {\n        try {\n            var transaction = ProcessPayment(cmd);\n            return Result Success(new PaymentProcessed(transaction Id));\n        }\n        catch (InsufficientFundsException ex) {\n            return Result Failure(new PaymentError(\"Insufficient funds\", ex));\n        }\n    }\n}\n`\nBehavior:\nOn Success → Process success value\nOn Failure → Handle error (can trigger compensation)\nIAsyncEnumerable (Streaming Results)\n`csharp\n---\ncategory: Core Concepts\ndifficulty: ADVANCED\ntags: [Return-Type-Semantics, Streaming, IAsyncEnumerable, Yield]\ndescription: IAsyncEnumerable return for streaming results as they're processed\n---\npublic class BatchHandler : IHandle<ProcessBatch> {\n    // Stream results as they're processed\n    public async IAsyncEnumerable<OrderProcessed> Handle(ProcessBatch cmd) {\n        foreach (var item in cmd Items) {\n            await Task Delay(100); // Simulate processing\n            var result = ProcessItem(item);\n            yield return new OrderProcessed(result Id, result Status);\n            // Each yielded item is immediately published\n        }\n    }\n}\n`\nBehavior: Each yielded item is processed as it's produced (streaming)\nOption Type (Maybe Monad)\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Option-Type, Maybe-Monad, Null-Safety]\ndescription: Option type for queries that might return nothing\n---\npublic class QueryHandler : IHandle<GetOrder> {\n    // Option<T> for queries that might return nothing\n    public Option<Order> Handle(GetOrder query) {\n        var order = repository FindById(query OrderId);\n        return order = null Option Some(order)\n            : Option",
        "startIndex": 4484,
        "preview": "difficulty: INTERMEDIATE tags: [Return-Type-Semantics, Result-Type, Railway-Oriented-Programming] description: Result type for success/failure handlin..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/return-type-semantics-chunk-3",
        "text": "difficulty: INTERMEDIATE tags: [Return-Type-Semantics, Option-Type, Maybe-Monad, Null-Safety] description: Option type for queries that might return nothing --- public class QueryHandler : IHandle<GetOrder> { // Option<T> for queries that might return nothing public Option<Order> Handle(GetOrder query) { var order = repository FindById(query OrderId); return order = null Option Some(order) : Option None<Order>();\n    }\n}\n`\nBehavior:\nSome(value) → Process the value\nNone → Handle absence (no error)\nSpecialized Return Types\nDeferred Messages\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Deferred-Messages, Scheduling, Time-Based]\ndescription: Deferred message return for scheduled future delivery\n---\npublic class ReminderHandler : IHandle<ScheduleReminder> {\n    // Defer message with fluent syntax\n    public Deferred<SendReminder> Handle(ScheduleReminder cmd) {\n        return new SendReminder(cmd UserId, cmd Message) After(TimeSpan FromHours(24));\n    }\n    // Or with specific time\n    public Deferred<SendReminder> HandleAt(ScheduleReminder cmd) {\n        return new SendReminder(cmd UserId, cmd Message) At(DateTime UtcNow AddDays(1) Date AddHours(9)); // Tomorrow 9 AM\n    }\n}\n`\nBehavior: Message is scheduled for future delivery\nSaga Instructions\n`csharp\n---\ncategory: Core Concepts\ndifficulty: ADVANCED\ntags: [Return-Type-Semantics, Saga, Orchestration, Timeout-Handling]\ndescription: Saga action return for complex orchestration with timeout handling\n---\npublic class OrderSaga : Saga<OrderState> {\n    // Return saga instructions\n    public SagaAction Handle(OrderCreated @event) {\n        State OrderId = @event OrderId;\n        State Status = \"Created\";\n        return SagaAction Send(new ProcessPayment(@event OrderId, @event Total)) After(TimeSpan FromSeconds(5)) WithTimeout(TimeSpan FromMinutes(10)) OnTimeout(new CancelOrder(@event OrderId));\n    }\n}\n`\nBehavior: Complex saga orchestration with timeout handling\nBatched Returns\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Batch-Processing, Collections, LINQ]\ndescription: Collection return for batch message processing\n---\npublic class BatchHandler : IHandle<ProcessOrders> {\n    // Return collection of messages\n    public IEnumerable<IMessage> Handle(ProcessOrders cmd) {\n        var messages = new List<IMessage>();\n        foreach (var orderId in cmd OrderIds) {\n            messages Add(new ProcessOrder(orderId));\n            messages Add(new LogOrderProcessing(orderId));\n        }\n        return messages;\n    }\n    // Or with LINQ\n    public IEnumerable<ProcessOrder> HandleLinq(ProcessOrders cmd) {\n        return cmd OrderIds",
        "startIndex": 6359,
        "preview": "difficulty: INTERMEDIATE tags: [Return-Type-Semantics, Option-Type, Maybe-Monad, Null-Safety] description: Option type for queries that might return n..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/return-type-semantics-chunk-4",
        "text": "public class BatchHandler : IHandle<ProcessOrders> { // Return collection of messages public IEnumerable<IMessage> Handle(ProcessOrders cmd) { var messages = new List<IMessage>(); foreach (var orderId in cmd OrderIds) { messages Add(new ProcessOrder(orderId)); messages Add(new LogOrderProcessing(orderId)); } return messages; } // Or with LINQ public IEnumerable<ProcessOrder> HandleLinq(ProcessOrders cmd) { return cmd OrderIds Select(id => new ProcessOrder(id));\n    }\n}\n`\nBehavior: All messages in collection are processed\nConditional Returns\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Pattern-Matching, Conditional-Logic, Switch-Expressions]\ndescription: Conditional return using pattern matching and switch expressions\n---\npublic class ConditionalHandler : IHandle<ProcessOrder> {\n    // Use pattern matching for conditional returns\n    public IMessage Handle(ProcessOrder cmd) {\n        return cmd Priority switch {\n            Priority High => new ProcessImmediately(cmd OrderId),\n            Priority Normal => new ProcessOrder(cmd OrderId) After(\"5m\"),\n            Priority Low => new QueueForBatch(cmd OrderId),\n            _ => new LogUnknownPriority(cmd OrderId)\n        };\n    }\n}\n`\nBehavior: Different messages based on conditions\nComplex Return Patterns\nNested Tuples for Grouping\n`csharp\n---\ncategory: Core Concepts\ndifficulty: ADVANCED\ntags: [Return-Type-Semantics, Nested-Tuples, Message-Grouping, Complex-Returns]\ndescription: Nested tuples for grouping related messages logically\n---\npublic class ComplexHandler : IHandle<ComplexCommand> {\n    // Group related messages\n    public ((OrderCreated, InventoryReserved), (SendEmail, LogActivity)) Handle(ComplexCommand cmd) {\n        var order = CreateOrder(cmd);\n        var inventory = ReserveInventory(cmd);\n        return (\n            // Business events\n            (new OrderCreated(order Id), new InventoryReserved(inventory Id)),\n            // Side effects\n            (new SendEmail(cmd Email), new LogActivity(\"Order created\"))\n        );\n    }\n}\n`\nDiscriminated Unions\n`csharp\n---\ncategory: Core Concepts\ndifficulty: ADVANCED\ntags: [Return-Type-Semantics, Discriminated-Unions, OneOf, Outcome-Based-Returns]\ndescription: Discriminated union return for different outcomes\n---\npublic class PaymentHandler : IHandle<ProcessPayment> {\n    // Return different types based on outcome\n    public OneOf<PaymentSucceeded, PaymentFailed, PaymentPending> Handle(ProcessPayment cmd) {\n        var result = paymentGateway Process(cmd);\n        return result Status switch {\n            \"succeeded\" => new PaymentSucceeded(result TransactionId),\n            \"failed\" => new PaymentFailed(result ErrorCode),\n            \"pending\" => new PaymentPending(result PendingId),\n            _ => throw new UnknownPaymentStatus(result",
        "startIndex": 8738,
        "preview": "public class BatchHandler : IHandle<ProcessOrders> { // Return collection of messages public IEnumerable<IMessage> Handle(ProcessOrders cmd) { var mes..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/return-type-semantics-chunk-5",
        "text": "public class PaymentHandler : IHandle<ProcessPayment> { // Return different types based on outcome public OneOf<PaymentSucceeded, PaymentFailed, PaymentPending> Handle(ProcessPayment cmd) { var result = paymentGateway Process(cmd); return result Status switch { \"succeeded\" => new PaymentSucceeded(result TransactionId), \"failed\" => new PaymentFailed(result ErrorCode), \"pending\" => new PaymentPending(result PendingId), _ => throw new UnknownPaymentStatus(result Status)\n        };\n    }\n}\n`\nRecursive Returns\n`csharp\n---\ncategory: Core Concepts\ndifficulty: ADVANCED\ntags: [Return-Type-Semantics, Recursive-Processing, Tree-Structures]\ndescription: Recursive handler return for tree/graph processing\n---\npublic class RecursiveHandler : IHandle<ProcessNode> {\n    // Return can trigger same handler recursively\n    public IEnumerable<ProcessNode> Handle(ProcessNode cmd) {\n        ProcessCurrentNode(cmd);\n        // Return child nodes for recursive processing\n        return cmd Children Select(child => new ProcessNode(child));\n    }\n}\n`\nReturn Type Metadata\nPriority and Headers\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Message-Metadata, Priority, Headers]\ndescription: Message with metadata for priority and header configuration\n---\npublic class PriorityHandler : IHandle<CreateOrder> {\n    public MessageWithMetadata<OrderCreated> Handle(CreateOrder cmd) {\n        var order = CreateOrder(cmd);\n        return new OrderCreated(order Id) WithPriority(MessagePriority High) WithHeader(\"CustomerId\", cmd CustomerId) WithHeader(\"Source\", \"WebAPI\") WithCorrelationId(cmd CorrelationId);\n    }\n}\n`\nRouting Instructions\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Message-Routing, Regional-Routing, Queue-Selection]\ndescription: Routed message return for regional queue selection\n---\npublic class RoutingHandler : IHandle<RouteOrder> {\n    public RoutedMessage Handle(RouteOrder cmd) {\n        return new ProcessOrder(cmd OrderId) RouteTo(cmd Region switch {\n                \"US\" => \"us-queue\",\n                \"EU\" => \"eu-queue\",\n                \"ASIA\" => \"asia-queue\",\n                _ => \"global-queue\"\n            }) WithRoutingKey($\"orders {cmd Priority} {cmd",
        "startIndex": 11146,
        "preview": "public class PaymentHandler : IHandle<ProcessPayment> { // Return different types based on outcome public OneOf<PaymentSucceeded, PaymentFailed, Payme..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/return-type-semantics-chunk-6",
        "text": "tags: [Return-Type-Semantics, Message-Routing, Regional-Routing, Queue-Selection] description: Routed message return for regional queue selection --- public class RoutingHandler : IHandle<RouteOrder> { public RoutedMessage Handle(RouteOrder cmd) { return new ProcessOrder(cmd OrderId) RouteTo(cmd Region switch { \"US\" => \"us-queue\", \"EU\" => \"eu-queue\", \"ASIA\" => \"asia-queue\", _ => \"global-queue\" }) WithRoutingKey($\"orders {cmd Priority} {cmd Region}\");\n    }\n}\n`\nCompile-Time Verification\nReturn Type Validation\n`csharp\n---\ncategory: Core Concepts\ndifficulty: ADVANCED\ntags: [Return-Type-Semantics, Compile-Time-Validation, Pure-Functions]\ndescription: Compile-time validation of return types and pure function constraints\n---\n// Source generator validates return types\npublic class InvalidHandler : IHandle<CreateOrder> {\n    // ❌ Compile error: Handler must return a message type\n    public string Handle(CreateOrder cmd) {\n        return \"This won't compile\";\n    }\n}\n[Pure]\npublic class PureHandler : IHandle<Calculate> {\n    // ❌ Compile error: Pure handlers cannot return commands\n    public SendEmail Handle(Calculate cmd) {\n        return new SendEmail(); // Side effect not allowed\n    }\n    // ✅ Valid: Pure handlers can return events\n    public Calculated Handle(Calculate cmd) {\n        return new Calculated(cmd A + cmd B);\n    }\n}\n`\nEffect Tracking\n`csharp\n---\ncategory: Core Concepts\ndifficulty: ADVANCED\ntags: [Return-Type-Semantics, Effect-Tracking, Compile-Time-Validation]\ndescription: Effect tracking validation of return types against declared effects\n---\n[Effects(Publishes = \"OrderEvents\")]\npublic class TrackedHandler : IHandle<CreateOrder> {\n    // ✅ Valid: Return type matches declared effects\n    public OrderCreated Handle(CreateOrder cmd) {\n        return new OrderCreated();\n    }\n    // ❌ Compile error: PaymentProcessed not in declared effects\n    public PaymentProcessed HandlePayment(ProcessPayment cmd) {\n        return new PaymentProcessed();\n    }\n}\n`\nPerformance Optimizations\nStack-Allocated Returns\n`csharp\n// Small structs are stack-allocated for performance\npublic readonly struct LightweightEvent : IEvent {\n    public readonly Guid Id;\n    public readonly DateTime Timestamp;\n    public LightweightEvent(Guid id) {\n        Id = id;\n        Timestamp = DateTime UtcNow;\n    }\n}\npublic class PerformantHandler : IHandle<QuickCommand> {\n    // Returns struct without heap allocation\n    public LightweightEvent Handle(QuickCommand cmd) {\n        return new LightweightEvent(cmd",
        "startIndex": 13021,
        "preview": "tags: [Return-Type-Semantics, Message-Routing, Regional-Routing, Queue-Selection] description: Routed message return for regional queue selection --- ..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/return-type-semantics-chunk-7",
        "text": "for performance public readonly struct LightweightEvent : IEvent { public readonly Guid Id; public readonly DateTime Timestamp; public LightweightEvent(Guid id) { Id = id; Timestamp = DateTime UtcNow; } } public class PerformantHandler : IHandle<QuickCommand> { // Returns struct without heap allocation public LightweightEvent Handle(QuickCommand cmd) { return new LightweightEvent(cmd Id);\n    }\n}\n`\nPooled Returns\n`csharp\n[PooledReturns] // Source generator creates pooling\npublic class PooledHandler : IHandle<FrequentCommand> {\n    public FrequentEvent Handle(FrequentCommand cmd) {\n        // Return value is automatically pooled and reused\n        return new FrequentEvent { Id = cmd Id };\n    }\n}\n`\nTesting Return Types\n`csharp\n[Test]\npublic async Task Handler_ReturnsCorrectMessageTypes() {\n    // Given\n    var handler = new OrderHandler();\n    var command = new CreateOrder { };\n    // When\n    var result = handler Handle(command);\n    // Then - Verify return types\n    result Should() BeOfType<(OrderCreated, ProcessPayment, SendEmail)>() Which Should() Satisfy(\n            r => r Item1 OrderId == command OrderId,\n            r => r Item2 Amount == command Total,\n            r => r Item3 Recipient == command CustomerEmail\n        );\n}\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Testing, Streaming, IAsyncEnumerable]\ndescription: Testing streaming return values with IAsyncEnumerable\n---\n[Test]\npublic async Task Handler_StreamingReturn_YieldsAllItems() {\n    var handler = new BatchHandler();\n    var items = new[] { item1, item2, item3 };\n    var results = await handler Handle(new ProcessBatch { Items = items }) ToListAsync();\n    results Should() HaveCount(3);\n    results Should()",
        "startIndex": 15098,
        "preview": "for performance public readonly struct LightweightEvent : IEvent { public readonly Guid Id; public readonly DateTime Timestamp; public LightweightEven..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/return-type-semantics-chunk-8",
        "text": "[Return-Type-Semantics, Testing, Streaming, IAsyncEnumerable] description: Testing streaming return values with IAsyncEnumerable --- [Test] public async Task Handler_StreamingReturn_YieldsAllItems() { var handler = new BatchHandler(); var items = new[] { item1, item2, item3 }; var results = await handler Handle(new ProcessBatch { Items = items }) ToListAsync(); results Should() HaveCount(3); results Should() AllBeOfType<OrderProcessed>();\n}\n`\nBest Practices\nDo's\n✅ Use specific return types for clarity\n`csharp\n---\ncategory: Core Concepts\ndifficulty: BEGINNER\ntags: [Return-Type-Semantics, Best-Practices, Clear-Intent]\ndescription: Using specific return types for clarity\n---\npublic OrderCreated Handle(CreateOrder cmd)  // Clear intent\n`\n✅ Leverage tuples for related messages\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Best-Practices, Tuple-Returns]\ndescription: Leveraging tuples for related messages\n---\npublic (OrderCreated, SendEmail) Handle(CreateOrder cmd)\n`\n✅ Use Result<T> for fallible operations\n`csharp\n---\ncategory: Core Concepts\ndifficulty: INTERMEDIATE\ntags: [Return-Type-Semantics, Best-Practices, Result-Type, Error-Handling]\ndescription: Using Result<T> for fallible operations\n---\npublic Result<PaymentProcessed> Handle(ProcessPayment cmd)\n`\n✅ Stream large result sets\n`csharp\n---\ncategory: Core Concepts\ndifficulty: ADVANCED\ntags: [Return-Type-Semantics, Best-Practices, Streaming, Large-Results]\ndescription: Streaming large result sets with IAsyncEnumerable\n---\npublic async IAsyncEnumerable<Result> Handle(LargeQuery query)\n`\nDon'ts\n❌ Don't use generic object returns\n`csharp\n---\ncategory: Core Concepts\ndifficulty: BEGINNER\ntags: [Return-Type-Semantics, Anti-Patterns, Type-Safety]\ndescription: Anti-pattern - using generic object returns loses type safety\n---\npublic object Handle(Command cmd)  // Loses type safety\n`\n❌ Don't mix unrelated messages in tuples\n`csharp\n---\ncategory: Core Concepts\ndifficulty: BEGINNER\ntags: [Return-Type-Semantics, Anti-Patterns, Unrelated-Messages]\ndescription: Anti-pattern - mixing unrelated messages in tuples\n---\npublic (OrderCreated, UnrelatedUserLogout) Handle(CreateOrder cmd)\n`\n❌ Don't ignore return values in tests\n`csharp\n---\ncategory: Core Concepts\ndifficulty: BEGINNER\ntags: [Return-Type-Semantics, Anti-Patterns, Testing, Ignored-Returns]\ndescription: Anti-pattern - ignoring return values in tests\n---\nhandler",
        "startIndex": 16502,
        "preview": "[Return-Type-Semantics, Testing, Streaming, IAsyncEnumerable] description: Testing streaming return values with IAsyncEnumerable --- [Test] public asy..."
      },
      {
        "id": "old-v1.0.0.0/core-concepts/return-type-semantics-chunk-9",
        "text": "difficulty: BEGINNER tags: [Return-Type-Semantics, Anti-Patterns, Unrelated-Messages] description: Anti-pattern - mixing unrelated messages in tuples --- public (OrderCreated, UnrelatedUserLogout) Handle(CreateOrder cmd) ` ❌ Don't ignore return values in tests `csharp --- category: Core Concepts difficulty: BEGINNER tags: [Return-Type-Semantics, Anti-Patterns, Testing, Ignored-Returns] description: Anti-pattern - ignoring return values in tests --- handler Handle(cmd);  // Should verify return value\n`\nSummary\nReturn type semantics in Whizbang provide:\nClear intent from method signatures\nZero configuration message routing\nType safety with compile-time verification\nFlexibility through various return patterns\nPerformance with optimized return handling\nThis approach makes your handlers self-documenting and eliminates the impedance mismatch between your domain logic and messaging infrastructure Next Steps\nExplore Policy Composition for resilience\nLearn about Aspect-Oriented Handlers\nSee Progressive Enhancement patterns\nReview Testing Strategies",
        "startIndex": 18524,
        "preview": "difficulty: BEGINNER tags: [Return-Type-Semantics, Anti-Patterns, Unrelated-Messages] description: Anti-pattern - mixing unrelated messages in tuples ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/examples/enhanced-csharp-examples",
    "title": "C# Code Examples",
    "category": "Examples",
    "url": "/docs/old-v1.0.0.0/examples/enhanced-csharp-examples",
    "chunks": [
      {
        "id": "old-v1.0.0.0/examples/enhanced-csharp-examples-chunk-0",
        "text": "CCode Examples\nThis document demonstrates comprehensive Ccode examples with rich metadata, interactive features, and professional styling Basic Examples\nSimple Console Application\n`csharp{\ntitle: \"Hello World Console App\"\ndescription: \"A simple console application demonstrating basic Csyntax\"\nframework: \"NET8\"\ndifficulty: \"BEGINNER\"\nfilename: \"Program cs\"\n}\nusing System;\nnamespace HelloWorld {\n    class Program {\n        static void Main(string[] args) {\n            Console WriteLine(\"Hello, World \");\n            Console WriteLine(\"Welcome to enhanced Ccode viewing \");\n            var message = GetWelcomeMessage(\"Developer\");\n            Console WriteLine(message);\n        }\n        static string GetWelcomeMessage(string name) {\n            return $\"Hello, {name} Today is {DateTime Now:yyyy-MM-dd}\";\n        }\n    }\n}\n`\nBasic Class Example\n`csharp{\ntitle: \"Person Class\"\ndescription: \"Simple class with properties and methods\"\ncategory: \"ENTITY\"\ndifficulty: \"BEGINNER\"\ntags: [\"Class\", \"Properties\", \"Methods\"]\nfilename: \"Person cs\"\n}\npublic class Person {\n    public string Name { get; set; }\n    public int Age { get; set; }\n    public string Email { get; set; }\n    public Person(string name, int age, string email) {\n        Name = name;\n        Age = age;\n        Email = email;\n    }\n    public void DisplayInfo() {\n        Console WriteLine($\"Name: {Name}\");\n        Console WriteLine($\"Age: {Age}\");\n        Console WriteLine($\"Email: {Email}\");\n    }\n    public bool IsAdult() {\n        return Age >= 18;\n    }\n}\n`\nNuGet Package Example\n`csharp{\ntitle: \"JSON Serialization Example\"\ndescription: \"Using Newtonsoft Json for JSON operations\"\nframework: \"NET8\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"JSON\", \"Serialization\", \"NuGet\"]\nnugetPackages: [\"Newtonsoft Json\"]\nfilename: \"JsonExample cs\"\n}\nusing Newtonsoft Json;\nusing System Collections Generic;\npublic class JsonExample {\n    public void SerializeExample() {\n        var person = new Person(\"John Doe\", 30, \"john@example com\");\n        // Serialize to JSON\n        string json = JsonConvert SerializeObject(person, Formatting Indented);\n        Console WriteLine(\"Serialized JSON:\");\n        Console WriteLine(json);\n        // Deserialize from JSON\n        var deserializedPerson = JsonConvert DeserializeObject<Person>(json);\n        Console WriteLine(\"\\nDeserialized object:\");\n        deserializedPerson",
        "startIndex": 0,
        "preview": "CCode Examples\nThis document demonstrates comprehensive Ccode examples with rich metadata, interactive features, and professional styling Basic Exampl..."
      },
      {
        "id": "old-v1.0.0.0/examples/enhanced-csharp-examples-chunk-1",
        "text": "using System Collections Generic; public class JsonExample { public void SerializeExample() { var person = new Person(\"John Doe\", 30, \"john@example com\"); // Serialize to JSON string json = JsonConvert SerializeObject(person, Formatting Indented); Console WriteLine(\"Serialized JSON:\"); Console WriteLine(json); // Deserialize from JSON var deserializedPerson = JsonConvert DeserializeObject<Person>(json); Console WriteLine(\"\\nDeserialized object:\"); deserializedPerson DisplayInfo();\n    }\n}\n`\nAdvanced Examples\nBasic API Controller Example\n`csharp{\ntitle: \"User Management API Controller\"\ndescription: \"A comprehensive REST API controller for user management with CRUD operations\"\nframework: \"NET8\"\ncategory: \"API\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Web API\", \"REST\", \"CRUD\", \"Authentication\"]\ngithubUrl: \"https://github com/example/user-api\"\ndocsUrl: \"https://docs microsoft com/aspnet/core/web-api\"\nnugetPackages: [\"Microsoft AspNetCore Mvc\", \"Microsoft EntityFrameworkCore\", \"Microsoft AspNetCore Authorization\"]\nfilename: \"UserController cs\"\nshowLineNumbers: true\nshowLinesOnly: [1, 2, 3, 8, 9, 12, 13, 14, 15, 18, 19] \nhighlightLines: [12, 15, 28, 45]\nusingStatements: [\"Microsoft AspNetCore Mvc\", \"Microsoft EntityFrameworkCore\", \"Microsoft AspNetCore Authorization\", \"System Threading Tasks\", \"System Collections Generic\"]\n}\nusing Microsoft AspNetCore Mvc;\nusing Microsoft EntityFrameworkCore;\nusing Microsoft AspNetCore Authorization;\nnamespace UserManagement Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public class UserController : ControllerBase\n    {\n        private readonly UserDbContext _context;\n        private readonly ILogger<UserController> _logger;\n        public UserController(UserDbContext context, ILogger<UserController> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n        [HttpGet]\n        public async Task<ActionResult<IEnumerable<UserDto>>> GetUsers()\n        {\n            try\n            {\n                var users = await _context Users Where(u => u IsActive) Select(u => new UserDto\n                    {\n                        Id = u Id,\n                        Name = u Name,\n                        Email = u Email,\n                        CreatedAt = u CreatedAt\n                    }) ToListAsync();\n                return Ok(users);\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error retrieving users\");\n                return StatusCode(500, \"Internal server error\");\n            }\n        }\n        [HttpGet(\"{id}\")]\n        public async Task<ActionResult<UserDto>> GetUser(int id)\n        {\n            var user = await _context Users FindAsync(id);\n            if (user == null)\n            {\n                return NotFound($\"User with ID {id} not found\");\n            }\n            return Ok(new UserDto\n            {\n                Id = user Id,\n                Name = user Name,\n                Email = user Email,\n                CreatedAt = user",
        "startIndex": 2380,
        "preview": "using System Collections Generic; public class JsonExample { public void SerializeExample() { var person = new Person(\"John Doe\", 30, \"john@example co..."
      },
      {
        "id": "old-v1.0.0.0/examples/enhanced-csharp-examples-chunk-2",
        "text": "server error\"); } } [HttpGet(\"{id}\")] public async Task<ActionResult<UserDto>> GetUser(int id) { var user = await _context Users FindAsync(id); if (user == null) { return NotFound($\"User with ID {id} not found\"); } return Ok(new UserDto { Id = user Id, Name = user Name, Email = user Email, CreatedAt = user CreatedAt\n            });\n        }\n        [HttpPost]\n        public async Task<ActionResult<UserDto>> CreateUser([FromBody] CreateUserRequest request)\n        {\n            if ( ModelState IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n            var user = new User\n            {\n                Name = request Name,\n                Email = request Email,\n                CreatedAt = DateTime UtcNow,\n                IsActive = true\n            };\n            _context Users Add(user);\n            await _context SaveChangesAsync();\n            var userDto = new UserDto\n            {\n                Id = user Id,\n                Name = user Name,\n                Email = user Email,\n                CreatedAt = user CreatedAt\n            };\n            return CreatedAtAction(nameof(GetUser), new { id = user Id }, userDto);\n        }\n    }\n}\n`\nEntity Framework Model Example\n`csharp{\ntitle: \"User Entity Model\"\ndescription: \"Entity Framework model with relationships and validation attributes\"\nframework: \"NET8\"\ncategory: \"ENTITY\"\ndifficulty: \"BEGINNER\"\ntags: [\"Entity Framework\", \"Models\", \"Data Annotations\"]\nnugetPackages: [\"Microsoft EntityFrameworkCore\", \"System ComponentModel Annotations\"]\nfilename: \"User cs\"\n}\nusing System ComponentModel DataAnnotations;\nusing System ComponentModel DataAnnotations Schema;\nnamespace UserManagement Models\n{\n    [Table(\"Users\")]\n    public class User\n    {\n        [Key]\n        [DatabaseGenerated(DatabaseGeneratedOption Identity)]\n        public int Id { get; set; }\n        [Required]\n        [StringLength(100, MinimumLength = 2)]\n        public string Name { get; set; } = string Empty;\n        [Required]\n        [EmailAddress]\n        [StringLength(255)]\n        public string Email { get; set; } = string Empty;\n        [Required]\n        public DateTime CreatedAt { get; set; }\n        public DateTime",
        "startIndex": 5016,
        "preview": "server error\"); } } [HttpGet(\"{id}\")] public async Task<ActionResult<UserDto>> GetUser(int id) { var user = await _context Users FindAsync(id); if (us..."
      },
      {
        "id": "old-v1.0.0.0/examples/enhanced-csharp-examples-chunk-3",
        "text": "User { [Key] [DatabaseGenerated(DatabaseGeneratedOption Identity)] public int Id { get; set; } [Required] [StringLength(100, MinimumLength = 2)] public string Name { get; set; } = string Empty; [Required] [EmailAddress] [StringLength(255)] public string Email { get; set; } = string Empty; [Required] public DateTime CreatedAt { get; set; } public DateTime UpdatedAt { get; set; }\n        [Required]\n        public bool IsActive { get; set; } = true;\n        // Navigation properties\n        public virtual ICollection<UserRole> UserRoles { get; set; } = new List<UserRole>();\n        public virtual ICollection<UserProfile> UserProfiles { get; set; } = new List<UserProfile>();\n    }\n    public class UserDto\n    {\n        public int Id { get; set; }\n        public string Name { get; set; } = string Empty;\n        public string Email { get; set; } = string Empty;\n        public DateTime CreatedAt { get; set; }\n    }\n    public class CreateUserRequest\n    {\n        [Required]\n        [StringLength(100, MinimumLength = 2)]\n        public string Name { get; set; } = string Empty;\n        [Required]\n        [EmailAddress]\n        public string Email { get; set; } = string Empty;\n    }\n}\n`\nAdvanced Service Pattern Example\n`csharp{\ntitle: \"User Service with Repository Pattern\"\ndescription: \"Implementation of service layer with dependency injection and error handling\"\nframework: \"NET8\"\ncategory: \"SERVICE\"\ndifficulty: \"ADVANCED\"\ntags: [\"Service Pattern\", \"Repository\", \"Dependency Injection\", \"Error Handling\"]\ngithubUrl: \"https://github com/example/user-service\"\nnugetPackages: [\"Microsoft Extensions Logging\", \"AutoMapper\"]\nfilename: \"UserService cs\"\nshowLinesOnly: [1, 2, 3, 4, 9, 10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 24, 25]\ncollapsible: false\n}\nusing AutoMapper;\nusing Microsoft Extensions Logging;\nusing UserManagement Models;\nusing UserManagement Repositories;\nusing UserManagement Exceptions;\nnamespace UserManagement Services\n{\n    public interface IUserService\n    {\n        Task<IEnumerable<UserDto>> GetAllUsersAsync();\n        Task<UserDto > GetUserByIdAsync(int id);\n        Task<UserDto> CreateUserAsync(CreateUserRequest request);\n        Task<UserDto",
        "startIndex": 6914,
        "preview": "User { [Key] [DatabaseGenerated(DatabaseGeneratedOption Identity)] public int Id { get; set; } [Required] [StringLength(100, MinimumLength = 2)] publi..."
      },
      {
        "id": "old-v1.0.0.0/examples/enhanced-csharp-examples-chunk-4",
        "text": "4, 9, 10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 24, 25] collapsible: false } using AutoMapper; using Microsoft Extensions Logging; using UserManagement Models; using UserManagement Repositories; using UserManagement Exceptions; namespace UserManagement Services { public interface IUserService { Task<IEnumerable<UserDto>> GetAllUsersAsync(); Task<UserDto > GetUserByIdAsync(int id); Task<UserDto> CreateUserAsync(CreateUserRequest request); Task<UserDto > UpdateUserAsync(int id, UpdateUserRequest request);\n        Task<bool> DeleteUserAsync(int id);\n        Task<bool> UserExistsAsync(string email);\n    }\n    public class UserService : IUserService\n    {\n        private readonly IUserRepository _userRepository;\n        private readonly IMapper _mapper;\n        private readonly ILogger<UserService> _logger;\n        public UserService(\n            IUserRepository userRepository,\n            IMapper mapper,\n            ILogger<UserService> logger)\n        {\n            _userRepository = userRepository throw new ArgumentNullException(nameof(userRepository));\n            _mapper = mapper throw new ArgumentNullException(nameof(mapper));\n            _logger = logger throw new ArgumentNullException(nameof(logger));\n        }\n        public async Task<IEnumerable<UserDto>> GetAllUsersAsync()\n        {\n            try\n            {\n                _logger LogInformation(\"Retrieving all active users\");\n                var users = await _userRepository GetActiveUsersAsync();\n                var userDtos = _mapper Map<IEnumerable<UserDto>>(users);\n                _logger LogInformation(\"Retrieved {UserCount} active users\", users Count());\n                return userDtos;\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error occurred while retrieving users\");\n                throw new ServiceException(\"Failed to retrieve users\", ex);\n            }\n        }\n        public async Task<UserDto > GetUserByIdAsync(int id)\n        {\n            try\n            {\n                _logger LogInformation(\"Retrieving user with ID: {UserId}\", id);\n                var user = await _userRepository GetByIdAsync(id);\n                if (user == null)\n                {\n                    _logger LogWarning(\"User with ID {UserId} not found\", id);\n                    return null;\n                }\n                var userDto = _mapper Map<UserDto>(user);\n                _logger LogInformation(\"Successfully retrieved user: {UserEmail}\", user Email);\n                return userDto;\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error occurred while retrieving user with ID: {UserId}\", id);\n                throw new ServiceException($\"Failed to retrieve user with ID: {id}\", ex);\n            }\n        }\n        public async Task<UserDto> CreateUserAsync(CreateUserRequest request)\n        {\n            try\n            {\n                _logger LogInformation(\"Creating new user with email: {Email}\", request Email);\n                // Check if user already exists\n                if (await UserExistsAsync(request Email))\n                {\n                    throw new DuplicateUserException($\"User with email {request Email} already exists\");\n                }\n                var user = _mapper Map<User>(request);\n                user CreatedAt = DateTime UtcNow;\n                user IsActive = true;\n                var createdUser = await _userRepository",
        "startIndex": 8735,
        "preview": "4, 9, 10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 24, 25] collapsible: false } using AutoMapper; using Microsoft Extensions Logging; using UserManagement ..."
      },
      {
        "id": "old-v1.0.0.0/examples/enhanced-csharp-examples-chunk-5",
        "text": "{ _logger LogInformation(\"Creating new user with email: {Email}\", request Email); // Check if user already exists if (await UserExistsAsync(request Email)) { throw new DuplicateUserException($\"User with email {request Email} already exists\"); } var user = _mapper Map<User>(request); user CreatedAt = DateTime UtcNow; user IsActive = true; var createdUser = await _userRepository CreateAsync(user);\n                var userDto = _mapper Map<UserDto>(createdUser);\n                _logger LogInformation(\"Successfully created user with ID: {UserId}\", createdUser Id);\n                return userDto;\n            }\n            catch (DuplicateUserException)\n            {\n                throw; // Re-throw business logic exceptions\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error occurred while creating user with email: {Email}\", request Email);\n                throw new ServiceException(\"Failed to create user\", ex);\n            }\n        }\n        public async Task<bool> UserExistsAsync(string email)\n        {\n            try\n            {\n                return await _userRepository ExistsByEmailAsync(email);\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error checking if user exists with email: {Email}\", email);\n                throw new ServiceException(\"Failed to check user existence\", ex);\n            }\n        }\n    }\n}\n`\nMiddleware Configuration Example\n`csharp{\ntitle: \"Custom Authentication Middleware\"\ndescription: \"JWT authentication middleware with custom claims handling\"\nframework: \"NET8\"\ncategory: \"MIDDLEWARE\"\ndifficulty: \"ADVANCED\"\ntags: [\"Middleware\", \"JWT\", \"Authentication\", \"Security\"]\ndocsUrl: \"https://docs microsoft com/aspnet/core/fundamentals/middleware\"\nnugetPackages: [\"Microsoft AspNetCore Authentication JwtBearer\", \"System IdentityModel Tokens Jwt\"]\nfilename: \"JwtAuthenticationMiddleware cs\"\n}\nusing Microsoft AspNetCore Authentication;\nusing Microsoft Extensions Options;\nusing System IdentityModel Tokens Jwt;\nusing System Security Claims;\nusing System Text Encodings Web;\nusing Microsoft IdentityModel Tokens;\nusing System Text;\nnamespace UserManagement Middleware\n{\n    public class JwtAuthenticationMiddleware\n    {\n        private readonly RequestDelegate _next;\n        private readonly JwtSettings _jwtSettings;\n        private readonly ILogger<JwtAuthenticationMiddleware> _logger;\n        public JwtAuthenticationMiddleware(\n            RequestDelegate next,\n            IOptions<JwtSettings> jwtSettings,\n            ILogger<JwtAuthenticationMiddleware> logger)\n        {\n            _next = next;\n            _jwtSettings = jwtSettings Value;\n            _logger = logger;\n        }\n        public async Task InvokeAsync(HttpContext context)\n        {\n            var token = ExtractTokenFromHeader(context);\n            if ( string IsNullOrEmpty(token))\n            {\n                await ValidateAndSetUser(context, token);\n            }\n            await _next(context);\n        }\n        private string ExtractTokenFromHeader(HttpContext context)\n        {\n            var authHeader = context Request Headers[\"Authorization\"] FirstOrDefault();\n            if (authHeader = null && authHeader",
        "startIndex": 11764,
        "preview": "{ _logger LogInformation(\"Creating new user with email: {Email}\", request Email); // Check if user already exists if (await UserExistsAsync(request Em..."
      },
      {
        "id": "old-v1.0.0.0/examples/enhanced-csharp-examples-chunk-6",
        "text": "= next; _jwtSettings = jwtSettings Value; _logger = logger; } public async Task InvokeAsync(HttpContext context) { var token = ExtractTokenFromHeader(context); if ( string IsNullOrEmpty(token)) { await ValidateAndSetUser(context, token); } await _next(context); } private string ExtractTokenFromHeader(HttpContext context) { var authHeader = context Request Headers[\"Authorization\"] FirstOrDefault(); if (authHeader = null && authHeader StartsWith(\"Bearer \"))\n            {\n                return authHeader Substring(\"Bearer \" Length) Trim();\n            }\n            return null;\n        }\n        private async Task ValidateAndSetUser(HttpContext context, string token)\n        {\n            try\n            {\n                var tokenHandler = new JwtSecurityTokenHandler();\n                var key = Encoding ASCII GetBytes(_jwtSettings SecretKey);\n                var validationParameters = new TokenValidationParameters\n                {\n                    ValidateIssuerSigningKey = true,\n                    IssuerSigningKey = new SymmetricSecurityKey(key),\n                    ValidateIssuer = true,\n                    ValidIssuer = _jwtSettings Issuer,\n                    ValidateAudience = true,\n                    ValidAudience = _jwtSettings Audience,\n                    ValidateLifetime = true,\n                    ClockSkew = TimeSpan Zero\n                };\n                var principal = tokenHandler ValidateToken(token, validationParameters, out SecurityToken validatedToken);\n                // Set the user context\n                context User = principal;\n                _logger LogInformation(\"JWT token validated successfully for user: {UserId}\", \n                    principal FindFirst(ClaimTypes NameIdentifier) Value);\n            }\n            catch (SecurityTokenException ex)\n            {\n                _logger LogWarning(\"Invalid JWT token: {Error}\", ex Message);\n            }\n            catch (Exception ex)\n            {\n                _logger LogError(ex, \"Error validating JWT token\");\n            }\n        }\n    }\n    public class JwtSettings\n    {\n        public string SecretKey { get; set; } = string Empty;\n        public string Issuer { get; set; } = string Empty;\n        public string Audience { get; set; } = string Empty;\n        public int ExpirationMinutes { get; set; } = 60;\n    }\n}\n`\nConfiguration and Startup Example\n`csharp{\ntitle: \"Program cs Configuration\"\ndescription: \"Modern NET 8 minimal hosting model with comprehensive service configuration\"\nframework: \"NET8\"\ncategory: \"CONFIG\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Configuration\", \"Dependency Injection\", \"Startup\", \"Minimal API\"]\nfilename: \"Program cs\"\n}\nusing Microsoft EntityFrameworkCore;\nusing Microsoft AspNetCore Authentication JwtBearer;\nusing Microsoft IdentityModel Tokens;\nusing System Text;\nusing UserManagement Data;\nusing UserManagement Services;\nusing UserManagement Repositories;\nusing UserManagement Middleware;\nvar builder = WebApplication CreateBuilder(args);\n// Configuration\nvar jwtSettings = builder Configuration",
        "startIndex": 14649,
        "preview": "= next; _jwtSettings = jwtSettings Value; _logger = logger; } public async Task InvokeAsync(HttpContext context) { var token = ExtractTokenFromHeader(..."
      },
      {
        "id": "old-v1.0.0.0/examples/enhanced-csharp-examples-chunk-7",
        "text": "tags: [\"Configuration\", \"Dependency Injection\", \"Startup\", \"Minimal API\"] filename: \"Program cs\" } using Microsoft EntityFrameworkCore; using Microsoft AspNetCore Authentication JwtBearer; using Microsoft IdentityModel Tokens; using System Text; using UserManagement Data; using UserManagement Services; using UserManagement Repositories; using UserManagement Middleware; var builder = WebApplication CreateBuilder(args); // Configuration var jwtSettings = builder Configuration GetSection(\"JwtSettings\");\nvar connectionString = builder Configuration GetConnectionString(\"DefaultConnection\");\n// Add services to the container\nbuilder Services AddDbContext<UserDbContext>(options =>\n    options UseSqlServer(connectionString));\n// JWT Authentication\nbuilder Services Configure<JwtSettings>(jwtSettings);\nbuilder Services AddAuthentication(JwtBearerDefaults AuthenticationScheme) AddJwtBearer(options =>\n    {\n        options TokenValidationParameters = new TokenValidationParameters\n        {\n            ValidateIssuerSigningKey = true,\n            IssuerSigningKey = new SymmetricSecurityKey(\n                Encoding ASCII GetBytes(jwtSettings[\"SecretKey\"] )),\n            ValidateIssuer = true,\n            ValidIssuer = jwtSettings[\"Issuer\"],\n            ValidateAudience = true,\n            ValidAudience = jwtSettings[\"Audience\"],\n            ValidateLifetime = true,\n            ClockSkew = TimeSpan Zero\n        };\n    });\nbuilder Services AddAuthorization();\n// Register application services\nbuilder Services AddScoped<IUserRepository, UserRepository>();\nbuilder Services AddScoped<IUserService, UserService>();\n// AutoMapper\nbuilder Services AddAutoMapper(typeof(Program));\n// API Controllers\nbuilder Services AddControllers();\n// API Documentation\nbuilder Services AddEndpointsApiExplorer();\nbuilder Services AddSwaggerGen(c =>\n{\n    c SwaggerDoc(\"v1\", new() { Title = \"User Management API\", Version = \"v1\" });\n    c AddSecurityDefinition(\"Bearer\", new()\n    {\n        Description = \"JWT Authorization header using the Bearer scheme \",\n        Name = \"Authorization\",\n        In = Microsoft OpenApi Models ParameterLocation Header,\n        Type = Microsoft OpenApi Models SecuritySchemeType Http,\n        Scheme = \"bearer\"\n    });\n});\n// CORS\nbuilder Services AddCors(options =>\n{\n    options AddPolicy(\"AllowSpecificOrigins\", policy =>\n    {\n        policy WithOrigins(\"https://localhost:4200\", \"https://myapp com\") AllowAnyHeader() AllowAnyMethod();\n    });\n});\n// Logging\nbuilder Services AddLogging(config =>\n{\n    config AddConsole();\n    config AddDebug();\n});\nvar app = builder Build();\n// Configure the HTTP request pipeline\nif (app Environment IsDevelopment())\n{\n    app UseSwagger();\n    app UseSwaggerUI();\n    app UseDeveloperExceptionPage();\n}\napp UseHttpsRedirection();\napp UseCors(\"AllowSpecificOrigins\");\n// Custom JWT middleware\napp UseMiddleware<JwtAuthenticationMiddleware>();\napp UseAuthentication();\napp UseAuthorization();\napp MapControllers();\napp",
        "startIndex": 17276,
        "preview": "tags: [\"Configuration\", \"Dependency Injection\", \"Startup\", \"Minimal API\"] filename: \"Program cs\" } using Microsoft EntityFrameworkCore; using Microsof..."
      },
      {
        "id": "old-v1.0.0.0/examples/enhanced-csharp-examples-chunk-8",
        "text": "builder Services AddLogging(config => { config AddConsole(); config AddDebug(); }); var app = builder Build(); // Configure the HTTP request pipeline if (app Environment IsDevelopment()) { app UseSwagger(); app UseSwaggerUI(); app UseDeveloperExceptionPage(); } app UseHttpsRedirection(); app UseCors(\"AllowSpecificOrigins\"); // Custom JWT middleware app UseMiddleware<JwtAuthenticationMiddleware>(); app UseAuthentication(); app UseAuthorization(); app MapControllers(); app Run();\n`\nThis documentation showcases the enhanced Ccode viewing capabilities with:\nRich Metadata: Titles, descriptions, framework versions, categories, difficulty levels\nInteractive Features: Copy, download, GitHub links, NuGet package integration\nVisual Enhancements: Syntax highlighting, line numbers, code folding\nProfessional Styling: VS Code-inspired themes, hover effects, responsive design\nDeveloper Tools: Line highlighting, collapsible sections, tag categorization",
        "startIndex": 19814,
        "preview": "builder Services AddLogging(config => { config AddConsole(); config AddDebug(); }); var app = builder Build(); // Configure the HTTP request pipeline ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/getting-started/aspire-integration",
    "title": ".NET Aspire Integration",
    "category": "Getting Started",
    "url": "/docs/old-v1.0.0.0/getting-started/aspire-integration",
    "chunks": [
      {
        "id": "old-v1.0.0.0/getting-started/aspire-integration-chunk-0",
        "text": "NET Aspire Integration\nWhizbang provides first-class support for NET Aspire, Microsoft's opinionated stack for building observable, production-ready cloud-native applications Overview\nWith Aspire integration, you get:\nLocal emulation of Postgres, Kafka, Redis, and other infrastructure\nOne-command setup for end-to-end development environment\nService discovery for microservices communication\nBuilt-in observability with OpenTelemetry dashboards\nResource orchestration with Docker containers\nConfiguration management across services\nQuick Start\nInstall Aspire Workload\n`bash{\ntitle: \"Install Aspire Workload\"\ndescription: \"Install the NET Aspire workload for local development\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Getting Started\", \"Aspire\", \"Installation\", \"Setup\"]\nshowLineNumbers: false\n}\ndotnet workload install aspire\n`\nAdd Whizbang Aspire Package\n`bash{\ntitle: \"Add Whizbang Aspire Package\"\ndescription: \"Install the Whizbang Aspire integration package\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Getting Started\", \"Aspire\", \"Installation\", \"NuGet\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang Aspire\n`\nConfigure AppHost\nCreate an Aspire AppHost project:\n`csharp{\ntitle: \"Aspire AppHost Configuration\"\ndescription: \"Configure Whizbang services with Aspire\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"BEGINNER\"\ntags: [\"Aspire\", \"Configuration\", \"Local Development\"]\nnugetPackages: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nfilename: \"Program cs\"\nusingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting;\nusing Whizbang Aspire;\nvar builder = DistributedApplication CreateBuilder(args);\n// Add Whizbang infrastructure\nvar whizbang = builder AddWhizbang(\"whizbang\") WithPostgres()       // Event store WithKafka()          // Message broker WithRedis()          // Caching WithOpenTelemetry(); // Observability\n// Add your services\nvar ordersService = builder AddProject<Projects OrdersService>(\"orders\") WithReference(whizbang);\nvar inventoryService = builder AddProject<Projects InventoryService>(\"inventory\") WithReference(whizbang);\nvar apiGateway = builder AddProject<Projects ApiGateway>(\"api\") WithReference(ordersService) WithReference(inventoryService);\nbuilder Build() Run();\n`\nConfigure Service\nIn your service's Program cs:\n`csharp{\ntitle: \"Service Configuration with Aspire\"\ndescription: \"Wire up Whizbang in a service using Aspire\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"BEGINNER\"\ntags: [\"Aspire\", \"Configuration\", \"Microservices\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Messaging\", \"Whizbang Aspire\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions Hosting\", \"Whizbang\", \"Whizbang",
        "startIndex": 0,
        "preview": "NET Aspire Integration\nWhizbang provides first-class support for NET Aspire, Microsoft's opinionated stack for building observable, production-ready c..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/aspire-integration-chunk-1",
        "text": "Configure Service In your service's Program cs: `csharp{ title: \"Service Configuration with Aspire\" description: \"Wire up Whizbang in a service using Aspire\" framework: \"NET8\" category: \"Aspire\" difficulty: \"BEGINNER\" tags: [\"Aspire\", \"Configuration\", \"Microservices\"] nugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Messaging\", \"Whizbang Aspire\"] filename: \"Program cs\" usingStatements: [\"Microsoft Extensions Hosting\", \"Whizbang\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions Hosting;\nusing Whizbang;\nusing Whizbang Aspire;\nvar builder = WebApplication CreateBuilder(args);\n// Add Aspire service defaults (observability, health checks, etc )\nbuilder AddServiceDefaults();\n// Add Whizbang with Aspire integration\nbuilder Services AddWhizbangWithAspire(options => {\n    options ScanAssembly(typeof(Program) Assembly);\n    // Infrastructure auto-configured from Aspire\n    options UseAspireEventStore();      // Connects to Aspire-managed Postgres\n    options UseAspireMessaging();       // Connects to Aspire-managed Kafka\n    options UseAspireProjectionCache(); // Connects to Aspire-managed Redis\n});\nvar app = builder Build();\napp MapDefaultEndpoints();  // Aspire health/metrics endpoints\napp Run();\n`\nRun Everything\n`bash{\ntitle: \"Run Aspire AppHost\"\ndescription: \"Start all services and infrastructure with a single command\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Getting Started\", \"Aspire\", \"Local Development\", \"Orchestration\"]\nshowLineNumbers: false\n}\ndotnet run --project AppHost\n`\nThis single command:\nStarts Postgres container for event store\nStarts Kafka + Zookeeper containers for messaging\nStarts Redis container for caching\nStarts all your microservices\nOpens Aspire dashboard with logs, metrics, and traces\nAspire Dashboard\nNavigate to http://localhost:15000 (or the URL shown in console) to see:\nResources - All running containers and services\nLogs - Structured logs from all services\nTraces - Distributed tracing across services\nMetrics - Real-time metrics (event throughput, projection lag, etc )\nHealth - Service health status\nOut-of-the-Box Infrastructure\nPostgres (Event Store)\nWhizbang automatically configures Postgres for event storage:\n`csharp{\ntitle: \"Aspire Postgres Configuration\"\ndescription: \"Auto-configured Postgres event store\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aspire\", \"Postgres\", \"Event Store\"]\nnugetPackages: [\"Whizbang Aspire\", \"Whizbang Postgres\"]\nusingStatements: [\"Aspire Hosting\", \"Whizbang",
        "startIndex": 2828,
        "preview": "Configure Service In your service's Program cs: `csharp{ title: \"Service Configuration with Aspire\" description: \"Wire up Whizbang in a service using ..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/aspire-integration-chunk-2",
        "text": "lag, etc ) Health - Service health status Out-of-the-Box Infrastructure Postgres (Event Store) Whizbang automatically configures Postgres for event storage: `csharp{ title: \"Aspire Postgres Configuration\" description: \"Auto-configured Postgres event store\" framework: \"NET8\" category: \"Aspire\" difficulty: \"INTERMEDIATE\" tags: [\"Aspire\", \"Postgres\", \"Event Store\"] nugetPackages: [\"Whizbang Aspire\", \"Whizbang Postgres\"] usingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting;\nusing Whizbang Aspire;\nvar builder = DistributedApplication CreateBuilder(args);\nvar whizbang = builder AddWhizbang(\"whizbang\") WithPostgres(postgres => {\n        postgres DatabaseName = \"whizbang_events\";\n        postgres WithPgAdmin();  // Optional: PgAdmin UI\n        postgres WithInitialData(\" /seed-data sql\");  // Optional: Seed data\n    });\n`\nWhat it does:\nStarts Postgres 16 container\nCreates whizbang_events database\nApplies Whizbang event store schema automatically\nConfigures connection string in all services\nEnables OpenTelemetry instrumentation\nKafka (Message Broker)\nWhizbang sets up Kafka for distributed messaging:\n`csharp{\ntitle: \"Aspire Kafka Configuration\"\ndescription: \"Auto-configured Kafka message broker\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aspire\", \"Kafka\", \"Messaging\"]\nnugetPackages: [\"Whizbang Aspire\", \"Whizbang Kafka\"]\nusingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting;\nusing Whizbang Aspire;\nvar whizbang = builder AddWhizbang(\"whizbang\") WithKafka(kafka => {\n        kafka WithKafkaUI();  // Optional: Kafka UI for topic inspection\n        kafka WithTopics(\n            \"whizbang orders events\",\n            \"whizbang inventory events\",\n            \"whizbang shipping events\"\n        );\n    });\n`\nWhat it does:\nStarts Kafka + Zookeeper containers\nCreates topics for each domain\nConfigures producers and consumers\nEnables distributed tracing for messages\nProvides Kafka UI at http://localhost:8080\nRedis (Caching & Projections)\nOptional Redis for projection caching:\n`csharp{\ntitle: \"Aspire Redis Configuration\"\ndescription: \"Auto-configured Redis for caching\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aspire\", \"Redis\", \"Caching\"]\nnugetPackages: [\"Whizbang Aspire\"]\nusingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting;\nusing Whizbang Aspire;\nvar whizbang = builder AddWhizbang(\"whizbang\") WithRedis(redis => {\n        redis WithRedisInsight();  // Optional: Redis UI\n        redis",
        "startIndex": 1588,
        "preview": "lag, etc ) Health - Service health status Out-of-the-Box Infrastructure Postgres (Event Store) Whizbang automatically configures Postgres for event st..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/aspire-integration-chunk-3",
        "text": "\"Aspire Redis Configuration\" description: \"Auto-configured Redis for caching\" framework: \"NET8\" category: \"Aspire\" difficulty: \"INTERMEDIATE\" tags: [\"Aspire\", \"Redis\", \"Caching\"] nugetPackages: [\"Whizbang Aspire\"] usingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"] showLineNumbers: true } using Aspire Hosting; using Whizbang Aspire; var whizbang = builder AddWhizbang(\"whizbang\") WithRedis(redis => { redis WithRedisInsight(); // Optional: Redis UI redis WithPersistence();   // Optional: Persist to disk\n    });\n`\nWhat it does:\nStarts Redis container\nConfigures projection caching\nEnables distributed locks for projection processing\nProvides Redis Insight UI\nService Discovery\nServices automatically discover each other through Aspire:\n`csharp{\ntitle: \"Service Discovery with Aspire\"\ndescription: \"Services discover each other automatically\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aspire\", \"Service Discovery\", \"Microservices\"]\nnugetPackages: [\"Whizbang Aspire\", \"Whizbang Messaging\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nusing Whizbang Aspire;\n// In API Gateway\nbuilder Services AddWhizbangWithAspire(options => {\n    options UseMessaging(msg => {\n        // Service URLs automatically resolved via Aspire\n        msg UseDomainOwnership(domains => {\n            domains RegisterDomain(\"Orders\", \"http://orders\");        // Aspire resolves to actual URL\n            domains RegisterDomain(\"Inventory\", \"http://inventory\");  // Aspire resolves to actual URL\n        });\n    });\n});\n// Commands automatically routed to correct service\nawait whizbang Send(new PlaceOrder( ));  // Routes to http://orders (resolved by Aspire)\n`\nEnd-to-End Example\nComplete Aspire setup for microservices:\n`csharp{\ntitle: \"Complete Aspire Setup\"\ndescription: \"Full microservices setup with Whizbang and Aspire\"\nframework: \"NET8\"\ncategory: \"Aspire\"\ndifficulty: \"ADVANCED\"\ntags: [\"Aspire\", \"Microservices\", \"Complete Example\"]\nnugetPackages: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nfilename: \"AppHost/Program cs\"\nusingStatements: [\"Aspire Hosting\", \"Whizbang Aspire\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting;\nusing Whizbang Aspire;\nvar builder = DistributedApplication CreateBuilder(args);\n// Shared infrastructure\nvar whizbang = builder AddWhizbang(\"whizbang\") WithPostgres(pg => {\n        pg DatabaseName = \"whizbang_events\";\n        pg WithPgAdmin();\n    }) WithKafka(kafka => {\n        kafka WithKafkaUI();\n        kafka WithTopics(\n            \"whizbang orders events\",\n            \"whizbang inventory events\",\n            \"whizbang shipping events\",\n            \"whizbang payments events\"\n        );\n    }) WithRedis(redis => {\n        redis",
        "startIndex": 7068,
        "preview": "\"Aspire Redis Configuration\" description: \"Auto-configured Redis for caching\" framework: \"NET8\" category: \"Aspire\" difficulty: \"INTERMEDIATE\" tags: [\"..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/aspire-integration-chunk-4",
        "text": "Whizbang Aspire; var builder = DistributedApplication CreateBuilder(args); // Shared infrastructure var whizbang = builder AddWhizbang(\"whizbang\") WithPostgres(pg => { pg DatabaseName = \"whizbang_events\"; pg WithPgAdmin(); }) WithKafka(kafka => { kafka WithKafkaUI(); kafka WithTopics( \"whizbang orders events\", \"whizbang inventory events\", \"whizbang shipping events\", \"whizbang payments events\" ); }) WithRedis(redis => { redis WithRedisInsight();\n    }) WithOpenTelemetry();\n// Microservices (each has own event store partition)\nvar orders = builder AddProject<Projects OrdersService>(\"orders\") WithReference(whizbang) WithReplicas(3);  // Scale out\nvar inventory = builder AddProject<Projects InventoryService>(\"inventory\") WithReference(whizbang) WithReplicas(2);\nvar shipping = builder AddProject<Projects ShippingService>(\"shipping\") WithReference(whizbang);\nvar payments = builder AddProject<Projects PaymentsService>(\"payments\") WithReference(whizbang);\n// Analytics service (subscribes to all events)\nvar analytics = builder AddProject<Projects AnalyticsService>(\"analytics\") WithReference(whizbang);\n// API Gateway\nvar api = builder AddProject<Projects ApiGateway>(\"api\") WithReference(orders) WithReference(inventory) WithReference(shipping) WithReference(payments) WithHttpsEndpoint(port: 5000);\nbuilder Build() Run();\n`\nRunning:\n`bash{\ntitle: \"Run Complete Microservices Setup\"\ndescription: \"Start the full microservices architecture with Aspire\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Aspire\", \"Microservices\", \"Orchestration\"]\nshowLineNumbers: false\n}\ndotnet run --project AppHost\n`\nStarts:\n1 Postgres container (shared event store)\n1 Kafka + Zookeeper (shared message broker)\n1 Redis (shared cache)\n3 replicas of Orders service\n2 replicas of Inventory service\n1 Shipping service\n1 Payments service\n1 Analytics service\n1 API Gateway\nAspire Dashboard with full observability\nConfiguration Management\nAspire manages configuration across all services:\n`json{\ntitle: \"Aspire Configuration Structure\"\ndescription: \"Example of how Aspire auto-configures Whizbang settings\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Getting Started\", \"Aspire\", \"Configuration\", \"JSON\"]\nfilename: \"appsettings json\"\nshowLineNumbers: true\n}\n{\n  \"Aspire\": {\n    \"Whizbang\": {\n      \"EventStore\": {\n        \"ConnectionString\": \" auto-configured \",\n        \"SchemaName\": \"whizbang\",\n        \"AutoMigrate\": true\n      },\n      \"Messaging\": {\n        \"Kafka\": {\n          \"BootstrapServers\": \" auto-configured \",\n          \"ConsumerGroup\": \"orders-service\"\n        }\n      },\n      \"Projections\": {\n        \"Redis\": {\n          \"ConnectionString\": \" auto-configured \"\n        }\n      }\n    }\n  }\n}\n`\nConnection strings and URLs are automatically injected from Aspire infrastructure",
        "startIndex": 9435,
        "preview": "Whizbang Aspire; var builder = DistributedApplication CreateBuilder(args); // Shared infrastructure var whizbang = builder AddWhizbang(\"whizbang\") Wit..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/aspire-integration-chunk-5",
        "text": "{ \"Whizbang\": { \"EventStore\": { \"ConnectionString\": \" auto-configured \", \"SchemaName\": \"whizbang\", \"AutoMigrate\": true }, \"Messaging\": { \"Kafka\": { \"BootstrapServers\": \" auto-configured \", \"ConsumerGroup\": \"orders-service\" } }, \"Projections\": { \"Redis\": { \"ConnectionString\": \" auto-configured \" } } } } } ` Connection strings and URLs are automatically injected from Aspire infrastructure Testing with Aspire\nRun integration tests against Aspire-managed infrastructure:\n`csharp{\ntitle: \"Integration Tests with Aspire\"\ndescription: \"Test against real infrastructure via Aspire\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"ADVANCED\"\ntags: [\"Testing\", \"Aspire\", \"Integration Tests\"]\nnugetPackages: [\"Aspire Hosting Testing\", \"Whizbang Aspire\", \"xUnit\"]\nusingStatements: [\"Aspire Hosting Testing\", \"Xunit\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing Aspire Hosting Testing;\nusing System Threading Tasks;\nusing Xunit;\npublic class OrderServiceTests : IClassFixture<DistributedApplicationFixture> {\n    private readonly DistributedApplicationFixture _fixture;\n    public OrderServiceTests(DistributedApplicationFixture fixture) {\n        _fixture = fixture;\n    }\n    [Fact]\n    public async Task PlaceOrder_PersistsToEventStore() {\n        // Aspire starts Postgres, Kafka, and services\n        await using var app = await _fixture CreateApplicationAsync();\n        await app StartAsync();\n        var ordersService = app GetHttpClient(\"orders\");\n        // Test against real service with real infrastructure\n        var response = await ordersService PostAsJsonAsync(\"/orders\", new {\n            CustomerId = Guid NewGuid(),\n            Items = new[] { new { ProductId = Guid NewGuid(), Quantity = 2, Price = 19 99 } }\n        });\n        response EnsureSuccessStatusCode();\n        // Events are actually persisted to Postgres\n        // Projections are actually updated via Kafka\n    }\n}\n`\nTests run against real infrastructure (Postgres, Kafka, etc ) managed by Aspire",
        "startIndex": 11934,
        "preview": "{ \"Whizbang\": { \"EventStore\": { \"ConnectionString\": \" auto-configured \", \"SchemaName\": \"whizbang\", \"AutoMigrate\": true }, \"Messaging\": { \"Kafka\": { \"B..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/aspire-integration-chunk-6",
        "text": "= new[] { new { ProductId = Guid NewGuid(), Quantity = 2, Price = 19 99 } } }); response EnsureSuccessStatusCode(); // Events are actually persisted to Postgres // Projections are actually updated via Kafka } } ` Tests run against real infrastructure (Postgres, Kafka, etc ) managed by Aspire Benefits of Aspire Integration\nFor Local Development\nOne command starts everything (databases, message brokers, services)\nNo manual Docker Compose management\nAutomatic configuration (connection strings, URLs)\nLive reload with hot reload support\nObservability dashboard out of the box\nFor Team Onboarding\nNew developers clone repo and run dotnet run --project AppHost\nEverything \"just works\" - no manual setup\nConsistent environment across team members\nSelf-documenting infrastructure (defined in code)\nFor Production\nSame infrastructure configuration in dev and prod\nAspire generates Kubernetes manifests\nEasy transition from local to cloud\nAzure Container Apps / AKS deployment support\nDeployment\nGenerate deployment artifacts from Aspire:\n`bash{\ntitle: \"Aspire Deployment Commands\"\ndescription: \"Generate deployment artifacts and deploy with Aspire\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Aspire\", \"Deployment\", \"Kubernetes\", \"Docker\"]\nshowLineNumbers: true\n}\nGenerate Kubernetes manifests\ndotnet run --project AppHost -- publish --output-path /deploy/k8s\nGenerate Docker Compose\ndotnet run --project AppHost -- publish --output-path /deploy/docker --format docker-compose\nDeploy to Azure Container Apps\nazd init\nazd up\n`\nNext Steps\nDistributed Messaging - Microservices with Kafka\nObservability - OpenTelemetry and monitoring\nTesting - Test with Aspire infrastructure\nResources NET Aspire Documentation\nWhizbang Aspire Samples\nAspire Dashboard Guide",
        "startIndex": 13534,
        "preview": "= new[] { new { ProductId = Guid NewGuid(), Quantity = 2, Price = 19 99 } } }); response EnsureSuccessStatusCode(); // Events are actually persisted t..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/getting-started/getting-started",
    "title": "Getting Started",
    "category": "Getting Started",
    "url": "/docs/old-v1.0.0.0/getting-started/getting-started",
    "chunks": [
      {
        "id": "old-v1.0.0.0/getting-started/getting-started-chunk-0",
        "text": "Getting Started\nThis is a hands-on tutorial that walks you through building your first Whizbang application, starting with a simple in-process mediator and progressively adding event sourcing, projections, and distributed messaging What you'll build:\n✅ Event-Driven Architecture - Receptors, Perspectives, and Lenses with Whizbang Core\n✅ Event Sourcing - Stateful receptors and ledger with Whizbang EventSourcing\n✅ Multiple Perspectives - Different views of the same events for efficient queries\n`mermaid\ngraph LR\n    A[Event-Driven] -->|Add Ledger| B[Event-Sourced]\n    B -->|Add Perspectives| C[Full Event Architecture]\n    class A layer-command\n    class B layer-event\n    class C layer-read\n`\nCompanion guides:\n📦 Package Structure - Reference guide for all NuGet packages, ORMs, and message broker adapters\n🧠 Philosophy - Understand Whizbang's design principles and architectural decisions\n📚 Core Concepts - Deep dive into commands, events, aggregates, and projections\nPrerequisites NET 8 0 SDK or later\nC12 or later\nYour favorite IDE (Visual Studio, Rider, VS Code)\nInstallation\n> 📦 Want to understand all available packages See the Package Structure Reference for a complete guide to Whizbang's NuGet packages, ORM integrations, and message broker adapters Step 1: Create a New Project\n`bash{\ntitle: \"Create New Web API Project\"\ndescription: \"Create a new ASP NET Core Web API project named MyApp\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"Setup\", \"dotnet\", \"Project Creation\"]\n}\ndotnet new webapi -n MyApp\ncd MyApp\n`\nStep 2: Install Whizbang\nFor this tutorial, we'll start with just the core package:\n`bash{\ntitle: \"Install Whizbang Core Package\"\ndescription: \"Add the Whizbang Core NuGet package for event-driven architecture\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"Installation\", \"dotnet\", \"Package Management\"]\n}\ndotnet add package Whizbang Core\n`\nWhat is Whizbang Core The foundation for event-driven architecture - includes dispatcher, receptors, perspectives, and lenses",
        "startIndex": 0,
        "preview": "Getting Started\nThis is a hands-on tutorial that walks you through building your first Whizbang application, starting with a simple in-process mediato..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/getting-started-chunk-1",
        "text": "\"Install Whizbang Core Package\" description: \"Add the Whizbang Core NuGet package for event-driven architecture\" framework: \"NET8\" category: \"Getting Started\" difficulty: \"BEGINNER\" tags: [\"Commands\", \"Installation\", \"dotnet\", \"Package Management\"] } dotnet add package Whizbang Core ` What is Whizbang Core The foundation for event-driven architecture - includes dispatcher, receptors, perspectives, and lenses Perfect for learning event-driven patterns where all writes flow through events We'll add event sourcing later in this tutorial ---\nYour First Command and Receptor\nLet's build a simple order system with event-driven architecture `mermaid\nsequenceDiagram\n    participant API as API Endpoint\n    participant D as Dispatcher\n    participant R as OrderReceptor\n    participant P as OrderPerspective\n    participant DB as Database\n    API->>D: Dispatch(PlaceOrder)\n    D->>R: Receive(PlaceOrder)\n    R->>R: Validate with Lens\n    R-->>D: OrderPlaced event\n    D->>P: Update(OrderPlaced)\n    P->>DB: Write order\n    D-->>API: OrderPlaced event\n    Note over API,DB: Event-driven pattern<br/>All writes through events\n`\nStep 1: Define a Command\nCreate Commands/PlaceOrder cs:\n`csharp{\ntitle: \"PlaceOrder Command\"\ndescription: \"Command to place a new order\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"CQRS\"]\nfilename: \"Commands/PlaceOrder cs\"\nusingStatements: [\"System\"]\nshowLineNumbers: true\n}\nusing System;\nnamespace MyApp Commands;\npublic record PlaceOrder(\n    Guid CustomerId,\n    List<OrderItem> Items\n);\npublic record OrderItem(\n    Guid ProductId,\n    int Quantity,\n    decimal Price\n);\n`\nStep 2: Create a Receptor\nCreate Receptors/PlaceOrderReceptor cs:\n`csharp{\ntitle: \"PlaceOrder Receptor\"\ndescription: \"Receptor that processes PlaceOrder commands\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Event-Driven\", \"Commands\"]\nfilename: \"Receptors/PlaceOrderReceptor cs\"\nusingStatements: [\"System\", \"Whizbang\", \"MyApp Commands\", \"MyApp Events\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing MyApp Commands;\nusing MyApp Events;\nnamespace MyApp Receptors;\npublic class PlaceOrderReceptor : IReceptor<PlaceOrder> {\n    public OrderPlaced Receive(PlaceOrder command) {\n        // Validate\n        if (command Items Count == 0) {\n            throw new InvalidOperationException(\"Order must have at least one item\");\n        }\n        // Create event\n        var orderId = Guid NewGuid();\n        var total = command Items Sum(i => i Price * i",
        "startIndex": 2091,
        "preview": "\"Install Whizbang Core Package\" description: \"Add the Whizbang Core NuGet package for event-driven architecture\" framework: \"NET8\" category: \"Getting ..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/getting-started-chunk-2",
        "text": "Receptors; public class PlaceOrderReceptor : IReceptor<PlaceOrder> { public OrderPlaced Receive(PlaceOrder command) { // Validate if (command Items Count == 0) { throw new InvalidOperationException(\"Order must have at least one item\"); } // Create event var orderId = Guid NewGuid(); var total = command Items Sum(i => i Price * i Quantity);\n        // Return event - perspective will handle persistence\n        return new OrderPlaced(\n            orderId,\n            command CustomerId,\n            DateTimeOffset UtcNow,\n            command Items,\n            total\n        );\n    }\n}\n`\nStep 3: Create a Perspective\nCreate Perspectives/OrderPerspective cs:\n`csharp{\ntitle: \"Order Perspective\"\ndescription: \"Perspective that handles OrderPlaced events\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Perspectives\", \"Event-Driven\", \"Database\"]\nfilename: \"Perspectives/OrderPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\", \"MyApp Events\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\nusing MyApp Events;\nnamespace MyApp Perspectives;\npublic class OrderPerspective : IPerspectiveOf<OrderPlaced> {\n    private readonly IOrderDatabase db;\n    public OrderPerspective(IOrderDatabase db) {\n        _db = db;\n    }\n    public async Task Update(OrderPlaced @event) {\n        // Perspective handles all writes\n        await _db Orders Add(new Order {\n            Id = @event OrderId,\n            CustomerId = @event CustomerId,\n            PlacedAt = @event PlacedAt,\n            Total = @event Total,\n            Status = \"Placed\"\n        });\n        await _db SaveChanges();\n    }\n}\n`\nStep 4: Configure Whizbang\nUpdate Program cs:\n`csharp{\ntitle: \"Whizbang Configuration\"\ndescription: \"Configure Whizbang dispatcher in ASP NET Core\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Configuration\", \"Setup\", \"ASP NET Core\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nvar builder = WebApplication CreateBuilder(args);\n// Add Whizbang dispatcher\nbuilder Services AddWhizbang(options => {\n    // Scan this assembly for receptors and perspectives\n    options ScanAssembly(typeof(Program) Assembly);\n});\nvar app = builder Build();\napp MapPost(\"/orders\", async (PlaceOrder command, IDispatcher dispatcher) => {\n    var @event = await dispatcher Send(command);\n    return Results Ok(new { OrderId = @event OrderId, Total = @event Total });\n});\napp",
        "startIndex": 4234,
        "preview": "Receptors; public class PlaceOrderReceptor : IReceptor<PlaceOrder> { public OrderPlaced Receive(PlaceOrder command) { // Validate if (command Items Co..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/getting-started-chunk-3",
        "text": "AddWhizbang(options => { // Scan this assembly for receptors and perspectives options ScanAssembly(typeof(Program) Assembly); }); var app = builder Build(); app MapPost(\"/orders\", async (PlaceOrder command, IDispatcher dispatcher) => { var @event = await dispatcher Send(command); return Results Ok(new { OrderId = @event OrderId, Total = @event Total }); }); app Run();\n`\nStep 5: Run the Application\n`bash{\ntitle: \"Run the Application\"\ndescription: \"Start the ASP NET Core Web API application\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"dotnet\", \"Execution\"]\n}\ndotnet run\n`\nTest with curl:\n`bash{\ntitle: \"Test Order API Endpoint\"\ndescription: \"Send a POST request to create a new order using curl\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"Testing\", \"API\", \"curl\"]\n}\ncurl -X POST http://localhost:5000/orders \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"customerId\": \"123e4567-e89b-12d3-a456-426614174000\",\n    \"items\": [\n      { \"productId\": \"prod-1\", \"quantity\": 2, \"price\": 19 99 }\n    ]\n  }'\n`\nCongratulations You've created your first Whizbang event-driven application with receptors and perspectives All writes flow through events, making the transition to event sourcing seamless ---\nAdding Event Sourcing\nLet's upgrade to event sourcing with stateful receptors and a ledger for complete audit trail `mermaid\nsequenceDiagram\n    participant API as API Endpoint\n    participant D as Dispatcher\n    participant R as OrderReceptor\n    participant L as Ledger\n    participant P as Perspective\n    API->>D: Send(PlaceOrder)\n    D->>R: Receive(PlaceOrder)\n    R->>R: Validate business rules\n    R->>R: Apply(OrderPlaced)\n    Note over R: Event updates<br/>receptor state\n    D->>L: Append events to stream\n    L-->>D: Events saved\n    D->>P: Update(OrderPlaced)\n    P->>P: Update read models\n    D-->>API: OrderPlaced event\n    Note over API,P: Events stored as immutable log<br/>Complete audit trail\n`\n> 📦 Learn more: See Whizbang EventSourcing in the Package Structure guide for ORM options, database support, and advanced configuration Step 1: Install Event Sourcing Package\n`bash{\ntitle: \"Install Event Sourcing Packages\"\ndescription: \"Add Whizbang",
        "startIndex": 6461,
        "preview": "AddWhizbang(options => { // Scan this assembly for receptors and perspectives options ScanAssembly(typeof(Program) Assembly); }); var app = builder Bu..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/getting-started-chunk-4",
        "text": "models D-->>API: OrderPlaced event Note over API,P: Events stored as immutable log<br/>Complete audit trail ` > 📦 Learn more: See Whizbang EventSourcing in the Package Structure guide for ORM options, database support, and advanced configuration Step 1: Install Event Sourcing Package `bash{ title: \"Install Event Sourcing Packages\" description: \"Add Whizbang EventSourcing and database provider packages\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Commands\", \"Installation\", \"dotnet\", \"Package Management\", \"Event Sourcing\"]\n}\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang Postgres  Or Whizbang SqlServer, Whizbang EntityFramework, etc `\nStep 2: Define Events\nCreate Events/OrderEvents cs:\n`csharp{\ntitle: \"Order Domain Events\"\ndescription: \"Events representing order lifecycle state changes\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"BEGINNER\"\ntags: [\"Events\", \"Event Sourcing\", \"Domain Events\"]\nfilename: \"Events/OrderEvents cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nnamespace MyApp Events;\n[OwnedBy(\"Orders\")]  // This event comes from the Orders domain\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset PlacedAt,\n    List<OrderItem> Items,\n    decimal Total\n);\n[OwnedBy(\"Orders\")]\npublic record OrderShipped(\n    Guid OrderId,\n    DateTimeOffset ShippedAt,\n    string TrackingNumber\n);\n`\nStep 3: Create a Stateful Receptor\nCreate Receptors/OrderReceptor cs:\n`csharp{\ntitle: \"Event-Sourced Order Receptor\"\ndescription: \"Stateful receptor for event-sourced orders\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Receptors\", \"Event Sourcing\", \"Stateful\"]\nfilename: \"Receptors/OrderReceptor cs\"\nusingStatements: [\"System\", \"Whizbang\", \"MyApp Commands\", \"MyApp Events\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing MyApp Commands;\nusing MyApp Events;\nnamespace MyApp Receptors;\n[EventSourced]\npublic class OrderReceptor : \n    IReceptor<PlaceOrder>,\n    IReceptor<ShipOrder> {\n    private Guid id;\n    private Guid customerId;\n    private OrderStatus status;\n    private List<OrderItem> items = new();\n    private decimal total;\n    // Command handler for new orders\n    public OrderPlaced Receive(PlaceOrder command) {\n        if (id = Guid Empty) {\n            throw new InvalidOperationException(\"Order already exists\");\n        }\n        if (command Items Count == 0) {\n            throw new InvalidOperationException(\"Order must have items\");\n        }\n        var orderTotal = command Items Sum(i => i",
        "startIndex": 8361,
        "preview": "models D-->>API: OrderPlaced event Note over API,P: Events stored as immutable log<br/>Complete audit trail ` > 📦 Learn more: See Whizbang EventSourc..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/getting-started-chunk-5",
        "text": "= new(); private decimal total; // Command handler for new orders public OrderPlaced Receive(PlaceOrder command) { if (id = Guid Empty) { throw new InvalidOperationException(\"Order already exists\"); } if (command Items Count == 0) { throw new InvalidOperationException(\"Order must have items\"); } var orderTotal = command Items Sum(i => i Price * i Quantity);\n        return new OrderPlaced(\n            Guid NewGuid(),\n            command CustomerId,\n            DateTimeOffset UtcNow,\n            command Items,\n            orderTotal\n        );\n    }\n    // Command handler for shipping\n    public OrderShipped Receive(ShipOrder command) {\n        if (status = OrderStatus Placed) {\n            throw new InvalidOperationException(\"Only placed orders can be shipped\");\n        }\n        return new OrderShipped(id, DateTimeOffset UtcNow, command TrackingNumber);\n    }\n    // Event handler - updates internal state\n    public void Absorb(OrderPlaced @event) {\n        id = @event OrderId;\n        customerId = @event CustomerId;\n        status = OrderStatus Placed;\n        items = @event Items ToList();\n        total = @event Total;\n    }\n    // Event handler - updates internal state\n    public void Absorb(OrderShipped @event) {\n        status = OrderStatus Shipped;\n    }\n}\npublic enum OrderStatus {\n    Placed,\n    Shipped,\n    Delivered,\n    Cancelled\n}\npublic record ShipOrder(Guid OrderId, string TrackingNumber);\n`\nStep 4: Add Event Definitions\nUpdate Events/OrderEvents cs with shipping event:\n`csharp{\ntitle: \"Complete Order Domain Events\"\ndescription: \"Events representing complete order lifecycle\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"BEGINNER\"\ntags: [\"Events\", \"Event Sourcing\", \"Domain Events\"]\nfilename: \"Events/OrderEvents cs\"\nusingStatements: [\"System\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nnamespace MyApp Events;\n[OwnedBy(\"Orders\")]\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset PlacedAt,\n    List<OrderItem> Items,\n    decimal Total\n);\n[OwnedBy(\"Orders\")]\npublic record OrderShipped(\n    Guid OrderId,\n    DateTimeOffset ShippedAt,\n    string TrackingNumber\n);\n`\nStep 5: Configure Event Sourcing\nUpdate Program cs:\n`csharp{\ntitle: \"Event Sourcing Configuration\"\ndescription: \"Configure Whizbang dispatcher with event sourcing and ledger\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Configuration\", \"Event Sourcing\", \"Postgres\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nvar builder = WebApplication",
        "startIndex": 4224,
        "preview": "= new(); private decimal total; // Command handler for new orders public OrderPlaced Receive(PlaceOrder command) { if (id = Guid Empty) { throw new In..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/getting-started-chunk-6",
        "text": "5: Configure Event Sourcing Update Program cs: `csharp{ title: \"Event Sourcing Configuration\" description: \"Configure Whizbang dispatcher with event sourcing and ledger\" framework: \"NET8\" category: \"Event Sourcing\" difficulty: \"INTERMEDIATE\" tags: [\"Configuration\", \"Event Sourcing\", \"Postgres\"] filename: \"Program cs\" usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"] showLineNumbers: true } using Whizbang; var builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbang(dispatcher => {\n    dispatcher RegisterReceptorsFromAssembly(typeof(Program) Assembly);\n    dispatcher RegisterPerspectivesFromAssembly(typeof(Program) Assembly);\n    // Enable event sourcing with ledger\n    dispatcher UseEventSourcing(es => {\n        es UseLedger(ledger => {\n            ledger UsePostgres(builder Configuration GetConnectionString(\"EventStore\"));\n        });\n    });\n});\nvar app = builder Build();\napp MapPost(\"/orders\", async (PlaceOrder command, IDispatcher dispatcher) => {\n    var @event = await dispatcher Send(command);\n    return Results Ok(new { OrderId = @event OrderId, Total = @event Total });\n});\napp Run();\n`\nAdd connection string to appsettings json:\n`json\n{\n  \"ConnectionStrings\": {\n    \"EventStore\": \"Host=localhost;Database=myapp;Username=user;Password=pass\"\n  }\n}\n`\nNow you have full event sourcing Receptors maintain state from events stored in the ledger, providing a complete audit trail and the ability to replay state from any point in time ---\nAdding Multiple Perspectives (Read Models)\nLet's add additional perspectives to maintain different views of order data for efficient queries `mermaid\ngraph TB\n    subgraph \"Write Side (Commands)\"\n        CMD[PlaceOrder Command]\n        AGG[Order Aggregate]\n        ES[Event Store]\n    end\n    subgraph \"Event Bus\"\n        EVT[OrderPlaced Event]\n    end\n    subgraph \"Read Side (Queries)\"\n        PROJ[OrderHistoryProjection]\n        RM[Read Model DB]\n        QUERY[Query: Get Orders]\n    end\n    CMD -->|Creates| AGG\n    AGG -->|Stores events| ES\n    ES -->|Publishes| EVT\n    EVT -->|Subscribes| PROJ\n    PROJ -->|Updates| RM\n    QUERY -->|Reads from| RM\n    class CMD layer-command\n    class AGG layer-core\n    class ES layer-event\n    class PROJ layer-read\n    class RM layer-read\n`\n> 📦 Learn more: See Whizbang Perspectives in the Package Structure guide for advanced perspective patterns and database integration Step 1: Create Order History Lens\nCreate Lenses/IOrderLens",
        "startIndex": 12930,
        "preview": "5: Configure Event Sourcing Update Program cs: `csharp{ title: \"Event Sourcing Configuration\" description: \"Configure Whizbang dispatcher with event s..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/getting-started-chunk-7",
        "text": "PROJ -->|Updates| RM QUERY -->|Reads from| RM class CMD layer-command class AGG layer-core class ES layer-event class PROJ layer-read class RM layer-read ` > 📦 Learn more: See Whizbang Perspectives in the Package Structure guide for advanced perspective patterns and database integration Step 1: Create Order History Lens Create Lenses/IOrderLens cs:\n`csharp{\ntitle: \"Order Lens Interface\"\ndescription: \"Read-only lens for querying orders\"\nframework: \"NET8\"\ncategory: \"Lenses\"\ndifficulty: \"BEGINNER\"\ntags: [\"Lenses\", \"Queries\", \"Read-Only\"]\nfilename: \"Lenses/IOrderLens cs\"\nusingStatements: [\"System\", \"System Linq Expressions\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Linq Expressions;\nnamespace MyApp Lenses;\npublic interface IOrderLens {\n    OrderSummary Focus(Guid orderId);\n    IEnumerable<OrderSummary> ViewByCustomer(Guid customerId);\n    IEnumerable<OrderSummary> View(Expression<Func<OrderSummary, bool>> filter);\n    bool Exists(Guid orderId);\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    public DateTimeOffset PlacedAt { get; set; }\n    public DateTimeOffset ShippedAt { get; set; }\n    public decimal Total { get; set; }\n    public string Status { get; set; }\n}\n`\nStep 2: Create Order History Perspective\nCreate Perspectives/OrderHistoryPerspective cs:\n`csharp{\ntitle: \"Order History Perspective\"\ndescription: \"Perspective that maintains order history for queries\"\nframework: \"NET8\"\ncategory: \"Perspectives\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Perspectives\", \"Read Models\", \"Multiple Views\"]\nfilename: \"Perspectives/OrderHistoryPerspective cs\"\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang\", \"MyApp Events\", \"MyApp Lenses\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang;\nusing MyApp Events;\nusing MyApp Lenses;\nnamespace MyApp Perspectives;\npublic class OrderHistoryPerspective : \n    IPerspectiveOf<OrderPlaced>,\n    IPerspectiveOf<OrderShipped> {\n    private readonly IOrderHistoryDatabase db;\n    public OrderHistoryPerspective(IOrderHistoryDatabase db) {\n        _db = db;\n    }\n    public async Task Update(OrderPlaced @event) {\n        await _db OrderHistory Add(new OrderSummary {\n            OrderId = @event OrderId,\n            CustomerId = @event CustomerId,\n            PlacedAt = @event PlacedAt,\n            Total = @event Total,\n            Status = \"Placed\"\n        });\n        await _db SaveChanges();\n    }\n    public async Task Update(OrderShipped @event) {\n        var order = await _db OrderHistory Get(@event OrderId);\n        order ShippedAt = @event ShippedAt;\n        order",
        "startIndex": 14949,
        "preview": "PROJ -->|Updates| RM QUERY -->|Reads from| RM class CMD layer-command class AGG layer-core class ES layer-event class PROJ layer-read class RM layer-r..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/getting-started-chunk-8",
        "text": "await _db OrderHistory Add(new OrderSummary { OrderId = @event OrderId, CustomerId = @event CustomerId, PlacedAt = @event PlacedAt, Total = @event Total, Status = \"Placed\" }); await _db SaveChanges(); } public async Task Update(OrderShipped @event) { var order = await _db OrderHistory Get(@event OrderId); order ShippedAt = @event ShippedAt; order Status = \"Shipped\";\n        await _db SaveChanges();\n    }\n}\n`\nStep 3: Implement Order Lens\nCreate Lenses/OrderLens cs:\n`csharp{\ntitle: \"Order Lens Implementation\"\ndescription: \"Lens implementation for querying order history\"\nframework: \"NET8\"\ncategory: \"Lenses\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Lenses\", \"Implementation\", \"Database\"]\nfilename: \"Lenses/OrderLens cs\"\nusingStatements: [\"System\", \"System Linq Expressions\", \"MyApp Lenses\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Linq Expressions;\nusing MyApp Lenses;\nnamespace MyApp Lenses;\npublic class OrderLens : IOrderLens {\n    private readonly IOrderHistoryDatabase db;\n    public OrderLens(IOrderHistoryDatabase db) {\n        _db = db;\n    }\n    public OrderSummary Focus(Guid orderId) {\n        return _db OrderHistory FirstOrDefault(o => o OrderId == orderId);\n    }\n    public IEnumerable<OrderSummary> ViewByCustomer(Guid customerId) {\n        return _db OrderHistory Where(o => o CustomerId == customerId) OrderByDescending(o => o PlacedAt);\n    }\n    public IEnumerable<OrderSummary> View(Expression<Func<OrderSummary, bool>> filter) {\n        return _db OrderHistory Where(filter);\n    }\n    public bool Exists(Guid orderId) {\n        return _db OrderHistory Any(o => o OrderId == orderId);\n    }\n}\n`\nStep 4: Configure Multiple Perspectives\nUpdate Program cs:\n`csharp{\ntitle: \"Multiple Perspectives Configuration\"\ndescription: \"Configure multiple perspectives in Whizbang dispatcher\"\nframework: \"NET8\"\ncategory: \"Perspectives\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Configuration\", \"Perspectives\", \"Multiple Views\"]\nfilename: \"Program cs\"\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"MyApp Lenses\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing MyApp Lenses;\nbuilder Services AddWhizbang(dispatcher => {\n    dispatcher RegisterReceptorsFromAssembly(typeof(Program) Assembly);\n    dispatcher RegisterPerspectivesFromAssembly(typeof(Program) Assembly);\n    // Register lenses\n    dispatcher RegisterLensesFromAssembly(typeof(Program) Assembly);\n    dispatcher UseEventSourcing(es => {\n        es UseLedger(ledger => {\n            ledger UsePostgres(connectionString);\n        });\n    });\n});\n// Register lens implementations\nbuilder Services",
        "startIndex": 17247,
        "preview": "await _db OrderHistory Add(new OrderSummary { OrderId = @event OrderId, CustomerId = @event CustomerId, PlacedAt = @event PlacedAt, Total = @event Tot..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/getting-started-chunk-9",
        "text": "[\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"MyApp Lenses\"] showLineNumbers: true } using Whizbang; using MyApp Lenses; builder Services AddWhizbang(dispatcher => { dispatcher RegisterReceptorsFromAssembly(typeof(Program) Assembly); dispatcher RegisterPerspectivesFromAssembly(typeof(Program) Assembly); // Register lenses dispatcher RegisterLensesFromAssembly(typeof(Program) Assembly); dispatcher UseEventSourcing(es => { es UseLedger(ledger => { ledger UsePostgres(connectionString); }); }); }); // Register lens implementations builder Services AddScoped<IOrderLens, OrderLens>();\n`\nStep 5: Query via Lens\nAdd query endpoint:\n`csharp{\ntitle: \"Query Order History via Lens\"\ndescription: \"Query endpoint using order lens for read operations\"\nframework: \"NET8\"\ncategory: \"Lenses\"\ndifficulty: \"BEGINNER\"\ntags: [\"Queries\", \"Lenses\", \"API\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft AspNetCore Builder\", \"System\", \"MyApp Lenses\"]\nshowLineNumbers: true\n}\napp MapGet(\"/customers/{customerId}/orders\", (\n    Guid customerId,\n    IOrderLens lens\n) => {\n    var orders = lens ViewByCustomer(customerId);\n    return Results Ok(orders);\n});\napp MapGet(\"/orders/{orderId}\", (\n    Guid orderId,\n    IOrderLens lens\n) => {\n    var order = lens Focus(orderId);\n    return order = null Results Ok(order) : Results NotFound();\n});\n`\nNow you have complete CQRS Commands go to receptors (decision-making), events flow to perspectives (write side), and queries use lenses (read side) Multiple perspectives can maintain different views of the same events ---\nNext Steps\nYou've built a complete Event-Driven and Event-Sourced application with Whizbang Here's what to explore next:\nPhilosophy - Understand Whizbang's design principles and architectural philosophy\nCore Concepts - Deep dive into receptors, perspectives, lenses, and events\nPackage Structure - Learn about all available packages\nTesting - Test your event-driven and event-sourced applications\nDistributed Messaging - Scale to microservices with relays and message brokers\nSagas - Coordinate long-running processes across receptors\nObservability - Monitor your event-driven systems",
        "startIndex": 19515,
        "preview": "[\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"MyApp Lenses\"] showLineNumbers: true } using Whizbang; using MyApp Lenses; builder Services ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/getting-started/package-structure",
    "title": "Package Structure",
    "category": "Getting Started",
    "url": "/docs/old-v1.0.0.0/getting-started/package-structure",
    "chunks": [
      {
        "id": "old-v1.0.0.0/getting-started/package-structure-chunk-0",
        "text": "Package Structure\nThis is a reference guide to all available Whizbang NuGet packages, their capabilities, and how to choose the right ones for your application > 💡 New to Whizbang Start with the Getting Started Tutorial for hands-on, step-by-step learning Come back here when you need detailed package information Overview\nWhizbang is distributed as a suite of NuGet packages, allowing you to install only what you need This keeps your application lean and supports AOT compilation Package Philosophy:\nStart minimal - Begin with Whizbang Core (just the mediator)\nAdd as needed - Install event sourcing, projections, messaging only when required\nChoose your stack - Pick your preferred ORM (EF Core, Dapper, NHibernate) and message broker\nStay lean - No forced dependencies, excellent for AOT compilation\n`mermaid\n%%{init: {'flowchart': {'nodeSpacing': 800}, 'themeVariables': {'fontSize': '200px'}}}%%\ngraph LR\n    subgraph ORM[\"ORM Integrations\"]\n        WhizEF[Whizbang EntityFramework<br/>EF Core Integration]\n        WhizDapper[Whizbang Dapper<br/>Dapper Integration]\n        WhizNH[Whizbang NHibernate<br/>NHibernate Integration]\n    end\n    subgraph Core[\"Core Packages\"]\n        WhizCore[Whizbang Core<br/>Mediator, Handlers, Pipeline]\n        WhizES[Whizbang EventSourcing<br/>Event Store, Aggregates]\n        WhizProj[Whizbang Projections<br/>Read Models, Subscriptions]\n        WhizMsg[Whizbang Messaging<br/>Distributed Messaging, Outbox/Inbox]\n    end\n    subgraph Messaging[\"Message Broker Adapters\"]\n        WhizKafka[Whizbang Kafka]\n        WhizRabbit[Whizbang RabbitMQ]\n        WhizASB[Whizbang AzureServiceBus]\n        WhizSQS[Whizbang AWSSQS]\n    end\n    subgraph Observability[\"Observability\"]\n        WhizOTel[Whizbang OpenTelemetry<br/>Tracing, Metrics]\n        WhizDash[Whizbang Dashboard<br/>Monitoring UI]\n    end\n    subgraph Dev[\"Developer Tools\"]\n        WhizAnalyzers[Whizbang Analyzers<br/>Roslyn Analyzers, Purity Checks]\n        WhizTesting[Whizbang Testing<br/>In-Memory Doubles, Test Helpers]\n    end\n    ORM - ->|Require| WhizES\n    Messaging -",
        "startIndex": 0,
        "preview": "Package Structure\nThis is a reference guide to all available Whizbang NuGet packages, their capabilities, and how to choose the right ones for your ap..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/package-structure-chunk-1",
        "text": "Projections<br/>Read Models, Subscriptions] WhizMsg[Whizbang Messaging<br/>Distributed Messaging, Outbox/Inbox] end subgraph Messaging[\"Message Broker Adapters\"] WhizKafka[Whizbang Kafka] WhizRabbit[Whizbang RabbitMQ] WhizASB[Whizbang AzureServiceBus] WhizSQS[Whizbang AWSSQS] end subgraph Observability[\"Observability\"] WhizOTel[Whizbang OpenTelemetry<br/>Tracing, Metrics] WhizDash[Whizbang Dashboard<br/>Monitoring UI] end subgraph Dev[\"Developer Tools\"] WhizAnalyzers[Whizbang Analyzers<br/>Roslyn Analyzers, Purity Checks] WhizTesting[Whizbang Testing<br/>In-Memory Doubles, Test Helpers] end ORM - ->|Require| WhizES Messaging - ->|Require| WhizMsg\n    WhizES --> WhizCore\n    WhizProj --> WhizCore\n    WhizProj --> WhizES\n    WhizMsg --> WhizCore\n`\nFunctional Area Color Key\nThe diagram uses color-coded edges to indicate functional areas:\n🟢 Green (Core) - Core business logic and domain functionality\n🔴 Red (Event) - Event sourcing, data persistence, and event handling\n🔵 Blue (Read) - Read models, projections, and query operations\n🟡 Yellow (Command) - Commands, write operations, and distributed messaging\n🔷 Teal (Observability) - Telemetry, metrics, tracing, and monitoring\n🟣 Purple (Infrastructure) - Developer tools, analyzers, and testing utilities\nCore Packages\nWhizbang Core\nThe minimal foundation for all Whizbang applications `bash{\ntitle: \"Install Whizbang Core Package\"\ndescription: \"Install the minimal foundation package for Whizbang applications\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Core\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang Core\n`\nIncludes:\nMessage routing (commands, events, queries)\nIn-memory mediator\nHandler discovery and execution\nBasic pipeline (validation, authorization hooks)\nNo persistence, no external messaging\nUse when:\nBuilding a simple CQRS application\nYou don't need event sourcing or projections\nIn-process messaging is sufficient\nLearning Whizbang\nExample:\n`csharp{\ntitle: \"Simple Mediator Setup - Complete Program cs\"\ndescription: \"Complete example showing Whizbang Core as an in-process mediator with handler discovery\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Mediator\", \"CQRS\", \"Setup\", \"Program cs\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\"]\nshowLineNumbers: true\ncollapsedLines: [1-3, 25-35]\n}\n// Stage 1: Imports\nusing Microsoft Extensions DependencyInjection;\nusing Microsoft Extensions",
        "startIndex": 2086,
        "preview": "Projections<br/>Read Models, Subscriptions] WhizMsg[Whizbang Messaging<br/>Distributed Messaging, Outbox/Inbox] end subgraph Messaging[\"Message Broker..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/package-structure-chunk-2",
        "text": "Whizbang Core as an in-process mediator with handler discovery\" framework: \"NET8\" category: \"Getting Started\" difficulty: \"BEGINNER\" tags: [\"Mediator\", \"CQRS\", \"Setup\", \"Program cs\"] nugetPackages: [\"Whizbang Core\"] usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\"] showLineNumbers: true collapsedLines: [1-3, 25-35] } // Stage 1: Imports using Microsoft Extensions DependencyInjection; using Microsoft Extensions Hosting;\nusing Whizbang;\n// Stage 2: Host builder setup\nvar builder = Host CreateApplicationBuilder(args);\n// Stage 3: Register Whizbang mediator (in-memory only)\nbuilder Services AddWhizbang(options => {\n    // OPTION A: Source generator approach (recommended)\n    // Handlers decorated with [WhizbangHandler] are auto-discovered at compile time\n    options RegisterGeneratedHandlers();\n    // OPTION B: Explicit registration\n    // Manually register each handler for fine-grained control\n    // options RegisterHandler<PlaceOrder, PlaceOrderHandler>();\n    // options RegisterHandler<CancelOrder, CancelOrderHandler>();\n});\n// Stage 4: Build and run\nvar app = builder Build();\nawait app RunAsync();\n// Stage 5: Example handler decorated with [WhizbangHandler]\n[WhizbangHandler]  // Source generator picks this up\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderResult> {\n    public async Task<OrderResult> Handle(PlaceOrder command, CancellationToken ct) {\n        // Business logic here\n        return new OrderResult(command OrderId);\n    }\n}\n`\nHandler Discovery Approaches:\nWhizbang is 100% AOT-compatible and supports two ways to register handlers:\nSource Generator (Recommended): Decorate handlers with [WhizbangHandler] attribute At compile time, a source generator discovers all marked handlers and generates registration code Call options RegisterGeneratedHandlers() to use them `csharp\n   // Handler definition\n   [WhizbangHandler]\n   public class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderResult> { }\n   // Registration\n   options RegisterGeneratedHandlers();\n   `\n   Benefits:\nZero runtime reflection\nAOT-safe\nAutomatic discovery at compile time\nNo manual registration needed\nExplicit Registration: Manually register each handler Gives you full control and is AOT-safe `csharp\n   options RegisterHandler<PlaceOrder, PlaceOrderHandler>();\n   options",
        "startIndex": 4034,
        "preview": "Whizbang Core as an in-process mediator with handler discovery\" framework: \"NET8\" category: \"Getting Started\" difficulty: \"BEGINNER\" tags: [\"Mediator\"..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/package-structure-chunk-3",
        "text": "`csharp // Handler definition [WhizbangHandler] public class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderResult> { } // Registration options RegisterGeneratedHandlers(); ` Benefits: Zero runtime reflection AOT-safe Automatic discovery at compile time No manual registration needed Explicit Registration: Manually register each handler Gives you full control and is AOT-safe `csharp options RegisterHandler<PlaceOrder, PlaceOrderHandler>(); options RegisterHandler<CancelOrder, CancelOrderHandler>();\n   `\n   Benefits:\nFine-grained control over registration\nNo attributes in domain code\nExplicit and obvious\nAOT-safe\nNote: The [WhizbangHandler] attribute can be placed on:\nThe handler class itself\nA base class the handler inherits from\nAn interface the handler implements\nThe source generator will discover handlers through any of these paths Attribute Naming: All Whizbang attributes use the Whizbang prefix for consistency and to avoid naming collisions ([WhizbangHandler], [WhizbangProjection], [WhizbangSubscribe]) ---\nWhizbang EventSourcing\nEvent sourcing and aggregate support `bash{\ntitle: \"Install Whizbang EventSourcing Package\"\ndescription: \"Add event sourcing and aggregate support to your application\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Event Sourcing\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang EventSourcing\n`\nIncludes:\nEvent store abstraction\nAggregate base classes\nEvent stream management\nOptimistic concurrency\nEvent versioning\nRequires a persistence driver (see below)\nUse when:\nYou need event sourcing\nBuilding event-sourced aggregates\nYou want complete audit trails\nExample:\n`csharp{\ntitle: \"Event Sourcing Setup - Complete Program cs\"\ndescription: \"Complete example adding event sourcing to your application\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Event Sourcing\", \"Aggregates\", \"Setup\", \"Program cs\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\"]\nshowLineNumbers: true\ncollapsedLines: [1-3, 7-8]\n}\n// Stage 1: Imports\nusing Microsoft Extensions DependencyInjection;\nusing Microsoft Extensions Hosting;\nusing Whizbang;\n// Stage 2: Host builder setup\nvar builder = Host CreateApplicationBuilder(args);\n// Stage 3: Register Whizbang with event sourcing\nbuilder Services AddWhizbang(options => {\n    // Register handlers (using source generator)\n    options",
        "startIndex": 5940,
        "preview": "`csharp // Handler definition [WhizbangHandler] public class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderResult> { } // Registration options ..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/package-structure-chunk-4",
        "text": "true collapsedLines: [1-3, 7-8] } // Stage 1: Imports using Microsoft Extensions DependencyInjection; using Microsoft Extensions Hosting; using Whizbang; // Stage 2: Host builder setup var builder = Host CreateApplicationBuilder(args); // Stage 3: Register Whizbang with event sourcing builder Services AddWhizbang(options => { // Register handlers (using source generator) options RegisterGeneratedHandlers();\n    // Stage 4: Enable event sourcing\n    options UseEventSourcing(es => {\n        // For production, use an ORM integration (see ORM Integrations section)\n        // es UseEntityFramework(ef => ef UseNpgsql(connectionString));\n        // es UseDapper(d => d UseNpgsql(connectionString));\n        // For development/testing, use in-memory store\n        es UseInMemoryStore();\n    });\n});\n// Stage 5: Build and run\nvar app = builder Build();\nawait app RunAsync();\n`\n---\nWhizbang Projections\nRead-side projections and CQRS queries `bash{\ntitle: \"Install Whizbang Projections Package\"\ndescription: \"Add read-side projections and CQRS query support\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Projections\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang Projections\n`\nIncludes:\nProjection engine\nEvent subscription management\nCheckpoint tracking\nBackfilling from event history\nParallel processing across partitions\nUse when:\nBuilding read models from events\nImplementing CQRS\nYou need denormalized views for queries\nExample:\n`csharp{\ntitle: \"Projections Setup - Complete Program cs\"\ndescription: \"Complete example adding projection support with attribute-based registration\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"CQRS\", \"Read Models\", \"Program cs\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Projections\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\", \"System Threading Tasks\", \"System Threading\"]\nshowLineNumbers: true\ncollapsedLines: [1-3, 7-8, 28-30]\n}\n// Stage 1: Imports\nusing Microsoft Extensions DependencyInjection;\nusing Microsoft Extensions Hosting;\nusing Whizbang;\n// Stage 2: Host builder setup\nvar builder = Host CreateApplicationBuilder(args);\n// Stage 3: Register Whizbang with projections\nbuilder Services AddWhizbang(options => {\n    options RegisterGeneratedHandlers();\n    options UseEventSourcing(es => es UseInMemoryStore());\n    // Stage 4: Enable projections\n    options",
        "startIndex": 8035,
        "preview": "true collapsedLines: [1-3, 7-8] } // Stage 1: Imports using Microsoft Extensions DependencyInjection; using Microsoft Extensions Hosting; using Whizba..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/package-structure-chunk-5",
        "text": "// Stage 1: Imports using Microsoft Extensions DependencyInjection; using Microsoft Extensions Hosting; using Whizbang; // Stage 2: Host builder setup var builder = Host CreateApplicationBuilder(args); // Stage 3: Register Whizbang with projections builder Services AddWhizbang(options => { options RegisterGeneratedHandlers(); options UseEventSourcing(es => es UseInMemoryStore()); // Stage 4: Enable projections options UseProjections(proj => {\n        // OPTION A: Attribute-based registration (recommended)\n        // Projections decorated with [Projection] are auto-discovered\n        proj RegisterGeneratedProjections();\n        // OPTION B: Manual registration\n        // proj RegisterProjection<OrderHistoryProjection>();\n        // proj RegisterProjection<CustomerSummaryProjection>();\n    });\n});\n// Stage 5: Build and run\nvar app = builder Build();\nawait app RunAsync();\n// Stage 6: Example projection with attribute-based event subscriptions\n[WhizbangProjection]  // Source generator picks this up\npublic class OrderHistoryProjection {\n    private readonly List<OrderSummary> _orders = new();\n    // Subscribe to events using [WhizbangSubscribe] attribute on method parameter\n    public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) {\n        _orders Add(new OrderSummary(\n            @event OrderId,\n            @event CustomerId,\n            @event Total,\n            \"Placed\"\n        ));\n        return Task CompletedTask;\n    }\n    public Task Handle([WhizbangSubscribe] OrderShipped @event, CancellationToken ct) {\n        var order = _orders First(o => o OrderId == @event OrderId);\n        order Status = \"Shipped\";\n        return Task CompletedTask;\n    }\n    // Query method (not a subscription)\n    public IEnumerable<OrderSummary> GetOrders() => _orders;\n}\npublic record OrderSummary(Guid OrderId, Guid CustomerId, decimal Total, string Status) {\n    public string Status { get; set; } = Status;\n}\n`\nProjection Registration Approaches:\nWhizbang supports two ways to register projections:\nAttribute-Based (Recommended for AOT): Decorate projection classes with [WhizbangProjection] and mark event handler parameters with [WhizbangSubscribe] `csharp\n   [WhizbangProjection]  // Can be on class, base class, or interface\n   public class OrderHistoryProjection {\n       public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) {\n           // Handle event\n       }\n   }\n   // Registration\n   proj RegisterGeneratedProjections();\n   `\nManual Registration: Explicitly register each projection `csharp\n   proj RegisterProjection<OrderHistoryProjection>();\n   proj",
        "startIndex": 10186,
        "preview": "// Stage 1: Imports using Microsoft Extensions DependencyInjection; using Microsoft Extensions Hosting; using Whizbang; // Stage 2: Host builder setup..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/package-structure-chunk-6",
        "text": "and mark event handler parameters with [WhizbangSubscribe] `csharp [WhizbangProjection] // Can be on class, base class, or interface public class OrderHistoryProjection { public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) { // Handle event } } // Registration proj RegisterGeneratedProjections(); ` Manual Registration: Explicitly register each projection `csharp proj RegisterProjection<OrderHistoryProjection>(); proj RegisterProjection<CustomerSummaryProjection>();\n   `\nEvent Subscription with [WhizbangSubscribe] Attribute:\nPlace [WhizbangSubscribe] directly on the method parameter representing the event\nOnly one parameter per method can have [WhizbangSubscribe]\nAdditional parameters (like CancellationToken, injected services, EventContext, ProjectionContext) are allowed\nMethod names are flexible: Use Handle, On, When, or any descriptive name you prefer\nAuto-registration: The source generator automatically wires subscriptions to service configuration\nThe source generator validates subscription rules at compile time\nSupports polymorphism: Subscribe to base classes or interfaces to handle multiple event types\nFor complete projection documentation, see:\nProjection Subscriptions - Event subscription patterns, polymorphism, generics, flexible method naming\nProjection Contexts - EventContext and ProjectionContext injection for metadata and CRUD operations\nProjection Purity - Maintaining pure, deterministic projections with compile-time enforcement\nProjection Return Values - Using return values for observability and metrics\nFor command handling documentation, see:\nCommand Handling - Business logic, CommandContext, event emission, sagas, and workflows\nWhizbang Messaging\nDistributed messaging and outbox/inbox patterns `bash{\ntitle: \"Install Whizbang Messaging Package\"\ndescription: \"Add distributed messaging and outbox/inbox patterns for microservices\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Messaging\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang Messaging\n`\nIncludes:\nMessage broker abstraction\nOutbox/Inbox pattern for exactly-once delivery\nDomain ownership routing\nSaga coordination\nRequires a message broker adapter (see below)\nUse when:\nBuilding microservices\nYou need distributed messaging\nCommands/events cross service boundaries\nExample:\n`csharp{\ntitle: \"Distributed Messaging Setup - Complete Program",
        "startIndex": 12404,
        "preview": "and mark event handler parameters with [WhizbangSubscribe] `csharp [WhizbangProjection] // Can be on class, base class, or interface public class Orde..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/package-structure-chunk-7",
        "text": "false } dotnet add package Whizbang Messaging ` Includes: Message broker abstraction Outbox/Inbox pattern for exactly-once delivery Domain ownership routing Saga coordination Requires a message broker adapter (see below) Use when: Building microservices You need distributed messaging Commands/events cross service boundaries Example: `csharp{ title: \"Distributed Messaging Setup - Complete Program cs\"\ndescription: \"Complete example configuring Whizbang for microservices with message broker\"\nframework: \"NET8\"\ncategory: \"Distributed Systems\"\ndifficulty: \"ADVANCED\"\ntags: [\"Messaging\", \"Microservices\", \"Distributed Systems\", \"Program cs\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Messaging\", \"Whizbang Kafka\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Microsoft Extensions Hosting\", \"Whizbang\"]\nshowLineNumbers: true\ncollapsedLines: [1-3, 7-8, 36-38]\n}\n// Stage 1: Imports\nusing Microsoft Extensions DependencyInjection;\nusing Microsoft Extensions Hosting;\nusing Whizbang;\n// Stage 2: Host builder setup\nvar builder = Host CreateApplicationBuilder(args);\n// Stage 3: Register Whizbang with distributed messaging\nbuilder Services AddWhizbang(options => {\n    options RegisterGeneratedHandlers();\n    options UseEventSourcing(es => es UseInMemoryStore());\n    // Stage 4: Enable distributed messaging\n    options UseMessaging(msg => {\n        // Register logical domain ownership (no URLs - services communicate via broker)\n        msg UseDomainOwnership(domains => {\n            // Declare which domains THIS service owns\n            domains RegisterDomain(\"Orders\");    // This service owns Orders domain\n            domains RegisterDomain(\"Payments\");  // This service owns Payments domain\n            // Other domains owned by other services:\n            // - \"Inventory\" owned by Inventory service\n            // - \"Shipping\" owned by Shipping service\n        });\n        // Configure message broker (how services actually communicate)\n        msg UseKafka(kafka => {\n            kafka BootstrapServers = \"localhost:9092\";\n            // Topic routing based on domain ownership\n            kafka CommandTopicPattern = \"commands {domain}\";  // commands Orders, commands Inventory\n            kafka EventTopicPattern = \"events {domain}\";      // events Orders, events Payments\n        });\n        // Enable exactly-once semantics\n        msg UseOutbox();  // Reliable message publishing (transactional)\n        msg UseInbox();   // Idempotent message consumption (deduplication)\n    });\n});\n// Stage 5: Build and run\nvar app = builder Build();\nawait app",
        "startIndex": 14411,
        "preview": "false } dotnet add package Whizbang Messaging ` Includes: Message broker abstraction Outbox/Inbox pattern for exactly-once delivery Domain ownership r..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/package-structure-chunk-8",
        "text": "{domain}\"; // commands Orders, commands Inventory kafka EventTopicPattern = \"events {domain}\"; // events Orders, events Payments }); // Enable exactly-once semantics msg UseOutbox(); // Reliable message publishing (transactional) msg UseInbox(); // Idempotent message consumption (deduplication) }); }); // Stage 5: Build and run var app = builder Build(); await app RunAsync();\n`\nDomain Ownership Explained:\nDomain ownership is logical, not physical Services declare which domains they own, and Whizbang routes messages based on ownership:\nCommands are sent TO the domain owner\nEvents are published BY the domain owner\nServices communicate via message broker (not HTTP endpoints)\nExample Message Flow:\n`csharp\n// Inventory service sends PlaceOrder command\n// → Whizbang routes to Kafka topic \"commands Orders\"\n// → Orders service (domain owner) receives and handles it\nawait whizbang Send(new PlaceOrder( ));\n// Orders service publishes OrderPlaced event\n// → Whizbang publishes to Kafka topic \"events Orders\"\n// → All interested services (Inventory, Shipping, etc ) receive it\nawait whizbang Publish(new OrderPlaced( ));\n`\nRouting Configuration:\nThe message broker adapter handles physical routing Different deployment scenarios use different configurations:\nIn-Process (Monolith): All domains in one service, in-memory routing\nMicroservices (Kafka): Domains in separate services, Kafka topics\nKubernetes (RabbitMQ): Pods communicate via RabbitMQ exchanges\nHybrid: Some domains in-process, others distributed\nThe domain registration stays the same—only the message broker adapter configuration changes ---\nORM Integrations\nWhizbang uses ORMs (not custom database drivers) for persistence, allowing you to leverage existing tools and database compatibility Whizbang EntityFramework\nEntity Framework Core integration for event store and projections `bash{\ntitle: \"Install Whizbang EntityFramework Package\"\ndescription: \"Add Entity Framework Core integration for event store and projections\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Entity Framework\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang",
        "startIndex": 16592,
        "preview": "{domain}\"; // commands Orders, commands Inventory kafka EventTopicPattern = \"events {domain}\"; // events Orders, events Payments }); // Enable exactly..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/package-structure-chunk-9",
        "text": "compatibility Whizbang EntityFramework Entity Framework Core integration for event store and projections `bash{ title: \"Install Whizbang EntityFramework Package\" description: \"Add Entity Framework Core integration for event store and projections\" framework: \"NET8\" category: \"Getting Started\" difficulty: \"INTERMEDIATE\" tags: [\"Getting Started\", \"Packages\", \"Installation\", \"Entity Framework\"] showLineNumbers: false } dotnet add package Whizbang EntityFramework\n`\nFeatures:\nWorks with ANY EF Core database provider (Postgres, SQL Server, MySQL, SQLite, Cosmos DB, etc )\nAutomatic migrations for event store schema\nDbContext integration for projections\nChange tracking for optimistic concurrency\nFull LINQ query support for projections\nShadow properties for metadata\nUse when:\nYou're already using Entity Framework Core\nYou want automatic migrations and schema management\nYou need complex LINQ queries in projections\nYou prefer convention-over-configuration\nExample with Postgres:\n`csharp{\ntitle: \"Entity Framework with Postgres\"\ndescription: \"Using EF Core with Postgres for event store and projections\"\nframework: \"NET8\"\ncategory: \"Persistence\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Entity Framework\", \"Postgres\", \"Event Store\", \"ORM\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang EntityFramework\", \"Npgsql EntityFrameworkCore PostgreSQL\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseEntityFramework(ef => {\n            // Use any EF Core database provider\n            ef UseNpgsql(\"Host=localhost;Database=myapp;Username=user;Password=pass\");\n            // Optional: customize event store schema\n            ef EventStoreSchema = \"events\";\n            ef EnableSensitiveDataLogging = false;\n        });\n    });\n});\n`\nExample with SQL Server:\n`csharp{\ntitle: \"Entity Framework with SQL Server\"\ndescription: \"Using EF Core with SQL Server for event store\"\nframework: \"NET8\"\ncategory: \"Persistence\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Entity Framework\", \"SQL Server\", \"Event Store\", \"ORM\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang EntityFramework\", \"Microsoft EntityFrameworkCore SqlServer\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseEntityFramework(ef => {\n            ef",
        "startIndex": 18425,
        "preview": "compatibility Whizbang EntityFramework Entity Framework Core integration for event store and projections `bash{ title: \"Install Whizbang EntityFramewo..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/package-structure-chunk-10",
        "text": "tags: [\"Entity Framework\", \"SQL Server\", \"Event Store\", \"ORM\"] nugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang EntityFramework\", \"Microsoft EntityFrameworkCore SqlServer\"] usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"] showLineNumbers: true } using Microsoft Extensions DependencyInjection; using Whizbang; var services = new ServiceCollection(); services AddWhizbang(options => { options UseEventSourcing(es => { es UseEntityFramework(ef => { ef UseSqlServer(\"Server=localhost;Database=myapp;Trusted_Connection=True;\");\n        });\n    });\n});\n`\n---\nWhizbang Dapper\nDapper integration for high-performance event store and projections `bash{\ntitle: \"Install Whizbang Dapper Package\"\ndescription: \"Add high-performance Dapper integration for event store and projections\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Dapper\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang Dapper\n`\nFeatures:\nWorks with ANY ADO NET database provider (Postgres, SQL Server, MySQL, SQLite, Oracle, etc )\nMinimal overhead - nearly raw SQL performance\nExplicit control over SQL queries\nBulk insert optimizations for event batches\nCustom type handlers for domain types\nMulti-database support in single application\nUse when:\nPerformance is critical\nYou want explicit control over SQL\nYou're comfortable writing queries\nYou need the absolute fastest event sourcing\nYou're using multiple database types\nExample with Postgres:\n`csharp{\ntitle: \"Dapper with Postgres\"\ndescription: \"Using Dapper with Postgres for high-performance event store\"\nframework: \"NET8\"\ncategory: \"Persistence\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Dapper\", \"Postgres\", \"Event Store\", \"Performance\", \"ORM\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Dapper\", \"Npgsql\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseDapper(dapper => {\n            dapper UseNpgsql(\"Host=localhost;Database=myapp;Username=user;Password=pass\");\n            // Optional: customize SQL queries for specific database optimizations\n            dapper UseJsonBinaryFormat = true;  // Postgres JSONB\n            dapper",
        "startIndex": 20688,
        "preview": "tags: [\"Entity Framework\", \"SQL Server\", \"Event Store\", \"ORM\"] nugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang EntityFramework\", ..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/package-structure-chunk-11",
        "text": "usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"] showLineNumbers: true } using Microsoft Extensions DependencyInjection; using Whizbang; var services = new ServiceCollection(); services AddWhizbang(options => { options UseEventSourcing(es => { es UseDapper(dapper => { dapper UseNpgsql(\"Host=localhost;Database=myapp;Username=user;Password=pass\"); // Optional: customize SQL queries for specific database optimizations dapper UseJsonBinaryFormat = true; // Postgres JSONB dapper BatchSize = 1000;            // Bulk insert optimization\n        });\n    });\n});\n`\nExample with SQL Server:\n`csharp{\ntitle: \"Dapper with SQL Server\"\ndescription: \"Using Dapper with SQL Server for event store\"\nframework: \"NET8\"\ncategory: \"Persistence\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Dapper\", \"SQL Server\", \"Event Store\", \"Performance\", \"ORM\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Dapper\", \"Microsoft Data SqlClient\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseDapper(dapper => {\n            dapper UseSqlServer(\"Server=localhost;Database=myapp;Trusted_Connection=True;\");\n            // SQL Server optimizations\n            dapper UseMemoryOptimizedTables = true;\n            dapper EnableChangeTracking = true;\n        });\n    });\n});\n`\n---\nWhizbang NHibernate\nNHibernate integration for event store and projections `bash{\ntitle: \"Install Whizbang NHibernate Package\"\ndescription: \"Add NHibernate integration for event store and projections\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"NHibernate\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang NHibernate\n`\nFeatures:\nWorks with ANY NHibernate-supported database (Postgres, SQL Server, MySQL, Oracle, SQLite, etc )\nMature ORM with extensive database support\nXML or fluent mapping configuration\nAdvanced caching strategies (first-level, second-level, query cache)\nLazy loading and eager fetching strategies\nSupports legacy database schemas\nUse when:\nYou're already using NHibernate\nYou need advanced caching strategies\nYou're working with legacy database schemas\nYou require complex mapping scenarios\nYou want mature, battle-tested ORM\nExample with Postgres:\n`csharp{\ntitle: \"NHibernate with Postgres\"\ndescription: \"Using NHibernate with Postgres for event store\"\nframework: \"NET8\"\ncategory: \"Persistence\"\ndifficulty: \"ADVANCED\"\ntags: [\"NHibernate\", \"Postgres\", \"Event Store\", \"ORM\"]\nnugetPackages: [\"Whizbang",
        "startIndex": 22632,
        "preview": "usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"] showLineNumbers: true } using Microsoft Extensions DependencyInjection; usin..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/package-structure-chunk-12",
        "text": "need advanced caching strategies You're working with legacy database schemas You require complex mapping scenarios You want mature, battle-tested ORM Example with Postgres: `csharp{ title: \"NHibernate with Postgres\" description: \"Using NHibernate with Postgres for event store\" framework: \"NET8\" category: \"Persistence\" difficulty: \"ADVANCED\" tags: [\"NHibernate\", \"Postgres\", \"Event Store\", \"ORM\"] nugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang NHibernate\", \"NHibernate\", \"NHibernate Driver NpgsqlDriver\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\", \"NHibernate Cfg\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing NHibernate Cfg;\nusing Whizbang;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseNHibernate(nh => {\n            nh ConfigureWith(cfg => {\n                cfg DataBaseIntegration(db => {\n                    db ConnectionString = \"Host=localhost;Database=myapp;Username=user;Password=pass\";\n                    db Driver<NpgsqlDriver>();\n                    db Dialect<PostgreSQLDialect>();\n                });\n                // Optional: enable second-level cache\n                cfg Cache(c => {\n                    c UseSecondLevelCache = true;\n                    c UseQueryCache = true;\n                });\n            });\n        });\n    });\n});\n`\n---\nChoosing an ORM\nEntity Framework - Best for:\nGeneral-purpose applications\nAutomatic migrations\nConvention-over-configuration\nComplex LINQ queries\nMost NET developers (familiar)\nDapper - Best for:\nHigh-performance scenarios\nExplicit SQL control\nMinimal overhead\nLarge event volumes\nPolyglot persistence (multiple databases)\nNHibernate - Best for:\nLegacy database integration\nAdvanced caching requirements\nComplex mapping scenarios\nEnterprise applications with existing NHibernate usage\n---\nMessage Broker Adapters\nWhizbang Kafka\nApache Kafka adapter for distributed messaging `bash{\ntitle: \"Install Whizbang Kafka Package\"\ndescription: \"Add Apache Kafka adapter for distributed messaging\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Kafka\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang Kafka\n`\nFeatures:\nHigh throughput\nPartition-aware consumers\nCompacted topics for snapshots\nExactly-once semantics\nUse when:\nBuilding event-driven microservices at scale\nYou need event replay and time-travel capabilities\n---\nWhizbang RabbitMQ\nRabbitMQ adapter for distributed messaging `bash{\ntitle: \"Install Whizbang",
        "startIndex": 7489,
        "preview": "need advanced caching strategies You're working with legacy database schemas You require complex mapping scenarios You want mature, battle-tested ORM ..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/package-structure-chunk-13",
        "text": "Started\", \"Packages\", \"Installation\", \"Kafka\"] showLineNumbers: false } dotnet add package Whizbang Kafka ` Features: High throughput Partition-aware consumers Compacted topics for snapshots Exactly-once semantics Use when: Building event-driven microservices at scale You need event replay and time-travel capabilities --- Whizbang RabbitMQ RabbitMQ adapter for distributed messaging `bash{ title: \"Install Whizbang RabbitMQ Package\"\ndescription: \"Add RabbitMQ adapter for distributed messaging\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"RabbitMQ\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang RabbitMQ\n`\nFeatures:\nFlexible routing\nPriority queues\nDead-letter exchanges\nPublisher confirms\n---\nWhizbang AzureServiceBus\nAzure Service Bus adapter `bash{\ntitle: \"Install Whizbang AzureServiceBus Package\"\ndescription: \"Add Azure Service Bus adapter for distributed messaging\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Azure Service Bus\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang AzureServiceBus\n`\nFeatures:\nManaged service (no infrastructure)\nSessions for ordered processing\nDuplicate detection\nIntegration with Azure ecosystem\n---\nWhizbang AWSSQS\nAWS SQS/SNS adapter `bash{\ntitle: \"Install Whizbang AWSSQS Package\"\ndescription: \"Add AWS SQS/SNS adapter for distributed messaging\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"AWS SQS\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang AWSSQS\n`\nFeatures:\nManaged service\nFIFO queues for ordering\nIntegration with AWS ecosystem\n---\nObservability Packages\nWhizbang OpenTelemetry\nOpenTelemetry integration `bash{\ntitle: \"Install Whizbang OpenTelemetry Package\"\ndescription: \"Add OpenTelemetry integration for tracing and metrics\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"OpenTelemetry\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang OpenTelemetry\n`\nIncludes:\nAutomatic tracing for all messages\nMetrics for throughput, latency, errors\nDistributed context propagation\n---\nWhizbang Dashboard\nWeb-based monitoring dashboard `bash{\ntitle: \"Install Whizbang",
        "startIndex": 27059,
        "preview": "Started\", \"Packages\", \"Installation\", \"Kafka\"] showLineNumbers: false } dotnet add package Whizbang Kafka ` Features: High throughput Partition-aware ..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/package-structure-chunk-14",
        "text": "for tracing and metrics\" framework: \"NET8\" category: \"Getting Started\" difficulty: \"INTERMEDIATE\" tags: [\"Getting Started\", \"Packages\", \"Installation\", \"OpenTelemetry\"] showLineNumbers: false } dotnet add package Whizbang OpenTelemetry ` Includes: Automatic tracing for all messages Metrics for throughput, latency, errors Distributed context propagation --- Whizbang Dashboard Web-based monitoring dashboard `bash{ title: \"Install Whizbang Dashboard Package\"\ndescription: \"Add web-based monitoring dashboard for Whizbang applications\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Dashboard\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang Dashboard\n`\nFeatures:\nLive message flow visualization\nProjection lag monitoring\nError tracking\nPerformance metrics\n---\nDeveloper Packages\nWhizbang Analyzers\nRoslyn analyzers for compile-time validation `bash{\ntitle: \"Install Whizbang Analyzers Package\"\ndescription: \"Add Roslyn analyzers for compile-time validation and purity checks\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Analyzers\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang Analyzers\n`\nIncludes:\nProjection Purity Checks: Enforce pure functions in projections\nNo field/property mutations outside method scope\nNo I/O operations (file system, network, database writes)\nNo static mutation\nNo logging or side effects in projection handlers\nHandler Validation: Enforce [Pure] attribute on command/query handlers\nDomain Ownership: Detect missing domain ownership attributes\nNaming Conventions: Validate event and command naming conventions\nAsync Patterns: Check for synchronous I/O in async handlers\nSubscription Rules: Validate [WhizbangSubscribe] usage (one per method, etc )\nSecurity Context: Warn when security-sensitive operations lack tenant/user validation\nPurity Enforcement Example:\n`csharp\n[WhizbangProjection]\npublic class OrderProjection {\n    private readonly ILogger _logger;  // ⚠️ Warning: Injected services should be read-only\n    // ✅ VALID - Pure projection handler\n    public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) {\n        // Pure state updates only\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - Side effect detected (logging)\n    public Task Handle([WhizbangSubscribe] OrderShipped @event, CancellationToken ct) {\n        _logger",
        "startIndex": 29002,
        "preview": "for tracing and metrics\" framework: \"NET8\" category: \"Getting Started\" difficulty: \"INTERMEDIATE\" tags: [\"Getting Started\", \"Packages\", \"Installation\"..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/package-structure-chunk-15",
        "text": "_logger; // ⚠️ Warning: Injected services should be read-only // ✅ VALID - Pure projection handler public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) { // Pure state updates only return Task CompletedTask; } // ❌ ERROR - Side effect detected (logging) public Task Handle([WhizbangSubscribe] OrderShipped @event, CancellationToken ct) { _logger LogInformation(\"Order shipped\");  // 💥 Compile error: Side effect in projection\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - I/O operation detected\n    public async Task Handle([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) {\n        await File WriteAllTextAsync(\"log txt\", \"cancelled\");  // 💥 Compile error: I/O in projection\n    }\n}\n`\n---\nWhizbang Testing\nTesting utilities and in-memory doubles `bash{\ntitle: \"Install Whizbang Testing Package\"\ndescription: \"Add testing utilities and in-memory doubles for development\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Testing\"]\nshowLineNumbers: false\n}\ndotnet add package Whizbang Testing\n`\nIncludes:\nIn-memory event store\nFake message bus\nProjection test helpers\nAggregate test fixtures\n---\nCustomizable Attributes\nWhizbang uses attributes for source generator discovery ([WhizbangHandler], [WhizbangProjection], [WhizbangSubscribe]), and these attributes are customizable to fit your team's preferences or naming conventions Why the Whizbang prefix All attributes use consistent Whizbang prefix to:\nAvoid naming collisions with other frameworks (e g , generic [Handler] attribute)\nProvide clear visual indication of framework-specific attributes\nEnable easy searching across codebase (grep \"WhizbangHandler\")\nMaintain consistent naming convention\nUsing Custom Attribute Names\nYou can configure Whizbang to recognize alternate attribute names:\n`csharp{\ntitle: \"Custom Attribute Names Configuration\"\ndescription: \"Configure Whizbang to use custom attribute names\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Attributes\", \"Source Generator\", \"Configuration\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"]\nshowLineNumbers: true\n}\nusing Microsoft Extensions DependencyInjection;\nusing Whizbang;\nvar builder = Host CreateApplicationBuilder(args);\nbuilder Services AddWhizbang(options => {\n    // Configure custom attribute names\n    options",
        "startIndex": 31039,
        "preview": "_logger; // ⚠️ Warning: Injected services should be read-only // ✅ VALID - Pure projection handler public Task Handle([WhizbangSubscribe] OrderPlaced ..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/package-structure-chunk-16",
        "text": "Whizbang to use custom attribute names\" framework: \"NET8\" category: \"Configuration\" difficulty: \"ADVANCED\" tags: [\"Attributes\", \"Source Generator\", \"Configuration\"] nugetPackages: [\"Whizbang Core\"] usingStatements: [\"Microsoft Extensions DependencyInjection\", \"Whizbang\"] showLineNumbers: true } using Microsoft Extensions DependencyInjection; using Whizbang; var builder = Host CreateApplicationBuilder(args); builder Services AddWhizbang(options => { // Configure custom attribute names options Attributes(attr => {\n        // Use your own handler attribute name\n        attr HandlerAttribute = \"MyCompany CommandHandlerAttribute\";\n        // Use your own projection attribute name\n        attr ProjectionAttribute = \"MyCompany ProjectionAttribute\";\n        // Use your own subscription attribute name\n        attr SubscribeAttribute = \"MyCompany EventSubscriptionAttribute\";\n    });\n    options RegisterGeneratedHandlers();\n    options UseProjections(proj => proj RegisterGeneratedProjections());\n});\n`\nSource-Generated Attributes (Future)\nIn future versions, Whizbang may provide source-generated attributes that are automatically created in your project:\n`csharp\n// Auto-generated by Whizbang source generator\nnamespace MyCompany;\n[AttributeUsage(AttributeTargets Class | AttributeTargets Interface)]\npublic class CommandHandlerAttribute : Attribute { }\n[AttributeUsage(AttributeTargets Class | AttributeTargets Interface)]\npublic class ProjectionAttribute : Attribute { }\n[AttributeUsage(AttributeTargets Parameter)]\npublic class EventSubscriptionAttribute : Attribute { }\n`\nBenefits:\nNo dependency on Whizbang Core in your domain layer\nYour own namespace and naming conventions\nStill compatible with Whizbang's source generator\nEnables clean architecture (domain doesn't reference framework)\nWhy Customizable Attributes Team Conventions: Match your existing attribute naming patterns\nClean Architecture: Keep framework attributes out of domain layer\nLegacy Integration: Reuse existing attributes from other frameworks\nMulti-Framework: Use same attributes with multiple frameworks\n---\nPackage Decision Tree\n`\nDo you need event sourcing ├─ NO → Whizbang Core (mediator only)\n└─ YES → Whizbang Core + Whizbang EventSourcing\n          └─ Choose an ORM integration:\n              ├─ Whizbang EntityFramework (recommended for most)\n              ├─ Whizbang Dapper (high performance)\n              └─ Whizbang NHibernate (enterprise/legacy)\nDo you need read models └─ YES → Add Whizbang Projections\nAre you building microservices └─ YES → Add Whizbang Messaging\n          └─ Choose a message broker adapter:\n              ├─ Whizbang",
        "startIndex": 33136,
        "preview": "Whizbang to use custom attribute names\" framework: \"NET8\" category: \"Configuration\" difficulty: \"ADVANCED\" tags: [\"Attributes\", \"Source Generator\", \"C..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/package-structure-chunk-17",
        "text": "EventSourcing └─ Choose an ORM integration: ├─ Whizbang EntityFramework (recommended for most) ├─ Whizbang Dapper (high performance) └─ Whizbang NHibernate (enterprise/legacy) Do you need read models └─ YES → Add Whizbang Projections Are you building microservices └─ YES → Add Whizbang Messaging └─ Choose a message broker adapter: ├─ Whizbang Kafka\n              ├─ Whizbang RabbitMQ\n              ├─ Whizbang AzureServiceBus\n              └─ Whizbang AWSSQS\nDo you need observability └─ YES → Add Whizbang OpenTelemetry or Whizbang Dashboard\nAre you developing/testing └─ YES → Add Whizbang Testing and Whizbang Analyzers\n`\n---\nTypical Configurations\nSimple Monolith\n`bash{\ntitle: \"Simple Monolith Package Installation\"\ndescription: \"Install packages for a simple monolithic application with event sourcing\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"BEGINNER\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Monolith\"]\nshowLineNumbers: true\n}\ndotnet add package Whizbang Core\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang EntityFramework\ndotnet add package Npgsql EntityFrameworkCore PostgreSQL\n`\n---\nMonolith with Read Models\n`bash{\ntitle: \"Monolith with Read Models Package Installation\"\ndescription: \"Install packages for a monolith with event sourcing and read model projections\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Monolith\", \"CQRS\"]\nshowLineNumbers: true\n}\ndotnet add package Whizbang Core\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang Projections\ndotnet add package Whizbang EntityFramework\ndotnet add package Npgsql EntityFrameworkCore PostgreSQL\n`\n---\nHigh-Performance Monolith\n`bash{\ntitle: \"High-Performance Monolith Package Installation\"\ndescription: \"Install packages for a high-performance monolith using Dapper for optimal speed\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Performance\", \"Dapper\"]\nshowLineNumbers: true\n}\ndotnet add package Whizbang Core\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang Projections\ndotnet add package Whizbang",
        "startIndex": 35278,
        "preview": "EventSourcing └─ Choose an ORM integration: ├─ Whizbang EntityFramework (recommended for most) ├─ Whizbang Dapper (high performance) └─ Whizbang NHibe..."
      },
      {
        "id": "old-v1.0.0.0/getting-started/package-structure-chunk-18",
        "text": "Package Installation\" description: \"Install packages for a high-performance monolith using Dapper for optimal speed\" framework: \"NET8\" category: \"Getting Started\" difficulty: \"ADVANCED\" tags: [\"Getting Started\", \"Packages\", \"Installation\", \"Performance\", \"Dapper\"] showLineNumbers: true } dotnet add package Whizbang Core dotnet add package Whizbang EventSourcing dotnet add package Whizbang Projections dotnet add package Whizbang Dapper\ndotnet add package Npgsql\n`\n---\nMicroservices with Kafka\n`bash{\ntitle: \"Microservices with Kafka Package Installation\"\ndescription: \"Install packages for microservices architecture with Kafka messaging and observability\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Microservices\", \"Kafka\"]\nshowLineNumbers: true\n}\ndotnet add package Whizbang Core\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang Projections\ndotnet add package Whizbang Messaging\ndotnet add package Whizbang EntityFramework\ndotnet add package Npgsql EntityFrameworkCore PostgreSQL\ndotnet add package Whizbang Kafka\ndotnet add package Whizbang OpenTelemetry\n`\n---\nEnterprise with SQL Server\n`bash{\ntitle: \"Enterprise with SQL Server Package Installation\"\ndescription: \"Install packages for enterprise applications using NHibernate and SQL Server\"\nframework: \"NET8\"\ncategory: \"Getting Started\"\ndifficulty: \"ADVANCED\"\ntags: [\"Getting Started\", \"Packages\", \"Installation\", \"Enterprise\", \"SQL Server\"]\nshowLineNumbers: true\n}\ndotnet add package Whizbang Core\ndotnet add package Whizbang EventSourcing\ndotnet add package Whizbang Projections\ndotnet add package Whizbang NHibernate\ndotnet add package NHibernate\ndotnet add package NHibernate Driver MicrosoftDataSqlClientDriver\n`\n---\nNext Steps\nGetting Started - Build your first Whizbang application\nPhilosophy - Understand Whizbang's design principles and architectural philosophy\nCore Concepts - Deep dive into commands, events, projections, and aggregates\nDriver System - Learn how to implement custom drivers\nTesting - Test your event-sourced applications",
        "startIndex": 37162,
        "preview": "Package Installation\" description: \"Install packages for a high-performance monolith using Dapper for optimal speed\" framework: \"NET8\" category: \"Gett..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/observability/dashboard",
    "title": "Whizbang Dashboard",
    "category": "Observability",
    "url": "/docs/old-v1.0.0.0/observability/dashboard",
    "chunks": [
      {
        "id": "old-v1.0.0.0/observability/dashboard-chunk-0",
        "text": "Whizbang Dashboard\nThe Whizbang Dashboard is a separate web application (package: Whizbang Dashboard) that provides real-time visualization of your event-sourced, message-driven system Overview\nThe dashboard offers:\nMessage Journey Visualization - See the complete lifecycle of commands and events\nDistributed Tracing - Track messages across microservices\nProjection Health - Monitor projection lag and errors\nEvent Stream Explorer - Browse aggregate event streams\nPerformance Metrics - Throughput, latency, error rates\nControl Plane - Send control commands to services\nInstallation\nNuGet Package\n`bash\n---\ncategory: Observability\ndifficulty: BEGINNER\ntags: [Installation, NuGet, Dashboard, Package-Management]\ndescription: Install Whizbang Dashboard NuGet package\n---\ndotnet add package Whizbang Dashboard\n`\nStandalone Dashboard Application\nOr run as a separate service:\n`bash\n---\ncategory: Observability\ndifficulty: BEGINNER\ntags: [Global-Tool, Dashboard, Standalone, CLI]\ndescription: Install and run dashboard as standalone global tool\n---\ndotnet tool install --global Whizbang Dashboard\nwhizbang-dashboard --port 5050\n`\nEmbedded in Application\nAdd to your ASP NET Core application:\n`csharp\n---\ncategory: Observability\ndifficulty: BEGINNER\ntags: [Dashboard, Setup, ASP NET-Core, Configuration]\ndescription: Embed dashboard in existing ASP NET Core application\n---\nusing Microsoft AspNetCore Builder;\nusing Whizbang Dashboard;\nvar builder = WebApplication CreateBuilder(args);\n// Add Whizbang Dashboard\nbuilder Services AddWhizbangDashboard(options => {\n    options EnableRealTimeUpdates = true;\n    options RetentionPeriod = TimeSpan FromHours(24);  // Keep traces for 24 hours\n    options RequireAuthentication = true;              // Protect dashboard\n});\nvar app = builder Build();\n// Mount dashboard at /whizbang\napp MapWhizbangDashboard(\"/whizbang\");\napp",
        "startIndex": 0,
        "preview": "Whizbang Dashboard\nThe Whizbang Dashboard is a separate web application (package: Whizbang Dashboard) that provides real-time visualization of your ev..."
      },
      {
        "id": "old-v1.0.0.0/observability/dashboard-chunk-1",
        "text": "var builder = WebApplication CreateBuilder(args); // Add Whizbang Dashboard builder Services AddWhizbangDashboard(options => { options EnableRealTimeUpdates = true; options RetentionPeriod = TimeSpan FromHours(24); // Keep traces for 24 hours options RequireAuthentication = true; // Protect dashboard }); var app = builder Build(); // Mount dashboard at /whizbang app MapWhizbangDashboard(\"/whizbang\"); app Run();\n`\nAccess at: http://localhost:5000/whizbang\nMessage Journey Visualization\nEnd-to-End Flow\nSee the complete journey of a command through your system:\n`\nPlaceOrder (Command)\n  ↓\nOrderCommandHandler\n  ↓\nOrderPlaced (Event)\n  ├─→ OrderHistoryProjection (updated)\n  ├─→ InventoryReservationSaga (triggered)\n  │   ↓\n  │   ReserveInventory (Command) → InventoryService\n  │   ↓\n  │   InventoryReserved (Event)\n  │   ↓\n  │   ProcessPayment (Command) → PaymentService\n  │   ↓\n  │   PaymentProcessed (Event)\n  └─→ CustomerNotificationHandler (email sent)\n`\nDashboard Visualization:\n`\n┌────────────────────────────────────────────────────────────┐\n│  Message Journey: PlaceOrder                               │\n├────────────────────────────────────────────────────────────┤\n│                                                             │\n│  [PlaceOrder] ──→ [OrderHandler] ──→ [OrderPlaced]         │\n│      ↓ 42ms          ↓ 120ms           ↓                   │\n│      │               │                 ├─→ [OrderHistory]  │\n│      │               │                 │    ↓ 15ms         │\n│      │               │                 │                   │\n│      │               │                 ├─→ [ReserveSaga]   │\n│      │               │                 │    ↓ 200ms        │\n│      │               │                 │    └─→ [Inventory]│\n│      │               │                 │         ↓ 350ms   │\n│      │               │                 │         └─→ [Pay] │\n│      │               │                 │              ↓    │\n│      │               │                 └─→ [Notify] ✓      │\n│                                                             │\n│  Total Duration: 727ms                                      │\n│  Status: ✓ Success                                          │\n└────────────────────────────────────────────────────────────┘\n`\nInteractive Trace Explorer\nClick on any message to drill down:\n`\n┌────────────────────────────────────────────────────────────┐\n│  OrderPlaced Event Details                                 │\n├────────────────────────────────────────────────────────────┤\n│  Event ID: evt_01J7G3KZ9P │\n│  Timestamp: 2025-10-18 14:32:15 234 UTC                    │\n│  Correlation ID: cmd_01J7G3KZ8N │\n│  Causation ID: cmd_01J7G3KZ8N │\n│                                                             │\n│  Payload:                                                   │\n│  {                                                          │\n│    \"orderId\": \"ord_123\",                                    │\n│    \"customerId\": \"cust_456\",                                │\n│    \"total\": 99 99,                                          │\n│    \"items\": [ /",
        "startIndex": 1865,
        "preview": "var builder = WebApplication CreateBuilder(args); // Add Whizbang Dashboard builder Services AddWhizbangDashboard(options => { options EnableRealTimeU..."
      },
      {
        "id": "old-v1.0.0.0/observability/dashboard-chunk-2",
        "text": "Details │ ├────────────────────────────────────────────────────────────┤ │ Event ID: evt_01J7G3KZ9P │ │ Timestamp: 2025-10-18 14:32:15 234 UTC │ │ Correlation ID: cmd_01J7G3KZ8N │ │ Causation ID: cmd_01J7G3KZ8N │ │ │ │ Payload: │ │ { │ │ \"orderId\": \"ord_123\", │ │ \"customerId\": \"cust_456\", │ │ \"total\": 99 99, │ │ \"items\": [ / / ]                                   │\n│  }                                                          │\n│                                                             │\n│  Metadata:                                                  │\n│  - Tenant: acme-corp                                        │\n│  - User: john doe@acme com                                  │\n│  - Source: orders-service-pod-3                             │\n│  - Trace ID: 4bf92f3577b34da6a3ce929d0e0e4736              │\n│                                                             │\n│  Subscribers (3):                                           │\n│  ✓ OrderHistoryProjection (15ms)                           │\n│  ✓ InventoryReservationSaga (200ms)                        │\n│  ✓ CustomerNotificationHandler (42ms)                      │\n└────────────────────────────────────────────────────────────┘\n`\nDistributed Tracing\nCross-Service Traces\nVisualize messages flowing across microservices:\n`\nAPI Gateway         Orders Service      Inventory Service    Payment Service\n    │                     │                     │                   │\n    ├─ PlaceOrder ──────→ │                     │                   │\n    │                     ├─ OrderPlaced ──────→│                   │\n    │                     │                     ├─ ReserveInventory │\n    │                     │                     │                   │\n    │                     │ ←── InventoryReserved                   │\n    │                     ├─ ProcessPayment ────────────────────→  │\n    │                     │                     │                   │\n    │                     │ ←─────────────────── PaymentProcessed ─┤\n    │ ←── OrderConfirmed ─┤                     │                   │\n    │                     │                     │                   │\n`\nOpenTelemetry Integration:\nThe dashboard integrates with OpenTelemetry traces:\n`csharp\n---\ncategory: Observability\ndifficulty: INTERMEDIATE\ntags: [OpenTelemetry, Tracing, Dashboard, Integration, Jaeger, Zipkin]\ndescription: Dashboard integration with OpenTelemetry, Jaeger, and Zipkin\n---\nusing Whizbang Dashboard;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbangDashboard(options => {\n    // Read traces from OpenTelemetry collector\n    options UseOpenTelemetry(otel => {\n        otel Endpoint = \"http://otel-collector:4317\";\n        otel Protocol = OpenTelemetryProtocol Grpc;\n    });\n    // Or from Jaeger\n    options UseJaeger(jaeger => {\n        jaeger Endpoint = \"http://jaeger:16686\";\n    });\n    // Or from Zipkin\n    options UseZipkin(zipkin => {\n        zipkin",
        "startIndex": 4623,
        "preview": "Details │ ├────────────────────────────────────────────────────────────┤ │ Event ID: evt_01J7G3KZ9P │ │ Timestamp: 2025-10-18 14:32:15 234 UTC │ │ Cor..."
      },
      {
        "id": "old-v1.0.0.0/observability/dashboard-chunk-3",
        "text": "using Microsoft Extensions DependencyInjection; services AddWhizbangDashboard(options => { // Read traces from OpenTelemetry collector options UseOpenTelemetry(otel => { otel Endpoint = \"http://otel-collector:4317\"; otel Protocol = OpenTelemetryProtocol Grpc; }); // Or from Jaeger options UseJaeger(jaeger => { jaeger Endpoint = \"http://jaeger:16686\"; }); // Or from Zipkin options UseZipkin(zipkin => { zipkin Endpoint = \"http://zipkin:9411\";\n    });\n});\n`\nTrace Timeline View\nWaterfall chart showing message timing:\n`\nTime ──────────────────────────────────────────────────→\n0ms   100ms  200ms  300ms  400ms  500ms  600ms  700ms\nPlaceOrder\n│────────────│ (120ms)\n             OrderPlaced\n             │──────────────────│ (200ms - saga processing)\n                                ReserveInventory\n                                │──────────────│ (150ms)\n                                               InventoryReserved\n                                               │────────────│ (100ms)\n                                                           ProcessPayment\n                                                           │──────────────│ (150ms)\n                                                                         PaymentProcessed\n                                                                         │─│ (5ms - notification)\n═══════════════════════════════════════════════════════════════════════════\nTotal: 727ms\n`\nProjection Health Monitoring\nProjection Dashboard\nReal-time view of all projections:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Projections                                                      │\n├──────────────────────────────────────────────────────────────────┤\n│                                                                   │\n│  Name                   Status    Lag      Throughput    Errors  │\n│  ────────────────────   ──────    ────     ──────────    ──────  │\n│  OrderHistory           🟢 OK     2ms      450 evt/sec   0       │\n│  CustomerStats          🟢 OK     5ms      320 evt/sec   0       │\n│  InventorySummary       🟡 WARN   2 5s     180 evt/sec   0       │\n│  ProductRecommendations 🔴 ERROR  45s      0 evt/sec     15      │\n│                                                                   │\n│  [Rebuild] [Pause] [Reset Checkpoint]                            │\n└──────────────────────────────────────────────────────────────────┘\n`\nLag Alert: Visual indicator when projection falls behind event stream Projection Details\nDrill into individual projection:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Projection: ProductRecommendations                               │\n├──────────────────────────────────────────────────────────────────┤\n│  Status: 🔴 ERROR                                                 │\n│  Last Processed Event: evt_01J7G3KZ9P",
        "startIndex": 7222,
        "preview": "using Microsoft Extensions DependencyInjection; services AddWhizbangDashboard(options => { // Read traces from OpenTelemetry collector options UseOpen..."
      },
      {
        "id": "old-v1.0.0.0/observability/dashboard-chunk-4",
        "text": "🔴 ERROR 45s 0 evt/sec 15 │ │ │ │ [Rebuild] [Pause] [Reset Checkpoint] │ └──────────────────────────────────────────────────────────────────┘ ` Lag Alert: Visual indicator when projection falls behind event stream Projection Details Drill into individual projection: ` ┌──────────────────────────────────────────────────────────────────┐ │ Projection: ProductRecommendations │ ├──────────────────────────────────────────────────────────────────┤ │ Status: 🔴 ERROR │ │ Last Processed Event: evt_01J7G3KZ9P (45 seconds ago)        │\n│  Current Checkpoint: 123,456                                      │\n│  Latest Event Position: 125,890                                   │\n│  Lag: 2,434 events (~45 seconds)                                  │\n│                                                                   │\n│  Recent Errors (15):                                              │\n│  - NullReferenceException at UpdateRecommendations:42            │\n│  - NullReferenceException at UpdateRecommendations:42            │\n│  - NullReferenceException at UpdateRecommendations:42            │\n│  [View Stack Trace]                                               │\n│                                                                   │\n│  Actions:                                                         │\n│  [Rebuild from Start] [Rebuild from Checkpoint] [Skip Failed]    │\n└──────────────────────────────────────────────────────────────────┘\n`\nActions:\nRebuild: Clear projection and replay all events\nSkip: Skip the failing event and continue\nPause: Stop projection processing\nEvent Stream Explorer\nBrowse aggregate event streams:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Event Stream: Order-ord_123                                      │\n├──────────────────────────────────────────────────────────────────┤\n│                                                                   │\n│  [0] OrderPlaced              2025-10-18 14:32:15 UTC            │\n│      Customer: cust_456       Total: $99 99                       │\n│                                                                   │\n│  [1] OrderItemAdded           2025-10-18 14:33:02 UTC            │\n│      Product: Widget          Quantity: 2                         │\n│                                                                   │\n│  [2] OrderShipped             2025-10-18 14:45:10 UTC            │\n│      Carrier: UPS             Tracking: 1Z999AA10123456789        │\n│                                                                   │\n│  [3] OrderDelivered           2025-10-20 10:15:33 UTC            │\n│      Signature: J",
        "startIndex": 9675,
        "preview": "🔴 ERROR 45s 0 evt/sec 15 │ │ │ │ [Rebuild] [Pause] [Reset Checkpoint] │ └──────────────────────────────────────────────────────────────────┘ ` Lag Al..."
      },
      {
        "id": "old-v1.0.0.0/observability/dashboard-chunk-5",
        "text": "│ │ Customer: cust_456 Total: $99 99 │ │ │ │ [1] OrderItemAdded 2025-10-18 14:33:02 UTC │ │ Product: Widget Quantity: 2 │ │ │ │ [2] OrderShipped 2025-10-18 14:45:10 UTC │ │ Carrier: UPS Tracking: 1Z999AA10123456789 │ │ │ │ [3] OrderDelivered 2025-10-20 10:15:33 UTC │ │ Signature: J Doe        Location: Front door                │\n│                                                                   │\n│  Total Events: 4              Aggregate Version: 3                │\n│                                                                   │\n│  [Replay] [Download JSON] [View Snapshots]                        │\n└──────────────────────────────────────────────────────────────────┘\n`\nFeatures:\nView full event stream for any aggregate\nDownload events as JSON\nReplay events (time-travel debugging)\nView snapshots (if enabled)\nPerformance Metrics\nThroughput Dashboard\nReal-time metrics:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Throughput (Last 5 Minutes)                                      │\n├──────────────────────────────────────────────────────────────────┤\n│                                                                   │\n│  Commands/sec:  ████████████████░░░░  120/sec                    │\n│  Events/sec:    ██████████████████░░  450/sec                    │\n│  Queries/sec:   ████████████░░░░░░░░  80/sec                     │\n│                                                                   │\n│  Avg Latency:                                                     │\n│  - Commands:    42ms   (p50: 35ms, p95: 120ms, p99: 250ms)       │\n│  - Events:      15ms   (p50: 12ms, p95: 45ms, p99: 80ms)         │\n│  - Queries:     8ms    (p50: 5ms, p95: 25ms, p99: 50ms)          │\n│                                                                   │\n│  Error Rate:    0 02%  (3 errors in 15,000 messages)             │\n└──────────────────────────────────────────────────────────────────┘\n`\nService Health\nMonitor individual services:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Services                                                         │\n├──────────────────────────────────────────────────────────────────┤\n│  Name              Status    CPU    Memory   Replicas   Requests │\n│  ──────────────    ──────    ───    ──────   ────────   ──────── │\n│  orders-service    🟢 OK     23%    1 2 GB   3/3        450/sec  │\n│  inventory-service 🟢 OK     45%    800 MB   2/2        320/sec  │\n│  payment-service   🟡 WARN   78%    1",
        "startIndex": 11792,
        "preview": "│ │ Customer: cust_456 Total: $99 99 │ │ │ │ [1] OrderItemAdded 2025-10-18 14:33:02 UTC │ │ Product: Widget Quantity: 2 │ │ │ │ [2] OrderShipped 2025-..."
      },
      {
        "id": "old-v1.0.0.0/observability/dashboard-chunk-6",
        "text": "services: ` ┌──────────────────────────────────────────────────────────────────┐ │ Services │ ├──────────────────────────────────────────────────────────────────┤ │ Name Status CPU Memory Replicas Requests │ │ ────────────── ────── ─── ────── ──────── ──────── │ │ orders-service 🟢 OK 23% 1 2 GB 3/3 450/sec │ │ inventory-service 🟢 OK 45% 800 MB 2/2 320/sec │ │ payment-service 🟡 WARN 78% 1 8 GB   2/2        180/sec  │\n│  shipping-service  🟢 OK     12%    600 MB   1/1        80/sec   │\n└──────────────────────────────────────────────────────────────────┘\n`\nControl Plane UI\nSend Control Commands\nFrom the dashboard UI:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Control Commands                                                 │\n├──────────────────────────────────────────────────────────────────┤\n│                                                                   │\n│  Command: [Rebuild Projection ▼]                                 │\n│                                                                   │\n│  Projection Name: [OrderHistory_____________]                     │\n│  Target Service:  [All Services ▼]                                │\n│  Start From:      [Beginning of Time ▼]                           │\n│                                                                   │\n│  ⚠️  Warning: This will clear and rebuild the projection │\n│      Queries may return incomplete data during rebuild │\n│                                                                   │\n│  [Cancel]  [Execute Command]                                      │\n└──────────────────────────────────────────────────────────────────┘\n`\nAvailable Commands:\nRebuild Projection\nSet Log Level\nClear Caches\nRun Health Check\nToggle Feature Flags\nPause/Resume Message Processing\nCommand History\nTrack what control commands were executed:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Command History                                                  │\n├──────────────────────────────────────────────────────────────────┤\n│  Time                Command                   User      Status  │\n│  ──────────────────  ────────────────────────  ────────  ──────  │\n│  14:52:10 UTC        Rebuild OrderHistory      admin     ✓ Done  │\n│  14:45:33 UTC        Set Log Level=Debug       john doe  ✓ Done  │\n│  14:32:15 UTC        Clear Cache               admin     ✗ Failed│\n│  14:18:02 UTC        Pause Projection          jane doe  ✓ Done  │\n└──────────────────────────────────────────────────────────────────┘\n`\nSearch and Filtering\nSearch Messages\nFind specific messages:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Search Messages                                                  │\n├──────────────────────────────────────────────────────────────────┤\n│  Query: [customer_id:cust_456 AND status:shipped_____________]   │\n│  Time Range: [Last 24 Hours ▼]                                   │\n│  [Search]                                                         │\n│                                                                   │\n│  Results (42):                                                    │\n│  ────────────────────────────────────────────────────────────────│\n│  OrderShipped - ord_123 - 2025-10-18 14:45:10                    │\n│  OrderShipped - ord_789 - 2025-10-18 12:15:33                    │\n│  OrderShipped - ord_456 - 2025-10-17 16:32:45                    │\n│",
        "startIndex": 14007,
        "preview": "services: ` ┌──────────────────────────────────────────────────────────────────┐ │ Services │ ├───────────────────────────────────────────────────────..."
      },
      {
        "id": "old-v1.0.0.0/observability/dashboard-chunk-7",
        "text": "│ Query: [customer_id:cust_456 AND status:shipped_____________] │ │ Time Range: [Last 24 Hours ▼] │ │ [Search] │ │ │ │ Results (42): │ │ ────────────────────────────────────────────────────────────────│ │ OrderShipped - ord_123 - 2025-10-18 14:45:10 │ │ OrderShipped - ord_789 - 2025-10-18 12:15:33 │ │ OrderShipped - ord_456 - 2025-10-17 16:32:45 │ │ │\n└──────────────────────────────────────────────────────────────────┘\n`\nQuery Syntax:\nevent_type:OrderPlaced\ntenant_id:acme-corp\ntimestamp > 2025-10-18\nstatus:error AND service:payment\nReal-Time Updates\nDashboard updates in real-time via SignalR:\n`csharp\n---\ncategory: Observability\ndifficulty: INTERMEDIATE\ntags: [Dashboard, SignalR, Real-Time, Push-Notifications]\ndescription: Real-time dashboard updates with SignalR and push notifications\n---\nusing Whizbang Dashboard;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbangDashboard(options => {\n    // Real-time updates via SignalR\n    options EnableRealTimeUpdates = true;\n    // Push notifications for important events\n    options PushNotifications(notify => {\n        notify OnProjectionError = true;\n        notify OnHighLatency = true;\n        notify OnErrorRateThreshold = 0 05;  // Alert if error rate > 5%\n    });\n});\n`\nFeatures:\nLive message journey updates\nReal-time projection lag updates\nInstant error notifications\nThroughput graphs update every second\nSecurity\nAuthentication\nProtect the dashboard:\n`csharp\n---\ncategory: Observability\ndifficulty: INTERMEDIATE\ntags: [Dashboard, Authentication, Security, Authorization]\ndescription: Secure dashboard with authentication and role-based access\n---\nusing Whizbang Dashboard;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbangDashboard(options => {\n    // Require authentication\n    options RequireAuthentication = true;\n    // Role-based access\n    options RequireRole(\"WhizbangAdmin\");\n    // Or custom authorization policy\n    options RequirePolicy(\"WhizbangDashboardAccess\");\n});\n`\nAudit Log\nTrack who accessed the dashboard:\n`\n┌──────────────────────────────────────────────────────────────────┐\n│  Audit Log                                                        │\n├──────────────────────────────────────────────────────────────────┤\n│  Timestamp           User         Action                          │\n│  ──────────────────  ───────────  ─────────────────────────────  │\n│  14:52:10 UTC        admin        Rebuilt projection OrderHistory│\n│  14:45:33 UTC        john doe     Viewed order stream ord_123    │\n│  14:32:15 UTC        admin        Set log level to Debug         │\n│  14:18:02 UTC        jane doe     Paused projection              │\n└──────────────────────────────────────────────────────────────────┘\n`\nNext Steps\nObservability - OpenTelemetry integration\nAdvanced Scenarios - Control plane commands\nDistributed Messaging - Cross-service tracing",
        "startIndex": 17141,
        "preview": "│ Query: [customer_id:cust_456 AND status:shipped_____________] │ │ Time Range: [Last 24 Hours ▼] │ │ [Search] │ │ │ │ Results (42): │ │ ─────────────..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/projections/projection-contexts",
    "title": "Projection Contexts",
    "category": "Projections",
    "url": "/docs/old-v1.0.0.0/projections/projection-contexts",
    "chunks": [
      {
        "id": "old-v1.0.0.0/projections/projection-contexts-chunk-0",
        "text": "Projection Contexts\nWhizbang provides two types of context for projections:\nEventContext - Rich event metadata (pure data, no side effects)\nProjectionContext - Projection-specific operations and metadata (CRUD operations, projection info)\nBoth can be injected at the method level or constructor level `mermaid\ngraph LR\n    Event[Event] --> Handler[Projection Handler]\n    subgraph Contexts[\"Injected Contexts\"]\n        EC[EventContext<br/>Pure Data Only]\n        PC[ProjectionContext<br/>With CRUD Operations]\n    end\n    subgraph ECData[\"EventContext Contents\"]\n        System[System Data<br/>Timestamp, Machine, etc ]\n        Security[Security Context<br/>User, Tenant, Roles]\n        EventMeta[Event Metadata<br/>EventId, Causation]\n        Tracing[Tracing Context<br/>CorrelationId, TraceId]\n    end\n    subgraph PCData[\"ProjectionContext Contents\"]\n        ProjMeta[Projection Metadata<br/>Name, Version, Type]\n        ServiceMeta[Service Metadata<br/>Environment, Machine]\n        Store[Projection Store<br/>Create, Update, Patch, Delete]\n    end\n    EC --> ECData\n    PC --> PCData\n    Handler --> EC\n    Handler --> PC\n    PC --> Store\n    style Event fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    style Handler fill:#cce5ff,stroke:#004085,stroke-width:2px\n    style EC fill:#d4edda,stroke:#28a745,stroke-width:2px\n    style PC fill:#d1ecf1,stroke:#0c5460,stroke-width:2px\n    style Store fill:#f8d7da,stroke:#dc3545,stroke-width:2px\n`\nEventContext Injection\nEventContext is pure data (no side effects) that provides rich metadata about every event EventContext Structure\n`csharp{\ntitle: \"EventContext Structure\"\ndescription: \"Complete structure of EventContext with system metadata, security context, event metadata, and tracing information\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"EventContext\", \"Structure\", \"Metadata\"]\nfilename: \"EventContext cs\"\nusingStatements: [\"System\", \"System Collections Generic\"]\nshowLineNumbers: true\n}\npublic class EventContext {\n    // System metadata\n    public SystemData System { get; init; }\n    // Security and multi-tenancy context\n    public SecurityContext Security { get; init; }\n    // Event-specific metadata\n    public EventMetadata Event { get; init; }\n    // Distributed tracing information\n    public TracingContext Tracing { get; init; }\n}\npublic class SystemData {\n    // System-generated metadata\n    public DateTime Timestamp { get; init; }\n    public string MachineName { get; init; }\n    public string Environment { get; init; }\n    public long EventSequenceNumber { get; init; }\n    // Custom system metadata (extensible)\n    public IReadOnlyDictionary<string, object> CustomMetadata { get; init; }\n}\npublic class SecurityContext {\n    // User information\n    public Guid",
        "startIndex": 0,
        "preview": "Projection Contexts\nWhizbang provides two types of context for projections:\nEventContext - Rich event metadata (pure data, no side effects)\nProjection..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-contexts-chunk-1",
        "text": "DateTime Timestamp { get; init; } public string MachineName { get; init; } public string Environment { get; init; } public long EventSequenceNumber { get; init; } // Custom system metadata (extensible) public IReadOnlyDictionary<string, object> CustomMetadata { get; init; } } public class SecurityContext { // User information public Guid UserId { get; init; }\n    public string UserName { get; init; }\n    public IReadOnlyList<string> Roles { get; init; }\n    // Multi-tenancy\n    public Guid TenantId { get; init; }\n    public string TenantName { get; init; }\n    // Permissions (evaluated at command/event creation time)\n    public IReadOnlyList<string> Permissions { get; init; }\n    // Service trust boundary\n    public bool IsTrustedService { get; init; }\n    public string ServiceName { get; init; }\n}\npublic class EventMetadata {\n    // Event identification\n    public Guid EventId { get; init; }\n    public string EventType { get; init; }\n    public int EventVersion { get; init; }\n    // Causation (what caused this event)\n    public Guid CausationId { get; init; }  // Command that caused this event\n    public string CausationType { get; init; }\n    // Custom event metadata\n    public IReadOnlyDictionary<string, object> CustomMetadata { get; init; }\n}\npublic class TracingContext {\n    // Distributed tracing\n    public string CorrelationId { get; init; }  // End-to-end request tracking\n    public string TraceId { get; init; }        // OpenTelemetry trace ID\n    public string SpanId { get; init; }         // OpenTelemetry span ID\n    // Message journey\n    public int HopCount { get; init; }          // Number of services traversed\n    public DateTime InitiatedAt { get; init; }  // When the original request started\n}\n`\nEventContext Usage Example\n`csharp{\ntitle: \"EventContext Usage in Projections\"\ndescription: \"Accessing system metadata, security context, and tracing information\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"EventContext\", \"Security\", \"Multi-Tenancy\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading",
        "startIndex": 2792,
        "preview": "DateTime Timestamp { get; init; } public string MachineName { get; init; } public string Environment { get; init; } public long EventSequenceNumber { ..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-contexts-chunk-2",
        "text": "init; } // When the original request started } ` EventContext Usage Example `csharp{ title: \"EventContext Usage in Projections\" description: \"Accessing system metadata, security context, and tracing information\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Projections\", \"EventContext\", \"Security\", \"Multi-Tenancy\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"] usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class TenantOrderHistoryProjection {\n    private readonly Dictionary<Guid, List<TenantOrderRecord>> _ordersByTenant = new();\n    public Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        EventContext context,\n        CancellationToken ct) {\n        // Use security context for tenant isolation\n        if ( context Security TenantId HasValue) {\n            throw new InvalidOperationException(\"TenantId is required for order events\");\n        }\n        var tenantId = context Security TenantId Value;\n        // Create tenant-scoped record with rich context\n        var record = new TenantOrderRecord {\n            OrderId = @event OrderId,\n            TenantId = tenantId,\n            TenantName = context Security TenantName,\n            CustomerId = @event CustomerId,\n            Total = @event Total,\n            // System metadata\n            PlacedAt = context System Timestamp,\n            PlacedBy = context Security UserName,\n            PlacedByUserId = context Security UserId,\n            // Tracing\n            CorrelationId = context Tracing CorrelationId,\n            OriginatedAt = context Tracing InitiatedAt,\n            // Event metadata\n            EventId = context Event EventId,\n            CausationId = context Event CausationId  // The PlaceOrder command ID\n        };\n        if ( _ordersByTenant ContainsKey(tenantId)) {\n            _ordersByTenant[tenantId] = new List<TenantOrderRecord>();\n        }\n        _ordersByTenant[tenantId] Add(record);\n        return Task CompletedTask;\n    }\n    // Query methods (tenant-scoped)\n    public IEnumerable<TenantOrderRecord> GetOrdersForTenant(Guid tenantId) {\n        return _ordersByTenant TryGetValue(tenantId, out var orders) orders\n            : Enumerable Empty<TenantOrderRecord>();\n    }\n}\npublic record TenantOrderRecord {\n    public Guid OrderId { get; init; }\n    public Guid TenantId { get; init; }\n    public string TenantName { get; init; }\n    public Guid CustomerId { get; init; }\n    public decimal Total { get; init; }\n    // System metadata\n    public DateTime PlacedAt { get; init; }\n    public string PlacedBy { get; init; }\n    public Guid",
        "startIndex": 4618,
        "preview": "init; } // When the original request started } ` EventContext Usage Example `csharp{ title: \"EventContext Usage in Projections\" description: \"Accessin..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-contexts-chunk-3",
        "text": "get; init; } public Guid TenantId { get; init; } public string TenantName { get; init; } public Guid CustomerId { get; init; } public decimal Total { get; init; } // System metadata public DateTime PlacedAt { get; init; } public string PlacedBy { get; init; } public Guid PlacedByUserId { get; init; }\n    // Tracing\n    public string CorrelationId { get; init; }\n    public DateTime OriginatedAt { get; init; }\n    // Event lineage\n    public Guid EventId { get; init; }\n    public Guid CausationId { get; init; }\n}\n`\nEventContext Benefits\nMulti-Tenancy: Access tenant context for data isolation\nSecurity: User, roles, permissions available for authorization\nAuditing: Track who did what and when\nTracing: End-to-end request tracking with correlation IDs\nCausation: Link events back to originating commands\nPure Data: All context is immutable, enabling pure function projections\nExtensible: Custom metadata dictionaries for app-specific data\nPurity Guarantees\nEventContext is designed to maintain projection purity:\nImmutable: All properties are init-only\nNo side effects: Contains only data, no methods with side effects\nNo I/O: No database, file system, or network access\nDeterministic: Same event + context always produces same projection state\nRoslyn Analyzers: Whizbang Analyzers enforces purity rules at compile time\n---\nProjectionContext Injection\nWhile EventContext is pure data, ProjectionContext provides database operations and projection metadata It can be injected at the method level or constructor level ProjectionContext Structure\n`csharp{\ntitle: \"ProjectionContext Structure\"\ndescription: \"Complete structure of ProjectionContext with projection metadata, service information, and projection store operations\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"ProjectionContext\", \"Structure\", \"CRUD Operations\"]\nfilename: \"ProjectionContext cs\"\nusingStatements: [\"System\", \"System Collections Generic\", \"System Threading\", \"System Threading",
        "startIndex": 6921,
        "preview": "get; init; } public Guid TenantId { get; init; } public string TenantName { get; init; } public Guid CustomerId { get; init; } public decimal Total { ..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-contexts-chunk-4",
        "text": "the method level or constructor level ProjectionContext Structure `csharp{ title: \"ProjectionContext Structure\" description: \"Complete structure of ProjectionContext with projection metadata, service information, and projection store operations\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Projections\", \"ProjectionContext\", \"Structure\", \"CRUD Operations\"] filename: \"ProjectionContext cs\" usingStatements: [\"System\", \"System Collections Generic\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\npublic class ProjectionContext {\n    // Projection metadata\n    public ProjectionMetadata Projection { get; init; }\n    // Service information\n    public ServiceMetadata Service { get; init; }\n    // Database operations (Create, Update, Patch, Delete)\n    public IProjectionStore Store { get; init; }\n}\npublic class ProjectionMetadata {\n    public string ProjectionName { get; init; }\n    public string ProjectionVersion { get; init; }\n    public Type ProjectionType { get; init; }\n    public DateTime StartedAt { get; init; }\n    // Custom projection metadata\n    public IReadOnlyDictionary<string, object> CustomMetadata { get; init; }\n}\npublic class ServiceMetadata {\n    public string ServiceName { get; init; }\n    public string ServiceVersion { get; init; }\n    public string Environment { get; init; }\n    public string MachineName { get; init; }\n}\npublic interface IProjectionStore {\n    // Create\n    Task CreateAsync<TProjection>(TProjection projection, CancellationToken ct = default)\n        where TProjection : class;\n    // Read (for checking existence or retrieving current state)\n    Task<TProjection",
        "startIndex": 8653,
        "preview": "the method level or constructor level ProjectionContext Structure `csharp{ title: \"ProjectionContext Structure\" description: \"Complete structure of Pr..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-contexts-chunk-5",
        "text": "} public string ServiceVersion { get; init; } public string Environment { get; init; } public string MachineName { get; init; } } public interface IProjectionStore { // Create Task CreateAsync<TProjection>(TProjection projection, CancellationToken ct = default) where TProjection : class; // Read (for checking existence or retrieving current state) Task<TProjection > GetAsync<TProjection>(object key, CancellationToken ct = default)\n        where TProjection : class;\n    // Update (replace entire document)\n    Task UpdateAsync<TProjection>(object key, TProjection projection, CancellationToken ct = default)\n        where TProjection : class;\n    // Patch (partial update)\n    Task PatchAsync<TProjection>(object key, Action<TProjection> patchAction, CancellationToken ct = default)\n        where TProjection : class;\n    // Delete\n    Task DeleteAsync<TProjection>(object key, CancellationToken ct = default)\n        where TProjection : class;\n    // Batch operations\n    Task CreateManyAsync<TProjection>(IEnumerable<TProjection> projections, CancellationToken ct = default)\n        where TProjection : class;\n}\n// Return values for projection methods\npublic enum ProjectionReturnType {\n    Accepted,  // Event was processed successfully (default)\n    Ignored    // Event was intentionally ignored/skipped\n}\npublic static class ProjectionContextExtensions {\n    // Return a projection outcome (metadata only, no side effects)\n    public static Task Return(this ProjectionContext context, ProjectionReturnType returnType) {\n        context RecordOutcome(returnType);\n        return Task CompletedTask;\n    }\n}\n`\nProjectionContext Usage Examples\nSee the complete examples in Projection Return Values ProjectionContext Benefits\nDatabase Operations: Built-in CRUD operations (Create, Update, Patch, Delete)\nProjection Metadata: Access projection name, version, and custom metadata\nService Context: Know which service and environment the projection is running in\nFlexible Injection: Inject at method or constructor level based on your needs\nBatch Operations: Efficient bulk creates for high-throughput scenarios\nReturn Values: Signal processing outcomes with Return() method\n---\nNext Steps\nProjection Subscriptions - Event subscription patterns\nProjection Purity - Maintaining pure, deterministic projections\nProjection Return Values - Using return values for observability",
        "startIndex": 9802,
        "preview": "} public string ServiceVersion { get; init; } public string Environment { get; init; } public string MachineName { get; init; } } public interface IPr..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/projections/projection-purity",
    "title": "Projection Purity",
    "category": "Projections",
    "url": "/docs/old-v1.0.0.0/projections/projection-purity",
    "chunks": [
      {
        "id": "old-v1.0.0.0/projections/projection-purity-chunk-0",
        "text": "Projection Purity\nCRITICAL: Projections must be pure functions and deterministic The same event must ALWAYS produce the same projection state, regardless of when it's processed The Purity Rule\nProjections are read-side transformations that convert event data into queryable read models They must:\nBe deterministic (same input = same output)\nHave no side effects\nUse only data from events or EventContext\nNever perform business logic\nGood vs Bad Projections\n✅ Good Projection (Pure)\n`csharp{\ntitle: \"Pure Projection Example\"\ndescription: \"Correct projection using only event data and EventContext\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Purity\", \"Best Practices\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class GoodProjection {\n    // ✅ CORRECT: Use event timestamp from EventContext\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        EventContext eventContext,\n        CancellationToken ct) {\n        var summary = new OrderSummary {\n            OrderId = @event OrderId,\n            PlacedAt = eventContext System Timestamp,  // ✅ Deterministic\n            ExpiresAt = @event ExpiresAt,              // ✅ From event (business logic set this)\n            CustomerId = @event CustomerId,\n            Total = @event Total\n        };\n        await projection Store CreateAsync(summary, ct);\n    }\n    // ✅ CORRECT: Business logic decision in event, not projection\n    public Task OnOrderPlaced2(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // Event already contains IsExpired flag (set by business logic)\n        if (@event IsExpired) {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Process non-expired order\n        return Task CompletedTask;\n    }\n    // ✅ CORRECT: Use data from event or context\n    public async Task OnOrderShipped(\n        [WhizbangSubscribe] OrderShipped @event,\n        ProjectionContext projection,\n        EventContext eventContext,\n        CancellationToken ct) {\n        await projection Store PatchAsync<OrderSummary>(\n            @event OrderId,\n            order => {\n                order Status = \"Shipped\";\n                order ShippedAt = eventContext System Timestamp;  // ✅ From context\n                order TrackingNumber = @event",
        "startIndex": 0,
        "preview": "Projection Purity\nCRITICAL: Projections must be pure functions and deterministic The same event must ALWAYS produce the same projection state, regardl..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-purity-chunk-1",
        "text": "// ✅ CORRECT: Use data from event or context public async Task OnOrderShipped( [WhizbangSubscribe] OrderShipped @event, ProjectionContext projection, EventContext eventContext, CancellationToken ct) { await projection Store PatchAsync<OrderSummary>( @event OrderId, order => { order Status = \"Shipped\"; order ShippedAt = eventContext System Timestamp; // ✅ From context order TrackingNumber = @event TrackingNumber;      // ✅ From event\n            },\n            ct);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public DateTime PlacedAt { get; set; }\n    public DateTime ExpiresAt { get; set; }\n    public Guid CustomerId { get; set; }\n    public decimal Total { get; set; }\n    public string Status { get; set; }\n    public DateTime ShippedAt { get; set; }\n    public string TrackingNumber { get; set; }\n}\n`\n❌ Bad Projection (Impure)\n`csharp{\ntitle: \"Impure Projection Example\"\ndescription: \"Common purity violations and how to avoid them\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Anti-Patterns\", \"Common Mistakes\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System IO\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System IO;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class BadProjection {\n    // ❌ WRONG: DateTime UtcNow is non-deterministic\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        var summary = new OrderSummary {\n            OrderId = @event OrderId,\n            PlacedAt = DateTime UtcNow,  // ❌ NON-DETERMINISTIC - Will be different on replay };\n        await projection Store CreateAsync(summary, ct);\n        // 💥 Whizbang Analyzers will flag this as a compile error\n    }\n    // ❌ WRONG: Business logic in projection\n    public Task OnOrderPlaced2(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        EventContext eventContext,\n        CancellationToken ct) {\n        // ❌ WRONG: Calculating expiration in projection is business logic\n        var age = DateTime UtcNow - eventContext System Timestamp;  // ❌ Non-deterministic\n        if (age > TimeSpan FromDays(90)) {\n            return projection Return(ProjectionReturnType",
        "startIndex": 2639,
        "preview": "// ✅ CORRECT: Use data from event or context public async Task OnOrderShipped( [WhizbangSubscribe] OrderShipped @event, ProjectionContext projection, ..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-purity-chunk-2",
        "text": "❌ WRONG: Business logic in projection public Task OnOrderPlaced2( [WhizbangSubscribe] OrderPlaced @event, ProjectionContext projection, EventContext eventContext, CancellationToken ct) { // ❌ WRONG: Calculating expiration in projection is business logic var age = DateTime UtcNow - eventContext System Timestamp; // ❌ Non-deterministic if (age > TimeSpan FromDays(90)) { return projection Return(ProjectionReturnType Ignored);\n        }\n        // Business logic belongs in command handler or aggregate, not projection return Task CompletedTask;\n        // 💥 Whizbang Analyzers will flag DateTime UtcNow usage\n    }\n    // ❌ WRONG: Random values\n    public async Task OnOrderPlaced3(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        var summary = new OrderSummary {\n            OrderId = @event OrderId,\n            RandomValue = Random Shared Next()  // ❌ NON-DETERMINISTIC\n        };\n        await projection Store CreateAsync(summary, ct);\n        // 💥 Whizbang Analyzers will flag Random usage\n    }\n    // ❌ WRONG: External I/O in projection\n    public async Task OnOrderPlaced4(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        HttpClient httpClient,\n        CancellationToken ct) {\n        // ❌ WRONG: Calling external API is non-deterministic\n        var customerData = await httpClient GetAsync($\"https://api/customers/{@event CustomerId}\");\n        // External data can change - not deterministic // 💥 Whizbang Analyzers will flag external I/O\n    }\n    // ❌ WRONG: File I/O in projection\n    public async Task OnOrderPlaced5(\n        [WhizbangSubscribe] OrderPlaced @event,\n        CancellationToken ct) {\n        // ❌ WRONG: File writes are side effects\n        await File WriteAllTextAsync(\"orders log\", @event OrderId ToString());\n        // 💥 Whizbang Analyzers will flag file I/O\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public DateTime PlacedAt { get; set; }\n    public int RandomValue { get; set; }\n}\n`\nPurity Rules\nProjections must follow these rules to remain pure and deterministic:\n| ❌ NEVER Use | ✅ Instead Use | Why |\n|-----------------|-------------------|---------|\n| DateTime UtcNow | eventContext System Timestamp | Current time is non-deterministic |\n| DateTime Now | eventContext System",
        "startIndex": 4666,
        "preview": "❌ WRONG: Business logic in projection public Task OnOrderPlaced2( [WhizbangSubscribe] OrderPlaced @event, ProjectionContext projection, EventContext e..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-purity-chunk-3",
        "text": "RandomValue { get; set; } } ` Purity Rules Projections must follow these rules to remain pure and deterministic: | ❌ NEVER Use | ✅ Instead Use | Why | |-----------------|-------------------|---------| | DateTime UtcNow | eventContext System Timestamp | Current time is non-deterministic | | DateTime Now | eventContext System Timestamp | Current time is non-deterministic |\n| Random / Guid NewGuid() | Data from event or context | Random values are non-deterministic |\n| External API calls | Data in event | External data can change |\n| Database reads (outside projection store) | Data in event | External data can change |\n| File I/O | Data in event | External data can change |\n| Environment variables | eventContext or config in event | Environment can change |\n| Business logic calculations | Business logic sets flags in event | Projections transform, don't decide |\nWhere Business Logic Belongs\nBusiness logic must live in command handlers and aggregates, NOT in projections ✅ Correct: Business Logic in Command Handler\n`csharp{\ntitle: \"Business Logic in Command Handler\"\ndescription: \"Correct placement of business logic and decision-making\"\nframework: \"NET8\"\ncategory: \"Command Handling\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Command Handlers\", \"Business Logic\", \"Best Practices\"]\nnugetPackages: [\"Whizbang Core\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n// ✅ CORRECT: Business logic in command handler or aggregate\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder, OrderPlaced> {\n    public async Task<OrderPlaced> Handle(\n        PlaceOrder command,\n        CommandContext context,\n        CancellationToken ct) {\n        // ✅ Business logic happens HERE\n        // - Validate the order\n        // - Check inventory\n        // - Calculate totals\n        // - Apply business rules\n        // - Decide if order should be marked as expired\n        var expiresAt = DateTime UtcNow",
        "startIndex": 6647,
        "preview": "RandomValue { get; set; } } ` Purity Rules Projections must follow these rules to remain pure and deterministic: | ❌ NEVER Use | ✅ Instead Use | Why |..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-purity-chunk-4",
        "text": "public async Task<OrderPlaced> Handle( PlaceOrder command, CommandContext context, CancellationToken ct) { // ✅ Business logic happens HERE // - Validate the order // - Check inventory // - Calculate totals // - Apply business rules // - Decide if order should be marked as expired var expiresAt = DateTime UtcNow AddDays(90);  // ✅ Business decision\n        var isExpired = false;  // ✅ Business decision\n        var status = \"Placed\";   // ✅ Business decision\n        // Create event POCO with results of business logic\n        // Event is just a data container - NO logic in the event class itself\n        var @event = context EmitEvent(new OrderPlaced {\n            OrderId = command OrderId,\n            CustomerId = command CustomerId,\n            Total = command Total,\n            ExpiresAt = expiresAt,      // ✅ Set by handler\n            IsExpired = isExpired,       // ✅ Set by handler\n            Status = status              // ✅ Set by handler\n        });\n        return @event;\n    }\n}\n// ✅ CORRECT: Event is just a POCO (Plain Old CLR Object)\n// NO business logic, NO methods (except maybe ToString for debugging)\n// Just immutable data describing what happened\npublic record OrderPlaced {\n    public Guid OrderId { get; init; }\n    public Guid CustomerId { get; init; }\n    public decimal Total { get; init; }\n    public DateTime ExpiresAt { get; init; }     // ✅ Data only\n    public bool IsExpired { get; init; }         // ✅ Data only\n    public string Status { get; init; }          // ✅ Data only\n    // ❌ NO business logic methods like:\n    // public bool ShouldExpire() => DateTime",
        "startIndex": 8342,
        "preview": "public async Task<OrderPlaced> Handle( PlaceOrder command, CommandContext context, CancellationToken ct) { // ✅ Business logic happens HERE // - Valid..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-purity-chunk-5",
        "text": "{ get; init; } public DateTime ExpiresAt { get; init; } // ✅ Data only public bool IsExpired { get; init; } // ✅ Data only public string Status { get; init; } // ✅ Data only // ❌ NO business logic methods like: // public bool ShouldExpire() => DateTime UtcNow > ExpiresAt;\n    // public void MarkAsExpired() => IsExpired = true;\n    // Events are immutable data - handlers make decisions, events record them\n}\n// ✅ CORRECT: Projection just transforms event data\n[WhizbangProjection]\npublic class OrderProjection {\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // ✅ No business logic - just transform POCO event to read model\n        var summary = new OrderSummary {\n            OrderId = @event OrderId,\n            ExpiresAt = @event ExpiresAt,    // ✅ Copy from event (handler set this)\n            IsExpired = @event IsExpired,     // ✅ Copy from event (handler set this)\n            Status = @event Status            // ✅ Copy from event (handler set this)\n        };\n        if (@event IsExpired) {\n            // Simple filtering based on event data (not a business decision)\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        await projection Store CreateAsync(summary, ct);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public DateTime ExpiresAt { get; set; }\n    public bool IsExpired { get; set; }\n    public string Status { get; set; }\n}\n`\nThe Three-Layer Architecture\nWhizbang enforces a clear separation of concerns:\n`mermaid\ngraph TB\n    subgraph BusinessLogic[\"Command Handler / Aggregate (Business Logic Layer)\"]\n        BL1[\"✅ Validates commands\"]\n        BL2[\"✅ Applies business rules\"]\n        BL3[\"✅ Makes decisions\"]\n        BL4[\"✅ Creates event POCOs with results\"]\n        BL5[\"✅ CAN emit commands (sagas)\"]\n        BL6[\"✅ CAN use DateTime",
        "startIndex": 9635,
        "preview": "{ get; init; } public DateTime ExpiresAt { get; init; } // ✅ Data only public bool IsExpired { get; init; } // ✅ Data only public string Status { get;..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-purity-chunk-6",
        "text": "set; } } ` The Three-Layer Architecture Whizbang enforces a clear separation of concerns: `mermaid graph TB subgraph BusinessLogic[\"Command Handler / Aggregate (Business Logic Layer)\"] BL1[\"✅ Validates commands\"] BL2[\"✅ Applies business rules\"] BL3[\"✅ Makes decisions\"] BL4[\"✅ Creates event POCOs with results\"] BL5[\"✅ CAN emit commands (sagas)\"] BL6[\"✅ CAN use DateTime UtcNow, Random, APIs\"]\n    end\n    subgraph DataLayer[\"Data Layer (POCOs - No Logic)\"]\n        Event[\"Event<br/>- Properties only<br/>- NO methods<br/>- Describes what happened\"]\n        Command[\"Command<br/>- Properties only<br/>- NO methods<br/>- Describes intent\"]\n    end\n    subgraph ReadModel[\"Projection (Read Model Layer)\"]\n        P1[\"✅ Pure transformation of event data\"]\n        P2[\"❌ NO business logic\"]\n        P3[\"❌ NO DateTime UtcNow, Random, APIs\"]\n        P4[\"✅ ONLY event data or EventContext\"]\n        P5[\"✅ Deterministic and replayable\"]\n    end\n    BusinessLogic -->|Emits Events| Event\n    BusinessLogic -->|Emits Commands| Command\n    Event -->|Consumed by| ReadModel\n    Command -->|Handled by| BusinessLogic\n    style BusinessLogic fill:#d4edda,stroke:#28a745,stroke-width:2px\n    style DataLayer fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    style ReadModel fill:#cce5ff,stroke:#004085,stroke-width:2px\n    style Event fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n    style Command fill:#fff3cd,stroke:#ffc107,stroke-width:2px\n`\nWhy Purity Matters\nReplay: Events can be replayed to rebuild projections - must produce same result\nTesting: Pure functions are easy to test - same input, same output\nDebugging: Deterministic behavior makes bugs reproducible\nScaling: Multiple projection instances can process same events safely\nTime Travel: Can replay events from any point in time\nAuditing: Projection state is always verifiable from event stream\nDisaster Recovery: Projections can be rebuilt from events after data loss\nBlue/Green Deployments: New projection version can process same events\nWhizbang Analyzers Enforcement\nThe Whizbang Analyzers package enforces purity at compile time:\n`csharp{\ntitle: \"Analyzer Enforcement Example\"\ndescription: \"Compile-time purity validation with Whizbang Analyzers\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Analyzers\", \"Purity\", \"Compile-Time Validation\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\", \"Whizbang Analyzers\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading",
        "startIndex": 11329,
        "preview": "set; } } ` The Three-Layer Architecture Whizbang enforces a clear separation of concerns: `mermaid graph TB subgraph BusinessLogic[\"Command Handler / ..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-purity-chunk-7",
        "text": "compile time: `csharp{ title: \"Analyzer Enforcement Example\" description: \"Compile-time purity validation with Whizbang Analyzers\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Analyzers\", \"Purity\", \"Compile-Time Validation\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\", \"Whizbang Analyzers\"] usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading; using System Threading Tasks;\n[WhizbangProjection]\npublic class OrderProjection {\n    private readonly ILogger _logger;  // ⚠️ Warning: Injected services should be read-only\n    // ✅ VALID - Pure projection handler\n    public Task Handle([WhizbangSubscribe] OrderPlaced @event, EventContext context, CancellationToken ct) {\n        // Pure state updates only\n        var summary = new OrderSummary {\n            PlacedAt = context System Timestamp  // ✅ OK - from context\n        };\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - Side effect detected (logging)\n    public Task Handle([WhizbangSubscribe] OrderShipped @event, CancellationToken ct) {\n        _logger LogInformation(\"Order shipped\");  // 💥 WBG001: Side effect in projection\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - DateTime UtcNow usage\n    public Task Handle([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) {\n        var cancelledAt = DateTime UtcNow;  // 💥 WBG002: Non-deterministic time source\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - Random value generation\n    public Task Handle([WhizbangSubscribe] OrderCompleted @event, CancellationToken ct) {\n        var random = Random Shared Next();  // 💥 WBG003: Non-deterministic random source\n        return Task CompletedTask;\n    }\n    // ❌ ERROR - External I/O detected\n    public async Task Handle([WhizbangSubscribe] OrderRefunded @event, CancellationToken ct) {\n        await File WriteAllTextAsync(\"log txt\", \"refunded\");  // 💥 WBG004: I/O in projection\n    }\n}\npublic class OrderSummary {\n    public DateTime PlacedAt { get; set; }\n}\n`\nAnalyzer Error Codes\nWBG001: Side effect detected in projection (logging, console writes, etc )\nWBG002: Non-deterministic time source (DateTime UtcNow, DateTime Now)\nWBG003: Non-deterministic random source (Random, Guid NewGuid())\nWBG004: I/O operation detected (file system, network, external database)\nWBG005: Database operation outside ProjectionContext",
        "startIndex": 13523,
        "preview": "compile time: `csharp{ title: \"Analyzer Enforcement Example\" description: \"Compile-time purity validation with Whizbang Analyzers\" framework: \"NET8\" c..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-purity-chunk-8",
        "text": "PlacedAt { get; set; } } ` Analyzer Error Codes WBG001: Side effect detected in projection (logging, console writes, etc ) WBG002: Non-deterministic time source (DateTime UtcNow, DateTime Now) WBG003: Non-deterministic random source (Random, Guid NewGuid()) WBG004: I/O operation detected (file system, network, external database) WBG005: Database operation outside ProjectionContext Store\nWBG006: Environment variable access\nWBG007: Complex business logic detected in projection (warning)\nPurity Checklist\nBefore merging projection code, verify:\n[ ] No DateTime UtcNow or DateTime Now usage\n[ ] No Random or Guid NewGuid() calls\n[ ] No external API calls (HTTP, gRPC, etc )\n[ ] No file system operations\n[ ] No logging or console writes\n[ ] No database operations outside ProjectionContext Store\n[ ] No environment variable reads\n[ ] All timestamps from EventContext System Timestamp\n[ ] All business decisions from event data (not calculated in projection)\n[ ] Whizbang Analyzers passes with no errors\nSummary\nProjections = Pure transformations of event data into read models\nBusiness Logic = Command handlers and aggregates that make decisions and emit events\nEvents = POCOs describing what happened (no logic)\nDeterminism = Same event always produces same projection state\nWhizbang Analyzers = Compile-time enforcement of purity rules\nNext Steps\nProjection Subscriptions - Event subscription patterns\nProjection Contexts - EventContext and ProjectionContext injection\nProjection Return Values - Using return values for observability",
        "startIndex": 15479,
        "preview": "PlacedAt { get; set; } } ` Analyzer Error Codes WBG001: Side effect detected in projection (logging, console writes, etc ) WBG002: Non-deterministic t..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/projections/projection-return-values",
    "title": "Projection Return Values",
    "category": "Projections",
    "url": "/docs/old-v1.0.0.0/projections/projection-return-values",
    "chunks": [
      {
        "id": "old-v1.0.0.0/projections/projection-return-values-chunk-0",
        "text": "Projection Return Values\nProjection methods can return metadata about the processing outcome using ProjectionContext Return() This is metadata only with no side effects - it's purely for observability and metrics ProjectionReturnType Enum\n`csharp{\ntitle: \"ProjectionReturnType Enum\"\ndescription: \"Enumeration defining the possible return values for projection methods\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"BEGINNER\"\ntags: [\"Projections\", \"Return Values\", \"Enums\"]\nfilename: \"ProjectionReturnType cs\"\nusingStatements: [\"System\"]\nshowLineNumbers: true\n}\npublic enum ProjectionReturnType {\n    Accepted,  // Event was processed successfully (default)\n    Ignored    // Event was intentionally ignored/skipped\n}\n`\nReturn Value Semantics\n| Return Type | Meaning | Use When | Metrics Impact |\n|------------|---------|----------|----------------|\n| Accepted | Event was processed successfully | Default behavior, projection state updated | Increments events_processed counter |\n| Ignored | Event was intentionally skipped | Filtering, tenant isolation, deduplication | Increments events_ignored counter |\nBasic Usage\n`csharp{\ntitle: \"Basic Projection Return Values\"\ndescription: \"Using return values to signal projection processing outcomes\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"BEGINNER\"\ntags: [\"Projections\", \"Return Values\", \"Observability\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class OrderProjection {\n    // Example 1: Explicit Accepted return (default behavior)\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        await projection Store CreateAsync(new OrderSummary {\n            OrderId = @event OrderId,\n            Status = \"Placed\"\n        }, ct);\n        // Explicitly signal success (optional - this is the default)\n        return projection Return(ProjectionReturnType Accepted);\n    }\n    // Example 2: Implicit Accepted (no return statement)\n    public async Task OnOrderShipped(\n        [WhizbangSubscribe] OrderShipped @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        await projection Store PatchAsync<OrderSummary>(\n            @event OrderId,\n            order => order",
        "startIndex": 0,
        "preview": "Projection Return Values\nProjection methods can return metadata about the processing outcome using ProjectionContext Return() This is metadata only wi..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-return-values-chunk-1",
        "text": "OrderId, Status = \"Placed\" }, ct); // Explicitly signal success (optional - this is the default) return projection Return(ProjectionReturnType Accepted); } // Example 2: Implicit Accepted (no return statement) public async Task OnOrderShipped( [WhizbangSubscribe] OrderShipped @event, ProjectionContext projection, CancellationToken ct) { await projection Store PatchAsync<OrderSummary>( @event OrderId, order => order Status = \"Shipped\",\n            ct);\n        // No explicit return = Accepted (default)\n    }\n    // Example 3: Ignored return (event intentionally skipped)\n    public Task OnOrderEvent(\n        [WhizbangSubscribe] OrderEvent @event,\n        ProjectionContext projection,\n        EventContext eventContext,\n        CancellationToken ct) {\n        // Only process events for current tenant\n        if (eventContext Security TenantId = projection Service CurrentTenantId) {\n            // Different tenant - ignore this event\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Process the event\n        // return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public string Status { get; set; }\n}\n`\nCommon Use Cases for Ignored\nTenant Isolation\n`csharp{\ntitle: \"Tenant Isolation with Return Values\"\ndescription: \"Using Ignored to skip events for different tenants\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Multi-Tenancy\", \"Filtering\", \"Return Values\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class TenantOrderProjection {\n    private readonly Guid _currentTenantId;\n    public TenantOrderProjection(Guid currentTenantId) {\n        _currentTenantId = currentTenantId;\n    }\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        EventContext eventContext,\n        CancellationToken ct) {\n        // Skip events for other tenants\n        if (eventContext Security TenantId = _currentTenantId) {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Process event for current tenant\n        await projection Store CreateAsync(new OrderSummary {\n            OrderId = @event OrderId,\n            TenantId = _currentTenantId,\n            Status = \"Placed\"\n        }, ct);\n        return projection Return(ProjectionReturnType",
        "startIndex": 2482,
        "preview": "OrderId, Status = \"Placed\" }, ct); // Explicitly signal success (optional - this is the default) return projection Return(ProjectionReturnType Accepte..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-return-values-chunk-2",
        "text": "EventContext eventContext, CancellationToken ct) { // Skip events for other tenants if (eventContext Security TenantId = _currentTenantId) { return projection Return(ProjectionReturnType Ignored); } // Process event for current tenant await projection Store CreateAsync(new OrderSummary { OrderId = @event OrderId, TenantId = _currentTenantId, Status = \"Placed\" }, ct); return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public Guid TenantId { get; set; }\n    public string Status { get; set; }\n}\n`\nVersion Checking and Deduplication\n`csharp{\ntitle: \"Version Checking and Deduplication\"\ndescription: \"Using Ignored to skip out-of-order or duplicate events\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Deduplication\", \"Versioning\", \"Return Values\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class VersionedOrderProjection {\n    public async Task OnOrderUpdated(\n        [WhizbangSubscribe] OrderUpdated @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // Get current projection state\n        var current = await projection Store GetAsync<OrderSummary>(@event OrderId, ct);\n        // Ignore if projection doesn't exist (might be deleted)\n        if (current == null) {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Ignore if event is older than current state (out-of-order delivery)\n        if (@event Version <= current Version) {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Update the projection\n        await projection Store UpdateAsync(@event OrderId, new OrderSummary {\n            OrderId = @event OrderId,\n            Version = @event Version,\n            Status = @event Status\n        }, ct);\n        return projection Return(ProjectionReturnType",
        "startIndex": 4692,
        "preview": "EventContext eventContext, CancellationToken ct) { // Skip events for other tenants if (eventContext Security TenantId = _currentTenantId) { return pr..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-return-values-chunk-3",
        "text": "if event is older than current state (out-of-order delivery) if (@event Version <= current Version) { return projection Return(ProjectionReturnType Ignored); } // Update the projection await projection Store UpdateAsync(@event OrderId, new OrderSummary { OrderId = @event OrderId, Version = @event Version, Status = @event Status }, ct); return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public int Version { get; set; }\n    public string Status { get; set; }\n}\n`\nEvent Data Filtering\n`csharp{\ntitle: \"Event Data Filtering\"\ndescription: \"Using Ignored to filter based on event flags set by business logic\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Filtering\", \"Event Data\", \"Return Values\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class ActiveOrderProjection {\n    public async Task OnOrderPlaced(\n        [WhizbangSubscribe] OrderPlaced @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // ✅ CORRECT: Business logic already set IsExpired in the event\n        // The command handler made this decision, projection just filters\n        if (@event IsExpired) {\n            // Event already marked as expired by business logic\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Process non-expired event\n        await projection Store CreateAsync(new OrderSummary {\n            OrderId = @event OrderId,\n            Status = \"Active\"\n        }, ct);\n        return projection Return(ProjectionReturnType Accepted);\n    }\n    public async Task OnOrderStatusChanged(\n        [WhizbangSubscribe] OrderStatusChanged @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // Only track \"active\" status changes\n        if (@event NewStatus = \"Active\") {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        await projection Store PatchAsync<OrderSummary>(\n            @event OrderId,\n            order => order Status = @event NewStatus,\n            ct);\n        return projection Return(ProjectionReturnType",
        "startIndex": 6383,
        "preview": "if event is older than current state (out-of-order delivery) if (@event Version <= current Version) { return projection Return(ProjectionReturnType Ig..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-return-values-chunk-4",
        "text": "projection Return(ProjectionReturnType Accepted); } public async Task OnOrderStatusChanged( [WhizbangSubscribe] OrderStatusChanged @event, ProjectionContext projection, CancellationToken ct) { // Only track \"active\" status changes if (@event NewStatus = \"Active\") { return projection Return(ProjectionReturnType Ignored); } await projection Store PatchAsync<OrderSummary>( @event OrderId, order => order Status = @event NewStatus, ct); return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public string Status { get; set; }\n}\n`\nFeature Flag Filtering\n`csharp{\ntitle: \"Feature Flag Filtering\"\ndescription: \"Using Ignored to skip events when features are disabled\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"ADVANCED\"\ntags: [\"Feature Flags\", \"Configuration\", \"Return Values\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class NotificationProjection {\n    private readonly IFeatureFlagService _featureFlags;\n    public NotificationProjection(IFeatureFlagService featureFlags) {\n        _featureFlags = featureFlags;\n    }\n    public async Task OnOrderShipped(\n        [WhizbangSubscribe] OrderShipped @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // Skip if shipping notifications are disabled\n        // Feature flag is from config, not time-based (deterministic for replay)\n        if ( _featureFlags IsEnabled(\"ShippingNotifications\")) {\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        await projection Store CreateAsync(new NotificationRecord {\n            EventId = @event OrderId,\n            Type = \"ShippingNotification\",\n            CreatedAt = DateTime UtcNow\n        }, ct);\n        return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic interface IFeatureFlagService {\n    bool IsEnabled(string featureName);\n}\npublic class NotificationRecord {\n    public Guid EventId { get; set; }\n    public string Type { get; set; }\n    public DateTime CreatedAt { get; set; }\n}\n`\nProjection Existence Checking\n`csharp{\ntitle: \"Projection Existence Checking\"\ndescription: \"Using Ignored to skip updates to deleted projections\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Existence Checks\", \"Deleted Projections\", \"Return Values\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading",
        "startIndex": 8369,
        "preview": "projection Return(ProjectionReturnType Accepted); } public async Task OnOrderStatusChanged( [WhizbangSubscribe] OrderStatusChanged @event, ProjectionC..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-return-values-chunk-5",
        "text": "`csharp{ title: \"Projection Existence Checking\" description: \"Using Ignored to skip updates to deleted projections\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Existence Checks\", \"Deleted Projections\", \"Return Values\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"] usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Threading; using System Threading Tasks;\n[WhizbangProjection]\npublic class OrderHistoryProjection {\n    public async Task OnOrderUpdated(\n        [WhizbangSubscribe] OrderUpdated @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        // Check if projection exists\n        var existing = await projection Store GetAsync<OrderHistory>(@event OrderId, ct);\n        if (existing == null) {\n            // Projection was deleted or never created - ignore this update\n            return projection Return(ProjectionReturnType Ignored);\n        }\n        // Update existing projection\n        await projection Store PatchAsync<OrderHistory>(\n            @event OrderId,\n            history => history UpdatedAt = DateTime UtcNow,\n            ct);\n        return projection Return(ProjectionReturnType Accepted);\n    }\n    public async Task OnOrderDeleted(\n        [WhizbangSubscribe] OrderDeleted @event,\n        ProjectionContext projection,\n        CancellationToken ct) {\n        await projection Store DeleteAsync<OrderHistory>(@event OrderId, ct);\n        return projection Return(ProjectionReturnType Accepted);\n    }\n}\npublic class OrderHistory {\n    public Guid OrderId { get; set; }\n    public DateTime UpdatedAt { get; set; }\n}\n`\nImportant Notes\nNo Side Effects: Return values are metadata only - they don't affect event flow or projection state\nDefault is Accepted: If you don't explicitly return, Accepted is assumed\nObservability: Return values are recorded for metrics, logging, and dashboard visualization\nNo Error Return: Errors should throw exceptions, not return a status code\nPure Metadata: Return values don't trigger any framework behavior - they're for observability\nMetrics and Observability\nReturn values enable rich metrics and dashboards:\n`csharp{\ntitle: \"Automatic Metrics Tracking\"\ndescription: \"Example metrics automatically tracked by Whizbang for projection return values\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Metrics\", \"Observability\", \"Monitoring\"]\nfilename: \"MetricsExample",
        "startIndex": 10658,
        "preview": "`csharp{ title: \"Projection Existence Checking\" description: \"Using Ignored to skip updates to deleted projections\" framework: \"NET8\" category: \"Proje..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-return-values-chunk-6",
        "text": "Metadata: Return values don't trigger any framework behavior - they're for observability Metrics and Observability Return values enable rich metrics and dashboards: `csharp{ title: \"Automatic Metrics Tracking\" description: \"Example metrics automatically tracked by Whizbang for projection return values\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Metrics\", \"Observability\", \"Monitoring\"] filename: \"MetricsExample cs\"\nusingStatements: [\"System\"]\nshowLineNumbers: true\n}\n// Whizbang automatically tracks these metrics:\n// - whizbang_projection_events_accepted{projection=\"OrderProjection\", event=\"OrderPlaced\"}\n// - whizbang_projection_events_ignored{projection=\"OrderProjection\", event=\"OrderPlaced\"}\n// - whizbang_projection_acceptance_rate{projection=\"OrderProjection\"}\n// - whizbang_projection_throughput{projection=\"OrderProjection\"}\n`\nDashboard Visualization\nThe Whizbang Dashboard uses return values to show:\nProjection Health: Acceptance rate over time\nEvent Filtering: Which events are commonly ignored\nTenant Metrics: Events processed per tenant\nPerformance: Throughput and latency per projection\nDebugging: Identify misconfigured filters\nExample Metrics Query\n`promql\nProjection acceptance rate (should be high for normal operations)\nsum(rate(whizbang_projection_events_accepted[5m])) by (projection)\n/\nsum(rate(whizbang_projection_events_total[5m])) by (projection)\nEvents ignored by reason (for debugging)\nsum(rate(whizbang_projection_events_ignored[5m])) by (projection, reason)\nTenant-specific processing rate\nsum(rate(whizbang_projection_events_accepted[5m])) by (tenant_id)\n`\nBest Practices\nBe Explicit When Filtering\n`csharp{\ntitle: \"Explicit Filtering Best Practice\"\ndescription: \"Best practices for explicit return value usage vs implicit behavior\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"BEGINNER\"\ntags: [\"Best Practices\", \"Return Values\", \"Explicit Programming\"]\nfilename: \"ExplicitFilteringExample cs\"\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\n// ✅ GOOD - Explicit and clear\nif (@event IsExpired) {\n    return projection Return(ProjectionReturnType Ignored);\n}\n// ❌ BAD - Implicit, unclear why event is ignored\nif (@event IsExpired) {\n    return Task CompletedTask;  // Looks like Accepted, but event wasn't processed\n}\n`\nUse Ignored for Intentional Filtering\n`csharp{\ntitle: \"Intentional Filtering vs Error Handling\"\ndescription: \"Correct usage of Ignored for filtering vs incorrect usage for error handling\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Best Practices\", \"Error Handling\", \"Filtering\"]\nfilename: \"FilteringVsErrorHandling cs\"\nusingStatements: [\"System\", \"System Threading\", \"System Threading",
        "startIndex": 12696,
        "preview": "Metadata: Return values don't trigger any framework behavior - they're for observability Metrics and Observability Return values enable rich metrics a..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-return-values-chunk-7",
        "text": "wasn't processed } ` Use Ignored for Intentional Filtering `csharp{ title: \"Intentional Filtering vs Error Handling\" description: \"Correct usage of Ignored for filtering vs incorrect usage for error handling\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Best Practices\", \"Error Handling\", \"Filtering\"] filename: \"FilteringVsErrorHandling cs\" usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\n// ✅ GOOD - Intentional filtering (return Ignored)\nif (eventContext Security TenantId = _currentTenantId) {\n    return projection Return(ProjectionReturnType Ignored);\n}\n// ❌ BAD - Errors should throw exceptions, not return Ignored\ntry {\n    await projection Store CreateAsync(summary, ct);\n} catch (Exception) {\n    return projection Return(ProjectionReturnType Ignored);  // Wrong Throw the exception\n}\n`\nDocument Ignored Reasons\n`csharp{\ntitle: \"Documented Filtering Reasons\"\ndescription: \"Best practice for documenting why events are ignored with clear comments\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"BEGINNER\"\ntags: [\"Best Practices\", \"Documentation\", \"Code Comments\"]\nfilename: \"DocumentedFilteringExample cs\"\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\n// ✅ GOOD - Comment explains why event is ignored\npublic Task OnOrderPlaced(\n    [WhizbangSubscribe] OrderPlaced @event,\n    ProjectionContext projection,\n    EventContext eventContext,\n    CancellationToken ct) {\n    // Ignore events for other tenants - this projection is tenant-scoped\n    if (eventContext Security TenantId = _currentTenantId) {\n        return projection Return(ProjectionReturnType Ignored);\n    }\n    // Process event }\n`\nMonitor Acceptance Rates\nSet up alerts for low acceptance rates:\n`yaml\nPrometheus alert rule\nalert: LowProjectionAcceptanceRate\n  expr: |\n    sum(rate(whizbang_projection_events_accepted[5m])) by (projection)\n    /\n    sum(rate(whizbang_projection_events_total[5m])) by (projection)\n    < 0 5\n  for: 10m\n  annotations:\n    summary: \"Projection {{ $labels",
        "startIndex": 15016,
        "preview": "wasn't processed } ` Use Ignored for Intentional Filtering `csharp{ title: \"Intentional Filtering vs Error Handling\" description: \"Correct usage of Ig..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-return-values-chunk-8",
        "text": "Security TenantId = _currentTenantId) { return projection Return(ProjectionReturnType Ignored); } // Process event } ` Monitor Acceptance Rates Set up alerts for low acceptance rates: `yaml Prometheus alert rule alert: LowProjectionAcceptanceRate expr: | sum(rate(whizbang_projection_events_accepted[5m])) by (projection) / sum(rate(whizbang_projection_events_total[5m])) by (projection) < 0 5 for: 10m annotations: summary: \"Projection {{ $labels projection }} has low acceptance rate\"\n    description: \"Less than 50% of events are being accepted\"\n`\nSummary\nReturn values are metadata only - no side effects\nDefault is Accepted - explicit return is optional\nUse Ignored for intentional filtering - tenant isolation, versioning, feature flags\nErrors should throw exceptions - not return Ignored\nMetrics enable observability - track acceptance rates, throughput, and health\nDashboard visualization - see projection health and filtering patterns\nNext Steps\nProjection Subscriptions - Event subscription patterns\nProjection Contexts - EventContext and ProjectionContext injection\nProjection Purity - Maintaining pure, deterministic projections",
        "startIndex": 16684,
        "preview": "Security TenantId = _currentTenantId) { return projection Return(ProjectionReturnType Ignored); } // Process event } ` Monitor Acceptance Rates Set up..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/projections/projection-subscriptions",
    "title": "Projection Subscriptions",
    "category": "Projections",
    "url": "/docs/old-v1.0.0.0/projections/projection-subscriptions",
    "chunks": [
      {
        "id": "old-v1.0.0.0/projections/projection-subscriptions-chunk-0",
        "text": "Projection Subscriptions\nWhizbang provides flexible event subscription patterns using the [WhizbangSubscribe] attribute Projections can subscribe to specific event types, base classes, interfaces, or use generic methods for maximum reusability Basic Subscription Pattern\nPlace [WhizbangSubscribe] directly on the method parameter representing the event:\n`csharp{\ntitle: \"Basic Event Subscription\"\ndescription: \"Simple event subscription pattern with flexible method naming\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"BEGINNER\"\ntags: [\"Projections\", \"Subscriptions\", \"Events\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class OrderHistoryProjection {\n    private readonly List<OrderSummary> _orders = new();\n    // ✅ Method names are flexible - use what makes sense\n    public Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) {\n        _orders Add(new OrderSummary(@event OrderId, \"Placed\"));\n        return Task CompletedTask;\n    }\n    public Task On([WhizbangSubscribe] OrderShipped @event, CancellationToken ct) {\n        var order = _orders First(o => o OrderId == @event OrderId);\n        order Status = \"Shipped\";\n        return Task CompletedTask;\n    }\n    public Task When([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) {\n        _orders RemoveAll(o => o OrderId == @event OrderId);\n        return Task CompletedTask;\n    }\n    // Descriptive names work too\n    public Task OnOrderCompleted([WhizbangSubscribe] OrderCompleted @event, CancellationToken ct) {\n        var order = _orders First(o => o OrderId == @event OrderId);\n        order Status = \"Completed\";\n        return Task",
        "startIndex": 0,
        "preview": "Projection Subscriptions\nWhizbang provides flexible event subscription patterns using the [WhizbangSubscribe] attribute Projections can subscribe to s..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-subscriptions-chunk-1",
        "text": "public Task When([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) { _orders RemoveAll(o => o OrderId == @event OrderId); return Task CompletedTask; } // Descriptive names work too public Task OnOrderCompleted([WhizbangSubscribe] OrderCompleted @event, CancellationToken ct) { var order = _orders First(o => o OrderId == @event OrderId); order Status = \"Completed\"; return Task CompletedTask;\n    }\n}\npublic record OrderSummary(Guid OrderId, string Status) {\n    public string Status { get; set; } = Status;\n}\n`\nSubscription Rules\nOne subscription per method: Only one parameter can have [WhizbangSubscribe] attribute\nAdditional parameters allowed: CancellationToken, EventContext, ProjectionContext, injected services\nFlexible naming: Use Handle, On, When, or any descriptive name\nAuto-registration: Source generator automatically wires subscriptions to service configuration\nSupports polymorphism: Subscribe to base classes or interfaces\nPolymorphic Subscriptions\nBase Class Subscriptions\nSubscribe to a base class to handle all derived event types:\n`csharp{\ntitle: \"Base Class Event Subscriptions\"\ndescription: \"Using base classes to handle multiple event types\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Polymorphism\", \"Base Classes\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n// Base class for all order events\npublic abstract record OrderEvent(Guid OrderId, DateTime Timestamp);\n// Derived event types\npublic record OrderPlaced(Guid OrderId, DateTime Timestamp, decimal Total)\n    : OrderEvent(OrderId, Timestamp);\npublic record OrderShipped(Guid OrderId, DateTime Timestamp, string TrackingNumber)\n    : OrderEvent(OrderId, Timestamp);\npublic record OrderCancelled(Guid OrderId, DateTime Timestamp, string Reason)\n    : OrderEvent(OrderId, Timestamp);\n[WhizbangProjection]\npublic class OrderAuditProjection {\n    private readonly List<AuditRecord> _auditLog = new();\n    // Single method handles ALL OrderEvent-derived types\n    public Task Handle([WhizbangSubscribe] OrderEvent @event, CancellationToken ct) {\n        // Common processing for all order events\n        LogAudit(@event OrderId, @event GetType() Name, @event",
        "startIndex": 1857,
        "preview": "public Task When([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) { _orders RemoveAll(o => o OrderId == @event OrderId); return Task C..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-subscriptions-chunk-2",
        "text": "public record OrderCancelled(Guid OrderId, DateTime Timestamp, string Reason) : OrderEvent(OrderId, Timestamp); [WhizbangProjection] public class OrderAuditProjection { private readonly List<AuditRecord> _auditLog = new(); // Single method handles ALL OrderEvent-derived types public Task Handle([WhizbangSubscribe] OrderEvent @event, CancellationToken ct) { // Common processing for all order events LogAudit(@event OrderId, @event GetType() Name, @event Timestamp);\n        // Pattern matching for specific handling\n        return @event switch {\n            OrderPlaced placed => HandlePlaced(placed),\n            OrderShipped shipped => HandleShipped(shipped),\n            OrderCancelled cancelled => HandleCancelled(cancelled),\n            _ => Task CompletedTask\n        };\n    }\n    private Task HandlePlaced(OrderPlaced @event) {\n        _auditLog Add(new AuditRecord(\"Order placed with total: \" + @event Total));\n        return Task CompletedTask;\n    }\n    private Task HandleShipped(OrderShipped @event) {\n        _auditLog Add(new AuditRecord(\"Order shipped: \" + @event TrackingNumber));\n        return Task CompletedTask;\n    }\n    private Task HandleCancelled(OrderCancelled @event) {\n        _auditLog Add(new AuditRecord(\"Order cancelled: \" + @event Reason));\n        return Task CompletedTask;\n    }\n    private void LogAudit(Guid orderId, string eventType, DateTime timestamp) {\n        Console WriteLine($\"[{timestamp}] {eventType} - Order {orderId}\");\n    }\n}\npublic record AuditRecord(string Message);\n`\nInterface Subscriptions\nSubscribe to an interface to handle all implementing event types:\n`csharp{\ntitle: \"Interface Event Subscriptions\"\ndescription: \"Using interfaces to handle multiple event types\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Polymorphism\", \"Interfaces\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading;\nusing System Threading",
        "startIndex": 3841,
        "preview": "public record OrderCancelled(Guid OrderId, DateTime Timestamp, string Reason) : OrderEvent(OrderId, Timestamp); [WhizbangProjection] public class Orde..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-subscriptions-chunk-3",
        "text": "Event Subscriptions\" description: \"Using interfaces to handle multiple event types\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Projections\", \"Polymorphism\", \"Interfaces\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"] usingStatements: [\"System\", \"System Collections Generic\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Collections Generic; using System Threading; using System Threading Tasks;\n// Interface for all inventory events\npublic interface IInventoryEvent {\n    Guid ProductId { get; }\n}\n// Event implementations\npublic record InventoryAdjusted(Guid ProductId, int Quantity) : IInventoryEvent;\npublic record InventoryReserved(Guid ProductId, int Quantity, Guid OrderId) : IInventoryEvent;\npublic record InventoryReleased(Guid ProductId, int Quantity, Guid OrderId) : IInventoryEvent;\n[WhizbangProjection]\npublic class InventoryProjection {\n    private readonly Dictionary<Guid, int> _stock = new();\n    // Single method handles ALL IInventoryEvent implementations\n    public Task Handle([WhizbangSubscribe] IInventoryEvent @event, CancellationToken ct) {\n        return @event switch {\n            InventoryAdjusted adjusted => HandleAdjusted(adjusted),\n            InventoryReserved reserved => HandleReserved(reserved),\n            InventoryReleased released => HandleReleased(released),\n            _ => Task CompletedTask\n        };\n    }\n    private Task HandleAdjusted(InventoryAdjusted @event) {\n        _stock[@event ProductId] = @event Quantity;\n        return Task CompletedTask;\n    }\n    private Task HandleReserved(InventoryReserved @event) {\n        if (_stock ContainsKey(@event ProductId)) {\n            _stock[@event ProductId] -= @event Quantity;\n        }\n        return Task CompletedTask;\n    }\n    private Task HandleReleased(InventoryReleased @event) {\n        if (_stock ContainsKey(@event ProductId)) {\n            _stock[@event ProductId] += @event Quantity;\n        }\n        return Task CompletedTask;\n    }\n    // Query method\n    public int GetStock(Guid productId) {\n        return _stock TryGetValue(productId, out var stock) stock : 0;\n    }\n}\n`\nGeneric Method Subscriptions\nUse generic methods for maximum flexibility and reusability:\n`csharp{\ntitle: \"Generic Method Subscriptions\"\ndescription: \"Using generic methods to handle multiple event types with shared logic\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Generics\", \"Polymorphism\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Collections Generic\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Collections Generic;\nusing System Threading;\nusing System Threading",
        "startIndex": 5512,
        "preview": "Event Subscriptions\" description: \"Using interfaces to handle multiple event types\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIAT..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-subscriptions-chunk-4",
        "text": "generic methods to handle multiple event types with shared logic\" framework: \"NET8\" category: \"Projections\" difficulty: \"ADVANCED\" tags: [\"Projections\", \"Generics\", \"Polymorphism\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"] usingStatements: [\"System\", \"System Collections Generic\", \"System Threading\", \"System Threading Tasks\"] showLineNumbers: true } using System; using System Collections Generic; using System Threading; using System Threading Tasks;\n// Marker interface for all events\npublic interface IEvent {\n    Guid EventId { get; }\n    DateTime Timestamp { get; }\n}\n// Base interface for domain events\npublic interface IDomainEvent : IEvent {\n    string Domain { get; }\n}\n// Example events\npublic abstract record OrderEvent(Guid EventId, DateTime Timestamp, string Domain) : IDomainEvent;\npublic record OrderPlaced(Guid EventId, DateTime Timestamp, Guid OrderId, decimal Total)\n    : OrderEvent(EventId, Timestamp, \"Orders\");\npublic record OrderShipped(Guid EventId, DateTime Timestamp, Guid OrderId, string TrackingNumber)\n    : OrderEvent(EventId, Timestamp, \"Orders\");\n// Generic method with interface constraint\n[WhizbangProjection]\npublic class EventAuditProjection {\n    private readonly List<EventAuditRecord> _auditLog = new();\n    // This ONE generic method handles ALL events implementing IEvent\n    public Task OnEvent<TEvent>([WhizbangSubscribe] TEvent @event, EventContext context, CancellationToken ct)\n        where TEvent : IEvent {\n        // Source generator creates separate registration for each concrete event type:\n        // - OnEvent<OrderPlaced>\n        // - OnEvent<OrderShipped>\n        // - OnEvent<InventoryAdjusted>\n        // - etc _auditLog Add(new EventAuditRecord {\n            EventId = @event EventId,\n            EventType = typeof(TEvent) Name,  // Concrete type name\n            Timestamp = @event Timestamp,\n            UserId = context Security UserId,\n            TenantId = context Security TenantId\n        });\n        return Task CompletedTask;\n    }\n}\n// Generic method with base class constraint\n[WhizbangProjection]\npublic class OrderEventLogProjection {\n    private readonly Dictionary<string, List<string>> _logsByDomain = new();\n    // Handles all OrderEvent-derived types\n    public Task LogOrderEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct)\n        where TEvent : OrderEvent {\n        if ( _logsByDomain ContainsKey(@event Domain)) {\n            _logsByDomain[@event Domain] = new List<string>();\n        }\n        _logsByDomain[@event Domain] Add(\n            $\"{@event Timestamp:O} - {typeof(TEvent) Name} - {@event EventId}\"\n        );\n        return Task",
        "startIndex": 7833,
        "preview": "generic methods to handle multiple event types with shared logic\" framework: \"NET8\" category: \"Projections\" difficulty: \"ADVANCED\" tags: [\"Projections..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-subscriptions-chunk-5",
        "text": "private readonly Dictionary<string, List<string>> _logsByDomain = new(); // Handles all OrderEvent-derived types public Task LogOrderEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct) where TEvent : OrderEvent { if ( _logsByDomain ContainsKey(@event Domain)) { _logsByDomain[@event Domain] = new List<string>(); } _logsByDomain[@event Domain] Add( $\"{@event Timestamp:O} - {typeof(TEvent) Name} - {@event EventId}\" ); return Task CompletedTask;\n    }\n}\npublic record EventAuditRecord {\n    public Guid EventId { get; init; }\n    public string EventType { get; init; }\n    public DateTime Timestamp { get; init; }\n    public Guid UserId { get; init; }\n    public Guid TenantId { get; init; }\n}\n`\nHow Generic Methods Work\nSource Generator Discovers Generic Methods: At compile time, finds all generic methods with [WhizbangSubscribe]\nCreates Registrations for Each Concrete Type: For every event type matching the generic constraint:\n   `csharp{\n   title: \"Generic Method Registration Example\"\n   description: \"How source generator creates registrations for generic subscription methods\"\n   framework: \"NET8\"\n   category: \"Projections\"\n   difficulty: \"ADVANCED\"\n   tags: [\"Projections\", \"Source Generation\", \"Generic Methods\"]\n   filename: \"SourceGenerationExample cs\"\n   usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\n   showLineNumbers: true\n   }\n   // You write this ONE generic method:\n   public Task OnEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct)\n       where TEvent : IEvent { }\n   // Source generator creates registrations for ALL event types:\n   services Subscribe<OrderPlaced, EventAuditProjection>(p => p OnEvent);\n   services Subscribe<OrderShipped, EventAuditProjection>(p => p OnEvent);\n   services Subscribe<InventoryAdjusted, EventAuditProjection>(p => p OnEvent);\n   // etc `\nType Safety Maintained: Generic constraints ensure only valid event types are registered\nMultiple Constraints Supported: Use where TEvent : class, IEvent, new() or any valid Cconstraint\nCombining Generic and Specific Methods\nMix generic and specific subscriptions in the same projection:\n`csharp{\ntitle: \"Hybrid Generic and Specific Subscriptions\"\ndescription: \"Combining generic catch-all methods with specific handlers\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Generics\", \"Hybrid Patterns\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"]\nusingStatements: [\"System\", \"System Threading\", \"System Threading",
        "startIndex": 10041,
        "preview": "private readonly Dictionary<string, List<string>> _logsByDomain = new(); // Handles all OrderEvent-derived types public Task LogOrderEvent<TEvent>([Wh..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-subscriptions-chunk-6",
        "text": "Generic and Specific Methods Mix generic and specific subscriptions in the same projection: `csharp{ title: \"Hybrid Generic and Specific Subscriptions\" description: \"Combining generic catch-all methods with specific handlers\" framework: \"NET8\" category: \"Projections\" difficulty: \"ADVANCED\" tags: [\"Projections\", \"Generics\", \"Hybrid Patterns\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Projections\"] usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading;\nusing System Threading Tasks;\n[WhizbangProjection]\npublic class HybridProjection {\n    // Generic catch-all for all events\n    public Task OnEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct)\n        where TEvent : IEvent {\n        // Log all events generically\n        Console WriteLine($\"Event received: {typeof(TEvent) Name}\");\n        return Task CompletedTask;\n    }\n    // Specific handler for OrderPlaced (takes precedence)\n    public Task OnOrderPlaced([WhizbangSubscribe] OrderPlaced @event, ProjectionContext projection, CancellationToken ct) {\n        // Special handling for OrderPlaced\n        Console WriteLine($\"Special handling for order: {@event OrderId}\");\n        return Task CompletedTask;\n    }\n    // Specific handler for high-priority events\n    public Task OnOrderCancelled([WhizbangSubscribe] OrderCancelled @event, CancellationToken ct) {\n        // Alert handling for cancellations\n        Console WriteLine($\"ALERT: Order cancelled - {@event Reason}\");\n        return Task CompletedTask;\n    }\n}\n`\nPrecedence Rules\nWhen multiple methods can handle an event, Whizbang invokes handlers in this order:\nExact type match (e g , OrderPlaced @event)\nBase class match (e g , OrderEvent @event)\nInterface match (e g , IEvent @event)\nGeneric with specific constraint (e g , TEvent where TEvent : OrderEvent)\nGeneric with general constraint (e g , TEvent where TEvent : IEvent)\nAll matching handlers are invoked in precedence order (most specific to least specific) `mermaid\ngraph TD\n    OrderPlaced[\"OrderPlaced Event<br/>(Concrete Type)\"]\n    subgraph Handlers[\"Projection Handlers (Invoked in Order)\"]\n        H1[\"1 OnOrderPlaced<br/>(Exact Match)<br/>⭐ Highest Priority\"]\n        H2[\"2 OnOrderEvent<br/>(Base Class Match)\"]\n        H3[\"3 OnDomainEvent<br/>(Interface Match)\"]\n        H4[\"4 OnEvent&lt;TEvent&gt; where TEvent : OrderEvent<br/>(Generic Specific)\"]\n        H5[\"5 OnEvent&lt;TEvent&gt; where TEvent : IEvent<br/>(Generic General)<br/>⭐ Lowest Priority\"]\n    end\n    OrderPlaced --> H1\n    OrderPlaced - -> H2\n    OrderPlaced - -> H3\n    OrderPlaced - -> H4\n    OrderPlaced -",
        "startIndex": 713,
        "preview": "Generic and Specific Methods Mix generic and specific subscriptions in the same projection: `csharp{ title: \"Hybrid Generic and Specific Subscriptions..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-subscriptions-chunk-7",
        "text": "Handlers (Invoked in Order)\"] H1[\"1 OnOrderPlaced<br/>(Exact Match)<br/>⭐ Highest Priority\"] H2[\"2 OnOrderEvent<br/>(Base Class Match)\"] H3[\"3 OnDomainEvent<br/>(Interface Match)\"] H4[\"4 OnEvent&lt;TEvent&gt; where TEvent : OrderEvent<br/>(Generic Specific)\"] H5[\"5 OnEvent&lt;TEvent&gt; where TEvent : IEvent<br/>(Generic General)<br/>⭐ Lowest Priority\"] end OrderPlaced --> H1 OrderPlaced - -> H2 OrderPlaced - -> H3 OrderPlaced - -> H4 OrderPlaced - -> H5\n    style OrderPlaced fill:#fff3cd,stroke:#ffc107,stroke-width:3px\n    style H1 fill:#d4edda,stroke:#28a745,stroke-width:2px\n    style H5 fill:#f8d7da,stroke:#dc3545,stroke-width:2px\n`\nBenefits of Polymorphic Subscriptions\nSingle Entry Point: One method handles all related events\nShared Logic: Common processing for all event types (logging, auditing, etc )\nType Safety: Pattern matching ensures all cases are handled\nFlexibility: Mix polymorphic and specific subscriptions as needed\nClean Code: Reduces boilerplate for related event types\nBenefits of Generic Methods\nDRY Principle: Write once, handle many event types\nShared Logic: Common processing for all events matching constraint\nType Safety: Generic constraints enforce compile-time safety\nAutomatic Registration: Source generator wires up all matching event types\nFlexibility: Combine with non-generic methods for specific overrides\nScalability: New event types automatically get handled without code changes\nValid Subscription Patterns\n`csharp{\ntitle: \"Valid Subscription Patterns\"\ndescription: \"Examples of all valid projection subscription patterns supported by Whizbang\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Subscriptions\", \"Patterns\", \"Examples\"]\nfilename: \"SubscriptionPatterns cs\"\nusingStatements: [\"System\", \"System Threading\", \"System Threading",
        "startIndex": 14332,
        "preview": "Handlers (Invoked in Order)\"] H1[\"1 OnOrderPlaced<br/>(Exact Match)<br/>⭐ Highest Priority\"] H2[\"2 OnOrderEvent<br/>(Base Class Match)\"] H3[\"3 OnDomai..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-subscriptions-chunk-8",
        "text": "overrides Scalability: New event types automatically get handled without code changes Valid Subscription Patterns `csharp{ title: \"Valid Subscription Patterns\" description: \"Examples of all valid projection subscription patterns supported by Whizbang\" framework: \"NET8\" category: \"Projections\" difficulty: \"INTERMEDIATE\" tags: [\"Projections\", \"Subscriptions\", \"Patterns\", \"Examples\"] filename: \"SubscriptionPatterns cs\" usingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\n// ✅ VALID - Specific event type\npublic Task Handle([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) { }\n// ✅ VALID - Base class subscription\npublic Task OnOrderEvent([WhizbangSubscribe] OrderEvent @event, CancellationToken ct) { }\n// ✅ VALID - Interface subscription\npublic Task HandleInventoryEvent([WhizbangSubscribe] IInventoryEvent @event, CancellationToken ct) { }\n// ✅ VALID - Generic method\npublic Task OnEvent<TEvent>([WhizbangSubscribe] TEvent @event, CancellationToken ct)\n    where TEvent : IEvent { }\n// ✅ VALID - With EventContext\npublic Task OnOrderPlaced([WhizbangSubscribe] OrderPlaced @event, EventContext context, CancellationToken ct) { }\n// ✅ VALID - With ProjectionContext\npublic Task OnOrderShipped([WhizbangSubscribe] OrderShipped @event, ProjectionContext projection, CancellationToken ct) { }\n// ✅ VALID - With both contexts\npublic Task WhenOrderPlaced(\n    [WhizbangSubscribe] OrderPlaced @event,\n    EventContext eventContext,\n    ProjectionContext projection,\n    CancellationToken ct) { }\n// ✅ VALID - With injected services (for querying, not mutation)\npublic Task ProcessOrder([WhizbangSubscribe] OrderPlaced @event, IOrderRepository repo, CancellationToken ct) { }\n// ❌ INVALID - Multiple subscriptions per method (compile error)\npublic Task OnOrderEvents([WhizbangSubscribe] OrderPlaced order, [WhizbangSubscribe] OrderShipped shipped) { }\n`\nAuto-Registration\nWhen you use [WhizbangSubscribe] on a method parameter, the source generator:\nDiscovers the subscription at compile time\nGenerates registration code linking the event type to the projection method\nAutomatically configures the service to route events to this projection\nNo manual registration needed - just mark with [WhizbangSubscribe]\n`mermaid\nsequenceDiagram\n    participant ES as Event Store\n    participant Router as Event Router\n    participant Proj1 as OrderProjection\n    participant Proj2 as AuditProjection\n    participant Store as Projection Store\n    ES->>Router: OrderPlaced event\n    Note over Router: Routes to all<br/>subscribed projections\n    Router->>Proj1: OnOrderPlaced(event, context)\n    Note over Proj1: ✅ Pure transformation<br/>Uses eventContext",
        "startIndex": 15706,
        "preview": "overrides Scalability: New event types automatically get handled without code changes Valid Subscription Patterns `csharp{ title: \"Valid Subscription ..."
      },
      {
        "id": "old-v1.0.0.0/projections/projection-subscriptions-chunk-9",
        "text": "- just mark with [WhizbangSubscribe] `mermaid sequenceDiagram participant ES as Event Store participant Router as Event Router participant Proj1 as OrderProjection participant Proj2 as AuditProjection participant Store as Projection Store ES->>Router: OrderPlaced event Note over Router: Routes to all<br/>subscribed projections Router->>Proj1: OnOrderPlaced(event, context) Note over Proj1: ✅ Pure transformation<br/>Uses eventContext System Timestamp\n    Proj1->>Store: CreateAsync(OrderSummary)\n    Store-->>Proj1: Success\n    Proj1-->>Router: Accepted\n    Router->>Proj2: OnEvent<OrderPlaced>(event, context)\n    Note over Proj2: Generic handler<br/>Logs all events\n    Proj2->>Store: CreateAsync(AuditRecord)\n    Store-->>Proj2: Success\n    Proj2-->>Router: Accepted\n    Router->>Router: All projections complete\n`\n`csharp{\ntitle: \"Auto-Registration Example\"\ndescription: \"How subscriptions are automatically registered by the source generator\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Auto-Registration\", \"Source Generation\"]\nfilename: \"AutoRegistrationExample cs\"\nusingStatements: [\"System\", \"System Threading\", \"System Threading Tasks\"]\nshowLineNumbers: true\n}\n// This subscription is automatically registered\npublic Task OnOrderPlaced([WhizbangSubscribe] OrderPlaced @event, CancellationToken ct) {\n    // Source generator creates registration code like:\n    // services Subscribe<OrderPlaced, OrderSummaryProjection>(\n    //     projection => projection OnOrderPlaced);\n}\n`\nNext Steps\nProjection Contexts - EventContext and ProjectionContext injection\nProjection Purity - Maintaining pure, deterministic projections\nProjection Return Values - Using return values for observability",
        "startIndex": 666,
        "preview": "- just mark with [WhizbangSubscribe] `mermaid sequenceDiagram participant ES as Event Store participant Router as Event Router participant Proj1 as Or..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/test-features",
    "title": "Test New Features",
    "category": "Test",
    "url": "/docs/old-v1.0.0.0/test-features",
    "chunks": [
      {
        "id": "old-v1.0.0.0/test-features-chunk-0",
        "text": "Test New Features\nThis page demonstrates the new interactive header and callout functionality.\nInteractive Headers\nEach header should have a link icon that appears on hover and allows copying the link to that section.\nSubsection with Custom ID {#custom-test-id}\nThis header has a custom ID defined in the markdown.\nNew Callout Examples\n:::new\nEnhanced Configuration\nThis is a new feature that provides advanced configuration options.\n:::\n:::updated\nConnection Pooling \nConnection pooling has been enhanced to support better performance.\n:::\n:::new{type=\"breaking\"}\nBreaking Change: API Format\nThe API format has changed in this version and requires migration.\n:::\n:::deprecated\nLegacy Configuration\nThe old configuration method is now deprecated and will be removed in future versions.\n:::\n:::planned{version=\"v1.2.0\" header=\"advanced-features\"}\nFuture Advanced Features\nThese features are planned for v1.2.0 and will provide advanced capabilities.\n:::\nRegular Content\nThis is regular markdown content that should render normally alongside the enhanced features.\nThe interactive headers allow users to:\nCopy direct links to any section\nShare specific parts of documentation\nNavigate more efficiently\nThe callouts provide clear visual indicators for:\nNew functionality\nUpdated features  \nBreaking changes\nDeprecated features\nPlanned future features",
        "startIndex": 0,
        "preview": "Test New Features\nThis page demonstrates the new interactive header and callout functionality.\nInteractive Headers\nEach header should have a link icon..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/usage-patterns/aspect-oriented-handlers",
    "title": "Aspect-Oriented Handlers",
    "category": "Usage Patterns",
    "url": "/docs/old-v1.0.0.0/usage-patterns/aspect-oriented-handlers",
    "chunks": [
      {
        "id": "old-v1.0.0.0/usage-patterns/aspect-oriented-handlers-chunk-0",
        "text": "Aspect-Oriented Handlers\nOverview\nAspect-Oriented Programming (AOP) in Whizbang allows you to cleanly separate cross-cutting concerns from your business logic Through source generators and declarative attributes, you can add logging, caching, validation, authorization, and other behaviors without cluttering your handler code Core Concepts\nAspects vs Traditional Approaches\nTraditional approach with manual cross-cutting concerns:\n`csharp\n// ❌ Traditional: Business logic mixed with infrastructure concerns\npublic class OrderHandler {\n    private readonly ILogger _logger;\n    private readonly ICache _cache;\n    private readonly IMetrics _metrics;\n    private readonly IValidator _validator;\n    public async Task<Result> Handle(CreateOrder cmd) {\n        // Validation\n        var validationResult = _validator Validate(cmd);\n        if ( validationResult IsValid) {\n            _logger Warning(\"Validation failed: {Errors}\", validationResult Errors);\n            return Result Failure(validationResult Errors);\n        }\n        // Logging\n        _logger Information(\"Processing order for customer {CustomerId}\", cmd CustomerId);\n        var stopwatch = Stopwatch StartNew();\n        try {\n            // Check cache\n            var cacheKey = $\"order:{cmd CustomerId}\";\n            var cached = await _cache GetAsync<Order>(cacheKey);\n            if (cached = null) {\n                _logger Debug(\"Cache hit for {CacheKey}\", cacheKey);\n                return Result Success(cached);\n            }\n            // FINALLY: Actual business logic (buried in infrastructure)\n            var order = CreateOrder(cmd);\n            // Update cache\n            await _cache SetAsync(cacheKey, order);\n            // Metrics\n            _metrics Increment(\"orders created\");\n            _metrics RecordDuration(\"order processing\", stopwatch Elapsed);\n            _logger Information(\"Order {OrderId} created successfully\", order Id);\n            return Result Success(order);\n        }\n        catch (Exception ex) {\n            _logger Error(ex, \"Failed to create order\");\n            _metrics Increment(\"orders failed\");\n            throw;\n        }\n    }\n}\n`\nWhizbang approach with aspects:\n`csharp\n// ✅ Whizbang: Pure business logic with declarative aspects\n[Validated]\n[Logged]\n[Cached(Duration = \"5m\")]\n[Timed]\n[Metered(\"orders\")]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // ONLY business logic - clean and focused\n        var order = CreateOrder(cmd);\n        return new OrderCreated(order Id, order Total);\n    }\n}\n`\nBuilt-in Aspects\nLogging Aspect\n`csharp{\ntitle: \"Logging Aspect\"\ndescription: \"Automatic structured logging for handlers\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"BEGINNER\"\ntags: [\"Logging\", \"Observability\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"LoggingAspect",
        "startIndex": 0,
        "preview": "Aspect-Oriented Handlers\nOverview\nAspect-Oriented Programming (AOP) in Whizbang allows you to cleanly separate cross-cutting concerns from your busine..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/aspect-oriented-handlers-chunk-1",
        "text": "// ONLY business logic - clean and focused var order = CreateOrder(cmd); return new OrderCreated(order Id, order Total); } } ` Built-in Aspects Logging Aspect `csharp{ title: \"Logging Aspect\" description: \"Automatic structured logging for handlers\" framework: \"NET8\" category: \"Aspects\" difficulty: \"BEGINNER\" tags: [\"Logging\", \"Observability\", \"Aspects\"] nugetPackages: [\"Whizbang Core\"] filename: \"LoggingAspect cs\"\nshowLineNumbers: true\nhighlightLines: [1, 2, 3]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Basic logging\n[Logged]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Automatically logs:\n        // - Handler execution start\n        // - Input parameters (redacted sensitive data)\n        // - Execution duration\n        // - Success/failure status\n        // - Return value summary\n        return new OrderCreated(cmd OrderId);\n    }\n}\n// Detailed logging with custom levels\n[Logged(\n    Level = LogLevel Debug,\n    LogInputs = true,\n    LogOutputs = true,\n    LogDuration = true\n)]\npublic class DetailedHandler : IHandle<ComplexOperation> {\n    public Result Handle(ComplexOperation cmd) {\n        return ProcessComplex(cmd);\n    }\n}\n// Conditional logging\n[Logged(\n    OnlyOnError = true,\n    IncludeStackTrace = true,\n    MaxDepth = 3  // How deep to serialize objects\n)]\npublic class ErrorFocusedHandler : IHandle<RiskyOperation> {\n    public Result Handle(RiskyOperation cmd) {\n        // Only logs when exception occurs\n        return PerformRiskyOperation(cmd);\n    }\n}\n// Custom log enrichment\n[Logged(Enricher = nameof(EnrichLog))]\npublic class EnrichedHandler : IHandle<BusinessOperation> {\n    public Result Handle(BusinessOperation cmd) {\n        return Process(cmd);\n    }\n    private void EnrichLog(LogContext context, BusinessOperation cmd) {\n        context AddProperty(\"TenantId\", cmd TenantId);\n        context AddProperty(\"Region\", GetRegion(cmd));\n        context AddProperty(\"Priority\", cmd Priority);\n    }\n}\n`\nValidation Aspect\n`csharp{\ntitle: \"Validation Aspect\"\ndescription: \"Automatic input validation using FluentValidation or DataAnnotations\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"BEGINNER\"\ntags: [\"Validation\", \"Input Validation\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"ValidationAspect cs\"\nshowLineNumbers: true\nhighlightLines: [1, 14, 27]\nusingStatements: [\"Whizbang\", \"System\", \"System ComponentModel",
        "startIndex": 2880,
        "preview": "// ONLY business logic - clean and focused var order = CreateOrder(cmd); return new OrderCreated(order Id, order Total); } } ` Built-in Aspects Loggin..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/aspect-oriented-handlers-chunk-2",
        "text": "GetRegion(cmd)); context AddProperty(\"Priority\", cmd Priority); } } ` Validation Aspect `csharp{ title: \"Validation Aspect\" description: \"Automatic input validation using FluentValidation or DataAnnotations\" framework: \"NET8\" category: \"Aspects\" difficulty: \"BEGINNER\" tags: [\"Validation\", \"Input Validation\", \"Aspects\"] nugetPackages: [\"Whizbang Core\"] filename: \"ValidationAspect cs\" showLineNumbers: true highlightLines: [1, 14, 27] usingStatements: [\"Whizbang\", \"System\", \"System ComponentModel DataAnnotations\"]\n}\n// Automatic validation with conventions\n[Validated]\npublic class CreateUserHandler : IHandle<CreateUser> {\n    public UserCreated Handle(CreateUser cmd) {\n        // Validation happens before this executes\n        // Looks for CreateUserValidator automatically\n        return new UserCreated(cmd Email);\n    }\n}\n// Explicit validator specification\n[Validated(Validator = typeof(CustomOrderValidator))]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        return new OrderCreated(cmd OrderId);\n    }\n}\n// Inline validation rules\n[Validated(\n    Rules = new[] {\n        \"Amount > 0\",\n        \"Currency = null\",\n        \"CustomerId = Guid Empty\"\n    }\n)]\npublic class PaymentHandler : IHandle<ProcessPayment> {\n    public PaymentProcessed Handle(ProcessPayment cmd) {\n        return new PaymentProcessed(cmd Amount);\n    }\n}\n// Combining with FluentValidation\npublic class CreateOrderValidator : AbstractValidator<CreateOrder> {\n    public CreateOrderValidator() {\n        RuleFor(x => x CustomerId) NotEmpty();\n        RuleFor(x => x Items) NotEmpty() Must(items => items All(i => i Quantity > 0));\n        RuleFor(x => x ShippingAddress) NotEmpty() MaximumLength(500);\n    }\n}\n[Validated] // Automatically uses CreateOrderValidator\npublic class ValidatedOrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nCaching Aspect\n`csharp{\ntitle: \"Caching Aspect\"\ndescription: \"Automatic result caching with flexible cache keys\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Caching\", \"Performance\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"CachingAspect cs\"\nshowLineNumbers: true\nhighlightLines: [1, 12, 24, 36]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Simple caching with duration\n[Cached(Duration = \"5m\")]\npublic class ProductHandler : IHandle<GetProduct> {\n    public Product Handle(GetProduct query) {\n        // Result cached for 5 minutes\n        // Cache key auto-generated from query properties\n        return database GetProduct(query",
        "startIndex": 4907,
        "preview": "GetRegion(cmd)); context AddProperty(\"Priority\", cmd Priority); } } ` Validation Aspect `csharp{ title: \"Validation Aspect\" description: \"Automatic in..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/aspect-oriented-handlers-chunk-3",
        "text": "Core\"] filename: \"CachingAspect cs\" showLineNumbers: true highlightLines: [1, 12, 24, 36] usingStatements: [\"Whizbang\", \"System\"] } // Simple caching with duration [Cached(Duration = \"5m\")] public class ProductHandler : IHandle<GetProduct> { public Product Handle(GetProduct query) { // Result cached for 5 minutes // Cache key auto-generated from query properties return database GetProduct(query ProductId);\n    }\n}\n// Custom cache key generation\n[Cached(\n    Duration = \"10m\",\n    KeyGenerator = nameof(GenerateCacheKey)\n)]\npublic class CustomKeyHandler : IHandle<ComplexQuery> {\n    public QueryResult Handle(ComplexQuery query) {\n        return ExecuteComplexQuery(query);\n    }\n    private string GenerateCacheKey(ComplexQuery query) {\n        return $\"complex:{query TenantId}:{query FilterHash}\";\n    }\n}\n// Sliding expiration cache\n[Cached(\n    Duration = \"1h\",\n    Mode = \"sliding\",  // Resets on each access\n    CacheNullResults = false\n)]\npublic class SlidingCacheHandler : IHandle<GetUserPreferences> {\n    public UserPreferences Handle(GetUserPreferences query) {\n        return userService GetPreferences(query UserId);\n    }\n}\n// Conditional caching\n[Cached(\n    Duration = \"30m\",\n    Condition = nameof(ShouldCache),\n    InvalidateOn = new[] { typeof(UserUpdated), typeof(UserDeleted) }\n)]\npublic class ConditionalCacheHandler : IHandle<GetUserProfile> {\n    public UserProfile Handle(GetUserProfile query) {\n        return userService GetProfile(query UserId);\n    }\n    private bool ShouldCache(GetUserProfile query) {\n        // Only cache for non-admin users\n        return query IsAdmin;\n    }\n}\n// Distributed cache\n[Cached(\n    Duration = \"1h\",\n    CacheType = \"distributed\",  // Redis, Memcached, etc SerializationFormat = \"msgpack\"\n)]\npublic class DistributedCacheHandler : IHandle<GetOrderHistory> {\n    public OrderHistory Handle(GetOrderHistory query) {\n        return orderService GetHistory(query CustomerId);\n    }\n}\n`\nAuthorization Aspect\n`csharp{\ntitle: \"Authorization Aspect\"\ndescription: \"Declarative security with fine-grained access control\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Authorization\", \"Security\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"AuthorizationAspect",
        "startIndex": 7083,
        "preview": "Core\"] filename: \"CachingAspect cs\" showLineNumbers: true highlightLines: [1, 12, 24, 36] usingStatements: [\"Whizbang\", \"System\"] } // Simple caching ..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/aspect-oriented-handlers-chunk-4",
        "text": "SerializationFormat = \"msgpack\" )] public class DistributedCacheHandler : IHandle<GetOrderHistory> { public OrderHistory Handle(GetOrderHistory query) { return orderService GetHistory(query CustomerId); } } ` Authorization Aspect `csharp{ title: \"Authorization Aspect\" description: \"Declarative security with fine-grained access control\" framework: \"NET8\" category: \"Aspects\" difficulty: \"INTERMEDIATE\" tags: [\"Authorization\", \"Security\", \"Aspects\"] nugetPackages: [\"Whizbang Core\"] filename: \"AuthorizationAspect cs\"\nshowLineNumbers: true\nhighlightLines: [1, 10, 19, 30]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Role-based authorization\n[Authorized(Roles = \"Admin,Manager\")]\npublic class AdminHandler : IHandle<AdminCommand> {\n    public Result Handle(AdminCommand cmd) {\n        // Only admins and managers can execute\n        return PerformAdminAction(cmd);\n    }\n}\n// Policy-based authorization\n[Authorized(Policy = \"CanEditOrders\")]\npublic class OrderEditHandler : IHandle<EditOrder> {\n    public OrderUpdated Handle(EditOrder cmd) {\n        // Policy evaluated before execution\n        return UpdateOrder(cmd);\n    }\n}\n// Resource-based authorization\n[Authorized(Resource = nameof(GetOrderResource))]\npublic class OrderAccessHandler : IHandle<GetOrder> {\n    public Order Handle(GetOrder query) {\n        return orderService Get(query OrderId);\n    }\n    private object GetOrderResource(GetOrder query) {\n        return new { Type = \"Order\", Id = query OrderId };\n    }\n}\n// Custom authorization logic\n[Authorized(Authorizer = typeof(CustomOrderAuthorizer))]\npublic class CustomAuthHandler : IHandle<SensitiveOperation> {\n    public Result Handle(SensitiveOperation cmd) {\n        return ExecuteSensitive(cmd);\n    }\n}\npublic class CustomOrderAuthorizer : IAuthorizer<SensitiveOperation> {\n    public Task<bool> AuthorizeAsync(SensitiveOperation cmd, IUser user) {\n        // Custom authorization logic\n        if (user IsInRole(\"Admin\")) return Task FromResult(true);\n        if (cmd OwnerId == user Id) return Task FromResult(true);\n        if (user HasPermission(\"sensitive execute\")) return Task FromResult(true);\n        return Task FromResult(false);\n    }\n}\n`\nTransactional Aspect\n`csharp{\ntitle: \"Transactional Aspect\"\ndescription: \"Automatic transaction management with various isolation levels\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Transactions\", \"Database\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"TransactionalAspect cs\"\nshowLineNumbers: true\nhighlightLines: [1, 11, 22, 35]\nusingStatements: [\"Whizbang\", \"System\", \"System Data\"]\n}\n// Simple transaction\n[Transactional]\npublic class TransferHandler : IHandle<TransferMoney> {\n    public TransferCompleted Handle(TransferMoney cmd, IAccountService accounts) {\n        // Entire operation wrapped in transaction\n        accounts Debit(cmd FromAccount, cmd Amount);\n        accounts Credit(cmd ToAccount, cmd",
        "startIndex": 8947,
        "preview": "SerializationFormat = \"msgpack\" )] public class DistributedCacheHandler : IHandle<GetOrderHistory> { public OrderHistory Handle(GetOrderHistory query)..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/aspect-oriented-handlers-chunk-5",
        "text": "[\"Whizbang Core\"] filename: \"TransactionalAspect cs\" showLineNumbers: true highlightLines: [1, 11, 22, 35] usingStatements: [\"Whizbang\", \"System\", \"System Data\"] } // Simple transaction [Transactional] public class TransferHandler : IHandle<TransferMoney> { public TransferCompleted Handle(TransferMoney cmd, IAccountService accounts) { // Entire operation wrapped in transaction accounts Debit(cmd FromAccount, cmd Amount); accounts Credit(cmd ToAccount, cmd Amount);\n        return new TransferCompleted(cmd TransferId);\n    }\n}\n// Transaction with specific isolation level\n[Transactional(\n    IsolationLevel = IsolationLevel ReadCommitted,\n    Timeout = \"30s\"\n)]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Executes with ReadCommitted isolation\n        return CreateOrderWithInventory(cmd);\n    }\n}\n// Nested transaction support\n[Transactional(AllowNested = true)]\npublic class ParentHandler : IHandle<ParentCommand> {\n    public Result Handle(ParentCommand cmd, IWhizbang whizbang) {\n        // Start transaction\n        var result1 = ProcessFirst(cmd);\n        // This creates a nested transaction\n        var result2 = whizbang Send(new ChildCommand());\n        return CombineResults(result1, result2);\n    }\n}\n// Distributed transaction\n[Transactional(\n    Mode = \"distributed\",\n    Coordinator = \"saga\"\n)]\npublic class DistributedHandler : IHandle<CrossServiceCommand> {\n    public async Task<Result> Handle(CrossServiceCommand cmd) {\n        // Coordinates transaction across services\n        await orderService CreateOrder(cmd Order);\n        await inventoryService ReserveStock(cmd Items);\n        await paymentService ProcessPayment(cmd Payment);\n        return Result Success();\n    }\n}\n`\nPerformance Aspects\n`csharp{\ntitle: \"Performance Aspects\"\ndescription: \"Timing, metrics, and performance monitoring\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Performance\", \"Metrics\", \"Monitoring\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"PerformanceAspects",
        "startIndex": 11362,
        "preview": "[\"Whizbang Core\"] filename: \"TransactionalAspect cs\" showLineNumbers: true highlightLines: [1, 11, 22, 35] usingStatements: [\"Whizbang\", \"System\", \"Sy..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/aspect-oriented-handlers-chunk-6",
        "text": "// Coordinates transaction across services await orderService CreateOrder(cmd Order); await inventoryService ReserveStock(cmd Items); await paymentService ProcessPayment(cmd Payment); return Result Success(); } } ` Performance Aspects `csharp{ title: \"Performance Aspects\" description: \"Timing, metrics, and performance monitoring\" framework: \"NET8\" category: \"Aspects\" difficulty: \"INTERMEDIATE\" tags: [\"Performance\", \"Metrics\", \"Monitoring\"] nugetPackages: [\"Whizbang Core\"] filename: \"PerformanceAspects cs\"\nshowLineNumbers: true\nhighlightLines: [1, 2, 3]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Comprehensive performance monitoring\n[Timed]\n[Metered(\"orders\")]\n[Traced]\npublic class MonitoredHandler : IHandle<ProcessOrder> {\n    public OrderProcessed Handle(ProcessOrder cmd) {\n        // Automatically tracks:\n        // - Execution duration (Timed)\n        // - Success/failure counts (Metered)\n        // - Distributed trace span (Traced)\n        return ProcessOrder(cmd);\n    }\n}\n// Detailed timing with percentiles\n[Timed(\n    RecordPercentiles = new[] { 50, 90, 95, 99 },\n    PublishHistogram = true,\n    BucketSize = \"100ms\"\n)]\npublic class DetailedTimingHandler : IHandle<ComplexCalculation> {\n    public CalculationResult Handle(ComplexCalculation cmd) {\n        return PerformCalculation(cmd);\n    }\n}\n// Custom metrics\n[Metered(\n    Namespace = \"business orders\",\n    RecordErrors = true,\n    RecordDuration = true,\n    Tags = new[] { \"region\", \"customer_type\" }\n)]\npublic class MeteredHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Publishes metrics:\n        // - business orders count\n        // - business orders errors\n        // - business orders duration\n        // Tagged with region and customer_type\n        return CreateOrder(cmd);\n    }\n}\n`\nCustom Aspects\nCreating Custom Aspects\n`csharp{\ntitle: \"Custom Aspect Implementation\"\ndescription: \"Build your own aspects for specific concerns\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"ADVANCED\"\ntags: [\"Custom Aspects\", \"Extensibility\", \"Source Generators\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"CustomAspects cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Define custom aspect attribute\n[AttributeUsage(AttributeTargets Class | AttributeTargets",
        "startIndex": 12964,
        "preview": "// Coordinates transaction across services await orderService CreateOrder(cmd Order); await inventoryService ReserveStock(cmd Items); await paymentSer..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/aspect-oriented-handlers-chunk-7",
        "text": "Aspects Creating Custom Aspects `csharp{ title: \"Custom Aspect Implementation\" description: \"Build your own aspects for specific concerns\" framework: \"NET8\" category: \"Aspects\" difficulty: \"ADVANCED\" tags: [\"Custom Aspects\", \"Extensibility\", \"Source Generators\"] nugetPackages: [\"Whizbang Core\"] filename: \"CustomAspects cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"System\"] } // Define custom aspect attribute [AttributeUsage(AttributeTargets Class | AttributeTargets Method)]\npublic class AuditedAttribute : AspectAttribute {\n    public bool IncludeResult { get; set; } = false;\n    public string AuditTable { get; set; } = \"AuditLog\";\n}\n// Source generator creates this implementation\n[SourceGenerated]\ninternal class AuditedAspect : IAspect {\n    private readonly IAuditService _auditService;\n    public async Task<T> InterceptAsync<T>(\n        AspectContext context,\n        Func<Task<T>> next) {\n        // Before execution\n        var auditEntry = new AuditEntry {\n            UserId = context User Id,\n            Operation = context HandlerName,\n            Input = SerializeInput(context Message),\n            Timestamp = DateTime UtcNow\n        };\n        try {\n            // Execute handler\n            var result = await next();\n            // After execution\n            auditEntry Success = true;\n            if (context Attribute IncludeResult) {\n                auditEntry Output = SerializeOutput(result);\n            }\n            return result;\n        }\n        catch (Exception ex) {\n            auditEntry Success = false;\n            auditEntry Error = ex Message;\n            throw;\n        }\n        finally {\n            // Always audit\n            await _auditService LogAsync(\n                context Attribute AuditTable, \n                auditEntry\n            );\n        }\n    }\n}\n// Use custom aspect\n[Audited(IncludeResult = true, AuditTable = \"OrderAudits\")]\npublic class AuditedOrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nAspect Composition\n`csharp{\ntitle: \"Composing Multiple Aspects\"\ndescription: \"Combining aspects for comprehensive behavior\"\nframework: \"NET8\"\ncategory: \"Aspects\"\ndifficulty: \"ADVANCED\"\ntags: [\"Aspect Composition\", \"Ordering\", \"Dependencies\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"AspectComposition cs\"\nshowLineNumbers: true\nhighlightLines: [1, 2, 3, 4, 5, 6]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Aspects execute in order of declaration\n[Logged]                    // 1 Outermost - logs everything\n[Timed]                     // 2 Times the entire operation\n[Authorized]                // 3 Check authorization\n[Validated]                 // 4 Validate inputs\n[Transactional]            // 5",
        "startIndex": 14764,
        "preview": "Aspects Creating Custom Aspects `csharp{ title: \"Custom Aspect Implementation\" description: \"Build your own aspects for specific concerns\" framework: ..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/aspect-oriented-handlers-chunk-8",
        "text": "filename: \"AspectComposition cs\" showLineNumbers: true highlightLines: [1, 2, 3, 4, 5, 6] usingStatements: [\"Whizbang\", \"System\"] } // Aspects execute in order of declaration [Logged] // 1 Outermost - logs everything [Timed] // 2 Times the entire operation [Authorized] // 3 Check authorization [Validated] // 4 Validate inputs [Transactional] // 5 Start transaction\n[Cached(Duration = \"10m\")]  // 6 Innermost - check cache first\npublic class FullyAspectedHandler : IHandle<ComplexQuery> {\n    public QueryResult Handle(ComplexQuery query) {\n        // Execution flow:\n        // → Logging starts\n        //   → Timer starts\n        //     → Authorization check\n        //       → Input validation\n        //         → Transaction begins\n        //           → Cache check (hit = early return)\n        //             → Handler executes\n        //           ← Cache stores result\n        //         ← Transaction commits\n        //       ← Validation complete\n        //     ← Authorization complete\n        //   ← Timer stops\n        // ← Logging ends\n        return ExecuteComplexQuery(query);\n    }\n}\n// Conditional aspect composition\n[ConditionalAspect(typeof(CachedAttribute), Condition = nameof(IsReadOperation))]\n[ConditionalAspect(typeof(TransactionalAttribute), Condition = nameof(IsWriteOperation))]\npublic class AdaptiveHandler : IHandle<DynamicCommand> {\n    public Result Handle(DynamicCommand cmd) {\n        return ProcessDynamic(cmd);\n    }\n    private bool IsReadOperation(DynamicCommand cmd) => cmd IsQuery;\n    private bool IsWriteOperation(DynamicCommand cmd) => cmd IsQuery;\n}\n// Aspect dependencies\n[RequiresAspect(typeof(LoggedAttribute))]  // Must have Logged\npublic class DependentAuditAttribute : AspectAttribute { }\n[Logged]\n[DependentAudit]  // OK - Logged is present\npublic class ValidHandler : IHandle<Command> { }\n// [DependentAudit]  // Compile error - Missing required Logged aspect\npublic class InvalidHandler : IHandle<Command> { }\n`\nTesting with Aspects\n`csharp{\ntitle: \"Testing Aspect Behavior\"\ndescription: \"Verify aspects work correctly in isolation and composition\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Testing\", \"Aspects\", \"Unit Tests\"]\nnugetPackages: [\"Whizbang Core\", \"xUnit\"]\nfilename: \"AspectTests cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang Testing\", \"Xunit\"]\n}\n[Fact]\npublic async Task CacheAspect_CachesResult() {\n    // Arrange\n    var test = await Whizbang Test<ProductHandler>() WithAspect<CachedAttribute>() Given(new GetProduct { ProductId = \"123\" });\n    // Act - First call\n    var result1 = await test",
        "startIndex": 17064,
        "preview": "filename: \"AspectComposition cs\" showLineNumbers: true highlightLines: [1, 2, 3, 4, 5, 6] usingStatements: [\"Whizbang\", \"System\"] } // Aspects execute..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/aspect-oriented-handlers-chunk-9",
        "text": "[\"Testing\", \"Aspects\", \"Unit Tests\"] nugetPackages: [\"Whizbang Core\", \"xUnit\"] filename: \"AspectTests cs\" showLineNumbers: true usingStatements: [\"Whizbang Testing\", \"Xunit\"] } [Fact] public async Task CacheAspect_CachesResult() { // Arrange var test = await Whizbang Test<ProductHandler>() WithAspect<CachedAttribute>() Given(new GetProduct { ProductId = \"123\" }); // Act - First call var result1 = await test WhenHandled();\n    // Act - Second call\n    var result2 = await test WhenHandled();\n    // Assert\n    Assert Same(result1, result2);  // Same instance\n    test Aspect<CachedAttribute>() Should() HaveHitCache() OnSecondCall();\n    test Handler Should() HaveBeenCalledOnce();  // Not twice\n}\n[Fact]\npublic async Task ValidationAspect_RejectsInvalidInput() {\n    // Arrange\n    var test = await Whizbang Test<CreateUserHandler>() WithAspect<ValidatedAttribute>() Given(new CreateUser { Email = \"invalid\" });\n    // Act & Assert\n    await test WhenHandled() Should() FailValidation() WithError(\"Email\", \"Invalid email format\");\n    test Handler Should() NotHaveBeenCalled();\n}\n[Fact]\npublic async Task TransactionalAspect_RollsBackOnError() {\n    // Arrange\n    var test = await Whizbang Test<TransferHandler>() WithAspect<TransactionalAttribute>() WithDatabase(db) Given(new TransferMoney { Amount = 100 });\n    // Act - Force error\n    test Handler ThrowsOn(2);  // Throw on second operation\n    // Assert\n    await test WhenHandled() Should() Throw<Exception>();\n    test Database Should() HaveNoChanges();  // Rolled back\n    test Aspect<TransactionalAttribute>() Should() HaveRolledBack();\n}\n// Test aspect ordering\n[Fact]\npublic async Task Aspects_ExecuteInCorrectOrder() {\n    // Arrange\n    var test = await Whizbang Test<FullyAspectedHandler>() WithAllAspects() RecordExecutionOrder();\n    // Act\n    await test WhenHandled(new ComplexQuery());\n    // Assert\n    test ExecutionOrder Should() BeInOrder(\n        \"LoggedAspect Before\",\n        \"TimedAspect Before\",\n        \"AuthorizedAspect Before\",\n        \"ValidatedAspect Before\",\n        \"TransactionalAspect Before\",\n        \"CachedAspect Before\",\n        \"Handler Execute\",\n        \"CachedAspect After\",\n        \"TransactionalAspect After\",\n        \"ValidatedAspect After\",\n        \"AuthorizedAspect After\",\n        \"TimedAspect After\",\n        \"LoggedAspect After\"\n    );\n}\n`\nPerformance Considerations\nSource Generation\n`csharp{\ntitle: \"Zero-Overhead Aspects via Source Generation\"\ndescription: \"How source generators eliminate aspect overhead\"\nframework: \"NET8\"\ncategory: \"Performance\"\ndifficulty: \"ADVANCED\"\ntags: [\"Source Generators\", \"Performance\", \"Compilation\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"SourceGeneration",
        "startIndex": 19337,
        "preview": "[\"Testing\", \"Aspects\", \"Unit Tests\"] nugetPackages: [\"Whizbang Core\", \"xUnit\"] filename: \"AspectTests cs\" showLineNumbers: true usingStatements: [\"Whi..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/aspect-oriented-handlers-chunk-10",
        "text": "Execute\", \"CachedAspect After\", \"TransactionalAspect After\", \"ValidatedAspect After\", \"AuthorizedAspect After\", \"TimedAspect After\", \"LoggedAspect After\" ); } ` Performance Considerations Source Generation `csharp{ title: \"Zero-Overhead Aspects via Source Generation\" description: \"How source generators eliminate aspect overhead\" framework: \"NET8\" category: \"Performance\" difficulty: \"ADVANCED\" tags: [\"Source Generators\", \"Performance\", \"Compilation\"] nugetPackages: [\"Whizbang Core\"] filename: \"SourceGeneration cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// What you write\n[Logged]\n[Cached(Duration = \"5m\")]\npublic class UserHandler : IHandle<GetUser> {\n    public User Handle(GetUser query) {\n        return database GetUser(query UserId);\n    }\n}\n// What source generator produces\n[SourceGenerated]\ninternal class UserHandler_Generated : IHandle<GetUser> {\n    private readonly UserHandler _inner;\n    private readonly ILogger _logger;\n    private readonly ICache _cache;\n    public User Handle(GetUser query) {\n        // Inlined logging\n        _logger LogInformation(\"Executing UserHandler with {UserId}\", query UserId);\n        var stopwatch = Stopwatch StartNew();\n        try {\n            // Inlined caching\n            var cacheKey = $\"user:{query UserId}\";\n            if (_cache TryGet<User>(cacheKey, out var cached)) {\n                _logger LogDebug(\"Cache hit for {Key}\", cacheKey);\n                return cached;\n            }\n            // Call actual handler\n            var result = _inner Handle(query);\n            // Store in cache\n            _cache Set(cacheKey, result, TimeSpan FromMinutes(5));\n            _logger LogInformation(\"UserHandler completed in {Duration}ms\", \n                stopwatch ElapsedMilliseconds);\n            return result;\n        }\n        catch (Exception ex) {\n            _logger LogError(ex, \"UserHandler failed\");\n            throw;\n        }\n    }\n}\n`\nBest Practices\nDo's\n✅ Use aspects for cross-cutting concerns\n`csharp{\ntitle: \"Use Aspects for Cross-Cutting Concerns\"\ndescription: \"Apply aspects for infrastructure concerns like logging, validation, and caching\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Usage Patterns\", \"AOP\", \"Cross-Cutting\", \"Best Practices\"]\nfilename: \"AspectUsage cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[Logged]\n[Validated]\n[Cached]\n`\n✅ Keep handlers focused on business logic\n`csharp{\ntitle: \"Keep Handlers Focused on Business Logic\"\ndescription: \"Handlers should contain only business logic with aspects handling infrastructure\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Usage Patterns\", \"AOP\", \"Clean Code\", \"Best Practices\"]\nfilename: \"FocusedHandler",
        "startIndex": 21745,
        "preview": "Execute\", \"CachedAspect After\", \"TransactionalAspect After\", \"ValidatedAspect After\", \"AuthorizedAspect After\", \"TimedAspect After\", \"LoggedAspect Aft..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/aspect-oriented-handlers-chunk-11",
        "text": "[\"Whizbang\", \"System\"] } [Logged] [Validated] [Cached] ` ✅ Keep handlers focused on business logic `csharp{ title: \"Keep Handlers Focused on Business Logic\" description: \"Handlers should contain only business logic with aspects handling infrastructure\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"BEGINNER\" tags: [\"Usage Patterns\", \"AOP\", \"Clean Code\", \"Best Practices\"] filename: \"FocusedHandler cs\"\nshowLineNumbers: true\nusingStatements: [\"System\"]\n}\npublic OrderCreated Handle(CreateOrder cmd) {\n    // Only business logic, no infrastructure\n    return CreateOrder(cmd);\n}\n`\n✅ Order aspects correctly\n`csharp{\ntitle: \"Order Aspects Correctly\"\ndescription: \"Proper ordering of aspects for logical execution flow\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"AOP\", \"Aspect Ordering\", \"Best Practices\"]\nfilename: \"AspectOrdering cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[Logged]        // Outermost - see everything\n[Authorized]    // Check auth before validation\n[Validated]     // Validate before execution\n[Transactional] // Wrap actual work\n`\n✅ Test aspects in isolation\n`csharp{\ntitle: \"Test Aspects in Isolation\"\ndescription: \"Test aspect behavior separately from business logic\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"AOP\", \"Testing\", \"Best Practices\"]\nfilename: \"AspectTesting cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang Testing\", \"System Threading Tasks\"]\n}\nawait Test<Handler>() WithAspect<CachedAttribute>() VerifyBehavior();\n`\nDon'ts\n❌ Don't mix aspects with manual concerns\n`csharp{\ntitle: \"Don't Mix Aspects with Manual Concerns\"\ndescription: \"Avoid redundant manual logging when using logging aspects\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Usage Patterns\", \"AOP\", \"Anti-Patterns\", \"Best Practices\"]\nfilename: \"AspectAntiPatterns cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[Logged]\npublic Result Handle(Command cmd) {\n    _logger Log(\"Starting\");  // Don't - redundant with aspect\n}\n`\n❌ Don't create aspects for business logic\n`csharp{\ntitle: \"Don't Create Aspects for Business Logic\"\ndescription: \"Aspects should be for cross-cutting concerns, not business logic\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Usage Patterns\", \"AOP\", \"Anti-Patterns\", \"Business Logic\"]\nfilename: \"BusinessLogicAspect",
        "startIndex": 23995,
        "preview": "[\"Whizbang\", \"System\"] } [Logged] [Validated] [Cached] ` ✅ Keep handlers focused on business logic `csharp{ title: \"Keep Handlers Focused on Business ..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/aspect-oriented-handlers-chunk-12",
        "text": "Log(\"Starting\"); // Don't - redundant with aspect } ` ❌ Don't create aspects for business logic `csharp{ title: \"Don't Create Aspects for Business Logic\" description: \"Aspects should be for cross-cutting concerns, not business logic\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"BEGINNER\" tags: [\"Usage Patterns\", \"AOP\", \"Anti-Patterns\", \"Business Logic\"] filename: \"BusinessLogicAspect cs\"\nshowLineNumbers: true\nusingStatements: [\"System\"]\n}\n[CalculateTax]  // Bad - business logic not cross-cutting\n`\n❌ Don't ignore aspect overhead in hot paths\n`csharp{\ntitle: \"Consider Aspect Overhead\"\ndescription: \"Be careful with verbose aspects in performance-critical paths\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"AOP\", \"Performance\", \"Best Practices\"]\nfilename: \"AspectPerformance cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[Logged(LogInputs = true)]  // Careful with large objects\npublic Result Handle(LargeDataQuery query)\n`\nReal-World Example\n`csharp{\ntitle: \"Complete E-Commerce Handler with Aspects\"\ndescription: \"Production-ready handler showcasing multiple aspects\"\nframework: \"NET8\"\ncategory: \"Real World\"\ndifficulty: \"ADVANCED\"\ntags: [\"E-Commerce\", \"Production\", \"Complete Example\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"ECommerceHandler cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Order processing with comprehensive aspects\n[Logged(Level = LogLevel Information)]\n[Timed(PublishHistogram = true)]\n[Metered(\"orders checkout\")]\n[Authorized(Policy = \"CanCreateOrders\")]\n[Validated]\n[RateLimited(Permits = 100, Window = \"1m\")]\n[Transactional(IsolationLevel = IsolationLevel ReadCommitted)]\n[Retry(3, Backoff = \"exponential\")]\n[CircuitBreaker(Threshold = 10, Duration = \"30s\")]\n[Traced(IncludeHeaders = true)]\npublic class CheckoutHandler : IHandle<Checkout> {\n    public CheckoutCompleted Handle(Checkout cmd, \n        IInventoryService inventory,\n        IPaymentService payment,\n        IShippingService shipping) {\n        // Pure business logic - all concerns handled by aspects\n        // Reserve inventory\n        var reservation = inventory Reserve(cmd Items);\n        // Process payment\n        var transaction = payment Charge(\n            cmd PaymentMethod, \n            cmd Total\n        );\n        // Create shipment\n        var shipment = shipping CreateShipment(\n            cmd ShippingAddress,\n            cmd Items\n        );\n        // Return completed checkout\n        return new CheckoutCompleted {\n            OrderId = Guid NewGuid(),\n            ReservationId = reservation Id,\n            TransactionId = transaction Id,\n            ShipmentId = shipment Id,\n            EstimatedDelivery = shipment",
        "startIndex": 26065,
        "preview": "Log(\"Starting\"); // Don't - redundant with aspect } ` ❌ Don't create aspects for business logic `csharp{ title: \"Don't Create Aspects for Business Log..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/aspect-oriented-handlers-chunk-13",
        "text": "var transaction = payment Charge( cmd PaymentMethod, cmd Total ); // Create shipment var shipment = shipping CreateShipment( cmd ShippingAddress, cmd Items ); // Return completed checkout return new CheckoutCompleted { OrderId = Guid NewGuid(), ReservationId = reservation Id, TransactionId = transaction Id, ShipmentId = shipment Id, EstimatedDelivery = shipment EstimatedDelivery\n        };\n    }\n}\n// Query handler with read-optimized aspects\n[Logged(OnlyOnError = true)]\n[Cached(Duration = \"15m\", Mode = \"sliding\")]\n[Compressed]\n[Traced]\npublic class OrderHistoryHandler : IHandle<GetOrderHistory> {\n    public OrderHistory Handle(GetOrderHistory query) {\n        // Cached and compressed for performance\n        return orderService GetHistory(\n            query CustomerId,\n            query StartDate,\n            query EndDate\n        );\n    }\n}\n`\nNext Steps\nExplore Progressive Enhancement for scaling patterns\nLearn about Policy Composition for resilience\nReview Testing Strategies for aspect testing\nSee Source Generators for implementation details",
        "startIndex": 28418,
        "preview": "var transaction = payment Charge( cmd PaymentMethod, cmd Total ); // Create shipment var shipment = shipping CreateShipment( cmd ShippingAddress, cmd ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/usage-patterns/cqrs-implementation",
    "title": "CQRS Implementation",
    "category": "Usage Patterns",
    "url": "/docs/old-v1.0.0.0/usage-patterns/cqrs-implementation",
    "chunks": [
      {
        "id": "old-v1.0.0.0/usage-patterns/cqrs-implementation-chunk-0",
        "text": "CQRS Implementation\nOverview\nCommand Query Responsibility Segregation (CQRS) is a pattern that uses separate models for reading and writing data Whizbang provides first-class support for CQRS, allowing you to optimize reads and writes independently while maintaining consistency through event-driven projections What is CQRS CQRS separates your application into two distinct paths:\nCommand Side: Handles writes, enforces business rules, generates events\nQuery Side: Handles reads from optimized, denormalized read models\nBenefits of CQRS\nPerformance: Optimize reads and writes independently\nScalability: Scale read and write sides separately\nFlexibility: Different storage technologies for different needs\nSimplicity: Simpler models focused on specific tasks\nEvolution: Change read models without affecting writes\nArchitecture Diagram\n`mermaid\ngraph TB\n    subgraph \"Write Side\"\n        CMD[Commands] --> CH[Command Handlers]\n        CH --> AGG[Aggregates]\n        AGG --> ES[(Event Store)]\n    end\n    subgraph \"Read Side\"\n        ES --> PROJ[Projections]\n        PROJ --> RM1[(Order List)]\n        PROJ --> RM2[(Customer View)]\n        PROJ --> RM3[(Analytics)]\n        Q[Queries] --> QH[Query Handlers]\n        QH --> RM1\n        QH --> RM2\n        QH --> RM3\n    end\n    style ES fill:#0066cc,color:#fff\n    style PROJ fill:#28a745,color:#fff\n`\nCore Components\nRequired Packages\n`xml{\ntitle: \"Required NuGet Packages\"\ndescription: \"Core packages needed for CQRS implementation with Whizbang\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Usage Patterns\", \"CQRS\", \"NuGet Packages\"]\nfilename: \"ProjectFile csproj\"\nshowLineNumbers: true\n}\n<PackageReference Include=\"Whizbang Core\" Version=\"1 0 0\" />\n<PackageReference Include=\"Whizbang EventSourcing\" Version=\"1 0 0\" />\n<PackageReference Include=\"Whizbang Projections\" Version=\"1 0 0\" />\n`\nKey Concepts\nWrite Model: Aggregates that enforce business rules\nRead Model: Denormalized views optimized for queries\nProjection: Process that builds read models from events\nEventually Consistent: Read models update asynchronously\nQuery Handler: Returns data from read models\nStep-by-Step Implementation\nStep 1: Define Read Models\n`csharp{\ntitle: \"Read Model Definitions\"\ndescription: \"Create denormalized read models optimized for specific queries\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Read Models\", \"Projections\", \"Query Models\"]\nnugetPackages: [\"Whizbang Projections\"]\nfilename: \"OrderReadModels",
        "startIndex": 0,
        "preview": "CQRS Implementation\nOverview\nCommand Query Responsibility Segregation (CQRS) is a pattern that uses separate models for reading and writing data Whizb..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/cqrs-implementation-chunk-1",
        "text": "Consistent: Read models update asynchronously Query Handler: Returns data from read models Step-by-Step Implementation Step 1: Define Read Models `csharp{ title: \"Read Model Definitions\" description: \"Create denormalized read models optimized for specific queries\" framework: \"NET8\" category: \"CQRS\" difficulty: \"INTERMEDIATE\" tags: [\"Read Models\", \"Projections\", \"Query Models\"] nugetPackages: [\"Whizbang Projections\"] filename: \"OrderReadModels cs\"\nshowLineNumbers: true\nhighlightLines: [9, 25, 41]\nusingStatements: [\"Whizbang Projections\", \"System\", \"System Collections Generic\"]\n}\nusing Whizbang Projections;\nusing System;\nusing System Collections Generic;\nnamespace MyApp Orders ReadModels;\n// Read model for order list/search\n[ReadModel(\"OrderList\")]\npublic class OrderListItem {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    public string CustomerName { get; set; }\n    public decimal TotalAmount { get; set; }\n    public string Status { get; set; }\n    public DateTime CreatedAt { get; set; }\n    public DateTime",
        "startIndex": 2506,
        "preview": "Consistent: Read models update asynchronously Query Handler: Returns data from read models Step-by-Step Implementation Step 1: Define Read Models `csh..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/cqrs-implementation-chunk-2",
        "text": "list/search [ReadModel(\"OrderList\")] public class OrderListItem { public Guid OrderId { get; set; } public Guid CustomerId { get; set; } public string CustomerName { get; set; } public decimal TotalAmount { get; set; } public string Status { get; set; } public DateTime CreatedAt { get; set; } public DateTime ShippedAt { get; set; }\n    // Denormalized data for fast queries\n    public int ItemCount { get; set; }\n    public string FirstItemName { get; set; }\n    public bool IsHighValue { get; set; } // TotalAmount > 1000\n}\n// Read model for customer order history\n[ReadModel(\"CustomerOrders\")]\npublic class CustomerOrderSummary {\n    public Guid CustomerId { get; set; }\n    public string CustomerName { get; set; }\n    public int TotalOrders { get; set; }\n    public int CompletedOrders { get; set; }\n    public int PendingOrders { get; set; }\n    public decimal LifetimeValue { get; set; }\n    public DateTime LastOrderDate { get; set; }\n    public List<RecentOrder> RecentOrders { get; set; } = new();\n}\npublic class RecentOrder {\n    public Guid OrderId { get; set; }\n    public decimal Amount { get; set; }\n    public string Status { get; set; }\n    public DateTime Date { get; set; }\n}\n// Read model for order details\n[ReadModel(\"OrderDetails\")]\npublic class OrderDetailsView {\n    public Guid OrderId { get; set; }\n    public Guid CustomerId { get; set; }\n    // Customer info (denormalized)\n    public string CustomerName { get; set; }\n    public string CustomerEmail { get; set; }\n    public string CustomerPhone { get; set; }\n    // Order info\n    public List<OrderLineView> Lines { get; set; } = new();\n    public decimal SubTotal { get; set; }\n    public decimal TaxAmount { get; set; }\n    public decimal ShippingCost { get; set; }\n    public decimal TotalAmount { get; set; }\n    // Shipping info\n    public string ShippingAddress { get; set; }\n    public string TrackingNumber { get; set; }\n    public string Carrier { get; set; }\n    // Status and dates\n    public string Status { get; set; }\n    public DateTime CreatedAt { get; set; }\n    public DateTime",
        "startIndex": 3118,
        "preview": "list/search [ReadModel(\"OrderList\")] public class OrderListItem { public Guid OrderId { get; set; } public Guid CustomerId { get; set; } public string..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/cqrs-implementation-chunk-3",
        "text": "decimal TotalAmount { get; set; } // Shipping info public string ShippingAddress { get; set; } public string TrackingNumber { get; set; } public string Carrier { get; set; } // Status and dates public string Status { get; set; } public DateTime CreatedAt { get; set; } public DateTime ShippedAt { get; set; }\n    public DateTime DeliveredAt { get; set; }\n    // Audit trail\n    public List<OrderEvent> EventHistory { get; set; } = new();\n}\npublic class OrderLineView {\n    public string ProductId { get; set; }\n    public string ProductName { get; set; }\n    public string ProductImageUrl { get; set; } // Enriched data\n    public int Quantity { get; set; }\n    public decimal UnitPrice { get; set; }\n    public decimal LineTotal { get; set; }\n}\npublic class OrderEvent {\n    public string EventType { get; set; }\n    public DateTime OccurredAt { get; set; }\n    public string Description { get; set; }\n}\n`\nStep 2: Create Projections\n`csharp{\ntitle: \"Projection Implementation\"\ndescription: \"Build projections that update read models from events\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Event Handlers\", \"Read Model Updates\"]\nnugetPackages: [\"Whizbang Projections\"]\nfilename: \"OrderProjections cs\"\nshowLineNumbers: true\nhighlightLines: [15, 35, 55, 75]\nusingStatements: [\"Whizbang Projections\", \"System\", \"System Threading Tasks\"]\n}\nusing Whizbang Projections;\nusing System;\nusing System Linq;\nusing System Threading;\nusing System Threading Tasks;\nusing MyApp Orders Events;\nusing MyApp Orders ReadModels;\nnamespace MyApp Orders Projections;\n[Projection(\"OrderListProjection\")]\npublic class OrderListProjection : IProjection {\n    private readonly IReadModelStore<OrderListItem> _store;\n    private readonly ICustomerService _customerService;\n    public OrderListProjection(\n        IReadModelStore<OrderListItem> store,\n        ICustomerService customerService) {\n        _store = store;\n        _customerService = customerService;\n    }\n    [Subscribe]\n    public async Task Handle(\n        OrderCreated @event,\n        EventMetadata metadata,\n        CancellationToken cancellationToken) {\n        // Enrich with customer data\n        var customer = await _customerService GetCustomer(\n            @event CustomerId,\n            cancellationToken\n        );\n        // Create read model\n        var item = new OrderListItem {\n            OrderId = @event",
        "startIndex": 4886,
        "preview": "decimal TotalAmount { get; set; } // Shipping info public string ShippingAddress { get; set; } public string TrackingNumber { get; set; } public strin..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/cqrs-implementation-chunk-4",
        "text": "ICustomerService customerService) { _store = store; _customerService = customerService; } [Subscribe] public async Task Handle( OrderCreated @event, EventMetadata metadata, CancellationToken cancellationToken) { // Enrich with customer data var customer = await _customerService GetCustomer( @event CustomerId, cancellationToken ); // Create read model var item = new OrderListItem { OrderId = @event OrderId,\n            CustomerId = @event CustomerId,\n            CustomerName = customer Name \"Unknown\",\n            TotalAmount = @event TotalAmount,\n            Status = \"Pending\",\n            CreatedAt = @event CreatedAt,\n            ItemCount = @event Items Count,\n            FirstItemName = @event Items FirstOrDefault() ProductName,\n            IsHighValue = @event TotalAmount > 1000\n        };\n        await _store Add(item OrderId, item, cancellationToken);\n    }\n    [Subscribe]\n    public async Task Handle(\n        OrderShipped @event,\n        EventMetadata metadata,\n        CancellationToken cancellationToken) {\n        await _store Update(\n            @event OrderId,\n            item => {\n                item Status = \"Shipped\";\n                item ShippedAt = @event ShippedAt;\n            },\n            cancellationToken\n        );\n    }\n    [Subscribe]\n    public async Task Handle(\n        OrderCancelled @event,\n        EventMetadata metadata,\n        CancellationToken cancellationToken) {\n        await _store Update(\n            @event OrderId,\n            item => item Status = \"Cancelled\",\n            cancellationToken\n        );\n    }\n}\n[Projection(\"CustomerOrdersProjection\")]\npublic class CustomerOrdersProjection : IProjection {\n    private readonly IReadModelStore<CustomerOrderSummary> _store;\n    public CustomerOrdersProjection(IReadModelStore<CustomerOrderSummary> store) {\n        _store = store;\n    }\n    [Subscribe]\n    public async Task Handle(\n        OrderCreated @event,\n        EventMetadata metadata,\n        CancellationToken cancellationToken) {\n        var summary = await _store GetById(@event CustomerId, cancellationToken) new CustomerOrderSummary { \n                CustomerId = @event CustomerId \n            };\n        // Update summary\n        summary TotalOrders++;\n        summary PendingOrders++;\n        summary LifetimeValue += @event TotalAmount;\n        summary LastOrderDate = @event CreatedAt;\n        // Add to recent orders (keep last 10)\n        summary RecentOrders Insert(0, new RecentOrder {\n            OrderId = @event OrderId,\n            Amount = @event TotalAmount,\n            Status = \"Pending\",\n            Date = @event CreatedAt\n        });\n        if (summary RecentOrders Count > 10) {\n            summary RecentOrders RemoveAt(10);\n        }\n        await _store Upsert(\n            summary CustomerId, \n            summary, \n            cancellationToken\n        );\n    }\n    [Subscribe]\n    public async Task Handle(\n        OrderShipped @event,\n        EventMetadata metadata,\n        CancellationToken cancellationToken) {\n        // Update customer summary when order ships\n        await _store Update(\n            @event CustomerId,\n            summary => {\n                summary PendingOrders--;\n                summary",
        "startIndex": 7005,
        "preview": "ICustomerService customerService) { _store = store; _customerService = customerService; } [Subscribe] public async Task Handle( OrderCreated @event, E..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/cqrs-implementation-chunk-5",
        "text": "if (summary RecentOrders Count > 10) { summary RecentOrders RemoveAt(10); } await _store Upsert( summary CustomerId, summary, cancellationToken ); } [Subscribe] public async Task Handle( OrderShipped @event, EventMetadata metadata, CancellationToken cancellationToken) { // Update customer summary when order ships await _store Update( @event CustomerId, summary => { summary PendingOrders--; summary CompletedOrders++;\n                var recentOrder = summary RecentOrders FirstOrDefault(o => o OrderId == @event OrderId);\n                if (recentOrder = null) {\n                    recentOrder Status = \"Shipped\";\n                }\n            },\n            cancellationToken\n        );\n    }\n}\n`\nStep 3: Implement Query Handlers\n`csharp{\ntitle: \"Query Handler Implementation\"\ndescription: \"Query handlers that read from optimized read models\"\nframework: \"NET8\"\ncategory: \"CQRS\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Query Handlers\", \"Read Operations\", \"Performance\"]\nnugetPackages: [\"Whizbang Projections\"]\nfilename: \"OrderQueryHandlers cs\"\nshowLineNumbers: true\nhighlightLines: [18, 40, 65]\nusingStatements: [\"Whizbang Projections\", \"System\", \"System Linq\", \"System Threading Tasks\"]\n}\nusing Whizbang;\nusing Whizbang Projections;\nusing System;\nusing System Collections Generic;\nusing System Linq;\nusing System Threading;\nusing System Threading Tasks;\nusing MyApp Orders Queries;\nusing MyApp Orders ReadModels;\nnamespace MyApp Orders Handlers;\npublic class GetOrderListHandler : IQueryHandler<GetOrderListQuery, PagedResult<OrderListItem>> {\n    private readonly IReadModelStore<OrderListItem> _store;\n    public GetOrderListHandler(IReadModelStore<OrderListItem> store) {\n        _store = store;\n    }\n    public async Task<PagedResult<OrderListItem>> Handle(\n        GetOrderListQuery query,\n        CancellationToken cancellationToken) {\n        // Query read model with filtering, sorting, paging\n        var items = await _store Query(\n            filter: item => {\n                var matches = true;\n                if (query CustomerId HasValue) {\n                    matches &= item CustomerId == query CustomerId;\n                }\n                if ( string IsNullOrEmpty(query Status)) {\n                    matches &= item Status == query Status;\n                }\n                if (query MinAmount HasValue) {\n                    matches &= item TotalAmount >= query MinAmount;\n                }\n                if (query IsHighValue HasValue) {\n                    matches &= item IsHighValue == query IsHighValue;\n                }\n                return matches;\n            },\n            orderBy: query SortBy switch {\n                \"date\" => items => query SortDescending items OrderByDescending(i => i CreatedAt)\n                    : items OrderBy(i => i CreatedAt),\n                \"amount\" => items => query SortDescending items",
        "startIndex": 9844,
        "preview": "if (summary RecentOrders Count > 10) { summary RecentOrders RemoveAt(10); } await _store Upsert( summary CustomerId, summary, cancellationToken ); } [..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/cqrs-implementation-chunk-6",
        "text": "TotalAmount >= query MinAmount; } if (query IsHighValue HasValue) { matches &= item IsHighValue == query IsHighValue; } return matches; }, orderBy: query SortBy switch { \"date\" => items => query SortDescending items OrderByDescending(i => i CreatedAt) : items OrderBy(i => i CreatedAt), \"amount\" => items => query SortDescending items OrderByDescending(i => i TotalAmount)\n                    : items OrderBy(i => i TotalAmount),\n                _ => items => items OrderByDescending(i => i CreatedAt)\n            },\n            skip: (query Page - 1) * query PageSize,\n            take: query PageSize,\n            cancellationToken: cancellationToken\n        );\n        var totalCount = await _store Count(cancellationToken);\n        return new PagedResult<OrderListItem> {\n            Items = items,\n            Page = query Page,\n            PageSize = query PageSize,\n            TotalCount = totalCount,\n            TotalPages = (int)Math Ceiling(totalCount / (double)query PageSize)\n        };\n    }\n}\npublic class GetCustomerOrdersHandler : IQueryHandler<GetCustomerOrdersQuery, CustomerOrderSummary> {\n    private readonly IReadModelStore<CustomerOrderSummary> _store;\n    private readonly ICustomerService _customerService;\n    public GetCustomerOrdersHandler(\n        IReadModelStore<CustomerOrderSummary> store,\n        ICustomerService customerService) {\n        _store = store;\n        _customerService = customerService;\n    }\n    public async Task<CustomerOrderSummary> Handle(\n        GetCustomerOrdersQuery query,\n        CancellationToken cancellationToken) {\n        // Get from read model\n        var summary = await _store GetById(query CustomerId, cancellationToken);\n        if (summary == null) {\n            // No orders yet, return empty summary\n            var customer = await _customerService GetCustomer(\n                query CustomerId,\n                cancellationToken\n            );\n            return new CustomerOrderSummary {\n                CustomerId = query CustomerId,\n                CustomerName = customer Name \"Unknown\",\n                TotalOrders = 0,\n                CompletedOrders = 0,\n                PendingOrders = 0,\n                LifetimeValue = 0,\n                RecentOrders = new List<RecentOrder>()\n            };\n        }\n        return summary;\n    }\n}\npublic class SearchOrdersHandler : IQueryHandler<SearchOrdersQuery, List<OrderListItem>> {\n    private readonly IReadModelStore<OrderListItem> _store;\n    private readonly ISearchService _searchService;\n    public SearchOrdersHandler(\n        IReadModelStore<OrderListItem> store,\n        ISearchService searchService) {\n        _store = store;\n        _searchService = searchService;\n    }\n    public async Task<List<OrderListItem>> Handle(\n        SearchOrdersQuery query,\n        CancellationToken cancellationToken) {\n        // Use search service for full-text search\n        var orderIds = await _searchService SearchOrders(\n            query SearchTerm,\n            limit: query",
        "startIndex": 12195,
        "preview": "TotalAmount >= query MinAmount; } if (query IsHighValue HasValue) { matches &= item IsHighValue == query IsHighValue; } return matches; }, orderBy: qu..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/cqrs-implementation-chunk-7",
        "text": "List<OrderListItem>> { private readonly IReadModelStore<OrderListItem> _store; private readonly ISearchService _searchService; public SearchOrdersHandler( IReadModelStore<OrderListItem> store, ISearchService searchService) { _store = store; _searchService = searchService; } public async Task<List<OrderListItem>> Handle( SearchOrdersQuery query, CancellationToken cancellationToken) { // Use search service for full-text search var orderIds = await _searchService SearchOrders( query SearchTerm, limit: query MaxResults,\n            cancellationToken: cancellationToken\n        );\n        // Get read models for matching orders\n        var orders = new List<OrderListItem>();\n        foreach (var orderId in orderIds) {\n            var order = await _store GetById(orderId, cancellationToken);\n            if (order = null) {\n                orders Add(order);\n            }\n        }\n        return orders;\n    }\n}\n`\nStep 4: Configure CQRS\n`csharp{\ntitle: \"CQRS Configuration\"\ndescription: \"Configure Whizbang with CQRS pattern and projection processing\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Configuration\", \"CQRS Setup\", \"Projections\"]\nnugetPackages: [\"Whizbang Projections\", \"Whizbang EventSourcing\"]\nfilename: \"Program cs\"\nshowLineNumbers: true\nhighlightLines: [9, 16, 23, 33]\nusingStatements: [\"Whizbang\", \"Whizbang Projections\", \"Microsoft Extensions DependencyInjection\"]\n}\nusing Whizbang;\nusing Whizbang Projections;\nusing Microsoft AspNetCore Builder;\nusing Microsoft Extensions DependencyInjection;\nvar builder = WebApplication CreateBuilder(args);\n// Configure Whizbang with CQRS\nbuilder Services AddWhizbang(config => {\n    // Configure event sourcing for write side\n    config UseEventSourcing(options => {\n        options UsePostgreSQL(builder Configuration GetConnectionString(\"EventStore\"));\n    });\n    // Configure projections for read side\n    config UseProjections(options => {\n        // Use separate database for read models\n        options UsePostgreSQL(builder Configuration GetConnectionString(\"ReadModels\"));\n        // Configure projection processing\n        options ProcessingMode = ProjectionProcessingMode Async;\n        options RetryPolicy = RetryPolicy Exponential(3, TimeSpan FromSeconds(1));\n        // Register projections\n        options RegisterProjectionsFromAssembly(typeof(Program) Assembly);\n        // Configure read model stores\n        options ConfigureStore<OrderListItem>(store => {\n            store TableName = \"order_list\";\n            store EnableCaching(TimeSpan FromMinutes(5));\n        });\n        options ConfigureStore<CustomerOrderSummary>(store => {\n            store TableName = \"customer_orders\";\n            store EnableCaching(TimeSpan FromMinutes(10));\n        });\n        options ConfigureStore<OrderDetailsView>(store => {\n            store TableName = \"order_details\";\n            store EnableCaching(TimeSpan FromMinutes(2));\n        });\n    });\n    // Register handlers\n    config RegisterHandlersFromAssembly(typeof(Program) Assembly);\n});\n// Register services\nbuilder Services AddScoped<ICustomerService, CustomerService>();\nbuilder Services AddScoped<ISearchService, ElasticsearchService>();\nbuilder Services AddControllers();\nvar app = builder",
        "startIndex": 15047,
        "preview": "List<OrderListItem>> { private readonly IReadModelStore<OrderListItem> _store; private readonly ISearchService _searchService; public SearchOrdersHand..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/cqrs-implementation-chunk-8",
        "text": "options ConfigureStore<CustomerOrderSummary>(store => { store TableName = \"customer_orders\"; store EnableCaching(TimeSpan FromMinutes(10)); }); options ConfigureStore<OrderDetailsView>(store => { store TableName = \"order_details\"; store EnableCaching(TimeSpan FromMinutes(2)); }); }); // Register handlers config RegisterHandlersFromAssembly(typeof(Program) Assembly); }); // Register services builder Services AddScoped<ICustomerService, CustomerService>(); builder Services AddScoped<ISearchService, ElasticsearchService>(); builder Services AddControllers(); var app = builder Build();\n// Initialize projection infrastructure\nawait app InitializeProjections();\n// Start projection processor\napp UseProjectionProcessor();\napp UseRouting();\napp MapControllers();\napp Run();\n`\nComplete Example\n`csharp{\ntitle: \"Complete CQRS Implementation\"\ndescription: \"Full working example showing CQRS from commands to queries\"\nframework: \"NET8\"\ncategory: \"Complete Example\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"CQRS\", \"Complete\", \"API\", \"Commands\", \"Queries\"]\nnugetPackages: [\"Whizbang Projections\", \"Microsoft AspNetCore Mvc\"]\nfilename: \"CQRSOrdersController cs\"\nshowLineNumbers: true\nhighlightLines: [22, 36, 51, 66, 81]\ntestFile: \"CQRSOrdersTests cs\"\ntestMethod: \"CreateOrder_UpdatesReadModel_QueryReturnsData\"\nusingStatements: [\"Whizbang\", \"Microsoft AspNetCore Mvc\", \"System Threading Tasks\"]\n}\nusing Whizbang;\nusing Microsoft AspNetCore Mvc;\nusing System;\nusing System Threading;\nusing System Threading Tasks;\nusing MyApp Orders Commands;\nusing MyApp Orders Queries;\nusing MyApp Orders ReadModels;\nnamespace MyApp Controllers;\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class OrdersController : ControllerBase {\n    private readonly IMediator _mediator;\n    public OrdersController(IMediator mediator) {\n        _mediator = mediator;\n    }\n    // COMMAND SIDE - Write operations\n    [HttpPost]\n    public async Task<ActionResult<OrderCreatedResult>> CreateOrder(\n        [FromBody] CreateOrderRequest request,\n        CancellationToken cancellationToken) {\n        var command = new CreateOrderCommand(\n            request CustomerId,\n            request Items,\n            request ShippingAddress\n        );\n        var result = await _mediator Send(command, cancellationToken);\n        return CreatedAtAction(nameof(GetOrderDetails), new { orderId = result OrderId }, result);\n    }\n    [HttpPost(\"{orderId}/ship\")]\n    public async Task<ActionResult<ShipmentResult>> ShipOrder(\n        Guid orderId,\n        CancellationToken cancellationToken) {\n        var command = new ShipOrderCommand(orderId);\n        var result = await _mediator Send(command, cancellationToken);\n        return Ok(result);\n    }\n    // QUERY SIDE - Read operations from optimized read models\n    [HttpGet]\n    public async Task<ActionResult<PagedResult<OrderListItem>>> GetOrders(\n        [FromQuery] int page = 1,\n        [FromQuery] int pageSize = 20,\n        [FromQuery] string status = null,\n        [FromQuery] decimal",
        "startIndex": 17796,
        "preview": "options ConfigureStore<CustomerOrderSummary>(store => { store TableName = \"customer_orders\"; store EnableCaching(TimeSpan FromMinutes(10)); }); option..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/cqrs-implementation-chunk-9",
        "text": "CancellationToken cancellationToken) { var command = new ShipOrderCommand(orderId); var result = await _mediator Send(command, cancellationToken); return Ok(result); } // QUERY SIDE - Read operations from optimized read models [HttpGet] public async Task<ActionResult<PagedResult<OrderListItem>>> GetOrders( [FromQuery] int page = 1, [FromQuery] int pageSize = 20, [FromQuery] string status = null, [FromQuery] decimal minAmount = null,\n        [FromQuery] string sortBy = \"date\",\n        [FromQuery] bool sortDescending = true,\n        CancellationToken cancellationToken = default) {\n        var query = new GetOrderListQuery {\n            Page = page,\n            PageSize = pageSize,\n            Status = status,\n            MinAmount = minAmount,\n            SortBy = sortBy,\n            SortDescending = sortDescending\n        };\n        var result = await _mediator Send(query, cancellationToken);\n        return Ok(result);\n    }\n    [HttpGet(\"{orderId}\")]\n    public async Task<ActionResult<OrderDetailsView>> GetOrderDetails(\n        Guid orderId,\n        CancellationToken cancellationToken) {\n        var query = new GetOrderDetailsQuery(orderId);\n        var result = await _mediator Send(query, cancellationToken);\n        if (result == null) {\n            return NotFound();\n        }\n        return Ok(result);\n    }\n    [HttpGet(\"customer/{customerId}\")]\n    public async Task<ActionResult<CustomerOrderSummary>> GetCustomerOrders(\n        Guid customerId,\n        CancellationToken cancellationToken) {\n        var query = new GetCustomerOrdersQuery(customerId);\n        var result = await _mediator Send(query, cancellationToken);\n        return Ok(result);\n    }\n    [HttpGet(\"search\")]\n    public async Task<ActionResult<List<OrderListItem>>> SearchOrders(\n        [FromQuery] string q,\n        [FromQuery] int maxResults = 50,\n        CancellationToken cancellationToken = default) {\n        if (string IsNullOrWhiteSpace(q)) {\n            return BadRequest(\"Search term is required\");\n        }\n        var query = new SearchOrdersQuery {\n            SearchTerm = q,\n            MaxResults = maxResults\n        };\n        var result = await _mediator Send(query, cancellationToken);\n        return Ok(result);\n    }\n    // Analytics queries from specialized read models\n    [HttpGet(\"analytics/top-customers\")]\n    public async Task<ActionResult<List<TopCustomer>>> GetTopCustomers(\n        [FromQuery] int count = 10,\n        CancellationToken cancellationToken = default) {\n        var query = new GetTopCustomersQuery(count);\n        var result = await _mediator Send(query, cancellationToken);\n        return Ok(result);\n    }\n    [HttpGet(\"analytics/sales-by-day\")]\n    public async Task<ActionResult<List<DailySales>>> GetSalesByDay(\n        [FromQuery] DateTime startDate,\n        [FromQuery] DateTime endDate,\n        CancellationToken cancellationToken = default) {\n        var query = new GetSalesByDayQuery(startDate, endDate);\n        var result = await _mediator",
        "startIndex": 20219,
        "preview": "CancellationToken cancellationToken) { var command = new ShipOrderCommand(orderId); var result = await _mediator Send(command, cancellationToken); ret..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/cqrs-implementation-chunk-10",
        "text": "count = 10, CancellationToken cancellationToken = default) { var query = new GetTopCustomersQuery(count); var result = await _mediator Send(query, cancellationToken); return Ok(result); } [HttpGet(\"analytics/sales-by-day\")] public async Task<ActionResult<List<DailySales>>> GetSalesByDay( [FromQuery] DateTime startDate, [FromQuery] DateTime endDate, CancellationToken cancellationToken = default) { var query = new GetSalesByDayQuery(startDate, endDate); var result = await _mediator Send(query, cancellationToken);\n        return Ok(result);\n    }\n}\n// Query definitions\npublic record GetOrderListQuery {\n    public int Page { get; set; } = 1;\n    public int PageSize { get; set; } = 20;\n    public Guid CustomerId { get; set; }\n    public string Status { get; set; }\n    public decimal MinAmount { get; set; }\n    public bool IsHighValue { get; set; }\n    public string SortBy { get; set; } = \"date\";\n    public bool SortDescending { get; set; } = true;\n}\npublic record SearchOrdersQuery {\n    public string SearchTerm { get; set; }\n    public int MaxResults { get; set; } = 50;\n}\n`\nTesting Strategy\nTesting Projections\n`csharp{\ntitle: \"Projection Tests\"\ndescription: \"Test that projections correctly update read models from events\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Unit Testing\", \"Projections\", \"Read Models\"]\nnugetPackages: [\"Whizbang Projections\", \"xUnit\", \"Moq\"]\nfilename: \"OrderProjectionTests cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang Projections\", \"Xunit\", \"Moq\"]\n}\nusing Whizbang Projections;\nusing Xunit;\nusing Moq;\nusing System;\nusing System Threading;\nusing System Threading Tasks;\nusing MyApp Orders Events;\nusing MyApp Orders Projections;\nusing MyApp Orders ReadModels;\nnamespace MyApp Tests Orders;\npublic class OrderListProjectionTests {\n    private readonly Mock<IReadModelStore<OrderListItem>> _storeMock;\n    private readonly Mock<ICustomerService> _customerServiceMock;\n    private readonly OrderListProjection _projection;\n    public OrderListProjectionTests() {\n        _storeMock = new Mock<IReadModelStore<OrderListItem>>();\n        _customerServiceMock = new Mock<ICustomerService>();\n        _projection = new OrderListProjection(\n            _storeMock Object,\n            _customerServiceMock Object\n        );\n    }\n    [Fact]\n    public async Task Handle_OrderCreated_CreatesReadModel() {\n        // Arrange\n        var @event = new OrderCreated(\n            Guid NewGuid(),\n            Guid NewGuid(),\n            new List<OrderItem> {\n                new OrderItem(\"P1\", \"Widget\", 2, 500 00m)\n            },\n            1000 00m,\n            \"123 Main St\",\n            DateTime",
        "startIndex": 22799,
        "preview": "count = 10, CancellationToken cancellationToken = default) { var query = new GetTopCustomersQuery(count); var result = await _mediator Send(query, can..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/cqrs-implementation-chunk-11",
        "text": "= new Mock<IReadModelStore<OrderListItem>>(); _customerServiceMock = new Mock<ICustomerService>(); _projection = new OrderListProjection( _storeMock Object, _customerServiceMock Object ); } [Fact] public async Task Handle_OrderCreated_CreatesReadModel() { // Arrange var @event = new OrderCreated( Guid NewGuid(), Guid NewGuid(), new List<OrderItem> { new OrderItem(\"P1\", \"Widget\", 2, 500 00m) }, 1000 00m, \"123 Main St\", DateTime UtcNow\n        );\n        _customerServiceMock Setup(x => x GetCustomer(It IsAny<Guid>(), It IsAny<CancellationToken>())) ReturnsAsync(new Customer { Name = \"John Doe\" });\n        // Act\n        await _projection Handle(\n            @event,\n            new EventMetadata(),\n            CancellationToken None\n        );\n        // Assert\n        _storeMock Verify(x => x Add(\n            @event OrderId,\n            It Is<OrderListItem>(item =>\n                item OrderId == @event OrderId &&\n                item TotalAmount == 1000 00m &&\n                item Status == \"Pending\" &&\n                item IsHighValue == true &&\n                item CustomerName == \"John Doe\"\n            ),\n            It IsAny<CancellationToken>()\n        ), Times Once);\n    }\n    [Fact]\n    public async Task Handle_OrderShipped_UpdatesStatus() {\n        // Arrange\n        var orderId = Guid NewGuid();\n        var @event = new OrderShipped(\n            orderId,\n            \"TRACK123\",\n            \"FedEx\",\n            DateTime UtcNow\n        );\n        // Act\n        await _projection Handle(\n            @event,\n            new EventMetadata(),\n            CancellationToken None\n        );\n        // Assert\n        _storeMock Verify(x => x Update(\n            orderId,\n            It IsAny<Action<OrderListItem>>(),\n            It IsAny<CancellationToken>()\n        ), Times Once);\n    }\n}\n`\nCommon Pitfalls\nDon't Query Write Models\n`csharp{\ntitle: \"Don't Query Write Models\"\ndescription: \"Avoid querying aggregates for read operations - use optimized read models instead\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"CQRS\", \"Anti-Patterns\", \"Best Practices\"]\nfilename: \"ReadModelVsAggregate cs\"\nshowLineNumbers: true\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq\", \"System Threading Tasks\"]\n}\n// ❌ BAD - Querying aggregates for read operations\npublic async Task<List<Order>> GetOrders() {\n    var aggregates = await _repository GetAll<OrderAggregate>();\n    return aggregates Select(a => MapToDto(a)) ToList();\n}\n// ✅ GOOD - Query optimized read models\npublic async Task<List<OrderListItem>> GetOrders() {\n    return await _readModelStore",
        "startIndex": 24981,
        "preview": "= new Mock<IReadModelStore<OrderListItem>>(); _customerServiceMock = new Mock<ICustomerService>(); _projection = new OrderListProjection( _storeMock O..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/cqrs-implementation-chunk-12",
        "text": "Generic\", \"System Linq\", \"System Threading Tasks\"] } // ❌ BAD - Querying aggregates for read operations public async Task<List<Order>> GetOrders() { var aggregates = await _repository GetAll<OrderAggregate>(); return aggregates Select(a => MapToDto(a)) ToList(); } // ✅ GOOD - Query optimized read models public async Task<List<OrderListItem>> GetOrders() { return await _readModelStore Query<OrderListItem>();\n}\n`\nHandle Eventual Consistency\n`csharp{\ntitle: \"Handle Eventual Consistency\"\ndescription: \"Account for eventual consistency between write and read models in CQRS\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"CQRS\", \"Eventual Consistency\", \"Best Practices\"]\nfilename: \"EventualConsistency cs\"\nshowLineNumbers: true\nusingStatements: [\"System\", \"System Threading Tasks\"]\n}\n// ❌ BAD - Expecting immediate consistency\nvar orderId = await CreateOrder(command);\nvar order = await GetOrder(orderId); // May not exist yet // ✅ GOOD - Handle eventual consistency\nvar orderId = await CreateOrder(command);\nawait Task Delay(100); // Or use polling/SignalR for real-time updates\nvar order = await GetOrder(orderId);\n`\nAvoid Complex Projections\n`csharp{\ntitle: \"Avoid Complex Projections\"\ndescription: \"Keep projections focused on single responsibility rather than doing multiple things\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"CQRS\", \"Projections\", \"Single Responsibility\", \"Best Practices\"]\nfilename: \"ProjectionResponsibility cs\"\nshowLineNumbers: true\nusingStatements: [\"System\", \"System Threading Tasks\"]\n}\n// ❌ BAD - Projection doing too much\npublic async Task Handle(OrderCreated @event) {\n    await UpdateOrderList();\n    await UpdateCustomerSummary();\n    await SendEmail();\n    await UpdateInventory();\n}\n// ✅ GOOD - Single responsibility projections\npublic class OrderListProjection { / Updates order list only / }\npublic class CustomerSummaryProjection { / Updates customer summary only / }\npublic class EmailNotificationHandler { / Sends emails only / }\n`\nProgressive Enhancement\nAdd Multiple Read Stores\n`csharp{\ntitle: \"Multiple Read Stores\"\ndescription: \"Configure different storage technologies for different read model needs\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Usage Patterns\", \"CQRS\", \"Multiple Stores\", \"Storage Options\"]\nfilename: \"MultipleStoresConfiguration",
        "startIndex": 27222,
        "preview": "Generic\", \"System Linq\", \"System Threading Tasks\"] } // ❌ BAD - Querying aggregates for read operations public async Task<List<Order>> GetOrders() { v..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/cqrs-implementation-chunk-13",
        "text": "} public class EmailNotificationHandler { / Sends emails only / } ` Progressive Enhancement Add Multiple Read Stores `csharp{ title: \"Multiple Read Stores\" description: \"Configure different storage technologies for different read model needs\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"ADVANCED\" tags: [\"Usage Patterns\", \"CQRS\", \"Multiple Stores\", \"Storage Options\"] filename: \"MultipleStoresConfiguration cs\"\nshowLineNumbers: true\nusingStatements: [\"System\", \"Whizbang Projections\"]\n}\n// Configure different stores for different needs\nconfig UseProjections(options => {\n    // PostgreSQL for transactional queries\n    options AddStore<OrderListItem>() UsePostgreSQL(connString) WithCaching(TimeSpan FromMinutes(5));\n    // MongoDB for document queries\n    options AddStore<OrderDetailsView>() UseMongoDB(mongoConnection) WithIndexes(\"CustomerId\", \"Status\");\n    // Elasticsearch for search\n    options AddStore<OrderSearchDocument>() UseElasticsearch(elasticUri) WithFullTextSearch();\n});\n`\nImplement Sagas for Complex Workflows\nSee Saga Orchestration for coordinating multi-aggregate operations Add Real-Time Updates\n`csharp{\ntitle: \"Real-Time Updates with SignalR\"\ndescription: \"Add real-time notifications to CQRS projections using SignalR\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Usage Patterns\", \"CQRS\", \"SignalR\", \"Real-Time\", \"Notifications\"]\nfilename: \"RealTimeNotifications cs\"\nshowLineNumbers: true\nusingStatements: [\"Microsoft AspNetCore SignalR\", \"System\", \"System Threading Tasks\"]\n}\n// SignalR for real-time notifications\npublic class OrderHub : Hub {\n    public async Task SubscribeToOrders(Guid customerId) {\n        await Groups AddToGroupAsync(Context ConnectionId, $\"customer-{customerId}\");\n    }\n}\n// In projection\npublic async Task Handle(OrderCreated @event) {\n    await UpdateReadModel(@event);\n    await _hubContext Clients Group($\"customer-{@event CustomerId}\") SendAsync(\"OrderCreated\", @event);\n}\n`\nRelated Patterns\nEvent Sourcing Basics - Foundation for CQRS write side\nSimple Mediator Pattern - Simpler alternative without separation\nDistributed Messaging - Scale CQRS across services\nProduction Considerations\nRead Model Rebuild\n`csharp{\ntitle: \"Read Model Rebuild\"\ndescription: \"Rebuild read models from events for data recovery or schema changes\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"CQRS\", \"Projections\", \"Rebuild\", \"Maintenance\"]\nfilename: \"ReadModelRebuild cs\"\nshowLineNumbers: true\nusingStatements: [\"System\", \"System Threading Tasks\"]\n}\n// Rebuild read models from events\nawait projectionManager RebuildProjection<OrderListProjection>(\n    fromPosition: EventPosition Start,\n    toPosition: EventPosition",
        "startIndex": 29266,
        "preview": "} public class EmailNotificationHandler { / Sends emails only / } ` Progressive Enhancement Add Multiple Read Stores `csharp{ title: \"Multiple Read St..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/cqrs-implementation-chunk-14",
        "text": "\"Rebuild read models from events for data recovery or schema changes\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"INTERMEDIATE\" tags: [\"Usage Patterns\", \"CQRS\", \"Projections\", \"Rebuild\", \"Maintenance\"] filename: \"ReadModelRebuild cs\" showLineNumbers: true usingStatements: [\"System\", \"System Threading Tasks\"] } // Rebuild read models from events await projectionManager RebuildProjection<OrderListProjection>( fromPosition: EventPosition Start, toPosition: EventPosition End\n);\n`\nMonitoring and Health Checks\n`csharp{\ntitle: \"Monitoring and Health Checks\"\ndescription: \"Monitor CQRS projection health and performance\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"CQRS\", \"Monitoring\", \"Health Checks\", \"Production\"]\nfilename: \"CQRSMonitoring cs\"\nshowLineNumbers: true\nusingStatements: [\"Microsoft Extensions DependencyInjection\"]\n}\n// Monitor projection lag\nservices AddHealthChecks() AddCheck<ProjectionLagHealthCheck>(\"projection-lag\") AddCheck<ReadModelConsistencyCheck>(\"read-consistency\");\n`\nPerformance Optimization\nUse appropriate indexes on read models\nImplement caching strategies\nConsider materialized views for complex queries\nMonitor query performance\nNext Steps\nExplore Saga Orchestration for complex workflows\nLearn about Distributed Messaging for microservices\nReview Projections Documentation for advanced patterns\nCheck out Query Optimization techniques",
        "startIndex": 31674,
        "preview": "\"Rebuild read models from events for data recovery or schema changes\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"INTERMEDIATE\" tags: [\"..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/usage-patterns/distributed-messaging",
    "title": "Distributed Messaging",
    "category": "Usage Patterns",
    "url": "/docs/old-v1.0.0.0/usage-patterns/distributed-messaging",
    "chunks": [
      {
        "id": "old-v1.0.0.0/usage-patterns/distributed-messaging-chunk-0",
        "text": "Distributed Messaging\nOverview\nDistributed Messaging enables reliable communication between services in a microservices architecture. Whizbang provides robust patterns for handling distributed transactions, ensuring message delivery, and maintaining consistency across service boundaries.\nKey Concepts\nOutbox Pattern: Ensure reliable message publishing\nInbox Pattern: Handle duplicate messages and ensure idempotency\nMessage Routing: Direct messages to appropriate handlers\nSaga Coordination: Orchestrate multi-service workflows\nArchitecture Diagram\n`mermaid\ngraph TB\n    subgraph \"Service A\"\n        A1[Command Handler] --> A2[Aggregate]\n        A2 --> A3[Event Store]\n        A3 --> A4[Outbox]\n        A4 --> A5[Message Publisher]\n    end\n    subgraph \"Message Broker\"\n        MB[(RabbitMQ/Kafka)]\n    end\n    subgraph \"Service B\"\n        B1[Message Consumer] --> B2[Inbox]\n        B2 --> B3[Command Handler]\n        B3 --> B4[Aggregate]\n    end\n    A5 --> MB\n    MB --> B1\n    style MB fill:#0066cc,color:#fff\n`\nImplementation Guide\nDocumentation in progress - This page demonstrates the structure for distributed messaging patterns with Whizbang.\nTopics to Cover:\nOutbox Pattern Implementation\nTransactional outbox\nMessage publishing\nRetry mechanisms\nInbox Pattern Implementation\nDuplicate detection\nMessage ordering\nIdempotent processing\nMessage Broker Integration\nRabbitMQ configuration\nKafka setup\nAzure Service Bus\nError Handling\nDead letter queues\nRetry policies\nCompensation\nMonitoring\nMessage tracking\nLatency metrics\nHealth checks\nRelated Patterns\nEvent Sourcing Basics - Foundation for event-driven messaging\nSaga Orchestration - Coordinate distributed workflows\nMicroservices Integration - Complete microservices setup\nNext Steps\nReview Distributed Messaging Roadmap for upcoming features\nExplore Saga Orchestration for complex workflows\nCheck Getting Started Guide for basics",
        "startIndex": 0,
        "preview": "Distributed Messaging\nOverview\nDistributed Messaging enables reliable communication between services in a microservices architecture. Whizbang provide..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/usage-patterns/event-sourcing-basics",
    "title": "Event Sourcing Basics",
    "category": "Usage Patterns",
    "url": "/docs/old-v1.0.0.0/usage-patterns/event-sourcing-basics",
    "chunks": [
      {
        "id": "old-v1.0.0.0/usage-patterns/event-sourcing-basics-chunk-0",
        "text": "Event Sourcing Basics\nOverview\nEvent Sourcing is a powerful pattern where instead of storing the current state of your domain objects, you store the sequence of events that led to that state Whizbang makes event sourcing approachable and practical for NET applications What is Event Sourcing Instead of updating a record in place, event sourcing:\nCaptures every state change as an immutable event\nStores events in an append-only log\nRebuilds current state by replaying events\nProvides a complete audit trail and time-travel capabilities\nWhen to Use Event Sourcing\nEvent sourcing is ideal when you need:\nComplete audit trails - Every change is recorded with who, what, when\nTime travel - Ability to see state at any point in time\nEvent replay - Rebuild state, fix bugs, or create new projections\nComplex workflows - Track multi-step processes with compensation\nCompliance - Immutable history for regulatory requirements\nArchitecture Diagram\n`mermaid\nsequenceDiagram\n    participant API as API Controller\n    participant M as Mediator\n    participant H as Command Handler\n    participant A as Aggregate\n    participant R as Repository\n    participant ES as Event Store\n    participant P as Projections\n    API->>M: Send Command\n    M->>H: Route to Handler\n    H->>R: Load Aggregate\n    R->>ES: Read Event Stream\n    ES-->>R: Events\n    R->>A: Rebuild from Events\n    R-->>H: Aggregate\n    H->>A: Execute Command\n    A->>A: Apply Business Rules\n    A->>A: Generate Event(s)\n    H->>R: Save Aggregate\n    R->>ES: Append Events\n    ES->>P: Publish Events\n    P->>P: Update Read Models\n    H-->>API: Command Result\n`\nCore Components\nRequired Packages\n`xml{\ntitle: \"Required NuGet Packages\"\ndescription: \"Core packages needed for event sourcing with Whizbang\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Usage Patterns\", \"Event Sourcing\", \"NuGet Packages\"]\nfilename: \"ProjectFile csproj\"\nshowLineNumbers: true\n}\n<PackageReference Include=\"Whizbang Core\" Version=\"1 0 0\" />\n<PackageReference Include=\"Whizbang EventSourcing\" Version=\"1 0",
        "startIndex": 0,
        "preview": "Event Sourcing Basics\nOverview\nEvent Sourcing is a powerful pattern where instead of storing the current state of your domain objects, you store the s..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/event-sourcing-basics-chunk-1",
        "text": "Core Components Required Packages `xml{ title: \"Required NuGet Packages\" description: \"Core packages needed for event sourcing with Whizbang\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"BEGINNER\" tags: [\"Usage Patterns\", \"Event Sourcing\", \"NuGet Packages\"] filename: \"ProjectFile csproj\" showLineNumbers: true } <PackageReference Include=\"Whizbang Core\" Version=\"1 0 0\" /> <PackageReference Include=\"Whizbang EventSourcing\" Version=\"1 0 0\" />\n`\nKey Concepts\nEvent - Immutable record of something that happened\nAggregate - Domain object that enforces business rules\nEvent Stream - Ordered sequence of events for an aggregate\nEvent Store - Database optimized for append-only event storage\nSnapshot - Periodic state capture to optimize replay\nStep-by-Step Implementation\nStep 1: Define Your Events\n`csharp{\ntitle: \"Event Definitions\"\ndescription: \"Define domain events that represent state changes\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Events\", \"Domain Events\", \"Event Sourcing\"]\nnugetPackages: [\"Whizbang EventSourcing\"]\nfilename: \"OrderEvents cs\"\nshowLineNumbers: true\nhighlightLines: [10, 19, 27]\nusingStatements: [\"Whizbang EventSourcing\", \"System\"]\n}\nusing Whizbang EventSourcing;\nusing System;\nusing System Collections Generic;\nnamespace MyApp Orders",
        "startIndex": 2066,
        "preview": "Core Components Required Packages `xml{ title: \"Required NuGet Packages\" description: \"Core packages needed for event sourcing with Whizbang\" framewor..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/event-sourcing-basics-chunk-2",
        "text": "description: \"Define domain events that represent state changes\" framework: \"NET8\" category: \"Event Sourcing\" difficulty: \"INTERMEDIATE\" tags: [\"Events\", \"Domain Events\", \"Event Sourcing\"] nugetPackages: [\"Whizbang EventSourcing\"] filename: \"OrderEvents cs\" showLineNumbers: true highlightLines: [10, 19, 27] usingStatements: [\"Whizbang EventSourcing\", \"System\"] } using Whizbang EventSourcing; using System; using System Collections Generic; namespace MyApp Orders Events;\n// Base event with common metadata\npublic abstract record OrderEvent : DomainEvent;\n// Event: Order was created\npublic record OrderCreated(\n    Guid OrderId,\n    Guid CustomerId,\n    List<OrderItem> Items,\n    decimal TotalAmount,\n    string ShippingAddress,\n    DateTime CreatedAt\n) : OrderEvent;\n// Event: Item was added to order\npublic record OrderItemAdded(\n    Guid OrderId,\n    OrderItem Item,\n    decimal NewTotalAmount\n) : OrderEvent;\n// Event: Order was shipped\npublic record OrderShipped(\n    Guid OrderId,\n    string TrackingNumber,\n    string Carrier,\n    DateTime ShippedAt\n) : OrderEvent;\n// Event: Order was cancelled\npublic record OrderCancelled(\n    Guid OrderId,\n    string Reason,\n    DateTime CancelledAt\n) : OrderEvent;\n// Value objects\npublic record OrderItem(\n    string ProductId,\n    string ProductName,\n    int Quantity,\n    decimal UnitPrice\n);\n`\nStep 2: Create Your Aggregate\n`csharp{\ntitle: \"Aggregate Implementation\"\ndescription: \"Build an aggregate that applies events and enforces business rules\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Aggregate\", \"Domain Model\", \"Business Rules\"]\nnugetPackages: [\"Whizbang EventSourcing\"]\nfilename: \"OrderAggregate cs\"\nshowLineNumbers: true\nhighlightLines: [25, 44, 67, 82]\nusingStatements: [\"Whizbang EventSourcing\", \"System\", \"System Collections Generic\"]\n}\nusing Whizbang EventSourcing;\nusing System;\nusing System Collections Generic;\nusing System Linq;\nusing MyApp Orders Events;\nnamespace MyApp Orders Aggregates;\npublic class OrderAggregate : Aggregate {\n    // Current state (rebuilt from events)\n    public Guid CustomerId { get; private set; }\n    public List<OrderItem> Items { get; private set; } = new();\n    public decimal TotalAmount { get; private set; }\n    public string ShippingAddress { get; private set; }\n    public OrderStatus Status { get; private set; }\n    public string TrackingNumber { get; private set; }\n    public DateTime",
        "startIndex": 2926,
        "preview": "description: \"Define domain events that represent state changes\" framework: \"NET8\" category: \"Event Sourcing\" difficulty: \"INTERMEDIATE\" tags: [\"Event..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/event-sourcing-basics-chunk-3",
        "text": "CustomerId { get; private set; } public List<OrderItem> Items { get; private set; } = new(); public decimal TotalAmount { get; private set; } public string ShippingAddress { get; private set; } public OrderStatus Status { get; private set; } public string TrackingNumber { get; private set; } public DateTime ShippedAt { get; private set; }\n    // Constructor for existing aggregate (loaded from events)\n    public OrderAggregate() { }\n    // Constructor for new aggregate\n    public OrderAggregate(Guid orderId, Guid customerId, List<OrderItem> items, string shippingAddress) {\n        if (items == null || items Any()) {\n            throw new DomainException(\"Order must have at least one item\");\n        }\n        var totalAmount = items Sum(i => i Quantity * i UnitPrice);\n        // Apply event (this both raises it and updates our state)\n        Apply(new OrderCreated(\n            orderId,\n            customerId,\n            items,\n            totalAmount,\n            shippingAddress,\n            DateTime UtcNow\n        ));\n    }\n    // Command: Add item to order\n    public void AddItem(OrderItem item) {\n        if (Status = OrderStatus Pending) {\n            throw new DomainException($\"Cannot add items to {Status} order\");\n        }\n        if (item Quantity <= 0) {\n            throw new DomainException(\"Quantity must be positive\");\n        }\n        var newTotal = TotalAmount + (item Quantity * item UnitPrice);\n        Apply(new OrderItemAdded(Id, item, newTotal));\n    }\n    // Command: Ship the order\n    public void Ship(string trackingNumber, string carrier) {\n        if (Status = OrderStatus Pending) {\n            throw new DomainException($\"Cannot ship order in {Status} status\");\n        }\n        if (string IsNullOrEmpty(trackingNumber)) {\n            throw new DomainException(\"Tracking number is required\");\n        }\n        Apply(new OrderShipped(Id, trackingNumber, carrier, DateTime UtcNow));\n    }\n    // Command: Cancel the order\n    public void Cancel(string reason) {\n        if (Status == OrderStatus Shipped) {\n            throw new DomainException(\"Cannot cancel shipped order\");\n        }\n        if (Status == OrderStatus Cancelled) {\n            return; // Idempotent\n        }\n        Apply(new OrderCancelled(Id, reason, DateTime UtcNow));\n    }\n    // Event handlers - Update state when events are applied\n    protected void When(OrderCreated @event) {\n        Id = @event OrderId;\n        CustomerId = @event CustomerId;\n        Items = @event Items",
        "startIndex": 4896,
        "preview": "CustomerId { get; private set; } public List<OrderItem> Items { get; private set; } = new(); public decimal TotalAmount { get; private set; } public s..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/event-sourcing-basics-chunk-4",
        "text": "throw new DomainException(\"Cannot cancel shipped order\"); } if (Status == OrderStatus Cancelled) { return; // Idempotent } Apply(new OrderCancelled(Id, reason, DateTime UtcNow)); } // Event handlers - Update state when events are applied protected void When(OrderCreated @event) { Id = @event OrderId; CustomerId = @event CustomerId; Items = @event Items ToList();\n        TotalAmount = @event TotalAmount;\n        ShippingAddress = @event ShippingAddress;\n        Status = OrderStatus Pending;\n    }\n    protected void When(OrderItemAdded @event) {\n        Items Add(@event Item);\n        TotalAmount = @event NewTotalAmount;\n    }\n    protected void When(OrderShipped @event) {\n        Status = OrderStatus Shipped;\n        TrackingNumber = @event TrackingNumber;\n        ShippedAt = @event ShippedAt;\n    }\n    protected void When(OrderCancelled @event) {\n        Status = OrderStatus Cancelled;\n    }\n}\npublic enum OrderStatus {\n    Pending,\n    Shipped,\n    Delivered,\n    Cancelled\n}\n`\nStep 3: Implement Command Handlers\n`csharp{\ntitle: \"Event-Sourced Command Handler\"\ndescription: \"Command handlers that work with aggregates and event stores\"\nframework: \"NET8\"\ncategory: \"Event Sourcing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Command Handler\", \"Event Store\", \"Repository\"]\nnugetPackages: [\"Whizbang EventSourcing\"]\nfilename: \"CreateOrderHandler cs\"\nshowLineNumbers: true\nhighlightLines: [20, 25, 28]\nusingStatements: [\"Whizbang EventSourcing\", \"System\", \"System Threading Tasks\"]\n}\nusing Whizbang EventSourcing;\nusing System;\nusing System Threading;\nusing System Threading Tasks;\nusing MyApp Orders Aggregates;\nusing MyApp Orders Commands;\nnamespace MyApp Orders Handlers;\npublic class CreateOrderHandler : ICommandHandler<CreateOrderCommand, OrderCreatedResult> {\n    private readonly IAggregateRepository<OrderAggregate> _repository;\n    private readonly IInventoryService _inventoryService;\n    public CreateOrderHandler(\n        IAggregateRepository<OrderAggregate> repository,\n        IInventoryService inventoryService) {\n        _repository = repository;\n        _inventoryService = inventoryService;\n    }\n    public async Task<OrderCreatedResult> Handle(\n        CreateOrderCommand command,\n        CancellationToken cancellationToken) {\n        // Check inventory before creating order\n        await _inventoryService ValidateAvailability(command Items, cancellationToken);\n        // Create new aggregate (generates OrderCreated event)\n        var orderId = Guid NewGuid();\n        var order = new OrderAggregate(\n            orderId,\n            command CustomerId,\n            command Items,\n            command ShippingAddress\n        );\n        // Save aggregate (persists events to event store)\n        await _repository SaveAsync(order, cancellationToken);\n        // Reserve inventory (side effect after event is saved)\n        await _inventoryService ReserveItems(orderId, command Items, cancellationToken);\n        return new OrderCreatedResult(\n            orderId,\n            order",
        "startIndex": 7091,
        "preview": "throw new DomainException(\"Cannot cancel shipped order\"); } if (Status == OrderStatus Cancelled) { return; // Idempotent } Apply(new OrderCancelled(Id..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/event-sourcing-basics-chunk-5",
        "text": "var orderId = Guid NewGuid(); var order = new OrderAggregate( orderId, command CustomerId, command Items, command ShippingAddress ); // Save aggregate (persists events to event store) await _repository SaveAsync(order, cancellationToken); // Reserve inventory (side effect after event is saved) await _inventoryService ReserveItems(orderId, command Items, cancellationToken); return new OrderCreatedResult( orderId, order TotalAmount,\n            EstimateDelivery(command ShippingAddress)\n        );\n    }\n    private DateTime EstimateDelivery(string address) {\n        // Simple estimation logic\n        return DateTime UtcNow AddDays(3);\n    }\n}\npublic class ShipOrderHandler : ICommandHandler<ShipOrderCommand, ShipmentResult> {\n    private readonly IAggregateRepository<OrderAggregate> _repository;\n    private readonly IShippingService _shippingService;\n    public ShipOrderHandler(\n        IAggregateRepository<OrderAggregate> repository,\n        IShippingService shippingService) {\n        _repository = repository;\n        _shippingService = shippingService;\n    }\n    public async Task<ShipmentResult> Handle(\n        ShipOrderCommand command,\n        CancellationToken cancellationToken) {\n        // Load aggregate from event store\n        var order = await _repository GetByIdAsync(command OrderId, cancellationToken);\n        if (order == null) {\n            throw new NotFoundException($\"Order {command OrderId} not found\");\n        }\n        // Request shipment\n        var shipment = await _shippingService CreateShipment(\n            order Id,\n            order ShippingAddress,\n            cancellationToken\n        );\n        // Apply ship command to aggregate (generates OrderShipped event)\n        order Ship(shipment TrackingNumber, shipment Carrier);\n        // Save aggregate (appends new event to stream)\n        await _repository SaveAsync(order, cancellationToken);\n        return new ShipmentResult(\n            shipment TrackingNumber,\n            shipment Carrier,\n            shipment EstimatedDelivery\n        );\n    }\n}\n`\nStep 4: Configure Event Store\n`csharp{\ntitle: \"Event Store Configuration\"\ndescription: \"Configure Whizbang with event sourcing and storage\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Configuration\", \"Event Store\", \"PostgreSQL\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang PostgreSQL\"]\nfilename: \"Program cs\"\nshowLineNumbers: true\nhighlightLines: [9, 14, 19]\nusingStatements: [\"Whizbang EventSourcing\", \"Microsoft Extensions DependencyInjection\"]\n}\nusing Whizbang EventSourcing;\nusing Microsoft AspNetCore Builder;\nusing Microsoft Extensions DependencyInjection;\nusing MyApp Orders Handlers;\nvar builder = WebApplication CreateBuilder(args);\n// Configure Whizbang with event sourcing\nbuilder Services AddWhizbang(config => {\n    // Use event sourcing with PostgreSQL\n    config UseEventSourcing(options => {\n        options UsePostgreSQL(builder Configuration GetConnectionString(\"EventStore\"));\n        // Configure snapshots (optional optimization)\n        options EnableSnapshots(snapshot => {\n            snapshot",
        "startIndex": 9745,
        "preview": "var orderId = Guid NewGuid(); var order = new OrderAggregate( orderId, command CustomerId, command Items, command ShippingAddress ); // Save aggregate..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/event-sourcing-basics-chunk-6",
        "text": "AspNetCore Builder; using Microsoft Extensions DependencyInjection; using MyApp Orders Handlers; var builder = WebApplication CreateBuilder(args); // Configure Whizbang with event sourcing builder Services AddWhizbang(config => { // Use event sourcing with PostgreSQL config UseEventSourcing(options => { options UsePostgreSQL(builder Configuration GetConnectionString(\"EventStore\")); // Configure snapshots (optional optimization) options EnableSnapshots(snapshot => { snapshot Frequency = 10; // Create snapshot every 10 events\n            snapshot KeepSnapshots = 3; // Keep last 3 snapshots\n        });\n        // Configure event serialization\n        options UseJsonSerialization(json => {\n            json UseSystemTextJson();\n            json IncludeTypeInformation = true;\n        });\n    });\n    // Register handlers\n    config RegisterHandlersFromAssembly(typeof(Program) Assembly);\n    // Add projections (read models)\n    config RegisterProjectionsFromAssembly(typeof(Program) Assembly);\n});\n// Register domain services\nbuilder Services AddScoped<IInventoryService, InventoryService>();\nbuilder Services AddScoped<IShippingService, ShippingService>();\nbuilder Services AddControllers();\nvar app = builder Build();\n// Initialize event store schema\nawait app InitializeEventStore();\napp UseRouting();\napp MapControllers();\napp Run();\n`\nComplete Example\n`csharp{\ntitle: \"Complete Event Sourcing Example\"\ndescription: \"Full working example showing event sourcing from API to persistence\"\nframework: \"NET8\"\ncategory: \"Complete Example\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Event Sourcing\", \"Complete\", \"API\", \"Aggregate\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Microsoft AspNetCore Mvc\"]\nfilename: \"EventSourcedOrdersController cs\"\nshowLineNumbers: true\nhighlightLines: [22, 35, 50, 68]\ntestFile: \"EventSourcedOrdersTests cs\"\ntestMethod: \"CreateOrder_StoresEvents_AndRebuildsState\"\nusingStatements: [\"Whizbang EventSourcing\", \"Microsoft AspNetCore Mvc\", \"System Threading Tasks\"]\n}\nusing Whizbang EventSourcing;\nusing Microsoft AspNetCore Mvc;\nusing System;\nusing System Threading;\nusing System Threading Tasks;\nusing MyApp Orders Commands;\nusing MyApp Orders Queries;\nnamespace MyApp Controllers;\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class OrdersController : ControllerBase {\n    private readonly IMediator _mediator;\n    private readonly IEventStore _eventStore;\n    public OrdersController(IMediator mediator, IEventStore eventStore) {\n        _mediator = mediator;\n        _eventStore = eventStore;\n    }\n    [HttpPost]\n    public async Task<ActionResult<OrderCreatedResult>> CreateOrder(\n        [FromBody] CreateOrderRequest request,\n        CancellationToken cancellationToken) {\n        var command = new CreateOrderCommand(\n            request CustomerId,\n            request Items,\n            request ShippingAddress\n        );\n        var result = await _dispatcher Send(command, cancellationToken);\n        return CreatedAtAction(\n            nameof(GetOrder),\n            new { orderId = result",
        "startIndex": 12439,
        "preview": "AspNetCore Builder; using Microsoft Extensions DependencyInjection; using MyApp Orders Handlers; var builder = WebApplication CreateBuilder(args); // ..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/event-sourcing-basics-chunk-7",
        "text": "OrdersController(IMediator mediator, IEventStore eventStore) { _mediator = mediator; _eventStore = eventStore; } [HttpPost] public async Task<ActionResult<OrderCreatedResult>> CreateOrder( [FromBody] CreateOrderRequest request, CancellationToken cancellationToken) { var command = new CreateOrderCommand( request CustomerId, request Items, request ShippingAddress ); var result = await _dispatcher Send(command, cancellationToken); return CreatedAtAction( nameof(GetOrder), new { orderId = result OrderId },\n            result\n        );\n    }\n    [HttpPost(\"{orderId}/ship\")]\n    public async Task<ActionResult<ShipmentResult>> ShipOrder(\n        Guid orderId,\n        [FromBody] ShipOrderRequest request,\n        CancellationToken cancellationToken) {\n        var command = new ShipOrderCommand(orderId, \"\", \"\"); // TODO: Get tracking details\n        var result = await _dispatcher Send(command, cancellationToken);\n        return Ok(result);\n    }\n    [HttpGet(\"{orderId}\")]\n    public async Task<ActionResult<OrderDetails>> GetOrder(\n        Guid orderId,\n        CancellationToken cancellationToken) {\n        // Query uses projection (read model)\n        var query = new GetOrderByIdQuery(orderId);\n        var result = await _mediator Send(query, cancellationToken);\n        if (result == null) {\n            return NotFound();\n        }\n        return Ok(result);\n    }\n    [HttpGet(\"{orderId}/history\")]\n    public async Task<ActionResult<OrderHistory>> GetOrderHistory(\n        Guid orderId,\n        CancellationToken cancellationToken) {\n        // Get all events for this aggregate\n        var events = await _eventStore GetEvents(\n            $\"Order-{orderId}\",\n            cancellationToken\n        );\n        // Map events to history entries\n        var history = events Select(e => new HistoryEntry {\n            EventType = e GetType() Name,\n            OccurredAt = e OccurredAt,\n            Data = e,\n            Version = e Version\n        }) ToList();\n        return Ok(new OrderHistory {\n            OrderId = orderId,\n            Events = history,\n            CurrentVersion = events LastOrDefault() Version 0\n        });\n    }\n    [HttpGet(\"{orderId}/at/{timestamp}\")]\n    public async Task<ActionResult<OrderSnapshot>> GetOrderAtPointInTime(\n        Guid orderId,\n        DateTime timestamp,\n        CancellationToken cancellationToken) {\n        // Replay events up to specific point in time\n        var events = await _eventStore GetEvents(\n            $\"Order-{orderId}\",\n            upTo: timestamp,\n            cancellationToken\n        );\n        // Rebuild aggregate state at that point\n        var aggregate = new OrderAggregate();\n        aggregate LoadFromHistory(events);\n        return Ok(new OrderSnapshot {\n            OrderId = orderId,\n            AsOf = timestamp,\n            State = aggregate,\n            Version = events LastOrDefault() Version",
        "startIndex": 14992,
        "preview": "OrdersController(IMediator mediator, IEventStore eventStore) { _mediator = mediator; _eventStore = eventStore; } [HttpPost] public async Task<ActionRe..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/event-sourcing-basics-chunk-8",
        "text": "events up to specific point in time var events = await _eventStore GetEvents( $\"Order-{orderId}\", upTo: timestamp, cancellationToken ); // Rebuild aggregate state at that point var aggregate = new OrderAggregate(); aggregate LoadFromHistory(events); return Ok(new OrderSnapshot { OrderId = orderId, AsOf = timestamp, State = aggregate, Version = events LastOrDefault() Version 0\n        });\n    }\n}\n`\nTesting Strategy\nTesting Aggregates\n`csharp{\ntitle: \"Aggregate Unit Tests\"\ndescription: \"Test aggregate behavior and event generation\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Unit Testing\", \"Aggregates\", \"Events\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"xUnit\"]\nfilename: \"OrderAggregateTests cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang EventSourcing\", \"Xunit\", \"System\"]\n}\nusing Whizbang EventSourcing;\nusing Xunit;\nusing System;\nusing System Collections Generic;\nusing System Linq;\nusing MyApp Orders Aggregates;\nusing MyApp Orders Events;\nnamespace MyApp Tests Orders;\npublic class OrderAggregateTests {\n    [Fact]\n    public void Constructor_ValidOrder_GeneratesOrderCreatedEvent() {\n        // Arrange\n        var orderId = Guid NewGuid();\n        var customerId = Guid NewGuid();\n        var items = new List<OrderItem> {\n            new OrderItem(\"PROD-1\", \"Widget\", 2, 10 00m)\n        };\n        // Act\n        var aggregate = new OrderAggregate(orderId, customerId, items, \"123 Main St\");\n        // Assert\n        var events = aggregate GetUncommittedEvents();\n        Assert Single(events);\n        var createdEvent = Assert IsType<OrderCreated>(events First());\n        Assert Equal(orderId, createdEvent OrderId);\n        Assert Equal(customerId, createdEvent CustomerId);\n        Assert Equal(20 00m, createdEvent TotalAmount);\n    }\n    [Fact]\n    public void Ship_ValidOrder_GeneratesOrderShippedEvent() {\n        // Arrange\n        var aggregate = CreateTestAggregate();\n        // Act\n        aggregate Ship(\"TRACK123\", \"FedEx\");\n        // Assert\n        var events = aggregate GetUncommittedEvents();\n        var shippedEvent = Assert IsType<OrderShipped>(events Last());\n        Assert Equal(\"TRACK123\", shippedEvent TrackingNumber);\n        Assert Equal(OrderStatus Shipped, aggregate Status);\n    }\n    [Fact]\n    public void Cancel_ShippedOrder_ThrowsException() {\n        // Arrange\n        var aggregate = CreateTestAggregate();\n        aggregate Ship(\"TRACK123\", \"FedEx\");\n        aggregate MarkEventsAsCommitted();\n        // Act & Assert\n        var exception = Assert Throws<DomainException>(\n            () => aggregate Cancel(\"Customer request\")\n        );\n        Assert Contains(\"Cannot cancel shipped order\", exception Message);\n    }\n    [Fact]\n    public void LoadFromHistory_RebuildsState() {\n        // Arrange\n        var orderId = Guid NewGuid();\n        var events = new List<DomainEvent> {\n            new OrderCreated(\n                orderId,\n                Guid",
        "startIndex": 17395,
        "preview": "events up to specific point in time var events = await _eventStore GetEvents( $\"Order-{orderId}\", upTo: timestamp, cancellationToken ); // Rebuild agg..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/event-sourcing-basics-chunk-9",
        "text": "aggregate Ship(\"TRACK123\", \"FedEx\"); aggregate MarkEventsAsCommitted(); // Act & Assert var exception = Assert Throws<DomainException>( () => aggregate Cancel(\"Customer request\") ); Assert Contains(\"Cannot cancel shipped order\", exception Message); } [Fact] public void LoadFromHistory_RebuildsState() { // Arrange var orderId = Guid NewGuid(); var events = new List<DomainEvent> { new OrderCreated( orderId, Guid NewGuid(),\n                new List<OrderItem> { new OrderItem(\"P1\", \"Widget\", 1, 10 00m) },\n                10 00m,\n                \"123 Main St\",\n                DateTime UtcNow\n            ),\n            new OrderItemAdded(\n                orderId,\n                new OrderItem(\"P2\", \"Gadget\", 2, 5 00m),\n                20 00m\n            ),\n            new OrderShipped(\n                orderId,\n                \"TRACK123\",\n                \"UPS\",\n                DateTime UtcNow\n            )\n        };\n        // Act\n        var aggregate = new OrderAggregate();\n        aggregate LoadFromHistory(events);\n        // Assert\n        Assert Equal(orderId, aggregate Id);\n        Assert Equal(2, aggregate Items Count);\n        Assert Equal(20 00m, aggregate TotalAmount);\n        Assert Equal(OrderStatus Shipped, aggregate Status);\n        Assert Equal(\"TRACK123\", aggregate TrackingNumber);\n    }\n    private OrderAggregate CreateTestAggregate() {\n        return new OrderAggregate(\n            Guid NewGuid(),\n            Guid NewGuid(),\n            new List<OrderItem> { new OrderItem(\"P1\", \"Widget\", 1, 10 00m) },\n            \"123 Main St\"\n        );\n    }\n}\n`\nCommon Pitfalls\nDon't Modify Events After Creation\n`csharp{\ntitle: \"Don't Modify Events After Creation\"\ndescription: \"Events must be immutable - create new events with correct data instead\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Usage Patterns\", \"Event Sourcing\", \"Immutability\", \"Best Practices\"]\nfilename: \"ImmutableEvents cs\"\nshowLineNumbers: true\nusingStatements: [\"System\"]\n}\n// ❌ BAD - Events are immutable\nvar @event = new OrderCreated( );\n@event TotalAmount = 100; // Compiler error - records are immutable\n// ✅ GOOD - Create new event with correct data\nvar @event = new OrderCreated( , TotalAmount: 100, );\n`\nAvoid Side Effects in Event Handlers\n`csharp{\ntitle: \"Avoid Side Effects in Event Handlers\"\ndescription: \"Keep event handlers pure - only update state, no side effects\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"Event Sourcing\", \"Pure Functions\", \"Best Practices\"]\nfilename: \"PureEventHandlers",
        "startIndex": 19974,
        "preview": "aggregate Ship(\"TRACK123\", \"FedEx\"); aggregate MarkEventsAsCommitted(); // Act & Assert var exception = Assert Throws<DomainException>( () => aggregat..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/event-sourcing-basics-chunk-10",
        "text": "OrderCreated( , TotalAmount: 100, ); ` Avoid Side Effects in Event Handlers `csharp{ title: \"Avoid Side Effects in Event Handlers\" description: \"Keep event handlers pure - only update state, no side effects\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"INTERMEDIATE\" tags: [\"Usage Patterns\", \"Event Sourcing\", \"Pure Functions\", \"Best Practices\"] filename: \"PureEventHandlers cs\"\nshowLineNumbers: true\nusingStatements: [\"System\"]\n}\n// ❌ BAD - Side effects in When method\nprotected void When(OrderShipped @event) {\n    Status = OrderStatus Shipped;\n    EmailService SendNotification( ); // NO Side effects don't belong here\n}\n// ✅ GOOD - Pure state updates only\nprotected void When(OrderShipped @event) {\n    Status = OrderStatus Shipped;\n    TrackingNumber = @event TrackingNumber;\n}\n`\nDon't Query in Receptors\n`csharp{\ntitle: \"Don't Query in Receptors\"\ndescription: \"Keep receptors pure by avoiding external queries - use lenses or pass data in commands\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Usage Patterns\", \"Event Sourcing\", \"Receptors\", \"Pure Functions\"]\nfilename: \"PureReceptors cs\"\nshowLineNumbers: true\nusingStatements: [\"System\", \"System Threading Tasks\"]\n}\n// ❌ BAD - Receptor querying external data\npublic class OrderReceptor : IReceptor<ShipOrderCommand> {\n    public async Task<OrderShipped> Receive(ShipOrderCommand cmd) {\n        var inventory = await _inventoryService Check(); // NO Receptors should be pure\n    }\n}\n// ✅ GOOD - Use lenses for validation or pass data in command\npublic OrderShipped Receive(ShipOrderCommand cmd, IInventoryLens lens) {\n    if ( lens IsAvailable(cmd OrderId)) {\n        throw new DomainException(\"Insufficient inventory\");\n    }\n    return new OrderShipped( );\n}\n`\nProgressive Enhancement\nAdd Snapshots for Performance\n`csharp{\ntitle: \"Add Snapshots for Performance\"\ndescription: \"Implement snapshots to optimize event replay for aggregates with many events\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Usage Patterns\", \"Event Sourcing\", \"Snapshots\", \"Performance\"]\nfilename: \"SnapshotOptimization cs\"\nshowLineNumbers: true\nusingStatements: [\"System\", \"System Collections Generic\", \"System Linq\"]\n}\n// Configure snapshot strategy\nledger EnableSnapshots(snapshot => {\n    snapshot Frequency = 10; // Every 10 events\n    snapshot",
        "startIndex": 22157,
        "preview": "OrderCreated( , TotalAmount: 100, ); ` Avoid Side Effects in Event Handlers `csharp{ title: \"Avoid Side Effects in Event Handlers\" description: \"Keep ..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/event-sourcing-basics-chunk-11",
        "text": "replay for aggregates with many events\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"ADVANCED\" tags: [\"Usage Patterns\", \"Event Sourcing\", \"Snapshots\", \"Performance\"] filename: \"SnapshotOptimization cs\" showLineNumbers: true usingStatements: [\"System\", \"System Collections Generic\", \"System Linq\"] } // Configure snapshot strategy ledger EnableSnapshots(snapshot => { snapshot Frequency = 10; // Every 10 events snapshot Strategy = SnapshotStrategy Automatic;\n});\n// Implement snapshot interface on receptor\n[EventSourced]\npublic class OrderReceptor : IReceptor<CreateOrderCommand>, ISnapshotable {\n    // receptor implementation public Snapshot TakeSnapshot() {\n        return new OrderSnapshot {\n            Id = id,\n            CustomerId = customerId,\n            Items = items ToList(),\n            Status = status,\n            Version = GetVersion()\n        };\n    }\n    public void RestoreFromSnapshot(Snapshot snapshot) {\n        var orderSnapshot = (OrderSnapshot)snapshot;\n        id = orderSnapshot Id;\n        customerId = orderSnapshot CustomerId;\n        items = orderSnapshot Items;\n        status = orderSnapshot Status;\n        SetVersion(orderSnapshot Version);\n    }\n}\n`\nAdd Perspectives for Queries\nSee Perspectives Documentation for detailed perspective patterns Scale with Event Streams\n`csharp{\ntitle: \"Scale with Event Streams\"\ndescription: \"Configure multiple event streams for better performance and scalability\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Usage Patterns\", \"Event Sourcing\", \"Scaling\", \"Streams\"]\nfilename: \"EventStreamScaling cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Configure multiple streams\ndispatcher UseEventSourcing(es => {\n    es UseLedger(ledger => {\n        ledger ConfigureStreams(streams => {\n            streams PartitionBy<OrderReceptor>(r => r CustomerId);\n            streams EnableParallelProcessing(maxDegree: 4);\n        });\n    });\n});\n`\nRelated Patterns\nEvent-Driven Dispatcher Pattern - Start without event sourcing\nPerspectives Documentation - Optimize reads with multiple views\nSaga Orchestration - Coordinate multi-receptor workflows\nProduction Considerations\nEvent Schema Evolution\n`csharp{\ntitle: \"Event Schema Evolution\"\ndescription: \"Version your events and provide migration logic for schema changes\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Usage Patterns\", \"Event Sourcing\", \"Schema Evolution\", \"Versioning\"]\nfilename: \"EventVersioning cs\"\nshowLineNumbers: true\nusingStatements: [\"System\"]\n}\n// Version your events\npublic record OrderCreatedV2(\n    // New fields",
        "startIndex": 24133,
        "preview": "replay for aggregates with many events\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"ADVANCED\" tags: [\"Usage Patterns\", \"Event Sourcing\",..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/event-sourcing-basics-chunk-12",
        "text": "Evolution `csharp{ title: \"Event Schema Evolution\" description: \"Version your events and provide migration logic for schema changes\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"ADVANCED\" tags: [\"Usage Patterns\", \"Event Sourcing\", \"Schema Evolution\", \"Versioning\"] filename: \"EventVersioning cs\" showLineNumbers: true usingStatements: [\"System\"] } // Version your events public record OrderCreatedV2( // New fields ) : OrderEvent, IUpgradeFrom<OrderCreated> {\n    public OrderCreatedV2 UpgradeFrom(OrderCreated old) {\n        // Migration logic\n    }\n}\n`\nEvent Store Maintenance\nRegular backups of event store\nMonitor stream sizes\nArchive old events if needed\nIndex frequently queried streams\nPerformance Optimization\nUse snapshots for aggregates with many events\nImplement caching for frequently accessed aggregates\nConsider async projections for read models\nMonitor event replay times\nNext Steps\nLearn about Perspectives for read model optimization\nExplore Saga Orchestration for complex workflows\nReview Receptors Documentation for advanced patterns\nCheck out Lenses for building query interfaces",
        "startIndex": 26363,
        "preview": "Evolution `csharp{ title: \"Event Schema Evolution\" description: \"Version your events and provide migration logic for schema changes\" framework: \"NET8\"..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/usage-patterns/microservices-integration",
    "title": "Microservices Integration",
    "category": "Usage Patterns",
    "url": "/docs/old-v1.0.0.0/usage-patterns/microservices-integration",
    "chunks": [
      {
        "id": "old-v1.0.0.0/usage-patterns/microservices-integration-chunk-0",
        "text": "Microservices Integration\nOverview\nWhizbang provides first-class support for building microservices with NET Aspire, Microsoft's opinionated stack for cloud-native applications This pattern shows how to structure, deploy, and operate Whizbang-based microservices in production Key Components\nService Boundaries: Define bounded contexts and aggregates NET Aspire Integration: Orchestration and observability\nService Discovery: Automatic service registration and discovery\nHealth Monitoring: Liveness and readiness probes\nDistributed Tracing: End-to-end request tracking\nArchitecture Diagram\n`mermaid\ngraph TB\n    subgraph \"API Gateway\"\n        GW[Gateway]\n    end\n    subgraph \"Order Service\"\n        OS[Order API]\n        OE[(Event Store)]\n        OP[Projections]\n    end\n    subgraph \"Inventory Service\"\n        IS[Inventory API]\n        IE[(Event Store)]\n        IP[Projections]\n    end\n    subgraph \"Payment Service\"\n        PS[Payment API]\n        PE[(Event Store)]\n        PP[Projections]\n    end\n    subgraph \"Infrastructure\"\n        SD[Service Discovery]\n        MB[Message Broker]\n        TR[Tracing]\n    end\n    GW --> OS\n    GW --> IS\n    GW --> PS\n    OS - -> MB\n    IS - -> MB\n    PS - -> MB\n    OS --> SD\n    IS --> SD\n    PS --> SD\n    style MB fill:#0066cc,color:#fff\n    style SD fill:#28a745,color:#fff\n`\nImplementation Guide\nDocumentation in progress - This page demonstrates the structure for microservices integration patterns with Whizbang Topics to Cover:\nService Design\nBounded context definition\nAPI contracts\nEvent contracts\nShared kernels NET Aspire Setup\nApp host configuration\nService registration\nResource provisioning\nEnvironment configuration\nService Communication\nSynchronous HTTP calls\nAsynchronous messaging\ngRPC integration\nCircuit breakers\nData Management\nDatabase per service\nEvent store partitioning\nCross-service queries\nData consistency\nDeployment Strategies\nKubernetes deployment\nContainer orchestration\nBlue-green deployments\nCanary releases\nExample: Aspire Configuration\n`csharp{\ntitle: \"Aspire App Host Configuration\"\ndescription: \"Placeholder for NET Aspire distributed application setup\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Aspire\", \"Microservices\", \"Distributed Applications\"]\nfilename: \"Program cs\"\nusingStatements: [\"Microsoft Extensions Hosting\"]\n}\n// Placeholder for Aspire app host configuration\nvar builder = DistributedApplication",
        "startIndex": 0,
        "preview": "Microservices Integration\nOverview\nWhizbang provides first-class support for building microservices with NET Aspire, Microsoft's opinionated stack for..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/microservices-integration-chunk-1",
        "text": "Canary releases Example: Aspire Configuration `csharp{ title: \"Aspire App Host Configuration\" description: \"Placeholder for NET Aspire distributed application setup\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"ADVANCED\" tags: [\"Aspire\", \"Microservices\", \"Distributed Applications\"] filename: \"Program cs\" usingStatements: [\"Microsoft Extensions Hosting\"] } // Placeholder for Aspire app host configuration var builder = DistributedApplication CreateBuilder(args);\n// Service configuration coming soon\n`\nRelated Patterns\nDistributed Messaging - Service communication patterns\nSaga Orchestration - Multi-service workflows\nEvent Sourcing Basics - Service data patterns\nProduction Considerations\nObservability\nDistributed tracing with OpenTelemetry\nCentralized logging with structured logs\nMetrics aggregation and alerting\nService dependency mapping\nResilience\nCircuit breaker patterns\nRetry policies with exponential backoff\nBulkhead isolation\nTimeout configuration\nSecurity\nService-to-service authentication\nAPI gateway security\nSecret management\nNetwork policies\nNext Steps\nReview NET Aspire Integration for setup details\nExplore Advanced Configuration for production settings\nCheck Dashboard Documentation for monitoring",
        "startIndex": 2432,
        "preview": "Canary releases Example: Aspire Configuration `csharp{ title: \"Aspire App Host Configuration\" description: \"Placeholder for NET Aspire distributed app..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/usage-patterns/policy-composition",
    "title": "Policy Composition",
    "category": "Usage Patterns",
    "url": "/docs/old-v1.0.0.0/usage-patterns/policy-composition",
    "chunks": [
      {
        "id": "old-v1.0.0.0/usage-patterns/policy-composition-chunk-0",
        "text": "Policy Composition\nOverview\nPolicy Composition in Whizbang allows you to build resilient applications by combining multiple policies like retry, circuit breaker, timeout, and fallback Inspired by Polly's approach but integrated seamlessly with our aspect-oriented architecture Core Concepts\nPolicies as Aspects\nIn Whizbang, resilience policies are first-class aspects that can be composed declaratively:\n`csharp{\ntitle: \"Declarative Policy Composition\"\ndescription: \"Combine multiple resilience policies via attributes\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Policies\", \"Resilience\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"ResilientHandler cs\"\nshowLineNumbers: true\nhighlightLines: [1, 2, 3, 4]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[Retry(3, Backoff = \"exponential\", DelayMs = 100)]\n[CircuitBreaker(Threshold = 5, Duration = \"30s\")]\n[Timeout(Seconds = 10)]\n[Fallback(typeof(OrderFallbackHandler))]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd, IOrderService service) {\n        // This handler is automatically wrapped with:\n        // 1 Exponential backoff retry (3 attempts)\n        // 2 Circuit breaker (opens after 5 failures)\n        // 3 10-second timeout\n        // 4 Fallback handler if all else fails\n        var order = service CreateOrder(cmd);\n        return new OrderCreated(order Id);\n    }\n}\n`\nBasic Policies\nRetry Policy\n`csharp{\ntitle: \"Retry Policy Examples\"\ndescription: \"Different retry strategies for various scenarios\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"BEGINNER\"\ntags: [\"Retry\", \"Resilience\", \"Error Handling\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"RetryExamples cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Simple retry with fixed delay\n[Retry(3, DelayMs = 1000)]\npublic class SimpleRetryHandler : IHandle<ProcessPayment> {\n    public PaymentProcessed Handle(ProcessPayment cmd) {\n        return paymentGateway Process(cmd);\n    }\n}\n// Exponential backoff\n[Retry(5, Backoff = \"exponential\", DelayMs = 100, MaxDelayMs = 10000)]\npublic class ExponentialRetryHandler : IHandle<CallExternalApi> {\n    // Delays: 100ms, 200ms, 400ms, 800ms, 1600ms\n    public ApiResponse Handle(CallExternalApi cmd) {\n        return externalApi",
        "startIndex": 0,
        "preview": "Policy Composition\nOverview\nPolicy Composition in Whizbang allows you to build resilient applications by combining multiple policies like retry, circu..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/policy-composition-chunk-1",
        "text": "1000)] public class SimpleRetryHandler : IHandle<ProcessPayment> { public PaymentProcessed Handle(ProcessPayment cmd) { return paymentGateway Process(cmd); } } // Exponential backoff [Retry(5, Backoff = \"exponential\", DelayMs = 100, MaxDelayMs = 10000)] public class ExponentialRetryHandler : IHandle<CallExternalApi> { // Delays: 100ms, 200ms, 400ms, 800ms, 1600ms public ApiResponse Handle(CallExternalApi cmd) { return externalApi Call(cmd);\n    }\n}\n// Retry only specific exceptions\n[Retry(3, \n    RetryOn = new[] { typeof(TransientException), typeof(TimeoutException) },\n    SkipOn = new[] { typeof(ValidationException) }\n)]\npublic class SelectiveRetryHandler : IHandle<UpdateInventory> {\n    public InventoryUpdated Handle(UpdateInventory cmd) {\n        return inventory Update(cmd);\n    }\n}\n// Retry with jitter to prevent thundering herd\n[Retry(3, Backoff = \"exponential-jitter\", DelayMs = 100)]\npublic class JitteredRetryHandler : IHandle<BulkOperation> {\n    // Adds randomization to prevent synchronized retries\n    public BulkResult Handle(BulkOperation cmd) {\n        return bulkService Process(cmd);\n    }\n}\n`\nCircuit Breaker\n`csharp{\ntitle: \"Circuit Breaker Policy\"\ndescription: \"Prevent cascading failures with circuit breaker pattern\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Circuit Breaker\", \"Resilience\", \"Fault Tolerance\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"CircuitBreakerExamples cs\"\nshowLineNumbers: true\nhighlightLines: [1, 15, 29]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Basic circuit breaker\n[CircuitBreaker(\n    Threshold = 5,           // Open after 5 failures\n    Duration = \"30s\",        // Stay open for 30 seconds\n    SuccessesRequired = 2    // Need 2 successes to close\n)]\npublic class ProtectedHandler : IHandle<CallDownstreamService> {\n    public ServiceResponse Handle(CallDownstreamService cmd) {\n        return downstreamService Call(cmd);\n    }\n}\n// Advanced circuit breaker with sampling\n[CircuitBreaker(\n    SamplingDuration = \"10s\",     // Sample over 10 seconds\n    FailureRate = 0 5,            // Open if 50% of calls fail\n    MinimumThroughput = 10,       // Need at least 10 calls in window\n    Duration = \"60s\"               // Stay open for 60 seconds\n)]\npublic class AdvancedCircuitHandler : IHandle<HighVolumeOperation> {\n    public OperationResult Handle(HighVolumeOperation cmd) {\n        return highVolumeService",
        "startIndex": 2314,
        "preview": "1000)] public class SimpleRetryHandler : IHandle<ProcessPayment> { public PaymentProcessed Handle(ProcessPayment cmd) { return paymentGateway Process(..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/policy-composition-chunk-2",
        "text": "// Sample over 10 seconds FailureRate = 0 5, // Open if 50% of calls fail MinimumThroughput = 10, // Need at least 10 calls in window Duration = \"60s\" // Stay open for 60 seconds )] public class AdvancedCircuitHandler : IHandle<HighVolumeOperation> { public OperationResult Handle(HighVolumeOperation cmd) { return highVolumeService Execute(cmd);\n    }\n}\n// Circuit breaker with custom break condition\n[CircuitBreaker(\n    BreakOn = result => result is ErrorResult { Code: \"CRITICAL\" },\n    Duration = \"120s\"\n)]\npublic class CustomBreakHandler : IHandle<CriticalOperation> {\n    public Result<OperationSuccess> Handle(CriticalOperation cmd) {\n        return criticalService Execute(cmd);\n    }\n}\n`\nTimeout Policy\n`csharp{\ntitle: \"Timeout Policy\"\ndescription: \"Prevent operations from running indefinitely\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"BEGINNER\"\ntags: [\"Timeout\", \"Resilience\", \"Performance\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"TimeoutExamples cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\", \"System Threading\"]\n}\n// Simple timeout\n[Timeout(Seconds = 5)]\npublic class TimeoutHandler : IHandle<LongRunningQuery> {\n    public QueryResult Handle(LongRunningQuery query) {\n        return database ExecuteComplexQuery(query);\n    }\n}\n// Pessimistic timeout (cancels the operation)\n[Timeout(Seconds = 10, Mode = \"pessimistic\")]\npublic class PessimisticTimeoutHandler : IHandle<CancellableOperation> {\n    public async Task<Result> Handle(CancellableOperation cmd, CancellationToken ct) {\n        // Operation receives cancellation token\n        return await longService ExecuteAsync(cmd, ct);\n    }\n}\n// Optimistic timeout (just gives up waiting)\n[Timeout(Seconds = 3, Mode = \"optimistic\")]\npublic class OptimisticTimeoutHandler : IHandle<FireAndForget> {\n    public void Handle(FireAndForget cmd) {\n        // We stop waiting after 3 seconds, but operation continues\n        backgroundService Process(cmd);\n    }\n}\n`\nFallback Policy\n`csharp{\ntitle: \"Fallback Policy\"\ndescription: \"Provide alternative results when primary operation fails\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Fallback\", \"Resilience\", \"Error Recovery\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"FallbackExamples cs\"\nshowLineNumbers: true\nhighlightLines: [1, 12, 23]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Fallback to another handler\n[Fallback(typeof(CachedDataHandler))]\npublic class LiveDataHandler : IHandle<GetProductData> {\n    public ProductData Handle(GetProductData query) {\n        return liveService GetProduct(query",
        "startIndex": 4297,
        "preview": "// Sample over 10 seconds FailureRate = 0 5, // Open if 50% of calls fail MinimumThroughput = 10, // Need at least 10 calls in window Duration = \"60s\"..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/policy-composition-chunk-3",
        "text": "primary operation fails\" framework: \"NET8\" category: \"Resilience\" difficulty: \"INTERMEDIATE\" tags: [\"Fallback\", \"Resilience\", \"Error Recovery\"] nugetPackages: [\"Whizbang Core\"] filename: \"FallbackExamples cs\" showLineNumbers: true highlightLines: [1, 12, 23] usingStatements: [\"Whizbang\", \"System\"] } // Fallback to another handler [Fallback(typeof(CachedDataHandler))] public class LiveDataHandler : IHandle<GetProductData> { public ProductData Handle(GetProductData query) { return liveService GetProduct(query ProductId);\n    }\n}\n// Fallback with inline value\n[Fallback(Value = \"DefaultResponse\")]\npublic class ServiceHandler : IHandle<GetConfiguration> {\n    public string Handle(GetConfiguration query) {\n        return configService Get(query Key);\n    }\n}\n// Fallback with factory method\n[Fallback(Factory = nameof(CreateDefaultOrder))]\npublic class OrderHandler : IHandle<GetOrder> {\n    public Order Handle(GetOrder query) {\n        return orderService Get(query OrderId);\n    }\n    private Order CreateDefaultOrder(GetOrder query) {\n        return new Order { \n            Id = query OrderId, \n            Status = \"Unknown\",\n            Items = new List<OrderItem>()\n        };\n    }\n}\n`\nAdvanced Composition\nPolicy Wrapping\n`csharp{\ntitle: \"Advanced Policy Composition\"\ndescription: \"Combine multiple policies for comprehensive resilience\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"ADVANCED\"\ntags: [\"Policy Composition\", \"Resilience\", \"Advanced\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"AdvancedComposition cs\"\nshowLineNumbers: true\nhighlightLines: [1, 2, 3, 4, 5]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Policies execute in order: Retry -> CircuitBreaker -> Timeout -> Fallback\n[Retry(3, Backoff = \"exponential\")]\n[CircuitBreaker(Threshold = 10, Duration = \"60s\")]\n[Timeout(Seconds = 5)]\n[Fallback(typeof(CachedInventoryHandler))]\n[Logged(OnError = true)]\npublic class ResilientInventoryHandler : IHandle<CheckInventory> {\n    public InventoryStatus Handle(CheckInventory query) {\n        // Execution flow:\n        // 1 Timeout wraps the actual call\n        // 2 Circuit breaker tracks failures\n        // 3 Retry handles transient failures\n        // 4 Fallback provides last resort\n        // 5 Everything is logged\n        return inventoryService Check(query);\n    }\n}\n// Conditional policies based on context\n[ConditionalPolicy(typeof(PeakHoursPolicy), Condition = nameof(IsPeakHours))]\n[ConditionalPolicy(typeof(StandardPolicy), Condition = nameof(IsStandardHours))]\npublic class AdaptiveHandler : IHandle<ProcessOrder> {\n    public OrderProcessed Handle(ProcessOrder cmd) {\n        return orderProcessor Process(cmd);\n    }\n    private bool IsPeakHours() => DateTime Now Hour >= 9 && DateTime Now Hour <= 17;\n    private bool IsStandardHours() =>",
        "startIndex": 6549,
        "preview": "primary operation fails\" framework: \"NET8\" category: \"Resilience\" difficulty: \"INTERMEDIATE\" tags: [\"Fallback\", \"Resilience\", \"Error Recovery\"] nugetP..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/policy-composition-chunk-4",
        "text": "} } // Conditional policies based on context [ConditionalPolicy(typeof(PeakHoursPolicy), Condition = nameof(IsPeakHours))] [ConditionalPolicy(typeof(StandardPolicy), Condition = nameof(IsStandardHours))] public class AdaptiveHandler : IHandle<ProcessOrder> { public OrderProcessed Handle(ProcessOrder cmd) { return orderProcessor Process(cmd); } private bool IsPeakHours() => DateTime Now Hour >= 9 && DateTime Now Hour <= 17; private bool IsStandardHours() => IsPeakHours();\n}\n`\nBulkhead Isolation\n`csharp{\ntitle: \"Bulkhead Pattern\"\ndescription: \"Isolate resources to prevent total system failure\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"ADVANCED\"\ntags: [\"Bulkhead\", \"Isolation\", \"Resilience\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"BulkheadExamples cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Limit concurrent executions\n[Bulkhead(\n    MaxConcurrency = 10,\n    MaxQueueLength = 100\n)]\npublic class ThrottledHandler : IHandle<HighLoadOperation> {\n    public Result Handle(HighLoadOperation cmd) {\n        // Only 10 concurrent executions allowed\n        // Up to 100 can queue, rest rejected immediately\n        return service Execute(cmd);\n    }\n}\n// Separate bulkheads for different operations\n[Bulkhead(Name = \"critical\", MaxConcurrency = 20)]\npublic class CriticalHandler : IHandle<CriticalOperation> {\n    public Result Handle(CriticalOperation cmd) {\n        return criticalService Execute(cmd);\n    }\n}\n[Bulkhead(Name = \"standard\", MaxConcurrency = 5)]\npublic class StandardHandler : IHandle<StandardOperation> {\n    public Result Handle(StandardOperation cmd) {\n        return standardService Execute(cmd);\n    }\n}\n`\nRate Limiting\n`csharp{\ntitle: \"Rate Limiting\"\ndescription: \"Control the rate of operations to prevent overload\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Rate Limiting\", \"Throttling\", \"Resilience\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"RateLimitExamples cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Fixed window rate limiting\n[RateLimit(\n    Permits = 100,\n    Window = \"1m\"  // 100 requests per minute\n)]\npublic class RateLimitedHandler : IHandle<ApiCall> {\n    public ApiResponse Handle(ApiCall cmd) {\n        return api Call(cmd);\n    }\n}\n// Sliding window rate limiting\n[RateLimit(\n    Permits = 1000,\n    Window = \"1h\",\n    Mode = \"sliding\"\n)]\npublic class SlidingWindowHandler : IHandle<BulkOperation> {\n    public BulkResult Handle(BulkOperation cmd) {\n        return bulkService",
        "startIndex": 8830,
        "preview": "} } // Conditional policies based on context [ConditionalPolicy(typeof(PeakHoursPolicy), Condition = nameof(IsPeakHours))] [ConditionalPolicy(typeof(S..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/policy-composition-chunk-5",
        "text": "100 requests per minute )] public class RateLimitedHandler : IHandle<ApiCall> { public ApiResponse Handle(ApiCall cmd) { return api Call(cmd); } } // Sliding window rate limiting [RateLimit( Permits = 1000, Window = \"1h\", Mode = \"sliding\" )] public class SlidingWindowHandler : IHandle<BulkOperation> { public BulkResult Handle(BulkOperation cmd) { return bulkService Process(cmd);\n    }\n}\n// Token bucket rate limiting\n[RateLimit(\n    Mode = \"token-bucket\",\n    Capacity = 100,\n    RefillRate = 10,      // 10 tokens per second\n    RefillInterval = \"1s\"\n)]\npublic class TokenBucketHandler : IHandle<StreamingOperation> {\n    public StreamResult Handle(StreamingOperation cmd) {\n        return streamService Process(cmd);\n    }\n}\n`\nCustom Policies\nCreating Custom Policies\n`csharp{\ntitle: \"Custom Policy Implementation\"\ndescription: \"Build your own resilience policies\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"ADVANCED\"\ntags: [\"Custom Policies\", \"Extensibility\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"CustomPolicyExamples cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Define custom policy attribute\n[AttributeUsage(AttributeTargets Class | AttributeTargets Method)]\npublic class CacheAsideAttribute : PolicyAttribute {\n    public int DurationSeconds { get; set; } = 300;\n    public string CacheKey { get; set; }\n    public override IPolicy CreatePolicy() {\n        return new CacheAsidePolicy(DurationSeconds, CacheKey);\n    }\n}\n// Implement the policy\npublic class CacheAsidePolicy : IPolicy {\n    private readonly int _durationSeconds;\n    private readonly string _cacheKey;\n    public async Task<T> ExecuteAsync<T>(\n        Func<Task<T>> action,\n        PolicyContext context) {\n        // Try cache first\n        var cached = await cache GetAsync<T>(_cacheKey);\n        if (cached = null) {\n            return cached;\n        }\n        // Execute action\n        var result = await action();\n        // Cache result\n        await cache SetAsync(_cacheKey, result, _durationSeconds);\n        return result;\n    }\n}\n// Use custom policy\n[CacheAside(DurationSeconds = 600, CacheKey = \"products\")]\npublic class ProductHandler : IHandle<GetProducts> {\n    public Products Handle(GetProducts query) {\n        return productService GetAll();\n    }\n}\n`\nPolicy Context and Telemetry\n`csharp{\ntitle: \"Policy Context and Observability\"\ndescription: \"Track and monitor policy execution\"\nframework: \"NET8\"\ncategory: \"Resilience\"\ndifficulty: \"ADVANCED\"\ntags: [\"Telemetry\", \"Monitoring\", \"Context\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"PolicyTelemetry",
        "startIndex": 10894,
        "preview": "100 requests per minute )] public class RateLimitedHandler : IHandle<ApiCall> { public ApiResponse Handle(ApiCall cmd) { return api Call(cmd); } } // ..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/policy-composition-chunk-6",
        "text": "= \"products\")] public class ProductHandler : IHandle<GetProducts> { public Products Handle(GetProducts query) { return productService GetAll(); } } ` Policy Context and Telemetry `csharp{ title: \"Policy Context and Observability\" description: \"Track and monitor policy execution\" framework: \"NET8\" category: \"Resilience\" difficulty: \"ADVANCED\" tags: [\"Telemetry\", \"Monitoring\", \"Context\"] nugetPackages: [\"Whizbang Core\"] filename: \"PolicyTelemetry cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Policy with detailed telemetry\n[Retry(3, \n    OnRetry = nameof(LogRetry),\n    OnSuccess = nameof(LogSuccess),\n    OnFailure = nameof(LogFailure)\n)]\npublic class ObservableHandler : IHandle<CriticalOperation> {\n    private readonly ILogger _logger;\n    private readonly IMetrics _metrics;\n    public Result Handle(CriticalOperation cmd) {\n        return service Execute(cmd);\n    }\n    private void LogRetry(RetryContext context) {\n        _logger Warning(\"Retry {Attempt} after {Delay}ms: {Error}\",\n            context AttemptNumber,\n            context Delay TotalMilliseconds,\n            context LastException Message);\n        _metrics Increment(\"handler retries\", \n            tags: new { handler = nameof(ObservableHandler) });\n    }\n    private void LogSuccess(PolicyContext context) {\n        _logger Information(\"Operation succeeded after {Attempts} attempts\",\n            context Attempts);\n        _metrics RecordDuration(\"handler duration\", \n            context Duration,\n            tags: new { status = \"success\" });\n    }\n    private void LogFailure(PolicyContext context) {\n        _logger Error(\"Operation failed after {Attempts} attempts: {Error}\",\n            context Attempts,\n            context LastException Message);\n        _metrics Increment(\"handler failures\",\n            tags: new { handler = nameof(ObservableHandler) });\n    }\n}\n`\nTesting Policies\n`csharp{\ntitle: \"Testing Resilience Policies\"\ndescription: \"Verify policy behavior under various failure scenarios\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Testing\", \"Resilience\", \"Policies\"]\nnugetPackages: [\"Whizbang Core\", \"xUnit\"]\nfilename: \"PolicyTests cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang Testing\", \"Xunit\"]\n}\n[Fact]\npublic async Task RetryPolicy_RetriesOnTransientFailure() {\n    // Arrange\n    var test = await Whizbang Test<OrderHandler>() WithPolicy<RetryPolicy>() SimulateFailures(2)  // Fail twice, then succeed Given(new CreateOrder { });\n    // Act\n    var result = await test WhenHandled();\n    // Assert\n    result Should() BeSuccess();\n    test Policy<RetryPolicy>() Should() HaveRetried(2) WithDelays(\"100ms\", \"200ms\");\n}\n[Fact]\npublic async Task CircuitBreaker_OpensAfterThreshold() {\n    // Arrange\n    var test = await Whizbang Test<ServiceHandler>() WithPolicy<CircuitBreakerPolicy>();\n    // Act - Trigger failures\n    for (int i = 0; i < 5; i++) {\n        await test SimulateFailure()",
        "startIndex": 13119,
        "preview": "= \"products\")] public class ProductHandler : IHandle<GetProducts> { public Products Handle(GetProducts query) { return productService GetAll(); } } ` ..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/policy-composition-chunk-7",
        "text": "result = await test WhenHandled(); // Assert result Should() BeSuccess(); test Policy<RetryPolicy>() Should() HaveRetried(2) WithDelays(\"100ms\", \"200ms\"); } [Fact] public async Task CircuitBreaker_OpensAfterThreshold() { // Arrange var test = await Whizbang Test<ServiceHandler>() WithPolicy<CircuitBreakerPolicy>(); // Act - Trigger failures for (int i = 0; i < 5; i++) { await test SimulateFailure() WhenHandled(new CallService { });\n    }\n    // Assert - Circuit should be open\n    test Policy<CircuitBreakerPolicy>() Should() BeOpen() For(\"30s\");\n    // Further calls should fail immediately\n    await test WhenHandled(new CallService { }) Should() FailImmediately() WithException<CircuitBreakerOpenException>();\n}\n[Fact]\npublic async Task Fallback_ProvidesAlternativeValue() {\n    // Arrange\n    var test = await Whizbang Test<DataHandler>() WithPolicy<FallbackPolicy>() SimulateFailure();\n    // Act\n    var result = await test WhenHandled(new GetData { });\n    // Assert\n    result Should() BeFromFallback();\n    test Policy<FallbackPolicy>() Should() HaveExecutedFallback() WithValue(\"DefaultData\");\n}\n`\nBest Practices\nDo's\n✅ Layer policies appropriately\n`csharp{\ntitle: \"Layer Policies Appropriately\"\ndescription: \"Proper layering of resilience policies for comprehensive protection\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"Policies\", \"Resilience\", \"Best Practices\"]\nfilename: \"PolicyLayering cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[Retry(3)]           // Inner - handles transient failures\n[CircuitBreaker(5)]  // Middle - prevents cascading failures\n[Timeout(10)]        // Outer - ensures bounded execution time\n`\n✅ Use specific exception handling\n`csharp{\ntitle: \"Use Specific Exception Handling\"\ndescription: \"Configure policies to handle only specific exception types\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"Policies\", \"Exception Handling\", \"Best Practices\"]\nfilename: \"SpecificExceptionHandling cs\"\nshowLineNumbers: true\nusingStatements: [\"System\"]\n}\n[Retry(3, RetryOn = new[] { typeof(TransientException) })]\n`\n✅ Monitor and log policy actions\n`csharp{\ntitle: \"Monitor and Log Policy Actions\"\ndescription: \"Add monitoring and logging to policy executions for observability\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"Policies\", \"Monitoring\", \"Best Practices\"]\nfilename: \"PolicyMonitoring",
        "startIndex": 15700,
        "preview": "result = await test WhenHandled(); // Assert result Should() BeSuccess(); test Policy<RetryPolicy>() Should() HaveRetried(2) WithDelays(\"100ms\", \"200m..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/policy-composition-chunk-8",
        "text": "usingStatements: [\"System\"] } [Retry(3, RetryOn = new[] { typeof(TransientException) })] ` ✅ Monitor and log policy actions `csharp{ title: \"Monitor and Log Policy Actions\" description: \"Add monitoring and logging to policy executions for observability\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"INTERMEDIATE\" tags: [\"Usage Patterns\", \"Policies\", \"Monitoring\", \"Best Practices\"] filename: \"PolicyMonitoring cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[Retry(3, OnRetry = nameof(LogRetry))]\n`\n✅ Test failure scenarios\n`csharp{\ntitle: \"Test Failure Scenarios\"\ndescription: \"Test how policies handle various failure conditions\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"Policies\", \"Testing\", \"Best Practices\"]\nfilename: \"PolicyTesting cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang Testing\", \"System Threading Tasks\"]\n}\nawait test SimulateFailures(3) WhenHandled();\n`\nDon'ts\n❌ Don't retry non-idempotent operations\n`csharp{\ntitle: \"Don't Retry Non-Idempotent Operations\"\ndescription: \"Avoid retrying operations that can cause side effects like duplicate charges\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"Policies\", \"Anti-Patterns\", \"Idempotency\"]\nfilename: \"NonIdempotentRetry cs\"\nshowLineNumbers: true\nusingStatements: [\"System\"]\n}\n// Bad: Payment might be charged multiple times\n[Retry(3)]\npublic PaymentCharged ChargePayment(ChargeCard cmd)\n`\n❌ Don't set timeouts shorter than retries\n`csharp{\ntitle: \"Don't Set Timeouts Shorter Than Retries\"\ndescription: \"Ensure timeout values account for total retry duration\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"Policies\", \"Anti-Patterns\", \"Timeouts\"]\nfilename: \"TimeoutRetryConflict cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Bad: Timeout will trigger before retries complete\n[Retry(3, DelayMs = 5000)]\n[Timeout(Seconds = 10)]\n`\n❌ Don't ignore circuit breaker state\n`csharp{\ntitle: \"Don't Ignore Circuit Breaker State\"\ndescription: \"Always monitor and track circuit breaker health and state changes\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Usage Patterns\", \"Policies\", \"Anti-Patterns\", \"Monitoring\"]\nfilename: \"CircuitBreakerMonitoring",
        "startIndex": 17888,
        "preview": "usingStatements: [\"System\"] } [Retry(3, RetryOn = new[] { typeof(TransientException) })] ` ✅ Monitor and log policy actions `csharp{ title: \"Monitor a..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/policy-composition-chunk-9",
        "text": "before retries complete [Retry(3, DelayMs = 5000)] [Timeout(Seconds = 10)] ` ❌ Don't ignore circuit breaker state `csharp{ title: \"Don't Ignore Circuit Breaker State\" description: \"Always monitor and track circuit breaker health and state changes\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"INTERMEDIATE\" tags: [\"Usage Patterns\", \"Policies\", \"Anti-Patterns\", \"Monitoring\"] filename: \"CircuitBreakerMonitoring cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Bad: No monitoring of circuit breaker health\n[CircuitBreaker(5)]\n// Should add telemetry to track circuit state\n`\nReal-World Examples\nE-Commerce Order Processing\n`csharp{\ntitle: \"E-Commerce Resilience Pattern\"\ndescription: \"Complete resilience strategy for order processing\"\nframework: \"NET8\"\ncategory: \"Real World\"\ndifficulty: \"ADVANCED\"\ntags: [\"E-Commerce\", \"Order Processing\", \"Resilience\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"ECommerceResilience cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Payment processing with comprehensive resilience\n[Retry(3, Backoff = \"exponential\", DelayMs = 1000)]\n[CircuitBreaker(Threshold = 10, Duration = \"60s\")]\n[Timeout(Seconds = 30)]\n[Fallback(typeof(QueuePaymentForManualProcessing))]\n[Logged]\n[Metered]\npublic class PaymentProcessor : IHandle<ProcessPayment> {\n    public PaymentProcessed Handle(ProcessPayment cmd, IPaymentGateway gateway) {\n        // This is protected by:\n        // - 3 retries with exponential backoff\n        // - Circuit breaker to prevent hammering failed gateway\n        // - 30 second timeout to prevent hanging\n        // - Fallback to queue for manual processing\n        // - Full logging and metrics\n        var result = gateway ChargeCard(\n            cmd CardNumber,\n            cmd Amount,\n            cmd Currency\n        );\n        return new PaymentProcessed(result TransactionId, result Status);\n    }\n}\n// Inventory check with caching fallback\n[CircuitBreaker(FailureRate = 0 5, SamplingDuration = \"30s\")]\n[Timeout(Seconds = 5)]\n[Fallback(typeof(CachedInventoryChecker))]\npublic class LiveInventoryChecker : IHandle<CheckInventory> {\n    public InventoryStatus Handle(CheckInventory query) {\n        return inventoryService GetRealTimeStatus(query ProductIds);\n    }\n}\n// Order fulfillment saga with resilience\n[Saga]\n[Retry(5, Backoff = \"linear\", DelayMs = 2000)]\n[Timeout(Seconds = 120)]\npublic class OrderFulfillmentSaga : IHandle<OrderPlaced> {\n    public async Task<SagaResult> Handle(OrderPlaced @event) {\n        // Each step has its own resilience policies\n        await Send(new ReserveInventory(@event OrderId)) WithRetry(3) WithTimeout(10);\n        await Send(new ProcessPayment(@event OrderId)) WithRetry(5) WithCircuitBreaker()",
        "startIndex": 19829,
        "preview": "before retries complete [Retry(3, DelayMs = 5000)] [Timeout(Seconds = 10)] ` ❌ Don't ignore circuit breaker state `csharp{ title: \"Don't Ignore Circui..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/policy-composition-chunk-10",
        "text": "} // Order fulfillment saga with resilience [Saga] [Retry(5, Backoff = \"linear\", DelayMs = 2000)] [Timeout(Seconds = 120)] public class OrderFulfillmentSaga : IHandle<OrderPlaced> { public async Task<SagaResult> Handle(OrderPlaced @event) { // Each step has its own resilience policies await Send(new ReserveInventory(@event OrderId)) WithRetry(3) WithTimeout(10); await Send(new ProcessPayment(@event OrderId)) WithRetry(5) WithCircuitBreaker() WithFallback(new QueuePayment(@event OrderId));\n        await Send(new ShipOrder(@event OrderId)) WithRetry(3) WithTimeout(30);\n        return SagaResult Completed();\n    }\n}\n`\nNext Steps\nLearn about Aspect-Oriented Handlers for more aspects\nExplore Testing Strategies for policy testing\nReview Distributed Messaging for cross-service resilience\nSee Production Deployment for monitoring setup",
        "startIndex": 22217,
        "preview": "} // Order fulfillment saga with resilience [Saga] [Retry(5, Backoff = \"linear\", DelayMs = 2000)] [Timeout(Seconds = 120)] public class OrderFulfillme..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/usage-patterns/progressive-enhancement",
    "title": "Progressive Enhancement",
    "category": "Usage Patterns",
    "url": "/docs/old-v1.0.0.0/usage-patterns/progressive-enhancement",
    "chunks": [
      {
        "id": "old-v1.0.0.0/usage-patterns/progressive-enhancement-chunk-0",
        "text": "Progressive Enhancement\nOverview\nProgressive Enhancement is Whizbang's superpower - the ability to evolve your application from a simple monolith to a distributed, event-sourced system without changing your handler code This pattern allows you to start simple and add complexity only when needed, maintaining the same business logic throughout your application's growth The Journey\n`mermaid\ngraph LR\n    A[In-Process<br/>Development] --> B[Durable<br/>Single Service]\n    B --> C[Distributed<br/>Microservices]\n    C --> D[Event-Sourced<br/>CQRS/ES]\n    style A fill:#28a745,color:#fff\n    style B fill:#17a2b8,color:#fff\n    style C fill:#ffc107,color:#000\n    style D fill:#dc3545,color:#fff\n`\nThe Same Handler, Every Mode\nThis is the key insight - one handler implementation works across all modes:\n`csharp{\ntitle: \"Universal Handler\"\ndescription: \"This exact handler works in ALL deployment modes\"\nframework: \"NET8\"\ncategory: \"Core Concept\"\ndifficulty: \"BEGINNER\"\ntags: [\"Handler\", \"Universal\", \"Progressive Enhancement\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"OrderHandler cs\"\nshowLineNumbers: true\nhighlightLines: [1, 2, 3]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[Logged]\n[Validated]\n[Transactional]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd, IOrderRepository repository) {\n        // This EXACT code works in:\n        // ✅ Local development (in-process)\n        // ✅ Production monolith (durable)\n        // ✅ Microservices (distributed)\n        // ✅ Event-sourced system (CQRS/ES)\n        var order = new Order {\n            Id = Guid NewGuid(),\n            CustomerId = cmd CustomerId,\n            Items = cmd Items,\n            Total = cmd Items Sum(i => i Quantity * i Price),\n            Status = OrderStatus Pending,\n            CreatedAt = DateTime UtcNow\n        };\n        repository Save(order);\n        return new OrderCreated(\n            order Id,\n            order CustomerId,\n            order Total,\n            order CreatedAt\n        );\n    }\n}\n`\nMode 1: In-Process (Development)\nConfiguration\n`csharp{\ntitle: \"Event-Driven Development Configuration\"\ndescription: \"Perfect for development and testing - in-memory events\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"BEGINNER\"\ntags: [\"Event-Driven\", \"Development\", \"Configuration\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"Program Development cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Program cs - Development mode\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services",
        "startIndex": 0,
        "preview": "Progressive Enhancement\nOverview\nProgressive Enhancement is Whizbang's superpower - the ability to evolve your application from a simple monolith to a..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/progressive-enhancement-chunk-1",
        "text": "\"Event-Driven Development Configuration\" description: \"Perfect for development and testing - in-memory events\" framework: \"NET8\" category: \"Configuration\" difficulty: \"BEGINNER\" tags: [\"Event-Driven\", \"Development\", \"Configuration\"] nugetPackages: [\"Whizbang Core\"] filename: \"Program Development cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"] } // Program cs - Development mode var builder = WebApplication CreateBuilder(args); builder Services AddWhizbang(dispatcher => {\n    // Event-driven mode with in-memory processing\n    dispatcher RegisterReceptorsFromAssembly(typeof(Program) Assembly);\n    dispatcher RegisterPerspectivesFromAssembly(typeof(Program) Assembly);\n    dispatcher RegisterLensesFromAssembly(typeof(Program) Assembly);\n    // No persistence in development\n    dispatcher UseInMemoryPerspectives();\n});\n// In-memory lens implementations\nbuilder Services AddSingleton<IOrderLens, InMemoryOrderLens>();\nvar app = builder Build();\napp MapPost(\"/orders\", async (CreateOrder cmd, IDispatcher dispatcher) => {\n    // Executes immediately, synchronously\n    var @event = await dispatcher Send(cmd);\n    return Results Ok(new { OrderId = @event OrderId, Total = @event Total });\n});\napp Run();\n`\nCharacteristics\n`csharp{\ntitle: \"Event-Driven Development Behavior\"\ndescription: \"How receptors execute in development mode\"\nframework: \"NET8\"\ncategory: \"Behavior\"\ndifficulty: \"BEGINNER\"\ntags: [\"Event-Driven\", \"Execution\", \"Development\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"EventDrivenBehavior cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System Diagnostics\"]\n}\npublic class EventDrivenExample {\n    public async Task DemonstrateEventDriven(IDispatcher dispatcher) {\n        var stopwatch = Stopwatch StartNew();\n        // Immediate, synchronous execution\n        var @event = await dispatcher Send(new CreateOrder {\n            CustomerId = Guid NewGuid(),\n            Items = new[] { new OrderItem(\"SKU-1\", 2, 10 00m) }\n        });\n        // Receptor executed in same thread\n        Console WriteLine($\"Thread: {Thread CurrentThread ManagedThreadId}\");\n        Console WriteLine($\"Duration: {stopwatch ElapsedMilliseconds}ms\");\n        // Output: Thread: 1, Duration: 5ms\n        // Events flow to perspectives synchronously\n        // All perspectives updated immediately\n        // No ledger persistence in development\n    }\n}\n// Testing is simple\n[Fact]\npublic async Task EventDrivenMode_ExecutesImmediately() {\n    var dispatcher = new DispatcherBuilder() UseEventDrivenMode() Build();\n    var @event = await dispatcher Send(new CreateOrder());\n    Assert NotNull(@event);\n    Assert",
        "startIndex": 2600,
        "preview": "\"Event-Driven Development Configuration\" description: \"Perfect for development and testing - in-memory events\" framework: \"NET8\" category: \"Configurat..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/progressive-enhancement-chunk-2",
        "text": "Thread: 1, Duration: 5ms // Events flow to perspectives synchronously // All perspectives updated immediately // No ledger persistence in development } } // Testing is simple [Fact] public async Task EventDrivenMode_ExecutesImmediately() { var dispatcher = new DispatcherBuilder() UseEventDrivenMode() Build(); var @event = await dispatcher Send(new CreateOrder()); Assert NotNull(@event); Assert IsType<OrderCreated>(@event);\n}\n`\nWhen to Use\nLocal development - Fast feedback loop with event-driven patterns\nUnit testing - No infrastructure dependencies, pure receptor testing\nPrototyping - Rapid iteration with event flows\nSimple applications - When you don't need event persistence\nMode 2: Durable (Single Service)\nConfiguration\n`csharp{\ntitle: \"Durable Mode Configuration\"\ndescription: \"Add persistence and retry capabilities to your monolith\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Durable\", \"Persistence\", \"Monolith\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang PostgreSQL\"]\nfilename: \"Program Durable cs\"\nshowLineNumbers: true\nhighlightLines: [5, 6, 7, 8]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Program cs - Production monolith\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbang() UseDurableMode()  // Adds persistence and retry UsePostgreSQL(connectionString) WithOutbox()  // Ensures message delivery WithRetry(3, backoff: \"exponential\") RegisterHandlersFromAssembly(typeof(Program) Assembly);\n// Real database for production\nbuilder Services AddScoped<IOrderRepository, PostgresOrderRepository>();\n// Background service for processing\nbuilder Services AddHostedService<WhizbangProcessor>();\nvar app = builder Build();\napp MapPost(\"/orders\", async (CreateOrder cmd, IWhizbang whizbang) => {\n    // Queued for durable processing\n    await whizbang Publish(cmd);\n    return Results Accepted();  // Returns immediately\n});\napp Run();\n`\nMessage Flow\n`csharp{\ntitle: \"Durable Mode Message Flow\"\ndescription: \"How messages are persisted and processed\"\nframework: \"NET8\"\ncategory: \"Message Flow\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Durability\", \"Outbox\", \"Retry\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"DurableFlow cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\npublic class DurableExample {\n    public async Task DemonstrateDurable(IWhizbang whizbang) {\n        // 1 Message persisted to outbox\n        await whizbang Publish(new CreateOrder { });\n        // Returns immediately after persisting\n        // 2",
        "startIndex": 4793,
        "preview": "Thread: 1, Duration: 5ms // Events flow to perspectives synchronously // All perspectives updated immediately // No ledger persistence in development ..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/progressive-enhancement-chunk-3",
        "text": "category: \"Message Flow\" difficulty: \"INTERMEDIATE\" tags: [\"Durability\", \"Outbox\", \"Retry\"] nugetPackages: [\"Whizbang Core\"] filename: \"DurableFlow cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"System\"] } public class DurableExample { public async Task DemonstrateDurable(IWhizbang whizbang) { // 1 Message persisted to outbox await whizbang Publish(new CreateOrder { }); // Returns immediately after persisting // 2 Background processor picks up message\n        // - Dequeues from outbox\n        // - Executes handler\n        // - On success: Marks complete\n        // - On failure: Retries with backoff\n        // 3 Events from handler also go through outbox\n        // - Ensures exactly-once delivery\n        // - Maintains order guarantees\n    }\n}\n// Automatic retry on failure\n[Retry(3, Backoff = \"exponential\")]\npublic class ResilientHandler : IHandle<ProcessPayment> {\n    public PaymentProcessed Handle(ProcessPayment cmd) {\n        // If this fails, automatically retried\n        // 1st retry: 1 second delay\n        // 2nd retry: 2 second delay  \n        // 3rd retry: 4 second delay\n        return ProcessPaymentWithGateway(cmd);\n    }\n}\n`\nDatabase Schema\n`sql{\ntitle: \"Outbox Pattern Database Schema\"\ndescription: \"Database tables for durable messaging with outbox and inbox patterns\"\nframework: \"PostgreSQL\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Database Schema\", \"Outbox Pattern\", \"Durable Messaging\"]\nfilename: \"whizbang_outbox",
        "startIndex": 6971,
        "preview": "category: \"Message Flow\" difficulty: \"INTERMEDIATE\" tags: [\"Durability\", \"Outbox\", \"Retry\"] nugetPackages: [\"Whizbang Core\"] filename: \"DurableFlow cs..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/progressive-enhancement-chunk-4",
        "text": "retry: 2 second delay // 3rd retry: 4 second delay return ProcessPaymentWithGateway(cmd); } } ` Database Schema `sql{ title: \"Outbox Pattern Database Schema\" description: \"Database tables for durable messaging with outbox and inbox patterns\" framework: \"PostgreSQL\" category: \"Usage Patterns\" difficulty: \"INTERMEDIATE\" tags: [\"Database Schema\", \"Outbox Pattern\", \"Durable Messaging\"] filename: \"whizbang_outbox sql\"\nshowLineNumbers: true\n}\n-- Outbox table for durable messaging\nCREATE TABLE whizbang_outbox (\n    id BIGSERIAL PRIMARY KEY,\n    message_id UUID NOT NULL UNIQUE,\n    message_type VARCHAR(500) NOT NULL,\n    payload JSONB NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    processed_at TIMESTAMPTZ,\n    attempts INT NOT NULL DEFAULT 0,\n    error TEXT\n);\n-- Inbox for idempotency\nCREATE TABLE whizbang_inbox (\n    message_id UUID PRIMARY KEY,\n    processed_at TIMESTAMPTZ NOT NULL,\n    handler_type VARCHAR(500) NOT NULL\n);\n`\nWhen to Use\nProduction systems - Reliability with perspective persistence\nHigh-value operations - Can't afford to lose events\nBackground processing - Decouple API from perspective updates\nRetry requirements - Handle transient perspective failures\nMode 3: Distributed (Microservices)\nConfiguration\n`csharp{\ntitle: \"Distributed Mode Configuration\"\ndescription: \"Scale across multiple services with message brokers\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Distributed\", \"Microservices\", \"Kafka\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Kafka\"]\nfilename: \"Program Distributed cs\"\nshowLineNumbers: true\nhighlightLines: [5, 6, 7, 8, 9]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Program cs - Orders Service\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbang() UseDistributedMode() UseKafka(config => {\n        config BootstrapServers = \"kafka:9092\";\n        config ConsumerGroup = \"orders-service\";\n    }) UsePostgreSQL(connectionString)  // Local event store WithSagaOrchestration()          // Distributed transactions WithDistributedTracing()         // OpenTelemetry RegisterHandlersFromAssembly(typeof(Program) Assembly);\n// Domain ownership configuration\nbuilder Services ConfigureDomain(\"Orders\", domain => {\n    domain OwnsAggregate<Order>();\n    domain PublishesEvents<OrderCreated, OrderShipped, OrderCancelled>();\n    domain HandlesCommands<CreateOrder, ShipOrder, CancelOrder>();\n});\nvar app = builder Build();\n// Health checks for service discovery\napp MapHealthChecks(\"/health\");\napp",
        "startIndex": 8022,
        "preview": "retry: 2 second delay // 3rd retry: 4 second delay return ProcessPaymentWithGateway(cmd); } } ` Database Schema `sql{ title: \"Outbox Pattern Database ..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/progressive-enhancement-chunk-5",
        "text": "}) UsePostgreSQL(connectionString) // Local event store WithSagaOrchestration() // Distributed transactions WithDistributedTracing() // OpenTelemetry RegisterHandlersFromAssembly(typeof(Program) Assembly); // Domain ownership configuration builder Services ConfigureDomain(\"Orders\", domain => { domain OwnsAggregate<Order>(); domain PublishesEvents<OrderCreated, OrderShipped, OrderCancelled>(); domain HandlesCommands<CreateOrder, ShipOrder, CancelOrder>(); }); var app = builder Build(); // Health checks for service discovery app MapHealthChecks(\"/health\"); app Run();\n`\nService Communication\n`csharp{\ntitle: \"Cross-Service Communication\"\ndescription: \"How services communicate in distributed mode\"\nframework: \"NET8\"\ncategory: \"Communication\"\ndifficulty: \"ADVANCED\"\ntags: [\"Service Communication\", \"Events\", \"Commands\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"DistributedCommunication cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Orders Service - Publishes events\n[OwnedBy(\"Orders\")]\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        var order = CreateOrder(cmd);\n        // This event is automatically published to Kafka\n        // Other services can subscribe\n        return new OrderCreated(order Id, order Total);\n    }\n}\n// Inventory Service - Subscribes to events\n[Service(\"Inventory\")]\npublic class InventoryHandler : IHandle<OrderCreated> {\n    public InventoryReserved Handle(OrderCreated @event) {\n        // Receives event from Kafka\n        // Reserves inventory for the order\n        var reservation = ReserveInventory(@event OrderId);\n        // Publishes its own event\n        return new InventoryReserved(\n            @event OrderId, \n            reservation Id\n        );\n    }\n}\n// Payment Service - Part of saga\n[Service(\"Payment\")]\npublic class PaymentSaga : Saga<PaymentState> {\n    public SagaAction Handle(OrderCreated @event) {\n        State OrderId = @event OrderId;\n        State Amount = @event Total;\n        // Orchestrate payment process\n        return SagaAction Send(new ChargeCard(State Amount)) OnSuccess(new PaymentCompleted(State OrderId)) OnFailure(new PaymentFailed(State OrderId)) WithTimeout(TimeSpan FromMinutes(5));\n    }\n}\n`\nService Discovery\n`csharp{\ntitle: \"Service Discovery and Routing\"\ndescription: \"Automatic service discovery and message routing\"\nframework: \"NET8\"\ncategory: \"Service Discovery\"\ndifficulty: \"ADVANCED\"\ntags: [\"Service Discovery\", \"Routing\", \"Consul\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang ServiceDiscovery\"]\nfilename: \"ServiceDiscovery cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Automatic service registration\nbuilder Services AddWhizbang() UseDistributedMode() UseServiceDiscovery(options => {\n        options UseConsul(\"http://consul:8500\");\n        options ServiceName = \"orders-service\";\n        options ServiceId = Environment MachineName;\n        options HealthCheckInterval = TimeSpan",
        "startIndex": 10186,
        "preview": "}) UsePostgreSQL(connectionString) // Local event store WithSagaOrchestration() // Distributed transactions WithDistributedTracing() // OpenTelemetry ..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/progressive-enhancement-chunk-6",
        "text": "category: \"Service Discovery\" difficulty: \"ADVANCED\" tags: [\"Service Discovery\", \"Routing\", \"Consul\"] nugetPackages: [\"Whizbang Core\", \"Whizbang ServiceDiscovery\"] filename: \"ServiceDiscovery cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"System\"] } // Automatic service registration builder Services AddWhizbang() UseDistributedMode() UseServiceDiscovery(options => { options UseConsul(\"http://consul:8500\"); options ServiceName = \"orders-service\"; options ServiceId = Environment MachineName; options HealthCheckInterval = TimeSpan FromSeconds(10);\n    });\n// Commands routed to owning service\npublic class OrderClient {\n    private readonly IWhizbang _whizbang;\n    public async Task<OrderCreated> CreateOrder(CreateOrder cmd) {\n        // Whizbang knows Orders service owns this command\n        // Automatically routes via service discovery\n        return await _whizbang Send(cmd);\n    }\n}\n// Load balancing across instances\n[LoadBalanced(Strategy = \"round-robin\")]\npublic class DistributedQuery : IHandle<GetOrderStatus> {\n    public OrderStatus Handle(GetOrderStatus query) {\n        // Queries can be handled by any instance\n        return GetStatus(query OrderId);\n    }\n}\n`\nWhen to Use\nMicroservice architecture - Independent service scaling with relays\nTeam boundaries - Different teams own different receptors/domains  \nTechnology diversity - Services in different languages sharing events\nGeographic distribution - Services in different regions with event streaming\nMode 4: Event-Sourced (CQRS/ES)\nConfiguration\n`csharp{\ntitle: \"Event-Sourced Mode Configuration\"\ndescription: \"Full event sourcing with projections and time travel\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Event Sourcing\", \"CQRS\", \"Projections\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventStore\"]\nfilename: \"Program EventSourced cs\"\nshowLineNumbers: true\nhighlightLines: [5, 6, 7, 8, 9, 10]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Program cs - Event-sourced system\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbang() UseEventSourcedMode() UseEventStore(config => {\n        config ConnectionString = eventStoreConnection;\n        config SnapshotFrequency = 100;  // Snapshot every 100 events\n    }) UseProjections(config => {\n        config UsePostgreSQL(readModelConnection);\n        config RebuildOnStartup = false;\n    }) WithTimeTravel()  // Enable historical queries RegisterHandlersFromAssembly(typeof(Program) Assembly);\n// Register aggregates\nbuilder Services RegisterAggregate<Order>();\nbuilder Services RegisterAggregate<Customer>();\n// Register projections\nbuilder Services RegisterProjection<OrderListProjection>();\nbuilder Services RegisterProjection<CustomerOrderHistoryProjection>();\nbuilder Services RegisterProjection<RevenueProjection>();\nvar app = builder Build();\n// Projection management endpoints\napp MapProjectionManagement(\"/projections\");\napp",
        "startIndex": 12666,
        "preview": "category: \"Service Discovery\" difficulty: \"ADVANCED\" tags: [\"Service Discovery\", \"Routing\", \"Consul\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Servi..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/progressive-enhancement-chunk-7",
        "text": "UseProjections(config => { config UsePostgreSQL(readModelConnection); config RebuildOnStartup = false; }) WithTimeTravel() // Enable historical queries RegisterHandlersFromAssembly(typeof(Program) Assembly); // Register aggregates builder Services RegisterAggregate<Order>(); builder Services RegisterAggregate<Customer>(); // Register projections builder Services RegisterProjection<OrderListProjection>(); builder Services RegisterProjection<CustomerOrderHistoryProjection>(); builder Services RegisterProjection<RevenueProjection>(); var app = builder Build(); // Projection management endpoints app MapProjectionManagement(\"/projections\"); app Run();\n`\nEvent-Sourced Aggregates\n`csharp{\ntitle: \"Event-Sourced Aggregate\"\ndescription: \"Domain aggregates that emit events\"\nframework: \"NET8\"\ncategory: \"Aggregates\"\ndifficulty: \"ADVANCED\"\ntags: [\"Aggregates\", \"Domain\", \"Events\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"OrderAggregate cs\"\nshowLineNumbers: true\nhighlightLines: [1, 10, 20, 30]\nusingStatements: [\"Whizbang\", \"System\"]\n}\n[EventSourced]\npublic class Order : Aggregate {\n    public Guid CustomerId { get; private set; }\n    public List<OrderItem> Items { get; private set; }\n    public decimal Total { get; private set; }\n    public OrderStatus Status { get; private set; }\n    // Command handler - returns events\n    public OrderCreated Handle(CreateOrder cmd) {\n        if (cmd Items Any() = true) {\n            throw new InvalidOperationException(\"Order must have items\");\n        }\n        var total = cmd Items Sum(i => i Quantity * i Price);\n        // Return event - automatically appended to event stream\n        return new OrderCreated {\n            OrderId = Guid NewGuid(),\n            CustomerId = cmd CustomerId,\n            Items = cmd Items,\n            Total = total,\n            CreatedAt = DateTime UtcNow\n        };\n    }\n    // Event handler - updates state\n    [Pure]  // No side effects allowed\n    public void Apply(OrderCreated @event) {\n        Id = @event OrderId;\n        CustomerId = @event CustomerId;\n        Items = @event Items ToList();\n        Total = @event Total;\n        Status = OrderStatus Pending;\n    }\n    // Another command\n    public OrderShipped Ship(ShipOrder cmd) {\n        if (Status = OrderStatus Paid) {\n            throw new InvalidOperationException(\"Can only ship paid orders\");\n        }\n        return new OrderShipped {\n            OrderId = Id,\n            ShippedAt = DateTime UtcNow,\n            TrackingNumber = cmd TrackingNumber\n        };\n    }\n    public void Apply(OrderShipped @event) {\n        Status = OrderStatus",
        "startIndex": 15110,
        "preview": "UseProjections(config => { config UsePostgreSQL(readModelConnection); config RebuildOnStartup = false; }) WithTimeTravel() // Enable historical querie..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/progressive-enhancement-chunk-8",
        "text": "OrderStatus Pending; } // Another command public OrderShipped Ship(ShipOrder cmd) { if (Status = OrderStatus Paid) { throw new InvalidOperationException(\"Can only ship paid orders\"); } return new OrderShipped { OrderId = Id, ShippedAt = DateTime UtcNow, TrackingNumber = cmd TrackingNumber }; } public void Apply(OrderShipped @event) { Status = OrderStatus Shipped;\n    }\n}\n`\nProjections\n`csharp{\ntitle: \"Event Projections\"\ndescription: \"Building read models from event streams\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Read Models\", \"CQRS\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"Projections cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Order list projection\n[Projection(\"OrderList\")]\npublic class OrderListProjection : \n    IProject<OrderCreated>,\n    IProject<OrderShipped>,\n    IProject<OrderCancelled> {\n    private readonly IDocumentStore _store;\n    public async Task Project(OrderCreated @event) {\n        await _store Upsert(new OrderListItem {\n            OrderId = @event OrderId,\n            CustomerId = @event CustomerId,\n            Total = @event Total,\n            Status = \"Created\",\n            CreatedAt = @event CreatedAt\n        });\n    }\n    public async Task Project(OrderShipped @event) {\n        await _store Update<OrderListItem>(@event OrderId, item => {\n            item Status = \"Shipped\";\n            item ShippedAt = @event ShippedAt;\n        });\n    }\n    public async Task Project(OrderCancelled @event) {\n        await _store Update<OrderListItem>(@event OrderId, item => {\n            item Status = \"Cancelled\";\n            item CancelledAt = @event CancelledAt;\n        });\n    }\n}\n// Revenue projection with time windows\n[Projection(\"Revenue\")]\npublic class RevenueProjection : IProject<OrderCreated> {\n    public async Task Project(OrderCreated @event) {\n        // Update daily revenue\n        await _store Increment(\n            $\"revenue:daily:{@event CreatedAt:yyyy-MM-dd}\",\n            @event Total\n        );\n        // Update monthly revenue\n        await _store Increment(\n            $\"revenue:monthly:{@event CreatedAt:yyyy-MM}\",\n            @event Total\n        );\n        // Update customer lifetime value\n        await _store Increment(\n            $\"customer:ltv:{@event CustomerId}\",\n            @event Total\n        );\n    }\n}\n`\nTime Travel Queries\n`csharp{\ntitle: \"Time Travel and Historical Queries\"\ndescription: \"Query system state at any point in time\"\nframework: \"NET8\"\ncategory: \"Time Travel\"\ndifficulty: \"ADVANCED\"\ntags: [\"Time Travel\", \"Historical\", \"Debugging\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"TimeTravel",
        "startIndex": 17062,
        "preview": "OrderStatus Pending; } // Another command public OrderShipped Ship(ShipOrder cmd) { if (Status = OrderStatus Paid) { throw new InvalidOperationExcepti..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/progressive-enhancement-chunk-9",
        "text": "customer lifetime value await _store Increment( $\"customer:ltv:{@event CustomerId}\", @event Total ); } } ` Time Travel Queries `csharp{ title: \"Time Travel and Historical Queries\" description: \"Query system state at any point in time\" framework: \"NET8\" category: \"Time Travel\" difficulty: \"ADVANCED\" tags: [\"Time Travel\", \"Historical\", \"Debugging\"] nugetPackages: [\"Whizbang Core\"] filename: \"TimeTravel cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\npublic class TimeTravelExample {\n    private readonly IWhizbang _whizbang;\n    public async Task<Order> GetOrderAtPointInTime(\n        Guid orderId, \n        DateTime pointInTime) {\n        // Replay events up to specific time\n        var order = await _whizbang AsOf(pointInTime) Get<Order>(orderId);\n        return order;\n    }\n    public async Task<decimal> GetRevenueOnDate(DateTime date) {\n        // Query projection as it was on specific date\n        var revenue = await _whizbang AsOf(date AddDays(1) AddSeconds(-1)) Query<RevenueProjection>() GetDailyRevenue(date);\n        return revenue;\n    }\n    public async Task DebugOrderHistory(Guid orderId) {\n        // Get all events for an aggregate\n        var events = await _whizbang EventStream(orderId) ToListAsync();\n        Console WriteLine($\"Order {orderId} history:\");\n        foreach (var @event in events) {\n            Console WriteLine($\"  {@event Timestamp}: {@event GetType() Name}\");\n            // Replay to this point\n            var orderAtPoint = await _whizbang AsOf(@event Timestamp) Get<Order>(orderId);\n            Console WriteLine($\"    Status: {orderAtPoint Status}\");\n            Console WriteLine($\"    Total: {orderAtPoint Total}\");\n        }\n    }\n}\n`\nWhen to Use\nAudit requirements - Complete history of all changes in ledger\nComplex domains - Rich business logic with stateful receptors\nDebugging needs - Replay events to understand receptor state\nAnalytics - Build new perspectives from historical events\nCompliance - Prove receptor state at any point in time\nMigration Strategies\nFrom In-Process to Durable\n`csharp{\ntitle: \"Migrating to Durable Mode\"\ndescription: \"Steps to add durability to existing application\"\nframework: \"NET8\"\ncategory: \"Migration\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Migration\", \"Durability\", \"Evolution\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"MigrateToDurable cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Step 1: Change configuration (no handler changes )\n// Before:\nbuilder Services AddWhizbang() UseInProcessMode();\n// After:\nbuilder Services AddWhizbang() UseDurableMode()",
        "startIndex": 19364,
        "preview": "customer lifetime value await _store Increment( $\"customer:ltv:{@event CustomerId}\", @event Total ); } } ` Time Travel Queries `csharp{ title: \"Time T..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/progressive-enhancement-chunk-10",
        "text": "add durability to existing application\" framework: \"NET8\" category: \"Migration\" difficulty: \"INTERMEDIATE\" tags: [\"Migration\", \"Durability\", \"Evolution\"] nugetPackages: [\"Whizbang Core\"] filename: \"MigrateToDurable cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"] } // Step 1: Change configuration (no handler changes ) // Before: builder Services AddWhizbang() UseInProcessMode(); // After: builder Services AddWhizbang() UseDurableMode() UsePostgreSQL(connectionString);\n// Step 2: Add background processor\nbuilder Services AddHostedService<WhizbangProcessor>();\n// Step 3: Update message sending (optional)\n// Change from Send (synchronous) to Publish (async)\n// Before:\nvar result = await whizbang Send(command);\n// After (for background processing):\nawait whizbang Publish(command);\n// Your handlers remain EXACTLY the same `\nFrom Durable to Distributed\n`csharp{\ntitle: \"Migrating to Distributed Mode\"\ndescription: \"Steps to split monolith into microservices\"\nframework: \"NET8\"\ncategory: \"Migration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Migration\", \"Microservices\", \"Distribution\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Kafka\"]\nfilename: \"MigrateToDistributed cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Step 1: Define service boundaries\n// Orders Service\nbuilder Services ConfigureDomain(\"Orders\", domain => {\n    domain OwnsAggregate<Order>();\n    domain HandlesCommands<CreateOrder, ShipOrder>();\n});\n// Inventory Service  \nbuilder Services ConfigureDomain(\"Inventory\", domain => {\n    domain OwnsAggregate<Product>();\n    domain HandlesCommands<ReserveStock, ReleaseStock>();\n});\n// Step 2: Add message broker\nbuilder Services AddWhizbang() UseDistributedMode() UseKafka(kafkaConfig);\n// Step 3: Deploy services independently\n// Each service has its own database\n// Communication via Kafka\n// Handlers remain EXACTLY the same `\nFrom Distributed to Event-Sourced\n`csharp{\ntitle: \"Migrating to Event Sourcing\"\ndescription: \"Steps to add event sourcing to existing system\"\nframework: \"NET8\"\ncategory: \"Migration\"\ndifficulty: \"ADVANCED\"\ntags: [\"Migration\", \"Event Sourcing\", \"CQRS\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventStore\"]\nfilename: \"MigrateToEventSourced cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Step 1: Convert entities to aggregates\n// Before:\npublic class Order {\n    public void UpdateStatus(OrderStatus status) {\n        Status = status;\n        repository",
        "startIndex": 21727,
        "preview": "add durability to existing application\" framework: \"NET8\" category: \"Migration\" difficulty: \"INTERMEDIATE\" tags: [\"Migration\", \"Durability\", \"Evolutio..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/progressive-enhancement-chunk-11",
        "text": "to existing system\" framework: \"NET8\" category: \"Migration\" difficulty: \"ADVANCED\" tags: [\"Migration\", \"Event Sourcing\", \"CQRS\"] nugetPackages: [\"Whizbang Core\", \"Whizbang EventStore\"] filename: \"MigrateToEventSourced cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"System\"] } // Step 1: Convert entities to aggregates // Before: public class Order { public void UpdateStatus(OrderStatus status) { Status = status; repository Save(this);\n    }\n}\n// After:\n[EventSourced]\npublic class Order : Aggregate {\n    public OrderStatusChanged UpdateStatus(ChangeOrderStatus cmd) {\n        // Return event instead of saving directly\n        return new OrderStatusChanged(Id, cmd NewStatus);\n    }\n    public void Apply(OrderStatusChanged @event) {\n        Status = @event NewStatus;\n    }\n}\n// Step 2: Update configuration\nbuilder Services AddWhizbang() UseEventSourcedMode() UseEventStore(config);\n// Step 3: Build projections for queries\nbuilder Services RegisterProjection<OrderListProjection>();\n// Step 4: Migrate historical data (optional)\nawait migrator MigrateToEventStore(existingOrders);\n// Core handler logic remains similar `\nTesting Across Modes\n`csharp{\ntitle: \"Testing Progressive Enhancement\"\ndescription: \"Verify handlers work correctly in all modes\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Testing\", \"Cross-Mode\", \"Verification\"]\nnugetPackages: [\"Whizbang Core\", \"xUnit\"]\nfilename: \"ProgressiveTests cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang Testing\", \"Xunit\"]\n}\npublic class CrossModeTests {\n    private readonly CreateOrder _command = new() {\n        CustomerId = Guid NewGuid(),\n        Items = new[] { new OrderItem(\"SKU-1\", 2, 10 00m) }\n    };\n    [Theory]\n    [InlineData(\"InProcess\")]\n    [InlineData(\"Durable\")]\n    [InlineData(\"Distributed\")]\n    [InlineData(\"EventSourced\")]\n    public async Task Handler_WorksInAllModes(string mode) {\n        // Arrange\n        var whizbang = BuildWhizbang(mode);\n        // Act\n        var result = await whizbang Send(_command);\n        // Assert - Same expectations regardless of mode\n        Assert NotNull(result);\n        Assert IsType<OrderCreated>(result);\n        var orderCreated = (OrderCreated)result;\n        Assert Equal(_command CustomerId, orderCreated CustomerId);\n        Assert Equal(20 00m, orderCreated Total);\n    }\n    private IWhizbang BuildWhizbang(string mode) {\n        return mode switch {\n            \"InProcess\" => new WhizbangBuilder() UseInProcessMode() Build(),\n            \"Durable\" => new WhizbangBuilder() UseDurableMode() UseInMemoryPersistence() Build(),\n            \"Distributed\" => new WhizbangBuilder() UseDistributedMode() UseInMemoryMessageBroker() Build(),\n            \"EventSourced\" => new WhizbangBuilder() UseEventSourcedMode() UseInMemoryEventStore()",
        "startIndex": 23773,
        "preview": "to existing system\" framework: \"NET8\" category: \"Migration\" difficulty: \"ADVANCED\" tags: [\"Migration\", \"Event Sourcing\", \"CQRS\"] nugetPackages: [\"Whiz..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/progressive-enhancement-chunk-12",
        "text": "var orderCreated = (OrderCreated)result; Assert Equal(_command CustomerId, orderCreated CustomerId); Assert Equal(20 00m, orderCreated Total); } private IWhizbang BuildWhizbang(string mode) { return mode switch { \"InProcess\" => new WhizbangBuilder() UseInProcessMode() Build(), \"Durable\" => new WhizbangBuilder() UseDurableMode() UseInMemoryPersistence() Build(), \"Distributed\" => new WhizbangBuilder() UseDistributedMode() UseInMemoryMessageBroker() Build(), \"EventSourced\" => new WhizbangBuilder() UseEventSourcedMode() UseInMemoryEventStore() Build(),\n            _ => throw new ArgumentException($\"Unknown mode: {mode}\")\n        };\n    }\n}\n// Performance comparison across modes\n[Benchmark]\npublic class ModeBenchmarks {\n    [Params(\"InProcess\", \"Durable\", \"Distributed\", \"EventSourced\")]\n    public string Mode { get; set; }\n    private IWhizbang _whizbang;\n    [GlobalSetup]\n    public void Setup() {\n        _whizbang = BuildWhizbang(Mode);\n    }\n    [Benchmark]\n    public async Task ProcessOrder() {\n        await _whizbang Send(new CreateOrder { });\n    }\n}\n`\nBest Practices\nDo's\n✅ Start with the simplest mode that works\n`csharp{\ntitle: \"Progressive Mode Selection\"\ndescription: \"Start simple and scale when needed\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Progressive Enhancement\", \"Mode Selection\", \"Best Practices\"]\nfilename: \"ModeSelection cs\"\nusingStatements: [\"Whizbang\"]\n}\n// Development: UseInProcessMode()\n// Production: Start with UseDurableMode()\n// Scale when needed\n`\n✅ Keep handlers focused on business logic\n`csharp{\ntitle: \"Clean Handler Design\"\ndescription: \"Focus handlers on business logic only\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Handler Design\", \"Best Practices\", \"Clean Code\"]\nfilename: \"CleanHandler cs\"\nusingStatements: [\"Whizbang\"]\n}\npublic OrderCreated Handle(CreateOrder cmd) {\n    // Only business logic, no infrastructure\n}\n`\n✅ Use aspects for cross-cutting concerns\n`csharp{\ntitle: \"Cross-Cutting Concerns with Aspects\"\ndescription: \"Use attributes for logging, validation, and transactions\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Aspects\", \"Cross-Cutting Concerns\", \"Attributes\"]\nfilename: \"OrderHandler cs\"\nusingStatements: [\"Whizbang\"]\n}\n[Logged]\n[Validated]\n[Transactional]\npublic class OrderHandler : IHandle<CreateOrder>\n`\n✅ Test handlers independently of mode\n`csharp{\ntitle: \"Cross-Mode Testing\"\ndescription: \"Test handlers work across all modes\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Testing\", \"Cross-Mode\", \"Theory Tests\"]\nfilename: \"CrossModeTests",
        "startIndex": 26342,
        "preview": "var orderCreated = (OrderCreated)result; Assert Equal(_command CustomerId, orderCreated CustomerId); Assert Equal(20 00m, orderCreated Total); } priva..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/progressive-enhancement-chunk-13",
        "text": "[\"Aspects\", \"Cross-Cutting Concerns\", \"Attributes\"] filename: \"OrderHandler cs\" usingStatements: [\"Whizbang\"] } [Logged] [Validated] [Transactional] public class OrderHandler : IHandle<CreateOrder> ` ✅ Test handlers independently of mode `csharp{ title: \"Cross-Mode Testing\" description: \"Test handlers work across all modes\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"INTERMEDIATE\" tags: [\"Testing\", \"Cross-Mode\", \"Theory Tests\"] filename: \"CrossModeTests cs\"\nusingStatements: [\"Xunit\", \"Whizbang\"]\n}\n[Theory]\n[InlineData(\"InProcess\")]\n[InlineData(\"Durable\")]\npublic async Task TestAcrossModes(string mode)\n`\nDon'ts\n❌ Don't add mode-specific logic to handlers\n`csharp{\ntitle: \"Anti-Pattern: Mode-Specific Logic\"\ndescription: \"Don't add mode-specific logic to handlers\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Anti-Pattern\", \"Bad Practice\", \"Mode-Specific\"]\nfilename: \"BadModeLogic cs\"\n}\n// BAD\nif (IsDistributedMode()) {\n    // Special distributed logic\n}\n`\n❌ Don't skip modes unnecessarily\n`csharp{\ntitle: \"Anti-Pattern: Skipping Modes\"\ndescription: \"Don't jump directly to complex modes\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Anti-Pattern\", \"Progressive Enhancement\", \"Evolution\"]\nfilename: \"ModeProgression cs\"\n}\n// BAD: Jumping straight to event sourcing\n// GOOD: Progress through modes as needed\n`\n❌ Don't mix modes in same deployment\n`csharp{\ntitle: \"Anti-Pattern: Mixed Modes\"\ndescription: \"Don't mix different modes in same deployment\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Anti-Pattern\", \"Deployment\", \"Consistency\"]\nfilename: \"MixedModes cs\"\n}\n// BAD: Some handlers durable, others distributed\n// GOOD: Consistent mode across application\n`\nReal-World Evolution\n`csharp{\ntitle: \"E-Commerce Platform Evolution\"\ndescription: \"Real example of progressive enhancement over time\"\nframework: \"NET8\"\ncategory: \"Real World\"\ndifficulty: \"ADVANCED\"\ntags: [\"Case Study\", \"E-Commerce\", \"Evolution\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"ECommercePlatform cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Year 1: Startup - In-Process Mode\n// Simple monolith, 100 orders/day\npublic class StartupPhase {\n    public void Configure(IServiceCollection services) {\n        services AddWhizbang() UseInProcessMode()",
        "startIndex": 28455,
        "preview": "[\"Aspects\", \"Cross-Cutting Concerns\", \"Attributes\"] filename: \"OrderHandler cs\" usingStatements: [\"Whizbang\"] } [Logged] [Validated] [Transactional] p..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/progressive-enhancement-chunk-14",
        "text": "over time\" framework: \"NET8\" category: \"Real World\" difficulty: \"ADVANCED\" tags: [\"Case Study\", \"E-Commerce\", \"Evolution\"] nugetPackages: [\"Whizbang Core\"] filename: \"ECommercePlatform cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"System\"] } // Year 1: Startup - In-Process Mode // Simple monolith, 100 orders/day public class StartupPhase { public void Configure(IServiceCollection services) { services AddWhizbang() UseInProcessMode() RegisterHandlers();\n        // Simple, fast, easy to debug\n        // No infrastructure complexity\n    }\n}\n// Year 2: Growth - Durable Mode\n// Need reliability, 1,000 orders/day\npublic class GrowthPhase {\n    public void Configure(IServiceCollection services) {\n        services AddWhizbang() UseDurableMode() UsePostgreSQL(connectionString) WithOutbox() WithRetry();\n        // Same handlers, added durability\n        // Background processing for emails\n        // Retry for payment processing\n    }\n}\n// Year 3: Scale - Distributed Mode\n// Multiple teams, 10,000 orders/day\npublic class ScalePhase {\n    // Orders Service\n    public class OrdersService {\n        public void Configure(IServiceCollection services) {\n            services AddWhizbang() UseDistributedMode() UseKafka(kafkaConfig) ConfigureDomain(\"Orders\");\n        }\n    }\n    // Inventory Service (different team)\n    public class InventoryService {\n        public void Configure(IServiceCollection services) {\n            services AddWhizbang() UseDistributedMode() UseKafka(kafkaConfig) ConfigureDomain(\"Inventory\");\n        }\n    }\n    // Same handler code, now distributed\n    // Independent deployment and scaling\n}\n// Year 4: Enterprise - Event-Sourced Mode\n// Compliance requirements, 100,000 orders/day\npublic class EnterprisePhase {\n    public void Configure(IServiceCollection services) {\n        services AddWhizbang() UseEventSourcedMode() UseEventStore(eventStoreConfig) UseProjections(projectionConfig) WithTimeTravel() WithSnapshots();\n        // Complete audit trail\n        // Time-travel debugging\n        // Complex analytics from event stream\n        // STILL the same handler patterns }\n}\n`\nSummary\nProgressive Enhancement in Whizbang allows you to:\nStart simple with event-driven development mode\nAdd persistence when you need reliability with perspectives\nScale to distributed when teams grow with relays\nEmbrace event sourcing when the domain demands stateful receptors\nAll without changing your receptor code This is the power of Whizbang's unified architecture - write once, scale infinitely",
        "startIndex": 30374,
        "preview": "over time\" framework: \"NET8\" category: \"Real World\" difficulty: \"ADVANCED\" tags: [\"Case Study\", \"E-Commerce\", \"Evolution\"] nugetPackages: [\"Whizbang C..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/progressive-enhancement-chunk-15",
        "text": "Start simple with event-driven development mode Add persistence when you need reliability with perspectives Scale to distributed when teams grow with relays Embrace event sourcing when the domain demands stateful receptors All without changing your receptor code This is the power of Whizbang's unified architecture - write once, scale infinitely Next Steps\nReview Event-Driven Dispatcher Pattern to start with basics\nExplore Event Sourcing Basics for stateful receptor patterns\nLearn about Receptors for command handling\nSee Perspectives for event handling and read models",
        "startIndex": 32685,
        "preview": "Start simple with event-driven development mode Add persistence when you need reliability with perspectives Scale to distributed when teams grow with ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/usage-patterns/saga-orchestration",
    "title": "Saga Orchestration",
    "category": "Usage Patterns",
    "url": "/docs/old-v1.0.0.0/usage-patterns/saga-orchestration",
    "chunks": [
      {
        "id": "old-v1.0.0.0/usage-patterns/saga-orchestration-chunk-0",
        "text": "Saga Orchestration\nOverview\nThe Saga pattern manages long-running business transactions that span multiple aggregates or services Whizbang provides comprehensive support for both orchestration and choreography-based sagas, with built-in compensation for handling failures What is a Saga A saga is a sequence of local transactions where each transaction updates data within a single service If a step fails, the saga executes compensating transactions to undo the impact of preceding transactions When to Use Sagas\nMulti-step workflows: Order fulfillment, payment processing\nCross-service transactions: Operations spanning multiple bounded contexts\nLong-running processes: Approval workflows, batch processing\nCompensatable operations: Actions that can be reversed or compensated\nArchitecture Diagram\n`mermaid\nstateDiagram-v2\n    [*] --> OrderPlaced\n    OrderPlaced --> PaymentProcessed: Process Payment\n    OrderPlaced --> OrderCancelled: Cancel\n    PaymentProcessed --> InventoryReserved: Reserve Inventory\n    PaymentProcessed --> PaymentRefunded: Fail\n    InventoryReserved --> OrderShipped: Ship Order\n    InventoryReserved --> InventoryReleased: Fail\n    OrderShipped --> [*]: Success\n    PaymentRefunded --> OrderCancelled: Compensate\n    InventoryReleased --> PaymentRefunded: Compensate\n    OrderCancelled --> [*]: Cancelled\n`\nImplementation Guide\nDocumentation in progress - This page demonstrates the structure for saga orchestration patterns with Whizbang Topics to Cover:\nSaga Definition\nState machine configuration\nStep definitions\nCompensation logic\nOrchestration Pattern\nCentral coordinator\nState management\nStep execution\nChoreography Pattern\nEvent-driven coordination\nDecentralized flow\nEvent subscriptions\nCompensation Strategies\nBackward recovery\nForward recovery\nPivot transactions\nError Handling\nTimeout management\nRetry policies\nManual intervention\nExample: Order Fulfillment Saga\n`csharp{\ntitle: \"Order Fulfillment Saga Example\"\ndescription: \"Placeholder for comprehensive saga implementation example\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"ADVANCED\"\ntags: [\"Sagas\", \"Orchestration\", \"Workflow\"]\nnugetPackages: [\"Whizbang Sagas\"]\nusingStatements: [\"Whizbang",
        "startIndex": 0,
        "preview": "Saga Orchestration\nOverview\nThe Saga pattern manages long-running business transactions that span multiple aggregates or services Whizbang provides co..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/saga-orchestration-chunk-1",
        "text": "subscriptions Compensation Strategies Backward recovery Forward recovery Pivot transactions Error Handling Timeout management Retry policies Manual intervention Example: Order Fulfillment Saga `csharp{ title: \"Order Fulfillment Saga Example\" description: \"Placeholder for comprehensive saga implementation example\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"ADVANCED\" tags: [\"Sagas\", \"Orchestration\", \"Workflow\"] nugetPackages: [\"Whizbang Sagas\"] usingStatements: [\"Whizbang Sagas\"]\nshowLineNumbers: true\n}\n// Placeholder for comprehensive saga implementation example\npublic class OrderFulfillmentSaga : Saga<OrderFulfillmentState> {\n    // Implementation details coming soon\n}\n`\nRelated Patterns\nEvent Sourcing Basics - Event-driven foundation\nCQRS Implementation - Query side for saga state\nDistributed Messaging - Cross-service communication\nNext Steps\nExplore Microservices Integration for deployment patterns\nReview Advanced Scenarios for production tips\nCheck Command Handling for command patterns",
        "startIndex": 2206,
        "preview": "subscriptions Compensation Strategies Backward recovery Forward recovery Pivot transactions Error Handling Timeout management Retry policies Manual in..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.0.0/usage-patterns/simple-mediator",
    "title": "Event-Driven Dispatcher Pattern",
    "category": "Usage Patterns",
    "url": "/docs/old-v1.0.0.0/usage-patterns/simple-mediator",
    "chunks": [
      {
        "id": "old-v1.0.0.0/usage-patterns/simple-mediator-chunk-0",
        "text": "Event-Driven Dispatcher Pattern\nOverview\nThe Event-Driven Dispatcher pattern is your entry point into the Whizbang library It provides a clean way to handle commands and queries using event-driven architecture, where all state changes flow through events This pattern is perfect for:\nGetting started with event-driven concepts\nBuilding applications with clear separation between reads and writes\nLearning the receptor/perspective/lens pattern\nStarting with Event-Driven mode before adding Event Sourcing\nKey Benefits\nProgressive Enhancement: Same code works from monolith to microservices\nConvention Over Configuration: Return types determine behavior\nAspect-Oriented: Cross-cutting concerns via declarative attributes\nCompile-Time Safety: Source generators catch errors at build time\nZero Overhead: Generated code performs like hand-written code\nArchitecture Diagram\n`mermaid\ngraph LR\n    Client[Client/Controller] --> Dispatcher[Whizbang Dispatcher]\n    Dispatcher --> Receptor[Receptor]\n    Receptor --> Event[Event]\n    Event --> Perspective[Perspective]\n    Perspective --> DB[Database]\n    Client --> Lens[Lens]\n    Lens --> DB\n    style Dispatcher fill:#0066cc,color:#fff\n    style Receptor fill:#28a745,color:#fff\n    style Perspective fill:#ffc107,color:#000\n    style Lens fill:#17a2b8,color:#fff\n`\nCore Components\nRequired Packages\n`xml{\ntitle: \"Required Package Reference\"\ndescription: \"Add Whizbang Core NuGet package to your project\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Simple Mediator\", \"NuGet\", \"Installation\"]\nfilename: \"YourProject csproj\"\nshowLineNumbers: true\n}\n<PackageReference Include=\"Whizbang Core\" Version=\"1 0 0\" />\n`\nThe Event-Driven Approach\nWhizbang uses a unified event-driven pattern:\nReceptors: Receive commands and emit events\nPerspectives: React to events and update views\nLenses: Provide read-only access to data\nAll writes through events: Even in non-event-sourced mode\nReturn Type Semantics: What you return determines what happens\nStep-by-Step Implementation\nStep 1: Define Your Messages\n`csharp{\ntitle: \"Message Definitions\"\ndescription: \"Simple message types - no special interfaces required\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Messages\", \"Commands\", \"Queries\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"OrderMessages cs\"\nshowLineNumbers: true\nusingStatements: [\"System\", \"System Collections Generic\"]\n}\nusing System;\nusing System Collections Generic;\nnamespace MyApp",
        "startIndex": 0,
        "preview": "Event-Driven Dispatcher Pattern\nOverview\nThe Event-Driven Dispatcher pattern is your entry point into the Whizbang library It provides a clean way to ..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/simple-mediator-chunk-1",
        "text": "1: Define Your Messages `csharp{ title: \"Message Definitions\" description: \"Simple message types - no special interfaces required\" framework: \"NET8\" category: \"Domain Logic\" difficulty: \"BEGINNER\" tags: [\"Messages\", \"Commands\", \"Queries\"] nugetPackages: [\"Whizbang Core\"] filename: \"OrderMessages cs\" showLineNumbers: true usingStatements: [\"System\", \"System Collections Generic\"] } using System; using System Collections Generic; namespace MyApp Orders;\n// Command: A message that changes state\npublic record CreateOrder(\n    Guid CustomerId,\n    List<OrderItem> Items,\n    string ShippingAddress\n);\n// Query: A message that reads data\npublic record GetOrderById(Guid OrderId);\n// Event: Something that happened\npublic record OrderCreated(\n    Guid OrderId,\n    Guid CustomerId,\n    decimal TotalAmount,\n    DateTime CreatedAt\n);\n// Response types\npublic record OrderDetails(\n    Guid OrderId,\n    Guid CustomerId,\n    List<OrderItem> Items,\n    decimal TotalAmount,\n    string Status,\n    DateTime CreatedAt\n);\n// Domain model\npublic record OrderItem(\n    string ProductId,\n    string ProductName,\n    int Quantity,\n    decimal UnitPrice\n);\n`\nStep 2: Implement Receptors with Return Type Semantics\n`csharp{\ntitle: \"Receptor Implementation - Event-Driven Approach\"\ndescription: \"Receptors emit events, perspectives handle writes\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Receptors\", \"Events\", \"Perspectives\", \"Lenses\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"OrderReceptors cs\"\nshowLineNumbers: true\nhighlightLines: [8, 13, 29, 45]\nusingStatements: [\"Whizbang\", \"System\", \"System Linq\"]\n}\nusing Whizbang;\nusing System;\nusing System Linq;\nnamespace MyApp Orders Receptors;\n// Receptor with aspects - receives commands, emits events\n[Logged]\n[Validated]\n[Transactional]\npublic class CreateOrderReceptor : IReceptor<CreateOrder> {\n    // Return type determines behavior: OrderCreated event flows to perspectives\n    public OrderCreated Receive(CreateOrder cmd, IOrderLens lens) {\n        // Validate using lens (read-only)\n        if ( lens CustomerExists(cmd CustomerId)) {\n            throw new CustomerNotFoundException();\n        }\n        // Calculate total\n        var totalAmount = cmd Items Sum(i => i Quantity * i UnitPrice);\n        // Emit event - perspectives handle all writes\n        return new OrderCreated(\n            Guid NewGuid(),\n            cmd CustomerId,\n            totalAmount,\n            DateTime",
        "startIndex": 2492,
        "preview": "1: Define Your Messages `csharp{ title: \"Message Definitions\" description: \"Simple message types - no special interfaces required\" framework: \"NET8\" c..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/simple-mediator-chunk-2",
        "text": "IOrderLens lens) { // Validate using lens (read-only) if ( lens CustomerExists(cmd CustomerId)) { throw new CustomerNotFoundException(); } // Calculate total var totalAmount = cmd Items Sum(i => i Quantity * i UnitPrice); // Emit event - perspectives handle all writes return new OrderCreated( Guid NewGuid(), cmd CustomerId, totalAmount, DateTime UtcNow\n        );\n    }\n}\n// Lens provides read-only queries\npublic class OrderLens : IOrderLens {\n    private readonly IDatabase db;\n    [Cached(Duration = \"5m\")]\n    public OrderDetails Focus(Guid orderId) {\n        var order = db Orders Find(orderId);\n        if (order == null) {\n            throw new NotFoundException($\"Order {orderId} not found\");\n        }\n        // Return read-only view\n        return new OrderDetails(\n            order Id,\n            order CustomerId,\n            order Items,\n            order TotalAmount,\n            order Status,\n            order CreatedAt\n        );\n    }\n    public bool CustomerExists(Guid customerId) {\n        return db Customers Any(c => c Id == customerId);\n    }\n}\n// Receptor returning multiple events via tuple\npublic class ProcessOrderReceptor : IReceptor<ProcessOrder> {\n    // Tuple return = multiple events flow to perspectives\n    public (OrderProcessed, EmailQueued, InventoryReserved) Receive(ProcessOrder cmd) {\n        // Make decisions, emit events\n        return (\n            new OrderProcessed(cmd OrderId),\n            new EmailQueued(cmd CustomerEmail, \"Order confirmed\"),\n            new InventoryReserved(cmd Items)\n        );\n    }\n}\n`\nStep 3: Implement Perspectives for Write Operations\n`csharp{\ntitle: \"Perspective Implementation - Handle All Writes\"\ndescription: \"Perspectives react to events and update storage\"\nframework: \"NET8\"\ncategory: \"Domain Logic\"\ndifficulty: \"BEGINNER\"\ntags: [\"Perspectives\", \"Events\", \"Database Updates\"]\nnugetPackages: [\"Whizbang Core\"]\nfilename: \"OrderPerspectives cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\", \"System Threading Tasks\"]\n}\nusing Whizbang;\nusing System;\nusing System Threading Tasks;\nnamespace MyApp Orders Perspectives;\n// Perspective handles all database writes\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> {\n    private readonly IDatabase db;\n    public async Task Update(OrderCreated e) {\n        // Create order in database\n        await db Orders Add(new Order {\n            Id = e OrderId,\n            CustomerId = e CustomerId,\n            Total = e TotalAmount,\n            Status = \"Pending\",\n            CreatedAt = e CreatedAt\n        });\n        await db",
        "startIndex": 4505,
        "preview": "IOrderLens lens) { // Validate using lens (read-only) if ( lens CustomerExists(cmd CustomerId)) { throw new CustomerNotFoundException(); } // Calculat..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/simple-mediator-chunk-3",
        "text": "writes public class OrderPerspective : IPerspectiveOf<OrderCreated> { private readonly IDatabase db; public async Task Update(OrderCreated e) { // Create order in database await db Orders Add(new Order { Id = e OrderId, CustomerId = e CustomerId, Total = e TotalAmount, Status = \"Pending\", CreatedAt = e CreatedAt }); await db SaveChanges();\n    }\n}\n// Multiple perspectives can react to same event\npublic class CustomerStatsPerspective : IPerspectiveOf<OrderCreated> {\n    private readonly IDatabase db;\n    public async Task Update(OrderCreated e) {\n        await db CustomerStats IncrementOrderCount(e CustomerId);\n        await db CustomerStats UpdateLastOrderDate(e CustomerId, e CreatedAt);\n    }\n}\n// Cache perspective\npublic class CachePerspective : IPerspectiveOf<OrderCreated> {\n    private readonly ICache cache;\n    public async Task Update(OrderCreated e) {\n        // Invalidate customer cache\n        await cache Remove($\"customer:{e CustomerId}:orders\");\n    }\n}\n`\nStep 4: Wire Up Your Application\n`csharp{\ntitle: \"Service Configuration\"\ndescription: \"Configure dispatcher with receptors, perspectives, and lenses\"\nframework: \"NET8\"\ncategory: \"Configuration\"\ndifficulty: \"BEGINNER\"\ntags: [\"DI\", \"Configuration\", \"Progressive Enhancement\"]\nnugetPackages: [\"Whizbang Core\", \"Microsoft Extensions DependencyInjection\"]\nfilename: \"Program cs\"\nshowLineNumbers: true\nhighlightLines: [8, 11, 20, 28]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\nusing Whizbang;\nusing Microsoft AspNetCore Builder;\nusing Microsoft Extensions DependencyInjection;\nusing MyApp Orders Receptors;\nusing MyApp Orders Perspectives;\nvar builder = WebApplication CreateBuilder(args);\n// Configure Event-Driven mode\nbuilder Services AddWhizbang() UseDispatcher(dispatcher => {\n        dispatcher DefaultPolicy = new EventDrivenPolicy();\n        // Register components\n        dispatcher RegisterReceptorsFromAssembly(typeof(Program) Assembly);\n        dispatcher RegisterPerspectivesFromAssembly(typeof(Program) Assembly);\n        dispatcher RegisterLensesFromAssembly(typeof(Program) Assembly);\n    });\n// Register lenses (read-only queries)\nbuilder Services AddScoped<IOrderLens, OrderLens>();\nbuilder Services AddScoped<ICustomerLens, CustomerLens>();\n// When ready for Event-Sourcing\n// dispatcher ForReceptor<Order>() UsePolicy(new EventSourcedPolicy());\n// When scaling to distributed\n// dispatcher UseRelay<KafkaRelay>();\nbuilder Services AddControllers();\nvar app = builder Build();\napp UseRouting();\napp MapControllers();\napp Run();\n`\nComplete Example\n`csharp{\ntitle: \"Complete Event-Driven Example\"\ndescription: \"Full working example with receptors, perspectives, and lenses\"\nframework: \"NET8\"\ncategory: \"Complete Example\"\ndifficulty: \"BEGINNER\"\ntags: [\"API\", \"Controller\", \"Dispatcher\", \"Event-Driven\", \"Complete\"]\nnugetPackages: [\"Whizbang",
        "startIndex": 6737,
        "preview": "writes public class OrderPerspective : IPerspectiveOf<OrderCreated> { private readonly IDatabase db; public async Task Update(OrderCreated e) { // Cre..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/simple-mediator-chunk-4",
        "text": "distributed // dispatcher UseRelay<KafkaRelay>(); builder Services AddControllers(); var app = builder Build(); app UseRouting(); app MapControllers(); app Run(); ` Complete Example `csharp{ title: \"Complete Event-Driven Example\" description: \"Full working example with receptors, perspectives, and lenses\" framework: \"NET8\" category: \"Complete Example\" difficulty: \"BEGINNER\" tags: [\"API\", \"Controller\", \"Dispatcher\", \"Event-Driven\", \"Complete\"] nugetPackages: [\"Whizbang Core\", \"Microsoft AspNetCore Mvc\"]\nfilename: \"OrdersController cs\"\nshowLineNumbers: true\nhighlightLines: [14, 23, 33]\ntestFile: \"OrdersControllerTests cs\"\ntestMethod: \"CreateOrder_ValidCommand_ReturnsOrderId\"\nusingStatements: [\"Whizbang\", \"Microsoft AspNetCore Mvc\", \"System\"]\n}\nusing Whizbang;\nusing Microsoft AspNetCore Mvc;\nusing System;\nusing MyApp Orders;\nnamespace MyApp Controllers;\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class OrdersController : ControllerBase {\n    private readonly IDispatcher _dispatcher;\n    private readonly IOrderLens _orderLens;\n    public OrdersController(IDispatcher dispatcher, IOrderLens orderLens) {\n        _dispatcher = dispatcher;\n        _orderLens = orderLens;\n    }\n    [HttpPost]\n    public async Task<ActionResult<OrderCreated>> CreateOrder(\n        [FromBody] CreateOrderRequest request) {\n        // Map request to command\n        var command = new CreateOrder(\n            request CustomerId,\n            request Items,\n            request ShippingAddress\n        );\n        try {\n            // Dispatcher routes to receptor, event flows to perspectives\n            var @event = await _dispatcher Dispatch(command);\n            return Ok(@event);\n        }\n        catch (ValidationException ex) {\n            return BadRequest(new { error = ex Message });\n        }\n        catch (InsufficientInventoryException ex) {\n            return Conflict(new { error = ex Message });\n        }\n    }\n    [HttpGet(\"{orderId}\")]\n    public async Task<ActionResult<OrderDetails>> GetOrder(Guid orderId) {\n        try {\n            // Use lens for queries (read-only)\n            var order = _orderLens Focus(orderId);\n            return Ok(order);\n        }\n        catch (NotFoundException ex) {\n            return NotFound(new { error = ex Message });\n        }\n    }\n    [HttpPost(\"{orderId}/process\")]\n    public async Task<ActionResult> ProcessOrder(Guid orderId) {\n        // Receptor returns tuple - all events flow to perspectives\n        var (orderProcessed, emailQueued, inventoryReserved) = \n            await _dispatcher Dispatch(new ProcessOrder(orderId));\n        return Ok(new {\n            orderId = orderProcessed OrderId,\n            emailQueued = emailQueued QueueId,\n            inventoryReserved = inventoryReserved",
        "startIndex": 7691,
        "preview": "distributed // dispatcher UseRelay<KafkaRelay>(); builder Services AddControllers(); var app = builder Build(); app UseRouting(); app MapControllers()..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/simple-mediator-chunk-5",
        "text": "return NotFound(new { error = ex Message }); } } [HttpPost(\"{orderId}/process\")] public async Task<ActionResult> ProcessOrder(Guid orderId) { // Receptor returns tuple - all events flow to perspectives var (orderProcessed, emailQueued, inventoryReserved) = await _dispatcher Dispatch(new ProcessOrder(orderId)); return Ok(new { orderId = orderProcessed OrderId, emailQueued = emailQueued QueueId, inventoryReserved = inventoryReserved ReservationId\n        });\n    }\n}\n// Request DTOs\npublic record CreateOrderRequest(\n    Guid CustomerId,\n    List<OrderItem> Items,\n    string ShippingAddress\n);\n`\nTesting Strategy\nUnit Testing Receptors and Perspectives\n`csharp{\ntitle: \"Receptor and Perspective Unit Tests\"\ndescription: \"Test receptors and perspectives in isolation\"\nframework: \"NET8\"\ncategory: \"Testing\"\ndifficulty: \"BEGINNER\"\ntags: [\"Unit Testing\", \"xUnit\", \"Aspects\"]\nnugetPackages: [\"Whizbang Core\", \"xUnit\"]\nfilename: \"CreateOrderHandlerTests cs\"\nshowLineNumbers: true\nhighlightLines: [15, 25, 40]\nusingStatements: [\"Whizbang\", \"Xunit\"]\n}\nusing Whizbang;\nusing Xunit;\nusing System;\nusing System Collections Generic;\nusing MyApp Orders;\nusing MyApp Orders Receptors;\nusing MyApp Orders Perspectives;\nnamespace MyApp Tests Orders;\npublic class CreateOrderReceptorTests {\n    [Fact]\n    public void Receive_ValidCommand_ReturnsOrderCreatedEvent() {\n        // Arrange\n        var receptor = new CreateOrderReceptor();\n        var command = new CreateOrder(\n            Guid NewGuid(),\n            new List<OrderItem> {\n                new OrderItem(\"PROD-1\", \"Widget\", 2, 10 00m)\n            },\n            \"123 Main St\"\n        );\n        var lens = Mock Of<IOrderLens>(l => \n            l CustomerExists(It IsAny<Guid>()) == true\n        );\n        // Act - Receptor emits event\n        var @event = receptor Receive(command, lens);\n        // Assert - Event emitted\n        Assert NotNull(@event);\n        Assert IsType<OrderCreated>(@event);\n        Assert Equal(20 00m, @event TotalAmount);\n    }\n    [Fact]\n    public void Receive_ProcessOrder_ReturnsMultipleEvents() {\n        // Arrange\n        var receptor = new ProcessOrderReceptor();\n        var command = new ProcessOrder(Guid NewGuid());\n        // Act - Receptor returns tuple of events\n        var (processed, emailQueued, inventoryReserved) = receptor Receive(command);\n        // Assert - All events emitted\n        Assert NotNull(processed);\n        Assert NotNull(emailQueued);\n        Assert NotNull(inventoryReserved);\n        Assert Equal(command OrderId, processed",
        "startIndex": 11567,
        "preview": "return NotFound(new { error = ex Message }); } } [HttpPost(\"{orderId}/process\")] public async Task<ActionResult> ProcessOrder(Guid orderId) { // Recep..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/simple-mediator-chunk-6",
        "text": "} [Fact] public void Receive_ProcessOrder_ReturnsMultipleEvents() { // Arrange var receptor = new ProcessOrderReceptor(); var command = new ProcessOrder(Guid NewGuid()); // Act - Receptor returns tuple of events var (processed, emailQueued, inventoryReserved) = receptor Receive(command); // Assert - All events emitted Assert NotNull(processed); Assert NotNull(emailQueued); Assert NotNull(inventoryReserved); Assert Equal(command OrderId, processed OrderId);\n    }\n}\n// Test Perspectives\npublic class PerspectiveTests {\n    [Fact]\n    public async Task OrderPerspective_UpdatesDatabase_WhenOrderCreatedReceived() {\n        // Arrange\n        var db = new InMemoryDatabase();\n        var perspective = new OrderPerspective(db);\n        var @event = new OrderCreated {\n            OrderId = Guid NewGuid(),\n            CustomerId = Guid NewGuid(),\n            TotalAmount = 100 00m\n        };\n        // Act - Perspective handles write\n        await perspective Update(@event);\n        // Assert - Database updated\n        var order = await db Orders Find(@event OrderId);\n        Assert NotNull(order);\n        Assert Equal(@event CustomerId, order CustomerId);\n        Assert Equal(@event TotalAmount, order Total);\n    }\n    [Fact]\n    public async Task Handler_WithLoggingAspect_LogsExecution() {\n        // Test logging aspect\n        await Whizbang Test<CreateOrderHandler>() Given(new CreateOrder { }) WithAspects() WhenHandled() ThenAspect<LoggingAspect>(logs => {\n                logs ShouldContain(\"Executing CreateOrderHandler\");\n                logs ShouldContain(\"Completed in\");\n            });\n    }\n}\n`\nCommon Pitfalls\nAvoid Direct Handler Calls\n`csharp{\ntitle: \"Proper Handler Usage Pattern\"\ndescription: \"Use the dispatcher instead of injecting handlers directly\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Simple Mediator\", \"Best Practices\", \"Anti-Patterns\"]\nfilename: \"OrderService cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\"]\n}\n// ❌ BAD - Don't inject and call handlers directly\npublic class OrderService {\n    private readonly CreateOrderHandler _handler;\n    public OrderService(CreateOrderHandler handler) {\n        _handler = handler;\n    }\n}\n// ✅ GOOD - Always use Whizbang for routing\npublic class OrderService {\n    private readonly IWhizbang _whizbang;\n    public OrderService(IWhizbang whizbang) {\n        _whizbang = whizbang;\n    }\n}\n`\nUse Return Types to Express Intent\n`csharp{\ntitle: \"Return Type Semantics Examples\"\ndescription: \"Express intent clearly through return types for proper event flow\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Simple Mediator\", \"Return Types\", \"Best Practices\", \"Events\"]\nfilename: \"ReturnTypeExamples",
        "startIndex": 13676,
        "preview": "} [Fact] public void Receive_ProcessOrder_ReturnsMultipleEvents() { // Arrange var receptor = new ProcessOrderReceptor(); var command = new ProcessOrd..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/simple-mediator-chunk-7",
        "text": "public OrderService(IWhizbang whizbang) { _whizbang = whizbang; } } ` Use Return Types to Express Intent `csharp{ title: \"Return Type Semantics Examples\" description: \"Express intent clearly through return types for proper event flow\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"BEGINNER\" tags: [\"Simple Mediator\", \"Return Types\", \"Best Practices\", \"Events\"] filename: \"ReturnTypeExamples cs\"\nshowLineNumbers: true\nusingStatements: [\"System\"]\n}\n// ❌ BAD - Unclear what happens with the result\npublic object Handle(CreateOrder cmd) {\n    return new { OrderId = Guid NewGuid() };\n}\n// ✅ GOOD - Return type makes intent clear\npublic OrderCreated Handle(CreateOrder cmd) {\n    return new OrderCreated(Guid NewGuid());\n}\n// ✅ GOOD - Multiple effects via tuple\npublic (OrderCreated, SendEmail) Handle(CreateOrder cmd) {\n    return (new OrderCreated(), new SendEmail());\n}\n`\nAvoid Business Logic in Controllers\n`csharp{\ntitle: \"Controller Logic Separation\"\ndescription: \"Keep business logic in handlers, not controllers\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Simple Mediator\", \"Controllers\", \"Separation of Concerns\", \"Best Practices\"]\nfilename: \"OrderController cs\"\nshowLineNumbers: true\nusingStatements: [\"Microsoft AspNetCore Mvc\", \"System Threading Tasks\"]\n}\n// ❌ BAD - Business logic in controller\n[HttpPost]\npublic async Task<IActionResult> CreateOrder(CreateOrderRequest request) {\n    if (request Items Sum(i => i Quantity * i UnitPrice) > 1000) {\n        // Business logic doesn't belong here request RequiresApproval = true;\n    }\n}\n// ✅ GOOD - All logic in handler\n[HttpPost]\npublic async Task<IActionResult> CreateOrder(CreateOrderRequest request) {\n    var command = MapToCommand(request);\n    var result = await _whizbang Send(command);\n    return Ok(result);\n}\n`\nProgressive Enhancement\nStart Simple\n`csharp{\ntitle: \"Phase 1: Simple In-Process Configuration\"\ndescription: \"Start with simple in-process messaging like MediatR\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Simple Mediator\", \"Configuration\", \"Progressive Enhancement\", \"In-Process\"]\nfilename: \"Program cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Phase 1: Simple in-process (like MediatR)\nbuilder Services AddWhizbang()",
        "startIndex": 16026,
        "preview": "public OrderService(IWhizbang whizbang) { _whizbang = whizbang; } } ` Use Return Types to Express Intent `csharp{ title: \"Return Type Semantics Exampl..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/simple-mediator-chunk-8",
        "text": "`csharp{ title: \"Phase 1: Simple In-Process Configuration\" description: \"Start with simple in-process messaging like MediatR\" framework: \"NET8\" category: \"Usage Patterns\" difficulty: \"BEGINNER\" tags: [\"Simple Mediator\", \"Configuration\", \"Progressive Enhancement\", \"In-Process\"] filename: \"Program cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"] } // Phase 1: Simple in-process (like MediatR) builder Services AddWhizbang() UseInProcessMode();\n`\nAdd Durability When Needed\n`csharp{\ntitle: \"Phase 2: Durable Mode Configuration\"\ndescription: \"Add persistence and retry capabilities like Wolverine\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Simple Mediator\", \"Configuration\", \"Progressive Enhancement\", \"Durability\", \"PostgreSQL\"]\nfilename: \"Program cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Phase 2: Add persistence and retry (like Wolverine)\nbuilder Services AddWhizbang() UseDurableMode() UsePostgreSQL(connectionString) WithOutbox();\n`\nScale to Distributed\n`csharp{\ntitle: \"Phase 3: Distributed Mode Configuration\"\ndescription: \"Scale to microservices architecture like MassTransit\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Simple Mediator\", \"Configuration\", \"Progressive Enhancement\", \"Distributed\", \"Kafka\", \"Microservices\"]\nfilename: \"Program cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Phase 3: Microservices (like MassTransit)\nbuilder Services AddWhizbang() UseDistributedMode() UseKafka(kafkaConfig) WithSagaOrchestration();\n`\nEnable Event Sourcing\n`csharp{\ntitle: \"Phase 4: Event Sourcing Configuration\"\ndescription: \"Enable full event sourcing capabilities unique to Whizbang\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Simple Mediator\", \"Configuration\", \"Progressive Enhancement\", \"Event Sourcing\", \"Projections\"]\nfilename: \"Program cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\n}\n// Phase 4: Full event sourcing (unique to Whizbang)\nbuilder Services AddWhizbang() UseEventSourcedMode() UseEventStore(eventStoreConfig) WithProjections() WithSnapshots();\n`\nThe same handler code works in ALL modes",
        "startIndex": 17972,
        "preview": "`csharp{ title: \"Phase 1: Simple In-Process Configuration\" description: \"Start with simple in-process messaging like MediatR\" framework: \"NET8\" catego..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/simple-mediator-chunk-9",
        "text": "category: \"Usage Patterns\" difficulty: \"INTERMEDIATE\" tags: [\"Simple Mediator\", \"Configuration\", \"Progressive Enhancement\", \"Event Sourcing\", \"Projections\"] filename: \"Program cs\" showLineNumbers: true usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"] } // Phase 4: Full event sourcing (unique to Whizbang) builder Services AddWhizbang() UseEventSourcedMode() UseEventStore(eventStoreConfig) WithProjections() WithSnapshots(); ` The same handler code works in ALL modes Related Patterns\nEvent Sourcing Basics - Add persistence and event history\nCQRS Implementation - Separate read and write models\nDistributed Messaging - Scale across services\nProduction Considerations\nPerformance\nZero-overhead aspects via source generation\nHandler pooling for reduced allocations\nCompile-time optimizations\nAdaptive runtime optimization\nMonitoring with Aspects\n`csharp{\ntitle: \"Monitoring with Aspects\"\ndescription: \"Built-in observability through declarative aspects\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"BEGINNER\"\ntags: [\"Simple Mediator\", \"Aspects\", \"Monitoring\", \"Observability\", \"Logging\"]\nfilename: \"OrderHandler cs\"\nshowLineNumbers: true\nusingStatements: [\"Whizbang\", \"System\"]\n}\n// Built-in observability via aspects\n[Observed] // Automatic telemetry\n[Timed]    // Performance metrics\n[Logged]   // Structured logging\npublic class OrderHandler : IHandle<CreateOrder> {\n    public OrderCreated Handle(CreateOrder cmd) {\n        // Automatically generates:\n        // - Distributed trace spans\n        // - Metrics (count, duration, errors)\n        // - Structured logs with correlation IDs\n        return new OrderCreated(cmd OrderId);\n    }\n}\n`\nError Handling with Result Types\n`csharp{\ntitle: \"Error Handling with Result Types\"\ndescription: \"Use Result types for robust error handling without exceptions\"\nframework: \"NET8\"\ncategory: \"Usage Patterns\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Simple Mediator\", \"Error Handling\", \"Result Types\", \"Best Practices\"]\nfilename: \"OrderHandler cs\"\nshowLineNumbers: true\nusingStatements: [\"System\"]\n}\npublic Result<OrderCreated> Handle(CreateOrder cmd) {\n    if ( IsValid(cmd)) {\n        return Result Failure<OrderCreated>(\"Validation failed\");\n    }\n    try {\n        var order = CreateOrder(cmd);\n        return Result Success(new OrderCreated(order Id));\n    }\n    catch (Exception ex) {\n        return Result Failure<OrderCreated>(ex",
        "startIndex": 19898,
        "preview": "category: \"Usage Patterns\" difficulty: \"INTERMEDIATE\" tags: [\"Simple Mediator\", \"Configuration\", \"Progressive Enhancement\", \"Event Sourcing\", \"Project..."
      },
      {
        "id": "old-v1.0.0.0/usage-patterns/simple-mediator-chunk-10",
        "text": "tags: [\"Simple Mediator\", \"Error Handling\", \"Result Types\", \"Best Practices\"] filename: \"OrderHandler cs\" showLineNumbers: true usingStatements: [\"System\"] } public Result<OrderCreated> Handle(CreateOrder cmd) { if ( IsValid(cmd)) { return Result Failure<OrderCreated>(\"Validation failed\"); } try { var order = CreateOrder(cmd); return Result Success(new OrderCreated(order Id)); } catch (Exception ex) { return Result Failure<OrderCreated>(ex Message);\n    }\n}\n`\nNext Steps\nExplore Progressive Enhancement to scale your application\nLearn about Aspect-Oriented Handlers for cross-cutting concerns\nReview Return Type Semantics for advanced patterns\nCheck out Event Sourcing Basics when ready for event sourcing\nSee CQRS Implementation for read/write separation",
        "startIndex": 21817,
        "preview": "tags: [\"Simple Mediator\", \"Error Handling\", \"Result Types\", \"Best Practices\"] filename: \"OrderHandler cs\" showLineNumbers: true usingStatements: [\"Sys..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.1/_folder",
    "title": "old-v1.0.1/_folder",
    "category": "General",
    "url": "/docs/old-v1.0.1/_folder",
    "chunks": [
      {
        "id": "old-v1.0.1/_folder-chunk-0",
        "text": "Release v1.0.1 - Bug Fixes & Improvements\nStatus\nCurrently in planning phase. Focus on stability and minor feature enhancements.\nEstimated Release: February 1, 2025",
        "startIndex": 0,
        "preview": "Release v1.0.1 - Bug Fixes & Improvements\nStatus\nCurrently in planning phase. Focus on stability and minor feature enhancements.\nEstimated Release: Fe..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.0.1/bug-fixes",
    "title": "Bug Fixes and Improvements",
    "category": "Release Notes",
    "url": "/docs/old-v1.0.1/bug-fixes",
    "chunks": [
      {
        "id": "old-v1.0.1/bug-fixes-chunk-0",
        "text": "Bug Fixes and Improvements\n⚠️ FUTURE FEATURE - NOT YET RELEASED\nThis documentation describes bug fixes and improvements planned for v1.0.1.\nThese features are not available in the current release.\nStatus: Planned\nTarget Version: 1.0.1\nPlanned Improvements\nPerformance optimizations\nMemory usage improvements\nEnhanced error handling\nDocumentation updates",
        "startIndex": 0,
        "preview": "Bug Fixes and Improvements\n⚠️ FUTURE FEATURE - NOT YET RELEASED\nThis documentation describes bug fixes and improvements planned for v1.0.1.\nThese feat..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.1.0/_folder",
    "title": "old-v1.1.0/_folder",
    "category": "General",
    "url": "/docs/old-v1.1.0/_folder",
    "chunks": [
      {
        "id": "old-v1.1.0/_folder-chunk-0",
        "text": "Release v1.1.0 - Advanced Projection Management\nPlanned Features\nEnhanced projection subscription system\nAdvanced aggregate management tools\nPerformance optimizations for large-scale deployments\nImproved configuration management\nEnhanced observability and metrics\nStatus\nCurrently in beta development. Features are being implemented and tested.\nEstimated Release: January 15, 2025",
        "startIndex": 0,
        "preview": "Release v1.1.0 - Advanced Projection Management\nPlanned Features\nEnhanced projection subscription system\nAdvanced aggregate management tools\nPerforman..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.1.0/backups-and-snapshots",
    "title": "Backups and Snapshots",
    "category": "Roadmap",
    "url": "/docs/old-v1.1.0/backups-and-snapshots",
    "chunks": [
      {
        "id": "old-v1.1.0/backups-and-snapshots-chunk-0",
        "text": "Backups and Snapshots\n⚠️ FUTURE FEATURE - NOT YET RELEASED\nThis documentation describes backup and snapshot support planned for v1 1 0 These features are not available in the current release Status: Planned\nTarget Version: 1 1 0\n---\nOverview\nWhizbang will provide comprehensive backup and snapshot capabilities for disaster recovery, point-in-time restoration, and performance optimization Event Store Backups\nContinuous Backup\nAutomatic, incremental backups of event streams:\n`csharp{\ntitle: \"Backup Configuration\"\ndescription: \"Configure automatic event store backups\"\nframework: \"NET8\"\ncategory: \"Backups\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Backups\", \"Disaster Recovery\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang Backups\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UsePostgres(connectionString);\n        // Configure backups\n        es UseBackups(backup => {\n            // Continuous backup to Azure Blob Storage\n            backup UseAzureBlobStorage(config => {\n                config ConnectionString = azureStorageConnectionString;\n                config ContainerName = \"whizbang-backups\";\n            });\n            // Backup every 5 minutes\n            backup Interval = TimeSpan FromMinutes(5);\n            // Retention policy\n            backup RetainFor = TimeSpan FromDays(30);\n            backup PointInTimeRecovery = true;  // Keep transaction logs\n        });\n    });\n});\n`\nBackup Targets:\nAzure Blob Storage\nAWS S3\nGoogle Cloud Storage\nLocal file system\nNetwork share (SMB/NFS)\nPoint-in-Time Recovery (PITR)\nRestore event store to any point in time:\n`csharp{\ntitle: \"Point-in-Time Recovery\"\ndescription: \"Restore event store to specific timestamp\"\nframework: \"NET8\"\ncategory: \"Disaster Recovery\"\ndifficulty: \"ADVANCED\"\ntags: [\"Backups\", \"Disaster Recovery\", \"PITR\"]\nnugetPackages: [\"Whizbang Backups\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang Backups\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang Backups;\npublic class DisasterRecoveryService {\n    private readonly IEventStoreBackupManager _backupManager;\n    public DisasterRecoveryService(IEventStoreBackupManager backupManager) {\n        _backupManager = backupManager;\n    }\n    public async Task RecoverToPointInTimeAsync(DateTimeOffset targetTime) {\n        // Restore event store to specific timestamp\n        await _backupManager",
        "startIndex": 0,
        "preview": "Backups and Snapshots\n⚠️ FUTURE FEATURE - NOT YET RELEASED\nThis documentation describes backup and snapshot support planned for v1 1 0 These features ..."
      },
      {
        "id": "old-v1.1.0/backups-and-snapshots-chunk-1",
        "text": "usingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang Backups\"] showLineNumbers: true } using System; using System Threading Tasks; using Whizbang Backups; public class DisasterRecoveryService { private readonly IEventStoreBackupManager _backupManager; public DisasterRecoveryService(IEventStoreBackupManager backupManager) { _backupManager = backupManager; } public async Task RecoverToPointInTimeAsync(DateTimeOffset targetTime) { // Restore event store to specific timestamp await _backupManager RestoreAsync(new RestoreOptions {\n            TargetTime = targetTime,\n            TargetDatabase = \"whizbang_events_restored\",\n            VerifyIntegrity = true\n        });\n        // All events after targetTime are discarded\n        // All events before targetTime are restored\n    }\n    public async Task RecoverLastGoodStateAsync() {\n        // Find last known good backup\n        var lastGood = await _backupManager GetLastHealthyBackupAsync();\n        await _backupManager RestoreAsync(new RestoreOptions {\n            BackupId = lastGood Id,\n            TargetDatabase = \"whizbang_events\"\n        });\n    }\n}\n`\nBackup Verification\nAutomatic verification of backup integrity:\n`csharp{\ntitle: \"Backup Verification\"\ndescription: \"Verify backup integrity automatically\"\nframework: \"NET8\"\ncategory: \"Backups\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Backups\", \"Verification\"]\nnugetPackages: [\"Whizbang Backups\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseBackups(backup => {\n            // Verify backups automatically\n            backup VerifyAfterBackup = true;\n            // Restore to temporary database and validate\n            backup VerificationStrategy = BackupVerificationStrategy FullRestore;\n            // Alert on verification failure\n            backup OnVerificationFailed = async (backupId, error) => {\n                await alertService SendAsync($\"Backup {backupId} verification failed: {error}\");\n            };\n        });\n    });\n});\n`\nAggregate Snapshots\nPerformance Optimization\nSnapshots avoid replaying thousands of events for long-lived aggregates:\n`csharp{\ntitle: \"Aggregate Snapshots\"\ndescription: \"Configure snapshots for aggregates\"\nframework: \"NET8\"\ncategory: \"Snapshots\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Snapshots\", \"Performance\", \"Aggregates\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang Snapshots\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UseSnapshots(snap => {\n            // Snapshot every 100 events\n            snap SnapshotEvery = 100;\n            // Store snapshots in same database as events\n            snap",
        "startIndex": 2587,
        "preview": "usingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang Backups\"] showLineNumbers: true } using System; using System Threading Tasks; using Wh..."
      },
      {
        "id": "old-v1.1.0/backups-and-snapshots-chunk-2",
        "text": "EventSourcing\", \"Whizbang Snapshots\"] usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"] showLineNumbers: true } using System; using Whizbang; using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseEventSourcing(es => { es UseSnapshots(snap => { // Snapshot every 100 events snap SnapshotEvery = 100; // Store snapshots in same database as events snap UsePostgres(connectionString);\n            // Or use faster storage for snapshots\n            snap UseRedis(redisConnectionString);\n            // Async snapshot creation (doesn't block aggregate saves)\n            snap CreateAsynchronously = true;\n        });\n    });\n});\n`\nManual Snapshots\nCreate snapshots for specific aggregates:\n`csharp{\ntitle: \"Manual Snapshot Creation\"\ndescription: \"Create snapshots on demand\"\nframework: \"NET8\"\ncategory: \"Snapshots\"\ndifficulty: \"ADVANCED\"\ntags: [\"Snapshots\", \"Aggregates\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang Snapshots\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang Snapshots\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang Snapshots;\npublic class SnapshotService {\n    private readonly ISnapshotStore _snapshotStore;\n    private readonly IRepository<Order> _orderRepository;\n    public SnapshotService(ISnapshotStore snapshotStore, IRepository<Order> orderRepository) {\n        _snapshotStore = snapshotStore;\n        _orderRepository = orderRepository;\n    }\n    public async Task CreateSnapshotAsync(Guid orderId) {\n        // Load aggregate\n        var order = await _orderRepository GetAsync(orderId);\n        // Create snapshot\n        await _snapshotStore SaveSnapshotAsync(order);\n    }\n    public async Task RebuildSnapshotsForAllOrdersAsync() {\n        // Rebuild all snapshots (e g , after schema change)\n        var orderIds = await GetAllOrderIdsAsync();\n        foreach (var orderId in orderIds) {\n            await CreateSnapshotAsync(orderId);\n        }\n    }\n}\n`\nSnapshot Schema Versioning\nHandle snapshot schema changes:\n`csharp{\ntitle: \"Snapshot Versioning\"\ndescription: \"Handle evolving snapshot schemas\"\nframework: \"NET8\"\ncategory: \"Snapshots\"\ndifficulty: \"ADVANCED\"\ntags: [\"Snapshots\", \"Versioning\", \"Schema Evolution\"]\nnugetPackages: [\"Whizbang Snapshots\"]\nusingStatements: [\"System\", \"Whizbang Snapshots\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang",
        "startIndex": 5101,
        "preview": "EventSourcing\", \"Whizbang Snapshots\"] usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"] showLineNumbers: true } usin..."
      },
      {
        "id": "old-v1.1.0/backups-and-snapshots-chunk-3",
        "text": "in orderIds) { await CreateSnapshotAsync(orderId); } } } ` Snapshot Schema Versioning Handle snapshot schema changes: `csharp{ title: \"Snapshot Versioning\" description: \"Handle evolving snapshot schemas\" framework: \"NET8\" category: \"Snapshots\" difficulty: \"ADVANCED\" tags: [\"Snapshots\", \"Versioning\", \"Schema Evolution\"] nugetPackages: [\"Whizbang Snapshots\"] usingStatements: [\"System\", \"Whizbang Snapshots\"] showLineNumbers: true } using System; using Whizbang Snapshots;\n// V1 snapshot\npublic class OrderSnapshotV1 {\n    public Guid Id { get; set; }\n    public string Status { get; set; }\n    public decimal Total { get; set; }\n}\n// V2 snapshot (added fields)\npublic class OrderSnapshotV2 {\n    public Guid Id { get; set; }\n    public string Status { get; set; }\n    public decimal Total { get; set; }\n    public DateTimeOffset PlacedAt { get; set; }  // New field\n    public string Currency { get; set; }          // New field\n}\n// Upcaster converts V1 → V2\npublic class OrderSnapshotUpcaster : ISnapshotUpcaster<OrderSnapshotV1, OrderSnapshotV2> {\n    public OrderSnapshotV2 Upcast(OrderSnapshotV1 oldSnapshot) {\n        return new OrderSnapshotV2 {\n            Id = oldSnapshot Id,\n            Status = oldSnapshot Status,\n            Total = oldSnapshot Total,\n            PlacedAt = DateTimeOffset MinValue,  // Default for old snapshots\n            Currency = \"USD\"                      // Default currency\n        };\n    }\n}\n`\nProjection Backups\nRebuild vs Backup\nProjections can be rebuilt from events, but backups provide faster recovery:\n`csharp{\ntitle: \"Projection Backup Strategy\"\ndescription: \"Choose between rebuild and backup restore\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Backups\", \"Disaster Recovery\"]\nnugetPackages: [\"Whizbang Projections\", \"Whizbang Backups\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseProjections(proj => {\n        proj RegisterProjection<OrderHistoryProjection>(p => {\n            // Strategy 1: Rebuild from events (slow but always correct)\n            p DisasterRecoveryStrategy = ProjectionRecoveryStrategy RebuildFromEvents;\n            // Strategy 2: Restore from backup (fast but needs regular backups)\n            p DisasterRecoveryStrategy = ProjectionRecoveryStrategy RestoreFromBackup;\n            p BackupInterval = TimeSpan",
        "startIndex": 7099,
        "preview": "in orderIds) { await CreateSnapshotAsync(orderId); } } } ` Snapshot Schema Versioning Handle snapshot schema changes: `csharp{ title: \"Snapshot Versio..."
      },
      {
        "id": "old-v1.1.0/backups-and-snapshots-chunk-4",
        "text": "Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseProjections(proj => { proj RegisterProjection<OrderHistoryProjection>(p => { // Strategy 1: Rebuild from events (slow but always correct) p DisasterRecoveryStrategy = ProjectionRecoveryStrategy RebuildFromEvents; // Strategy 2: Restore from backup (fast but needs regular backups) p DisasterRecoveryStrategy = ProjectionRecoveryStrategy RestoreFromBackup; p BackupInterval = TimeSpan FromHours(1);\n            // Strategy 3: Hybrid (restore backup, then replay recent events)\n            p DisasterRecoveryStrategy = ProjectionRecoveryStrategy Hybrid;\n            p BackupInterval = TimeSpan FromHours(6);\n        });\n    });\n});\n`\nProjection Snapshots\nExport projection state for analytics or migration:\n`csharp{\ntitle: \"Projection Export\"\ndescription: \"Export projection state for backup or analytics\"\nframework: \"NET8\"\ncategory: \"Projections\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Projections\", \"Backups\", \"Export\"]\nnugetPackages: [\"Whizbang Projections\", \"Whizbang Backups\"]\nusingStatements: [\"System\", \"System Threading Tasks\", \"Whizbang Backups\"]\nshowLineNumbers: true\n}\nusing System;\nusing System Threading Tasks;\nusing Whizbang Backups;\npublic class ProjectionBackupService {\n    private readonly IProjectionBackupManager _backupManager;\n    public ProjectionBackupService(IProjectionBackupManager backupManager) {\n        _backupManager = backupManager;\n    }\n    public async Task BackupProjectionAsync<TProjection>() {\n        // Export entire projection to Parquet file\n        await _backupManager ExportProjectionAsync<TProjection>(new ExportOptions {\n            Format = ExportFormat Parquet,\n            Destination = \"s3://backups/projections/order-history parquet\",\n            Compression = CompressionType Snappy\n        });\n    }\n    public async Task RestoreProjectionAsync<TProjection>(string backupPath) {\n        // Import projection from backup\n        await _backupManager ImportProjectionAsync<TProjection>(new ImportOptions {\n            Source = backupPath,\n            TruncateExisting = true  // Clear current data first\n        });\n    }\n}\n`\nCross-Region Replication\nReplicate event streams to multiple regions for disaster recovery:\n`csharp{\ntitle: \"Cross-Region Replication\"\ndescription: \"Replicate events to multiple regions\"\nframework: \"NET8\"\ncategory: \"Disaster Recovery\"\ndifficulty: \"ADVANCED\"\ntags: [\"Replication\", \"Multi-Region\", \"Disaster Recovery\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang Replication\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        // Primary region (US East)\n        es UsePostgres(\"Host=us-east postgres azure com; \");\n        // Replicate to secondary regions\n        es UseReplication(repl => {\n            repl ReplicateTo(\"us-west\", \"Host=us-west postgres azure com; \");\n            repl ReplicateTo(\"eu-west\", \"Host=eu-west postgres azure",
        "startIndex": 9160,
        "preview": "Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseProjections(proj => { proj RegisterProjection<OrderHistoryProje..."
      },
      {
        "id": "old-v1.1.0/backups-and-snapshots-chunk-5",
        "text": "DependencyInjection\"] showLineNumbers: true } using Whizbang; using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseEventSourcing(es => { // Primary region (US East) es UsePostgres(\"Host=us-east postgres azure com; \"); // Replicate to secondary regions es UseReplication(repl => { repl ReplicateTo(\"us-west\", \"Host=us-west postgres azure com; \"); repl ReplicateTo(\"eu-west\", \"Host=eu-west postgres azure com; \");\n            // Async replication (eventual consistency)\n            repl Mode = ReplicationMode Asynchronous;\n            // Failover configuration\n            repl AutomaticFailover = true;\n            repl HealthCheckInterval = TimeSpan FromSeconds(10);\n        });\n    });\n});\n`\nBackup Monitoring\nMonitor backup health and alert on issues:\n`csharp{\ntitle: \"Backup Monitoring\"\ndescription: \"Monitor and alert on backup health\"\nframework: \"NET8\"\ncategory: \"Observability\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Backups\", \"Monitoring\", \"Alerts\"]\nnugetPackages: [\"Whizbang Backups\", \"Whizbang OpenTelemetry\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseBackups(backup => {\n        // Emit OpenTelemetry metrics\n        backup UseOpenTelemetry();\n        // Alert on backup failures\n        backup OnBackupFailed = async (error) => {\n            await alertService SendAsync($\"Backup failed: {error Message}\");\n        };\n        // Alert if backup hasn't run recently\n        backup AlertIfNoBackupFor = TimeSpan FromHours(2);\n        // Alert on low disk space\n        backup AlertIfStorageBelow = 10  1024  1024 * 1024;  // 10 GB\n    });\n});\n`\nMetrics Emitted:\nwhizbang backup duration - How long backups take\nwhizbang backup size - Backup size in bytes\nwhizbang backup success - Backup success/failure count\nwhizbang backup verification_duration - Verification time\nNext Steps\nLakehouse Streaming - Stream events to data lakes\nObservability - Monitor backup health\nDisaster Recovery - Complete DR strategy\nFeedback Welcome\nWe're designing this feature now What backup strategies do you need Share your thoughts",
        "startIndex": 11553,
        "preview": "DependencyInjection\"] showLineNumbers: true } using Whizbang; using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { option..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.2.0/_folder",
    "title": "old-v1.2.0/_folder",
    "category": "General",
    "url": "/docs/old-v1.2.0/_folder",
    "chunks": [
      {
        "id": "old-v1.2.0/_folder-chunk-0",
        "text": "Release v1.2.0 - Distributed Messaging & Scalability\nPlanned Features\nDistributed messaging infrastructure\nMulti-tenant architecture support\nAdvanced schema evolution\nLakehouse streaming capabilities\nEnterprise-grade deployment tools\nStatus\nCurrently in alpha planning phase. Architecture and design work in progress.\nEstimated Release: March 15, 2025",
        "startIndex": 0,
        "preview": "Release v1.2.0 - Distributed Messaging & Scalability\nPlanned Features\nDistributed messaging infrastructure\nMulti-tenant architecture support\nAdvanced ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.2.0/distributed-messaging",
    "title": "Distributed Messaging",
    "category": "Roadmap",
    "url": "/docs/old-v1.2.0/distributed-messaging",
    "chunks": [
      {
        "id": "old-v1.2.0/distributed-messaging-chunk-0",
        "text": "Distributed Messaging\n⚠️ FUTURE FEATURE - NOT YET RELEASED\nThis documentation describes distributed messaging support planned for v1 0 0 This feature is not available in the current release Status: Planned\nTarget Version: 1 0 0\n---\nOverview\nDistributed messaging enables Whizbang applications to scale beyond a single process into microservices architecture Commands and events can be routed across service boundaries using message brokers like Kafka, RabbitMQ, or Azure Service Bus Key Features\nDomain Ownership Routing\nCommands are routed to the service that owns the domain:\n`csharp\n// In the API Gateway service\nawait whizbang Send(new PlaceOrder( ));\n// ↓\n// Command automatically routed to Orders service via message broker\n`\nEvents are broadcast from the owning domain to all subscribers:\n`csharp\n// In the Orders service\nawait repository SaveAsync(order);  // Emits OrderPlaced event\n// ↓\n// Event published to message broker\n// ↓\n// Inventory, Shipping, and Analytics services all receive the event\n`\nOutbox/Inbox Pattern\nEnsures exactly-once semantics for distributed messaging:\nOutbox (publishing side):\nEvents written to outbox table in same transaction as event store append\nBackground worker publishes from outbox to message broker\nMessages marked as published after broker confirms\nInbox (subscribing side):\nMessages received from broker stored in inbox table\nIdempotent handler checks if message ID already processed\nPeriodic cleanup of old inbox entries\nMessage Broker Adapters\nMultiple message broker adapters will be supported:\nKafka - High throughput, event replay, partition awareness\nRabbitMQ - Flexible routing, priority queues\nAzure Service Bus - Managed service, sessions, duplicate detection\nAWS SQS/SNS - Managed service, FIFO queues\nConfiguration\nIntended API:\n`csharp{\ntitle: \"Distributed Messaging Configuration\"\ndescription: \"How distributed messaging will be configured\"\nframework: \"NET8\"\ncategory: \"Distributed Systems\"\ndifficulty: \"ADVANCED\"\ntags: [\"Messaging\", \"Configuration\", \"Microservices\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang Messaging\", \"Whizbang Kafka\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions",
        "startIndex": 0,
        "preview": "Distributed Messaging\n⚠️ FUTURE FEATURE - NOT YET RELEASED\nThis documentation describes distributed messaging support planned for v1 0 0 This feature ..."
      },
      {
        "id": "old-v1.2.0/distributed-messaging-chunk-1",
        "text": "- Managed service, sessions, duplicate detection AWS SQS/SNS - Managed service, FIFO queues Configuration Intended API: `csharp{ title: \"Distributed Messaging Configuration\" description: \"How distributed messaging will be configured\" framework: \"NET8\" category: \"Distributed Systems\" difficulty: \"ADVANCED\" tags: [\"Messaging\", \"Configuration\", \"Microservices\"] nugetPackages: [\"Whizbang Core\", \"Whizbang Messaging\", \"Whizbang Kafka\"] usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nvar services = new ServiceCollection();\nservices AddWhizbang(options => {\n    options UseMessaging(msg => {\n        // Configure domain ownership\n        msg UseDomainOwnership(domains => {\n            domains RegisterDomain(\"Orders\", \"https://orders myapp com\");\n            domains RegisterDomain(\"Inventory\", \"https://inventory myapp com\");\n            domains RegisterDomain(\"Shipping\", \"https://shipping myapp com\");\n        });\n        // Use Kafka as message broker\n        msg UseKafka(kafka => {\n            kafka BootstrapServers = \"kafka:9092\";\n            kafka ConsumerGroup = \"orders-service\";\n        });\n        // Enable outbox for reliable publishing\n        msg UseOutbox(outbox => {\n            outbox PublishInterval = TimeSpan FromSeconds(1);\n        });\n        // Enable inbox for idempotent consumption\n        msg UseInbox(inbox => {\n            inbox CleanupRetention = TimeSpan FromDays(7);\n        });\n    });\n});\n`\nBackfilling Projections\nWhen a new service subscribes to events for the first time, it can backfill from the entire event history:\n`csharp{\ntitle: \"Projection Backfilling\"\ndescription: \"Subscribe to events and backfill from history\"\nframework: \"NET8\"\ncategory: \"Distributed Systems\"\ndifficulty: \"ADVANCED\"\ntags: [\"Projections\", \"Backfilling\", \"Event Sourcing\"]\nnugetPackages: [\"Whizbang Core\", \"Whizbang EventSourcing\", \"Whizbang Projections\", \"Whizbang Messaging\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseProjections(proj => {\n        proj RegisterProjection<OrderAnalyticsProjection>(p => {\n            // Subscribe to events from Orders domain\n            p Subscribe<OrderPlaced>();\n            p Subscribe<OrderShipped>();\n            p Subscribe<OrderCancelled>();\n            // Backfill from the beginning of time\n            p BackfillFrom = DateTimeOffset MinValue;\n            // Query Orders service for historical events\n            p BackfillSource = \"https://orders myapp",
        "startIndex": 2161,
        "preview": "- Managed service, sessions, duplicate detection AWS SQS/SNS - Managed service, FIFO queues Configuration Intended API: `csharp{ title: \"Distributed M..."
      },
      {
        "id": "old-v1.2.0/distributed-messaging-chunk-2",
        "text": "DependencyInjection; services AddWhizbang(options => { options UseProjections(proj => { proj RegisterProjection<OrderAnalyticsProjection>(p => { // Subscribe to events from Orders domain p Subscribe<OrderPlaced>(); p Subscribe<OrderShipped>(); p Subscribe<OrderCancelled>(); // Backfill from the beginning of time p BackfillFrom = DateTimeOffset MinValue; // Query Orders service for historical events p BackfillSource = \"https://orders myapp com/events\";\n        });\n    });\n});\n`\nThe projection engine will:\nQuery the Orders service's event store via HTTP API\nFetch all historical events matching subscribed types\nApply them to the projection in order\nSwitch to real-time message broker consumption\nContinue processing new events as they arrive\nFeedback Welcome\nWe're designing this feature now and welcome your input What message brokers do you need supported What edge cases should we handle What API would be most intuitive Open a discussion to share your thoughts",
        "startIndex": 4398,
        "preview": "DependencyInjection; services AddWhizbang(options => { options UseProjections(proj => { proj RegisterProjection<OrderAnalyticsProjection>(p => { // Su..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "old-v1.2.0/lakehouse-streaming",
    "title": "Lakehouse Streaming",
    "category": "Roadmap",
    "url": "/docs/old-v1.2.0/lakehouse-streaming",
    "chunks": [
      {
        "id": "old-v1.2.0/lakehouse-streaming-chunk-0",
        "text": "Lakehouse Streaming\n⚠️ FUTURE FEATURE - NOT YET RELEASED\nThis documentation describes lakehouse streaming support planned for v1 2 0 This feature is not available in the current release Status: Planned\nTarget Version: 1 2 0\n---\nOverview\nWhizbang will provide first-class integration with data lakehouses (Delta Lake, Apache Iceberg, Apache Hudi), enabling real-time streaming of events for analytics, ML, and business intelligence Why Lakehouse Streaming Event Store as Operational Database\nThe event store is optimized for transactional workloads (fast writes, point queries):\nWrite new events\nLoad aggregate streams\nSupport projections\nLakehouse as Analytical Database\nLakehouses are optimized for analytical workloads (complex queries, aggregations):\nAd-hoc SQL queries across all events\nTime-series analytics\nMachine learning feature extraction\nBusiness intelligence dashboards\nStream events from Whizbang → Lakehouse for the best of both worlds Supported Lakehouses\nDelta Lake (Databricks, Azure Synapse, AWS EMR)\nApache Iceberg (Snowflake, AWS Athena, Google BigQuery)\nApache Hudi (AWS EMR, Google Dataproc)\nParquet files (S3, Azure Data Lake, Google Cloud Storage)\nConfiguration\nDelta Lake Streaming\n`csharp{\ntitle: \"Delta Lake Streaming Configuration\"\ndescription: \"Stream events to Delta Lake\"\nframework: \"NET8\"\ncategory: \"Analytics\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Delta Lake\", \"Streaming\", \"Analytics\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es UsePostgres(connectionString);\n        // Stream events to Delta Lake\n        es StreamToLakehouse(lake => {\n            lake UseDeltaLake(delta => {\n                delta StoragePath = \"s3://my-data-lake/whizbang/events\";\n                delta PartitionBy = \"event_date\";  // Partition by date for performance\n                delta MergeSchema = true;          // Handle schema evolution\n            });\n            // Stream continuously\n            lake StreamingMode = StreamingMode Continuous;\n            // Batch events for efficiency\n            lake BatchSize = 1000;\n            lake FlushInterval = TimeSpan",
        "startIndex": 0,
        "preview": "Lakehouse Streaming\n⚠️ FUTURE FEATURE - NOT YET RELEASED\nThis documentation describes lakehouse streaming support planned for v1 2 0 This feature is n..."
      },
      {
        "id": "old-v1.2.0/lakehouse-streaming-chunk-1",
        "text": "=> { lake UseDeltaLake(delta => { delta StoragePath = \"s3://my-data-lake/whizbang/events\"; delta PartitionBy = \"event_date\"; // Partition by date for performance delta MergeSchema = true; // Handle schema evolution }); // Stream continuously lake StreamingMode = StreamingMode Continuous; // Batch events for efficiency lake BatchSize = 1000; lake FlushInterval = TimeSpan FromSeconds(30);\n        });\n    });\n});\n`\nWhat happens:\nEvents written to Postgres event store\nBackground worker batches events\nEvents written to Delta Lake as Parquet files\nPartitioned by date for efficient queries\nSchema automatically detected and evolved\nApache Iceberg Streaming\n`csharp{\ntitle: \"Apache Iceberg Streaming Configuration\"\ndescription: \"Stream events to Apache Iceberg\"\nframework: \"NET8\"\ncategory: \"Analytics\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Iceberg\", \"Streaming\", \"Analytics\"]\nnugetPackages: [\"Whizbang EventSourcing\", \"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es StreamToLakehouse(lake => {\n            lake UseIceberg(iceberg => {\n                iceberg Catalog = \"glue\";  // AWS Glue catalog\n                iceberg Database = \"whizbang\";\n                iceberg TableName = \"events\";\n                iceberg WarehousePath = \"s3://my-warehouse/whizbang\";\n            });\n        });\n    });\n});\n`\nEvent Filtering\nStream only specific events to lakehouse:\n`csharp{\ntitle: \"Event Filtering for Lakehouse\"\ndescription: \"Stream only specific events\"\nframework: \"NET8\"\ncategory: \"Analytics\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Filtering\", \"Streaming\", \"Analytics\"]\nnugetPackages: [\"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es StreamToLakehouse(lake => {\n            lake UseDeltaLake(delta => { / / });\n            // Stream only certain event types\n            lake IncludeEvents(\n                typeof(OrderPlaced),\n                typeof(OrderShipped),\n                typeof(PaymentProcessed)\n            );\n            // Exclude sensitive events\n            lake ExcludeEvents(typeof(PaymentMethodUpdated));\n            // Custom filter\n            lake Filter = @event => {\n                // Don't stream test tenant data\n                return @event Metadata TenantId",
        "startIndex": 2349,
        "preview": "=> { lake UseDeltaLake(delta => { delta StoragePath = \"s3://my-data-lake/whizbang/events\"; delta PartitionBy = \"event_date\"; // Partition by date for ..."
      },
      {
        "id": "old-v1.2.0/lakehouse-streaming-chunk-2",
        "text": "=> { es StreamToLakehouse(lake => { lake UseDeltaLake(delta => { / / }); // Stream only certain event types lake IncludeEvents( typeof(OrderPlaced), typeof(OrderShipped), typeof(PaymentProcessed) ); // Exclude sensitive events lake ExcludeEvents(typeof(PaymentMethodUpdated)); // Custom filter lake Filter = @event => { // Don't stream test tenant data return @event Metadata TenantId StartsWith(\"test-\");\n            };\n        });\n    });\n});\n`\nEvent Schema Mapping\nMap events to lakehouse schema:\n`csharp{\ntitle: \"Event Schema Mapping\"\ndescription: \"Map events to lakehouse table schema\"\nframework: \"NET8\"\ncategory: \"Analytics\"\ndifficulty: \"ADVANCED\"\ntags: [\"Schema\", \"Mapping\", \"Analytics\"]\nnugetPackages: [\"Whizbang Lakehouse\"]\nusingStatements: [\"System\", \"Whizbang Lakehouse\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang Lakehouse;\npublic class OrderPlacedEventMapper : IEventMapper<OrderPlaced> {\n    public LakehouseRow Map(OrderPlaced @event) {\n        return new LakehouseRow {\n            // Standard fields\n            [\"event_id\"] = @event EventId,\n            [\"event_type\"] = \"OrderPlaced\",\n            [\"event_timestamp\"] = @event Timestamp,\n            [\"aggregate_id\"] = @event OrderId,\n            [\"tenant_id\"] = @event TenantId,\n            // Event-specific fields\n            [\"customer_id\"] = @event CustomerId,\n            [\"order_total\"] = @event Total,\n            [\"order_status\"] = \"Placed\",\n            [\"item_count\"] = @event Items Count,\n            // Denormalized for analytics\n            [\"year\"] = @event PlacedAt Year,\n            [\"month\"] = @event PlacedAt Month,\n            [\"day\"] = @event PlacedAt Day,\n            [\"hour\"] = @event PlacedAt Hour\n        };\n    }\n}\n`\nQuerying Lakehouse Data\nSQL Queries (Delta Lake)\nOnce events are in the lakehouse, query with SQL:\n`sql\n-- Total orders by day\nSELECT\n    event_date,\n    COUNT(*) as order_count,\n    SUM(order_total) as total_revenue\nFROM whizbang events\nWHERE event_type = 'OrderPlaced'\nGROUP BY event_date\nORDER BY event_date DESC;\n-- Customer lifetime value\nSELECT\n    customer_id,\n    COUNT(DISTINCT aggregate_id) as total_orders,\n    SUM(order_total) as lifetime_value\nFROM whizbang events\nWHERE event_type = 'OrderPlaced'\nGROUP BY customer_id\nORDER BY lifetime_value DESC\nLIMIT 100;\n-- Hourly order trends\nSELECT\n    DATE_TRUNC('hour', event_timestamp) as hour,\n    COUNT(*) as order_count\nFROM whizbang",
        "startIndex": 4595,
        "preview": "=> { es StreamToLakehouse(lake => { lake UseDeltaLake(delta => { / / }); // Stream only certain event types lake IncludeEvents( typeof(OrderPlaced), t..."
      },
      {
        "id": "old-v1.2.0/lakehouse-streaming-chunk-3",
        "text": "GROUP BY event_date ORDER BY event_date DESC; -- Customer lifetime value SELECT customer_id, COUNT(DISTINCT aggregate_id) as total_orders, SUM(order_total) as lifetime_value FROM whizbang events WHERE event_type = 'OrderPlaced' GROUP BY customer_id ORDER BY lifetime_value DESC LIMIT 100; -- Hourly order trends SELECT DATE_TRUNC('hour', event_timestamp) as hour, COUNT(*) as order_count FROM whizbang events\nWHERE event_type = 'OrderPlaced'\n  AND event_date >= CURRENT_DATE - INTERVAL '7 days'\nGROUP BY hour\nORDER BY hour;\n`\nDataFrames (Spark/Databricks)\n`python\nLoad events from Delta Lake\nevents = spark read format(\"delta\") load(\"s3://my-data-lake/whizbang/events\")\nFilter to order events\norders = events filter(events event_type == \"OrderPlaced\")\nAggregate by customer\ncustomer_stats = orders groupBy(\"customer_id\") agg(\n    count(\"*\") alias(\"order_count\"),\n    sum(\"order_total\") alias(\"total_spend\"),\n    avg(\"order_total\") alias(\"avg_order_value\")\n)\nWrite to feature store for ML\ncustomer_stats write format(\"delta\") mode(\"overwrite\") save(\"s3://features/customers\")\n`\nTime Travel Queries\nLakehouse time travel enables querying historical data:\n`sql\n-- Query events as of yesterday\nSELECT * FROM whizbang events TIMESTAMP AS OF '2025-10-17 00:00:00';\n-- Query events from specific version\nSELECT * FROM whizbang events VERSION AS OF 123;\n-- See all changes between versions\nSELECT * FROM whizbang events VERSION AS OF 100\nEXCEPT\nSELECT * FROM whizbang events VERSION AS OF 150;\n`\nSchema Evolution\nLakehouses handle schema changes gracefully:\n`csharp{\ntitle: \"Schema Evolution\"\ndescription: \"Handle evolving event schemas in lakehouse\"\nframework: \"NET8\"\ncategory: \"Analytics\"\ndifficulty: \"ADVANCED\"\ntags: [\"Schema\", \"Evolution\", \"Analytics\"]\nnugetPackages: [\"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es StreamToLakehouse(lake => {\n            lake UseDeltaLake(delta => {\n                // Automatically add new columns when event schema changes\n                delta MergeSchema = true;\n                // Or use strict mode (fail on schema mismatch)\n                delta MergeSchema = false;\n                delta OnSchemaMismatch = SchemaMismatchPolicy",
        "startIndex": 6624,
        "preview": "GROUP BY event_date ORDER BY event_date DESC; -- Customer lifetime value SELECT customer_id, COUNT(DISTINCT aggregate_id) as total_orders, SUM(order_t..."
      },
      {
        "id": "old-v1.2.0/lakehouse-streaming-chunk-4",
        "text": "using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseEventSourcing(es => { es StreamToLakehouse(lake => { lake UseDeltaLake(delta => { // Automatically add new columns when event schema changes delta MergeSchema = true; // Or use strict mode (fail on schema mismatch) delta MergeSchema = false; delta OnSchemaMismatch = SchemaMismatchPolicy Fail;\n            });\n        });\n    });\n});\n`\nExample:\n`csharp\n// V1 event\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, decimal Total);\n// V2 event (added field)\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, decimal Total, string Currency);\n`\nWith MergeSchema = true:\nOld events have Currency = null\nNew events have all fields\nNo data migration needed\nPerformance Optimization\nPartitioning Strategy\n`csharp{\ntitle: \"Lakehouse Partitioning\"\ndescription: \"Optimize queries with partitioning\"\nframework: \"NET8\"\ncategory: \"Performance\"\ndifficulty: \"ADVANCED\"\ntags: [\"Partitioning\", \"Performance\", \"Analytics\"]\nnugetPackages: [\"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es StreamToLakehouse(lake => {\n            lake UseDeltaLake(delta => {\n                // Partition by date and tenant for fast queries\n                delta PartitionBy = new[] { \"event_date\", \"tenant_id\" };\n                // Z-order for co-located data\n                delta ZOrderBy = new[] { \"customer_id\", \"event_type\" };\n                // Optimize file sizes\n                delta TargetFileSize = 128  1024  1024;  // 128 MB\n            });\n        });\n    });\n});\n`\nQuery optimization:\n`sql\n-- Fast (partition pruning)\nSELECT * FROM events\nWHERE event_date = '2025-10-18'\n  AND tenant_id = 'acme-corp';\n-- Slow (full table scan)\nSELECT * FROM events\nWHERE customer_id = '12345';\n`\nCompaction\nPeriodically compact small files:\n`csharp{\ntitle: \"Lakehouse Compaction\"\ndescription: \"Compact small files for better performance\"\nframework: \"NET8\"\ncategory: \"Performance\"\ndifficulty: \"ADVANCED\"\ntags: [\"Compaction\", \"Performance\", \"Analytics\"]\nnugetPackages: [\"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"]\nshowLineNumbers: true\n}\nusing System;\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es StreamToLakehouse(lake => {\n            lake",
        "startIndex": 8608,
        "preview": "using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseEventSourcing(es => { es StreamToLakehouse(lake => { lake..."
      },
      {
        "id": "old-v1.2.0/lakehouse-streaming-chunk-5",
        "text": "description: \"Compact small files for better performance\" framework: \"NET8\" category: \"Performance\" difficulty: \"ADVANCED\" tags: [\"Compaction\", \"Performance\", \"Analytics\"] nugetPackages: [\"Whizbang Lakehouse\"] usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\", \"System\"] showLineNumbers: true } using System; using Whizbang; using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseEventSourcing(es => { es StreamToLakehouse(lake => { lake UseDeltaLake(delta => {\n                // Auto-compact small files\n                delta AutoCompact = true;\n                delta CompactInterval = TimeSpan FromHours(6);\n                delta TargetFileSize = 128  1024  1024;  // 128 MB\n            });\n        });\n    });\n});\n`\nIntegration with BI Tools\nDatabricks\nEvents in Delta Lake are queryable from Databricks notebooks:\n`python\nConnect to lakehouse\nevents = spark read format(\"delta\") load(\"s3://my-data-lake/whizbang/events\")\nCreate temp view for SQL\nevents createOrReplaceTempView(\"events\")\nQuery with Spark SQL\nresults = spark sql(\"\"\"\n    SELECT event_date, COUNT(*) as event_count\n    FROM events\n    GROUP BY event_date\n    ORDER BY event_date DESC\n\"\"\")\nVisualize in notebook\ndisplay(results)\n`\nPower BI / Tableau\nConnect via ODBC/JDBC:\n`plaintext\nConnection: Delta Lake (S3)\nPath: s3://my-data-lake/whizbang/events\nTable: events\n`\ndbt (Data Build Tool)\nCreate analytics models from events:\n`sql\n-- models/orders_daily sql\n{{ config(materialized='table') }}\nSELECT\n    DATE(event_timestamp) as date,\n    COUNT(DISTINCT aggregate_id) as order_count,\n    SUM(order_total) as revenue,\n    AVG(order_total) as avg_order_value\nFROM {{ source('whizbang', 'events') }}\nWHERE event_type = 'OrderPlaced'\nGROUP BY date\n`\nStreaming Guarantees\nAt-Least-Once Delivery\nEvents are guaranteed to be delivered to the lakehouse at least once:\nIdempotent writes (duplicate events filtered by event_id)\nCheckpointing for crash recovery\nTransactional writes to lakehouse\nExactly-Once Semantics\nFor critical analytics, enable exactly-once:\n`csharp{\ntitle: \"Exactly-Once Lakehouse Streaming\"\ndescription: \"Ensure no duplicate events in lakehouse\"\nframework: \"NET8\"\ncategory: \"Reliability\"\ndifficulty: \"ADVANCED\"\ntags: [\"Exactly-Once\", \"Reliability\", \"Streaming\"]\nnugetPackages: [\"Whizbang Lakehouse\"]\nusingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"]\nshowLineNumbers: true\n}\nusing Whizbang;\nusing Microsoft Extensions DependencyInjection;\nservices AddWhizbang(options => {\n    options UseEventSourcing(es => {\n        es StreamToLakehouse(lake => {\n            lake UseDeltaLake(delta => { / / });\n            // Exactly-once semantics\n            lake",
        "startIndex": 10817,
        "preview": "description: \"Compact small files for better performance\" framework: \"NET8\" category: \"Performance\" difficulty: \"ADVANCED\" tags: [\"Compaction\", \"Perfo..."
      },
      {
        "id": "old-v1.2.0/lakehouse-streaming-chunk-6",
        "text": "framework: \"NET8\" category: \"Reliability\" difficulty: \"ADVANCED\" tags: [\"Exactly-Once\", \"Reliability\", \"Streaming\"] nugetPackages: [\"Whizbang Lakehouse\"] usingStatements: [\"Whizbang\", \"Microsoft Extensions DependencyInjection\"] showLineNumbers: true } using Whizbang; using Microsoft Extensions DependencyInjection; services AddWhizbang(options => { options UseEventSourcing(es => { es StreamToLakehouse(lake => { lake UseDeltaLake(delta => { / / }); // Exactly-once semantics lake DeliveryGuarantee = DeliveryGuarantee ExactlyOnce;\n            // Deduplication by event ID\n            lake DeduplicateBy = \"event_id\";\n        });\n    });\n});\n`\nNext Steps\nBackups and Snapshots - Backup strategies\nObservability - Monitor streaming health\nAnalytics - Query patterns and examples\nFeedback Welcome\nWhat analytics use cases do you have for event data Share your thoughts",
        "startIndex": 13041,
        "preview": "framework: \"NET8\" category: \"Reliability\" difficulty: \"ADVANCED\" tags: [\"Exactly-Once\", \"Reliability\", \"Streaming\"] nugetPackages: [\"Whizbang Lakehous..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "proposals/_folder",
    "title": "proposals/_folder",
    "category": "General",
    "url": "/docs/proposals/_folder",
    "chunks": [
      {
        "id": "proposals/_folder-chunk-0",
        "text": "Proposed Features\nThis section contains documentation for features that have been proposed but not yet approved for development. These represent ideas and concepts being evaluated for future releases.\nGuidelines\nFeatures under consideration\nNot yet approved for development\nSubject to approval process\nMay be modified or rejected",
        "startIndex": 0,
        "preview": "Proposed Features\nThis section contains documentation for features that have been proposed but not yet approved for development. These represent ideas..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "proposals/advanced-features",
    "title": "Advanced Features",
    "category": "Architecture & Design",
    "url": "/docs/proposals/advanced-features",
    "chunks": [
      {
        "id": "proposals/advanced-features-chunk-0",
        "text": "Advanced Features\nWhizbang includes advanced features for enterprise scenarios, including cross-aggregate transactions, performance monitoring, Kubernetes operators, and debugging tools Cross-Aggregate Transactions\nUnit of Work Pattern\nCoordinate transactions across multiple aggregates while maintaining consistency:\n`csharp{title=\"Unit of Work Configuration\" description=\"Unit of work pattern configuration for cross-aggregate transactions\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Advanced-Features\", \"Unit-of-Work\", \"Cross-Aggregate-Transactions\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options UseUnitOfWork(uow => {\n        uow IsolationLevel = IsolationLevel ReadCommitted;\n        uow Timeout = TimeSpan FromSeconds(30);\n        uow EnableDistributedTransactions = true;\n    });\n});\n`csharp{title=\"Multi-Aggregate Command Handler\" description=\"Command handler using unit of work for coordinated multi-aggregate operations\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Advanced-Features\", \"Unit-of-Work\", \"Command-Handlers\"] framework=\"NET8\"}\n// Usage in handlers\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder> {\n    private readonly IUnitOfWork _unitOfWork;\n    private readonly IRepository<Order> _orderRepository;\n    private readonly IRepository<Customer> _customerRepository;\n    private readonly IRepository<Product> _productRepository;\n    public async Task<OrderPlaced> Handle(PlaceOrder command) {\n        return await _unitOfWork ExecuteAsync(async () => {\n            // Load multiple aggregates\n            var customer = await _customerRepository Load(command CustomerId);\n            var products = await _productRepository LoadMany(command ProductIds);\n            // Validate business rules across aggregates\n            if ( customer CanPlaceOrder(command Total)) {\n                throw new DomainException(\"Customer credit limit exceeded\");\n            }\n            foreach (var product in products) {\n                if ( product IsAvailable(command GetQuantity(product Id))) {\n                    throw new DomainException($\"Product {product Id} not available\");\n                }\n            }\n            // Create new aggregate\n            var order = new Order(command CustomerId, command Items);\n            // Update existing aggregates\n            customer ReserveCreditLimit(command Total);\n            foreach (var product in products) {\n                product ReserveStock(command GetQuantity(product Id));\n            }\n            // Save all changes in single transaction\n            await _orderRepository Save(order);\n            await _customerRepository Save(customer);\n            await _productRepository SaveMany(products);\n            return new OrderPlaced(order Id, command CustomerId, DateTimeOffset UtcNow);\n        });\n    }\n}\n`\nDistributed Transactions with Saga Fallback\n`csharp{title=\"Distributed Transactions with Saga Fallback\" description=\"Distributed transactions with saga fallback for complex operations\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Advanced-Features\", \"Cross-Aggregate-Transactions\", \"Saga-Fallback\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options CrossAggregateTransactions(transactions => {\n        transactions DefaultStrategy = TransactionStrategy UnitOfWork;\n        transactions FallbackToSaga = true;\n        transactions",
        "startIndex": 0,
        "preview": "Advanced Features\nWhizbang includes advanced features for enterprise scenarios, including cross-aggregate transactions, performance monitoring, Kubern..."
      },
      {
        "id": "proposals/advanced-features-chunk-1",
        "text": "CustomerId, DateTimeOffset UtcNow); }); } } ` Distributed Transactions with Saga Fallback `csharp{title=\"Distributed Transactions with Saga Fallback\" description=\"Distributed transactions with saga fallback for complex operations\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Advanced-Features\", \"Cross-Aggregate-Transactions\", \"Saga-Fallback\"] framework=\"NET8\"} services AddWhizbang(options => { options CrossAggregateTransactions(transactions => { transactions DefaultStrategy = TransactionStrategy UnitOfWork; transactions FallbackToSaga = true; transactions SagaTimeoutMs = 30000;\n        // Configure per-operation\n        transactions ForOperation<PlaceOrder>(op => {\n            op Strategy = TransactionStrategy UnitOfWork;\n            op MaxAggregatesInTransaction = 5;\n        });\n        transactions ForOperation<ComplexOrderWorkflow>(op => {\n            op Strategy = TransactionStrategy Saga; // Force saga for complex operations\n        });\n    });\n});\n`\nTransaction Boundaries\n`csharp{title=\"Transaction Boundary Implementation\" description=\"Transaction boundary implementation with automatic rollback on failure\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Advanced-Features\", \"Transaction-Boundaries\", \"Error-Handling\"] framework=\"NET8\"}\npublic class TransactionBoundary : ITransactionBoundary {\n    public async Task<T> ExecuteInTransaction<T>(Func<Task<T>> operation) {\n        using var scope = new TransactionScope(TransactionScopeAsyncFlowOption Enabled);\n        try {\n            var result = await operation();\n            scope Complete();\n            return result;\n        } catch (Exception ex) {\n            // Transaction automatically rolled back\n            _logger LogError(ex, \"Transaction failed and was rolled back\");\n            throw;\n        }\n    }\n}\n`\nPerformance Budgets & Monitoring\n> 📋 Detailed Coverage: For comprehensive performance budgets, observability, and monitoring details, see Observability & Metrics\nPerformance Budget Overview\nPerformance budgets provide automatic tracking and alerting for handler performance:\n`csharp{title=\"Performance Budget Attributes\" description=\"Performance budget attributes for automatic tracking and alerting\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Advanced-Features\", \"Performance-Budgets\", \"Monitoring\"] framework=\"NET8\"}\n[PerformanceBudget(MaxLatencyMs = 100)]\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder> {\n    // Automatic budget tracking and violation alerts\n}\n`\nOpenTelemetry Integration\n> 📋 Detailed Coverage: For complete OpenTelemetry setup, metrics, and distributed tracing, see Observability & Metrics\n`csharp{title=\"OpenTelemetry Integration Configuration\" description=\"OpenTelemetry integration configuration for comprehensive observability\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Advanced-Features\", \"OpenTelemetry\", \"Observability\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options Observability(observability => {\n        observability UseOpenTelemetry(otel => {\n            otel TraceAllCommands = true;\n            otel TraceAllEvents = true;\n            otel TraceProjections = true;\n            otel TraceSagas = true;\n            // Custom metrics\n            otel",
        "startIndex": 3401,
        "preview": "CustomerId, DateTimeOffset UtcNow); }); } } ` Distributed Transactions with Saga Fallback `csharp{title=\"Distributed Transactions with Saga Fallback\" ..."
      },
      {
        "id": "proposals/advanced-features-chunk-2",
        "text": "& Metrics `csharp{title=\"OpenTelemetry Integration Configuration\" description=\"OpenTelemetry integration configuration for comprehensive observability\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Advanced-Features\", \"OpenTelemetry\", \"Observability\"] framework=\"NET8\"} services AddWhizbang(options => { options Observability(observability => { observability UseOpenTelemetry(otel => { otel TraceAllCommands = true; otel TraceAllEvents = true; otel TraceProjections = true; otel TraceSagas = true; // Custom metrics otel EmitCustomMetrics = true;\n            otel MetricsPrefix = \"whizbang\";\n            // Performance budget violations\n            otel TracePerformanceBudgetViolations = true;\n            otel AlertOnBudgetViolation = true;\n        });\n    });\n});\n`csharp{title=\"Custom Performance Tracking Handler\" description=\"Custom performance tracking handler with detailed metrics collection\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Advanced-Features\", \"Performance-Tracking\", \"Custom-Metrics\"] framework=\"NET8\"}\n// Custom performance tracking\npublic class PerformanceTrackingHandler<T> : ICommandHandler<T> where T : ICommand {\n    private readonly ICommandHandler<T> _innerHandler;\n    private readonly IMetrics _metrics;\n    public async Task Handle(T command) {\n        using var activity = Activity StartActivity($\"Command {typeof(T) Name}\");\n        using var timer = _metrics StartTimer($\"command {typeof(T) Name ToLower()} duration\");\n        var startMemory = GC GetTotalMemory(false);\n        var stopwatch = Stopwatch StartNew();\n        try {\n            await _innerHandler Handle(command);\n            // Record success metrics\n            _metrics IncrementCounter($\"command {typeof(T) Name ToLower()} success\");\n        } catch (Exception ex) {\n            // Record failure metrics\n            _metrics IncrementCounter($\"command {typeof(T) Name ToLower()} failure\", \n                new[] { (\"error_type\", ex GetType() Name) });\n            activity SetStatus(ActivityStatusCode Error, ex Message);\n            throw;\n        } finally {\n            stopwatch Stop();\n            var endMemory = GC GetTotalMemory(false);\n            // Record performance metrics\n            activity SetTag(\"duration_ms\", stopwatch ElapsedMilliseconds);\n            activity SetTag(\"memory_allocated_bytes\", endMemory - startMemory);\n            _metrics RecordValue($\"command {typeof(T) Name ToLower()} memory\", endMemory - startMemory);\n        }\n    }\n}\n`\nKubernetes Operator Features\n> 📋 Detailed Coverage: For production deployment patterns, health checks, and operational best practices, see Deployment & Operations\nAuto-Scaling Projection Workers\n`yaml\n---\ncategory: Design\ndifficulty: ADVANCED\ntags: [Design, Advanced-Features, Kubernetes-Operator, Auto-Scaling]\ndescription: Kubernetes custom resource for auto-scaling projection workers\n---\napiVersion: whizbang",
        "startIndex": 6106,
        "preview": "& Metrics `csharp{title=\"OpenTelemetry Integration Configuration\" description=\"OpenTelemetry integration configuration for comprehensive observability..."
      },
      {
        "id": "proposals/advanced-features-chunk-3",
        "text": "} } } ` Kubernetes Operator Features > 📋 Detailed Coverage: For production deployment patterns, health checks, and operational best practices, see Deployment & Operations Auto-Scaling Projection Workers `yaml --- category: Design difficulty: ADVANCED tags: [Design, Advanced-Features, Kubernetes-Operator, Auto-Scaling] description: Kubernetes custom resource for auto-scaling projection workers --- apiVersion: whizbang io/v1\nkind: ProjectionWorker\nmetadata:\n  name: order-summary-projection\nspec:\n  projectionName: order-summary\n  scaling:\n    strategy: lag-based\n    minReplicas: 2\n    maxReplicas: 10\n    lagThresholdSeconds: 30\n    scaleUpCooldownMs: 300000   5 minutes\n    scaleDownCooldownMs: 600000 10 minutes\n  partitioning:\n    enabled: true\n    partitionCount: 8\n    partitionBy: \"streamId\"\n  resources:\n    requests:\n      cpu: 100m\n      memory: 128Mi\n    limits:\n      cpu: 500m\n      memory: 512Mi\n`\nPartition-Aware Pod Placement\n`yaml\n---\ncategory: Design\ndifficulty: ADVANCED\ntags: [Design, Advanced-Features, Kubernetes-Operator, Partition-Aware-Placement]\ndescription: Partition-aware pod placement for distributed projection processing\n---\napiVersion: whizbang io/v1\nkind: PartitionedProjection\nmetadata:\n  name: analytics-projection\nspec:\n  projectionName: analytics\n  partitions:\nid: 0\n    nodeSelector:\n      whizbang io/partition-group: \"group-a\"\nid: 1\n    nodeSelector:\n      whizbang io/partition-group: \"group-a\"\nid: 2\n    nodeSelector:\n      whizbang io/partition-group: \"group-b\"\nid: 3\n    nodeSelector:\n      whizbang io/partition-group: \"group-b\"\n  antiAffinity:\n    enabled: true\n    topologyKey: kubernetes io/hostname\n`\nBlue/Green Projection Deployments\n`yaml\n---\ncategory: Design\ndifficulty: ADVANCED\ntags: [Design, Advanced-Features, Kubernetes-Operator, Blue-Green-Deployment]\ndescription: Blue/green projection deployments with validation and automatic switchover\n---\napiVersion: whizbang io/v1\nkind: ProjectionDeployment\nmetadata:\n  name: order-summary-deployment\nspec:\n  strategy: blue-green\n  validation:\n    samplingRate: 0 1          Validate 10% of data\n    accuracyThreshold: 0 99    99% accuracy required\n    validationTimeoutMinutes: 30\n  switchover:\n    automatic: false           Manual approval required\n    trafficSplitDurationMinutes: 10\n  cleanup:\n    retainBlueVersionHours: 24 Keep blue for 24 hours after switchover\n`\nAutomatic Backfilling\n`yaml\n---\ncategory: Design\ndifficulty: ADVANCED\ntags: [Design, Advanced-Features, Kubernetes-Operator, Automatic-Backfilling]\ndescription: Kubernetes job for automatic projection backfilling with resource management\n---\napiVersion: whizbang",
        "startIndex": 8490,
        "preview": "} } } ` Kubernetes Operator Features > 📋 Detailed Coverage: For production deployment patterns, health checks, and operational best practices, see De..."
      },
      {
        "id": "proposals/advanced-features-chunk-4",
        "text": "99% accuracy required validationTimeoutMinutes: 30 switchover: automatic: false Manual approval required trafficSplitDurationMinutes: 10 cleanup: retainBlueVersionHours: 24 Keep blue for 24 hours after switchover ` Automatic Backfilling `yaml --- category: Design difficulty: ADVANCED tags: [Design, Advanced-Features, Kubernetes-Operator, Automatic-Backfilling] description: Kubernetes job for automatic projection backfilling with resource management --- apiVersion: whizbang io/v1\nkind: BackfillJob\nmetadata:\n  name: customer-analytics-backfill\nspec:\n  projectionName: customer-analytics\n  trigger: deployment-update  Trigger on projection deployment\n  source:\n    fromDate: \"2024-01-01T00:00:00Z\"\n    toDate: null              Current time\n  execution:\n    batchSize: 1000\n    parallelism: 4\n    maxRetries: 3\n  resources:\n    requests:\n      cpu: 200m\n      memory: 256Mi\n    limits:\n      cpu: 1000m\n      memory: 1Gi\n`\nKubernetes Operator Implementation\n`csharp{title=\"Kubernetes Operator Implementation\" description=\"Kubernetes operator implementation for Whizbang resource management\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Advanced-Features\", \"Kubernetes-Operator\", \"Implementation\"] framework=\"NET8\"}\npublic class WhizbangOperator : IHostedService {\n    private readonly IKubernetesClient _kubernetesClient;\n    private readonly IProjectionManager _projectionManager;\n    public async Task StartAsync(CancellationToken cancellationToken) {\n        // Watch for ProjectionWorker resources\n        await _kubernetesClient WatchAsync<ProjectionWorker>(\n            onEvent: async (eventType, resource) => {\n                switch (eventType) {\n                    case WatchEventType Added:\n                        await CreateProjectionWorker(resource);\n                        break;\n                    case WatchEventType Modified:\n                        await UpdateProjectionWorker(resource);\n                        break;\n                    case WatchEventType Deleted:\n                        await DeleteProjectionWorker(resource);\n                        break;\n                }\n            },\n            cancellationToken: cancellationToken\n        );\n        // Monitor projection lag and auto-scale\n        _ = Task Run(() => MonitorAndScale(cancellationToken), cancellationToken);\n    }\n    private async Task MonitorAndScale(CancellationToken cancellationToken) {\n        while ( cancellationToken IsCancellationRequested) {\n            var projections = await _projectionManager GetAllProjections();\n            foreach (var projection in projections) {\n                var lag = await _projectionManager GetLag(projection Name);\n                var workerSpec = await GetProjectionWorkerSpec(projection Name);\n                if (ShouldScaleUp(lag, workerSpec)) {\n                    await ScaleUpProjectionWorker(projection Name, workerSpec);\n                } else if (ShouldScaleDown(lag, workerSpec)) {\n                    await ScaleDownProjectionWorker(projection Name, workerSpec);\n                }\n            }\n            await Task Delay(TimeSpan",
        "startIndex": 10706,
        "preview": "99% accuracy required validationTimeoutMinutes: 30 switchover: automatic: false Manual approval required trafficSplitDurationMinutes: 10 cleanup: reta..."
      },
      {
        "id": "proposals/advanced-features-chunk-5",
        "text": "IsCancellationRequested) { var projections = await _projectionManager GetAllProjections(); foreach (var projection in projections) { var lag = await _projectionManager GetLag(projection Name); var workerSpec = await GetProjectionWorkerSpec(projection Name); if (ShouldScaleUp(lag, workerSpec)) { await ScaleUpProjectionWorker(projection Name, workerSpec); } else if (ShouldScaleDown(lag, workerSpec)) { await ScaleDownProjectionWorker(projection Name, workerSpec); } } await Task Delay(TimeSpan FromSeconds(30), cancellationToken);\n        }\n    }\n}\n`\nDebugging and Development Tools\n> 📋 Detailed Coverage: For comprehensive testing framework, development tools, CLI, and IDE integration, see Testing & Development Tools and Source Generation & IDE Integration\nOpenTelemetry Journey Visualization\nCapture and visualize message journeys for debugging:\n`csharp{title=\"Message Journey Debugging Configuration\" description=\"Debugging configuration for message journey capture and visualization\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Advanced-Features\", \"Debugging\", \"Message-Journeys\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options Debugging(debugging => {\n        debugging CaptureMessageJourneys = true;\n        debugging JourneyRetentionDays = 7;\n        debugging EnableBreakpoints = true;\n        debugging EnableStateInspection = true;\n    });\n});\n`csharp{title=\"Message Journey Tracking Interceptor\" description=\"Message journey tracking interceptor for debugging and visualization\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Advanced-Features\", \"Debugging\", \"Journey-Tracking\"] framework=\"NET8\"}\n// Message journey tracking\npublic class MessageJourneyTracker : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message, \n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        var journeyId = context CorrelationId Guid NewGuid() ToString();\n        using var activity = Activity StartActivity(\"MessageJourney\");\n        activity SetTag(\"journey_id\", journeyId);\n        activity SetTag(\"message_type\", typeof(TRequest) Name);\n        activity SetTag(\"handler_type\", context HandlerType Name);\n        var stopwatch = Stopwatch StartNew();\n        try {\n            var response = await next(message, context);\n            await _journeyStore RecordStep(new JourneyStep {\n                JourneyId = journeyId,\n                MessageType = typeof(TRequest) Name,\n                HandlerType = context HandlerType Name,\n                Duration = stopwatch Elapsed,\n                Status = \"Success\",\n                Input = JsonSerializer Serialize(message),\n                Output = JsonSerializer Serialize(response)\n            });\n            return response;\n        } catch (Exception ex) {\n            await _journeyStore RecordStep(new JourneyStep {\n                JourneyId = journeyId,\n                MessageType = typeof(TRequest) Name,\n                HandlerType = context HandlerType Name,\n                Duration = stopwatch Elapsed,\n                Status = \"Failed\",\n                Error = ex ToString(),\n                Input = JsonSerializer",
        "startIndex": 13335,
        "preview": "IsCancellationRequested) { var projections = await _projectionManager GetAllProjections(); foreach (var projection in projections) { var lag = await _..."
      },
      {
        "id": "proposals/advanced-features-chunk-6",
        "text": "Status = \"Success\", Input = JsonSerializer Serialize(message), Output = JsonSerializer Serialize(response) }); return response; } catch (Exception ex) { await _journeyStore RecordStep(new JourneyStep { JourneyId = journeyId, MessageType = typeof(TRequest) Name, HandlerType = context HandlerType Name, Duration = stopwatch Elapsed, Status = \"Failed\", Error = ex ToString(), Input = JsonSerializer Serialize(message)\n            });\n            throw;\n        }\n    }\n}\n`\nReplay and Simulation\nReplay events for debugging and testing:\n`csharp{title=\"Event Replay Service Interface\" description=\"Event replay service interface for debugging and testing scenarios\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Advanced-Features\", \"Event-Replay\", \"Simulation\"] framework=\"NET8\"}\npublic interface IEventReplayService {\n    Task<ReplayResult> ReplayEvents(ReplayOptions options);\n    Task<SimulationResult> SimulateEventStream(SimulationOptions options);\n    IAsyncEnumerable<ReplayProgress> GetReplayProgress(string replayId);\n}\npublic class EventReplayService : IEventReplayService {\n    public async Task<ReplayResult> ReplayEvents(ReplayOptions options) {\n        var replayId = Guid NewGuid() ToString();\n        // Create isolated replay environment\n        var replayContext = await CreateReplayContext(replayId, options);\n        try {\n            // Load events to replay\n            var events = await LoadEventsForReplay(options);\n            // Replay events in isolated context\n            foreach (var @event in events) {\n                if (options Breakpoints Contains(@event EventNumber) == true) {\n                    await PauseForBreakpoint(@event, replayContext);\n                }\n                await replayContext ProcessEvent(@event);\n                if (options StepByStep) {\n                    await WaitForContinueSignal(replayId);\n                }\n            }\n            return new ReplayResult {\n                ReplayId = replayId,\n                EventsProcessed = events Count(),\n                Status = ReplayStatus Completed\n            };\n        } catch (Exception ex) {\n            return new ReplayResult {\n                ReplayId = replayId,\n                Status = ReplayStatus Failed,\n                Error = ex Message\n            };\n        }\n    }\n}\n`csharp{title=\"Event Replay Usage Example\" description=\"Event replay configuration options and usage example\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Advanced-Features\", \"Event-Replay\", \"Usage-Example\"] framework=\"NET8\"}\n// Usage\nvar replayOptions = new ReplayOptions {\n    FromEventNumber = 1000,\n    ToEventNumber = 2000,\n    StreamFilter = streamId => streamId StartsWith(\"Order-\"),\n    StepByStep = true,\n    Breakpoints = new[] { 1500, 1750 },\n    IsolatedEnvironment = true\n};\nvar result = await _replayService",
        "startIndex": 16074,
        "preview": "Status = \"Success\", Input = JsonSerializer Serialize(message), Output = JsonSerializer Serialize(response) }); return response; } catch (Exception ex)..."
      },
      {
        "id": "proposals/advanced-features-chunk-7",
        "text": "options and usage example\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Advanced-Features\", \"Event-Replay\", \"Usage-Example\"] framework=\"NET8\"} // Usage var replayOptions = new ReplayOptions { FromEventNumber = 1000, ToEventNumber = 2000, StreamFilter = streamId => streamId StartsWith(\"Order-\"), StepByStep = true, Breakpoints = new[] { 1500, 1750 }, IsolatedEnvironment = true }; var result = await _replayService ReplayEvents(replayOptions);\n`\nState Inspection and Breakpoints\nInspect aggregate and projection state during debugging:\n`csharp{title=\"State Inspection Interface\" description=\"State inspection interface for debugging aggregate and projection state\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Advanced-Features\", \"State-Inspection\", \"Debugging\"] framework=\"NET8\"}\npublic interface IStateInspector {\n    Task<AggregateState> InspectAggregate(string streamId, long version = null);\n    Task<ProjectionState> InspectProjection(string projectionName, string documentId);\n    Task<IEnumerable<EventInfo>> GetEventHistory(string streamId);\n    Task SetBreakpoint(string streamId, long eventVersion);\n    Task<BreakpointContext> WaitForBreakpoint(string breakpointId);\n}\n`csharp{title=\"Breakpoint Handler Implementation\" description=\"Breakpoint handler implementation for debugging event processing\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Advanced-Features\", \"Breakpoints\", \"Implementation\"] framework=\"NET8\"}\n// Breakpoint implementation\npublic class BreakpointHandler : IEventHandler<object> {\n    public async Task Handle(object @event, EventContext context) {\n        var breakpoints = await _breakpointStore GetActiveBreakpoints(context StreamId);\n        foreach (var breakpoint in breakpoints) {\n            if (ShouldTriggerBreakpoint(breakpoint, @event, context)) {\n                var breakpointContext = new BreakpointContext {\n                    BreakpointId = breakpoint Id,\n                    Event = @event,\n                    StreamId = context StreamId,\n                    EventVersion = context EventVersion,\n                    AggregateState = await LoadAggregateState(context StreamId, context EventVersion - 1),\n                    Timestamp = DateTimeOffset UtcNow\n                };\n                await _breakpointStore RecordBreakpointHit(breakpointContext);\n                await _notificationService NotifyBreakpointHit(breakpointContext);\n                // Pause execution until developer continues\n                await WaitForContinueSignal(breakpoint Id);\n            }\n        }\n    }\n}\n`\nW3C Trace Context Integration\nDistributed tracing with W3C standards:\n`csharp{title=\"W3C Trace Context Configuration\" description=\"W3C trace context integration configuration for distributed tracing\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Advanced-Features\", \"Distributed-Tracing\", \"W3C-Standards\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options DistributedTracing(tracing => {\n        tracing UseW3CTraceContext = true;\n        tracing PropagateTraceHeaders = true;\n        tracing SampleRate = 0 1; // Sample 10% of traces\n        tracing CustomTags Add(\"service name\", \"whizbang-orders\");\n        tracing CustomTags Add(\"service version\", \"1 2",
        "startIndex": 18526,
        "preview": "options and usage example\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Advanced-Features\", \"Event-Replay\", \"Usage-Example\"] framework..."
      },
      {
        "id": "proposals/advanced-features-chunk-8",
        "text": "context integration configuration for distributed tracing\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Advanced-Features\", \"Distributed-Tracing\", \"W3C-Standards\"] framework=\"NET8\"} services AddWhizbang(options => { options DistributedTracing(tracing => { tracing UseW3CTraceContext = true; tracing PropagateTraceHeaders = true; tracing SampleRate = 0 1; // Sample 10% of traces tracing CustomTags Add(\"service name\", \"whizbang-orders\"); tracing CustomTags Add(\"service version\", \"1 2 3\");\n    });\n});\n`csharp{title=\"W3C Trace Context Propagation\" description=\"Automatic W3C trace context propagation implementation\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Advanced-Features\", \"Trace-Propagation\", \"W3C-Implementation\"] framework=\"NET8\"}\n// Automatic trace propagation\npublic class TraceContextPropagator : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        // Extract W3C trace context from headers\n        var traceParent = context Headers GetValueOrDefault(\"traceparent\");\n        var traceState = context Headers GetValueOrDefault(\"tracestate\");\n        if (traceParent = null) {\n            // Parse W3C trace context\n            var traceContext = W3CTraceContext Parse(traceParent, traceState);\n            // Create child span\n            using var activity = Activity StartActivity($\"Handle{typeof(TRequest) Name}\");\n            activity SetParentId(traceContext TraceId, traceContext SpanId);\n            activity SetTag(\"whizbang correlation_id\", context CorrelationId);\n            activity SetTag(\"whizbang message_type\", typeof(TRequest) Name);\n            // Add custom trace state\n            var newTraceState = $\"whizbang=correlation-id:{context CorrelationId}\";\n            if ( string IsNullOrEmpty(traceState)) {\n                newTraceState = $\"{traceState},{newTraceState}\";\n            }\n            activity SetTag(\"tracestate\", newTraceState);\n            return await next(message, context);\n        }\n        // No parent trace - start new one\n        using var rootActivity = Activity StartActivity($\"Handle{typeof(TRequest) Name}\");\n        return await next(message, context);\n    }\n}\n`\nConfiguration Examples\nComprehensive Advanced Features Setup\n`csharp{title=\"Comprehensive Advanced Features Setup\" description=\"Comprehensive advanced features configuration combining all options\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Advanced-Features\", \"Comprehensive-Setup\", \"Configuration\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    // Cross-aggregate transactions\n    options UseUnitOfWork(uow => {\n        uow IsolationLevel = IsolationLevel ReadCommitted;\n        uow EnableDistributedTransactions = true;\n        uow FallbackToSaga = true;\n    });\n    // Performance budgets\n    options PerformanceBudgets(budgets => {\n        budgets DefaultCommandLatency = TimeSpan FromMilliseconds(500);\n        budgets AlertOnViolation = true;\n        budgets UseOpenTelemetryMetrics = true;\n    });\n    // Observability\n    options Observability(observability => {\n        observability UseOpenTelemetry();\n        observability CaptureMessageJourneys = true;\n        observability EnableDistributedTracing = true;\n    });\n    // Debugging\n    options Debugging(debugging => {\n        debugging",
        "startIndex": 21366,
        "preview": "context integration configuration for distributed tracing\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Advanced-Features\", \"Distribut..."
      },
      {
        "id": "proposals/advanced-features-chunk-9",
        "text": "uow FallbackToSaga = true; }); // Performance budgets options PerformanceBudgets(budgets => { budgets DefaultCommandLatency = TimeSpan FromMilliseconds(500); budgets AlertOnViolation = true; budgets UseOpenTelemetryMetrics = true; }); // Observability options Observability(observability => { observability UseOpenTelemetry(); observability CaptureMessageJourneys = true; observability EnableDistributedTracing = true; }); // Debugging options Debugging(debugging => { debugging EnableBreakpoints = true;\n        debugging EnableStateInspection = true;\n        debugging EnableEventReplay = true;\n        debugging RetainDebugDataDays = 7;\n    });\n    // Kubernetes integration\n    options Kubernetes(k8s => {\n        k8s EnableOperator = true;\n        k8s AutoScaleProjections = true;\n        k8s EnableBlueGreenDeployments = true;\n        k8s",
        "startIndex": 14146,
        "preview": "uow FallbackToSaga = true; }); // Performance budgets options PerformanceBudgets(budgets => { budgets DefaultCommandLatency = TimeSpan FromMillisecond..."
      },
      {
        "id": "proposals/advanced-features-chunk-10",
        "text": "= true; observability EnableDistributedTracing = true; }); // Debugging options Debugging(debugging => { debugging EnableBreakpoints = true; debugging EnableStateInspection = true; debugging EnableEventReplay = true; debugging RetainDebugDataDays = 7; }); // Kubernetes integration options Kubernetes(k8s => { k8s EnableOperator = true; k8s AutoScaleProjections = true; k8s EnableBlueGreenDeployments = true; k8s PartitionAwarePlacement = true;\n    });\n});\n`\nBest Practices\nTransaction Guidelines\nKeep transactions short - Minimize time holding locks\nLimit aggregate count - Avoid transactions with too many aggregates\nUse sagas for long processes - Don't use transactions for workflows\nTest rollback scenarios - Ensure proper cleanup on failure\nMonitor transaction metrics - Track duration and failure rates\nPerformance Monitoring\nSet realistic budgets - Base on actual performance requirements\nMonitor trends - Track performance over time\nAlert on violations - Set up proper alerting for budget violations\nUse sampling - Don't trace every request in production\nCorrelate with business metrics - Connect performance to business impact\nDebugging Best Practices\nUse structured logging - Include correlation IDs and context\nLimit debug data retention - Don't keep debug data indefinitely\nSecure sensitive data - Mask PII in debug traces\nTest replay scenarios - Ensure replay works correctly\nDocument debugging procedures - Help team members debug effectively\n---\nRelated Documentation\nCore Architecture\nEvent Store & Projections - Core storage architecture\nConcurrency Control - Managing concurrent updates\nPolicy Engine - Universal configuration scoping mechanism\nFlags & Tags System - Cross-service context propagation\nImplementation & Operations\nSource Generation & IDE Integration - Development tooling and navigation\nTesting & Development Tools - Testing framework and CLI tools  \nObservability & Metrics - Production monitoring and observability\nDeployment & Operations - Operational patterns and best practices",
        "startIndex": 24675,
        "preview": "= true; observability EnableDistributedTracing = true; }); // Debugging options Debugging(debugging => { debugging EnableBreakpoints = true; debugging..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "proposals/concurrency-control",
    "title": "Concurrency Control",
    "category": "Architecture & Design",
    "url": "/docs/proposals/concurrency-control",
    "chunks": [
      {
        "id": "proposals/concurrency-control-chunk-0",
        "text": "Concurrency Control\nWhizbang provides flexible concurrency control mechanisms to handle concurrent updates to aggregates, supporting multiple strategies that developers can choose globally or per-operation Concurrency Strategies\nA Expected Version (Default)\nStandard event sourcing pattern - explicitly specify the expected version:\n`csharp{title=\"Expected Version Concurrency Control\" description=\"Standard event sourcing pattern with explicit version checking\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"expected-version\", \"optimistic-locking\", \"event-sourcing\"] framework=\"NET8\"}\n// Load aggregate at version 5\nvar order = await repository Load<Order>(orderId);\n// Make changes\norder AddItem(new OrderItem(\"Product\", 10 00m));\n// Save with expected version - will fail if current version = 5\nawait repository Save(order, expectedVersion: 5);\n`\nBenefits:\n✅ Detects all conflicts\n✅ Standard event sourcing pattern\n✅ Explicit and predictable\nDrawbacks:\n❌ Requires version tracking\n❌ Manual conflict resolution\nB Timestamp-Based (Last-Modified)\nHTTP-style semantics using timestamps:\n`csharp{title=\"Timestamp-Based Concurrency Control\" description=\"HTTP-style semantics using last-modified timestamps\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"timestamp-based\", \"http-semantics\", \"last-modified\"] framework=\"NET8\"}\nvar order = await repository Load<Order>(orderId);\nvar lastModified = order LastModified;\n// Make changes\norder AddItem(new OrderItem(\"Product\", 10 00m));\n// Save with timestamp check\nawait repository Save(order, ifNotModifiedSince: lastModified);\n`\nBenefits:\n✅ Familiar HTTP semantics\n✅ No version number tracking\nDrawbacks:\n❌ Clock skew potential\n❌ Less precise than versions\nC Automatic Retry with Conflict Resolution\nSmart retry with configurable resolution strategies:\n`csharp{title=\"Automatic Retry with Conflict Resolution\" description=\"Smart retry with configurable resolution strategies via policies\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"concurrency\", \"automatic-retry\", \"conflict-resolution\", \"policy-engine\"] framework=\"NET8\"}\n// Configure automatic retry via policies\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        // Default strategy for all operations\n        policies When(ctx => true) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy AutomaticRetry)) And(config => config SetRetryAttempts(3)) And(config => config SetRetryDelay(TimeSpan FromMilliseconds(100)));\n        // Custom conflict resolution for Order aggregates\n        policies When(ctx => ctx MatchesAggregate<Order>()) Then(config => config SetConflictResolver((current, attempted) => {\n                    // Custom merge logic\n                    var merged = current Copy();\n                    merged",
        "startIndex": 0,
        "preview": "Concurrency Control\nWhizbang provides flexible concurrency control mechanisms to handle concurrent updates to aggregates, supporting multiple strategi..."
      },
      {
        "id": "proposals/concurrency-control-chunk-1",
        "text": "for all operations policies When(ctx => true) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy AutomaticRetry)) And(config => config SetRetryAttempts(3)) And(config => config SetRetryDelay(TimeSpan FromMilliseconds(100))); // Custom conflict resolution for Order aggregates policies When(ctx => ctx MatchesAggregate<Order>()) Then(config => config SetConflictResolver((current, attempted) => { // Custom merge logic var merged = current Copy(); merged MergeChanges(attempted);\n                    return merged;\n                }));\n    });\n});\n// Save with automatic retry\nawait repository Save(order); // Retries automatically on conflict\n`\nBenefits:\n✅ Handles most conflicts automatically\n✅ Better developer experience\n✅ Configurable retry policies\nDrawbacks:\n❌ Complex to implement\n❌ Not all conflicts can be auto-resolved\nMarten-Inspired Extensions\nDrawing from Marten's concurrency features, Whizbang also supports:\nD Token-Based Concurrency\nUsing opaque tokens instead of version numbers:\n`csharp{title=\"Token-Based Concurrency Control\" description=\"Using opaque tokens instead of version numbers\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"token-based\", \"opaque-tokens\", \"marten-inspired\"] framework=\"NET8\"}\nvar (order, token) = await repository LoadWithToken<Order>(orderId);\n// Make changes\norder AddItem(new OrderItem(\"Product\", 10 00m));\n// Save with token\nawait repository Save(order, concurrencyToken: token);\n`\nE Revision-Based Tracking\nMarten-style revision tracking with metadata:\n`csharp{title=\"Revision-Based Tracking\" description=\"Marten-style revision tracking with automatic metadata\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"revision-based\", \"marten-style\", \"metadata\"] framework=\"NET8\"}\npublic class Order : Aggregate {\n    // Whizbang tracks revision automatically\n    public int Revision { get; internal set; }\n    public DateTime LastModified { get; internal set; }\n    public string LastModifiedBy { get; internal set; }\n}\nawait repository Save(order, expectedRevision: order Revision);\n`\nF Conditional Updates\nSQL-style conditional updates:\n`csharp{title=\"Conditional Updates\" description=\"SQL-style conditional updates with business logic conditions\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"conditional-updates\", \"sql-style\", \"business-logic\"] framework=\"NET8\"}\nawait repository Save(order, condition: o => o Status == OrderStatus Pending);\n// Only saves if order is still pending\n`\nPolicy-Driven Configuration\n> 📋 Universal Configuration: Whizbang uses the Policy Engine as the universal configuration scoping mechanism",
        "startIndex": 2873,
        "preview": "for all operations policies When(ctx => true) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy AutomaticRetry)) And(config => config S..."
      },
      {
        "id": "proposals/concurrency-control-chunk-2",
        "text": "conditional updates with business logic conditions\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"conditional-updates\", \"sql-style\", \"business-logic\"] framework=\"NET8\"} await repository Save(order, condition: o => o Status == OrderStatus Pending); // Only saves if order is still pending ` Policy-Driven Configuration > 📋 Universal Configuration: Whizbang uses the Policy Engine as the universal configuration scoping mechanism All concurrency strategies, retry policies, and conflict resolution rules are configured through policies rather than direct configuration methods Basic Policy Configuration\nConfigure concurrency strategies using the Policy Engine - the universal configuration scoping mechanism:\n`csharp{title=\"Basic Policy Configuration\" description=\"Global concurrency strategy configuration using policy engine\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"policy-configuration\", \"global-strategy\", \"policy-engine\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        // Global default strategy\n        policies When(ctx => true) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy ExpectedVersion)) And(config => config SetRetryAttempts(3)) And(config => config SetRetryDelay(TimeSpan FromMilliseconds(100)));\n    });\n});\n`\nAdvanced Policy Scenarios\nCombine multiple conditions for sophisticated concurrency control:\n`csharp{title=\"Advanced Policy Scenarios\" description=\"Sophisticated concurrency control with context-dependent strategies\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"concurrency\", \"advanced-policies\", \"context-dependent\", \"tenant-specific\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        // Orders get automatic retry with more attempts\n        policies When(ctx => ctx MatchesAggregate<Order>()) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy AutomaticRetry)) And(config => config SetRetryAttempts(5)); // Orders get more retries\n        // Shopping carts use timestamp-based for simplicity\n        policies When(ctx => ctx MatchesAggregate<ShoppingCart>()) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy TimestampBased));\n        // High-volume commands get automatic retry\n        policies When(ctx => ctx HasTag(\"high-volume\")) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy AutomaticRetry)) And(config => config SetRetryAttempts(5));\n        // Load testing uses relaxed concurrency\n        policies When(ctx => ctx HasFlag(WhizbangFlags LoadTesting)) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy LastWriteWins));\n        // Environment-based strategies\n        policies When(ctx => ctx Environment == \"production\") Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy ExpectedVersion)) And(config => config SetRetryAttempts(3));\n        policies When(ctx => ctx Environment == \"development\") Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy LastWriteWins)); // Relaxed for dev\n        // Tenant-specific strategies\n        policies When(ctx => ctx TenantId = null && ctx HasTag(\"enterprise-tenant\")) Then(config => config",
        "startIndex": 5051,
        "preview": "conditional updates with business logic conditions\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"conditional-updates\", \"sql-style..."
      },
      {
        "id": "proposals/concurrency-control-chunk-3",
        "text": "Environment-based strategies policies When(ctx => ctx Environment == \"production\") Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy ExpectedVersion)) And(config => config SetRetryAttempts(3)); policies When(ctx => ctx Environment == \"development\") Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy LastWriteWins)); // Relaxed for dev // Tenant-specific strategies policies When(ctx => ctx TenantId = null && ctx HasTag(\"enterprise-tenant\")) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy ExpectedVersion)) And(config => config SetRetryAttempts(5)) And(config => config EnableStrictConflictResolution());\n    });\n});\n`\nRuntime Policy Evaluation\nPolicies are evaluated at runtime based on the current context:\n`csharp{title=\"Runtime Policy Evaluation\" description=\"Context-driven policy evaluation with automatic strategy selection\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"runtime-evaluation\", \"context-driven\", \"automatic-selection\"] framework=\"NET8\"}\n// Policy evaluation happens automatically during save operations\nawait repository Save(order, context => {\n    context WithTag(\"high-volume\");        // Triggers high-volume policy\n    context WithFlag(WhizbangFlags Production); // Triggers production policy\n});\n// Context determines which concurrency strategy is used\n// No need to manually specify strategy - policies handle it\n`\nManual Override (When Needed)\nOverride policies for exceptional cases:\n`csharp{title=\"Manual Override\" description=\"Explicit override of policy-driven concurrency for critical operations\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"manual-override\", \"policy-bypass\", \"critical-operations\"] framework=\"NET8\"}\n// Explicit override for critical operations\nawait repository Save(order, saveOptions => {\n    saveOptions OverrideConcurrencyStrategy(ConcurrencyStrategy ExpectedVersion);\n    saveOptions SetExpectedVersion(5);\n    saveOptions BypassPolicies(); // Skip policy evaluation\n});\n`\nConflict Resolution Strategies\nBuilt-in Resolvers\n`csharp{title=\"Built-in Conflict Resolvers\" description=\"Common conflict resolution strategies for different scenarios\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"built-in-resolvers\", \"conflict-strategies\", \"merge-strategies\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        // Last-write-wins for Order aggregates\n        policies When(ctx => ctx MatchesAggregate<Order>()) Then(config => config SetConflictResolver(ConflictResolvers LastWriteWins));\n        // First-write-wins for Customer aggregates (reject conflicting changes)\n        policies When(ctx => ctx MatchesAggregate<Customer>()) Then(config => config SetConflictResolver(ConflictResolvers FirstWriteWins));\n        // Additive merge for ShoppingCart (combine collections)\n        policies When(ctx => ctx MatchesAggregate<ShoppingCart>()) Then(config => config SetConflictResolver(ConflictResolvers",
        "startIndex": 2346,
        "preview": "Environment-based strategies policies When(ctx => ctx Environment == \"production\") Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy Ex..."
      },
      {
        "id": "proposals/concurrency-control-chunk-4",
        "text": "{ // Last-write-wins for Order aggregates policies When(ctx => ctx MatchesAggregate<Order>()) Then(config => config SetConflictResolver(ConflictResolvers LastWriteWins)); // First-write-wins for Customer aggregates (reject conflicting changes) policies When(ctx => ctx MatchesAggregate<Customer>()) Then(config => config SetConflictResolver(ConflictResolvers FirstWriteWins)); // Additive merge for ShoppingCart (combine collections) policies When(ctx => ctx MatchesAggregate<ShoppingCart>()) Then(config => config SetConflictResolver(ConflictResolvers AdditiveMerge));\n    });\n});\n`\nCustom Conflict Resolvers via Policies\nDefine custom conflict resolution logic through policies:\n`csharp{title=\"Custom Conflict Resolvers\" description=\"Domain-specific merge logic for different aggregate properties\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"concurrency\", \"custom-resolvers\", \"business-logic-merge\", \"domain-specific\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        // Custom resolver for Order aggregates\n        policies When(ctx => ctx MatchesAggregate<Order>()) Then(config => config SetConflictResolver((current, attempted) => {\n                    var resolved = current Copy();\n                    // Merge line items additively\n                    foreach (var item in attempted Items) {\n                        if ( resolved Items Any(i => i ProductId == item ProductId)) {\n                            resolved AddItem(item);\n                        }\n                    }\n                    // Take latest shipping address\n                    if (attempted ShippingAddress = null) {\n                        resolved UpdateShippingAddress(attempted ShippingAddress);\n                    }\n                    return resolved;\n                }));\n    });\n});\n`\nAdvanced Conflict Resolution\nAccess full conflict context through policies:\n`csharp{title=\"Advanced Conflict Resolution\" description=\"Three-way merge using original version as merge base\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"concurrency\", \"three-way-merge\", \"advanced-resolution\", \"merge-base\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        policies When(ctx => ctx MatchesAggregate<Order>()) Then(config => config SetConflictResolver((context) => {\n                    var current = context CurrentVersion;\n                    var attempted = context AttemptedVersion;\n                    var original = context",
        "startIndex": 10620,
        "preview": "{ // Last-write-wins for Order aggregates policies When(ctx => ctx MatchesAggregate<Order>()) Then(config => config SetConflictResolver(ConflictResolv..."
      },
      {
        "id": "proposals/concurrency-control-chunk-5",
        "text": "Conflict Resolution\" description=\"Three-way merge using original version as merge base\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"concurrency\", \"three-way-merge\", \"advanced-resolution\", \"merge-base\"] framework=\"NET8\"} services AddWhizbang(options => { options Policies(policies => { policies When(ctx => ctx MatchesAggregate<Order>()) Then(config => config SetConflictResolver((context) => { var current = context CurrentVersion; var attempted = context AttemptedVersion; var original = context OriginalVersion; // Version when load started\n                    // Three-way merge using original as base\n                    return ThreeWayMerge(original, current, attempted);\n                }));\n    });\n});\n});\n`\nImplementation Details\nConcurrency Exception Handling\n`csharp{title=\"Concurrency Exception Handling\" description=\"Detailed conflict information for debugging and error handling\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"exception-handling\", \"conflict-information\", \"debugging\"] framework=\"NET8\"}\npublic class ConcurrencyException : Exception {\n    public string StreamId { get; }\n    public int ExpectedVersion { get; }\n    public int ActualVersion { get; }\n    public Type AggregateType { get; }\n    public ConcurrencyException(string streamId, int expectedVersion, int actualVersion, Type aggregateType)\n        : base($\"Concurrency conflict in {aggregateType Name} stream {streamId} Expected version {expectedVersion}, but current version is {actualVersion}\") {\n        StreamId = streamId;\n        ExpectedVersion = expectedVersion;\n        ActualVersion = actualVersion;\n        AggregateType = aggregateType;\n    }\n}\n`\nRetry Logic\n`csharp{title=\"Retry Logic Configuration\" description=\"Exponential backoff and jitter for reducing contention\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"retry-logic\", \"exponential-backoff\", \"jitter\"] framework=\"NET8\"}\npublic class RetryPolicy {\n    public int MaxAttempts { get; set; } = 3;\n    public TimeSpan InitialDelay { get; set; } = TimeSpan FromMilliseconds(100);\n    public TimeSpan MaxDelay { get; set; } = TimeSpan FromSeconds(1);\n    public double BackoffMultiplier { get; set; } = 2 0;\n    public RetryJitter Jitter { get; set; } = RetryJitter",
        "startIndex": 12599,
        "preview": "Conflict Resolution\" description=\"Three-way merge using original version as merge base\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"concurrency\", \"..."
      },
      {
        "id": "proposals/concurrency-control-chunk-6",
        "text": "RetryPolicy { public int MaxAttempts { get; set; } = 3; public TimeSpan InitialDelay { get; set; } = TimeSpan FromMilliseconds(100); public TimeSpan MaxDelay { get; set; } = TimeSpan FromSeconds(1); public double BackoffMultiplier { get; set; } = 2 0; public RetryJitter Jitter { get; set; } = RetryJitter Random;\n}\n// Example retry sequence:\n// Attempt 1: 100ms + random(0-50ms)\n// Attempt 2: 200ms + random(0-100ms)  \n// Attempt 3: 400ms + random(0-200ms)\n`\nDriver Interface\n`csharp{title=\"Driver Interface\" description=\"Interface for implementing concurrency control strategies\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"concurrency\", \"driver-interface\", \"implementation\", \"strategies\"] framework=\"NET8\"}\npublic interface IConcurrencyDriver {\n    Task<T> Load<T>(string streamId, ConcurrencyOptions options) where T : Aggregate;\n    Task<(T Aggregate, ConcurrencyToken Token)> LoadWithToken<T>(string streamId) where T : Aggregate;\n    Task Save<T>(T aggregate, ConcurrencyCheck check) where T : Aggregate;\n    Task<SaveResult> TrySave<T>(T aggregate, ConcurrencyCheck check) where T : Aggregate;\n    Task<ConflictResolutionResult> ResolveConflict<T>(\n        T original, \n        T current, \n        T attempted, \n        ConflictResolver<T> resolver) where T : Aggregate;\n}\npublic class ConcurrencyCheck {\n    public ConcurrencyStrategy Strategy { get; set; }\n    public int ExpectedVersion { get; set; }\n    public DateTime IfNotModifiedSince { get; set; }\n    public ConcurrencyToken Token { get; set; }\n    public Expression<Func<object, bool>> Condition { get; set; }\n}\n`\nPerformance Considerations\nOptimizations\nVersion caching - Cache current versions to reduce round trips\nBatch operations - Group saves to reduce conflicts\nRead replicas - Load from read replicas to reduce load on primary\nConflict prediction - Use heuristics to predict likely conflicts\nMonitoring\n`csharp{title=\"Concurrency Monitoring\" description=\"Conflict logging and metrics for observability\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"concurrency\", \"monitoring\", \"metrics\", \"observability\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options UseOptimisticConcurrency(concurrency => {\n        concurrency OnConflict = (context) => {\n            // Log conflict for monitoring\n            logger LogWarning(\"Concurrency conflict in {StreamId}: {Conflict}\", \n                context StreamId, context ConflictDescription);\n            // Emit metrics\n            metrics IncrementCounter(\"whizbang concurrency conflicts\", \n                new[] { (\"aggregate_type\", context AggregateType Name) });\n        };\n        concurrency OnRetry = (context) => {\n            logger",
        "startIndex": 14361,
        "preview": "RetryPolicy { public int MaxAttempts { get; set; } = 3; public TimeSpan InitialDelay { get; set; } = TimeSpan FromMilliseconds(100); public TimeSpan M..."
      },
      {
        "id": "proposals/concurrency-control-chunk-7",
        "text": "AddWhizbang(options => { options UseOptimisticConcurrency(concurrency => { concurrency OnConflict = (context) => { // Log conflict for monitoring logger LogWarning(\"Concurrency conflict in {StreamId}: {Conflict}\", context StreamId, context ConflictDescription); // Emit metrics metrics IncrementCounter(\"whizbang concurrency conflicts\", new[] { (\"aggregate_type\", context AggregateType Name) }); }; concurrency OnRetry = (context) => { logger LogDebug(\"Retrying save for {StreamId}, attempt {Attempt}\", \n                context StreamId, context AttemptNumber);\n        };\n    });\n});\n`\nBest Practices\nStrategy Selection Guidelines\nExpected Version - Use for critical business operations requiring strict consistency\nTimestamp-Based - Use for user-facing operations where UX matters more than strict consistency\nAutomatic Retry - Use for high-contention scenarios with predictable merge strategies\nToken-Based - Use when integrating with external systems that provide tokens\nConditional - Use for operations that depend on specific business conditions\nConflict Resolution Guidelines\nKeep resolvers fast - Avoid heavy computation or I/O\nTest thoroughly - Ensure resolvers handle edge cases\nMake resolvers deterministic - Same inputs should produce same outputs\nLog conflicts - Track conflict patterns for optimization\nFallback to exceptions - Don't resolve conflicts you can't handle safely\n---\nRelated Documentation\nEvent Store & Projections - Storage architecture\nDomain Ownership - Command routing and ownership\nPerformance Optimization - Scaling strategies",
        "startIndex": 16741,
        "preview": "AddWhizbang(options => { options UseOptimisticConcurrency(concurrency => { concurrency OnConflict = (context) => { // Log conflict for monitoring logg..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "proposals/deployment-operations",
    "title": "Deployment & Operations",
    "category": "Architecture & Design",
    "url": "/docs/proposals/deployment-operations",
    "chunks": [
      {
        "id": "proposals/deployment-operations-chunk-0",
        "text": "Deployment & Operations\nWhizbang is designed as an embedded library that runs within developer services, providing comprehensive operational hooks for production deployment, monitoring, and lifecycle management Deployment Model\nEmbedded Library Architecture\nWhizbang runs embedded within your application, not as a separate service:\n`csharp{title=\"Embedded Library Setup\" description=\"Basic embedded library setup within ASP NET Core application\" category=\"Design\" difficulty=\"BEGINNER\" tags=[\"Design\", \"Deployment\", \"Embedded-Library\", \"ASP NET-Core\"] framework=\"NET8\"}\n// Your service with Whizbang embedded\npublic class Program {\n    public static void Main(string[] args) {\n        var builder = WebApplication CreateBuilder(args);\n        // Add your application services\n        builder Services AddControllers();\n        builder Services AddOrderService();\n        // Add Whizbang as embedded library\n        builder Services AddWhizbang(options => {\n            options UsePostgresEventStore(connectionString);\n            options UseKafkaMessageBroker(kafkaConfig);\n            options ConfigureDomains();\n        });\n        var app = builder Build();\n        // Configure your application pipeline\n        app MapControllers();\n        app MapWhizbangEndpoints(); // Optional: Expose Whizbang endpoints\n        app",
        "startIndex": 0,
        "preview": "Deployment & Operations\nWhizbang is designed as an embedded library that runs within developer services, providing comprehensive operational hooks for..."
      },
      {
        "id": "proposals/deployment-operations-chunk-1",
        "text": "CreateBuilder(args); // Add your application services builder Services AddControllers(); builder Services AddOrderService(); // Add Whizbang as embedded library builder Services AddWhizbang(options => { options UsePostgresEventStore(connectionString); options UseKafkaMessageBroker(kafkaConfig); options ConfigureDomains(); }); var app = builder Build(); // Configure your application pipeline app MapControllers(); app MapWhizbangEndpoints(); // Optional: Expose Whizbang endpoints app Run();\n    }\n}\n`\nService Architecture Patterns\nMultiple deployment patterns supported:\nMonolithic Deployment\n`yaml\n---\ncategory: Design\ndifficulty: INTERMEDIATE\ntags: [Design, Deployment, Kubernetes, Monolithic-Deployment]\ndescription: Kubernetes deployment configuration for monolithic service architecture\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: ecommerce-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: ecommerce-service\n  template:\n    metadata:\n      labels:\n        app: ecommerce-service\n    spec:\n      containers:\nname: ecommerce-service\n        image: myapp/ecommerce-service:latest\n        ports:\ncontainerPort: 8080\n        env:\nname: WHIZBANG_EVENTSTORE_CONNECTION\n          valueFrom:\n            secretKeyRef:\n              name: database-secrets\n              key: connection-string\nname: WHIZBANG_MESSAGEBROKER_BOOTSTRAP_SERVERS\n          value: \"kafka:9092\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /health/ready\n            port: 8080\n          initialDelaySeconds: 5\n          periodSeconds: 5\n`\nMicroservices Deployment\n`yaml\n---\ncategory: Design\ndifficulty: INTERMEDIATE\ntags: [Design, Deployment, Kubernetes, Microservices, Separation-of-Concerns]\ndescription: Kubernetes deployment for microservices with separated command and projection services\n---\nCommand Service\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: order-command-service\nspec:\n  replicas: 2\n  template:\n    spec:\n      containers:\nname: order-service\n        image: myapp/order-service:latest\n        env:\nname: WHIZBANG_DOMAIN\n          value: \"Orders\"\nname: WHIZBANG_PROJECTION_MODE\n          value: \"Disabled\" Command service doesn't run projections\n---\nProjection Worker Service  \napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: order-projection-worker\nspec:\n  replicas: 3\n  template:\n    spec:\n      containers:\nname: projection-worker\n        image: myapp/order-projection-worker:latest\n        env:\nname: WHIZBANG_DOMAIN\n          value: \"Orders\"\nname: WHIZBANG_COMMAND_MODE\n          value: \"Disabled\" Projection worker doesn't handle commands\nname: WHIZBANG_PROJECTIONS\n          value: \"OrderSummary,OrderHistory,OrderAnalytics\"\n`\nDomain-per-Service Deployment\n`yaml\n---\ncategory: Design\ndifficulty: INTERMEDIATE\ntags: [Design, Deployment, Kubernetes, Domain-per-Service]\ndescription: Domain-per-service deployment pattern with domain ownership configuration\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: orders-service\nspec:\n  template:\n    spec:\n      containers:\nname: orders-service\n        image: myapp/orders-service:latest\n        env:\nname: WHIZBANG_OWNED_DOMAINS\n          value: \"Orders\"\n---\napiVersion: apps/v1  \nkind: Deployment\nmetadata:\n  name: inventory-service\nspec:\n  template:\n    spec:\n      containers:\nname: inventory-service\n        image: myapp/inventory-service:latest\n        env:\nname: WHIZBANG_OWNED_DOMAINS\n          value: \"Inventory\"\n`\nHealth Checks\nBuilt-in Health Check System\nComprehensive health monitoring ready for Kubernetes probes:\n`csharp{title=\"Health Check Configuration\" description=\"Comprehensive health check configuration for production readiness\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Deployment\", \"Health-Checks\", \"Monitoring\"] framework=\"NET8\"}\nservices",
        "startIndex": 1327,
        "preview": "CreateBuilder(args); // Add your application services builder Services AddControllers(); builder Services AddOrderService(); // Add Whizbang as embedd..."
      },
      {
        "id": "proposals/deployment-operations-chunk-2",
        "text": "kind: Deployment metadata: name: inventory-service spec: template: spec: containers: name: inventory-service image: myapp/inventory-service:latest env: name: WHIZBANG_OWNED_DOMAINS value: \"Inventory\" ` Health Checks Built-in Health Check System Comprehensive health monitoring ready for Kubernetes probes: `csharp{title=\"Health Check Configuration\" description=\"Comprehensive health check configuration for production readiness\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Deployment\", \"Health-Checks\", \"Monitoring\"] framework=\"NET8\"} services AddWhizbang(options => {\n    options HealthChecks(health => {\n        // Core infrastructure health\n        health CheckEventStoreConnection = true;\n        health CheckMessageBrokerConnection = true;\n        health CheckProjectionHealth = true;\n        // Operational thresholds\n        health ProjectionLagThreshold = TimeSpan FromMinutes(5);\n        health EventStoreLatencyThreshold = TimeSpan FromMilliseconds(100);\n        health MessageBrokerLatencyThreshold = TimeSpan FromMilliseconds(500);\n        // Custom health checks\n        health AddCheck<CustomBusinessLogicHealthCheck>();\n    });\n});\n// Register health check endpoints\napp MapHealthChecks(\"/health\", new HealthCheckOptions {\n    ResponseWriter = UIResponseWriter WriteHealthCheckUIResponse\n});\napp MapHealthChecks(\"/health/ready\", new HealthCheckOptions {\n    Predicate = check => check Tags Contains(\"ready\"),\n    ResponseWriter = UIResponseWriter WriteHealthCheckUIResponse\n});\napp MapHealthChecks(\"/health/live\", new HealthCheckOptions {\n    Predicate = check => check Tags Contains(\"live\")\n});\n`\nHealth Check Implementation\nDetailed health check implementation:\n`csharp{title=\"Health Check Implementation\" description=\"Detailed health check implementation for infrastructure components\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Deployment\", \"Health-Checks\", \"Implementation\"] framework=\"NET8\"}\npublic class WhizbangHealthCheck : IHealthCheck {\n    private readonly IEventStore _eventStore;\n    private readonly IMessageBroker _messageBroker;\n    private readonly IProjectionManager _projectionManager;\n    private readonly WhizbangHealthOptions _options;\n    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default) {\n        var checks = new List<(string name, bool healthy, string details)>();\n        // Event store connectivity\n        if (_options CheckEventStoreConnection) {\n            try {\n                await _eventStore HealthCheckAsync(cancellationToken);\n                checks Add((\"EventStore\", true, \"Connected\"));\n            } catch (Exception ex) {\n                checks Add((\"EventStore\", false, ex Message));\n            }\n        }\n        // Message broker connectivity\n        if (_options CheckMessageBrokerConnection) {\n            try {\n                await _messageBroker HealthCheckAsync(cancellationToken);\n                checks Add((\"MessageBroker\", true, \"Connected\"));\n            } catch (Exception ex) {\n                checks Add((\"MessageBroker\", false, ex Message));\n            }\n        }\n        // Projection health\n        if (_options CheckProjectionHealth) {\n            var projections = await _projectionManager GetAllProjectionsAsync(cancellationToken);\n            foreach (var projection in projections) {\n                var lag = await _projectionManager GetLagAsync(projection",
        "startIndex": 4791,
        "preview": "kind: Deployment metadata: name: inventory-service spec: template: spec: containers: name: inventory-service image: myapp/inventory-service:latest env..."
      },
      {
        "id": "proposals/deployment-operations-chunk-3",
        "text": "if (_options CheckMessageBrokerConnection) { try { await _messageBroker HealthCheckAsync(cancellationToken); checks Add((\"MessageBroker\", true, \"Connected\")); } catch (Exception ex) { checks Add((\"MessageBroker\", false, ex Message)); } } // Projection health if (_options CheckProjectionHealth) { var projections = await _projectionManager GetAllProjectionsAsync(cancellationToken); foreach (var projection in projections) { var lag = await _projectionManager GetLagAsync(projection Name, cancellationToken);\n                var healthy = lag <= _options ProjectionLagThreshold;\n                checks Add(($\"Projection:{projection Name}\", healthy, $\"Lag: {lag TotalSeconds}s\"));\n            }\n        }\n        // Determine overall health\n        var allHealthy = checks All(c => c healthy);\n        var status = allHealthy HealthStatus Healthy : HealthStatus Unhealthy;\n        var data = checks ToDictionary(c => c name, c => (object)new { \n            healthy = c healthy, \n            details = c details \n        });\n        return new HealthCheckResult(status, data: data);\n    }\n}\n`\nGraceful Shutdown NET Host Lifetime Integration\nProper integration with NET hosting lifetime for clean shutdown:\n`csharp{title=\"Graceful Shutdown Service\" description=\" NET hosted service integration with graceful shutdown support\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Deployment\", \"Graceful-Shutdown\", \"Hosting-Integration\"] framework=\"NET8\"}\npublic class WhizbangHostedService : IHostedService, IDisposable {\n    private readonly IWhizbangRuntime _runtime;\n    private readonly ILogger<WhizbangHostedService> _logger;\n    private readonly WhizbangOptions _options;\n    public async Task StartAsync(CancellationToken cancellationToken) {\n        _logger LogInformation(\"Starting Whizbang runtime\");\n        await _runtime StartAsync(cancellationToken);\n        _logger LogInformation(\"Whizbang runtime started\");\n    }\n    public async Task StopAsync(CancellationToken cancellationToken) {\n        _logger LogInformation(\"Stopping Whizbang runtime\");\n        try {\n            // Stop accepting new messages\n            await _runtime StopAcceptingMessagesAsync(cancellationToken);\n            _logger LogInformation(\"Stopped accepting new messages\");\n            // Drain in-flight messages with timeout\n            var drainTimeout = _options GracefulShutdownTimeout TimeSpan FromSeconds(30);\n            using var drainCts = CancellationTokenSource CreateLinkedTokenSource(cancellationToken);\n            drainCts CancelAfter(drainTimeout);\n            await _runtime DrainInFlightMessagesAsync(drainCts Token);\n            _logger LogInformation(\"Drained in-flight messages\");\n            // Stop projections\n            await _runtime StopProjectionsAsync(cancellationToken);\n            _logger LogInformation(\"Stopped projections\");\n            // Close connections\n            await _runtime CloseConnectionsAsync(cancellationToken);\n            _logger LogInformation(\"Closed connections\");\n        } catch (OperationCanceledException) {\n            _logger LogWarning(\"Graceful shutdown timed out, forcing shutdown\");\n        } catch (Exception ex) {\n            _logger LogError(ex, \"Error during graceful shutdown\");\n        }\n        _logger LogInformation(\"Whizbang runtime stopped\");\n    }\n    public void Dispose() {\n        _runtime",
        "startIndex": 7693,
        "preview": "if (_options CheckMessageBrokerConnection) { try { await _messageBroker HealthCheckAsync(cancellationToken); checks Add((\"MessageBroker\", true, \"Conne..."
      },
      {
        "id": "proposals/deployment-operations-chunk-4",
        "text": "Stop projections await _runtime StopProjectionsAsync(cancellationToken); _logger LogInformation(\"Stopped projections\"); // Close connections await _runtime CloseConnectionsAsync(cancellationToken); _logger LogInformation(\"Closed connections\"); } catch (OperationCanceledException) { _logger LogWarning(\"Graceful shutdown timed out, forcing shutdown\"); } catch (Exception ex) { _logger LogError(ex, \"Error during graceful shutdown\"); } _logger LogInformation(\"Whizbang runtime stopped\"); } public void Dispose() { _runtime Dispose();\n    }\n}\n`\nKubernetes Integration\nSIGTERM handling for Kubernetes graceful shutdown:\n`csharp{title=\"Kubernetes Graceful Shutdown\" description=\"Kubernetes SIGTERM handling with graceful shutdown and load balancer drain\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Deployment\", \"Graceful-Shutdown\", \"Kubernetes-Integration\"] framework=\"NET8\"}\npublic class GracefulShutdownService : BackgroundService {\n    private readonly IHostApplicationLifetime _applicationLifetime;\n    private readonly IWhizbangRuntime _runtime;\n    private readonly ILogger<GracefulShutdownService> _logger;\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken) {\n        // Register for shutdown notification\n        _applicationLifetime ApplicationStopping Register(OnShutdown);\n        // Wait for shutdown\n        await Task Delay(Timeout Infinite, stoppingToken);\n    }\n    private void OnShutdown() {\n        _logger LogInformation(\"Received shutdown signal, initiating graceful shutdown\");\n        // Custom shutdown logic\n        Task Run(async () => {\n            try {\n                // Give projections time to finish current batch\n                await _runtime CompleteCurrentBatchAsync(TimeSpan FromSeconds(10));\n                // Signal readiness probe to fail (remove from load balancer)\n                _runtime MarkAsNotReady();\n                // Wait for load balancer to drain\n                await Task Delay(TimeSpan FromSeconds(5));\n                _logger LogInformation(\"Graceful shutdown preparation complete\");\n            } catch (Exception ex) {\n                _logger LogError(ex, \"Error during shutdown preparation\");\n            }\n        });\n    }\n}\n`\nConfiguration Management\nEnvironment-Specific Configuration\nFlexible configuration for different deployment environments:\n`json\n---\ncategory: Design\ndifficulty: BEGINNER\ntags: [Design, Deployment, Configuration, Environment-Management]\ndescription: Environment-specific configuration management with base and override files\n---\n// appsettings json (base configuration)\n{\n  \"Whizbang\": {\n    \"EventStore\": {\n      \"Driver\": \"Postgres\"\n    },\n    \"MessageBroker\": {\n      \"Driver\": \"Kafka\"\n    },\n    \"Projections\": {\n      \"DefaultStrategy\": \"Automatic\"\n    }\n  }\n}\n// appsettings Development json\n{\n  \"Whizbang\": {\n    \"EventStore\": {\n      \"ConnectionString\": \"Host=localhost;Database=whizbang_dev\",\n      \"EnableDetailedLogging\": true\n    },\n    \"MessageBroker\": {\n      \"BootstrapServers\": \"localhost:9092\",\n      \"EnableAutoCommit\": true\n    },\n    \"Observability\": {\n      \"Level\": \"Verbose\",\n      \"SampleRate\": 1 0\n    }\n  }\n}\n// appsettings Production",
        "startIndex": 10584,
        "preview": "Stop projections await _runtime StopProjectionsAsync(cancellationToken); _logger LogInformation(\"Stopped projections\"); // Close connections await _ru..."
      },
      {
        "id": "proposals/deployment-operations-chunk-5",
        "text": "{ \"Driver\": \"Postgres\" }, \"MessageBroker\": { \"Driver\": \"Kafka\" }, \"Projections\": { \"DefaultStrategy\": \"Automatic\" } } } // appsettings Development json { \"Whizbang\": { \"EventStore\": { \"ConnectionString\": \"Host=localhost;Database=whizbang_dev\", \"EnableDetailedLogging\": true }, \"MessageBroker\": { \"BootstrapServers\": \"localhost:9092\", \"EnableAutoCommit\": true }, \"Observability\": { \"Level\": \"Verbose\", \"SampleRate\": 1 0 } } } // appsettings Production json\n{\n  \"Whizbang\": {\n    \"EventStore\": {\n      \"ConnectionString\": \"\", // Set via environment variable\n      \"PoolSize\": 20,\n      \"CommandTimeout\": 30\n    },\n    \"MessageBroker\": {\n      \"BootstrapServers\": \"\", // Set via environment variable\n      \"SecurityProtocol\": \"SaslSsl\",\n      \"EnableIdempotence\": true\n    },\n    \"Observability\": {\n      \"Level\": \"Standard\",\n      \"SampleRate\": 0 1\n    },\n    \"HealthChecks\": {\n      \"ProjectionLagThresholdMinutes\": 5,\n      \"EventStoreLatencyThresholdMs\": 100\n    }\n  }\n}\n`\nSecret Management\nSecure credential handling:\n`csharp{title=\"Secret Management\" description=\"Secure credential handling with Azure Key Vault and Kubernetes secrets\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Deployment\", \"Security\", \"Secret-Management\"] framework=\"NET8\"}\n// Using Azure Key Vault\nbuilder Configuration AddAzureKeyVault(\n    new Uri(\"https://myapp-keyvault vault azure net/\"),\n    new DefaultAzureCredential()\n);\n// Using Kubernetes secrets\nservices AddWhizbang(options => {\n    // Connection string from Kubernetes secret\n    var connectionString = Environment GetEnvironmentVariable(\"WHIZBANG_EVENTSTORE_CONNECTION\") throw new InvalidOperationException(\"Event store connection string not configured\");\n    options UsePostgresEventStore(connectionString);\n    // Message broker configuration from environment\n    options UseKafkaMessageBroker(kafka => {\n        kafka BootstrapServers = Environment GetEnvironmentVariable(\"KAFKA_BOOTSTRAP_SERVERS\");\n        kafka SecurityProtocol = Enum Parse<SecurityProtocol>(\n            Environment GetEnvironmentVariable(\"KAFKA_SECURITY_PROTOCOL\") \"Plaintext\"\n        );\n        if (kafka SecurityProtocol = SecurityProtocol Plaintext) {\n            kafka SaslUsername = Environment GetEnvironmentVariable(\"KAFKA_SASL_USERNAME\");\n            kafka SaslPassword = Environment GetEnvironmentVariable(\"KAFKA_SASL_PASSWORD\");\n        }\n    });\n});\n`\nMonitoring and Alerting\nProduction Monitoring Setup\nComprehensive monitoring stack integration:\n`yaml\n---\ncategory: Design\ndifficulty: INTERMEDIATE\ntags: [Design, Deployment, Monitoring, Prometheus, Grafana]\ndescription: Production monitoring setup with Prometheus and Grafana dashboard configuration\n---\nPrometheus ServiceMonitor for metrics scraping\napiVersion: monitoring coreos com/v1\nkind: ServiceMonitor\nmetadata:\n  name: whizbang-metrics\nspec:\n  selector:\n    matchLabels:\n      app: ecommerce-service\n  endpoints:\nport: metrics\n    path: /metrics\n    interval: 30s\n    scrapeTimeout: 10s\n---\nGrafana dashboard ConfigMap\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: whizbang-dashboard\ndata:\n  dashboard",
        "startIndex": 13253,
        "preview": "{ \"Driver\": \"Postgres\" }, \"MessageBroker\": { \"Driver\": \"Kafka\" }, \"Projections\": { \"DefaultStrategy\": \"Automatic\" } } } // appsettings Development jso..."
      },
      {
        "id": "proposals/deployment-operations-chunk-6",
        "text": "monitoring setup with Prometheus and Grafana dashboard configuration --- Prometheus ServiceMonitor for metrics scraping apiVersion: monitoring coreos com/v1 kind: ServiceMonitor metadata: name: whizbang-metrics spec: selector: matchLabels: app: ecommerce-service endpoints: port: metrics path: /metrics interval: 30s scrapeTimeout: 10s --- Grafana dashboard ConfigMap apiVersion: v1 kind: ConfigMap metadata: name: whizbang-dashboard data: dashboard json: |\n    {\n      \"dashboard\": {\n        \"title\": \"Whizbang Application Metrics\",\n        \"panels\": [\n          {\n            \"title\": \"Command Processing Rate\",\n            \"targets\": [\n              {\n                \"expr\": \"rate(whizbang_command_total[5m])\",\n                \"legendFormat\": \"{{command_type}}\"\n              }\n            ]\n          }\n        ]\n      }\n    }\n`\nLog Aggregation\nStructured logging for centralized log management:\n`csharp{title=\"Structured Logging\" description=\"Structured logging configuration for centralized log management\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Deployment\", \"Logging\", \"Structured-Logging\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options Logging(logging => {\n        logging StructuredLogging = true;\n        logging IncludeCorrelationIds = true;\n        logging IncludeDomainContext = true;\n        logging SanitizeSensitiveData = true;\n        // Log levels by component\n        logging SetLogLevel(\"Whizbang Commands\", LogLevel Information);\n        logging SetLogLevel(\"Whizbang Events\", LogLevel Information);\n        logging SetLogLevel(\"Whizbang Projections\", LogLevel Warning);\n        logging SetLogLevel(\"Whizbang Policies\", LogLevel Debug);\n    });\n});\n// Example structured log output\n{\n  \"timestamp\": \"2024-01-01T10:00:00",
        "startIndex": 15925,
        "preview": "monitoring setup with Prometheus and Grafana dashboard configuration --- Prometheus ServiceMonitor for metrics scraping apiVersion: monitoring coreos ..."
      },
      {
        "id": "proposals/deployment-operations-chunk-7",
        "text": "StructuredLogging = true; logging IncludeCorrelationIds = true; logging IncludeDomainContext = true; logging SanitizeSensitiveData = true; // Log levels by component logging SetLogLevel(\"Whizbang Commands\", LogLevel Information); logging SetLogLevel(\"Whizbang Events\", LogLevel Information); logging SetLogLevel(\"Whizbang Projections\", LogLevel Warning); logging SetLogLevel(\"Whizbang Policies\", LogLevel Debug); }); }); // Example structured log output { \"timestamp\": \"2024-01-01T10:00:00 000Z\",\n  \"level\": \"Information\",\n  \"messageTemplate\": \"Command {CommandType} processed for domain {Domain}\",\n  \"properties\": {\n    \"CommandType\": \"PlaceOrder\",\n    \"Domain\": \"Orders\",\n    \"CorrelationId\": \"abc-123-def\",\n    \"TenantId\": \"tenant-456\",\n    \"ExecutionTimeMs\": 45,\n    \"Success\": true\n  }\n}\n`\nScaling Strategies\nHorizontal Scaling\nScale-out patterns for high throughput:\n`yaml\n---\ncategory: Design\ndifficulty: INTERMEDIATE\ntags: [Design, Deployment, Kubernetes, Auto-Scaling, HPA]\ndescription: Horizontal pod autoscaler configuration with custom metrics\n---\nHorizontal Pod Autoscaler\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: ecommerce-service-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: ecommerce-service\n  minReplicas: 2\n  maxReplicas: 20\n  metrics:\ntype: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70\ntype: Resource\n    resource:\n      name: memory\n      target:\n        type: Utilization\n        averageUtilization: 80\ntype: Pods\n    pods:\n      metric:\n        name: whizbang_projection_lag_seconds\n      target:\n        type: AverageValue\n        averageValue: \"300\" Scale when lag > 5 minutes\n`\nVertical Scaling\nResource optimization for different workloads:\n`yaml\n---\ncategory: Design\ndifficulty: INTERMEDIATE\ntags: [Design, Deployment, Kubernetes, Resource-Optimization, Vertical-Scaling]\ndescription: Resource optimization configurations for different workload types\n---\nCommand-heavy service\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: order-command-service\nspec:\n  template:\n    spec:\n      containers:\nname: order-service\n        resources:\n          requests:\n            cpu: 500m      Higher CPU for command processing\n            memory: 512Mi\n          limits:\n            cpu: 2000m\n            memory: 1Gi\n---\nProjection-heavy service\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: analytics-projection-worker\nspec:\n  template:\n    spec:\n      containers:\nname: projection-worker\n        resources:\n          requests:\n            cpu: 200m\n            memory: 1Gi    Higher memory for projection state\n          limits:\n            cpu: 1000m\n            memory: 4Gi\n`\nBest Practices\nDeployment Guidelines\nStart simple - Begin with monolithic deployment, extract services as needed\nUse health checks - Implement comprehensive liveness and readiness probes\nPlan for scaling - Design with horizontal scaling in mind\nMonitor everything - Set up observability before going to production\nTest failure modes - Practice chaos engineering and disaster recovery\nConfiguration Management\nEnvironment parity - Keep development and production configs similar\nSecure secrets - Never store credentials in code or config files\nValidate on startup - Fail fast if configuration is invalid\nDocument settings - Maintain clear documentation of all configuration options\nVersion configurations - Track configuration changes alongside code\nOperational Excellence\nAutomate deployments - Use CI/CD pipelines for consistent deployments\nMonitor SLOs - Define and track service level objectives\nPlan for disasters - Regular backup and recovery testing\nCapacity planning - Monitor trends and plan for growth\nRegular maintenance - Schedule updates and maintenance windows\n---\nRelated Documentation\nObservability & Metrics - Production monitoring setup\nTesting & Development Tools - Testing deployment configurations\nAdvanced Features - Kubernetes operator features",
        "startIndex": 17257,
        "preview": "StructuredLogging = true; logging IncludeCorrelationIds = true; logging IncludeDomainContext = true; logging SanitizeSensitiveData = true; // Log leve..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "proposals/domain-ownership",
    "title": "Domain Ownership",
    "category": "Architecture & Design",
    "url": "/docs/proposals/domain-ownership",
    "chunks": [
      {
        "id": "proposals/domain-ownership-chunk-0",
        "text": "Domain Ownership\nWhizbang enforces explicit domain ownership to prevent distributed system chaos Every command and event has a clear owner, enabling proper routing, authorization, and system boundaries Ownership Determination Order\nDomain ownership is determined in user-configurable order, with this default precedence:\nNamespace Convention (highest priority)\nAttributes \nConfiguration-Driven (lowest priority)\nEach level can override previous levels, giving developers full control Namespace Convention (Default First)\nAutomatic ownership derived from namespace structure:\n`csharp{title=\"Namespace-Based Domain Ownership\" description=\"Automatic domain ownership derived from namespace structure\" category=\"Design\" difficulty=\"BEGINNER\" tags=[\"domain-ownership\", \"namespace-convention\", \"commands\", \"events\"] framework=\"NET8\"}\n// Orders domain\nnamespace MyApp Orders Commands {\n    public record PlaceOrder(Guid OrderId, Guid CustomerId, List<OrderItem> Items);\n    // Domain: \"Orders\" (extracted from namespace)\n}\nnamespace MyApp Orders Events {\n    public record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt);\n    // Domain: \"Orders\"\n}\n// Inventory domain  \nnamespace MyApp Inventory Commands {\n    public record ReserveStock(Guid ProductId, int Quantity);\n    // Domain: \"Inventory\"\n}\n`\nNamespace Policy Configuration\n`csharp{title=\"Namespace Policy Configuration\" description=\"Configuring namespace extraction policies for domain ownership\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"configuration\", \"namespace-policy\", \"setup\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options DomainOwnership(ownership => {\n        // Configure namespace extraction policies\n        ownership NamespacePolicy(policy => {\n            // Default: Extract domain from namespace segment\n            policy ExtractDomainFromNamespace = true;\n            policy DomainNamespacePosition = 1; // MyApp [Domain] Commands\n            // Custom extraction function\n            policy DomainExtractor = (type) => {\n                var segments = type Namespace Split(' ');\n                if (segments Length >= 3 && segments[1] == \"Domains\") {\n                    return segments[2]; // MyApp Domains [Domain] Commands\n                }\n                return segments Length >= 2 segments[1] : \"Default\";\n            };\n            // Namespace patterns\n            policy CommandNamespacePattern = \"* Commands\";\n            policy EventNamespacePattern = \"* Events\";\n            policy QueryNamespacePattern = \"*",
        "startIndex": 0,
        "preview": "Domain Ownership\nWhizbang enforces explicit domain ownership to prevent distributed system chaos Every command and event has a clear owner, enabling p..."
      },
      {
        "id": "proposals/domain-ownership-chunk-1",
        "text": "segments = type Namespace Split(' '); if (segments Length >= 3 && segments[1] == \"Domains\") { return segments[2]; // MyApp Domains [Domain] Commands } return segments Length >= 2 segments[1] : \"Default\"; }; // Namespace patterns policy CommandNamespacePattern = \"* Commands\"; policy EventNamespacePattern = \"* Events\"; policy QueryNamespacePattern = \"* Queries\";\n        });\n    });\n});\n`\nAttribute-Based Ownership\nExplicit declaration using attributes:\n`csharp{title=\"Attribute-Based Domain Ownership\" description=\"Explicit domain ownership declaration using attributes\" category=\"Design\" difficulty=\"BEGINNER\" tags=[\"domain-ownership\", \"attributes\", \"explicit-declaration\", \"override\"] framework=\"NET8\"}\n[OwnedBy(\"Orders\")]\npublic record PlaceOrder(Guid OrderId, Guid CustomerId, List<OrderItem> Items);\n[OwnedBy(\"Orders\")]\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt);\n// Override namespace convention\nnamespace MyApp Shared Commands {\n    [OwnedBy(\"Inventory\")] // Overrides \"Shared\" from namespace\n    public record ReserveStock(Guid ProductId, int Quantity);\n}\n`\nAttribute Policies\n`csharp{title=\"Attribute Policy Configuration\" description=\"Configuring attribute-based ownership policies\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"attribute-policy\", \"configuration\", \"custom-attributes\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options DomainOwnership(ownership => {\n        ownership AttributePolicy(policy => {\n            // Require explicit ownership for certain patterns\n            policy RequireExplicitOwnership<ICommand>();\n            policy RequireExplicitOwnership(type => type Name EndsWith(\"Command\"));\n            // Default ownership for unattributed types\n            policy DefaultDomain = \"Shared\";\n            // Custom attribute types\n            policy RecognizeAttribute<DomainAttribute>();\n            policy RecognizeAttribute<BoundedContextAttribute>();\n        });\n    });\n});\n`\nConfiguration-Driven Ownership\nCentralized registration in Program cs:\n`csharp{title=\"Configuration-Driven Ownership\" description=\"Centralized domain registration with explicit ownership\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"configuration\", \"domain-registration\", \"centralized-config\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options DomainOwnership(ownership => {\n        // Register domains with explicit ownership\n        ownership RegisterDomain(\"Orders\", domain => {\n            domain OwnsCommand<PlaceOrder>();\n            domain OwnsCommand<UpdateOrder>();\n            domain OwnsEvent<OrderPlaced>();\n            domain OwnsEvent<OrderUpdated>();\n            // Override other declarations\n            domain OwnsCommand<SpecialSharedCommand>(); // Takes from \"Shared\"\n        });\n        ownership RegisterDomain(\"Inventory\", domain => {\n            domain OwnsCommand<ReserveStock>();\n            domain OwnsCommand<ReleaseStock>();\n            domain OwnsEvent<StockReserved>();\n            domain",
        "startIndex": 2564,
        "preview": "segments = type Namespace Split(' '); if (segments Length >= 3 && segments[1] == \"Domains\") { return segments[2]; // MyApp Domains [Domain] Commands }..."
      },
      {
        "id": "proposals/domain-ownership-chunk-2",
        "text": "services AddWhizbang(options => { options DomainOwnership(ownership => { // Register domains with explicit ownership ownership RegisterDomain(\"Orders\", domain => { domain OwnsCommand<PlaceOrder>(); domain OwnsCommand<UpdateOrder>(); domain OwnsEvent<OrderPlaced>(); domain OwnsEvent<OrderUpdated>(); // Override other declarations domain OwnsCommand<SpecialSharedCommand>(); // Takes from \"Shared\" }); ownership RegisterDomain(\"Inventory\", domain => { domain OwnsCommand<ReserveStock>(); domain OwnsCommand<ReleaseStock>(); domain OwnsEvent<StockReserved>(); domain OwnsEvent<StockReleased>();\n        });\n    });\n});\n`\nInterface and Inheritance Policies\nInterface-Based Ownership\n`csharp{title=\"Interface-Based Ownership\" description=\"Interface-based domain ownership with marker interfaces\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"interface-based\", \"marker-interfaces\", \"configuration\"] framework=\"NET8\"}\n// Domain marker interfaces\npublic interface IOrderCommand : ICommand { }\npublic interface IInventoryCommand : ICommand { }\npublic record PlaceOrder( ) : IOrderCommand;\npublic record ReserveStock( ) : IInventoryCommand;\n// Configure interface-based ownership\nservices AddWhizbang(options => {\n    options DomainOwnership(ownership => {\n        ownership InterfacePolicy(policy => {\n            policy RegisterInterface<IOrderCommand>(\"Orders\");\n            policy RegisterInterface<IInventoryCommand>(\"Inventory\");\n            policy RegisterInterface<ISharedCommand>(\"Shared\");\n        });\n    });\n});\n`\nInheritance-Based Ownership\n`csharp{title=\"Inheritance-Based Ownership\" description=\"Inheritance-based domain ownership with base command classes\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"inheritance-based\", \"base-classes\", \"configuration\"] framework=\"NET8\"}\n// Base classes for domains\npublic abstract class OrderCommand : ICommand {\n    // Common order command properties\n}\npublic abstract class InventoryCommand : ICommand {\n    // Common inventory command properties  \n}\npublic class PlaceOrder : OrderCommand {\n    // Inherits \"Orders\" domain\n}\n// Configure inheritance-based ownership\nservices AddWhizbang(options => {\n    options DomainOwnership(ownership => {\n        ownership InheritancePolicy(policy => {\n            policy RegisterBaseClass<OrderCommand>(\"Orders\");\n            policy RegisterBaseClass<InventoryCommand>(\"Inventory\");\n        });\n    });\n});\n`\nCustom Ownership Precedence\nDeveloper controls the order of ownership determination:\n`csharp{title=\"Custom Ownership Precedence\" description=\"Custom ownership precedence order configuration\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"domain-ownership\", \"precedence-order\", \"configuration\", \"custom-rules\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options DomainOwnership(ownership => {\n        // Custom precedence order\n        ownership PrecedenceOrder(\n            DomainOwnershipSource Attributes,        // Check attributes first\n            DomainOwnershipSource Configuration,     // Then explicit config\n            DomainOwnershipSource Interfaces,        // Then interfaces\n            DomainOwnershipSource Inheritance,       // Then inheritance\n            DomainOwnershipSource Namespace          // Finally namespace\n        );\n        // Or use fluent API\n        ownership CheckAttributesFirst() ThenConfiguration() ThenInterfaces() ThenInheritance()",
        "startIndex": 5266,
        "preview": "services AddWhizbang(options => { options DomainOwnership(ownership => { // Register domains with explicit ownership ownership RegisterDomain(\"Orders\"..."
      },
      {
        "id": "proposals/domain-ownership-chunk-3",
        "text": "=> { options DomainOwnership(ownership => { // Custom precedence order ownership PrecedenceOrder( DomainOwnershipSource Attributes, // Check attributes first DomainOwnershipSource Configuration, // Then explicit config DomainOwnershipSource Interfaces, // Then interfaces DomainOwnershipSource Inheritance, // Then inheritance DomainOwnershipSource Namespace // Finally namespace ); // Or use fluent API ownership CheckAttributesFirst() ThenConfiguration() ThenInterfaces() ThenInheritance() FinallyNamespace();\n    });\n});\n`\nComplex Policy Examples\nMulti-Level Namespace Extraction\n`csharp{title=\"Multi-Level Namespace Extraction\" description=\"Multi-level namespace extraction with complex custom logic\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"domain-ownership\", \"namespace-extraction\", \"multi-level\", \"custom-logic\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options DomainOwnership(ownership => {\n        ownership NamespacePolicy(policy => {\n            policy DomainExtractor = (type) => {\n                var ns = type Namespace;\n                // MyApp Domains Orders Commands -> \"Orders\"\n                if (ns Contains(\" Domains \")) {\n                    var segments = ns Split(' ');\n                    var domainIndex = Array IndexOf(segments, \"Domains\") + 1;\n                    return domainIndex < segments Length segments[domainIndex] : \"Unknown\";\n                }\n                // MyApp Orders V2 Commands -> \"Orders\"\n                var parts = ns Split(' ');\n                if (parts Length >= 2) {\n                    return parts[1]; // Second segment is domain\n                }\n                return \"Default\";\n            };\n        });\n    });\n});\n`\nConditional Ownership Rules\n`csharp{title=\"Conditional Ownership Rules\" description=\"Conditional ownership rules based on type patterns and assemblies\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"domain-ownership\", \"conditional-rules\", \"assembly-based\", \"integration-events\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options DomainOwnership(ownership => {\n        ownership ConditionalRules(rules => {\n            // Integration events are always \"Shared\"\n            rules When(type => type Name EndsWith(\"IntegrationEvent\")) AssignToDomain(\"Shared\");\n            // Commands from external assemblies go to \"External\"\n            rules When(type => type Assembly GetName() Name StartsWith(\"MyApp\")) AssignToDomain(\"External\");\n            // Saga commands inherit from the saga's domain\n            rules When(type => typeof(ISagaCommand) IsAssignableFrom(type)) ExtractDomainFromProperty(\"SagaDomain\");\n        });\n    });\n});\n`\nAssembly-Based Policies\n`csharp{title=\"Assembly-Based Policies\" description=\"Assembly-based domain ownership with naming conventions\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"assembly-based\", \"assembly-mapping\", \"naming-convention\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options DomainOwnership(ownership => {\n        ownership AssemblyPolicy(policy => {\n            // Each assembly represents a domain\n            policy MapAssemblyToDomain(\"MyApp Orders\", \"Orders\");\n            policy MapAssemblyToDomain(\"MyApp Inventory\", \"Inventory\");\n            policy MapAssemblyToDomain(\"MyApp",
        "startIndex": 8208,
        "preview": "=> { options DomainOwnership(ownership => { // Custom precedence order ownership PrecedenceOrder( DomainOwnershipSource Attributes, // Check attribute..."
      },
      {
        "id": "proposals/domain-ownership-chunk-4",
        "text": "ExtractDomainFromProperty(\"SagaDomain\"); }); }); }); ` Assembly-Based Policies `csharp{title=\"Assembly-Based Policies\" description=\"Assembly-based domain ownership with naming conventions\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"assembly-based\", \"assembly-mapping\", \"naming-convention\"] framework=\"NET8\"} services AddWhizbang(options => { options DomainOwnership(ownership => { ownership AssemblyPolicy(policy => { // Each assembly represents a domain policy MapAssemblyToDomain(\"MyApp Orders\", \"Orders\"); policy MapAssemblyToDomain(\"MyApp Inventory\", \"Inventory\"); policy MapAssemblyToDomain(\"MyApp Shipping\", \"Shipping\");\n            // Assembly naming convention\n            policy ExtractDomainFromAssemblyName = true;\n            policy AssemblyNamePattern = \"MyApp {Domain}\";\n        });\n    });\n});\n`\nRuntime Ownership Resolution\nOwnership Discovery API\n`csharp{title=\"Domain Ownership Resolver API\" description=\"Domain ownership resolver API for runtime discovery\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"runtime-resolution\", \"api\", \"interface\"] framework=\"NET8\"}\npublic interface IDomainOwnershipResolver {\n    string ResolveDomain<T>();\n    string ResolveDomain(Type type);\n    bool IsDomainOwner<T>(string domain);\n    IEnumerable<string> GetAllDomains();\n    IEnumerable<Type> GetDomainTypes(string domain);\n}\n// Usage\n`csharp{title=\"Using Domain Ownership Resolver\" description=\"Example of using domain ownership resolver in a controller\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"controllers\", \"usage-example\", \"resolver\"] framework=\"NET8\"}\npublic class OrderController : ControllerBase {\n    private readonly IDomainOwnershipResolver _ownership;\n    public OrderController(IDomainOwnershipResolver ownership) {\n        _ownership = ownership;\n    }\n    public async Task<IActionResult> PlaceOrder(PlaceOrderRequest request) {\n        var domain = _ownership ResolveDomain<PlaceOrder>();\n        // domain = \"Orders\"\n        var command = new PlaceOrder(request OrderId, request CustomerId, request Items);\n        await _mediator Send(command);\n        return Ok();\n    }\n}\n`\nCompile-Time Validation\nRoslyn analyzer enforces ownership rules:\n`csharp{title=\"Compile-Time Validation\" description=\"Compile-time validation of domain ownership rules with Roslyn analyzers\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"domain-ownership\", \"compile-time-validation\", \"roslyn-analyzers\", \"source-generators\"] framework=\"NET8\"}\n// This will generate a compile error\n[OwnedBy(\"Orders\")]\npublic record PlaceOrder( );\n// In different assembly/project\npublic class InventoryHandler : ICommandHandler<PlaceOrder> {\n    // ERROR: InventoryHandler cannot handle PlaceOrder - different domains\n    public async Task Handle(PlaceOrder command) { }\n}\n`\nSource Generator Support\n`csharp{title=\"Auto-Generated Domain Registry\" description=\"Auto-generated domain ownership registry for runtime lookups\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"domain-ownership\", \"source-generation\", \"code-generation\", \"registry\"] framework=\"NET8\"}\n// Generated at compile time\n[GeneratedCode(\"Whizbang",
        "startIndex": 11060,
        "preview": "ExtractDomainFromProperty(\"SagaDomain\"); }); }); }); ` Assembly-Based Policies `csharp{title=\"Assembly-Based Policies\" description=\"Assembly-based dom..."
      },
      {
        "id": "proposals/domain-ownership-chunk-5",
        "text": "public class InventoryHandler : ICommandHandler<PlaceOrder> { // ERROR: InventoryHandler cannot handle PlaceOrder - different domains public async Task Handle(PlaceOrder command) { } } ` Source Generator Support `csharp{title=\"Auto-Generated Domain Registry\" description=\"Auto-generated domain ownership registry for runtime lookups\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"domain-ownership\", \"source-generation\", \"code-generation\", \"registry\"] framework=\"NET8\"} // Generated at compile time [GeneratedCode(\"Whizbang SourceGenerator\")]\npublic static class DomainOwnershipRegistry {\n    public static readonly Dictionary<Type, string> TypeToDomain = new() {\n        { typeof(PlaceOrder), \"Orders\" },\n        { typeof(OrderPlaced), \"Orders\" },\n        { typeof(ReserveStock), \"Inventory\" },\n        { typeof(StockReserved), \"Inventory\" }\n    };\n    public static readonly Dictionary<string, HashSet<Type>> DomainToTypes = new() {\n        { \"Orders\", new HashSet<Type> { typeof(PlaceOrder), typeof(OrderPlaced) } },\n        { \"Inventory\", new HashSet<Type> { typeof(ReserveStock), typeof(StockReserved) } }\n    };\n}\n`\nCommand Routing Based on Ownership\nIn-Process Routing\n`csharp{title=\"In-Process Command Routing\" description=\"Local command routing within the same domain service\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"routing\", \"in-process-communication\", \"local-handling\"] framework=\"NET8\"}\n// Same domain - route locally\nvar command = new PlaceOrder( );\nvar domain = _ownership ResolveDomain<PlaceOrder>(); // \"Orders\"\nvar handler = _serviceProvider GetRequiredService<ICommandHandler<PlaceOrder>>();\nawait handler Handle(command);\n`\nCross-Service Routing\n`csharp{title=\"Cross-Service Command Routing\" description=\"Cross-service command routing based on domain ownership\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"routing\", \"cross-service-communication\", \"message-broker\"] framework=\"NET8\"}\n// Different domain - route via message broker\nvar command = new ReserveStock( );\nvar domain = _ownership ResolveDomain<ReserveStock>(); // \"Inventory\"\nif (domain = _currentDomain) {\n    // Send to remote service\n    await _messageBroker SendToService(domain, command);\n} else {\n    // Handle locally\n    await _localMediator",
        "startIndex": 13613,
        "preview": "public class InventoryHandler : ICommandHandler<PlaceOrder> { // ERROR: InventoryHandler cannot handle PlaceOrder - different domains public async Tas..."
      },
      {
        "id": "proposals/domain-ownership-chunk-6",
        "text": "category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"routing\", \"cross-service-communication\", \"message-broker\"] framework=\"NET8\"} // Different domain - route via message broker var command = new ReserveStock( ); var domain = _ownership ResolveDomain<ReserveStock>(); // \"Inventory\" if (domain = _currentDomain) { // Send to remote service await _messageBroker SendToService(domain, command); } else { // Handle locally await _localMediator Send(command);\n}\n`\nBest Practices\nOwnership Guidelines\nBe explicit - Prefer attributes over conventions for critical commands\nConsistent patterns - Use the same ownership style within a domain\nDocument policies - Make namespace and interface conventions clear\nValidate early - Use analyzers to catch ownership violations\nMonitor boundaries - Track cross-domain communication patterns\nPolicy Design\nStart simple - Begin with namespace conventions\nAdd specificity - Use attributes for exceptions\nCentralize overrides - Use configuration for edge cases\nTest policies - Ensure ownership resolution works as expected\nVersion carefully - Changing ownership affects routing\n---\nRelated Documentation\nEvent Store & Projections - Storage architecture\nConcurrency Control - Managing concurrent updates  \nMulti-Tenancy - Tenant isolation with domain ownership",
        "startIndex": 15381,
        "preview": "category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"domain-ownership\", \"routing\", \"cross-service-communication\", \"message-broker\"] framework=\"NET8\"} //..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "proposals/event-store-projections",
    "title": "Event Store & Projection Architecture",
    "category": "Architecture & Design",
    "url": "/docs/proposals/event-store-projections",
    "chunks": [
      {
        "id": "proposals/event-store-projections-chunk-0",
        "text": "Event Store & Projection Architecture\nWhizbang implements a hybrid event store and projection architecture that separates event persistence from projection storage, enabling flexible schema evolution and high-performance querying",
        "startIndex": 0,
        "preview": "Event Store & Projection Architecture\nWhizbang implements a hybrid event store and projection architecture that separates event persistence from proje..."
      },
      {
        "id": "proposals/event-store-projections-chunk-1",
        "text": "Event Store & Projection Architecture Whizbang implements a hybrid event store and projection architecture that separates event persistence from projection storage, enabling flexible schema evolution and high-performance querying Core Architecture\nHybrid Storage Design\nEvents Table (Immutable Event Stream):\n`sql\n---\ncategory: Design\ndifficulty: INTERMEDIATE\ntags: [Design, Architecture, Event-Store, SQL, JSONB]\ndescription: SQL schema for events table with JSONB data storage\n---\nCREATE TABLE events (\n    event_id BIGSERIAL PRIMARY KEY,\n    stream_id VARCHAR(255) NOT NULL,\n    stream_version INT NOT NULL,\n    event_type VARCHAR(255) NOT NULL,\n    event_data JSONB NOT NULL,\n    metadata JSONB,\n    tenant_id VARCHAR(100),\n    created_at TIMESTAMPTZ NOT NULL,\n    UNIQUE(stream_id, stream_version)\n);\nCREATE INDEX idx_stream ON events(stream_id);\nCREATE INDEX idx_type ON events(event_type);\nCREATE INDEX idx_tenant ON events(tenant_id) WHERE tenant_id IS NOT NULL;\n`\nProjections Tables (Mutable JSONB Documents):\n`sql\n---\ncategory: Design\ndifficulty: INTERMEDIATE\ntags: [Design, Architecture, Projections, SQL, JSONB]\ndescription: SQL schema for projections table with mutable JSONB documents\n---\nCREATE TABLE projections (\n    projection_name VARCHAR(255) NOT NULL,\n    document_id VARCHAR(255) NOT NULL,\n    document JSONB NOT NULL,\n    tenant_id VARCHAR(100),\n    version BIGINT NOT NULL,\n    last_updated TIMESTAMPTZ NOT NULL,\n    PRIMARY KEY (projection_name, document_id, COALESCE(tenant_id, ''))\n);\nCREATE INDEX idx_projection_tenant ON projections(projection_name, tenant_id);\n`\nBenefits of Hybrid Approach\nEvents are immutable - Perfect audit trail, never changes\nProjections are mutable - Can be rebuilt, schema can evolve\nJSONB flexibility - No schema migrations for projection changes\nPerformance optimization - Events optimized for append, projections for queries\nIndependent scaling - Different databases/drivers for events vs projections\nProjection Management\nSchema-Free Evolution\n`csharp{\ntitle: \"Schema Evolution Example\",\ndescription: \"Schema evolution example showing projection changes without migrations\",\ncategory: \"Design\",\ndifficulty: \"INTERMEDIATE\",\ntags: [\"Design\", \"Projections\", \"Schema-Evolution\", \"Domain-Models\"],\nframework: \"NET8\"\n}\n// V1 Projection\npublic class OrderSummaryProjection {\n    public Guid OrderId { get; set; }\n    public decimal Total { get; set; }\n    public OrderStatus Status { get; set; }\n}\n// V2 Projection - Add fields without migration\npublic class OrderSummaryProjection {\n    public Guid OrderId { get; set; }\n    public decimal Total { get; set; }\n    public OrderStatus Status { get; set; }\n    public DateTime EstimatedDelivery { get; set; }  // New field\n    public List<string> Tags { get; set; } = new();   // New collection\n}\n`\nNo database migration required - JSONB handles missing fields gracefully",
        "startIndex": 231,
        "preview": "Event Store & Projection Architecture Whizbang implements a hybrid event store and projection architecture that separates event persistence from proje..."
      },
      {
        "id": "proposals/event-store-projections-chunk-2",
        "text": "set; } public decimal Total { get; set; } public OrderStatus Status { get; set; } public DateTime EstimatedDelivery { get; set; } // New field public List<string> Tags { get; set; } = new(); // New collection } ` No database migration required - JSONB handles missing fields gracefully Atomic Projection Rebuilds\nWhizbang supports zero-downtime projection rebuilds using temporary table swapping:\n`csharp{\ntitle: \"Atomic Projection Rebuild Configuration\",\ndescription: \"Configuration for atomic projection rebuilds with zero downtime\",\ncategory: \"Design\",\ndifficulty: \"INTERMEDIATE\",\ntags: [\"Design\", \"Projections\", \"Configuration\", \"Atomic-Operations\"],\nframework: \"NET8\"\n}\nservices AddProjection<OrderSummaryProjection>(options => {\n    options RebuildStrategy = RebuildStrategy AtomicSwap;\n});\n// Rebuild process:\n// 1 Create temporary table: projections_ordersummary_temp\n// 2 Build new projection in temp table from events\n// 3 Atomic swap: RENAME projections_ordersummary TO projections_ordersummary_old,\n//                  projections_ordersummary_temp TO projections_ordersummary\n// 4 Drop old table\n`\nProjection Drivers\nProjections use driver-based storage for flexibility:\n`csharp{\ntitle: \"Projection Driver Configuration\",\ndescription: \"Driver configuration for different projection storage backends\",\ncategory: \"Design\",\ndifficulty: \"BEGINNER\",\ntags: [\"Design\", \"Configuration\", \"Drivers\", \"PostgreSQL\", \"MongoDB\"],\nframework: \"NET8\"\n}\n// PostgreSQL JSONB Driver (default)\nservices AddWhizbang(options => {\n    options UsePostgresProjections(connectionString);\n});\n// SQL Server JSON Driver\nservices AddWhizbang(options => {\n    options UseSqlServerProjections(connectionString);\n});\n// MongoDB Driver\nservices AddWhizbang(options => {\n    options UseMongoProjections(connectionString);\n});\n// Custom Driver\nservices AddWhizbang(options => {\n    options",
        "startIndex": 2874,
        "preview": "set; } public decimal Total { get; set; } public OrderStatus Status { get; set; } public DateTime EstimatedDelivery { get; set; } // New field public ..."
      },
      {
        "id": "proposals/event-store-projections-chunk-3",
        "text": "[\"Design\", \"Configuration\", \"Drivers\", \"PostgreSQL\", \"MongoDB\"], framework: \"NET8\" } // PostgreSQL JSONB Driver (default) services AddWhizbang(options => { options UsePostgresProjections(connectionString); }); // SQL Server JSON Driver services AddWhizbang(options => { options UseSqlServerProjections(connectionString); }); // MongoDB Driver services AddWhizbang(options => { options UseMongoProjections(connectionString); }); // Custom Driver services AddWhizbang(options => { options UseProjectionDriver<MyCustomDriver>();\n});\n`\nSnapshotting\nSmart Replay with Snapshots\nWhizbang supports snapshot-assisted replays to reduce replay overhead:\n`csharp{\ntitle: \"Aggregate with Automatic Snapshotting\",\ndescription: \"Aggregate with automatic snapshotting for replay optimization\",\ncategory: \"Design\",\ndifficulty: \"INTERMEDIATE\",\ntags: [\"Design\", \"Aggregates\", \"Snapshots\", \"Performance\"],\nframework: \"NET8\"\n}\npublic class OrderAggregate : Aggregate {\n    public Guid Id { get; private set; }\n    public decimal Total { get; private set; }\n    public List<OrderItem> Items { get; private set; } = new();\n    // Automatic snapshots every 100 events\n    [Snapshot(Every = 100)]\n    public OrderSnapshot CreateSnapshot() {\n        return new OrderSnapshot {\n            Id = Id,\n            Total = Total,\n            Items = Items ToList()\n        };\n    }\n    // Restore from snapshot\n    public void RestoreFromSnapshot(OrderSnapshot snapshot) {\n        Id = snapshot Id;\n        Total = snapshot Total;\n        Items = snapshot",
        "startIndex": 4459,
        "preview": "[\"Design\", \"Configuration\", \"Drivers\", \"PostgreSQL\", \"MongoDB\"], framework: \"NET8\" } // PostgreSQL JSONB Driver (default) services AddWhizbang(options..."
      },
      {
        "id": "proposals/event-store-projections-chunk-4",
        "text": "new(); // Automatic snapshots every 100 events [Snapshot(Every = 100)] public OrderSnapshot CreateSnapshot() { return new OrderSnapshot { Id = Id, Total = Total, Items = Items ToList() }; } // Restore from snapshot public void RestoreFromSnapshot(OrderSnapshot snapshot) { Id = snapshot Id; Total = snapshot Total; Items = snapshot Items;\n    }\n}\n`\nSnapshot Storage\n`sql\n---\ncategory: Design\ndifficulty: INTERMEDIATE\ntags: [Design, Snapshots, SQL, Performance]\ndescription: SQL schema for snapshot storage with JSONB data\n---\nCREATE TABLE snapshots (\n    stream_id VARCHAR(255) NOT NULL,\n    snapshot_version BIGINT NOT NULL,\n    snapshot_data JSONB NOT NULL,\n    tenant_id VARCHAR(100),\n    created_at TIMESTAMPTZ NOT NULL,\n    PRIMARY KEY (stream_id, snapshot_version)\n);\n`\nReplay Strategy\nWhen replaying events for projection rebuilds:\nFind closest snapshot ≤ starting event number\nRestore snapshot if available\nReplay remaining events from snapshot version to target\nNon-atomic replays only - atomic replays always start from beginning\n`csharp{\ntitle: \"Smart Replay Strategy\",\ndescription: \"Smart replay strategy using snapshots to reduce event processing\",\ncategory: \"Design\",\ndifficulty: \"ADVANCED\",\ntags: [\"Design\", \"Snapshots\", \"Replay\", \"Performance-Optimization\"],\nframework: \"NET8\"\n}\n// Smart replay from event #50,000\nvar snapshot = await snapshotStore GetLatestBefore(streamId, eventNumber: 50000);\nif (snapshot = null && snapshot Version >= 49900) { // Within 100 events\n    aggregate RestoreFromSnapshot(snapshot);\n    var events = await eventStore ReadFrom(streamId, snapshot Version + 1, 50000);\n} else {\n    var events = await eventStore ReadFrom(streamId, 0, 50000);\n}\n`\nImplementation Details\nProjection Handler Registration\n`csharp{\ntitle: \"Projection Handler Implementation\",\ndescription: \"Projection handler implementation for multiple event types\",\ncategory: \"Design\",\ndifficulty: \"INTERMEDIATE\",\ntags: [\"Design\", \"Projections\", \"Event-Handlers\", \"Domain-Logic\"],\nframework: \"NET8\"\n}\npublic class OrderSummaryProjection : IProjectionHandler<OrderPlaced>,\n                                     IProjectionHandler<OrderUpdated>,\n                                     IProjectionHandler<OrderShipped> {\n    public async Task Handle(OrderPlaced @event, ProjectionContext context) {\n        var summary = new OrderSummary {\n            OrderId = @event OrderId,\n            Total = @event Total,\n            Status = OrderStatus Placed,\n            CustomerId = @event CustomerId\n        };\n        await context Store(summary OrderId",
        "startIndex": 5498,
        "preview": "new(); // Automatic snapshots every 100 events [Snapshot(Every = 100)] public OrderSnapshot CreateSnapshot() { return new OrderSnapshot { Id = Id, Tot..."
      },
      {
        "id": "proposals/event-store-projections-chunk-5",
        "text": "[\"Design\", \"Projections\", \"Event-Handlers\", \"Domain-Logic\"], framework: \"NET8\" } public class OrderSummaryProjection : IProjectionHandler<OrderPlaced>, IProjectionHandler<OrderUpdated>, IProjectionHandler<OrderShipped> { public async Task Handle(OrderPlaced @event, ProjectionContext context) { var summary = new OrderSummary { OrderId = @event OrderId, Total = @event Total, Status = OrderStatus Placed, CustomerId = @event CustomerId }; await context Store(summary OrderId ToString(), summary);\n    }\n    public async Task Handle(OrderUpdated @event, ProjectionContext context) {\n        var summary = await context Load<OrderSummary>(@event OrderId ToString());\n        if (summary = null) {\n            summary Total = @event NewTotal;\n            summary Items = @event UpdatedItems;\n            await context Store(@event OrderId ToString(), summary);\n        }\n    }\n}\n`\nProjection Configuration\n`csharp{\ntitle: \"Advanced Projection Configuration\",\ndescription: \"Advanced projection configuration with partitioning and rebuild strategies\",\ncategory: \"Design\",\ndifficulty: \"INTERMEDIATE\",\ntags: [\"Design\", \"Projections\", \"Configuration\", \"Multi-Tenancy\"],\nframework: \"NET8\"\n}\nservices AddProjection<OrderSummaryProjection>(projection => {\n    projection ProjectionName = \"order-summary\";\n    projection PartitionBy = order => order CustomerId; // Multi-tenant partitioning\n    projection SnapshotStrategy = SnapshotStrategy Automatic;\n    projection RebuildStrategy = RebuildStrategy AtomicSwap;\n    projection CheckpointStorage = CheckpointStorage SameDatabase;\n});\n`\nDriver Interface\n`csharp{\ntitle: \"Projection Driver Interface\",\ndescription: \"Projection driver interface for pluggable storage backends\",\ncategory: \"Design\",\ndifficulty: \"ADVANCED\",\ntags: [\"Design\", \"Drivers\", \"Interfaces\", \"Architecture\"],\nframework: \"NET8\"\n}\npublic interface IProjectionDriver {\n    Task Store<T>(string projectionName, string documentId, T document, string tenantId = null);\n    Task<T > Load<T>(string projectionName, string documentId, string tenantId = null);\n    Task Delete(string projectionName, string documentId, string tenantId = null);\n    // Querying support\n    Task<IEnumerable<T>> Query<T>(string projectionName, Expression<Func<T, bool>> predicate, string tenantId = null);\n    Task<IEnumerable<T>> QueryAll<T>(string projectionName, string tenantId = null);\n    // Rebuild support\n    Task<string> CreateTemporaryProjectionTable(string projectionName);\n    Task SwapProjectionTables(string projectionName, string temporaryTableName);\n    Task DropProjectionTable(string tableName);\n}\n`\nMulti-Database Support\nEvents and Projections in Different Databases\n`csharp{\ntitle: \"Multi-Database Configuration\",\ndescription: \"Configuration for separating events and projections across different databases\",\ncategory: \"Design\",\ndifficulty: \"ADVANCED\",\ntags: [\"Design\", \"Configuration\", \"Multi-Database\", \"Architecture\"],\nframework: \"NET8\"\n}\nservices AddWhizbang(options => {\n    // Events in PostgreSQL\n    options",
        "startIndex": 7719,
        "preview": "[\"Design\", \"Projections\", \"Event-Handlers\", \"Domain-Logic\"], framework: \"NET8\" } public class OrderSummaryProjection : IProjectionHandler<OrderPlaced>..."
      },
      {
        "id": "proposals/event-store-projections-chunk-6",
        "text": "string temporaryTableName); Task DropProjectionTable(string tableName); } ` Multi-Database Support Events and Projections in Different Databases `csharp{ title: \"Multi-Database Configuration\", description: \"Configuration for separating events and projections across different databases\", category: \"Design\", difficulty: \"ADVANCED\", tags: [\"Design\", \"Configuration\", \"Multi-Database\", \"Architecture\"], framework: \"NET8\" } services AddWhizbang(options => { // Events in PostgreSQL options UsePostgresEventStore(\"Host=events-db;Database=events\");\n    // Projections in MongoDB\n    options UseMongoProjections(\"mongodb://projections-cluster\");\n    // Or projections in separate PostgreSQL instance\n    options UsePostgresProjections(\"Host=projections-db;Database=projections\");\n});\n`\nPerformance Benefits\nEvents database optimized for writes (append-only)\nProjections database optimized for reads (complex queries)\nIndependent scaling of read vs write workloads\nDifferent drivers for different use cases\nBest Practices\nProjection Design\nKeep projections focused - One projection per use case\nDenormalize for queries - Include all needed data\nUse tenant partitioning - For multi-tenant scenarios\nVersion projections - For breaking changes\nSnapshot Guidelines\nSnapshot long-lived aggregates - Orders, customers, accounts\nDon't snapshot short-lived aggregates - Shopping carts, sessions\nConsider snapshot frequency - Balance storage vs replay speed\nTest snapshot restore - Ensure snapshots work correctly\nRebuild Strategies\nUse atomic swaps for production rebuilds\nUse in-place updates for development\nMonitor rebuild progress with checkpoints\nValidate rebuilt projections before swapping\n---\nRelated Documentation\nConcurrency Control - How concurrency is managed\nMulti-Tenancy - Tenant isolation strategies\nPerformance Optimization - Scaling and tuning",
        "startIndex": 10267,
        "preview": "string temporaryTableName); Task DropProjectionTable(string tableName); } ` Multi-Database Support Events and Projections in Different Databases `csha..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "proposals/flags-tags-system",
    "title": "Flags & Tags System",
    "category": "Architecture & Design",
    "url": "/docs/proposals/flags-tags-system",
    "chunks": [
      {
        "id": "proposals/flags-tags-system-chunk-0",
        "text": "Flags & Tags System\nWhizbang provides a sophisticated flags and tags system for message context, enabling dynamic behavior modification, cross-service debugging, and flexible routing throughout the entire message lifecycle Core Concepts\nFlags (Library-Defined)\nHardcoded enum flags provided by Whizbang for common scenarios:\n`csharp{title=\"WhizbangFlags Enum Definition\" description=\"Library-defined flags enum for common development and operational scenarios\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Message-Context\", \"Cross-Service-Communication\"] framework=\"NET8\"}\n[Flags]\npublic enum WhizbangFlags : long {\n    None = 0,\n    // Testing & Development\n    LoadTesting = 1 << 0,           // Don't replay these events\n    DryRun = 1 << 1,                // Execute handlers but don't persist\n    Development = 1 << 2,           // Development mode behaviors\n    TraceReplay = 1 << 3,           // Replay/trace mode\n    // Debugging & Inspection\n    VerboseLogging = 1 << 4,        // Increase logging verbosity\n    VerboseOtel = 1 << 5,           // Increase OpenTelemetry verbosity\n    IgnoreTimeouts = 1 << 6,        // Bypass timeouts for debugging\n    CursorMode = 1 << 7,            // IDE cursor/scrubbing mode\n    Breakpoint = 1 << 8,            // Trigger breakpoints\n    // Security & Compliance\n    SecurityBypass = 1 << 9,        // Bypass security checks (dangerous)\n    DataScrubbing = 1 << 10,        // Scrub sensitive data\n    ComplianceMode = 1 << 11,       // Extra compliance logging\n    // Routing & Delivery\n    AlternativeRouting = 1 << 12,   // Use alternative handlers\n    PriorityDelivery = 1 << 13,     // Expedite processing\n    DelayedProcessing = 1 << 14,    // Defer processing\n    // Environment & Lifecycle\n    Production = 1 << 15,           // Production environment\n    Staging = 1 << 16,              // Staging environment\n    QA = 1 << 17,                   // QA environment\n    Migration = 1 << 18,            // Data migration context\n    // Custom ranges for user-defined flags\n    UserDefined1 = 1 << 32,\n    UserDefined2 = 1 << 33,\n    //",
        "startIndex": 0,
        "preview": "Flags & Tags System\nWhizbang provides a sophisticated flags and tags system for message context, enabling dynamic behavior modification, cross-service..."
      },
      {
        "id": "proposals/flags-tags-system-chunk-1",
        "text": "Production = 1 << 15, // Production environment Staging = 1 << 16, // Staging environment QA = 1 << 17, // QA environment Migration = 1 << 18, // Data migration context // Custom ranges for user-defined flags UserDefined1 = 1 << 32, UserDefined2 = 1 << 33, // up to 1 << 63\n}\n`\nTags (User-Defined)\nArbitrary string tags added by developers for custom scenarios:\n`csharp{title=\"MessageContext with Fluent API\" description=\"Message context class with fluent API for flags and tags management\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Message-Context\", \"Fluent-API\"] framework=\"NET8\"}\npublic class MessageContext {\n    public WhizbangFlags Flags { get; set; }\n    public HashSet<string> Tags { get; set; } = new();\n    public string CorrelationId { get; set; }\n    public string TenantId { get; set; }\n    public string Domain { get; set; }\n    // Fluent API for context building\n    public MessageContext WithTag(string tag) {\n        Tags Add(tag);\n        return this;\n    }\n    public MessageContext WithFlags(WhizbangFlags flags) {\n        Flags |= flags;\n        return this;\n    }\n    public MessageContext WithCorrelationId(string correlationId) {\n        CorrelationId = correlationId;\n        return this;\n    }\n    public bool HasFlag(WhizbangFlags flag) => (Flags & flag) == flag;\n    public bool HasTag(string tag) => Tags Contains(tag);\n    public bool HasAnyTag(params string[] tags) => tags Any(Tags Contains);\n    public bool HasAllTags(params string[] tags) => tags All(Tags Contains);\n}\n// Usage examples\ncontext WithTag(\"customer-priority\") WithTag(\"region-us-west\") WithTag(\"high-value-order\") WithFlags(WhizbangFlags VerboseLogging | WhizbangFlags PriorityDelivery) WithCorrelationId(\"debug-session-123\");\n`\nCross-Service Propagation\nAutomatic Flag Propagation\nFlags carry through entire message journey across service boundaries:\n`csharp{title=\"Cross-Service Flag Propagation\" description=\"Automatic flag and tag propagation across service boundaries\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Cross-Service-Propagation\", \"Debugging\"] framework=\"NET8\"}\n// Service 1: Initial command with debugging flags\nvar command = new PlaceOrder(orderId, customerId, items);\nawait _mediator Send(command, context => {\n    context WithFlags(WhizbangFlags VerboseLogging | WhizbangFlags TraceReplay) WithTag(\"debug-session-123\") WithTag(\"customer-vip\");\n});\n// Flags automatically propagate to:\n// 1 Command handler execution in Service 1\n// 2",
        "startIndex": 2124,
        "preview": "Production = 1 << 15, // Production environment Staging = 1 << 16, // Staging environment QA = 1 << 17, // QA environment Migration = 1 << 18, // Data..."
      },
      {
        "id": "proposals/flags-tags-system-chunk-2",
        "text": "tags=[\"Design\", \"Flags-Tags\", \"Cross-Service-Propagation\", \"Debugging\"] framework=\"NET8\"} // Service 1: Initial command with debugging flags var command = new PlaceOrder(orderId, customerId, items); await _mediator Send(command, context => { context WithFlags(WhizbangFlags VerboseLogging | WhizbangFlags TraceReplay) WithTag(\"debug-session-123\") WithTag(\"customer-vip\"); }); // Flags automatically propagate to: // 1 Command handler execution in Service 1 // 2 Event publishing from Service 1\n// 3 Cross-service event delivery via message broker\n// 4 Event handler execution in Service 2\n// 5 Projection updates in Service 2\n// 6 Saga execution across services\n`csharp{title=\"Context-Aware Event Handler\" description=\"Event handler using propagated flags and tags for conditional processing\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Event-Handlers\", \"Context-Aware-Processing\"] framework=\"NET8\"}\n// Service 2: Receives event with same flags and tags\npublic class InventoryHandler : IEventHandler<OrderPlaced> {\n    public async Task Handle(OrderPlaced @event, EventContext context) {\n        // context Flags contains VerboseLogging | TraceReplay\n        // context Tags contains \"debug-session-123\", \"customer-vip\"\n        if (context HasFlag(WhizbangFlags VerboseLogging)) {\n            _logger LogInformation(\"Processing order with verbose logging enabled for debug session {DebugSession}\", \n                context Tags FirstOrDefault(t => t StartsWith(\"debug-session\")));\n        }\n        if (context HasTag(\"customer-vip\")) {\n            // Special handling for VIP customers\n            await _vipCustomerService NotifyOrderReceived(@event OrderId);\n        }\n    }\n}\n`\nMessage Context Serialization\nContext travels with messages across all transport mechanisms:\n`csharp{title=\"Message Envelope for Cross-Service Communication\" description=\"Message envelope with context serialization for cross-service communication\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Message-Serialization\", \"Cross-Service\"] framework=\"NET8\"}\n// Message envelope for cross-service communication\npublic class MessageEnvelope<T> {\n    public T Message { get; set; }\n    public MessageContext Context { get; set; }\n    public Dictionary<string, string> Headers { get; set; } = new();\n    public DateTimeOffset Timestamp { get; set; } = DateTimeOffset",
        "startIndex": 4441,
        "preview": "tags=[\"Design\", \"Flags-Tags\", \"Cross-Service-Propagation\", \"Debugging\"] framework=\"NET8\"} // Service 1: Initial command with debugging flags var comma..."
      },
      {
        "id": "proposals/flags-tags-system-chunk-3",
        "text": "category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Message-Serialization\", \"Cross-Service\"] framework=\"NET8\"} // Message envelope for cross-service communication public class MessageEnvelope<T> { public T Message { get; set; } public MessageContext Context { get; set; } public Dictionary<string, string> Headers { get; set; } = new(); public DateTimeOffset Timestamp { get; set; } = DateTimeOffset UtcNow;\n}\n`csharp{title=\"Kafka Message Publisher\" description=\"Kafka message publisher with automatic context serialization\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Kafka\", \"Message-Brokers\"] framework=\"NET8\"}\n// Automatic context serialization in message brokers\npublic class KafkaMessagePublisher : IMessagePublisher {\n    public async Task PublishAsync<T>(T message, MessageContext context) {\n        var envelope = new MessageEnvelope<T> {\n            Message = message,\n            Context = context,\n            Headers = new Dictionary<string, string> {\n                [\"whizbang-flags\"] = ((long)context Flags) ToString(),\n                [\"whizbang-tags\"] = string Join(\",\", context Tags),\n                [\"whizbang-correlation-id\"] = context CorrelationId \"\",\n                [\"whizbang-tenant-id\"] = context TenantId \"\",\n                [\"whizbang-domain\"] = context Domain \"\"\n            }\n        };\n        await _kafkaProducer ProduceAsync(GetTopicName<T>(), envelope);\n    }\n}\n`\nDebugging and Development Features\nIDE Cursor/Scrubbing Mode\nInteractive debugging with state inspection:\n`csharp{title=\"IDE Cursor Mode Handler\" description=\"IDE integration for interactive debugging with state inspection\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Flags-Tags\", \"IDE-Integration\", \"Debugging\", \"Cursor-Mode\"] framework=\"NET8\"}\n// IDE integration for step-by-step debugging\npublic class CursorModeHandler : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        if (context HasFlag(WhizbangFlags CursorMode)) {\n            // Capture pre-execution state\n            var preState = await _stateCapture CaptureStateAsync(context);\n            // Notify IDE of execution point\n            await _ideNotificationService NotifyExecutionPoint(new ExecutionPoint {\n                MessageType = typeof(TRequest) Name,\n                HandlerType = context HandlerType Name,\n                CorrelationId = context CorrelationId,\n                State = preState,\n                CanStepForward = true,\n                CanStepBackward = true\n            });\n            // Wait for IDE to signal continue\n            await _ideNotificationService WaitForContinueSignal(context CorrelationId);\n        }\n        var response = await next(message, context);\n        if (context HasFlag(WhizbangFlags CursorMode)) {\n            // Capture post-execution state\n            var postState = await _stateCapture CaptureStateAsync(context);\n            await _ideNotificationService NotifyExecutionComplete(new ExecutionResult {\n                CorrelationId = context CorrelationId,\n                Response = response,\n                PostState = postState,\n                ExecutionTime = context",
        "startIndex": 6383,
        "preview": "category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Message-Serialization\", \"Cross-Service\"] framework=\"NET8\"} // Message envel..."
      },
      {
        "id": "proposals/flags-tags-system-chunk-4",
        "text": "Wait for IDE to signal continue await _ideNotificationService WaitForContinueSignal(context CorrelationId); } var response = await next(message, context); if (context HasFlag(WhizbangFlags CursorMode)) { // Capture post-execution state var postState = await _stateCapture CaptureStateAsync(context); await _ideNotificationService NotifyExecutionComplete(new ExecutionResult { CorrelationId = context CorrelationId, Response = response, PostState = postState, ExecutionTime = context ExecutionTime\n            });\n        }\n        return response;\n    }\n}\n`\nBreakpoint System\nProgrammatic breakpoints triggered by flags:\n`csharp{title=\"Programmatic Breakpoint Handler\" description=\"Programmatic breakpoint system triggered by flags for debugging\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Flags-Tags\", \"Debugging\", \"Breakpoints\", \"Development-Tools\"] framework=\"NET8\"}\npublic class BreakpointHandler : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        if (context HasFlag(WhizbangFlags Breakpoint)) {\n            var breakpointContext = new BreakpointContext {\n                BreakpointId = Guid NewGuid(),\n                MessageType = typeof(TRequest) Name,\n                Message = message,\n                Context = context,\n                StackTrace = Environment StackTrace,\n                Timestamp = DateTimeOffset UtcNow\n            };\n            // Store breakpoint information\n            await _breakpointStore StoreBreakpointAsync(breakpointContext);\n            // Notify debugging tools\n            await _debuggerNotificationService NotifyBreakpointHit(breakpointContext);\n            // Optionally pause execution for attached debuggers\n            if (_debuggerService IsAttached) {\n                System Diagnostics Debugger Break();\n            }\n        }\n        return await next(message, context);\n    }\n}\n`\nData Scrubbing and Security\nAutomatic Data Scrubbing\nPolicy-driven data sanitization based on flags:\n`csharp{title=\"Data Scrubbing Interceptor\" description=\"Policy-driven data sanitization based on flags for security compliance\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Flags-Tags\", \"Data-Scrubbing\", \"Security\", \"Privacy\"] framework=\"NET8\"}\npublic class DataScrubbingInterceptor : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        TRequest processedMessage = message;\n        if (context HasFlag(WhizbangFlags DataScrubbing)) {\n            // Apply data scrubbing rules\n            processedMessage = await _dataScrubber ScrubAsync(message, new ScrubOptions {\n                ScrubPersonalData = true,\n                ScrubFinancialData = true,\n                ScrubSensitiveFields = true,\n                PreserveFunctionality = true,\n                AddScrubbedMarkers = true\n            });\n            // Add scrubbing metadata to context\n            context Tags Add(\"data-scrubbed\");\n            context Tags Add($\"scrubbed-at-{DateTimeOffset",
        "startIndex": 9298,
        "preview": "Wait for IDE to signal continue await _ideNotificationService WaitForContinueSignal(context CorrelationId); } var response = await next(message, conte..."
      },
      {
        "id": "proposals/flags-tags-system-chunk-5",
        "text": "TRequest processedMessage = message; if (context HasFlag(WhizbangFlags DataScrubbing)) { // Apply data scrubbing rules processedMessage = await _dataScrubber ScrubAsync(message, new ScrubOptions { ScrubPersonalData = true, ScrubFinancialData = true, ScrubSensitiveFields = true, PreserveFunctionality = true, AddScrubbedMarkers = true }); // Add scrubbing metadata to context context Tags Add(\"data-scrubbed\"); context Tags Add($\"scrubbed-at-{DateTimeOffset UtcNow:yyyy-MM-dd-HH-mm-ss}\");\n        }\n        return await next(processedMessage, context);\n    }\n}\n`csharp{title=\"Order Data Scrubber Implementation\" description=\"Concrete data scrubber implementation for order data sanitization\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Data-Scrubbing\", \"Implementation\"] framework=\"NET8\"}\n// Data scrubbing rules\npublic class OrderDataScrubber : IDataScrubber<PlaceOrder> {\n    public async Task<PlaceOrder> ScrubAsync(PlaceOrder order, ScrubOptions options) {\n        return order with {\n            // Scrub customer email\n            CustomerEmail = options ScrubPersonalData ScrubEmail(order CustomerEmail) : order CustomerEmail,\n            // Scrub payment information\n            PaymentToken = options ScrubFinancialData \"[SCRUBBED-PAYMENT-TOKEN]\" : order PaymentToken,\n            // Preserve order structure but scrub sensitive data\n            Items = order Items Select(item => item with {\n                ProductName = options PreserveFunctionality item ProductName : $\"Product-{item ProductId ToString()[ 8]}\"\n            }) ToList()\n        };\n    }\n}\n`\nProduction to QA Data Flow\nSecure data replication with automatic scrubbing:\n`csharp{title=\"Production to QA Data Replicator\" description=\"Secure data replication from production to QA with automatic scrubbing\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Flags-Tags\", \"Production-to-QA\", \"Data-Replication\"] framework=\"NET8\"}\n// Handler that duplicates production messages to QA with scrubbing\npublic class ProductionToQAReplicator : IEventHandler<object> {\n    public async Task Handle(object @event, EventContext context) {\n        // Only replicate events tagged for QA replication\n        if (context HasTag(\"production-data\") && \n            context HasFlag(WhizbangFlags QA)) {\n            // Create a copy with scrubbing flag\n            var qaCopy = @event;\n            var qaContext = context Copy() WithFlag(WhizbangFlags DataScrubbing) WithTag(\"qa-replicated\") WithTag($\"replicated-from-production-{DateTimeOffset UtcNow:yyyy-MM-dd}\");\n            // Remove production-specific tags\n            qaContext Tags Remove(\"production-data\");\n            qaContext Tags Remove(\"customer-vip\"); // Don't carry VIP status to QA\n            // Route to QA environment\n            await _qaEventPublisher",
        "startIndex": 12060,
        "preview": "TRequest processedMessage = message; if (context HasFlag(WhizbangFlags DataScrubbing)) { // Apply data scrubbing rules processedMessage = await _dataS..."
      },
      {
        "id": "proposals/flags-tags-system-chunk-6",
        "text": "&& context HasFlag(WhizbangFlags QA)) { // Create a copy with scrubbing flag var qaCopy = @event; var qaContext = context Copy() WithFlag(WhizbangFlags DataScrubbing) WithTag(\"qa-replicated\") WithTag($\"replicated-from-production-{DateTimeOffset UtcNow:yyyy-MM-dd}\"); // Remove production-specific tags qaContext Tags Remove(\"production-data\"); qaContext Tags Remove(\"customer-vip\"); // Don't carry VIP status to QA // Route to QA environment await _qaEventPublisher PublishAsync(qaCopy, qaContext);\n        }\n    }\n}\n`\nPerformance and Load Testing\nLoad Testing Flag Handling\nOptimize behavior for load testing scenarios:\n`csharp{title=\"Load Testing Optimizer\" description=\"Load testing optimization interceptor with flag-based behavior modification\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Load-Testing\", \"Performance-Optimization\"] framework=\"NET8\"}\npublic class LoadTestingOptimizer : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        if (context HasFlag(WhizbangFlags LoadTesting)) {\n            // Optimize for load testing\n            using var loadTestScope = _performanceOptimizer EnterLoadTestMode();\n            // Disable slow operations\n            context Tags Add(\"skip-audit-logging\");\n            context Tags Add(\"skip-analytics-tracking\");\n            context Tags Add(\"minimal-validation\");\n            // Add load test metadata\n            context Tags Add($\"load-test-batch-{GetLoadTestBatch()}\");\n            context Tags Add($\"load-test-thread-{Thread CurrentThread ManagedThreadId}\");\n            // Execute with load test optimizations\n            return await next(message, context);\n        }\n        return await next(message, context);\n    }\n    private string GetLoadTestBatch() {\n        // Identify which load test batch this belongs to\n        return Environment GetEnvironmentVariable(\"LOAD_TEST_BATCH_ID\") \"unknown\";\n    }\n}\n`\nAdvanced Routing Scenarios\nDynamic Handler Selection\nRoute to different handlers based on flags and tags:\n`csharp{title=\"Context-Aware Handler Factory\" description=\"Dynamic handler selection based on flags and tags for flexible routing\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Flags-Tags\", \"Dynamic-Routing\", \"Handler-Selection\"] framework=\"NET8\"}\n// Handler factory that selects implementation based on context\npublic class ContextAwareHandlerFactory<T> : ICommandHandler<T> where T : ICommand {\n    private readonly IServiceProvider _serviceProvider;\n    private readonly IHandlerRoutingRules _routingRules;\n    public async Task Handle(T command, MessageContext context) {\n        var handlerType = await _routingRules DetermineHandlerType<T>(context);\n        var handler = (ICommandHandler<T>)_serviceProvider GetRequiredService(handlerType);\n        return await handler",
        "startIndex": 14479,
        "preview": "&& context HasFlag(WhizbangFlags QA)) { // Create a copy with scrubbing flag var qaCopy = @event; var qaContext = context Copy() WithFlag(WhizbangFlag..."
      },
      {
        "id": "proposals/flags-tags-system-chunk-7",
        "text": "framework=\"NET8\"} // Handler factory that selects implementation based on context public class ContextAwareHandlerFactory<T> : ICommandHandler<T> where T : ICommand { private readonly IServiceProvider _serviceProvider; private readonly IHandlerRoutingRules _routingRules; public async Task Handle(T command, MessageContext context) { var handlerType = await _routingRules DetermineHandlerType<T>(context); var handler = (ICommandHandler<T>)_serviceProvider GetRequiredService(handlerType); return await handler Handle(command, context);\n    }\n}\n`csharp{title=\"Handler Routing Rules\" description=\"Context-based routing rules for handler type determination\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Flags-Tags\", \"Routing-Rules\", \"Handler-Selection\"] framework=\"NET8\"}\n// Routing rules based on context\npublic class HandlerRoutingRules : IHandlerRoutingRules {\n    public async Task<Type> DetermineHandlerType<T>(MessageContext context) {\n        // VIP customers get premium handler\n        if (context HasTag(\"customer-vip\")) {\n            return typeof(PremiumOrderHandler);\n        }\n        // Load testing gets optimized handler\n        if (context HasFlag(WhizbangFlags LoadTesting)) {\n            return typeof(LoadTestOptimizedOrderHandler);\n        }\n        // Migration data gets special handler\n        if (context HasFlag(WhizbangFlags Migration)) {\n            return typeof(DataMigrationOrderHandler);\n        }\n        // Default handler\n        return typeof(StandardOrderHandler);\n    }\n}\n`\nConfiguration and Management\nFlag Management\nControl flag behavior through configuration:\n`csharp{title=\"Flag Management Configuration\" description=\"Flag management configuration with environment-based defaults and validation\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Configuration\", \"Environment-Management\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options Flags(flags => {\n        // Environment-based flag defaults\n        if (_environment IsDevelopment()) {\n            flags DefaultFlags = WhizbangFlags Development | WhizbangFlags VerboseLogging;\n        } else if (_environment IsProduction()) {\n            flags DefaultFlags = WhizbangFlags Production;\n            flags RestrictedFlags = WhizbangFlags SecurityBypass | WhizbangFlags DataScrubbing;\n        }\n        // Flag validation rules\n        flags AddValidationRule(ctx => {\n            if (ctx HasFlag(WhizbangFlags SecurityBypass) && ctx HasTag(\"authorized-security-bypass\")) {\n                throw new UnauthorizedFlagException(\"SecurityBypass flag requires authorization\");\n            }\n        });\n        // Automatic flag addition based on context\n        flags AddAutoFlag(WhizbangFlags ComplianceMode, \n            condition: ctx => ctx HasTag(\"pci-data\") || ctx",
        "startIndex": 16969,
        "preview": "framework=\"NET8\"} // Handler factory that selects implementation based on context public class ContextAwareHandlerFactory<T> : ICommandHandler<T> wher..."
      },
      {
        "id": "proposals/flags-tags-system-chunk-8",
        "text": "flags RestrictedFlags = WhizbangFlags SecurityBypass | WhizbangFlags DataScrubbing; } // Flag validation rules flags AddValidationRule(ctx => { if (ctx HasFlag(WhizbangFlags SecurityBypass) && ctx HasTag(\"authorized-security-bypass\")) { throw new UnauthorizedFlagException(\"SecurityBypass flag requires authorization\"); } }); // Automatic flag addition based on context flags AddAutoFlag(WhizbangFlags ComplianceMode, condition: ctx => ctx HasTag(\"pci-data\") || ctx HasTag(\"gdpr-data\"));\n    });\n});\n`\nTag Lifecycle Management\nManage tag propagation and cleanup:\n`csharp{title=\"Tag Lifecycle Manager\" description=\"Tag lifecycle management with automatic addition and cleanup\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Flags-Tags\", \"Tag-Lifecycle\", \"Management\"] framework=\"NET8\"}\npublic class TagLifecycleManager : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        // Add automatic tags\n        context Tags Add($\"processed-at-{Environment MachineName}\");\n        context Tags Add($\"handler-{typeof(TRequest) Name}\");\n        // Remove expired tags\n        var expiredTags = context Tags Where(tag => tag StartsWith(\"session-\") && IsSessionExpired(tag)) ToList();\n        foreach (var expiredTag in expiredTags) {\n            context Tags Remove(expiredTag);\n        }\n        var response = await next(message, context);\n        // Add response-based tags\n        if (response is ISuccessResult) {\n            context Tags Add(\"execution-success\");\n        } else if (response is IErrorResult error) {\n            context Tags Add($\"execution-error-{error ErrorCode}\");\n        }\n        return response;\n    }\n}\n`\nBest Practices\nFlag Usage Guidelines\nUse library flags first - Prefer built-in flags over custom tags when possible\nDocument custom flags - Make user-defined flags clear to the team\nBe conservative with propagation - Not all flags should cross service boundaries\nConsider flag lifetime - How long should flags persist in the system\nAudit flag usage - Track which flags are used and where\nTag Design Principles\nHierarchical naming - Use consistent naming conventions (e g",
        "startIndex": 19273,
        "preview": "flags RestrictedFlags = WhizbangFlags SecurityBypass | WhizbangFlags DataScrubbing; } // Flag validation rules flags AddValidationRule(ctx => { if (ct..."
      },
      {
        "id": "proposals/flags-tags-system-chunk-9",
        "text": "to the team Be conservative with propagation - Not all flags should cross service boundaries Consider flag lifetime - How long should flags persist in the system Audit flag usage - Track which flags are used and where Tag Design Principles Hierarchical naming - Use consistent naming conventions (e g , \"customer-vip\", \"region-us-west\")\nMeaningful values - Tags should be self-documenting\nAvoid high cardinality - Don't create too many unique tag combinations\nLifecycle awareness - Consider when tags should be added/removed\nSecurity sensitivity - Don't include sensitive data in tag names\nSecurity Considerations\nValidate flag sources - Ensure flags come from trusted sources\nLimit dangerous flags - SecurityBypass should be heavily restricted\nAudit flag changes - Log all flag modifications\nEncrypt sensitive tags - Some tags may contain sensitive information\nPrinciple of least privilege - Flags should grant minimal necessary permissions\n---\nRelated Documentation\nPolicy Engine - How policies use flags and tags for decision making\nObservability & Metrics - Flag-driven observability levels\nTesting & Development Tools - Testing with flags and tags",
        "startIndex": 21102,
        "preview": "to the team Be conservative with propagation - Not all flags should cross service boundaries Consider flag lifetime - How long should flags persist in..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "proposals/multi-tenancy",
    "title": "Multi-Tenancy",
    "category": "Architecture & Design",
    "url": "/docs/proposals/multi-tenancy",
    "chunks": [
      {
        "id": "proposals/multi-tenancy-chunk-0",
        "text": "Multi-Tenancy\nWhizbang provides comprehensive multi-tenancy support with flexible tenant isolation strategies, from single database with row-level security to complete database separation Tenant Isolation Strategies\nSingle Database with Tenant ID\nRow-level tenant isolation using tenant ID columns:\n`sql\n---\ncategory: Design\ndifficulty: INTERMEDIATE\ntags: [Design, Multi-Tenancy, SQL, Row-Level-Security]\ndescription: SQL schema for tenant-isolated events table with row-level security\n---\n-- Events table with tenant isolation\nCREATE TABLE events (\n    event_id BIGSERIAL PRIMARY KEY,\n    stream_id VARCHAR(255) NOT NULL,\n    stream_version INT NOT NULL,\n    event_type VARCHAR(255) NOT NULL,\n    event_data JSONB NOT NULL,\n    metadata JSONB,\n    tenant_id UUID NOT NULL,  -- Tenant isolation\n    created_at TIMESTAMPTZ NOT NULL,\n    UNIQUE(tenant_id, stream_id, stream_version)\n);\n-- Projections table with tenant isolation\nCREATE TABLE projections (\n    projection_name VARCHAR(255) NOT NULL,\n    document_id VARCHAR(255) NOT NULL,\n    document JSONB NOT NULL,\n    tenant_id UUID NOT NULL,  -- Tenant isolation\n    version BIGINT NOT NULL,\n    last_updated TIMESTAMPTZ NOT NULL,\n    PRIMARY KEY (projection_name, document_id, tenant_id)\n);\n-- Row-level security policies\nCREATE POLICY tenant_isolation_events ON events\n    USING (tenant_id = current_setting('app current_tenant_id')::UUID);\nCREATE POLICY tenant_isolation_projections ON projections  \n    USING (tenant_id = current_setting('app current_tenant_id')::UUID);\n`\nMultiple Databases\nComplete database separation per tenant:\n`csharp{\ntitle: \"Separate Database Configuration\",\ndescription: \"Configuration for complete database separation per tenant\",\ncategory: \"Design\",\ndifficulty: \"ADVANCED\",\ntags: [\"Multi-Tenancy\", \"Configuration\", \"Separate-Databases\", \"Database-Per-Tenant\"],\nframework: \"NET8\"\n}\nservices AddWhizbang(options => {\n    options MultiTenancy(tenancy => {\n        tenancy Strategy = TenancyStrategy SeparateDatabases;\n        tenancy DatabaseProvider = (tenantId) => {\n            return $\"Host=db-server;Database=tenant_{tenantId};Username=app;Password=secret\";\n        };\n        // Database creation for new tenants\n        tenancy AutoCreateDatabases = true;\n        tenancy",
        "startIndex": 0,
        "preview": "Multi-Tenancy\nWhizbang provides comprehensive multi-tenancy support with flexible tenant isolation strategies, from single database with row-level sec..."
      },
      {
        "id": "proposals/multi-tenancy-chunk-1",
        "text": "complete database separation per tenant\", category: \"Design\", difficulty: \"ADVANCED\", tags: [\"Multi-Tenancy\", \"Configuration\", \"Separate-Databases\", \"Database-Per-Tenant\"], framework: \"NET8\" } services AddWhizbang(options => { options MultiTenancy(tenancy => { tenancy Strategy = TenancyStrategy SeparateDatabases; tenancy DatabaseProvider = (tenantId) => { return $\"Host=db-server;Database=tenant_{tenantId};Username=app;Password=secret\"; }; // Database creation for new tenants tenancy AutoCreateDatabases = true; tenancy DatabaseTemplate = \"tenant_template\";\n    });\n});\n`\nSame Table with Partitioning\nTable partitioning by tenant for performance:\n`sql\n---\ncategory: Design\ndifficulty: ADVANCED\ntags: [Design, Multi-Tenancy, SQL, Table-Partitioning, Performance]\ndescription: Table partitioning by tenant for performance optimization\n---\n-- Partitioned events table\nCREATE TABLE events (\n    event_id BIGSERIAL,\n    stream_id VARCHAR(255) NOT NULL,\n    stream_version INT NOT NULL,\n    event_type VARCHAR(255) NOT NULL,\n    event_data JSONB NOT NULL,\n    metadata JSONB,\n    tenant_id UUID NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL\n) PARTITION BY HASH (tenant_id);\n-- Create partitions\nCREATE TABLE events_p0 PARTITION OF events FOR VALUES WITH (MODULUS 4, REMAINDER 0);\nCREATE TABLE events_p1 PARTITION OF events FOR VALUES WITH (MODULUS 4, REMAINDER 1);\nCREATE TABLE events_p2 PARTITION OF events FOR VALUES WITH (MODULUS 4, REMAINDER 2);\nCREATE TABLE events_p3 PARTITION OF events FOR VALUES WITH (MODULUS 4, REMAINDER 3);\n`\nTenant ID Definition\nDefault Tenant ID Field\nStandard GUID-based tenant identification:\n`csharp{\ntitle: \"Default Tenant ID Definition\",\ndescription: \"Standard tenant ID definition using property conventions and strong types\",\ncategory: \"Design\",\ndifficulty: \"BEGINNER\",\ntags: [\"Multi-Tenancy\", \"Domain-Models\", \"Tenant-ID\", \"Strong-Types\"],\nframework: \"NET8\"\n}\n// Default: Look for TenantId property\npublic class Order : Aggregate {\n    public Guid Id { get; private set; }\n    public Guid TenantId { get; private set; } // Automatically detected\n    public decimal Total { get; private set; }\n    public Order(Guid tenantId, Guid id) {\n        TenantId = tenantId;\n        Id = id;\n    }\n}\n// Strong-typed tenant ID\npublic record TenantId(Guid Value) : StrongTypeId<Guid>(Value);\npublic class Order : Aggregate {\n    public Guid Id { get; private set; }\n    public TenantId TenantId { get; private set; } // Strong type detected\n    public decimal Total { get; private set; }\n}\n`\nComposite Tenant ID\nMulti-field tenant identification:\n`csharp{\ntitle: \"Composite Tenant ID Configuration\",\ndescription: \"Multi-field tenant identification for complex organizational structures\",\ncategory: \"Design\",\ndifficulty: \"INTERMEDIATE\",\ntags: [\"Multi-Tenancy\", \"Composite-Tenant-ID\", \"Configuration\", \"Organization-Structure\"],\nframework: \"NET8\"\n}\nservices",
        "startIndex": 2261,
        "preview": "complete database separation per tenant\", category: \"Design\", difficulty: \"ADVANCED\", tags: [\"Multi-Tenancy\", \"Configuration\", \"Separate-Databases\", \"..."
      },
      {
        "id": "proposals/multi-tenancy-chunk-2",
        "text": "private set; } // Strong type detected public decimal Total { get; private set; } } ` Composite Tenant ID Multi-field tenant identification: `csharp{ title: \"Composite Tenant ID Configuration\", description: \"Multi-field tenant identification for complex organizational structures\", category: \"Design\", difficulty: \"INTERMEDIATE\", tags: [\"Multi-Tenancy\", \"Composite-Tenant-ID\", \"Configuration\", \"Organization-Structure\"], framework: \"NET8\" } services AddWhizbang(options => {\n    options MultiTenancy(tenancy => {\n        tenancy TenantIdComposition<Order>(composition => {\n            composition FromFields(order => new { \n                order OrganizationId, \n                order DivisionId \n            });\n        });\n        tenancy TenantIdComposition<Customer>(composition => {\n            composition FromFields(customer => customer CompanyId);\n        });\n    });\n});\n// Usage in aggregates\npublic class Order : Aggregate {\n    public Guid Id { get; private set; }\n    public Guid OrganizationId { get; private set; } // Part of tenant ID\n    public Guid DivisionId { get; private set; }     // Part of tenant ID\n    public Guid CustomerId { get; private set; }\n}\n`\nCustom Tenant Resolution\nComplex tenant identification logic:\n`csharp{\ntitle: \"Custom Tenant Resolution\",\ndescription: \"Custom tenant identification logic for complex business scenarios\",\ncategory: \"Design\",\ndifficulty: \"ADVANCED\",\ntags: [\"Multi-Tenancy\", \"Custom-Resolution\", \"Business-Logic\", \"Configuration\"],\nframework: \"NET8\"\n}\nservices AddWhizbang(options => {\n    options MultiTenancy(tenancy => {\n        tenancy TenantResolver<Order>(order => {\n            // Custom logic to determine tenant\n            if (order OrganizationId == SpecialOrgId) {\n                return $\"special-{order DivisionId}\";\n            }\n            return order OrganizationId ToString();\n        });\n    });\n});\n`\nTenant Context Management\nTenant Context Propagation\n`csharp{\ntitle: \"Tenant Context Interface\",\ndescription: \"Interface for managing current tenant state and context\",\ncategory: \"Design\",\ndifficulty: \"INTERMEDIATE\",\ntags: [\"Multi-Tenancy\", \"Context-Management\", \"Interfaces\", \"State-Management\"],\nframework: \"NET8\"\n}\npublic interface ITenantContext {\n    string CurrentTenantId { get; }\n    void SetTenant(string tenantId);\n    void ClearTenant();\n    bool HasTenant { get; }\n}\n`csharp{\ntitle: \"Tenant Context Middleware\",\ndescription: \"ASP NET Core middleware for automatic tenant context propagation from multiple sources\",\ncategory: \"Design\",\ndifficulty: \"INTERMEDIATE\",\ntags: [\"Multi-Tenancy\", \"ASP NET-Core\", \"Middleware\", \"Context-Propagation\"],\nframework: \"NET8\"\n}\n// ASP",
        "startIndex": 1875,
        "preview": "private set; } // Strong type detected public decimal Total { get; private set; } } ` Composite Tenant ID Multi-field tenant identification: `csharp{ ..."
      },
      {
        "id": "proposals/multi-tenancy-chunk-3",
        "text": "{ string CurrentTenantId { get; } void SetTenant(string tenantId); void ClearTenant(); bool HasTenant { get; } } `csharp{ title: \"Tenant Context Middleware\", description: \"ASP NET Core middleware for automatic tenant context propagation from multiple sources\", category: \"Design\", difficulty: \"INTERMEDIATE\", tags: [\"Multi-Tenancy\", \"ASP NET-Core\", \"Middleware\", \"Context-Propagation\"], framework: \"NET8\" } // ASP NET Core middleware\npublic class TenantContextMiddleware {\n    public async Task InvokeAsync(HttpContext context, RequestDelegate next) {\n        var tenantId = ExtractTenantId(context);\n        if (tenantId = null) {\n            _tenantContext SetTenant(tenantId);\n        }\n        try {\n            await next(context);\n        } finally {\n            _tenantContext ClearTenant();\n        }\n    }\n    private string ExtractTenantId(HttpContext context) {\n        // From header\n        if (context Request Headers TryGetValue(\"X-Tenant-ID\", out var headerValue)) {\n            return headerValue;\n        }\n        // From subdomain\n        var host = context Request Host Host;\n        if (host Contains(' ')) {\n            var subdomain = host Split(' ')[0];\n            return subdomain = \"www\" subdomain : null;\n        }\n        // From route\n        if (context Request RouteValues TryGetValue(\"tenantId\", out var routeValue)) {\n            return routeValue ToString();\n        }\n        return null;\n    }\n}\n`\nTenant-Aware Command/Event Handling\n`csharp{\ntitle: \"Tenant-Aware Command Handler\",\ndescription: \"Command handler implementation with tenant context validation and isolation\",\ncategory: \"Design\",\ndifficulty: \"INTERMEDIATE\",\ntags: [\"Multi-Tenancy\", \"Command-Handlers\", \"Domain-Logic\", \"Context-Validation\"],\nframework: \"NET8\"\n}\npublic class PlaceOrderHandler : ICommandHandler<PlaceOrder> {\n    private readonly ITenantContext _tenantContext;\n    private readonly IOrderRepository _repository;\n    public async Task<OrderPlaced> Handle(PlaceOrder command) {\n        var tenantId = _tenantContext CurrentTenantId throw new InvalidOperationException(\"No tenant context\");\n        var order = new Order(\n            tenantId: Guid Parse(tenantId),\n            orderId: command OrderId,\n            customerId: command CustomerId,\n            items: command Items\n        );\n        await _repository Save(order);\n        return new OrderPlaced(\n            command OrderId,\n            command CustomerId,\n            DateTimeOffset UtcNow\n        ) {\n            TenantId = tenantId // Automatically added to event metadata\n        };\n    }\n}\n`\nTenant-Aware Projections\nProjection-Level Isolation\n`csharp{\ntitle: \"Tenant-Specific Projection\",\ndescription: \"Tenant-specific projection configuration with isolation controls\",\ncategory: \"Design\",\ndifficulty: \"INTERMEDIATE\",\ntags: [\"Multi-Tenancy\", \"Projections\", \"Tenant-Isolation\", \"Event-Handling\"],\nframework: \"NET8\"\n}\nservices AddProjection<OrderSummaryProjection>(options => {\n    options TenantIsolation(isolation => {\n        isolation",
        "startIndex": 6830,
        "preview": "{ string CurrentTenantId { get; } void SetTenant(string tenantId); void ClearTenant(); bool HasTenant { get; } } `csharp{ title: \"Tenant Context Middl..."
      },
      {
        "id": "proposals/multi-tenancy-chunk-4",
        "text": "{ TenantId = tenantId // Automatically added to event metadata }; } } ` Tenant-Aware Projections Projection-Level Isolation `csharp{ title: \"Tenant-Specific Projection\", description: \"Tenant-specific projection configuration with isolation controls\", category: \"Design\", difficulty: \"INTERMEDIATE\", tags: [\"Multi-Tenancy\", \"Projections\", \"Tenant-Isolation\", \"Event-Handling\"], framework: \"NET8\" } services AddProjection<OrderSummaryProjection>(options => { options TenantIsolation(isolation => { isolation Strategy = ProjectionTenantStrategy TenantSpecific;\n        isolation AllowCrossTenantQueries = false;\n    });\n});\npublic class OrderSummaryProjection : IProjectionHandler<OrderPlaced> {\n    public async Task Handle(OrderPlaced @event, ProjectionContext context) {\n        var tenantId = context TenantId; // Automatically extracted\n        var summary = new OrderSummary {\n            OrderId = @event OrderId,\n            TenantId = tenantId,\n            Total = @event Total\n        };\n        // Stored with tenant isolation\n        await context Store(@event OrderId ToString(), summary);\n    }\n}\n`\nCross-Tenant Projections\nGlobal projections that aggregate across tenants:\n`csharp{\ntitle: \"Cross-Tenant Analytics Projection\",\ndescription: \"Cross-tenant projection for global analytics and reporting across all tenants\",\ncategory: \"Design\",\ndifficulty: \"ADVANCED\",\ntags: [\"Multi-Tenancy\", \"Projections\", \"Cross-Tenant\", \"Analytics\", \"Global-Data\"],\nframework: \"NET8\"\n}\nservices AddProjection<GlobalAnalyticsProjection>(options => {\n    options TenantIsolation(isolation => {\n        isolation Strategy = ProjectionTenantStrategy CrossTenant;\n        isolation RequireExplicitTenantAccess = true;\n    });\n});\npublic class GlobalAnalyticsProjection : IProjectionHandler<OrderPlaced> {\n    public async Task Handle(OrderPlaced @event, ProjectionContext context) {\n        // Access to all tenant data for analytics\n        var analytics = await context LoadGlobal<GlobalAnalytics>(\"summary\");\n        analytics = new GlobalAnalytics();\n        analytics TotalOrders++;\n        analytics TotalRevenue += @event Total;\n        analytics OrdersByTenant[context TenantId] = \n            analytics OrdersByTenant GetValueOrDefault(context TenantId) + 1;\n        await context StoreGlobal(\"summary\", analytics);\n    }\n}\n`\nDriver Support for Multi-Tenancy\nPostgreSQL Driver\n`csharp{\ntitle: \"PostgreSQL Tenant-Aware Driver\",\ndescription: \"PostgreSQL driver implementation with tenant isolation support for event storage\",\ncategory: \"Design\",\ndifficulty: \"ADVANCED\",\ntags: [\"Multi-Tenancy\", \"Drivers\", \"PostgreSQL\", \"Event-Store\", \"Data-Access\"],\nframework: \"NET8\"\n}\npublic class PostgresTenantDriver : IEventStoreDriver {\n    public async Task<IEnumerable<Event>> ReadEvents(string streamId, string tenantId = null) {\n        var sql = tenantId = null",
        "startIndex": 9462,
        "preview": "{ TenantId = tenantId // Automatically added to event metadata }; } } ` Tenant-Aware Projections Projection-Level Isolation `csharp{ title: \"Tenant-Sp..."
      },
      {
        "id": "proposals/multi-tenancy-chunk-5",
        "text": "title: \"PostgreSQL Tenant-Aware Driver\", description: \"PostgreSQL driver implementation with tenant isolation support for event storage\", category: \"Design\", difficulty: \"ADVANCED\", tags: [\"Multi-Tenancy\", \"Drivers\", \"PostgreSQL\", \"Event-Store\", \"Data-Access\"], framework: \"NET8\" } public class PostgresTenantDriver : IEventStoreDriver { public async Task<IEnumerable<Event>> ReadEvents(string streamId, string tenantId = null) { var sql = tenantId = null \"SELECT * FROM events WHERE stream_id = @streamId AND tenant_id = @tenantId ORDER BY stream_version\"\n            : \"SELECT * FROM events WHERE stream_id = @streamId ORDER BY stream_version\";\n        return await _connection QueryAsync<Event>(sql, new { streamId, tenantId });\n    }\n    public async Task AppendEvents(string streamId, IEnumerable<Event> events, string tenantId = null) {\n        if (tenantId == null) {\n            throw new InvalidOperationException(\"Tenant ID required for event storage\");\n        }\n        foreach (var @event in events) {\n            @event TenantId = tenantId;\n        }\n        await _connection ExecuteAsync(\n            \"INSERT INTO events (stream_id, stream_version, event_type, event_data, tenant_id, created_at) \" +\n            \"VALUES (@StreamId, @StreamVersion, @EventType, @EventData, @TenantId, @CreatedAt)\",\n            events\n        );\n    }\n}\n`\nAbstract Driver Interface\n`csharp{\ntitle: \"Tenant-Aware Driver Interface\",\ndescription: \"Abstract driver interface for tenant-aware data operations with cross-tenant support\",\ncategory: \"Design\",\ndifficulty: \"INTERMEDIATE\",\ntags: [\"Multi-Tenancy\", \"Drivers\", \"Interfaces\", \"Architecture\", \"Data-Access\"],\nframework: \"NET8\"\n}\npublic interface ITenantAwareDriver {\n    Task<T> Load<T>(string id, string tenantId = null);\n    Task Save<T>(T entity, string tenantId = null);\n    Task<IEnumerable<T>> Query<T>(Expression<Func<T, bool>> predicate, string tenantId = null);\n    // Cross-tenant operations (require special permissions)\n    Task<IEnumerable<T>> QueryAllTenants<T>(Expression<Func<T, bool>> predicate);\n    Task<Dictionary<string, IEnumerable<T>>> QueryByTenant<T>(Expression<Func<T, bool>> predicate);\n}\n`\nSecurity and Authorization\nTenant-Based Authorization\n`csharp{\ntitle: \"Tenant-Based Authorization\",\ndescription: \"Tenant-based authorization configuration with isolation enforcement and policies\",\ncategory: \"Design\",\ndifficulty: \"INTERMEDIATE\",\ntags: [\"Multi-Tenancy\", \"Security\", \"Authorization\", \"ASP NET-Core\", \"Policies\"],\nframework: \"NET8\"\n}\nservices AddWhizbang(options => {\n    options Authorization(auth => {\n        auth RequireTenantContext = true;\n        auth EnforceTenantIsolation = true;\n        auth AddPolicy(\"TenantAdmin\", policy => {\n            policy RequireClaim(\"tenant_id\");\n            policy RequireClaim(\"role\", \"admin\");\n        });\n        auth AddPolicy(\"CrossTenantRead\", policy => {\n            policy",
        "startIndex": 11827,
        "preview": "title: \"PostgreSQL Tenant-Aware Driver\", description: \"PostgreSQL driver implementation with tenant isolation support for event storage\", category: \"D..."
      },
      {
        "id": "proposals/multi-tenancy-chunk-6",
        "text": "enforcement and policies\", category: \"Design\", difficulty: \"INTERMEDIATE\", tags: [\"Multi-Tenancy\", \"Security\", \"Authorization\", \"ASP NET-Core\", \"Policies\"], framework: \"NET8\" } services AddWhizbang(options => { options Authorization(auth => { auth RequireTenantContext = true; auth EnforceTenantIsolation = true; auth AddPolicy(\"TenantAdmin\", policy => { policy RequireClaim(\"tenant_id\"); policy RequireClaim(\"role\", \"admin\"); }); auth AddPolicy(\"CrossTenantRead\", policy => { policy RequireClaim(\"permission\", \"cross_tenant_read\");\n        });\n    });\n});\n[Authorize(\"TenantAdmin\")]\npublic class OrderController : ControllerBase {\n    [HttpGet]\n    public async Task<IActionResult> GetOrders() {\n        // Automatically filtered by tenant context\n        var orders = await _orderQuery GetOrdersForCurrentTenant();\n        return Ok(orders);\n    }\n    [HttpGet(\"all-tenants\")]\n    [Authorize(\"CrossTenantRead\")]\n    public async Task<IActionResult> GetOrdersAllTenants() {\n        // Requires special permission\n        var orders = await _orderQuery GetOrdersAllTenants();\n        return Ok(orders);\n    }\n}\n`\nRow-Level Security Integration\n`csharp{\ntitle: \"Row-Level Security Configuration\",\ndescription: \"PostgreSQL row-level security integration for automatic tenant isolation\",\ncategory: \"Design\",\ndifficulty: \"ADVANCED\",\ntags: [\"Multi-Tenancy\", \"PostgreSQL\", \"Row-Level-Security\", \"Configuration\"],\nframework: \"NET8\"\n}\nservices AddWhizbang(options => {\n    options UsePostgres(connectionString, postgres => {\n        postgres EnableRowLevelSecurity = true;\n        postgres TenantContextVariable = \"app current_tenant_id\";\n    });\n});\n`csharp{\ntitle: \"Tenant-Aware Connection Factory\",\ndescription: \"Database connection factory with automatic tenant context setting for RLS\",\ncategory: \"Design\",\ndifficulty: \"ADVANCED\",\ntags: [\"Multi-Tenancy\", \"PostgreSQL\", \"Connection-Factory\", \"Context-Propagation\"],\nframework: \"NET8\"\n}\n// Automatically sets tenant context for all database operations\npublic class PostgresTenantConnectionFactory : IDbConnectionFactory {\n    public async Task<IDbConnection> CreateConnection() {\n        var connection = new NpgsqlConnection(_connectionString);\n        await connection OpenAsync();\n        var tenantId = _tenantContext CurrentTenantId;\n        if (tenantId = null) {\n            await connection ExecuteAsync(\n                \"SET app current_tenant_id = @tenantId\", \n                new { tenantId }\n            );\n        }\n        return connection;\n    }\n}\n`\nConfiguration Examples\nComprehensive Multi-Tenancy Setup\n`csharp{\ntitle: \"Comprehensive Multi-Tenancy Setup\",\ndescription: \"Complete multi-tenancy configuration with all options and strategies\",\ncategory: \"Design\",\ndifficulty: \"ADVANCED\",\ntags: [\"Multi-Tenancy\", \"Configuration\", \"Comprehensive-Setup\", \"Production-Ready\"],\nframework: \"NET8\"\n}\nservices AddWhizbang(options => {\n    options MultiTenancy(tenancy => {\n        // Tenant identification\n        tenancy TenantIdField = \"TenantId\";\n        tenancy TenantIdType = typeof(Guid);\n        // Storage strategy\n        tenancy Strategy = TenancyStrategy SingleDatabaseWithIsolation;\n        tenancy",
        "startIndex": 14276,
        "preview": "enforcement and policies\", category: \"Design\", difficulty: \"INTERMEDIATE\", tags: [\"Multi-Tenancy\", \"Security\", \"Authorization\", \"ASP NET-Core\", \"Polic..."
      },
      {
        "id": "proposals/multi-tenancy-chunk-7",
        "text": "Setup\", description: \"Complete multi-tenancy configuration with all options and strategies\", category: \"Design\", difficulty: \"ADVANCED\", tags: [\"Multi-Tenancy\", \"Configuration\", \"Comprehensive-Setup\", \"Production-Ready\"], framework: \"NET8\" } services AddWhizbang(options => { options MultiTenancy(tenancy => { // Tenant identification tenancy TenantIdField = \"TenantId\"; tenancy TenantIdType = typeof(Guid); // Storage strategy tenancy Strategy = TenancyStrategy SingleDatabaseWithIsolation; tenancy EnableRowLevelSecurity = true;\n        // Tenant context\n        tenancy TenantResolver = (httpContext) => {\n            return httpContext Request Headers[\"X-Tenant-ID\"] FirstOrDefault();\n        };\n        // Cross-tenant operations\n        tenancy AllowCrossTenantOperations = false;\n        tenancy RequireExplicitCrossTenantPermission = true;\n        // Database partitioning\n        tenancy UsePartitioning = true;\n        tenancy PartitionCount = 16;\n        // Tenant lifecycle\n        tenancy AutoCreateTenantData = true;\n        tenancy TenantDataTemplate = \"default_tenant_template\";\n    });\n    // Tenant-aware projections\n    options Projections(projections => {\n        projections DefaultTenantStrategy = ProjectionTenantStrategy TenantSpecific;\n        projections AllowGlobalProjections = true;\n        projections RequireExplicitCrossTenantAccess = true;\n    });\n});\n`\nTenant Onboarding Workflow\n`csharp{\ntitle: \"Tenant Onboarding Service\",\ndescription: \"Tenant onboarding workflow with resource provisioning and initialization\",\ncategory: \"Design\",\ndifficulty: \"INTERMEDIATE\",\ntags: [\"Multi-Tenancy\", \"Onboarding\", \"Tenant-Lifecycle\", \"Resource-Provisioning\"],\nframework: \"NET8\"\n}\npublic class TenantOnboardingService {\n    public async Task OnboardTenant(string tenantId, TenantConfiguration config) {\n        // Create tenant-specific database resources\n        await _tenantManager CreateTenantResources(tenantId);\n        // Initialize tenant data\n        await _tenantManager InitializeTenantData(tenantId, config);\n        // Set up tenant-specific projections\n        await _projectionManager CreateTenantProjections(tenantId);\n        // Emit tenant onboarded event\n        await _eventPublisher PublishAsync(new TenantOnboarded(\n            tenantId,\n            config,\n            DateTimeOffset",
        "startIndex": 16958,
        "preview": "Setup\", description: \"Complete multi-tenancy configuration with all options and strategies\", category: \"Design\", difficulty: \"ADVANCED\", tags: [\"Multi..."
      },
      {
        "id": "proposals/multi-tenancy-chunk-8",
        "text": "\"NET8\" } public class TenantOnboardingService { public async Task OnboardTenant(string tenantId, TenantConfiguration config) { // Create tenant-specific database resources await _tenantManager CreateTenantResources(tenantId); // Initialize tenant data await _tenantManager InitializeTenantData(tenantId, config); // Set up tenant-specific projections await _projectionManager CreateTenantProjections(tenantId); // Emit tenant onboarded event await _eventPublisher PublishAsync(new TenantOnboarded( tenantId, config, DateTimeOffset UtcNow\n        ));\n    }\n}\n`\nBest Practices\nTenant Design Guidelines\nDesign for isolation - Assume tenants can't see each other's data\nValidate tenant context - Always check tenant context in handlers\nUse consistent tenant IDs - Keep tenant identification simple\nPlan for scale - Design partitioning strategy from the start\nTest cross-tenant security - Verify isolation works correctly\nPerformance Considerations\nPartition by tenant - Use database partitioning for large tables\nIndex tenant columns - Include tenant_id in all indexes\nConnection pooling - Consider tenant-specific connection pools\nCache tenant data - Cache tenant configuration and permissions\nMonitor per-tenant usage - Track resource usage by tenant\nSecurity Best Practices\nDefense in depth - Use multiple layers of tenant isolation\nPrinciple of least privilege - Only grant necessary cross-tenant permissions\nAudit tenant access - Log all cross-tenant operations\nValidate tenant ownership - Check tenant context in all operations\nRegular security reviews - Audit tenant isolation regularly\n---\nRelated Documentation\nEvent Store & Projections - Storage architecture with tenant isolation\nDomain Ownership - How domain ownership works with tenants\nPerformance Optimization - Scaling multi-tenant systems",
        "startIndex": 18784,
        "preview": "\"NET8\" } public class TenantOnboardingService { public async Task OnboardTenant(string tenantId, TenantConfiguration config) { // Create tenant-specif..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "proposals/observability-metrics",
    "title": "Observability & Metrics",
    "category": "Architecture & Design",
    "url": "/docs/proposals/observability-metrics",
    "chunks": [
      {
        "id": "proposals/observability-metrics-chunk-0",
        "text": "Observability & Metrics\nWhizbang provides comprehensive observability with policy-driven metrics collection, OpenTelemetry integration, and custom field attributes for rich monitoring and debugging capabilities Metrics Architecture\nDefault Metrics (Always Enabled)\nCore performance and health metrics essential for operation:\n`csharp\n---\ncategory: Design\ndifficulty: INTERMEDIATE\ntags: [Design, Observability, Metrics, Default-Metrics]\ndescription: Core performance and health metrics essential for operation\n---\n// Command metrics\nwhizbang_command_duration_seconds{command_type, domain, handler_type, status}\nwhizbang_command_total{command_type, domain, status}\n// Event metrics  \nwhizbang_event_published_total{event_type, domain, source_handler}\nwhizbang_event_processing_duration_seconds{event_type, handler_type, status}\n// Projection metrics\nwhizbang_projection_lag_seconds{projection_name, partition}\nwhizbang_projection_events_processed_total{projection_name, event_type}\nwhizbang_projection_errors_total{projection_name, error_type}\n// Infrastructure metrics\nwhizbang_event_store_append_duration_seconds{driver_type, operation}\nwhizbang_message_broker_publish_duration_seconds{broker_type, topic}\nwhizbang_message_broker_consume_duration_seconds{broker_type, topic}\n// System health\nwhizbang_active_handlers_total{handler_type}\nwhizbang_memory_usage_bytes{component}\nwhizbang_cpu_usage_percent{component}\n`\nObservability Levels\nConfigurable detail levels for different scenarios:\n`csharp\n---\ncategory: Design\ndifficulty: INTERMEDIATE\ntags: [Design, Observability, Configuration, Observability-Levels]\ndescription: Configurable observability levels for different scenarios\n---\npublic enum ObservabilityLevel {\n    Minimal,    // Only essential metrics + errors\n    Standard,   // Default metrics + basic timing\n    Detailed,   // Additional context + custom fields  \n    Verbose,    // Everything + debug information\n    Debug       // Maximum detail for troubleshooting\n}\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        // Default observability configuration\n        policies When(ctx => true) // Matches all contexts Then(config => config SetObservabilityLevel(ObservabilityLevel Standard)) And(config => config EnableCustomFields());\n        // Environment-specific policies\n        policies When(ctx => ctx IsEnvironment(\"production\")) Then(config => config SetObservabilityLevel(ObservabilityLevel Standard)) And(config => config SetSampleRate(0 1)); // 10% sampling in production\n        policies When(ctx => ctx IsEnvironment(\"development\")) Then(config => config SetObservabilityLevel(ObservabilityLevel Verbose)) And(config => config SetSampleRate(1 0)); // Full sampling in development\n    });\n});\n`\nPolicy-Driven Observability\nContext-Aware Metrics Collection\nDynamic observability based on message context and policies:\n`csharp\n---\ncategory: Design\ndifficulty: ADVANCED\ntags: [Design, Observability, Context-Aware-Metrics, Dynamic-Configuration]\ndescription: Dynamic observability configuration based on message context and policies\n---\nservices AddWhizbang(options => {\n    options Observability(obs => {\n        obs Policies(policies => {\n            // Verbose logging for critical customer journeys\n            policies When(ctx => ctx",
        "startIndex": 0,
        "preview": "Observability & Metrics\nWhizbang provides comprehensive observability with policy-driven metrics collection, OpenTelemetry integration, and custom fie..."
      },
      {
        "id": "proposals/observability-metrics-chunk-1",
        "text": "on message context and policies: `csharp --- category: Design difficulty: ADVANCED tags: [Design, Observability, Context-Aware-Metrics, Dynamic-Configuration] description: Dynamic observability configuration based on message context and policies --- services AddWhizbang(options => { options Observability(obs => { obs Policies(policies => { // Verbose logging for critical customer journeys policies When(ctx => ctx HasTag(\"customer-vip\")) Then(action => action SetObservabilityLevel(ObservabilityLevel Verbose)) And(action => action CaptureCustomFields()) And(action => action EnableDistributedTracing());\n            // Detailed metrics for flagged debugging sessions\n            policies When(ctx => ctx HasFlag(WhizbangFlags VerboseOtel)) Then(action => action SetObservabilityLevel(ObservabilityLevel Debug)) And(action => action CaptureMethodParameters()) And(action => action CaptureReturnValues());\n            // Minimal overhead for load testing\n            policies When(ctx => ctx HasFlag(WhizbangFlags LoadTesting)) Then(action => action SetObservabilityLevel(ObservabilityLevel Minimal)) And(action => action DisableSlowMetrics());\n            // Enhanced monitoring for production critical paths\n            policies When(ctx => ctx HasTag(\"critical-path\") && ctx HasFlag(WhizbangFlags Production)) Then(action => action SetObservabilityLevel(ObservabilityLevel Detailed)) And(action => action EnablePerformanceBudgetTracking()) And(action => action AlertOnAnomalies());\n        });\n    });\n});\n`\nAdaptive Sampling\nSmart sampling based on context and system load:\n`csharp\n---\ncategory: Design\ndifficulty: ADVANCED\ntags: [Design, Observability, Adaptive-Sampling, System-Load]\ndescription: Smart sampling based on context and system load for performance optimization\n---\npublic class AdaptiveObservabilityPolicy : IObservabilityPolicy {\n    public async Task<ObservabilityConfig> GetConfigAsync(MessageContext context) {\n        var config = new ObservabilityConfig();\n        // Always capture errors\n        if (context HasError) {\n            config Level = ObservabilityLevel Verbose;\n            config SampleRate = 1 0;\n            return config;\n        }\n        // Adaptive sampling based on system load\n        var systemLoad = await _systemMetrics GetCurrentLoadAsync();\n        if (systemLoad > 0 8) {\n            config SampleRate = 0 01; // 1% when system is under stress\n        } else if (systemLoad > 0 5) {\n            config SampleRate = 0 1;  // 10% when system is busy\n        } else {\n            config SampleRate = 0 5;  // 50% when system is idle\n        }\n        // VIP customers always get full tracking\n        if (context HasTag(\"customer-vip\")) {\n            config SampleRate = 1 0;\n            config",
        "startIndex": 3392,
        "preview": "on message context and policies: `csharp --- category: Design difficulty: ADVANCED tags: [Design, Observability, Context-Aware-Metrics, Dynamic-Config..."
      },
      {
        "id": "proposals/observability-metrics-chunk-2",
        "text": "else if (systemLoad > 0 5) { config SampleRate = 0 1; // 10% when system is busy } else { config SampleRate = 0 5; // 50% when system is idle } // VIP customers always get full tracking if (context HasTag(\"customer-vip\")) { config SampleRate = 1 0; config Level = ObservabilityLevel Detailed;\n        }\n        return config;\n    }\n}\n`\nCustom Field Attributes\nSource Generation for Rich Metrics\nAutomatically include relevant fields in metrics via attributes:\n`csharp\n---\ncategory: Design\ndifficulty: INTERMEDIATE\ntags: [Design, Observability, Custom-Fields, Source-Generation]\ndescription: Automatically include relevant fields in metrics via attributes\n---\n// Command with observability annotations\npublic record PlaceOrder(\n    Guid OrderId,\n    [ObservabilityField(MetricType Label)] \n    Guid CustomerId,    // Include as metric label\n    [ObservabilityField(MetricType Measure)] \n    decimal Total,      // Include as measured value\n    [ObservabilityField(MetricType Label, Transform = \"Range\")] \n    decimal Total2,     // Transform to range (0-100, 100-500, etc )\n    [ObservabilityField(MetricType Context)]\n    string Region,      // Include in trace context only\n    List<OrderItem> Items, // Not annotated - not included\n    [SensitiveData]\n    string PaymentToken // Marked sensitive - never included\n);\n// Generated metrics include custom fields\n// whizbang_command_total{command_type=\"PlaceOrder\", customer_id=\"123\", total_range=\"100-500\", region=\"us-west\"}\n// whizbang_command_duration_seconds{command_type=\"PlaceOrder\", customer_id=\"123\", total_range=\"100-500\"}\n`\nField Transformation Options\nSmart field transformations for better cardinality management:\n`csharp\n---\ncategory: Design\ndifficulty: INTERMEDIATE\ntags: [Design, Observability, Field-Transformations, Cardinality-Management]\ndescription: Smart field transformations for better metric cardinality management\n---\npublic enum FieldTransform {\n    None,           // Use raw value\n    Range,          // Convert numbers to ranges (0-100, 100-500, etc )\n    Hash,           // Hash sensitive identifiers\n    Truncate,       // Truncate long strings\n    Sanitize,       // Remove sensitive parts\n    Category        // Map to predefined categories\n}\n[ObservabilityField(MetricType Label, Transform = FieldTransform Range, Ranges = \"0,100,500,1000,5000\")]\npublic decimal Total { get; set; }\n[ObservabilityField(MetricType Label, Transform = FieldTransform Hash)]\npublic string CustomerId { get; set; } // Becomes hash for privacy\n[ObservabilityField(MetricType Label, Transform = FieldTransform",
        "startIndex": 5274,
        "preview": "else if (systemLoad > 0 5) { config SampleRate = 0 1; // 10% when system is busy } else { config SampleRate = 0 5; // 50% when system is idle } // VIP..."
      },
      {
        "id": "proposals/observability-metrics-chunk-3",
        "text": "// Remove sensitive parts Category // Map to predefined categories } [ObservabilityField(MetricType Label, Transform = FieldTransform Range, Ranges = \"0,100,500,1000,5000\")] public decimal Total { get; set; } [ObservabilityField(MetricType Label, Transform = FieldTransform Hash)] public string CustomerId { get; set; } // Becomes hash for privacy [ObservabilityField(MetricType Label, Transform = FieldTransform Category, \n    Categories = \"standard,premium,enterprise\")]\npublic string CustomerTier { get; set; }\n`\nGenerated Metric Collection\nSource generator creates metric collection code:\n`csharp\n---\ncategory: Design\ndifficulty: ADVANCED\ntags: [Design, Observability, Source-Generation, Metrics-Collection]\ndescription: Source generator creates metric collection code for annotated types\n---\n// Generated metric collection for PlaceOrder\n[GeneratedCode(\"Whizbang SourceGenerator\")]\npublic partial class PlaceOrderMetricsCollector {\n    public static void RecordCommandExecution(PlaceOrder command, CommandResult result, TimeSpan duration) {\n        var labels = new Dictionary<string, object> {\n            [\"command_type\"] = \"PlaceOrder\",\n            [\"customer_id\"] = command CustomerId ToString(),\n            [\"total_range\"] = TransformToRange(command Total, new[] { 0, 100, 500, 1000, 5000 }),\n            [\"region\"] = command Region,\n            [\"status\"] = result Success \"success\" : \"failure\"\n        };\n        _commandDurationHistogram Record(duration TotalSeconds, labels);\n        _commandTotalCounter Add(1, labels);\n        if ( result Success) {\n            _commandErrorsCounter Add(1, labels Concat(new[] {\n                new KeyValuePair<string, object>(\"error_type\", result ErrorType)\n            }));\n        }\n    }\n    private static string TransformToRange(decimal value, decimal[] ranges) {\n        for (int i = 0; i < ranges Length - 1; i++) {\n            if (value >= ranges[i] && value < ranges[i + 1]) {\n                return $\"{ranges[i]}-{ranges[i + 1]}\";\n            }\n        }\n        return $\"{ranges[^1]}+\";\n    }\n}\n`\nOpenTelemetry Integration\nComprehensive Instrumentation\nFull OpenTelemetry implementation with Whizbang-specific semantics:\n`csharp\n---\ncategory: Design\ndifficulty: INTERMEDIATE\ntags: [Design, Observability, OpenTelemetry, Comprehensive-Instrumentation]\ndescription: Full OpenTelemetry implementation with Whizbang-specific semantics\n---\nservices AddWhizbang(options => {\n    options UseOpenTelemetry(otel => {\n        otel ConfigureTracing(tracing => {\n            tracing AddWhizbangInstrumentation() AddAspNetCoreInstrumentation() AddHttpClientInstrumentation() AddEntityFrameworkCoreInstrumentation();\n            // Whizbang-specific trace attributes\n            tracing SetSampler(new WhizbangAdaptiveSampler());\n            tracing AddProcessor<WhizbangSpanProcessor>();\n        });\n        otel ConfigureMetrics(metrics => {\n            metrics AddWhizbangInstrumentation() AddRuntimeInstrumentation() AddAspNetCoreInstrumentation();\n            // Custom metric providers\n            metrics AddMeter(\"Whizbang Commands\");\n            metrics AddMeter(\"Whizbang Events\");\n            metrics AddMeter(\"Whizbang",
        "startIndex": 8267,
        "preview": "// Remove sensitive parts Category // Map to predefined categories } [ObservabilityField(MetricType Label, Transform = FieldTransform Range, Ranges = ..."
      },
      {
        "id": "proposals/observability-metrics-chunk-4",
        "text": "Whizbang-specific semantics --- services AddWhizbang(options => { options UseOpenTelemetry(otel => { otel ConfigureTracing(tracing => { tracing AddWhizbangInstrumentation() AddAspNetCoreInstrumentation() AddHttpClientInstrumentation() AddEntityFrameworkCoreInstrumentation(); // Whizbang-specific trace attributes tracing SetSampler(new WhizbangAdaptiveSampler()); tracing AddProcessor<WhizbangSpanProcessor>(); }); otel ConfigureMetrics(metrics => { metrics AddWhizbangInstrumentation() AddRuntimeInstrumentation() AddAspNetCoreInstrumentation(); // Custom metric providers metrics AddMeter(\"Whizbang Commands\"); metrics AddMeter(\"Whizbang Events\"); metrics AddMeter(\"Whizbang Projections\");\n        });\n        otel ConfigureLogs(logs => {\n            logs AddWhizbangInstrumentation() AddConsoleExporter() AddOpenTelemetryProtocolExporter();\n        });\n    });\n});\n`\nSemantic Conventions\nWhizbang-specific OpenTelemetry semantic conventions:\n`csharp\n---\ncategory: Design\ndifficulty: INTERMEDIATE\ntags: [Design, Observability, OpenTelemetry, Semantic-Conventions]\ndescription: Whizbang-specific OpenTelemetry semantic conventions for consistency\n---\npublic static class WhizbangSemanticConventions {\n    // Span attributes\n    public const string CommandType = \"whizbang command type\";\n    public const string EventType = \"whizbang event type\";\n    public const string ProjectionName = \"whizbang projection name\";\n    public const string Domain = \"whizbang domain\";\n    public const string StreamId = \"whizbang stream id\";\n    public const string StreamVersion = \"whizbang stream version\";\n    public const string CorrelationId = \"whizbang correlation id\";\n    public const string TenantId = \"whizbang tenant id\";\n    // Metric attributes\n    public const string HandlerType = \"whizbang handler type\";\n    public const string DriverType = \"whizbang driver type\";\n    public const string PolicyName = \"whizbang policy name\";\n    public const string FlagValue = \"whizbang flags\";\n    // Resource attributes\n    public const string ServiceDomain = \"whizbang service domain\";\n    public const string ServiceVersion = \"whizbang service version\";\n    public const string LibraryVersion = \"whizbang library version\";\n}\n`csharp\n---\ncategory: Design\ndifficulty: INTERMEDIATE\ntags: [Design, Observability, OpenTelemetry, Command-Instrumentation]\ndescription: Command instrumentation with automatic attribute and custom field capture\n---\n// Usage in instrumentation\npublic class WhizbangCommandInstrumentation : IDisposable {\n    public Activity StartCommandActivity<T>(T command, MessageContext context) where T : ICommand {\n        var activity = Activity StartActivity($\"Command {typeof(T) Name}\");\n        activity SetTag(WhizbangSemanticConventions CommandType, typeof(T) Name);\n        activity SetTag(WhizbangSemanticConventions Domain, context Domain);\n        activity SetTag(WhizbangSemanticConventions CorrelationId, context CorrelationId);\n        if (context TenantId = null) {\n            activity SetTag(WhizbangSemanticConventions TenantId, context",
        "startIndex": 11137,
        "preview": "Whizbang-specific semantics --- services AddWhizbang(options => { options UseOpenTelemetry(otel => { otel ConfigureTracing(tracing => { tracing AddWhi..."
      },
      {
        "id": "proposals/observability-metrics-chunk-5",
        "text": "instrumentation public class WhizbangCommandInstrumentation : IDisposable { public Activity StartCommandActivity<T>(T command, MessageContext context) where T : ICommand { var activity = Activity StartActivity($\"Command {typeof(T) Name}\"); activity SetTag(WhizbangSemanticConventions CommandType, typeof(T) Name); activity SetTag(WhizbangSemanticConventions Domain, context Domain); activity SetTag(WhizbangSemanticConventions CorrelationId, context CorrelationId); if (context TenantId = null) { activity SetTag(WhizbangSemanticConventions TenantId, context TenantId);\n        }\n        // Add custom fields from annotations\n        AddCustomFields(activity, command);\n        return activity;\n    }\n}\n`\nPerformance Budget Integration\nBudget-Aware Observability\nAutomatic performance budget tracking with alerts:\n`csharp\n---\ncategory: Design\ndifficulty: ADVANCED\ntags: [Design, Observability, Performance-Budgets, Automatic-Tracking]\ndescription: Automatic performance budget tracking with alerts and dynamic observability\n---\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        // Performance budgets for specific handlers\n        policies When(ctx => ctx MatchesHandler<PlaceOrderHandler>()) Then(config => config SetPerformanceBudget(new PerformanceBudget {\n                    MaxLatency = TimeSpan FromMilliseconds(100),\n                    MaxMemoryMB = 10,\n                    MaxCpuMs = 50\n                })) And(config => config OnBudgetViolation(async (violation) => {\n                    // Increase observability for budget violations\n                    await _observabilityService IncreaseDetailLevel(\n                        violation HandlerType, \n                        ObservabilityLevel Debug,\n                        duration: TimeSpan FromMinutes(10)\n                    );\n                    // Alert on violations\n                    await _alerting SendBudgetViolationAlert(violation);\n                }));\n        // Default budget tracking settings\n        policies When(ctx => true) // Matches all contexts Then(config => config EnableBudgetTracking()) And(config => config SetBudgetViolationSampleRate(1 0)); // Always capture violations\n    });\n});\n// Generated budget tracking metrics\nwhizbang_performance_budget_violation_total{handler_type, budget_type, severity}\nwhizbang_performance_budget_utilization_ratio{handler_type, budget_type}\nwhizbang_performance_budget_headroom_seconds{handler_type}\n`\nDistributed Tracing\nW3C Trace Context Propagation\nStandards-compliant distributed tracing:\n`csharp\n---\ncategory: Design\ndifficulty: ADVANCED\ntags: [Design, Observability, W3C-Trace-Context, Distributed-Tracing]\ndescription: Standards-compliant W3C trace context propagation implementation\n---\npublic class WhizbangTraceContextPropagator : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        // Extract W3C trace context from message headers\n        var traceParent = context Headers GetValueOrDefault(\"traceparent\");\n        var traceState = context Headers GetValueOrDefault(\"tracestate\");\n        Activity activity = null;\n        if (traceParent = null) {\n            // Continue existing trace\n            var traceContext = W3CTraceContext Parse(traceParent, traceState);\n            activity = Activity StartActivity($\"Handle {typeof(TRequest) Name}\");\n            activity SetParentId(traceContext",
        "startIndex": 13556,
        "preview": "instrumentation public class WhizbangCommandInstrumentation : IDisposable { public Activity StartCommandActivity<T>(T command, MessageContext context)..."
      },
      {
        "id": "proposals/observability-metrics-chunk-6",
        "text": "TResponse> next) { // Extract W3C trace context from message headers var traceParent = context Headers GetValueOrDefault(\"traceparent\"); var traceState = context Headers GetValueOrDefault(\"tracestate\"); Activity activity = null; if (traceParent = null) { // Continue existing trace var traceContext = W3CTraceContext Parse(traceParent, traceState); activity = Activity StartActivity($\"Handle {typeof(TRequest) Name}\"); activity SetParentId(traceContext TraceId, traceContext SpanId);\n        } else {\n            // Start new trace\n            activity = Activity StartActivity($\"Handle {typeof(TRequest) Name}\");\n        }\n        // Add Whizbang-specific context\n        activity SetTag(WhizbangSemanticConventions CommandType, typeof(TRequest) Name);\n        activity SetTag(WhizbangSemanticConventions CorrelationId, context CorrelationId);\n        activity SetTag(WhizbangSemanticConventions Domain, context Domain);\n        // Enhance trace state with Whizbang context\n        var enhancedTraceState = EnhanceTraceState(traceState, context);\n        activity SetTag(\"tracestate\", enhancedTraceState);\n        try {\n            var response = await next(message, context);\n            activity SetTag(\"status\", \"success\");\n            return response;\n        } catch (Exception ex) {\n            activity SetTag(\"status\", \"error\");\n            activity SetTag(\"error type\", ex GetType() Name);\n            activity SetTag(\"error message\", ex Message);\n            throw;\n        } finally {\n            activity Dispose();\n        }\n    }\n    private string EnhanceTraceState(string existingTraceState, MessageContext context) {\n        var whizbangState = new List<string>();\n        if (context CorrelationId = null) {\n            whizbangState Add($\"correlation-id:{context CorrelationId}\");\n        }\n        if (context Domain = null) {\n            whizbangState Add($\"domain:{context Domain}\");\n        }\n        if (context Flags = WhizbangFlags None) {\n            whizbangState Add($\"flags:{(long)context Flags}\");\n        }\n        var newTraceState = $\"whizbang={string Join(\",\", whizbangState)}\";\n        return string IsNullOrEmpty(existingTraceState)",
        "startIndex": 16593,
        "preview": "TResponse> next) { // Extract W3C trace context from message headers var traceParent = context Headers GetValueOrDefault(\"traceparent\"); var traceStat..."
      },
      {
        "id": "proposals/observability-metrics-chunk-7",
        "text": "EnhanceTraceState(string existingTraceState, MessageContext context) { var whizbangState = new List<string>(); if (context CorrelationId = null) { whizbangState Add($\"correlation-id:{context CorrelationId}\"); } if (context Domain = null) { whizbangState Add($\"domain:{context Domain}\"); } if (context Flags = WhizbangFlags None) { whizbangState Add($\"flags:{(long)context Flags}\"); } var newTraceState = $\"whizbang={string Join(\",\", whizbangState)}\"; return string IsNullOrEmpty(existingTraceState) newTraceState \n            : $\"{existingTraceState},{newTraceState}\";\n    }\n}\n`\nMonitoring Dashboards\nPre-built Dashboard Configurations\nReady-to-use monitoring dashboards for popular platforms:\n`json\n---\ncategory: Design\ndifficulty: INTERMEDIATE\ntags: [Design, Observability, Grafana, Dashboard-Configuration]\ndescription: Ready-to-use Grafana dashboard configuration for Whizbang metrics\n---\n// Grafana dashboard configuration\n{\n  \"dashboard\": {\n    \"title\": \"Whizbang Application Metrics\",\n    \"panels\": [\n      {\n        \"title\": \"Command Processing Rate\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(whizbang_command_total[5m])\",\n            \"legendFormat\": \"{{command_type}} ({{domain}})\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Projection Lag\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"whizbang_projection_lag_seconds\",\n            \"legendFormat\": \"{{projection_name}}\"\n          }\n        ],\n        \"thresholds\": [\n          { \"value\": 300, \"color\": \"yellow\" },\n          { \"value\": 600, \"color\": \"red\" }\n        ]\n      },\n      {\n        \"title\": \"Performance Budget Violations\",\n        \"type\": \"table\",\n        \"targets\": [\n          {\n            \"expr\": \"increase(whizbang_performance_budget_violation_total[1h])\",\n            \"format\": \"table\"\n          }\n        ]\n      }\n    ]\n  }\n}\n`\nAlert Rules\nProduction-ready alerting rules:\n`yaml\n---\ncategory: Design\ndifficulty: INTERMEDIATE\ntags: [Design, Observability, Prometheus, Alerting-Rules]\ndescription: Production-ready Prometheus alerting rules for Whizbang applications\n---\nPrometheus alerting rules\ngroups:\nname: whizbang rules\n    rules:\nalert: ProjectionLagHigh\n        expr: whizbang_projection_lag_seconds > 300\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"Projection {{ $labels projection_name }} is lagging\"\n          description: \"Projection {{ $labels projection_name }} has been lagging behind by {{ $value }} seconds for more than 5 minutes\"\nalert: CommandErrorRateHigh\n        expr: rate(whizbang_command_errors_total[5m]) / rate(whizbang_command_total[5m]) > 0 05\n        for: 2m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"High command error rate for {{ $labels command_type }}\"\n          description: \"Command {{ $labels",
        "startIndex": 18339,
        "preview": "EnhanceTraceState(string existingTraceState, MessageContext context) { var whizbangState = new List<string>(); if (context CorrelationId = null) { whi..."
      },
      {
        "id": "proposals/observability-metrics-chunk-8",
        "text": "lagging\" description: \"Projection {{ $labels projection_name }} has been lagging behind by {{ $value }} seconds for more than 5 minutes\" alert: CommandErrorRateHigh expr: rate(whizbang_command_errors_total[5m]) / rate(whizbang_command_total[5m]) > 0 05 for: 2m labels: severity: critical annotations: summary: \"High command error rate for {{ $labels command_type }}\" description: \"Command {{ $labels command_type }} error rate is {{ $value | humanizePercentage }}\"\nalert: PerformanceBudgetViolation\n        expr: increase(whizbang_performance_budget_violation_total[10m]) > 5\n        for: 0m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"Performance budget violations for {{ $labels handler_type }}\"\n          description: \"Handler {{ $labels handler_type }} has violated its performance budget {{ $value }} times in the last 10 minutes\"\n`\nBest Practices\nMetric Design\nControl cardinality - Avoid high-cardinality labels\nUse transformations - Convert IDs to ranges or categories\nStandardize naming - Follow OpenTelemetry conventions\nInclude context - Domain, tenant, and correlation information\nMonitor overhead - Track observability performance impact\nPolicy Configuration\nStart conservative - Begin with standard observability level\nUse adaptive sampling - Reduce overhead under load\nPrioritize critical paths - Enhanced monitoring for important flows\nHandle errors specially - Always capture error scenarios\nRegular review - Adjust policies based on insights\nDashboard Organization\nLayer dashboards - Overview → Domain → Handler specific\nUse SLOs - Define and track service level objectives\nAlert on trends - Early warning indicators\nInclude business metrics - Connect technical to business impact\nRegular maintenance - Keep dashboards current and useful\n---\nRelated Documentation\nPolicy Engine - How policies drive observability\nFlags & Tags System - Cross-service context propagation\nTesting & Development Tools - Testing observability features\nDeployment & Operations - Production monitoring setup",
        "startIndex": 20739,
        "preview": "lagging\" description: \"Projection {{ $labels projection_name }} has been lagging behind by {{ $value }} seconds for more than 5 minutes\" alert: Comman..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "proposals/open-questions",
    "title": "Open Design Questions - RESOLVED",
    "category": "Architecture & Design",
    "url": "/docs/proposals/open-questions",
    "chunks": [
      {
        "id": "proposals/open-questions-chunk-0",
        "text": "Open Design Questions - RESOLVED ✅\nStatus: All critical and important design questions have been resolved and documented in detailed specification documents This document previously captured open questions and architectural decisions for Whizbang All questions have now been resolved and documented in comprehensive specifications 🔴 Critical Decisions - ALL RESOLVED ✅\nAll critical decisions have been resolved and documented",
        "startIndex": 0,
        "preview": "Open Design Questions - RESOLVED ✅\nStatus: All critical and important design questions have been resolved and documented in detailed specification doc..."
      },
      {
        "id": "proposals/open-questions-chunk-1",
        "text": "and important design questions have been resolved and documented in detailed specification documents This document previously captured open questions and architectural decisions for Whizbang All questions have now been resolved and documented in comprehensive specifications 🔴 Critical Decisions - ALL RESOLVED ✅ All critical decisions have been resolved and documented See the detailed specifications below:\nHandler Discovery Mechanism ✅ RESOLVED\nDecision: Hybrid approach (Source Generators + Explicit Registration)\nDetailed Specification: Domain Ownership\nHandler Method Signature Conventions ✅ RESOLVED\nDecision: Convention-based with Source Generator support\nDetailed Specification: Domain Ownership\nEvent Store Schema Design ✅ RESOLVED\nDecision: Hybrid approach (Separate Events and Projections with JSONB)\nDetailed Specification: Event Store & Projections\nOptimistic Concurrency Strategy ✅ RESOLVED\nDecision: Support all strategies (Expected Version, Timestamp-Based, Automatic Retry)\nDetailed Specification: Concurrency Control\nDomain Ownership Declaration ✅ RESOLVED\nDecision: Configurable precedence order (Namespace → Attributes → Configuration)\nDetailed Specification: Domain Ownership\n---\n🟡 Important Decisions - ALL RESOLVED ✅\nProjection Checkpoint Storage ✅ RESOLVED\nDecision: Support both Same Database (default) and Separate Metadata Store\nDetailed Specification: Projection Management\nSnapshot Strategy ✅ RESOLVED\nDecision: Support all strategies (Automatic, Manual, None with Automatic as default)\nDetailed Specification: Event Store & Projections\nProjection Backfilling API ✅ RESOLVED\nDecision: Support both Declarative and Imperative with System Events\nDetailed Specification: Projection Management\nSaga State Persistence ✅ RESOLVED\nDecision: Event-Sourced Sagas as primary pattern\nDetailed Specification: Event Store & Projections\n---\n🟢 Future Considerations - DOCUMENTED ✅\nAll future considerations have been documented in the new specification files:\nMulti-Tenancy Support ✅ DOCUMENTED\nComprehensive support for single/multiple databases and tenant isolation\nDetailed Specification: Multi-Tenancy\nSchema Evolution & Event Versioning ✅ DOCUMENTED\nJSONB-based evolution with upcasting and schema registry support\nDetailed Specification: Schema Evolution\nBlue/Green Projection Deployments ✅ DOCUMENTED\nDriver-level blue/green implementation with atomic table swapping\nDetailed Specification: Schema Evolution\nCross-Aggregate Transactions ✅ DOCUMENTED\nUnit of Work pattern with saga fallback for complex operations\nDetailed Specification: Advanced Features\nOutbox/Inbox Table Schema ✅ DOCUMENTED\nComprehensive outbox/inbox pattern implementation\nDetailed Specification: Event Store & Projections\nDistributed Tracing Context ✅ DOCUMENTED\nW3C trace context headers with OpenTelemetry integration\nDetailed Specification: Advanced Features\nPerformance Budgets & SLOs ✅ DOCUMENTED\nAttribute and programmatic performance budgets with OpenTelemetry\nDetailed Specification: Advanced Features\nKubernetes Operator Features ✅ DOCUMENTED\nAuto-scaling, partition-aware placement, and blue/green deployments\nDetailed Specification: Advanced Features\nDebugging & Development Tools ✅ DOCUMENTED\nOpenTelemetry journey visualization, replay, and state inspection\nDetailed Specification: Advanced Features\n---\nImplementation Status\nAll architectural questions have been resolved and documented in comprehensive specification files",
        "startIndex": 431,
        "preview": "and important design questions have been resolved and documented in detailed specification documents This document previously captured open questions ..."
      },
      {
        "id": "proposals/open-questions-chunk-2",
        "text": "Specification: Advanced Features Kubernetes Operator Features ✅ DOCUMENTED Auto-scaling, partition-aware placement, and blue/green deployments Detailed Specification: Advanced Features Debugging & Development Tools ✅ DOCUMENTED OpenTelemetry journey visualization, replay, and state inspection Detailed Specification: Advanced Features --- Implementation Status All architectural questions have been resolved and documented in comprehensive specification files The library design is now ready for implementation Next Steps\nReview specifications - Study the detailed documentation for each area\nCreate ADRs - Document key decisions in Architecture Decision Records\nBegin implementation - Start building based on the specifications\nValidate with prototypes - Build proof-of-concepts to validate designs\nFor Contributors\nAll major architectural decisions have been made Contributors should:\nRead the specifications before starting work\nFollow the documented patterns in implementation\nPropose changes via GitHub Discussions if specifications need updates\nFor Maintainers\nFocus on:\nImplementation planning - Break down specifications into development tasks\nPrototype validation - Build key components to validate architectural decisions\nDocumentation updates - Keep specifications current as implementation progresses\n---\nComplete Specification Suite\nCore Architecture\nEvent Store & Projections - Storage architecture and JSONB projections\nDomain Ownership - Handler discovery and ownership policies\nConcurrency Control - Multiple concurrency strategies\nAdvanced Features\nProjection Management - Checkpoints, snapshots, and backfilling\nMulti-Tenancy - Comprehensive tenant isolation strategies\nSchema Evolution - JSONB evolution and versioning\nPolicy Engine - Universal configuration scoping mechanism\nFlags & Tags System - Cross-service context propagation\nAdvanced Features - Cross-aggregate transactions, K8s operators, debugging\nImplementation & Tooling\nSource Generation & IDE Integration - Incremental generation and navigation service\nTesting & Development Tools - Comprehensive testing framework and CLI tools\nObservability & Metrics - Policy-driven monitoring and OpenTelemetry\nDeployment & Operations - Production deployment and operational patterns\nFoundation Documents\nPhilosophy - Core principles and design philosophy\nArchitecture - Overall system architecture\n---\nReady to implement",
        "startIndex": 3496,
        "preview": "Specification: Advanced Features Kubernetes Operator Features ✅ DOCUMENTED Auto-scaling, partition-aware placement, and blue/green deployments Detaile..."
      },
      {
        "id": "proposals/open-questions-chunk-3",
        "text": "generation and navigation service Testing & Development Tools - Comprehensive testing framework and CLI tools Observability & Metrics - Policy-driven monitoring and OpenTelemetry Deployment & Operations - Production deployment and operational patterns Foundation Documents Philosophy - Core principles and design philosophy Architecture - Overall system architecture --- Ready to implement All questions resolved, specifications complete, design decisions documented ---\n🆕 New Questions Emerging from Implementation Planning\nAs we dive deeper into the specifications, new architectural questions have emerged that need resolution:\n🔴 Critical Implementation Questions\nSource Generator Architecture ✅ RESOLVED\nDecision: Single incremental generator with pipeline architecture\nKey Requirements:\nIncremental generation - Only regenerate what changed\nIDE integration - Analyzer errors/fixes + navigation service\nMulti-project support - Aggregate generated code across project dependencies\nDebug transparency - No \"magic\", clear generated code + metadata\nBuild observability - Detailed logging and timing for optimization\nImplementation Approach:\n`csharp{\ntitle: \"Incremental Source Generator Implementation\"\ndescription: \"Shows how to implement an incremental source generator with pipeline architecture for Whizbang code generation\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"source-generation\", \"incremental\", \"ide-integration\", \"pipeline\"]\nframework: \"NET8\"\n}\n[Generator]\npublic class WhizbangSourceGenerator : IIncrementalGenerator {\n    public void Initialize(IncrementalGeneratorInitializationContext context) {\n        // Pipeline stages with timing/logging\n        var handlersPipeline = context SyntaxProvider CreateSyntaxProvider( );\n        var domainOwnershipPipeline = context SyntaxProvider CreateSyntaxProvider( );\n        var projectionsPipeline = context SyntaxProvider CreateSyntaxProvider( );\n        // Combine all sources for cross-project aggregation\n        var combinedPipeline = handlersPipeline Combine(domainOwnershipPipeline) Combine(projectionsPipeline);\n        context RegisterSourceOutput(combinedPipeline, GenerateCode);\n        context",
        "startIndex": 5432,
        "preview": "generation and navigation service Testing & Development Tools - Comprehensive testing framework and CLI tools Observability & Metrics - Policy-driven ..."
      },
      {
        "id": "proposals/open-questions-chunk-4",
        "text": "IIncrementalGenerator { public void Initialize(IncrementalGeneratorInitializationContext context) { // Pipeline stages with timing/logging var handlersPipeline = context SyntaxProvider CreateSyntaxProvider( ); var domainOwnershipPipeline = context SyntaxProvider CreateSyntaxProvider( ); var projectionsPipeline = context SyntaxProvider CreateSyntaxProvider( ); // Combine all sources for cross-project aggregation var combinedPipeline = handlersPipeline Combine(domainOwnershipPipeline) Combine(projectionsPipeline); context RegisterSourceOutput(combinedPipeline, GenerateCode); context RegisterSourceOutput(combinedPipeline, GenerateMetadata); // For IDE service\n    }\n}\n// Generated metadata for IDE navigation service\npublic class WhizbangNavigationMetadata {\n    public Dictionary<string, EventStreamInfo> EventStreams { get; set; }\n    public Dictionary<string, HandlerInfo> Handlers { get; set; }\n    public Dictionary<string, ProjectionInfo> Projections { get; set; }\n    public Dictionary<string, DomainInfo> Domains { get; set; }\n}\n`\nIDE Integration Features:\nGitLens-style event stream navigation\nCommand → Handler → Events → Projections flow visualization\nAnalyzer errors for misconfigured ownership/handlers\nCode fixes for common patterns\n---\nDriver Loading & Plugin Architecture ✅ RESOLVED\nDecision: Option A - Explicit registration for simplicity and predictability\nImplementation:\n`csharp{\ntitle: \"Driver Registration Configuration\"\ndescription: \"Demonstrates explicit driver registration with type safety for Event Store, Projections, and Message Broker\"\ncategory: \"Design\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"configuration\", \"drivers\", \"dependency-injection\"]\nframework: \"NET8\"\n}\nservices AddWhizbang(options => {\n    options UseEventStoreDriver<PostgresDriver>(\"connection-string\");\n    options UseProjectionDriver<MongoDriver>(\"mongo-connection\");\n    options UseMessageBrokerDriver<KafkaDriver>(kafka => {\n        kafka BootstrapServers = \"localhost:9092\";\n        kafka EnableIdempotence = true;\n    });\n});\n`\nBenefits:\nClear, explicit dependencies\nCompile-time safety\nPredictable behavior\nEasy to reason about and debug\nWorks well with dependency injection\n---\nMessage Serialization Strategy ✅ RESOLVED\nDecision: Duck-typed serialization with System Text Json default + abstraction layer\nKey Principles:\nDecoupled microservices - No shared dependencies required\nDuck typing - Service1 EventA can deserialize to Service5",
        "startIndex": 7249,
        "preview": "IIncrementalGenerator { public void Initialize(IncrementalGeneratorInitializationContext context) { // Pipeline stages with timing/logging var handler..."
      },
      {
        "id": "proposals/open-questions-chunk-5",
        "text": "Compile-time safety Predictable behavior Easy to reason about and debug Works well with dependency injection --- Message Serialization Strategy ✅ RESOLVED Decision: Duck-typed serialization with System Text Json default + abstraction layer Key Principles: Decoupled microservices - No shared dependencies required Duck typing - Service1 EventA can deserialize to Service5 EventC if shapes match\nInterface support - Both duck-typed and pure-shared interfaces\nPure type sharing - Support shared Domain Models libraries when desired\nZero-copy optimization - When applicable through adapters\nCompression support - Through driver adapters\nImplementation Architecture:\n`csharp{\ntitle: \"Duck-Typed Message Serialization Configuration\"\ndescription: \"Demonstrates duck-typed serialization allowing cross-service message compatibility without shared dependencies\"\ncategory: \"Design\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"serialization\", \"duck-typing\", \"microservices\", \"configuration\"]\nframework: \"NET8\"\n}\n// Duck-typed serialization example\n// Service 1 publishes:\npublic record OrderPlaced(Guid OrderId, string CustomerName, decimal Total);\n// Service 5 receives as:\npublic record OrderReceived(Guid OrderId, string CustomerName, decimal Total);\n// Works automatically via duck typing\n// Interface-based approach (optional)\npublic interface IOrderEvent {\n    Guid OrderId { get; }\n    string CustomerName { get; }\n    decimal Total { get; }\n}\n// Both services can implement the interface\npublic record OrderPlaced( ) : IOrderEvent;\npublic record OrderReceived( ) : IOrderEvent;\n// Serialization configuration\nservices AddWhizbang(options => {\n    options Serialization(serialization => {\n        serialization DefaultSerializer = SystemTextJsonSerializer Default;\n        serialization EnableDuckTyping = true;\n        serialization EnableInterfaceMapping = true;\n        serialization EnableZeroCopy = true; // When supported by driver\n        // Driver-specific optimizations\n        serialization ForDriver<PostgresDriver>() UseJsonOptimizations(jsonb: true);\n        serialization ForDriver<KafkaDriver>() UseCompression(CompressionType",
        "startIndex": 9103,
        "preview": "Compile-time safety Predictable behavior Easy to reason about and debug Works well with dependency injection --- Message Serialization Strategy ✅ RESO..."
      },
      {
        "id": "proposals/open-questions-chunk-6",
        "text": "IOrderEvent; public record OrderReceived( ) : IOrderEvent; // Serialization configuration services AddWhizbang(options => { options Serialization(serialization => { serialization DefaultSerializer = SystemTextJsonSerializer Default; serialization EnableDuckTyping = true; serialization EnableInterfaceMapping = true; serialization EnableZeroCopy = true; // When supported by driver // Driver-specific optimizations serialization ForDriver<PostgresDriver>() UseJsonOptimizations(jsonb: true); serialization ForDriver<KafkaDriver>() UseCompression(CompressionType Gzip);\n    });\n});\n`\nDuck Typing Implementation:\n`csharp{\ntitle: \"Duck-Typing Message Serializer Implementation\"\ndescription: \"Shows implementation of duck-typing serializer that can convert between compatible message types without shared contracts\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"serialization\", \"duck-typing\", \"json\", \"type-conversion\"]\nframework: \"NET8\"\n}\npublic interface IMessageSerializer {\n    T Deserialize<T>(byte[] data, Type sourceType);\n    byte[] Serialize<T>(T message);\n    bool CanDuckType(Type source, Type target);\n}\npublic class DuckTypingJsonSerializer : IMessageSerializer {\n    public T Deserialize<T>(byte[] data, Type sourceType) {\n        if (typeof(T) == sourceType) {\n            return JsonSerializer Deserialize<T>(data);\n        }\n        // Duck typing: deserialize to JObject then convert\n        var json = JsonSerializer Deserialize<JsonObject>(data);\n        return json Deserialize<T>();\n    }\n}\n`\n---\nError Handling & Resilience Patterns ✅ RESOLVED\nDecision: Use Polly as the resilience framework with Whizbang-specific defaults and policies\nCore Principle: Never lose data - prefer backing up streams over discarding messages\nImplementation Strategy:\n`csharp{\ntitle: \"Resilience Policy Configuration with Polly\"\ndescription: \"Demonstrates comprehensive error handling and resilience patterns using Polly with data integrity safeguards\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"resilience\", \"polly\", \"error-handling\", \"circuit-breaker\", \"retry\"]\nframework: \"NET8\"\n}\nservices AddWhizbang(options => {\n    options Resilience(resilience => {\n        // Default policies (can be overridden)\n        resilience DefaultRetryPolicy = Policy Handle<TransientException>() WaitAndRetryAsync(3, retryAttempt => \n                TimeSpan FromSeconds(Math Pow(2, retryAttempt)));\n        resilience DefaultCircuitBreakerPolicy = Policy Handle<Exception>() CircuitBreakerAsync(5, TimeSpan FromMinutes(1));\n        // Data integrity first - back up rather than lose\n        resilience OnMaxRetriesExceeded = (context, exception) => {\n            // Back up the stream, don't discard\n            return ResilienceAction BackupAndHold;\n        };\n        // Per-event/interface/pattern customization\n        resilience ForEvent<OrderPlaced>() UseRetryPolicy(customOrderRetryPolicy);\n        resilience ForInterface<IProjectionHandler>() UseCircuitBreaker(projectionCircuitBreaker);\n        resilience ForPattern(type => type Name EndsWith(\"Command\")) UseTimeout(TimeSpan",
        "startIndex": 10891,
        "preview": "IOrderEvent; public record OrderReceived( ) : IOrderEvent; // Serialization configuration services AddWhizbang(options => { options Serialization(seri..."
      },
      {
        "id": "proposals/open-questions-chunk-7",
        "text": "= Policy Handle<Exception>() CircuitBreakerAsync(5, TimeSpan FromMinutes(1)); // Data integrity first - back up rather than lose resilience OnMaxRetriesExceeded = (context, exception) => { // Back up the stream, don't discard return ResilienceAction BackupAndHold; }; // Per-event/interface/pattern customization resilience ForEvent<OrderPlaced>() UseRetryPolicy(customOrderRetryPolicy); resilience ForInterface<IProjectionHandler>() UseCircuitBreaker(projectionCircuitBreaker); resilience ForPattern(type => type Name EndsWith(\"Command\")) UseTimeout(TimeSpan FromSeconds(30));\n    });\n});\n`\nDefault Behaviors with Safety Warnings:\n`csharp{\ntitle: \"Safe Default Resilience Policies\"\ndescription: \"Defines safe default resilience policies that prioritize data integrity with warnings for dangerous overrides\"\ncategory: \"Design\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"resilience\", \"safety\", \"data-integrity\", \"defaults\"]\nframework: \"NET8\"\n}\n// Safe defaults\npublic static class DefaultResiliencePolicies {\n    public static ResiliencePolicy SafeDefault => new() {\n        MaxRetries = 3,\n        BackoffStrategy = BackoffStrategy ExponentialWithJitter,\n        OnFailure = ResilienceAction BackupAndHold, // SAFE: Don't lose data\n        CircuitBreakerThreshold = 5,\n        CircuitBreakerDuration = TimeSpan FromMinutes(1)\n    };\n    // Dangerous overrides (with warnings)\n    [Obsolete(\"WARNING: This policy may result in data loss Use SafeDefault unless you understand the risks \")]\n    public static ResiliencePolicy DangerousDiscardOnFailure => new() {\n        OnFailure = ResilienceAction Discard // DANGEROUS: May lose data\n    };\n}\n`\nCustomizable Hooks:\n`csharp{\ntitle: \"Resilience Failure Hooks Configuration\"\ndescription: \"Shows how to configure global hooks for handling transient and permanent failures with logging and alerting\"\ncategory: \"Design\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"resilience\", \"hooks\", \"logging\", \"alerting\", \"dead-letter\"]\nframework: \"NET8\"\n}\n// Global hooks\nresilience OnTransientFailure = async (context, exception) => {\n    await _logger LogWarningAsync($\"Transient failure in {context HandlerType}: {exception Message}\");\n};\nresilience OnPermanentFailure = async (context, exception) => {\n    await _alerting SendCriticalAlert($\"Permanent failure in {context HandlerType}: {exception Message}\");\n    await _deadLetterQueue SendAsync(context",
        "startIndex": 13501,
        "preview": "= Policy Handle<Exception>() CircuitBreakerAsync(5, TimeSpan FromMinutes(1)); // Data integrity first - back up rather than lose resilience OnMaxRetri..."
      },
      {
        "id": "proposals/open-questions-chunk-8",
        "text": "tags: [\"resilience\", \"hooks\", \"logging\", \"alerting\", \"dead-letter\"] framework: \"NET8\" } // Global hooks resilience OnTransientFailure = async (context, exception) => { await _logger LogWarningAsync($\"Transient failure in {context HandlerType}: {exception Message}\"); }; resilience OnPermanentFailure = async (context, exception) => { await _alerting SendCriticalAlert($\"Permanent failure in {context HandlerType}: {exception Message}\"); await _deadLetterQueue SendAsync(context Message, exception);\n};\n`\n---\nConfiguration Management Strategy ✅ RESOLVED\nDecision: Hybrid approach - Options B & C (fluent + configuration) with Policy Engine integration\nImplementation Strategy:\n`csharp{\ntitle: \"Hybrid Configuration Strategy\"\ndescription: \"Demonstrates fluent builder pattern combined with policy-driven configuration for type safety and flexibility\"\ncategory: \"Design\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"configuration\", \"fluent-api\", \"policies\", \"multi-environment\"]\nframework: \"NET8\"\n}\n// Fluent builder for type safety and discoverability\nservices AddWhizbang(options => {\n    options UseEventStore<PostgresDriver>(\"connection-string\") UseProjections(proj => proj DefaultStrategy = SnapshotStrategy Automatic) UseDomainOwnership(dom => dom PrecedenceOrder(\"Namespace\", \"Attributes\")) UseMultiTenancy(mt => mt DefaultStrategy = TenancyStrategy SingleDatabase);\n    // Policy-driven configuration\n    options Policies(policies => {\n        policies ForEnvironment(\"Production\") LoadFromConfiguration(\"ProductionPolicies\");\n        policies ForEnvironment(\"Development\") Apply(DevelopmentPolicies Default);\n    });\n});\n// Configuration sections for environment-specific overrides\n{\n  \"Whizbang\": {\n    \"EventStore\": { \"Driver\": \"Postgres\", \"ConnectionString\": \" \" },\n    \"Projections\": { \"DefaultStrategy\": \"Automatic\" },\n    \"Policies\": {\n      \"Production\": [ ],\n      \"Development\": [ ]\n    }\n  }\n}\n`\nBenefits:\nType safety through fluent builder\nFlexibility through configuration sections\nPolicy-driven behavior for environment adaptation\nValidation at startup with clear error messages\n---\nTesting Strategy & Test Helpers ✅ RESOLVED\nDecision: Provide comprehensive testing library including suggested helpers\nImplementation:\n`csharp{\ntitle: \"Comprehensive Testing Framework\"\ndescription: \"Shows the testing library with Given/When/Then pattern, projection testing, and in-memory drivers for fast unit tests\"\ncategory: \"Design\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"testing\", \"given-when-then\", \"unit-tests\", \"in-memory\", \"projections\"]\nframework: \"NET8\"\n}\n// Whizbang",
        "startIndex": 15314,
        "preview": "tags: [\"resilience\", \"hooks\", \"logging\", \"alerting\", \"dead-letter\"] framework: \"NET8\" } // Global hooks resilience OnTransientFailure = async (context..."
      },
      {
        "id": "proposals/open-questions-chunk-9",
        "text": "Test Helpers ✅ RESOLVED Decision: Provide comprehensive testing library including suggested helpers Implementation: `csharp{ title: \"Comprehensive Testing Framework\" description: \"Shows the testing library with Given/When/Then pattern, projection testing, and in-memory drivers for fast unit tests\" category: \"Design\" difficulty: \"INTERMEDIATE\" tags: [\"testing\", \"given-when-then\", \"unit-tests\", \"in-memory\", \"projections\"] framework: \"NET8\" } // Whizbang Testing package\npublic class WhizbangTestFixture {\n    public GivenEventsBuilder Given(params object[] events);\n    public WhenCommandBuilder When(ICommand command);\n    public ThenEventsBuilder Then();\n    // Projection testing\n    public ProjectionTestBuilder ForProjection<TProjection>();\n    // Policy testing\n    public PolicyTestBuilder ForPolicy(string policyName);\n}\n// Usage in tests\n[Test]\npublic async Task PlaceOrder_ShouldEmitOrderPlaced() {\n    await _fixture Given(new CustomerRegistered(customerId, \"John Doe\")) When(new PlaceOrder(orderId, customerId, items)) Then() ShouldEmitEvent<OrderPlaced>() WithProperty(e => e CustomerId, customerId);\n}\n// In-memory drivers for testing\nservices AddWhizbang(options => {\n    options UseInMemoryEventStore()  // For unit tests UseInMemoryProjections() UseInMemoryMessageBroker();\n});\n`\nFeatures:\nIn-memory drivers for fast unit testing\nGiven/When/Then fluent test API\nProjection test helpers with event feeding\nPolicy testing for complex rule validation\nIntegration test helpers with test containers\n---\nMetrics & Observability Data Model ✅ RESOLVED\nDecision: Configurable metrics with policy-driven verbosity and custom field attributes\nDefault Metrics (Always Enabled):\n`csharp{\ntitle: \"Default Observability Metrics\"\ndescription: \"Defines the core performance and infrastructure health metrics that are always enabled in Whizbang\"\ncategory: \"Design\"\ndifficulty: \"BEGINNER\"\ntags: [\"observability\", \"metrics\", \"performance\", \"monitoring\"]\nframework: \"NET8\"\n}\n// Core performance metrics\nwhizbang_command_duration_seconds{command_type, domain, handler_type}\nwhizbang_command_total{command_type, domain, status}\nwhizbang_event_processing_duration_seconds{event_type, handler_type}\nwhizbang_projection_lag_seconds{projection_name}\n// Infrastructure health\nwhizbang_event_store_append_duration_seconds{driver_type}\nwhizbang_message_broker_publish_duration_seconds{broker_type}\n`\nPolicy-Driven Observability:\n`csharp{\ntitle: \"Policy-Driven Observability Configuration\"\ndescription: \"Shows how to configure observability levels using policies based on flags and tags for dynamic monitoring\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"observability\", \"policies\", \"monitoring\", \"telemetry\", \"conditional\"]\nframework: \"NET8\"\n}\nservices AddWhizbang(options => {\n    options Observability(obs => {\n        obs DefaultLevel = ObservabilityLevel Standard;\n        // Policy-based observability levels\n        obs Policies(policies => {\n            policies When(ctx => ctx HasFlag(WhizbangFlags VerboseOtel)) Then(action => action SetObservabilityLevel(ObservabilityLevel",
        "startIndex": 17479,
        "preview": "Test Helpers ✅ RESOLVED Decision: Provide comprehensive testing library including suggested helpers Implementation: `csharp{ title: \"Comprehensive Tes..."
      },
      {
        "id": "proposals/open-questions-chunk-10",
        "text": "flags and tags for dynamic monitoring\" category: \"Design\" difficulty: \"ADVANCED\" tags: [\"observability\", \"policies\", \"monitoring\", \"telemetry\", \"conditional\"] framework: \"NET8\" } services AddWhizbang(options => { options Observability(obs => { obs DefaultLevel = ObservabilityLevel Standard; // Policy-based observability levels obs Policies(policies => { policies When(ctx => ctx HasFlag(WhizbangFlags VerboseOtel)) Then(action => action SetObservabilityLevel(ObservabilityLevel Verbose));\n            policies When(ctx => ctx HasTag(\"critical-path\")) Then(action => action EnableDetailedMetrics()) And(action => action CaptureCustomFields());\n        });\n    });\n});\n`\nCustom Field Attributes for Source Generation:\n`csharp{\ntitle: \"Custom Observability Fields with Attributes\"\ndescription: \"Demonstrates using attributes to include specific event fields in generated metrics for enhanced observability\"\ncategory: \"Design\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"observability\", \"attributes\", \"source-generation\", \"metrics\", \"events\"]\nframework: \"NET8\"\n}\n// Add fields to metadata via attributes\npublic record OrderPlaced(\n    Guid OrderId,\n    [ObservabilityField] Guid CustomerId,    // Include in metrics\n    [ObservabilityField] decimal Total,      // Include in metrics\n    List<OrderItem> Items\n);\n// Generated metric includes custom fields\nwhizbang_event_published_total{event_type=\"OrderPlaced\", customer_id=\"123\", total_range=\"1000-5000\"}\n`\n---\nDevelopment Experience & Tooling ✅ RESOLVED\nDecision: Comprehensive tooling suite as outlined\nPlanned Tools:\n`bash\nCLI tool (whizbang-cli)\nwhizbang new --template microservice --name OrderService\nwhizbang add projection --name OrderSummary --events OrderPlaced,OrderShipped\nwhizbang migrate --from 1 0 --to 2",
        "startIndex": 20193,
        "preview": "flags and tags for dynamic monitoring\" category: \"Design\" difficulty: \"ADVANCED\" tags: [\"observability\", \"policies\", \"monitoring\", \"telemetry\", \"condi..."
      },
      {
        "id": "proposals/open-questions-chunk-11",
        "text": "); // Generated metric includes custom fields whizbang_event_published_total{event_type=\"OrderPlaced\", customer_id=\"123\", total_range=\"1000-5000\"} ` --- Development Experience & Tooling ✅ RESOLVED Decision: Comprehensive tooling suite as outlined Planned Tools: `bash CLI tool (whizbang-cli) whizbang new --template microservice --name OrderService whizbang add projection --name OrderSummary --events OrderPlaced,OrderShipped whizbang migrate --from 1 0 --to 2 0\nwhizbang dashboard --port 5000\nwhizbang replay --stream orders --from 2024-01-01\nVisual Studio integration\ndotnet new whizbang-service --name MyService\ndotnet new whizbang-projection --name OrderSummary\n`\nIDE Extensions:\nNavigation service for GitLens-style event stream traversal\nCode analyzers for ownership and pattern validation\nLive templates for commands, events, projections, sagas\nDebugging tools with state inspection and replay\nWeb Dashboard:\nReal-time projection lag monitoring\nEvent stream visualization\nPolicy rule testing and validation\nPerformance metrics and alerting\nDocumentation: Dedicated tools page and documentation section\n---\nDeployment & Operations Patterns ✅ RESOLVED\nDecision: Embedded library with comprehensive operational hooks\nDeployment Model:\nEmbedded library - Runs within developer's service\nBuilt-in health checks - Ready for Kubernetes probes\nGraceful shutdown - Message draining support NET integration - Hooks into NET hosting lifetime\nImplementation:\n`csharp{\ntitle: \"Deployment Health Checks and Graceful Shutdown\"\ndescription: \"Shows built-in health checks for Kubernetes probes and graceful shutdown with message draining support\"\ncategory: \"Design\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"deployment\", \"health-checks\", \"graceful-shutdown\", \"kubernetes\", \"operations\"]\nframework: \"NET8\"\n}\n// Built-in health checks\nservices AddWhizbang(options => {\n    options HealthChecks(health => {\n        health CheckEventStoreConnection = true;\n        health CheckProjectionLag = true;\n        health CheckMessageBrokerConnection = true;\n        health ProjectionLagThreshold = TimeSpan FromMinutes(5);\n    });\n});\n// Graceful shutdown integration\npublic class WhizbangHostedService : IHostedService {\n    public async Task StopAsync(CancellationToken cancellationToken) {\n        // Drain in-flight messages\n        await _messageProcessor DrainAsync(cancellationToken);\n        // Stop accepting new messages\n        await _messageSubscriptions",
        "startIndex": 21515,
        "preview": "); // Generated metric includes custom fields whizbang_event_published_total{event_type=\"OrderPlaced\", customer_id=\"123\", total_range=\"1000-5000\"} ` -..."
      },
      {
        "id": "proposals/open-questions-chunk-12",
        "text": "{ health CheckEventStoreConnection = true; health CheckProjectionLag = true; health CheckMessageBrokerConnection = true; health ProjectionLagThreshold = TimeSpan FromMinutes(5); }); }); // Graceful shutdown integration public class WhizbangHostedService : IHostedService { public async Task StopAsync(CancellationToken cancellationToken) { // Drain in-flight messages await _messageProcessor DrainAsync(cancellationToken); // Stop accepting new messages await _messageSubscriptions StopAsync(cancellationToken);\n    }\n}\n`\n---\n🟢 Future Enhancement Questions\nEvent Store Scaling Patterns ✅ RESOLVED\nDecision: All suggested scaling patterns should be available as options\nScaling Options:\nSharding strategies - By tenant, aggregate type, time, or custom logic\nRead replicas - For query load distribution\nEvent archiving - Automated cold storage migration\nCross-shard projections - With aggregation support\nAdvanced Saga Patterns\nQuestion: Should Whizbang support more sophisticated saga patterns Considerations:\nSaga compensation - Automatic rollback workflows\nSaga timeouts - What happens when sagas get stuck\nNested sagas - Sagas that spawn other sagas\nSaga state queries - Query current saga states\nReal-time Features\nQuestion: How should Whizbang support real-time scenarios Considerations:\nLive projections - Real-time projection updates\nEvent streaming - WebSocket/SSE event feeds\nPush notifications - Mobile/web notifications\nLive dashboards - Real-time metrics and monitoring\n---\nDecision Process for New Questions\nPrioritize by impact - Focus on critical implementation blockers first\nPrototype when uncertain - Build spikes to validate approaches\nConsider ecosystem integration - How do decisions affect NET ecosystem fit\nBalance simplicity vs power - Don't over-engineer early decisions\nDocument decisions - Update specifications as decisions are made\nNext Steps: Review and prioritize these questions for the implementation phase",
        "startIndex": 23495,
        "preview": "{ health CheckEventStoreConnection = true; health CheckProjectionLag = true; health CheckMessageBrokerConnection = true; health ProjectionLagThreshold..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "proposals/policy-engine",
    "title": "Policy Engine",
    "category": "Architecture & Design",
    "url": "/docs/proposals/policy-engine",
    "chunks": [
      {
        "id": "proposals/policy-engine-chunk-0",
        "text": "Policy Engine\nWhizbang includes a sophisticated policy engine that enables flexible, rule-based configuration for routing, behavior modification, and system adaptation across the entire message lifecycle Core Architecture\nThe Policy Engine is the universal configuration scoping mechanism for Whizbang Rather than having separate configuration systems for each feature, policies provide a unified way to apply configuration based on context, conditions, and scope Every configurable aspect of Whizbang can use policies to determine when and how configuration should be applied:\nConcurrency strategies - Which concurrency approach to use based on message type/context\nObservability levels - How much detail to capture based on flags/environment\nPerformance budgets - Different performance expectations for different scenarios\nSerialization formats - Which serializer to use for different drivers/contexts\nMulti-tenancy isolation - Tenant-specific behavior and storage strategies\nDomain ownership - Dynamic ownership rules based on context\nError handling - Different resilience policies for different message types\nRouting decisions - Which handlers to use based on flags/tags\nSecurity policies - Authentication/authorization rules based on context\nPolicies can evaluate any aspect of the system state:\nMessage content - Properties, types, values within commands/events\nMessage context - Flags, tags, correlation IDs, tenant information\nSystem state - Current load, resource utilization, error rates\nEnvironment - Development, staging, production, feature flags\nUser context - Authentication, authorization, user roles\nTime-based conditions - Business hours, maintenance windows, seasons\nDomain context - Which domain owns the message, cross-domain interactions\nInfrastructure state - Database health, message broker status\nCustom conditions - Any developer-defined evaluation criteria\n> 📋 Message Context: While policies can evaluate any system aspect, the Flags & Tags System provides a convenient way to carry context through message flows",
        "startIndex": 0,
        "preview": "Policy Engine\nWhizbang includes a sophisticated policy engine that enables flexible, rule-based configuration for routing, behavior modification, and ..."
      },
      {
        "id": "proposals/policy-engine-chunk-1",
        "text": "context - Which domain owns the message, cross-domain interactions Infrastructure state - Database health, message broker status Custom conditions - Any developer-defined evaluation criteria > 📋 Message Context: While policies can evaluate any system aspect, the Flags & Tags System provides a convenient way to carry context through message flows Configuration Architecture Principles\nPolicy-Based vs Direct Configuration\nPolicies handle behavioral configuration that varies by context, environment, message type, or runtime conditions:\n`csharp{title=\"Policy-Based vs Direct Configuration\" description=\"Policy-based vs direct configuration showing separation of infrastructure and behavioral settings\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Policy-Engine\", \"Configuration\", \"Behavioral-Configuration\"] framework=\"NET8\"}\n---\nservices AddWhizbang(options => {\n    // INFRASTRUCTURE CONFIGURATION (Direct)\n    // - Connection strings, driver selection, basic setup\n    options UseEventStoreDriver<PostgresDriver>(connectionString);\n    options UseMessageBrokerDriver<KafkaDriver>(kafkaConfig);\n    // BEHAVIORAL CONFIGURATION (Policy-Based)\n    // - Strategies, levels, rules that change based on context\n    options Policies(policies => {\n        // Environment-based behavior\n        policies When(ctx => ctx IsEnvironment(\"production\")) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy ExpectedVersion)) And(config => config SetObservabilityLevel(ObservabilityLevel Standard));\n        // Message type-based behavior\n        policies WhenMessageName(name => name Contains(\"Payment\")) Then(config => config SetStrictSecurity()) And(config => config EnableDetailedAuditing());\n        // Load/context-based behavior\n        policies When(ctx => ctx HasFlag(WhizbangFlags LoadTesting)) Then(config => config",
        "startIndex": 2046,
        "preview": "context - Which domain owns the message, cross-domain interactions Infrastructure state - Database health, message broker status Custom conditions - A..."
      },
      {
        "id": "proposals/policy-engine-chunk-2",
        "text": "Policies(policies => { // Environment-based behavior policies When(ctx => ctx IsEnvironment(\"production\")) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy ExpectedVersion)) And(config => config SetObservabilityLevel(ObservabilityLevel Standard)); // Message type-based behavior policies WhenMessageName(name => name Contains(\"Payment\")) Then(config => config SetStrictSecurity()) And(config => config EnableDetailedAuditing()); // Load/context-based behavior policies When(ctx => ctx HasFlag(WhizbangFlags LoadTesting)) Then(config => config UseOptimizedForThroughput());\n    });\n});\n`\nWhen to use Policies vs Direct Configuration:\n| Configuration Type | Use Policies | Use Direct |\n|-------------------|-------------|------------|\n| Concurrency Strategies | ✅ Context-dependent | ❌ |\n| Observability Levels | ✅ Environment/load dependent | ❌ |\n| Security Policies | ✅ Message/tenant dependent | ❌ |\n| Performance Budgets | ✅ Handler/context dependent | ❌ |\n| Multi-tenancy Strategy | ✅ Tenant-type dependent | ❌ |\n| Connection Strings | ❌ | ✅ Infrastructure |\n| Driver Selection | ✅ Environment dependent | ✅ Simple cases |\n| Basic DI Registration | ❌ | ✅ Infrastructure |\nPolicy Engine Architecture\nUniversal Configuration via Policies\nAll Whizbang configuration can be scoped using policies:\n`csharp{title=\"Universal Configuration via Policies\" description=\"Comprehensive example showing all Whizbang features configured through unified policy system\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Policy-Engine\", \"Universal-Configuration\", \"Complex-Policies\"] framework=\"NET8\"}\n---\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        // === CONCURRENCY STRATEGY POLICIES ===\n        policies When(ctx => ctx MatchesMessage<HighVolumeCommand>()) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy AutomaticRetry)) And(config => config SetMaxRetries(5));\n        policies When(ctx => ctx HasTag(\"critical-transaction\")) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy ExpectedVersion)) And(config => config SetIsolationLevel(IsolationLevel Serializable));\n        // === OBSERVABILITY POLICIES ===\n        policies When(ctx => ctx HasFlag(WhizbangFlags Production)) Then(config => config SetObservabilityLevel(ObservabilityLevel Standard)) And(config => config SetSampleRate(0 1));\n        policies When(ctx => ctx HasTag(\"customer-vip\") || ctx HasFlag(WhizbangFlags VerboseLogging)) Then(config => config SetObservabilityLevel(ObservabilityLevel Verbose)) And(config => config SetSampleRate(1 0)) And(config => config EnableCustomFields());\n        // === PERFORMANCE BUDGET POLICIES ===\n        policies WhenMessageName(name => name EndsWith(\"Command\")) Then(config => config SetPerformanceBudget(new PerformanceBudget {\n                    MaxLatency = TimeSpan",
        "startIndex": 3627,
        "preview": "Policies(policies => { // Environment-based behavior policies When(ctx => ctx IsEnvironment(\"production\")) Then(config => config UseConcurrencyStrateg..."
      },
      {
        "id": "proposals/policy-engine-chunk-3",
        "text": "SetObservabilityLevel(ObservabilityLevel Standard)) And(config => config SetSampleRate(0 1)); policies When(ctx => ctx HasTag(\"customer-vip\") || ctx HasFlag(WhizbangFlags VerboseLogging)) Then(config => config SetObservabilityLevel(ObservabilityLevel Verbose)) And(config => config SetSampleRate(1 0)) And(config => config EnableCustomFields()); // === PERFORMANCE BUDGET POLICIES === policies WhenMessageName(name => name EndsWith(\"Command\")) Then(config => config SetPerformanceBudget(new PerformanceBudget { MaxLatency = TimeSpan FromMilliseconds(500),\n                    MaxMemoryMB = 10\n                }));\n        policies When(ctx => ctx HasTag(\"real-time\")) Then(config => config SetPerformanceBudget(new PerformanceBudget {\n                    MaxLatency = TimeSpan FromMilliseconds(50),\n                    AlertOnViolation = true\n                }));\n        // === SERIALIZATION POLICIES ===\n        policies WhenDriverType<KafkaDriver>() Then(config => config UseSerializer<AvroSerializer>()) And(config => config EnableCompression(CompressionType Gzip));\n        policies WhenDriverType<PostgresDriver>() Then(config => config UseSerializer<JsonSerializer>()) And(config => config EnableJsonbOptimizations());\n        // === MULTI-TENANCY POLICIES ===\n        policies When(ctx => ctx TenantId = null && ctx HasTag(\"enterprise-tenant\")) Then(config => config UseTenancyStrategy(TenancyStrategy SeparateDatabases)) And(config => config EnableTenantIsolation());\n        policies When(ctx => ctx TenantId = null && ctx HasTag(\"startup-tenant\")) Then(config => config UseTenancyStrategy(TenancyStrategy SingleDatabaseWithIsolation)) And(config => config EnableSharedResources());\n        // === ERROR HANDLING POLICIES ===\n        policies WhenMessageName(name => name Contains(\"Payment\")) Then(config => config UseResiliencePolicy(StrictRetryPolicy)) And(config => config SetMaxRetries(3)) And(config => config EnableCircuitBreaker());\n        policies When(ctx => ctx HasFlag(WhizbangFlags LoadTesting)) Then(config => config UseResiliencePolicy(FastFailPolicy)) And(config => config DisableRetries());\n        // === ROUTING POLICIES ===\n        policies When(ctx => ctx HasTag(\"customer-vip\")) Then(config => config RouteToHandler<PremiumOrderHandler>()) And(config => config SetPriority(MessagePriority High));\n        policies When(ctx => ctx SystemLoad > 0 8) Then(config => config RouteToHandler<LightweightOrderHandler>()) And(config => config DeferNonCriticalProcessing());\n        // === SECURITY POLICIES ===\n        policies When(ctx => ctx HasTag(\"pci-data\") || ctx HasTag(\"sensitive\")) Then(config => config RequireEncryption()) And(config => config EnableAuditLogging()) And(config => config RequireAuthorization(\"pci-access\"));\n        policies When(ctx => ctx IsEnvironment(\"production\") && ctx HasTag(\"external-api\")) Then(config => config EnableRateLimiting(100, TimeSpan FromMinutes(1))) And(config => config RequireApiKey());\n    });\n});\n`\nPolicy Combination Strategies\n`csharp{title=\"Policy Combination Strategies\" description=\"Advanced policy combination strategies using intersection, union, and exclusion operations\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Policy-Engine\", \"Policy-Combination\", \"Venn-Diagrams\"] framework=\"NET8\"}\n---\n// Venn diagram-style policy combinations\npolicies Combine(\n    // Policy A: High-priority customers\n    policies",
        "startIndex": 6089,
        "preview": "SetObservabilityLevel(ObservabilityLevel Standard)) And(config => config SetSampleRate(0 1)); policies When(ctx => ctx HasTag(\"customer-vip\") || ctx H..."
      },
      {
        "id": "proposals/policy-engine-chunk-4",
        "text": "Then(config => config EnableRateLimiting(100, TimeSpan FromMinutes(1))) And(config => config RequireApiKey()); }); }); ` Policy Combination Strategies `csharp{title=\"Policy Combination Strategies\" description=\"Advanced policy combination strategies using intersection, union, and exclusion operations\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Policy-Engine\", \"Policy-Combination\", \"Venn-Diagrams\"] framework=\"NET8\"} --- // Venn diagram-style policy combinations policies Combine( // Policy A: High-priority customers policies When(ctx => ctx HasTag(\"customer-vip\")),\n    // Policy B: Large orders with custom condition\n    policies When(ctx => ctx MatchesEvent<OrderPlaced>() && ctx GetEvent<OrderPlaced>() Total > 10000),\n    // Combination strategies\n    CombinationStrategy Intersection  // Both A AND B\n);\npolicies Combine(\n    policies When(ctx => ctx HasFlag(WhizbangFlags LoadTesting)),\n    policies When(ctx => ctx HasFlag(WhizbangFlags DryRun)),\n    CombinationStrategy Union        // Either A OR B\n);\npolicies Combine(\n    policies When(ctx => ctx HasTag(\"batch-import\")),\n    policies When(ctx => ctx HasFlag(WhizbangFlags Migration)),\n    CombinationStrategy Exclusion    // A XOR B (one but not both)\n);\n`\nCanned/Static Policies\n`csharp{title=\"Canned/Static Policies\" description=\"Pre-defined reusable policies for common scenarios with override capabilities\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Policy-Engine\", \"Canned-Policies\", \"Reusable-Patterns\"] framework=\"NET8\"}\n---\n// Pre-defined policies for common scenarios\npublic static class WhizbangPolicies {\n    public static Policy LoadTestingPolicy => new PolicyBuilder() When(ctx => ctx HasFlag(WhizbangFlags LoadTesting)) Then(action => action SkipProjections()) And(action => action DisableSlowOperations()) And(action => action AddTag(\"load-test-ignored\")) Build();\n    public static Policy ProductionSafetyPolicy => new PolicyBuilder() When(ctx => ctx HasFlag(WhizbangFlags Production)) Then(action => action EnableDataScrubbing()) And(action => action EnforceRateLimits()) And(action => action EnableAuditLogging()) Build();\n    public static Policy DevelopmentDebuggingPolicy => new PolicyBuilder() When(ctx => ctx HasFlag(WhizbangFlags Development)) Then(action => action EnableVerboseLogging()) And(action => action EnableBreakpoints()) And(action => action DisableTimeouts()) Build();\n}\n// Apply canned policies\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        policies Apply(WhizbangPolicies LoadTestingPolicy);\n        policies Apply(WhizbangPolicies ProductionSafetyPolicy);\n        policies Apply(WhizbangPolicies DevelopmentDebuggingPolicy);\n        // Custom policies can override or extend canned policies\n        policies When(ctx => ctx HasTag(\"special-case\")) OverridePolicy(WhizbangPolicies ProductionSafetyPolicy) Then(action => action",
        "startIndex": 3013,
        "preview": "Then(config => config EnableRateLimiting(100, TimeSpan FromMinutes(1))) And(config => config RequireApiKey()); }); }); ` Policy Combination Strategies..."
      },
      {
        "id": "proposals/policy-engine-chunk-5",
        "text": "And(action => action EnableBreakpoints()) And(action => action DisableTimeouts()) Build(); } // Apply canned policies services AddWhizbang(options => { options Policies(policies => { policies Apply(WhizbangPolicies LoadTestingPolicy); policies Apply(WhizbangPolicies ProductionSafetyPolicy); policies Apply(WhizbangPolicies DevelopmentDebuggingPolicy); // Custom policies can override or extend canned policies policies When(ctx => ctx HasTag(\"special-case\")) OverridePolicy(WhizbangPolicies ProductionSafetyPolicy) Then(action => action DisableDataScrubbing()); // Override for this case\n    });\n});\n`\nAdvanced Policy Scenarios\nCross-Service Flag Propagation\nFlags carry through entire message journey:\n`csharp{title=\"Cross-Service Flag Propagation\" description=\"Flag propagation across service boundaries maintaining context through entire message journey\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Policy-Engine\", \"Cross-Service-Propagation\", \"Debugging\"] framework=\"NET8\"}\n---\n// Initial command with debugging flags\nvar command = new PlaceOrder(orderId, customerId, items);\nawait _mediator Send(command, context => {\n    context WithFlags(WhizbangFlags VerboseLogging | WhizbangFlags TraceReplay) WithTag(\"debug-session-123\");\n});\n// Flags automatically propagate to:\n// 1 Command handler execution\n// 2 Event publishing\n// 3 Cross-service event delivery\n// 4 Projection updates\n// 5 Saga execution\n// Service 2 receives event with same flags\npublic class InventoryHandler : IEventHandler<OrderPlaced> {\n    public async Task Handle(OrderPlaced @event, EventContext context) {\n        // context Flags contains VerboseLogging | TraceReplay\n        // context Tags contains \"debug-session-123\"\n        if (context HasFlag(WhizbangFlags VerboseLogging)) {\n            _logger LogInformation(\"Processing order with verbose logging enabled\");\n        }\n    }\n}\n`\nData Scrubbing with Policy-Based Duplication\n`csharp{title=\"Data Scrubbing with Policy-Based Duplication\" description=\"Policy-based data scrubbing when promoting production data to QA environment\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Policy-Engine\", \"Data-Scrubbing\", \"Environment-Promotion\"] framework=\"NET8\"}\n---\n// Production to QA data flow with scrubbing\npolicies When(ctx => ctx HasTag(\"production-data\") && ctx HasFlag(WhizbangFlags QA)) Then(action => action DuplicateMessage()) And(action => action ScrubSensitiveData()) And(action => action AddFlag(WhizbangFlags DataScrubbing)) And(action => action RouteToEnvironment(\"qa\"));\n// Handler that applies scrubbing\npublic class DataScrubbingHandler : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message, \n        MessageContext context, \n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        if (context HasFlag(WhizbangFlags DataScrubbing)) {\n            message = _dataScrubber",
        "startIndex": 11874,
        "preview": "And(action => action EnableBreakpoints()) And(action => action DisableTimeouts()) Build(); } // Apply canned policies services AddWhizbang(options => ..."
      },
      {
        "id": "proposals/policy-engine-chunk-6",
        "text": "QA)) Then(action => action DuplicateMessage()) And(action => action ScrubSensitiveData()) And(action => action AddFlag(WhizbangFlags DataScrubbing)) And(action => action RouteToEnvironment(\"qa\")); // Handler that applies scrubbing public class DataScrubbingHandler : IMessageInterceptor { public async Task<TResponse> Intercept<TRequest, TResponse>( TRequest message, MessageContext context, MessageHandlerDelegate<TRequest, TResponse> next) { if (context HasFlag(WhizbangFlags DataScrubbing)) { message = _dataScrubber Scrub(message);\n        }\n        return await next(message, context);\n    }\n}\n`\nDynamic Handler Routing\n`csharp{title=\"Dynamic Handler Routing\" description=\"Dynamic handler routing based on flags and tags with conditional registration\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Policy-Engine\", \"Dynamic-Routing\", \"Handler-Selection\"] framework=\"NET8\"}\n---\n// Route to different handlers based on flags/tags\npolicies When(ctx => ctx HasTag(\"high-value-customer\")) Then(action => action RouteToHandler<PremiumOrderHandler>()) Else(action => action RouteToHandler<StandardOrderHandler>());\npolicies When(ctx => ctx HasFlag(WhizbangFlags LoadTesting)) Then(action => action RouteToHandler<LoadTestOrderHandler>()) And(action => action SkipProjections());\n// Alternative handler registration\nservices AddWhizbang(options => {\n    options RegisterHandler<PlaceOrder, StandardOrderHandler>(); // Default\n    options RegisterHandler<PlaceOrder, PremiumOrderHandler>(\n        condition: ctx => ctx Tags Contains(\"high-value-customer\"));\n    options RegisterHandler<PlaceOrder, LoadTestOrderHandler>(\n        condition: ctx => ctx Flags HasFlag(WhizbangFlags LoadTesting));\n});\n`\nIDE Debugging Support\n`csharp{title=\"IDE Debugging Support\" description=\"Advanced debugging support with IDE integration, breakpoints, and state inspection\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Policy-Engine\", \"IDE-Integration\", \"Debugging\", \"Time-Travel\"] framework=\"NET8\"}\n---\n// IDE cursor/scrubbing mode\npolicies When(ctx => ctx HasFlag(WhizbangFlags CursorMode)) Then(action => action EnableStepByStepExecution()) And(action => action CaptureStateSnapshots()) And(action => action AllowTimeTravel());\n// Breakpoint support\npolicies When(ctx => ctx HasFlag(WhizbangFlags Breakpoint)) Then(action => action PauseExecution()) And(action => action NotifyIDE()) And(action => action CaptureFullContext());\n// State inspection\npublic class StateInspectionInterceptor : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        if (context HasFlag(WhizbangFlags CursorMode)) {\n            await _stateCapture CapturePreExecutionState(message, context);\n        }\n        var response = await next(message, context);\n        if (context HasFlag(WhizbangFlags CursorMode)) {\n            await _stateCapture",
        "startIndex": 14302,
        "preview": "QA)) Then(action => action DuplicateMessage()) And(action => action ScrubSensitiveData()) And(action => action AddFlag(WhizbangFlags DataScrubbing)) A..."
      },
      {
        "id": "proposals/policy-engine-chunk-7",
        "text": "NotifyIDE()) And(action => action CaptureFullContext()); // State inspection public class StateInspectionInterceptor : IMessageInterceptor { public async Task<TResponse> Intercept<TRequest, TResponse>( TRequest message, MessageContext context, MessageHandlerDelegate<TRequest, TResponse> next) { if (context HasFlag(WhizbangFlags CursorMode)) { await _stateCapture CapturePreExecutionState(message, context); } var response = await next(message, context); if (context HasFlag(WhizbangFlags CursorMode)) { await _stateCapture CapturePostExecutionState(response, context);\n        }\n        return response;\n    }\n}\n`\nPolicy Engine Implementation\nCore Interfaces\n`csharp{title=\"Core Interfaces\" description=\"Core policy engine interfaces and action types for implementing the policy system\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Policy-Engine\", \"Core-Interfaces\", \"Implementation\"] framework=\"NET8\"}\n---\npublic interface IPolicyEngine {\n    Task<PolicyResult> EvaluateAsync<T>(T message, MessageContext context);\n    void RegisterPolicy(IPolicy policy);\n    void RegisterPolicies(IEnumerable<IPolicy> policies);\n    IPolicy CombinePolicies(IEnumerable<IPolicy> policies, CombinationStrategy strategy);\n}\npublic interface IPolicy {\n    string Name { get; }\n    int Priority { get; }\n    Task<bool> ShouldApplyAsync<T>(T message, MessageContext context);\n    Task<PolicyAction[]> GetActionsAsync<T>(T message, MessageContext context);\n}\npublic abstract class PolicyAction {\n    public abstract Task ExecuteAsync<T>(T message, MessageContext context);\n}\n// Specific policy actions\npublic class RouteToHandlerAction<THandler> : PolicyAction { }\npublic class AddFlagAction : PolicyAction { }\npublic class AddTagAction : PolicyAction { }\npublic class SkipProjectionsAction : PolicyAction { }\npublic class EnableVerboseLoggingAction : PolicyAction { }\npublic class ScrubDataAction : PolicyAction { }\n`\nTyped Policy Methods\nContext provides strongly-typed matching methods:\n`csharp{title=\"Typed Policy Methods\" description=\"Typed policy methods with strongly-typed context matching and clean policy configuration\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Policy-Engine\", \"Message-Context\", \"Strongly-Typed\"] framework=\"NET8\"}\n---\npublic class MessageContext {\n    // Core properties\n    public string CorrelationId { get; set; }\n    public WhizbangFlags Flags { get; set; }\n    public HashSet<string> Tags { get; set; }\n    public string Environment { get; set; }\n    public string TenantId { get; set; }\n    public Type MessageType { get; set; }\n    public Type AggregateType { get; set; }\n    public Type HandlerType { get; set; }\n    // Strongly-typed matching methods (for types)\n    public bool MatchesMessage<T>() => MessageType == typeof(T);\n    public bool MatchesEvent<T>() where T : IEvent => MessageType == typeof(T);\n    public bool MatchesCommand<T>() where T : ICommand => MessageType == typeof(T);\n    public bool MatchesAggregate<T>() where T : Aggregate => AggregateType == typeof(T);\n    public bool MatchesHandler<T>() => HandlerType == typeof(T);\n    public bool MatchesDriver<T>() => DriverType == typeof(T);\n    // Convenience methods\n    public bool HasFlag(WhizbangFlags flag) => Flags",
        "startIndex": 16860,
        "preview": "NotifyIDE()) And(action => action CaptureFullContext()); // State inspection public class StateInspectionInterceptor : IMessageInterceptor { public as..."
      },
      {
        "id": "proposals/policy-engine-chunk-8",
        "text": "IEvent => MessageType == typeof(T); public bool MatchesCommand<T>() where T : ICommand => MessageType == typeof(T); public bool MatchesAggregate<T>() where T : Aggregate => AggregateType == typeof(T); public bool MatchesHandler<T>() => HandlerType == typeof(T); public bool MatchesDriver<T>() => DriverType == typeof(T); // Convenience methods public bool HasFlag(WhizbangFlags flag) => Flags HasFlag(flag);\n    public bool HasTag(string tag) => Tags Contains(tag);\n    public bool IsEnvironment(string env) => Environment Equals(env, StringComparison OrdinalIgnoreCase);\n}\n// Simple policy builder\npublic interface IPolicyBuilder {\n    IPolicyBuilder When(Func<MessageContext, bool> condition);\n    IPolicyBuilder Then(Action<ConfigurationBuilder> action);\n    IPolicyBuilder And(Action<ConfigurationBuilder> action);\n}\n// Clean, readable policy configuration\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        // Type matching using context methods\n        policies When(ctx => ctx MatchesMessage<PlaceOrder>()) Then(config => config SetPerformanceBudget(orderBudget));\n        policies When(ctx => ctx MatchesAggregate<Order>()) Then(config => config UseConcurrencyStrategy(ConcurrencyStrategy AutomaticRetry));\n        policies When(ctx => ctx MatchesHandler<PaymentHandler>()) Then(config => config RequireEncryption());\n        // Conditional type matching with additional checks\n        policies When(ctx => ctx MatchesEvent<OrderPlaced>() && \n                             ctx GetEvent<OrderPlaced>() Total > 10000) Then(config => config EnableDetailedAuditing());\n        // Pattern matching on message names\n        policies When(ctx => ctx MessageType Name EndsWith(\"Command\")) Then(config => config SetMaxLatency(TimeSpan FromSeconds(1)));\n        // Flag and tag conditions\n        policies When(ctx => ctx HasFlag(WhizbangFlags Production)) Then(config => config SetObservabilityLevel(ObservabilityLevel Standard));\n        policies When(ctx => ctx HasTag(\"critical-path\") && ctx IsEnvironment(\"production\")) Then(config => config SetObservabilityLevel(ObservabilityLevel Detailed));\n        // Complex tenant conditions\n        policies When(ctx => ctx TenantId = null && ctx HasTag(\"enterprise\")) Then(config => config UseTenancyStrategy(TenancyStrategy",
        "startIndex": 19574,
        "preview": "IEvent => MessageType == typeof(T); public bool MatchesCommand<T>() where T : ICommand => MessageType == typeof(T); public bool MatchesAggregate<T>() ..."
      },
      {
        "id": "proposals/policy-engine-chunk-9",
        "text": "config SetMaxLatency(TimeSpan FromSeconds(1))); // Flag and tag conditions policies When(ctx => ctx HasFlag(WhizbangFlags Production)) Then(config => config SetObservabilityLevel(ObservabilityLevel Standard)); policies When(ctx => ctx HasTag(\"critical-path\") && ctx IsEnvironment(\"production\")) Then(config => config SetObservabilityLevel(ObservabilityLevel Detailed)); // Complex tenant conditions policies When(ctx => ctx TenantId = null && ctx HasTag(\"enterprise\")) Then(config => config UseTenancyStrategy(TenancyStrategy SeparateDatabases));\n    });\n});\n`\nPolicy Hashing & Tracing\nEvery policy generates a deterministic hash for tracing and debugging:\n`csharp{title=\"Policy Hashing & Tracing\" description=\"Policy hashing and tracing infrastructure for debugging and policy identification\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Policy-Engine\", \"Policy-Hashing\", \"Debugging\", \"Tracing\"] framework=\"NET8\"}\n---\npublic interface IPolicy {\n    string Name { get; }\n    int Priority { get; }\n    string PolicyHash { get; } // Deterministic hash of policy conditions & actions\n    Task<bool> ShouldApplyAsync<T>(T message, MessageContext context);\n    Task<PolicyAction[]> GetActionsAsync<T>(T message, MessageContext context);\n}\n// Policy hash generation\npublic class PolicyBuilder {\n    public string GeneratePolicyHash() {\n        var hashInput = new {\n            Conditions = _conditions Select(c => c ToHashString()),\n            Actions = _actions Select(a => a ToHashString()),\n            Priority = _priority\n        };\n        using var sha = SHA256 Create();\n        var bytes = sha ComputeHash(Encoding UTF8 GetBytes(JsonSerializer Serialize(hashInput)));\n        return Convert ToBase64String(bytes)[",
        "startIndex": 21614,
        "preview": "config SetMaxLatency(TimeSpan FromSeconds(1))); // Flag and tag conditions policies When(ctx => ctx HasFlag(WhizbangFlags Production)) Then(config => ..."
      },
      {
        "id": "proposals/policy-engine-chunk-10",
        "text": "hash generation public class PolicyBuilder { public string GeneratePolicyHash() { var hashInput = new { Conditions = _conditions Select(c => c ToHashString()), Actions = _actions Select(a => a ToHashString()), Priority = _priority }; using var sha = SHA256 Create(); var bytes = sha ComputeHash(Encoding UTF8 GetBytes(JsonSerializer Serialize(hashInput))); return Convert ToBase64String(bytes)[ 8]; // Short hash for readability\n    }\n}\n// Context carries applied policies\npublic class MessageContext {\n    public string CorrelationId { get; set; }\n    public WhizbangFlags Flags { get; set; }\n    public HashSet<string> Tags { get; set; }\n    // Policy tracking for debugging\n    public List<AppliedPolicy> AppliedPolicies { get; set; } = new();\n    public string ActivePolicyHash { get; set; } // Currently executing policy\n    public Dictionary<string, object> PolicyDecisions { get; set; } = new();\n}\npublic class AppliedPolicy {\n    public string PolicyHash { get; set; }\n    public string PolicyName { get; set; }\n    public DateTimeOffset AppliedAt { get; set; }\n    public Dictionary<string, object> Decisions { get; set; }\n    public TimeSpan EvaluationTime { get; set; }\n}\n`\nDistributed Tracing Integration\nPolicy decisions are traced through OpenTelemetry:\n`csharp{title=\"Distributed Tracing Integration\" description=\"Distributed tracing integration showing policy decisions in OpenTelemetry traces\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Policy-Engine\", \"Distributed-Tracing\", \"OpenTelemetry\"] framework=\"NET8\"}\n---\npublic class PolicyTracingInterceptor : IMessageInterceptor {\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        using var activity = Activity StartActivity(\"PolicyEvaluation\");\n        // Evaluate applicable policies\n        var policies = await _policyEngine EvaluateAsync(message, context);\n        foreach (var policy in policies) {\n            // Add policy hash to trace\n            activity SetTag(\"whizbang policy hash\", policy PolicyHash);\n            activity SetTag(\"whizbang policy name\", policy Name);\n            // Track in context for debugging\n            context AppliedPolicies Add(new AppliedPolicy {\n                PolicyHash = policy PolicyHash,\n                PolicyName = policy Name,\n                AppliedAt = DateTimeOffset UtcNow,\n                Decisions = policy GetDecisions()\n            });\n        }\n        // Include policy hashes in trace state\n        var traceState = $\"policies={string Join(',', policies Select(p => p",
        "startIndex": 22820,
        "preview": "hash generation public class PolicyBuilder { public string GeneratePolicyHash() { var hashInput = new { Conditions = _conditions Select(c => c ToHashS..."
      },
      {
        "id": "proposals/policy-engine-chunk-11",
        "text": "SetTag(\"whizbang policy name\", policy Name); // Track in context for debugging context AppliedPolicies Add(new AppliedPolicy { PolicyHash = policy PolicyHash, PolicyName = policy Name, AppliedAt = DateTimeOffset UtcNow, Decisions = policy GetDecisions() }); } // Include policy hashes in trace state var traceState = $\"policies={string Join(',', policies Select(p => p PolicyHash))}\";\n        activity SetTag(\"tracestate\", traceState);\n        return await next(message, context);\n    }\n}\n// Policy decisions visible in traces\n// Trace: PlaceOrder -> OrderHandler\n//   Tags:\n//     whizbang policy hash: \"Ab3d9F2x\"\n//     whizbang policy name: \"HighValueOrderPolicy\"\n//     whizbang decisions: { \"concurrency\": \"ExpectedVersion\", \"observability\": \"Verbose\" }\n`\nIDE Integration via Source Generation\nSource generator creates policy metadata for IDE tooling:\n`csharp{title=\"IDE Integration via Source Generation\" description=\"Source-generated metadata enabling IDE navigation and policy impact analysis\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Policy-Engine\", \"Source-Generation\", \"IDE-Integration\"] framework=\"NET8\"}\n---\n// Generated policy metadata for IDE navigation\n[GeneratedCode(\"Whizbang SourceGenerator\")]\npublic static class PolicyMetadata {\n    // Map of types to affecting policies\n    public static readonly Dictionary<Type, List<PolicyInfo>> TypePolicies = new() {\n        [typeof(Order)] = new List<PolicyInfo> {\n            new(\"Ab3d9F2x\", \"OrderConcurrencyPolicy\", PolicyEffect ConcurrencyStrategy),\n            new(\"Cd5e8G3y\", \"OrderObservabilityPolicy\", PolicyEffect ObservabilityLevel),\n            new(\"Ef7h2K4z\", \"OrderPerformanceBudget\", PolicyEffect PerformanceBudget)\n        },\n        [typeof(OrderPlaced)] = new List<PolicyInfo> {\n            new(\"Gh9j4M5a\", \"EventRoutingPolicy\", PolicyEffect Routing),\n            new(\"Ij2k6N7b\", \"EventSerializationPolicy\", PolicyEffect Serialization)\n        },\n        [typeof(OrderSummaryProjection)] = new List<PolicyInfo> {\n            new(\"Kl4m8P9c\", \"ProjectionLagPolicy\", PolicyEffect Performance),\n            new(\"Mn6o2Q1d\", \"ProjectionPartitioningPolicy\", PolicyEffect Partitioning)\n        }\n    };\n    // Reverse mapping for \"what does this policy affect \"\n    public static readonly Dictionary<string, List<AffectedType>> PolicyEffects = new() {\n        [\"Ab3d9F2x\"] = new List<AffectedType> {\n            new(typeof(Order), \"Aggregate\", \"Sets concurrency to ExpectedVersion\"),\n            new(typeof(PlaceOrder), \"Command\", \"Inherits aggregate concurrency\"),\n            new(typeof(UpdateOrder), \"Command\", \"Inherits aggregate concurrency\")\n        }\n    };\n    // Policy evaluation paths for debugging\n    public static readonly Dictionary<string, PolicyEvaluationPath> PolicyPaths = new() {\n        [\"Ab3d9F2x\"] = new PolicyEvaluationPath {\n            Conditions = new[] { \"AggregateType == Order\" },\n            Actions = new[] { \"SetConcurrencyStrategy(ExpectedVersion)\" },\n            Priority = 100,\n            Source = \"OrderConcurrencyPolicy",
        "startIndex": 25076,
        "preview": "SetTag(\"whizbang policy name\", policy Name); // Track in context for debugging context AppliedPolicies Add(new AppliedPolicy { PolicyHash = policy Pol..."
      },
      {
        "id": "proposals/policy-engine-chunk-12",
        "text": "\"Inherits aggregate concurrency\"), new(typeof(UpdateOrder), \"Command\", \"Inherits aggregate concurrency\") } }; // Policy evaluation paths for debugging public static readonly Dictionary<string, PolicyEvaluationPath> PolicyPaths = new() { [\"Ab3d9F2x\"] = new PolicyEvaluationPath { Conditions = new[] { \"AggregateType == Order\" }, Actions = new[] { \"SetConcurrencyStrategy(ExpectedVersion)\" }, Priority = 100, Source = \"OrderConcurrencyPolicy cs:line 15\"\n        }\n    };\n}\n`\nGitLens-Style IDE Experience\nVisual Studio/Rider extension shows policy effects inline:\n`csharp{title=\"GitLens-Style IDE Experience\" description=\"Visual Studio/Rider extension shows policy effects inline\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Policy-Engine\", \"IDE-Experience\", \"Visual-Annotations\"] framework=\"NET8\"}\n// OrderAggregate cs\npublic class Order : Aggregate { // 📋 3 policies affect this aggregate [hover for details]\n    // PolicyLens: Ab3d9F2x (Concurrency: ExpectedVersion)\n    // PolicyLens: Cd5e8G3y (Observability: Verbose for orders > $1000)  \n    // PolicyLens: Ef7h2K4z (Performance Budget: 100ms max latency)\n    public void PlaceOrder(CustomerId customerId, List<OrderItem> items) {\n        // PolicyLens: This method triggers policies Ab3d9F2x, Gh9j4M5a\n        Apply(new OrderPlaced( ));\n    }\n}\n// OrderSummaryProjection cs  \npublic class OrderSummaryProjection { // 📋 2 policies affect this projection\n    // PolicyLens: Kl4m8P9c (Max lag: 5 minutes before alert)\n    // PolicyLens: Mn6o2Q1d (Partitioned by CustomerId)\n    public void Handle(OrderPlaced @event) { // PolicyLens: Routed by policy Gh9j4M5a\n        // Update projection }\n}\n`\nPolicy Debugging Commands\nIDE commands for policy investigation:\n`csharp{title=\"Policy Debugging Commands\" description=\"IDE commands for policy investigation\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Policy-Engine\", \"IDE-Commands\", \"Debugging\"] framework=\"NET8\"}\n// Right-click on any type/method in IDE:\n// > Whizbang: Show Affecting Policies\n// > Whizbang: Trace Policy Evaluation  \n// > Whizbang: Simulate Policy Changes\n// > Whizbang: Show Policy History (git blame for policies)\n// Command palette:\n// > Whizbang: What policies affect Order aggregate // > Whizbang: What does policy Ab3d9F2x affect",
        "startIndex": 27753,
        "preview": "\"Inherits aggregate concurrency\"), new(typeof(UpdateOrder), \"Command\", \"Inherits aggregate concurrency\") } }; // Policy evaluation paths for debugging..."
      },
      {
        "id": "proposals/policy-engine-chunk-13",
        "text": "type/method in IDE: // > Whizbang: Show Affecting Policies // > Whizbang: Trace Policy Evaluation // > Whizbang: Simulate Policy Changes // > Whizbang: Show Policy History (git blame for policies) // Command palette: // > Whizbang: What policies affect Order aggregate // > Whizbang: What does policy Ab3d9F2x affect // > Whizbang: Show policy evaluation for PlaceOrder command\n// > Whizbang: Compare policies between environments\n`\nRuntime Policy Debugging\nAccess policy decisions at runtime:\n`csharp{title=\"Runtime Policy Debugging\" description=\"Runtime policy debugging middleware exposing policy decisions through HTTP headers\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Policy-Engine\", \"Runtime-Debugging\", \"HTTP-Headers\"] framework=\"NET8\"}\n---\npublic class PolicyDebugMiddleware {\n    public async Task InvokeAsync(HttpContext context, RequestDelegate next) {\n        // Inject policy debug header\n        context Response OnStarting(() => {\n            var messageContext = context GetMessageContext();\n            if (messageContext AppliedPolicies Any() == true) {\n                var policyHashes = string Join(\",\", \n                    messageContext AppliedPolicies Select(p => p PolicyHash));\n                context Response Headers[\"X-Whizbang-Policies\"] = policyHashes;\n                // Debug mode: include full policy decisions\n                if (context Request Headers ContainsKey(\"X-Debug-Policies\")) {\n                    context Response Headers[\"X-Whizbang-Policy-Decisions\"] = \n                        JsonSerializer Serialize(messageContext PolicyDecisions);\n                }\n            }\n            return Task CompletedTask;\n        });\n        await next(context);\n    }\n}\n// HTTP Response Headers:\n// X-Whizbang-Policies: Ab3d9F2x,Cd5e8G3y,Ef7h2K4z\n// X-Whizbang-Policy-Decisions: {\"concurrency\":\"ExpectedVersion\",\"observability\":\"Verbose\"}\n`\nPolicy Evaluation Pipeline\n`csharp{title=\"Policy Evaluation Pipeline\" description=\"Policy evaluation pipeline with pre and post-execution action application\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Policy-Engine\", \"Pipeline\", \"Pre-Post-Execution\"] framework=\"NET8\"}\n---\npublic class PolicyEvaluationPipeline : IMessageInterceptor {\n    private readonly IPolicyEngine _policyEngine;\n    public async Task<TResponse> Intercept<TRequest, TResponse>(\n        TRequest message,\n        MessageContext context,\n        MessageHandlerDelegate<TRequest, TResponse> next) {\n        // Evaluate policies before handler execution\n        var policyResult = await _policyEngine EvaluateAsync(message, context);\n        // Apply pre-execution actions\n        foreach (var action in policyResult PreExecutionActions) {\n            await action ExecuteAsync(message, context);\n        }\n        // Execute handler (might be changed by policy)\n        var response = await next(message, context);\n        // Apply post-execution actions\n        foreach (var action in policyResult PostExecutionActions) {\n            await action",
        "startIndex": 29609,
        "preview": "type/method in IDE: // > Whizbang: Show Affecting Policies // > Whizbang: Trace Policy Evaluation // > Whizbang: Simulate Policy Changes // > Whizbang..."
      },
      {
        "id": "proposals/policy-engine-chunk-14",
        "text": "var policyResult = await _policyEngine EvaluateAsync(message, context); // Apply pre-execution actions foreach (var action in policyResult PreExecutionActions) { await action ExecuteAsync(message, context); } // Execute handler (might be changed by policy) var response = await next(message, context); // Apply post-execution actions foreach (var action in policyResult PostExecutionActions) { await action ExecuteAsync(response, context);\n        }\n        return response;\n    }\n}\n`\nConfiguration Integration\n`csharp{title=\"Configuration Integration\" description=\"Environment-based policy loading with configuration integration and team-specific policies\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Policy-Engine\", \"Configuration-Integration\", \"Environment-Based\"] framework=\"NET8\"}\n---\n// Environment-based policy loading\nservices AddWhizbang(options => {\n    options Policies(policies => {\n        // Load environment-specific policies\n        if (_environment IsProduction()) {\n            policies LoadFromConfiguration(\"Production\");\n            policies Apply(WhizbangPolicies ProductionSafetyPolicy);\n        } else if (_environment IsDevelopment()) {\n            policies LoadFromConfiguration(\"Development\");\n            policies Apply(WhizbangPolicies DevelopmentDebuggingPolicy);\n        }\n        // Load custom policies from configuration\n        policies LoadFromSection(\"CustomPolicies\");\n        // Team-specific canned policies\n        policies Apply(TeamPolicies DataTeamStandardPolicies);\n        policies Apply(TeamPolicies",
        "startIndex": 32325,
        "preview": "var policyResult = await _policyEngine EvaluateAsync(message, context); // Apply pre-execution actions foreach (var action in policyResult PreExecutio..."
      },
      {
        "id": "proposals/policy-engine-chunk-15",
        "text": "services AddWhizbang(options => { options Policies(policies => { // Load environment-specific policies if (_environment IsProduction()) { policies LoadFromConfiguration(\"Production\"); policies Apply(WhizbangPolicies ProductionSafetyPolicy); } else if (_environment IsDevelopment()) { policies LoadFromConfiguration(\"Development\"); policies Apply(WhizbangPolicies DevelopmentDebuggingPolicy); } // Load custom policies from configuration policies LoadFromSection(\"CustomPolicies\"); // Team-specific canned policies policies Apply(TeamPolicies DataTeamStandardPolicies); policies Apply(TeamPolicies SecurityTeamCompliancePolicies);\n    });\n});\n// Configuration example\n{\n  \"Whizbang\": {\n    \"Policies\": {\n      \"Production\": [\n        {\n          \"Name\": \"ProductionDataScrubbing\",\n          \"Condition\": \"HasFlag('Production') && HasTag('sensitive-data')\",\n          \"Actions\": [\n            { \"Type\": \"ScrubData\", \"Fields\": [\"SSN\", \"CreditCard\"] },\n            { \"Type\": \"AddTag\", \"Value\": \"scrubbed\" }\n          ]\n        }\n      ]\n    }\n  }\n}\n`\nBest Practices\nPolicy Design Guidelines\nKeep policies focused - One policy per concern\nUse clear naming - Policy names should describe their purpose\nDocument side effects - Policies can change behavior significantly\nTest policy interactions - Multiple policies can interact unexpectedly\nMonitor policy performance - Complex policies can impact performance\nFlag Usage Guidelines\nUse library flags first - Prefer built-in flags over custom tags\nDocument custom flags - Make user-defined flags clear to the team\nBe conservative with propagation - Not all flags should cross service boundaries\nConsider flag lifetime - How long should flags persist in the system\nAudit flag usage - Track which flags are used and where\nSecurity Considerations\nValidate flag sources - Ensure flags come from trusted sources\nLimit dangerous flags - SecurityBypass should be heavily restricted\nAudit policy changes - Log all policy modifications\nEncrypt sensitive tags - Some tags may contain sensitive information\nPrinciple of least privilege - Policies should grant minimal necessary permissions\n---\nRelated Documentation\nEvent Store & Projections - How policies affect storage and projections\nDomain Ownership - Policy-based routing and ownership\nAdvanced Features - Debugging and development tools integration",
        "startIndex": 33482,
        "preview": "services AddWhizbang(options => { options Policies(policies => { // Load environment-specific policies if (_environment IsProduction()) { policies Loa..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "proposals/projection-management",
    "title": "Projection Management",
    "category": "Architecture & Design",
    "url": "/docs/proposals/projection-management",
    "chunks": [
      {
        "id": "proposals/projection-management-chunk-0",
        "text": "Projection Management\nWhizbang provides comprehensive projection management including checkpoints, backfilling strategies, system events for on-demand rebuilds, and flexible storage options Checkpoint Storage\nProjections track their progress through checkpoint storage, supporting multiple strategies:\nA Same Database (Default)\nTransactional consistency - checkpoints and projections updated together:\n`csharp{title=\"Transactional Checkpoint Storage Configuration\" description=\"Configuration for transactional checkpoint storage with projections\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"checkpoints\", \"configuration\", \"transactions\"] framework=\"NET8\"}\nservices AddProjection<OrderSummaryProjection>(options => {\n    options CheckpointStorage = CheckpointStorage SameDatabase;\n});\n// Implementation: Single transaction\nawait using var transaction = await database BeginTransactionAsync();\nawait projectionStore UpdateProjection(orderSummary, transaction);\nawait checkpointStore SaveCheckpoint(position, transaction);\nawait transaction CommitAsync();\n`\nBenefits:\n✅ Exactly-once processing guarantee\n✅ Simple consistency model\n✅ No external dependencies\nDrawbacks:\n❌ Tight coupling to projection database\n❌ Limited to single database systems\nB Separate Metadata Store\nFlexible checkpoint storage separate from projection data:\n`csharp{title=\"Separate Checkpoint Storage Configuration\" description=\"Configuration for separate checkpoint storage using Redis or other stores\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"checkpoints\", \"redis\", \"eventually-consistent\"] framework=\"NET8\"}\nservices AddProjection<OrderSummaryProjection>(options => {\n    options CheckpointStorage = CheckpointStorage Separate;\n    options CheckpointStore = CheckpointStore Redis; // or CosmosDB, DynamoDB\n});\n// Implementation: Two-phase with compensation\ntry {\n    await projectionStore UpdateProjection(orderSummary);\n    await checkpointStore SaveCheckpoint(position);\n} catch {\n    // Compensation: projection will be updated again on replay\n    // Idempotent handlers ensure correctness\n}\n`\nBenefits:\n✅ Optimized checkpoint storage (Redis, DynamoDB)\n✅ Cross-database projections supported\n✅ Better performance for high-throughput scenarios\nDrawbacks:\n❌ Eventually consistent\n❌ Requires idempotent projection handlers\nCheckpoint Configuration\n`csharp{title=\"Global Checkpoint Configuration\" description=\"Global checkpoint configuration and storage options\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"configuration\", \"global-settings\", \"checkpoints\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options Projections(projections => {\n        // Global checkpoint settings\n        projections DefaultCheckpointStorage = CheckpointStorage SameDatabase;\n        projections CheckpointFrequency = CheckpointFrequency EveryEvent; // or EveryNEvents(10)\n        // Checkpoint stores\n        projections UseRedisCheckpoints(\"localhost:6379\");\n        projections UseCosmosCheckpoints(\"connection-string\");\n        projections UseSqlCheckpoints(\"connection-string\");\n    });\n});\n`\nSnapshot Management\nA",
        "startIndex": 0,
        "preview": "Projection Management\nWhizbang provides comprehensive projection management including checkpoints, backfilling strategies, system events for on-demand..."
      },
      {
        "id": "proposals/projection-management-chunk-1",
        "text": "and storage options\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"configuration\", \"global-settings\", \"checkpoints\"] framework=\"NET8\"} services AddWhizbang(options => { options Projections(projections => { // Global checkpoint settings projections DefaultCheckpointStorage = CheckpointStorage SameDatabase; projections CheckpointFrequency = CheckpointFrequency EveryEvent; // or EveryNEvents(10) // Checkpoint stores projections UseRedisCheckpoints(\"localhost:6379\"); projections UseCosmosCheckpoints(\"connection-string\"); projections UseSqlCheckpoints(\"connection-string\"); }); }); ` Snapshot Management A Automatic Snapshots (Default)\nConfigurable automatic snapshotting for projections:\n`csharp{title=\"Automatic Snapshot Configuration\" description=\"Automatic snapshot configuration with frequency and retention policies\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"snapshots\", \"automatic-management\"] framework=\"NET8\"}\nservices AddProjection<CustomerSummaryProjection>(options => {\n    options Snapshots(snapshots => {\n        snapshots Strategy = SnapshotStrategy Automatic;\n        snapshots Frequency = SnapshotFrequency EveryNEvents(1000);\n        snapshots RetentionPolicy = SnapshotRetention KeepLast(5);\n    });\n});\n`\nB Manual Snapshots\nDeveloper-controlled snapshotting:\n`csharp{title=\"Manual Snapshot Control\" description=\"Manual snapshot control with custom triggers and restoration logic\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"snapshots\", \"manual-control\", \"triggers\"] framework=\"NET8\"}\npublic class CustomerSummaryProjection : IProjectionHandler<CustomerRegistered>,\n                                        IProjectionHandler<CustomerUpdated>,\n                                        ISnapshotProvider<CustomerSummarySnapshot> {\n    public CustomerSummary State { get; private set; }\n    public async Task Handle(CustomerRegistered @event, ProjectionContext context) {\n        State = new CustomerSummary {\n            CustomerId = @event CustomerId,\n            Name = @event Name,\n            Email = @event Email,\n            RegisteredAt = @event RegisteredAt\n        };\n        await context Store(@event CustomerId ToString(), State);\n    }\n    // Manual snapshot creation\n    [Snapshot(TriggerOn = typeof(CustomerMilestoneReached))]\n    public CustomerSummarySnapshot CreateSnapshot() {\n        return new CustomerSummarySnapshot {\n            CustomerId = State CustomerId,\n            Name = State Name,\n            TotalOrders = State TotalOrders,\n            LifetimeValue = State LifetimeValue,\n            SnapshotVersion = State Version\n        };\n    }\n    public void RestoreFromSnapshot(CustomerSummarySnapshot snapshot) {\n        State = new CustomerSummary {\n            CustomerId = snapshot CustomerId,\n            Name = snapshot Name,\n            TotalOrders = snapshot TotalOrders,\n            LifetimeValue = snapshot LifetimeValue,\n            Version = snapshot SnapshotVersion\n        };\n    }\n}\n`\nC No Snapshots\nOpt out of snapshotting for simple projections:\n`csharp{title=\"Disable Snapshots Configuration\" description=\"Disabling snapshots for simple projections that don't need them\" category=\"Design\" difficulty=\"BEGINNER\" tags=[\"projections\", \"snapshots\", \"simple-projections\"] framework=\"NET8\"}\nservices AddProjection<SimpleEventLogProjection>(options => {\n    options Snapshots(snapshots => {\n        snapshots Strategy = SnapshotStrategy None;\n    });\n});\n`\nBackfilling Strategies\nA",
        "startIndex": 3156,
        "preview": "and storage options\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"configuration\", \"global-settings\", \"checkpoints\"] framework=\"NE..."
      },
      {
        "id": "proposals/projection-management-chunk-2",
        "text": "} } ` C No Snapshots Opt out of snapshotting for simple projections: `csharp{title=\"Disable Snapshots Configuration\" description=\"Disabling snapshots for simple projections that don't need them\" category=\"Design\" difficulty=\"BEGINNER\" tags=[\"projections\", \"snapshots\", \"simple-projections\"] framework=\"NET8\"} services AddProjection<SimpleEventLogProjection>(options => { options Snapshots(snapshots => { snapshots Strategy = SnapshotStrategy None; }); }); ` Backfilling Strategies A Declarative Backfilling\nSimple configuration-based backfilling:\n`csharp{title=\"Declarative Backfilling Configuration\" description=\"Declarative backfilling configuration with date ranges and batch settings\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"backfilling\", \"declarative-configuration\"] framework=\"NET8\"}\nservices AddProjection<OrderHistoryProjection>(options => {\n    options Backfill(backfill => {\n        backfill StartFrom = DateTimeOffset Parse(\"2024-01-01\");\n        backfill AutoStart = true;\n        backfill BatchSize = 1000;\n        backfill MaxConcurrency = 4;\n    });\n});\n// Or backfill everything\nservices AddProjection<NewAnalyticsProjection>(options => {\n    options BackfillFromBeginning();\n});\n`\nB Imperative Backfilling\nProgrammatic control over backfilling:\n`csharp{title=\"Programmatic Backfilling REST API\" description=\"REST API controller for programmatic projection backfilling\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"backfilling\", \"rest-api\", \"controller\"] framework=\"NET8\"}\npublic class BackfillController : ControllerBase {\n    private readonly IProjectionManager _projectionManager;\n    [HttpPost(\"projections/{projectionName}/backfill\")]\n    public async Task<IActionResult> BackfillProjection(\n        string projectionName,\n        BackfillRequest request) {\n        var options = new BackfillOptions {\n            FromDate = request FromDate,\n            ToDate = request ToDate,\n            BatchSize = request BatchSize 1000,\n            IsAtomic = request IsAtomic false,\n            OnProgress = (progress) => {\n                // Real-time progress updates via SignalR\n                _hubContext Clients All SendAsync(\"BackfillProgress\", progress);\n            }\n        };\n        var result = await _projectionManager BackfillAsync(projectionName, options);\n        return Ok(result);\n    }\n}\n`\nSystem Events for On-Demand Backfilling\nEvent-driven backfill requests:\n`csharp{title=\"System Events for Backfilling\" description=\"System events for on-demand projection backfilling with criteria\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"system-events\", \"event-driven-backfill\"] framework=\"NET8\"}\n// System event to trigger backfilling\npublic record ProjectionBackfillRequested(\n    string ProjectionName,\n    DateTimeOffset FromDate,\n    DateTimeOffset",
        "startIndex": 6032,
        "preview": "} } ` C No Snapshots Opt out of snapshotting for simple projections: `csharp{title=\"Disable Snapshots Configuration\" description=\"Disabling snapshots ..."
      },
      {
        "id": "proposals/projection-management-chunk-3",
        "text": "= await _projectionManager BackfillAsync(projectionName, options); return Ok(result); } } ` System Events for On-Demand Backfilling Event-driven backfill requests: `csharp{title=\"System Events for Backfilling\" description=\"System events for on-demand projection backfilling with criteria\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"system-events\", \"event-driven-backfill\"] framework=\"NET8\"} // System event to trigger backfilling public record ProjectionBackfillRequested( string ProjectionName, DateTimeOffset FromDate, DateTimeOffset ToDate,\n    bool IsAtomic,\n    BackfillCriteria Criteria,\n    string RequestedBy\n) : ISystemEvent;\n`csharp{title=\"Backfill System Event Handler\" description=\"System event handler for processing backfill requests\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"system-events\", \"event-handlers\", \"backfilling\"] framework=\"NET8\"}\n// System event handler\npublic class ProjectionBackfillHandler : ISystemEventHandler<ProjectionBackfillRequested> {\n    public async Task Handle(ProjectionBackfillRequested @event, SystemEventContext context) {\n        var options = new BackfillOptions {\n            FromDate = @event FromDate,\n            ToDate = @event ToDate,\n            IsAtomic = @event IsAtomic,\n            Criteria = @event Criteria,\n            RequestId = context CorrelationId\n        };\n        await _projectionManager BackfillAsync(@event ProjectionName, options);\n        // Emit completion event\n        await context PublishSystemEvent(new ProjectionBackfillCompleted(\n            @event ProjectionName,\n            options FromDate,\n            options ToDate,\n            context CorrelationId\n        ));\n    }\n}\n// Trigger backfill via system event\nawait _systemEventPublisher PublishAsync(new ProjectionBackfillRequested(\n    ProjectionName: \"order-summary\",\n    FromDate: DateTimeOffset Parse(\"2024-01-01\"),\n    ToDate: null, // To current\n    IsAtomic: true,\n    Criteria: BackfillCriteria FullRebuild,\n    RequestedBy: \"admin-user\"\n));\n`\nBackfill Criteria Options\n`csharp{title=\"Backfill Criteria Options\" description=\"Comprehensive backfill criteria options for different scenarios\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"backfilling\", \"criteria-options\"] framework=\"NET8\"}\npublic enum BackfillCriteria {\n    // Date-based backfill\n    DateRange,              // Specific date range\n    FromDate,               // From date to current\n    LastNDays,              // Last N days only\n    // Event-based backfill  \n    EventNumberRange,       // Specific event number range\n    FromEventNumber,        // From event number to current\n    LastNEvents,            // Last N events only\n    // Full rebuild options\n    FullRebuild,            // Complete rebuild from beginning\n    IncrementalUpdate,      // Only missing/updated events\n    // Custom criteria\n    CustomPredicate         // Custom filter expression\n}\n// Usage examples\nservices AddProjection<OrderSummaryProjection>(options => {\n    options Backfill(backfill => {\n        backfill Criteria = BackfillCriteria LastNDays;\n        backfill CriteriaValue = 30; // Last 30 days\n    });\n});\n// System event with custom criteria\nawait _systemEvents",
        "startIndex": 8404,
        "preview": "= await _projectionManager BackfillAsync(projectionName, options); return Ok(result); } } ` System Events for On-Demand Backfilling Event-driven backf..."
      },
      {
        "id": "proposals/projection-management-chunk-4",
        "text": "from beginning IncrementalUpdate, // Only missing/updated events // Custom criteria CustomPredicate // Custom filter expression } // Usage examples services AddProjection<OrderSummaryProjection>(options => { options Backfill(backfill => { backfill Criteria = BackfillCriteria LastNDays; backfill CriteriaValue = 30; // Last 30 days }); }); // System event with custom criteria await _systemEvents PublishAsync(new ProjectionBackfillRequested(\n    ProjectionName: \"analytics\",\n    FromDate: null,\n    ToDate: null,\n    IsAtomic: false,\n    Criteria: BackfillCriteria CustomPredicate,\n    RequestedBy: \"system\"\n) {\n    CustomPredicate = @event => @event EventType StartsWith(\"Order\") && \n                               @event Metadata[\"source\"] == \"web-api\"\n});\n`\nAdvanced Backfill Features\nParallel Processing\n`csharp{title=\"Parallel Backfill Processing\" description=\"Parallel backfill processing with partitioning and concurrency control\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"backfilling\", \"parallel-processing\", \"concurrency\"] framework=\"NET8\"}\nservices AddProjection<AnalyticsProjection>(options => {\n    options Backfill(backfill => {\n        backfill Strategy = BackfillStrategy Parallel;\n        backfill PartitionBy = @event => @event StreamId GetHashCode() % 8;\n        backfill MaxConcurrency = 8;\n        backfill BatchSize = 500;\n    });\n});\n`\nProgress Tracking\n`csharp{title=\"Backfill Progress Tracking\" description=\"Real-time progress tracking for backfill operations\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"backfilling\", \"progress-tracking\"] framework=\"NET8\"}\npublic class BackfillProgressTracker {\n    public async Task TrackProgress(string projectionName, CancellationToken cancellationToken) {\n        await foreach (var progress in _projectionManager GetBackfillProgress(projectionName, cancellationToken)) {\n            Console WriteLine($\"Backfill progress: {progress EventsProcessed}/{progress TotalEvents} \" +\n                            $\"({progress PercentComplete:F1}%) - ETA: {progress EstimatedTimeRemaining}\");\n        }\n    }\n}\n`\nRollback Support\n`csharp{title=\"Backfill Rollback Support\" description=\"Rollback support for failed backfill operations with backup creation\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"backfilling\", \"rollback-support\", \"backup\"] framework=\"NET8\"}\n// Rollback to previous version if backfill fails\nservices AddProjection<OrderSummaryProjection>(options => {\n    options Backfill(backfill => {\n        backfill EnableRollback = true;\n        backfill RollbackOnFailure = true;\n        backfill CreateBackupBeforeBackfill = true;\n    });\n});\n// Manual rollback API\nawait _projectionManager",
        "startIndex": 11072,
        "preview": "from beginning IncrementalUpdate, // Only missing/updated events // Custom criteria CustomPredicate // Custom filter expression } // Usage examples se..."
      },
      {
        "id": "proposals/projection-management-chunk-5",
        "text": "for failed backfill operations with backup creation\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"backfilling\", \"rollback-support\", \"backup\"] framework=\"NET8\"} // Rollback to previous version if backfill fails services AddProjection<OrderSummaryProjection>(options => { options Backfill(backfill => { backfill EnableRollback = true; backfill RollbackOnFailure = true; backfill CreateBackupBeforeBackfill = true; }); }); // Manual rollback API await _projectionManager RollbackProjection(\"order-summary\", toVersion: previousVersion);\n`\nSystem Event Integration\nBuilt-in System Events\n`csharp{title=\"Projection Lifecycle System Events\" description=\"Built-in system events for projection lifecycle monitoring\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"system-events\", \"lifecycle-management\"] framework=\"NET8\"}\n// Projection lifecycle events\npublic record ProjectionStarted(string ProjectionName, DateTimeOffset StartedAt);\npublic record ProjectionStopped(string ProjectionName, DateTimeOffset StoppedAt);\npublic record ProjectionFailed(string ProjectionName, Exception Error, DateTimeOffset FailedAt);\n// Backfill events\npublic record ProjectionBackfillStarted(string ProjectionName, BackfillOptions Options);\npublic record ProjectionBackfillProgress(string ProjectionName, BackfillProgress Progress);\npublic record ProjectionBackfillCompleted(string ProjectionName, BackfillResult Result);\npublic record ProjectionBackfillFailed(string ProjectionName, Exception Error);\n// Checkpoint events\npublic record ProjectionCheckpointSaved(string ProjectionName, long Position);\npublic record ProjectionCheckpointRestored(string ProjectionName, long Position);\n// Snapshot events\npublic record ProjectionSnapshotCreated(string ProjectionName, long EventVersion);\npublic record ProjectionSnapshotRestored(string ProjectionName, long EventVersion);\n`\nCustom System Event Handlers\n`csharp{title=\"Projection Monitoring Event Handlers\" description=\"Custom system event handlers for projection monitoring and alerting\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"system-events\", \"monitoring\", \"alerting\"] framework=\"NET8\"}\npublic class ProjectionMonitoringHandler : \n    ISystemEventHandler<ProjectionFailed>,\n    ISystemEventHandler<ProjectionBackfillCompleted> {\n    public async Task Handle(ProjectionFailed @event, SystemEventContext context) {\n        // Alert on projection failures\n        await _alerting SendAlert($\"Projection {@event ProjectionName} failed: {@event Error Message}\");\n        // Automatic retry for transient failures\n        if (IsTransientError(@event Error)) {\n            await context PublishSystemEvent(new ProjectionRestartRequested(\n                @event ProjectionName,\n                retryAttempt: context GetRetryAttempt() + 1\n            ));\n        }\n    }\n    public async Task Handle(ProjectionBackfillCompleted @event, SystemEventContext context) {\n        // Update projection metadata\n        await _projectionMetadata MarkBackfillComplete(@event ProjectionName, @event Result);\n        // Notify stakeholders\n        await _notifications NotifyBackfillComplete(@event",
        "startIndex": 13391,
        "preview": "for failed backfill operations with backup creation\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"projections\", \"backfilling\", \"rollback-support\", \"..."
      },
      {
        "id": "proposals/projection-management-chunk-6",
        "text": "Error Message}\"); // Automatic retry for transient failures if (IsTransientError(@event Error)) { await context PublishSystemEvent(new ProjectionRestartRequested( @event ProjectionName, retryAttempt: context GetRetryAttempt() + 1 )); } } public async Task Handle(ProjectionBackfillCompleted @event, SystemEventContext context) { // Update projection metadata await _projectionMetadata MarkBackfillComplete(@event ProjectionName, @event Result); // Notify stakeholders await _notifications NotifyBackfillComplete(@event ProjectionName);\n    }\n}\n`\nAPI Reference\nIProjectionManager Interface\n`csharp{title=\"IProjectionManager Interface\" description=\"Comprehensive projection management API interface\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"management-api\", \"interfaces\"] framework=\"NET8\"}\npublic interface IProjectionManager {\n    // Lifecycle management\n    Task StartProjection(string projectionName);\n    Task StopProjection(string projectionName);\n    Task RestartProjection(string projectionName);\n    // Backfilling\n    Task<BackfillResult> BackfillAsync(string projectionName, BackfillOptions options);\n    IAsyncEnumerable<BackfillProgress> GetBackfillProgress(string projectionName, CancellationToken cancellationToken);\n    Task CancelBackfill(string projectionName);\n    // Snapshots\n    Task<SnapshotResult> CreateSnapshot(string projectionName);\n    Task<SnapshotResult> RestoreFromSnapshot(string projectionName, long snapshotVersion);\n    Task<IEnumerable<SnapshotInfo>> GetSnapshots(string projectionName);\n    // Checkpoints\n    Task<long> GetCurrentCheckpoint(string projectionName);\n    Task ResetCheckpoint(string projectionName, long position);\n    // Status and monitoring\n    Task<ProjectionStatus> GetStatus(string projectionName);\n    Task<IEnumerable<ProjectionInfo>> GetAllProjections();\n    Task<ProjectionHealth> GetHealth(string projectionName);\n}\n`\nConfiguration Extensions\n`csharp{title=\"Projection Configuration Extensions\" description=\"Extension methods for fluent projection configuration API\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"projections\", \"extension-methods\", \"fluent-api\"] framework=\"NET8\"}\npublic static class ProjectionConfigurationExtensions {\n    public static IProjectionBuilder<T> BackfillFromBeginning<T>(this IProjectionBuilder<T> builder) \n        where T : class;\n    public static IProjectionBuilder<T> BackfillFrom<T>(this IProjectionBuilder<T> builder, DateTimeOffset from) \n        where T : class;\n    public static IProjectionBuilder<T> WithSnapshots<T>(this IProjectionBuilder<T> builder, \n        Action<SnapshotConfiguration> configure) where T : class;\n    public static IProjectionBuilder<T> WithCheckpoints<T>(this IProjectionBuilder<T> builder, \n        Action<CheckpointConfiguration> configure) where T : class;\n    public static IProjectionBuilder<T> OnSystemEvent<T, TEvent>(this IProjectionBuilder<T> builder, \n        Func<TEvent, Task> handler) where T : class where TEvent : ISystemEvent;\n}\n`\nBest Practices\nProjection Design\nKeep projections focused - One projection per query need\nMake handlers idempotent - Support replay scenarios\nHandle missing data gracefully - Events may be out of order\nVersion projection schemas - Enable evolution over time\nBackfill Planning\nTest backfills in staging - Verify performance and correctness\nUse atomic rebuilds for critical projections\nMonitor resource usage during large backfills\nPlan for rollback scenarios if backfill fails\nCheckpoint Strategy\nUse same-database checkpoints for consistency-critical projections\nUse separate checkpoints for high-throughput scenarios\nCheckpoint frequently to minimize replay overhead\nMonitor checkpoint lag for early failure detection\n---\nRelated Documentation\nEvent Store & Projections - Core storage architecture\nMulti-Tenancy - Tenant-aware projection management\nPerformance Optimization - Scaling projection processing",
        "startIndex": 16063,
        "preview": "Error Message}\"); // Automatic retry for transient failures if (IsTransientError(@event Error)) { await context PublishSystemEvent(new ProjectionResta..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "proposals/schema-evolution",
    "title": "Schema Evolution & Event Versioning",
    "category": "Architecture & Design",
    "url": "/docs/proposals/schema-evolution",
    "chunks": [
      {
        "id": "proposals/schema-evolution-chunk-0",
        "text": "Schema Evolution & Event Versioning\nWhizbang provides robust schema evolution capabilities using JSONB storage and flexible driver interfaces, allowing events and projections to evolve over time without breaking existing systems JSONB-Based Schema Evolution\nFlexible Event Schema\nEvents stored in JSONB format naturally support schema evolution:\n`csharp{title=\"Event Schema Evolution\" description=\"Event schema evolution from V1 to V3 with backward-compatible changes\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Schema-Evolution\", \"Event-Versioning\", \"Backward-Compatibility\"] framework=\"NET8\"}\n// V1 Event\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId\n);\n// V2 Event - Add field (backward compatible)\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset PlacedAt = null  // Optional for backward compatibility\n);\n// V3 Event - Add collection (backward compatible)\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset PlacedAt = null,\n    List<string> Tags = null         // Null-safe collection\n) {\n    // Ensure collections are never null\n    public List<string> Tags { get; init; } = Tags new List<string>();\n}\n`\nJSONB benefits:\n✅ Missing fields handled gracefully\n✅ Extra fields ignored during deserialization\n✅ No database schema migrations required\n✅ Query flexibility with JSON operators\nProjection Schema Evolution\nProjections can evolve independently of events:\n`csharp{title=\"Projection Schema Evolution\" description=\"Projection schema evolution without database migrations using JSONB\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Schema-Evolution\", \"Projections\", \"JSONB-Storage\"] framework=\"NET8\"}\n// V1 Projection\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public decimal Total { get; set; }\n    public OrderStatus Status { get; set; }\n}\n// V2 Projection - Add fields without migration\npublic class OrderSummary {\n    public Guid OrderId { get; set; }\n    public decimal Total { get; set; }\n    public OrderStatus Status { get; set; }\n    // New fields with sensible defaults\n    public DateTime EstimatedDelivery { get; set; } = DateTime",
        "startIndex": 0,
        "preview": "Schema Evolution & Event Versioning\nWhizbang provides robust schema evolution capabilities using JSONB storage and flexible driver interfaces, allowin..."
      },
      {
        "id": "proposals/schema-evolution-chunk-1",
        "text": "} } // V2 Projection - Add fields without migration public class OrderSummary { public Guid OrderId { get; set; } public decimal Total { get; set; } public OrderStatus Status { get; set; } // New fields with sensible defaults public DateTime EstimatedDelivery { get; set; } = DateTime MinValue;\n    public List<string> Tags { get; set; } = new();\n    public CustomerInfo Customer { get; set; } = new();\n}\n// Projection rebuild handles missing data gracefully\npublic class OrderSummaryProjection : IProjectionHandler<OrderPlaced> {\n    public async Task Handle(OrderPlaced @event, ProjectionContext context) {\n        var summary = await context Load<OrderSummary>(@event OrderId ToString()) new OrderSummary();\n        summary OrderId = @event OrderId;\n        summary Total = @event Total;\n        // Handle optional V2+ fields\n        if (@event PlacedAt HasValue) {\n            summary EstimatedDelivery = @event PlacedAt Value AddDays(7);\n        }\n        if (@event Tags Any() == true) {\n            summary Tags = @event Tags;\n        }\n        await context Store(@event OrderId ToString(), summary);\n    }\n}\n`\nEvent Versioning Strategies\nA Upcasting (Recommended)\nConvert old events to new schema on read:\n`csharp{title=\"Event Upcaster Interface\" description=\"Event upcasting interface for converting old events to new schemas\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Upcasting\", \"Event-Transformation\", \"Interface\"] framework=\"NET8\"}\npublic interface IEventUpcaster<TOld, TNew> {\n    TNew Upcast(TOld oldEvent);\n    bool CanUpcast(Type eventType, int version);\n}\n`csharp{title=\"Concrete Upcaster Implementation\" description=\"Concrete upcaster implementation for event version migration\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Upcasting\", \"Implementation\", \"Registration\"] framework=\"NET8\"}\n// Upcast V1 OrderPlaced to V2\npublic class OrderPlacedV1ToV2Upcaster : IEventUpcaster<OrderPlacedV1, OrderPlaced> {\n    public OrderPlaced Upcast(OrderPlacedV1 oldEvent) {\n        return new OrderPlaced(\n            oldEvent OrderId,\n            oldEvent CustomerId,\n            PlacedAt: DateTimeOffset UtcNow, // Best guess for missing data\n            Tags: new List<string>()         // Default to empty\n        );\n    }\n    public bool CanUpcast(Type eventType, int version) {\n        return eventType == typeof(OrderPlacedV1) && version == 1;\n    }\n}\n// Registration\nservices AddWhizbang(options => {\n    options EventVersioning(versioning => {\n        versioning AddUpcaster<OrderPlacedV1ToV2Upcaster>();\n        versioning AddUpcaster<OrderPlacedV2ToV3Upcaster>();\n    });\n});\n`\nB",
        "startIndex": 2183,
        "preview": "} } // V2 Projection - Add fields without migration public class OrderSummary { public Guid OrderId { get; set; } public decimal Total { get; set; } p..."
      },
      {
        "id": "proposals/schema-evolution-chunk-2",
        "text": "// Best guess for missing data Tags: new List<string>() // Default to empty ); } public bool CanUpcast(Type eventType, int version) { return eventType == typeof(OrderPlacedV1) && version == 1; } } // Registration services AddWhizbang(options => { options EventVersioning(versioning => { versioning AddUpcaster<OrderPlacedV1ToV2Upcaster>(); versioning AddUpcaster<OrderPlacedV2ToV3Upcaster>(); }); }); ` B Multiple Versions Supported Simultaneously\nKeep multiple event versions active:\n`csharp{title=\"Multiple Version Handlers\" description=\"Supporting multiple event versions simultaneously with separate handlers\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Multiple-Versions\", \"Event-Handlers\", \"Registration\"] framework=\"NET8\"}\n// Multiple handlers for different versions\npublic class OrderPlacedV1Handler : IEventHandler<OrderPlacedV1> {\n    public async Task Handle(OrderPlacedV1 @event, EventContext context) {\n        // Handle legacy V1 events\n        var order = await _repository Load<Order>(@event OrderId);\n        order MarkAsPlaced(placedAt: DateTimeOffset UtcNow); // Default timestamp\n        await _repository Save(order);\n    }\n}\npublic class OrderPlacedV2Handler : IEventHandler<OrderPlaced> {\n    public async Task Handle(OrderPlaced @event, EventContext context) {\n        // Handle current V2+ events\n        var order = await _repository Load<Order>(@event OrderId);\n        order MarkAsPlaced(@event PlacedAt DateTimeOffset UtcNow);\n        await _repository Save(order);\n    }\n}\n// Router determines which handler to use based on event version\nservices AddWhizbang(options => {\n    options EventVersioning(versioning => {\n        versioning RouteByVersion = true;\n        versioning RegisterHandler<OrderPlacedV1Handler>(version: 1);\n        versioning RegisterHandler<OrderPlacedV2Handler>(version: 2);\n    });\n});\n`\nC Schema Registry\nCentralized schema management:\n`csharp{title=\"Schema Registry Configuration\" description=\"Centralized schema registry configuration for schema management\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Schema-Registry\", \"Centralized-Management\", \"Configuration\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options EventVersioning(versioning => {\n        versioning UseSchemaRegistry(registry => {\n            registry ConnectionString = \"https://schema-registry company com\";\n            registry AutoRegisterSchemas = true;\n            registry ValidateOnWrite = true;\n            registry CompatibilityLevel = CompatibilityLevel Backward;\n        });\n    });\n});\n// Events automatically registered with schema registry\n[SchemaRegistration(subject: \"order-placed\", version: 2)]\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset",
        "startIndex": 4572,
        "preview": "// Best guess for missing data Tags: new List<string>() // Default to empty ); } public bool CanUpcast(Type eventType, int version) { return eventType..."
      },
      {
        "id": "proposals/schema-evolution-chunk-3",
        "text": "{ options EventVersioning(versioning => { versioning UseSchemaRegistry(registry => { registry ConnectionString = \"https://schema-registry company com\"; registry AutoRegisterSchemas = true; registry ValidateOnWrite = true; registry CompatibilityLevel = CompatibilityLevel Backward; }); }); }); // Events automatically registered with schema registry [SchemaRegistration(subject: \"order-placed\", version: 2)] public record OrderPlaced( Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt = null\n);\n`\nDriver Interface for Schema Evolution\nAbstract Driver Interface\n`csharp{title=\"Schema Evolution Driver Interface\" description=\"Driver interface for schema evolution with versioning and upcasting support\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Driver-Interface\", \"Serialization\", \"Versioning\"] framework=\"NET8\"}\npublic interface ISchemaEvolutionDriver {\n    // Serialization with versioning\n    Task<byte[]> Serialize<T>(T @event, int version = null);\n    Task<T> Deserialize<T>(byte[] data, int version);\n    Task<object> DeserializeToLatestVersion(byte[] data, Type eventType, int storedVersion);\n    // Schema registration\n    Task RegisterSchema(Type eventType, int version);\n    Task<SchemaInfo> GetSchema(Type eventType, int version);\n    Task<IEnumerable<SchemaInfo>> GetSchemaEvolution(Type eventType);\n    // Upcasting support\n    Task<T> UpcastToLatest<T>(object oldEvent, int fromVersion);\n    bool CanUpcast(Type eventType, int fromVersion, int toVersion);\n}\npublic class SchemaInfo {\n    public Type EventType { get; set; }\n    public int Version { get; set; }\n    public string Schema { get; set; }\n    public DateTime RegisteredAt { get; set; }\n    public CompatibilityLevel Compatibility { get; set; }\n}\n`\nPostgreSQL JSONB Driver Implementation\n`csharp{title=\"PostgreSQL Schema Evolution Driver\" description=\"PostgreSQL JSONB implementation of schema evolution driver with serialization and upcasting\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"PostgreSQL\", \"JSONB-Implementation\", \"Driver\"] framework=\"NET8\"}\npublic class PostgresSchemaEvolutionDriver : ISchemaEvolutionDriver {\n    public async Task<byte[]> Serialize<T>(T @event, int version = null) {\n        var eventType = typeof(T);\n        var currentVersion = version await GetLatestVersion(eventType);\n        var eventData = new {\n            EventType = eventType FullName,\n            Version = currentVersion,\n            Data = @event\n        };\n        return JsonSerializer SerializeToUtf8Bytes(eventData);\n    }\n    public async Task<T> Deserialize<T>(byte[] data, int version) {\n        var eventData = JsonSerializer Deserialize<dynamic>(data);\n        var storedVersion = (int)eventData Version;\n        if (storedVersion == version) {\n            return JsonSerializer Deserialize<T>(eventData Data);\n        }\n        // Need to upcast\n        var oldEvent = DeserializeToVersion(eventData",
        "startIndex": 6952,
        "preview": "{ options EventVersioning(versioning => { versioning UseSchemaRegistry(registry => { registry ConnectionString = \"https://schema-registry company com\"..."
      },
      {
        "id": "proposals/schema-evolution-chunk-4",
        "text": "= eventType FullName, Version = currentVersion, Data = @event }; return JsonSerializer SerializeToUtf8Bytes(eventData); } public async Task<T> Deserialize<T>(byte[] data, int version) { var eventData = JsonSerializer Deserialize<dynamic>(data); var storedVersion = (int)eventData Version; if (storedVersion == version) { return JsonSerializer Deserialize<T>(eventData Data); } // Need to upcast var oldEvent = DeserializeToVersion(eventData Data, typeof(T), storedVersion);\n        return await UpcastToLatest<T>(oldEvent, storedVersion);\n    }\n    public async Task<object> DeserializeToLatestVersion(byte[] data, Type eventType, int storedVersion) {\n        var latestVersion = await GetLatestVersion(eventType);\n        if (storedVersion == latestVersion) {\n            // Already latest version\n            return JsonSerializer Deserialize(data, eventType);\n        }\n        // Upcast to latest\n        var oldEvent = DeserializeToVersion(data, eventType, storedVersion);\n        return await UpcastToLatest(oldEvent, eventType, storedVersion, latestVersion);\n    }\n}\n`\nLINQ Support Evolution\nDriver-Specific LINQ Implementation\n`csharp{title=\"Query Evolution Driver Interface\" description=\"Driver interface for schema-aware LINQ querying across versions\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"LINQ-Support\", \"Querying\", \"Interface\"] framework=\"NET8\"}\npublic interface IQueryEvolutionDriver {\n    IQueryable<T> Query<T>() where T : class;\n    IQueryable<T> QueryVersion<T>(int version) where T : class;\n    IQueryable<object> QueryAllVersions(Type eventType);\n}\n`csharp{title=\"PostgreSQL Query Driver Implementation\" description=\"PostgreSQL implementation with JSONB operators for evolved schemas\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"PostgreSQL\", \"JSONB-Queries\", \"EF-Core\"] framework=\"NET8\"}\n// PostgreSQL implementation with JSONB operators\npublic class PostgresQueryDriver : IQueryEvolutionDriver {\n    public IQueryable<T> Query<T>() where T : class {\n        return _context Events Where(e => e EventType == typeof(T) Name) Select(e => JsonSerializer Deserialize<T>(e EventData)) AsQueryable();\n    }\n    // JSONB path queries for evolved schemas\n    public IQueryable<OrderSummary> QueryOrdersWithTags() {\n        return _context Projections Where(p => p ProjectionName == \"order-summary\") Where(p => EF Functions JsonExists(p Document, \"$ Tags\"))  // Has tags field Select(p => JsonSerializer Deserialize<OrderSummary>(p Document)) AsQueryable();\n    }\n    // Query across schema versions\n    public IQueryable<decimal> QueryOrderTotals() {\n        return _context Events Where(e => e EventType == \"OrderPlaced\") Select(e => EF Functions JsonExtract<decimal>(e EventData, \"$ Total\"))",
        "startIndex": 9408,
        "preview": "= eventType FullName, Version = currentVersion, Data = @event }; return JsonSerializer SerializeToUtf8Bytes(eventData); } public async Task<T> Deseria..."
      },
      {
        "id": "proposals/schema-evolution-chunk-5",
        "text": "=> p ProjectionName == \"order-summary\") Where(p => EF Functions JsonExists(p Document, \"$ Tags\")) // Has tags field Select(p => JsonSerializer Deserialize<OrderSummary>(p Document)) AsQueryable(); } // Query across schema versions public IQueryable<decimal> QueryOrderTotals() { return _context Events Where(e => e EventType == \"OrderPlaced\") Select(e => EF Functions JsonExtract<decimal>(e EventData, \"$ Total\")) AsQueryable();\n    }\n}\n`\nSchema-Aware Query Extensions\n`csharp{title=\"Schema-Aware Query Extensions\" description=\"Extension methods for schema-aware querying and filtering across versions\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Schema-Evolution\", \"LINQ-Extensions\", \"Query-Helpers\", \"Extensions\"] framework=\"NET8\"}\npublic static class SchemaQueryExtensions {\n    public static IQueryable<T> WhereSchemaVersion<T>(this IQueryable<T> query, int version) {\n        // Filter by schema version\n        return query Where(/ version filter logic /);\n    }\n    public static IQueryable<T> WhereHasField<T>(this IQueryable<T> query, string fieldPath) {\n        // Filter by field existence (JSONB support)\n        return query Where(/ field existence logic /);\n    }\n    public static IQueryable<TResult> SelectEvolved<T, TResult>(\n        this IQueryable<T> query, \n        Expression<Func<T, TResult>> selector,\n        SchemaEvolutionOptions options = null) {\n        // Schema-aware projection\n        return query Select(/ evolved selector logic /);\n    }\n}\n// Usage\nvar recentOrdersWithTags = await _context Query<OrderSummary>() WhereHasField(\"Tags\") Where(o => o PlacedAt > DateTime UtcNow AddDays(-30)) ToListAsync();\n`\nBlue/Green Deployment Support\nDriver-Level Blue/Green Implementation\n`csharp{title=\"Blue/Green Deployment Driver\" description=\"Driver interface and implementation for blue/green projection deployments\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Blue-Green-Deployment\", \"Driver-Interface\", \"PostgreSQL\"] framework=\"NET8\"}\npublic interface IBlueGreenDriver {\n    Task<string> CreateGreenDeployment(string projectionName);\n    Task BuildGreenProjection(string projectionName, string greenVersion);\n    Task ValidateGreenProjection(string projectionName, string greenVersion);\n    Task SwitchToGreen(string projectionName, string greenVersion);\n    Task CleanupBlueVersion(string projectionName);\n}\npublic class PostgresBlueGreenDriver : IBlueGreenDriver {\n    public async Task<string> CreateGreenDeployment(string projectionName) {\n        var greenVersion = Guid NewGuid() ToString(\"N\")[ 8];\n        var greenTableName = $\"{projectionName}_green_{greenVersion}\";\n        // Create green table with same schema as blue\n        await _connection",
        "startIndex": 11854,
        "preview": "=> p ProjectionName == \"order-summary\") Where(p => EF Functions JsonExists(p Document, \"$ Tags\")) // Has tags field Select(p => JsonSerializer Deseria..."
      },
      {
        "id": "proposals/schema-evolution-chunk-6",
        "text": "string greenVersion); Task ValidateGreenProjection(string projectionName, string greenVersion); Task SwitchToGreen(string projectionName, string greenVersion); Task CleanupBlueVersion(string projectionName); } public class PostgresBlueGreenDriver : IBlueGreenDriver { public async Task<string> CreateGreenDeployment(string projectionName) { var greenVersion = Guid NewGuid() ToString(\"N\")[ 8]; var greenTableName = $\"{projectionName}_green_{greenVersion}\"; // Create green table with same schema as blue await _connection ExecuteAsync($\"\"\"\n            CREATE TABLE {greenTableName} (LIKE {projectionName} INCLUDING ALL);\n            CREATE INDEX CONCURRENTLY idx_{greenTableName}_tenant \n                ON {greenTableName}(tenant_id) WHERE tenant_id IS NOT NULL;\n        \"\"\");\n        return greenVersion;\n    }\n    public async Task BuildGreenProjection(string projectionName, string greenVersion) {\n        var greenTableName = $\"{projectionName}_green_{greenVersion}\";\n        // Rebuild projection in green table from events\n        await _projectionBuilder RebuildInTable(projectionName, greenTableName);\n    }\n    public async Task SwitchToGreen(string projectionName, string greenVersion) {\n        var greenTableName = $\"{projectionName}_green_{greenVersion}\";\n        var blueBackupName = $\"{projectionName}_blue_backup_{DateTimeOffset UtcNow:yyyyMMdd_HHmmss}\";\n        // Atomic table swap\n        await _connection ExecuteAsync($\"\"\"\n            BEGIN;\n            ALTER TABLE {projectionName} RENAME TO {blueBackupName};\n            ALTER TABLE {greenTableName} RENAME TO {projectionName};\n            COMMIT;\n        \"\"\");\n    }\n}\n`\nConfiguration and Best Practices\nComprehensive Schema Evolution Setup\n`csharp{title=\"Comprehensive Schema Evolution Setup\" description=\"Complete schema evolution configuration with all features enabled\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Schema-Evolution\", \"Configuration\", \"Comprehensive-Setup\", \"Best-Practices\"] framework=\"NET8\"}\nservices AddWhizbang(options => {\n    options SchemaEvolution(evolution => {\n        // Storage format\n        evolution UseJsonb = true;\n        evolution StoreSchemaVersion = true;\n        evolution ValidateOnWrite = false; // Allow forward compatibility\n        // Versioning strategy\n        evolution VersioningStrategy = VersioningStrategy Upcasting;\n        evolution AutoRegisterUpcasterts = true;\n        evolution UpcastOnRead = true;\n        // Schema registry\n        evolution UseSchemaRegistry(registry => {\n            registry Url = \"https://schema-registry internal\";\n            registry AutoRegister = true;\n            registry CompatibilityLevel = CompatibilityLevel Backward;\n        });\n        // Blue/Green deployments\n        evolution BlueGreen(blueGreen => {\n            blueGreen ValidationThreshold = 0 99; // 99% accuracy required\n            blueGreen WarmupPeriod = TimeSpan FromMinutes(5);\n            blueGreen AutoSwitch = false; // Manual approval required\n        });\n    });\n});\n`\nEvent Versioning Best Practices\n`csharp{title=\"Event Versioning Best Practices\" description=\"Best practices for event versioning and backward-compatible schema evolution\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Schema-Evolution\", \"Best-Practices\", \"Backward-Compatibility\", \"Versioning\"] framework=\"NET8\"}\n// 1",
        "startIndex": 14170,
        "preview": "string greenVersion); Task ValidateGreenProjection(string projectionName, string greenVersion); Task SwitchToGreen(string projectionName, string green..."
      },
      {
        "id": "proposals/schema-evolution-chunk-7",
        "text": "= 0 99; // 99% accuracy required blueGreen WarmupPeriod = TimeSpan FromMinutes(5); blueGreen AutoSwitch = false; // Manual approval required }); }); }); ` Event Versioning Best Practices `csharp{title=\"Event Versioning Best Practices\" description=\"Best practices for event versioning and backward-compatible schema evolution\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Schema-Evolution\", \"Best-Practices\", \"Backward-Compatibility\", \"Versioning\"] framework=\"NET8\"} // 1 Always make fields optional when adding them\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    DateTimeOffset PlacedAt = null,      // Optional - added in V2\n    List<string> Tags = null             // Optional - added in V3\n);\n// 2 Use wrapper types for complex evolution\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    OrderMetadata Metadata = null        // Wrapper for evolving fields\n);\npublic record OrderMetadata(\n    DateTimeOffset PlacedAt = null,\n    List<string> Tags = null,\n    CustomerInfo Customer = null\n);\n// 3 Never remove fields - mark as obsolete\npublic record OrderPlaced(\n    Guid OrderId,\n    Guid CustomerId,\n    [Obsolete(\"Use Metadata PlacedAt instead\")]\n    DateTimeOffset PlacedAt = null,      // Keep for backward compatibility\n    OrderMetadata Metadata = null\n);\n// 4 Use semantic versioning for breaking changes\n[EventVersion(\"order-placed\", \"1 0 0\")]\npublic record OrderPlacedV1(Guid OrderId, Guid CustomerId);\n[EventVersion(\"order-placed\", \"1 1 0\")]  // Minor version - additive\npublic record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt = null);\n[EventVersion(\"order-placed\", \"2 0 0\")]  // Major version - breaking change\npublic record OrderPlacedV2(Guid OrderId, CustomerId CustomerId, DateTimeOffset PlacedAt);\n`\nProjection Evolution Guidelines\nAdd fields with defaults - New fields should have sensible default values\nRebuild for major changes - Use blue/green deployment for breaking changes\nTest evolution paths - Verify old events work with new projections\nMonitor data quality - Track schema evolution impact on data\nDocument changes - Keep clear records of schema evolution decisions\n---\nRelated Documentation\nEvent Store & Projections - Core storage architecture\nProjection Management - Backfilling and rebuilding strategies\nAdvanced Features - Cross-aggregate transactions and distributed tracing",
        "startIndex": 16982,
        "preview": "= 0 99; // 99% accuracy required blueGreen WarmupPeriod = TimeSpan FromMinutes(5); blueGreen AutoSwitch = false; // Manual approval required }); }); }..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "proposals/source-generation-ide",
    "title": "Source Generation & IDE Integration",
    "category": "Architecture & Design",
    "url": "/docs/proposals/source-generation-ide",
    "chunks": [
      {
        "id": "proposals/source-generation-ide-chunk-0",
        "text": "Source Generation & IDE Integration\nWhizbang uses advanced source generation and IDE integration to provide a seamless developer experience with compile-time validation, intelligent navigation, and powerful debugging tools Source Generator Architecture\nSingle Pipeline Generator\nIncremental source generator with orchestrated pipeline stages for optimal performance:\n`csharp{\ntitle: \"Incremental Source Generator\"\ndescription: \"Single incremental source generator with orchestrated pipeline stages\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"Design\", \"Source-Generation\", \"Incremental-Generation\", \"Pipeline-Architecture\"]\nframework: \"NET8\"\n}\n[Generator]\npublic class WhizbangSourceGenerator : IIncrementalGenerator {\n    public void Initialize(IncrementalGeneratorInitializationContext context) {\n        // Stage 1: Handler Discovery Pipeline\n        var handlersPipeline = context SyntaxProvider CreateSyntaxProvider(\n            predicate: (node, _) => IsHandlerCandidate(node),\n            transform: (ctx, _) => ExtractHandlerInfo(ctx)\n        ) Where(info => info = null);\n        // Stage 2: Domain Ownership Pipeline  \n        var domainOwnershipPipeline = context SyntaxProvider CreateSyntaxProvider(\n            predicate: (node, _) => IsDomainCandidate(node),\n            transform: (ctx, _) => ExtractDomainInfo(ctx)\n        );\n        // Stage 3: Projection Pipeline\n        var projectionsPipeline = context SyntaxProvider CreateSyntaxProvider(\n            predicate: (node, _) => IsProjectionCandidate(node),\n            transform: (ctx, _) => ExtractProjectionInfo(ctx)\n        );\n        // Stage 4: Policy Pipeline\n        var policiesPipeline = context SyntaxProvider CreateSyntaxProvider(\n            predicate: (node, _) => IsPolicyCandidate(node),\n            transform: (ctx, _) => ExtractPolicyInfo(ctx)\n        );\n        // Combine all sources for cross-project aggregation\n        var combinedPipeline = handlersPipeline Combine(domainOwnershipPipeline) Combine(projectionsPipeline) Combine(policiesPipeline);\n        // Generate code\n        context RegisterSourceOutput(combinedPipeline, GenerateWhizbangRegistry);\n        // Generate metadata for IDE service\n        context RegisterSourceOutput(combinedPipeline, GenerateNavigationMetadata);\n        // Generate analyzer data\n        context RegisterSourceOutput(combinedPipeline, GenerateAnalyzerData);\n    }\n}\n`\nBuild Performance & Logging\nDetailed timing and logging for optimization:\n`csharp{\ntitle: \"Performance Tracker\"\ndescription: \"Performance tracking for source generation stages with detailed timing\"\ncategory: \"Design\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Design\", \"Source-Generation\", \"Performance-Tracking\", \"Build-Optimization\"]\nframework: \"NET8\"\n}\npublic class GenerationPerformanceTracker {\n    private readonly Dictionary<string, Stopwatch> _stageTimers = new();\n    public void StartStage(string stageName) {\n        _stageTimers[stageName] = Stopwatch StartNew();\n        LogInformation($\"Starting stage: {stageName}\");\n    }\n    public void EndStage(string stageName) {\n        if (_stageTimers TryGetValue(stageName, out var timer)) {\n            timer Stop();\n            LogInformation($\"Completed stage: {stageName} in {timer",
        "startIndex": 0,
        "preview": "Source Generation & IDE Integration\nWhizbang uses advanced source generation and IDE integration to provide a seamless developer experience with compi..."
      },
      {
        "id": "proposals/source-generation-ide-chunk-1",
        "text": "[\"Design\", \"Source-Generation\", \"Performance-Tracking\", \"Build-Optimization\"] framework: \"NET8\" } public class GenerationPerformanceTracker { private readonly Dictionary<string, Stopwatch> _stageTimers = new(); public void StartStage(string stageName) { _stageTimers[stageName] = Stopwatch StartNew(); LogInformation($\"Starting stage: {stageName}\"); } public void EndStage(string stageName) { if (_stageTimers TryGetValue(stageName, out var timer)) { timer Stop(); LogInformation($\"Completed stage: {stageName} in {timer ElapsedMilliseconds}ms\");\n        }\n    }\n    public void LogSummary() {\n        var totalTime = _stageTimers Values Sum(t => t ElapsedMilliseconds);\n        LogInformation($\"Total generation time: {totalTime}ms\");\n        foreach (var (stage, timer) in _stageTimers) {\n            var percentage = (timer ElapsedMilliseconds / (double)totalTime) * 100;\n            LogInformation($\"  {stage}: {timer ElapsedMilliseconds}ms ({percentage:F1}%)\");\n        }\n    }\n}\n`\nMulti-Project Aggregation\nCross-assembly handler discovery and registration:\n`csharp{\ntitle: \"Cross-Project Registry\"\ndescription: \"Generated registry that aggregates handlers across multiple projects\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"Design\", \"Source-Generation\", \"Multi-Project-Aggregation\", \"Code-Generation\"]\nframework: \"NET8\"\n}\n// Generated registry aggregates across projects\n[GeneratedCode(\"Whizbang SourceGenerator\")]\npublic static class WhizbangGeneratedRegistry {\n    public static void RegisterAll(IServiceCollection services) {\n        // Handlers from current project\n        RegisterLocalHandlers(services);\n        // Handlers from referenced projects\n        RegisterReferencedHandlers(services);\n        // Domain ownership from all projects\n        RegisterDomainOwnership(services);\n        // Policies from all projects\n        RegisterPolicies(services);\n    }\n    private static void RegisterLocalHandlers(IServiceCollection services) {\n        services AddScoped<ICommandHandler<PlaceOrder>, PlaceOrderHandler>();\n        services AddScoped<IEventHandler<OrderPlaced>, OrderSummaryProjection>();\n        // other local handlers\n    }\n    private static void RegisterReferencedHandlers(IServiceCollection services) {\n        // Handlers discovered from referenced assemblies\n        SharedLibrary WhizbangRegistry RegisterHandlers(services);\n        CoreDomain WhizbangRegistry",
        "startIndex": 3279,
        "preview": "[\"Design\", \"Source-Generation\", \"Performance-Tracking\", \"Build-Optimization\"] framework: \"NET8\" } public class GenerationPerformanceTracker { private ..."
      },
      {
        "id": "proposals/source-generation-ide-chunk-2",
        "text": "projects RegisterReferencedHandlers(services); // Domain ownership from all projects RegisterDomainOwnership(services); // Policies from all projects RegisterPolicies(services); } private static void RegisterLocalHandlers(IServiceCollection services) { services AddScoped<ICommandHandler<PlaceOrder>, PlaceOrderHandler>(); services AddScoped<IEventHandler<OrderPlaced>, OrderSummaryProjection>(); // other local handlers } private static void RegisterReferencedHandlers(IServiceCollection services) { // Handlers discovered from referenced assemblies SharedLibrary WhizbangRegistry RegisterHandlers(services); CoreDomain WhizbangRegistry RegisterHandlers(services);\n    }\n}\n`\nIDE Navigation Service\nEvent Stream Navigation\nGitLens-style navigation through event streams and handlers:\n`csharp{\ntitle: \"Navigation Service\"\ndescription: \"Navigation service interface for GitLens-style event stream traversal\"\ncategory: \"Design\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Design\", \"IDE-Integration\", \"Navigation-Service\", \"Event-Stream-Navigation\"]\nframework: \"NET8\"\n}\npublic interface IWhizbangNavigationService {\n    Task<EventStreamInfo> GetEventStreamAsync(string streamId);\n    Task<IEnumerable<HandlerInfo>> GetHandlersForEventAsync(Type eventType);\n    Task<IEnumerable<ProjectionInfo>> GetProjectionsForEventAsync(Type eventType);\n    Task<EventFlowDiagram> GetEventFlowAsync(Type commandType);\n    Task<DomainMap> GetDomainMapAsync();\n}\n// Event flow visualization\npublic class EventFlowDiagram {\n    public CommandInfo Command { get; set; }\n    public HandlerInfo CommandHandler { get; set; }\n    public List<EventInfo> EmittedEvents { get; set; }\n    public Dictionary<EventInfo, List<HandlerInfo>> EventHandlers { get; set; }\n    public Dictionary<EventInfo, List<ProjectionInfo>> EventProjections { get; set; }\n    public List<SagaInfo> TriggeredSagas { get; set; }\n}\n`csharp{\ntitle: \"Code Lens Provider\"\ndescription: \"Code lens provider for displaying event flow information in IDE\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"Design\", \"IDE-Integration\", \"Code-Lens-Provider\", \"Event-Flow-Visualization\"]\nframework: \"NET8\"\n}\n// Usage in IDE extension\npublic class WhizbangCodeLensProvider : CodeLensProvider {\n    public override async Task<CodeLens[]> ProvideCodeLensesAsync(Document document) {\n        var semanticModel = await document GetSemanticModelAsync();\n        var root = await document GetSyntaxRootAsync();\n        var codeLenses = new List<CodeLens>();\n        // Find command handlers\n        foreach (var handlerClass in root DescendantNodes() OfType<ClassDeclarationSyntax>()) {\n            if (IsCommandHandler(handlerClass, semanticModel)) {\n                var commandType = GetCommandType(handlerClass, semanticModel);\n                var eventFlow = await _navigationService GetEventFlowAsync(commandType);\n                codeLenses Add(new CodeLens {\n                    Range = GetRange(handlerClass),\n                    Command = new Command {\n                        Title = $\"Emits {eventFlow EmittedEvents Count} events, triggers {eventFlow EventHandlers Count} handlers\",\n                        Arguments = new object[] { eventFlow }\n                    }\n                });\n            }\n        }\n        return codeLenses",
        "startIndex": 5166,
        "preview": "projects RegisterReferencedHandlers(services); // Domain ownership from all projects RegisterDomainOwnership(services); // Policies from all projects ..."
      },
      {
        "id": "proposals/source-generation-ide-chunk-3",
        "text": "semanticModel)) { var commandType = GetCommandType(handlerClass, semanticModel); var eventFlow = await _navigationService GetEventFlowAsync(commandType); codeLenses Add(new CodeLens { Range = GetRange(handlerClass), Command = new Command { Title = $\"Emits {eventFlow EmittedEvents Count} events, triggers {eventFlow EventHandlers Count} handlers\", Arguments = new object[] { eventFlow } } }); } } return codeLenses ToArray();\n    }\n}\n`\nGenerated Metadata\nRich metadata for IDE integration:\n`json\n// Generated metadata file: WhizbangMetadata json\n{\n  \"eventStreams\": {\n    \"Order-{orderId}\": {\n      \"aggregateType\": \"Order\",\n      \"domain\": \"Orders\",\n      \"events\": [\"OrderPlaced\", \"OrderUpdated\", \"OrderShipped\"],\n      \"handlers\": [\"OrderSummaryProjection\", \"OrderHistoryProjection\"],\n      \"sagas\": [\"OrderFulfillmentSaga\"]\n    }\n  },\n  \"handlers\": {\n    \"PlaceOrderHandler\": {\n      \"handlerType\": \"Command\",\n      \"inputType\": \"PlaceOrder\",\n      \"outputTypes\": [\"OrderPlaced\"],\n      \"domain\": \"Orders\",\n      \"sourceLocation\": \"OrderService/Handlers/PlaceOrderHandler cs:15\"\n    }\n  },\n  \"projections\": {\n    \"OrderSummaryProjection\": {\n      \"projectionName\": \"order-summary\",\n      \"subscribedEvents\": [\"OrderPlaced\", \"OrderUpdated\", \"OrderShipped\"],\n      \"domain\": \"Orders\",\n      \"sourceLocation\": \"OrderService/Projections/OrderSummaryProjection cs:8\"\n    }\n  },\n  \"domains\": {\n    \"Orders\": {\n      \"commands\": [\"PlaceOrder\", \"UpdateOrder\", \"ShipOrder\"],\n      \"events\": [\"OrderPlaced\", \"OrderUpdated\", \"OrderShipped\"],\n      \"handlers\": [\"PlaceOrderHandler\", \"UpdateOrderHandler\"],\n      \"projections\": [\"OrderSummaryProjection\", \"OrderHistoryProjection\"]\n    }\n  }\n}\n`\nCode Analyzers & Fixes\nDomain Ownership Validation\nCompile-time enforcement of domain ownership rules:\n`csharp{\ntitle: \"Domain Ownership Analyzer\"\ndescription: \"Roslyn analyzer for compile-time domain ownership validation\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"Design\", \"Code-Analyzers\", \"Domain-Ownership\", \"Compile-Time-Validation\"]\nframework: \"NET8\"\n}\n[DiagnosticAnalyzer(LanguageNames CSharp)]\npublic class DomainOwnershipAnalyzer : DiagnosticAnalyzer {\n    public static readonly DiagnosticDescriptor CrossDomainHandlerRule = new(\n        \"WB001\",\n        \"Handler cannot handle command/event from different domain\",\n        \"Handler '{0}' in domain '{1}' cannot handle '{2}' from domain '{3}'\",\n        \"Domain Ownership\",\n        DiagnosticSeverity Error,\n        isEnabledByDefault: true\n    );\n    public override void Initialize(AnalysisContext context) {\n        context RegisterSyntaxNodeAction(AnalyzeHandlerClass, SyntaxKind ClassDeclaration);\n    }\n    private void AnalyzeHandlerClass(SyntaxNodeAnalysisContext context) {\n        var classDeclaration = (ClassDeclarationSyntax)context Node;\n        var semanticModel = context SemanticModel;\n        var handlerDomain = GetHandlerDomain(classDeclaration, semanticModel);\n        var handledTypes = GetHandledTypes(classDeclaration, semanticModel);\n        foreach (var handledType in handledTypes) {\n            var messageDomain = GetMessageDomain(handledType, semanticModel);\n            if (handlerDomain = messageDomain) {\n                var diagnostic = Diagnostic Create(\n                    CrossDomainHandlerRule,\n                    classDeclaration GetLocation(),\n                    classDeclaration Identifier ValueText,\n                    handlerDomain,\n                    handledType Name,\n                    messageDomain\n                );\n                context",
        "startIndex": 7795,
        "preview": "semanticModel)) { var commandType = GetCommandType(handlerClass, semanticModel); var eventFlow = await _navigationService GetEventFlowAsync(commandTyp..."
      },
      {
        "id": "proposals/source-generation-ide-chunk-4",
        "text": "(ClassDeclarationSyntax)context Node; var semanticModel = context SemanticModel; var handlerDomain = GetHandlerDomain(classDeclaration, semanticModel); var handledTypes = GetHandledTypes(classDeclaration, semanticModel); foreach (var handledType in handledTypes) { var messageDomain = GetMessageDomain(handledType, semanticModel); if (handlerDomain = messageDomain) { var diagnostic = Diagnostic Create( CrossDomainHandlerRule, classDeclaration GetLocation(), classDeclaration Identifier ValueText, handlerDomain, handledType Name, messageDomain ); context ReportDiagnostic(diagnostic);\n            }\n        }\n    }\n}\n`\nCode Fixes\nAutomatic fixes for common patterns:\n`csharp{\ntitle: \"Code Fix Provider\"\ndescription: \"Code fix provider for automatic domain ownership attribute addition\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"Design\", \"Code-Fixes\", \"Domain-Ownership\", \"Automatic-Fixes\"]\nframework: \"NET8\"\n}\n[ExportCodeFixProvider(LanguageNames CSharp)]\npublic class AddDomainOwnershipCodeFixProvider : CodeFixProvider {\n    public override async Task RegisterCodeFixesAsync(CodeFixContext context) {\n        var diagnostic = context Diagnostics FirstOrDefault(d => d Id == \"WB002\");\n        if (diagnostic == null) return;\n        var document = context Document;\n        var root = await document GetSyntaxRootAsync(context CancellationToken);\n        var declaration = root FindNode(diagnostic Location SourceSpan);\n        // Offer to add [OwnedBy] attribute\n        var codeAction = CodeAction Create(\n            title: \"Add [OwnedBy] attribute\",\n            createChangedDocument: c => AddOwnedByAttribute(document, declaration, c),\n            equivalenceKey: \"AddOwnedBy\"\n        );\n        context RegisterCodeFix(codeAction, diagnostic);\n    }\n    private async Task<Document> AddOwnedByAttribute(Document document, SyntaxNode declaration, CancellationToken cancellationToken) {\n        var root = await document GetSyntaxRootAsync(cancellationToken);\n        var inferredDomain = InferDomainFromNamespace(declaration);\n        var attribute = SyntaxFactory Attribute(\n            SyntaxFactory IdentifierName(\"OwnedBy\"),\n            SyntaxFactory AttributeArgumentList(\n                SyntaxFactory SingletonSeparatedList(\n                    SyntaxFactory AttributeArgument(\n                        SyntaxFactory LiteralExpression(SyntaxKind StringLiteralExpression, \n                            SyntaxFactory Literal(inferredDomain))\n                    )\n                )\n            )\n        );\n        var newDeclaration = AddAttributeToDeclaration(declaration, attribute);\n        var newRoot = root ReplaceNode(declaration, newDeclaration);\n        return document WithSyntaxRoot(newRoot);\n    }\n}\n`\nDebugging Integration\nTransparent Generated Code\nClear, debuggable generated code with source maps:\n`csharp{\ntitle: \"Debuggable Generated Code\"\ndescription: \"Clear, debuggable generated code with source maps and metadata\"\ncategory: \"Design\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Design\", \"Source-Generation\", \"Transparent-Code\", \"Debug-Experience\"]\nframework: \"NET8\"\n}\n// Generated handler registry with clear structure\n[GeneratedCode(\"Whizbang SourceGenerator\", \"1 0 0\")]\npublic static partial class OrderServiceHandlerRegistry {\n    // Source: OrderService/Handlers/PlaceOrderHandler cs\n    public static void RegisterPlaceOrderHandler(IServiceCollection services) {\n        services",
        "startIndex": 10929,
        "preview": "(ClassDeclarationSyntax)context Node; var semanticModel = context SemanticModel; var handlerDomain = GetHandlerDomain(classDeclaration, semanticModel)..."
      },
      {
        "id": "proposals/source-generation-ide-chunk-5",
        "text": "\"Clear, debuggable generated code with source maps and metadata\" category: \"Design\" difficulty: \"INTERMEDIATE\" tags: [\"Design\", \"Source-Generation\", \"Transparent-Code\", \"Debug-Experience\"] framework: \"NET8\" } // Generated handler registry with clear structure [GeneratedCode(\"Whizbang SourceGenerator\", \"1 0 0\")] public static partial class OrderServiceHandlerRegistry { // Source: OrderService/Handlers/PlaceOrderHandler cs public static void RegisterPlaceOrderHandler(IServiceCollection services) { services AddScoped<ICommandHandler<PlaceOrder>, PlaceOrderHandler>();\n        // Generated metadata for debugging\n        services AddSingleton(new HandlerMetadata {\n            HandlerType = typeof(PlaceOrderHandler),\n            MessageType = typeof(PlaceOrder),\n            SourceFile = \"OrderService/Handlers/PlaceOrderHandler cs\",\n            SourceLine = 15,\n            Domain = \"Orders\",\n            GeneratedAt = DateTimeOffset Parse(\"2024-01-01T10:00:00Z\")\n        });\n    }\n    // Source: OrderService/Projections/OrderSummaryProjection cs  \n    public static void RegisterOrderSummaryProjection(IServiceCollection services) {\n        services AddScoped<IProjectionHandler<OrderPlaced>, OrderSummaryProjection>();\n        services AddScoped<IProjectionHandler<OrderUpdated>, OrderSummaryProjection>();\n        services AddScoped<IProjectionHandler<OrderShipped>, OrderSummaryProjection>();\n        // Register projection metadata\n        services AddSingleton(new ProjectionMetadata {\n            ProjectionType = typeof(OrderSummaryProjection),\n            ProjectionName = \"order-summary\",\n            SubscribedEvents = new[] { typeof(OrderPlaced), typeof(OrderUpdated), typeof(OrderShipped) },\n            SourceFile = \"OrderService/Projections/OrderSummaryProjection cs\",\n            SourceLine = 8,\n            Domain = \"Orders\"\n        });\n    }\n}\n`\nDebug Experience Enhancements\nNo \"magic\" - clear understanding of what's happening:\n`csharp{\ntitle: \"Debug-Friendly Registration\"\ndescription: \"Debug-friendly service registration with detailed logging\"\ncategory: \"Design\"\ndifficulty: \"INTERMEDIATE\"\ntags: [\"Design\", \"Source-Generation\", \"Debug-Experience\", \"Service-Registration\"]\nframework: \"NET8\"\n}\n// Debug-friendly service registration\npublic static class WhizbangServiceCollectionExtensions {\n    public static IServiceCollection AddWhizbangGeneratedServices(this IServiceCollection services) {\n        if (IsDebugMode()) {\n            // In debug mode, show detailed registration logging\n            services AddSingleton<IHandlerRegistrationLogger, DetailedHandlerRegistrationLogger>();\n        }\n        // Call generated registration methods\n        OrderServiceHandlerRegistry RegisterAll(services);\n        return services;\n    }\n}\npublic class DetailedHandlerRegistrationLogger : IHandlerRegistrationLogger {\n    public void LogHandlerRegistration<TMessage, THandler>(string sourceFile, int sourceLine) {\n        Console WriteLine($\"Registering handler {typeof(THandler) Name} for {typeof(TMessage) Name}\");\n        Console WriteLine($\"  Source: {sourceFile}:{sourceLine}\");\n        Console",
        "startIndex": 13789,
        "preview": "\"Clear, debuggable generated code with source maps and metadata\" category: \"Design\" difficulty: \"INTERMEDIATE\" tags: [\"Design\", \"Source-Generation\", \"..."
      },
      {
        "id": "proposals/source-generation-ide-chunk-6",
        "text": "// In debug mode, show detailed registration logging services AddSingleton<IHandlerRegistrationLogger, DetailedHandlerRegistrationLogger>(); } // Call generated registration methods OrderServiceHandlerRegistry RegisterAll(services); return services; } } public class DetailedHandlerRegistrationLogger : IHandlerRegistrationLogger { public void LogHandlerRegistration<TMessage, THandler>(string sourceFile, int sourceLine) { Console WriteLine($\"Registering handler {typeof(THandler) Name} for {typeof(TMessage) Name}\"); Console WriteLine($\" Source: {sourceFile}:{sourceLine}\"); Console WriteLine($\"  Service lifetime: Scoped\");\n    }\n}\n`\nPerformance Optimizations\nIncremental Generation\nOnly regenerate what changed for fast incremental builds:\n`csharp{\ntitle: \"Incremental Generation Context\"\ndescription: \"Incremental generation context for tracking file changes and optimization\"\ncategory: \"Design\"\ndifficulty: \"ADVANCED\"\ntags: [\"Design\", \"Source-Generation\", \"Incremental-Generation\", \"Performance-Optimization\"]\nframework: \"NET8\"\n}\npublic class IncrementalGenerationContext {\n    private readonly ConcurrentDictionary<string, string> _fileHashes = new();\n    public bool HasFileChanged(string filePath, string content) {\n        var currentHash = ComputeHash(content);\n        var previousHash = _fileHashes GetValueOrDefault(filePath);\n        if (currentHash",
        "startIndex": 16401,
        "preview": "// In debug mode, show detailed registration logging services AddSingleton<IHandlerRegistrationLogger, DetailedHandlerRegistrationLogger>(); } // Call..."
      },
      {
        "id": "proposals/source-generation-ide-chunk-7",
        "text": "\"Incremental generation context for tracking file changes and optimization\" category: \"Design\" difficulty: \"ADVANCED\" tags: [\"Design\", \"Source-Generation\", \"Incremental-Generation\", \"Performance-Optimization\"] framework: \"NET8\" } public class IncrementalGenerationContext { private readonly ConcurrentDictionary<string, string> _fileHashes = new(); public bool HasFileChanged(string filePath, string content) { var currentHash = ComputeHash(content); var previousHash = _fileHashes GetValueOrDefault(filePath); if (currentHash = previousHash) {\n            _fileHashes[filePath] = currentHash;\n            return true;\n        }\n        return false;\n    }\n    public void TrackGeneratedOutput(string outputKey, string content) {\n        // Track what we generated so we can skip unchanged outputs\n        _generatedOutputs[outputKey] = ComputeHash(content);\n    }\n}\n`\nCompilation Performance\nOptimize for IDE experience:\nSyntax-only analysis for most validations\nSemantic analysis only when necessary\nCaching of expensive operations\nParallel processing of independent analysis\nEarly termination when errors are found\nBest Practices\nGenerator Design\nKeep generators focused - Single responsibility per generator stage\nMinimize semantic model usage - Use syntax analysis when possible\nCache expensive operations - Avoid redundant analysis\nProvide clear diagnostics - Help developers understand issues\nGenerate debuggable code - Include source references and metadata\nIDE Integration\nResponsive navigation - Fast lookups and searches\nContextual information - Show relevant details for current location\nClear visualizations - Easy to understand flow diagrams\nHelpful code lenses - Actionable information overlays\nIntelligent suggestions - Context-aware code completion\nDebug Experience\nNo hidden magic - Everything should be discoverable\nClear error messages - Point to exact problems and solutions\nSource mapping - Connect generated code to source\nMetadata preservation - Keep debug information through compilation\nPerformance transparency - Show timing and costs\n---\nRelated Documentation\nDomain Ownership - How ownership affects source generation\nPolicy Engine - Policy-based code generation\nFlags & Tags System - Cross-service context propagation\nTesting & Development Tools - Testing the generated code",
        "startIndex": 17182,
        "preview": "\"Incremental generation context for tracking file changes and optimization\" category: \"Design\" difficulty: \"ADVANCED\" tags: [\"Design\", \"Source-Generat..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "proposals/testing-development-tools",
    "title": "Testing & Development Tools",
    "category": "Architecture & Design",
    "url": "/docs/proposals/testing-development-tools",
    "chunks": [
      {
        "id": "proposals/testing-development-tools-chunk-0",
        "text": "Testing & Development Tools\nWhizbang provides comprehensive testing utilities and development tools to ensure a productive developer experience from local development to production deployment Testing Framework\nWhizbang Testing Package\nComprehensive testing library with fluent APIs for all Whizbang scenarios:\n`csharp{title=\"Installing Whizbang Testing Package\" description=\"Installing and setting up the Whizbang testing package\" category=\"Design\" difficulty=\"BEGINNER\" tags=[\"Design\", \"Testing\", \"Package-Installation\", \"Setup\"] framework=\"NET8\"}\n// Install the testing package\ndotnet add package Whizbang Testing\n`csharp{title=\"Test Fixture Setup\" description=\"Test fixture setup with in-memory drivers for fast unit testing\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Testing\", \"Test-Fixtures\", \"In-Memory-Drivers\"] framework=\"NET8\"}\n// Test fixture setup\npublic class OrderServiceTests {\n    private readonly WhizbangTestFixture _fixture;\n    public OrderServiceTests() {\n        _fixture = new WhizbangTestFixture() UseInMemoryEventStore() UseInMemoryProjections() UseInMemoryMessageBroker() ConfigureServices(services => {\n                services AddScoped<IOrderService, OrderService>();\n                services AddScoped<ICustomerService, MockCustomerService>();\n            });\n    }\n}\n`\nEvent Sourcing Test Helpers\nGiven/When/Then fluent API for event sourcing scenarios:\n`csharp{title=\"Given/When/Then Event Sourcing Tests\" description=\"Given/When/Then fluent API for event sourcing test scenarios\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Testing\", \"Given-When-Then\", \"Event-Sourcing\"] framework=\"NET8\"}\n[Test]\npublic async Task PlaceOrder_WithValidCustomer_ShouldEmitOrderPlaced() {\n    // Arrange & Act & Assert in fluent chain\n    await _fixture Given(\n            new CustomerRegistered(customerId, \"John Doe\", \"john@example com\"),\n            new ProductCreated(productId, \"Widget\", 10 00m)\n        ) When(new PlaceOrder(orderId, customerId, new[] { \n            new OrderItem(productId, 2, 10 00m) \n        })) Then() ShouldEmitEvent<OrderPlaced>() WithProperty(e => e OrderId, orderId) WithProperty(e => e CustomerId, customerId) WithProperty(e => e Total, 20 00m) And() ShouldNotEmitEvent<OrderRejected>();\n}\n`csharp{title=\"Error Scenario Testing\" description=\"Testing error scenarios with event validation assertions\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Testing\", \"Error-Scenarios\", \"Event-Validation\"] framework=\"NET8\"}\n[Test]\npublic async Task PlaceOrder_WithInvalidCustomer_ShouldEmitOrderRejected() {\n    await _fixture Given() // No customer registered When(new PlaceOrder(orderId, customerId, items)) Then() ShouldEmitEvent<OrderRejected>() WithProperty(e => e Reason, \"Customer not found\") And() ShouldNotEmitEvent<OrderPlaced>();\n}\n`\nProjection Testing\nFeed events and assert projection state:\n`csharp{title=\"Projection Lifecycle Testing\" description=\"Projection testing with event feeding and state assertions\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Testing\", \"Projections\", \"Lifecycle-Testing\"] framework=\"NET8\"}\n[Test]\npublic async Task OrderSummaryProjection_ShouldTrackOrderLifecycle() {\n    await _fixture ForProjection<OrderSummaryProjection>()",
        "startIndex": 0,
        "preview": "Testing & Development Tools\nWhizbang provides comprehensive testing utilities and development tools to ensure a productive developer experience from l..."
      },
      {
        "id": "proposals/testing-development-tools-chunk-1",
        "text": "customerId, items)) Then() ShouldEmitEvent<OrderRejected>() WithProperty(e => e Reason, \"Customer not found\") And() ShouldNotEmitEvent<OrderPlaced>(); } ` Projection Testing Feed events and assert projection state: `csharp{title=\"Projection Lifecycle Testing\" description=\"Projection testing with event feeding and state assertions\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Testing\", \"Projections\", \"Lifecycle-Testing\"] framework=\"NET8\"} [Test] public async Task OrderSummaryProjection_ShouldTrackOrderLifecycle() { await _fixture ForProjection<OrderSummaryProjection>() GivenEvents(\n            new OrderPlaced(orderId, customerId, 100 00m, DateTimeOffset UtcNow),\n            new OrderShipped(orderId, \"TRACK123\", DateTimeOffset UtcNow AddDays(1))\n        ) WhenProjectionRuns() ThenProjection<OrderSummary>(orderId ToString()) ShouldExist() ShouldHaveProperty(s => s Status, OrderStatus Shipped) ShouldHaveProperty(s => s Total, 100 00m) ShouldHaveProperty(s => s TrackingNumber, \"TRACK123\");\n}\n[Test]\npublic async Task OrderSummaryProjection_WithMissingEvents_ShouldHandleGracefully() {\n    await _fixture ForProjection<OrderSummaryProjection>() GivenEvents(\n            new OrderShipped(orderId, \"TRACK123\", DateTimeOffset UtcNow) // No OrderPlaced\n        ) WhenProjectionRuns() ThenProjection<OrderSummary>(orderId ToString()) ShouldNotExist(); // Projection should handle missing OrderPlaced gracefully\n}\n`\nPolicy Testing\nTest policy rules and combinations:\n`csharp{title=\"Policy Rule Testing\" description=\"Testing policy rules and their effects on system behavior\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Testing\", \"Policy-Testing\", \"Load-Testing\"] framework=\"NET8\"}\n[Test]\npublic async Task LoadTestingPolicy_ShouldSkipProjections() {\n    await _fixture ForPolicy(\"LoadTestingPolicy\") GivenContext(ctx => ctx WithFlag(WhizbangFlags LoadTesting)) GivenMessage(new OrderPlaced(orderId, customerId, 100 00m)) WhenPolicyEvaluates() ThenActions() ShouldContain<SkipProjectionsAction>() ShouldContain<AddTagAction>(action => action Tag == \"load-test-processed\");\n}\n[Test]\npublic async Task VIPCustomerPolicy_ShouldRouteToSpecialHandler() {\n    await _fixture ForPolicy(\"VIPCustomerPolicy\") GivenContext(ctx => ctx WithTag(\"customer-vip\")) GivenMessage(new PlaceOrder(orderId, customerId, items)) WhenPolicyEvaluates() ThenActions() ShouldContain<RouteToHandlerAction<VIPOrderHandler>>();\n}\n`\nSaga Testing\nTest long-running process coordination:\n`csharp{title=\"Saga Workflow Testing\" description=\"Testing long-running saga workflows with command coordination\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Testing\", \"Sagas\", \"Workflow-Coordination\"] framework=\"NET8\"}\n[Test]\npublic async Task OrderFulfillmentSaga_ShouldCoordinateFullWorkflow() {\n    await _fixture ForSaga<OrderFulfillmentSaga>() GivenEvents(\n            new OrderPlaced(orderId, customerId, items)\n        ) WhenSagaRuns() ThenCommands() ShouldContain<ReserveInventory>(cmd => cmd OrderId == orderId) And() WhenEvent(new InventoryReserved(orderId, items)) ThenCommands() ShouldContain<ChargePayment>(cmd => cmd OrderId == orderId) And() WhenEvent(new PaymentCharged(orderId, 100 00m)) ThenCommands() ShouldContain<ShipOrder>(cmd => cmd",
        "startIndex": 3484,
        "preview": "customerId, items)) Then() ShouldEmitEvent<OrderRejected>() WithProperty(e => e Reason, \"Customer not found\") And() ShouldNotEmitEvent<OrderPlaced>();..."
      },
      {
        "id": "proposals/testing-development-tools-chunk-2",
        "text": "category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Testing\", \"Sagas\", \"Workflow-Coordination\"] framework=\"NET8\"} [Test] public async Task OrderFulfillmentSaga_ShouldCoordinateFullWorkflow() { await _fixture ForSaga<OrderFulfillmentSaga>() GivenEvents( new OrderPlaced(orderId, customerId, items) ) WhenSagaRuns() ThenCommands() ShouldContain<ReserveInventory>(cmd => cmd OrderId == orderId) And() WhenEvent(new InventoryReserved(orderId, items)) ThenCommands() ShouldContain<ChargePayment>(cmd => cmd OrderId == orderId) And() WhenEvent(new PaymentCharged(orderId, 100 00m)) ThenCommands() ShouldContain<ShipOrder>(cmd => cmd OrderId == orderId);\n}\n`\nIntegration Testing\nReal drivers with test containers:\n`csharp{title=\"Integration Testing with TestContainers\" description=\"Integration testing with real infrastructure using TestContainers\" category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Testing\", \"Integration-Testing\", \"TestContainers\"] framework=\"NET8\"}\n[Test]\npublic async Task OrderService_IntegrationTest_WithRealDatabase() {\n    // Uses TestContainers for real PostgreSQL\n    await using var fixture = new WhizbangIntegrationTestFixture() UseTestContainerPostgres() UseTestContainerKafka() ConfigureServices(services => {\n            services AddOrderService();\n            services AddInventoryService();\n        });\n    await fixture StartAsync();\n    // Test with real infrastructure\n    var result = await fixture Given(/ setup data in real database /) When(new PlaceOrder(orderId, customerId, items)) Then() ShouldEmitEvent<OrderPlaced>() And() ShouldHaveProjection<OrderSummary>(orderId ToString()) InDatabase(); // Verify in real database\n}\n`\nDevelopment Tools Suite\nCLI Tool (whizbang-cli)\nComprehensive command-line interface for project management:\n`bash\n---\ncategory: Design\ndifficulty: BEGINNER\ntags: [Design, CLI, Project-Scaffolding, Templates]\ndescription: CLI commands for project scaffolding and code generation\n---\nProject scaffolding\nwhizbang new --template microservice --name OrderService\nwhizbang new --template monolith --name ECommerceApp\nwhizbang new --template projection-worker --name AnalyticsWorker\nCode generation\nwhizbang add command --name PlaceOrder --domain Orders\nwhizbang add event --name OrderPlaced --domain Orders  \nwhizbang add projection --name OrderSummary --events OrderPlaced,OrderShipped\nwhizbang add saga --name OrderFulfillment --triggers OrderPlaced\nDevelopment utilities\nwhizbang validate --project /OrderService --check-ownership\nwhizbang generate --project /OrderService --watch\nwhizbang dashboard --port 5000 --project /OrderService\nEvent store utilities\nwhizbang events list --stream \"Order-*\" --from 2024-01-01\nwhizbang events replay --stream \"Order-123\" --to-projection OrderSummary\nwhizbang events export --stream \"Order-*\" --format json --output orders json\nMigration utilities\nwhizbang migrate --from 1 0 --to 2",
        "startIndex": 6486,
        "preview": "category=\"Design\" difficulty=\"ADVANCED\" tags=[\"Design\", \"Testing\", \"Sagas\", \"Workflow-Coordination\"] framework=\"NET8\"} [Test] public async Task OrderF..."
      },
      {
        "id": "proposals/testing-development-tools-chunk-3",
        "text": "--project /OrderService --check-ownership whizbang generate --project /OrderService --watch whizbang dashboard --port 5000 --project /OrderService Event store utilities whizbang events list --stream \"Order-*\" --from 2024-01-01 whizbang events replay --stream \"Order-123\" --to-projection OrderSummary whizbang events export --stream \"Order-*\" --format json --output orders json Migration utilities whizbang migrate --from 1 0 --to 2 0 --dry-run\nwhizbang migrate --apply --backup\n`\nCLI Implementation Architecture\n`csharp{title=\"CLI Command Structure\" description=\"CLI command structure implementation with subcommands\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"CLI\", \"Command-Structure\", \"Implementation\"] framework=\"NET8\"}\n// CLI command structure\n[Command(\"whizbang\")]\npublic class WhizbangCliCommand {\n    [Command(\"new\")]\n    public class NewCommand {\n        [Option(\"--template\", Description = \"Project template\")]\n        public string Template { get; set; } = \"microservice\";\n        [Option(\"--name\", Description = \"Project name\")]\n        public string Name { get; set; }\n        public async Task<int> ExecuteAsync() {\n            var templateEngine = new ProjectTemplateEngine();\n            await templateEngine CreateProjectAsync(Template, Name);\n            return 0;\n        }\n    }\n    [Command(\"add\")]\n    public class AddCommand {\n        [Command(\"command\")]\n        public class AddCommandCommand {\n            [Option(\"--name\")] public string Name { get; set; }\n            [Option(\"--domain\")] public string Domain { get; set; }\n            public async Task<int> ExecuteAsync() {\n                var generator = new CodeGenerator();\n                await generator GenerateCommandAsync(Name, Domain);\n                return 0;\n            }\n        }\n    }\n}\n`\nVisual Studio Integration\nTemplates and extensions for rapid development:\n`xml\n---\ncategory: Design\ndifficulty: INTERMEDIATE\ntags: [Design, Templates, Visual-Studio, Project-Templates]\ndescription: Visual Studio template configuration for rapid development\n---\n< -- dotnet new templates -->\n<Project Sdk=\"Microsoft NET Sdk\">\n  <PropertyGroup>\n    <PackageType>Template</PackageType>\n    <PackageVersion>1 0 0</PackageVersion>\n    <PackageId>Whizbang",
        "startIndex": 8841,
        "preview": "--project /OrderService --check-ownership whizbang generate --project /OrderService --watch whizbang dashboard --port 5000 --project /OrderService Eve..."
      },
      {
        "id": "proposals/testing-development-tools-chunk-4",
        "text": "} } } } ` Visual Studio Integration Templates and extensions for rapid development: `xml --- category: Design difficulty: INTERMEDIATE tags: [Design, Templates, Visual-Studio, Project-Templates] description: Visual Studio template configuration for rapid development --- < -- dotnet new templates --> <Project Sdk=\"Microsoft NET Sdk\"> <PropertyGroup> <PackageType>Template</PackageType> <PackageVersion>1 0 0</PackageVersion> <PackageId>Whizbang Templates</PackageId>\n    <Title>Whizbang Project Templates</Title>\n    <Description>Templates for Whizbang applications</Description>\n    <IncludeContentInPack>true</IncludeContentInPack>\n    <IncludeBuildOutput>false</IncludeBuildOutput>\n    <ContentTargetFolders>content</ContentTargetFolders>\n  </PropertyGroup>\n</Project>\n`\nLive Templates for common patterns:\n`csharp{title=\"Live Code Templates\" description=\"Live templates for common Whizbang patterns and boilerplate\" category=\"Design\" difficulty=\"BEGINNER\" tags=[\"Design\", \"Live-Templates\", \"Code-Generation\", \"Commands\"] framework=\"NET8\"}\n// Command template\npublic record $COMMAND_NAME$(\n    $PARAMETERS$\n) : ICommand;\n// Event template  \npublic record $EVENT_NAME$(\n    $PARAMETERS$\n) : IEvent;\n// Handler template\npublic class $HANDLER_NAME$ : ICommandHandler<$COMMAND_TYPE$> {\n    public async Task<IEvent[]> Handle($COMMAND_TYPE$ command) {\n        $HANDLER_LOGIC$\n        return new IEvent[] {\n            new $EVENT_TYPE$($EVENT_PARAMETERS$)\n        };\n    }\n}\n// Projection template\npublic class $PROJECTION_NAME$ : IProjectionHandler<$EVENT_TYPE$> {\n    public async Task Handle($EVENT_TYPE$ @event, ProjectionContext context) {\n        var projection = await context Load<$PROJECTION_MODEL$>(@event $KEY_FIELD$ ToString()) new $PROJECTION_MODEL$ { $KEY_FIELD$ = @event $KEY_FIELD$ };\n        $PROJECTION_LOGIC$\n        await context Store(@event $KEY_FIELD$ ToString(), projection);\n    }\n}\n`\nWeb Dashboard\nReal-time monitoring and debugging interface:\n`csharp{title=\"Web Dashboard Configuration\" description=\"Web dashboard configuration for real-time monitoring and debugging\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"Web-Dashboard\", \"Real-Time-Monitoring\", \"Configuration\"] framework=\"NET8\"}\n// Dashboard startup\npublic class WhizbangDashboard {\n    public static void ConfigureDashboard(WebApplicationBuilder builder) {\n        builder Services AddWhizbangDashboard(options => {\n            options EnableRealTimeUpdates = true;\n            options EventRetentionHours = 24;\n            options ProjectionLagAlertThreshold = TimeSpan FromMinutes(5);\n        });\n    }\n    public static void MapDashboardEndpoints(WebApplication app) {\n        app MapWhizbangDashboard(\"/dashboard\");\n        // API endpoints for dashboard\n        app MapGet(\"/api/whizbang/projections\", GetProjectionStatus);\n        app MapGet(\"/api/whizbang/events/{streamId}\", GetEventStream);\n        app MapPost(\"/api/whizbang/replay\", TriggerReplay);\n        app MapGet(\"/api/whizbang/policies\", GetActivePolicies);\n        app",
        "startIndex": 10662,
        "preview": "} } } } ` Visual Studio Integration Templates and extensions for rapid development: `xml --- category: Design difficulty: INTERMEDIATE tags: [Design, ..."
      },
      {
        "id": "proposals/testing-development-tools-chunk-5",
        "text": "void ConfigureDashboard(WebApplicationBuilder builder) { builder Services AddWhizbangDashboard(options => { options EnableRealTimeUpdates = true; options EventRetentionHours = 24; options ProjectionLagAlertThreshold = TimeSpan FromMinutes(5); }); } public static void MapDashboardEndpoints(WebApplication app) { app MapWhizbangDashboard(\"/dashboard\"); // API endpoints for dashboard app MapGet(\"/api/whizbang/projections\", GetProjectionStatus); app MapGet(\"/api/whizbang/events/{streamId}\", GetEventStream); app MapPost(\"/api/whizbang/replay\", TriggerReplay); app MapGet(\"/api/whizbang/policies\", GetActivePolicies); app MapPost(\"/api/whizbang/policies/test\", TestPolicy);\n    }\n}\n`\nDashboard Features:\nReal-time Projection Monitoring\nProjection lag visualization\nEvent processing rates\nError rates and alerts\nCheckpoint status\nEvent Stream Visualization\nStream browsing and filtering\nEvent details and metadata\nCross-stream correlation\nFlow diagrams\nPolicy Rule Testing\nPolicy condition testing\nAction preview\nRule combination visualization\nPerformance impact analysis\nPerformance Metrics\nHandler execution times\nThroughput measurements\nResource utilization\nBottleneck identification\nIDE Extensions\nVisual Studio Code Extension with advanced features:\n`typescript\n---\ncategory: Design\ndifficulty: ADVANCED\ntags: [Design, IDE-Extensions, VSCode, Event-Stream-Navigation]\ndescription: VSCode extension implementation for advanced Whizbang development features\n---\n// VSCode extension main functionality\nexport function activate(context: vscode ExtensionContext) {\n    // Register command for event stream navigation\n    const navigateCommand = vscode commands registerCommand(\n        'whizbang navigateEventStream',\n        async () => {\n            const streamId = await vscode window showInputBox({\n                prompt: 'Enter stream ID or pattern'\n            });\n            if (streamId) {\n                const events = await whizbangService getEventStream(streamId);\n                showEventStreamPanel(events);\n            }\n        }\n    );\n    // Register hover provider for command/event info\n    const hoverProvider = vscode languages registerHoverProvider(\n        'csharp',\n        new WhizbangHoverProvider()\n    );\n    // Register code lens provider for handler flow\n    const codeLensProvider = vscode languages registerCodeLensProvider(\n        'csharp',\n        new WhizbangCodeLensProvider()\n    );\n    context subscriptions push(navigateCommand, hoverProvider, codeLensProvider);\n}\n`typescript\n---\ncategory: Design\ndifficulty: ADVANCED\ntags: [Design, IDE-Extensions, Hover-Provider, Type-Metadata]\ndescription: Hover provider implementation for type metadata and handler information\n---\nclass WhizbangHoverProvider implements vscode HoverProvider {\n    async provideHover(document: vscode TextDocument, position: vscode Position): Promise<vscode Hover | undefined> {\n        const word = document getWordRangeAtPosition(position);\n        if ( word) return;\n        const wordText = document",
        "startIndex": 13281,
        "preview": "void ConfigureDashboard(WebApplicationBuilder builder) { builder Services AddWhizbangDashboard(options => { options EnableRealTimeUpdates = true; opti..."
      },
      {
        "id": "proposals/testing-development-tools-chunk-6",
        "text": "Design difficulty: ADVANCED tags: [Design, IDE-Extensions, Hover-Provider, Type-Metadata] description: Hover provider implementation for type metadata and handler information --- class WhizbangHoverProvider implements vscode HoverProvider { async provideHover(document: vscode TextDocument, position: vscode Position): Promise<vscode Hover | undefined> { const word = document getWordRangeAtPosition(position); if ( word) return; const wordText = document getText(word);\n        // Check if it's a Whizbang command/event\n        const metadata = await whizbangService getTypeMetadata(wordText);\n        if (metadata) {\n            const contents = new vscode MarkdownString();\n            contents appendMarkdown(${metadata type}: ${metadata name}\\n\\n);\n            contents appendMarkdown(Domain: ${metadata domain}\\n\\n);\n            if (metadata handlers) {\n                contents appendMarkdown(Handlers:\\n);\n                metadata handlers forEach(h => {\n                    contents appendMarkdown(- ${h name} (${h domain})\\n);\n                });\n            }\n            return new vscode Hover(contents, word);\n        }\n    }\n}\n`\nIn-Memory Drivers for Testing\nFast Unit Test Infrastructure\nOptimized in-memory implementations for rapid testing:\n`csharp{title=\"In-Memory Event Store\" description=\"In-memory event store implementation optimized for unit testing\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"In-Memory-Drivers\", \"Unit-Testing\", \"Fast-Testing\"] framework=\"NET8\"}\n// In-memory event store\npublic class InMemoryEventStore : IEventStoreDriver {\n    private readonly ConcurrentDictionary<string, List<StoredEvent>> _streams = new();\n    public async Task AppendEventsAsync(string streamId, IEnumerable<IEvent> events, int expectedVersion) {\n        var streamEvents = _streams GetOrAdd(streamId, _ => new List<StoredEvent>());\n        lock (streamEvents) {\n            if (streamEvents Count = expectedVersion) {\n                throw new ConcurrencyException(streamId, expectedVersion, streamEvents Count);\n            }\n            foreach (var @event in events) {\n                streamEvents Add(new StoredEvent {\n                    StreamId = streamId,\n                    EventId = Guid NewGuid(),\n                    EventType = @event GetType() Name,\n                    EventData = JsonSerializer Serialize(@event),\n                    Version = streamEvents Count + 1,\n                    Timestamp = DateTimeOffset UtcNow\n                });\n            }\n        }\n    }\n    public async Task<IEnumerable<StoredEvent>> ReadEventsAsync(string streamId, int fromVersion = 0) {\n        var streamEvents = _streams GetOrAdd(streamId, _ => new List<StoredEvent>());\n        return streamEvents Where(e => e Version > fromVersion)",
        "startIndex": 15678,
        "preview": "Design difficulty: ADVANCED tags: [Design, IDE-Extensions, Hover-Provider, Type-Metadata] description: Hover provider implementation for type metadata..."
      },
      {
        "id": "proposals/testing-development-tools-chunk-7",
        "text": "EventType = @event GetType() Name, EventData = JsonSerializer Serialize(@event), Version = streamEvents Count + 1, Timestamp = DateTimeOffset UtcNow }); } } } public async Task<IEnumerable<StoredEvent>> ReadEventsAsync(string streamId, int fromVersion = 0) { var streamEvents = _streams GetOrAdd(streamId, _ => new List<StoredEvent>()); return streamEvents Where(e => e Version > fromVersion) ToList();\n    }\n}\n`csharp{title=\"In-Memory Projection Store\" description=\"In-memory projection store for fast unit test execution\" category=\"Design\" difficulty=\"INTERMEDIATE\" tags=[\"Design\", \"In-Memory-Drivers\", \"Projection-Testing\", \"Fast-Testing\"] framework=\"NET8\"}\n// In-memory projection store\npublic class InMemoryProjectionStore : IProjectionDriver {\n    private readonly ConcurrentDictionary<string, Dictionary<string, object>> _projections = new();\n    public async Task Store<T>(string projectionName, string documentId, T document, string tenantId = null) {\n        var key = tenantId = null $\"{projectionName}_{tenantId}\" : projectionName;\n        var projectionData = _projections GetOrAdd(key, _ => new Dictionary<string, object>());\n        lock (projectionData) {\n            projectionData[documentId] = document;\n        }\n    }\n    public async Task<T > Load<T>(string projectionName, string documentId, string tenantId = null) {\n        var key = tenantId = null $\"{projectionName}_{tenantId}\" : projectionName;\n        if (_projections TryGetValue(key, out var projectionData)) {\n            lock (projectionData) {\n                if (projectionData",
        "startIndex": 18000,
        "preview": "EventType = @event GetType() Name, EventData = JsonSerializer Serialize(@event), Version = streamEvents Count + 1, Timestamp = DateTimeOffset UtcNow }..."
      },
      {
        "id": "proposals/testing-development-tools-chunk-8",
        "text": "= _projections GetOrAdd(key, _ => new Dictionary<string, object>()); lock (projectionData) { projectionData[documentId] = document; } } public async Task<T > Load<T>(string projectionName, string documentId, string tenantId = null) { var key = tenantId = null $\"{projectionName}_{tenantId}\" : projectionName; if (_projections TryGetValue(key, out var projectionData)) { lock (projectionData) { if (projectionData TryGetValue(documentId, out var document)) {\n                    return (T)document;\n                }\n            }\n        }\n        return default(T);\n    }\n}\n`\nTesting Best Practices\nTest Organization\nSeparate test categories:\nUnit tests - Fast, isolated, use in-memory drivers\nIntegration tests - Real infrastructure with test containers\nEnd-to-end tests - Full system testing\nPerformance tests - Load and stress testing\nTest data management:\nBuilders for complex test data construction\nFixtures for reusable test scenarios\nCleanup strategies for integration tests\nAssertion patterns:\nFluent assertions for readability\nCustom matchers for domain concepts\nError scenarios testing\nDevelopment Workflow\nTDD-friendly - Tests before implementation\nFast feedback - Sub-second unit test execution\nIDE integration - Run tests from code editor\nContinuous testing - Watch mode for automatic test runs\nCoverage tracking - Identify untested code paths\n---\nRelated Documentation\nSource Generation & IDE Integration - How testing integrates with generated code\nPolicy Engine - Testing policy rules and combinations\nFlags & Tags System - Cross-service context propagation\nObservability & Metrics - Testing observability features",
        "startIndex": 19179,
        "preview": "= _projections GetOrAdd(key, _ => new Dictionary<string, object>()); lock (projectionData) { projectionData[documentId] = document; } } public async T..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "roadmap/FEATURE-EVOLUTION",
    "title": "Feature Evolution Matrix",
    "category": "Roadmap",
    "url": "/docs/roadmap/FEATURE-EVOLUTION",
    "chunks": [
      {
        "id": "roadmap/FEATURE-EVOLUTION-chunk-0",
        "text": "Feature Evolution Matrix\nOverview\nThis matrix tracks how each Whizbang feature evolves across versions, showing clear progression from foundation to production-ready implementations Legend\n:::new New - Feature introduced in this version\n:::updated Enhanced - Feature improved from previous version\n:::updated{type=\"major\"} Major Update - Significant enhancement\n:::deprecated Deprecated - Feature being phased out\n:::planned Planned - Coming in future version\n- No changes in this version\nCore Components Evolution\nDispatcher\n| Version | Status | Key Features | Breaking Changes | Documentation |\n|---------|--------|--------------|------------------|---------------|\n| v0 1 0 | :::new New | • In-memory routing<br/>• Source-generated dispatch tables<br/>• Basic pipeline | - | View → |\n| v0 2 0 | :::updated Enhanced | • Parallel dispatch<br/>• Batch operations<br/>• Enhanced context | None | View → |\n| v0 3 0 | :::updated Enhanced | • Event store integration<br/>• Replay support | None | View → |\n| v0 4 0 | :::updated Enhanced | • Database persistence<br/>• Transaction support | None | View → |\n| v0 5 0 | :::updated{type=\"major\"} Major | • Distributed routing<br/>• Saga coordination | None | View → |\nReceptors\n| Version | Status | Key Features | Breaking Changes | Documentation |\n|---------|--------|--------------|------------------|---------------|\n| v0 1 0 | :::new New | • Stateless receptors<br/>• Basic interface<br/>• Command handling | - | View → |\n| v0 2 0 | :::updated Enhanced | • Validation attributes<br/>• Parameter injection<br/>• Async support | None | View → |\n| v0 3 0 | :::updated{type=\"major\"} Major | • Stateful receptors<br/>• Event sourcing<br/>• State hydration | None | View → |\n| v0 4 0 | - | No changes | - | - |\n| v0 5",
        "startIndex": 0,
        "preview": "Feature Evolution Matrix\nOverview\nThis matrix tracks how each Whizbang feature evolves across versions, showing clear progression from foundation to p..."
      },
      {
        "id": "roadmap/FEATURE-EVOLUTION-chunk-1",
        "text": "Validation attributes<br/>• Parameter injection<br/>• Async support | None | View → | | v0 3 0 | :::updated{type=\"major\"} Major | • Stateful receptors<br/>• Event sourcing<br/>• State hydration | None | View → | | v0 4 0 | - | No changes | - | - | | v0 5 0 | :::updated Enhanced | • Distributed execution<br/>• Remote receptors | None | View → |\nPerspectives\n| Version | Status | Key Features | Breaking Changes | Documentation |\n|---------|--------|--------------|------------------|---------------|\n| v0 1 0 | :::new New | • Event handling<br/>• In-memory updates<br/>• Basic interface | - | View → |\n| v0 2 0 | :::updated Enhanced | • Batch updates<br/>• Parallel execution<br/>• Error handling | None | View → |\n| v0 3 0 | :::updated{type=\"major\"} Major | • Projection support<br/>• Rebuild capability<br/>• Checkpoints | None | View → |\n| v0 4 0 | :::updated Enhanced | • Database backing<br/>• Optimized queries | None | View → |\n| v0 5 0 | :::updated Enhanced | • Distributed perspectives<br/>• Partitioned processing | None | View → |\nLenses\n| Version | Status | Key Features | Breaking Changes | Documentation |\n|---------|--------|--------------|------------------|---------------|\n| v0 1 0 | :::new New | • Query interface<br/>• Focus, View, Glimpse<br/>• In-memory queries | - | View → |\n| v0 2 0 | :::updated Enhanced | • Pagination<br/>• Async enumeration<br/>• Query optimization | None | View → |\n| v0 3 0 | :::updated Enhanced | • Projection queries<br/>• Time-travel queries | None | View → |\n| v0 4 0 | :::updated{type=\"major\"} Major | • SQL generation<br/>• Index usage<br/>• Query caching | None | View → |\n| v0 5",
        "startIndex": 1759,
        "preview": "Validation attributes<br/>• Parameter injection<br/>• Async support | None | View → | | v0 3 0 | :::updated{type=\"major\"} Major | • Stateful receptors..."
      },
      {
        "id": "roadmap/FEATURE-EVOLUTION-chunk-2",
        "text": "optimization | None | View → | | v0 3 0 | :::updated Enhanced | • Projection queries<br/>• Time-travel queries | None | View → | | v0 4 0 | :::updated{type=\"major\"} Major | • SQL generation<br/>• Index usage<br/>• Query caching | None | View → | | v0 5 0 | :::updated Enhanced | • Distributed queries<br/>• Federated lenses | None | View → |\nPolicy Engine\n| Version | Status | Key Features | Breaking Changes | Documentation |\n|---------|--------|--------------|------------------|---------------|\n| v0 1 0 | :::new New | • Retry<br/>• Timeout<br/>• Cache<br/>• CircuitBreaker | - | View → |\n| v0 2 0 | :::updated Enhanced | • Bulkhead<br/>• Rate limiting<br/>• Policy composition | None | View → |\n| v0 3 0 | :::updated Enhanced | • Stateful policies<br/>• Policy persistence | None | View → |\n| v0 4 0 | - | No changes | - | - |\n| v0 5 0 | :::updated Enhanced | • Distributed policies<br/>• Policy synchronization | None | View → |\n| v0 6 0 | :::planned Planned | • Authorization<br/>• Audit policies<br/>• Compliance policies | None | View → |\nLedger (Event Store)\n| Version | Status | Key Features | Breaking Changes | Documentation |\n|---------|--------|--------------|------------------|---------------|\n| v0 1 0 | :::new New | • Event store interface<br/>• In-memory storage<br/>• Basic streams | - | View → |\n| v0 2 0 | :::updated Enhanced | • Event metadata<br/>• Stream categories | None | View → |\n| v0 3 0 | :::updated{type=\"major\"} Major | • Snapshots<br/>• Projections<br/>• Event versioning | None | View → |\n| v0 4 0 | :::updated{type=\"major\"} Major | • Database persistence<br/>• JSONB storage<br/>• Indexes | None | View → |\n| v0 5",
        "startIndex": 3139,
        "preview": "optimization | None | View → | | v0 3 0 | :::updated Enhanced | • Projection queries<br/>• Time-travel queries | None | View → | | v0 4 0 | :::updated..."
      },
      {
        "id": "roadmap/FEATURE-EVOLUTION-chunk-3",
        "text": "Stream categories | None | View → | | v0 3 0 | :::updated{type=\"major\"} Major | • Snapshots<br/>• Projections<br/>• Event versioning | None | View → | | v0 4 0 | :::updated{type=\"major\"} Major | • Database persistence<br/>• JSONB storage<br/>• Indexes | None | View → | | v0 5 0 | :::updated Enhanced | • Distributed streams<br/>• Partitioning | None | View → |\nDrivers\n| Version | Status | Key Features | Breaking Changes | Documentation |\n|---------|--------|--------------|------------------|---------------|\n| v0 1 0 | :::new New | • Driver interface<br/>• In-memory driver | - | View → |\n| v0 2 0 | - | No changes | - | - |\n| v0 3 0 | :::updated Enhanced | • Transaction support<br/>• Batch operations | None | View → |\n| v0 4 0 | :::updated{type=\"major\"} Major | • PostgreSQL driver<br/>• SQL Server driver<br/>• SQLite driver | None | View → |\n| v0 5 0 | :::updated Enhanced | • Connection pooling<br/>• Failover support | None | View → |\nTransports\n| Version | Status | Key Features | Breaking Changes | Documentation |\n|---------|--------|--------------|------------------|---------------|\n| v0 1 0 | :::new New | • Transport interface<br/>• In-memory transport | - | View → |\n| v0 2 0 | - | No changes | - | - |\n| v0 3 0 | - | No changes | - | - |\n| v0 4 0 | :::updated Enhanced | • Outbox pattern prep | None | View → |\n| v0 5 0 | :::updated{type=\"major\"} Major | • Kafka transport<br/>• RabbitMQ transport<br/>• Azure Service Bus | None | View → |\nDeveloper Experience Evolution\nSource Generators\n| Version | Features | Performance Impact |\n|---------|----------|-------------------|\n| v0 1",
        "startIndex": 4536,
        "preview": "Stream categories | None | View → | | v0 3 0 | :::updated{type=\"major\"} Major | • Snapshots<br/>• Projections<br/>• Event versioning | None | View → |..."
      },
      {
        "id": "roadmap/FEATURE-EVOLUTION-chunk-4",
        "text": "| • Outbox pattern prep | None | View → | | v0 5 0 | :::updated{type=\"major\"} Major | • Kafka transport<br/>• RabbitMQ transport<br/>• Azure Service Bus | None | View → | Developer Experience Evolution Source Generators | Version | Features | Performance Impact | |---------|----------|-------------------| | v0 1 0 | • Handler discovery<br/>• Routing tables<br/>• Service registration | < 1s for 1000 handlers |\n| v0 2 0 | • Validation generation<br/>• Policy weaving | < 1 5s for 1000 handlers |\n| v0 3 0 | • Serialization generation<br/>• State machines | < 2s for 1000 handlers |\n| v0 4 0 | • SQL generation<br/>• Migration scripts | < 2 5s for 1000 handlers |\n| v0 5 0 | • Message contracts<br/>• Saga orchestration | < 3s for 1000 handlers |\nIDE Tools\n| Version | Features | Enhancements |\n|---------|----------|--------------|\n| v0 1 0 | • CodeLens references<br/>• Basic navigation<br/>• Analyzer warnings | Foundation |\n| v0 2 0 | • Enhanced traceability<br/>• Quick fixes<br/>• Refactoring support | +50% features |\n| v0 3 0 | • Time-travel debugging<br/>• Event replay<br/>• State inspection | +30% features |\n| v0 4 0 | • Query optimization hints<br/>• Index suggestions | +20% features |\n| v0 5 0 | • Distributed tracing<br/>• Message flow viz | +40% features |\nTesting Support\n| Version | Features | Test Types |\n|---------|----------|------------|\n| v0 1 0 | • TUnit integration<br/>• Bogus scenarios<br/>• In-memory doubles | Unit, Integration |\n| v0 2 0 | • Behavior specs<br/>• Property testing | + BDD, Property |\n| v0 3 0 | • Event sourcing helpers<br/>• Time travel testing | + Event Testing |\n| v0 4 0 | • Database testing<br/>• Migration testing | + Database |\n| v0 5",
        "startIndex": 5862,
        "preview": "| • Outbox pattern prep | None | View → | | v0 5 0 | :::updated{type=\"major\"} Major | • Kafka transport<br/>• RabbitMQ transport<br/>• Azure Service B..."
      },
      {
        "id": "roadmap/FEATURE-EVOLUTION-chunk-5",
        "text": "| | v0 2 0 | • Behavior specs<br/>• Property testing | + BDD, Property | | v0 3 0 | • Event sourcing helpers<br/>• Time travel testing | + Event Testing | | v0 4 0 | • Database testing<br/>• Migration testing | + Database | | v0 5 0 | • Distributed testing<br/>• Chaos engineering | + Distributed |\nMigration Complexity\nVersion Upgrade Paths\n| From → To | Complexity | Breaking Changes | Migration Guide |\n|-----------|------------|------------------|-----------------|\n| v0 1 0 → v0 2 0 | ⭐ Easy | None | Guide → |\n| v0 2 0 → v0 3 0 | ⭐⭐ Moderate | None | Guide → |\n| v0 3 0 → v0 4 0 | ⭐⭐ Moderate | None | Guide → |\n| v0 4 0 → v0 5 0 | ⭐⭐⭐ Complex | None | Guide → |\nFeature Adoption Timeline\n`mermaid\ngantt\n    title Feature Adoption Timeline\n    dateFormat YYYY-MM\n    section Foundation\n    Core Components     :done, 2025-01, 2025-02\n    Source Generators   :done, 2025-01, 2025-02\n    IDE Tools          :done, 2025-01, 2025-02\n    section Enhancement\n    Validation         :active, 2025-03, 2025-04\n    Policies           :active, 2025-03, 2025-04\n    section Event Sourcing\n    Stateful Receptors :2025-05, 2025-06\n    Projections        :2025-05, 2025-06\n    section Persistence\n    Database Drivers   :2025-07, 2025-08\n    Migrations         :2025-07, 2025-08\n    section Distributed\n    Message Transports :2025-09, 2025-10\n    Sagas             :2025-09, 2025-10\n`\nSuccess Metrics by Version\n| Version | Adoption Target | Performance Target | Quality Target |\n|---------|----------------|-------------------|----------------|\n| v0 1 0 | 100+ developers | < 1ms operations | 100% test coverage |\n| v0 2 0 | 500+ developers | < 1ms operations | 100% test coverage |\n| v0 3 0 | 1,000+ developers | < 10ms operations | 95% test coverage |\n| v0 4 0 | 5,000+ developers | < 10ms operations | 95% test coverage |\n| v0 5",
        "startIndex": 7239,
        "preview": "| | v0 2 0 | • Behavior specs<br/>• Property testing | + BDD, Property | | v0 3 0 | • Event sourcing helpers<br/>• Time travel testing | + Event Testi..."
      },
      {
        "id": "roadmap/FEATURE-EVOLUTION-chunk-6",
        "text": "v0 2 0 | 500+ developers | < 1ms operations | 100% test coverage | | v0 3 0 | 1,000+ developers | < 10ms operations | 95% test coverage | | v0 4 0 | 5,000+ developers | < 10ms operations | 95% test coverage | | v0 5 0 | 10,000+ developers | < 100ms operations | 90% test coverage |\nNavigation\nBack to Roadmap\nv0 1 0 Documentation\nSuccess Metrics\nSession Context",
        "startIndex": 8835,
        "preview": "v0 2 0 | 500+ developers | < 1ms operations | 100% test coverage | | v0 3 0 | 1,000+ developers | < 10ms operations | 95% test coverage | | v0 4 0 | 5..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "roadmap/README",
    "title": "Whizbang Implementation Roadmap",
    "category": "Roadmap",
    "url": "/docs/roadmap/README",
    "chunks": [
      {
        "id": "roadmap/README-chunk-0",
        "text": "Whizbang Implementation Roadmap\nOverview\nThis roadmap outlines the complete implementation plan for Whizbang, a unified event-sourced data and messaging runtime for NET We follow a breadth-first approach, establishing thin implementations of ALL major components early, then iteratively enhancing each component Core Principles\nZero Reflection: Everything discovered and wired at compile time via source generators\nIDE-First Development: Developer tools and traceability from day one\nTest-Driven: Comprehensive testing with TUnit and Bogus from the start\nProgressive Enhancement: Start simple, enhance iteratively\nIn-Memory First: All components start with in-memory implementations that become test doubles\nVersion Overview\n🚀 v0 1 0 - Foundation\nStatus: Planning  \nGoal: Minimal working implementation of EVERY major component\nAll core interfaces and abstractions\nSource generators and analyzers\nIDE tools with CodeLens-style references\nTraceability and debugging foundation\nComplete testing framework with TUnit and Bogus\nIn-memory implementations for all components\n📈 v0 2 0 - Event-Driven Enhancement\nStatus: Planning  \nGoal: Deepen event-driven capabilities\nEnhanced receptors with validation\nRich event metadata and correlation\nMultiple perspectives per event\nAdvanced lens query methods\nPolicy engine enhancements\n💾 v0 3 0 - Event Sourcing\nStatus: Planning  \nGoal: Add stateful capabilities\nStateful receptors\nTraditional aggregates\nEvent store implementation\nProjections and snapshots\nOptimistic concurrency\n🗄️ v0 4 0 - Real Persistence\nStatus: Planning  \nGoal: Production-ready persistence\nPostgreSQL driver with JSONB\nSQL Server driver with JSON columns\nSQLite driver for edge scenarios\nSchema migrations\nMulti-tenancy support\n📡 v0 5 0 - Distributed Systems\nStatus: Planning  \nGoal: Enable distributed messaging\nKafka transport\nRabbitMQ transport\nOutbox/Inbox patterns\nSaga orchestration\nDistributed tracing\n🔮 Future Versions\nv0 6 0 - Production Hardening (Observability, Security, Compliance)\nv0 7 0 - Performance & Scale (Zero allocation, AOT support)\nv0 8 0 - Cloud Native (Kubernetes, Serverless)\nv0 9 0 - Innovation (Effect system, AI integration)\nComponent Architecture\nCore Components Present from v0 1",
        "startIndex": 0,
        "preview": "Whizbang Implementation Roadmap\nOverview\nThis roadmap outlines the complete implementation plan for Whizbang, a unified event-sourced data and messagi..."
      },
      {
        "id": "roadmap/README-chunk-1",
        "text": "Distributed tracing 🔮 Future Versions v0 6 0 - Production Hardening (Observability, Security, Compliance) v0 7 0 - Performance & Scale (Zero allocation, AOT support) v0 8 0 - Cloud Native (Kubernetes, Serverless) v0 9 0 - Innovation (Effect system, AI integration) Component Architecture Core Components Present from v0 1 0\n| Component | Purpose | Starting Implementation |\n|-----------|---------|------------------------|\n| Dispatcher | Message routing and coordination | In-memory routing with generated mappings |\n| Receptors | Command receivers and decision makers | Stateless with parameter injection |\n| Perspectives | Event handlers and write models | In-memory state updates |\n| Lenses | Query interfaces and read models | In-memory LINQ queries |\n| Policy Engine | Cross-cutting concerns | Retry, Timeout, Cache, CircuitBreaker |\n| Ledger | Event store abstraction | In-memory event streams |\n| Drivers | Storage abstraction | In-memory storage |\n| Transports | Message broker abstraction | In-memory pub/sub |\nDeveloper Experience from Day One\n| Feature | Purpose | Available From |\n|---------|---------|----------------|\n| Source Generators | Zero-reflection handler discovery | v0 1 0 |\n| Analyzers | Compile-time validation | v0 1 0 |\n| IDE Tools | CodeLens references, navigation | v0 1 0 |\n| Traceability | Message flow visualization | v0 1 0 |\n| Time-Travel Debugging | Step through message history | v0 1 0 |\n| Test Framework | TUnit with Bogus scenarios | v0 1",
        "startIndex": 2229,
        "preview": "Distributed tracing 🔮 Future Versions v0 6 0 - Production Hardening (Observability, Security, Compliance) v0 7 0 - Performance & Scale (Zero allocati..."
      },
      {
        "id": "roadmap/README-chunk-2",
        "text": "1 0 | | IDE Tools | CodeLens references, navigation | v0 1 0 | | Traceability | Message flow visualization | v0 1 0 | | Time-Travel Debugging | Step through message history | v0 1 0 | | Test Framework | TUnit with Bogus scenarios | v0 1 0 |\nSuccess Metrics\nTechnical Goals\nZero reflection throughout the entire library\nSub-millisecond in-memory operations\n<10ms p99 for database operations\n<100ms p99 for distributed operations\n100% backward compatibility within major versions\nQuality Goals\n100% test coverage of public APIs\nAll code examples compile and run\nComplete documentation for every public API\nAnalyzers catch common mistakes at compile time\nDeveloper Experience Goals\nIntelliSense for all configuration options\nOne-click navigation between related components\nVisual debugging of message flow\nComprehensive error messages with fixes\nGetting Started\nRead the Philosophy - Understand our core principles\nReview the Architecture - See how components fit together\nStart with v0 1 0 - Begin with the foundation\nCheck Success Metrics - Understand how we measure progress\nContributing\nThis roadmap is a living document Each version's documentation contains:\nDetailed specifications for each component\nCode examples and patterns\nTesting requirements\nMigration guides from previous versions\nNavigation\nBy Version\nv0 1 0 - Foundation\nv0 2 0 - Event-Driven\nv0 3 0 - Event Sourcing\nv0 4 0 - Persistence\nv0 5 0 - Distributed\nFuture Versions\nBy Topic\nCore Philosophy\nArchitecture Overview\nSuccess Metrics\nTesting Strategy\nDeveloper Experience",
        "startIndex": 3386,
        "preview": "1 0 | | IDE Tools | CodeLens references, navigation | v0 1 0 | | Traceability | Message flow visualization | v0 1 0 | | Time-Travel Debugging | Step t..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "roadmap/SESSION-CONTEXT",
    "title": "Session Context for Claude",
    "category": "Roadmap",
    "url": "/docs/roadmap/SESSION-CONTEXT",
    "chunks": [
      {
        "id": "roadmap/SESSION-CONTEXT-chunk-0",
        "text": "Session Context for Claude\nQuick Start for New Sessions\nCopy this to Claude when starting a new session:\n> I'm working on implementing the Whizbang NET library Please read the SESSION-CONTEXT md file in src/assets/docs/roadmap/ for full context We're building a zero-reflection, event-driven/event-sourced messaging runtime with source generators and comprehensive IDE support from day one Project Overview\nWhat is Whizbang Whizbang is a unified event-sourced data and messaging runtime for NET that combines the best aspects of MediatR, Wolverine, MassTransit, and NServiceBus into a single, cohesive platform with progressive enhancement Current Status\nPhase: Implementation planning and documentation\nCurrent Version: v0 1 0 (Foundation) - Planning\nDocumentation: Located in src/assets/docs/\nOld Docs: Previous versions prefixed with old- for reference\nCore Implementation Principles\nNon-Negotiable Rules\nZERO REFLECTION - Everything via source generators, no exceptions\nIDE-First - CodeLens, traceability, and debugging from day one\nTest-Driven - TUnit + Bogus for all components\nBreadth-First - All components exist from v0 1 0, even if simple\nIn-Memory First - All components start with in-memory implementations\nArchitecture Components (All in v0 1 0)\nDispatcher - Message routing coordination\nReceptors - Command receivers (not handlers)\nPerspectives - Event handlers (not projections initially)\nLenses - Read-only query interfaces\nPolicy Engine - Cross-cutting concerns\nLedger - Event store abstraction\nDrivers - Storage abstraction\nTransports - Message broker abstraction\nUnique Terminology\nReceptors instead of Handlers (emphasizes decision-making)\nPerspectives instead of Projections (more general, handles all writes)\nLenses for queries (composable, functional)\nLedger instead of Event Store (cleaner abstraction)\nDocumentation Structure\n`\nsrc/assets/docs/\n├── roadmap/                    Implementation roadmap\n│   ├── README md              Main roadmap navigation\n│   ├── philosophy md          Core principles\n│   ├── architecture md        Component relationships\n│   ├── success-metrics md     How we measure success\n│   └── SESSION-CONTEXT md     This file\n├── v0 1",
        "startIndex": 0,
        "preview": "Session Context for Claude\nQuick Start for New Sessions\nCopy this to Claude when starting a new session:\n> I'm working on implementing the Whizbang NE..."
      },
      {
        "id": "roadmap/SESSION-CONTEXT-chunk-1",
        "text": "instead of Event Store (cleaner abstraction) Documentation Structure ` src/assets/docs/ ├── roadmap/ Implementation roadmap │ ├── README md Main roadmap navigation │ ├── philosophy md Core principles │ ├── architecture md Component relationships │ ├── success-metrics md How we measure success │ └── SESSION-CONTEXT md This file ├── v0 1 0/                    Foundation release (current focus)\n│   ├── components/            Component specifications\n│   ├── developer-experience/  IDE, source generators, debugging\n│   ├── testing/              Testing strategy\n│   └── examples/             Code examples\n├── v0 2 0/ through v0 5 0/    Future versions\n├── future/                    Long-term vision (v0 6 0+)\n└── old-*/                     Previous documentation for reference\n`\nCurrent Implementation Focus\nv0 1 0 Goals\n[ ] All 8 core components with interfaces\n[ ] Source generators for zero-reflection discovery\n[ ] IDE tools with CodeLens-style references\n[ ] Traceability and time-travel debugging foundation\n[ ] Complete testing framework (TUnit + Bogus)\n[ ] In-memory implementations (become test doubles)\nKey Files to Review\n/roadmap/philosophy md - Core principles and anti-patterns\n/roadmap/architecture md - Component relationships\n/v0 1 0/README md - Current version details\n/v0 1 0/components/dispatcher md - Example component spec\nDevelopment Patterns\nSource Generator Pattern\n`csharp\n[WhizbangHandler]  // Source generator discovers this\npublic class OrderReceptor : IReceptor<CreateOrder> {\n    public OrderCreated Receive(CreateOrder cmd) { }\n}\n`\nPolicy Pattern\n`csharp\n[Retry(3)]\n[Timeout(5000)]\n[Cache(300)]\npublic class PaymentReceptor : IReceptor<ProcessPayment> { }\n`\nTesting Pattern\n`csharp\n[Test]\n[MethodDataSource(nameof(OrderScenarios))]  // Bogus generates scenarios\npublic async Task CreateOrder_ShouldEmitOrderCreated(OrderScenario scenario) { }\n`\nVersion Progression\nv0 1 0 - Foundation (all components, in-memory)\nv0 2 0 - Event-Driven Enhancement (validation, rich events)\nv0 3 0 - Event Sourcing (stateful receptors, aggregates)\nv0 4 0 - Real Persistence (PostgreSQL, SQL Server, SQLite)\nv0 5 0 - Distributed Systems (Kafka, RabbitMQ, Sagas)\nv0 6",
        "startIndex": 2193,
        "preview": "instead of Event Store (cleaner abstraction) Documentation Structure ` src/assets/docs/ ├── roadmap/ Implementation roadmap │ ├── README md Main roadm..."
      },
      {
        "id": "roadmap/SESSION-CONTEXT-chunk-2",
        "text": "` Version Progression v0 1 0 - Foundation (all components, in-memory) v0 2 0 - Event-Driven Enhancement (validation, rich events) v0 3 0 - Event Sourcing (stateful receptors, aggregates) v0 4 0 - Real Persistence (PostgreSQL, SQL Server, SQLite) v0 5 0 - Distributed Systems (Kafka, RabbitMQ, Sagas) v0 6 0+ - Production, Performance, Cloud, Innovation\nCommon Tasks\nAdding a New Component Spec\nCreate file in /v0 1 0/components/[component] md\nInclude: Interface, In-Memory Implementation, Source Generation, Testing, IDE Integration\nUpdate /v0 1 0/components/README md navigation\nAdding a New Version\nCreate folder /v0 X 0/\nAdd _folder md with metadata\nCreate README md with version overview\nAdd migration-guide md from previous version\nWorking on Specific Topics\nComponents: Focus on /v0 1 0/components/\nTesting: Focus on /v0 1 0/testing/\nIDE Features: Focus on /v0 1 0/developer-experience/\nExamples: Focus on /v0 1 0/examples/\nKey Decisions Made\nNo Reflection Ever - Source generators from day one\nBreadth First - All components in v0 1 0\nTUnit over xUnit/NUnit - Modern, fast, better DX\nBogus for Test Data - Realistic scenario generation\nIn-Memory as Test Doubles - Not throwaway code\nPolicies over Aspects - Explicit, composable, testable\nQuestions/Discussions in Progress\n[ ] Exact IDE overlay visualization format\n[ ] Specific OpenTelemetry integration points\n[ ] Dashboard technology (Blazor vs React)\n[ ] Package naming conventions\n[ ] CI/CD pipeline structure\nWorking Conventions\nCode Examples\nAlways show complete, compilable examples\nInclude using statements\nShow both simple and advanced usage\nInclude testing examples\nDocumentation Style\nUse clear headings and sections\nInclude code examples with syntax highlighting\nProvide \"why\" not just \"what\"\nLink between related documents\nFile Naming\nComponents: [component-name] md\nGuides: [topic]-guide md\nExamples: [scenario]-example",
        "startIndex": 4038,
        "preview": "` Version Progression v0 1 0 - Foundation (all components, in-memory) v0 2 0 - Event-Driven Enhancement (validation, rich events) v0 3 0 - Event Sourc..."
      },
      {
        "id": "roadmap/SESSION-CONTEXT-chunk-3",
        "text": "Examples Always show complete, compilable examples Include using statements Show both simple and advanced usage Include testing examples Documentation Style Use clear headings and sections Include code examples with syntax highlighting Provide \"why\" not just \"what\" Link between related documents File Naming Components: [component-name] md Guides: [topic]-guide md Examples: [scenario]-example md\nAlways lowercase with hyphens\nConcepts & Patterns Documentation\nPattern Documentation Standards\nAll pattern files in /src/assets/patterns/ follow this proven structure (based on successful Receptor Pattern template):\nRequired Structure\nFront-matter - Standard metadata (title, category, order, description, tags)\nTitle & Tagline - Pattern name with memorable quote  \nEvolution (Early in document - key placement )\nPattern Roadmap\nVersion Timeline (Mermaid flowchart showing v0 1 0 → v0 5 0)\nCapability Growth by Version\nCode examples for each version with enhanced front-matter metadata\nProgressive complexity from foundation to distributed\nEvolution Benefits\nMigration Path\nCapability Matrix (Mermaid diagram showing evolution timeline)\nPattern Overview\nWhat is [Pattern] Key Characteristics  \nIndustry Pattern Comparisons (embedded, no separate header):\nTraditional Pattern Name - Similarity: and Difference:\nMultiple comparisons showing how this pattern relates to existing approaches\nWhen to Use [Pattern]\nImplementation - Technical details and core concepts\nCode Examples - Progressive complexity with full metadata\nWhen to Use This Pattern - Clear guidance and anti-patterns\nCommon Misconceptions - Address typical confusion points\nImplementation Checklist - Practical step-by-step guidance\nExample: [Specific Scenario] - Complete working implementation\nBenefits - For developers and systems\nNext Steps - Links to related patterns\nKey Standards\nEvolution section placement: Position #3 (early), not late in document\nIndustry comparisons: Use Similarity: and Difference: format (bold text renders automatically)\nCode examples: All must have enhanced front-matter with metadata including:\ntitle, description, framework, category, difficulty\ntags, nugetPackages, filename, testFile, testMethod, usingStatements\nMermaid diagrams: Use consistent color schemes across all patterns\nVersion progression: Always follows v0",
        "startIndex": 5624,
        "preview": "Examples Always show complete, compilable examples Include using statements Show both simple and advanced usage Include testing examples Documentation..."
      },
      {
        "id": "roadmap/SESSION-CONTEXT-chunk-4",
        "text": "not late in document Industry comparisons: Use Similarity: and Difference: format (bold text renders automatically) Code examples: All must have enhanced front-matter with metadata including: title, description, framework, category, difficulty tags, nugetPackages, filename, testFile, testMethod, usingStatements Mermaid diagrams: Use consistent color schemes across all patterns Version progression: Always follows v0 1 0 → v0 2 0 → v0 3 0 → v0 4 0 → v0 5 0\nCross-references: Use relative links between related patterns\nContent Quality Requirements\nAll code examples must be complete and compilable\nProgressive complexity from simple to distributed scenarios\nClear explanations of \"why\" not just \"what\"\nTestable examples with accompanying test methods\nConsistent terminology aligned with Whizbang's unique vocabulary\nSession Handoff Notes\nFor next session, current priorities are:\nComplete remaining v0 1 0 component specifications\nDetail out testing foundation with TUnit/Bogus\nSpecify source generator implementation\nCreate developer experience documentation\nAdd concrete examples for each component\nRecent work completed:\nRenamed old version folders to old-*\nCreated complete roadmap documentation structure\nEstablished v0 1 0 through v0 5 0 version folders\nDocumented philosophy and architecture\nCreated success metrics framework\nQuick Commands\n`bash\nNavigate to docs\ncd /Users/philcarbone/src/whizbang-lib github io/src/assets/docs\nView structure\nls -la roadmap/ v0 1 0/\nFind all component docs\nfind -name \"component md\"\nSearch for specific patterns\ngrep -r \"IReceptor\" --include=\"* md\"\n`\nContact/Questions\nGitHub: https://github com/whizbang/whizbang\nDiscussions: Use GitHub Discussions for design questions\nDocumentation Site: This site (whizbang-lib github io)\n---\nRemember: We're building the future of NET messaging - zero reflection, exceptional DX, progressive enhancement",
        "startIndex": 731,
        "preview": "not late in document Industry comparisons: Use Similarity: and Difference: format (bold text renders automatically) Code examples: All must have enhan..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "roadmap/architecture",
    "title": "Architecture Overview",
    "category": "Roadmap",
    "url": "/docs/roadmap/architecture",
    "chunks": [
      {
        "id": "roadmap/architecture-chunk-0",
        "text": "Architecture Overview\nComponent Architecture\n`mermaid\ngraph TB\n    subgraph \"Message Flow\"\n        CMD[Command] --> DISP[Dispatcher]\n        DISP --> REC[Receptor]\n        REC --> EVT[Event]\n        EVT --> DISP2[Dispatcher]\n        DISP2 --> PERSP[Perspectives]\n    end\n    subgraph \"Query Flow\"\n        QUERY[Query] --> LENS[Lens]\n        LENS --> STORE[(Storage)]\n    end\n    subgraph \"Cross-Cutting\"\n        POLICY[Policy Engine] - ->|Applies to| REC\n        POLICY - ->|Applies to| PERSP\n        TRACE[Traceability] - ->|Observes| DISP\n        TRACE -",
        "startIndex": 0,
        "preview": "Architecture Overview\nComponent Architecture\n`mermaid\ngraph TB\n    subgraph \"Message Flow\"\n        CMD[Command] --> DISP[Dispatcher]\n        DISP --> ..."
      },
      {
        "id": "roadmap/architecture-chunk-1",
        "text": "graph TB subgraph \"Message Flow\" CMD[Command] --> DISP[Dispatcher] DISP --> REC[Receptor] REC --> EVT[Event] EVT --> DISP2[Dispatcher] DISP2 --> PERSP[Perspectives] end subgraph \"Query Flow\" QUERY[Query] --> LENS[Lens] LENS --> STORE[(Storage)] end subgraph \"Cross-Cutting\" POLICY[Policy Engine] - ->|Applies to| REC POLICY - ->|Applies to| PERSP TRACE[Traceability] - ->|Observes| DISP TRACE - ->|Observes| DISP2\n    end\n    PERSP --> STORE\n    LEDGER[(Event Store)] --> STORE\n    style CMD fill:#e1f5fe\n    style EVT fill:#fff3e0\n    style STORE fill:#f3e5f5\n    style POLICY fill:#e8f5e9\n`\nCore Components\nDispatcher\nThe nervous system of Whizbang\n`csharp\npublic interface IDispatcher {\n    // Commands go to exactly one receptor\n    Task<TResult> Send<TResult>(ICommand<TResult> command);\n    // Events go to all interested perspectives\n    Task Publish<TEvent>(TEvent @event);\n    // Queries go through lenses\n    TLens GetLens<TLens>() where TLens : ILens;\n}\n`\nThe Dispatcher:\nRoutes messages based on compile-time generated tables\nManages execution pipeline\nApplies policies\nTracks correlation and causation\nProvides traceability hooks\nReceptors\nCommand receivers and decision makers\n`csharp\npublic interface IReceptor<TCommand> {\n    object Receive(TCommand command);\n}\n`\nReceptors:\nReceive commands from the dispatcher\nMake decisions based on business rules\nEmit events representing decisions\nCan be stateless (Event-Driven) or stateful (Event-Sourced)\nNever perform side effects directly\nPerspectives\nEvent handlers that update views\n`csharp\npublic interface IPerspectiveOf<TEvent> {\n    Task Update(TEvent @event);\n}\n`\nPerspectives:\nReact to events from receptors\nUpdate databases, caches, search indexes\nMaintain different views of the same data\nExecute all write operations\nCan be synchronous or asynchronous\nLenses\nRead-only query interfaces\n`csharp\npublic interface ILens {\n    T Focus<T>(object id);                              // Single item\n    IEnumerable<T> View<T>(Expression<Func<T, bool>> filter);  // Filtered set\n    TSummary Glimpse<TSummary>(object id);             // Partial view\n    bool Exists(object id);                            // Existence check\n    IAsyncEnumerable<T> Scan<T>();                     // Full scan\n}\n`\nLenses:\nProvide read-only access to data\nFocus on specific query needs\nAbstract storage mechanism\nSupport different view shapes\nEnable query optimization\nPolicy Engine\nCross-cutting concerns as composable policies\n`csharp\n[Retry(3, BackoffStrategy",
        "startIndex": 557,
        "preview": "graph TB subgraph \"Message Flow\" CMD[Command] --> DISP[Dispatcher] DISP --> REC[Receptor] REC --> EVT[Event] EVT --> DISP2[Dispatcher] DISP2 --> PERSP..."
      },
      {
        "id": "roadmap/architecture-chunk-2",
        "text": "TSummary Glimpse<TSummary>(object id); // Partial view bool Exists(object id); // Existence check IAsyncEnumerable<T> Scan<T>(); // Full scan } ` Lenses: Provide read-only access to data Focus on specific query needs Abstract storage mechanism Support different view shapes Enable query optimization Policy Engine Cross-cutting concerns as composable policies `csharp [Retry(3, BackoffStrategy Exponential)]\n[Timeout(5000)]\n[Cache(Duration = 300)]\n[CircuitBreaker(0 5, 10)]\npublic class PaymentReceptor : IReceptor<ProcessPayment> { }\n`\nPolicies include:\nResilience: Retry, Circuit Breaker, Timeout, Fallback\nPerformance: Cache, Batch, Throttle\nSecurity: Authorize, Audit, Encrypt\nObservability: Trace, Metric, Log\nLedger (Event Store)\nThe source of truth for events\n`csharp\npublic interface ILedger {\n    // Append events to a stream\n    Task<long> Append(string stream, IEnumerable<object> events, long expectedVersion = null);\n    // Load events from a stream\n    IAsyncEnumerable<IEvent> Load(string stream, long from = 0);\n    // Subscribe to events\n    IDisposable Subscribe(string stream, Func<IEvent, Task> handler);\n    // Snapshot support\n    Task SaveSnapshot(string stream, object snapshot);\n    Task<T",
        "startIndex": 2666,
        "preview": "TSummary Glimpse<TSummary>(object id); // Partial view bool Exists(object id); // Existence check IAsyncEnumerable<T> Scan<T>(); // Full scan } ` Lens..."
      },
      {
        "id": "roadmap/architecture-chunk-3",
        "text": "interface ILedger { // Append events to a stream Task<long> Append(string stream, IEnumerable<object> events, long expectedVersion = null); // Load events from a stream IAsyncEnumerable<IEvent> Load(string stream, long from = 0); // Subscribe to events IDisposable Subscribe(string stream, Func<IEvent, Task> handler); // Snapshot support Task SaveSnapshot(string stream, object snapshot); Task<T > LoadSnapshot<T>(string stream);\n}\n`\nDrivers\nStorage abstraction layer\n`csharp\npublic interface IDriver {\n    // Execute queries\n    Task<T> Query<T>(IQuery<T> query);\n    // Execute commands\n    Task Execute(ICommand command);\n    // Transaction support\n    Task<T> Transaction<T>(Func<ITransaction, Task<T>> action);\n    // Migration support\n    Task Migrate(IMigration migration);\n}\n`\nDrivers available:\nInMemoryDriver: Development and testing\nPostgreSQLDriver: JSONB support\nSqlServerDriver: JSON columns\nSQLiteDriver: Edge scenarios\nCustom: Implement IDriver\nTransports\nMessage broker abstraction\n`csharp\npublic interface ITransport {\n    // Send messages\n    Task Send<T>(string destination, T message);\n    // Subscribe to messages\n    IDisposable Subscribe<T>(string source, Func<T, Task> handler);\n    // Request-Reply pattern\n    Task<TResponse> Request<TRequest, TResponse>(string destination, TRequest request);\n}\n`\nTransports available:\nInMemoryTransport: Development and testing\nKafkaTransport: High-throughput streaming\nRabbitMQTransport: Reliable messaging\nAzureServiceBusTransport: Cloud-native\nCustom: Implement ITransport\nMessage Flow Patterns\nCommand Flow (Event-Driven Mode)\n`\nCommand → Dispatcher → Receptor → Event → Perspectives → Storage\n                          ↓\n                        Lens ← Query\n`\nCommand Flow (Event-Sourced Mode)\n`\nCommand → Dispatcher → Receptor → Event → Ledger\n                                     ↓\n                              Perspectives → Read Models\n                                     ↓\n                                   Lens ← Query\n`\nQuery Flow\n`\nQuery → Lens → Storage → Result\n`\nSaga Flow\n`\nEvent → Saga Coordinator → Command → Receptor\n          ↓                   ↓\n      Saga State          New Event → Continue/Complete\n`\nProgressive Enhancement Path\nLevel 1: In-Process Event-Driven\n`csharp\nservices AddWhizbang() UseInMemory();  // Everything in-memory\n`\nCommands → Receptors → Events → Perspectives\nAll synchronous, in-process\nPerfect for development\nLevel 2: Event-Sourced\n`csharp\nservices AddWhizbang() UseEventSourcing() UseInMemory();  // In-memory event store\n`\nAdd event store (Ledger)\nSupport stateful receptors\nEnable projections\nLevel 3: Persistent\n`csharp\nservices AddWhizbang() UseEventSourcing()",
        "startIndex": 3488,
        "preview": "interface ILedger { // Append events to a stream Task<long> Append(string stream, IEnumerable<object> events, long expectedVersion = null); // Load ev..."
      },
      {
        "id": "roadmap/architecture-chunk-4",
        "text": "`csharp services AddWhizbang() UseInMemory(); // Everything in-memory ` Commands → Receptors → Events → Perspectives All synchronous, in-process Perfect for development Level 2: Event-Sourced `csharp services AddWhizbang() UseEventSourcing() UseInMemory(); // In-memory event store ` Add event store (Ledger) Support stateful receptors Enable projections Level 3: Persistent `csharp services AddWhizbang() UseEventSourcing() UsePostgreSQL(\"connection-string\");\n`\nReal database persistence\nProduction-ready storage\nSchema migrations\nLevel 4: Distributed\n`csharp\nservices AddWhizbang() UseEventSourcing() UsePostgreSQL(\"connection-string\") UseKafka(\"bootstrap-servers\");\n`\nDistributed messaging\nMicroservices ready\nSaga orchestration\nComponent Relationships\nCompile-Time Relationships\nSource Generators discover and wire components\nAnalyzers validate relationships\nGenerated Code creates efficient dispatch tables\nRuntime Relationships\nDispatcher coordinates all message flow\nPolicy Engine wraps component execution\nTraceability observes all operations\nLedger persists all events\nTesting Relationships\nIn-Memory Implementations serve as test doubles\nTest Harness provides scenario execution\nVerification uses recorded interactions\nKey Design Decisions\nWhy Receptors Instead of Handlers Receptors emphasize decision-making over handling\nThey're the same interface for stateless and stateful\nThey make the event-driven nature explicit\nThey separate concerns better than traditional handlers\nWhy Perspectives Instead of Projections Perspectives are more general than projections\nThey handle all write operations, not just read models\nThey can update multiple stores\nThey emphasize the \"view\" nature of the data\nWhy Lenses for Queries Lenses are composable\nThey're purely functional\nThey separate query concerns from storage\nThey enable query optimization\nWhy Policies Instead of Aspects",
        "startIndex": 5798,
        "preview": "`csharp services AddWhizbang() UseInMemory(); // Everything in-memory ` Commands → Receptors → Events → Perspectives All synchronous, in-process Perfe..."
      },
      {
        "id": "roadmap/architecture-chunk-5",
        "text": "general than projections They handle all write operations, not just read models They can update multiple stores They emphasize the \"view\" nature of the data Why Lenses for Queries Lenses are composable They're purely functional They separate query concerns from storage They enable query optimization Why Policies Instead of Aspects Policies are more explicit\nThey're composable and configurable\nThey're testable in isolation\nThey avoid AOP magic\nExtension Points\nCustom Components\nImplement IReceptor<T> for custom command handling\nImplement IPerspectiveOf<T> for custom event handling\nImplement ILens for custom queries\nImplement IPolicyOf<T> for custom policies\nCustom Drivers\nImplement IDriver for new databases\nImplement ITransport for new message brokers\nImplement ILedger for custom event stores\nSource Generator Extensions\nAdd custom attributes for discovery\nGenerate specialized dispatch code\nCreate domain-specific optimizations\nPerformance Architecture\nCompile-Time Optimizations\nGenerated dispatch tables (no reflection)\nInlined serialization code\nPre-compiled expressions\nAOT-friendly code\nRuntime Optimizations\nObject pooling for messages\nZero-allocation patterns\nEfficient async state machines\nMinimal boxing/unboxing\nStorage Optimizations\nBatch operations\nPrepared statements\nConnection pooling\nQuery plan caching\nThis architecture provides a solid foundation that scales from simple in-process messaging to complex distributed event-sourced systems, all while maintaining the same programming model",
        "startIndex": 7274,
        "preview": "general than projections They handle all write operations, not just read models They can update multiple stores They emphasize the \"view\" nature of th..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "roadmap/philosophy",
    "title": "Implementation Philosophy",
    "category": "Roadmap",
    "url": "/docs/roadmap/philosophy",
    "chunks": [
      {
        "id": "roadmap/philosophy-chunk-0",
        "text": "Implementation Philosophy\nCore Principles\nZero Reflection - Compile-Time Everything\nWe never use reflection Ever All handler discovery happens at compile time via source generators\nAll routing tables are generated during compilation\nAll serialization code is generated, not reflected\nType information is captured at compile time, not runtime\n`csharp\n// ❌ NEVER THIS\nvar handlers = Assembly GetExecutingAssembly() GetTypes() Where(t => t IsAssignableTo(typeof(IHandler)));\n// ✅ ALWAYS THIS\n[WhizbangHandler]  // Source generator finds this at compile time\npublic class OrderHandler : IReceptor<CreateOrder> { }\n`\nIDE-First Development\nThe IDE experience is not an afterthought - it's foundational From day one, we provide:\nCodeLens-style references: See handler counts, event publishers, consumers\nTraceability overlays: Visualize message flow inline\nTime-travel debugging: Step through message history\nSmart navigation: Jump between commands, handlers, and events\nCompile-time validation: Catch errors before runtime\n`csharp\n// The IDE shows: \"3 handlers | 2 perspectives | Last: 50ms ago\"\npublic record OrderCreated(Guid OrderId);  \n// The IDE shows: \"Handles: CreateOrder | Publishes: OrderCreated\"\npublic class OrderReceptor : IReceptor<CreateOrder> { }\n`\nTest-Driven from the Start\nTesting is not bolted on - it's built in TUnit for modern, fast, parallel testing\nBogus for realistic scenario generation\nBehavior Specs for BDD-style testing\nIn-Memory Doubles that become production test doubles\nProperty-Based Testing for edge case discovery\n`csharp\n[Test]\n[MethodDataSource(nameof(OrderScenarios))]  // Bogus generates scenarios\npublic async Task CreateOrder_ShouldEmitExpectedEvents(OrderScenario scenario) {\n    // Every component is testable from day one\n    var result = await dispatcher Send(scenario Command);\n    await Verify That(result) Matches(scenario Expected);\n}\n`\nProgressive Enhancement\nStart simple, enhance iteratively, maintain compatibility `csharp\n// v0 1 0 - Simple in-memory\nservices AddWhizbang() UseInMemory();\n// v0 3 0 - Add event sourcing (same code still works )\nservices AddWhizbang() UseEventSourcing() UseInMemory();\n// v0 4 0 - Add persistence (same code still works )\nservices AddWhizbang() UseEventSourcing() UsePostgreSQL();\n// v0",
        "startIndex": 0,
        "preview": "Implementation Philosophy\nCore Principles\nZero Reflection - Compile-Time Everything\nWe never use reflection Ever All handler discovery happens at comp..."
      },
      {
        "id": "roadmap/philosophy-chunk-1",
        "text": "enhance iteratively, maintain compatibility `csharp // v0 1 0 - Simple in-memory services AddWhizbang() UseInMemory(); // v0 3 0 - Add event sourcing (same code still works ) services AddWhizbang() UseEventSourcing() UseInMemory(); // v0 4 0 - Add persistence (same code still works ) services AddWhizbang() UseEventSourcing() UsePostgreSQL(); // v0 5 0 - Add distribution (same code still works )\nservices AddWhizbang() UseEventSourcing() UsePostgreSQL() UseKafka();\n`\nBreadth-First Implementation\nAll components exist from day one, even if simple We don't build deep, then wide We build wide, then deep:\nv0 1 0 has EVERY component (dispatcher, receptors, perspectives, lenses, policies, ledger, drivers, transports)\nEach component starts thin but functional\nWe enhance all components together, maintaining consistency\nNo component is \"coming later\" - everything is always available\nIn-Memory First\nEverything starts in-memory, which becomes our testing foundation In-memory implementations are not throwaway code\nThey become the test doubles for unit testing\nThey provide fast feedback during development\nThey enable offline development\nThey're always available as a fallback\n`csharp\n// In-memory implementations are first-class citizens\npublic class InMemoryLedger : ILedger {\n    // This becomes our test double AND our development database\n}\n`\nPerformance by Design\nPerformance is not an optimization - it's a requirement Zero allocation patterns from the start\nSource generation for hot paths\nCompile-time optimization via generators\nAOT compatibility from day one\nBenchmark everything with BenchmarkDotNet\n`csharp\n// Generated code is faster than runtime reflection\n[Generated]\npublic static class OrderHandlerDispatcher {\n    // Source-generated dispatch table - zero reflection, zero allocation\n    public static readonly Dictionary<Type, Delegate> Handlers = new() {\n        [typeof(CreateOrder)] = OrderReceptor Handle_CreateOrder\n    };\n}\n`\nDeveloper Experience is User Experience\nFor a library, developers ARE the users",
        "startIndex": 1093,
        "preview": "enhance iteratively, maintain compatibility `csharp // v0 1 0 - Simple in-memory services AddWhizbang() UseInMemory(); // v0 3 0 - Add event sourcing ..."
      },
      {
        "id": "roadmap/philosophy-chunk-2",
        "text": "Generated code is faster than runtime reflection [Generated] public static class OrderHandlerDispatcher { // Source-generated dispatch table - zero reflection, zero allocation public static readonly Dictionary<Type, Delegate> Handlers = new() { [typeof(CreateOrder)] = OrderReceptor Handle_CreateOrder }; } ` Developer Experience is User Experience For a library, developers ARE the users Clear, actionable error messages with suggested fixes\nComprehensive IntelliSense documentation\nAnalyzers that guide not just validate\nCode fixes for common patterns\nVisual debugging tools built-in\n`csharp\n// Analyzer: \"OrderCreated event is not handled by any perspective\"\n// Code Fix: \"Generate OrderPerspective class\"\n// Quick Action: \"Add handler for OrderCreated\"\n`\nPolicies as First-Class Citizens\nCross-cutting concerns are not aspects - they're policies Policies are:\nComposable\nTestable\nMeasurable\nConfigurable\nDiscoverable\n`csharp\n[Retry(3)]\n[Timeout(5000)]\n[Cache(300)]\n[Authorize(\"OrderAdmin\")]\npublic class OrderReceptor : IReceptor<CreateOrder> {\n    // Policies are composed and applied via source generation\n}\n`\nTraceability Built-In\nEvery message is traceable, every decision is observable From v0 1 0:\nCorrelation IDs flow automatically\nCausation chains are tracked\nTiming information is captured\nDecision points are recorded\nOpenTelemetry hooks are everywhere\n`csharp\n// Every message carries its history\npublic interface IMessageContext {\n    Guid CorrelationId { get; }\n    Guid CausationId { get; }\n    DateTimeOffset Timestamp { get; }\n    Dictionary<string, object> Metadata { get; }\n    ISpan Span { get; }  // OpenTelemetry span\n}\n`\nAnti-Patterns We Avoid\n❌ No Reflection\nNo assembly scanning\nNo runtime type discovery\nNo dynamic invocation\nNo expression tree compilation at runtime\n❌ No Magic\nExplicit over implicit\nConvention with configuration\nDiscoverable behavior\nNo hidden side effects\n❌ No Framework Lock-In\nAbstractions over implementations\nSwappable components\nStandard interfaces\nMinimal dependencies\n❌ No Untestable Code\nEverything has an interface\nEverything has a test double\nEverything is observable\nEverything is measurable\nImplementation Strategy\nPhase 1: Foundation (v0 1",
        "startIndex": 3974,
        "preview": "Generated code is faster than runtime reflection [Generated] public static class OrderHandlerDispatcher { // Source-generated dispatch table - zero re..."
      },
      {
        "id": "roadmap/philosophy-chunk-3",
        "text": "over implicit Convention with configuration Discoverable behavior No hidden side effects ❌ No Framework Lock-In Abstractions over implementations Swappable components Standard interfaces Minimal dependencies ❌ No Untestable Code Everything has an interface Everything has a test double Everything is observable Everything is measurable Implementation Strategy Phase 1: Foundation (v0 1 0)\nBuild wide - every component exists, even if simple Phase 2: Enhancement (v0 2 0-v0 3 0)\nBuild deep - enhance each component iteratively Phase 3: Production (v0 4 0-v0 5 0)\nBuild real - replace in-memory with production implementations Phase 4: Scale (v0 6 0+)\nBuild up - add enterprise features and optimizations Measuring Success\nWe measure success by:\nZero reflection in production code\n100% test coverage of public APIs\nSub-millisecond in-memory operations\nSingle-digit millisecond database operations\nNo breaking changes within major versions\nCompile-time safety for all operations\nDeveloper satisfaction via feedback\nThe Whizbang Promise\nWhen you use Whizbang, you get:\nPerformance without complexity\nSafety without ceremony\nPower without lock-in\nFlexibility without magic\nObservability without overhead\nThis is not just a messaging library This is a new way of building NET applications",
        "startIndex": 5791,
        "preview": "over implicit Convention with configuration Discoverable behavior No hidden side effects ❌ No Framework Lock-In Abstractions over implementations Swap..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "roadmap/success-metrics",
    "title": "Success Metrics",
    "category": "Roadmap",
    "url": "/docs/roadmap/success-metrics",
    "chunks": [
      {
        "id": "roadmap/success-metrics-chunk-0",
        "text": "Success Metrics\nOverview\nSuccess is measured across multiple dimensions: technical performance, code quality, developer experience, and adoption Each version has specific success criteria that must be met before moving forward Version-Specific Success Criteria\nv0 1 0 - Foundation Success\nCore Functionality\n✅ All 8 core components have working implementations\n✅ Source generators discover and wire all handlers\n✅ Zero reflection in production code\n✅ All components work with in-memory implementations\n✅ Basic policy engine with 4+ policies working\nDeveloper Experience\n✅ IDE shows handler references via CodeLens\n✅ Analyzers catch 5+ common mistakes\n✅ Code fixes available for all analyzer warnings\n✅ IntelliSense works for all public APIs\n✅ Traceability shows message flow\nTesting\n✅ TUnit integration complete\n✅ Bogus generates 10+ scenario types\n✅ Behavior specs framework working\n✅ 100% test coverage of public APIs\n✅ All in-memory implementations usable as test doubles\nPerformance\n✅ < 1ms for in-memory message dispatch\n✅ < 100μs for handler invocation\n✅ Zero allocations in hot path\n✅ Source generator < 1s for 1000 handlers\nv0 2 0 - Event-Driven Enhancement Success\nFunctionality\n✅ Validation attributes work on all commands\n✅ Multiple perspectives can handle same event\n✅ Lens methods support pagination\n✅ Policy composition works correctly\n✅ Batch operations supported\nPerformance\n✅ < 1ms for event publishing to 10 perspectives\n✅ Parallel perspective execution where safe\n✅ Query optimization via generated SQL\nv0 3 0 - Event Sourcing Success\nFunctionality\n✅ Stateful receptors maintain state correctly\n✅ Event store supports optimistic concurrency\n✅ Projections can rebuild from events\n✅ Snapshots improve load time by 10x\n✅ Version conflicts detected and handled\nPerformance\n✅ < 10ms to load aggregate with 100 events\n✅ < 1ms with snapshot\n✅ < 100ms to rebuild projection with 1000 events\nv0 4",
        "startIndex": 0,
        "preview": "Success Metrics\nOverview\nSuccess is measured across multiple dimensions: technical performance, code quality, developer experience, and adoption Each ..."
      },
      {
        "id": "roadmap/success-metrics-chunk-1",
        "text": "Event store supports optimistic concurrency ✅ Projections can rebuild from events ✅ Snapshots improve load time by 10x ✅ Version conflicts detected and handled Performance ✅ < 10ms to load aggregate with 100 events ✅ < 1ms with snapshot ✅ < 100ms to rebuild projection with 1000 events v0 4 0 - Real Persistence Success\nFunctionality\n✅ All 3 database drivers pass same test suite\n✅ Migrations work across all databases\n✅ Multi-tenancy isolation verified\n✅ Indexes improve query performance by 10x\nPerformance\n✅ < 10ms for single event append\n✅ < 50ms for batch of 100 events\n✅ < 5ms for indexed queries\n✅ Connection pooling reduces latency by 50%\nv0 5",
        "startIndex": 1909,
        "preview": "Event store supports optimistic concurrency ✅ Projections can rebuild from events ✅ Snapshots improve load time by 10x ✅ Version conflicts detected an..."
      },
      {
        "id": "roadmap/success-metrics-chunk-2",
        "text": "test suite ✅ Migrations work across all databases ✅ Multi-tenancy isolation verified ✅ Indexes improve query performance by 10x Performance ✅ < 10ms for single event append ✅ < 50ms for batch of 100 events ✅ < 5ms for indexed queries ✅ Connection pooling reduces latency by 50% v0 5 0 - Distributed Systems Success\nFunctionality\n✅ All transports pass same test suite\n✅ Outbox pattern prevents message loss\n✅ Saga orchestration handles failures\n✅ Distributed tracing works end-to-end\nPerformance\n✅ < 100ms p99 for distributed operations\n✅ Kafka: > 10,000 msg/sec throughput\n✅ RabbitMQ: < 10ms latency\n✅ Saga compensation < 1s\nPerformance Benchmarks\nBaseline Performance Targets\n`csharp\n[Benchmark]\npublic class DispatcherBenchmarks {\n    // Target: < 100ns\n    [Benchmark]\n    public Task DirectHandlerInvocation() { }\n    // Target: < 1μs\n    [Benchmark]\n    public Task DispatchedHandlerInvocation() { }\n    // Target: < 10μs\n    [Benchmark]\n    public Task DispatchWithPolicies() { }\n}\n`\nMemory Allocation Targets\n| Operation | Target Allocation |\n|-----------|------------------|\n| Message Dispatch | 0 bytes |\n| Handler Invocation | 0 bytes |\n| Event Publishing | 0 bytes |\n| Simple Query | < 1KB |\n| Complex Query | < 10KB |\n| Aggregate Load | < Size of Events |\nThroughput Targets\n| Component | Target Throughput |\n|-----------|------------------|\n| In-Memory Dispatcher | > 1M msg/sec |\n| In-Memory Event Store | > 100K events/sec |\n| PostgreSQL Driver | > 10K events/sec |\n| Kafka Transport | > 100K msg/sec |\n| RabbitMQ Transport | > 10K msg/sec |\nLatency Targets (p99)\n| Operation | In-Memory | Database | Distributed |\n|-----------|-----------|----------|-------------|\n| Command Dispatch | < 1ms | < 10ms | < 100ms |\n| Event Publishing | < 1ms | < 10ms | < 100ms |\n| Query Execution | < 1ms | < 5ms | < 50ms |\n| Aggregate Load | < 1ms | < 10ms | N/A |\n| Projection Update | < 1ms | < 10ms | < 100ms |\nCode Quality Metrics\nTest Coverage Requirements\n| Component | Unit Test | Integration Test | Coverage |\n|-----------|-----------|------------------|----------|\n| Core Interfaces | Required | Required | 100% |\n| Source Generators | Required | Required | 100% |\n| Public APIs | Required | Required | 100% |\n| Internal Code | Required | Optional | > 90% |\n| Generated Code | Optional | Required | > 80% |\nDocumentation Requirements\n✅ Every public type has XML documentation\n✅ Every public method has examples\n✅ Every configuration option documented\n✅ Architecture decisions recorded\n✅ Migration guides for version upgrades\nCode Analysis Metrics\n| Metric | Target |\n|--------|--------|\n| Cyclomatic Complexity | < 10 |\n| Maintainability Index | > 80 |\n| Code Coverage | > 95% |\n| Technical Debt Ratio | < 5% |\n| Duplicated Code | < 3% |\nDeveloper Experience Metrics\nIDE Integration\n✅ IntelliSense response < 100ms\n✅ Code fixes available < 500ms\n✅ Navigation works in < 100ms\n✅ Refactoring preserves correctness\n✅ Debugging symbols always available\nError Messages\nQuality criteria for error messages:\nActionable: Tell the developer what to do\nContextual: Include relevant information\nLinkable: Link to documentation\nFixable: Provide code fixes where possible\nExample:\n`\nError WB0001: Handler signature mismatch\n  The handler 'OrderHandler",
        "startIndex": 2270,
        "preview": "test suite ✅ Migrations work across all databases ✅ Multi-tenancy isolation verified ✅ Indexes improve query performance by 10x Performance ✅ < 10ms f..."
      },
      {
        "id": "roadmap/success-metrics-chunk-3",
        "text": "in < 100ms ✅ Refactoring preserves correctness ✅ Debugging symbols always available Error Messages Quality criteria for error messages: Actionable: Tell the developer what to do Contextual: Include relevant information Linkable: Link to documentation Fixable: Provide code fixes where possible Example: ` Error WB0001: Handler signature mismatch The handler 'OrderHandler Handle' has an invalid signature Expected: Task<OrderCreated> Handle(CreateOrder command, IOrderLens lens)\n  Actual: OrderCreated Handle(CreateOrder command)\n  Fix: Add async Task<> return type and IOrderLens parameter\n  Docs: https://whizbang dev/errors/WB0001\n  Quick Fix Available: Press Ctrl+ to apply\n`\nBuild Time Metrics\n| Operation | Target Time |\n|-----------|------------|\n| Clean Build | < 10s |\n| Incremental Build | < 2s |\n| Source Generator | < 1s per 1000 types |\n| Analyzer Execution | < 500ms |\n| Test Execution | < 5s for 1000 tests |\nAdoption Metrics\nCommunity Engagement\nTarget metrics for community health:\nGitHub Stars: > 1,000 in year 1\nContributors: > 50 unique contributors\nIssues Response: < 24 hours\nPR Review: < 48 hours\nDocumentation Traffic: > 10,000 monthly views\nProduction Readiness\nChecklist for production readiness:\n✅ Used in 10+ production applications\n✅ Processing > 1M messages/day in production\n✅ 99 99% uptime achieved\n✅ Security audit passed\n✅ Performance benchmarks published\nPackage Metrics\n| Package | Target Downloads (Year 1) |\n|---------|---------------------------|\n| Whizbang Core | > 100,000 |\n| Whizbang Generators | > 100,000 |\n| Whizbang PostgreSQL | > 50,000 |\n| Whizbang Kafka | > 25,000 |\n| Whizbang",
        "startIndex": 5234,
        "preview": "in < 100ms ✅ Refactoring preserves correctness ✅ Debugging symbols always available Error Messages Quality criteria for error messages: Actionable: Te..."
      },
      {
        "id": "roadmap/success-metrics-chunk-4",
        "text": "achieved ✅ Security audit passed ✅ Performance benchmarks published Package Metrics | Package | Target Downloads (Year 1) | |---------|---------------------------| | Whizbang Core | > 100,000 | | Whizbang Generators | > 100,000 | | Whizbang PostgreSQL | > 50,000 | | Whizbang Kafka | > 25,000 | | Whizbang Testing | > 75,000 |\nContinuous Monitoring\nAutomated Metrics Collection\n`yaml\nCI/CD Pipeline Metrics\non:\n  push:\n    branches: [main]\njobs:\n  metrics:\n    steps:\nname: Performance Benchmarks\n        run: dotnet run -c Release --project benchmarks\nname: Code Coverage\n        run: dotnet test --collect:\"XPlat Code Coverage\"\nname: Static Analysis\n        run: dotnet analyze\nname: API Compatibility\n        run: dotnet apicompat\nname: Package Size\n        run: dotnet pack --measure-size\n`\nDashboard Metrics\nReal-time dashboard tracking:\nBuild success rate\nTest pass rate\nPerformance regression detection\nCode coverage trends\nAPI breaking changes\nPackage download stats\nIssue/PR velocity\nDocumentation coverage\nSuccess Evaluation\nVersion Release Criteria\nA version is ready for release when:\nAll success criteria are met\nNo critical bugs remain\nPerformance targets achieved\nDocumentation complete\nMigration guide written\nBreaking changes documented\nAll tests passing\nSecurity scan clean\nGo/No-Go Decision Matrix\n| Criterion | Weight | v0 1 0 | v0 2 0 | v0 3 0 | v0 4 0 | v0 5 0 |\n|-----------|--------|--------|--------|--------|--------|--------|\n| Functionality | 30% | ✅ | - | - | - | - |\n| Performance | 25% | ✅ | - | - | - | - |\n| Quality | 20% | ✅ | - | - | - | - |\n| Documentation | 15% | ✅ | - | - | - | - |\n| Developer Experience | 10% | ✅ | - | - | - | - |\nRetrospective Questions\nAfter each version:\nWhat succeeded beyond expectations What fell short of targets What surprised us",
        "startIndex": 6494,
        "preview": "achieved ✅ Security audit passed ✅ Performance benchmarks published Package Metrics | Package | Target Downloads (Year 1) | |---------|---------------..."
      },
      {
        "id": "roadmap/success-metrics-chunk-5",
        "text": "- | | Documentation | 15% | ✅ | - | - | - | - | | Developer Experience | 10% | ✅ | - | - | - | - | Retrospective Questions After each version: What succeeded beyond expectations What fell short of targets What surprised us What should we change What should we keep Long-Term Success Metrics\nYear 1 Goals\n5+ production deployments\n1,000+ GitHub stars\n100,000+ NuGet downloads\n0 security vulnerabilities\n< 5% technical debt\nYear 2 Goals\n50+ production deployments\n5,000+ GitHub stars\n1M+ NuGet downloads\nIndustry recognition\nCase studies published\nUltimate Success\nWhizbang becomes the default choice for event-driven and event-sourced systems in NET, known for:\nZero-reflection performance\nExceptional developer experience\nProgressive enhancement model\nProduction reliability\nComprehensive testing support",
        "startIndex": 7987,
        "preview": "- | | Documentation | 15% | ✅ | - | - | - | - | | Developer Experience | 10% | ✅ | - | - | - | - | Retrospective Questions After each version: What su..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.1.0/README",
    "title": "Version 0.1.0 - Foundation Release",
    "category": "Implementation",
    "url": "/docs/v0.1.0/README",
    "chunks": [
      {
        "id": "v0.1.0/README-chunk-0",
        "text": "Version 0 1 0 - Foundation Release\nOverview\nVersion 0 1 0 is the foundation release of Whizbang, establishing a complete skeleton of all major components with in-memory implementations This version prioritizes breadth over depth, ensuring every component exists and works together from day one Release Goals\nPrimary Goals\nComplete Component Set: All 8 core components implemented and working\nZero Reflection: Everything wired via source generators\nIDE Integration: Full developer experience from day one\nTesting Foundation: Comprehensive testing with TUnit and Bogus\nIn-Memory Everything: Fast development and testing cycle\nSuccess Criteria\n✅ All components have basic working implementations\n✅ Source generators discover and wire all handlers\n✅ IDE tools provide navigation and traceability\n✅ Testing framework with scenario generation\n✅ 100% test coverage of public APIs\n✅ < 1ms in-memory operation performance\nWhat's Included\nCore Components\nDispatcher - Message routing and coordination\nReceptors - Command receivers (stateless)\nPerspectives - Event handlers\nLenses - Query interfaces\nPolicy Engine - Cross-cutting concerns\nLedger - Event store interface\nDrivers - Storage abstraction\nTransports - Message broker abstraction\nDeveloper Experience\nSource Generators - Zero-reflection handler discovery\nAnalyzers - Compile-time validation\nIDE Tools - CodeLens-style references\nTraceability - Message flow visualization\nDebugging - Time-travel debugging foundation\nTesting Foundation\nTesting Strategy - Overall testing approach\nTUnit Integration - Modern test framework\nBogus Scenarios - Realistic data generation\nBehavior Specs - BDD-style testing\nTest Doubles - In-memory mocking\nQuick Start\nInstallation\n`bash\ndotnet add package Whizbang Core --version 0 1 0\n`\nBasic Usage\n`csharp\nusing Whizbang;\n// 1 Define a command\npublic record CreateOrder(Guid CustomerId, List<OrderItem> Items);\n// 2 Define a receptor\n[WhizbangHandler]\npublic class OrderReceptor : IReceptor<CreateOrder, OrderCreated> {\n    public async Task<OrderCreated> Receive(CreateOrder cmd) {\n        // Validation and business logic\n        if (cmd Items",
        "startIndex": 0,
        "preview": "Version 0 1 0 - Foundation Release\nOverview\nVersion 0 1 0 is the foundation release of Whizbang, establishing a complete skeleton of all major compone..."
      },
      {
        "id": "v0.1.0/README-chunk-1",
        "text": "Whizbang Core --version 0 1 0 ` Basic Usage `csharp using Whizbang; // 1 Define a command public record CreateOrder(Guid CustomerId, List<OrderItem> Items); // 2 Define a receptor [WhizbangHandler] public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> { public async Task<OrderCreated> Receive(CreateOrder cmd) { // Validation and business logic if (cmd Items Count == 0) {\n            throw new InvalidOperationException(\"Order must have items\");\n        }\n        // Emit event\n        return new OrderCreated(Guid NewGuid(), cmd CustomerId, cmd Items);\n    }\n}\n// 3 Define perspectives\n[WhizbangHandler]\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> {\n    private readonly Dictionary<Guid, Order> _orders = new();\n    public Task Update(OrderCreated e) {\n        _orders[e OrderId] = new Order {\n            Id = e OrderId,\n            CustomerId = e CustomerId,\n            Items = e Items\n        };\n        return Task CompletedTask;\n    }\n}\n// 4 Define a lens\npublic interface IOrderLens : ILens {\n    Order Focus(Guid orderId);\n    IEnumerable<Order> ViewByCustomer(Guid customerId);\n}\n[WhizbangLens]\npublic class OrderLens : IOrderLens {\n    private readonly Dictionary<Guid, Order> _orders;\n    public Order Focus(Guid orderId) => _orders[orderId];\n    public IEnumerable<Order> ViewByCustomer(Guid customerId) =>\n        _orders Values Where(o => o CustomerId == customerId);\n}\n// 5 Configure and use\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbang(options => {\n    options RegisterGeneratedHandlers();  // Source-generated registration\n    options UseInMemory();                // In-memory implementations\n    options EnableTraceability();         // IDE tools and debugging\n});\nvar app = builder Build();\n// 6 Use via dispatcher\napp MapPost(\"/orders\", async (CreateOrder cmd, IDispatcher dispatcher) => {\n    var result = await dispatcher Send(cmd);\n    return Results Ok(result);\n});\napp MapGet(\"/orders/{id}\", (Guid id, IDispatcher dispatcher) => {\n    var lens = dispatcher GetLens<IOrderLens>();\n    var order = lens Focus(id);\n    return Results",
        "startIndex": 2128,
        "preview": "Whizbang Core --version 0 1 0 ` Basic Usage `csharp using Whizbang; // 1 Define a command public record CreateOrder(Guid CustomerId, List<OrderItem> I..."
      },
      {
        "id": "v0.1.0/README-chunk-2",
        "text": "}); var app = builder Build(); // 6 Use via dispatcher app MapPost(\"/orders\", async (CreateOrder cmd, IDispatcher dispatcher) => { var result = await dispatcher Send(cmd); return Results Ok(result); }); app MapGet(\"/orders/{id}\", (Guid id, IDispatcher dispatcher) => { var lens = dispatcher GetLens<IOrderLens>(); var order = lens Focus(id); return Results Ok(order);\n});\n`\nIDE Features\nCodeLens References\n`csharp\n// IDE shows: \"2 handlers | 1 perspective | Last: 50ms ago\"\npublic record OrderCreated(Guid OrderId, Guid CustomerId);  \n// IDE shows: \"Handles: CreateOrder | Publishes: OrderCreated\"\npublic class OrderReceptor : IReceptor<CreateOrder, OrderCreated> { }\n`\nTraceability Overlay\nSee message flow inline in the editor\nVisualize command → receptor → event → perspective chains\nClick to navigate between components\nView execution timings and counts\nAnalyzer Warnings\n`csharp\n// Warning WB0001: Command 'CancelOrder' has no handler\npublic record CancelOrder(Guid OrderId);  // Squiggly line here\n// Quick Fix: Generate handler for CancelOrder (Ctrl+ )\n`\nTesting Example\n`csharp\n[TestClass]\npublic class OrderTests : WhizbangTestBase {\n    [Test]\n    [MethodDataSource(nameof(OrderScenarios))]\n    public async Task CreateOrder_ShouldEmitOrderCreated(OrderScenario scenario) {\n        // Arrange\n        var dispatcher = CreateDispatcher();\n        // Act\n        var result = await dispatcher Send(scenario Command);\n        // Assert\n        await Verify Event<OrderCreated>() WithCustomerId(scenario CustomerId) WasPublished();\n    }\n    public static IEnumerable<OrderScenario> OrderScenarios() {\n        var faker = new OrderScenarioFaker();\n        yield return faker Generate();  // Happy path\n        yield return faker WithNoItems() Generate();  // Error case\n        yield return faker WithManyItems(100)",
        "startIndex": 3883,
        "preview": "}); var app = builder Build(); // 6 Use via dispatcher app MapPost(\"/orders\", async (CreateOrder cmd, IDispatcher dispatcher) => { var result = await ..."
      },
      {
        "id": "v0.1.0/README-chunk-3",
        "text": "dispatcher = CreateDispatcher(); // Act var result = await dispatcher Send(scenario Command); // Assert await Verify Event<OrderCreated>() WithCustomerId(scenario CustomerId) WasPublished(); } public static IEnumerable<OrderScenario> OrderScenarios() { var faker = new OrderScenarioFaker(); yield return faker Generate(); // Happy path yield return faker WithNoItems() Generate(); // Error case yield return faker WithManyItems(100) Generate();  // Stress case\n    }\n}\n`\nPerformance Characteristics\nIn-Memory Performance\n| Operation | Target | Actual |\n|-----------|--------|--------|\n| Message Dispatch | < 1μs | TBD |\n| Handler Invocation | < 100ns | TBD |\n| Event Publishing | < 1μs | TBD |\n| Lens Query | < 1ms | TBD |\n| Policy Application | < 10μs | TBD |\nMemory Allocation\nZero allocations in dispatch hot path\nPooled objects for messages\nMinimal GC pressure\nMigration Path\nTo v0 2 0\nVersion 0 2 0 enhances existing components without breaking changes:\nReceptors gain validation attributes\nPerspectives support batch updates\nLenses add pagination\nPolicies become composable\nSee v0 2 0 Migration Guide\nKnown Limitations\nAs a foundation release, v0 1 0 has intentional limitations:\nIn-Memory Only: No persistent storage yet\nStateless Receptors: No event sourcing support\nBasic Policies: Limited to Retry, Timeout, Cache, CircuitBreaker\nSingle Node: No distributed messaging\nNo Sagas: Long-running processes not supported\nThese limitations are addressed in subsequent versions while maintaining backward compatibility Examples\nComplete Examples\nBasic Receptor - Simple command handling\nPolicy Usage - Applying policies to handlers\nTest Scenario - Testing with Bogus\nComponent Documentation\nCore Components\nDispatcher\nReceptors\nPerspectives\nLenses\nPolicy Engine\nLedger\nDrivers\nTransports\nDeveloper Experience\nSource Generators\nAnalyzers\nIDE Tools\nTraceability\nTesting\nTesting Foundation\nTUnit Integration\nBogus Scenarios\nBehavior Specs\nFeedback\nThis is the foundation release - your feedback shapes the future:\nReport issues: https://github com/whizbang/whizbang/issues\nJoin discussions: https://github com/whizbang/whizbang/discussions\nContribute: See Contributing Guide",
        "startIndex": 5375,
        "preview": "dispatcher = CreateDispatcher(); // Act var result = await dispatcher Send(scenario Command); // Assert await Verify Event<OrderCreated>() WithCustome..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.1.0/_folder",
    "title": "Version 0.1.0 - Foundation",
    "category": "General",
    "url": "/docs/v0.1.0/_folder",
    "chunks": [
      {
        "id": "v0.1.0/_folder-chunk-0",
        "text": "",
        "startIndex": 0,
        "preview": ""
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.1.0/components/README",
    "title": "Core Components Overview",
    "category": "Components",
    "url": "/docs/v0.1.0/components/README",
    "chunks": [
      {
        "id": "v0.1.0/components/README-chunk-0",
        "text": "Core Components Overview\nComponent Architecture\nAll components in Whizbang v0 1 0 work together to provide a complete message-driven architecture Each component has a specific responsibility and clean interface `mermaid\ngraph LR\n    CMD[Command] --> D[Dispatcher]\n    D --> R[Receptor]\n    R --> E[Event]\n    E --> D\n    D --> P[Perspectives]\n    P --> S[(Storage)]\n    Q[Query] --> L[Lens]\n    L --> S\n    POL[Policies] - ->|Wrap| R\n    POL - ->|Wrap| P\n    style CMD fill:#e3f2fd\n    style E fill:#fff3e0\n    style Q fill:#f3e5f5\n`\nComponent Responsibilities\nMessage Flow Components\n| Component | Responsibility | Interface |\n|-----------|---------------|-----------|\n| Dispatcher | Routes all messages | IDispatcher |\n| Receptors | Receive messages, make decisions | IReceptor<T, R> |\n| Perspectives | React to events, update state | IPerspectiveOf<T> |\n| Lenses | Provide read-only queries | ILens |\nInfrastructure Components\n| Component | Responsibility | Interface |\n|-----------|---------------|-----------|\n| Policy Engine | Cross-cutting concerns | IPolicyOf<T> |\n| Ledger | Event storage abstraction | ILedger |\n| Drivers | Database abstraction | IDriver |\n| Transports | Message broker abstraction | ITransport |\nIn-Memory Implementations\nIn v0 1 0, all components have in-memory implementations:\n`csharp\nservices AddWhizbang(options => {\n    options",
        "startIndex": 0,
        "preview": "Core Components Overview\nComponent Architecture\nAll components in Whizbang v0 1 0 work together to provide a complete message-driven architecture Each..."
      },
      {
        "id": "v0.1.0/components/README-chunk-1",
        "text": "Engine | Cross-cutting concerns | IPolicyOf<T> | | Ledger | Event storage abstraction | ILedger | | Drivers | Database abstraction | IDriver | | Transports | Message broker abstraction | ITransport | In-Memory Implementations In v0 1 0, all components have in-memory implementations: `csharp services AddWhizbang(options => { options UseInMemory();  // Configures all in-memory implementations\n});\n`\nThis configures:\nInMemoryDispatcher - Routes messages via dictionary\nInMemoryLedger - Stores events in lists\nInMemoryDriver - Stores data in dictionaries\nInMemoryTransport - Pub/sub via event handlers\nComponent Interaction\nCommand Processing Flow\nCommand submitted to Dispatcher\nDispatcher routes to appropriate Receptor\nReceptor validates and makes decision\nReceptor returns Event(s)\nDispatcher publishes events to Perspectives\nPerspectives update their state\nQuery Processing Flow\nQuery request made\nDispatcher provides appropriate Lens\nLens queries underlying storage\nResults returned to caller\nPolicy Application\nPolicies wrap component execution:\n`csharp\n[Retry(3)]\n[Timeout(5000)]\npublic class PaymentReceptor : IReceptor<ProcessPayment> {\n    // Policies applied automatically via source generation\n}\n`\nComponent Discovery\nAll components are discovered at compile time:\n`csharp\n[WhizbangHandler]  // Source generator finds this\npublic class OrderReceptor : IReceptor<CreateOrder> { }\n[WhizbangHandler]  // And this\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> { }\n[WhizbangLens]  // And this\npublic class OrderLens : IOrderLens { }\n`\nComponent Registration\nSource generators create registration code:\n`csharp\n// Generated code\npublic static class WhizbangGenerated {\n    public static void RegisterHandlers(IServiceCollection services) {\n        services AddScoped<IReceptor<CreateOrder>, OrderReceptor>();\n        services AddScoped<IPerspectiveOf<OrderCreated>, OrderPerspective>();\n        services AddScoped<IOrderLens, OrderLens>();\n        // all discovered components\n    }\n}\n`\nComponent Testing\nAll components are testable via in-memory implementations:\n`csharp\n[Test]\npublic async Task TestOrderFlow() {\n    var dispatcher = new InMemoryDispatcher();\n    var ledger = new InMemoryLedger();\n    // Register components\n    dispatcher Register(new OrderReceptor());\n    dispatcher Register(new OrderPerspective());\n    // Test command flow\n    var result = await dispatcher Send(new CreateOrder( ));\n    // Verify\n    Assert",
        "startIndex": 1364,
        "preview": "Engine | Cross-cutting concerns | IPolicyOf<T> | | Ledger | Event storage abstraction | ILedger | | Drivers | Database abstraction | IDriver | | Trans..."
      },
      {
        "id": "v0.1.0/components/README-chunk-2",
        "text": "Component Testing All components are testable via in-memory implementations: `csharp [Test] public async Task TestOrderFlow() { var dispatcher = new InMemoryDispatcher(); var ledger = new InMemoryLedger(); // Register components dispatcher Register(new OrderReceptor()); dispatcher Register(new OrderPerspective()); // Test command flow var result = await dispatcher Send(new CreateOrder( )); // Verify Assert IsType<OrderCreated>(result);\n}\n`\nComponent Guidelines\nInterface Segregation\nEach component has a focused interface with single responsibility Dependency Injection\nAll components are registered in DI container and resolved automatically Testability\nEvery component can be tested in isolation using in-memory implementations Extensibility\nNew components can be added by implementing the appropriate interface Navigation\nDetailed Documentation\nDispatcher - Message routing\nReceptors - Command handling\nPerspectives - Event handling\nLenses - Queries\nPolicy Engine - Cross-cutting concerns\nLedger - Event storage\nDrivers - Database abstraction\nTransports - Messaging abstraction",
        "startIndex": 3490,
        "preview": "Component Testing All components are testable via in-memory implementations: `csharp [Test] public async Task TestOrderFlow() { var dispatcher = new I..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.1.0/components/dispatcher",
    "title": "Dispatcher Component",
    "category": "Components",
    "url": "/docs/v0.1.0/components/dispatcher",
    "chunks": [
      {
        "id": "v0.1.0/components/dispatcher-chunk-0",
        "text": "Dispatcher Component Version Status Next Update\nVersion History\n:::new\nNew in v0 1 0: Basic message dispatcher with handler discovery and in-process routing\n:::\n:::planned\nComing in v0 2 0: \nPipeline middleware support\nHandler prioritization\nParallel execution\nSee pipeline features →\n:::\n:::planned\nComing in v0 3 0: \nSaga orchestration\nWorkflow support\nCompensation patterns\nSee orchestration features →\n:::\nEvolution Timeline\n`mermaid\ngraph LR\n    v010[v0 1 0<br/>Basic<br/>Routing] --> v020[v0 2 0<br/>Pipeline<br/>Middleware]\n    v020 --> v030[v0 3 0<br/>Saga<br/>Workflows]\n    v030 --> v040[v0 4 0<br/>Streaming<br/>Reactive]\n    v040 --> v050[v0 5 0<br/>Distributed<br/>Orchestration]\n    style v010 fill:#4CAF50,color:#fff\n    style v020 fill:#2196F3,color:#fff\n    style v030 fill:#FF9800,color:#fff\n    style v040 fill:#795548,color:#fff\n    style v050 fill:#9C27B0,color:#fff\n`\nOverview\nThe Dispatcher is the heart of Whizbang - it routes messages to handlers, orchestrates component interactions, and ensures proper execution flow In v0 1 0, it provides basic handler discovery and routing with support for commands, events, and queries What is a Dispatcher A Dispatcher:\nRoutes messages to appropriate handlers\nOrchestrates component interactions\nManages execution flow and dependencies\nCoordinates between receptors, perspectives, and lenses\nThink of the dispatcher as the conductor of an orchestra - it ensures each component plays its part at the right time Core Interface (v0 1 0)\n:::new\nThe fundamental dispatcher interface:\n:::\n`csharp\npublic interface IDispatcher {\n    // Send command to exactly one receptor\n    Task<TResult> Send<TResult>(ICommand<TResult> command);\n    // Publish event to all interested perspectives\n    Task Publish<TEvent>(TEvent @event);\n    // Get lens for queries\n    TLens GetLens<TLens>() where TLens : ILens;\n    // Advanced: Send with context\n    Task<TResult> Send<TResult>(ICommand<TResult> command, IMessageContext context);\n    // Advanced: Batch operations\n    Task<IEnumerable<TResult>> SendMany<TResult>(IEnumerable<ICommand<TResult>> commands);\n}\n`\nIn-Memory Implementation\n`csharp\npublic class InMemoryDispatcher : IDispatcher {\n    private readonly Dictionary<Type, Delegate> _handlers;\n    private readonly Dictionary<Type, List<Delegate>> _eventHandlers;\n    private readonly IServiceProvider _serviceProvider;\n    public InMemoryDispatcher(IServiceProvider serviceProvider) {\n        _serviceProvider = serviceProvider;\n        _handlers = WhizbangGenerated GetCommandHandlers();  // Source-generated\n        _eventHandlers = WhizbangGenerated",
        "startIndex": 0,
        "preview": "Dispatcher Component Version Status Next Update\nVersion History\n:::new\nNew in v0 1 0: Basic message dispatcher with handler discovery and in-process r..."
      },
      {
        "id": "v0.1.0/components/dispatcher-chunk-1",
        "text": "IMessageContext context); // Advanced: Batch operations Task<IEnumerable<TResult>> SendMany<TResult>(IEnumerable<ICommand<TResult>> commands); } ` In-Memory Implementation `csharp public class InMemoryDispatcher : IDispatcher { private readonly Dictionary<Type, Delegate> _handlers; private readonly Dictionary<Type, List<Delegate>> _eventHandlers; private readonly IServiceProvider _serviceProvider; public InMemoryDispatcher(IServiceProvider serviceProvider) { _serviceProvider = serviceProvider; _handlers = WhizbangGenerated GetCommandHandlers(); // Source-generated _eventHandlers = WhizbangGenerated GetEventHandlers();  // Source-generated\n    }\n    public async Task<TResult> Send<TResult>(ICommand<TResult> command) {\n        var commandType = command GetType();\n        if ( _handlers TryGetValue(commandType, out var handler)) {\n            throw new HandlerNotFoundException(commandType);\n        }\n        // Apply policies (generated code handles this)\n        var receptor = _serviceProvider GetRequiredService(handler Method DeclaringType);\n        var result = await handler DynamicInvoke(receptor, command);\n        // If result is an event, publish it\n        if (result is IEvent @event) {\n            await Publish(@event);\n        }\n        return (TResult)result;\n    }\n    public async Task Publish<TEvent>(TEvent @event) {\n        var eventType = @event GetType();\n        if (_eventHandlers TryGetValue(eventType, out var handlers)) {\n            var tasks = handlers Select(async handler => {\n                var perspective = _serviceProvider GetRequiredService(handler Method DeclaringType);\n                await handler DynamicInvoke(perspective, @event);\n            });\n            await Task WhenAll(tasks);\n        }\n    }\n    public TLens GetLens<TLens>() where TLens : ILens {\n        return _serviceProvider GetRequiredService<TLens>();\n    }\n}\n`\nSource-Generated Routing\nThe source generator creates efficient routing tables:\n`csharp\n// Generated by Whizbang Generators\npublic static partial class WhizbangGenerated {\n    public static Dictionary<Type, Delegate> GetCommandHandlers() {\n        return new Dictionary<Type, Delegate> {\n            [typeof(CreateOrder)] = (Func<OrderReceptor, CreateOrder, Task<OrderCreated>>)\n                ((receptor, cmd) => receptor Receive(cmd)),\n            [typeof(CancelOrder)] = (Func<OrderReceptor, CancelOrder, Task<OrderCancelled>>)\n                ((receptor, cmd) => receptor Cancel(cmd)),\n            // all discovered handlers\n        };\n    }\n    public static Dictionary<Type, List<Delegate>> GetEventHandlers() {\n        return new Dictionary<Type, List<Delegate>> {\n            [typeof(OrderCreated)] = new List<Delegate> {\n                (Func<OrderPerspective, OrderCreated, Task>)\n                    ((perspective, e) => perspective Update(e)),\n                (Func<InventoryPerspective, OrderCreated, Task>)\n                    ((perspective, e) => perspective Update(e)),\n            },\n            // all discovered event handlers\n        };\n    }\n}\n`\nMessage Context\nEvery message carries context for traceability:\n`csharp\npublic class MessageContext : IMessageContext {\n    public Guid MessageId { get; init; } = Guid",
        "startIndex": 2616,
        "preview": "IMessageContext context); // Advanced: Batch operations Task<IEnumerable<TResult>> SendMany<TResult>(IEnumerable<ICommand<TResult>> commands); } ` In-..."
      },
      {
        "id": "v0.1.0/components/dispatcher-chunk-2",
        "text": "(Func<OrderPerspective, OrderCreated, Task>) ((perspective, e) => perspective Update(e)), (Func<InventoryPerspective, OrderCreated, Task>) ((perspective, e) => perspective Update(e)), }, // all discovered event handlers }; } } ` Message Context Every message carries context for traceability: `csharp public class MessageContext : IMessageContext { public Guid MessageId { get; init; } = Guid NewGuid();\n    public Guid CorrelationId { get; init; }\n    public Guid CausationId { get; init; }\n    public DateTimeOffset Timestamp { get; init; } = DateTimeOffset UtcNow();\n    public string UserId { get; init; }\n    public Dictionary<string, object> Metadata { get; init; } = new();\n    public ISpan Span { get; init; }  // OpenTelemetry span\n}\n`\nPolicy Application\nThe dispatcher applies policies through generated decorators:\n`csharp\n// Source-generated decorator for policies\npublic class PolicyAwareDispatcher : IDispatcher {\n    private readonly IDispatcher _inner;\n    private readonly IPolicyEngine _policies;\n    public async Task<TResult> Send<TResult>(ICommand<TResult> command) {\n        // Get policies for this command type (compile-time determined)\n        var policies = WhizbangGenerated GetPoliciesFor(command GetType());\n        // Apply policies in order\n        return await _policies Execute(policies, async () => {\n            return await _inner Send(command);\n        });\n    }\n}\n`\nTraceability Integration\nThe dispatcher provides hooks for traceability:\n`csharp\npublic class TraceableDispatcher : IDispatcher {\n    private readonly IDispatcher _inner;\n    private readonly ITraceabilityService _traceability;\n    public async Task<TResult> Send<TResult>(ICommand<TResult> command) {\n        var span = _traceability StartSpan($\"Send {command GetType() Name}\");\n        try {\n            var result = await _inner Send(command);\n            _traceability RecordSuccess(span, command, result);\n            // Update IDE overlay\n            _traceability UpdateOverlay(command GetType(), result GetType());\n            return result;\n        }\n        catch (Exception ex) {\n            _traceability RecordError(span, command, ex);\n            throw;\n        }\n        finally {\n            span End();\n        }\n    }\n}\n`\nError Handling\nThe dispatcher provides comprehensive error information:\n`csharp\npublic class HandlerNotFoundException : Exception {\n    public Type CommandType { get; }\n    public HandlerNotFoundException(Type commandType) \n        : base(FormatMessage(commandType)) {\n        CommandType = commandType;\n    }\n    private static string FormatMessage(Type commandType) {\n        return $@\"\nNo handler found for command '{commandType Name}'",
        "startIndex": 5239,
        "preview": "(Func<OrderPerspective, OrderCreated, Task>) ((perspective, e) => perspective Update(e)), (Func<InventoryPerspective, OrderCreated, Task>) ((perspecti..."
      },
      {
        "id": "v0.1.0/components/dispatcher-chunk-3",
        "text": "} } } ` Error Handling The dispatcher provides comprehensive error information: `csharp public class HandlerNotFoundException : Exception { public Type CommandType { get; } public HandlerNotFoundException(Type commandType) : base(FormatMessage(commandType)) { CommandType = commandType; } private static string FormatMessage(Type commandType) { return $@\" No handler found for command '{commandType Name}' To fix this:\nCreate a receptor that implements IReceptor<{commandType Name}>\nAdd the [WhizbangHandler] attribute to the receptor\nEnsure the receptor is in a scanned assembly\nExample:\n[WhizbangHandler]\npublic class {commandType Name Replace(\"Command\", \"\")}Receptor : IReceptor<{commandType Name}, {commandType Name Replace(\"Command\", \"\")}Result> {{\n    public async Task<{commandType Name Replace(\"Command\", \"\")}Result> Receive({commandType Name} command) {{\n        // Handle command\n    }}\n}}\nQuick Fix: Press Ctrl+ to generate the handler automatically \";\n    }\n}\n`\nConfiguration\n`csharp\npublic class DispatcherOptions {\n    /// <summary>\n    /// Maximum time to wait for a handler (milliseconds)\n    /// </summary>\n    public int DefaultTimeout { get; set; } = 30000;\n    /// <summary>\n    /// Enable parallel event publishing\n    /// </summary>\n    public bool ParallelEventPublishing { get; set; } = true;\n    /// <summary>\n    /// Maximum degree of parallelism for events\n    /// </summary>\n    public int MaxEventParallelism { get; set; } = 10;\n    /// <summary>\n    /// Enable traceability hooks\n    /// </summary>\n    public bool EnableTraceability { get; set; } = true;\n    /// <summary>\n    /// Record performance metrics\n    /// </summary>\n    public bool EnableMetrics { get; set; } = true;\n}\n`\nTesting\n`csharp\n[Test]\npublic class DispatcherTests {\n    private IDispatcher _dispatcher;\n    [SetUp]\n    public void Setup() {\n        var services = new ServiceCollection();\n        services AddWhizbang(o => o UseInMemory());\n        var provider = services BuildServiceProvider();\n        _dispatcher = provider GetRequiredService<IDispatcher>();\n    }\n    [Test]\n    public async Task Send_Command_Should_Return_Result() {\n        // Arrange\n        var command = new CreateOrder(\n            CustomerId: Guid NewGuid(),\n            Items: new[] { new OrderItem(\"SKU-001\", 2, 29 99m) }\n        );\n        // Act\n        var result = await _dispatcher Send(command);\n        // Assert\n        Assert IsType<OrderCreated>(result);\n        Assert NotEqual(Guid Empty, result",
        "startIndex": 7532,
        "preview": "} } } ` Error Handling The dispatcher provides comprehensive error information: `csharp public class HandlerNotFoundException : Exception { public Typ..."
      },
      {
        "id": "v0.1.0/components/dispatcher-chunk-4",
        "text": "= services BuildServiceProvider(); _dispatcher = provider GetRequiredService<IDispatcher>(); } [Test] public async Task Send_Command_Should_Return_Result() { // Arrange var command = new CreateOrder( CustomerId: Guid NewGuid(), Items: new[] { new OrderItem(\"SKU-001\", 2, 29 99m) } ); // Act var result = await _dispatcher Send(command); // Assert Assert IsType<OrderCreated>(result); Assert NotEqual(Guid Empty, result OrderId);\n    }\n    [Test]\n    public async Task Publish_Event_Should_Notify_All_Perspectives() {\n        // Arrange\n        var @event = new OrderCreated(Guid NewGuid(), Guid NewGuid());\n        var notificationCount = 0;\n        // Subscribe to notifications\n        _dispatcher Subscribe<OrderCreated>(e => {\n            notificationCount++;\n            return Task CompletedTask;\n        });\n        // Act\n        await _dispatcher Publish(@event);\n        // Assert\n        Assert Greater(notificationCount, 0);\n    }\n}\n`\nPerformance Characteristics\n| Operation | Target | Actual (v0 1 0) |\n|-----------|--------|-----------------|\n| Command Routing | < 100ns | TBD |\n| Event Publishing (1 handler) | < 1μs | TBD |\n| Event Publishing (10 handlers) | < 10μs | TBD |\n| Context Creation | < 50ns | TBD |\n| Policy Application | < 1μs per policy | TBD |\nIDE Integration\nThe dispatcher provides real-time information to the IDE:\n`csharp\n// IDE shows: \"5 commands routed | 23 events published | Last: 2ms ago\"\npublic interface IDispatcher { }\n// IDE shows: \"Routed 15 times | Avg: 1 2ms | Last: CreateOrder\"\npublic async Task<TResult> Send<TResult>(ICommand<TResult> command);\n`\nLimitations in v0 1 0\n:::info\nThese limitations are addressed in future versions:\n:::\nNo middleware - Cannot inject cross-cutting concerns\nSequential execution - Perspectives run one at a time\nNo saga support - Cannot coordinate multi-step workflows\nNo retry logic - Failed operations aren't retried\nSingle instance - No distributed coordination\nMigration Path\nTo v0 2 0 (Pipeline & Middleware)\n:::planned\nv0 2 0 adds pipeline processing:\n:::\n`csharp\n// v0 2 0 - Middleware pipeline\nservices AddWhizbangDispatcher(dispatcher => {\n    dispatcher AddMiddleware<LoggingMiddleware>();\n    dispatcher AddMiddleware<ValidationMiddleware>();\n    dispatcher",
        "startIndex": 9619,
        "preview": "= services BuildServiceProvider(); _dispatcher = provider GetRequiredService<IDispatcher>(); } [Test] public async Task Send_Command_Should_Return_Res..."
      },
      {
        "id": "v0.1.0/components/dispatcher-chunk-5",
        "text": "multi-step workflows No retry logic - Failed operations aren't retried Single instance - No distributed coordination Migration Path To v0 2 0 (Pipeline & Middleware) :::planned v0 2 0 adds pipeline processing: ::: `csharp // v0 2 0 - Middleware pipeline services AddWhizbangDispatcher(dispatcher => { dispatcher AddMiddleware<LoggingMiddleware>(); dispatcher AddMiddleware<ValidationMiddleware>(); dispatcher AddMiddleware<MetricsMiddleware>();\n});\n`\nTo v0 3 0 (Saga Orchestration)\n:::planned\nv0 3 0 adds workflow support:\n:::\n`csharp\n// v0 3 0 - Saga orchestration\npublic class OrderSaga : ISaga<CreateOrder> {\n    public async Task<SagaResult> Execute(CreateOrder command) {\n        // Multi-step workflow with compensation\n    }\n}\n`\nBest Practices\nKeep dispatcher thin - Logic belongs in handlers, not dispatcher\nHandle errors gracefully - Don't let one perspective failure break all\nUse dependency injection - Let DI container manage lifetimes\nMonitor performance - Track dispatch times and success rates\nTest handler discovery - Ensure all handlers are registered\nDesign for async - All operations should be async\nRelated Documentation\nReceptors - Command handlers\nPerspectives - Event handlers\nLenses - Query handlers\nLedger - Event storage\nFeature Evolution - How dispatcher evolves\nNext Steps\nSee v0 2 0 Pipeline for middleware support\nSee v0 3 0 Orchestration for saga patterns\nReview Examples for usage patterns",
        "startIndex": 11447,
        "preview": "multi-step workflows No retry logic - Failed operations aren't retried Single instance - No distributed coordination Migration Path To v0 2 0 (Pipelin..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.1.0/components/drivers",
    "title": "Drivers Component",
    "category": "Components",
    "url": "/docs/v0.1.0/components/drivers",
    "chunks": [
      {
        "id": "v0.1.0/components/drivers-chunk-0",
        "text": "Drivers Component Version Status Next Update\nVersion History\n:::new\nNew in v0 1 0: Basic in-memory driver with simple key-value storage abstraction\n:::\n:::planned\nComing in v0 2 0: \nFile-based driver for persistence\nJSON serialization support\nBasic indexing capabilities\nSee file storage features →\n:::\n:::planned\nComing in v0 4 0: \nSQL database drivers (PostgreSQL, SQL Server)\nNoSQL drivers (MongoDB, Redis)\nJSONB support for flexible schemas\nSee database features →\n:::\nEvolution Timeline\n`mermaid\ngraph LR\n    v010[v0 1 0<br/>In-Memory<br/>Key-Value] --> v020[v0 2 0<br/>File<br/>JSON]\n    v020 --> v030[v0 3 0<br/>Embedded<br/>SQLite]\n    v030 --> v040[v0 4 0<br/>Database<br/>SQL/NoSQL]\n    v040 --> v050[v0 5 0<br/>Distributed<br/>Multi-Model]\n    style v010 fill:#4CAF50,color:#fff\n    style v020 fill:#2196F3,color:#fff\n    style v030 fill:#FF9800,color:#fff\n    style v040 fill:#795548,color:#fff\n    style v050 fill:#9C27B0,color:#fff\n`\nOverview\nDrivers provide the storage abstraction layer in Whizbang, allowing the framework to work with different storage backends without changing application code In v0 1 0, we provide a simple in-memory driver perfect for development, testing, and prototyping What is a Driver A Driver:\nAbstracts storage implementation details\nProvides a consistent interface for data operations\nHandles serialization and deserialization\nManages connections and resources\nThink of drivers as adapters that allow Whizbang to speak different storage \"languages\" while maintaining a consistent programming model Core Interface (v0 1 0)\n:::new\nThe basic driver interface for storage operations:\n:::\n`csharp\npublic interface IDriver {\n    // Basic CRUD operations\n    Task<T",
        "startIndex": 0,
        "preview": "Drivers Component Version Status Next Update\nVersion History\n:::new\nNew in v0 1 0: Basic in-memory driver with simple key-value storage abstraction\n::..."
      },
      {
        "id": "v0.1.0/components/drivers-chunk-1",
        "text": "serialization and deserialization Manages connections and resources Think of drivers as adapters that allow Whizbang to speak different storage \"languages\" while maintaining a consistent programming model Core Interface (v0 1 0) :::new The basic driver interface for storage operations: ::: `csharp public interface IDriver { // Basic CRUD operations Task<T > Get<T>(string key) where T : class;\n    Task Set<T>(string key, T value) where T : class;\n    Task<bool> Delete(string key);\n    Task<bool> Exists(string key);\n    // Collection operations\n    Task<IEnumerable<T>> GetAll<T>(string prefix = \"\") where T : class;\n    Task Clear(string prefix = \"\");\n    // Driver metadata\n    string Name { get; }\n    DriverCapabilities Capabilities { get; }\n}\npublic enum DriverCapabilities {\n    None = 0,\n    Persistence = 1,\n    Transactions = 2,\n    Queries = 4,\n    Indexing = 8,\n    Streaming = 16\n}\n`\nIn-Memory Driver\n:::new\nThe default in-memory driver for v0 1 0:\n:::\n`csharp\n[WhizbangDriver(\"InMemory\")]\npublic class InMemoryDriver : IDriver {\n    private readonly ConcurrentDictionary<string, object> _store = new();\n    private readonly ReaderWriterLockSlim _lock = new();\n    public string Name => \"InMemory\";\n    public DriverCapabilities Capabilities => DriverCapabilities None;\n    public Task<T > Get<T>(string key) where T : class {\n        _lock EnterReadLock();\n        try {\n            if (_store TryGetValue(key, out var value)) {\n                return Task FromResult(value as T);\n            }\n            return Task FromResult<T >(null);\n        }\n        finally {\n            _lock ExitReadLock();\n        }\n    }\n    public Task Set<T>(string key, T value) where T : class {\n        _lock EnterWriteLock();\n        try {\n            _store[key] = value;\n            return Task CompletedTask;\n        }\n        finally {\n            _lock ExitWriteLock();\n        }\n    }\n    public Task<bool> Delete(string key) {\n        _lock EnterWriteLock();\n        try {\n            return Task FromResult(_store TryRemove(key, out _));\n        }\n        finally {\n            _lock ExitWriteLock();\n        }\n    }\n    public Task<bool> Exists(string key) {\n        _lock EnterReadLock();\n        try {\n            return Task FromResult(_store ContainsKey(key));\n        }\n        finally {\n            _lock ExitReadLock();\n        }\n    }\n    public Task<IEnumerable<T>> GetAll<T>(string prefix = \"\") where T : class {\n        _lock EnterReadLock();\n        try {\n            var results = _store",
        "startIndex": 1712,
        "preview": "serialization and deserialization Manages connections and resources Think of drivers as adapters that allow Whizbang to speak different storage \"langu..."
      },
      {
        "id": "v0.1.0/components/drivers-chunk-2",
        "text": "FromResult(_store TryRemove(key, out _)); } finally { _lock ExitWriteLock(); } } public Task<bool> Exists(string key) { _lock EnterReadLock(); try { return Task FromResult(_store ContainsKey(key)); } finally { _lock ExitReadLock(); } } public Task<IEnumerable<T>> GetAll<T>(string prefix = \"\") where T : class { _lock EnterReadLock(); try { var results = _store Where(kvp => string IsNullOrEmpty(prefix) || kvp Key StartsWith(prefix)) Select(kvp => kvp Value) OfType<T>();\n            return Task FromResult<IEnumerable<T>>(results ToList());\n        }\n        finally {\n            _lock ExitReadLock();\n        }\n    }\n    public Task Clear(string prefix = \"\") {\n        _lock EnterWriteLock();\n        try {\n            if (string IsNullOrEmpty(prefix)) {\n                _store Clear();\n            } else {\n                var keysToRemove = _store Keys Where(k => k StartsWith(prefix)) ToList();\n                foreach (var key in keysToRemove) {\n                    _store TryRemove(key, out _);\n                }\n            }\n            return Task CompletedTask;\n        }\n        finally {\n            _lock ExitWriteLock();\n        }\n    }\n}\n`\nDriver Registration\nDrivers are registered at startup and discovered by source generators:\n`csharp\n// Manual registration\nservices AddWhizbangDrivers(options => {\n    options UseInMemory();\n});\n// Or with configuration\nservices AddWhizbangDrivers(options => {\n    options UseDriver<InMemoryDriver>(\"default\");\n    options UseDriver<InMemoryDriver>(\"cache\");\n});\n// Source generated registration\npublic static partial class WhizbangGenerated {\n    public static void RegisterDrivers(IServiceCollection services) {\n        services AddSingleton<IDriver, InMemoryDriver>();\n    }\n}\n`\nStore Abstraction\n:::new\nHigher-level store abstraction built on drivers:\n:::\n`csharp\npublic interface IStore<T> where T : class {\n    Task<T > GetById(string id);\n    Task Save(string id, T entity);\n    Task Delete(string id);\n    Task<IEnumerable<T>> GetAll();\n}\npublic class DriverStore<T> : IStore<T> where T : class {\n    private readonly IDriver _driver;\n    private readonly string _prefix;\n    public DriverStore(IDriver driver) {\n        _driver = driver;\n        _prefix = $\"{typeof(T) Name}:\";\n    }\n    public Task<T > GetById(string id) {\n        return _driver Get<T>($\"{_prefix}{id}\");\n    }\n    public Task Save(string id, T entity) {\n        return _driver Set($\"{_prefix}{id}\", entity);\n    }\n    public Task Delete(string id) {\n        return _driver Delete($\"{_prefix}{id}\");\n    }\n    public Task<IEnumerable<T>> GetAll() {\n        return _driver",
        "startIndex": 3885,
        "preview": "FromResult(_store TryRemove(key, out _)); } finally { _lock ExitWriteLock(); } } public Task<bool> Exists(string key) { _lock EnterReadLock(); try { r..."
      },
      {
        "id": "v0.1.0/components/drivers-chunk-3",
        "text": "_prefix; public DriverStore(IDriver driver) { _driver = driver; _prefix = $\"{typeof(T) Name}:\"; } public Task<T > GetById(string id) { return _driver Get<T>($\"{_prefix}{id}\"); } public Task Save(string id, T entity) { return _driver Set($\"{_prefix}{id}\", entity); } public Task Delete(string id) { return _driver Delete($\"{_prefix}{id}\"); } public Task<IEnumerable<T>> GetAll() { return _driver GetAll<T>(_prefix);\n    }\n}\n`\nUsing Drivers in Components\nIn Perspectives\n`csharp\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> {\n    private readonly IStore<Order> _orderStore;\n    public OrderPerspective(IDriver driver) {\n        _orderStore = new DriverStore<Order>(driver);\n    }\n    public async Task Update(OrderCreated @event) {\n        var order = new Order {\n            Id = @event OrderId,\n            CustomerId = @event CustomerId,\n            Items = @event Items,\n            Total = @event Total,\n            Status = OrderStatus Created\n        };\n        await _orderStore Save(@event OrderId ToString(), order);\n    }\n}\n`\nIn Lenses\n`csharp\npublic class OrderLens : IOrderLens {\n    private readonly IStore<Order> _orderStore;\n    public OrderLens(IDriver driver) {\n        _orderStore = new DriverStore<Order>(driver);\n    }\n    public async Task<Order> Focus(Guid orderId) {\n        return await _orderStore GetById(orderId ToString());\n    }\n    public async Task<IEnumerable<Order>> ViewAll() {\n        return await _orderStore GetAll();\n    }\n}\n`\nTesting with Drivers\n`csharp\n[Test]\npublic class DriverTests {\n    private InMemoryDriver _driver;\n    [SetUp]\n    public void Setup() {\n        _driver = new InMemoryDriver();\n    }\n    [Test]\n    public async Task SetAndGet_ShouldStoreAndRetrieve() {\n        // Arrange\n        var testObject = new TestEntity { \n            Id = \"test-1\", \n            Name = \"Test Entity\" \n        };\n        // Act\n        await _driver Set(\"test-1\", testObject);\n        var retrieved = await _driver Get<TestEntity>(\"test-1\");\n        // Assert\n        Assert NotNull(retrieved);\n        Assert Equal(\"Test Entity\", retrieved Name);\n    }\n    [Test]\n    public async Task GetAll_WithPrefix_ShouldFilterResults() {\n        // Arrange\n        await _driver Set(\"order:1\", new Order { Id = Guid NewGuid() });\n        await _driver Set(\"order:2\", new Order { Id = Guid NewGuid() });\n        await _driver Set(\"customer:1\", new Customer { Id = Guid NewGuid() });\n        // Act\n        var orders = await _driver GetAll<Order>(\"order:\");\n        // Assert\n        Assert Equal(2, orders Count());\n    }\n    [Test]\n    public async Task Clear_WithPrefix_ShouldOnlyRemoveMatching() {\n        // Arrange\n        await _driver",
        "startIndex": 6206,
        "preview": "_prefix; public DriverStore(IDriver driver) { _driver = driver; _prefix = $\"{typeof(T) Name}:\"; } public Task<T > GetById(string id) { return _driver ..."
      },
      {
        "id": "v0.1.0/components/drivers-chunk-4",
        "text": "Guid NewGuid() }); await _driver Set(\"order:2\", new Order { Id = Guid NewGuid() }); await _driver Set(\"customer:1\", new Customer { Id = Guid NewGuid() }); // Act var orders = await _driver GetAll<Order>(\"order:\"); // Assert Assert Equal(2, orders Count()); } [Test] public async Task Clear_WithPrefix_ShouldOnlyRemoveMatching() { // Arrange await _driver Set(\"temp:1\", new object());\n        await _driver Set(\"temp:2\", new object());\n        await _driver Set(\"keep:1\", new object());\n        // Act\n        await _driver Clear(\"temp:\");\n        // Assert\n        Assert False(await _driver Exists(\"temp:1\"));\n        Assert False(await _driver Exists(\"temp:2\"));\n        Assert True(await _driver Exists(\"keep:1\"));\n    }\n}\n`\nDriver Selection Strategy\n`csharp\npublic interface IDriverSelector {\n    IDriver GetDriver(string name);\n    IDriver GetDriverForType<T>();\n}\npublic class DriverSelector : IDriverSelector {\n    private readonly Dictionary<string, IDriver> _drivers;\n    public IDriver GetDriver(string name) {\n        return _drivers TryGetValue(name, out var driver) driver \n            : _drivers[\"default\"];\n    }\n    public IDriver GetDriverForType<T>() {\n        // Can implement type-based routing\n        var typeName = typeof(T) Name;\n        return typeName switch {\n            \"Order\" or \"Customer\" => GetDriver(\"primary\"),\n            \"Cache\" or \"Session\" => GetDriver(\"cache\"),\n            _ => GetDriver(\"default\")\n        };\n    }\n}\n`\nIDE Features\n`csharp\n// IDE shows: \"Driver: InMemory | Objects: 234 | Memory: 5 2MB\"\npublic interface IDriver { }\n// IDE shows: \"Called 45 times | Avg: 0 1ms | Hit rate: 92%\"\npublic Task<T > Get<T>(string key) { }\n// IDE shows: \"Warning: No persistence - data lost on restart\"\npublic class InMemoryDriver : IDriver { }\n`\nPerformance Characteristics\n| Operation | Target | Actual |\n|-----------|--------|--------|\n| Get | < 100ns | TBD |\n| Set | < 500ns | TBD |\n| Delete | < 200ns | TBD |\n| GetAll (1000 items) | < 1ms | TBD |\n| Clear | < 100μs | TBD |\nLimitations in v0 1",
        "startIndex": 8499,
        "preview": "Guid NewGuid() }); await _driver Set(\"order:2\", new Order { Id = Guid NewGuid() }); await _driver Set(\"customer:1\", new Customer { Id = Guid NewGuid()..."
      },
      {
        "id": "v0.1.0/components/drivers-chunk-5",
        "text": "| Actual | |-----------|--------|--------| | Get | < 100ns | TBD | | Set | < 500ns | TBD | | Delete | < 200ns | TBD | | GetAll (1000 items) | < 1ms | TBD | | Clear | < 100μs | TBD | Limitations in v0 1 0\n:::info\nThese limitations are addressed in future versions:\n:::\nNo persistence - Data lost on restart\nNo queries - Only key-based lookups\nNo transactions - No atomicity guarantees\nNo indexing - Linear scans for GetAll\nMemory only - Limited by available RAM\nMigration Path\nTo v0 2 0 (File Storage)\n:::planned\nv0 2 0 adds persistent file storage:\n:::\n`csharp\n// v0 2 0 - File-based driver\nservices AddWhizbangDrivers(options => {\n    options UseFileDriver(file => {\n        file DataDirectory = \" /data\";\n        file Format = SerializationFormat Json;\n        file Compression = true;\n    });\n});\n`\nTo v0 4 0 (Database Drivers)\n:::planned\nv0 4 0 adds real database support:\n:::\n`csharp\n// v0 4 0 - SQL and NoSQL drivers\nservices AddWhizbangDrivers(options => {\n    options UsePostgreSQL(\"Host=localhost;Database=whizbang\");\n    options UseMongoDB(\"mongodb://localhost:27017/whizbang\");\n    options UseRedis(\"localhost:6379\");\n});\n`\nBest Practices\nUse abstractions - Depend on IDriver, not concrete implementations\nPlan for persistence - Design assuming data will persist\nUse prefixes - Organize keys with consistent prefixes\nHandle nulls - Always check for null returns from Get\nTest with different drivers - Ensure code works with any driver\nConsider capabilities - Check driver capabilities before using features\nRelated Documentation\nPerspectives - Using drivers for write models\nLenses - Using drivers for read models\nTesting - Testing with in-memory driver\nFeature Evolution - How drivers evolve\nNext Steps\nSee v0 2 0 File Storage for persistence\nSee v0 4 0 Databases for SQL/NoSQL support\nReview Examples for driver patterns",
        "startIndex": 10192,
        "preview": "| Actual | |-----------|--------|--------| | Get | < 100ns | TBD | | Set | < 500ns | TBD | | Delete | < 200ns | TBD | | GetAll (1000 items) | < 1ms | ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.1.0/components/ledger",
    "title": "Ledger Component",
    "category": "Components",
    "url": "/docs/v0.1.0/components/ledger",
    "chunks": [
      {
        "id": "v0.1.0/components/ledger-chunk-0",
        "text": "Ledger Component Version Status Next Update\nVersion History\n:::new\nNew in v0 1 0: Basic in-memory event store with append-only semantics\n:::\n:::planned\nComing in v0 2 0: \nPersistent file-based storage\nEvent streams and versioning\nBasic snapshots\nSee persistence features →\n:::\n:::planned\nComing in v0 3 0: \nFull event sourcing with projections\nTime-travel queries\nEvent replay\nSee event sourcing features →\n:::\nEvolution Timeline\n`mermaid\ngraph LR\n    v010[v0 1 0<br/>In-Memory<br/>Append-Only] --> v020[v0 2 0<br/>File<br/>Persistent]\n    v020 --> v030[v0 3 0<br/>Event<br/>Sourcing]\n    v030 --> v040[v0 4 0<br/>SQL<br/>JSONB]\n    v040 --> v050[v0 5 0<br/>Distributed<br/>Multi-Region]\n    style v010 fill:#4CAF50,color:#fff\n    style v020 fill:#2196F3,color:#fff\n    style v030 fill:#FF9800,color:#fff\n    style v040 fill:#795548,color:#fff\n    style v050 fill:#9C27B0,color:#fff\n`\nOverview\nThe Ledger is Whizbang's append-only event store, providing an immutable audit trail of all events in your system In v0 1 0, it's a simple in-memory store that captures events and allows basic retrieval This foundation will evolve into a full event sourcing system What is a Ledger A Ledger:\nStores events in append-only fashion\nPreserves the complete history of state changes\nProvides an immutable audit trail\nEnables event replay and debugging\nThink of the ledger as your system's permanent memory - every significant action is recorded and can never be altered or deleted Core Interface (v0 1 0)\n:::new\nThe basic ledger interface for event storage:\n:::\n`csharp\npublic interface ILedger {\n    // Append an event to the ledger\n    Task<long> Append(IEvent @event);\n    // Read events from the ledger\n    IEnumerable<IEvent> Read(long fromPosition = 0);\n    // Read events of a specific type\n    IEnumerable<T> Read<T>(long fromPosition = 0) where T : IEvent;\n    // Get the current position (last event number)\n    long GetPosition();\n}\n`\nBasic Implementation\n:::new\nIn v0 1",
        "startIndex": 0,
        "preview": "Ledger Component Version Status Next Update\nVersion History\n:::new\nNew in v0 1 0: Basic in-memory event store with append-only semantics\n:::\n:::planne..."
      },
      {
        "id": "v0.1.0/components/ledger-chunk-1",
        "text": "the ledger Task<long> Append(IEvent @event); // Read events from the ledger IEnumerable<IEvent> Read(long fromPosition = 0); // Read events of a specific type IEnumerable<T> Read<T>(long fromPosition = 0) where T : IEvent; // Get the current position (last event number) long GetPosition(); } ` Basic Implementation :::new In v0 1 0, the ledger uses in-memory storage:\n:::\n`csharp\n[WhizbangLedger]\npublic class InMemoryLedger : ILedger {\n    private readonly List<StoredEvent> _events = new();\n    private readonly object _lock = new();\n    private long _position = 0;\n    public Task<long> Append(IEvent @event) {\n        lock (_lock) {\n            var position = ++_position;\n            _events Add(new StoredEvent {\n                Position = position,\n                EventType = @event GetType() Name,\n                Event = @event,\n                Timestamp = DateTimeOffset UtcNow\n            });\n            return Task FromResult(position);\n        }\n    }\n    public IEnumerable<IEvent> Read(long fromPosition = 0) {\n        lock (_lock) {\n            return _events Where(e => e Position > fromPosition) Select(e => e Event);\n        }\n    }\n    public IEnumerable<T> Read<T>(long fromPosition = 0) where T : IEvent {\n        return Read(fromPosition) OfType<T>();\n    }\n    public long GetPosition() {\n        lock (_lock) {\n            return _position;\n        }\n    }\n}\n`\nEvent Storage\nEvent Structure\n`csharp\npublic interface IEvent {\n    Guid Id { get; }\n    DateTimeOffset Timestamp { get; }\n    string AggregateId { get; }\n    int Version { get; }\n}\n// Stored event wrapper\ninternal class StoredEvent {\n    public long Position { get; set; }\n    public string EventType { get; set; }\n    public IEvent Event { get; set; }\n    public DateTimeOffset Timestamp { get; set; }\n}\n`\nAppending Events\n:::new\nEvents are automatically appended by the dispatcher:\n:::\n`csharp\n// Events flow from receptors through dispatcher to ledger\npublic class OrderReceptor : IReceptor<CreateOrder> {\n    public OrderCreated Receive(CreateOrder cmd) {\n        return new OrderCreated {\n            Id = Guid NewGuid(),\n            Timestamp = DateTimeOffset UtcNow,\n            AggregateId = cmd OrderId ToString(),\n            Version = 1,\n            CustomerId = cmd CustomerId,\n            Items = cmd",
        "startIndex": 1978,
        "preview": "the ledger Task<long> Append(IEvent @event); // Read events from the ledger IEnumerable<IEvent> Read(long fromPosition = 0); // Read events of a speci..."
      },
      {
        "id": "v0.1.0/components/ledger-chunk-2",
        "text": "dispatcher: ::: `csharp // Events flow from receptors through dispatcher to ledger public class OrderReceptor : IReceptor<CreateOrder> { public OrderCreated Receive(CreateOrder cmd) { return new OrderCreated { Id = Guid NewGuid(), Timestamp = DateTimeOffset UtcNow, AggregateId = cmd OrderId ToString(), Version = 1, CustomerId = cmd CustomerId, Items = cmd Items,\n            Total = cmd Total\n        };\n        // Event automatically appended to ledger by dispatcher\n    }\n}\n`\nReading Events\n:::new\nBasic event retrieval in v0 1 0:\n:::\n`csharp\npublic class EventReader {\n    private readonly ILedger _ledger;\n    // Read all events\n    public void ReadAllEvents() {\n        var events = _ledger Read();\n        foreach (var @event in events) {\n            Console WriteLine($\"{@event Timestamp}: {@event GetType() Name}\");\n        }\n    }\n    // Read specific event types\n    public void ReadOrderEvents() {\n        var orderEvents = _ledger Read<OrderCreated>();\n        foreach (var order in orderEvents) {\n            Console WriteLine($\"Order {order AggregateId}: {order Total}\");\n        }\n    }\n    // Read from checkpoint\n    public void ReadNewEvents(long lastPosition) {\n        var newEvents = _ledger Read(fromPosition: lastPosition);\n        foreach (var @event in newEvents) {\n            ProcessEvent(@event);\n        }\n    }\n}\n`\nIntegration with Dispatcher\nThe ledger is automatically integrated with the dispatcher:\n`csharp\n// Source generated registration\npublic static partial class WhizbangGenerated {\n    public static void RegisterLedger(IServiceCollection services) {\n        services AddSingleton<ILedger, InMemoryLedger>();\n    }\n}\n// Dispatcher automatically appends events\npublic class Dispatcher : IDispatcher {\n    private readonly ILedger _ledger;\n    public async Task<TResult> Dispatch<TCommand, TResult>(TCommand command) \n        where TResult : IEvent {\n        // Execute receptor\n        var result = await ExecuteReceptor(command);\n        // Append to ledger\n        await _ledger Append(result);\n        // Update perspectives\n        await UpdatePerspectives(result);\n        return result;\n    }\n}\n`\nDebugging with the Ledger\n:::new\nThe ledger enables powerful debugging capabilities:\n:::\n`csharp\npublic class LedgerDebugger {\n    private readonly ILedger _ledger;\n    // Show event timeline\n    public void ShowTimeline(DateTime from, DateTime to) {\n        var events = _ledger Read() Where(e => e Timestamp >= from && e Timestamp <= to)",
        "startIndex": 3985,
        "preview": "dispatcher: ::: `csharp // Events flow from receptors through dispatcher to ledger public class OrderReceptor : IReceptor<CreateOrder> { public OrderC..."
      },
      {
        "id": "v0.1.0/components/ledger-chunk-3",
        "text": "} ` Debugging with the Ledger :::new The ledger enables powerful debugging capabilities: ::: `csharp public class LedgerDebugger { private readonly ILedger _ledger; // Show event timeline public void ShowTimeline(DateTime from, DateTime to) { var events = _ledger Read() Where(e => e Timestamp >= from && e Timestamp <= to) OrderBy(e => e Timestamp);\n        foreach (var @event in events) {\n            Console WriteLine($\"{@event Timestamp:HH:mm:ss fff} \" +\n                            $\"[{@event GetType() Name}] \" +\n                            $\"Aggregate: {@event AggregateId}\");\n        }\n    }\n    // Analyze event patterns\n    public void AnalyzePatterns() {\n        var events = _ledger Read();\n        var stats = events GroupBy(e => e GetType() Name) Select(g => new {\n                EventType = g Key,\n                Count = g Count(),\n                FirstOccurred = g Min(e => e Timestamp),\n                LastOccurred = g Max(e => e Timestamp)\n            });\n        foreach (var stat in stats) {\n            Console WriteLine($\"{stat EventType}: {stat Count} events\");\n        }\n    }\n}\n`\nTesting with the Ledger\n`csharp\n[Test]\npublic class LedgerTests {\n    private InMemoryLedger _ledger;\n    [SetUp]\n    public void Setup() {\n        _ledger = new InMemoryLedger();\n    }\n    [Test]\n    public async Task Append_ShouldReturnIncrementingPosition() {\n        // Arrange\n        var event1 = new TestEvent { Id = Guid NewGuid() };\n        var event2 = new TestEvent { Id = Guid NewGuid() };\n        // Act\n        var pos1 = await _ledger Append(event1);\n        var pos2 = await _ledger Append(event2);\n        // Assert\n        Assert Equal(1, pos1);\n        Assert Equal(2, pos2);\n    }\n    [Test]\n    public async Task Read_ShouldReturnEventsInOrder() {\n        // Arrange\n        var events = new[] {\n            new TestEvent { Id = Guid NewGuid() },\n            new TestEvent { Id = Guid NewGuid() },\n            new TestEvent { Id = Guid NewGuid() }\n        };\n        foreach (var @event in events) {\n            await _ledger Append(@event);\n        }\n        // Act\n        var readEvents = _ledger Read() ToList();\n        // Assert\n        Assert Equal(3, readEvents Count);\n        Assert Equal(events[0] Id, readEvents[0] Id);\n        Assert Equal(events[2] Id, readEvents[2]",
        "startIndex": 6137,
        "preview": "} ` Debugging with the Ledger :::new The ledger enables powerful debugging capabilities: ::: `csharp public class LedgerDebugger { private readonly IL..."
      },
      {
        "id": "v0.1.0/components/ledger-chunk-4",
        "text": "new TestEvent { Id = Guid NewGuid() }, new TestEvent { Id = Guid NewGuid() } }; foreach (var @event in events) { await _ledger Append(@event); } // Act var readEvents = _ledger Read() ToList(); // Assert Assert Equal(3, readEvents Count); Assert Equal(events[0] Id, readEvents[0] Id); Assert Equal(events[2] Id, readEvents[2] Id);\n    }\n    [Test]\n    public async Task Read_FromPosition_ShouldSkipEarlierEvents() {\n        // Arrange\n        for (int i = 0; i < 5; i++) {\n            await _ledger Append(new TestEvent());\n        }\n        // Act\n        var events = _ledger Read(fromPosition: 3) ToList();\n        // Assert\n        Assert Equal(2, events Count); // Only events 4 and 5\n    }\n}\n`\nIDE Features\n`csharp\n// IDE shows: \"Events stored: 1,234 | Size: 5 2MB | Last: 2s ago\"\npublic interface ILedger { }\n// IDE shows: \"Appended 45 times | Avg: 0 1ms\"\npublic Task<long> Append(IEvent @event) { }\n// IDE shows: \"Warning: Reading all events can be expensive\"\npublic IEnumerable<IEvent> Read(long fromPosition = 0) { }\n`\nPerformance Characteristics\n| Operation | Target | Actual |\n|-----------|--------|--------|\n| Append | < 1μs | TBD |\n| Read (1000 events) | < 1ms | TBD |\n| Read by type | < 2ms | TBD |\n| Get position | < 100ns | TBD |\nLimitations in v0 1 0\n:::info\nThese limitations are addressed in future versions:\n:::\nIn-memory only - Events lost on restart\nNo streaming - Must load all events at once\nNo snapshots - Can't optimize long event streams\nSingle stream - No concept of aggregate streams\nNo queries - Basic sequential read only\nMigration Path\nTo v0 2 0 (Persistence)\n:::planned\nv0 2 0 adds persistent storage:\n:::\n`csharp\n// v0 2 0 - File-based persistence\npublic interface ILedger {\n    Task<long> Append(string streamId, IEvent @event);\n    IAsyncEnumerable<IEvent> ReadStream(string streamId);\n    Task<Snapshot> CreateSnapshot(string streamId);\n}\n`\nTo v0 3",
        "startIndex": 8150,
        "preview": "new TestEvent { Id = Guid NewGuid() }, new TestEvent { Id = Guid NewGuid() } }; foreach (var @event in events) { await _ledger Append(@event); } // Ac..."
      },
      {
        "id": "v0.1.0/components/ledger-chunk-5",
        "text": "No queries - Basic sequential read only Migration Path To v0 2 0 (Persistence) :::planned v0 2 0 adds persistent storage: ::: `csharp // v0 2 0 - File-based persistence public interface ILedger { Task<long> Append(string streamId, IEvent @event); IAsyncEnumerable<IEvent> ReadStream(string streamId); Task<Snapshot> CreateSnapshot(string streamId); } ` To v0 3 0 (Event Sourcing)\n:::planned\nv0 3 0 adds full event sourcing:\n:::\n`csharp\n// v0 3 0 - Event sourcing with projections\npublic interface IEventStore : ILedger {\n    Task<T> LoadAggregate<T>(string aggregateId) where T : IAggregate;\n    Task SaveAggregate<T>(T aggregate) where T : IAggregate;\n    Task<ProjectionState> GetProjection(string projectionName);\n    Task RebuildProjection(string projectionName, DateTime from = null);\n}\n`\nBest Practices\nEvents are immutable - Never modify events after creation\nUse meaningful event names - OrderCreated not Event1\nInclude all relevant data - Events should be self-contained\nKeep events small - Large payloads impact performance\nVersion your events - Plan for schema evolution\nTest with the ledger - Verify event flow in tests\nRelated Documentation\nReceptors - Where events come from\nDispatcher - How events reach the ledger\nPerspectives - How events update views\nTesting - Testing with the ledger\nFeature Evolution - How the ledger evolves\nNext Steps\nSee v0 2 0 Persistence for file-based storage\nSee v0 3 0 Event Sourcing for full ES/CQRS\nReview Examples for event design patterns",
        "startIndex": 9711,
        "preview": "No queries - Basic sequential read only Migration Path To v0 2 0 (Persistence) :::planned v0 2 0 adds persistent storage: ::: `csharp // v0 2 0 - File..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.1.0/components/lenses",
    "title": "Lenses Component",
    "category": "Components",
    "url": "/docs/v0.1.0/components/lenses",
    "chunks": [
      {
        "id": "v0.1.0/components/lenses-chunk-0",
        "text": "Lenses Component Version Status Next Update\nVersion History\n:::new\nNew in v0 1 0: Basic query interface with Focus, View, Glimpse, Exists, and Scan methods\n:::\n:::planned\nComing in v0 2 0: \nPagination support for large result sets\nAsync enumeration with IAsyncEnumerable\nQuery optimization hints\nSee planned enhancements →\n:::\n:::planned\nComing in v0 4 0: \nSQL generation for database queries\nIndex usage optimization\nQuery result caching\nSee database features →\n:::\nEvolution Timeline\n`mermaid\ngraph LR\n    v010[v0 1 0<br/>Basic<br/>In-Memory] --> v020[v0 2 0<br/>Pagination<br/>Async]\n    v020 --> v030[v0 3 0<br/>Time-Travel<br/>Queries]\n    v030 --> v040[v0 4 0<br/>SQL<br/>Optimized]\n    v040 --> v050[v0 5 0<br/>Distributed<br/>Federated]\n    style v010 fill:#4CAF50,color:#fff\n    style v020 fill:#2196F3,color:#fff\n    style v030 fill:#FF9800,color:#fff\n    style v040 fill:#795548,color:#fff\n    style v050 fill:#9C27B0,color:#fff\n`\nOverview\nLenses provide focused, read-only views into your data They are the query side of Whizbang's CQRS implementation, offering a clean separation between reads and writes In v0 1 0, lenses work with in-memory data and establish the foundation for more advanced query capabilities What is a Lens A Lens:\nProvides read-only access to data\nFocuses on specific query needs\nNever modifies state\nAbstracts the underlying storage mechanism\nThink of a lens as a window into your data - you can look through it from different angles to see different views, but you can't reach through it to change what you see Core Interface (v0 1",
        "startIndex": 0,
        "preview": "Lenses Component Version Status Next Update\nVersion History\n:::new\nNew in v0 1 0: Basic query interface with Focus, View, Glimpse, Exists, and Scan me..."
      },
      {
        "id": "v0.1.0/components/lenses-chunk-1",
        "text": "on specific query needs Never modifies state Abstracts the underlying storage mechanism Think of a lens as a window into your data - you can look through it from different angles to see different views, but you can't reach through it to change what you see Core Interface (v0 1 0)\n:::new\nThe basic lens interface pattern with five core methods:\n:::\n`csharp\npublic interface ILens {\n    // Focus on a single item\n    T Focus<T>(object id);\n    // View a filtered collection\n    IEnumerable<T> View<T>(Expression<Func<T, bool>> filter);\n    // Glimpse a summary or partial view\n    TSummary Glimpse<TSummary>(object id);\n    // Check existence\n    bool Exists(object id);\n    // Scan all items (use sparingly)\n    IEnumerable<T> Scan<T>();\n}\n`\nDomain-Specific Lenses\n:::new\nCreate specific lens interfaces for your domain:\n:::\n`csharp\n[WhizbangLens]  // Source generator discovers this\npublic interface IOrderLens : ILens {\n    // Strongly-typed methods\n    Order Focus(Guid orderId);\n    IEnumerable<Order> ViewByCustomer(Guid customerId);\n    IEnumerable<Order> ViewByStatus(OrderStatus status);\n    OrderSummary Glimpse(Guid orderId);\n    bool Exists(Guid orderId);\n    IEnumerable<Order> Scan();\n}\n// Implementation for v0 1 0 (in-memory)\npublic class OrderLens : IOrderLens {\n    private readonly Dictionary<Guid, Order> _orders;\n    public OrderLens(IInMemoryStore<Order> store) {\n        _orders = store Collection;\n    }\n    public Order Focus(Guid orderId) {\n        return _orders TryGetValue(orderId, out var order) order \n            : null;\n    }\n    public IEnumerable<Order> ViewByCustomer(Guid customerId) {\n        return _orders Values Where(o => o CustomerId == customerId);\n    }\n    public IEnumerable<Order> ViewByStatus(OrderStatus status) {\n        return _orders Values Where(o => o Status == status);\n    }\n    public OrderSummary Glimpse(Guid orderId) {\n        var order = Focus(orderId);\n        return order == null null : new OrderSummary {\n            Id = order Id,\n            CustomerName = GetCustomerName(order CustomerId),\n            Total = order Total,\n            ItemCount = order Items Count,\n            Status = order Status ToString()\n        };\n    }\n    public bool Exists(Guid orderId) {\n        return _orders ContainsKey(orderId);\n    }\n    public IEnumerable<Order> Scan() {\n        return _orders",
        "startIndex": 1578,
        "preview": "on specific query needs Never modifies state Abstracts the underlying storage mechanism Think of a lens as a window into your data - you can look thro..."
      },
      {
        "id": "v0.1.0/components/lenses-chunk-2",
        "text": "= Focus(orderId); return order == null null : new OrderSummary { Id = order Id, CustomerName = GetCustomerName(order CustomerId), Total = order Total, ItemCount = order Items Count, Status = order Status ToString() }; } public bool Exists(Guid orderId) { return _orders ContainsKey(orderId); } public IEnumerable<Order> Scan() { return _orders Values;\n    }\n}\n`\nCore Lens Methods Explained\nFocus - Single Item Retrieval\n:::new\nRetrieve a single item by its identifier:\n:::\n`csharp\npublic interface ICustomerLens : ILens {\n    Customer Focus(Guid customerId);\n}\n// Usage in receptor\npublic class OrderReceptor : IReceptor<UpdateOrder> {\n    public OrderUpdated Receive(UpdateOrder cmd, ICustomerLens lens) {\n        var customer = lens Focus(cmd CustomerId);\n        if (customer == null) {\n            throw new CustomerNotFoundException(cmd CustomerId);\n        }\n        if ( customer IsActive) {\n            throw new InactiveCustomerException();\n        }\n        return new OrderUpdated(cmd OrderId, cmd Changes);\n    }\n}\n`\nView - Filtered Collections\n:::new\nQuery multiple items with filters:\n:::\n`csharp\npublic interface IProductLens : ILens {\n    IEnumerable<Product> View(Expression<Func<Product, bool>> filter);\n    IEnumerable<Product> ViewByCategory(string category);\n    IEnumerable<Product> ViewInPriceRange(decimal min, decimal max);\n}\n// Implementation\npublic class ProductLens : IProductLens {\n    public IEnumerable<Product> ViewByCategory(string category) {\n        return _products Values Where(p => p Category == category);\n    }\n    public IEnumerable<Product> ViewInPriceRange(decimal min, decimal max) {\n        return _products Values Where(p => p Price >= min && p Price <= max);\n    }\n}\n`\nGlimpse - Summaries and Projections\n:::new\nGet lightweight summaries without full entity data:\n:::\n`csharp\npublic interface IInventoryLens : ILens {\n    InventorySummary Glimpse(Guid productId);\n    StockLevel GlimpseStock(Guid productId);\n    IEnumerable<LowStockItem> GlimpseLowStock();\n}\n// Returns just what's needed\npublic InventorySummary Glimpse(Guid productId) {\n    var product = _products[productId];\n    return new InventorySummary {\n        ProductId = product Id,\n        Name = product Name,\n        Available = product Quantity - product Reserved,\n        Status = product Quantity > 10",
        "startIndex": 3666,
        "preview": "= Focus(orderId); return order == null null : new OrderSummary { Id = order Id, CustomerName = GetCustomerName(order CustomerId), Total = order Total,..."
      },
      {
        "id": "v0.1.0/components/lenses-chunk-3",
        "text": "ILens { InventorySummary Glimpse(Guid productId); StockLevel GlimpseStock(Guid productId); IEnumerable<LowStockItem> GlimpseLowStock(); } // Returns just what's needed public InventorySummary Glimpse(Guid productId) { var product = _products[productId]; return new InventorySummary { ProductId = product Id, Name = product Name, Available = product Quantity - product Reserved, Status = product Quantity > 10 \"In Stock\" : \"Low Stock\"\n    };\n}\n`\nExists - Efficient Existence Checks\n:::new\nCheck if an item exists without loading it:\n:::\n`csharp\npublic class OrderReceptor : IReceptor<AddItemToOrder> {\n    public ItemAdded Receive(AddItemToOrder cmd, IOrderLens orderLens, IProductLens productLens) {\n        if ( orderLens Exists(cmd OrderId)) {\n            throw new OrderNotFoundException(cmd OrderId);\n        }\n        if ( productLens Exists(cmd ProductId)) {\n            throw new ProductNotFoundException(cmd ProductId);\n        }\n        return new ItemAdded(cmd OrderId, cmd ProductId, cmd Quantity);\n    }\n}\n`\nScan - Full Collection Access\n:::new\nRetrieve all items (use sparingly):\n:::\n`csharp\npublic interface IReportLens : ILens {\n    IEnumerable<Order> ScanOrders();\n    IEnumerable<Customer> ScanCustomers();\n}\n// Use with caution - can be expensive\npublic DailyReport GenerateReport(IReportLens lens) {\n    var allOrders = lens ScanOrders();\n    return new DailyReport {\n        TotalOrders = allOrders Count(),\n        TotalRevenue = allOrders Sum(o => o Total),\n        AverageOrderValue = allOrders Average(o => o Total)\n    };\n}\n`\nComposition Pattern\n:::new\nLenses can be composed for complex queries:\n:::\n`csharp\npublic class OrderSearchLens : IOrderSearchLens {\n    private readonly IOrderLens _orderLens;\n    private readonly ICustomerLens _customerLens;\n    private readonly IProductLens _productLens;\n    public IEnumerable<OrderSearchResult> Search(OrderSearchCriteria criteria) {\n        var orders = _orderLens Scan();\n        if (criteria CustomerId HasValue) {\n            var customer = _customerLens Focus(criteria CustomerId Value);\n            orders = orders Where(o => o CustomerId == customer Id);\n        }\n        if ( string IsNullOrEmpty(criteria ProductSku)) {\n            var product = _productLens ViewBySku(criteria ProductSku) FirstOrDefault();\n            orders = orders Where(o => o Items Any(i => i ProductId == product Id));\n        }\n        return orders",
        "startIndex": 5642,
        "preview": "ILens { InventorySummary Glimpse(Guid productId); StockLevel GlimpseStock(Guid productId); IEnumerable<LowStockItem> GlimpseLowStock(); } // Returns j..."
      },
      {
        "id": "v0.1.0/components/lenses-chunk-4",
        "text": "HasValue) { var customer = _customerLens Focus(criteria CustomerId Value); orders = orders Where(o => o CustomerId == customer Id); } if ( string IsNullOrEmpty(criteria ProductSku)) { var product = _productLens ViewBySku(criteria ProductSku) FirstOrDefault(); orders = orders Where(o => o Items Any(i => i ProductId == product Id)); } return orders Select(o => MapToSearchResult(o));\n    }\n}\n`\nSource Generation\n:::new\nLenses are discovered and registered at compile time:\n:::\n`csharp\n// Generated by Whizbang Generators\npublic static partial class WhizbangGenerated {\n    public static void RegisterLenses(IServiceCollection services) {\n        services AddScoped<IOrderLens, OrderLens>();\n        services AddScoped<ICustomerLens, CustomerLens>();\n        services AddScoped<IProductLens, ProductLens>();\n        services AddScoped<IInventoryLens, InventoryLens>();\n    }\n}\n`\nTesting Lenses\n`csharp\n[Test]\npublic class OrderLensTests {\n    private OrderLens _lens;\n    private InMemoryStore<Order> _store;\n    [SetUp]\n    public void Setup() {\n        _store = new InMemoryStore<Order>();\n        _lens = new OrderLens(_store);\n        // Add test data\n        _store Collection[Guid Parse(\"123 \")] = new Order {\n            Id = Guid Parse(\"123 \"),\n            CustomerId = Guid Parse(\"456 \"),\n            Status = OrderStatus Pending,\n            Total = 99 99m\n        };\n    }\n    [Test]\n    public void Focus_ExistingOrder_ShouldReturnOrder() {\n        var order = _lens Focus(Guid Parse(\"123 \"));\n        Assert NotNull(order);\n        Assert Equal(99 99m, order Total);\n    }\n    [Test]\n    public void ViewByStatus_ShouldFilterCorrectly() {\n        var pendingOrders = _lens ViewByStatus(OrderStatus Pending);\n        Assert Equal(1, pendingOrders Count());\n    }\n    [Test]\n    public void Exists_ExistingOrder_ShouldReturnTrue() {\n        Assert True(_lens Exists(Guid Parse(\"123 \")));\n    }\n}\n`\nIDE Features\n`csharp\n// IDE shows: \"Used by: 5 receptors | Queries: 234 | Avg: 0 5ms\"\npublic interface IOrderLens : ILens { }\n// IDE shows: \"Called 45 times | Last: 2s ago | Avg: 0",
        "startIndex": 7642,
        "preview": "HasValue) { var customer = _customerLens Focus(criteria CustomerId Value); orders = orders Where(o => o CustomerId == customer Id); } if ( string IsNu..."
      },
      {
        "id": "v0.1.0/components/lenses-chunk-5",
        "text": "[Test] public void Exists_ExistingOrder_ShouldReturnTrue() { Assert True(_lens Exists(Guid Parse(\"123 \"))); } } ` IDE Features `csharp // IDE shows: \"Used by: 5 receptors | Queries: 234 | Avg: 0 5ms\" public interface IOrderLens : ILens { } // IDE shows: \"Called 45 times | Last: 2s ago | Avg: 0 3ms\"\npublic Order Focus(Guid orderId) { }\n// IDE shows: \"Warning: Scan can be expensive - consider using View with filters\"\npublic IEnumerable<Order> Scan() { }\n`\nPerformance Characteristics\n| Operation | Target | Actual |\n|-----------|--------|--------|\n| Focus (in-memory) | < 100ns | TBD |\n| View (filtered) | < 1μs per item | TBD |\n| Glimpse | < 500ns | TBD |\n| Exists | < 50ns | TBD |\n| Scan (1000 items) | < 1ms | TBD |\nLimitations in v0 1 0\n:::info\nThese limitations are addressed in future versions:\n:::\nNo pagination - All results returned at once\nSynchronous only - No async/await support\nIn-memory only - No database queries\nNo caching - Queries execute every time\nMigration Path\nTo v0 2 0 (Enhanced Queries)\n:::planned\nv0 2 0 adds pagination and async support:\n:::\n`csharp\n// v0 2 0 - Pagination\npublic interface IOrderLens : ILens {\n    PagedResult<Order> ViewByCustomer(Guid customerId, int page, int pageSize);\n}\n// v0 2 0 - Async enumeration\npublic interface IOrderLens : ILens {\n    IAsyncEnumerable<Order> ScanAsync();\n}\n`\nTo v0 4 0 (Database Queries)\n:::planned\nv0 4 0 adds real database support with SQL generation:\n:::\n`csharp\n// v0 4 0 - SQL generation\n[SqlOptimized]\npublic class OrderLens : IOrderLens {\n    public Order Focus(Guid orderId) {\n        // Generated SQL: SELECT * FROM Orders WHERE Id = @orderId\n        return _db QuerySingle<Order>(\"",
        "startIndex": 9392,
        "preview": "[Test] public void Exists_ExistingOrder_ShouldReturnTrue() { Assert True(_lens Exists(Guid Parse(\"123 \"))); } } ` IDE Features `csharp // IDE shows: \"..."
      },
      {
        "id": "v0.1.0/components/lenses-chunk-6",
        "text": "4 0 (Database Queries) :::planned v0 4 0 adds real database support with SQL generation: ::: `csharp // v0 4 0 - SQL generation [SqlOptimized] public class OrderLens : IOrderLens { public Order Focus(Guid orderId) { // Generated SQL: SELECT * FROM Orders WHERE Id = @orderId return _db QuerySingle<Order>(\" \", new { orderId });\n    }\n}\n`\nBest Practices\nKeep lenses read-only - Never modify state through a lens\nUse specific methods - ViewByCustomer over generic View\nAvoid Scan - Use filtered queries when possible\nReturn summaries - Use Glimpse for lightweight results\nCheck existence - Use Exists before Focus\nCompose lenses - Combine for complex queries\nRelated Documentation\nReceptors - Using lenses in receptors\nPerspectives - Data that lenses query\nDispatcher - How lenses are provided\nTesting - Testing lenses\nFeature Evolution - How lenses evolve\nNext Steps\nSee v0 2 0 Enhancements for pagination and async features\nSee v0 4 0 Database Support for SQL optimization\nReview Examples for query patterns",
        "startIndex": 10768,
        "preview": "4 0 (Database Queries) :::planned v0 4 0 adds real database support with SQL generation: ::: `csharp // v0 4 0 - SQL generation [SqlOptimized] public ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.1.0/components/perspectives",
    "title": "Perspectives Component",
    "category": "Components",
    "url": "/docs/v0.1.0/components/perspectives",
    "chunks": [
      {
        "id": "v0.1.0/components/perspectives-chunk-0",
        "text": "Perspectives Component Version Status Next Update\nVersion History\n:::new\nNew in v0 1 0: Basic event handling with in-memory updates for multiple views\n:::\n:::planned\nComing in v0 2 0: \nBatch update support for performance\nParallel perspective execution\nEnhanced error handling with dead letter queues\nSee planned enhancements →\n:::\n:::planned\nComing in v0 3 0: \nFull projection support with rebuild capability\nCheckpoint management for event replay\nSubscription management\nSee projection features →\n:::\nEvolution Timeline\n`mermaid\ngraph LR\n    v010[v0 1 0<br/>Basic<br/>In-Memory] --> v020[v0 2 0<br/>Batch<br/>Parallel]\n    v020 --> v030[v0 3 0<br/>Projections<br/>Rebuild]\n    v030 --> v040[v0 4 0<br/>Database<br/>Optimized]\n    v040 --> v050[v0 5 0<br/>Distributed<br/>Partitioned]\n    style v010 fill:#4CAF50,color:#fff\n    style v020 fill:#2196F3,color:#fff\n    style v030 fill:#FF9800,color:#fff\n    style v040 fill:#795548,color:#fff\n    style v050 fill:#9C27B0,color:#fff\n`\nOverview\nPerspectives are the components that react to events and update various views of your data They handle all write operations in Whizbang, ensuring that state changes flow consistently from events to storage In v0 1 0, perspectives work with in-memory storage and provide the foundation for more advanced features What is a Perspective A Perspective:\nReacts to events emitted by receptors\nUpdates data stores (in-memory in v0 1 0)\nMaintains different views of the same data\nExecutes all write operations in the system\nThink of perspectives as event handlers that maintain materialized views Each perspective provides a different \"perspective\" on the events flowing through your system Core Interface (v0 1 0)\n:::new\nThe fundamental perspective interface for handling events:\n:::\n`csharp\npublic interface IPerspectiveOf<TEvent> {\n    Task Update(TEvent @event);\n}\n`\nSimple, yet powerful - perspectives react to specific events and update their views accordingly Basic Implementation\n:::new\nIn v0 1 0, perspectives work with in-memory storage:\n:::\n`csharp\n[WhizbangHandler]  // Source generator discovers this\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> {\n    private readonly Dictionary<Guid, Order> _orders;\n    public OrderPerspective(IInMemoryStore<Order> store) {\n        _orders = store",
        "startIndex": 0,
        "preview": "Perspectives Component Version Status Next Update\nVersion History\n:::new\nNew in v0 1 0: Basic event handling with in-memory updates for multiple views..."
      },
      {
        "id": "v0.1.0/components/perspectives-chunk-1",
        "text": "powerful - perspectives react to specific events and update their views accordingly Basic Implementation :::new In v0 1 0, perspectives work with in-memory storage: ::: `csharp [WhizbangHandler] // Source generator discovers this public class OrderPerspective : IPerspectiveOf<OrderCreated> { private readonly Dictionary<Guid, Order> _orders; public OrderPerspective(IInMemoryStore<Order> store) { _orders = store Collection;\n    }\n    public Task Update(OrderCreated @event) {\n        _orders[@event OrderId] = new Order {\n            Id = @event OrderId,\n            CustomerId = @event CustomerId,\n            Items = @event Items,\n            Total = @event Total,\n            Status = OrderStatus Created,\n            CreatedAt = @event Timestamp\n        };\n        return Task CompletedTask;\n    }\n}\n`\nMultiple Perspectives Pattern\n:::new\nDifferent perspectives can handle the same event to create different views:\n:::\n`csharp\n// Order list for display\n[WhizbangHandler]\npublic class OrderListPerspective : IPerspectiveOf<OrderCreated> {\n    private readonly List<OrderListItem> _orderList;\n    public async Task Update(OrderCreated @event) {\n        _orderList Add(new OrderListItem {\n            Id = @event OrderId,\n            CustomerName = await GetCustomerName(@event CustomerId),\n            Total = @event Total,\n            Status = \"New\",\n            CreatedAt = @event Timestamp\n        });\n    }\n}\n// Customer statistics\n[WhizbangHandler]\npublic class CustomerStatsPerspective : IPerspectiveOf<OrderCreated> {\n    private readonly Dictionary<Guid, CustomerStats> _stats;\n    public Task Update(OrderCreated @event) {\n        if ( _stats TryGetValue(@event CustomerId, out var stats)) {\n            stats = _stats[@event CustomerId] = new CustomerStats();\n        }\n        stats OrderCount++;\n        stats TotalSpent += @event Total;\n        stats LastOrderDate = @event Timestamp;\n        return Task CompletedTask;\n    }\n}\n// Analytics perspective\n[WhizbangHandler]\npublic class AnalyticsPerspective : IPerspectiveOf<OrderCreated> {\n    private readonly IAnalyticsStore _analytics;\n    public Task Update(OrderCreated @event) {\n        _analytics RecordMetric(\"orders created\", 1);\n        _analytics RecordMetric(\"orders value\", @event Total);\n        return Task",
        "startIndex": 2308,
        "preview": "powerful - perspectives react to specific events and update their views accordingly Basic Implementation :::new In v0 1 0, perspectives work with in-m..."
      },
      {
        "id": "v0.1.0/components/perspectives-chunk-2",
        "text": "new CustomerStats(); } stats OrderCount++; stats TotalSpent += @event Total; stats LastOrderDate = @event Timestamp; return Task CompletedTask; } } // Analytics perspective [WhizbangHandler] public class AnalyticsPerspective : IPerspectiveOf<OrderCreated> { private readonly IAnalyticsStore _analytics; public Task Update(OrderCreated @event) { _analytics RecordMetric(\"orders created\", 1); _analytics RecordMetric(\"orders value\", @event Total); return Task CompletedTask;\n    }\n}\n`\nEvent Flow\nHow Events Reach Perspectives\n`mermaid\nsequenceDiagram\n    participant R as Receptor\n    participant D as Dispatcher\n    participant P1 as OrderPerspective\n    participant P2 as StatsPerspective\n    participant P3 as AnalyticsPerspective\n    R->>D: OrderCreated event\n    D->>P1: Update(event)\n    D->>P2: Update(event)\n    D->>P3: Update(event)\n    Note over P1,P3: All perspectives update\n`\nHandling Multiple Event Types\nA perspective can handle multiple event types:\n`csharp\n[WhizbangHandler]\npublic class OrderPerspective : \n    IPerspectiveOf<OrderCreated>,\n    IPerspectiveOf<OrderUpdated>,\n    IPerspectiveOf<OrderShipped>,\n    IPerspectiveOf<OrderCancelled> {\n    private readonly Dictionary<Guid, Order> _orders;\n    public Task Update(OrderCreated @event) {\n        _orders[@event OrderId] = new Order { \n            Status = OrderStatus Created \n        };\n        return Task CompletedTask;\n    }\n    public Task Update(OrderUpdated @event) {\n        _orders[@event OrderId] UpdatedAt = @event Timestamp;\n        return Task CompletedTask;\n    }\n    public Task Update(OrderShipped @event) {\n        _orders[@event OrderId] Status = OrderStatus Shipped;\n        _orders[@event OrderId] ShippedAt = @event Timestamp;\n        return Task CompletedTask;\n    }\n    public Task Update(OrderCancelled @event) {\n        _orders[@event OrderId] Status = OrderStatus Cancelled;\n        return Task CompletedTask;\n    }\n}\n`\nError Handling\n:::new\nBasic error handling in v0 1 0:\n:::\n`csharp\npublic class ResilientPerspective : IPerspectiveOf<OrderCreated> {\n    private readonly ILogger<ResilientPerspective> _logger;\n    public async Task Update(OrderCreated @event) {\n        try {\n            // Update logic\n            await UpdateDatabase(@event);\n        }\n        catch (Exception ex) {\n            _logger LogError(ex, \"Failed to update perspective for order {OrderId}\", \n                @event OrderId);\n            // In v0 1 0, errors are logged but not retried\n            // v0 2",
        "startIndex": 4181,
        "preview": "new CustomerStats(); } stats OrderCount++; stats TotalSpent += @event Total; stats LastOrderDate = @event Timestamp; return Task CompletedTask; } } //..."
      },
      {
        "id": "v0.1.0/components/perspectives-chunk-3",
        "text": ": IPerspectiveOf<OrderCreated> { private readonly ILogger<ResilientPerspective> _logger; public async Task Update(OrderCreated @event) { try { // Update logic await UpdateDatabase(@event); } catch (Exception ex) { _logger LogError(ex, \"Failed to update perspective for order {OrderId}\", @event OrderId); // In v0 1 0, errors are logged but not retried // v0 2 0 adds retry policies and dead letter queues\n            throw;\n        }\n    }\n}\n`\nPolicy Application\n:::new\nPolicies can be applied to perspectives:\n:::\n`csharp\n[Retry(3)]\n[Timeout(5000)]\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated @event) {\n        // Policies are applied automatically by the dispatcher\n        await UpdateDatabase(@event);\n    }\n}\n`\nSource Generation\n:::new\nPerspectives are discovered at compile time:\n:::\n`csharp\n// Generated by Whizbang Generators\npublic static partial class WhizbangGenerated {\n    public static void RegisterPerspectives(IServiceCollection services) {\n        services AddScoped<IPerspectiveOf<OrderCreated>, OrderPerspective>();\n        services AddScoped<IPerspectiveOf<OrderCreated>, CustomerStatsPerspective>();\n        services AddScoped<IPerspectiveOf<OrderCreated>, AnalyticsPerspective>();\n    }\n    public static Dictionary<Type, List<Type>> GetEventPerspectives() {\n        return new() {\n            [typeof(OrderCreated)] = new() {\n                typeof(OrderPerspective),\n                typeof(CustomerStatsPerspective),\n                typeof(AnalyticsPerspective)\n            }\n        };\n    }\n}\n`\nTesting Perspectives\n`csharp\n[Test]\npublic class OrderPerspectiveTests {\n    private OrderPerspective _perspective;\n    private InMemoryStore<Order> _store;\n    [SetUp]\n    public void Setup() {\n        _store = new InMemoryStore<Order>();\n        _perspective = new OrderPerspective(_store);\n    }\n    [Test]\n    public async Task Update_OrderCreated_ShouldStoreOrder() {\n        // Arrange\n        var @event = new OrderCreated(\n            OrderId: Guid NewGuid(),\n            CustomerId: Guid NewGuid(),\n            Items: new[] { new OrderItem(\"SKU-001\", 2, 29 99m) },\n            Total: 59 98m,\n            Timestamp: DateTimeOffset UtcNow\n        );\n        // Act\n        await _perspective Update(@event);\n        // Assert\n        Assert True(_store Collection ContainsKey(@event OrderId));\n        var order = _store Collection[@event OrderId];\n        Assert Equal(@event CustomerId, order CustomerId);\n        Assert Equal(@event Total, order Total);\n        Assert Equal(OrderStatus Created, order",
        "startIndex": 6212,
        "preview": ": IPerspectiveOf<OrderCreated> { private readonly ILogger<ResilientPerspective> _logger; public async Task Update(OrderCreated @event) { try { // Upda..."
      },
      {
        "id": "v0.1.0/components/perspectives-chunk-4",
        "text": "Guid NewGuid(), Items: new[] { new OrderItem(\"SKU-001\", 2, 29 99m) }, Total: 59 98m, Timestamp: DateTimeOffset UtcNow ); // Act await _perspective Update(@event); // Assert Assert True(_store Collection ContainsKey(@event OrderId)); var order = _store Collection[@event OrderId]; Assert Equal(@event CustomerId, order CustomerId); Assert Equal(@event Total, order Total); Assert Equal(OrderStatus Created, order Status);\n    }\n}\n`\nIDE Features\n`csharp\n// IDE shows: \"Handles: OrderCreated, OrderUpdated, OrderShipped | Updated by: 3 dispatchers\"\npublic class OrderPerspective : IPerspectiveOf<OrderCreated> { }\n// IDE shows: \"Published to: 3 perspectives\"\npublic record OrderCreated(Guid OrderId);\n// IDE shows: \"Updates triggered: 127 times | Avg: 2 3ms | Last: 5s ago\"\npublic async Task Update(OrderCreated @event) { }\n`\nPerformance Characteristics\n| Operation | Target | Actual |\n|-----------|--------|--------|\n| Update invocation | < 1μs | TBD |\n| In-memory write | < 100ns | TBD |\n| Multiple perspectives | < 10μs | TBD |\n| Error handling | < 1ms | TBD |\nLimitations in v0 1 0\n:::info\nThese limitations are addressed in future versions:\n:::\nNo batch updates - Each event processed individually\nSequential execution - Perspectives run one at a time\nBasic error handling - No retry or dead letter queues\nIn-memory only - No database persistence\nMigration Path\nTo v0 2 0 (Enhanced Features)\n:::planned\nv0 2 0 adds performance and reliability features:\n:::\n`csharp\n// v0 2 0 - Batch updates\npublic class OrderPerspective : IBatchPerspective<OrderCreated> {\n    public async Task UpdateBatch(IEnumerable<OrderCreated> events) {\n        // Process multiple events efficiently\n        await BulkInsert(events);\n    }\n}\n// v0 2 0 - Parallel execution\n[ParallelExecution(MaxDegree = 4)]\npublic class AnalyticsPerspective : IPerspectiveOf<OrderCreated> { }\n`\nTo v0 3 0 (Projections)\n:::planned\nv0 3 0 transforms perspectives into full projections:\n:::\n`csharp\n// v0 3",
        "startIndex": 8446,
        "preview": "Guid NewGuid(), Items: new[] { new OrderItem(\"SKU-001\", 2, 29 99m) }, Total: 59 98m, Timestamp: DateTimeOffset UtcNow ); // Act await _perspective Upd..."
      },
      {
        "id": "v0.1.0/components/perspectives-chunk-5",
        "text": "Task UpdateBatch(IEnumerable<OrderCreated> events) { // Process multiple events efficiently await BulkInsert(events); } } // v0 2 0 - Parallel execution [ParallelExecution(MaxDegree = 4)] public class AnalyticsPerspective : IPerspectiveOf<OrderCreated> { } ` To v0 3 0 (Projections) :::planned v0 3 0 transforms perspectives into full projections: ::: `csharp // v0 3 0 - Projection with rebuild\n[Projection(\"OrderSummary\")]\npublic class OrderProjection : IProjection {\n    public async Task Handle(OrderCreated @event) {\n        // Same as perspective but with checkpoint tracking\n    }\n    [Rebuild]\n    public async Task RebuildFrom(DateTime from) {\n        // Rebuild projection from event history\n    }\n}\n`\nBest Practices\nKeep perspectives focused - One concern per perspective\nAvoid complex logic - Perspectives should be simple updates\nHandle errors gracefully - Log and continue when possible\nDesign for idempotency - Same event twice = same result\nUse multiple perspectives - Different views for different needs\nTest with events - Test perspectives with real event data\nRelated Documentation\nReceptors - Where events come from\nDispatcher - How events reach perspectives\nLenses - Reading the data perspectives write\nTesting - Testing perspectives\nFeature Evolution - How perspectives evolve\nNext Steps\nSee v0 2 0 Enhancements for batch and parallel features\nSee v0 3 0 Projections for full projection support\nReview Examples for practical patterns",
        "startIndex": 9998,
        "preview": "Task UpdateBatch(IEnumerable<OrderCreated> events) { // Process multiple events efficiently await BulkInsert(events); } } // v0 2 0 - Parallel executi..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.1.0/components/policy-engine",
    "title": "Policy Engine Component",
    "category": "Components",
    "url": "/docs/v0.1.0/components/policy-engine",
    "chunks": [
      {
        "id": "v0.1.0/components/policy-engine-chunk-0",
        "text": "Policy Engine Component Version Status Next Update\nVersion History\n:::new\nNew in v0 1 0: Basic policies - Retry, Timeout, Cache, and CircuitBreaker\n:::\n:::planned\nComing in v0 2 0: \nPolicy composition for combining multiple policies\nBulkhead isolation for resource protection\nRate limiting with token buckets\nSee planned enhancements →\n:::\n:::planned\nComing in v0 6 0: \nAuthorization policies\nAudit logging policies\nCompliance and security policies\nSee production features →\n:::\nEvolution Timeline\n`mermaid\ngraph LR\n    v010[v0 1 0<br/>Basic<br/>4 Policies] --> v020[v0 2 0<br/>Composition<br/>Rate Limit]\n    v020 --> v030[v0 3 0<br/>Stateful<br/>Persistence]\n    v030 --> v050[v0 5 0<br/>Distributed<br/>Coordination]\n    v050 --> v060[v0 6 0<br/>Security<br/>Audit]\n    style v010 fill:#4CAF50,color:#fff\n    style v020 fill:#2196F3,color:#fff\n    style v030 fill:#FF9800,color:#fff\n    style v050 fill:#9C27B0,color:#fff\n    style v060 fill:#F44336,color:#fff\n`\nOverview\nThe Policy Engine provides cross-cutting concerns as composable, declarative policies Instead of cluttering your business logic with retry loops, timeout handling, and caching code, you declare policies that the framework applies automatically In v0 1 0, we provide four essential policies to handle the most common scenarios What is a Policy A Policy:\nWraps component execution with additional behavior\nHandles cross-cutting concerns declaratively\nComposes with other policies\nApplies automatically via source generation\nThink of policies as aspects that modify how your components execute without changing their core logic Core Interface (v0 1 0)\n:::new\nThe basic policy interface for wrapping execution:\n:::\n`csharp\npublic interface IPolicyOf<T> {\n    Task<TResult> Execute<TResult>(\n        Func<Task<TResult>> operation,\n        IMessageContext context\n    );\n}\n`\nAvailable Policies in v0 1 0\nRetry Policy\n:::new\nAutomatically retry failed operations with configurable backoff strategies:\n:::\n`csharp\n// Basic retry with fixed delay\n[Retry(3)]\npublic class PaymentReceptor : IReceptor<ProcessPayment, PaymentProcessed> {\n    public async Task<PaymentProcessed> Receive(ProcessPayment cmd) {\n        // If this throws, it will retry up to 3 times\n        return ProcessPayment(cmd);\n    }\n}\n// Exponential backoff\n[Retry(3, BackoffStrategy",
        "startIndex": 0,
        "preview": "Policy Engine Component Version Status Next Update\nVersion History\n:::new\nNew in v0 1 0: Basic policies - Retry, Timeout, Cache, and CircuitBreaker\n::..."
      },
      {
        "id": "v0.1.0/components/policy-engine-chunk-1",
        "text": "Automatically retry failed operations with configurable backoff strategies: ::: `csharp // Basic retry with fixed delay [Retry(3)] public class PaymentReceptor : IReceptor<ProcessPayment, PaymentProcessed> { public async Task<PaymentProcessed> Receive(ProcessPayment cmd) { // If this throws, it will retry up to 3 times return ProcessPayment(cmd); } } // Exponential backoff [Retry(3, BackoffStrategy Exponential)]\npublic class OrderReceptor : IReceptor<CreateOrder, OrderCreated> {\n    // Retries with delays: 1s, 2s, 4s\n}\n// Custom delays\n[Retry(Delays = new[] { 100, 500, 2000 })]\npublic class InventoryReceptor : IReceptor<ReserveStock> {\n    // Retries with specific delays: 100ms, 500ms, 2s\n}\n`\nConfiguration Options\n`csharp\n[Retry(\n    MaxAttempts = 3,\n    BackoffStrategy = BackoffStrategy Exponential,\n    InitialDelayMs = 100,\n    MaxDelayMs = 30000,\n    RetryOn = typeof(TransientException),\n    ExcludeOn = typeof(ValidationException)\n)]\n`\nTimeout Policy\n:::new\nPrevent operations from running indefinitely:\n:::\n`csharp\n// Simple timeout\n[Timeout(5000)]  // 5 seconds\npublic class DatabaseReceptor : IReceptor<QueryData> {\n    public QueryResult Receive(QueryData cmd) {\n        // Cancelled if takes longer than 5 seconds\n        return ExecuteQuery(cmd);\n    }\n}\n// Timeout with custom exception\n[Timeout(3000, ThrowOnTimeout = true)]\npublic class CriticalReceptor : IReceptor<CriticalCommand> {\n    // Throws TimeoutException instead of returning default\n}\n`\nCache Policy\n:::new\nCache results to avoid redundant processing:\n:::\n`csharp\n// Cache for 5 minutes\n[Cache(Duration = 300)]  // seconds\npublic class ProductLens : IProductLens {\n    public Product Focus(Guid productId) {\n        // Result cached for 5 minutes\n        return LoadProduct(productId);\n    }\n}\n// Cache with sliding expiration\n[Cache(Duration = 600, Sliding = true)]\npublic class CustomerLens : ICustomerLens {\n    // Cache extends on each access\n}\n// Cache with custom key\n[Cache(Duration = 300, KeyProperty = \"CustomerId\")]\npublic class OrderHistoryReceptor : IReceptor<GetOrderHistory> {\n    // Cached by CustomerId property\n}\n`\nCircuit Breaker Policy\n:::new\nPrevent cascading failures by breaking the circuit after repeated failures:\n:::\n`csharp\n// Basic circuit breaker\n[CircuitBreaker(\n    FailureThreshold = 0",
        "startIndex": 2327,
        "preview": "Automatically retry failed operations with configurable backoff strategies: ::: `csharp // Basic retry with fixed delay [Retry(3)] public class Paymen..."
      },
      {
        "id": "v0.1.0/components/policy-engine-chunk-2",
        "text": "access } // Cache with custom key [Cache(Duration = 300, KeyProperty = \"CustomerId\")] public class OrderHistoryReceptor : IReceptor<GetOrderHistory> { // Cached by CustomerId property } ` Circuit Breaker Policy :::new Prevent cascading failures by breaking the circuit after repeated failures: ::: `csharp // Basic circuit breaker [CircuitBreaker( FailureThreshold = 0 5,  // 50% failure rate\n    SamplingDuration = 10,   // Over 10 seconds\n    MinimumThroughput = 5,   // At least 5 calls\n    BreakDuration = 30       // Break for 30 seconds\n)]\npublic class ExternalServiceReceptor : IReceptor<CallExternalService> {\n    public ServiceResult Receive(CallExternalService cmd) {\n        // Circuit opens after 50% failures\n        // Stays open for 30 seconds\n        // Then half-open to test recovery\n    }\n}\n`\nCircuit States\n`mermaid\nstateDiagram-v2\n    [*] --> Closed: Initial\n    Closed --> Open: Threshold<br/>Exceeded\n    Open --> HalfOpen: After<br/>BreakDuration\n    HalfOpen --> Closed: Success\n    HalfOpen --> Open: Failure\n`\nApplying Policies\nVia Attributes\n:::new\nThe simplest way to apply policies is via attributes:\n:::\n`csharp\n[Retry(3)]\n[Timeout(5000)]\n[Cache(300)]\n[CircuitBreaker(0 5, 10)]\npublic class ResilientReceptor : IReceptor<ImportantCommand> {\n    public CommandResult Receive(ImportantCommand cmd) {\n        // All policies applied in order:\n        // 1 Check cache\n        // 2 Check circuit breaker\n        // 3 Apply timeout\n        // 4 Retry on failure\n        return ProcessCommand(cmd);\n    }\n}\n`\nPolicy Execution Order\nPolicies execute in a specific order (innermost to outermost):\nCache - Check cache first\nCircuitBreaker - Check if circuit is open\nTimeout - Apply timeout to operation\nRetry - Retry if operation fails\nCustom Policies\n:::new\nCreate custom policies for specific needs:\n:::\n`csharp\n[WhizbangPolicy]\npublic class LoggingPolicy : IPolicyOf<IReceptor> {\n    private readonly ILogger _logger;\n    public async Task<TResult> Execute<TResult>(\n        Func<Task<TResult>> operation,\n        IMessageContext context\n    ) {\n        var stopwatch = Stopwatch StartNew();\n        try {\n            _logger LogInformation(\"Executing {Operation}\", context MessageType);\n            var result = await operation();\n            _logger LogInformation(\"Completed in {ElapsedMs}ms\", stopwatch ElapsedMilliseconds);\n            return result;\n        }\n        catch (Exception ex) {\n            _logger",
        "startIndex": 4230,
        "preview": "access } // Cache with custom key [Cache(Duration = 300, KeyProperty = \"CustomerId\")] public class OrderHistoryReceptor : IReceptor<GetOrderHistory> {..."
      },
      {
        "id": "v0.1.0/components/policy-engine-chunk-3",
        "text": "class LoggingPolicy : IPolicyOf<IReceptor> { private readonly ILogger _logger; public async Task<TResult> Execute<TResult>( Func<Task<TResult>> operation, IMessageContext context ) { var stopwatch = Stopwatch StartNew(); try { _logger LogInformation(\"Executing {Operation}\", context MessageType); var result = await operation(); _logger LogInformation(\"Completed in {ElapsedMs}ms\", stopwatch ElapsedMilliseconds); return result; } catch (Exception ex) { _logger LogError(ex, \"Failed after {ElapsedMs}ms\", stopwatch ElapsedMilliseconds);\n            throw;\n        }\n    }\n}\n// Usage\n[LoggingPolicy]\n[Retry(3)]\npublic class AuditedReceptor : IReceptor<AuditedCommand> { }\n`\nSource Generation\n:::new\nPolicies are woven at compile time for zero overhead:\n:::\n`csharp\n// Generated by Whizbang Generators\npublic static class PolicyWeaver {\n    public static OrderReceptor WrapWithPolicies(OrderReceptor receptor) {\n        return new RetryPolicyWrapper(\n            new TimeoutPolicyWrapper(\n                new CachePolicyWrapper(\n                    new CircuitBreakerPolicyWrapper(receptor)\n                )\n            )\n        );\n    }\n}\n`\nTesting with Policies\n`csharp\n[Test]\npublic class PolicyTests {\n    [Test]\n    public async Task Retry_ShouldRetryThreeTimes() {\n        // Arrange\n        var attempts = 0;\n        var receptor = new TestReceptor(() => {\n            attempts++;\n            if (attempts < 3) throw new TransientException();\n            return new TestResult();\n        });\n        var retryPolicy = new RetryPolicy(3);\n        // Act\n        var result = await retryPolicy Execute(\n            () => receptor Receive(new TestCommand()),\n            new MessageContext()\n        );\n        // Assert\n        Assert Equal(3, attempts);\n        Assert NotNull(result);\n    }\n    [Test]\n    public async Task CircuitBreaker_ShouldOpenAfterFailures() {\n        // Arrange\n        var breaker = new CircuitBreakerPolicy(0 5, 10, 5, 30);\n        var failingOperation = () => throw new Exception();\n        // Act - cause failures\n        for (int i = 0; i < 5; i++) {\n            try {\n                await breaker Execute(failingOperation, new MessageContext());\n            }\n            catch { }\n        }\n        // Assert - circuit should be open\n        Assert Throws<CircuitBreakerOpenException>(\n            () => breaker Execute(failingOperation, new MessageContext())\n        );\n    }\n}\n`\nIDE Features\n`csharp\n// IDE shows: \"Policies: Retry(3), Timeout(5s), Cache(5m)\"\n[Retry(3)][Timeout(5000)][Cache(300)]\npublic class PolicyReceptor : IReceptor<Command> { }\n// IDE shows: \"Circuit breaker state: Closed | Success: 95% | Calls: 1,234\"\n[CircuitBreaker(0",
        "startIndex": 6307,
        "preview": "class LoggingPolicy : IPolicyOf<IReceptor> { private readonly ILogger _logger; public async Task<TResult> Execute<TResult>( Func<Task<TResult>> operat..."
      },
      {
        "id": "v0.1.0/components/policy-engine-chunk-4",
        "text": "Assert - circuit should be open Assert Throws<CircuitBreakerOpenException>( () => breaker Execute(failingOperation, new MessageContext()) ); } } ` IDE Features `csharp // IDE shows: \"Policies: Retry(3), Timeout(5s), Cache(5m)\" [Retry(3)][Timeout(5000)][Cache(300)] public class PolicyReceptor : IReceptor<Command> { } // IDE shows: \"Circuit breaker state: Closed | Success: 95% | Calls: 1,234\" [CircuitBreaker(0 5, 10)]\npublic class ServiceReceptor { }\n// IDE shows: \"Cache hit rate: 78% | Entries: 234 | Memory: 5 2MB\"\n[Cache(300)]\npublic class CachedLens { }\n`\nPerformance Characteristics\n| Policy | Overhead | Memory Impact |\n|--------|----------|---------------|\n| Retry | < 10ns per attempt | Minimal |\n| Timeout | < 100ns | Timer allocation |\n| Cache | < 50ns lookup | Depends on cache size |\n| CircuitBreaker | < 20ns check | State tracking |\nLimitations in v0 1 0\n:::info\nThese limitations are addressed in future versions:\n:::\nNo policy composition - Cannot combine policies dynamically\nBasic configuration - Limited to attribute parameters\nIn-memory state - Policy state not persisted\nNo distributed coordination - Policies are instance-local\nMigration Path\nTo v0 2 0 (Enhanced Policies)\n:::planned\nv0 2 0 adds composition and new policy types:\n:::\n`csharp\n// v0 2 0 - Policy composition\n[PolicySet(\"Resilient\")]\npublic class OrderReceptor { }\n// Define policy sets\nservices AddPolicySet(\"Resilient\", policies => {\n    policies AddRetry(3);\n    policies AddTimeout(5000);\n    policies AddBulkhead(10);  // New in v0 2 0\n    policies AddRateLimit(100, TimeSpan FromMinute(1));  // New in v0 2 0\n});\n`\nTo v0 6 0 (Security Policies)\n:::planned\nv0 6 0 adds security and compliance policies:\n:::\n`csharp\n// v0 6 0 - Security policies\n[Authorize(Roles = \"Admin\")]\n[Audit(Level = AuditLevel",
        "startIndex": 8530,
        "preview": "Assert - circuit should be open Assert Throws<CircuitBreakerOpenException>( () => breaker Execute(failingOperation, new MessageContext()) ); } } ` IDE..."
      },
      {
        "id": "v0.1.0/components/policy-engine-chunk-5",
        "text": "policies AddBulkhead(10); // New in v0 2 0 policies AddRateLimit(100, TimeSpan FromMinute(1)); // New in v0 2 0 }); ` To v0 6 0 (Security Policies) :::planned v0 6 0 adds security and compliance policies: ::: `csharp // v0 6 0 - Security policies [Authorize(Roles = \"Admin\")] [Audit(Level = AuditLevel Full)]\n[EncryptPII]\npublic class SecureReceptor { }\n`\nBest Practices\nOrder matters - Apply policies in the right order\nConfigure appropriately - Don't retry non-transient errors\nMonitor policy metrics - Track success rates and performance\nTest with policies - Include policies in your tests\nUse circuit breakers - Protect external dependencies\nCache judiciously - Consider memory and staleness\nRelated Documentation\nReceptors - Applying policies to receptors\nPerspectives - Applying policies to perspectives\nDispatcher - How policies are executed\nTesting - Testing with policies\nFeature Evolution - How policies evolve\nNext Steps\nSee v0 2 0 Enhancements for composition and new policies\nSee v0 6 0 Production for security policies\nReview Examples for policy patterns",
        "startIndex": 9912,
        "preview": "policies AddBulkhead(10); // New in v0 2 0 policies AddRateLimit(100, TimeSpan FromMinute(1)); // New in v0 2 0 }); ` To v0 6 0 (Security Policies) ::..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.1.0/components/receptors",
    "title": "Receptors Component",
    "category": "Components",
    "url": "/docs/v0.1.0/components/receptors",
    "chunks": [
      {
        "id": "v0.1.0/components/receptors-chunk-0",
        "text": "Receptors Component Version Status Next Update\nVersion History\n:::new\nNew in v0 1 0: Type-safe receptors with async support and automatic multi-destination routing\n:::\n:::planned\nComing in v0 2 0: \nSource-generated automatic registration\nPolicy integration through attributes\nZero-reflection performance\nSee planned enhancements →\n:::\n:::planned\nComing in v0 3 0: \nAutomatic causality tracking\nComplete time-travel debugging\nReplay capability from any point\nSee temporal features →\n:::\nEvolution Timeline\n`mermaid\ngraph LR\n    v010[v0 1 0<br/>Type-Safe<br/>Multi-Destination] --> v020[v0 2 0<br/>Source Generation<br/>Policy Integration]\n    v020 --> v030[v0 3 0<br/>Temporal Awareness<br/>Time-Travel Debug]\n    v030 --> v040[v0 4 0<br/>Distributed<br/>Production Ready]\n    style v010 fill:#4CAF50,color:#fff\n    style v020 fill:#2196F3,color:#fff\n    style v030 fill:#FF9800,color:#fff\n    style v040 fill:#9C27B0,color:#fff\n`\nOverview\nReceptors are the decision-making components in Whizbang They receive commands, apply business rules, and emit events representing the decisions made In v0 1 0, receptors are stateless and focus on simple command-to-event transformation What is a Receptor A Receptor:\nReceives commands from the dispatcher\nValidates business rules\nDecides what should happen\nEmits events representing decisions\nNever performs side effects directly\nThink of a receptor as a pure decision function: given a command, what event(s) should occur Core Interface (v0 1",
        "startIndex": 0,
        "preview": "Receptors Component Version Status Next Update\nVersion History\n:::new\nNew in v0 1 0: Type-safe receptors with async support and automatic multi-destin..."
      },
      {
        "id": "v0.1.0/components/receptors-chunk-1",
        "text": "simple command-to-event transformation What is a Receptor A Receptor: Receives commands from the dispatcher Validates business rules Decides what should happen Emits events representing decisions Never performs side effects directly Think of a receptor as a pure decision function: given a command, what event(s) should occur Core Interface (v0 1 0)\n:::new\nThe type-safe receptor interface with generic message and response types:\n:::\n`csharp\npublic interface IReceptor<TMessage, TResponse> {\n    Task<TResponse> Receive(TMessage message);\n}\n`\nKey Features\nType Safety: Compile-time checking for message and response types\nAsync Support: All operations return Task<TResponse> for async handling\nMulti-Destination: Multiple receptors can handle the same message type\nZero Reflection: Source generation provides maximum performance\nResponse Type Flexibility\nReceptors support flexible response types:\n| Response Type | Behavior | Example |\n|---------------|----------|---------|\n| Single Response | Return typed response | Task<OrderCreated> |\n| Tuple Response | Return multiple related responses | Task<(PaymentProcessed, AuditEvent)> |\n| Array Response | Return dynamic number of responses | Task<NotificationEvent[]> |\n| Result Type | Success/failure handling | Task<Result<OrderCreated>> |\nStateless Implementation\n:::new\nIn v0 1 0, all receptors are stateless and get any needed state from parameters:\n:::\n`csharp\n[WhizbangHandler]  // Source generator discovers this\npublic class OrderReceptor : IReceptor<CreateOrder, OrderCreated> {\n    public async Task<OrderCreated> Receive(CreateOrder cmd) {\n        // Simple validation\n        if (cmd Items Count == 0) {\n            throw new InvalidOperationException(\"Order must have items\");\n        }\n        // Make decision and return response\n        return new OrderCreated(\n            OrderId: Guid NewGuid(),\n            CustomerId: cmd CustomerId,\n            Items: cmd Items,\n            Total: cmd Items Sum(i => i Quantity * i Price),\n            CreatedAt: DateTimeOffset",
        "startIndex": 1492,
        "preview": "simple command-to-event transformation What is a Receptor A Receptor: Receives commands from the dispatcher Validates business rules Decides what shou..."
      },
      {
        "id": "v0.1.0/components/receptors-chunk-2",
        "text": "Receive(CreateOrder cmd) { // Simple validation if (cmd Items Count == 0) { throw new InvalidOperationException(\"Order must have items\"); } // Make decision and return response return new OrderCreated( OrderId: Guid NewGuid(), CustomerId: cmd CustomerId, Items: cmd Items, Total: cmd Items Sum(i => i Quantity * i Price), CreatedAt: DateTimeOffset UtcNow\n        );\n    }\n}\n`\nMulti-Destination Routing\n:::new\nKey Feature: Multiple receptors can handle the same message type, running automatically in parallel:\n:::\n`csharp\n// Multiple receptors can handle the same message type\npublic class OrderBusinessReceptor : IReceptor<CreateOrder, OrderCreated> {\n    public async Task<OrderCreated> Receive(CreateOrder cmd) {\n        // Main business logic\n        var order = await ProcessOrder(cmd);\n        return new OrderCreated(order Id, order Items);\n    }\n}\npublic class OrderAuditReceptor : IReceptor<CreateOrder, AuditEvent> {\n    public async Task<AuditEvent> Receive(CreateOrder cmd) {\n        // Compliance logging runs in parallel\n        await _auditLog Record(\"OrderCreationAttempt\", cmd);\n        return new AuditEvent(\"OrderCreationAttempt\", cmd OrderId);\n    }\n}\npublic class OrderFraudReceptor : IReceptor<CreateOrder, FraudCheckResult> {\n    public async Task<FraudCheckResult> Receive(CreateOrder cmd) {\n        // Fraud detection runs in parallel\n        var riskScore = await _fraudEngine Analyze(cmd);\n        return new FraudCheckResult(cmd OrderId, riskScore);\n    }\n}\n// Framework automatically routes CreateOrder to all three receptors\n// All run in parallel, each returning their specific response type\n`\nWorking with Lenses\nFor queries, receptors can receive lens parameters:\n`csharp\npublic class OrderUpdateReceptor : IReceptor<UpdateOrder, OrderUpdated> {\n    public async Task<OrderUpdated> Receive(UpdateOrder cmd, IOrderLens lens) {\n        // Use lens to query current state (read-only)\n        var currentOrder = await lens Focus(cmd OrderId);\n        if (currentOrder == null) {\n            throw new OrderNotFoundException(cmd OrderId);\n        }\n        if (currentOrder Status == OrderStatus Shipped) {\n            throw new InvalidOperationException(\"Cannot update shipped order\");\n        }\n        // Return response based on decision\n        return new OrderUpdated(\n            OrderId: cmd OrderId,\n            Changes: cmd Changes,\n            UpdatedAt: DateTimeOffset",
        "startIndex": 3180,
        "preview": "Receive(CreateOrder cmd) { // Simple validation if (cmd Items Count == 0) { throw new InvalidOperationException(\"Order must have items\"); } // Make de..."
      },
      {
        "id": "v0.1.0/components/receptors-chunk-3",
        "text": "state (read-only) var currentOrder = await lens Focus(cmd OrderId); if (currentOrder == null) { throw new OrderNotFoundException(cmd OrderId); } if (currentOrder Status == OrderStatus Shipped) { throw new InvalidOperationException(\"Cannot update shipped order\"); } // Return response based on decision return new OrderUpdated( OrderId: cmd OrderId, Changes: cmd Changes, UpdatedAt: DateTimeOffset UtcNow\n        );\n    }\n}\n`\nFlexible Response Types\nReceptors can return single responses, tuples, or arrays:\n`csharp\n// Single response\npublic class OrderReceptor : IReceptor<CreateOrder, OrderCreated> {\n    public async Task<OrderCreated> Receive(CreateOrder cmd) {\n        return new OrderCreated(cmd OrderId);\n    }\n}\n// Multiple responses via tuple\npublic class PaymentReceptor : IReceptor<ProcessPayment, (PaymentProcessed, AuditEvent)> {\n    public async Task<(PaymentProcessed, AuditEvent)> Receive(ProcessPayment cmd) {\n        var payment = await ProcessPayment(cmd);\n        return (\n            new PaymentProcessed(payment Id),\n            new AuditEvent(\"PaymentProcessed\", payment Id)\n        );\n    }\n}\n// Array for dynamic responses\npublic class NotificationReceptor : IReceptor<OrderCreated, NotificationEvent[]> {\n    public async Task<NotificationEvent[]> Receive(OrderCreated evt) {\n        var notifications = new List<NotificationEvent>();\n        notifications Add(new EmailSent(evt CustomerId));\n        if (evt Total > 1000) {\n            notifications Add(new HighValueAlert(evt OrderId));\n        }\n        return notifications ToArray();\n    }\n}\n`\nError Handling\nUse Result<T> for explicit success/failure:\n`csharp\npublic class OrderCancelReceptor : IReceptor<CancelOrder, Result<OrderCancelled>> {\n    public async Task<Result<OrderCancelled>> Receive(CancelOrder cmd, IOrderLens lens) {\n        var order = await lens Focus(cmd OrderId);\n        if (order == null) {\n            return Result Failure<OrderCancelled>(\"Order not found\");\n        }\n        if (order Status == OrderStatus Shipped) {\n            return Result Failure<OrderCancelled>(\"Cannot cancel shipped order\");\n        }\n        return Result Success(new OrderCancelled(cmd OrderId));\n    }\n}\n`\nSource Generation\n:::new\nReceptors are discovered at compile time via source generators:\n:::\n`csharp\n// Generated by Whizbang Generators\npublic static partial class WhizbangGenerated {\n    public static void RegisterReceptors(IServiceCollection services) {\n        services AddScoped<IReceptor<CreateOrder, OrderCreated>, OrderReceptor>();\n        services AddScoped<IReceptor<CreateOrder, AuditEvent>, OrderAuditReceptor>();\n        services AddScoped<IReceptor<CreateOrder, FraudCheckResult>, OrderFraudReceptor>();\n        services AddScoped<IReceptor<UpdateOrder, OrderUpdated>, OrderUpdateReceptor>();\n        services",
        "startIndex": 5241,
        "preview": "state (read-only) var currentOrder = await lens Focus(cmd OrderId); if (currentOrder == null) { throw new OrderNotFoundException(cmd OrderId); } if (c..."
      },
      {
        "id": "v0.1.0/components/receptors-chunk-4",
        "text": "} ` Source Generation :::new Receptors are discovered at compile time via source generators: ::: `csharp // Generated by Whizbang Generators public static partial class WhizbangGenerated { public static void RegisterReceptors(IServiceCollection services) { services AddScoped<IReceptor<CreateOrder, OrderCreated>, OrderReceptor>(); services AddScoped<IReceptor<CreateOrder, AuditEvent>, OrderAuditReceptor>(); services AddScoped<IReceptor<CreateOrder, FraudCheckResult>, OrderFraudReceptor>(); services AddScoped<IReceptor<UpdateOrder, OrderUpdated>, OrderUpdateReceptor>(); services AddScoped<IReceptor<CancelOrder, Result<OrderCancelled>>, OrderCancelReceptor>();\n    }\n}\n`\nPolicy Application\n:::new\nPolicies can be applied to receptors via attributes:\n:::\n`csharp\n[Retry(3, BackoffStrategy Exponential)]\n[Timeout(5000)]\n[CircuitBreaker(0 5, TimeoutSeconds = 30)]\npublic class PaymentReceptor : IReceptor<ProcessPayment, PaymentProcessed> {\n    public async Task<PaymentProcessed> Receive(ProcessPayment cmd) {\n        // Policies are applied automatically by the dispatcher\n        var result = await ProcessPaymentAsync(cmd);\n        return new PaymentProcessed(cmd PaymentId, result Amount);\n    }\n}\n`\nTesting Receptors\n`csharp\n[Test]\npublic class OrderReceptorTests {\n    private OrderReceptor _receptor;\n    [SetUp]\n    public void Setup() {\n        _receptor = new OrderReceptor();\n    }\n    [Test]\n    public async Task CreateOrder_WithItems_ShouldReturnOrderCreated() {\n        // Arrange\n        var command = new CreateOrder(\n            CustomerId: Guid NewGuid(),\n            Items: new[] { new OrderItem(\"SKU-001\", 2, 29 99m) }\n        );\n        // Act\n        var result = await _receptor Receive(command);\n        // Assert\n        Assert IsType<OrderCreated>(result);\n        Assert NotEqual(Guid Empty, result OrderId);\n        Assert Equal(59 98m, result Total);\n    }\n    [Test]\n    public async Task CreateOrder_WithNoItems_ShouldThrow() {\n        // Arrange\n        var command = new CreateOrder(\n            CustomerId: Guid NewGuid(),\n            Items: Array Empty<OrderItem>()\n        );\n        // Act & Assert\n        await Assert ThrowsAsync<InvalidOperationException>(\n            () => _receptor Receive(command)\n        );\n    }\n}\n`\nIDE Features\nThe IDE provides rich support for receptors:\n`csharp\n// IDE shows: \"Handles: CreateOrder → OrderCreated | Type-safe async receptor\"\npublic class OrderReceptor : IReceptor<CreateOrder, OrderCreated> { }\n// IDE shows: \"3 receptors handle this message type\"\npublic record CreateOrder(Guid CustomerId, OrderItem[] Items);\n// IDE shows: \"Returned by: OrderReceptor Receive, OrderBusinessReceptor",
        "startIndex": 7660,
        "preview": "} ` Source Generation :::new Receptors are discovered at compile time via source generators: ::: `csharp // Generated by Whizbang Generators public st..."
      },
      {
        "id": "v0.1.0/components/receptors-chunk-5",
        "text": "The IDE provides rich support for receptors: `csharp // IDE shows: \"Handles: CreateOrder → OrderCreated | Type-safe async receptor\" public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> { } // IDE shows: \"3 receptors handle this message type\" public record CreateOrder(Guid CustomerId, OrderItem[] Items); // IDE shows: \"Returned by: OrderReceptor Receive, OrderBusinessReceptor Receive\"\npublic record OrderCreated(Guid OrderId, Guid CustomerId);\n`\nDispatcher Integration\nThe Dispatcher provides different ways to invoke receptors:\n`csharp\npublic interface IDispatcher {\n    // Inline async - wait for single response\n    Task<TResponse> Send<TResponse>(object message);\n    // Fire and forget - no response needed\n    Task Fire(object message);\n    // Callback - handle response asynchronously\n    Task SendWithCallback<TResponse>(object message, Func<TResponse, Task> callback);\n    // Multiple responses (from multiple receptors)\n    Task<IEnumerable<object>> SendAll(object message);\n}\n`\nUsage Examples\n`csharp\npublic class OrderController {\n    private readonly IDispatcher _dispatcher;\n    // Inline async - wait for result\n    public async Task<IActionResult> CreateOrder(CreateOrderRequest request) {\n        var command = new CreateOrder(request CustomerId, request Items);\n        var result = await _dispatcher Send<OrderCreated>(command);\n        return Ok(result);\n    }\n    // Fire and forget - audit logging\n    public async Task LogAction(string action) {\n        var auditCommand = new LogAuditEvent(action, GetUserId());\n        await _dispatcher Fire(auditCommand); // Don't wait for completion\n    }\n    // Multiple responses - get all results\n    public async Task<IActionResult> ProcessOrderWithAudit(CreateOrder command) {\n        var results = await _dispatcher SendAll(command);\n        var orderCreated = results OfType<OrderCreated>() Single();\n        var auditEvent = results OfType<AuditEvent>() Single();\n        var fraudResult = results OfType<FraudCheckResult>() Single();\n        return Ok(new { orderCreated, auditEvent, fraudResult });\n    }\n}\n`\nLimitations in v0 1 0\n:::info\nThese limitations are addressed in future versions:\n:::\nNo state management - Receptors cannot maintain state between calls\nBasic validation - Manual validation in code  \nLimited dependency injection - Cannot inject services directly into Receive method\nSingle message handling - Each receptor handles one message type\nMigration Path\nTo v0 2 0 (Non-Breaking)\n:::planned\nv0 2",
        "startIndex": 9747,
        "preview": "The IDE provides rich support for receptors: `csharp // IDE shows: \"Handles: CreateOrder → OrderCreated | Type-safe async receptor\" public class Order..."
      },
      {
        "id": "v0.1.0/components/receptors-chunk-6",
        "text": "versions: ::: No state management - Receptors cannot maintain state between calls Basic validation - Manual validation in code Limited dependency injection - Cannot inject services directly into Receive method Single message handling - Each receptor handles one message type Migration Path To v0 2 0 (Non-Breaking) :::planned v0 2 0 adds these enhancements without breaking existing code:\n:::\n`csharp\n// v0 1 0 - Current async interface\npublic async Task<OrderCreated> Receive(CreateOrder cmd) { }\n// v0 2 0 - Enhanced capabilities\npublic async Task<OrderCreated> Receive(\n    [Valid] CreateOrder cmd,      // Automatic validation\n    IOrderService service,        // Service injection\n    IMessageContext context       // Context injection\n) { }\n`\nTo v0 3 0 (Stateful Receptors)\n:::planned\nv0 3 0 introduces stateful receptors for event sourcing:\n:::\n`csharp\n// v0 3 0 - Stateful receptor\n[EventSourced]\npublic class OrderReceptor : IStatefulReceptor<Order> {\n    private Order state;  // Maintained from events\n    public OrderUpdated Receive(UpdateOrder cmd) {\n        // Can access state directly\n        if (state Status == OrderStatus Shipped) {\n            throw new InvalidOperationException();\n        }\n        return new OrderUpdated(state Id, cmd",
        "startIndex": 11856,
        "preview": "versions: ::: No state management - Receptors cannot maintain state between calls Basic validation - Manual validation in code Limited dependency inje..."
      },
      {
        "id": "v0.1.0/components/receptors-chunk-7",
        "text": "sourcing: ::: `csharp // v0 3 0 - Stateful receptor [EventSourced] public class OrderReceptor : IStatefulReceptor<Order> { private Order state; // Maintained from events public OrderUpdated Receive(UpdateOrder cmd) { // Can access state directly if (state Status == OrderStatus Shipped) { throw new InvalidOperationException(); } return new OrderUpdated(state Id, cmd Changes);\n    }\n}\n`\nPerformance Characteristics\n| Operation | Target | Actual |\n|-----------|--------|--------|\n| Receive invocation | < 100ns | TBD |\n| Event creation | < 50ns | TBD |\n| Validation | < 1μs | TBD |\n| Policy application | < 10μs | TBD |\nBest Practices\nKeep receptors pure - No side effects, only decisions\nReturn events - Always return events, not void\nValidate early - Check preconditions first\nUse meaningful names - OrderReceptor, not OrderHandler\nOne command type - Each receptor handles one command\nTest thoroughly - Unit test all paths\nRelated Documentation\nDispatcher - How commands reach receptors\nPerspectives - What happens to emitted events\nLenses - Querying state in receptors\nPolicy Engine - Applying policies to receptors\nTesting - Testing receptors\nNext Steps\nSee v0 2 0 Enhancements for validation and injection features\nSee v0 3 0 Stateful Receptors for event sourcing\nReview Examples for practical usage",
        "startIndex": 12784,
        "preview": "sourcing: ::: `csharp // v0 3 0 - Stateful receptor [EventSourced] public class OrderReceptor : IStatefulReceptor<Order> { private Order state; // Mai..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.1.0/components/transports",
    "title": "Transports Component",
    "category": "Components",
    "url": "/docs/v0.1.0/components/transports",
    "chunks": [
      {
        "id": "v0.1.0/components/transports-chunk-0",
        "text": "Transports Component Version Status Next Update\nVersion History\n:::new\nNew in v0 1 0: Basic in-process transport with synchronous message passing\n:::\n:::planned\nComing in v0 2 0: \nHTTP transport for REST APIs\nWebSocket support for real-time\nBasic message serialization\nSee HTTP features →\n:::\n:::planned\nComing in v0 3 0: \nMessage queue transports (RabbitMQ, Redis)\nPub/sub patterns\nMessage routing and topics\nSee messaging features →\n:::\nEvolution Timeline\n`mermaid\ngraph LR\n    v010[v0 1 0<br/>In-Process<br/>Sync] --> v020[v0 2 0<br/>HTTP<br/>WebSocket]\n    v020 --> v030[v0 3 0<br/>Queues<br/>Pub/Sub]\n    v030 --> v040[v0 4 0<br/>gRPC<br/>Streaming]\n    v040 --> v050[v0 5 0<br/>Cloud<br/>Federation]\n    style v010 fill:#4CAF50,color:#fff\n    style v020 fill:#2196F3,color:#fff\n    style v030 fill:#FF9800,color:#fff\n    style v040 fill:#795548,color:#fff\n    style v050 fill:#9C27B0,color:#fff\n`\nOverview\nTransports provide the communication layer in Whizbang, enabling message exchange between components In v0 1 0, we provide a simple in-process transport that passes messages directly in memory - perfect for monolithic applications and testing What is a Transport A Transport:\nCarries messages between components\nHandles serialization and deserialization\nManages connections and channels\nProvides delivery guarantees\nThink of transports as the postal service of your application - they ensure messages get from sender to receiver reliably Core Interface (v0 1 0)\n:::new\nThe basic transport interface for message passing:\n:::\n`csharp\npublic interface ITransport {\n    // Send a message\n    Task<TResponse> Send<TRequest, TResponse>(TRequest request, string destination)\n        where TRequest : IMessage\n        where TResponse : IMessage;\n    // Send without response\n    Task Publish<TMessage>(TMessage message, string topic)\n        where TMessage : IMessage;\n    // Subscribe to messages\n    Task Subscribe<TMessage>(string topic, Func<TMessage, Task> handler)\n        where TMessage : IMessage;\n    // Transport metadata\n    string Name { get; }\n    TransportCapabilities Capabilities { get; }\n}\npublic enum TransportCapabilities {\n    None = 0,\n    RequestResponse = 1,\n    PublishSubscribe = 2,\n    Streaming = 4,\n    Reliable = 8,\n    Ordered = 16\n}\n`\nIn-Process Transport\n:::new\nThe default in-process transport for v0 1",
        "startIndex": 0,
        "preview": "Transports Component Version Status Next Update\nVersion History\n:::new\nNew in v0 1 0: Basic in-process transport with synchronous message passing\n:::\n..."
      },
      {
        "id": "v0.1.0/components/transports-chunk-1",
        "text": ": IMessage; // Transport metadata string Name { get; } TransportCapabilities Capabilities { get; } } public enum TransportCapabilities { None = 0, RequestResponse = 1, PublishSubscribe = 2, Streaming = 4, Reliable = 8, Ordered = 16 } ` In-Process Transport :::new The default in-process transport for v0 1 0:\n:::\n`csharp\n[WhizbangTransport(\"InProcess\")]\npublic class InProcessTransport : ITransport {\n    private readonly Dictionary<string, object> _handlers = new();\n    private readonly Dictionary<string, List<Func<object, Task>>> _subscribers = new();\n    private readonly object _lock = new();\n    public string Name => \"InProcess\";\n    public TransportCapabilities Capabilities => \n        TransportCapabilities RequestResponse | \n        TransportCapabilities PublishSubscribe |\n        TransportCapabilities Ordered;\n    // Register a handler for request/response\n    public void RegisterHandler<TRequest, TResponse>(\n        string destination, \n        Func<TRequest, Task<TResponse>> handler)\n        where TRequest : IMessage\n        where TResponse : IMessage {\n        lock (_lock) {\n            _handlers[destination] = handler;\n        }\n    }\n    public async Task<TResponse> Send<TRequest, TResponse>(\n        TRequest request, \n        string destination)\n        where TRequest : IMessage\n        where TResponse : IMessage {\n        object handler;\n        lock (_lock) {\n            if ( _handlers TryGetValue(destination, out handler )) {\n                throw new TransportException($\"No handler registered for {destination}\");\n            }\n        }\n        var typedHandler = (Func<TRequest, Task<TResponse>>)handler;\n        return await typedHandler(request);\n    }\n    public async Task Publish<TMessage>(TMessage message, string topic)\n        where TMessage : IMessage {\n        List<Func<object, Task>> subscribers;\n        lock (_lock) {\n            if ( _subscribers TryGetValue(topic, out subscribers )) {\n                return; // No subscribers\n            }\n            subscribers = subscribers ToList(); // Copy to avoid lock during execution\n        }\n        // Execute all subscribers\n        var tasks = subscribers Select(sub => sub(message ));\n        await Task WhenAll(tasks);\n    }\n    public Task Subscribe<TMessage>(string topic, Func<TMessage, Task> handler)\n        where TMessage : IMessage {\n        lock (_lock) {\n            if ( _subscribers ContainsKey(topic)) {\n                _subscribers[topic] = new List<Func<object, Task>>();\n            }\n            _subscribers[topic] Add(async obj => await handler((TMessage)obj));\n        }\n        return Task",
        "startIndex": 2347,
        "preview": ": IMessage; // Transport metadata string Name { get; } TransportCapabilities Capabilities { get; } } public enum TransportCapabilities { None = 0, Req..."
      },
      {
        "id": "v0.1.0/components/transports-chunk-2",
        "text": "Execute all subscribers var tasks = subscribers Select(sub => sub(message )); await Task WhenAll(tasks); } public Task Subscribe<TMessage>(string topic, Func<TMessage, Task> handler) where TMessage : IMessage { lock (_lock) { if ( _subscribers ContainsKey(topic)) { _subscribers[topic] = new List<Func<object, Task>>(); } _subscribers[topic] Add(async obj => await handler((TMessage)obj)); } return Task CompletedTask;\n    }\n}\n`\nMessage Contracts\n:::new\nDefine messages for transport:\n:::\n`csharp\npublic interface IMessage {\n    Guid Id { get; }\n    DateTimeOffset Timestamp { get; }\n    Dictionary<string, string> Headers { get; }\n}\npublic abstract record Message : IMessage {\n    public Guid Id { get; init; } = Guid NewGuid();\n    public DateTimeOffset Timestamp { get; init; } = DateTimeOffset UtcNow;\n    public Dictionary<string, string> Headers { get; init; } = new();\n}\n// Command message\npublic record CreateOrderCommand : Message {\n    public Guid CustomerId { get; init; }\n    public List<OrderItem> Items { get; init; }\n    public decimal Total { get; init; }\n}\n// Event message\npublic record OrderCreatedEvent : Message {\n    public Guid OrderId { get; init; }\n    public Guid CustomerId { get; init; }\n    public OrderStatus Status { get; init; }\n}\n// Query message\npublic record GetOrderQuery : Message {\n    public Guid OrderId { get; init; }\n}\n// Response message\npublic record OrderResponse : Message {\n    public Order Order { get; init; }\n    public bool Success { get; init; }\n    public string Error { get; init; }\n}\n`\nTransport Registration\nTransports are registered and configured at startup:\n`csharp\n// Manual registration\nservices AddWhizbangTransports(options => {\n    options UseInProcess();\n});\n// Register handlers\nservices AddTransportHandlers(handlers => {\n    handlers Handle<CreateOrderCommand, OrderCreatedEvent>(\"orders\", \n        async cmd => {\n            // Process command\n            return new OrderCreatedEvent { \n                OrderId = Guid NewGuid(),\n                CustomerId = cmd",
        "startIndex": 4659,
        "preview": "Execute all subscribers var tasks = subscribers Select(sub => sub(message )); await Task WhenAll(tasks); } public Task Subscribe<TMessage>(string topi..."
      },
      {
        "id": "v0.1.0/components/transports-chunk-3",
        "text": "} ` Transport Registration Transports are registered and configured at startup: `csharp // Manual registration services AddWhizbangTransports(options => { options UseInProcess(); }); // Register handlers services AddTransportHandlers(handlers => { handlers Handle<CreateOrderCommand, OrderCreatedEvent>(\"orders\", async cmd => { // Process command return new OrderCreatedEvent { OrderId = Guid NewGuid(), CustomerId = cmd CustomerId \n            };\n        });\n});\n// Source generated registration\npublic static partial class WhizbangGenerated {\n    public static void RegisterTransports(IServiceCollection services) {\n        services AddSingleton<ITransport, InProcessTransport>();\n        // Auto-discover and register handlers\n        services AddScoped<IHandler<CreateOrderCommand>, CreateOrderHandler>();\n    }\n}\n`\nUsing Transports\nIn Receptors\n`csharp\npublic class OrderReceptor : IReceptor<CreateOrder> {\n    private readonly ITransport _transport;\n    public OrderReceptor(ITransport transport) {\n        _transport = transport;\n    }\n    public async Task<OrderCreated> Receive(CreateOrder cmd) {\n        // Validate locally\n        if ( IsValid(cmd)) {\n            throw new ValidationException(\"Invalid order\");\n        }\n        // Send to inventory service (in-process for now)\n        var inventoryCommand = new CheckInventoryCommand {\n            Items = cmd Items\n        };\n        var inventoryResponse = await _transport Send<CheckInventoryCommand, InventoryResponse>(\n            inventoryCommand, \n            \"inventory\"\n        );\n        if ( inventoryResponse Available) {\n            throw new InsufficientInventoryException();\n        }\n        // Create order\n        var orderCreated = new OrderCreated {\n            OrderId = Guid NewGuid(),\n            CustomerId = cmd CustomerId,\n            Items = cmd Items\n        };\n        // Publish event\n        await _transport Publish(orderCreated, \"orders created\");\n        return orderCreated;\n    }\n}\n`\nEvent Subscriptions\n`csharp\npublic class NotificationService {\n    private readonly ITransport _transport;\n    public async Task Start() {\n        // Subscribe to order events\n        await _transport Subscribe<OrderCreatedEvent>(\n            \"orders created\",\n            HandleOrderCreated\n        );\n        await _transport Subscribe<OrderShippedEvent>(\n            \"orders shipped\",\n            HandleOrderShipped\n        );\n    }\n    private async Task HandleOrderCreated(OrderCreatedEvent evt) {\n        // Send confirmation email\n        await SendEmail(evt CustomerId, \"Order Confirmed\", \n            $\"Your order {evt OrderId} has been confirmed \");\n    }\n    private async Task HandleOrderShipped(OrderShippedEvent evt) {\n        // Send shipping notification\n        await SendEmail(evt CustomerId, \"Order Shipped\",\n            $\"Your order {evt OrderId} has been shipped \");\n    }\n}\n`\nMessage Pipeline\n:::new\nSimple message pipeline for v0 1",
        "startIndex": 6288,
        "preview": "} ` Transport Registration Transports are registered and configured at startup: `csharp // Manual registration services AddWhizbangTransports(options ..."
      },
      {
        "id": "v0.1.0/components/transports-chunk-4",
        "text": "email await SendEmail(evt CustomerId, \"Order Confirmed\", $\"Your order {evt OrderId} has been confirmed \"); } private async Task HandleOrderShipped(OrderShippedEvent evt) { // Send shipping notification await SendEmail(evt CustomerId, \"Order Shipped\", $\"Your order {evt OrderId} has been shipped \"); } } ` Message Pipeline :::new Simple message pipeline for v0 1 0:\n:::\n`csharp\npublic interface IMessagePipeline {\n    Task<TResponse> Process<TRequest, TResponse>(\n        TRequest request,\n        Func<TRequest, Task<TResponse>> next);\n}\npublic class MessagePipeline : IMessagePipeline {\n    private readonly List<IMessageMiddleware> _middleware = new();\n    public void Use(IMessageMiddleware middleware) {\n        _middleware Add(middleware);\n    }\n    public async Task<TResponse> Process<TRequest, TResponse>(\n        TRequest request,\n        Func<TRequest, Task<TResponse>> handler) {\n        // Build pipeline\n        Func<TRequest, Task<TResponse>> pipeline = handler;\n        foreach (var middleware in _middleware Reverse<IMessageMiddleware>()) {\n            var next = pipeline;\n            pipeline = async req => await middleware Process(req, () => next(req));\n        }\n        return await pipeline(request);\n    }\n}\n// Example middleware\npublic class LoggingMiddleware : IMessageMiddleware {\n    private readonly ILogger _logger;\n    public async Task<object> Process(object message, Func<Task<object>> next) {\n        _logger LogInformation(\"Processing {MessageType}\", message GetType() Name);\n        var start = Stopwatch StartNew();\n        try {\n            var result = await next();\n            _logger LogInformation(\"Processed in {ElapsedMs}ms\", start ElapsedMilliseconds);\n            return result;\n        }\n        catch (Exception ex) {\n            _logger LogError(ex, \"Failed after {ElapsedMs}ms\", start ElapsedMilliseconds);\n            throw;\n        }\n    }\n}\n`\nTesting with Transports\n`csharp\n[Test]\npublic class TransportTests {\n    private InProcessTransport _transport;\n    [SetUp]\n    public void Setup() {\n        _transport = new InProcessTransport();\n    }\n    [Test]\n    public async Task Send_ShouldInvokeHandler() {\n        // Arrange\n        var handlerCalled = false;\n        _transport RegisterHandler<TestCommand, TestResponse>(\n            \"test\",\n            async cmd => {\n                handlerCalled = true;\n                return new TestResponse { Success = true };\n            }\n        );\n        // Act\n        var response = await _transport Send<TestCommand, TestResponse>(\n            new TestCommand(),\n            \"test\"\n        );\n        // Assert\n        Assert True(handlerCalled);\n        Assert True(response Success);\n    }\n    [Test]\n    public async Task Publish_ShouldNotifyAllSubscribers() {\n        // Arrange\n        var received1 = false;\n        var received2 = false;\n        await _transport Subscribe<TestEvent>(\"test",
        "startIndex": 8806,
        "preview": "email await SendEmail(evt CustomerId, \"Order Confirmed\", $\"Your order {evt OrderId} has been confirmed \"); } private async Task HandleOrderShipped(Ord..."
      },
      {
        "id": "v0.1.0/components/transports-chunk-5",
        "text": "return new TestResponse { Success = true }; } ); // Act var response = await _transport Send<TestCommand, TestResponse>( new TestCommand(), \"test\" ); // Assert Assert True(handlerCalled); Assert True(response Success); } [Test] public async Task Publish_ShouldNotifyAllSubscribers() { // Arrange var received1 = false; var received2 = false; await _transport Subscribe<TestEvent>(\"test topic\", evt => {\n            received1 = true;\n            return Task CompletedTask;\n        });\n        await _transport Subscribe<TestEvent>(\"test topic\", evt => {\n            received2 = true;\n            return Task CompletedTask;\n        });\n        // Act\n        await _transport Publish(new TestEvent(), \"test topic\");\n        // Assert\n        Assert True(received1);\n        Assert True(received2);\n    }\n}\n`\nIDE Features\n`csharp\n// IDE shows: \"Transport: InProcess | Handlers: 12 | Subscribers: 34\"\npublic interface ITransport { }\n// IDE shows: \"Called 234 times | Avg: 0 5ms | Success: 99 8%\"\npublic Task<TResponse> Send<TRequest, TResponse>( ) { }\n// IDE shows: \"Topic: orders created | Subscribers: 3\"\npublic Task Publish<TMessage>(TMessage message, string topic) { }\n`\nPerformance Characteristics\n| Operation | Target | Actual |\n|-----------|--------|--------|\n| Send (in-process) | < 100ns | TBD |\n| Publish (10 subscribers) | < 1μs | TBD |\n| Subscribe | < 50ns | TBD |\n| Message serialization | N/A | N/A |\nLimitations in v0 1 0\n:::info\nThese limitations are addressed in future versions:\n:::\nIn-process only - No network communication\nNo persistence - Messages lost on crash\nNo serialization - Direct object passing\nNo retry - Failed messages are lost\nSingle instance - No distributed messaging\nMigration Path\nTo v0 2 0 (HTTP/WebSocket)\n:::planned\nv0 2 0 adds network transports:\n:::\n`csharp\n// v0 2 0 - HTTP transport\nservices AddWhizbangTransports(options => {\n    options UseHttp(http => {\n        http BaseUrl = \"https://api example com\";\n        http Timeout = TimeSpan FromSeconds(30);\n    });\n});\n`\nTo v0 3 0 (Message Queues)\n:::planned\nv0 3",
        "startIndex": 11346,
        "preview": "return new TestResponse { Success = true }; } ); // Act var response = await _transport Send<TestCommand, TestResponse>( new TestCommand(), \"test\" ); ..."
      },
      {
        "id": "v0.1.0/components/transports-chunk-6",
        "text": "2 0 (HTTP/WebSocket) :::planned v0 2 0 adds network transports: ::: `csharp // v0 2 0 - HTTP transport services AddWhizbangTransports(options => { options UseHttp(http => { http BaseUrl = \"https://api example com\"; http Timeout = TimeSpan FromSeconds(30); }); }); ` To v0 3 0 (Message Queues) :::planned v0 3 0 adds message queue support:\n:::\n`csharp\n// v0 3 0 - RabbitMQ transport\nservices AddWhizbangTransports(options => {\n    options UseRabbitMQ(rabbit => {\n        rabbit ConnectionString = \"amqp://localhost\";\n        rabbit ExchangeName = \"whizbang\";\n    });\n});\n`\nBest Practices\nDesign for distribution - Even with in-process, assume network\nUse message contracts - Define clear message schemas\nHandle failures - Plan for transport failures\nVersion messages - Plan for message evolution\nKeep messages small - Large messages impact performance\nTest with different transports - Ensure transport agnostic code\nRelated Documentation\nDispatcher - How messages are routed\nReceptors - Message handlers\nTesting - Testing with transports\nFeature Evolution - How transports evolve\nNext Steps\nSee v0 2 0 HTTP Transport for REST APIs\nSee v0 3 0 Message Queues for async messaging\nReview Examples for transport patterns",
        "startIndex": 13016,
        "preview": "2 0 (HTTP/WebSocket) :::planned v0 2 0 adds network transports: ::: `csharp // v0 2 0 - HTTP transport services AddWhizbangTransports(options => { opt..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.2.0/_folder",
    "title": "Version 0.2.0 - Event-Driven Enhancement",
    "category": "General",
    "url": "/docs/v0.2.0/_folder",
    "chunks": [
      {
        "id": "v0.2.0/_folder-chunk-0",
        "text": "",
        "startIndex": 0,
        "preview": ""
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.2.0/enhancements/dispatcher",
    "title": "Pipeline & Middleware Dispatcher",
    "category": "Enhancements",
    "url": "/docs/v0.2.0/enhancements/dispatcher",
    "chunks": [
      {
        "id": "v0.2.0/enhancements/dispatcher-chunk-0",
        "text": "Pipeline & Middleware Dispatcher Version Status Next Update\nVersion History\n:::updated\nEnhanced in v0 2 0: \nMiddleware pipeline for cross-cutting concerns\nParallel perspective execution\nHandler prioritization and ordering\nPre/post processing hooks\n:::\n:::planned\nComing in v0 3 0: \nSaga orchestration and workflows\nCompensation and rollback support\nStateful process management\nSee orchestration features →\n:::\nNew Features in v0 2 0\nMiddleware Pipeline\n:::new\nComposable middleware for message processing:\n:::\n`csharp\npublic interface IDispatcherMiddleware {\n    Task<TResult> Execute<TCommand, TResult>(\n        TCommand command,\n        DispatcherContext context,\n        Func<TCommand, DispatcherContext, Task<TResult>> next)\n        where TCommand : ICommand;\n}\npublic class PipelineDispatcher : IDispatcher {\n    private readonly List<IDispatcherMiddleware> _middleware;\n    private readonly IDispatcher _inner;\n    public PipelineDispatcher(IDispatcher inner) {\n        _inner = inner;\n        _middleware = new List<IDispatcherMiddleware>();\n    }\n    public void Use(IDispatcherMiddleware middleware) {\n        _middleware Add(middleware);\n    }\n    public async Task<TResult> Send<TResult>(ICommand<TResult> command) {\n        var context = new DispatcherContext {\n            MessageId = Guid NewGuid(),\n            Timestamp = DateTimeOffset UtcNow,\n            User = GetCurrentUser(),\n            Metadata = new Dictionary<string, object>()\n        };\n        // Build pipeline\n        Func<ICommand<TResult>, DispatcherContext, Task<TResult>> pipeline = \n            async (cmd, ctx) => await _inner Send(cmd);\n        // Wrap with middleware in reverse order\n        foreach (var middleware in _middleware AsEnumerable() Reverse()) {\n            var next = pipeline;\n            pipeline = async (cmd, ctx) => \n                await middleware Execute(cmd, ctx, \n                    async (c, cx) => await next(c, cx));\n        }\n        return await pipeline(command, context);\n    }\n}\n`\nBuilt-in Middleware\n:::new\nCommon middleware implementations:\n:::\n`csharp\n// Logging middleware\npublic class LoggingMiddleware : IDispatcherMiddleware {\n    private readonly ILogger<LoggingMiddleware> _logger;\n    public async Task<TResult> Execute<TCommand, TResult>(\n        TCommand command,\n        DispatcherContext context,\n        Func<TCommand, DispatcherContext, Task<TResult>> next) {\n        _logger LogInformation(\n            \"Executing {CommandType} with ID {MessageId}\",\n            typeof(TCommand) Name,\n            context MessageId);\n        var stopwatch = Stopwatch StartNew();\n        try {\n            var result = await next(command, context);\n            _logger LogInformation(\n                \"Executed {CommandType} in {ElapsedMs}ms\",\n                typeof(TCommand) Name,\n                stopwatch ElapsedMilliseconds);\n            return result;\n        }\n        catch (Exception ex) {\n            _logger LogError(ex,\n                \"Failed {CommandType} after {ElapsedMs}ms\",\n                typeof(TCommand) Name,\n                stopwatch",
        "startIndex": 0,
        "preview": "Pipeline & Middleware Dispatcher Version Status Next Update\nVersion History\n:::updated\nEnhanced in v0 2 0: \nMiddleware pipeline for cross-cutting conc..."
      },
      {
        "id": "v0.2.0/enhancements/dispatcher-chunk-1",
        "text": "_logger LogInformation( \"Executing {CommandType} with ID {MessageId}\", typeof(TCommand) Name, context MessageId); var stopwatch = Stopwatch StartNew(); try { var result = await next(command, context); _logger LogInformation( \"Executed {CommandType} in {ElapsedMs}ms\", typeof(TCommand) Name, stopwatch ElapsedMilliseconds); return result; } catch (Exception ex) { _logger LogError(ex, \"Failed {CommandType} after {ElapsedMs}ms\", typeof(TCommand) Name, stopwatch ElapsedMilliseconds);\n            throw;\n        }\n    }\n}\n// Validation middleware\npublic class ValidationMiddleware : IDispatcherMiddleware {\n    private readonly IValidator _validator;\n    public async Task<TResult> Execute<TCommand, TResult>(\n        TCommand command,\n        DispatcherContext context,\n        Func<TCommand, DispatcherContext, Task<TResult>> next) {\n        // Validate command\n        var validationResult = await _validator Validate(command);\n        if ( validationResult IsValid) {\n            throw new ValidationException(validationResult Errors);\n        }\n        // Add validation metadata\n        context Metadata[\"ValidationTime\"] = DateTimeOffset UtcNow;\n        context Metadata[\"ValidatorVersion\"] = _validator Version;\n        return await next(command, context);\n    }\n}\n// Transaction middleware\npublic class TransactionMiddleware : IDispatcherMiddleware {\n    public async Task<TResult> Execute<TCommand, TResult>(\n        TCommand command,\n        DispatcherContext context,\n        Func<TCommand, DispatcherContext, Task<TResult>> next) {\n        using var transaction = new TransactionScope(\n            TransactionScopeOption Required,\n            new TransactionOptions { \n                IsolationLevel = IsolationLevel ReadCommitted \n            },\n            TransactionScopeAsyncFlowOption Enabled);\n        var result = await next(command, context);\n        transaction Complete();\n        return result;\n    }\n}\n// Caching middleware\npublic class CachingMiddleware : IDispatcherMiddleware {\n    private readonly IMemoryCache _cache;\n    public async Task<TResult> Execute<TCommand, TResult>(\n        TCommand command,\n        DispatcherContext context,\n        Func<TCommand, DispatcherContext, Task<TResult>> next) {\n        // Check if command is cacheable\n        if (command is ICacheable cacheable) {\n            var cacheKey = cacheable GetCacheKey();\n            if (_cache TryGetValue<TResult>(cacheKey, out var cached)) {\n                context Metadata[\"CacheHit\"] = true;\n                return cached;\n            }\n            var result = await next(command, context);\n            _cache Set(cacheKey, result, cacheable GetCacheDuration());\n            context Metadata[\"CacheHit\"] = false;\n            return result;\n        }\n        return await next(command, context);\n    }\n}\n`\nParallel Perspective Execution\n:::new\nExecute perspectives concurrently for better performance:\n:::\n`csharp\npublic class ParallelEventPublisher : IEventPublisher {\n    private readonly IServiceProvider _serviceProvider;\n    private readonly ParallelOptions _parallelOptions;\n    public ParallelEventPublisher(IServiceProvider serviceProvider, DispatcherOptions options) {\n        _serviceProvider = serviceProvider;\n        _parallelOptions = new ParallelOptions {\n            MaxDegreeOfParallelism = options",
        "startIndex": 3083,
        "preview": "_logger LogInformation( \"Executing {CommandType} with ID {MessageId}\", typeof(TCommand) Name, context MessageId); var stopwatch = Stopwatch StartNew()..."
      },
      {
        "id": "v0.2.0/enhancements/dispatcher-chunk-2",
        "text": "return await next(command, context); } } ` Parallel Perspective Execution :::new Execute perspectives concurrently for better performance: ::: `csharp public class ParallelEventPublisher : IEventPublisher { private readonly IServiceProvider _serviceProvider; private readonly ParallelOptions _parallelOptions; public ParallelEventPublisher(IServiceProvider serviceProvider, DispatcherOptions options) { _serviceProvider = serviceProvider; _parallelOptions = new ParallelOptions { MaxDegreeOfParallelism = options MaxEventParallelism\n        };\n    }\n    public async Task Publish<TEvent>(TEvent @event) where TEvent : IEvent {\n        var perspectiveTypes = WhizbangGenerated GetPerspectivesFor<TEvent>();\n        if ( perspectiveTypes Any()) return;\n        // Execute perspectives in parallel\n        await Parallel ForEachAsync(\n            perspectiveTypes,\n            _parallelOptions,\n            async (perspectiveType, ct) => {\n                try {\n                    using var scope = _serviceProvider CreateScope();\n                    var perspective = scope ServiceProvider GetRequiredService(perspectiveType) as IPerspectiveOf<TEvent>;\n                    await perspective Update(@event);\n                }\n                catch (Exception ex) {\n                    // Log but don't fail other perspectives\n                    _logger LogError(ex,\n                        \"Perspective {PerspectiveType} failed for event {EventType}\",\n                        perspectiveType Name,\n                        typeof(TEvent) Name);\n                }\n            });\n    }\n}\n`\nHandler Prioritization\n:::new\nControl execution order with priorities:\n:::\n`csharp\n[AttributeUsage(AttributeTargets Class)]\npublic class HandlerPriorityAttribute : Attribute {\n    public int Priority { get; }\n    public HandlerPriorityAttribute(int priority) => Priority = priority;\n}\n[HandlerPriority(100)]  // High priority - executes first\npublic class CriticalPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated @event) {\n        // Critical update that must happen first\n    }\n}\n[HandlerPriority(50)]   // Medium priority\npublic class StandardPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated @event) {\n        // Standard processing\n    }\n}\n[HandlerPriority(10)]   // Low priority - executes last\npublic class AnalyticsPerspective : IPerspectiveOf<OrderCreated> {\n    public async Task Update(OrderCreated @event) {\n        // Analytics can happen later\n    }\n}\n// Source generator orders handlers by priority\npublic static partial class WhizbangGenerated {\n    public static List<Type> GetPerspectivesFor<TEvent>() {\n        return _eventHandlers[typeof(TEvent)] OrderByDescending(h => GetPriority(h)) ToList();\n    }\n    private static int GetPriority(Type handlerType) {\n        var attribute = handlerType GetCustomAttribute<HandlerPriorityAttribute>();\n        return attribute Priority",
        "startIndex": 5944,
        "preview": "return await next(command, context); } } ` Parallel Perspective Execution :::new Execute perspectives concurrently for better performance: ::: `csharp..."
      },
      {
        "id": "v0.2.0/enhancements/dispatcher-chunk-3",
        "text": "Task Update(OrderCreated @event) { // Analytics can happen later } } // Source generator orders handlers by priority public static partial class WhizbangGenerated { public static List<Type> GetPerspectivesFor<TEvent>() { return _eventHandlers[typeof(TEvent)] OrderByDescending(h => GetPriority(h)) ToList(); } private static int GetPriority(Type handlerType) { var attribute = handlerType GetCustomAttribute<HandlerPriorityAttribute>(); return attribute Priority 50; // Default priority\n    }\n}\n`\nPre/Post Processing Hooks\n:::new\nHooks for before and after message processing:\n:::\n`csharp\npublic interface IDispatcherHooks {\n    Task OnBeforeDispatch<TCommand>(TCommand command, DispatcherContext context);\n    Task OnAfterDispatch<TCommand, TResult>(TCommand command, TResult result, DispatcherContext context);\n    Task OnDispatchError<TCommand>(TCommand command, Exception error, DispatcherContext context);\n}\npublic class MetricsHooks : IDispatcherHooks {\n    private readonly IMetrics _metrics;\n    public Task OnBeforeDispatch<TCommand>(TCommand command, DispatcherContext context) {\n        _metrics StartTimer($\"command {typeof(TCommand) Name}\", context MessageId);\n        return Task CompletedTask;\n    }\n    public Task OnAfterDispatch<TCommand, TResult>(TCommand command, TResult result, DispatcherContext context) {\n        var duration = _metrics StopTimer(context MessageId);\n        _metrics RecordHistogram($\"command {typeof(TCommand) Name} duration\", duration);\n        _metrics Increment($\"command {typeof(TCommand) Name} success\");\n        return Task CompletedTask;\n    }\n    public Task OnDispatchError<TCommand>(TCommand command, Exception error, DispatcherContext context) {\n        _metrics StopTimer(context MessageId);\n        _metrics Increment($\"command {typeof(TCommand) Name} failure\");\n        _metrics RecordError(error);\n        return Task CompletedTask;\n    }\n}\n`\nConfiguration\n`csharp\n// Configure enhanced dispatcher\nservices AddWhizbangDispatcher(options => {\n    // Enable parallel event publishing\n    options ParallelEventPublishing = true;\n    options MaxEventParallelism = 10;\n    // Configure middleware pipeline\n    options Pipeline(pipeline => {\n        pipeline Use<LoggingMiddleware>();\n        pipeline Use<ValidationMiddleware>();\n        pipeline Use<TransactionMiddleware>();\n        pipeline Use<CachingMiddleware>();\n        pipeline Use<MetricsMiddleware>();\n    });\n    // Add hooks\n    options AddHooks<MetricsHooks>();\n    options AddHooks<AuditHooks>();\n    // Configure timeout\n    options DefaultTimeout = TimeSpan FromSeconds(30);\n});\n`\nMiddleware Development Guide\nCreating Custom Middleware\n`csharp\npublic class CustomMiddleware : IDispatcherMiddleware {\n    // 1 Inject dependencies\n    private readonly ICustomService _service;\n    public CustomMiddleware(ICustomService service) {\n        _service = service;\n    }\n    // 2 Implement Execute method\n    public async Task<TResult> Execute<TCommand, TResult>(\n        TCommand command,\n        DispatcherContext context,\n        Func<TCommand, DispatcherContext, Task<TResult>> next) {\n        // 3 Pre-processing\n        await _service BeforeCommand(command);\n        // 4 Optionally modify context\n        context",
        "startIndex": 8444,
        "preview": "Task Update(OrderCreated @event) { // Analytics can happen later } } // Source generator orders handlers by priority public static partial class Whizb..."
      },
      {
        "id": "v0.2.0/enhancements/dispatcher-chunk-4",
        "text": ": IDispatcherMiddleware { // 1 Inject dependencies private readonly ICustomService _service; public CustomMiddleware(ICustomService service) { _service = service; } // 2 Implement Execute method public async Task<TResult> Execute<TCommand, TResult>( TCommand command, DispatcherContext context, Func<TCommand, DispatcherContext, Task<TResult>> next) { // 3 Pre-processing await _service BeforeCommand(command); // 4 Optionally modify context context Metadata[\"CustomValue\"] = \"example\";\n        try {\n            // 5 Call next middleware or handler\n            var result = await next(command, context);\n            // 6 Post-processing\n            await _service AfterCommand(command, result);\n            return result;\n        }\n        catch (Exception ex) {\n            // 7 Error handling\n            await _service OnError(command, ex);\n            throw; // or handle/transform\n        }\n    }\n}\n`\nTesting Enhanced Dispatcher\n`csharp\n[Test]\npublic class PipelineDispatcherTests {\n    [Test]\n    public async Task Middleware_ShouldExecuteInOrder() {\n        // Arrange\n        var executionOrder = new List<string>();\n        var dispatcher = new PipelineDispatcher(new InMemoryDispatcher());\n        dispatcher Use(new TestMiddleware(\"First\", executionOrder));\n        dispatcher Use(new TestMiddleware(\"Second\", executionOrder));\n        dispatcher Use(new TestMiddleware(\"Third\", executionOrder));\n        // Act\n        await dispatcher Send(new TestCommand());\n        // Assert\n        Assert That(executionOrder, Is EqualTo(new[] { \n            \"First:Before\", \"Second:Before\", \"Third:Before\",\n            \"Third:After\", \"Second:After\", \"First:After\"\n        }));\n    }\n    [Test]\n    public async Task ParallelPublishing_ShouldExecuteConcurrently() {\n        // Test parallel perspective execution\n    }\n}\n`\nPerformance Improvements\n| Feature | v0 1 0 | v0 2 0 | Improvement |\n|---------|--------|--------|-------------|\n| Event Publishing (10 handlers) | Sequential ~10ms | Parallel ~2ms | 5x faster |\n| Middleware Overhead | N/A | < 100ns per middleware | Minimal |\n| Cache Hit | N/A | < 50ns | N/A |\n| Priority Sorting | N/A | < 1μs | Compile-time optimized |\nMigration from v0 1 0\nAdding Middleware\n`csharp\n// v0 1 0 - Basic dispatcher\nservices AddWhizbangDispatcher();\n// v0 2 0 - Enhanced with middleware\nservices AddWhizbangDispatcher(options => {\n    options Pipeline(pipeline => {\n        pipeline Use<LoggingMiddleware>();\n        pipeline Use<ValidationMiddleware>();\n    });\n});\n`\nRelated Documentation\nv0 1 0 Foundation - Basic dispatcher\nv0 3",
        "startIndex": 11217,
        "preview": ": IDispatcherMiddleware { // 1 Inject dependencies private readonly ICustomService _service; public CustomMiddleware(ICustomService service) { _servic..."
      },
      {
        "id": "v0.2.0/enhancements/dispatcher-chunk-5",
        "text": "from v0 1 0 Adding Middleware `csharp // v0 1 0 - Basic dispatcher services AddWhizbangDispatcher(); // v0 2 0 - Enhanced with middleware services AddWhizbangDispatcher(options => { options Pipeline(pipeline => { pipeline Use<LoggingMiddleware>(); pipeline Use<ValidationMiddleware>(); }); }); ` Related Documentation v0 1 0 Foundation - Basic dispatcher v0 3 0 Orchestration - Saga support\nMiddleware Guide - Writing custom middleware\nPerformance Tuning - Optimization tips",
        "startIndex": 13343,
        "preview": "from v0 1 0 Adding Middleware `csharp // v0 1 0 - Basic dispatcher services AddWhizbangDispatcher(); // v0 2 0 - Enhanced with middleware services Add..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.2.0/enhancements/drivers",
    "title": "File Storage Drivers",
    "category": "Enhancements",
    "url": "/docs/v0.2.0/enhancements/drivers",
    "chunks": [
      {
        "id": "v0.2.0/enhancements/drivers-chunk-0",
        "text": "File Storage Drivers Version Status Next Update\nVersion History\n:::updated\nEnhanced in v0 2 0: \nFile-based persistent storage\nJSON and binary serialization\nBasic indexing for queries\nAtomic write operations\n:::\n:::planned\nComing in v0 4 0: \nFull SQL database drivers (PostgreSQL, SQL Server, MySQL)\nNoSQL drivers (MongoDB, Redis, Cassandra)\nJSONB support for flexible schemas\nQuery optimization with indexes\nSee database features →\n:::\nNew Features in v0 2 0\nFile-Based Driver\n:::new\nPersistent storage using efficient file formats:\n:::\n`csharp\n[WhizbangDriver(\"File\")]\npublic class FileDriver : IDriver {\n    private readonly FileDriverOptions _options;\n    private readonly ISerializer _serializer;\n    private readonly FileIndex _index;\n    private readonly object _writeLock = new();\n    public string Name => \"File\";\n    public DriverCapabilities Capabilities => \n        DriverCapabilities Persistence | \n        DriverCapabilities Indexing;\n    public FileDriver(FileDriverOptions options) {\n        _options = options;\n        _serializer = CreateSerializer(options Format);\n        _index = new FileIndex(Path Combine(options DataDirectory, \" index\"));\n        // Ensure directory exists\n        Directory CreateDirectory(options DataDirectory);\n        // Load index on startup\n        _index Load();\n    }\n    public async Task<T > Get<T>(string key) where T : class {\n        var filePath = GetFilePath(key);\n        if ( File Exists(filePath)) {\n            return null;\n        }\n        var data = await File ReadAllBytesAsync(filePath);\n        if (_options Compression) {\n            data = Decompress(data);\n        }\n        return _serializer Deserialize<T>(data);\n    }\n    public async Task Set<T>(string key, T value) where T : class {\n        var filePath = GetFilePath(key);\n        var directory = Path GetDirectoryName(filePath);\n        // Ensure subdirectory exists\n        Directory CreateDirectory(directory );\n        var data = _serializer Serialize(value);\n        if (_options Compression) {\n            data = Compress(data);\n        }\n        // Atomic write with temp file\n        var tempPath = $\"{filePath} tmp\";\n        await File WriteAllBytesAsync(tempPath, data);\n        lock (_writeLock) {\n            File Move(tempPath, filePath, true);\n            _index Add(key, value GetType(), GetMetadata(value));\n        }\n    }\n    private string GetFilePath(string key) {\n        // Convert key to safe file path\n        var safeName = key Replace(':', '/');\n        return Path Combine(_options DataDirectory, $\"{safeName} {_options",
        "startIndex": 0,
        "preview": "File Storage Drivers Version Status Next Update\nVersion History\n:::updated\nEnhanced in v0 2 0: \nFile-based persistent storage\nJSON and binary serializ..."
      },
      {
        "id": "v0.2.0/enhancements/drivers-chunk-1",
        "text": "with temp file var tempPath = $\"{filePath} tmp\"; await File WriteAllBytesAsync(tempPath, data); lock (_writeLock) { File Move(tempPath, filePath, true); _index Add(key, value GetType(), GetMetadata(value)); } } private string GetFilePath(string key) { // Convert key to safe file path var safeName = key Replace(':', '/'); return Path Combine(_options DataDirectory, $\"{safeName} {_options Extension}\");\n    }\n}\n`\nSerialization Options\n:::new\nSupport for multiple serialization formats:\n:::\n`csharp\npublic enum SerializationFormat {\n    Json,\n    MessagePack,\n    Protobuf,\n    Binary\n}\npublic class JsonSerializer : ISerializer {\n    private readonly JsonSerializerOptions _options;\n    public JsonSerializer() {\n        _options = new JsonSerializerOptions {\n            WriteIndented = true,\n            PropertyNamingPolicy = JsonNamingPolicy CamelCase,\n            DefaultIgnoreCondition = JsonIgnoreCondition WhenWritingNull,\n            Converters = { new JsonStringEnumConverter() }\n        };\n    }\n    public byte[] Serialize<T>(T value) {\n        return JsonSerializer SerializeToUtf8Bytes(value, _options);\n    }\n    public T Deserialize<T>(byte[] data) {\n        return JsonSerializer Deserialize<T>(data, _options) ;\n    }\n}\npublic class MessagePackSerializer : ISerializer {\n    private readonly MessagePackSerializerOptions _options;\n    public MessagePackSerializer() {\n        _options = MessagePackSerializerOptions Standard WithCompression(MessagePackCompression Lz4BlockArray);\n    }\n    public byte[] Serialize<T>(T value) {\n        return MessagePack MessagePackSerializer Serialize(value, _options);\n    }\n    public T Deserialize<T>(byte[] data) {\n        return MessagePack MessagePackSerializer Deserialize<T>(data, _options);\n    }\n}\n`\nBasic Indexing\n:::new\nIndex support for efficient queries:\n:::\n`csharp\npublic class FileIndex {\n    private readonly string _indexPath;\n    private readonly Dictionary<string, IndexEntry> _entries = new();\n    private readonly Dictionary<string, HashSet<string>> _typeIndex = new();\n    private readonly Dictionary<string, Dictionary<string, HashSet<string>>> _propertyIndex = new();\n    public void Add(string key, Type type, Dictionary<string, object> metadata) {\n        var entry = new IndexEntry {\n            Key = key,\n            Type = type FullName,\n            LastModified = DateTime UtcNow,\n            Metadata = metadata\n        };\n        _entries[key] = entry;\n        // Update type index\n        if ( _typeIndex ContainsKey(type FullName)) {\n            _typeIndex[type FullName] = new HashSet<string>();\n        }\n        _typeIndex[type FullName] Add(key);\n        // Update property indexes\n        foreach (var (propName, propValue) in metadata) {\n            if ( _propertyIndex ContainsKey(propName)) {\n                _propertyIndex[propName] = new Dictionary<string, HashSet<string>>();\n            }\n            var valueStr = propValue ToString() \"\";\n            if ( _propertyIndex[propName]",
        "startIndex": 2577,
        "preview": "with temp file var tempPath = $\"{filePath} tmp\"; await File WriteAllBytesAsync(tempPath, data); lock (_writeLock) { File Move(tempPath, filePath, true..."
      },
      {
        "id": "v0.2.0/enhancements/drivers-chunk-2",
        "text": "// Update type index if ( _typeIndex ContainsKey(type FullName)) { _typeIndex[type FullName] = new HashSet<string>(); } _typeIndex[type FullName] Add(key); // Update property indexes foreach (var (propName, propValue) in metadata) { if ( _propertyIndex ContainsKey(propName)) { _propertyIndex[propName] = new Dictionary<string, HashSet<string>>(); } var valueStr = propValue ToString() \"\"; if ( _propertyIndex[propName] ContainsKey(valueStr)) {\n                _propertyIndex[propName][valueStr] = new HashSet<string>();\n            }\n            _propertyIndex[propName][valueStr] Add(key);\n        }\n    }\n    public IEnumerable<string> FindByType(Type type) {\n        return _typeIndex TryGetValue(type FullName, out var keys) keys \n            : Enumerable Empty<string>();\n    }\n    public IEnumerable<string> FindByProperty(string propertyName, object value) {\n        if (_propertyIndex TryGetValue(propertyName, out var valueIndex)) {\n            var valueStr = value ToString() \"\";\n            if (valueIndex TryGetValue(valueStr, out var keys)) {\n                return keys;\n            }\n        }\n        return Enumerable Empty<string>();\n    }\n    public async Task Save() {\n        var json = JsonSerializer Serialize(_entries);\n        await File WriteAllTextAsync(_indexPath, json);\n    }\n    public async Task Load() {\n        if ( File Exists(_indexPath)) return;\n        var json = await File ReadAllTextAsync(_indexPath);\n        var entries = JsonSerializer Deserialize<Dictionary<string, IndexEntry>>(json);\n        // Rebuild indexes\n        foreach (var (key, entry) in entries ) {\n            _entries[key] = entry;\n            RebuildIndexesForEntry(key, entry);\n        }\n    }\n}\n`\nQuery Support\n:::new\nBasic query capabilities using indexes:\n:::\n`csharp\npublic interface IQueryableDriver : IDriver {\n    Task<IEnumerable<T>> Query<T>(Expression<Func<T, bool>> predicate) where T : class;\n    Task<IEnumerable<T>> QueryByType<T>() where T : class;\n}\npublic class QueryableFileDriver : FileDriver, IQueryableDriver {\n    public async Task<IEnumerable<T>> Query<T>(Expression<Func<T, bool>> predicate) where T : class {\n        // Simple property equality queries\n        if (predicate Body is BinaryExpression binary && \n            binary NodeType == ExpressionType Equal) {\n            if (binary Left is MemberExpression member) {\n                var propertyName = member Member Name;\n                var value = GetValue(binary Right);\n                // Use index for fast lookup\n                var keys = _index FindByProperty(propertyName, value);\n                var results = new List<T>();\n                foreach (var key in keys) {\n                    var item = await Get<T>(key);\n                    if (item = null) {\n                        results",
        "startIndex": 5190,
        "preview": "// Update type index if ( _typeIndex ContainsKey(type FullName)) { _typeIndex[type FullName] = new HashSet<string>(); } _typeIndex[type FullName] Add(..."
      },
      {
        "id": "v0.2.0/enhancements/drivers-chunk-3",
        "text": "Left is MemberExpression member) { var propertyName = member Member Name; var value = GetValue(binary Right); // Use index for fast lookup var keys = _index FindByProperty(propertyName, value); var results = new List<T>(); foreach (var key in keys) { var item = await Get<T>(key); if (item = null) { results Add(item);\n                    }\n                }\n                return results;\n            }\n        }\n        // Fallback to scanning all items of type\n        var allItems = await QueryByType<T>();\n        var compiled = predicate Compile();\n        return allItems Where(compiled);\n    }\n    public async Task<IEnumerable<T>> QueryByType<T>() where T : class {\n        var keys = _index FindByType(typeof(T));\n        var results = new List<T>();\n        foreach (var key in keys) {\n            var item = await Get<T>(key);\n            if (item = null) {\n                results Add(item);\n            }\n        }\n        return results;\n    }\n}\n`\nConfiguration\n`csharp\npublic class FileDriverOptions {\n    public string DataDirectory { get; set; } = \" /data\";\n    public SerializationFormat Format { get; set; } = SerializationFormat Json;\n    public bool Compression { get; set; } = false;\n    public string Extension { get; set; } = \"json\";\n    public bool AutoSaveIndex { get; set; } = true;\n    public TimeSpan IndexSaveInterval { get; set; } = TimeSpan FromMinutes(1);\n}\n// Registration\nservices AddWhizbangDrivers(options => {\n    options UseFileDriver(file => {\n        file DataDirectory = \" /data/whizbang\";\n        file Format = SerializationFormat MessagePack;\n        file Compression = true;\n        file Extension = \"msgpack\";\n    });\n});\n`\nAtomic Operations\nWrite Atomicity\n`csharp\npublic class AtomicFileDriver : FileDriver {\n    public async Task<bool> CompareAndSwap<T>(string key, T expected, T value) where T : class {\n        var lockPath = $\"{GetFilePath(key)} lock\";\n        // Acquire exclusive lock\n        using var lockFile = new FileStream(lockPath, FileMode Create, \n            FileAccess Write, FileShare None);\n        try {\n            var current = await Get<T>(key);\n            // Compare current with expected\n            if ( Equals(current, expected)) {\n                return false;\n            }\n            // Perform atomic update\n            await Set(key, value);\n            return true;\n        }\n        finally {\n            lockFile Close();\n            File",
        "startIndex": 7585,
        "preview": "Left is MemberExpression member) { var propertyName = member Member Name; var value = GetValue(binary Right); // Use index for fast lookup var keys = ..."
      },
      {
        "id": "v0.2.0/enhancements/drivers-chunk-4",
        "text": "Acquire exclusive lock using var lockFile = new FileStream(lockPath, FileMode Create, FileAccess Write, FileShare None); try { var current = await Get<T>(key); // Compare current with expected if ( Equals(current, expected)) { return false; } // Perform atomic update await Set(key, value); return true; } finally { lockFile Close(); File Delete(lockPath);\n        }\n    }\n}\n`\nPerformance Optimization\nWrite Batching\n`csharp\npublic class BatchingFileDriver : FileDriver {\n    private readonly Channel<WriteOperation> _writeQueue;\n    private readonly Task _batchProcessor;\n    public BatchingFileDriver(FileDriverOptions options) : base(options) {\n        _writeQueue = Channel CreateUnbounded<WriteOperation>();\n        _batchProcessor = ProcessBatches();\n    }\n    public override async Task Set<T>(string key, T value) where T : class {\n        var operation = new WriteOperation(key, value);\n        await _writeQueue Writer WriteAsync(operation);\n        await operation Completion Task;\n    }\n    private async Task ProcessBatches() {\n        while (await _writeQueue Reader WaitToReadAsync()) {\n            var batch = new List<WriteOperation>();\n            // Collect batch\n            while (_writeQueue Reader TryRead(out var op) && batch Count < 100) {\n                batch Add(op);\n            }\n            // Process batch atomically\n            await ProcessBatch(batch);\n            // Complete operations\n            foreach (var op in batch) {\n                op Completion SetResult(true);\n            }\n        }\n    }\n}\n`\nTesting File Drivers\n`csharp\n[Test]\npublic class FileDriverTests {\n    private string _testDirectory;\n    private FileDriver _driver;\n    [SetUp]\n    public void Setup() {\n        _testDirectory = Path Combine(Path GetTempPath(), Guid NewGuid() ToString());\n        _driver = new FileDriver(new FileDriverOptions {\n            DataDirectory = _testDirectory,\n            Format = SerializationFormat Json\n        });\n    }\n    [TearDown]\n    public void TearDown() {\n        Directory Delete(_testDirectory, recursive: true);\n    }\n    [Test]\n    public async Task Data_ShouldPersistAcrossRestarts() {\n        // Arrange\n        await _driver Set(\"test\", new TestEntity { Name = \"Test\" });\n        // Act - create new driver instance\n        var driver2 = new FileDriver(new FileDriverOptions {\n            DataDirectory = _testDirectory\n        });\n        var result = await driver2 Get<TestEntity>(\"test\");\n        // Assert\n        Assert NotNull(result);\n        Assert Equal(\"Test\", result Name);\n    }\n}\n`\nPerformance Characteristics\n| Operation | v0 1 0 (Memory) | v0 2",
        "startIndex": 9704,
        "preview": "Acquire exclusive lock using var lockFile = new FileStream(lockPath, FileMode Create, FileAccess Write, FileShare None); try { var current = await Get..."
      },
      {
        "id": "v0.2.0/enhancements/drivers-chunk-5",
        "text": "= \"Test\" }); // Act - create new driver instance var driver2 = new FileDriver(new FileDriverOptions { DataDirectory = _testDirectory }); var result = await driver2 Get<TestEntity>(\"test\"); // Assert Assert NotNull(result); Assert Equal(\"Test\", result Name); } } ` Performance Characteristics | Operation | v0 1 0 (Memory) | v0 2 0 (File) | Notes |\n|-----------|-----------------|---------------|-------|\n| Get | < 100ns | < 1ms | Disk I/O |\n| Set | < 500ns | < 5ms | Atomic write |\n| Query (indexed) | N/A | < 2ms | Using index |\n| Query (scan) | < 1ms | < 100ms | Full scan |\nMigration from v0 1 0\nConfiguration Changes\n`csharp\n// v0 1 0 - In-memory only\nservices AddWhizbangDrivers(options => {\n    options UseInMemory();\n});\n// v0 2 0 - File persistence\nservices AddWhizbangDrivers(options => {\n    options UseFileDriver(file => {\n        file DataDirectory = \" /data\";\n    });\n});\n`\nRelated Documentation\nv0 1 0 Foundation - In-memory driver\nv0 4 0 Databases - SQL/NoSQL drivers\nStorage Guide - Configuration options\nPerformance - Optimization tips",
        "startIndex": 11988,
        "preview": "= \"Test\" }); // Act - create new driver instance var driver2 = new FileDriver(new FileDriverOptions { DataDirectory = _testDirectory }); var result = ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.2.0/enhancements/ledger",
    "title": "Ledger Persistence",
    "category": "Enhancements",
    "url": "/docs/v0.2.0/enhancements/ledger",
    "chunks": [
      {
        "id": "v0.2.0/enhancements/ledger-chunk-0",
        "text": "Ledger Persistence Version Status Next Update\nVersion History\n:::updated\nEnhanced in v0 2 0: \nFile-based persistent storage\nEvent streams with versioning\nBasic snapshot support\nAsync streaming APIs\n:::\n:::planned\nComing in v0 3 0: \nFull event sourcing with aggregates\nProjection management\nTime-travel queries\nEvent replay and rebuilding\nSee event sourcing features →\n:::\nNew Features in v0 2 0\nPersistent Storage\n:::new\nEvents now persist to disk using an efficient file format:\n:::\n`csharp\n// Configure file-based ledger\nservices AddLedger(options => {\n    options UseFileStorage(file => {\n        file DataDirectory = \" /data/events\";\n        file MaxFileSize = 100_000_000; // 100MB per file\n        file Compression = CompressionLevel Optimal;\n        file FlushInterval = TimeSpan FromSeconds(1);\n    });\n});\npublic class FileLedger : ILedger {\n    private readonly FileEventStore _store;\n    public async Task<EventPosition> Append(string streamId, IEvent @event) {\n        // Events are written to append-only log files\n        // Each file has an index for fast seeking\n        var entry = new EventEntry {\n            StreamId = streamId,\n            EventType = @event GetType() AssemblyQualifiedName,\n            EventData = JsonSerializer Serialize(@event),\n            Metadata = CreateMetadata(@event),\n            Timestamp = DateTimeOffset UtcNow\n        };\n        return await _store Append(entry);\n    }\n}\n`\nEvent Streams\n:::new\nEvents are now organized into streams:\n:::\n`csharp\npublic interface IStreamedLedger : ILedger {\n    // Append to a specific stream\n    Task<StreamVersion> Append(string streamId, IEvent @event, ExpectedVersion version);\n    // Read a specific stream\n    IAsyncEnumerable<EventEnvelope> ReadStream(string streamId, StreamPosition from = default);\n    // Read all events across streams\n    IAsyncEnumerable<EventEnvelope> ReadAll(GlobalPosition from = default);\n    // Get stream metadata\n    Task<StreamMetadata> GetStreamMetadata(string streamId);\n}\n// Usage\npublic class OrderAggregate {\n    private readonly IStreamedLedger _ledger;\n    private readonly string _streamId;\n    public async Task CreateOrder(CreateOrder cmd) {\n        var @event = new OrderCreated {\n            OrderId = cmd OrderId,\n            CustomerId = cmd CustomerId,\n            Items = cmd Items\n        };\n        // Append to order-specific stream\n        await _ledger Append(\n            streamId: $\"order-{cmd OrderId}\",\n            @event: @event,\n            version: ExpectedVersion",
        "startIndex": 0,
        "preview": "Ledger Persistence Version Status Next Update\nVersion History\n:::updated\nEnhanced in v0 2 0: \nFile-based persistent storage\nEvent streams with version..."
      },
      {
        "id": "v0.2.0/enhancements/ledger-chunk-1",
        "text": "OrderAggregate { private readonly IStreamedLedger _ledger; private readonly string _streamId; public async Task CreateOrder(CreateOrder cmd) { var @event = new OrderCreated { OrderId = cmd OrderId, CustomerId = cmd CustomerId, Items = cmd Items }; // Append to order-specific stream await _ledger Append( streamId: $\"order-{cmd OrderId}\", @event: @event, version: ExpectedVersion NoStream\n        );\n    }\n    public async Task<Order> LoadOrder(Guid orderId) {\n        var order = new Order();\n        // Read all events for this order\n        await foreach (var envelope in _ledger ReadStream($\"order-{orderId}\")) {\n            order Apply(envelope Event);\n        }\n        return order;\n    }\n}\n`\nStream Versioning\n:::new\nOptimistic concurrency control via stream versions:\n:::\n`csharp\npublic enum ExpectedVersion {\n    Any = -2,        // Don't check version\n    NoStream = -1,   // Stream shouldn't exist\n    EmptyStream = 0  // Stream should be empty\n}\npublic class ConcurrentOrderUpdates {\n    private readonly IStreamedLedger _ledger;\n    public async Task UpdateOrder(Guid orderId, UpdateOrder cmd) {\n        var streamId = $\"order-{orderId}\";\n        // Read current version\n        var metadata = await _ledger GetStreamMetadata(streamId);\n        var currentVersion = metadata Version;\n        // Create event\n        var @event = new OrderUpdated {\n            OrderId = orderId,\n            Changes = cmd Changes\n        };\n        try {\n            // Append with version check\n            await _ledger Append(streamId, @event, currentVersion);\n        }\n        catch (WrongExpectedVersionException ex) {\n            // Handle concurrent modification\n            throw new ConcurrentUpdateException(\n                $\"Order {orderId} was modified by another process\"\n            );\n        }\n    }\n}\n`\nSnapshots\n:::new\nBasic snapshot support for long event streams:\n:::\n`csharp\npublic interface ISnapshotStore {\n    Task SaveSnapshot(string streamId, object snapshot, StreamVersion version);\n    Task<SnapshotEnvelope > GetSnapshot(string streamId);\n}\npublic class SnapshotLedger : IStreamedLedger {\n    private readonly IStreamedLedger _inner;\n    private readonly ISnapshotStore _snapshots;\n    public async Task<T> LoadWithSnapshot<T>(string streamId) where T : IAggregate, new() {\n        var aggregate = new T();\n        // Try to load from snapshot\n        var snapshot = await _snapshots GetSnapshot(streamId);\n        if (snapshot = null) {\n            aggregate RestoreFromSnapshot(snapshot",
        "startIndex": 2520,
        "preview": "OrderAggregate { private readonly IStreamedLedger _ledger; private readonly string _streamId; public async Task CreateOrder(CreateOrder cmd) { var @ev..."
      },
      {
        "id": "v0.2.0/enhancements/ledger-chunk-2",
        "text": "} public class SnapshotLedger : IStreamedLedger { private readonly IStreamedLedger _inner; private readonly ISnapshotStore _snapshots; public async Task<T> LoadWithSnapshot<T>(string streamId) where T : IAggregate, new() { var aggregate = new T(); // Try to load from snapshot var snapshot = await _snapshots GetSnapshot(streamId); if (snapshot = null) { aggregate RestoreFromSnapshot(snapshot Data);\n            // Read events after snapshot\n            await foreach (var envelope in _inner ReadStream(streamId, snapshot Version)) {\n                aggregate Apply(envelope Event);\n            }\n        } else {\n            // No snapshot, read all events\n            await foreach (var envelope in _inner ReadStream(streamId)) {\n                aggregate Apply(envelope Event);\n            }\n        }\n        return aggregate;\n    }\n    public async Task SaveWithSnapshot<T>(T aggregate) where T : IAggregate {\n        var streamId = aggregate GetStreamId();\n        // Save events\n        foreach (var @event in aggregate GetUncommittedEvents()) {\n            await _inner Append(streamId, @event, aggregate Version);\n        }\n        // Create snapshot every 100 events\n        if (aggregate Version % 100 == 0) {\n            var snapshot = aggregate CreateSnapshot();\n            await _snapshots SaveSnapshot(streamId, snapshot, aggregate Version);\n        }\n    }\n}\n`\nAsync Streaming\n:::new\nEfficient async enumeration for large event streams:\n:::\n`csharp\npublic class EventProcessor {\n    private readonly IStreamedLedger _ledger;\n    public async Task ProcessAllEvents(CancellationToken ct) {\n        var position = GlobalPosition Start;\n        // Stream events efficiently without loading all into memory\n        await foreach (var envelope in _ledger ReadAll(position) WithCancellation(ct)) {\n            await ProcessEvent(envelope Event);\n            // Save checkpoint periodically\n            if (envelope Position Offset % 1000 == 0) {\n                await SaveCheckpoint(envelope Position);\n            }\n        }\n    }\n    public async IAsyncEnumerable<OrderSummary> StreamOrderSummaries(\n        [EnumeratorCancellation] CancellationToken ct = default) {\n        await foreach (var envelope in _ledger ReadAll() WithCancellation(ct)) {\n            if (envelope Event is OrderCreated created) {\n                yield return new OrderSummary {\n                    OrderId = created OrderId,\n                    Total = created Total,\n                    Timestamp = envelope Timestamp\n                };\n            }\n        }\n    }\n}\n`\nFile Storage Format\nEvent File Structure\n`\ndata/events/\n├── 00000001 events     Event data files (append-only)\n├── 00000001 index      Position index for seeking\n├── 00000002",
        "startIndex": 4658,
        "preview": "} public class SnapshotLedger : IStreamedLedger { private readonly IStreamedLedger _inner; private readonly ISnapshotStore _snapshots; public async Ta..."
      },
      {
        "id": "v0.2.0/enhancements/ledger-chunk-3",
        "text": "OrderCreated created) { yield return new OrderSummary { OrderId = created OrderId, Total = created Total, Timestamp = envelope Timestamp }; } } } } ` File Storage Format Event File Structure ` data/events/ ├── 00000001 events Event data files (append-only) ├── 00000001 index Position index for seeking ├── 00000002 events\n├── 00000002 index\n├── streams db          Stream metadata\n└── checkpoints db      Consumer checkpoints\n`\nEvent Entry Format\n`csharp\n// Binary format for efficient storage\n[StructLayout(LayoutKind Sequential, Pack = 1)]\npublic struct EventHeader {\n    public uint Magic;           // 0xEVNT\n    public uint Version;         // Format version\n    public long Position;        // Global position\n    public long Timestamp;       // Unix timestamp\n    public int StreamIdLength;   // Stream ID byte length\n    public int EventTypeLength;  // Type name byte length\n    public int DataLength;       // Event data byte length\n    public int MetadataLength;   // Metadata byte length\n    public uint Checksum;        // CRC32 checksum\n}\n// Followed by: StreamId, EventType, Data, Metadata (all UTF-8)\n`\nPerformance Improvements\nBuffered Writes\n`csharp\npublic class BufferedLedger : IStreamedLedger {\n    private readonly Channel<EventWrite> _writeBuffer;\n    public async Task<StreamVersion> Append(string streamId, IEvent @event, ExpectedVersion version) {\n        // Buffer writes for batch processing\n        var write = new EventWrite(streamId, @event, version);\n        await _writeBuffer Writer WriteAsync(write);\n        return await write Completion Task;\n    }\n    private async Task ProcessWrites() {\n        var batch = new List<EventWrite>(capacity: 100);\n        while (await _writeBuffer Reader WaitToReadAsync()) {\n            // Collect batch\n            while (_writeBuffer Reader TryRead(out var write) && batch Count < 100) {\n                batch Add(write);\n            }\n            // Write batch to disk\n            await WriteBatch(batch);\n            // Complete tasks\n            foreach (var write in batch) {\n                write Completion SetResult(write ResultVersion);\n            }\n            batch Clear();\n        }\n    }\n}\n`\nTesting Enhanced Ledger\n`csharp\n[Test]\npublic class PersistentLedgerTests {\n    [Test]\n    public async Task Events_ShouldPersistAcrossRestarts() {\n        // Arrange\n        var dataDir = Path GetTempPath() + Guid",
        "startIndex": 7001,
        "preview": "OrderCreated created) { yield return new OrderSummary { OrderId = created OrderId, Total = created Total, Timestamp = envelope Timestamp }; } } } } ` ..."
      },
      {
        "id": "v0.2.0/enhancements/ledger-chunk-4",
        "text": "Write batch to disk await WriteBatch(batch); // Complete tasks foreach (var write in batch) { write Completion SetResult(write ResultVersion); } batch Clear(); } } } ` Testing Enhanced Ledger `csharp [Test] public class PersistentLedgerTests { [Test] public async Task Events_ShouldPersistAcrossRestarts() { // Arrange var dataDir = Path GetTempPath() + Guid NewGuid();\n        var ledger1 = new FileLedger(dataDir);\n        // Act - write events\n        await ledger1 Append(\"stream-1\", new TestEvent { Data = \"test\" });\n        await ledger1 Dispose();\n        // Act - read after restart\n        var ledger2 = new FileLedger(dataDir);\n        var events = await ledger2 ReadStream(\"stream-1\") ToListAsync();\n        // Assert\n        Assert Equal(1, events Count);\n        Assert Equal(\"test\", ((TestEvent)events[0] Event) Data);\n    }\n    [Test]\n    public async Task ConcurrentAppend_ShouldDetectConflicts() {\n        // Test optimistic concurrency control\n    }\n}\n`\nMigration from v0 1 0\nBreaking Changes\nAppend now requires a stream ID\nRead returns IAsyncEnumerable instead of IEnumerable\nMigration Steps\n`csharp\n// v0 1 0\nawait ledger Append(@event);\nvar events = ledger Read();\n// v0 2 0\nawait ledger Append(\"default-stream\", @event, ExpectedVersion Any);\nvar events = await ledger ReadAll() ToListAsync();\n`\nPerformance Characteristics\n| Operation | v0 1 0 | v0 2 0 | Notes |\n|-----------|--------|--------|-------|\n| Append | < 1μs | < 10ms | Disk I/O |\n| Read 1K events | < 1ms | < 5ms | From cache |\n| Read 100K events | OOM | < 100ms | Streaming |\n| Restart recovery | N/A | < 1s | Index loading |\nRelated Documentation\nv0 1 0 Foundation - Basic ledger\nv0 3 0 Event Sourcing - Full ES/CQRS\nStorage Guide - File storage setup\nPerformance - Optimization tips",
        "startIndex": 9080,
        "preview": "Write batch to disk await WriteBatch(batch); // Complete tasks foreach (var write in batch) { write Completion SetResult(write ResultVersion); } batch..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.2.0/enhancements/policies",
    "title": "Policy Enhancements",
    "category": "Enhancements",
    "url": "/docs/v0.2.0/enhancements/policies",
    "chunks": [
      {
        "id": "v0.2.0/enhancements/policies-chunk-0",
        "text": "Policy Enhancements Version Status Next Update\nVersion History\n:::updated\nEnhanced in v0 2 0: \nPolicy composition for combining multiple policies\nBulkhead isolation for resource protection\nRate limiting with token buckets\nDead letter queue support\n:::\n:::planned\nComing in v0 3 0: \nStateful policies with persistence\nPolicy metrics and monitoring\nDynamic policy configuration\nSee state management features →\n:::\nNew Features in v0 2 0\nPolicy Composition\n:::new\nCombine multiple policies into reusable sets:\n:::\n`csharp\n// Define policy sets\nservices AddPolicySet(\"Resilient\", policies => {\n    policies AddRetry(3, BackoffStrategy Exponential);\n    policies AddTimeout(5000);\n    policies AddCircuitBreaker(0 5, 10, 5, 30);\n    policies AddCache(300);\n});\nservices AddPolicySet(\"RateLimited\", policies => {\n    policies AddRateLimit(100, TimeSpan FromMinute(1));\n    policies AddBulkhead(10, 20);  // 10 concurrent, 20 queued\n});\n// Apply policy sets\n[PolicySet(\"Resilient\")]\npublic class OrderReceptor : IReceptor<CreateOrder> { }\n// Combine sets\n[PolicySet(\"Resilient\", \"RateLimited\")]\npublic class ExternalServiceReceptor : IReceptor<CallExternalService> { }\n`\nBulkhead Isolation\n:::new\nPrevent resource exhaustion with bulkhead isolation:\n:::\n`csharp\n[Bulkhead(\n    MaxConcurrency = 10,\n    MaxQueuedActions = 20,\n    TimeoutMs = 30000\n)]\npublic class DatabaseReceptor : IReceptor<QueryDatabase> {\n    public QueryResult Receive(QueryDatabase cmd) {\n        // Max 10 concurrent executions\n        // Queue up to 20 additional requests\n        // Reject if queue full\n        return ExecuteQuery(cmd);\n    }\n}\n// Advanced configuration\n[Bulkhead(\n    MaxConcurrency = 5,\n    MaxQueuedActions = 10,\n    OnReject = BulkheadRejectStrategy ThrowException,\n    Name = \"DatabaseBulkhead\"  // Named for monitoring\n)]\npublic class CriticalReceptor : IReceptor<CriticalCommand> { }\n`\nBulkhead States\n`mermaid\nstateDiagram-v2\n    [*] --> Available: Initial\n    Available --> Full: Max<br/>Concurrency\n    Full --> Queuing: Has<br/>Queue Space\n    Queuing --> Rejecting: Queue<br/>Full\n    Full --> Available: Slot<br/>Released\n    Queuing --> Full: Dequeue\n`\nRate Limiting\n:::new\nControl request rates with token bucket algorithm:\n:::\n`csharp\n// Simple rate limit\n[RateLimit(100, TimeSpan FromMinute(1))]  // 100 requests per minute\npublic class ApiReceptor : IReceptor<ApiCall> { }\n// Advanced rate limiting\n[RateLimit(\n    TokenLimit = 1000,\n    Window = TimeSpan",
        "startIndex": 0,
        "preview": "Policy Enhancements Version Status Next Update\nVersion History\n:::updated\nEnhanced in v0 2 0: \nPolicy composition for combining multiple policies\nBulk..."
      },
      {
        "id": "v0.2.0/enhancements/policies-chunk-1",
        "text": "--> Available: Slot<br/>Released Queuing --> Full: Dequeue ` Rate Limiting :::new Control request rates with token bucket algorithm: ::: `csharp // Simple rate limit [RateLimit(100, TimeSpan FromMinute(1))] // 100 requests per minute public class ApiReceptor : IReceptor<ApiCall> { } // Advanced rate limiting [RateLimit( TokenLimit = 1000, Window = TimeSpan FromHour(1),\n    ReplenishRate = 100,  // Add 100 tokens per window\n    BurstSize = 50,       // Allow burst of 50\n    OnReject = RateLimitRejectStrategy Queue\n)]\npublic class ThrottledReceptor : IReceptor<ThrottledCommand> { }\n// Multiple rate limits (all must pass)\n[RateLimit(10, TimeSpan FromSecond(1))]   // 10 per second\n[RateLimit(100, TimeSpan FromMinute(1))]  // 100 per minute\n[RateLimit(1000, TimeSpan FromHour(1))]   // 1000 per hour\npublic class MultiLimitReceptor : IReceptor<Command> { }\n`\nDead Letter Queue\n:::new\nHandle policy failures with dead letter queues:\n:::\n`csharp\n[Retry(3, OnFinalFailure = FailureStrategy DeadLetter)]\n[DeadLetterQueue(\"failed-orders\")]\npublic class OrderReceptor : IReceptor<ProcessOrder> { }\n// Configure dead letter processing\nservices AddDeadLetterQueue(\"failed-orders\", options => {\n    options MaxRetries = 5;\n    options RetryDelay = TimeSpan FromMinutes(5);\n    options OnDeadLetter = async (message, context) => {\n        await NotifyOps(message);\n        await LogToAudit(message);\n    };\n});\n// Manual dead letter processing\npublic class DeadLetterProcessor {\n    private readonly IDeadLetterQueue _dlq;\n    public async Task ProcessFailures() {\n        await foreach (var message in _dlq ReadAsync(\"failed-orders\")) {\n            // Attempt reprocessing\n            if (await TryReprocess(message)) {\n                await _dlq Remove(message);\n            } else {\n                await _dlq Postpone(message, TimeSpan FromHour(1));\n            }\n        }\n    }\n}\n`\nDynamic Policy Configuration\n:::new\nConfigure policies at runtime:\n:::\n`csharp\n// Policy with dynamic configuration\n[DynamicPolicy(\"OrderProcessing\")]\npublic class OrderReceptor : IReceptor<ProcessOrder> { }\n// Configure dynamically\nservices ConfigurePolicy(\"OrderProcessing\", policy => {\n    if (IsHighLoad()) {\n        policy AddRateLimit(50, TimeSpan FromSecond(1));\n        policy AddBulkhead(5);\n    } else {\n        policy AddRateLimit(100, TimeSpan FromSecond(1));\n        policy AddBulkhead(20);\n    }\n});\n// Update configuration at runtime\npublic class PolicyManager {\n    private readonly IPolicyConfiguration _config;\n    public void AdjustForLoad(double cpuUsage) {\n        if (cpuUsage > 80) {\n            _config",
        "startIndex": 2463,
        "preview": "--> Available: Slot<br/>Released Queuing --> Full: Dequeue ` Rate Limiting :::new Control request rates with token bucket algorithm: ::: `csharp // Si..."
      },
      {
        "id": "v0.2.0/enhancements/policies-chunk-2",
        "text": "dynamically services ConfigurePolicy(\"OrderProcessing\", policy => { if (IsHighLoad()) { policy AddRateLimit(50, TimeSpan FromSecond(1)); policy AddBulkhead(5); } else { policy AddRateLimit(100, TimeSpan FromSecond(1)); policy AddBulkhead(20); } }); // Update configuration at runtime public class PolicyManager { private readonly IPolicyConfiguration _config; public void AdjustForLoad(double cpuUsage) { if (cpuUsage > 80) { _config Update(\"OrderProcessing\", p => p AddTimeout(2000));\n        } else {\n            _config Update(\"OrderProcessing\", p => p AddTimeout(5000));\n        }\n    }\n}\n`\nEnhanced Policy Execution\nParallel Policy Execution\n:::updated\nPolicies can now execute in parallel where appropriate:\n:::\n`csharp\n[ParallelPolicies(\n    typeof(LoggingPolicy),\n    typeof(MetricsPolicy),\n    typeof(TracingPolicy)\n)]\npublic class InstrumentedReceptor : IReceptor<Command> { }\n`\nPolicy Context\n:::new\nRich context flows through policy chain:\n:::\n`csharp\npublic class CustomPolicy : IPolicyOf<IReceptor> {\n    public async Task<TResult> Execute<TResult>(\n        Func<Task<TResult>> operation,\n        IPolicyContext context  // Enhanced in v0 2 0\n    ) {\n        // Access context information\n        var correlationId = context CorrelationId;\n        var attemptNumber = context GetValue<int>(\"AttemptNumber\");\n        var previousFailures = context GetValue<List<Exception>>(\"Failures\");\n        // Add context for downstream policies\n        context SetValue(\"PolicyName\", \"CustomPolicy\");\n        context SetValue(\"StartTime\", DateTime UtcNow);\n        return await operation();\n    }\n}\n`\nTesting Enhanced Policies\n`csharp\n[Test]\npublic class PolicyCompositionTests {\n    [Test]\n    public async Task PolicySet_ShouldApplyInOrder() {\n        // Arrange\n        var services = new ServiceCollection();\n        services AddPolicySet(\"TestSet\", policies => {\n            policies AddRetry(2);\n            policies AddTimeout(1000);\n        });\n        var receptor = new TestReceptor();\n        var wrapped = PolicyWeaver WrapWithSet(receptor, \"TestSet\");\n        // Act & Assert\n        // Verify policies applied in correct order\n    }\n    [Test]\n    public async Task RateLimit_ShouldThrottle() {\n        // Arrange\n        var policy = new RateLimitPolicy(5, TimeSpan FromSecond(1));\n        var successes = 0;\n        // Act - try 10 rapid requests\n        for (int i = 0; i < 10; i++) {\n            try {\n                await policy Execute(() => Task FromResult(true), new PolicyContext());\n                successes++;\n            } catch (RateLimitExceededException) { }\n        }\n        // Assert - only 5 should succeed\n        Assert",
        "startIndex": 4714,
        "preview": "dynamically services ConfigurePolicy(\"OrderProcessing\", policy => { if (IsHighLoad()) { policy AddRateLimit(50, TimeSpan FromSecond(1)); policy AddBul..."
      },
      {
        "id": "v0.2.0/enhancements/policies-chunk-3",
        "text": "new RateLimitPolicy(5, TimeSpan FromSecond(1)); var successes = 0; // Act - try 10 rapid requests for (int i = 0; i < 10; i++) { try { await policy Execute(() => Task FromResult(true), new PolicyContext()); successes++; } catch (RateLimitExceededException) { } } // Assert - only 5 should succeed Assert Equal(5, successes);\n    }\n    [Test]\n    public async Task Bulkhead_ShouldLimitConcurrency() {\n        // Complex test verifying concurrent execution limits\n    }\n}\n`\nPerformance Improvements\n| Policy | v0 1 0 Overhead | v0 2 0 Overhead | Improvement |\n|--------|----------------|-----------------|-------------|\n| Retry | < 10ns | < 8ns | 20% faster |\n| Timeout | < 100ns | < 50ns | 50% faster |\n| Cache | < 50ns | < 30ns | 40% faster |\n| CircuitBreaker | < 20ns | < 15ns | 25% faster |\n| RateLimit | - | < 25ns | New |\n| Bulkhead | - | < 30ns | New |\nMigration from v0 1 0\nBreaking Changes\nNone - v0 2 0 is fully backward compatible Recommended Updates\n`csharp\n// Before (v0 1 0)\n[Retry(3)]\n[Timeout(5000)]\npublic class OrderReceptor : IReceptor<CreateOrder> { }\n// After (v0 2 0) - Use policy sets\nservices AddPolicySet(\"Standard\", policies => {\n    policies AddRetry(3);\n    policies AddTimeout(5000);\n});\n[PolicySet(\"Standard\")]\npublic class OrderReceptor : IReceptor<CreateOrder> { }\n`\nRelated Documentation\nv0 1 0 Foundation - Basic policy implementation\nv0 3 0 State Management - Stateful policies\nTesting Guide - Testing composed policies\nPerformance Tuning - Optimization tips",
        "startIndex": 6939,
        "preview": "new RateLimitPolicy(5, TimeSpan FromSecond(1)); var successes = 0; // Act - try 10 rapid requests for (int i = 0; i < 10; i++) { try { await policy Ex..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.2.0/enhancements/transports",
    "title": "HTTP & WebSocket Transports",
    "category": "Enhancements",
    "url": "/docs/v0.2.0/enhancements/transports",
    "chunks": [
      {
        "id": "v0.2.0/enhancements/transports-chunk-0",
        "text": "HTTP & WebSocket Transports Version Status Next Update\nVersion History\n:::updated\nEnhanced in v0 2 0: \nHTTP transport for REST APIs\nWebSocket support for real-time\nJSON and MessagePack serialization\nRetry policies and circuit breakers\n:::\n:::planned\nComing in v0 3 0: \nMessage queue transports (RabbitMQ, Kafka)\nAdvanced pub/sub with topics\nDead letter queues\nMessage persistence\nSee messaging features →\n:::\nNew Features in v0 2 0\nHTTP Transport\n:::new\nFull HTTP/REST transport with client and server:\n:::\n`csharp\n[WhizbangTransport(\"HTTP\")]\npublic class HttpTransport : ITransport {\n    private readonly HttpClient _httpClient;\n    private readonly HttpTransportOptions _options;\n    private readonly ISerializer _serializer;\n    private readonly IRetryPolicy _retryPolicy;\n    public string Name => \"HTTP\";\n    public TransportCapabilities Capabilities => \n        TransportCapabilities RequestResponse |\n        TransportCapabilities Reliable;\n    public HttpTransport(HttpTransportOptions options) {\n        _options = options;\n        _serializer = CreateSerializer(options SerializationFormat);\n        _retryPolicy = new ExponentialBackoffRetry(options RetryOptions);\n        _httpClient = new HttpClient {\n            BaseAddress = new Uri(options BaseUrl),\n            Timeout = options Timeout\n        };\n        // Add default headers\n        _httpClient DefaultRequestHeaders Add(\"Accept\", GetContentType());\n        _httpClient DefaultRequestHeaders Add(\"User-Agent\", \"Whizbang/0 2 0\");\n    }\n    public async Task<TResponse> Send<TRequest, TResponse>(\n        TRequest request, \n        string destination)\n        where TRequest : IMessage\n        where TResponse : IMessage {\n        // Build HTTP request\n        var httpRequest = new HttpRequestMessage(HttpMethod Post, destination) {\n            Content = new ByteArrayContent(_serializer Serialize(request))\n        };\n        httpRequest Content Headers ContentType = new MediaTypeHeaderValue(GetContentType());\n        // Add message headers\n        foreach (var header in request Headers) {\n            httpRequest Headers Add($\"X-Whizbang-{header Key}\", header Value);\n        }\n        // Add correlation ID for tracing\n        httpRequest Headers Add(\"X-Correlation-Id\", request Id ToString());\n        // Execute with retry\n        var response = await _retryPolicy Execute(async () => \n            await _httpClient SendAsync(httpRequest)\n        );\n        response EnsureSuccessStatusCode();\n        // Deserialize response\n        var responseBytes = await response Content ReadAsByteArrayAsync();\n        return _serializer Deserialize<TResponse>(responseBytes);\n    }\n    private string GetContentType() {\n        return _options SerializationFormat switch {\n            SerializationFormat Json => \"application/json\",\n            SerializationFormat MessagePack => \"application/msgpack\",\n            SerializationFormat Protobuf => \"application/protobuf\",\n            _ => \"application/octet-stream\"\n        };\n    }\n}\n`\nHTTP Server Endpoint\n:::new\nASP",
        "startIndex": 0,
        "preview": "HTTP & WebSocket Transports Version Status Next Update\nVersion History\n:::updated\nEnhanced in v0 2 0: \nHTTP transport for REST APIs\nWebSocket support ..."
      },
      {
        "id": "v0.2.0/enhancements/transports-chunk-1",
        "text": "); response EnsureSuccessStatusCode(); // Deserialize response var responseBytes = await response Content ReadAsByteArrayAsync(); return _serializer Deserialize<TResponse>(responseBytes); } private string GetContentType() { return _options SerializationFormat switch { SerializationFormat Json => \"application/json\", SerializationFormat MessagePack => \"application/msgpack\", SerializationFormat Protobuf => \"application/protobuf\", _ => \"application/octet-stream\" }; } } ` HTTP Server Endpoint :::new ASP NET Core integration for receiving HTTP messages:\n:::\n`csharp\npublic class WhizbangHttpEndpoint {\n    private readonly ITransportDispatcher _dispatcher;\n    private readonly ISerializer _serializer;\n    public void MapEndpoints(IEndpointRouteBuilder endpoints) {\n        endpoints MapPost(\"/api/messages/{destination}\", HandleMessage);\n        endpoints MapGet(\"/api/health\", HandleHealth);\n    }\n    private async Task<IResult> HandleMessage(\n        string destination,\n        HttpRequest request,\n        CancellationToken ct) {\n        try {\n            // Read message\n            using var reader = new StreamReader(request Body);\n            var body = await reader ReadToEndAsync();\n            // Determine message type from header\n            var messageType = request Headers[\"X-Message-Type\"] FirstOrDefault();\n            if (string IsNullOrEmpty(messageType)) {\n                return Results BadRequest(\"Missing X-Message-Type header\");\n            }\n            // Deserialize\n            var type = Type GetType(messageType);\n            var message = _serializer Deserialize(body, type);\n            // Extract correlation ID\n            var correlationId = request Headers[\"X-Correlation-Id\"] FirstOrDefault();\n            // Dispatch to handler\n            var response = await _dispatcher Dispatch(message, destination, correlationId);\n            // Serialize response\n            var responseBody = _serializer Serialize(response);\n            return Results Ok(responseBody);\n        }\n        catch (HandlerNotFoundException ex) {\n            return Results NotFound(ex Message);\n        }\n        catch (ValidationException ex) {\n            return Results BadRequest(ex Message);\n        }\n        catch (Exception ex) {\n            _logger LogError(ex, \"Failed to handle message\");\n            return Results StatusCode(500);\n        }\n    }\n}\n// Registration in Program cs\nvar builder = WebApplication CreateBuilder(args);\nbuilder Services AddWhizbangHttpTransport();\nvar app = builder Build();\napp MapWhizbangEndpoints();\n`\nWebSocket Transport\n:::new\nReal-time bidirectional communication:\n:::\n`csharp\n[WhizbangTransport(\"WebSocket\")]\npublic class WebSocketTransport : ITransport, IStreamingTransport {\n    private readonly ClientWebSocket _webSocket;\n    private readonly WebSocketOptions _options;\n    private readonly ISerializer _serializer;\n    private readonly ConcurrentDictionary<Guid, TaskCompletionSource<IMessage>> _pendingRequests;\n    private readonly ConcurrentDictionary<string, List<Func<IMessage, Task>>> _subscriptions;\n    public string Name => \"WebSocket\";\n    public TransportCapabilities Capabilities => \n        TransportCapabilities RequestResponse |\n        TransportCapabilities PublishSubscribe |\n        TransportCapabilities Streaming |\n        TransportCapabilities",
        "startIndex": 3041,
        "preview": "); response EnsureSuccessStatusCode(); // Deserialize response var responseBytes = await response Content ReadAsByteArrayAsync(); return _serializer D..."
      },
      {
        "id": "v0.2.0/enhancements/transports-chunk-2",
        "text": "[WhizbangTransport(\"WebSocket\")] public class WebSocketTransport : ITransport, IStreamingTransport { private readonly ClientWebSocket _webSocket; private readonly WebSocketOptions _options; private readonly ISerializer _serializer; private readonly ConcurrentDictionary<Guid, TaskCompletionSource<IMessage>> _pendingRequests; private readonly ConcurrentDictionary<string, List<Func<IMessage, Task>>> _subscriptions; public string Name => \"WebSocket\"; public TransportCapabilities Capabilities => TransportCapabilities RequestResponse | TransportCapabilities PublishSubscribe | TransportCapabilities Streaming | TransportCapabilities Ordered;\n    public async Task Connect(string url) {\n        _webSocket = new ClientWebSocket();\n        await _webSocket ConnectAsync(new Uri(url), CancellationToken None);\n        // Start receive loop\n        _ = Task Run(ReceiveLoop);\n        // Start heartbeat\n        _ = Task Run(HeartbeatLoop);\n    }\n    public async Task<TResponse> Send<TRequest, TResponse>(\n        TRequest request, \n        string destination)\n        where TRequest : IMessage\n        where TResponse : IMessage {\n        var envelope = new MessageEnvelope {\n            Id = request Id,\n            Type = MessageType Request,\n            Destination = destination,\n            Payload = _serializer Serialize(request),\n            Headers = request Headers\n        };\n        // Register pending request\n        var tcs = new TaskCompletionSource<IMessage>();\n        _pendingRequests[request Id] = tcs;\n        // Send over WebSocket\n        await SendEnvelope(envelope);\n        // Wait for response with timeout\n        using var cts = new CancellationTokenSource(_options RequestTimeout);\n        cts Token Register(() => tcs TrySetCanceled());\n        var response = await tcs Task;\n        return (TResponse)response;\n    }\n    public async Task Publish<TMessage>(TMessage message, string topic)\n        where TMessage : IMessage {\n        var envelope = new MessageEnvelope {\n            Id = message Id,\n            Type = MessageType Publish,\n            Topic = topic,\n            Payload = _serializer Serialize(message),\n            Headers = message Headers\n        };\n        await SendEnvelope(envelope);\n    }\n    public async Task Subscribe<TMessage>(string topic, Func<TMessage, Task> handler)\n        where TMessage : IMessage {\n        // Register local handler\n        if ( _subscriptions ContainsKey(topic)) {\n            _subscriptions[topic] = new List<Func<IMessage, Task>>();\n        }\n        _subscriptions[topic] Add(async msg => await handler((TMessage)msg));\n        // Send subscription request\n        var envelope = new MessageEnvelope {\n            Id = Guid NewGuid(),\n            Type = MessageType Subscribe,\n            Topic = topic\n        };\n        await SendEnvelope(envelope);\n    }\n    private async Task ReceiveLoop() {\n        var buffer = new ArraySegment<byte>(new byte[4096]);\n        while (_webSocket State == WebSocketState Open) {\n            try {\n                var result = await _webSocket",
        "startIndex": 5868,
        "preview": "[WhizbangTransport(\"WebSocket\")] public class WebSocketTransport : ITransport, IStreamingTransport { private readonly ClientWebSocket _webSocket; priv..."
      },
      {
        "id": "v0.2.0/enhancements/transports-chunk-3",
        "text": "// Send subscription request var envelope = new MessageEnvelope { Id = Guid NewGuid(), Type = MessageType Subscribe, Topic = topic }; await SendEnvelope(envelope); } private async Task ReceiveLoop() { var buffer = new ArraySegment<byte>(new byte[4096]); while (_webSocket State == WebSocketState Open) { try { var result = await _webSocket ReceiveAsync(buffer, CancellationToken None);\n                if (result MessageType == WebSocketMessageType Close) {\n                    await HandleClose();\n                    break;\n                }\n                if (result MessageType == WebSocketMessageType Binary) {\n                    var envelope = DeserializeEnvelope(buffer Array, result Count);\n                    await HandleEnvelope(envelope);\n                }\n            }\n            catch (Exception ex) {\n                _logger LogError(ex, \"WebSocket receive error\");\n                await Reconnect();\n            }\n        }\n    }\n    private async Task HandleEnvelope(MessageEnvelope envelope) {\n        switch (envelope Type) {\n            case MessageType Response:\n                // Complete pending request\n                if (_pendingRequests TryRemove(envelope CorrelationId, out var tcs)) {\n                    var response = _serializer Deserialize(envelope Payload, envelope PayloadType);\n                    tcs SetResult(response);\n                }\n                break;\n            case MessageType Event:\n                // Dispatch to subscribers\n                if (_subscriptions TryGetValue(envelope Topic, out var handlers)) {\n                    var message = _serializer Deserialize(envelope Payload, envelope PayloadType);\n                    var tasks = handlers Select(h => h(message));\n                    await Task WhenAll(tasks);\n                }\n                break;\n        }\n    }\n}\n`\nMessage Serialization\n:::new\nMultiple serialization formats:\n:::\n`csharp\npublic interface ISerializer {\n    byte[] Serialize<T>(T value);\n    T Deserialize<T>(byte[] data);\n    object Deserialize(byte[] data, Type type);\n}\n// JSON serializer with compression\npublic class CompressedJsonSerializer : ISerializer {\n    private readonly JsonSerializerOptions _options;\n    public CompressedJsonSerializer() {\n        _options = new JsonSerializerOptions {\n            DefaultIgnoreCondition = JsonIgnoreCondition WhenWritingNull,\n            PropertyNamingPolicy = JsonNamingPolicy CamelCase,\n            Converters = {\n                new JsonStringEnumConverter(),\n                new DateTimeOffsetConverter()\n            }\n        };\n    }\n    public byte[] Serialize<T>(T value) {\n        var json = JsonSerializer SerializeToUtf8Bytes(value, _options);\n        // Compress if larger than threshold\n        if (json Length > 1024) {\n            return Compress(json);\n        }\n        return json;\n    }\n    private byte[] Compress(byte[] data) {\n        using var output = new MemoryStream();\n        // Write compression marker\n        output WriteByte(0xFF);\n        using (var gzip = new GZipStream(output, CompressionLevel Optimal)) {\n            gzip Write(data, 0, data Length);\n        }\n        return output",
        "startIndex": 8301,
        "preview": "// Send subscription request var envelope = new MessageEnvelope { Id = Guid NewGuid(), Type = MessageType Subscribe, Topic = topic }; await SendEnvelo..."
      },
      {
        "id": "v0.2.0/enhancements/transports-chunk-4",
        "text": "if larger than threshold if (json Length > 1024) { return Compress(json); } return json; } private byte[] Compress(byte[] data) { using var output = new MemoryStream(); // Write compression marker output WriteByte(0xFF); using (var gzip = new GZipStream(output, CompressionLevel Optimal)) { gzip Write(data, 0, data Length); } return output ToArray();\n    }\n}\n// MessagePack serializer\npublic class MessagePackSerializer : ISerializer {\n    private readonly MessagePackSerializerOptions _options;\n    public MessagePackSerializer() {\n        _options = MessagePackSerializerOptions Standard WithCompression(MessagePackCompression Lz4BlockArray) WithSecurity(MessagePackSecurity UntrustedData);\n    }\n    public byte[] Serialize<T>(T value) {\n        return MessagePack MessagePackSerializer Serialize(value, _options);\n    }\n    public T Deserialize<T>(byte[] data) {\n        return MessagePack MessagePackSerializer Deserialize<T>(data, _options);\n    }\n}\n`\nRetry and Resilience\n:::new\nBuilt-in retry policies:\n:::\n`csharp\npublic class ResilientHttpTransport : HttpTransport {\n    private readonly ICircuitBreaker _circuitBreaker;\n    private readonly IRetryPolicy _retryPolicy;\n    public override async Task<TResponse> Send<TRequest, TResponse>(\n        TRequest request,\n        string destination) {\n        return await _circuitBreaker Execute(async () => {\n            return await _retryPolicy Execute(async () => {\n                try {\n                    return await base Send<TRequest, TResponse>(request, destination);\n                }\n                catch (HttpRequestException ex) when (IsTransient(ex)) {\n                    _logger LogWarning(\"Transient error, will retry: {Message}\", ex Message);\n                    throw;\n                }\n            });\n        });\n    }\n    private bool IsTransient(HttpRequestException ex) {\n        // Retry on specific status codes\n        return ex StatusCode is \n            HttpStatusCode ServiceUnavailable or\n            HttpStatusCode GatewayTimeout or\n            HttpStatusCode TooManyRequests;\n    }\n}\n`\nConfiguration\n`csharp\n// HTTP transport configuration\nservices AddWhizbangTransports(options => {\n    options UseHttp(http => {\n        http BaseUrl = \"https://api example com\";\n        http Timeout = TimeSpan FromSeconds(30);\n        http SerializationFormat = SerializationFormat MessagePack;\n        http RetryOptions = new RetryOptions {\n            MaxAttempts = 3,\n            InitialDelay = TimeSpan FromMilliseconds(100),\n            MaxDelay = TimeSpan FromSeconds(5),\n            BackoffMultiplier = 2\n        };\n    });\n});\n// WebSocket configuration\nservices AddWhizbangTransports(options => {\n    options UseWebSocket(ws => {\n        ws Url = \"wss://realtime example com/hub\";\n        ws ReconnectInterval = TimeSpan FromSeconds(5);\n        ws HeartbeatInterval = TimeSpan FromSeconds(30);\n        ws RequestTimeout = TimeSpan",
        "startIndex": 11123,
        "preview": "if larger than threshold if (json Length > 1024) { return Compress(json); } return json; } private byte[] Compress(byte[] data) { using var output = n..."
      },
      {
        "id": "v0.2.0/enhancements/transports-chunk-5",
        "text": "RetryOptions { MaxAttempts = 3, InitialDelay = TimeSpan FromMilliseconds(100), MaxDelay = TimeSpan FromSeconds(5), BackoffMultiplier = 2 }; }); }); // WebSocket configuration services AddWhizbangTransports(options => { options UseWebSocket(ws => { ws Url = \"wss://realtime example com/hub\"; ws ReconnectInterval = TimeSpan FromSeconds(5); ws HeartbeatInterval = TimeSpan FromSeconds(30); ws RequestTimeout = TimeSpan FromSeconds(10);\n    });\n});\n`\nTesting HTTP/WebSocket Transports\n`csharp\n[Test]\npublic class HttpTransportTests {\n    private HttpTransport _transport;\n    private MockHttpMessageHandler _mockHttp;\n    [SetUp]\n    public void Setup() {\n        _mockHttp = new MockHttpMessageHandler();\n        _transport = new HttpTransport(new HttpTransportOptions {\n            BaseUrl = \"http://test local\"\n        }, _mockHttp);\n    }\n    [Test]\n    public async Task Send_ShouldSerializeAndDeserialize() {\n        // Arrange\n        _mockHttp Expect(HttpMethod Post, \"http://test local/api/orders\") Respond(\"application/json\", \n                JsonSerializer Serialize(new OrderResponse { Success = true }));\n        // Act\n        var response = await _transport Send<CreateOrderCommand, OrderResponse>(\n            new CreateOrderCommand { CustomerId = Guid NewGuid() },\n            \"/api/orders\"\n        );\n        // Assert\n        Assert True(response Success);\n        _mockHttp VerifyNoOutstandingExpectation();\n    }\n}\n`\nPerformance Characteristics\n| Operation | v0 1 0 (In-Process) | v0 2 0 (HTTP) | v0 2 0 (WebSocket) |\n|-----------|-------------------|---------------|-------------------|\n| Send | < 100ns | < 50ms | < 10ms |\n| Publish | < 1μs | N/A | < 5ms |\n| Latency | 0 | Network dependent | Lower than HTTP |\n| Throughput | Unlimited | Limited by HTTP | Higher than HTTP |\nMigration from v0 1 0\nSupporting Multiple Transports\n`csharp\n// v0 1 0 - In-process only\nservices AddWhizbangTransports(options => {\n    options UseInProcess();\n});\n// v0 2 0 - Support both for gradual migration\nservices AddWhizbangTransports(options => {\n    options UseInProcess();  // For local components\n    options UseHttp(http => {  // For remote components\n        http BaseUrl = Configuration[\"RemoteApi:BaseUrl\"];\n    });\n});\n// Transport selector\npublic class TransportSelector {\n    public ITransport SelectTransport(string destination) {\n        return destination StartsWith(\"http://\") GetTransport<HttpTransport>()\n            : GetTransport<InProcessTransport>();\n    }\n}\n`\nRelated Documentation\nv0 1 0 Foundation - In-process transport\nv0 3",
        "startIndex": 13724,
        "preview": "RetryOptions { MaxAttempts = 3, InitialDelay = TimeSpan FromMilliseconds(100), MaxDelay = TimeSpan FromSeconds(5), BackoffMultiplier = 2 }; }); }); //..."
      },
      {
        "id": "v0.2.0/enhancements/transports-chunk-6",
        "text": "// For local components options UseHttp(http => { // For remote components http BaseUrl = Configuration[\"RemoteApi:BaseUrl\"]; }); }); // Transport selector public class TransportSelector { public ITransport SelectTransport(string destination) { return destination StartsWith(\"http://\") GetTransport<HttpTransport>() : GetTransport<InProcessTransport>(); } } ` Related Documentation v0 1 0 Foundation - In-process transport v0 3 0 Message Queues - Async messaging\nAPI Design - REST API best practices\nWebSocket Guide - Real-time patterns",
        "startIndex": 15888,
        "preview": "// For local components options UseHttp(http => { // For remote components http BaseUrl = Configuration[\"RemoteApi:BaseUrl\"]; }); }); // Transport sel..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.3.0/_folder",
    "title": "Version 0.3.0 - Event Sourcing",
    "category": "General",
    "url": "/docs/v0.3.0/_folder",
    "chunks": [
      {
        "id": "v0.3.0/_folder-chunk-0",
        "text": "",
        "startIndex": 0,
        "preview": ""
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.3.0/features/dispatcher",
    "title": "Saga Orchestration & Workflows",
    "category": "Features",
    "url": "/docs/v0.3.0/features/dispatcher",
    "chunks": [
      {
        "id": "v0.3.0/features/dispatcher-chunk-0",
        "text": "Saga Orchestration & Workflows Version Status Next Update\nVersion History\n:::updated\nEnhanced in v0 3 0: \nSaga pattern implementation\nMulti-step workflow orchestration\nAutomatic compensation and rollback\nProcess state management\nActivity monitoring and visualization\n:::\n:::planned\nComing in v0 5 0: \nDistributed saga coordination\nMulti-region orchestration\nWorkflow versioning and migration\nSee production features →\n:::\nSaga Implementation\nSaga Definition\n:::new\nDefine multi-step business processes with compensation:\n:::\n`csharp\npublic interface ISaga<TCommand> {\n    Task<SagaResult> Execute(TCommand command, ISagaContext context);\n}\npublic abstract class Saga<TCommand> : ISaga<TCommand> {\n    private readonly List<ISagaStep> _steps = new();\n    private readonly ISagaStateStore _stateStore;\n    protected void AddStep<TStepCommand, TStepResult>(\n        Func<TStepCommand, Task<TStepResult>> action,\n        Func<TStepResult, Task> compensate = null) {\n        _steps Add(new SagaStep<TStepCommand, TStepResult>(action, compensate));\n    }\n    public async Task<SagaResult> Execute(TCommand command, ISagaContext context) {\n        var sagaId = Guid NewGuid();\n        var state = new SagaState(sagaId, typeof(TCommand) Name);\n        try {\n            // Execute each step\n            foreach (var step in _steps) {\n                state CurrentStep = step Name;\n                await _stateStore SaveState(state);\n                var stepResult = await ExecuteStep(step, context);\n                state CompletedSteps Add(new CompletedStep(step Name, stepResult));\n            }\n            state Status = SagaStatus Completed;\n            await _stateStore SaveState(state);\n            return new SagaResult { Success = true, SagaId = sagaId };\n        }\n        catch (Exception ex) {\n            // Compensate in reverse order\n            await Compensate(state, ex);\n            state Status = SagaStatus Compensated;\n            await _stateStore SaveState(state);\n            return new SagaResult { \n                Success = false, \n                SagaId = sagaId,\n                Error = ex Message \n            };\n        }\n    }\n    private async Task Compensate(SagaState state, Exception error) {\n        // Execute compensation for completed steps in reverse\n        foreach (var step in state CompletedSteps Reverse()) {\n            try {\n                await step Compensate();\n                state CompensatedSteps Add(step Name);\n            }\n            catch (Exception compensationError) {\n                _logger LogError(compensationError, \n                    \"Compensation failed for step {Step}\", step Name);\n                state CompensationErrors Add(new CompensationError(\n                    step Name, compensationError",
        "startIndex": 0,
        "preview": "Saga Orchestration & Workflows Version Status Next Update\nVersion History\n:::updated\nEnhanced in v0 3 0: \nSaga pattern implementation\nMulti-step workf..."
      },
      {
        "id": "v0.3.0/features/dispatcher-chunk-1",
        "text": "state, Exception error) { // Execute compensation for completed steps in reverse foreach (var step in state CompletedSteps Reverse()) { try { await step Compensate(); state CompensatedSteps Add(step Name); } catch (Exception compensationError) { _logger LogError(compensationError, \"Compensation failed for step {Step}\", step Name); state CompensationErrors Add(new CompensationError( step Name, compensationError Message));\n            }\n        }\n    }\n}\n`\nOrder Processing Saga\n:::new\nExample saga for complex order processing:\n:::\n`csharp\n[WhizbangSaga]\npublic class OrderProcessingSaga : Saga<CreateOrder> {\n    private readonly IDispatcher _dispatcher;\n    private readonly IInventoryService _inventory;\n    private readonly IPaymentService _payment;\n    private readonly IShippingService _shipping;\n    public OrderProcessingSaga(\n        IDispatcher dispatcher,\n        IInventoryService inventory,\n        IPaymentService payment,\n        IShippingService shipping) {\n        _dispatcher = dispatcher;\n        _inventory = inventory;\n        _payment = payment;\n        _shipping = shipping;\n        DefineSteps();\n    }\n    private void DefineSteps() {\n        // Step 1: Reserve inventory\n        AddStep<ReserveInventory, InventoryReservation>(\n            action: async cmd => {\n                var reservation = await _inventory Reserve(cmd Items);\n                if ( reservation Success) {\n                    throw new InsufficientInventoryException();\n                }\n                return reservation;\n            },\n            compensate: async reservation => {\n                await _inventory Release(reservation ReservationId);\n            }\n        );\n        // Step 2: Process payment\n        AddStep<ProcessPayment, PaymentConfirmation>(\n            action: async cmd => {\n                var payment = await _payment Charge(cmd CustomerId, cmd Amount);\n                if ( payment Success) {\n                    throw new PaymentFailedException(payment Reason);\n                }\n                return payment;\n            },\n            compensate: async payment => {\n                await _payment Refund(payment TransactionId);\n            }\n        );\n        // Step 3: Create shipment\n        AddStep<CreateShipment, ShipmentDetails>(\n            action: async cmd => {\n                var shipment = await _shipping CreateShipment(cmd Order);\n                return shipment;\n            },\n            compensate: async shipment => {\n                await _shipping CancelShipment(shipment ShipmentId);\n            }\n        );\n        // Step 4: Send confirmation\n        AddStep<SendConfirmation, ConfirmationResult>(\n            action: async cmd => {\n                await _dispatcher Publish(new OrderConfirmed {\n                    OrderId = cmd OrderId,\n                    CustomerId = cmd",
        "startIndex": 2771,
        "preview": "state, Exception error) { // Execute compensation for completed steps in reverse foreach (var step in state CompletedSteps Reverse()) { try { await st..."
      },
      {
        "id": "v0.3.0/features/dispatcher-chunk-2",
        "text": "action: async cmd => { var shipment = await _shipping CreateShipment(cmd Order); return shipment; }, compensate: async shipment => { await _shipping CancelShipment(shipment ShipmentId); } ); // Step 4: Send confirmation AddStep<SendConfirmation, ConfirmationResult>( action: async cmd => { await _dispatcher Publish(new OrderConfirmed { OrderId = cmd OrderId, CustomerId = cmd CustomerId,\n                    ConfirmationNumber = GenerateConfirmationNumber()\n                });\n                return new ConfirmationResult { Sent = true };\n            }\n            // No compensation for notification\n        );\n    }\n}\n`\nWorkflow Orchestration\nProcess Manager\n:::new\nLong-running process management:\n:::\n`csharp\npublic interface IProcessManager<TState> where TState : ProcessState {\n    Task<ProcessResult> Handle(IMessage message);\n    Task<TState> GetState();\n    Task Timeout();\n}\npublic class OrderFulfillmentProcess : IProcessManager<OrderFulfillmentState> {\n    private readonly OrderFulfillmentState _state;\n    private readonly IDispatcher _dispatcher;\n    public async Task<ProcessResult> Handle(IMessage message) {\n        return message switch {\n            OrderCreated e => await HandleOrderCreated(e),\n            PaymentReceived e => await HandlePaymentReceived(e),\n            ItemsShipped e => await HandleItemsShipped(e),\n            OrderCancelled e => await HandleOrderCancelled(e),\n            _ => ProcessResult NotHandled\n        };\n    }\n    private async Task<ProcessResult> HandleOrderCreated(OrderCreated @event) {\n        _state OrderId = @event OrderId;\n        _state Status = FulfillmentStatus WaitingForPayment;\n        // Set timeout for payment\n        await ScheduleTimeout(TimeSpan FromHours(24));\n        // Request payment\n        await _dispatcher Send(new RequestPayment {\n            OrderId = @event OrderId,\n            Amount = @event Total\n        });\n        return ProcessResult Continue;\n    }\n    private async Task<ProcessResult> HandlePaymentReceived(PaymentReceived @event) {\n        if (_state Status = FulfillmentStatus WaitingForPayment) {\n            return ProcessResult InvalidState;\n        }\n        _state Status = FulfillmentStatus PreparingShipment;\n        _state PaymentId = @event PaymentId;\n        // Ship items\n        await _dispatcher Send(new ShipOrder {\n            OrderId = _state OrderId,\n            ShippingAddress = _state ShippingAddress\n        });\n        return ProcessResult Continue;\n    }\n    private async Task<ProcessResult> HandleItemsShipped(ItemsShipped @event) {\n        _state Status = FulfillmentStatus Completed;\n        _state CompletedAt = DateTimeOffset UtcNow;\n        // Notify customer\n        await _dispatcher Publish(new OrderFulfilled {\n            OrderId = _state OrderId,\n            TrackingNumber = @event TrackingNumber\n        });\n        return ProcessResult Complete;\n    }\n    public async Task Timeout() {\n        switch (_state Status) {\n            case FulfillmentStatus WaitingForPayment:\n                // Cancel order due to payment timeout\n                await _dispatcher",
        "startIndex": 5198,
        "preview": "action: async cmd => { var shipment = await _shipping CreateShipment(cmd Order); return shipment; }, compensate: async shipment => { await _shipping C..."
      },
      {
        "id": "v0.3.0/features/dispatcher-chunk-3",
        "text": "= FulfillmentStatus Completed; _state CompletedAt = DateTimeOffset UtcNow; // Notify customer await _dispatcher Publish(new OrderFulfilled { OrderId = _state OrderId, TrackingNumber = @event TrackingNumber }); return ProcessResult Complete; } public async Task Timeout() { switch (_state Status) { case FulfillmentStatus WaitingForPayment: // Cancel order due to payment timeout await _dispatcher Send(new CancelOrder {\n                    OrderId = _state OrderId,\n                    Reason = \"Payment timeout\"\n                });\n                break;\n        }\n    }\n}\n`\nState Machine\n:::new\nDeclarative state machine for workflows:\n:::\n`csharp\n[StateMachine(\"OrderStateMachine\")]\npublic class OrderStateMachine : StateMachine<OrderState> {\n    public OrderStateMachine() {\n        // Define states\n        State(OrderState New) On<OrderConfirmed>() TransitionTo(OrderState Confirmed) On<OrderCancelled>() TransitionTo(OrderState Cancelled);\n        State(OrderState Confirmed) OnEntry(async ctx => await SendConfirmationEmail(ctx)) On<PaymentReceived>() TransitionTo(OrderState Paid) On<OrderCancelled>() TransitionTo(OrderState Cancelled);\n        State(OrderState Paid) On<OrderShipped>() TransitionTo(OrderState Shipped) On<RefundRequested>() TransitionTo(OrderState Refunding);\n        State(OrderState Shipped) On<OrderDelivered>() TransitionTo(OrderState Delivered) On<ReturnRequested>() TransitionTo(OrderState Returning);\n        State(OrderState Delivered) OnEntry(async ctx => await RequestFeedback(ctx)) IsFinal();\n        State(OrderState Cancelled) OnEntry(async ctx => await ProcessCancellation(ctx)) IsFinal();\n        // Global handlers\n        AnyState() On<OrderError>() TransitionTo(OrderState Error);\n    }\n}\n// Usage\npublic class OrderService {\n    private readonly IStateMachineEngine _engine;\n    public async Task ProcessOrder(Guid orderId, IMessage message) {\n        var stateMachine = await _engine Load<OrderStateMachine>(orderId);\n        var result = await stateMachine Process(message);\n        if (result TransitionOccurred) {\n            await _engine Save(stateMachine);\n            // Publish state change event\n            await _dispatcher Publish(new OrderStateChanged {\n                OrderId = orderId,\n                FromState = result FromState,\n                ToState = result ToState,\n                Trigger = message GetType()",
        "startIndex": 7924,
        "preview": "= FulfillmentStatus Completed; _state CompletedAt = DateTimeOffset UtcNow; // Notify customer await _dispatcher Publish(new OrderFulfilled { OrderId =..."
      },
      {
        "id": "v0.3.0/features/dispatcher-chunk-4",
        "text": "Task ProcessOrder(Guid orderId, IMessage message) { var stateMachine = await _engine Load<OrderStateMachine>(orderId); var result = await stateMachine Process(message); if (result TransitionOccurred) { await _engine Save(stateMachine); // Publish state change event await _dispatcher Publish(new OrderStateChanged { OrderId = orderId, FromState = result FromState, ToState = result ToState, Trigger = message GetType() Name\n            });\n        }\n    }\n}\n`\nCompensation Patterns\nCompensating Transactions\n`csharp\npublic interface ICompensatable<TResult> {\n    Task<TResult> Execute();\n    Task Compensate(TResult result);\n}\npublic class CompensatingTransaction<TResult> : ICompensatable<TResult> {\n    private readonly Func<Task<TResult>> _action;\n    private readonly Func<TResult, Task> _compensation;\n    public CompensatingTransaction(\n        Func<Task<TResult>> action,\n        Func<TResult, Task> compensation) {\n        _action = action;\n        _compensation = compensation;\n    }\n    public Task<TResult> Execute() => _action();\n    public Task Compensate(TResult result) => _compensation(result);\n}\n// Saga with compensating transactions\npublic class TransactionalSaga {\n    private readonly List<ICompensatable<object>> _transactions = new();\n    private readonly Stack<object> _results = new();\n    public void AddTransaction<T>(ICompensatable<T> transaction) {\n        _transactions Add(new CompensatableWrapper<T>(transaction));\n    }\n    public async Task<bool> Execute() {\n        try {\n            foreach (var transaction in _transactions) {\n                var result = await transaction Execute();\n                _results Push(result);\n            }\n            return true;\n        }\n        catch {\n            await Rollback();\n            return false;\n        }\n    }\n    private async Task Rollback() {\n        while (_results Count > 0) {\n            var result = _results Pop();\n            var transaction = _transactions[_results Count];\n            try {\n                await transaction Compensate(result);\n            }\n            catch (Exception ex) {\n                _logger LogError(ex, \"Compensation failed\");\n                // Continue with other compensations\n            }\n        }\n    }\n}\n`\nActivity Monitoring\nSaga Visualization\n`csharp\npublic class SagaMonitor {\n    private readonly ISagaStateStore _stateStore;\n    public async Task<SagaVisualization> GetVisualization(Guid sagaId) {\n        var state = await _stateStore GetState(sagaId);\n        return new SagaVisualization {\n            SagaId = sagaId,\n            Type = state SagaType,\n            Status = state Status,\n            Steps = state Steps Select(step => new StepVisualization {\n                Name = step Name,\n                Status = GetStepStatus(step, state),\n                StartTime = step StartTime,\n                EndTime = step EndTime,\n                Duration = step EndTime - step StartTime,\n                Error = step",
        "startIndex": 10091,
        "preview": "Task ProcessOrder(Guid orderId, IMessage message) { var stateMachine = await _engine Load<OrderStateMachine>(orderId); var result = await stateMachine..."
      },
      {
        "id": "v0.3.0/features/dispatcher-chunk-5",
        "text": "return new SagaVisualization { SagaId = sagaId, Type = state SagaType, Status = state Status, Steps = state Steps Select(step => new StepVisualization { Name = step Name, Status = GetStepStatus(step, state), StartTime = step StartTime, EndTime = step EndTime, Duration = step EndTime - step StartTime, Error = step Error\n            }),\n            Timeline = GenerateTimeline(state),\n            Diagram = GenerateMermaidDiagram(state)\n        };\n    }\n    private string GenerateMermaidDiagram(SagaState state) {\n        var mermaid = new StringBuilder();\n        mermaid AppendLine(\"graph LR\");\n        foreach (var step in state Steps) {\n            var status = GetStepStatus(step, state);\n            var style = status switch {\n                StepStatus Completed => \"fill:#4CAF50\",\n                StepStatus Failed => \"fill:#F44336\",\n                StepStatus Compensated => \"fill:#FF9800\",\n                StepStatus Pending => \"fill:#9E9E9E\",\n                _ => \"\"\n            };\n            mermaid AppendLine($\"    {step Name}[{step Name}]\");\n            if ( string IsNullOrEmpty(style)) {\n                mermaid AppendLine($\"    style {step Name} {style}\");\n            }\n        }\n        return mermaid ToString();\n    }\n}\n`\nTesting Sagas\n`csharp\n[Test]\npublic class SagaTests {\n    [Test]\n    public async Task Saga_ShouldCompensateOnFailure() {\n        // Arrange\n        var saga = new TestSaga();\n        var context = new SagaContext();\n        // Force failure in third step\n        saga ConfigureStep(3, shouldFail: true);\n        // Act\n        var result = await saga Execute(new TestCommand(), context);\n        // Assert\n        Assert False(result Success);\n        Assert That(saga CompensatedSteps, Is EqualTo(new[] { \"Step2\", \"Step1\" }));\n    }\n    [Test]\n    public async Task ProcessManager_ShouldHandleTimeout() {\n        // Test timeout behavior\n    }\n}\n`\nPerformance Characteristics\n| Operation | Target | Notes |\n|-----------|--------|-------|\n| Saga step execution | < 10ms | Per step overhead |\n| State persistence | < 5ms | Async write |\n| Compensation | < 20ms | Per step |\n| Process manager dispatch | < 2ms | Message routing |\nMigration from v0 2 0\nAdding Saga Support\n`csharp\n// v0 2 0 - Pipeline dispatcher\nservices AddWhizbangDispatcher(options => {\n    options Pipeline(p => p Use<LoggingMiddleware>());\n});\n// v0 3 0 - Add saga orchestration\nservices AddWhizbangDispatcher(options => {\n    options",
        "startIndex": 12634,
        "preview": "return new SagaVisualization { SagaId = sagaId, Type = state SagaType, Status = state Status, Steps = state Steps Select(step => new StepVisualization..."
      },
      {
        "id": "v0.3.0/features/dispatcher-chunk-6",
        "text": "| Process manager dispatch | < 2ms | Message routing | Migration from v0 2 0 Adding Saga Support `csharp // v0 2 0 - Pipeline dispatcher services AddWhizbangDispatcher(options => { options Pipeline(p => p Use<LoggingMiddleware>()); }); // v0 3 0 - Add saga orchestration services AddWhizbangDispatcher(options => { options Pipeline(p => p Use<LoggingMiddleware>());\n    options EnableSagas(saga => {\n        saga UseStateStore<SqlSagaStateStore>();\n        saga RegisterSaga<OrderProcessingSaga>();\n        saga RegisterProcessManager<OrderFulfillmentProcess>();\n    });\n});\n`\nRelated Documentation\nv0 2 0 Pipeline - Middleware support\nv0 5 0 Production - Distributed orchestration\nSaga Patterns - Common saga implementations\nWorkflow Design - Best practices",
        "startIndex": 14633,
        "preview": "| Process manager dispatch | < 2ms | Message routing | Migration from v0 2 0 Adding Saga Support `csharp // v0 2 0 - Pipeline dispatcher services AddW..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.3.0/features/ledger",
    "title": "Event Sourcing & Projections",
    "category": "Features",
    "url": "/docs/v0.3.0/features/ledger",
    "chunks": [
      {
        "id": "v0.3.0/features/ledger-chunk-0",
        "text": "Event Sourcing & Projections Version Status Next Update\nVersion History\n:::updated\nEnhanced in v0 3 0: \nFull event sourcing with aggregates\nProjection management and rebuilding\nTime-travel queries\nEvent replay and debugging\n:::\n:::planned\nComing in v0 4 0: \nSQL/JSONB storage backend\nIndex-optimized queries\nPartitioned event streams\nSee database features →\n:::\n:::planned\nComing in v0 5 0: \nDistributed event store\nMulti-region replication\nEvent streaming protocols\nSee production features →\n:::\nEvent Sourcing Implementation\nAggregate Root Pattern\n:::new\nFull aggregate support with event sourcing:\n:::\n`csharp\npublic abstract class AggregateRoot {\n    private readonly List<IEvent> _uncommittedEvents = new();\n    public string Id { get; protected set; }\n    public int Version { get; private set; } = -1;\n    // Get uncommitted events for persistence\n    public IReadOnlyList<IEvent> GetUncommittedEvents() => _uncommittedEvents;\n    // Mark events as committed\n    public void MarkEventsAsCommitted() {\n        _uncommittedEvents Clear();\n    }\n    // Apply event and increment version\n    protected void ApplyEvent(IEvent @event, bool isNew = true) {\n        ((dynamic)this) Apply((dynamic)@event);\n        Version++;\n        if (isNew) {\n            _uncommittedEvents Add(@event);\n        }\n    }\n    // Load aggregate from history\n    public void LoadFromHistory(IEnumerable<IEvent> events) {\n        foreach (var @event in events) {\n            ApplyEvent(@event, isNew: false);\n        }\n    }\n}\n// Domain aggregate\npublic class Order : AggregateRoot {\n    public Guid CustomerId { get; private set; }\n    public OrderStatus Status { get; private set; }\n    public decimal Total { get; private set; }\n    public List<OrderItem> Items { get; private set; } = new();\n    // Commands create events\n    public void Create(Guid orderId, Guid customerId, List<OrderItem> items) {\n        ApplyEvent(new OrderCreated {\n            OrderId = orderId,\n            CustomerId = customerId,\n            Items = items,\n            Total = items Sum(i => i Price * i Quantity)\n        });\n    }\n    public void Ship(string trackingNumber) {\n        if (Status = OrderStatus Confirmed) {\n            throw new InvalidOperationException(\"Can only ship confirmed orders\");\n        }\n        ApplyEvent(new OrderShipped {\n            OrderId = Guid",
        "startIndex": 0,
        "preview": "Event Sourcing & Projections Version Status Next Update\nVersion History\n:::updated\nEnhanced in v0 3 0: \nFull event sourcing with aggregates\nProjection..."
      },
      {
        "id": "v0.3.0/features/ledger-chunk-1",
        "text": "{ ApplyEvent(new OrderCreated { OrderId = orderId, CustomerId = customerId, Items = items, Total = items Sum(i => i Price * i Quantity) }); } public void Ship(string trackingNumber) { if (Status = OrderStatus Confirmed) { throw new InvalidOperationException(\"Can only ship confirmed orders\"); } ApplyEvent(new OrderShipped { OrderId = Guid Parse(Id),\n            TrackingNumber = trackingNumber\n        });\n    }\n    // Event handlers update state\n    public void Apply(OrderCreated @event) {\n        Id = @event OrderId ToString();\n        CustomerId = @event CustomerId;\n        Items = @event Items ToList();\n        Total = @event Total;\n        Status = OrderStatus Created;\n    }\n    public void Apply(OrderShipped @event) {\n        Status = OrderStatus Shipped;\n    }\n}\n`\nEvent Store Repository\n:::new\nRepository pattern for aggregate persistence:\n:::\n`csharp\npublic interface IEventStoreRepository<T> where T : AggregateRoot {\n    Task<T> GetById(string id);\n    Task Save(T aggregate, ExpectedVersion expectedVersion = ExpectedVersion Any);\n    Task<bool> Exists(string id);\n}\npublic class EventStoreRepository<T> : IEventStoreRepository<T> \n    where T : AggregateRoot, new() {\n    private readonly IEventStore _eventStore;\n    private readonly ISnapshotStore _snapshots;\n    public async Task<T> GetById(string id) {\n        var aggregate = new T();\n        // Try loading from snapshot\n        var snapshot = await _snapshots GetLatest(GetStreamName(id));\n        if (snapshot = null) {\n            aggregate RestoreFromSnapshot(snapshot Data);\n            // Load events after snapshot\n            var events = await _eventStore ReadStream(\n                GetStreamName(id), \n                fromVersion: snapshot Version + 1\n            );\n            aggregate LoadFromHistory(events);\n        } else {\n            // No snapshot, load all events\n            var events = await _eventStore ReadStream(GetStreamName(id));\n            if ( events Any()) {\n                throw new AggregateNotFoundException(id);\n            }\n            aggregate LoadFromHistory(events);\n        }\n        return aggregate;\n    }\n    public async Task Save(T aggregate, ExpectedVersion expectedVersion = ExpectedVersion Any) {\n        var streamName = GetStreamName(aggregate Id);\n        var events = aggregate GetUncommittedEvents();\n        if ( events Any()) return;\n        // Save events\n        await _eventStore AppendToStream(\n            streamName, \n            events, \n            expectedVersion == ExpectedVersion Any expectedVersion \n                : aggregate Version - events Count\n        );\n        // Create snapshot if needed (every 50 events)\n        if (aggregate Version > 0 && aggregate",
        "startIndex": 2347,
        "preview": "{ ApplyEvent(new OrderCreated { OrderId = orderId, CustomerId = customerId, Items = items, Total = items Sum(i => i Price * i Quantity) }); } public v..."
      },
      {
        "id": "v0.3.0/features/ledger-chunk-2",
        "text": "var streamName = GetStreamName(aggregate Id); var events = aggregate GetUncommittedEvents(); if ( events Any()) return; // Save events await _eventStore AppendToStream( streamName, events, expectedVersion == ExpectedVersion Any expectedVersion : aggregate Version - events Count ); // Create snapshot if needed (every 50 events) if (aggregate Version > 0 && aggregate Version % 50 == 0) {\n            var snapshot = aggregate CreateSnapshot();\n            await _snapshots Save(streamName, aggregate Version, snapshot);\n        }\n        aggregate MarkEventsAsCommitted();\n    }\n    private string GetStreamName(string aggregateId) => $\"{typeof(T) Name}-{aggregateId}\";\n}\n`\nProjection Management\nProjection Definition\n:::new\nDefine projections that build read models from events:\n:::\n`csharp\n[Projection(\"OrderSummary\")]\npublic class OrderSummaryProjection : IProjection {\n    private readonly IProjectionStore _store;\n    // Current checkpoint for this projection\n    public long Checkpoint { get; private set; }\n    // Handle specific events\n    public async Task Handle(OrderCreated @event, EventMetadata metadata) {\n        await _store Upsert(\"OrderSummary\", @event OrderId, new {\n            OrderId = @event OrderId,\n            CustomerId = @event CustomerId,\n            Total = @event Total,\n            Status = \"Created\",\n            CreatedAt = metadata Timestamp,\n            ItemCount = @event Items Count\n        });\n        Checkpoint = metadata Position;\n    }\n    public async Task Handle(OrderShipped @event, EventMetadata metadata) {\n        await _store Update(\"OrderSummary\", @event OrderId, doc => {\n            doc Status = \"Shipped\";\n            doc ShippedAt = metadata Timestamp;\n        });\n        Checkpoint = metadata Position;\n    }\n    public async Task Handle(OrderCancelled @event, EventMetadata metadata) {\n        await _store Update(\"OrderSummary\", @event OrderId, doc => {\n            doc Status = \"Cancelled\";\n            doc CancelledAt = metadata Timestamp;\n        });\n        Checkpoint = metadata Position;\n    }\n}\n`\nProjection Rebuilding\n:::new\nRebuild projections from event history:\n:::\n`csharp\npublic interface IProjectionManager {\n    Task RebuildProjection(string projectionName, DateTime from = null);\n    Task<ProjectionStatus> GetStatus(string projectionName);\n    Task PauseProjection(string projectionName);\n    Task ResumeProjection(string projectionName);\n}\npublic class ProjectionManager : IProjectionManager {\n    private readonly IEventStore _eventStore;\n    private readonly IProjectionStore _projectionStore;\n    private readonly IProjectionRegistry _registry;\n    public async Task RebuildProjection(string projectionName, DateTime from = null) {\n        // Get projection instance\n        var projection = _registry",
        "startIndex": 4742,
        "preview": "var streamName = GetStreamName(aggregate Id); var events = aggregate GetUncommittedEvents(); if ( events Any()) return; // Save events await _eventSto..."
      },
      {
        "id": "v0.3.0/features/ledger-chunk-3",
        "text": "DateTime from = null); Task<ProjectionStatus> GetStatus(string projectionName); Task PauseProjection(string projectionName); Task ResumeProjection(string projectionName); } public class ProjectionManager : IProjectionManager { private readonly IEventStore _eventStore; private readonly IProjectionStore _projectionStore; private readonly IProjectionRegistry _registry; public async Task RebuildProjection(string projectionName, DateTime from = null) { // Get projection instance var projection = _registry GetProjection(projectionName);\n        // Clear existing projection data\n        if (from == null) {\n            await _projectionStore Clear(projectionName);\n            projection Checkpoint = 0;\n        }\n        // Stream all events from checkpoint\n        var position = from = null await _eventStore GetPositionAt(from Value)\n            : GlobalPosition Start;\n        await foreach (var @event in _eventStore ReadAll(position)) {\n            // Dispatch to projection handlers\n            await projection Handle(@event Data, @event Metadata);\n            // Save checkpoint periodically\n            if (@event Metadata Position % 1000 == 0) {\n                await SaveCheckpoint(projectionName, @event Metadata Position);\n            }\n        }\n        // Save final checkpoint\n        await SaveCheckpoint(projectionName, projection Checkpoint);\n    }\n}\n`\nTime-Travel Queries\nQuery Historical State\n:::new\nQuery system state at any point in time:\n:::\n`csharp\npublic interface ITimeTravelQuery {\n    Task<T> GetAggregateAt<T>(string aggregateId, DateTime asOf) where T : AggregateRoot, new();\n    Task<IReadOnlyList<T>> QueryAt<T>(DateTime asOf, Expression<Func<T, bool>> predicate);\n}\npublic class TimeTravelQuery : ITimeTravelQuery {\n    private readonly IEventStore _eventStore;\n    public async Task<T> GetAggregateAt<T>(string aggregateId, DateTime asOf) \n        where T : AggregateRoot, new() {\n        var aggregate = new T();\n        var streamName = $\"{typeof(T) Name}-{aggregateId}\";\n        // Read events up to specified time\n        await foreach (var @event in _eventStore ReadStream(streamName)) {\n            if (@event Metadata Timestamp > asOf) break;\n            aggregate LoadFromHistory(new[] { @event Data });\n        }\n        return aggregate;\n    }\n    public async Task<Order> GetOrderStatus(Guid orderId, DateTime when) {\n        return await GetAggregateAt<Order>(orderId ToString(), when);\n    }\n}\n// Usage\npublic class HistoricalAnalysis {\n    private readonly ITimeTravelQuery _timeTravel;\n    public async Task AnalyzeOrderHistory(Guid orderId) {\n        var now = DateTime UtcNow;\n        var yesterday = now AddDays(-1);\n        var lastWeek = now AddDays(-7);\n        var orderNow = await _timeTravel GetAggregateAt<Order>(orderId ToString(), now);\n        var orderYesterday = await _timeTravel GetAggregateAt<Order>(orderId",
        "startIndex": 7158,
        "preview": "DateTime from = null); Task<ProjectionStatus> GetStatus(string projectionName); Task PauseProjection(string projectionName); Task ResumeProjection(str..."
      },
      {
        "id": "v0.3.0/features/ledger-chunk-4",
        "text": "GetAggregateAt<Order>(orderId ToString(), when); } } // Usage public class HistoricalAnalysis { private readonly ITimeTravelQuery _timeTravel; public async Task AnalyzeOrderHistory(Guid orderId) { var now = DateTime UtcNow; var yesterday = now AddDays(-1); var lastWeek = now AddDays(-7); var orderNow = await _timeTravel GetAggregateAt<Order>(orderId ToString(), now); var orderYesterday = await _timeTravel GetAggregateAt<Order>(orderId ToString(), yesterday);\n        var orderLastWeek = await _timeTravel GetAggregateAt<Order>(orderId ToString(), lastWeek);\n        Console WriteLine($\"Order status evolution:\");\n        Console WriteLine($\"  Last week: {orderLastWeek Status \"Not created\"}\");\n        Console WriteLine($\"  Yesterday: {orderYesterday Status \"Not created\"}\");\n        Console WriteLine($\"  Now: {orderNow Status}\");\n    }\n}\n`\nEvent Replay & Debugging\n:::new\nReplay events for debugging and analysis:\n:::\n`csharp\npublic class EventReplayer {\n    private readonly IEventStore _eventStore;\n    public async Task ReplayEvents(\n        DateTime from, \n        DateTime to,\n        Func<IEvent, EventMetadata, Task> handler) {\n        var startPos = await _eventStore GetPositionAt(from);\n        await foreach (var envelope in _eventStore ReadAll(startPos)) {\n            if (envelope Metadata Timestamp > to) break;\n            await handler(envelope Data, envelope Metadata);\n        }\n    }\n    public async Task DebugEventFlow(string streamId) {\n        Console WriteLine($\"Event flow for stream: {streamId}\");\n        Console WriteLine(new string('-', 50));\n        await foreach (var envelope in _eventStore ReadStream(streamId)) {\n            Console WriteLine($\"[{envelope Metadata Timestamp:HH:mm:ss fff}] \" +\n                            $\"v{envelope Metadata Version} \" +\n                            $\"{envelope Data GetType() Name}\");\n            Console WriteLine($\"  Data: {JsonSerializer Serialize(envelope Data)}\");\n            Console WriteLine();\n        }\n    }\n}\n`\nAdvanced Features\nSubscription Management\n`csharp\npublic interface IEventSubscription : IDisposable {\n    string SubscriptionId { get; }\n    Task Start(CancellationToken cancellationToken = default);\n    Task Stop();\n}\npublic class LiveEventSubscription : IEventSubscription {\n    private readonly IEventStore _eventStore;\n    private readonly Func<IEvent, Task> _handler;\n    public async Task Start(CancellationToken cancellationToken = default) {\n        var checkpoint = await LoadCheckpoint();\n        // Subscribe to live events\n        await foreach (var envelope in _eventStore SubscribeToAll(checkpoint) WithCancellation(cancellationToken)) {\n            await _handler(envelope Data);\n            await SaveCheckpoint(envelope Metadata",
        "startIndex": 9547,
        "preview": "GetAggregateAt<Order>(orderId ToString(), when); } } // Usage public class HistoricalAnalysis { private readonly ITimeTravelQuery _timeTravel; public ..."
      },
      {
        "id": "v0.3.0/features/ledger-chunk-5",
        "text": "Stop(); } public class LiveEventSubscription : IEventSubscription { private readonly IEventStore _eventStore; private readonly Func<IEvent, Task> _handler; public async Task Start(CancellationToken cancellationToken = default) { var checkpoint = await LoadCheckpoint(); // Subscribe to live events await foreach (var envelope in _eventStore SubscribeToAll(checkpoint) WithCancellation(cancellationToken)) { await _handler(envelope Data); await SaveCheckpoint(envelope Metadata Position);\n        }\n    }\n}\n`\nTesting Event Sourcing\n`csharp\n[Test]\npublic class EventSourcingTests {\n    [Test]\n    public async Task Aggregate_ShouldRehydrateFromEvents() {\n        // Arrange\n        var repository = new EventStoreRepository<Order>();\n        var orderId = Guid NewGuid();\n        var order = new Order();\n        order Create(orderId, Guid NewGuid(), items);\n        order Confirm();\n        order Ship(\"TRACK123\");\n        // Act - save and reload\n        await repository Save(order);\n        var loaded = await repository GetById(orderId ToString());\n        // Assert\n        Assert Equal(OrderStatus Shipped, loaded Status);\n        Assert Equal(2, loaded Version); // 3 events = version 2 (0-based)\n    }\n    [Test]\n    public async Task Projection_ShouldRebuildFromEvents() {\n        // Test projection rebuilding\n    }\n}\n`\nPerformance Characteristics\n| Operation | Target | Notes |\n|-----------|--------|-------|\n| Load aggregate (50 events) | < 10ms | With snapshot: < 2ms |\n| Save aggregate | < 5ms | Single stream append |\n| Rebuild projection (100k events) | < 30s | ~3,300 events/sec |\n| Time-travel query | < 50ms | Depends on history depth |\nMigration from v0 2 0\nNew Concepts\nAggregate roots for domain modeling\nProjections for read models\nTime-travel queries\nEvent subscriptions\nCode Changes\n`csharp\n// v0 2 0 - Direct event append\nawait ledger Append(\"order-123\", new OrderCreated( ));\n// v0 3 0 - Through aggregates\nvar order = new Order();\norder Create(orderId, customerId, items);\nawait repository Save(order);\n`\nRelated Documentation\nv0 2 0 Persistence - File storage\nv0 4 0 Database - SQL/JSONB backend\nv0 5 0 Production - Distributed event store\nEvent Sourcing Guide - Best practices\nProjection Patterns - Common patterns",
        "startIndex": 11887,
        "preview": "Stop(); } public class LiveEventSubscription : IEventSubscription { private readonly IEventStore _eventStore; private readonly Func<IEvent, Task> _han..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.3.0/features/policies",
    "title": "Stateful Policy Management",
    "category": "Features",
    "url": "/docs/v0.3.0/features/policies",
    "chunks": [
      {
        "id": "v0.3.0/features/policies-chunk-0",
        "text": "Stateful Policy Management Version Status Next Update\nVersion History\n:::updated\nEnhanced in v0 3 0: \nPersistent policy state across restarts\nComprehensive metrics and monitoring\nDynamic policy reconfiguration\nPolicy health checks\n:::\n:::planned\nComing in v0 5 0: \nDistributed policy coordination\nPolicy federation across services\nAdvanced analytics and ML-based tuning\nSee production features →\n:::\nState Management\nPersistent Circuit Breakers\n:::new\nCircuit breaker state survives restarts:\n:::\n`csharp\n// Configure persistent state\nservices AddPolicyState(options => {\n    options UseRedis(\"localhost:6379\");\n    options StatePrefix = \"whizbang:policies\";\n    options StateTTL = TimeSpan FromHours(24);\n});\n[CircuitBreaker(\n    FailureThreshold = 0 5,\n    SamplingDuration = 10,\n    StatePersistence = true,  // New in v0 3 0\n    StateKey = \"order-service-breaker\"\n)]\npublic class OrderServiceReceptor : IReceptor<CallOrderService> {\n    public async Task<OrderResult> Receive(CallOrderService cmd) {\n        // Circuit state persisted to Redis\n        // Survives process restarts\n        // Shared across instances\n        return await CallService(cmd);\n    }\n}\n`\nStateful Rate Limiting\n:::new\nRate limits with persistent token buckets:\n:::\n`csharp\n[RateLimit(\n    TokenLimit = 1000,\n    Window = TimeSpan FromHour(1),\n    StatePersistence = true,\n    StateKey = \"api-rate-limit\",\n    Scope = RateLimitScope Global  // Across all instances\n)]\npublic class ApiReceptor : IReceptor<ApiCall> { }\n// Per-user rate limiting\n[RateLimit(\n    TokenLimit = 100,\n    Window = TimeSpan FromMinute(1),\n    StatePersistence = true,\n    StateKeyFactory = context => $\"user:{context UserId}\",\n    Scope = RateLimitScope PerIdentity\n)]\npublic class UserApiReceptor : IReceptor<UserApiCall> { }\n`\nCache State Management\n:::new\nDistributed cache with state tracking:\n:::\n`csharp\n[Cache(\n    Duration = 300,\n    StateProvider = CacheStateProvider Redis,\n    EvictionPolicy = EvictionPolicy LRU,\n    MaxEntries = 10000,\n    TrackHitRate = true  // New in v0 3",
        "startIndex": 0,
        "preview": "Stateful Policy Management Version Status Next Update\nVersion History\n:::updated\nEnhanced in v0 3 0: \nPersistent policy state across restarts\nComprehe..."
      },
      {
        "id": "v0.3.0/features/policies-chunk-1",
        "text": "=> $\"user:{context UserId}\", Scope = RateLimitScope PerIdentity )] public class UserApiReceptor : IReceptor<UserApiCall> { } ` Cache State Management :::new Distributed cache with state tracking: ::: `csharp [Cache( Duration = 300, StateProvider = CacheStateProvider Redis, EvictionPolicy = EvictionPolicy LRU, MaxEntries = 10000, TrackHitRate = true // New in v0 3 0\n)]\npublic class ProductLens : IProductLens {\n    public Product Focus(Guid productId) {\n        // Cache state includes:\n        // - Hit/miss rates\n        // - Access patterns\n        // - Memory usage\n        return LoadProduct(productId);\n    }\n}\n`\nMetrics and Monitoring\nBuilt-in Metrics\n:::new\nComprehensive policy metrics out of the box:\n:::\n`csharp\n// Automatic metrics for all policies\n[EnablePolicyMetrics]\npublic class MonitoredReceptor : IReceptor<Command> { }\n// Available metrics:\n// - policy executions total\n// - policy executions successful\n// - policy executions failed\n// - policy duration p50/p95/p99\n// - retry attempts total\n// - circuitbreaker state changes\n// - ratelimit rejections total\n// - cache hit rate\n// - bulkhead queue length\n`\nCustom Metrics\n`csharp\npublic class CustomMetricsPolicy : IPolicyOf<IReceptor> {\n    private readonly IMetricsCollector _metrics;\n    public async Task<TResult> Execute<TResult>(\n        Func<Task<TResult>> operation,\n        IPolicyContext context\n    ) {\n        using var timer = _metrics StartTimer(\"custom policy duration\");\n        try {\n            var result = await operation();\n            _metrics Increment(\"custom policy success\");\n            return result;\n        }\n        catch (Exception ex) {\n            _metrics Increment($\"custom policy failure {ex GetType() Name}\");\n            throw;\n        }\n    }\n}\n`\nPolicy Dashboard\n:::new\nReal-time policy monitoring dashboard:\n:::\n`csharp\n// Enable policy dashboard\nservices AddPolicyDashboard(options => {\n    options Path = \"/policies\";\n    options RefreshInterval = TimeSpan FromSeconds(5);\n    options",
        "startIndex": 2048,
        "preview": "=> $\"user:{context UserId}\", Scope = RateLimitScope PerIdentity )] public class UserApiReceptor : IReceptor<UserApiCall> { } ` Cache State Management ..."
      },
      {
        "id": "v0.3.0/features/policies-chunk-2",
        "text": "_metrics Increment(\"custom policy success\"); return result; } catch (Exception ex) { _metrics Increment($\"custom policy failure {ex GetType() Name}\"); throw; } } } ` Policy Dashboard :::new Real-time policy monitoring dashboard: ::: `csharp // Enable policy dashboard services AddPolicyDashboard(options => { options Path = \"/policies\"; options RefreshInterval = TimeSpan FromSeconds(5); options ShowDetailedMetrics = true;\n});\n// Dashboard shows:\n// - Policy execution rates\n// - Success/failure ratios\n// - Circuit breaker states\n// - Rate limit utilization\n// - Cache efficiency\n// - Bulkhead saturation\n`\nDynamic Configuration\nRuntime Policy Updates\n:::new\nChange policy configuration without restart:\n:::\n`csharp\npublic interface IPolicyConfigurator {\n    void Configure(string policyName, Action<PolicyBuilder> configure);\n    void Disable(string policyName);\n    void Enable(string policyName);\n    PolicyState GetState(string policyName);\n}\n// Usage\npublic class PolicyController {\n    private readonly IPolicyConfigurator _configurator;\n    public void AdjustForLoad(SystemMetrics metrics) {\n        if (metrics CpuUsage > 80) {\n            // Tighten rate limits under high load\n            _configurator Configure(\"ApiRateLimit\", policy => {\n                policy UpdateRateLimit(50, TimeSpan FromSecond(1));\n            });\n            // Reduce circuit breaker sensitivity\n            _configurator Configure(\"ServiceBreaker\", policy => {\n                policy UpdateCircuitBreaker(threshold: 0 7);\n            });\n        }\n    }\n    public void EmergencyMode() {\n        // Disable non-critical policies\n        _configurator Disable(\"CachePolicy\");\n        _configurator Disable(\"OptimizationPolicy\");\n        // Strengthen critical policies\n        _configurator Configure(\"SecurityPolicy\", policy => {\n            policy AddTimeout(1000);\n            policy AddRetry(5);\n        });\n    }\n}\n`\nConfiguration Sources\n`csharp\n// Configuration from various sources\nservices AddPolicyConfiguration(options => {\n    options Sources Add(new JsonFileConfiguration(\"policies json\"));\n    options Sources Add(new ConsulConfiguration(\"consul:8500\"));\n    options Sources Add(new EnvironmentConfiguration());\n    options ReloadOnChange = true;\n    options ReloadInterval = TimeSpan FromMinutes(1);\n});\n// policies json\n{\n  \"policies\": {\n    \"OrderProcessing\": {\n      \"retry\": { \"attempts\": 3, \"backoff\": \"exponential\" },\n      \"timeout\": { \"duration\": 5000 },\n      \"circuitBreaker\": { \"threshold\": 0 5 }\n    }\n  }\n}\n`\nHealth Checks\nPolicy Health Monitoring\n:::new\nBuilt-in health checks for policies:\n:::\n`csharp\nservices AddHealthChecks() AddPolicyHealth(\"OrderServiceBreaker\", options => {\n        options UnhealthyWhenOpen = true;\n        options DegradedWhenHalfOpen = true;\n    }) AddRateLimitHealth(\"ApiRateLimit\", options => {\n        options",
        "startIndex": 3684,
        "preview": "_metrics Increment(\"custom policy success\"); return result; } catch (Exception ex) { _metrics Increment($\"custom policy failure {ex GetType() Name}\");..."
      },
      {
        "id": "v0.3.0/features/policies-chunk-3",
        "text": "\"exponential\" }, \"timeout\": { \"duration\": 5000 }, \"circuitBreaker\": { \"threshold\": 0 5 } } } } ` Health Checks Policy Health Monitoring :::new Built-in health checks for policies: ::: `csharp services AddHealthChecks() AddPolicyHealth(\"OrderServiceBreaker\", options => { options UnhealthyWhenOpen = true; options DegradedWhenHalfOpen = true; }) AddRateLimitHealth(\"ApiRateLimit\", options => { options UnhealthyUtilization = 0 95;\n        options DegradedUtilization = 0 8;\n    }) AddCacheHealth(\"ProductCache\", options => {\n        options MinimumHitRate = 0 7;\n        options MaximumMemoryMB = 500;\n    });\n// Health endpoint returns:\n{\n  \"status\": \"Degraded\",\n  \"policies\": {\n    \"OrderServiceBreaker\": {\n      \"status\": \"Healthy\",\n      \"state\": \"Closed\",\n      \"failureRate\": 0 02\n    },\n    \"ApiRateLimit\": {\n      \"status\": \"Degraded\",\n      \"utilization\": 0 82,\n      \"tokensAvailable\": 180\n    },\n    \"ProductCache\": {\n      \"status\": \"Healthy\",\n      \"hitRate\": 0 85,\n      \"memoryUsageMB\": 234\n    }\n  }\n}\n`\nState Persistence Options\nStorage Providers\n`csharp\n// Redis (recommended for production)\nservices AddPolicyState(options => {\n    options UseRedis(redis => {\n        redis ConnectionString = \"localhost:6379\";\n        redis Database = 0;\n        redis KeyPrefix = \"whizbang:policies\";\n    });\n});\n// SQL Server\nservices AddPolicyState(options => {\n    options UseSqlServer(sql => {\n        sql ConnectionString = \" \";\n        sql Schema = \"policies\";\n        sql TablePrefix = \"Policy\";\n    });\n});\n// In-Memory (for testing)\nservices AddPolicyState(options => {\n    options UseInMemory();\n});\n// Custom provider\nservices AddPolicyState(options => {\n    options UseCustom<MyStateProvider>();\n});\n`\nTesting Stateful Policies\n`csharp\n[Test]\npublic class StatefulPolicyTests {\n    [Test]\n    public async Task CircuitBreaker_StateShouldPersist() {\n        // Arrange\n        var stateProvider = new InMemoryStateProvider();\n        var breaker = new CircuitBreakerPolicy(\n            threshold: 0 5,\n            stateProvider: stateProvider,\n            stateKey: \"test-breaker\"\n        );\n        // Act - cause failures to open circuit\n        for (int i = 0; i < 5; i++) {\n            try {\n                await breaker Execute(() => throw new Exception(), new PolicyContext());\n            } catch { }\n        }\n        // Create new instance with same state\n        var breaker2 = new CircuitBreakerPolicy(\n            threshold: 0 5,\n            stateProvider: stateProvider,\n            stateKey: \"test-breaker\"\n        );\n        // Assert - state persisted\n        Assert Equal(CircuitState Open, breaker2",
        "startIndex": 6158,
        "preview": "\"exponential\" }, \"timeout\": { \"duration\": 5000 }, \"circuitBreaker\": { \"threshold\": 0 5 } } } } ` Health Checks Policy Health Monitoring :::new Built-i..."
      },
      {
        "id": "v0.3.0/features/policies-chunk-4",
        "text": "i < 5; i++) { try { await breaker Execute(() => throw new Exception(), new PolicyContext()); } catch { } } // Create new instance with same state var breaker2 = new CircuitBreakerPolicy( threshold: 0 5, stateProvider: stateProvider, stateKey: \"test-breaker\" ); // Assert - state persisted Assert Equal(CircuitState Open, breaker2 State);\n    }\n    [Test]\n    public async Task Metrics_ShouldTrackExecution() {\n        // Test metrics collection\n    }\n}\n`\nPerformance Impact\n| Feature | Overhead | Notes |\n|---------|----------|-------|\n| State Persistence | < 5ms | Redis latency |\n| Metrics Collection | < 100ns | In-memory counters |\n| Health Checks | < 1ms | Cached for 1 second |\n| Dynamic Config | < 10ms | Config reload time |\nMigration from v0 2 0\nNew Requirements\nRedis or SQL Server for state persistence\nMetrics sink (Prometheus, AppInsights, etc )\nHealth check endpoint configuration\nConfiguration Changes\n`csharp\n// v0 2 0\n[CircuitBreaker(0 5, 10, 5, 30)]\n// v0 3 0 - Add state persistence\n[CircuitBreaker(\n    FailureThreshold = 0 5,\n    SamplingDuration = 10,\n    MinimumThroughput = 5,\n    BreakDuration = 30,\n    StatePersistence = true,\n    StateKey = \"my-breaker\"\n)]\n`\nRelated Documentation\nv0 2 0 Enhancements - Policy composition\nv0 5 0 Production - Distributed coordination\nMonitoring Guide - Setting up dashboards\nState Management - Persistence strategies",
        "startIndex": 8396,
        "preview": "i < 5; i++) { try { await breaker Execute(() => throw new Exception(), new PolicyContext()); } catch { } } // Create new instance with same state var ..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.3.0/features/transports",
    "title": "Message Queue Transports",
    "category": "Features",
    "url": "/docs/v0.3.0/features/transports",
    "chunks": [
      {
        "id": "v0.3.0/features/transports-chunk-0",
        "text": "Message Queue Transports Version Status Next Update\nVersion History\n:::updated\nEnhanced in v0 3 0: \nRabbitMQ transport with exchanges and routing\nApache Kafka transport for event streaming\nRedis pub/sub for lightweight messaging\nDead letter queues and poison message handling\nMessage persistence and durability\n:::\n:::planned\nComing in v0 4 0: \ngRPC transport with streaming\nGraphQL subscriptions\nServer-Sent Events (SSE)\nSee streaming features →\n:::\n:::planned\nComing in v0 5 0: \nCloud-native transports (SQS, Service Bus, Pub/Sub)\nMulti-cloud federation\nGlobal message routing\nSee production features →\n:::\nMessage Queue Architecture\nRabbitMQ Transport\n:::new\nFull RabbitMQ support with advanced routing:\n:::\n`csharp\n[WhizbangTransport(\"RabbitMQ\")]\npublic class RabbitMQTransport : ITransport, IReliableTransport {\n    private readonly IConnection _connection;\n    private readonly IModel _channel;\n    private readonly RabbitMQOptions _options;\n    private readonly ISerializer _serializer;\n    public string Name => \"RabbitMQ\";\n    public TransportCapabilities Capabilities => \n        TransportCapabilities PublishSubscribe |\n        TransportCapabilities Reliable |\n        TransportCapabilities Ordered;\n    public RabbitMQTransport(RabbitMQOptions options) {\n        _options = options;\n        _serializer = new MessagePackSerializer();\n        var factory = new ConnectionFactory {\n            Uri = new Uri(options ConnectionString),\n            AutomaticRecoveryEnabled = true,\n            NetworkRecoveryInterval = TimeSpan FromSeconds(10),\n            RequestedHeartbeat = TimeSpan FromSeconds(60),\n            DispatchConsumersAsync = true\n        };\n        _connection = factory CreateConnection($\"Whizbang-{Environment MachineName}\");\n        _channel = _connection CreateModel();\n        // Configure channel\n        _channel BasicQos(prefetchSize: 0, prefetchCount: options PrefetchCount, global: false);\n        // Declare exchanges\n        DeclareExchanges();\n    }\n    private void DeclareExchanges() {\n        // Topic exchange for pub/sub\n        _channel ExchangeDeclare(\n            exchange: $\"{_options ExchangePrefix} events\",\n            type: ExchangeType Topic,\n            durable: true,\n            autoDelete: false\n        );\n        // Direct exchange for commands\n        _channel ExchangeDeclare(\n            exchange: $\"{_options ExchangePrefix} commands\",\n            type: ExchangeType Direct,\n            durable: true,\n            autoDelete: false\n        );\n        // Headers exchange for complex routing\n        _channel ExchangeDeclare(\n            exchange: $\"{_options ExchangePrefix} headers\",\n            type: ExchangeType Headers,\n            durable: true,\n            autoDelete: false\n        );\n        // Dead letter exchange\n        _channel ExchangeDeclare(\n            exchange: $\"{_options ExchangePrefix} dlx\",\n            type: ExchangeType",
        "startIndex": 0,
        "preview": "Message Queue Transports Version Status Next Update\nVersion History\n:::updated\nEnhanced in v0 3 0: \nRabbitMQ transport with exchanges and routing\nApac..."
      },
      {
        "id": "v0.3.0/features/transports-chunk-1",
        "text": "Direct exchange for commands _channel ExchangeDeclare( exchange: $\"{_options ExchangePrefix} commands\", type: ExchangeType Direct, durable: true, autoDelete: false ); // Headers exchange for complex routing _channel ExchangeDeclare( exchange: $\"{_options ExchangePrefix} headers\", type: ExchangeType Headers, durable: true, autoDelete: false ); // Dead letter exchange _channel ExchangeDeclare( exchange: $\"{_options ExchangePrefix} dlx\", type: ExchangeType Fanout,\n            durable: true,\n            autoDelete: false\n        );\n    }\n    public async Task<TResponse> Send<TRequest, TResponse>(\n        TRequest request, \n        string destination)\n        where TRequest : IMessage\n        where TResponse : IMessage {\n        // Create temporary reply queue\n        var replyQueue = _channel QueueDeclare(\n            queue: \"\",\n            durable: false,\n            exclusive: true,\n            autoDelete: true\n        ) QueueName;\n        var correlationId = Guid NewGuid() ToString();\n        var tcs = new TaskCompletionSource<TResponse>();\n        // Setup consumer for reply\n        var consumer = new AsyncEventingBasicConsumer(_channel);\n        consumer Received += async (sender, ea) => {\n            if (ea BasicProperties CorrelationId == correlationId) {\n                var response = _serializer Deserialize<TResponse>(ea Body ToArray());\n                tcs SetResult(response);\n            }\n        };\n        _channel BasicConsume(replyQueue, autoAck: true, consumer);\n        // Send request\n        var properties = _channel CreateBasicProperties();\n        properties CorrelationId = correlationId;\n        properties ReplyTo = replyQueue;\n        properties Persistent = _options PersistentMessages;\n        properties Expiration = _options MessageTTL TotalMilliseconds ToString();\n        properties Headers = ConvertHeaders(request Headers);\n        var body = _serializer Serialize(request);\n        _channel BasicPublish(\n            exchange: $\"{_options ExchangePrefix} commands\",\n            routingKey: destination,\n            basicProperties: properties,\n            body: body\n        );\n        // Wait for response with timeout\n        using var cts = new CancellationTokenSource(_options RequestTimeout);\n        cts Token Register(() => tcs TrySetCanceled());\n        return await tcs Task;\n    }\n    public async Task Publish<TMessage>(TMessage message, string topic)\n        where TMessage : IMessage {\n        var properties = _channel CreateBasicProperties();\n        properties Persistent = _options PersistentMessages;\n        properties MessageId = message Id ToString();\n        properties Timestamp = new AmqpTimestamp(DateTimeOffset UtcNow ToUnixTimeSeconds());\n        properties Type = typeof(TMessage) FullName;\n        properties Headers = ConvertHeaders(message Headers);\n        var body = _serializer Serialize(message);\n        _channel BasicPublish(\n            exchange: $\"{_options ExchangePrefix} events\",\n            routingKey: topic,\n            basicProperties: properties,\n            body: body\n        );\n        await Task",
        "startIndex": 2911,
        "preview": "Direct exchange for commands _channel ExchangeDeclare( exchange: $\"{_options ExchangePrefix} commands\", type: ExchangeType Direct, durable: true, auto..."
      },
      {
        "id": "v0.3.0/features/transports-chunk-2",
        "text": "_channel CreateBasicProperties(); properties Persistent = _options PersistentMessages; properties MessageId = message Id ToString(); properties Timestamp = new AmqpTimestamp(DateTimeOffset UtcNow ToUnixTimeSeconds()); properties Type = typeof(TMessage) FullName; properties Headers = ConvertHeaders(message Headers); var body = _serializer Serialize(message); _channel BasicPublish( exchange: $\"{_options ExchangePrefix} events\", routingKey: topic, basicProperties: properties, body: body ); await Task CompletedTask;\n    }\n    public async Task Subscribe<TMessage>(string topic, Func<TMessage, Task> handler)\n        where TMessage : IMessage {\n        // Declare queue for subscription\n        var queueName = $\"{_options QueuePrefix} {typeof(TMessage) Name} {Guid NewGuid():N}\";\n        _channel QueueDeclare(\n            queue: queueName,\n            durable: _options DurableQueues,\n            exclusive: false,\n            autoDelete: true,\n            arguments: new Dictionary<string, object> {\n                [\"x-dead-letter-exchange\"] = $\"{_options ExchangePrefix} dlx\",\n                [\"x-message-ttl\"] = _options MessageTTL TotalMilliseconds 86400000,\n                [\"x-max-length\"] = _options MaxQueueLength 10000\n            }\n        );\n        // Bind to topic\n        _channel QueueBind(\n            queue: queueName,\n            exchange: $\"{_options ExchangePrefix} events\",\n            routingKey: topic\n        );\n        // Create consumer\n        var consumer = new AsyncEventingBasicConsumer(_channel);\n        consumer Received += async (sender, ea) => {\n            try {\n                var message = _serializer Deserialize<TMessage>(ea Body ToArray());\n                await handler(message);\n                // Acknowledge message\n                _channel BasicAck(ea DeliveryTag, multiple: false);\n            }\n            catch (Exception ex) {\n                _logger LogError(ex, \"Failed to process message\");\n                // Reject and send to DLQ\n                _channel BasicNack(ea DeliveryTag, multiple: false, requeue: false);\n            }\n        };\n        _channel BasicConsume(\n            queue: queueName,\n            autoAck: false,\n            consumer: consumer\n        );\n        await Task CompletedTask;\n    }\n}\n`\nKafka Transport\n:::new\nApache Kafka for high-throughput event streaming:\n:::\n`csharp\n[WhizbangTransport(\"Kafka\")]\npublic class KafkaTransport : ITransport, IStreamingTransport {\n    private readonly IProducer<string, byte[]> _producer;\n    private readonly Dictionary<string, IConsumer<string, byte[]>> _consumers;\n    private readonly KafkaOptions _options;\n    private readonly ISerializer _serializer;\n    public string Name => \"Kafka\";\n    public TransportCapabilities Capabilities => \n        TransportCapabilities PublishSubscribe |\n        TransportCapabilities Streaming |\n        TransportCapabilities Ordered |\n        TransportCapabilities Reliable;\n    public KafkaTransport(KafkaOptions options) {\n        _options = options;\n        _serializer = new AvroSerializer(options SchemaRegistry);\n        _consumers = new Dictionary<string, IConsumer<string, byte[]>>();\n        // Configure producer\n        var producerConfig = new ProducerConfig {\n            BootstrapServers = options BootstrapServers,\n            Acks = options",
        "startIndex": 5556,
        "preview": "_channel CreateBasicProperties(); properties Persistent = _options PersistentMessages; properties MessageId = message Id ToString(); properties Timest..."
      },
      {
        "id": "v0.3.0/features/transports-chunk-3",
        "text": "\"Kafka\"; public TransportCapabilities Capabilities => TransportCapabilities PublishSubscribe | TransportCapabilities Streaming | TransportCapabilities Ordered | TransportCapabilities Reliable; public KafkaTransport(KafkaOptions options) { _options = options; _serializer = new AvroSerializer(options SchemaRegistry); _consumers = new Dictionary<string, IConsumer<string, byte[]>>(); // Configure producer var producerConfig = new ProducerConfig { BootstrapServers = options BootstrapServers, Acks = options Acks,\n            EnableIdempotence = true,\n            MaxInFlight = 5,\n            CompressionType = CompressionType Snappy,\n            LingerMs = 10,\n            BatchSize = 16384,\n            RetryBackoffMs = 100,\n            MessageSendMaxRetries = 3\n        };\n        _producer = new ProducerBuilder<string, byte[]>(producerConfig) SetErrorHandler((_, e) => _logger LogError($\"Kafka error: {e Reason}\")) SetStatisticsHandler((_, json) => _logger LogDebug($\"Kafka stats: {json}\")) Build();\n    }\n    public async Task Publish<TMessage>(TMessage message, string topic)\n        where TMessage : IMessage {\n        var headers = new Headers();\n        foreach (var header in message Headers) {\n            headers Add(header Key, Encoding UTF8 GetBytes(header Value));\n        }\n        var kafkaMessage = new Message<string, byte[]> {\n            Key = message Id ToString(),\n            Value = await _serializer SerializeAsync(message),\n            Headers = headers,\n            Timestamp = new Timestamp(DateTimeOffset UtcNow)\n        };\n        var result = await _producer ProduceAsync(topic, kafkaMessage);\n        if (result Status = PersistenceStatus Persisted) {\n            throw new TransportException($\"Failed to publish to Kafka: {result Status}\");\n        }\n    }\n    public async Task Subscribe<TMessage>(string topic, Func<TMessage, Task> handler)\n        where TMessage : IMessage {\n        var consumerConfig = new ConsumerConfig {\n            BootstrapServers = _options BootstrapServers,\n            GroupId = $\"{_options ConsumerGroupPrefix} {typeof(TMessage) Name}\",\n            AutoOffsetReset = AutoOffsetReset Earliest,\n            EnableAutoCommit = false,\n            EnablePartitionEof = false,\n            MaxPollIntervalMs = 300000,\n            SessionTimeoutMs = 10000,\n            IsolationLevel = IsolationLevel ReadCommitted\n        };\n        var consumer = new ConsumerBuilder<string, byte[]>(consumerConfig) SetErrorHandler((_, e) => _logger LogError($\"Consumer error: {e Reason}\")) SetPartitionsAssignedHandler((c, partitions) => {\n                _logger LogInformation($\"Assigned partitions: {string Join(\", \", partitions)}\");\n            }) Build();\n        consumer Subscribe(topic);\n        _consumers[topic] = consumer;\n        // Start consumption loop\n        _ = Task Run(async () => {\n            while ( _cancellationToken IsCancellationRequested) {\n                try {\n                    var result = consumer Consume(_cancellationToken);\n                    var message = await _serializer DeserializeAsync<TMessage>(result Message",
        "startIndex": 8380,
        "preview": "\"Kafka\"; public TransportCapabilities Capabilities => TransportCapabilities PublishSubscribe | TransportCapabilities Streaming | TransportCapabilities..."
      },
      {
        "id": "v0.3.0/features/transports-chunk-4",
        "text": "{e Reason}\")) SetPartitionsAssignedHandler((c, partitions) => { _logger LogInformation($\"Assigned partitions: {string Join(\", \", partitions)}\"); }) Build(); consumer Subscribe(topic); _consumers[topic] = consumer; // Start consumption loop _ = Task Run(async () => { while ( _cancellationToken IsCancellationRequested) { try { var result = consumer Consume(_cancellationToken); var message = await _serializer DeserializeAsync<TMessage>(result Message Value);\n                    // Add headers to message\n                    foreach (var header in result Message Headers) {\n                        message Headers[header Key] = Encoding UTF8 GetString(header GetValueBytes());\n                    }\n                    await handler(message);\n                    // Commit offset after successful processing\n                    consumer Commit(result);\n                }\n                catch (ConsumeException ex) {\n                    _logger LogError(ex, \"Kafka consume error\");\n                }\n            }\n        });\n        await Task CompletedTask;\n    }\n    // Stream processing API\n    public IAsyncEnumerable<TMessage> Stream<TMessage>(string topic, CancellationToken ct)\n        where TMessage : IMessage {\n        return new KafkaStream<TMessage>(\n            CreateConsumer(topic),\n            _serializer,\n            ct\n        );\n    }\n}\n`\nRedis Pub/Sub Transport\n:::new\nLightweight pub/sub with Redis:\n:::\n`csharp\n[WhizbangTransport(\"Redis\")]\npublic class RedisTransport : ITransport {\n    private readonly IConnectionMultiplexer _redis;\n    private readonly ISubscriber _subscriber;\n    private readonly RedisOptions _options;\n    private readonly ISerializer _serializer;\n    public string Name => \"Redis\";\n    public TransportCapabilities Capabilities => \n        TransportCapabilities PublishSubscribe;\n    public RedisTransport(RedisOptions options) {\n        _options = options;\n        _serializer = new JsonSerializer();\n        var config = ConfigurationOptions Parse(options ConnectionString);\n        config AbortOnConnectFail = false;\n        config ReconnectRetryPolicy = new ExponentialRetry(5000);\n        _redis = ConnectionMultiplexer Connect(config);\n        _subscriber = _redis GetSubscriber();\n    }\n    public async Task Publish<TMessage>(TMessage message, string topic)\n        where TMessage : IMessage {\n        var channel = new RedisChannel($\"{_options ChannelPrefix}:{topic}\", \n            RedisChannel PatternMode Literal);\n        var envelope = new RedisMessageEnvelope {\n            MessageId = message Id,\n            MessageType = typeof(TMessage) FullName,\n            Timestamp = DateTimeOffset UtcNow,\n            Headers = message Headers,\n            Body = _serializer Serialize(message)\n        };\n        var json = JsonSerializer Serialize(envelope);\n        await _subscriber PublishAsync(channel, json);\n    }\n    public async Task Subscribe<TMessage>(string topic, Func<TMessage, Task> handler)\n        where TMessage : IMessage {\n        var channel = new RedisChannel($\"{_options ChannelPrefix}:{topic}\",\n            RedisChannel PatternMode Literal);\n        await _subscriber SubscribeAsync(channel, async (ch, value) => {\n            try {\n                var envelope = JsonSerializer Deserialize<RedisMessageEnvelope>(value",
        "startIndex": 11051,
        "preview": "{e Reason}\")) SetPartitionsAssignedHandler((c, partitions) => { _logger LogInformation($\"Assigned partitions: {string Join(\", \", partitions)}\"); }) Bu..."
      },
      {
        "id": "v0.3.0/features/transports-chunk-5",
        "text": "_serializer Serialize(message) }; var json = JsonSerializer Serialize(envelope); await _subscriber PublishAsync(channel, json); } public async Task Subscribe<TMessage>(string topic, Func<TMessage, Task> handler) where TMessage : IMessage { var channel = new RedisChannel($\"{_options ChannelPrefix}:{topic}\", RedisChannel PatternMode Literal); await _subscriber SubscribeAsync(channel, async (ch, value) => { try { var envelope = JsonSerializer Deserialize<RedisMessageEnvelope>(value );\n                var message = _serializer Deserialize<TMessage>(envelope Body);\n                // Restore headers\n                foreach (var header in envelope Headers) {\n                    message Headers[header Key] = header Value;\n                }\n                await handler(message);\n            }\n            catch (Exception ex) {\n                _logger LogError(ex, \"Failed to process Redis message\");\n            }\n        });\n    }\n}\n`\nDead Letter Queue Handling\nPoison Message Processing\n`csharp\npublic class DeadLetterQueueProcessor {\n    private readonly ITransport _transport;\n    private readonly IDeadLetterStore _dlqStore;\n    public async Task ProcessDeadLetters(string queue) {\n        await foreach (var deadLetter in _dlqStore ReadDeadLetters(queue)) {\n            try {\n                // Analyze failure reason\n                var analysis = AnalyzeFailure(deadLetter);\n                if (analysis CanRetry) {\n                    // Attempt reprocessing\n                    await ReprocessMessage(deadLetter);\n                } else if (analysis RequiresManualIntervention) {\n                    // Alert operations team\n                    await AlertOperations(deadLetter, analysis);\n                } else {\n                    // Archive permanently\n                    await ArchiveMessage(deadLetter);\n                }\n            }\n            catch (Exception ex) {\n                _logger LogError(ex, \"Failed to process dead letter\");\n            }\n        }\n    }\n    private FailureAnalysis AnalyzeFailure(DeadLetter deadLetter) {\n        // Check failure patterns\n        if (deadLetter Exception Contains(\"Timeout\")) {\n            return new FailureAnalysis { \n                CanRetry = true, \n                RetryDelay = TimeSpan FromMinutes(5) \n            };\n        }\n        if (deadLetter Exception Contains(\"ValidationException\")) {\n            return new FailureAnalysis { \n                CanRetry = false,\n                RequiresManualIntervention = true\n            };\n        }\n        return new FailureAnalysis { CanRetry = false };\n    }\n}\n`\nMessage Patterns\nCompeting Consumers\n`csharp\npublic class CompetingConsumerSetup {\n    public void ConfigureCompetingConsumers(ITransport transport) {\n        // All consumers in same group compete for messages\n        var consumerGroup = \"order-processors\";\n        for (int i = 0; i < 5; i++) {\n            transport Subscribe<ProcessOrderCommand>(\n                topic: \"orders",
        "startIndex": 13898,
        "preview": "_serializer Serialize(message) }; var json = JsonSerializer Serialize(envelope); await _subscriber PublishAsync(channel, json); } public async Task Su..."
      },
      {
        "id": "v0.3.0/features/transports-chunk-6",
        "text": "FailureAnalysis { CanRetry = false }; } } ` Message Patterns Competing Consumers `csharp public class CompetingConsumerSetup { public void ConfigureCompetingConsumers(ITransport transport) { // All consumers in same group compete for messages var consumerGroup = \"order-processors\"; for (int i = 0; i < 5; i++) { transport Subscribe<ProcessOrderCommand>( topic: \"orders process\",\n                handler: async cmd => await ProcessOrder(cmd),\n                options: new SubscriptionOptions {\n                    ConsumerGroup = consumerGroup,\n                    MaxConcurrency = 10\n                }\n            );\n        }\n    }\n}\n`\nSaga Pattern\n`csharp\npublic class OrderSaga {\n    private readonly ITransport _transport;\n    public async Task StartSaga(CreateOrderCommand command) {\n        var sagaId = Guid NewGuid();\n        // Step 1: Reserve inventory\n        await _transport Publish(new ReserveInventoryCommand {\n            SagaId = sagaId,\n            Items = command Items\n        }, \"inventory reserve\");\n        // Step 2: Process payment\n        await _transport Subscribe<InventoryReservedEvent>(\n            $\"saga {sagaId}\",\n            async evt => {\n                await _transport Publish(new ProcessPaymentCommand {\n                    SagaId = sagaId,\n                    Amount = command Total\n                }, \"payment process\");\n            }\n        );\n        // Step 3: Complete or compensate\n        await _transport Subscribe<PaymentProcessedEvent>(\n            $\"saga {sagaId}\",\n            async evt => await CompleteSaga(sagaId)\n        );\n        await _transport Subscribe<PaymentFailedEvent>(\n            $\"saga {sagaId}\",\n            async evt => await CompensateSaga(sagaId)\n        );\n    }\n}\n`\nTesting Message Queues\n`csharp\n[Test]\npublic class MessageQueueTests {\n    [Test]\n    public async Task RabbitMQ_ShouldDeliverInOrder() {\n        // Arrange\n        var transport = new RabbitMQTransport(new RabbitMQOptions {\n            ConnectionString = \"amqp://localhost\"\n        });\n        var received = new List<int>();\n        await transport Subscribe<TestMessage>(\"test ordered\", async msg => {\n            received Add(msg Sequence);\n        });\n        // Act\n        for (int i = 1; i <= 10; i++) {\n            await transport Publish(new TestMessage { Sequence = i }, \"test ordered\");\n        }\n        await Task Delay(1000); // Wait for delivery\n        // Assert\n        Assert That(received, Is EqualTo(Enumerable",
        "startIndex": 16390,
        "preview": "FailureAnalysis { CanRetry = false }; } } ` Message Patterns Competing Consumers `csharp public class CompetingConsumerSetup { public void ConfigureCo..."
      },
      {
        "id": "v0.3.0/features/transports-chunk-7",
        "text": "List<int>(); await transport Subscribe<TestMessage>(\"test ordered\", async msg => { received Add(msg Sequence); }); // Act for (int i = 1; i <= 10; i++) { await transport Publish(new TestMessage { Sequence = i }, \"test ordered\"); } await Task Delay(1000); // Wait for delivery // Assert Assert That(received, Is EqualTo(Enumerable Range(1, 10)));\n    }\n}\n`\nPerformance Characteristics\n| Transport | Throughput | Latency | Durability | Ordering |\n|-----------|------------|---------|------------|----------|\n| RabbitMQ | 50K msg/s | < 5ms | Yes | Yes |\n| Kafka | 1M msg/s | < 10ms | Yes | Per partition |\n| Redis | 100K msg/s | < 1ms | No | No |\nMigration from v0 2 0\nAdding Queue Support\n`csharp\n// v0 2 0 - HTTP only\nservices AddWhizbangTransports(options => {\n    options UseHttp(http => { });\n});\n// v0 3 0 - Add message queues\nservices AddWhizbangTransports(options => {\n    options UseHttp(http => { });  // Keep HTTP\n    options UseRabbitMQ(rabbit => {  // Add RabbitMQ\n        rabbit ConnectionString = \"amqp://localhost\";\n    });\n    options UseKafka(kafka => {  // Add Kafka\n        kafka BootstrapServers = \"localhost:9092\";\n    });\n});\n`\nRelated Documentation\nv0 2 0 HTTP/WebSocket - Network transports\nv0 5 0 Cloud - Cloud-native transports\nMessaging Patterns - Common patterns\nQueue Selection - Choosing the right queue",
        "startIndex": 18495,
        "preview": "List<int>(); await transport Subscribe<TestMessage>(\"test ordered\", async msg => { received Add(msg Sequence); }); // Act for (int i = 1; i <= 10; i++..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.4.0/_folder",
    "title": "Version 0.4.0 - Real Persistence",
    "category": "General",
    "url": "/docs/v0.4.0/_folder",
    "chunks": [
      {
        "id": "v0.4.0/_folder-chunk-0",
        "text": "",
        "startIndex": 0,
        "preview": ""
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.4.0/database/drivers",
    "title": "Database Drivers",
    "category": "Database",
    "url": "/docs/v0.4.0/database/drivers",
    "chunks": [
      {
        "id": "v0.4.0/database/drivers-chunk-0",
        "text": "Database Drivers Version Status Next Update\nVersion History\n:::updated\nDatabase support in v0 4 0: \nPostgreSQL driver with JSONB\nSQL Server and MySQL drivers\nMongoDB driver\nRedis driver for caching\nConnection pooling and retry logic\n:::\n:::planned\nComing in v0 5 0: \nDistributed multi-model drivers\nCross-region replication\nAutomatic sharding\nCloud-native drivers (DynamoDB, Cosmos DB)\nSee production features →\n:::\nSQL Drivers\nPostgreSQL Driver\n:::new\nFull PostgreSQL support with JSONB for flexible schemas:\n:::\n`csharp\n[WhizbangDriver(\"PostgreSQL\")]\npublic class PostgreSQLDriver : IDriver, IQueryableDriver, ITransactionalDriver {\n    private readonly string _connectionString;\n    private readonly NpgsqlDataSource _dataSource;\n    public string Name => \"PostgreSQL\";\n    public DriverCapabilities Capabilities => \n        DriverCapabilities Persistence | \n        DriverCapabilities Transactions |\n        DriverCapabilities Queries |\n        DriverCapabilities Indexing |\n        DriverCapabilities Streaming;\n    public PostgreSQLDriver(PostgreSQLOptions options) {\n        _connectionString = options ConnectionString;\n        // Configure connection pool\n        var dataSourceBuilder = new NpgsqlDataSourceBuilder(_connectionString);\n        dataSourceBuilder EnableDynamicJson();\n        dataSourceBuilder ConnectionLifetime = 300; // 5 minutes\n        dataSourceBuilder MaxPoolSize = options MaxPoolSize;\n        _dataSource = dataSourceBuilder Build();\n        // Ensure table exists\n        InitializeSchema() Wait();\n    }\n    private async Task InitializeSchema() {\n        await using var conn = await _dataSource OpenConnectionAsync();\n        await using var cmd = conn CreateCommand();\n        cmd CommandText = @\"\n            CREATE TABLE IF NOT EXISTS whizbang_store (\n                key TEXT PRIMARY KEY,\n                type TEXT NOT NULL,\n                data JSONB NOT NULL,\n                metadata JSONB,\n                created_at TIMESTAMPTZ DEFAULT NOW(),\n                updated_at TIMESTAMPTZ DEFAULT NOW()\n            );\n            CREATE INDEX IF NOT EXISTS idx_type ON whizbang_store(type);\n            CREATE INDEX IF NOT EXISTS idx_data_gin ON whizbang_store USING GIN(data);\n            CREATE INDEX IF NOT EXISTS idx_metadata_gin ON whizbang_store USING GIN(metadata);\n        \";\n        await cmd ExecuteNonQueryAsync();\n    }\n    public async Task<T > Get<T>(string key) where T : class {\n        await using var conn = await _dataSource OpenConnectionAsync();\n        await using var cmd = conn CreateCommand();\n        cmd CommandText = \"SELECT data FROM whizbang_store WHERE key = @key\";\n        cmd Parameters AddWithValue(\"key\", key);\n        await using var reader = await cmd ExecuteReaderAsync();\n        if (await reader",
        "startIndex": 0,
        "preview": "Database Drivers Version Status Next Update\nVersion History\n:::updated\nDatabase support in v0 4 0: \nPostgreSQL driver with JSONB\nSQL Server and MySQL ..."
      },
      {
        "id": "v0.4.0/database/drivers-chunk-1",
        "text": "Task<T > Get<T>(string key) where T : class { await using var conn = await _dataSource OpenConnectionAsync(); await using var cmd = conn CreateCommand(); cmd CommandText = \"SELECT data FROM whizbang_store WHERE key = @key\"; cmd Parameters AddWithValue(\"key\", key); await using var reader = await cmd ExecuteReaderAsync(); if (await reader ReadAsync()) {\n            var json = reader GetFieldValue<JsonDocument>(0);\n            return JsonSerializer Deserialize<T>(json RootElement GetRawText());\n        }\n        return null;\n    }\n    public async Task Set<T>(string key, T value) where T : class {\n        await using var conn = await _dataSource OpenConnectionAsync();\n        await using var cmd = conn CreateCommand();\n        cmd CommandText = @\"\n            INSERT INTO whizbang_store (key, type, data, metadata, updated_at)\n            VALUES (@key, @type, @data, @metadata, NOW())\n            ON CONFLICT (key) DO UPDATE \n            SET data = EXCLUDED data,\n                type = EXCLUDED type,\n                metadata = EXCLUDED metadata,\n                updated_at = NOW()\n        \";\n        cmd Parameters AddWithValue(\"key\", key);\n        cmd Parameters AddWithValue(\"type\", typeof(T) FullName);\n        cmd Parameters AddWithValue(\"data\", NpgsqlDbType Jsonb, \n            JsonSerializer Serialize(value));\n        cmd Parameters AddWithValue(\"metadata\", NpgsqlDbType Jsonb,\n            JsonSerializer Serialize(ExtractMetadata(value)));\n        await cmd ExecuteNonQueryAsync();\n    }\n    public async Task<IEnumerable<T>> Query<T>(Expression<Func<T, bool>> predicate) where T : class {\n        var visitor = new JsonQueryVisitor();\n        visitor Visit(predicate);\n        await using var conn = await _dataSource OpenConnectionAsync();\n        await using var cmd = conn CreateCommand();\n        cmd CommandText = $@\"\n            SELECT data FROM whizbang_store \n            WHERE type = @type \n            AND data @> @filter::jsonb\n        \";\n        cmd Parameters AddWithValue(\"type\", typeof(T) FullName);\n        cmd Parameters AddWithValue(\"filter\", visitor GetJsonFilter());\n        var results = new List<T>();\n        await using var reader = await cmd ExecuteReaderAsync();\n        while (await reader ReadAsync()) {\n            var json = reader GetFieldValue<JsonDocument>(0);\n            var item = JsonSerializer Deserialize<T>(json RootElement GetRawText());\n            if (item = null) {\n                results",
        "startIndex": 2778,
        "preview": "Task<T > Get<T>(string key) where T : class { await using var conn = await _dataSource OpenConnectionAsync(); await using var cmd = conn CreateCommand..."
      },
      {
        "id": "v0.4.0/database/drivers-chunk-2",
        "text": "data @> @filter::jsonb \"; cmd Parameters AddWithValue(\"type\", typeof(T) FullName); cmd Parameters AddWithValue(\"filter\", visitor GetJsonFilter()); var results = new List<T>(); await using var reader = await cmd ExecuteReaderAsync(); while (await reader ReadAsync()) { var json = reader GetFieldValue<JsonDocument>(0); var item = JsonSerializer Deserialize<T>(json RootElement GetRawText()); if (item = null) { results Add(item);\n            }\n        }\n        return results;\n    }\n}\n`\nSQL Server Driver\n:::new\nSQL Server support with JSON columns:\n:::\n`csharp\n[WhizbangDriver(\"SqlServer\")]\npublic class SqlServerDriver : IDriver, ITransactionalDriver {\n    private readonly string _connectionString;\n    public async Task Set<T>(string key, T value) where T : class {\n        using var conn = new SqlConnection(_connectionString);\n        await conn OpenAsync();\n        var cmd = new SqlCommand(@\"\n            MERGE whizbang_store AS target\n            USING (SELECT @key AS [key], @type AS [type], @data AS [data]) AS source\n            ON target [key] = source [key]\n            WHEN MATCHED THEN \n                UPDATE SET [data] = source [data], \n                          [type] = source [type],\n                          updated_at = GETUTCDATE()\n            WHEN NOT MATCHED THEN\n                INSERT ([key], [type], [data], created_at, updated_at)\n                VALUES (source [key], source [type], source [data], \n                       GETUTCDATE(), GETUTCDATE());\n        \", conn);\n        cmd Parameters AddWithValue(\"@key\", key);\n        cmd Parameters AddWithValue(\"@type\", typeof(T) FullName);\n        cmd Parameters AddWithValue(\"@data\", JsonSerializer Serialize(value));\n        await cmd ExecuteNonQueryAsync();\n    }\n    public async Task<IEnumerable<T>> Query<T>(Expression<Func<T, bool>> predicate) where T : class {\n        using var conn = new SqlConnection(_connectionString);\n        await conn OpenAsync();\n        // Convert predicate to SQL JSON query\n        var jsonPath = ConvertToJsonPath(predicate);\n        var cmd = new SqlCommand($@\"\n            SELECT [data] \n            FROM whizbang_store\n            WHERE [type] = @type\n            AND JSON_VALUE([data], @jsonPath) IS NOT NULL\n        \", conn);\n        cmd Parameters AddWithValue(\"@type\", typeof(T) FullName);\n        cmd Parameters AddWithValue(\"@jsonPath\", jsonPath);\n        var results = new List<T>();\n        using var reader = await cmd ExecuteReaderAsync();\n        while (await reader ReadAsync()) {\n            var json = reader GetString(0);\n            var item = JsonSerializer Deserialize<T>(json);\n            if (item = null) results",
        "startIndex": 4892,
        "preview": "data @> @filter::jsonb \"; cmd Parameters AddWithValue(\"type\", typeof(T) FullName); cmd Parameters AddWithValue(\"filter\", visitor GetJsonFilter()); var..."
      },
      {
        "id": "v0.4.0/database/drivers-chunk-3",
        "text": "@type AND JSON_VALUE([data], @jsonPath) IS NOT NULL \", conn); cmd Parameters AddWithValue(\"@type\", typeof(T) FullName); cmd Parameters AddWithValue(\"@jsonPath\", jsonPath); var results = new List<T>(); using var reader = await cmd ExecuteReaderAsync(); while (await reader ReadAsync()) { var json = reader GetString(0); var item = JsonSerializer Deserialize<T>(json); if (item = null) results Add(item);\n        }\n        return results;\n    }\n}\n`\nNoSQL Drivers\nMongoDB Driver\n:::new\nNative MongoDB support with BSON documents:\n:::\n`csharp\n[WhizbangDriver(\"MongoDB\")]\npublic class MongoDBDriver : IDriver, IQueryableDriver {\n    private readonly IMongoDatabase _database;\n    private readonly IMongoCollection<BsonDocument> _collection;\n    public string Name => \"MongoDB\";\n    public DriverCapabilities Capabilities => \n        DriverCapabilities Persistence | \n        DriverCapabilities Queries |\n        DriverCapabilities Indexing |\n        DriverCapabilities Streaming;\n    public MongoDBDriver(MongoDBOptions options) {\n        var client = new MongoClient(options ConnectionString);\n        _database = client GetDatabase(options Database);\n        _collection = _database GetCollection<BsonDocument>(\"whizbang_store\");\n        // Create indexes\n        CreateIndexes() Wait();\n    }\n    private async Task CreateIndexes() {\n        var indexKeys = Builders<BsonDocument> IndexKeys;\n        await _collection Indexes CreateManyAsync(new[] {\n            new CreateIndexModel<BsonDocument>(indexKeys Ascending(\"_key\")),\n            new CreateIndexModel<BsonDocument>(indexKeys Ascending(\"_type\")),\n            new CreateIndexModel<BsonDocument>(indexKeys Text(\"data\"))\n        });\n    }\n    public async Task<T > Get<T>(string key) where T : class {\n        var filter = Builders<BsonDocument> Filter Eq(\"_key\", key);\n        var document = await _collection Find(filter) FirstOrDefaultAsync();\n        if (document == null) return null;\n        var json = document[\"data\"] ToJson();\n        return JsonSerializer Deserialize<T>(json);\n    }\n    public async Task Set<T>(string key, T value) where T : class {\n        var document = new BsonDocument {\n            [\"_key\"] = key,\n            [\"_type\"] = typeof(T) FullName,\n            [\"data\"] = BsonDocument Parse(JsonSerializer Serialize(value)),\n            [\"metadata\"] = BsonDocument Parse(JsonSerializer Serialize(ExtractMetadata(value))),\n            [\"updated_at\"] = DateTime UtcNow\n        };\n        var filter = Builders<BsonDocument> Filter Eq(\"_key\", key);\n        var options = new ReplaceOptions { IsUpsert = true };\n        await _collection ReplaceOneAsync(filter, document, options);\n    }\n    public async Task<IEnumerable<T>> Query<T>(Expression<Func<T, bool>> predicate) where T : class {\n        // Convert expression to MongoDB filter\n        var filter = ConvertToMongoFilter(predicate);\n        var typeFilter = Builders<BsonDocument> Filter Eq(\"_type\", typeof(T) FullName);\n        var combinedFilter = Builders<BsonDocument> Filter",
        "startIndex": 7127,
        "preview": "@type AND JSON_VALUE([data], @jsonPath) IS NOT NULL \", conn); cmd Parameters AddWithValue(\"@type\", typeof(T) FullName); cmd Parameters AddWithValue(\"@..."
      },
      {
        "id": "v0.4.0/database/drivers-chunk-4",
        "text": "var options = new ReplaceOptions { IsUpsert = true }; await _collection ReplaceOneAsync(filter, document, options); } public async Task<IEnumerable<T>> Query<T>(Expression<Func<T, bool>> predicate) where T : class { // Convert expression to MongoDB filter var filter = ConvertToMongoFilter(predicate); var typeFilter = Builders<BsonDocument> Filter Eq(\"_type\", typeof(T) FullName); var combinedFilter = Builders<BsonDocument> Filter And(typeFilter, filter);\n        var documents = await _collection Find(combinedFilter) ToListAsync();\n        return documents Select(doc => {\n            var json = doc[\"data\"] ToJson();\n            return JsonSerializer Deserialize<T>(json);\n        }) Where(item => item = null) ;\n    }\n}\n`\nRedis Driver\n:::new\nHigh-performance caching with Redis:\n:::\n`csharp\n[WhizbangDriver(\"Redis\")]\npublic class RedisDriver : IDriver {\n    private readonly IConnectionMultiplexer _redis;\n    private readonly IDatabase _db;\n    private readonly RedisOptions _options;\n    public string Name => \"Redis\";\n    public DriverCapabilities Capabilities => \n        DriverCapabilities Persistence | \n        DriverCapabilities Streaming;\n    public RedisDriver(RedisOptions options) {\n        _options = options;\n        var config = ConfigurationOptions Parse(options ConnectionString);\n        config AbortOnConnectFail = false;\n        config ConnectRetry = 3;\n        config ConnectTimeout = 5000;\n        _redis = ConnectionMultiplexer Connect(config);\n        _db = _redis GetDatabase(options Database);\n    }\n    public async Task<T > Get<T>(string key) where T : class {\n        var value = await _db StringGetAsync(key);\n        if (value IsNullOrEmpty) return null;\n        return JsonSerializer Deserialize<T>(value );\n    }\n    public async Task Set<T>(string key, T value) where T : class {\n        var json = JsonSerializer Serialize(value);\n        var expiry = _options DefaultExpiry;\n        await _db StringSetAsync(key, json, expiry);\n        // Update type index\n        await _db SetAddAsync($\"type:{typeof(T) FullName}\", key);\n    }\n    public async Task<IEnumerable<T>> GetAll<T>(string prefix = \"\") where T : class {\n        var server = _redis GetServer(_redis GetEndPoints() First());\n        var keys = server Keys(pattern: $\"{prefix}*\") ToArray();\n        if ( keys Any()) return Enumerable Empty<T>();\n        var values = await _db StringGetAsync(keys);\n        return values Where(v => v IsNullOrEmpty) Select(v => JsonSerializer Deserialize<T>(v )) Where(item => item = null)",
        "startIndex": 9750,
        "preview": "var options = new ReplaceOptions { IsUpsert = true }; await _collection ReplaceOneAsync(filter, document, options); } public async Task<IEnumerable<T>..."
      },
      {
        "id": "v0.4.0/database/drivers-chunk-5",
        "text": "= \"\") where T : class { var server = _redis GetServer(_redis GetEndPoints() First()); var keys = server Keys(pattern: $\"{prefix}*\") ToArray(); if ( keys Any()) return Enumerable Empty<T>(); var values = await _db StringGetAsync(keys); return values Where(v => v IsNullOrEmpty) Select(v => JsonSerializer Deserialize<T>(v )) Where(item => item = null) ;\n    }\n    // Pub/Sub support for real-time updates\n    public async Task Subscribe<T>(string channel, Action<T> handler) where T : class {\n        var subscriber = _redis GetSubscriber();\n        await subscriber SubscribeAsync(channel, (ch, message) => {\n            var item = JsonSerializer Deserialize<T>(message );\n            if (item = null) {\n                handler(item);\n            }\n        });\n    }\n}\n`\nTransaction Support\nDistributed Transactions\n`csharp\npublic interface ITransactionalDriver : IDriver {\n    Task<ITransaction> BeginTransaction(IsolationLevel isolation = IsolationLevel ReadCommitted);\n}\npublic class PostgreSQLTransaction : ITransaction {\n    private readonly NpgsqlTransaction _transaction;\n    private readonly NpgsqlConnection _connection;\n    public async Task<T > Get<T>(string key) where T : class {\n        // All operations use the transaction's connection\n        using var cmd = _connection CreateCommand();\n        cmd Transaction = _transaction;\n        cmd CommandText = \"SELECT data FROM whizbang_store WHERE key = @key\";\n        cmd Parameters AddWithValue(\"key\", key);\n        // execute within transaction\n    }\n    public async Task Commit() {\n        await _transaction CommitAsync();\n    }\n    public async Task Rollback() {\n        await _transaction RollbackAsync();\n    }\n}\n`\nConnection Management\nConnection Pooling\n`csharp\npublic class PooledDriverOptions {\n    public int MinPoolSize { get; set; } = 5;\n    public int MaxPoolSize { get; set; } = 100;\n    public TimeSpan ConnectionLifetime { get; set; } = TimeSpan FromMinutes(5);\n    public TimeSpan ConnectionTimeout { get; set; } = TimeSpan FromSeconds(30);\n    public RetryPolicy RetryPolicy { get; set; } = new ExponentialBackoffRetry();\n}\n`\nTesting Database Drivers\n`csharp\n[Test]\npublic class DatabaseDriverTests {\n    [Test]\n    public async Task PostgreSQL_JsonbQuery_ShouldWork() {\n        // Arrange\n        var driver = new PostgreSQLDriver(new PostgreSQLOptions {\n            ConnectionString = GetTestConnectionString()\n        });\n        await driver Set(\"order:1\", new Order {\n            Id = Guid",
        "startIndex": 11883,
        "preview": "= \"\") where T : class { var server = _redis GetServer(_redis GetEndPoints() First()); var keys = server Keys(pattern: $\"{prefix}*\") ToArray(); if ( ke..."
      },
      {
        "id": "v0.4.0/database/drivers-chunk-6",
        "text": "FromSeconds(30); public RetryPolicy RetryPolicy { get; set; } = new ExponentialBackoffRetry(); } ` Testing Database Drivers `csharp [Test] public class DatabaseDriverTests { [Test] public async Task PostgreSQL_JsonbQuery_ShouldWork() { // Arrange var driver = new PostgreSQLDriver(new PostgreSQLOptions { ConnectionString = GetTestConnectionString() }); await driver Set(\"order:1\", new Order { Id = Guid NewGuid(),\n            Customer = new Customer { Name = \"John\", Country = \"USA\" },\n            Total = 99 99m\n        });\n        // Act - Query using JSONB\n        var results = await driver Query<Order>(o => \n            o Customer Country == \"USA\" && o Total > 50);\n        // Assert\n        Assert Equal(1, results Count());\n    }\n}\n`\nPerformance Characteristics\n| Driver | Write | Read | Query (indexed) | Transaction |\n|--------|-------|------|-----------------|-------------|\n| PostgreSQL | < 5ms | < 2ms | < 5ms | < 10ms |\n| SQL Server | < 8ms | < 3ms | < 8ms | < 15ms |\n| MongoDB | < 3ms | < 1ms | < 3ms | N/A |\n| Redis | < 1ms | < 0 5ms | N/A | N/A |\nMigration from v0 2 0\nFrom File to Database\n`csharp\n// v0 2 0 - File driver\nservices AddWhizbangDrivers(options => {\n    options UseFileDriver(file => {\n        file DataDirectory = \" /data\";\n    });\n});\n// v0 4 0 - Database driver\nservices AddWhizbangDrivers(options => {\n    options UsePostgreSQL(Configuration GetConnectionString(\"WhizbangDb\"));\n});\n// Migration tool\npublic class DriverMigration {\n    public async Task MigrateFromFileToDB(IDriver source, IDriver target) {\n        var allKeys = await source GetAll<object>();\n        foreach (var item in allKeys) {\n            await target Set(item Key, item Value);\n        }\n    }\n}\n`\nRelated Documentation\nv0 2 0 File Storage - File-based drivers\nv0 5 0 Production - Distributed drivers\nDatabase Guide - Choosing the right database\nPerformance - Database optimization",
        "startIndex": 14016,
        "preview": "FromSeconds(30); public RetryPolicy RetryPolicy { get; set; } = new ExponentialBackoffRetry(); } ` Testing Database Drivers `csharp [Test] public clas..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.5.0/_folder",
    "title": "Version 0.5.0 - Distributed Systems",
    "category": "General",
    "url": "/docs/v0.5.0/_folder",
    "chunks": [
      {
        "id": "v0.5.0/_folder-chunk-0",
        "text": "",
        "startIndex": 0,
        "preview": ""
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.5.0/production/dispatcher",
    "title": "Distributed Orchestration",
    "category": "Production",
    "url": "/docs/v0.5.0/production/dispatcher",
    "chunks": [
      {
        "id": "v0.5.0/production/dispatcher-chunk-0",
        "text": "Distributed Orchestration Version Status\nVersion History\n:::updated\nProduction-ready in v0 5 0: \nDistributed saga coordination across regions\nConsensus-based orchestration with Raft\nGlobal workflow state management\nMulti-region failover and recovery\nDistributed tracing and monitoring\n:::\nDistributed Architecture\nGlobal Orchestrator\n:::new\nCoordinate workflows across multiple regions:\n:::\n`csharp\n[WhizbangOrchestrator]\npublic class DistributedOrchestrator : IOrchestrator {\n    private readonly IConsensusService _consensus;\n    private readonly IRegionRegistry _regions;\n    private readonly IDistributedStateStore _stateStore;\n    private readonly IGlobalRouter _router;\n    public DistributedOrchestrator(\n        IConsensusService consensus,\n        IRegionRegistry regions,\n        IDistributedStateStore stateStore,\n        IGlobalRouter router) {\n        _consensus = consensus;\n        _regions = regions;\n        _stateStore = stateStore;\n        _router = router;\n    }\n    public async Task<OrchestratorResult> Execute<TCommand>(\n        TCommand command,\n        OrchestratorContext context) where TCommand : ICommand {\n        // Determine if we're the leader\n        if ( await _consensus IsLeader()) {\n            // Forward to leader\n            var leader = await _consensus GetLeader();\n            return await ForwardToLeader(leader, command, context);\n        }\n        // Create global transaction ID\n        var transactionId = await _consensus GenerateGlobalId();\n        context TransactionId = transactionId;\n        // Determine optimal region for execution\n        var targetRegion = await _router DetermineRegion(command, context);\n        // Create distributed saga\n        var saga = new DistributedSaga(transactionId, targetRegion);\n        try {\n            // Execute saga with distributed coordination\n            var result = await ExecuteDistributedSaga(saga, command, context);\n            // Replicate state to all regions\n            await ReplicateState(saga);\n            return result;\n        }\n        catch (RegionFailureException ex) {\n            // Failover to another region\n            return await FailoverExecution(saga, command, context, ex FailedRegion);\n        }\n    }\n    private async Task<OrchestratorResult> ExecuteDistributedSaga<TCommand>(\n        DistributedSaga saga,\n        TCommand command,\n        OrchestratorContext context) {\n        // Lock saga globally\n        await using var globalLock = await _consensus AcquireGlobalLock(\n            $\"saga:{saga Id}\",\n            TimeSpan FromSeconds(30));\n        // Execute steps across regions\n        foreach (var step in saga Steps) {\n            var stepRegion = DetermineStepRegion(step);\n            var regionOrchestrator = _regions GetOrchestrator(stepRegion);\n            try {\n                // Execute step in target region\n                var stepResult = await regionOrchestrator ExecuteStep(\n                    step,\n                    context,\n                    globalLock Token);\n                // Update global state\n                await _stateStore UpdateStep(saga Id, step Id, stepResult);\n                // Broadcast state change\n                await BroadcastStateChange(saga",
        "startIndex": 0,
        "preview": "Distributed Orchestration Version Status\nVersion History\n:::updated\nProduction-ready in v0 5 0: \nDistributed saga coordination across regions\nConsensu..."
      },
      {
        "id": "v0.5.0/production/dispatcher-chunk-1",
        "text": "(var step in saga Steps) { var stepRegion = DetermineStepRegion(step); var regionOrchestrator = _regions GetOrchestrator(stepRegion); try { // Execute step in target region var stepResult = await regionOrchestrator ExecuteStep( step, context, globalLock Token); // Update global state await _stateStore UpdateStep(saga Id, step Id, stepResult); // Broadcast state change await BroadcastStateChange(saga Id, step Id, stepResult);\n            }\n            catch (StepFailureException ex) {\n                // Initiate global compensation\n                await CompensateGlobally(saga, ex);\n                throw;\n            }\n        }\n        return new OrchestratorResult {\n            Success = true,\n            TransactionId = saga Id,\n            ExecutionRegions = saga GetExecutionRegions()\n        };\n    }\n}\n`\nConsensus-Based Coordination\n:::new\nUse Raft consensus for distributed coordination:\n:::\n`csharp\npublic interface IConsensusService {\n    Task<bool> IsLeader();\n    Task<NodeInfo> GetLeader();\n    Task<ulong> GenerateGlobalId();\n    Task<IGlobalLock> AcquireGlobalLock(string resource, TimeSpan ttl);\n    Task ProposeValue<T>(string key, T value);\n}\npublic class RaftConsensusService : IConsensusService {\n    private readonly RaftNode _node;\n    private readonly IClusterConfiguration _cluster;\n    public RaftConsensusService(RaftNode node, IClusterConfiguration cluster) {\n        _node = node;\n        _cluster = cluster;\n        InitializeRaft();\n    }\n    private void InitializeRaft() {\n        _node Configure(options => {\n            options ElectionTimeout = TimeSpan FromMilliseconds(150);\n            options HeartbeatInterval = TimeSpan FromMilliseconds(50);\n            options LogCompactionThreshold = 10000;\n            // Configure cluster members\n            foreach (var member in _cluster Members) {\n                options AddPeer(member Id, member Endpoint);\n            }\n        });\n        // Start Raft node\n        _node Start();\n    }\n    public async Task<bool> IsLeader() {\n        return _node State == RaftState Leader;\n    }\n    public async Task<NodeInfo> GetLeader() {\n        var leaderId = _node CurrentLeader;\n        return _cluster GetMember(leaderId);\n    }\n    public async Task<ulong> GenerateGlobalId() {\n        // Use Raft log index as globally unique ID\n        var entry = new LogEntry {\n            Type = EntryType IdGeneration,\n            Data = Guid NewGuid() ToByteArray()\n        };\n        var index = await _node AppendEntry(entry);\n        return index;\n    }\n    public async Task<IGlobalLock> AcquireGlobalLock(string resource, TimeSpan ttl) {\n        var lockEntry = new LockEntry {\n            Resource = resource,\n            Owner = _node Id,\n            ExpiresAt = DateTimeOffset UtcNow Add(ttl)\n        };\n        // Propose lock through Raft\n        var acquired = await ProposeValue($\"lock:{resource}\", lockEntry);\n        if (",
        "startIndex": 3111,
        "preview": "(var step in saga Steps) { var stepRegion = DetermineStepRegion(step); var regionOrchestrator = _regions GetOrchestrator(stepRegion); try { // Execute..."
      },
      {
        "id": "v0.5.0/production/dispatcher-chunk-2",
        "text": "}; var index = await _node AppendEntry(entry); return index; } public async Task<IGlobalLock> AcquireGlobalLock(string resource, TimeSpan ttl) { var lockEntry = new LockEntry { Resource = resource, Owner = _node Id, ExpiresAt = DateTimeOffset UtcNow Add(ttl) }; // Propose lock through Raft var acquired = await ProposeValue($\"lock:{resource}\", lockEntry); if ( acquired) {\n            throw new LockAcquisitionException($\"Failed to acquire lock on {resource}\");\n        }\n        return new GlobalLock(resource, _node Id, ttl, this);\n    }\n    public async Task ProposeValue<T>(string key, T value) {\n        var proposal = new StateProposal {\n            Key = key,\n            Value = JsonSerializer Serialize(value),\n            Timestamp = DateTimeOffset UtcNow\n        };\n        // Replicate through Raft\n        var committed = await _node Propose(proposal);\n        return committed;\n    }\n}\n`\nMulti-Region State Management\n:::new\nManage workflow state across regions:\n:::\n`csharp\npublic class DistributedStateStore : IDistributedStateStore {\n    private readonly Dictionary<string, IRegionalStateStore> _regionalStores;\n    private readonly IConsensusService _consensus;\n    private readonly IReplicationService _replication;\n    public async Task<SagaState> GetState(string sagaId) {\n        // Try local region first\n        var localState = await _regionalStores[GetLocalRegion()] GetState(sagaId);\n        if (localState = null && localState IsComplete) {\n            return localState;\n        }\n        // Query all regions for latest state\n        var states = await Task WhenAll(\n            _regionalStores Select(async kvp => new {\n                Region = kvp Key,\n                State = await kvp Value GetState(sagaId)\n            })\n        );\n        // Return most recent consistent state\n        return states Where(s => s State = null) OrderByDescending(s => s State Version) FirstOrDefault() State;\n    }\n    public async Task UpdateState(string sagaId, SagaState state) {\n        // Update through consensus\n        var committed = await _consensus ProposeValue($\"saga:{sagaId}\", state);\n        if ( committed) {\n            throw new StateUpdateException(\"Failed to commit state update\");\n        }\n        // Replicate to all regions asynchronously\n        await _replication ReplicateAsync(new ReplicationRequest {\n            Key = $\"saga:{sagaId}\",\n            Value = state,\n            Regions = _regionalStores Keys ToList(),\n            ConsistencyLevel = ConsistencyLevel",
        "startIndex": 5741,
        "preview": "}; var index = await _node AppendEntry(entry); return index; } public async Task<IGlobalLock> AcquireGlobalLock(string resource, TimeSpan ttl) { var l..."
      },
      {
        "id": "v0.5.0/production/dispatcher-chunk-3",
        "text": "state) { // Update through consensus var committed = await _consensus ProposeValue($\"saga:{sagaId}\", state); if ( committed) { throw new StateUpdateException(\"Failed to commit state update\"); } // Replicate to all regions asynchronously await _replication ReplicateAsync(new ReplicationRequest { Key = $\"saga:{sagaId}\", Value = state, Regions = _regionalStores Keys ToList(), ConsistencyLevel = ConsistencyLevel EventualConsistency\n        });\n    }\n}\n`\nGlobal Workflow Router\n:::new\nIntelligent routing across regions:\n:::\n`csharp\npublic class GlobalWorkflowRouter : IGlobalRouter {\n    private readonly IRegionCapabilities _capabilities;\n    private readonly ILatencyMonitor _latencyMonitor;\n    private readonly ICostCalculator _costCalculator;\n    public async Task<string> DetermineRegion<TCommand>(\n        TCommand command,\n        OrchestratorContext context) {\n        // Get routing hints\n        var hints = ExtractRoutingHints(command, context);\n        // Evaluate each region\n        var evaluations = await Task WhenAll(\n            _capabilities GetRegions() Select(async region => {\n                var score = await EvaluateRegion(region, hints);\n                return new { Region = region, Score = score };\n            })\n        );\n        // Select optimal region\n        return evaluations OrderByDescending(e => e Score) First() Region;\n    }\n    private async Task<double> EvaluateRegion(string region, RoutingHints hints) {\n        var score = 100 0;\n        // Data locality\n        if (hints DataRegion == region) {\n            score += 50; // Prefer region where data resides\n        }\n        // Latency\n        var latency = await _latencyMonitor GetLatency(GetLocalRegion(), region);\n        score -= latency TotalMilliseconds / 10;\n        // Cost\n        var cost = await _costCalculator EstimateCost(region, hints EstimatedSize);\n        score -= cost * 10;\n        // Compliance\n        if (hints RequiredCompliance = null) {\n            var compliant = await _capabilities IsCompliant(region, hints RequiredCompliance);\n            if ( compliant) {\n                score = -1000; // Disqualify non-compliant regions\n            }\n        }\n        // Load\n        var load = await _capabilities GetLoad(region);\n        score -= load * 20;\n        return score;\n    }\n}\n`\nFailure Handling\nRegional Failover\n`csharp\npublic class RegionalFailoverManager {\n    private readonly IHealthMonitor _healthMonitor;\n    private readonly IFailoverPolicy _policy;\n    public async Task<string> GetHealthyRegion(string preferredRegion) {\n        // Check if preferred region is healthy\n        if (await _healthMonitor",
        "startIndex": 7935,
        "preview": "state) { // Update through consensus var committed = await _consensus ProposeValue($\"saga:{sagaId}\", state); if ( committed) { throw new StateUpdateEx..."
      },
      {
        "id": "v0.5.0/production/dispatcher-chunk-4",
        "text": "Load var load = await _capabilities GetLoad(region); score -= load * 20; return score; } } ` Failure Handling Regional Failover `csharp public class RegionalFailoverManager { private readonly IHealthMonitor _healthMonitor; private readonly IFailoverPolicy _policy; public async Task<string> GetHealthyRegion(string preferredRegion) { // Check if preferred region is healthy if (await _healthMonitor IsHealthy(preferredRegion)) {\n            return preferredRegion;\n        }\n        // Find next best region\n        var candidates = await _policy GetFailoverCandidates(preferredRegion);\n        foreach (var candidate in candidates) {\n            if (await _healthMonitor IsHealthy(candidate)) {\n                _logger LogWarning(\n                    \"Failing over from {Preferred} to {Candidate}\",\n                    preferredRegion,\n                    candidate);\n                return candidate;\n            }\n        }\n        throw new NoHealthyRegionException(\n            $\"No healthy regions available for failover from {preferredRegion}\");\n    }\n    public async Task InitiateFailover(string failedRegion, DistributedSaga saga) {\n        // Elect new coordinator\n        var newCoordinator = await ElectNewCoordinator(failedRegion, saga ParticipatingRegions);\n        // Transfer saga ownership\n        await TransferSagaOwnership(saga, newCoordinator);\n        // Resume execution from last checkpoint\n        await newCoordinator ResumeSaga(saga);\n        // Notify all participants\n        await NotifyFailover(saga Id, failedRegion, newCoordinator);\n    }\n}\n`\nSplit-Brain Prevention\n`csharp\npublic class SplitBrainDetector {\n    private readonly IConsensusService _consensus;\n    private readonly INetworkPartitionDetector _partitionDetector;\n    public async Task<bool> IsSplitBrain() {\n        // Check if we have quorum\n        var hasQuorum = await _consensus HasQuorum();\n        if ( hasQuorum) {\n            return true; // Potential split-brain\n        }\n        // Check network partitions\n        var partitions = await _partitionDetector DetectPartitions();\n        if (partitions Count > 1) {\n            _logger LogCritical(\n                \"Split-brain detected: {PartitionCount} partitions\",\n                partitions Count);\n            return true;\n        }\n        return false;\n    }\n    public async Task ResolveSplitBrain() {\n        // Enter read-only mode\n        await EnterSafeMode();\n        // Wait for network healing\n        await WaitForNetworkHealing();\n        // Re-establish consensus\n        await _consensus ReestablishQuorum();\n        // Reconcile state\n        await ReconcileDistributedState();\n        // Resume normal operations\n        await ExitSafeMode();\n    }\n}\n`\nMonitoring & Observability\nDistributed Tracing\n`csharp\npublic class DistributedTracingMiddleware : IDispatcherMiddleware {\n    private readonly ITracer _tracer;\n    public async Task<TResult> Execute<TCommand, TResult>(\n        TCommand command,\n        DispatcherContext context,\n        Func<TCommand, DispatcherContext, Task<TResult>> next) {\n        // Extract or create trace context\n        var traceContext = ExtractTraceContext(context)",
        "startIndex": 10208,
        "preview": "Load var load = await _capabilities GetLoad(region); score -= load * 20; return score; } } ` Failure Handling Regional Failover `csharp public class R..."
      },
      {
        "id": "v0.5.0/production/dispatcher-chunk-5",
        "text": "ReconcileDistributedState(); // Resume normal operations await ExitSafeMode(); } } ` Monitoring & Observability Distributed Tracing `csharp public class DistributedTracingMiddleware : IDispatcherMiddleware { private readonly ITracer _tracer; public async Task<TResult> Execute<TCommand, TResult>( TCommand command, DispatcherContext context, Func<TCommand, DispatcherContext, Task<TResult>> next) { // Extract or create trace context var traceContext = ExtractTraceContext(context) CreateTraceContext();\n        using var span = _tracer StartSpan(\n            $\"orchestrate {typeof(TCommand) Name}\",\n            traceContext);\n        // Add span metadata\n        span SetTag(\"region\", GetCurrentRegion());\n        span SetTag(\"saga id\", context SagaId);\n        span SetTag(\"transaction id\", context TransactionId);\n        span SetTag(\"is leader\", await _consensus IsLeader());\n        try {\n            // Inject trace context for propagation\n            InjectTraceContext(context, span Context);\n            var result = await next(command, context);\n            span SetTag(\"success\", true);\n            return result;\n        }\n        catch (Exception ex) {\n            span RecordException(ex);\n            span SetTag(\"success\", false);\n            throw;\n        }\n    }\n}\n`\nGlobal Metrics\n`csharp\npublic class GlobalOrchestratorMetrics {\n    private readonly IMetricsCollector _metrics;\n    public void RecordSagaExecution(string sagaType, string region, TimeSpan duration, bool success) {\n        _metrics RecordHistogram(\n            \"orchestrator saga duration\",\n            duration TotalMilliseconds,\n            (\"saga_type\", sagaType),\n            (\"region\", region),\n            (\"success\", success ToString())\n        );\n        _metrics Increment(\n            success \"orchestrator saga success\" : \"orchestrator saga failure\",\n            (\"saga_type\", sagaType),\n            (\"region\", region)\n        );\n    }\n    public void RecordConsensusOperation(string operation, TimeSpan duration, bool success) {\n        _metrics RecordHistogram(\n            \"orchestrator consensus duration\",\n            duration TotalMilliseconds,\n            (\"operation\", operation),\n            (\"success\", success ToString())\n        );\n    }\n    public void RecordFailover(string fromRegion, string toRegion, string reason) {\n        _metrics Increment(\n            \"orchestrator failover\",\n            (\"from_region\", fromRegion),\n            (\"to_region\", toRegion),\n            (\"reason\", reason)\n        );\n    }\n}\n`\nPerformance at Scale\n| Metric | Target | Achieved |\n|--------|--------|----------|\n| Global saga coordination | < 100ms | 85ms p99 |\n| Consensus round-trip | < 50ms | 35ms p99 |\n| Regional failover | < 5s | 3",
        "startIndex": 12987,
        "preview": "ReconcileDistributedState(); // Resume normal operations await ExitSafeMode(); } } ` Monitoring & Observability Distributed Tracing `csharp public cla..."
      },
      {
        "id": "v0.5.0/production/dispatcher-chunk-6",
        "text": "(\"from_region\", fromRegion), (\"to_region\", toRegion), (\"reason\", reason) ); } } ` Performance at Scale | Metric | Target | Achieved | |--------|--------|----------| | Global saga coordination | < 100ms | 85ms p99 | | Consensus round-trip | < 50ms | 35ms p99 | | Regional failover | < 5s | 3 2s |\n| State replication lag | < 500ms | 320ms p99 |\n| Split-brain detection | < 1s | 750ms |\n| Global lock acquisition | < 20ms | 15ms p99 |\nTesting Distributed Orchestration\n`csharp\n[Test]\npublic class DistributedOrchestratorTests {\n    [Test]\n    public async Task Orchestrator_ShouldFailoverOnRegionFailure() {\n        // Arrange\n        var orchestrator = CreateDistributedOrchestrator();\n        var saga = new TestSaga();\n        // Simulate region failure during execution\n        SimulateRegionFailure(\"us-east-1\", afterSteps: 2);\n        // Act\n        var result = await orchestrator Execute(saga, new TestCommand());\n        // Assert\n        Assert True(result Success);\n        Assert Contains(\"us-west-2\", result ExecutionRegions);\n        Assert That(result FailoverOccurred, Is True);\n    }\n    [Test]\n    public async Task Consensus_ShouldElectNewLeader() {\n        // Test leader election\n    }\n}\n`\nConfiguration\n`csharp\nservices AddWhizbangOrchestrator(options => {\n    // Configure regions\n    options Regions Add(\"us-east-1\", \"orchestrator us-east-1 example com\");\n    options Regions Add(\"eu-west-1\", \"orchestrator eu-west-1 example com\");\n    options Regions Add(\"ap-south-1\", \"orchestrator ap-south-1 example com\");\n    // Configure consensus\n    options Consensus UseRaft(raft => {\n        raft ElectionTimeout = TimeSpan FromMilliseconds(150);\n        raft HeartbeatInterval = TimeSpan FromMilliseconds(50);\n    });\n    // Configure failover\n    options Failover Policy = FailoverPolicy ClosestHealthyRegion;\n    options Failover MaxRetries = 3;\n    // Configure monitoring\n    options Monitoring EnableDistributedTracing = true;\n    options Monitoring EnableGlobalMetrics = true;\n});\n`\nRelated Documentation\nv0 3 0 Orchestration - Saga patterns\nProduction Guide - Deployment best practices\nConsensus Patterns - Distributed consensus\nDisaster Recovery - Recovery procedures",
        "startIndex": 15243,
        "preview": "(\"from_region\", fromRegion), (\"to_region\", toRegion), (\"reason\", reason) ); } } ` Performance at Scale | Metric | Target | Achieved | |--------|------..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.5.0/production/drivers",
    "title": "Distributed Multi-Model Drivers",
    "category": "Production",
    "url": "/docs/v0.5.0/production/drivers",
    "chunks": [
      {
        "id": "v0.5.0/production/drivers-chunk-0",
        "text": "Distributed Multi-Model Drivers Version Status\nVersion History\n:::updated\nProduction-ready in v0 5 0: \nDistributed multi-model drivers\nAutomatic sharding and partitioning\nCross-region replication\nCloud-native drivers (DynamoDB, Cosmos DB, Spanner)\nIntelligent routing and caching\n:::\nDistributed Architecture\nMulti-Model Driver\n:::new\nSingle driver interface supporting multiple storage models:\n:::\n`csharp\n[WhizbangDriver(\"MultiModel\")]\npublic class MultiModelDriver : IDriver, IDistributedDriver {\n    private readonly IDriverRouter _router;\n    private readonly IDriverRegistry _registry;\n    private readonly IShardManager _shardManager;\n    private readonly IReplicationManager _replication;\n    public string Name => \"MultiModel\";\n    public DriverCapabilities Capabilities => \n        DriverCapabilities Persistence | \n        DriverCapabilities Transactions |\n        DriverCapabilities Queries |\n        DriverCapabilities Indexing |\n        DriverCapabilities Streaming |\n        DriverCapabilities Distributed;\n    public MultiModelDriver(MultiModelOptions options) {\n        _router = new IntelligentRouter(options RoutingStrategy);\n        _registry = new DriverRegistry();\n        _shardManager = new ConsistentHashShardManager(options ShardCount);\n        _replication = new MultiRegionReplicationManager(options Regions);\n        // Register model-specific drivers\n        RegisterDrivers(options);\n    }\n    private void RegisterDrivers(MultiModelOptions options) {\n        // Document model - MongoDB/CosmosDB\n        _registry Register(ModelType Document, \n            new CosmosDBDriver(options CosmosDB));\n        // Key-Value model - Redis/DynamoDB\n        _registry Register(ModelType KeyValue, \n            new DynamoDBDriver(options DynamoDB));\n        // Graph model - Neo4j/CosmosDB Gremlin\n        _registry Register(ModelType Graph, \n            new Neo4jDriver(options Neo4j));\n        // Time-series model - InfluxDB/TimescaleDB\n        _registry Register(ModelType TimeSeries, \n            new InfluxDBDriver(options InfluxDB));\n        // Relational model - PostgreSQL/Spanner\n        _registry Register(ModelType Relational, \n            new SpannerDriver(options Spanner));\n    }\n    public async Task<T > Get<T>(string key) where T : class {\n        // Determine optimal driver based on access patterns\n        var driver = _router RouteRead<T>(key);\n        // Try cache first\n        var cached = await _cacheDriver Get<T>(key);\n        if (cached = null) return cached;\n        // Determine shard\n        var shard = _shardManager GetShard(key);\n        // Read from primary region\n        var result = await driver Get<T>(shard GetShardedKey(key));\n        // Update cache\n        if (result = null) {\n            await _cacheDriver Set(key, result, TimeSpan FromMinutes(5));\n        }\n        return result;\n    }\n    public async Task Set<T>(string key, T value) where T : class {\n        // Determine optimal driver based on data characteristics\n        var driver = _router RouteWrite<T>(key, value);\n        // Determine shard\n        var shard = _shardManager",
        "startIndex": 0,
        "preview": "Distributed Multi-Model Drivers Version Status\nVersion History\n:::updated\nProduction-ready in v0 5 0: \nDistributed multi-model drivers\nAutomatic shard..."
      },
      {
        "id": "v0.5.0/production/drivers-chunk-1",
        "text": "Update cache if (result = null) { await _cacheDriver Set(key, result, TimeSpan FromMinutes(5)); } return result; } public async Task Set<T>(string key, T value) where T : class { // Determine optimal driver based on data characteristics var driver = _router RouteWrite<T>(key, value); // Determine shard var shard = _shardManager GetShard(key);\n        var shardedKey = shard GetShardedKey(key);\n        // Write to primary\n        await driver Set(shardedKey, value);\n        // Replicate asynchronously\n        _ = _replication ReplicateAsync(shardedKey, value, driver Name);\n        // Update cache\n        await _cacheDriver Set(key, value, TimeSpan FromMinutes(5));\n        // Update indexes\n        await UpdateIndexes(key, value);\n    }\n}\n`\nIntelligent Routing\n:::new\nAI-powered routing based on access patterns:\n:::\n`csharp\npublic class IntelligentRouter : IDriverRouter {\n    private readonly IAccessPatternAnalyzer _analyzer;\n    private readonly IModelSelector _modelSelector;\n    private readonly RoutingCache _routingCache;\n    public IDriver RouteRead<T>(string key) {\n        // Check cached routing decision\n        if (_routingCache TryGetRoute(key, out var cachedDriver)) {\n            return cachedDriver;\n        }\n        // Analyze access patterns\n        var patterns = _analyzer AnalyzeType<T>();\n        // Select optimal model\n        var model = _modelSelector SelectModel(patterns);\n        var driver = model switch {\n            // Frequent point lookups -> Key-Value\n            ModelType KeyValue when patterns PointLookupRatio > 0 8 => \n                GetDriver(ModelType KeyValue),\n            // Complex queries -> Document\n            ModelType Document when patterns QueryComplexity > 0 6 => \n                GetDriver(ModelType Document),\n            // Relationships -> Graph\n            ModelType Graph when patterns RelationshipDepth > 2 => \n                GetDriver(ModelType Graph),\n            // Time-based -> TimeSeries\n            ModelType TimeSeries when patterns TemporalAccess > 0 7 => \n                GetDriver(ModelType TimeSeries),\n            // Default -> Relational\n            _ => GetDriver(ModelType Relational)\n        };\n        // Cache routing decision\n        _routingCache SetRoute(key, driver, TimeSpan FromHours(1));\n        return driver;\n    }\n}\npublic class AccessPatternAnalyzer {\n    private readonly IMetricsCollector _metrics;\n    public AccessPatterns AnalyzeType<T>() {\n        var typeName = typeof(T) FullName;\n        return new AccessPatterns {\n            PointLookupRatio = _metrics GetRatio($\"{typeName} point_lookups\"),\n            QueryComplexity = _metrics GetAverage($\"{typeName} query_complexity\"),\n            RelationshipDepth = CalculateRelationshipDepth<T>(),\n            TemporalAccess = _metrics GetRatio($\"{typeName} temporal_queries\"),\n            WriteFrequency = _metrics GetRate($\"{typeName} writes\"),\n            DataSize = _metrics GetAverage($\"{typeName}",
        "startIndex": 3110,
        "preview": "Update cache if (result = null) { await _cacheDriver Set(key, result, TimeSpan FromMinutes(5)); } return result; } public async Task Set<T>(string key..."
      },
      {
        "id": "v0.5.0/production/drivers-chunk-2",
        "text": "} } public class AccessPatternAnalyzer { private readonly IMetricsCollector _metrics; public AccessPatterns AnalyzeType<T>() { var typeName = typeof(T) FullName; return new AccessPatterns { PointLookupRatio = _metrics GetRatio($\"{typeName} point_lookups\"), QueryComplexity = _metrics GetAverage($\"{typeName} query_complexity\"), RelationshipDepth = CalculateRelationshipDepth<T>(), TemporalAccess = _metrics GetRatio($\"{typeName} temporal_queries\"), WriteFrequency = _metrics GetRate($\"{typeName} writes\"), DataSize = _metrics GetAverage($\"{typeName} size\")\n        };\n    }\n}\n`\nCloud-Native Drivers\nAWS DynamoDB Driver\n:::new\nServerless NoSQL with automatic scaling:\n:::\n`csharp\n[WhizbangDriver(\"DynamoDB\")]\npublic class DynamoDBDriver : IDriver, IDistributedDriver {\n    private readonly IAmazonDynamoDB _client;\n    private readonly DynamoDBOptions _options;\n    public DynamoDBDriver(DynamoDBOptions options) {\n        _options = options;\n        var config = new AmazonDynamoDBConfig {\n            RegionEndpoint = RegionEndpoint GetBySystemName(options Region),\n            MaxErrorRetry = 3,\n            Timeout = TimeSpan FromSeconds(30),\n            ReadWriteTimeout = TimeSpan FromSeconds(30)\n        };\n        _client = new AmazonDynamoDBClient(config);\n        // Ensure table exists with global tables\n        EnsureGlobalTable() Wait();\n    }\n    private async Task EnsureGlobalTable() {\n        var createRequest = new CreateTableRequest {\n            TableName = _options TableName,\n            AttributeDefinitions = new List<AttributeDefinition> {\n                new() { AttributeName = \"pk\", AttributeType = \"S\" },\n                new() { AttributeName = \"sk\", AttributeType = \"S\" },\n                new() { AttributeName = \"gsi1pk\", AttributeType = \"S\" },\n                new() { AttributeName = \"gsi1sk\", AttributeType = \"S\" }\n            },\n            KeySchema = new List<KeySchemaElement> {\n                new() { AttributeName = \"pk\", KeyType = \"HASH\" },\n                new() { AttributeName = \"sk\", KeyType = \"RANGE\" }\n            },\n            GlobalSecondaryIndexes = new List<GlobalSecondaryIndex> {\n                new() {\n                    IndexName = \"GSI1\",\n                    KeySchema = new List<KeySchemaElement> {\n                        new() { AttributeName = \"gsi1pk\", KeyType = \"HASH\" },\n                        new() { AttributeName = \"gsi1sk\", KeyType = \"RANGE\" }\n                    },\n                    Projection = new Projection { ProjectionType = \"ALL\" },\n                    ProvisionedThroughput = new ProvisionedThroughput {\n                        ReadCapacityUnits = 5,\n                        WriteCapacityUnits = 5\n                    }\n                }\n            },\n            BillingMode = BillingMode PAY_PER_REQUEST,\n            StreamSpecification = new StreamSpecification {\n                StreamEnabled = true,\n                StreamViewType = StreamViewType NEW_AND_OLD_IMAGES\n            }\n        };\n        try {\n            await _client",
        "startIndex": 5741,
        "preview": "} } public class AccessPatternAnalyzer { private readonly IMetricsCollector _metrics; public AccessPatterns AnalyzeType<T>() { var typeName = typeof(T..."
      },
      {
        "id": "v0.5.0/production/drivers-chunk-3",
        "text": "KeyType = \"RANGE\" } }, Projection = new Projection { ProjectionType = \"ALL\" }, ProvisionedThroughput = new ProvisionedThroughput { ReadCapacityUnits = 5, WriteCapacityUnits = 5 } } }, BillingMode = BillingMode PAY_PER_REQUEST, StreamSpecification = new StreamSpecification { StreamEnabled = true, StreamViewType = StreamViewType NEW_AND_OLD_IMAGES } }; try { await _client CreateTableAsync(createRequest);\n        } catch (ResourceInUseException) {\n            // Table already exists\n        }\n        // Enable global tables\n        if (_options GlobalRegions Any() == true) {\n            await EnableGlobalTable();\n        }\n    }\n    public async Task<T > Get<T>(string key) where T : class {\n        var request = new GetItemRequest {\n            TableName = _options TableName,\n            Key = new Dictionary<string, AttributeValue> {\n                [\"pk\"] = new AttributeValue { S = GetPartitionKey(key) },\n                [\"sk\"] = new AttributeValue { S = GetSortKey(key) }\n            },\n            ConsistentRead = _options ConsistentRead\n        };\n        var response = await _client GetItemAsync(request);\n        if ( response Item ContainsKey(\"data\")) return null;\n        var json = response Item[\"data\"] S;\n        return JsonSerializer Deserialize<T>(json);\n    }\n    public async Task Set<T>(string key, T value) where T : class {\n        var item = new Dictionary<string, AttributeValue> {\n            [\"pk\"] = new AttributeValue { S = GetPartitionKey(key) },\n            [\"sk\"] = new AttributeValue { S = GetSortKey(key) },\n            [\"data\"] = new AttributeValue { S = JsonSerializer Serialize(value) },\n            [\"type\"] = new AttributeValue { S = typeof(T) FullName },\n            [\"ttl\"] = new AttributeValue { N = GetTTL() ToString() },\n            [\"gsi1pk\"] = new AttributeValue { S = GetGSI1PartitionKey<T>() },\n            [\"gsi1sk\"] = new AttributeValue { S = GetGSI1SortKey(value) }\n        };\n        var request = new PutItemRequest {\n            TableName = _options TableName,\n            Item = item,\n            ConditionExpression = _options OptimisticLocking \"attribute_not_exists(pk) OR version = :current_version\"\n                : null\n        };\n        await _client PutItemAsync(request);\n    }\n    // Advanced query using GSI\n    public async Task<IEnumerable<T>> QueryByType<T>() where T : class {\n        var request = new QueryRequest {\n            TableName = _options",
        "startIndex": 8211,
        "preview": "KeyType = \"RANGE\" } }, Projection = new Projection { ProjectionType = \"ALL\" }, ProvisionedThroughput = new ProvisionedThroughput { ReadCapacityUnits =..."
      },
      {
        "id": "v0.5.0/production/drivers-chunk-4",
        "text": "= new PutItemRequest { TableName = _options TableName, Item = item, ConditionExpression = _options OptimisticLocking \"attribute_not_exists(pk) OR version = :current_version\" : null }; await _client PutItemAsync(request); } // Advanced query using GSI public async Task<IEnumerable<T>> QueryByType<T>() where T : class { var request = new QueryRequest { TableName = _options TableName,\n            IndexName = \"GSI1\",\n            KeyConditionExpression = \"gsi1pk = :type\",\n            ExpressionAttributeValues = new Dictionary<string, AttributeValue> {\n                [\":type\"] = new AttributeValue { S = typeof(T) FullName }\n            },\n            Limit = 100\n        };\n        var response = await _client QueryAsync(request);\n        return response Items Select(item => {\n            var json = item[\"data\"] S;\n            return JsonSerializer Deserialize<T>(json);\n        }) Where(x => x = null) ;\n    }\n}\n`\nAzure Cosmos DB Driver\n:::new\nGlobally distributed multi-model database:\n:::\n`csharp\n[WhizbangDriver(\"CosmosDB\")]\npublic class CosmosDBDriver : IDriver, IDistributedDriver {\n    private readonly CosmosClient _client;\n    private readonly Database _database;\n    private readonly Container _container;\n    public CosmosDBDriver(CosmosDBOptions options) {\n        _client = new CosmosClient(\n            options ConnectionString,\n            new CosmosClientOptions {\n                ApplicationRegion = options PreferredRegion,\n                ConsistencyLevel = ConsistencyLevel Session,\n                MaxRetryAttemptsOnRateLimitedRequests = 3,\n                MaxRetryWaitTimeOnRateLimitedRequests = TimeSpan FromSeconds(30),\n                EnableContentResponseOnWrite = false,\n                EnableTcpConnectionEndpointRediscovery = true\n            }\n        );\n        _database = _client GetDatabase(options Database);\n        _container = _database GetContainer(options Container);\n        // Configure multi-region writes\n        if (options EnableMultiRegionWrites) {\n            ConfigureMultiRegion() Wait();\n        }\n    }\n    public async Task<T > Get<T>(string key) where T : class {\n        try {\n            var response = await _container ReadItemAsync<CosmosDocument<T>>(\n                id: key,\n                partitionKey: new PartitionKey(GetPartitionKey(key)),\n                new ItemRequestOptions {\n                    ConsistencyLevel = ConsistencyLevel Session\n                }\n            );\n            return response Resource Data;\n        }\n        catch (CosmosException ex) when (ex StatusCode == HttpStatusCode NotFound) {\n            return null;\n        }\n    }\n    public async Task Set<T>(string key, T value) where T : class {\n        var document = new CosmosDocument<T> {\n            id = key,\n            PartitionKey = GetPartitionKey(key),\n            Data = value,\n            Type = typeof(T) FullName,\n            Timestamp = DateTimeOffset UtcNow,\n            TTL = _options DefaultTTL\n        };\n        await _container UpsertItemAsync(\n            document,\n            new PartitionKey(document",
        "startIndex": 10288,
        "preview": "= new PutItemRequest { TableName = _options TableName, Item = item, ConditionExpression = _options OptimisticLocking \"attribute_not_exists(pk) OR vers..."
      },
      {
        "id": "v0.5.0/production/drivers-chunk-5",
        "text": "return null; } } public async Task Set<T>(string key, T value) where T : class { var document = new CosmosDocument<T> { id = key, PartitionKey = GetPartitionKey(key), Data = value, Type = typeof(T) FullName, Timestamp = DateTimeOffset UtcNow, TTL = _options DefaultTTL }; await _container UpsertItemAsync( document, new PartitionKey(document PartitionKey),\n            new ItemRequestOptions {\n                EnableContentResponseOnWrite = false\n            }\n        );\n    }\n    // Change feed for real-time updates\n    public async Task SubscribeToChanges<T>(Action<T> handler) where T : class {\n        var processor = _container GetChangeFeedProcessorBuilder<CosmosDocument<T>>(\n                processorName: $\"processor-{typeof(T) Name}\",\n                onChangesDelegate: async (changes, cancellationToken) => {\n                    foreach (var change in changes) {\n                        if (change Type == typeof(T) FullName) {\n                            handler(change Data);\n                        }\n                    }\n                }) WithInstanceName(Environment MachineName) WithLeaseContainer(_database GetContainer(\"leases\")) Build();\n        await processor StartAsync();\n    }\n}\n`\nGoogle Spanner Driver\n:::new\nGlobally consistent relational database:\n:::\n`csharp\n[WhizbangDriver(\"Spanner\")]\npublic class SpannerDriver : IDriver, ITransactionalDriver {\n    private readonly SpannerConnection _connection;\n    private readonly SpannerOptions _options;\n    public async Task<T > Get<T>(string key) where T : class {\n        using var cmd = _connection CreateSelectCommand(\n            \"SELECT data FROM whizbang_store WHERE key = @key\",\n            new SpannerParameterCollection {\n                { \"key\", SpannerDbType String, key }\n            }\n        );\n        using var reader = await cmd ExecuteReaderAsync();\n        if (await reader ReadAsync()) {\n            var json = reader GetFieldValue<string>(\"data\");\n            return JsonSerializer Deserialize<T>(json);\n        }\n        return null;\n    }\n    // Distributed transaction support\n    public async Task<ITransaction> BeginTransaction(TransactionOptions options) {\n        var transaction = await _connection BeginTransactionAsync(\n            options IsolationLevel == IsolationLevel Serializable TransactionOptions ReadWrite()\n                : TransactionOptions",
        "startIndex": 12992,
        "preview": "return null; } } public async Task Set<T>(string key, T value) where T : class { var document = new CosmosDocument<T> { id = key, PartitionKey = GetPa..."
      },
      {
        "id": "v0.5.0/production/drivers-chunk-6",
        "text": "); using var reader = await cmd ExecuteReaderAsync(); if (await reader ReadAsync()) { var json = reader GetFieldValue<string>(\"data\"); return JsonSerializer Deserialize<T>(json); } return null; } // Distributed transaction support public async Task<ITransaction> BeginTransaction(TransactionOptions options) { var transaction = await _connection BeginTransactionAsync( options IsolationLevel == IsolationLevel Serializable TransactionOptions ReadWrite() : TransactionOptions ReadOnly()\n        );\n        return new SpannerTransaction(transaction);\n    }\n}\n`\nAutomatic Sharding\nConsistent Hash Sharding\n`csharp\npublic class ConsistentHashShardManager : IShardManager {\n    private readonly ConsistentHash<ShardNode> _ring;\n    private readonly int _virtualNodesPerShard;\n    public ConsistentHashShardManager(int shardCount, int virtualNodes = 150) {\n        _virtualNodesPerShard = virtualNodes;\n        _ring = new ConsistentHash<ShardNode>();\n        // Initialize shards\n        for (int i = 0; i < shardCount; i++) {\n            var shard = new ShardNode($\"shard-{i}\", i);\n            AddShard(shard);\n        }\n    }\n    public ShardNode GetShard(string key) {\n        return _ring GetNode(key);\n    }\n    public async Task Rebalance() {\n        // Detect imbalanced shards\n        var distribution = await AnalyzeDistribution();\n        if (distribution StandardDeviation > 0 2) {\n            // Add virtual nodes to underutilized shards\n            foreach (var shard in distribution UnderutilizedShards) {\n                AddVirtualNodes(shard, 50);\n            }\n            // Migrate data from overutilized shards\n            foreach (var shard in distribution OverutilizedShards) {\n                await MigrateData(shard, distribution UnderutilizedShards);\n            }\n        }\n    }\n}\n`\nPerformance Monitoring\nDistributed Tracing\n`csharp\npublic class TracedDriver : IDriver {\n    private readonly IDriver _inner;\n    private readonly ITracer _tracer;\n    public async Task<T > Get<T>(string key) where T : class {\n        using var span = _tracer StartSpan(\"driver get\", new SpanContext {\n            Tags = {\n                [\"driver type\"] = _inner Name,\n                [\"key\"] = key,\n                [\"type\"] = typeof(T) FullName\n            }\n        });\n        try {\n            var result = await _inner Get<T>(key);\n            span SetTag(\"cache hit\", result = null);\n            return result;\n        }\n        catch (Exception ex) {\n            span",
        "startIndex": 15082,
        "preview": "); using var reader = await cmd ExecuteReaderAsync(); if (await reader ReadAsync()) { var json = reader GetFieldValue<string>(\"data\"); return JsonSeri..."
      },
      {
        "id": "v0.5.0/production/drivers-chunk-7",
        "text": "{ using var span = _tracer StartSpan(\"driver get\", new SpanContext { Tags = { [\"driver type\"] = _inner Name, [\"key\"] = key, [\"type\"] = typeof(T) FullName } }); try { var result = await _inner Get<T>(key); span SetTag(\"cache hit\", result = null); return result; } catch (Exception ex) { span RecordException(ex);\n            throw;\n        }\n    }\n}\n`\nPerformance at Scale\n| Driver | Write Latency | Read Latency | Global Consistency | Auto-Scaling |\n|--------|--------------|--------------|-------------------|--------------|\n| DynamoDB | < 10ms | < 5ms | Eventual | Yes |\n| Cosmos DB | < 10ms | < 5ms | Multiple levels | Yes |\n| Spanner | < 20ms | < 10ms | Strong | Yes |\n| Multi-Model | < 15ms | < 8ms | Configurable | Yes |\nTesting Distributed Drivers\n`csharp\n[Test]\npublic class DistributedDriverTests {\n    [Test]\n    public async Task MultiRegion_ShouldReplicateData() {\n        // Setup multi-region driver\n        var driver = new MultiModelDriver(new MultiModelOptions {\n            Regions = new[] { \"us-east-1\", \"eu-west-1\", \"ap-southeast-1\" }\n        });\n        // Write to primary region\n        await driver Set(\"test-key\", new TestEntity { Name = \"Test\" });\n        // Wait for replication\n        await Task Delay(TimeSpan FromSeconds(2));\n        // Read from secondary region\n        var driver2 = new MultiModelDriver(new MultiModelOptions {\n            PreferredRegion = \"eu-west-1\"\n        });\n        var result = await driver2 Get<TestEntity>(\"test-key\");\n        Assert NotNull(result);\n        Assert Equal(\"Test\", result Name);\n    }\n}\n`\nRelated Documentation\nv0 4 0 Database Drivers - SQL/NoSQL drivers\nProduction Guide - Driver selection for production\nScaling Guide - Sharding and partitioning\nCloud Architecture - Cloud-native patterns",
        "startIndex": 17089,
        "preview": "{ using var span = _tracer StartSpan(\"driver get\", new SpanContext { Tags = { [\"driver type\"] = _inner Name, [\"key\"] = key, [\"type\"] = typeof(T) FullN..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.5.0/production/ledger",
    "title": "Distributed Event Store",
    "category": "Production",
    "url": "/docs/v0.5.0/production/ledger",
    "chunks": [
      {
        "id": "v0.5.0/production/ledger-chunk-0",
        "text": "Distributed Event Store Version Status\nVersion History\n:::updated\nProduction-ready in v0 5 0: \nDistributed multi-region event store\nAutomatic replication and failover\nEvent stream partitioning\ngRPC and Kafka streaming\nGlobal ordering guarantees\n:::\nDistributed Architecture\nMulti-Region Deployment\n:::new\nDeploy event stores across multiple regions with automatic replication:\n:::\n`csharp\n// Configure distributed event store\nservices AddDistributedEventStore(options => {\n    options Regions = new[] {\n        new RegionConfig {\n            Name = \"us-east-1\",\n            IsPrimary = true,\n            Endpoints = new[] { \"es1 us-east whizbang io\", \"es2 us-east whizbang io\" },\n            ReplicationLag = TimeSpan FromMilliseconds(50)\n        },\n        new RegionConfig {\n            Name = \"eu-west-1\",\n            IsPrimary = false,\n            Endpoints = new[] { \"es1 eu-west whizbang io\", \"es2 eu-west whizbang io\" },\n            ReplicationLag = TimeSpan FromMilliseconds(150)\n        },\n        new RegionConfig {\n            Name = \"ap-south-1\",\n            IsPrimary = false,\n            Endpoints = new[] { \"es1 ap-south whizbang io\" },\n            ReplicationLag = TimeSpan FromMilliseconds(200)\n        }\n    };\n    options Replication = new ReplicationOptions {\n        Mode = ReplicationMode Asynchronous,\n        ConsistencyLevel = ConsistencyLevel EventuallyConsistent,\n        ConflictResolution = ConflictResolutionStrategy LastWriteWins,\n        MaxReplicationLag = TimeSpan FromSeconds(5)\n    };\n    options Failover = new FailoverOptions {\n        Strategy = FailoverStrategy Automatic,\n        DetectionTime = TimeSpan FromSeconds(10),\n        PromotionTime = TimeSpan FromSeconds(30),\n        MinNodesForQuorum = 2\n    };\n});\n`\nEvent Stream Partitioning\n:::new\nPartition streams for horizontal scaling:\n:::\n`csharp\n[EventStream(PartitionStrategy = PartitionStrategy ByAggregateType)]\npublic class PartitionedEventStore : IDistributedEventStore {\n    private readonly IPartitionManager _partitions;\n    public async Task<EventPosition> Append(string streamId, IEvent @event) {\n        // Determine partition based on stream\n        var partition = _partitions GetPartition(streamId);\n        // Route to appropriate partition node\n        var node = partition GetPrimaryNode();\n        // Append with global ordering\n        var globalPosition = await node AppendWithGlobalOrder(\n            streamId, \n            @event,\n            _partitions GetGlobalSequencer()\n        );\n        // Replicate to secondary nodes\n        await partition ReplicateAsync(@event, globalPosition);\n        return globalPosition;\n    }\n}\n// Partition configuration\nservices ConfigurePartitions(config => {\n    config PartitionCount = 128;  // Number of partitions\n    config ReplicationFactor = 3; // Copies per partition\n    config",
        "startIndex": 0,
        "preview": "Distributed Event Store Version Status\nVersion History\n:::updated\nProduction-ready in v0 5 0: \nDistributed multi-region event store\nAutomatic replicat..."
      },
      {
        "id": "v0.5.0/production/ledger-chunk-1",
        "text": "global ordering var globalPosition = await node AppendWithGlobalOrder( streamId, @event, _partitions GetGlobalSequencer() ); // Replicate to secondary nodes await partition ReplicateAsync(@event, globalPosition); return globalPosition; } } // Partition configuration services ConfigurePartitions(config => { config PartitionCount = 128; // Number of partitions config ReplicationFactor = 3; // Copies per partition config Strategy = new ConsistentHashingStrategy {\n        HashFunction = HashFunction MurmurHash3,\n        VirtualNodes = 150 // For better distribution\n    };\n    config AutoRebalance = new AutoRebalanceOptions {\n        Enabled = true,\n        Threshold = 0 2, // 20% imbalance triggers rebalance\n        MaxConcurrentMoves = 5\n    };\n});\n`\nGlobal Event Ordering\n:::new\nMaintain global ordering across distributed nodes:\n:::\n`csharp\npublic interface IGlobalSequencer {\n    Task<GlobalSequence> GetNext(string partitionKey);\n    Task<GlobalSequence> GetNextBatch(string partitionKey, int count);\n}\npublic class HybridLogicalClock : IGlobalSequencer {\n    private long _logicalTime;\n    private readonly ITimeProvider _timeProvider;\n    public async Task<GlobalSequence> GetNext(string partitionKey) {\n        var physicalTime = _timeProvider GetCurrentTime();\n        var logicalTime = Interlocked Increment(ref _logicalTime);\n        return new GlobalSequence {\n            PhysicalTimestamp = physicalTime,\n            LogicalCounter = logicalTime,\n            NodeId = Environment MachineName,\n            PartitionKey = partitionKey,\n            // Globally unique, monotonically increasing\n            Value = (physicalTime << 20) | (logicalTime & 0xFFFFF)\n        };\n    }\n}\n// Usage in event store\npublic class GloballyOrderedEventStore {\n    private readonly IGlobalSequencer _sequencer;\n    public async Task<EventEnvelope> AppendWithGlobalOrder(\n        string streamId, \n        IEvent @event) {\n        // Get globally unique sequence\n        var sequence = await _sequencer GetNext(streamId);\n        return new EventEnvelope {\n            StreamId = streamId,\n            Event = @event,\n            GlobalPosition = sequence Value,\n            Timestamp = sequence PhysicalTimestamp,\n            CausalityClock = sequence ToVector()\n        };\n    }\n}\n`\nEvent Streaming Protocols\ngRPC Streaming\n:::new\nHigh-performance event streaming via gRPC:\n:::\n`csharp\n// Proto definition\nservice EventStore {\n    rpc AppendEvents(stream AppendRequest) returns (stream AppendResponse);\n    rpc SubscribeToStream(SubscribeRequest) returns (stream EventEnvelope);\n    rpc SubscribeToAll(SubscribeAllRequest) returns (stream EventEnvelope);\n}\n// Server implementation\npublic class GrpcEventStoreService : EventStore",
        "startIndex": 2846,
        "preview": "global ordering var globalPosition = await node AppendWithGlobalOrder( streamId, @event, _partitions GetGlobalSequencer() ); // Replicate to secondary..."
      },
      {
        "id": "v0.5.0/production/ledger-chunk-2",
        "text": "sequence ToVector() }; } } ` Event Streaming Protocols gRPC Streaming :::new High-performance event streaming via gRPC: ::: `csharp // Proto definition service EventStore { rpc AppendEvents(stream AppendRequest) returns (stream AppendResponse); rpc SubscribeToStream(SubscribeRequest) returns (stream EventEnvelope); rpc SubscribeToAll(SubscribeAllRequest) returns (stream EventEnvelope); } // Server implementation public class GrpcEventStoreService : EventStore EventStoreBase {\n    private readonly IDistributedEventStore _store;\n    public override async Task SubscribeToAll(\n        SubscribeAllRequest request,\n        IServerStreamWriter<EventEnvelope> responseStream,\n        ServerCallContext context) {\n        var subscription = _store SubscribeToAll(\n            from: request FromPosition,\n            filter: ParseFilter(request Filter)\n        );\n        await foreach (var @event in subscription WithCancellation(context CancellationToken)) {\n            // Transform to protobuf\n            var envelope = new EventEnvelope {\n                EventId = @event Id ToString(),\n                StreamId = @event StreamId,\n                EventType = @event EventType,\n                EventData = Google Protobuf ByteString CopyFrom(@event Data),\n                Metadata = ConvertMetadata(@event Metadata),\n                GlobalPosition = @event Position\n            };\n            await responseStream WriteAsync(envelope);\n            // Heartbeat every 100 events\n            if (@event Position % 100 == 0) {\n                await responseStream WriteAsync(CreateHeartbeat());\n            }\n        }\n    }\n}\n// Client usage\npublic class GrpcEventConsumer {\n    private readonly EventStore EventStoreClient _client;\n    public async Task ConsumeEvents(CancellationToken ct) {\n        using var call = _client SubscribeToAll(new SubscribeAllRequest {\n            FromPosition = 0,\n            Filter = new EventFilter {\n                EventTypes = { \"OrderCreated\", \"OrderShipped\" },\n                IncludeSystemEvents = false\n            }\n        });\n        await foreach (var envelope in call ResponseStream ReadAllAsync(ct)) {\n            await ProcessEvent(envelope);\n        }\n    }\n}\n`\nKafka Integration\n:::new\nEvent streaming through Kafka for broader integration:\n:::\n`csharp\n[KafkaEventPublisher(Topic = \"whizbang events\")]\npublic class KafkaEventStore : IEventStore {\n    private readonly IProducer<string, byte[]> _producer;\n    private readonly IDistributedEventStore _store;\n    public async Task<EventPosition> Append(string streamId, IEvent @event) {\n        // Save to event store\n        var position = await _store Append(streamId, @event);\n        // Publish to Kafka\n        var message = new Message<string, byte[]> {\n            Key = streamId,\n            Value = SerializeEvent(@event),\n            Headers = new Headers {\n                { \"event-type\", Encoding UTF8 GetBytes(@event GetType() Name) },\n                { \"global-position\", BitConverter GetBytes(position",
        "startIndex": 5156,
        "preview": "sequence ToVector() }; } } ` Event Streaming Protocols gRPC Streaming :::new High-performance event streaming via gRPC: ::: `csharp // Proto definitio..."
      },
      {
        "id": "v0.5.0/production/ledger-chunk-3",
        "text": "streamId, IEvent @event) { // Save to event store var position = await _store Append(streamId, @event); // Publish to Kafka var message = new Message<string, byte[]> { Key = streamId, Value = SerializeEvent(@event), Headers = new Headers { { \"event-type\", Encoding UTF8 GetBytes(@event GetType() Name) }, { \"global-position\", BitConverter GetBytes(position Value) },\n                { \"timestamp\", BitConverter GetBytes(DateTimeOffset UtcNow ToUnixTimeMilliseconds()) }\n            }\n        };\n        await _producer ProduceAsync($\"whizbang events {GetPartition(streamId)}\", message);\n        return position;\n    }\n}\n// Kafka consumer for projections\npublic class KafkaProjectionConsumer {\n    private readonly IConsumer<string, byte[]> _consumer;\n    private readonly IProjectionManager _projections;\n    public async Task Start(CancellationToken ct) {\n        _consumer Subscribe(new[] {\n            \"whizbang events 0\",\n            \"whizbang events 1\",\n            // all partitions\n        });\n        while ( ct IsCancellationRequested) {\n            var result = _consumer Consume(ct);\n            var @event = DeserializeEvent(result Message Value);\n            await _projections HandleEvent(@event);\n            // Commit offset after processing\n            _consumer Commit(result);\n        }\n    }\n}\n`\nProduction Features\nMonitoring & Observability\n`csharp\npublic class EventStoreMetrics {\n    private readonly IMetricsCollector _metrics;\n    public void RecordAppend(string streamId, TimeSpan duration, bool success) {\n        _metrics RecordHistogram(\"eventstore append duration\", duration TotalMilliseconds,\n            (\"stream\", streamId),\n            (\"success\", success ToString()));\n        _metrics Increment($\"eventstore append {(success \"success\" : \"failure\")}\");\n    }\n    public void RecordReplicationLag(string region, TimeSpan lag) {\n        _metrics RecordGauge($\"eventstore replication lag {region}\", lag TotalMilliseconds);\n    }\n    public void RecordPartitionBalance(Dictionary<int, int> distribution) {\n        var stdDev = CalculateStandardDeviation(distribution Values);\n        _metrics RecordGauge(\"eventstore partition balance stddev\", stdDev);\n    }\n}\n`\nBackup & Recovery\n`csharp\npublic class EventStoreBackup {\n    public async Task CreateBackup(BackupOptions options) {\n        // Create consistent snapshot across all partitions\n        var snapshot = await CreateConsistentSnapshot();\n        // Stream events to backup storage\n        await using var backupStream = OpenBackupStream(options Destination);\n        await foreach (var partition in GetPartitions()) {\n            await BackupPartition(partition, backupStream, snapshot Timestamp);\n        }\n        // Write metadata\n        await WriteBackupMetadata(backupStream, snapshot);\n    }\n    public async Task RestoreFromBackup(string backupPath, RestoreOptions options) {\n        // Read backup metadata\n        var metadata = await ReadBackupMetadata(backupPath);\n        // Restore partitions in parallel\n        await Parallel ForEachAsync(metadata",
        "startIndex": 7709,
        "preview": "streamId, IEvent @event) { // Save to event store var position = await _store Append(streamId, @event); // Publish to Kafka var message = new Message<..."
      },
      {
        "id": "v0.5.0/production/ledger-chunk-4",
        "text": "var backupStream = OpenBackupStream(options Destination); await foreach (var partition in GetPartitions()) { await BackupPartition(partition, backupStream, snapshot Timestamp); } // Write metadata await WriteBackupMetadata(backupStream, snapshot); } public async Task RestoreFromBackup(string backupPath, RestoreOptions options) { // Read backup metadata var metadata = await ReadBackupMetadata(backupPath); // Restore partitions in parallel await Parallel ForEachAsync(metadata Partitions, async (partition, ct) => {\n            await RestorePartition(partition, backupPath, options);\n        });\n        // Rebuild indexes\n        await RebuildIndexes();\n        // Resume replication\n        await ResumeReplication(metadata LastPosition);\n    }\n}\n`\nCapacity Planning\n`csharp\npublic class CapacityPlanner {\n    public CapacityReport AnalyzeCapacity(TimeSpan window) {\n        return new CapacityReport {\n            EventsPerSecond = CalculateEventRate(window),\n            StorageGrowthRate = CalculateStorageGrowth(window),\n            ProjectedCapacity = ProjectCapacity(window * 12), // 1 year projection\n            Recommendations = new[] {\n                $\"Add {CalculateRequiredNodes()} nodes for 50% growth\",\n                $\"Increase partitions to {CalculateOptimalPartitions()} for better distribution\",\n                $\"Archive events older than {CalculateArchiveAge()} days\"\n            }\n        };\n    }\n}\n`\nPerformance at Scale\n| Metric | Target | Achieved |\n|--------|--------|----------|\n| Write throughput | 100K events/sec | 125K events/sec |\n| Read throughput | 1M events/sec | 1 2M events/sec |\n| Replication lag (same region) | < 100ms | 45ms p99 |\n| Replication lag (cross region) | < 500ms | 320ms p99 |\n| Global ordering overhead | < 5% | 3 2% |\n| Partition rebalance time | < 5 min | 3 5 min |\n| Recovery time (100GB) | < 30 min | 22 min |\nTesting Distributed Features\n`csharp\n[Test]\npublic class DistributedEventStoreTests {\n    [Test]\n    public async Task Replication_ShouldMaintainConsistency() {\n        // Setup 3-node cluster\n        var nodes = CreateCluster(3);\n        // Write to primary\n        var primary = nodes GetPrimary();\n        await primary Append(\"stream-1\", new TestEvent());\n        // Wait for replication\n        await Task Delay(TimeSpan FromSeconds(1));\n        // Read from replicas\n        foreach (var replica in nodes GetReplicas()) {\n            var events = await replica ReadStream(\"stream-1\");\n            Assert Equal(1, events",
        "startIndex": 10414,
        "preview": "var backupStream = OpenBackupStream(options Destination); await foreach (var partition in GetPartitions()) { await BackupPartition(partition, backupSt..."
      },
      {
        "id": "v0.5.0/production/ledger-chunk-5",
        "text": "// Setup 3-node cluster var nodes = CreateCluster(3); // Write to primary var primary = nodes GetPrimary(); await primary Append(\"stream-1\", new TestEvent()); // Wait for replication await Task Delay(TimeSpan FromSeconds(1)); // Read from replicas foreach (var replica in nodes GetReplicas()) { var events = await replica ReadStream(\"stream-1\"); Assert Equal(1, events Count);\n        }\n    }\n    [Test]\n    public async Task Failover_ShouldPromoteReplica() {\n        // Test automatic failover\n    }\n}\n`\nRelated Documentation\nv0 3 0 Event Sourcing - Core ES/CQRS\nv0 4 0 Database - SQL/JSONB storage\nProduction Guide - Deployment best practices\nDisaster Recovery - Backup and recovery procedures\nCapacity Planning - Sizing guidelines",
        "startIndex": 12434,
        "preview": "// Setup 3-node cluster var nodes = CreateCluster(3); // Write to primary var primary = nodes GetPrimary(); await primary Append(\"stream-1\", new TestE..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.5.0/production/policies",
    "title": "Production Policy System",
    "category": "Production",
    "url": "/docs/v0.5.0/production/policies",
    "chunks": [
      {
        "id": "v0.5.0/production/policies-chunk-0",
        "text": "Production Policy System Version Status Next Update\nVersion History\n:::updated\nProduction-ready in v0 5 0: \nDistributed policy coordination across services\nPolicy federation for multi-region deployments\nML-based policy tuning and optimization\nAdvanced observability and tracing\n:::\n:::planned\nComing in v0 6 0: \nSecurity policies (authorization, encryption)\nCompliance and audit policies\nPolicy governance and approval workflows\nSee security features →\n:::\nDistributed Coordination\nCross-Service Policy State\n:::new\nCoordinate policies across distributed services:\n:::\n`csharp\n// Configure distributed coordination\nservices AddDistributedPolicies(options => {\n    options UseConsul(consul => {\n        consul Address = \"consul:8500\";\n        consul Datacenter = \"us-east-1\";\n        consul ServiceName = \"order-service\";\n    });\n    options Coordination = new CoordinationOptions {\n        SyncInterval = TimeSpan FromSeconds(5),\n        ConflictResolution = ConflictStrategy LastWriteWins,\n        PartitionTolerance = true\n    };\n});\n// Distributed circuit breaker\n[DistributedCircuitBreaker(\n    ServiceName = \"payment-api\",\n    Scope = DistributionScope Global,  // All instances share state\n    FailureThreshold = 0 5,\n    CoordinationGroup = \"payment-services\"\n)]\npublic class PaymentReceptor : IReceptor<ProcessPayment> {\n    public async Task<PaymentResult> Receive(ProcessPayment cmd) {\n        // Circuit state synchronized across all services\n        // If any instance opens the circuit, all see it\n        return await ProcessPayment(cmd);\n    }\n}\n`\nFederated Rate Limiting\n:::new\nRate limits that span multiple regions and services:\n:::\n`csharp\n[FederatedRateLimit(\n    TokenLimit = 10000,\n    Window = TimeSpan FromMinute(1),\n    Federation = new FederationOptions {\n        Regions = new[] { \"us-east-1\", \"eu-west-1\", \"ap-south-1\" },\n        ReplicationStrategy = ReplicationStrategy EventualConsistency,\n        ConflictResolution = ConflictStrategy MergeTokens,\n        SyncLatencyMs = 100\n    }\n)]\npublic class GlobalApiReceptor : IReceptor<ApiCall> {\n    public async Task<ApiResult> Receive(ApiCall cmd) {\n        // Rate limit applies globally across all regions\n        // Token consumption synchronized with eventual consistency\n        return await HandleApiCall(cmd);\n    }\n}\n// Per-tenant federated limits\n[FederatedRateLimit(\n    TokenLimitProvider = typeof(TenantLimitProvider),\n    Window = TimeSpan FromHour(1),\n    Scope = FederationScope",
        "startIndex": 0,
        "preview": "Production Policy System Version Status Next Update\nVersion History\n:::updated\nProduction-ready in v0 5 0: \nDistributed policy coordination across ser..."
      },
      {
        "id": "v0.5.0/production/policies-chunk-1",
        "text": "100 } )] public class GlobalApiReceptor : IReceptor<ApiCall> { public async Task<ApiResult> Receive(ApiCall cmd) { // Rate limit applies globally across all regions // Token consumption synchronized with eventual consistency return await HandleApiCall(cmd); } } // Per-tenant federated limits [FederatedRateLimit( TokenLimitProvider = typeof(TenantLimitProvider), Window = TimeSpan FromHour(1), Scope = FederationScope PerTenant\n)]\npublic class TenantApiReceptor : IReceptor<TenantApiCall> { }\n`\nML-Based Optimization\nAdaptive Policies\n:::new\nPolicies that learn and adapt based on patterns:\n:::\n`csharp\n[AdaptivePolicy(\n    LearningModel = typeof(CircuitBreakerMLModel),\n    TrainingWindow = TimeSpan FromDays(7),\n    UpdateInterval = TimeSpan FromHours(1)\n)]\npublic class SmartCircuitBreaker : IAdaptivePolicy {\n    private readonly IMLEngine _mlEngine;\n    public async Task<PolicyParameters> Optimize(PolicyMetrics metrics) {\n        // ML model analyzes:\n        // - Failure patterns over time\n        // - Recovery time distributions\n        // - Request characteristics\n        // - Downstream service health\n        var prediction = await _mlEngine Predict(metrics);\n        return new PolicyParameters {\n            FailureThreshold = prediction OptimalThreshold,\n            SamplingDuration = prediction OptimalWindow,\n            BreakDuration = prediction OptimalBreakTime\n        };\n    }\n}\n// Usage\n[UseAdaptivePolicy(typeof(SmartCircuitBreaker))]\npublic class IntelligentReceptor : IReceptor<Command> { }\n`\nPredictive Scaling\n:::new\nPolicies that anticipate load patterns:\n:::\n`csharp\n[PredictivePolicy(\n    Model = \"load-forecasting-v2\",\n    PredictionWindow = TimeSpan FromMinutes(15),\n    Actions = PredictiveAction AdjustLimits | PredictiveAction PreWarm\n)]\npublic class PredictiveRateLimiter : IPredictivePolicy {\n    public async Task<PolicyAdjustment> PredictAndAdjust(TimeSeriesData data) {\n        var forecast = await ForecastLoad(data);\n        if (forecast ExpectedLoad > CurrentCapacity * 0 8) {\n            return new PolicyAdjustment {\n                RateLimit = forecast ExpectedLoad * 1 2,\n                BulkheadSize = CalculateOptimalBulkhead(forecast),\n                PreWarmConnections = forecast ExpectedLoad / 10,\n                EffectiveAt = forecast PeakTime AddMinutes(-5)\n            };\n        }\n        return PolicyAdjustment NoChange;\n    }\n}\n`\nAdvanced Observability\nDistributed Tracing\n:::new\nFull policy execution tracing across services:\n:::\n`csharp\n[TracedPolicy(DetailLevel = TraceDetail",
        "startIndex": 2474,
        "preview": "100 } )] public class GlobalApiReceptor : IReceptor<ApiCall> { public async Task<ApiResult> Receive(ApiCall cmd) { // Rate limit applies globally acro..."
      },
      {
        "id": "v0.5.0/production/policies-chunk-2",
        "text": "{ return new PolicyAdjustment { RateLimit = forecast ExpectedLoad * 1 2, BulkheadSize = CalculateOptimalBulkhead(forecast), PreWarmConnections = forecast ExpectedLoad / 10, EffectiveAt = forecast PeakTime AddMinutes(-5) }; } return PolicyAdjustment NoChange; } } ` Advanced Observability Distributed Tracing :::new Full policy execution tracing across services: ::: `csharp [TracedPolicy(DetailLevel = TraceDetail Full)]\npublic class TracedReceptor : IReceptor<Command> {\n    // Automatically generates spans for:\n    // - Policy evaluation\n    // - Each retry attempt\n    // - Circuit state changes\n    // - Rate limit checks\n    // - Cache lookups\n}\n// Custom trace enrichment\npublic class CustomTracingPolicy : ITracedPolicy {\n    public void EnrichSpan(ISpan span, IPolicyContext context) {\n        span SetTag(\"tenant id\", context TenantId);\n        span SetTag(\"policy version\", \"v2 3\");\n        span SetBaggage(\"correlation id\", context CorrelationId);\n        if (context HasPreviousFailures) {\n            span LogEvent(\"previous_failures\", context Failures);\n        }\n    }\n}\n`\nPolicy Analytics\n:::new\nComprehensive analytics and reporting:\n:::\n`csharp\n// Enable analytics\nservices AddPolicyAnalytics(options => {\n    options UseTimeSeries(ts => {\n        ts Database = \"InfluxDB\";\n        ts RetentionDays = 90;\n        ts Aggregations = new[] { \"1m\", \"5m\", \"1h\", \"1d\" };\n    });\n    options Reports = new[] {\n        new PolicyEffectivenessReport(),\n        new CostBenefitAnalysisReport(),\n        new SLAComplianceReport()\n    };\n    options Alerting = new AlertingOptions {\n        Provider = AlertProvider PagerDuty,\n        Rules = new[] {\n            new AlertRule(\"circuit_open_too_long\", TimeSpan FromMinutes(30)),\n            new AlertRule(\"cache_hit_rate_low\", threshold: 0 5)\n        }\n    };\n});\n// Query analytics\npublic class PolicyAnalyzer {\n    public async Task<PolicyInsights> Analyze(DateRange range) {\n        return new PolicyInsights {\n            RetrySuccessRate = await CalculateRetryEffectiveness(range),\n            CircuitBreakerROI = await CalculateCircuitBreakerValue(range),\n            CacheEfficiency = await AnalyzeCachePerformance(range),\n            OptimalConfiguration = await SuggestOptimalConfig(range)\n        };\n    }\n}\n`\nFederation Patterns\nMulti-Region Coordination\n`csharp\n// Configure multi-region federation\nservices AddPolicyFederation(options => {\n    options Regions = new[] {\n        new Region(\"us-east-1\", priority: 1, isPrimary: true),\n        new Region(\"eu-west-1\", priority: 2),\n        new Region(\"ap-south-1\", priority: 3)\n    };\n    options Replication = new ReplicationOptions {\n        Strategy = ReplicationStrategy MasterSlave,\n        ConsistencyLevel = ConsistencyLevel Eventual,\n        MaxReplicationLag = TimeSpan FromSeconds(5)\n    };\n    options",
        "startIndex": 4601,
        "preview": "{ return new PolicyAdjustment { RateLimit = forecast ExpectedLoad * 1 2, BulkheadSize = CalculateOptimalBulkhead(forecast), PreWarmConnections = forec..."
      },
      {
        "id": "v0.5.0/production/policies-chunk-3",
        "text": "Coordination `csharp // Configure multi-region federation services AddPolicyFederation(options => { options Regions = new[] { new Region(\"us-east-1\", priority: 1, isPrimary: true), new Region(\"eu-west-1\", priority: 2), new Region(\"ap-south-1\", priority: 3) }; options Replication = new ReplicationOptions { Strategy = ReplicationStrategy MasterSlave, ConsistencyLevel = ConsistencyLevel Eventual, MaxReplicationLag = TimeSpan FromSeconds(5) }; options FailoverPolicy = new FailoverPolicy {\n        Strategy = FailoverStrategy Automatic,\n        HealthCheckInterval = TimeSpan FromSeconds(10),\n        PromotionDelay = TimeSpan FromSeconds(30)\n    };\n});\n`\nCross-Service Policy Mesh\n`csharp\n[PolicyMesh(\"order-processing-mesh\")]\npublic class OrderService {\n    [MeshPolicy(PropagateContext = true)]\n    public async Task<Order> ProcessOrder(CreateOrder cmd) {\n        // Policy context flows through service mesh\n        // Coordinated rate limiting across all services\n        // Shared circuit breaker state\n        // Distributed tracing enabled\n    }\n}\n// Mesh configuration\nservices ConfigurePolicyMesh(\"order-processing-mesh\", mesh => {\n    mesh Services = new[] {\n        \"order-service\",\n        \"inventory-service\",\n        \"payment-service\",\n        \"shipping-service\"\n    };\n    mesh Policies = new PolicyMeshConfiguration {\n        SharedRateLimit = 10000, // Shared across all services\n        CircuitBreakerScope = MeshScope PerService,\n        TracingEnabled = true,\n        MetricsAggregation = AggregationLevel Mesh\n    };\n});\n`\nProduction Deployment\nZero-Downtime Policy Updates\n`csharp\npublic class PolicyDeployment {\n    public async Task DeployPolicyUpdate(PolicyUpdate update) {\n        // Phase 1: Deploy to canary (5% traffic)\n        await DeployToCanary(update);\n        await MonitorCanaryMetrics(TimeSpan FromMinutes(10));\n        // Phase 2: Progressive rollout\n        foreach (var percentage in new[] { 25, 50, 75, 100 }) {\n            await IncreaseRolloutPercentage(percentage);\n            await MonitorHealthMetrics(TimeSpan FromMinutes(5));\n            if (await DetectRegression()) {\n                await Rollback();\n                return;\n            }\n        }\n        // Phase 3: Finalize\n        await FinalizePolicyUpdate(update);\n    }\n}\n`\nPolicy Versioning\n`csharp\n[PolicyVersion(\"2 0\")]\npublic class VersionedPolicy : IVersionedPolicy {\n    public PolicyVersion Version => new PolicyVersion(2, 0);\n    public async Task<TResult> Execute<TResult>(\n        Func<Task<TResult>> operation,\n        IPolicyContext context\n    ) {\n        // Check for version-specific behavior\n        if (context",
        "startIndex": 7017,
        "preview": "Coordination `csharp // Configure multi-region federation services AddPolicyFederation(options => { options Regions = new[] { new Region(\"us-east-1\", ..."
      },
      {
        "id": "v0.5.0/production/policies-chunk-4",
        "text": "{ await Rollback(); return; } } // Phase 3: Finalize await FinalizePolicyUpdate(update); } } ` Policy Versioning `csharp [PolicyVersion(\"2 0\")] public class VersionedPolicy : IVersionedPolicy { public PolicyVersion Version => new PolicyVersion(2, 0); public async Task<TResult> Execute<TResult>( Func<Task<TResult>> operation, IPolicyContext context ) { // Check for version-specific behavior if (context ClientVersion < new Version(2, 0)) {\n            // Apply backward compatibility\n            return await ExecuteV1Compatible(operation, context);\n        }\n        return await ExecuteV2(operation, context);\n    }\n}\n`\nPerformance at Scale\n| Metric | Target | Achieved |\n|--------|--------|----------|\n| Policy evaluation | < 100ns | 82ns p99 |\n| Distributed sync | < 10ms | 7ms p99 |\n| Federation overhead | < 5% | 3 2% |\n| ML prediction | < 50ms | 35ms p99 |\n| Trace overhead | < 2% | 1 5% |\nTesting Distributed Policies\n`csharp\n[Test]\npublic class DistributedPolicyTests {\n    [Test]\n    public async Task Federation_ShouldSynchronizeAcrossRegions() {\n        // Arrange\n        var regions = new[] {\n            new TestRegion(\"us-east-1\"),\n            new TestRegion(\"eu-west-1\")\n        };\n        var federation = new PolicyFederation(regions);\n        // Act - trigger rate limit in one region\n        await regions[0] ConsumeTokens(100);\n        await federation Synchronize();\n        // Assert - other region sees consumption\n        Assert Equal(900, await regions[1] GetAvailableTokens());\n    }\n}\n`\nRelated Documentation\nv0 3 0 State Management - Stateful policies\nv0 6 0 Security - Security policies\nProduction Guide - Deployment best practices\nMonitoring - Observability setup",
        "startIndex": 9204,
        "preview": "{ await Rollback(); return; } } // Phase 3: Finalize await FinalizePolicyUpdate(update); } } ` Policy Versioning `csharp [PolicyVersion(\"2 0\")] public..."
      }
    ]
  },
  {
    "type": "document",
    "slug": "v0.5.0/production/transports",
    "title": "Cloud-Native Transports",
    "category": "Production",
    "url": "/docs/v0.5.0/production/transports",
    "chunks": [
      {
        "id": "v0.5.0/production/transports-chunk-0",
        "text": "Cloud-Native Transports Version Status\nVersion History\n:::updated\nProduction-ready in v0 5 0: \nAWS SQS/SNS transport with FIFO support\nAzure Service Bus with sessions and transactions\nGoogle Cloud Pub/Sub with ordering keys\nMulti-cloud message federation\nGlobal routing and failover\n:::\nCloud Provider Transports\nAWS SQS/SNS Transport\n:::new\nFully managed AWS messaging with auto-scaling:\n:::\n`csharp\n[WhizbangTransport(\"AWS\")]\npublic class AWSTransport : ITransport, ICloudTransport {\n    private readonly IAmazonSQS _sqsClient;\n    private readonly IAmazonSNS _snsClient;\n    private readonly AWSTransportOptions _options;\n    private readonly ISerializer _serializer;\n    private readonly Dictionary<string, string> _queueUrls;\n    private readonly Dictionary<string, string> _topicArns;\n    public string Name => \"AWS\";\n    public TransportCapabilities Capabilities => \n        TransportCapabilities RequestResponse |\n        TransportCapabilities PublishSubscribe |\n        TransportCapabilities Reliable |\n        TransportCapabilities Ordered |\n        TransportCapabilities CloudNative;\n    public AWSTransport(AWSTransportOptions options) {\n        _options = options;\n        _serializer = new CloudEventSerializer();\n        _queueUrls = new ConcurrentDictionary<string, string>();\n        _topicArns = new ConcurrentDictionary<string, string>();\n        var config = new AmazonSQSConfig {\n            RegionEndpoint = RegionEndpoint GetBySystemName(options Region),\n            MaxErrorRetry = 3,\n            Timeout = TimeSpan FromSeconds(30)\n        };\n        _sqsClient = new AmazonSQSClient(config);\n        _snsClient = new AmazonSNSClient(config);\n        // Initialize resources\n        InitializeResources() Wait();\n    }\n    private async Task InitializeResources() {\n        // Create or get queues\n        foreach (var queueConfig in _options Queues) {\n            var queueUrl = await EnsureQueue(queueConfig);\n            _queueUrls[queueConfig Name] = queueUrl;\n        }\n        // Create or get topics\n        foreach (var topicConfig in _options Topics) {\n            var topicArn = await EnsureTopic(topicConfig);\n            _topicArns[topicConfig Name] = topicArn;\n        }\n    }\n    private async Task<string> EnsureQueue(QueueConfig config) {\n        var attributes = new Dictionary<string, string> {\n            [\"MessageRetentionPeriod\"] = config RetentionPeriod TotalSeconds ToString(),\n            [\"VisibilityTimeout\"] = config VisibilityTimeout TotalSeconds ToString(),\n            [\"ReceiveMessageWaitTimeSeconds\"] = \"20\", // Long polling\n        };\n        if (config IsFifo) {\n            attributes[\"FifoQueue\"] = \"true\";\n            attributes[\"ContentBasedDeduplication\"] = \"true\";\n        }\n        if (config EnableDLQ) {\n            // Create DLQ first\n            var dlqUrl = await CreateDeadLetterQueue(config Name);\n            attributes[\"RedrivePolicy\"] = JsonSerializer Serialize(new {\n                deadLetterTargetArn = GetQueueArn(dlqUrl),\n                maxReceiveCount = config MaxReceiveCount\n            });\n        }\n        if (config EnableEncryption) {\n            attributes[\"KmsMasterKeyId\"] = config KmsKeyId",
        "startIndex": 0,
        "preview": "Cloud-Native Transports Version Status\nVersion History\n:::updated\nProduction-ready in v0 5 0: \nAWS SQS/SNS transport with FIFO support\nAzure Service B..."
      },
      {
        "id": "v0.5.0/production/transports-chunk-1",
        "text": "Long polling }; if (config IsFifo) { attributes[\"FifoQueue\"] = \"true\"; attributes[\"ContentBasedDeduplication\"] = \"true\"; } if (config EnableDLQ) { // Create DLQ first var dlqUrl = await CreateDeadLetterQueue(config Name); attributes[\"RedrivePolicy\"] = JsonSerializer Serialize(new { deadLetterTargetArn = GetQueueArn(dlqUrl), maxReceiveCount = config MaxReceiveCount }); } if (config EnableEncryption) { attributes[\"KmsMasterKeyId\"] = config KmsKeyId \"alias/aws/sqs\";\n        }\n        var request = new CreateQueueRequest {\n            QueueName = config IsFifo $\"{config Name} fifo\" : config Name,\n            Attributes = attributes,\n            Tags = config Tags\n        };\n        var response = await _sqsClient CreateQueueAsync(request);\n        return response QueueUrl;\n    }\n    public async Task<TResponse> Send<TRequest, TResponse>(\n        TRequest request, \n        string destination)\n        where TRequest : IMessage\n        where TResponse : IMessage {\n        var queueUrl = _queueUrls[destination];\n        var responseQueueUrl = await CreateTemporaryResponseQueue();\n        try {\n            // Send request with response queue info\n            var messageBody = _serializer Serialize(request);\n            var sendRequest = new SendMessageRequest {\n                QueueUrl = queueUrl,\n                MessageBody = messageBody,\n                MessageAttributes = new Dictionary<string, MessageAttributeValue> {\n                    [\"ResponseQueue\"] = new() { \n                        DataType = \"String\", \n                        StringValue = responseQueueUrl \n                    },\n                    [\"CorrelationId\"] = new() { \n                        DataType = \"String\", \n                        StringValue = request Id ToString() \n                    },\n                    [\"MessageType\"] = new() { \n                        DataType = \"String\", \n                        StringValue = typeof(TRequest) FullName \n                    }\n                }\n            };\n            if (queueUrl EndsWith(\" fifo\")) {\n                sendRequest MessageGroupId = GetMessageGroupId(request);\n                sendRequest MessageDeduplicationId = request Id ToString();\n            }\n            await _sqsClient SendMessageAsync(sendRequest);\n            // Wait for response\n            return await WaitForResponse<TResponse>(responseQueueUrl, request Id);\n        }\n        finally {\n            // Clean up temporary queue\n            await _sqsClient DeleteQueueAsync(responseQueueUrl);\n        }\n    }\n    public async Task Publish<TMessage>(TMessage message, string topic)\n        where TMessage : IMessage {\n        var topicArn = _topicArns[topic];\n        // Convert to CloudEvents format\n        var cloudEvent = new CloudEvent {\n            Id = message Id ToString(),\n            Source = new Uri($\"whizbang://{Environment MachineName}\"),\n            Type = typeof(TMessage) FullName,\n            Time = DateTimeOffset UtcNow,\n            Data = message,\n            DataContentType = \"application/json\"\n        };\n        var publishRequest = new PublishRequest {\n            TopicArn = topicArn,\n            Message = JsonSerializer Serialize(cloudEvent),\n            MessageAttributes = ConvertToSNSAttributes(message Headers)\n        };\n        if (topic EndsWith(\" fifo\")) {\n            publishRequest",
        "startIndex": 3189,
        "preview": "Long polling }; if (config IsFifo) { attributes[\"FifoQueue\"] = \"true\"; attributes[\"ContentBasedDeduplication\"] = \"true\"; } if (config EnableDLQ) { // ..."
      },
      {
        "id": "v0.5.0/production/transports-chunk-2",
        "text": "{ Id = message Id ToString(), Source = new Uri($\"whizbang://{Environment MachineName}\"), Type = typeof(TMessage) FullName, Time = DateTimeOffset UtcNow, Data = message, DataContentType = \"application/json\" }; var publishRequest = new PublishRequest { TopicArn = topicArn, Message = JsonSerializer Serialize(cloudEvent), MessageAttributes = ConvertToSNSAttributes(message Headers) }; if (topic EndsWith(\" fifo\")) { publishRequest MessageGroupId = GetMessageGroupId(message);\n            publishRequest MessageDeduplicationId = message Id ToString();\n        }\n        await _snsClient PublishAsync(publishRequest);\n    }\n    public async Task Subscribe<TMessage>(string topic, Func<TMessage, Task> handler)\n        where TMessage : IMessage {\n        // Create SQS queue for subscription\n        var queueName = $\"{topic}-{typeof(TMessage) Name}-{Guid NewGuid():N}\";\n        var queueUrl = await EnsureQueue(new QueueConfig { \n            Name = queueName,\n            AutoDelete = true \n        });\n        // Subscribe queue to SNS topic\n        var topicArn = _topicArns[topic];\n        await _snsClient SubscribeAsync(new SubscribeRequest {\n            Protocol = \"sqs\",\n            TopicArn = topicArn,\n            Endpoint = GetQueueArn(queueUrl),\n            Attributes = new Dictionary<string, string> {\n                [\"RawMessageDelivery\"] = \"true\"\n            }\n        });\n        // Start polling\n        _ = Task Run(async () => {\n            while ( _cancellationToken IsCancellationRequested) {\n                var receiveRequest = new ReceiveMessageRequest {\n                    QueueUrl = queueUrl,\n                    MaxNumberOfMessages = 10,\n                    WaitTimeSeconds = 20,\n                    MessageAttributeNames = new List<string> { \"All\" }\n                };\n                var response = await _sqsClient ReceiveMessageAsync(receiveRequest);\n                foreach (var sqsMessage in response Messages) {\n                    try {\n                        var cloudEvent = JsonSerializer Deserialize<CloudEvent>(sqsMessage Body);\n                        var message = (TMessage)cloudEvent Data;\n                        await handler(message);\n                        // Delete message on success\n                        await _sqsClient DeleteMessageAsync(queueUrl, sqsMessage ReceiptHandle);\n                    }\n                    catch (Exception ex) {\n                        _logger",
        "startIndex": 6089,
        "preview": "{ Id = message Id ToString(), Source = new Uri($\"whizbang://{Environment MachineName}\"), Type = typeof(TMessage) FullName, Time = DateTimeOffset UtcNo..."
      },
      {
        "id": "v0.5.0/production/transports-chunk-3",
        "text": "new List<string> { \"All\" } }; var response = await _sqsClient ReceiveMessageAsync(receiveRequest); foreach (var sqsMessage in response Messages) { try { var cloudEvent = JsonSerializer Deserialize<CloudEvent>(sqsMessage Body); var message = (TMessage)cloudEvent Data; await handler(message); // Delete message on success await _sqsClient DeleteMessageAsync(queueUrl, sqsMessage ReceiptHandle); } catch (Exception ex) { _logger LogError(ex, \"Failed to process SQS message\");\n                        // Message will be retried based on queue configuration\n                    }\n                }\n            }\n        });\n    }\n}\n`\nAzure Service Bus Transport\n:::new\nEnterprise messaging with sessions and transactions:\n:::\n`csharp\n[WhizbangTransport(\"AzureServiceBus\")]\npublic class AzureServiceBusTransport : ITransport, ICloudTransport {\n    private readonly ServiceBusClient _client;\n    private readonly Dictionary<string, ServiceBusSender> _senders;\n    private readonly Dictionary<string, ServiceBusProcessor> _processors;\n    private readonly AzureServiceBusOptions _options;\n    public AzureServiceBusTransport(AzureServiceBusOptions options) {\n        _options = options;\n        _senders = new ConcurrentDictionary<string, ServiceBusSender>();\n        _processors = new ConcurrentDictionary<string, ServiceBusProcessor>();\n        var clientOptions = new ServiceBusClientOptions {\n            TransportType = ServiceBusTransportType AmqpWebSockets,\n            RetryOptions = new ServiceBusRetryOptions {\n                Mode = ServiceBusRetryMode Exponential,\n                MaxRetries = 3,\n                Delay = TimeSpan FromSeconds(1),\n                MaxDelay = TimeSpan FromSeconds(30)\n            }\n        };\n        _client = new ServiceBusClient(options ConnectionString, clientOptions);\n    }\n    public async Task<TResponse> Send<TRequest, TResponse>(\n        TRequest request, \n        string destination)\n        where TRequest : IMessage\n        where TResponse : IMessage {\n        var sender = GetOrCreateSender(destination);\n        var message = new ServiceBusMessage {\n            Body = BinaryData FromObjectAsJson(request),\n            MessageId = request Id ToString(),\n            CorrelationId = request Id ToString(),\n            SessionId = GetSessionId(request),\n            ContentType = \"application/json\",\n            TimeToLive = _options MessageTTL,\n            ApplicationProperties = {\n                [\"MessageType\"] = typeof(TRequest) FullName,\n                [\"ReplyTo\"] = $\"response-{request Id}\"\n            }\n        };\n        // Add custom headers\n        foreach (var header in request Headers) {\n            message ApplicationProperties[header Key] = header Value;\n        }\n        // Use transaction if available\n        if (Transaction Current = null) {\n            await sender SendMessageAsync(message);\n        } else {\n            // Create new transaction\n            using var ts = new TransactionScope(\n                TransactionScopeAsyncFlowOption Enabled);\n            await sender SendMessageAsync(message);\n            ts Complete();\n        }\n        // Wait for response\n        return await WaitForSessionResponse<TResponse>(\n            $\"response-{request Id}\", \n            request",
        "startIndex": 8088,
        "preview": "new List<string> { \"All\" } }; var response = await _sqsClient ReceiveMessageAsync(receiveRequest); foreach (var sqsMessage in response Messages) { try..."
      },
      {
        "id": "v0.5.0/production/transports-chunk-4",
        "text": "Key] = header Value; } // Use transaction if available if (Transaction Current = null) { await sender SendMessageAsync(message); } else { // Create new transaction using var ts = new TransactionScope( TransactionScopeAsyncFlowOption Enabled); await sender SendMessageAsync(message); ts Complete(); } // Wait for response return await WaitForSessionResponse<TResponse>( $\"response-{request Id}\", request Id\n        );\n    }\n    public async Task Subscribe<TMessage>(string topic, Func<TMessage, Task> handler)\n        where TMessage : IMessage {\n        var processor = _client CreateProcessor(\n            topic,\n            new ServiceBusProcessorOptions {\n                MaxConcurrentCalls = _options MaxConcurrency,\n                PrefetchCount = _options PrefetchCount,\n                AutoCompleteMessages = false,\n                MaxAutoLockRenewalDuration = TimeSpan FromMinutes(5),\n                ReceiveMode = ServiceBusReceiveMode PeekLock\n            }\n        );\n        processor ProcessMessageAsync += async args => {\n            try {\n                var message = args Message Body ToObjectFromJson<TMessage>();\n                // Restore headers\n                foreach (var prop in args Message ApplicationProperties) {\n                    message Headers[prop Key] = prop Value ToString() \"\";\n                }\n                await handler(message);\n                // Complete message\n                await args CompleteMessageAsync(args Message);\n            }\n            catch (Exception ex) {\n                _logger LogError(ex, \"Failed to process Service Bus message\");\n                // Move to dead letter queue\n                await args DeadLetterMessageAsync(\n                    args Message,\n                    deadLetterReason: ex GetType() Name,\n                    deadLetterErrorDescription: ex Message\n                );\n            }\n        };\n        processor ProcessErrorAsync += async args => {\n            _logger LogError(args Exception, \n                \"Service Bus processor error on {EntityPath}\", \n                args EntityPath);\n        };\n        await processor StartProcessingAsync();\n        _processors[topic] = processor;\n    }\n}\n`\nGoogle Cloud Pub/Sub Transport\n:::new\nGlobal message distribution with Google Cloud:\n:::\n`csharp\n[WhizbangTransport(\"GooglePubSub\")]\npublic class GooglePubSubTransport : ITransport, ICloudTransport {\n    private readonly PublisherServiceApiClient _publisher;\n    private readonly SubscriberServiceApiClient _subscriber;\n    private readonly GooglePubSubOptions _options;\n    private readonly Dictionary<string, TopicName> _topics;\n    private readonly Dictionary<string, SubscriptionName> _subscriptions;\n    public async Task Publish<TMessage>(TMessage message, string topic)\n        where TMessage : IMessage {\n        var topicName = _topics[topic];\n        var pubsubMessage = new PubsubMessage {\n            Data = ByteString CopyFrom(_serializer Serialize(message)),\n            OrderingKey = GetOrderingKey(message),\n            Attributes = {\n                [\"messageType\"] = typeof(TMessage) FullName,\n                [\"messageId\"] = message Id ToString(),\n                [\"timestamp\"] = DateTimeOffset UtcNow ToUnixTimeSeconds()",
        "startIndex": 10924,
        "preview": "Key] = header Value; } // Use transaction if available if (Transaction Current = null) { await sender SendMessageAsync(message); } else { // Create ne..."
      },
      {
        "id": "v0.5.0/production/transports-chunk-5",
        "text": "Dictionary<string, SubscriptionName> _subscriptions; public async Task Publish<TMessage>(TMessage message, string topic) where TMessage : IMessage { var topicName = _topics[topic]; var pubsubMessage = new PubsubMessage { Data = ByteString CopyFrom(_serializer Serialize(message)), OrderingKey = GetOrderingKey(message), Attributes = { [\"messageType\"] = typeof(TMessage) FullName, [\"messageId\"] = message Id ToString(), [\"timestamp\"] = DateTimeOffset UtcNow ToUnixTimeSeconds() ToString()\n            }\n        };\n        // Add headers as attributes\n        foreach (var header in message Headers) {\n            pubsubMessage Attributes[header Key] = header Value;\n        }\n        await _publisher PublishAsync(topicName, new[] { pubsubMessage });\n    }\n    public async Task Subscribe<TMessage>(string topic, Func<TMessage, Task> handler)\n        where TMessage : IMessage {\n        var subscriptionName = await CreateSubscription(topic, typeof(TMessage) Name);\n        var subscriber = await SubscriberClient CreateAsync(subscriptionName);\n        await subscriber StartAsync(async (PubsubMessage msg, CancellationToken ct) => {\n            try {\n                var message = _serializer Deserialize<TMessage>(msg Data ToByteArray());\n                // Restore headers\n                foreach (var attr in msg Attributes) {\n                    message Headers[attr Key] = attr Value;\n                }\n                await handler(message);\n                return SubscriberClient Reply Ack;\n            }\n            catch (Exception ex) {\n                _logger LogError(ex, \"Failed to process Pub/Sub message\");\n                return SubscriberClient Reply Nack;\n            }\n        });\n    }\n}\n`\nMulti-Cloud Federation\nFederated Transport Layer\n:::new\nSeamless messaging across cloud providers:\n:::\n`csharp\npublic class FederatedTransport : ITransport, IFederatedTransport {\n    private readonly Dictionary<CloudProvider, ICloudTransport> _transports;\n    private readonly FederationRouter _router;\n    private readonly FederationOptions _options;\n    public FederatedTransport(FederationOptions options) {\n        _options = options;\n        _transports = new Dictionary<CloudProvider, ICloudTransport>();\n        _router = new FederationRouter(options RoutingRules);\n        // Initialize cloud transports\n        InitializeTransports();\n    }\n    private void InitializeTransports() {\n        if (_options EnableAWS) {\n            _transports[CloudProvider AWS] = new AWSTransport(_options AWS);\n        }\n        if (_options EnableAzure) {\n            _transports[CloudProvider Azure] = new AzureServiceBusTransport(_options Azure);\n        }\n        if (_options EnableGCP) {\n            _transports[CloudProvider GCP] = new GooglePubSubTransport(_options GCP);\n        }\n    }\n    public async Task Publish<TMessage>(TMessage message, string topic)\n        where TMessage : IMessage {\n        // Determine target clouds based on routing rules\n        var targets = _router GetTargetClouds(topic, message);\n        // Publish to all target clouds\n        var tasks = targets",
        "startIndex": 13764,
        "preview": "Dictionary<string, SubscriptionName> _subscriptions; public async Task Publish<TMessage>(TMessage message, string topic) where TMessage : IMessage { v..."
      },
      {
        "id": "v0.5.0/production/transports-chunk-6",
        "text": "Azure); } if (_options EnableGCP) { _transports[CloudProvider GCP] = new GooglePubSubTransport(_options GCP); } } public async Task Publish<TMessage>(TMessage message, string topic) where TMessage : IMessage { // Determine target clouds based on routing rules var targets = _router GetTargetClouds(topic, message); // Publish to all target clouds var tasks = targets Select(cloud => \n            _transports[cloud] Publish(message, topic)\n        );\n        await Task WhenAll(tasks);\n    }\n    public async Task Bridge(BridgeConfiguration config) {\n        // Bridge messages between clouds\n        await Subscribe<IMessage>(config SourceTopic, async message => {\n            // Transform if needed\n            var transformed = await config Transform(message);\n            // Publish to target cloud\n            await _transports[config TargetCloud] Publish(transformed, config TargetTopic);\n        });\n    }\n}\npublic class FederationRouter {\n    private readonly List<RoutingRule> _rules;\n    public CloudProvider[] GetTargetClouds<TMessage>(string topic, TMessage message) {\n        var targets = new HashSet<CloudProvider>();\n        foreach (var rule in _rules) {\n            if (rule Matches(topic, message)) {\n                targets UnionWith(rule TargetClouds);\n                if (rule StopProcessing) break;\n            }\n        }\n        return targets ToArray();\n    }\n}\npublic class RoutingRule {\n    public string TopicPattern { get; set; }\n    public CloudProvider[] TargetClouds { get; set; }\n    public Func<IMessage, bool> Predicate { get; set; }\n    public bool StopProcessing { get; set; }\n    public bool Matches<TMessage>(string topic, TMessage message) {\n        if ( Regex IsMatch(topic, TopicPattern)) return false;\n        if (Predicate = null) {\n            return Predicate(message as IMessage);\n        }\n        return true;\n    }\n}\n`\nGlobal Message Routing\n`csharp\npublic class GlobalMessageRouter {\n    private readonly IFederatedTransport _transport;\n    private readonly IGeoLocationService _geoLocation;\n    private readonly ILatencyMonitor _latencyMonitor;\n    public async Task<CloudProvider> SelectOptimalCloud(string destination) {\n        // Get current location\n        var currentRegion = await _geoLocation GetCurrentRegion();\n        // Get latency metrics\n        var latencies = await _latencyMonitor GetLatencies(currentRegion);\n        // Select cloud with lowest latency\n        return latencies OrderBy(l => l Value) First() Key;\n    }\n    public async Task RouteWithFailover<TMessage>(\n        TMessage message, \n        string topic) where TMessage : IMessage {\n        var primaryCloud = await SelectOptimalCloud(topic);\n        try {\n            await _transport GetTransport(primaryCloud)",
        "startIndex": 16383,
        "preview": "Azure); } if (_options EnableGCP) { _transports[CloudProvider GCP] = new GooglePubSubTransport(_options GCP); } } public async Task Publish<TMessage>(..."
      },
      {
        "id": "v0.5.0/production/transports-chunk-7",
        "text": "_geoLocation GetCurrentRegion(); // Get latency metrics var latencies = await _latencyMonitor GetLatencies(currentRegion); // Select cloud with lowest latency return latencies OrderBy(l => l Value) First() Key; } public async Task RouteWithFailover<TMessage>( TMessage message, string topic) where TMessage : IMessage { var primaryCloud = await SelectOptimalCloud(topic); try { await _transport GetTransport(primaryCloud) Publish(message, topic);\n        }\n        catch (CloudTransportException) {\n            // Failover to secondary\n            var secondaryCloud = GetFailoverCloud(primaryCloud);\n            await _transport GetTransport(secondaryCloud) Publish(message, topic);\n        }\n    }\n}\n`\nMonitoring & Observability\nCross-Cloud Tracing\n`csharp\npublic class CloudTransportTracing {\n    private readonly ITracer _tracer;\n    public async Task<T> TraceCloudOperation<T>(\n        string operationName,\n        CloudProvider provider,\n        Func<Task<T>> operation) {\n        using var span = _tracer StartSpan(operationName, new SpanContext {\n            Tags = {\n                [\"cloud provider\"] = provider ToString(),\n                [\"cloud region\"] = GetRegion(provider),\n                [\"transport type\"] = \"cloud\"\n            }\n        });\n        try {\n            var result = await operation();\n            span SetTag(\"success\", true);\n            return result;\n        }\n        catch (Exception ex) {\n            span RecordException(ex);\n            span SetTag(\"success\", false);\n            throw;\n        }\n    }\n}\n`\nPerformance at Scale\n| Cloud Provider | Throughput | Latency (same region) | Latency (cross-region) | Cost per Million |\n|----------------|------------|----------------------|------------------------|------------------|\n| AWS SQS/SNS | 3K msg/s per queue | < 10ms | 50-150ms | $0 40 |\n| Azure Service Bus | 2K msg/s | < 15ms | 60-180ms | $0 50 |\n| Google Pub/Sub | 10K msg/s | < 20ms | 70-200ms | $0 45 |\n| Federated | Varies | < 25ms | 100-250ms | Combined |\nTesting Cloud Transports\n`csharp\n[Test]\npublic class CloudTransportTests {\n    [Test]\n    public async Task Federation_ShouldRouteToMultipleClouds() {\n        // Arrange\n        var federation = new FederatedTransport(new FederationOptions {\n            EnableAWS = true,\n            EnableAzure = true,\n            RoutingRules = new[] {\n                new RoutingRule {\n                    TopicPattern = \"global *\",\n                    TargetClouds = new[] { CloudProvider AWS, CloudProvider Azure }\n                }\n            }\n        });\n        // Act\n        await federation Publish(new TestMessage(), \"global",
        "startIndex": 18838,
        "preview": "_geoLocation GetCurrentRegion(); // Get latency metrics var latencies = await _latencyMonitor GetLatencies(currentRegion); // Select cloud with lowest..."
      },
      {
        "id": "v0.5.0/production/transports-chunk-8",
        "text": "public async Task Federation_ShouldRouteToMultipleClouds() { // Arrange var federation = new FederatedTransport(new FederationOptions { EnableAWS = true, EnableAzure = true, RoutingRules = new[] { new RoutingRule { TopicPattern = \"global *\", TargetClouds = new[] { CloudProvider AWS, CloudProvider Azure } } } }); // Act await federation Publish(new TestMessage(), \"global events\");\n        // Assert - verify message in both clouds\n        // }\n}\n`\nRelated Documentation\nv0 3 0 Message Queues - Queue transports\nv0 4 0 Streaming - gRPC and streaming\nCloud Architecture - Multi-cloud patterns\nCost Optimization - Managing cloud messaging costs",
        "startIndex": 21066,
        "preview": "public async Task Federation_ShouldRouteToMultipleClouds() { // Arrange var federation = new FederatedTransport(new FederationOptions { EnableAWS = tr..."
      }
    ]
  }
]