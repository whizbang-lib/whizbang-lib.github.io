<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noindex">
  <title>Whizbang Documentation - Static Index</title>
  <meta name="description" content="Complete Whizbang documentation in a single static HTML page. Optimized for AI consumption and offline reading.">
  <style>
    :root {
      --bg: #ffffff;
      --text: #1a1a1a;
      --code-bg: #f4f4f4;
      --border: #e0e0e0;
      --link: #0066cc;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #1a1a1a;
        --text: #e0e0e0;
        --code-bg: #2d2d2d;
        --border: #404040;
        --link: #66b3ff;
      }
    }
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: var(--bg);
      color: var(--text);
    }
    a { color: var(--link); }
    code, pre {
      background: var(--code-bg);
      border-radius: 4px;
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
    }
    code { padding: 2px 6px; font-size: 0.9em; }
    pre {
      padding: 16px;
      overflow-x: auto;
      border: 1px solid var(--border);
    }
    pre code { padding: 0; background: none; }
    .header {
      border-bottom: 2px solid var(--border);
      padding-bottom: 20px;
      margin-bottom: 30px;
    }
    .quick-links {
      background: var(--code-bg);
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
    }
    .quick-links ul { margin: 10px 0; padding-left: 20px; }
    nav {
      background: var(--code-bg);
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 30px;
    }
    nav ul { padding-left: 20px; margin: 5px 0; }
    nav li { margin: 3px 0; }
    .doc-section {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
    }
    .doc-path { font-size: 0.85em; color: #666; }
    .doc-description { font-style: italic; color: #555; }
    .category-header {
      border-bottom: 1px solid var(--border);
      padding-bottom: 10px;
    }
    blockquote {
      border-left: 4px solid var(--border);
      margin: 10px 0;
      padding-left: 20px;
      color: #666;
    }
    table { border-collapse: collapse; width: 100%; margin: 10px 0; }
    th, td { border: 1px solid var(--border); padding: 8px; text-align: left; }
    th { background: var(--code-bg); }
    hr { border: none; border-top: 1px solid var(--border); margin: 20px 0; }
    .stats { font-size: 0.9em; color: #666; }
  </style>
</head>
<body>
  <div id="top"></div>

  <header class="header">
    <h1>Whizbang Documentation</h1>
    <p>A comprehensive .NET library for building event-driven, CQRS, and event-sourced applications with zero reflection and AOT compatibility.</p>

    <div class="quick-links">
      <h3>Quick Links</h3>
      <ul>
        <li><strong>Library Source:</strong> <a href="https://github.com/whizbang-lib/whizbang">github.com/whizbang-lib/whizbang</a></li>
        <li><strong>VSCode Extension:</strong> <a href="https://github.com/whizbang-lib/whizbang-vscode">github.com/whizbang-lib/whizbang-vscode</a></li>
        <li><strong>Documentation Site:</strong> <a href="https://whizbang-lib.github.io">whizbang-lib.github.io</a></li>
        <li><strong>NuGet Packages:</strong> <a href="https://www.nuget.org/profiles/SoftwareExtravaganza">nuget.org/profiles/SoftwareExtravaganza</a></li>
      </ul>
    </div>

    <div class="quick-links">
      <h3>For AI Assistants: MCP Server</h3>
      <p>For enhanced documentation access, run the Whizbang <a href="https://modelcontextprotocol.io">MCP (Model Context Protocol)</a> server locally:</p>
      <pre><code># Clone and install
git clone https://github.com/whizbang-lib/whizbang-lib.github.io.git
cd whizbang-lib.github.io/mcp-docs-server
npm install && npm run build</code></pre>
      <p><strong>Compatible AI Tools:</strong></p>
      <ul>
        <li><strong>Desktop:</strong> Claude Desktop, Google Antigravity, VS Code + Copilot, Cursor, Windsurf, Zed</li>
        <li><strong>CLI:</strong> Claude Code, Gemini CLI, GitHub Copilot CLI</li>
        <li><strong>Extensions:</strong> Continue, Cline, Sourcegraph Cody</li>
        <li><strong>Chat:</strong> ChatGPT Connectors, LibreChat</li>
      </ul>
      <pre><code># Claude Code: claude mcp add whizbang-docs node /path/to/build/index.js
# JSON config (Claude Desktop, VS Code, etc.):
{ "mcpServers": { "whizbang-docs": { "command": "node", "args": ["/path/to/build/index.js"] } } }

# MCP Tools: search-docs, find-examples, get-code-location, get-related-docs, get-tests-for-code</code></pre>
    </div>

    <p class="stats">Generated: 2026-02-25T06:16:49.649Z | Total documents: 175</p>
  </header>

  <nav>
    <h2>Table of Contents</h2>
<h3>Released Versions</h3>
<h4>v1.0.0</h4>
<ul>
  <li><a href="#v1-0-0-readme">Version 0.1.0 - Foundation Release</a></li>
  <li>
    <strong>Advanced Topics</strong>
    <ul>
      <li><a href="#v1-0-0-advanced-topics-deployment-strategies">Deployment Strategies</a></li>
      <li><a href="#v1-0-0-advanced-topics-monitoring">Monitoring &amp; Observability</a></li>
      <li><a href="#v1-0-0-advanced-topics-multi-tenancy">Multi-Tenancy Patterns</a></li>
      <li><a href="#v1-0-0-advanced-topics-native-aot">Native AOT</a></li>
      <li><a href="#v1-0-0-advanced-topics-performance-tuning">Performance Tuning</a></li>
      <li><a href="#v1-0-0-advanced-topics-scaling">Scaling Patterns</a></li>
      <li><a href="#v1-0-0-advanced-topics-security">Security Best Practices</a></li>
      <li><a href="#v1-0-0-advanced-topics-testing-receptors">Testing Receptors &amp; Perspectives</a></li>
      <li><a href="#v1-0-0-advanced-topics-troubleshooting">Troubleshooting Guide</a></li>
    </ul>
  </li>
  <li>
    <strong>Architecture</strong>
    <ul>
      <li><a href="#v1-0-0-architecture-message-lifecycle">Message Lifecycle &amp; Architecture</a></li>
    </ul>
  </li>
  <li>
    <strong>Attributes</strong>
    <ul>
      <li><a href="#v1-0-0-attributes-streamkey">StreamKey Attribute</a></li>
    </ul>
  </li>
  <li>
    <strong>Components</strong>
    <ul>
      <li><a href="#v1-0-0-components-readme">Core Components Overview</a></li>
      <li><a href="#v1-0-0-components-dispatcher">Dispatcher Component</a></li>
      <li><a href="#v1-0-0-components-drivers">Drivers Component</a></li>
      <li><a href="#v1-0-0-components-ledger">Ledger Component</a></li>
      <li><a href="#v1-0-0-components-lenses">Lenses Component</a></li>
      <li><a href="#v1-0-0-components-perspectives">Perspectives Component</a></li>
      <li><a href="#v1-0-0-components-policy-engine">Policy Engine Component</a></li>
      <li><a href="#v1-0-0-components-receptors">Receptors Component</a></li>
      <li><a href="#v1-0-0-components-transports">Transports Component</a></li>
    </ul>
  </li>
  <li>
    <strong>Core Concepts</strong>
    <ul>
      <li><a href="#v1-0-0-core-concepts-audit-logging">Audit Logging</a></li>
      <li><a href="#v1-0-0-core-concepts-dispatcher">Dispatcher Deep Dive</a></li>
      <li><a href="#v1-0-0-core-concepts-event-store-query">Event Store Query</a></li>
      <li><a href="#v1-0-0-core-concepts-fuzzy-matching">fuzzy matching</a></li>
      <li><a href="#v1-0-0-core-concepts-lenses">Lenses Guide</a></li>
      <li><a href="#v1-0-0-core-concepts-lifecycle-receptors">Lifecycle Receptors</a></li>
      <li><a href="#v1-0-0-core-concepts-lifecycle-stages">Lifecycle Stages</a></li>
      <li><a href="#v1-0-0-core-concepts-message-context">Message Context &amp; Tracing</a></li>
      <li><a href="#v1-0-0-core-concepts-message-security">message security</a></li>
      <li><a href="#v1-0-0-core-concepts-observability">Observability &amp; Message Hops</a></li>
      <li><a href="#v1-0-0-core-concepts-perspectives">Perspectives Guide</a></li>
      <li><a href="#v1-0-0-core-concepts-receptors">Receptors Guide</a></li>
      <li><a href="#v1-0-0-core-concepts-routing">routing</a></li>
      <li><a href="#v1-0-0-core-concepts-rpc-extraction">rpc extraction</a></li>
      <li><a href="#v1-0-0-core-concepts-scoping">scoping</a></li>
      <li><a href="#v1-0-0-core-concepts-security">security</a></li>
      <li><a href="#v1-0-0-core-concepts-system-events">system events</a></li>
      <li><a href="#v1-0-0-core-concepts-transport-consumer">transport consumer</a></li>
      <li><a href="#v1-0-0-core-concepts-type-formatting">type formatting</a></li>
      <li><a href="#v1-0-0-core-concepts-type-matching">type matching</a></li>
      <li><a href="#v1-0-0-core-concepts-type-qualification">type qualification</a></li>
      <li><a href="#v1-0-0-core-concepts-whizbang-ids">whizbang ids</a></li>
      <li>
        <strong>Perspectives</strong>
        <ul>
          <li><a href="#v1-0-0-core-concepts-perspectives-association-info">association info</a></li>
          <li><a href="#v1-0-0-core-concepts-perspectives-multi-stream">Multi-Stream Perspectives</a></li>
          <li><a href="#v1-0-0-core-concepts-perspectives-perspective-sync">Perspective Synchronization</a></li>
          <li><a href="#v1-0-0-core-concepts-perspectives-typed-associations">typed associations</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <strong>Customization Examples</strong>
    <ul>
      <li><a href="#v1-0-0-customization-examples-event-sourcing-cqrs">Event Sourcing &amp; CQRS</a></li>
      <li><a href="#v1-0-0-customization-examples-microservices-orchestration">Microservices Orchestration</a></li>
      <li><a href="#v1-0-0-customization-examples-multi-tenant-saas">Multi-Tenant SaaS</a></li>
      <li><a href="#v1-0-0-customization-examples-real-time-analytics">Real-Time Analytics</a></li>
    </ul>
  </li>
  <li>
    <strong>Data</strong>
    <ul>
      <li><a href="#v1-0-0-data-dapper-integration">Dapper Integration</a></li>
      <li><a href="#v1-0-0-data-efcore-integration">EF Core Integration</a></li>
      <li><a href="#v1-0-0-data-efcore-json-configuration">EF Core 10 JSON Configuration</a></li>
      <li><a href="#v1-0-0-data-event-store">Event Store</a></li>
      <li><a href="#v1-0-0-data-perspectives-storage">Perspectives Storage</a></li>
      <li><a href="#v1-0-0-data-schema-migration">schema migration</a></li>
      <li><a href="#v1-0-0-data-turnkey-initialization">turnkey initialization</a></li>
    </ul>
  </li>
  <li>
    <strong>Data Access</strong>
    <ul>
      <li><a href="#v1-0-0-data-access-schema-generation-pattern">Schema Generation Pattern</a></li>
    </ul>
  </li>
  <li>
    <strong>Diagnostics</strong>
    <ul>
      <li><a href="#v1-0-0-diagnostics-whiz030">WHIZ030: Perspective Event Missing StreamKey</a></li>
      <li><a href="#v1-0-0-diagnostics-whiz031">WHIZ031: Multiple StreamKey Attributes</a></li>
      <li><a href="#v1-0-0-diagnostics-whiz058">WHIZ058: GUID Call Intercepted</a></li>
      <li><a href="#v1-0-0-diagnostics-whiz059">WHIZ059: GUID Interception Suppressed</a></li>
      <li><a href="#v1-0-0-diagnostics-whiz070">WHIZ070: Missing Pgvector.EntityFrameworkCore Package</a></li>
      <li><a href="#v1-0-0-diagnostics-whiz071">WHIZ071: Missing Pgvector Package</a></li>
    </ul>
  </li>
  <li>
    <strong>Extensibility</strong>
    <ul>
      <li><a href="#v1-0-0-extensibility-custom-dispatchers">Custom Dispatchers</a></li>
      <li><a href="#v1-0-0-extensibility-custom-health-checks">Custom Health Checks</a></li>
      <li><a href="#v1-0-0-extensibility-custom-id-generators">Custom ID Generators</a></li>
      <li><a href="#v1-0-0-extensibility-custom-perspectives">Custom Perspectives</a></li>
      <li><a href="#v1-0-0-extensibility-custom-policies">Custom Policies</a></li>
      <li><a href="#v1-0-0-extensibility-custom-receptors">Custom Receptors</a></li>
      <li><a href="#v1-0-0-extensibility-custom-serializers">Custom Serializers</a></li>
      <li><a href="#v1-0-0-extensibility-custom-storage">Custom Storage</a></li>
      <li><a href="#v1-0-0-extensibility-custom-transports">Custom Transports</a></li>
      <li><a href="#v1-0-0-extensibility-custom-work-coordinators">Custom Work Coordinators</a></li>
      <li><a href="#v1-0-0-extensibility-database-schema-framework">Database Schema Framework</a></li>
      <li><a href="#v1-0-0-extensibility-hooks-and-middleware">Hooks and Middleware</a></li>
      <li><a href="#v1-0-0-extensibility-plugin-architecture">Plugin Architecture</a></li>
    </ul>
  </li>
  <li>
    <strong>Getting Started</strong>
    <ul>
      <li><a href="#v1-0-0-getting-started-installation">Installation Guide</a></li>
      <li><a href="#v1-0-0-getting-started-introduction">Introduction to Whizbang</a></li>
      <li><a href="#v1-0-0-getting-started-project-structure">Project Structure Guide</a></li>
      <li><a href="#v1-0-0-getting-started-quick-start">Quick Start Tutorial</a></li>
    </ul>
  </li>
  <li>
    <strong>Graphql</strong>
    <ul>
      <li><a href="#v1-0-0-graphql-filtering">filtering</a></li>
      <li><a href="#v1-0-0-graphql-index">index</a></li>
      <li><a href="#v1-0-0-graphql-lens-integration">lens integration</a></li>
      <li><a href="#v1-0-0-graphql-scoping">scoping</a></li>
      <li><a href="#v1-0-0-graphql-setup">setup</a></li>
      <li><a href="#v1-0-0-graphql-sorting">sorting</a></li>
    </ul>
  </li>
  <li>
    <strong>Guides</strong>
    <ul>
      <li><a href="#v1-0-0-guides-implementing-multi-tenancy">implementing multi tenancy</a></li>
    </ul>
  </li>
  <li>
    <strong>Infrastructure</strong>
    <ul>
      <li><a href="#v1-0-0-infrastructure-aspire-integration">.NET Aspire Integration</a></li>
      <li><a href="#v1-0-0-infrastructure-health-checks">Health Checks</a></li>
      <li><a href="#v1-0-0-infrastructure-policies">Policy-Based Routing</a></li>
      <li><a href="#v1-0-0-infrastructure-pooling">Object Pooling</a></li>
    </ul>
  </li>
  <li>
    <strong>Lenses</strong>
    <ul>
      <li><a href="#v1-0-0-lenses-raw-sql">raw sql</a></li>
      <li><a href="#v1-0-0-lenses-vector-search">vector search</a></li>
    </ul>
  </li>
  <li>
    <strong>Messaging</strong>
    <ul>
      <li><a href="#v1-0-0-messaging-commands-events">commands events</a></li>
      <li><a href="#v1-0-0-messaging-failure-handling">failure handling</a></li>
      <li><a href="#v1-0-0-messaging-idempotency-patterns">idempotency patterns</a></li>
      <li><a href="#v1-0-0-messaging-inbox-pattern">Inbox Pattern</a></li>
      <li><a href="#v1-0-0-messaging-message-envelopes">Message Envelopes Deep Dive</a></li>
      <li><a href="#v1-0-0-messaging-multi-instance-coordination">multi instance coordination</a></li>
      <li><a href="#v1-0-0-messaging-outbox-pattern">Outbox Pattern</a></li>
      <li><a href="#v1-0-0-messaging-topic-filters">topic filters</a></li>
      <li><a href="#v1-0-0-messaging-work-coordination">work coordination</a></li>
      <li><a href="#v1-0-0-messaging-work-coordinator">Work Coordinator</a></li>
    </ul>
  </li>
  <li>
    <strong>Migration Guide</strong>
    <ul>
      <li><a href="#v1-0-0-migration-guide-01-concept-mapping">Concept Mapping</a></li>
      <li><a href="#v1-0-0-migration-guide-02-project-setup">Project Setup</a></li>
      <li><a href="#v1-0-0-migration-guide-03-handler-migration">Handler Migration</a></li>
      <li><a href="#v1-0-0-migration-guide-04-projection-migration">Projection Migration</a></li>
      <li><a href="#v1-0-0-migration-guide-05-event-store-migration">Event Store Migration</a></li>
      <li><a href="#v1-0-0-migration-guide-06-transport-configuration">Transport Configuration</a></li>
      <li><a href="#v1-0-0-migration-guide-07-outbox-migration">Outbox Migration</a></li>
      <li><a href="#v1-0-0-migration-guide-08-testing-migration">Testing Migration</a></li>
      <li><a href="#v1-0-0-migration-guide-readme">Migration Guide Overview</a></li>
      <li><a href="#v1-0-0-migration-guide-appendix-checklist">Migration Checklist</a></li>
    </ul>
  </li>
  <li>
    <strong>Perspectives</strong>
    <ul>
      <li><a href="#v1-0-0-perspectives-registry">registry</a></li>
      <li><a href="#v1-0-0-perspectives-table-naming">table naming</a></li>
      <li><a href="#v1-0-0-perspectives-temporal">temporal</a></li>
    </ul>
  </li>
  <li>
    <strong>Source Generators</strong>
    <ul>
      <li><a href="#v1-0-0-source-generators-aggregate-ids">Aggregate IDs</a></li>
      <li><a href="#v1-0-0-source-generators-json-contexts">JSON Contexts</a></li>
      <li><a href="#v1-0-0-source-generators-message-registry">Message Registry</a></li>
      <li><a href="#v1-0-0-source-generators-perspective-discovery">Perspective Discovery</a></li>
      <li><a href="#v1-0-0-source-generators-receptor-discovery">Receptor Discovery</a></li>
      <li><a href="#v1-0-0-source-generators-topic-filter-discovery">Topic Filter Discovery</a></li>
    </ul>
  </li>
  <li>
    <strong>Testing</strong>
    <ul>
      <li><a href="#v1-0-0-testing-lifecycle-synchronization">Lifecycle Synchronization</a></li>
    </ul>
  </li>
  <li>
    <strong>Transports</strong>
    <ul>
      <li><a href="#v1-0-0-transports-azure-service-bus">Azure Service Bus Transport</a></li>
      <li><a href="#v1-0-0-transports-in-memory">In-Memory Transport</a></li>
      <li><a href="#v1-0-0-transports-rabbitmq">RabbitMQ Transport</a></li>
    </ul>
  </li>
  <li>
    <strong>Tutorial</strong>
    <ul>
      <li><a href="#v1-0-0-tutorial-analytics-service">Analytics Service</a></li>
      <li><a href="#v1-0-0-tutorial-customer-service">Customer Service (BFF)</a></li>
      <li><a href="#v1-0-0-tutorial-deployment">Deployment</a></li>
      <li><a href="#v1-0-0-tutorial-inventory-service">Inventory Service</a></li>
      <li><a href="#v1-0-0-tutorial-notification-service">Notification Service</a></li>
      <li><a href="#v1-0-0-tutorial-order-management">Order Management Service</a></li>
      <li><a href="#v1-0-0-tutorial-payment-processing">Payment Processing Service</a></li>
      <li><a href="#v1-0-0-tutorial-shipping-service">Shipping Service</a></li>
      <li><a href="#v1-0-0-tutorial-testing-strategy">Testing Strategy</a></li>
      <li><a href="#v1-0-0-tutorial-tutorial-overview">ECommerce Tutorial Overview</a></li>
    </ul>
  </li>
  <li>
    <strong>Workers</strong>
    <ul>
      <li><a href="#v1-0-0-workers-database-readiness">Database Readiness</a></li>
      <li><a href="#v1-0-0-workers-execution-lifecycle">Execution Lifecycle</a></li>
      <li><a href="#v1-0-0-workers-perspective-worker">Perspective Worker</a></li>
    </ul>
  </li>
</ul>
<h3>Guides</h3>
<h4>Migrate From Marten Wolverine</h4>
<ul>
  <li><a href="#migrate-from-marten-wolverine-01-concept-mapping">01 concept mapping</a></li>
  <li><a href="#migrate-from-marten-wolverine-02-project-setup">02 project setup</a></li>
  <li><a href="#migrate-from-marten-wolverine-03-handler-migration">03 handler migration</a></li>
  <li><a href="#migrate-from-marten-wolverine-04-projection-migration">04 projection migration</a></li>
  <li><a href="#migrate-from-marten-wolverine-05-event-store-migration">05 event store migration</a></li>
  <li><a href="#migrate-from-marten-wolverine-06-transport-configuration">06 transport configuration</a></li>
  <li><a href="#migrate-from-marten-wolverine-07-outbox-migration">07 outbox migration</a></li>
  <li><a href="#migrate-from-marten-wolverine-08-testing-migration">08 testing migration</a></li>
  <li><a href="#migrate-from-marten-wolverine-09-cli-wizard">CLI Migration Wizard</a></li>
  <li><a href="#migrate-from-marten-wolverine-readme">README</a></li>
  <li><a href="#migrate-from-marten-wolverine-appendix-checklist">appendix checklist</a></li>
</ul>
<h4>Roadmap</h4>
<ul>
  <li><a href="#roadmap-feature-evolution">Feature Evolution Matrix</a></li>
  <li><a href="#roadmap-readme">Whizbang Implementation Roadmap</a></li>
  <li><a href="#roadmap-session-context">Session Context for Claude</a></li>
  <li><a href="#roadmap-architecture">Architecture Overview</a></li>
  <li><a href="#roadmap-philosophy">Implementation Philosophy</a></li>
  <li><a href="#roadmap-success-metrics">Success Metrics</a></li>
</ul>
<h3>Development</h3>
<h4>Drafts</h4>
<ul>
  <li><a href="#drafts-test-error-display">Test Error Display</a></li>
  <li>
    <strong>Attributes</strong>
    <ul>
      <li><a href="#drafts-attributes-must-exist">MustExist Attribute</a></li>
    </ul>
  </li>
  <li>
    <strong>Core Concepts</strong>
    <ul>
      <li><a href="#drafts-core-concepts-model-action">Model Actions - Perspective Deletion Support</a></li>
    </ul>
  </li>
</ul>
<h4>Proposals</h4>
<ul>
  <li><a href="#proposals-advanced-features">Advanced Features</a></li>
  <li><a href="#proposals-concurrency-control">Concurrency Control</a></li>
  <li><a href="#proposals-deployment-operations">Deployment &amp; Operations</a></li>
  <li><a href="#proposals-domain-ownership">Domain Ownership</a></li>
  <li><a href="#proposals-event-store-projections">Event Store &amp; Projection Architecture</a></li>
  <li><a href="#proposals-flags-tags-system">Flags &amp; Tags System</a></li>
  <li><a href="#proposals-multi-tenancy">Multi-Tenancy</a></li>
  <li><a href="#proposals-observability-metrics">Observability &amp; Metrics</a></li>
  <li><a href="#proposals-open-questions">Open Design Questions - RESOLVED</a></li>
  <li><a href="#proposals-policy-engine">Policy Engine</a></li>
  <li><a href="#proposals-projection-management">Projection Management</a></li>
  <li><a href="#proposals-schema-evolution">Schema Evolution &amp; Event Versioning</a></li>
  <li><a href="#proposals-source-generation-ide">Source Generation &amp; IDE Integration</a></li>
  <li><a href="#proposals-testing-development-tools">Testing &amp; Development Tools</a></li>
</ul>
<h4>Backlog</h4>

  </nav>

  <main>
<section id="versions"><h2>Released Versions</h2>
<section id="v1-0-0"><h3>v1.0.0</h3>
<article id="v1-0-0-readme" class="doc-section">
  <h2>Version 0.1.0 - Foundation Release</h2>
  <p class="doc-path"><code>v1.0.0/README</code></p>
  <p class="doc-description"><em>The foundation release of Whizbang establishing all core components with comprehensive testing and IDE support</em></p>
  <div class="doc-content">

<h1>Version 1.0.0 - Foundation Release</h1>

<h2>Overview</h2>

<p>Version 1.0.0 is the foundation release of Whizbang, establishing a <strong>complete skeleton</strong> of all major components with in-memory implementations. This version prioritizes breadth over depth, ensuring every component exists and works together from day one.</p>

<h2>Release Goals</h2>

<h3>Primary Goals</h3>
<ul><li><strong>Complete Component Set</strong>: All 8 core components implemented and working</li>
<li><strong>Zero Reflection</strong>: Everything wired via source generators</li>
<li><strong>IDE Integration</strong>: Full developer experience from day one</li>
<li><strong>Testing Foundation</strong>: Comprehensive testing with TUnit and Bogus</li>
<li><strong>In-Memory Everything</strong>: Fast development and testing cycle</li>
</ul>
<h3>Success Criteria</h3>
<ul><li>✅ All components have basic working implementations</li>
<li>✅ Source generators discover and wire all handlers</li>
<li>✅ IDE tools provide navigation and traceability</li>
<li>✅ Testing framework with scenario generation</li>
<li>✅ 100% test coverage of public APIs</li>
<li>✅ < 1ms in-memory operation performance</li>
</ul>
<h2>What's Included</h2>

<h3>Core Components</h3>
<ul><li><strong><a href="components/dispatcher.md">Dispatcher</a></strong> - Message routing and coordination</li>
<li><strong><a href="components/receptors.md">Receptors</a></strong> - Command receivers (stateless)</li>
<li><strong><a href="components/perspectives.md">Perspectives</a></strong> - Event handlers</li>
<li><strong><a href="components/lenses.md">Lenses</a></strong> - Query interfaces</li>
<li><strong><a href="components/policy-engine.md">Policy Engine</a></strong> - Cross-cutting concerns</li>
<li><strong><a href="components/ledger.md">Ledger</a></strong> - Event store interface</li>
<li><strong><a href="components/drivers.md">Drivers</a></strong> - Storage abstraction</li>
<li><strong><a href="components/transports.md">Transports</a></strong> - Message broker abstraction</li>
</ul>
<h3>Developer Experience</h3>
<ul><li><strong><a href="developer-experience/source-generators.md">Source Generators</a></strong> - Zero-reflection handler discovery</li>
<li><strong><a href="developer-experience/analyzers.md">Analyzers</a></strong> - Compile-time validation</li>
<li><strong><a href="developer-experience/ide-tools.md">IDE Tools</a></strong> - CodeLens-style references</li>
<li><strong><a href="developer-experience/traceability.md">Traceability</a></strong> - Message flow visualization</li>
<li><strong><a href="developer-experience/codelens.md">Debugging</a></strong> - Time-travel debugging foundation</li>
</ul>
<h3>Testing Foundation</h3>
<ul><li><strong><a href="testing/foundation.md">Testing Strategy</a></strong> - Overall testing approach</li>
<li><strong><a href="testing/tunit.md">TUnit Integration</a></strong> - Modern test framework</li>
<li><strong><a href="testing/bogus.md">Bogus Scenarios</a></strong> - Realistic data generation</li>
<li><strong><a href="testing/behavior-specs.md">Behavior Specs</a></strong> - BDD-style testing</li>
<li><strong><a href="testing/test-doubles.md">Test Doubles</a></strong> - In-memory mocking</li>
</ul>
<h2>Quick Start</h2>

<h3>Installation</h3>

<pre><code class="language-bash">dotnet add package Whizbang.Core --version 1.0.0
<p></code></pre></p>

<h3>Basic Usage</h3>

<pre><code class="language-csharp">using Whizbang;

<p>// 1. Define a command</p>
<p>public record CreateOrder(Guid CustomerId, List<OrderItem> Items);</p>

<p>// 2. Define a receptor</p>
<p>[WhizbangHandler]</p>
<p>public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    public async Task<OrderCreated> Receive(CreateOrder cmd) {</p>
<p>        // Validation and business logic</p>
<p>        if (cmd.Items.Count == 0) {</p>
<p>            throw new InvalidOperationException("Order must have items");</p>
<p>        }</p>
<p>        </p>
<p>        // Emit event</p>
<p>        return new OrderCreated(Guid.NewGuid(), cmd.CustomerId, cmd.Items);</p>
<p>    }</p>
<p>}</p>

<p>// 3. Define perspectives</p>
<p>[WhizbangHandler]</p>
<p>public class OrderPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>    private readonly Dictionary<Guid, Order> _orders = new();</p>
<p>    </p>
<p>    public Task Update(OrderCreated e) {</p>
<p>        _orders[e.OrderId] = new Order {</p>
<p>            Id = e.OrderId,</p>
<p>            CustomerId = e.CustomerId,</p>
<p>            Items = e.Items</p>
<p>        };</p>
<p>        return Task.CompletedTask;</p>
<p>    }</p>
<p>}</p>

<p>// 4. Define a lens</p>
<p>public interface IOrderLens : ILens {</p>
<p>    Order Focus(Guid orderId);</p>
<p>    IEnumerable<Order> ViewByCustomer(Guid customerId);</p>
<p>}</p>

<p>[WhizbangLens]</p>
<p>public class OrderLens : IOrderLens {</p>
<p>    private readonly Dictionary<Guid, Order> _orders;</p>
<p>    </p>
<p>    public Order Focus(Guid orderId) => _orders[orderId];</p>
<p>    </p>
<p>    public IEnumerable<Order> ViewByCustomer(Guid customerId) =></p>
<p>        _orders.Values.Where(o => o.CustomerId == customerId);</p>
<p>}</p>

<p>// 5. Configure and use</p>
<p>var builder = WebApplication.CreateBuilder(args);</p>

<p>builder.Services.AddWhizbang(options => {</p>
<p>    options.RegisterGeneratedHandlers();  // Source-generated registration</p>
<p>    options.UseInMemory();                // In-memory implementations</p>
<p>    options.EnableTraceability();         // IDE tools and debugging</p>
<p>});</p>

<p>var app = builder.Build();</p>

<p>// 6. Use via dispatcher</p>
<p>app.MapPost("/orders", async (CreateOrder cmd, IDispatcher dispatcher) => {</p>
<p>    var result = await dispatcher.Send(cmd);</p>
<p>    return Results.Ok(result);</p>
<p>});</p>

<p>app.MapGet("/orders/{id}", (Guid id, IDispatcher dispatcher) => {</p>
<p>    var lens = dispatcher.GetLens<IOrderLens>();</p>
<p>    var order = lens.Focus(id);</p>
<p>    return Results.Ok(order);</p>
<p>});</p>
<p></code></pre></p>

<h2>IDE Features</h2>

<h3>CodeLens References</h3>
<pre><code class="language-csharp">// IDE shows: "2 handlers | 1 perspective | Last: 50ms ago"
<p>public record OrderCreated(Guid OrderId, Guid CustomerId);  </p>

<p>// IDE shows: "Handles: CreateOrder | Publishes: OrderCreated"</p>
<p>public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> { }</p>
<p></code></pre></p>

<h3>Traceability Overlay</h3>
<ul><li>See message flow inline in the editor</li>
<li>Visualize command → receptor → event → perspective chains</li>
<li>Click to navigate between components</li>
<li>View execution timings and counts</li>
</ul>
<h3>Analyzer Warnings</h3>
<pre><code class="language-csharp">// Warning WB0001: Command 'CancelOrder' has no handler
<p>public record CancelOrder(Guid OrderId);  // Squiggly line here</p>

<p>// Quick Fix: Generate handler for CancelOrder (Ctrl+.)</p>
<p></code></pre></p>

<h2>Testing Example</h2>

<pre><code class="language-csharp">[TestClass]
<p>public class OrderTests : WhizbangTestBase {</p>
<p>    [Test]</p>
<p>    [MethodDataSource(nameof(OrderScenarios))]</p>
<p>    public async Task CreateOrder_ShouldEmitOrderCreated(OrderScenario scenario) {</p>
<p>        // Arrange</p>
<p>        var dispatcher = CreateDispatcher();</p>
<p>        </p>
<p>        // Act</p>
<p>        var result = await dispatcher.Send(scenario.Command);</p>
<p>        </p>
<p>        // Assert</p>
<p>        await Verify.Event<OrderCreated>()</p>
<p>            .WithCustomerId(scenario.CustomerId)</p>
<p>            .WasPublished();</p>
<p>    }</p>
<p>    </p>
<p>    public static IEnumerable<OrderScenario> OrderScenarios() {</p>
<p>        var faker = new OrderScenarioFaker();</p>
<p>        yield return faker.Generate();  // Happy path</p>
<p>        yield return faker.WithNoItems().Generate();  // Error case</p>
<p>        yield return faker.WithManyItems(100).Generate();  // Stress case</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Performance Characteristics</h2>

<h3>In-Memory Performance</h3>
<p>| Operation | Target | Actual |</p>
<p>|-----------|--------|--------|</p>
<p>| Message Dispatch | < 1μs | TBD |</p>
<p>| Handler Invocation | < 100ns | TBD |</p>
<p>| Event Publishing | < 1μs | TBD |</p>
<p>| Lens Query | < 1ms | TBD |</p>
<p>| Policy Application | < 10μs | TBD |</p>

<h3>Memory Allocation</h3>
<ul><li>Zero allocations in dispatch hot path</li>
<li>Pooled objects for messages</li>
<li>Minimal GC pressure</li>
</ul>
<h2>Migration Path</h2>

<h3>To v0.2.0</h3>
<p>Version 0.2.0 enhances existing components without breaking changes:</p>
<ul><li>Receptors gain validation attributes</li>
<li>Perspectives support batch updates</li>
<li>Lenses add pagination</li>
<li>Policies become composable</li>
</ul>
<p>See <a href="../v0.2.0/migration-guide.md">v0.2.0 Migration Guide</a></p>

<h2>Known Limitations</h2>

<p>As a foundation release, v1.0.0 has intentional limitations:</p>
<ul><li><strong>In-Memory Only</strong>: No persistent storage yet</li>
<li><strong>Stateless Receptors</strong>: No event sourcing support</li>
<li><strong>Basic Policies</strong>: Limited to Retry, Timeout, Cache, CircuitBreaker</li>
<li><strong>Single Node</strong>: No distributed messaging</li>
<li><strong>No Sagas</strong>: Long-running processes not supported</li>
</ul>
<p>These limitations are addressed in subsequent versions while maintaining backward compatibility.</p>

<h2>Examples</h2>

<h3>Complete Examples</h3>
<ul><li><strong><a href="examples/basic-receptor.md">Basic Receptor</a></strong> - Simple command handling</li>
<li><strong><a href="examples/policy-usage.md">Policy Usage</a></strong> - Applying policies to handlers</li>
<li><strong><a href="examples/test-scenario.md">Test Scenario</a></strong> - Testing with Bogus</li>
</ul>
<h2>Component Documentation</h2>

<h3>Core Components</h3>
<ul><li><a href="components/dispatcher.md">Dispatcher</a></li>
<li><a href="components/receptors.md">Receptors</a></li>
<li><a href="components/perspectives.md">Perspectives</a></li>
<li><a href="components/lenses.md">Lenses</a></li>
<li><a href="components/policy-engine.md">Policy Engine</a></li>
<li><a href="components/ledger.md">Ledger</a></li>
<li><a href="components/drivers.md">Drivers</a></li>
<li><a href="components/transports.md">Transports</a></li>
</ul>
<h3>Developer Experience</h3>
<ul><li><a href="developer-experience/source-generators.md">Source Generators</a></li>
<li><a href="developer-experience/analyzers.md">Analyzers</a></li>
<li><a href="developer-experience/ide-tools.md">IDE Tools</a></li>
<li><a href="developer-experience/traceability.md">Traceability</a></li>
</ul>
<h3>Testing</h3>
<ul><li><a href="testing/foundation.md">Testing Foundation</a></li>
<li><a href="testing/tunit.md">TUnit Integration</a></li>
<li><a href="testing/bogus.md">Bogus Scenarios</a></li>
<li><a href="testing/behavior-specs.md">Behavior Specs</a></li>
</ul>
<h2>Feedback</h2>

<p>This is the foundation release - your feedback shapes the future:</p>
<ul><li>Report issues: https://github.com/whizbang-lib/whizbang/issues</li>
<li>Join discussions: https://github.com/whizbang-lib/whizbang/discussions</li>
<li>Contribute: See <a href="../contributing.md">Contributing Guide</a></li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<section class="doc-category">
  <h2 class="category-header">Advanced Topics</h2>
<article id="v1-0-0-advanced-topics-deployment-strategies" class="doc-section">
  <h3>Deployment Strategies</h3>
  <p class="doc-path"><code>v1.0.0/advanced-topics/deployment-strategies</code></p>
  <p class="doc-description"><em>Deployment patterns - blue-green, canary, rolling updates, feature flags, and rollback strategies</em></p>
  <div class="doc-content">

<h1>Deployment Strategies</h1>

<p>Comprehensive guide to <strong>deployment strategies</strong> for Whizbang applications - blue-green deployments, canary releases, rolling updates, feature flags, and safe rollback patterns.</p>

<hr>

<h2>Deployment Strategy Comparison</h2>

<p>| Strategy | Downtime | Risk | Rollback Speed | Cost |</p>
<p>|----------|----------|------|----------------|------|</p>
<p>| <strong>Recreate</strong> | ❌ Yes | ⚠️ High | Slow | Low |</p>
<p>| <strong>Rolling Update</strong> | ✅ No | ⚠️ Medium | Medium | Low |</p>
<p>| <strong>Blue-Green</strong> | ✅ No | ✅ Low | Fast | High |</p>
<p>| <strong>Canary</strong> | ✅ No | ✅ Very Low | Fast | Medium |</p>

<hr>

<h2>Strategy 1: Blue-Green Deployment</h2>

<strong>Zero downtime</strong> - Run two identical environments (blue = production, green = staging), then swap.

<h3>Architecture</h3>

<pre><code class="language-">┌────────────────────────────────────────────────────┐
<p>│  Blue-Green Deployment                             │</p>
<p>│                                                     │</p>
<p>│  ┌──────────────┐                                  │</p>
<p>│  │ Load Balancer│                                  │</p>
<p>│  └──────┬───────┘                                  │</p>
<p>│         │                                           │</p>
<p>│         │ Traffic (100%)                            │</p>
<p>│         ▼                                           │</p>
<p>│  ┌──────────────┐          ┌──────────────┐        │</p>
<p>│  │  Blue (v1.0) │          │ Green (v1.1) │        │</p>
<p>│  │  - Live      │          │ - Staging    │        │</p>
<p>│  │  - 3 pods    │          │ - 3 pods     │        │</p>
<p>│  └──────────────┘          └──────────────┘        │</p>
<p>│                                                     │</p>
<p>│  After validation:                                 │</p>
<p>│  ┌──────────────┐                                  │</p>
<p>│  │ Load Balancer│                                  │</p>
<p>│  └──────┬───────┘                                  │</p>
<p>│         │                                           │</p>
<p>│         │ Traffic (100%)                            │</p>
<p>│         ▼                                           │</p>
<p>│  ┌──────────────┐          ┌──────────────┐        │</p>
<p>│  │  Blue (v1.0) │          │ Green (v1.1) │        │</p>
<p>│  │  - Idle      │          │ - Live       │        │</p>
<p>│  │  - 3 pods    │          │ - 3 pods     │        │</p>
<p>│  └──────────────┘          └──────────────┘        │</p>
<p>└────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<h3>Kubernetes Manifests</h3>

<strong>blue-deployment.yaml</strong>:

<pre><code class="language-yaml">apiVersion: apps/v1
<p>kind: Deployment</p>
<p>metadata:</p>
<p>  name: order-service-blue</p>
<p>  labels:</p>
<p>    app: order-service</p>
<p>    version: blue</p>
<p>spec:</p>
<p>  replicas: 3</p>
<p>  selector:</p>
<p>    matchLabels:</p>
<p>      app: order-service</p>
<p>      version: blue</p>
<p>  template:</p>
<p>    metadata:</p>
<p>      labels:</p>
<p>        app: order-service</p>
<p>        version: blue</p>
<p>    spec:</p>
<p>      containers:</p>
<p>      - name: order-service</p>
<p>        image: myregistry.azurecr.io/order-service:1.0.0</p>
<p>        ports:</p>
<p>        - containerPort: 8080</p>
<p>        env:</p>
<p>        - name: ASPNETCORE_ENVIRONMENT</p>
<p>          value: Production</p>
<p></code></pre></p>

<strong>green-deployment.yaml</strong>:

<pre><code class="language-yaml">apiVersion: apps/v1
<p>kind: Deployment</p>
<p>metadata:</p>
<p>  name: order-service-green</p>
<p>  labels:</p>
<p>    app: order-service</p>
<p>    version: green</p>
<p>spec:</p>
<p>  replicas: 3</p>
<p>  selector:</p>
<p>    matchLabels:</p>
<p>      app: order-service</p>
<p>      version: green</p>
<p>  template:</p>
<p>    metadata:</p>
<p>      labels:</p>
<p>        app: order-service</p>
<p>        version: green</p>
<p>    spec:</p>
<p>      containers:</p>
<p>      - name: order-service</p>
<p>        image: myregistry.azurecr.io/order-service:1.1.0  # New version</p>
<p>        ports:</p>
<p>        - containerPort: 8080</p>
<p>        env:</p>
<p>        - name: ASPNETCORE_ENVIRONMENT</p>
<p>          value: Production</p>
<p></code></pre></p>

<strong>service.yaml</strong> (switch between blue/green):

<pre><code class="language-yaml">apiVersion: v1
<p>kind: Service</p>
<p>metadata:</p>
<p>  name: order-service</p>
<p>spec:</p>
<p>  selector:</p>
<p>    app: order-service</p>
<p>    version: blue  # Switch to "green" after validation</p>
<p>  ports:</p>
<p>  - protocol: TCP</p>
<p>    port: 80</p>
<p>    targetPort: 8080</p>
<p>  type: LoadBalancer</p>
<p></code></pre></p>

<h3>GitHub Actions Workflow</h3>

<strong>.github/workflows/blue-green-deploy.yml</strong>:

<pre><code class="language-yaml">name: Blue-Green Deployment

<p>on:</p>
<p>  push:</p>
<p>    branches: [main]</p>

<p>jobs:</p>
<p>  deploy:</p>
<p>    runs-on: ubuntu-latest</p>
<p>    steps:</p>
<p>      - uses: actions/checkout@v4</p>

<p>      - name: Build and push Docker image</p>
<p>        run: |</p>
<p>          docker build -t myregistry.azurecr.io/order-service:${{ github.sha }} .</p>
<p>          docker push myregistry.azurecr.io/order-service:${{ github.sha }}</p>

<p>      - name: Deploy to Green environment</p>
<p>        run: |</p>
<p>          kubectl set image deployment/order-service-green \</p>
<p>            order-service=myregistry.azurecr.io/order-service:${{ github.sha }}</p>
<p>          kubectl rollout status deployment/order-service-green</p>

<p>      - name: Run smoke tests on Green</p>
<p>        run: |</p>
<p>          GREEN_URL=$(kubectl get svc order-service-green -o jsonpath='{.status.loadBalancer.ingress[0].ip}')</p>
<p>          curl -f http://$GREEN_URL/health || exit 1</p>

<p>      - name: Switch traffic to Green</p>
<p>        run: |</p>
<p>          kubectl patch svc order-service -p '{"spec":{"selector":{"version":"green"}}}'</p>

<p>      - name: Wait for traffic switch</p>
<p>        run: sleep 30</p>

<p>      - name: Verify production traffic</p>
<p>        run: |</p>
<p>          curl -f http://order-service.myapp.com/health || exit 1</p>

<p>      - name: Scale down Blue (keep for rollback)</p>
<p>        run: |</p>
<p>          kubectl scale deployment/order-service-blue --replicas=1</p>
<p></code></pre></p>

<h3>Rollback</h3>

<pre><code class="language-bash"># Instant rollback: Switch service back to blue
<p>kubectl patch svc order-service -p '{"spec":{"selector":{"version":"blue"}}}'</p>

<h1>Scale blue back up</h1>
<p>kubectl scale deployment/order-service-blue --replicas=3</p>
<p></code></pre></p>

<hr>

<h2>Strategy 2: Canary Deployment</h2>

<strong>Gradual rollout</strong> - Deploy new version to small percentage of users, then gradually increase.

<h3>Architecture</h3>

<pre><code class="language-">┌────────────────────────────────────────────────────┐
<p>│  Canary Deployment                                 │</p>
<p>│                                                     │</p>
<p>│  ┌──────────────┐                                  │</p>
<p>│  │ Load Balancer│                                  │</p>
<p>│  └──────┬───────┘                                  │</p>
<p>│         │                                           │</p>
<p>│    ┌────┴────┐                                     │</p>
<p>│    │         │                                      │</p>
<p>│    ▼ 90%     ▼ 10% (canary)                        │</p>
<p>│  ┌─────┐  ┌─────┐                                  │</p>
<p>│  │ v1.0│  │v1.1 │                                  │</p>
<p>│  │ 9pods│  │1pod │                                  │</p>
<p>│  └─────┘  └─────┘                                  │</p>
<p>│                                                     │</p>
<p>│  After validation: 50/50                           │</p>
<p>│    ┌────┴────┐                                     │</p>
<p>│    │         │                                      │</p>
<p>│    ▼ 50%     ▼ 50%                                 │</p>
<p>│  ┌─────┐  ┌─────┐                                  │</p>
<p>│  │ v1.0│  │v1.1 │                                  │</p>
<p>│  │ 5pods│  │5pods│                                  │</p>
<p>│  └─────┘  └─────┘                                  │</p>
<p>└────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<h3>Kubernetes with Istio</h3>

<strong>virtualservice.yaml</strong>:

<pre><code class="language-yaml">apiVersion: networking.istio.io/v1beta1
<p>kind: VirtualService</p>
<p>metadata:</p>
<p>  name: order-service</p>
<p>spec:</p>
<p>  hosts:</p>
<p>  - order-service.myapp.com</p>
<p>  http:</p>
<p>  - match:</p>
<p>    - headers:</p>
<p>        canary:</p>
<p>          exact: "true"  # Users with canary header get v1.1</p>
<p>    route:</p>
<p>    - destination:</p>
<p>        host: order-service</p>
<p>        subset: v1-1</p>
<p>      weight: 100</p>
<p>  - route:</p>
<p>    - destination:</p>
<p>        host: order-service</p>
<p>        subset: v1-0</p>
<p>      weight: 90  # 90% of traffic to v1.0</p>
<p>    - destination:</p>
<p>        host: order-service</p>
<p>        subset: v1-1</p>
<p>      weight: 10  # 10% of traffic to v1.1 (canary)</p>
<p></code></pre></p>

<strong>destinationrule.yaml</strong>:

<pre><code class="language-yaml">apiVersion: networking.istio.io/v1beta1
<p>kind: DestinationRule</p>
<p>metadata:</p>
<p>  name: order-service</p>
<p>spec:</p>
<p>  host: order-service</p>
<p>  subsets:</p>
<p>  - name: v1-0</p>
<p>    labels:</p>
<p>      version: "1.0.0"</p>
<p>  - name: v1-1</p>
<p>    labels:</p>
<p>      version: "1.1.0"</p>
<p></code></pre></p>

<h3>Gradual Rollout Script</h3>

<strong>canary-rollout.sh</strong>:

<pre><code class="language-bash">#!/bin/bash

<p>WEIGHTS=(</p>
<p>  "90:10"   # Stage 1: 10% canary</p>
<p>  "75:25"   # Stage 2: 25% canary</p>
<p>  "50:50"   # Stage 3: 50% canary</p>
<p>  "25:75"   # Stage 4: 75% canary</p>
<p>  "0:100"   # Stage 5: 100% canary (full rollout)</p>
<p>)</p>

<p>for WEIGHT in "${WEIGHTS[@]}"; do</p>
<p>  IFS=':' read -r OLD_WEIGHT NEW_WEIGHT <<< "$WEIGHT"</p>

<p>  echo "Shifting traffic: $OLD_WEIGHT% v1.0, $NEW_WEIGHT% v1.1"</p>

<p>  kubectl apply -f - <<EOF</p>
<p>apiVersion: networking.istio.io/v1beta1</p>
<p>kind: VirtualService</p>
<p>metadata:</p>
<p>  name: order-service</p>
<p>spec:</p>
<p>  hosts:</p>
<p>  - order-service.myapp.com</p>
<p>  http:</p>
<p>  - route:</p>
<p>    - destination:</p>
<p>        host: order-service</p>
<p>        subset: v1-0</p>
<p>      weight: $OLD_WEIGHT</p>
<p>    - destination:</p>
<p>        host: order-service</p>
<p>        subset: v1-1</p>
<p>      weight: $NEW_WEIGHT</p>
<p>EOF</p>

<p>  echo "Waiting 5 minutes for metrics..."</p>
<p>  sleep 300</p>

<p>  # Check error rate</p>
<p>  ERROR_RATE=$(curl -s "http://prometheus:9090/api/v1/query?query=error_rate" | jq '.data.result[0].value[1]')</p>

<p>  if (( $(echo "$ERROR_RATE > 5" | bc -l) )); then</p>
<p>    echo "ERROR: Error rate exceeded 5% ($ERROR_RATE%). Rolling back."</p>
<p>    kubectl apply -f virtualservice-v1.0.yaml  # Rollback to 100% v1.0</p>
<p>    exit 1</p>
<p>  fi</p>

<p>  echo "Metrics look good. Proceeding to next stage."</p>
<p>done</p>

<p>echo "Canary deployment complete!"</p>
<p></code></pre></p>

<hr>

<h2>Strategy 3: Rolling Update</h2>

<strong>Default Kubernetes strategy</strong> - Replace pods one-by-one.

<h3>Deployment Manifest</h3>

<strong>deployment.yaml</strong>:

<pre><code class="language-yaml">apiVersion: apps/v1
<p>kind: Deployment</p>
<p>metadata:</p>
<p>  name: order-service</p>
<p>spec:</p>
<p>  replicas: 10</p>
<p>  strategy:</p>
<p>    type: RollingUpdate</p>
<p>    rollingUpdate:</p>
<p>      maxUnavailable: 1  # Max 1 pod unavailable during update</p>
<p>      maxSurge: 2        # Max 2 extra pods during update</p>
<p>  selector:</p>
<p>    matchLabels:</p>
<p>      app: order-service</p>
<p>  template:</p>
<p>    metadata:</p>
<p>      labels:</p>
<p>        app: order-service</p>
<p>    spec:</p>
<p>      containers:</p>
<p>      - name: order-service</p>
<p>        image: myregistry.azurecr.io/order-service:1.1.0</p>
<p>        ports:</p>
<p>        - containerPort: 8080</p>
<p>        readinessProbe:</p>
<p>          httpGet:</p>
<p>            path: /health/ready</p>
<p>            port: 8080</p>
<p>          initialDelaySeconds: 10</p>
<p>          periodSeconds: 5</p>
<p>        livenessProbe:</p>
<p>          httpGet:</p>
<p>            path: /health/live</p>
<p>            port: 8080</p>
<p>          initialDelaySeconds: 30</p>
<p>          periodSeconds: 10</p>
<p></code></pre></p>

<h3>Rollout</h3>

<pre><code class="language-bash"># Apply new version
<p>kubectl apply -f deployment.yaml</p>

<h1>Watch rollout progress</h1>
<p>kubectl rollout status deployment/order-service</p>

<h1>Output:</h1>
<h1>Waiting for deployment "order-service" rollout to finish: 2 out of 10 new replicas have been updated...</h1>
<h1>Waiting for deployment "order-service" rollout to finish: 5 out of 10 new replicas have been updated...</h1>
<h1>Waiting for deployment "order-service" rollout to finish: 8 out of 10 new replicas have been updated...</h1>
<h1>deployment "order-service" successfully rolled out</h1>
<p></code></pre></p>

<h3>Rollback</h3>

<pre><code class="language-bash"># Rollback to previous version
<p>kubectl rollout undo deployment/order-service</p>

<h1>Rollback to specific revision</h1>
<p>kubectl rollout undo deployment/order-service --to-revision=3</p>

<h1>View rollout history</h1>
<p>kubectl rollout history deployment/order-service</p>
<p></code></pre></p>

<hr>

<h2>Strategy 4: Recreate (Downtime)</h2>

<strong>Simple but with downtime</strong> - Terminate all old pods, then start new pods.

<strong>deployment.yaml</strong>:

<pre><code class="language-yaml">apiVersion: apps/v1
<p>kind: Deployment</p>
<p>metadata:</p>
<p>  name: order-service</p>
<p>spec:</p>
<p>  replicas: 3</p>
<p>  strategy:</p>
<p>    type: Recreate  # ❌ Causes downtime</p>
<p>  selector:</p>
<p>    matchLabels:</p>
<p>      app: order-service</p>
<p>  template:</p>
<p>    metadata:</p>
<p>      labels:</p>
<p>        app: order-service</p>
<p>    spec:</p>
<p>      containers:</p>
<p>      - name: order-service</p>
<p>        image: myregistry.azurecr.io/order-service:1.1.0</p>
<p></code></pre></p>

<strong>When to use</strong>:
<ul><li>⚠️ Only for non-critical services</li>
<li>⚠️ When database migrations require downtime</li>
<li>⚠️ Development/staging environments</li>
</ul>
<hr>

<h2>Feature Flags</h2>

<strong>Decouple deployment from release</strong> - Deploy new code with features disabled, then enable via feature flags.

<h3>LaunchDarkly Integration</h3>

<strong>Program.cs</strong>:

<pre><code class="language-csharp">builder.Services.AddSingleton<ILdClient>(sp => {
<p>  var config = Configuration.Builder(builder.Configuration["LaunchDarkly:SdkKey"])</p>
<p>    .Build();</p>
<p>  return new LdClient(config);</p>
<p>});</p>
<p></code></pre></p>

<strong>Usage</strong>:

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>  private readonly ILdClient _featureFlags;</p>

<p>  public async Task<OrderCreated> HandleAsync(</p>
<p>    CreateOrder command,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var user = Context.User(command.CustomerId);</p>

<p>    // Check feature flag</p>
<p>    var useNewPricingEngine = await _featureFlags.BoolVariationAsync(</p>
<p>      "new-pricing-engine",</p>
<p>      user,</p>
<p>      defaultValue: false</p>
<p>    );</p>

<p>    decimal totalAmount;</p>
<p>    if (useNewPricingEngine) {</p>
<p>      totalAmount = CalculateTotalWithNewEngine(command.Items);</p>
<p>    } else {</p>
<p>      totalAmount = CalculateTotalWithOldEngine(command.Items);</p>
<p>    }</p>

<p>    // Process order...</p>

<p>    return new OrderCreated { OrderId = orderId, TotalAmount = totalAmount };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Gradual Rollout with Feature Flags</h3>

<pre><code class="language-csharp">// LaunchDarkly dashboard:
<p>// Day 1: Enable for 10% of users</p>
<p>// Day 2: Enable for 25% of users</p>
<p>// Day 3: Enable for 50% of users</p>
<p>// Day 4: Enable for 100% of users</p>

<p>// Rollback: Disable feature flag instantly (no deployment needed)</p>
<p></code></pre></p>

<hr>

<h2>Database Migrations</h2>

<h3>Backward-Compatible Migrations</h3>

<strong>Step 1: Add new column (optional)</strong>:

<pre><code class="language-sql">ALTER TABLE orders ADD COLUMN payment_method TEXT NULL;
<p></code></pre></p>

<strong>Step 2: Deploy new code</strong> (reads from <code>payment_method</code> if present, falls back to old logic)

<strong>Step 3: Backfill data</strong>:

<pre><code class="language-sql">UPDATE orders SET payment_method = 'credit_card' WHERE payment_method IS NULL;
<p></code></pre></p>

<strong>Step 4: Make column required</strong>:

<pre><code class="language-sql">ALTER TABLE orders ALTER COLUMN payment_method SET NOT NULL;
<p></code></pre></p>

<h3>Expand-Contract Pattern</h3>

<strong>Expand phase</strong>:
<ul><li>Add new column/table (optional)</li>
<li>Deploy code that writes to both old and new schema</li>
<li>Backfill data</li>
</ul>
<strong>Contract phase</strong>:
<ul><li>Deploy code that reads from new schema only</li>
<li>Remove old column/table</li>
</ul>
<hr>

<h2>Health Check Gates</h2>

<strong>Prevent traffic to unhealthy pods</strong>:

<strong>deployment.yaml</strong>:

<pre><code class="language-yaml">readinessProbe:
<p>  httpGet:</p>
<p>    path: /health/ready</p>
<p>    port: 8080</p>
<p>  initialDelaySeconds: 10</p>
<p>  periodSeconds: 5</p>
<p>  failureThreshold: 3</p>

<p>livenessProbe:</p>
<p>  httpGet:</p>
<p>    path: /health/live</p>
<p>    port: 8080</p>
<p>  initialDelaySeconds: 30</p>
<p>  periodSeconds: 10</p>
<p>  failureThreshold: 3</p>
<p></code></pre></p>

<strong>ReadinessProbe</strong>: Pod receives traffic only when <code>/health/ready</code> returns 200
<strong>LivenessProbe</strong>: Kubernetes restarts pod if <code>/health/live</code> fails

<hr>

<h2>Pre-Deployment Checks</h2>

<strong>pre-deploy.sh</strong>:

<pre><code class="language-bash">#!/bin/bash

<p>echo "Running pre-deployment checks..."</p>

<h1>1. Check database connectivity</h1>
<p>echo "Checking database..."</p>
<p>psql $DATABASE_URL -c "SELECT 1" > /dev/null || {</p>
<p>  echo "ERROR: Database unreachable"</p>
<p>  exit 1</p>
<p>}</p>

<h1>2. Run database migrations</h1>
<p>echo "Running migrations..."</p>
<p>dotnet ef database update || {</p>
<p>  echo "ERROR: Migrations failed"</p>
<p>  exit 1</p>
<p>}</p>

<h1>3. Run integration tests</h1>
<p>echo "Running integration tests..."</p>
<p>dotnet test --filter Category=Integration || {</p>
<p>  echo "ERROR: Integration tests failed"</p>
<p>  exit 1</p>
<p>}</p>

<h1>4. Check external dependencies</h1>
<p>echo "Checking external dependencies..."</p>
<p>curl -f https://api.stripe.com/v1/health || {</p>
<p>  echo "ERROR: Stripe API unreachable"</p>
<p>  exit 1</p>
<p>}</p>

<p>echo "Pre-deployment checks passed!"</p>
<p></code></pre></p>

<hr>

<h2>Post-Deployment Verification</h2>

<strong>post-deploy.sh</strong>:

<pre><code class="language-bash">#!/bin/bash

<p>echo "Running post-deployment verification..."</p>

<h1>1. Health check</h1>
<p>echo "Checking health endpoint..."</p>
<p>curl -f https://order-service.myapp.com/health || {</p>
<p>  echo "ERROR: Health check failed"</p>
<p>  exit 1</p>
<p>}</p>

<h1>2. Smoke tests</h1>
<p>echo "Running smoke tests..."</p>
<p>ORDER_ID=$(curl -s -X POST https://order-service.myapp.com/orders \</p>
<p>  -H "Content-Type: application/json" \</p>
<p>  -d '{"customerId":"test-123","items":[{"productId":"prod-456","quantity":1,"unitPrice":19.99}]}' \</p>
<p>  | jq -r '.orderId')</p>

<p>curl -f https://order-service.myapp.com/orders/$ORDER_ID || {</p>
<p>  echo "ERROR: Smoke test failed"</p>
<p>  exit 1</p>
<p>}</p>

<h1>3. Check metrics</h1>
<p>echo "Checking error rate..."</p>
<p>ERROR_RATE=$(curl -s "http://prometheus:9090/api/v1/query?query=error_rate" | jq -r '.data.result[0].value[1]')</p>

<p>if (( $(echo "$ERROR_RATE > 5" | bc -l) )); then</p>
<p>  echo "ERROR: Error rate exceeded 5% ($ERROR_RATE%)"</p>
<p>  exit 1</p>
<p>fi</p>

<p>echo "Post-deployment verification passed!"</p>
<p></code></pre></p>

<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>Blue-Green</strong> - Zero downtime, instant rollback, high cost (2x resources)</p>
<p>✅ <strong>Canary</strong> - Gradual rollout, low risk, requires traffic splitting (Istio)</p>
<p>✅ <strong>Rolling Update</strong> - Default Kubernetes strategy, medium risk</p>
<p>✅ <strong>Feature Flags</strong> - Decouple deployment from release</p>
<p>✅ <strong>Backward-Compatible Migrations</strong> - Avoid downtime during schema changes</p>
<p>✅ <strong>Health Checks</strong> - Prevent traffic to unhealthy pods</p>
<p>✅ <strong>Pre/Post-Deployment Checks</strong> - Automated verification</p>

<hr>

<h2>Decision Matrix</h2>

<p>| Use Case | Recommended Strategy |</p>
<p>|----------|---------------------|</p>
<p>| <strong>Critical production services</strong> | Blue-Green or Canary |</p>
<p>| <strong>Standard services</strong> | Rolling Update |</p>
<p>| <strong>Feature releases</strong> | Feature Flags + Rolling Update |</p>
<p>| <strong>Database migrations</strong> | Expand-Contract + Blue-Green |</p>
<p>| <strong>Non-critical services</strong> | Rolling Update or Recreate |</p>

<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-advanced-topics-monitoring" class="doc-section">
  <h3>Monitoring &amp; Observability</h3>
  <p class="doc-path"><code>v1.0.0/advanced-topics/monitoring</code></p>
  <p class="doc-description"><em>Application monitoring - Application Insights, Prometheus, distributed tracing, metrics, and dashboards</em></p>
  <div class="doc-content">

<h1>Monitoring & Observability</h1>

<p>Comprehensive <strong>monitoring and observability</strong> for Whizbang applications - Application Insights, Prometheus metrics, distributed tracing, health checks, and dashboards.</p>

<hr>

<h2>Observability Pillars</h2>

<p>| Pillar | Tool | Purpose |</p>
<p>|--------|------|---------|</p>
<p>| <strong>Logs</strong> | Application Insights | Structured logging and queries |</p>
<p>| <strong>Metrics</strong> | Prometheus + Grafana | Time-series metrics and dashboards |</p>
<p>| <strong>Traces</strong> | Application Insights | Distributed tracing across services |</p>
<p>| <strong>Health</strong> | ASP.NET Health Checks | Service health and dependencies |</p>

<hr>

<h2>Application Insights</h2>

<h3>Setup</h3>

<strong>Program.cs</strong>:

<pre><code class="language-csharp">builder.Services.AddApplicationInsightsTelemetry(options => {
<p>  options.ConnectionString = builder.Configuration["ApplicationInsights:ConnectionString"];</p>
<p>  options.EnableAdaptiveSampling = true;</p>
<p>  options.EnableDependencyTrackingTelemetryModule = true;</p>
<p>  options.EnablePerformanceCounterCollectionModule = true;</p>
<p>});</p>

<p>builder.Services.AddApplicationInsightsTelemetryProcessor<FilterHealthChecksTelemetryProcessor>();</p>
<p></code></pre></p>

<strong>appsettings.json</strong>:

<pre><code class="language-json">{
<p>  "ApplicationInsights": {</p>
<p>    "ConnectionString": "InstrumentationKey=...;IngestionEndpoint=https://..."</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Structured Logging</h3>

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>  private readonly ILogger<CreateOrderReceptor> _logger;</p>

<p>  public async Task<OrderCreated> HandleAsync(</p>
<p>    CreateOrder command,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    using (_logger.BeginScope(new Dictionary<string, object> {</p>
<p>      ["OrderId"] = orderId,</p>
<p>      ["CustomerId"] = command.CustomerId</p>
<p>    })) {</p>
<p>      _logger.LogInformation(</p>
<p>        "Creating order for customer {CustomerId} with {ItemCount} items",</p>
<p>        command.CustomerId,</p>
<p>        command.Items.Length</p>
<p>      );</p>

<p>      try {</p>
<p>        // Process order...</p>

<p>        _logger.LogInformation(</p>
<p>          "Order {OrderId} created successfully with total amount {TotalAmount:C}",</p>
<p>          orderId,</p>
<p>          totalAmount</p>
<p>        );</p>

<p>        return new OrderCreated { OrderId = orderId, TotalAmount = totalAmount };</p>
<p>      } catch (Exception ex) {</p>
<p>        _logger.LogError(</p>
<p>          ex,</p>
<p>          "Failed to create order for customer {CustomerId}",</p>
<p>          command.CustomerId</p>
<p>        );</p>
<p>        throw;</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Kusto Queries (Application Insights)</h3>

<strong>Query 1: Error rate by operation</strong>:

<pre><code class="language-kusto">requests
<p>| where timestamp > ago(1h)</p>
<p>| summarize</p>
<p>    Total = count(),</p>
<p>    Errors = countif(success == false),</p>
<p>    ErrorRate = 100.0 * countif(success == false) / count()</p>
<p>  by name</p>
<p>| order by ErrorRate desc</p>
<p></code></pre></p>

<strong>Query 2: P95 latency by operation</strong>:

<pre><code class="language-kusto">requests
<p>| where timestamp > ago(1h)</p>
<p>| summarize</p>
<p>    p50 = percentile(duration, 50),</p>
<p>    p95 = percentile(duration, 95),</p>
<p>    p99 = percentile(duration, 99)</p>
<p>  by name</p>
<p>| order by p95 desc</p>
<p></code></pre></p>

<strong>Query 3: Failed operations with traces</strong>:

<pre><code class="language-kusto">requests
<p>| where timestamp > ago(1h) and success == false</p>
<p>| join kind=inner (</p>
<p>    traces</p>
<p>    | where timestamp > ago(1h)</p>
<p>  ) on operation_Id</p>
<p>| project</p>
<p>    timestamp,</p>
<p>    operation_Name,</p>
<p>    resultCode,</p>
<p>    message,</p>
<p>    customDimensions</p>
<p>| order by timestamp desc</p>
<p></code></pre></p>

<hr>

<h2>Prometheus Metrics</h2>

<h3>Setup</h3>

<strong>Program.cs</strong>:

<pre><code class="language-csharp">builder.Services.AddOpenTelemetry()
<p>  .WithMetrics(metrics => {</p>
<p>    metrics</p>
<p>      .AddMeter("Whizbang.*")</p>
<p>      .AddAspNetCoreInstrumentation()</p>
<p>      .AddHttpClientInstrumentation()</p>
<p>      .AddPrometheusExporter();</p>
<p>  });</p>

<p>app.MapPrometheusScrapingEndpoint();  // /metrics endpoint</p>
<p></code></pre></p>

<h3>Custom Metrics</h3>

<strong>OrderMetrics.cs</strong>:

<pre><code class="language-csharp">using System.Diagnostics.Metrics;

<p>public class OrderMetrics {</p>
<p>  private static readonly Meter Meter = new("Whizbang.OrderService");</p>

<p>  private static readonly Counter<long> OrdersCreated = Meter.CreateCounter<long>(</p>
<p>    "orders_created_total",</p>
<p>    description: "Total number of orders created"</p>
<p>  );</p>

<p>  private static readonly Histogram<double> OrderAmount = Meter.CreateHistogram<double>(</p>
<p>    "order_amount",</p>
<p>    unit: "USD",</p>
<p>    description: "Order amount distribution"</p>
<p>  );</p>

<p>  private static readonly ObservableGauge<int> ActiveOrders = Meter.CreateObservableGauge<int>(</p>
<p>    "active_orders",</p>
<p>    observeValue: () => GetActiveOrderCount(),</p>
<p>    description: "Current number of active orders"</p>
<p>  );</p>

<p>  public static void RecordOrderCreated(decimal amount) {</p>
<p>    OrdersCreated.Add(1);</p>
<p>    OrderAmount.Record((double)amount);</p>
<p>  }</p>

<p>  private static int GetActiveOrderCount() {</p>
<p>    // Query database for active orders</p>
<p>    return 0;  // Placeholder</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:

<pre><code class="language-csharp">public async Task<OrderCreated> HandleAsync(
<p>  CreateOrder command,</p>
<p>  CancellationToken ct = default</p>
<p>) {</p>
<p>  // Process order...</p>

<p>  OrderMetrics.RecordOrderCreated(totalAmount);</p>

<p>  return new OrderCreated { OrderId = orderId, TotalAmount = totalAmount };</p>
<p>}</p>
<p></code></pre></p>

<h3>Prometheus Queries (PromQL)</h3>

<strong>Query 1: Request rate (requests/second)</strong>:

<pre><code class="language-promql">rate(http_requests_total[5m])
<p></code></pre></p>

<strong>Query 2: Error rate percentage</strong>:

<pre><code class="language-promql">100 * (
<p>  rate(http_requests_total{status=~"5.."}[5m])</p>
<p>  /</p>
<p>  rate(http_requests_total[5m])</p>
<p>)</p>
<p></code></pre></p>

<strong>Query 3: P95 latency</strong>:

<pre><code class="language-promql">histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))
<p></code></pre></p>

<strong>Query 4: Orders created per minute</strong>:

<pre><code class="language-promql">rate(orders_created_total[1m]) * 60
<p></code></pre></p>

<hr>

<h2>Distributed Tracing</h2>

<h3>Activity (W3C Trace Context)</h3>

<strong>CreateOrderReceptor.cs</strong>:

<pre><code class="language-csharp">public async Task<OrderCreated> HandleAsync(
<p>  CreateOrder command,</p>
<p>  CancellationToken ct = default</p>
<p>) {</p>
<p>  using var activity = Activity.Current?.Source.StartActivity("CreateOrder");</p>
<p>  activity?.SetTag("order.customer_id", command.CustomerId);</p>
<p>  activity?.SetTag("order.item_count", command.Items.Length);</p>

<p>  try {</p>
<p>    // Process order...</p>

<p>    activity?.SetTag("order.total_amount", totalAmount);</p>
<p>    activity?.SetStatus(ActivityStatusCode.Ok);</p>

<p>    return new OrderCreated { OrderId = orderId, TotalAmount = totalAmount };</p>
<p>  } catch (Exception ex) {</p>
<p>    activity?.SetStatus(ActivityStatusCode.Error, ex.Message);</p>
<p>    throw;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Propagate Trace Context</h3>

<strong>MessageEnvelope.cs</strong>:

<pre><code class="language-csharp">public record MessageEnvelope {
<p>  public required string MessageId { get; init; }</p>
<p>  public required string MessageType { get; init; }</p>
<p>  public required Dictionary<string, string> Headers { get; init; }</p>

<p>  public static MessageEnvelope CreateFromActivity(string messageId, string messageType) {</p>
<p>    var headers = new Dictionary<string, string>();</p>

<p>    // Propagate W3C Trace Context</p>
<p>    if (Activity.Current != null) {</p>
<p>      headers["traceparent"] = Activity.Current.Id ?? string.Empty;</p>
<p>      if (!string.IsNullOrEmpty(Activity.Current.TraceStateString)) {</p>
<p>        headers["tracestate"] = Activity.Current.TraceStateString;</p>
<p>      }</p>
<p>    }</p>

<p>    return new MessageEnvelope {</p>
<p>      MessageId = messageId,</p>
<p>      MessageType = messageType,</p>
<p>      Headers = headers</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>ServiceBusPublisher.cs</strong>:

<pre><code class="language-csharp">public async Task PublishAsync(object @event, CancellationToken ct = default) {
<p>  var envelope = MessageEnvelope.CreateFromActivity(</p>
<p>    messageId: Guid.NewGuid().ToString(),</p>
<p>    messageType: @event.GetType().Name</p>
<p>  );</p>

<p>  var message = new ServiceBusMessage(JsonSerializer.SerializeToUtf8Bytes(@event)) {</p>
<p>    MessageId = envelope.MessageId,</p>
<p>    Subject = envelope.MessageType</p>
<p>  };</p>

<p>  // Propagate trace context in message properties</p>
<p>  foreach (var header in envelope.Headers) {</p>
<p>    message.ApplicationProperties[header.Key] = header.Value;</p>
<p>  }</p>

<p>  await _sender.SendMessageAsync(message, ct);</p>
<p>}</p>
<p></code></pre></p>

<strong>ServiceBusProcessor.cs</strong>:

<pre><code class="language-csharp">private async Task ProcessMessageAsync(ProcessMessageEventArgs args) {
<p>  // Extract trace context from message</p>
<p>  var traceparent = args.Message.ApplicationProperties.GetValueOrDefault("traceparent") as string;</p>

<p>  Activity? activity = null;</p>
<p>  if (!string.IsNullOrEmpty(traceparent)) {</p>
<p>    activity = Activity.Current?.Source.StartActivity(</p>
<p>      "ProcessMessage",</p>
<p>      ActivityKind.Consumer,</p>
<p>      traceparent</p>
<p>    );</p>
<p>  }</p>

<p>  try {</p>
<p>    // Process message...</p>

<p>    await args.CompleteMessageAsync(args.Message);</p>
<p>  } finally {</p>
<p>    activity?.Dispose();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Health Checks</h2>

<h3>Basic Health Checks</h3>

<strong>Program.cs</strong>:

<pre><code class="language-csharp">builder.Services.AddHealthChecks()
<p>  .AddNpgSql(</p>
<p>    builder.Configuration["Database:ConnectionString"],</p>
<p>    name: "database",</p>
<p>    tags: ["db", "postgres"]</p>
<p>  )</p>
<p>  .AddAzureServiceBusTopic(</p>
<p>    builder.Configuration["AzureServiceBus:ConnectionString"],</p>
<p>    "orders",</p>
<p>    name: "servicebus",</p>
<p>    tags: ["messaging", "servicebus"]</p>
<p>  )</p>
<p>  .AddUrlGroup(</p>
<p>    new Uri("https://api.stripe.com/v1/health"),</p>
<p>    name: "stripe",</p>
<p>    tags: ["external", "payment"]</p>
<p>  );</p>

<p>app.MapHealthChecks("/health", new HealthCheckOptions {</p>
<p>  ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse</p>
<p>});</p>

<p>app.MapHealthChecks("/health/ready", new HealthCheckOptions {</p>
<p>  Predicate = check => check.Tags.Contains("ready")</p>
<p>});</p>

<p>app.MapHealthChecks("/health/live", new HealthCheckOptions {</p>
<p>  Predicate = _ => true</p>
<p>});</p>
<p></code></pre></p>

<h3>Custom Health Check</h3>

<strong>OrderServiceHealthCheck.cs</strong>:

<pre><code class="language-csharp">public class OrderServiceHealthCheck : IHealthCheck {
<p>  private readonly IDbConnection _db;</p>

<p>  public async Task<HealthCheckResult> CheckHealthAsync(</p>
<p>    HealthCheckContext context,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    try {</p>
<p>      // Check database connectivity</p>
<p>      var count = await _db.ExecuteScalarAsync<int>("SELECT COUNT(*) FROM orders LIMIT 1");</p>

<p>      // Check outbox backlog</p>
<p>      var outboxBacklog = await _db.ExecuteScalarAsync<int>(</p>
<p>        "SELECT COUNT(*) FROM outbox WHERE processed_at IS NULL"</p>
<p>      );</p>

<p>      if (outboxBacklog > 10000) {</p>
<p>        return HealthCheckResult.Degraded(</p>
<p>          $"Outbox backlog is {outboxBacklog} messages",</p>
<p>          data: new Dictionary<string, object> {</p>
<p>            ["outbox_backlog"] = outboxBacklog</p>
<p>          }</p>
<p>        );</p>
<p>      }</p>

<p>      return HealthCheckResult.Healthy("Order service is healthy", data: new Dictionary<string, object> {</p>
<p>        ["outbox_backlog"] = outboxBacklog</p>
<p>      });</p>
<p>    } catch (Exception ex) {</p>
<p>      return HealthCheckResult.Unhealthy("Order service is unhealthy", ex);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Registration</strong>:

<pre><code class="language-csharp">builder.Services.AddHealthChecks()
<p>  .AddCheck<OrderServiceHealthCheck>("order-service", tags: ["ready"]);</p>
<p></code></pre></p>

<hr>

<h2>Dashboards</h2>

<h3>Grafana Dashboard (JSON)</h3>

<strong>orders-dashboard.json</strong>:

<pre><code class="language-json">{
<p>  "dashboard": {</p>
<p>    "title": "Order Service Metrics",</p>
<p>    "panels": [</p>
<p>      {</p>
<p>        "title": "Request Rate",</p>
<p>        "targets": [</p>
<p>          {</p>
<p>            "expr": "rate(http_requests_total{service=\"order-service\"}[5m])"</p>
<p>          }</p>
<p>        ],</p>
<p>        "type": "graph"</p>
<p>      },</p>
<p>      {</p>
<p>        "title": "Error Rate",</p>
<p>        "targets": [</p>
<p>          {</p>
<p>            "expr": "100 * (rate(http_requests_total{service=\"order-service\",status=~\"5..\"}[5m]) / rate(http_requests_total{service=\"order-service\"}[5m]))"</p>
<p>          }</p>
<p>        ],</p>
<p>        "type": "graph"</p>
<p>      },</p>
<p>      {</p>
<p>        "title": "P95 Latency",</p>
<p>        "targets": [</p>
<p>          {</p>
<p>            "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket{service=\"order-service\"}[5m]))"</p>
<p>          }</p>
<p>        ],</p>
<p>        "type": "graph"</p>
<p>      },</p>
<p>      {</p>
<p>        "title": "Orders Created",</p>
<p>        "targets": [</p>
<p>          {</p>
<p>            "expr": "rate(orders_created_total[1m]) * 60"</p>
<p>          }</p>
<p>        ],</p>
<p>        "type": "graph"</p>
<p>      }</p>
<p>    ]</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Azure Dashboard (KQL)</h3>

<strong>orders-dashboard.kql</strong>:

<pre><code class="language-kusto">// Request rate
<p>requests</p>
<p>| where timestamp > ago(1h)</p>
<p>| summarize RequestRate = count() / 60.0 by bin(timestamp, 1m)</p>
<p>| render timechart</p>

<p>// Error rate</p>
<p>requests</p>
<p>| where timestamp > ago(1h)</p>
<p>| summarize</p>
<p>    Total = count(),</p>
<p>    Errors = countif(success == false)</p>
<p>  by bin(timestamp, 1m)</p>
<p>| extend ErrorRate = 100.0 * Errors / Total</p>
<p>| render timechart</p>

<p>// P95 latency</p>
<p>requests</p>
<p>| where timestamp > ago(1h)</p>
<p>| summarize p95 = percentile(duration, 95) by bin(timestamp, 1m)</p>
<p>| render timechart</p>

<p>// Top slow operations</p>
<p>requests</p>
<p>| where timestamp > ago(1h)</p>
<p>| summarize p95 = percentile(duration, 95) by name</p>
<p>| top 10 by p95 desc</p>
<p>| render barchart</p>
<p></code></pre></p>

<hr>

<h2>Alerts</h2>

<h3>Prometheus Alerts</h3>

<strong>alerts.yml</strong>:

<pre><code class="language-yaml">groups:
<p>  - name: order-service</p>
<p>    interval: 30s</p>
<p>    rules:</p>
<p>      - alert: HighErrorRate</p>
<p>        expr: |</p>
<p>          100 * (</p>
<p>            rate(http_requests_total{service="order-service",status=~"5.."}[5m])</p>
<p>            /</p>
<p>            rate(http_requests_total{service="order-service"}[5m])</p>
<p>          ) > 5</p>
<p>        for: 5m</p>
<p>        labels:</p>
<p>          severity: critical</p>
<p>        annotations:</p>
<p>          summary: "High error rate on Order Service"</p>
<p>          description: "Error rate is {{ $value }}% over the last 5 minutes"</p>

<p>      - alert: HighLatency</p>
<p>        expr: |</p>
<p>          histogram_quantile(0.95,</p>
<p>            rate(http_request_duration_seconds_bucket{service="order-service"}[5m])</p>
<p>          ) > 1.0</p>
<p>        for: 5m</p>
<p>        labels:</p>
<p>          severity: warning</p>
<p>        annotations:</p>
<p>          summary: "High latency on Order Service"</p>
<p>          description: "P95 latency is {{ $value }}s over the last 5 minutes"</p>

<p>      - alert: OutboxBacklog</p>
<p>        expr: outbox_backlog > 10000</p>
<p>        for: 10m</p>
<p>        labels:</p>
<p>          severity: warning</p>
<p>        annotations:</p>
<p>          summary: "Outbox backlog is high"</p>
<p>          description: "Outbox has {{ $value }} unprocessed messages"</p>
<p></code></pre></p>

<h3>Application Insights Alerts</h3>

<strong>Azure CLI</strong>:

<pre><code class="language-bash"># Create alert for error rate
<p>az monitor metrics alert create \</p>
<p>  --name "High Error Rate" \</p>
<p>  --resource-group whizbang-rg \</p>
<p>  --scopes /subscriptions/.../resourceGroups/whizbang-rg/providers/Microsoft.Insights/components/whizbang-ai \</p>
<p>  --condition "count requests/failed > 50" \</p>
<p>  --window-size 5m \</p>
<p>  --evaluation-frequency 1m \</p>
<p>  --severity 2 \</p>
<p>  --description "Error rate exceeded 50 requests/5min"</p>

<h1>Create alert for P95 latency</h1>
<p>az monitor metrics alert create \</p>
<p>  --name "High Latency" \</p>
<p>  --resource-group whizbang-rg \</p>
<p>  --scopes /subscriptions/.../resourceGroups/whizbang-rg/providers/Microsoft.Insights/components/whizbang-ai \</p>
<p>  --condition "percentile requests/duration > 1000" \</p>
<p>  --window-size 5m \</p>
<p>  --evaluation-frequency 1m \</p>
<p>  --severity 3 \</p>
<p>  --description "P95 latency exceeded 1 second"</p>
<p></code></pre></p>

<hr>

<h2>Log Aggregation</h2>

<h3>Serilog with Sinks</h3>

<strong>Program.cs</strong>:

<pre><code class="language-csharp">using Serilog;
<p>using Serilog.Sinks.ApplicationInsights.TelemetryConverters;</p>

<p>Log.Logger = new LoggerConfiguration()</p>
<p>  .MinimumLevel.Information()</p>
<p>  .MinimumLevel.Override("Microsoft", LogEventLevel.Warning)</p>
<p>  .Enrich.FromLogContext()</p>
<p>  .Enrich.WithMachineName()</p>
<p>  .Enrich.WithEnvironmentName()</p>
<p>  .WriteTo.Console(new JsonFormatter())</p>
<p>  .WriteTo.ApplicationInsights(</p>
<p>    builder.Configuration["ApplicationInsights:ConnectionString"],</p>
<p>    TelemetryConverter.Traces</p>
<p>  )</p>
<p>  .CreateLogger();</p>

<p>builder.Host.UseSerilog();</p>
<p></code></pre></p>

<strong>appsettings.json</strong>:

<pre><code class="language-json">{
<p>  "Serilog": {</p>
<p>    "MinimumLevel": {</p>
<p>      "Default": "Information",</p>
<p>      "Override": {</p>
<p>        "Microsoft": "Warning",</p>
<p>        "System": "Warning"</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Performance Monitoring</h2>

<h3>BenchmarkDotNet Integration</h3>

<strong>CreateOrderBenchmark.cs</strong>:

<pre><code class="language-csharp">using BenchmarkDotNet.Attributes;
<p>using BenchmarkDotNet.Running;</p>

<p>[MemoryDiagnoser]</p>
<p>[SimpleJob(warmupCount: 3, iterationCount: 10)]</p>
<p>public class CreateOrderBenchmark {</p>
<p>  private CreateOrderReceptor _receptor = null!;</p>
<p>  private CreateOrder _command = null!;</p>

<p>  [GlobalSetup]</p>
<p>  public void Setup() {</p>
<p>    _receptor = new CreateOrderReceptor(Mock.Of<IDbConnection>());</p>
<p>    _command = new CreateOrder {</p>
<p>      CustomerId = "cust-123",</p>
<p>      Items = [</p>
<p>        new OrderItem { ProductId = "prod-456", Quantity = 2, UnitPrice = 19.99m }</p>
<p>      ]</p>
<p>    };</p>
<p>  }</p>

<p>  [Benchmark]</p>
<p>  public async Task<OrderCreated> CreateOrder() {</p>
<p>    return await _receptor.HandleAsync(_command);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Run</strong>:

<pre><code class="language-bash">dotnet run -c Release --project Benchmarks

<h1>Output:</h1>
<h1>| Method      | Mean     | Error   | StdDev | Allocated |</h1>
<h1>|------------ |---------:|--------:|-------:|----------:|</h1>
<h1>| CreateOrder | 125.3 μs | 2.34 μs | 2.19 μs |     512 B |</h1>
<p></code></pre></p>

<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>Application Insights</strong> - Logs, metrics, traces in one platform</p>
<p>✅ <strong>Prometheus + Grafana</strong> - Time-series metrics and dashboards</p>
<p>✅ <strong>Distributed Tracing</strong> - W3C Trace Context propagation</p>
<p>✅ <strong>Health Checks</strong> - Readiness and liveness probes</p>
<p>✅ <strong>Custom Metrics</strong> - Business-specific KPIs</p>
<p>✅ <strong>Alerts</strong> - Proactive incident detection</p>
<p>✅ <strong>Structured Logging</strong> - Queryable logs with context</p>

<hr>

<h2>Monitoring Checklist</h2>

<ul><li>[ ] Application Insights configured with connection string</li>
<li>[ ] Prometheus metrics exported at <code>/metrics</code></li>
<li>[ ] Distributed tracing enabled with W3C Trace Context</li>
<li>[ ] Health checks at <code>/health</code>, <code>/health/ready</code>, <code>/health/live</code></li>
<li>[ ] Custom metrics for business KPIs (orders created, revenue, etc.)</li>
<li>[ ] Alerts configured for error rate, latency, backlog</li>
<li>[ ] Dashboards created in Grafana and Azure Portal</li>
<li>[ ] Log aggregation with Serilog</li>
<li>[ ] Performance benchmarks with BenchmarkDotNet</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-advanced-topics-multi-tenancy" class="doc-section">
  <h3>Multi-Tenancy Patterns</h3>
  <p class="doc-path"><code>v1.0.0/advanced-topics/multi-tenancy</code></p>
  <p class="doc-description"><em>Multi-tenancy architecture patterns - database-per-tenant, schema-per-tenant, row-level security</em></p>
  <div class="doc-content">

<h1>Multi-Tenancy Patterns</h1>

<p>Comprehensive guide to <strong>multi-tenancy architectures</strong> with Whizbang - database-per-tenant, schema-per-tenant, row-level security, tenant context management, and migration strategies.</p>

<hr>

<h2>Multi-Tenancy Comparison</h2>

<p>| Pattern | Isolation | Cost | Complexity | Scale Limit |</p>
<p>|---------|-----------|------|------------|-------------|</p>
<p>| <strong>Database Per Tenant</strong> | ⭐⭐⭐⭐⭐ | High | Medium | ~1,000 tenants |</p>
<p>| <strong>Schema Per Tenant</strong> | ⭐⭐⭐⭐ | Medium | Medium | ~10,000 tenants |</p>
<p>| <strong>Row-Level Security (RLS)</strong> | ⭐⭐⭐ | Low | Low | ~100,000+ tenants |</p>
<p>| <strong>Discriminator Column</strong> | ⭐⭐ | Low | Low | ~100,000+ tenants |</p>

<hr>

<h2>Pattern 1: Database Per Tenant</h2>

<strong>Strongest isolation</strong> - Each tenant has dedicated database.

<h3>Architecture</h3>

<pre><code class="language-">┌────────────────────────────────────────────────────┐
<p>│  Multi-Tenant SaaS Application                     │</p>
<p>│                                                     │</p>
<p>│  ┌──────────────────┐                              │</p>
<p>│  │  Tenant Resolver │                              │</p>
<p>│  │  - Header/JWT    │                              │</p>
<p>│  │  - Subdomain     │                              │</p>
<p>│  └────────┬─────────┘                              │</p>
<p>│           │                                         │</p>
<p>│           ▼                                         │</p>
<p>│  ┌──────────────────┐                              │</p>
<p>│  │ Connection Pool  │                              │</p>
<p>│  │  Manager         │                              │</p>
<p>│  └────────┬─────────┘                              │</p>
<p>│           │                                         │</p>
<p>│  ┌────────┼───────────────────────────┐            │</p>
<p>│  │        │                           │            │</p>
<p>│  ▼        ▼                           ▼            │</p>
<p>│ ┌─────┐ ┌─────┐                   ┌─────┐         │</p>
<p>│ │DB-A │ │DB-B │       ...         │DB-Z │         │</p>
<p>│ └─────┘ └─────┘                   └─────┘         │</p>
<p>└────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<h3>Tenant Context (AsyncLocal)</h3>

<strong>TenantContext.cs</strong>:

<pre><code class="language-csharp">public static class TenantContext {
<p>  private static readonly AsyncLocal<string?> _tenantId = new();</p>

<p>  public static string? CurrentTenantId {</p>
<p>    get => _tenantId.Value;</p>
<p>    set => _tenantId.Value = value;</p>
<p>  }</p>

<p>  public static string RequireTenantId() {</p>
<p>    return CurrentTenantId</p>
<p>      ?? throw new InvalidOperationException("No tenant context established");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Why AsyncLocal?</strong>:
<ul><li>✅ Thread-safe</li>
<li>✅ Async-safe (flows through await calls)</li>
<li>✅ Request-scoped (automatically cleared after request)</li>
</ul>
<h3>Tenant Identification Middleware</h3>

<strong>TenantIdentificationMiddleware.cs</strong>:

<pre><code class="language-csharp">public class TenantIdentificationMiddleware {
<p>  private readonly RequestDelegate _next;</p>

<p>  public TenantIdentificationMiddleware(RequestDelegate next) {</p>
<p>    _next = next;</p>
<p>  }</p>

<p>  public async Task InvokeAsync(HttpContext context) {</p>
<p>    // Option 1: Custom header</p>
<p>    var tenantId = context.Request.Headers["X-Tenant-Id"].FirstOrDefault();</p>

<p>    // Option 2: Subdomain (e.g., acme.myapp.com -> acme)</p>
<p>    if (string.IsNullOrEmpty(tenantId)) {</p>
<p>      var host = context.Request.Host.Host;</p>
<p>      tenantId = host.Split('.').FirstOrDefault();</p>
<p>    }</p>

<p>    // Option 3: JWT claim</p>
<p>    if (string.IsNullOrEmpty(tenantId)) {</p>
<p>      tenantId = context.User.FindFirst("tenant_id")?.Value;</p>
<p>    }</p>

<p>    if (string.IsNullOrEmpty(tenantId)) {</p>
<p>      context.Response.StatusCode = 400;</p>
<p>      await context.Response.WriteAsync("Missing tenant identification");</p>
<p>      return;</p>
<p>    }</p>

<p>    // Set tenant context</p>
<p>    TenantContext.CurrentTenantId = tenantId;</p>

<p>    await _next(context);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Registration (Program.cs)</strong>:

<pre><code class="language-csharp">app.UseMiddleware<TenantIdentificationMiddleware>();
<p></code></pre></p>

<h3>Tenant-Aware Database Connections</h3>

<strong>TenantDbConnectionFactory.cs</strong>:

<pre><code class="language-csharp">public interface ITenantDbConnectionFactory {
<p>  Task<IDbConnection> CreateConnectionAsync(CancellationToken ct = default);</p>
<p>}</p>

<p>public class TenantDbConnectionFactory : ITenantDbConnectionFactory {</p>
<p>  private readonly IConfiguration _config;</p>
<p>  private readonly ILogger<TenantDbConnectionFactory> _logger;</p>

<p>  public async Task<IDbConnection> CreateConnectionAsync(CancellationToken ct = default) {</p>
<p>    var tenantId = TenantContext.RequireTenantId();</p>
<p>    var connectionString = GetConnectionString(tenantId);</p>

<p>    var connection = new NpgsqlConnection(connectionString);</p>
<p>    await connection.OpenAsync(ct);</p>

<p>    _logger.LogDebug("Opened connection to tenant database: {TenantId}", tenantId);</p>

<p>    return connection;</p>
<p>  }</p>

<p>  private string GetConnectionString(string tenantId) {</p>
<p>    // Option 1: Configuration-based</p>
<p>    var connectionString = _config[$"Tenants:{tenantId}:ConnectionString"];</p>
<p>    if (!string.IsNullOrEmpty(connectionString)) {</p>
<p>      return connectionString;</p>
<p>    }</p>

<p>    // Option 2: Template-based (same server, different database)</p>
<p>    var template = _config["Database:TenantTemplate"]</p>
<p>      ?? throw new InvalidOperationException("Missing tenant template connection string");</p>

<p>    return template.Replace("{TenantId}", tenantId);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>appsettings.json</strong>:

<pre><code class="language-json">{
<p>  "Database": {</p>
<p>    "TenantTemplate": "Host=db.myapp.com;Database=tenant_{TenantId};Username=app;Password=<em></em>*"</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Tenant-Aware Receptors</h3>

<strong>CreateOrderReceptor.cs</strong>:

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>  private readonly ITenantDbConnectionFactory _dbFactory;</p>

<p>  public async Task<OrderCreated> HandleAsync(</p>
<p>    CreateOrder command,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var tenantId = TenantContext.RequireTenantId();</p>

<p>    await using var connection = await _dbFactory.CreateConnectionAsync(ct);</p>
<p>    await using var tx = await connection.BeginTransactionAsync(ct);</p>

<p>    try {</p>
<p>      // Insert order (tenant-specific database)</p>
<p>      await connection.ExecuteAsync(</p>
<p>        """</p>
<p>        INSERT INTO orders (order_id, customer_id, total_amount, created_at)</p>
<p>        VALUES (@OrderId, @CustomerId, @TotalAmount, NOW())</p>
<p>        """,</p>
<p>        new {</p>
<p>          OrderId = orderId,</p>
<p>          CustomerId = command.CustomerId,</p>
<p>          TotalAmount = command.Items.Sum(i => i.Quantity * i.UnitPrice)</p>
<p>        },</p>
<p>        transaction: tx</p>
<p>      );</p>

<p>      // Insert outbox message</p>
<p>      await connection.ExecuteAsync(</p>
<p>        """</p>
<p>        INSERT INTO outbox (message_id, message_type, message_body, created_at)</p>
<p>        VALUES (@MessageId, @MessageType, @MessageBody::jsonb, NOW())</p>
<p>        """,</p>
<p>        transaction: tx</p>
<p>      );</p>

<p>      await tx.CommitAsync(ct);</p>

<p>      return new OrderCreated {</p>
<p>        OrderId = orderId,</p>
<p>        CustomerId = command.CustomerId,</p>
<p>        TenantId = tenantId,  // Include tenant in event</p>
<p>        CreatedAt = DateTime.UtcNow</p>
<p>      };</p>
<p>    } catch {</p>
<p>      await tx.RollbackAsync(ct);</p>
<p>      throw;</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Tenant Onboarding</h3>

<strong>TenantOnboardingReceptor.cs</strong>:

<pre><code class="language-csharp">public record CreateTenant : ICommand<TenantCreated> {
<p>  public required string TenantId { get; init; }</p>
<p>  public required string Name { get; init; }</p>
<p>  public required string AdminEmail { get; init; }</p>
<p>}</p>

<p>public class TenantOnboardingReceptor : IReceptor<CreateTenant, TenantCreated> {</p>
<p>  private readonly IConfiguration _config;</p>
<p>  private readonly IDbConnection _adminDb;</p>

<p>  public async Task<TenantCreated> HandleAsync(</p>
<p>    CreateTenant command,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    // 1. Create tenant database</p>
<p>    var adminConnectionString = _config["Database:AdminConnectionString"];</p>
<p>    await using var adminConn = new NpgsqlConnection(adminConnectionString);</p>
<p>    await adminConn.OpenAsync(ct);</p>

<p>    await adminConn.ExecuteAsync($"CREATE DATABASE tenant_{command.TenantId}");</p>

<p>    // 2. Run schema migrations</p>
<p>    var tenantConnectionString = _config["Database:TenantTemplate"]</p>
<p>      .Replace("{TenantId}", command.TenantId);</p>

<p>    await using var tenantConn = new NpgsqlConnection(tenantConnectionString);</p>
<p>    await tenantConn.OpenAsync(ct);</p>

<p>    await tenantConn.ExecuteAsync(File.ReadAllText("schema.sql"));</p>

<p>    // 3. Register tenant in admin database</p>
<p>    await _adminDb.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO tenants (tenant_id, name, admin_email, created_at, status)</p>
<p>      VALUES (@TenantId, @Name, @AdminEmail, NOW(), 'active')</p>
<p>      """,</p>
<p>      new {</p>
<p>        TenantId = command.TenantId,</p>
<p>        Name = command.Name,</p>
<p>        AdminEmail = command.AdminEmail</p>
<p>      }</p>
<p>    );</p>

<p>    return new TenantCreated {</p>
<p>      TenantId = command.TenantId,</p>
<p>      Name = command.Name,</p>
<p>      CreatedAt = DateTime.UtcNow</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Pattern 2: Schema Per Tenant</h2>

<strong>Medium isolation</strong> - Shared database, separate schemas per tenant.

<h3>Schema Management</h3>

<strong>PostgreSQL schemas</strong>:

<pre><code class="language-sql">-- Create tenant schemas
<p>CREATE SCHEMA tenant_acme;</p>
<p>CREATE SCHEMA tenant_globex;</p>

<p>-- Create tables in each schema</p>
<p>CREATE TABLE tenant_acme.orders (</p>
<p>  order_id UUID PRIMARY KEY,</p>
<p>  customer_id TEXT NOT NULL,</p>
<p>  total_amount DECIMAL(18,2) NOT NULL,</p>
<p>  created_at TIMESTAMP NOT NULL</p>
<p>);</p>

<p>CREATE TABLE tenant_globex.orders (</p>
<p>  order_id UUID PRIMARY KEY,</p>
<p>  customer_id TEXT NOT NULL,</p>
<p>  total_amount DECIMAL(18,2) NOT NULL,</p>
<p>  created_at TIMESTAMP NOT NULL</p>
<p>);</p>
<p></code></pre></p>

<h3>Tenant-Aware Connection</h3>

<strong>SchemaPerTenantDbConnectionFactory.cs</strong>:

<pre><code class="language-csharp">public class SchemaPerTenantDbConnectionFactory : ITenantDbConnectionFactory {
<p>  private readonly IConfiguration _config;</p>

<p>  public async Task<IDbConnection> CreateConnectionAsync(CancellationToken ct = default) {</p>
<p>    var tenantId = TenantContext.RequireTenantId();</p>
<p>    var connectionString = _config["Database:ConnectionString"];</p>

<p>    var connection = new NpgsqlConnection(connectionString);</p>
<p>    await connection.OpenAsync(ct);</p>

<p>    // Set search_path to tenant schema</p>
<p>    await connection.ExecuteAsync($"SET search_path TO tenant_{tenantId}");</p>

<p>    return connection;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Tenant Onboarding (Schema)</h3>

<pre><code class="language-csharp">public async Task<TenantCreated> HandleAsync(
<p>  CreateTenant command,</p>
<p>  CancellationToken ct = default</p>
<p>) {</p>
<p>  await using var connection = new NpgsqlConnection(_config["Database:ConnectionString"]);</p>
<p>  await connection.OpenAsync(ct);</p>

<p>  // 1. Create schema</p>
<p>  await connection.ExecuteAsync($"CREATE SCHEMA tenant_{command.TenantId}");</p>

<p>  // 2. Create tables in schema</p>
<p>  await connection.ExecuteAsync($"""</p>
<p>    CREATE TABLE tenant_{command.TenantId}.orders (</p>
<p>      order_id UUID PRIMARY KEY,</p>
<p>      customer_id TEXT NOT NULL,</p>
<p>      total_amount DECIMAL(18,2) NOT NULL,</p>
<p>      created_at TIMESTAMP NOT NULL</p>
<p>    )</p>
<p>    """);</p>

<p>  // 3. Register tenant</p>
<p>  await connection.ExecuteAsync(</p>
<p>    """</p>
<p>    INSERT INTO public.tenants (tenant_id, name, admin_email, created_at, status)</p>
<p>    VALUES (@TenantId, @Name, @AdminEmail, NOW(), 'active')</p>
<p>    """,</p>
<p>    new { TenantId = command.TenantId, Name = command.Name, AdminEmail = command.AdminEmail }</p>
<p>  );</p>

<p>  return new TenantCreated { TenantId = command.TenantId, CreatedAt = DateTime.UtcNow };</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Pattern 3: Row-Level Security (RLS)</h2>

<strong>Lower isolation</strong> - Shared database and schema, automatic row filtering.

<h3>PostgreSQL RLS Setup</h3>

<pre><code class="language-sql">-- Enable RLS on table
<p>CREATE TABLE orders (</p>
<p>  order_id UUID PRIMARY KEY,</p>
<p>  tenant_id TEXT NOT NULL,</p>
<p>  customer_id TEXT NOT NULL,</p>
<p>  total_amount DECIMAL(18,2) NOT NULL,</p>
<p>  created_at TIMESTAMP NOT NULL</p>
<p>);</p>

<p>ALTER TABLE orders ENABLE ROW LEVEL SECURITY;</p>

<p>-- Create RLS policy</p>
<p>CREATE POLICY tenant_isolation_policy ON orders</p>
<p>  USING (tenant_id = current_setting('app.tenant_id')::text);</p>

<p>-- Grant access</p>
<p>GRANT SELECT, INSERT, UPDATE, DELETE ON orders TO app_user;</p>
<p></code></pre></p>

<h3>Tenant Context (PostgreSQL)</h3>

<strong>RLSDbConnectionFactory.cs</strong>:

<pre><code class="language-csharp">public class RLSDbConnectionFactory : ITenantDbConnectionFactory {
<p>  private readonly IConfiguration _config;</p>

<p>  public async Task<IDbConnection> CreateConnectionAsync(CancellationToken ct = default) {</p>
<p>    var tenantId = TenantContext.RequireTenantId();</p>
<p>    var connectionString = _config["Database:ConnectionString"];</p>

<p>    var connection = new NpgsqlConnection(connectionString);</p>
<p>    await connection.OpenAsync(ct);</p>

<p>    // Set tenant context for RLS</p>
<p>    await connection.ExecuteAsync(</p>
<p>      "SELECT set_config('app.tenant_id', @TenantId, false)",</p>
<p>      new { TenantId = tenantId }</p>
<p>    );</p>

<p>    return connection;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Automatic Tenant Filtering</h3>

<p>With RLS enabled, all queries automatically filter by tenant:</p>

<pre><code class="language-csharp">// This query automatically filters to current tenant
<p>var orders = await connection.QueryAsync<OrderRow>(</p>
<p>  """</p>
<p>  SELECT * FROM orders</p>
<p>  WHERE customer_id = @CustomerId</p>
<p>  """,</p>
<p>  new { CustomerId = "cust-123" }</p>
<p>);</p>

<p>// Equivalent to:</p>
<p>// SELECT * FROM orders</p>
<p>// WHERE customer_id = 'cust-123' AND tenant_id = 'current-tenant'</p>
<p></code></pre></p>

<hr>

<h2>Pattern 4: Discriminator Column</h2>

<strong>Lowest isolation</strong> - Shared database/schema, manual tenant filtering.

<h3>Schema</h3>

<pre><code class="language-sql">CREATE TABLE orders (
<p>  order_id UUID PRIMARY KEY,</p>
<p>  tenant_id TEXT NOT NULL,  -- Discriminator column</p>
<p>  customer_id TEXT NOT NULL,</p>
<p>  total_amount DECIMAL(18,2) NOT NULL,</p>
<p>  created_at TIMESTAMP NOT NULL</p>
<p>);</p>

<p>-- Index for tenant queries</p>
<p>CREATE INDEX idx_orders_tenant_id ON orders(tenant_id);</p>
<p></code></pre></p>

<h3>Manual Filtering</h3>

<strong>CreateOrderReceptor.cs</strong>:

<pre><code class="language-csharp">public async Task<OrderCreated> HandleAsync(
<p>  CreateOrder command,</p>
<p>  CancellationToken ct = default</p>
<p>) {</p>
<p>  var tenantId = TenantContext.RequireTenantId();</p>

<p>  await using var connection = new NpgsqlConnection(_config["Database:ConnectionString"]);</p>
<p>  await connection.OpenAsync(ct);</p>

<p>  // ALWAYS include tenant_id in INSERT</p>
<p>  await connection.ExecuteAsync(</p>
<p>    """</p>
<p>    INSERT INTO orders (order_id, tenant_id, customer_id, total_amount, created_at)</p>
<p>    VALUES (@OrderId, @TenantId, @CustomerId, @TotalAmount, NOW())</p>
<p>    """,</p>
<p>    new {</p>
<p>      OrderId = orderId,</p>
<p>      TenantId = tenantId,  // ⚠️ Critical: Include tenant ID</p>
<p>      CustomerId = command.CustomerId,</p>
<p>      TotalAmount = totalAmount</p>
<p>    }</p>
<p>  );</p>

<p>  return new OrderCreated { OrderId = orderId, TenantId = tenantId };</p>
<p>}</p>

<p>// ALWAYS include tenant_id in WHERE clause</p>
<p>var orders = await connection.QueryAsync<OrderRow>(</p>
<p>  """</p>
<p>  SELECT * FROM orders</p>
<p>  WHERE tenant_id = @TenantId AND customer_id = @CustomerId</p>
<p>  """,</p>
<p>  new { TenantId = tenantId, CustomerId = "cust-123" }</p>
<p>);</p>
<p></code></pre></p>

<strong>⚠️ Risk</strong>: Developers must remember to include <code>tenant_id</code> in every query (easy to forget).

<hr>

<h2>Cross-Tenant Analytics</h2>

<strong>Shared analytics database</strong> for reporting across tenants:

<h3>Architecture</h3>

<pre><code class="language-">┌────────────────────────────────────────────────────────┐
<p>│  Tenant Databases                                      │</p>
<p>│  ┌─────┐  ┌─────┐             ┌─────┐                 │</p>
<p>│  │DB-A │  │DB-B │    ...      │DB-Z │                 │</p>
<p>│  └──┬──┘  └──┬──┘             └──┬──┘                 │</p>
<p>│     │        │                   │                     │</p>
<p>│     └────────┼───────────────────┘                     │</p>
<p>│              │ Events                                  │</p>
<p>│              ▼                                          │</p>
<p>│  ┌───────────────────────────┐                         │</p>
<p>│  │ Analytics Worker          │                         │</p>
<p>│  │  - CrossTenantPerspective │                         │</p>
<p>│  └──────────┬────────────────┘                         │</p>
<p>│             │                                           │</p>
<p>│             ▼                                           │</p>
<p>│  ┌───────────────────────────┐                         │</p>
<p>│  │ Shared Analytics Database │                         │</p>
<p>│  │  - Aggregated metrics     │                         │</p>
<p>│  │  - All tenants            │                         │</p>
<p>│  └───────────────────────────┘                         │</p>
<p>└────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<h3>Cross-Tenant Perspective</h3>

<strong>CrossTenantAnalyticsPerspective.cs</strong>:

<pre><code class="language-csharp">public class CrossTenantAnalyticsPerspective : IPerspectiveOf<OrderCreated> {
<p>  private readonly IDbConnection _analyticsDb;  // Shared analytics database</p>

<p>  public async Task HandleAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>    // Insert into shared analytics database (includes tenant_id)</p>
<p>    await _analyticsDb.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO order_analytics (order_id, tenant_id, customer_id, total_amount, created_at)</p>
<p>      VALUES (@OrderId, @TenantId, @CustomerId, @TotalAmount, @CreatedAt)</p>
<p>      """,</p>
<p>      new {</p>
<p>        OrderId = @event.OrderId,</p>
<p>        TenantId = @event.TenantId,  // Track which tenant</p>
<p>        CustomerId = @event.CustomerId,</p>
<p>        TotalAmount = @event.TotalAmount,</p>
<p>        CreatedAt = @event.CreatedAt</p>
<p>      }</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Analytics Queries</h3>

<pre><code class="language-csharp">// Query across all tenants
<p>var metrics = await _analyticsDb.QueryAsync<TenantMetrics>(</p>
<p>  """</p>
<p>  SELECT</p>
<p>    tenant_id,</p>
<p>    COUNT(*) AS total_orders,</p>
<p>    SUM(total_amount) AS total_revenue,</p>
<p>    AVG(total_amount) AS avg_order_value</p>
<p>  FROM order_analytics</p>
<p>  WHERE created_at >= @StartDate</p>
<p>  GROUP BY tenant_id</p>
<p>  ORDER BY total_revenue DESC</p>
<p>  """,</p>
<p>  new { StartDate = DateTime.UtcNow.AddDays(-30) }</p>
<p>);</p>
<p></code></pre></p>

<hr>

<h2>Tenant Isolation Testing</h2>

<strong>TenantIsolationTests.cs</strong>:

<pre><code class="language-csharp">public class TenantIsolationTests {
<p>  [Test]</p>
<p>  public async Task CreateOrder_DifferentTenants_IsolatedData() {</p>
<p>    // Arrange - Tenant A</p>
<p>    TenantContext.CurrentTenantId = "tenant-a";</p>
<p>    var receptorA = new CreateOrderReceptor(_dbFactory);</p>
<p>    var commandA = new CreateOrder { CustomerId = "cust-a", Items = [...] };</p>

<p>    // Act - Tenant A creates order</p>
<p>    var resultA = await receptorA.HandleAsync(commandA);</p>

<p>    // Arrange - Tenant B</p>
<p>    TenantContext.CurrentTenantId = "tenant-b";</p>
<p>    var receptorB = new CreateOrderReceptor(_dbFactory);</p>
<p>    var commandB = new CreateOrder { CustomerId = "cust-b", Items = [...] };</p>

<p>    // Act - Tenant B creates order</p>
<p>    var resultB = await receptorB.HandleAsync(commandB);</p>

<p>    // Assert - Tenant A cannot see Tenant B's order</p>
<p>    TenantContext.CurrentTenantId = "tenant-a";</p>
<p>    await using var connA = await _dbFactory.CreateConnectionAsync();</p>
<p>    var ordersA = await connA.QueryAsync<OrderRow>("SELECT * FROM orders");</p>

<p>    await Assert.That(ordersA).HasCount(1);</p>
<p>    await Assert.That(ordersA.Single().OrderId).IsEqualTo(resultA.OrderId);</p>

<p>    // Assert - Tenant B cannot see Tenant A's order</p>
<p>    TenantContext.CurrentTenantId = "tenant-b";</p>
<p>    await using var connB = await _dbFactory.CreateConnectionAsync();</p>
<p>    var ordersB = await connB.QueryAsync<OrderRow>("SELECT * FROM orders");</p>

<p>    await Assert.That(ordersB).HasCount(1);</p>
<p>    await Assert.That(ordersB.Single().OrderId).IsEqualTo(resultB.OrderId);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Migration Strategies</h2>

<h3>Migrating from Discriminator to Database-Per-Tenant</h3>

<strong>Step 1: Export tenant data</strong>:

<pre><code class="language-csharp">var tenantIds = await _db.QueryAsync<string>("SELECT DISTINCT tenant_id FROM orders");

<p>foreach (var tenantId in tenantIds) {</p>
<p>  var orders = await _db.QueryAsync<OrderRow>(</p>
<p>    "SELECT * FROM orders WHERE tenant_id = @TenantId",</p>
<p>    new { TenantId = tenantId }</p>
<p>  );</p>

<p>  await File.WriteAllTextAsync(</p>
<p>    $"export/tenant-{tenantId}-orders.json",</p>
<p>    JsonSerializer.Serialize(orders)</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<strong>Step 2: Create tenant databases</strong>:

<pre><code class="language-csharp">foreach (var tenantId in tenantIds) {
<p>  await _adminDb.ExecuteAsync($"CREATE DATABASE tenant_{tenantId}");</p>

<p>  await using var tenantConn = new NpgsqlConnection(</p>
<p>    $"Host=localhost;Database=tenant_{tenantId};..."</p>
<p>  );</p>
<p>  await tenantConn.OpenAsync();</p>

<p>  await tenantConn.ExecuteAsync(File.ReadAllText("schema.sql"));</p>
<p>}</p>
<p></code></pre></p>

<strong>Step 3: Import data</strong>:

<pre><code class="language-csharp">foreach (var tenantId in tenantIds) {
<p>  var orders = JsonSerializer.Deserialize<OrderRow[]>(</p>
<p>    await File.ReadAllTextAsync($"export/tenant-{tenantId}-orders.json")</p>
<p>  );</p>

<p>  await using var tenantConn = new NpgsqlConnection(</p>
<p>    $"Host=localhost;Database=tenant_{tenantId};..."</p>
<p>  );</p>
<p>  await tenantConn.OpenAsync();</p>

<p>  await tenantConn.ExecuteAsync(</p>
<p>    "INSERT INTO orders (order_id, customer_id, total_amount, created_at) VALUES (@OrderId, @CustomerId, @TotalAmount, @CreatedAt)",</p>
<p>    orders</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>Database Per Tenant</strong> - Strongest isolation, higher cost (~1,000 tenants)</p>
<p>✅ <strong>Schema Per Tenant</strong> - Medium isolation, shared database (~10,000 tenants)</p>
<p>✅ <strong>Row-Level Security</strong> - Automatic filtering, lower isolation (~100K+ tenants)</p>
<p>✅ <strong>Discriminator Column</strong> - Manual filtering, lowest isolation (~100K+ tenants)</p>
<p>✅ <strong>AsyncLocal Context</strong> - Thread-safe, async-safe tenant tracking</p>
<p>✅ <strong>Cross-Tenant Analytics</strong> - Shared analytics database for reporting</p>

<hr>

<h2>Decision Matrix</h2>

<p>| Use Case | Recommended Pattern |</p>
<p>|----------|---------------------|</p>
<p>| <strong>B2B SaaS (< 1K customers)</strong> | Database Per Tenant |</p>
<p>| <strong>B2B SaaS (1K-10K customers)</strong> | Schema Per Tenant |</p>
<p>| <strong>B2C SaaS (millions of users)</strong> | RLS or Discriminator |</p>
<p>| <strong>Strict compliance (HIPAA, etc.)</strong> | Database Per Tenant |</p>
<p>| <strong>Cost-sensitive</strong> | RLS or Discriminator |</p>

<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-advanced-topics-native-aot" class="doc-section">
  <h3>Native AOT</h3>
  <p class="doc-path"><code>v1.0.0/advanced-topics/native-aot</code></p>
  <p class="doc-description"><em>Deploy with Native AOT - zero reflection, trim-safe code, and AOT-compatible patterns</em></p>
  <div class="doc-content">

<h1>Native AOT</h1>

<p>Deploy Whizbang applications with <strong>Native AOT (Ahead-of-Time compilation)</strong> for faster startup, smaller memory footprint, and self-contained executables.</p>

<hr>

<h2>Why Native AOT?</h2>

<p>| Metric | JIT (.NET Runtime) | Native AOT |</p>
<p>|--------|-------------------|------------|</p>
<p>| <strong>Startup Time</strong> | 1-2 seconds | < 100ms |</p>
<p>| <strong>Memory Footprint</strong> | 100-200 MB | 20-40 MB |</p>
<p>| <strong>Deployment Size</strong> | 80 MB + runtime | 10-15 MB (self-contained) |</p>
<p>| <strong>Reflection</strong> | ✅ Fully supported | ❌ Limited |</p>
<p>| <strong>Trim-Safe</strong> | Optional | ✅ Required |</p>

<hr>

<h2>Enabling Native AOT</h2>

<strong>Project file (.csproj)</strong>:

<pre><code class="language-xml"><Project Sdk="Microsoft.NET.Sdk.Web">
<p>  <PropertyGroup></p>
<p>    <TargetFramework>net10.0</TargetFramework></p>
<p>    <PublishAot>true</PublishAot></p>
<p>    <InvariantGlobalization>true</InvariantGlobalization></p>
<p>    <IlcOptimizationPreference>Speed</IlcOptimizationPreference></p>
<p>    <IlcGenerateStackTraceData>false</IlcGenerateStackTraceData></p>
<p>  </PropertyGroup></p>
<p></Project></p>
<p></code></pre></p>

<strong>Publish</strong>:

<pre><code class="language-bash">dotnet publish -c Release -r linux-x64
<p></code></pre></p>

<strong>Output</strong>:

<pre><code class="language-">ECommerce.OrderService.API (self-contained executable)
<p>Size: 12.3 MB</p>
<p>Startup: 87ms</p>
<p>Memory: 24 MB</p>
<p></code></pre></p>

<hr>

<h2>Whizbang is AOT-Ready</h2>

<p>Whizbang uses <strong>source generators</strong> instead of reflection, making it AOT-compatible by default:</p>

<pre><code class="language-csharp">// ❌ BAD - Reflection (not AOT-compatible)
<p>public class ReflectionDispatcher : IDispatcher {</p>
<p>  public async Task<TResponse> DispatchAsync<TRequest, TResponse>(</p>
<p>    TRequest request,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    var receptorType = typeof(IReceptor<,>).MakeGenericType(typeof(TRequest), typeof(TResponse));</p>
<p>    var receptor = (IReceptor<TRequest, TResponse>)_services.GetService(receptorType);</p>
<p>    return await receptor.HandleAsync(request, ct);</p>
<p>  }</p>
<p>}</p>

<p>// ✅ GOOD - Source-generated (AOT-compatible)</p>
<p>public partial class GeneratedDispatcher : IDispatcher {</p>
<p>  public async Task<TResponse> DispatchAsync<TRequest, TResponse>(</p>
<p>    TRequest request,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    return request switch {</p>
<p>      CreateOrder cmd => (TResponse)(object)await DispatchCreateOrderAsync(cmd, ct),</p>
<p>      UpdateOrder cmd => (TResponse)(object)await DispatchUpdateOrderAsync(cmd, ct),</p>
<p>      _ => throw new InvalidOperationException($"No handler for {typeof(TRequest).Name}")</p>
<p>    };</p>
<p>  }</p>

<p>  [MethodImpl(MethodImplOptions.AggressiveInlining)]</p>
<p>  private async Task<OrderCreated> DispatchCreateOrderAsync(</p>
<p>    CreateOrder command,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    var receptor = _services.GetRequiredService<IReceptor<CreateOrder, OrderCreated>>();</p>
<p>    return await receptor.HandleAsync(command, ct);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key differences</strong>:
<ul><li>✅ <strong>No reflection</strong> - Direct method calls</li>
<li>✅ <strong>No <code>MakeGenericType</code></strong> - All types known at compile-time</li>
<li>✅ <strong>Inlineable</strong> - JIT/AOT can inline small methods</li>
<li>✅ <strong>Trim-safe</strong> - No dynamic type loading</li>
</ul>
<hr>

<h2>JSON Serialization (AOT-Compatible)</h2>

<p>Use <code>System.Text.Json</code> source generators for AOT-compatible JSON:</p>

<strong>JsonContextRegistry.cs</strong>:

<pre><code class="language-csharp">using System.Text.Json.Serialization;

<p>[JsonSerializable(typeof(CreateOrder))]</p>
<p>[JsonSerializable(typeof(OrderCreated))]</p>
<p>[JsonSerializable(typeof(PaymentProcessed))]</p>
<p>[JsonSerializable(typeof(ShipmentCreated))]</p>
<p>public partial class MessageJsonContext : JsonSerializerContext {</p>
<p>}</p>

<p>public static class JsonContextRegistry {</p>
<p>  public static JsonSerializerOptions CreateOptions() {</p>
<p>    return new JsonSerializerOptions {</p>
<p>      TypeInfoResolver = JsonTypeInfoResolver.Combine(</p>
<p>        MessageJsonContext.Default</p>
<p>      )</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:

<pre><code class="language-csharp">// ✅ GOOD - AOT-compatible
<p>var options = JsonContextRegistry.CreateOptions();</p>
<p>var json = JsonSerializer.Serialize(order, options);</p>
<p>var deserialized = JsonSerializer.Deserialize<OrderCreated>(json, options);</p>

<p>// ❌ BAD - NOT AOT-compatible</p>
<p>var json = JsonSerializer.Serialize(order);  // Uses reflection</p>
<p>var deserialized = JsonSerializer.Deserialize<OrderCreated>(json);</p>
<p></code></pre></p>

<strong>Whizbang MessageJsonContextGenerator</strong>:

<p>Whizbang automatically generates <code>JsonSerializerContext</code> for all messages:</p>

<pre><code class="language-csharp">// Generated by Whizbang.Generators.MessageJsonContextGenerator
<p>[JsonSerializable(typeof(CreateOrder))]</p>
<p>[JsonSerializable(typeof(OrderCreated))]</p>
<p>// ... all discovered messages</p>
<p>public partial class WhizbangJsonContext : JsonSerializerContext {</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Trim Warnings</h2>

<p>Enable trim analysis to detect non-AOT-safe code:</p>

<strong>Project file</strong>:

<pre><code class="language-xml"><PropertyGroup>
<p>  <PublishAot>true</PublishAot></p>
<p>  <EnableTrimAnalyzer>true</EnableTrimAnalyzer></p>
<p>  <SuppressTrimAnalysisWarnings>false</SuppressTrimAnalysisWarnings></p>
<p></PropertyGroup></p>
<p></code></pre></p>

<strong>Common warnings</strong>:

<pre><code class="language-">IL2026: Using member 'System.Type.GetType(string)' which has 'RequiresUnreferencedCodeAttribute' can break functionality when trimming application code.
<p></code></pre></p>

<strong>Fix</strong>:

<pre><code class="language-csharp">// ❌ BAD
<p>var type = Type.GetType("MyNamespace.MyClass");</p>

<p>// ✅ GOOD</p>
<p>var type = typeof(MyClass);  // Compile-time reference</p>
<p></code></pre></p>

<hr>

<h2>Dependency Injection (AOT-Compatible)</h2>

<p>Use constructor injection with explicit registrations:</p>

<strong>Program.cs</strong>:

<pre><code class="language-csharp">// ✅ GOOD - Explicit registration (AOT-compatible)
<p>builder.Services.AddSingleton<IReceptor<CreateOrder, OrderCreated>, CreateOrderReceptor>();</p>
<p>builder.Services.AddSingleton<IReceptor<UpdateOrder, OrderUpdated>, UpdateOrderReceptor>();</p>

<p>// ❌ BAD - Assembly scanning (NOT AOT-compatible)</p>
<p>builder.Services.Scan(scan => scan</p>
<p>  .FromAssemblyOf<CreateOrderReceptor>()</p>
<p>  .AddClasses(classes => classes.AssignableTo(typeof(IReceptor<,>)))</p>
<p>  .AsImplementedInterfaces()</p>
<p>  .WithSingletonLifetime()</p>
<p>);</p>
<p></code></pre></p>

<strong>Whizbang ReceptorDiscoveryGenerator</strong>:

<p>Whizbang automatically generates DI registrations:</p>

<pre><code class="language-csharp">// Generated by Whizbang.Generators.ReceptorDiscoveryGenerator
<p>public static class ReceptorServiceCollectionExtensions {</p>
<p>  public static IServiceCollection AddGeneratedReceptors(this IServiceCollection services) {</p>
<p>    services.AddSingleton<IReceptor<CreateOrder, OrderCreated>, CreateOrderReceptor>();</p>
<p>    services.AddSingleton<IReceptor<UpdateOrder, OrderUpdated>, UpdateOrderReceptor>();</p>
<p>    // ... all discovered receptors</p>
<p>    return services;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Entity Framework Core (AOT-Compatible)</h2>

<p>EF Core 10 added AOT support with compiled models:</p>

<strong>Generate compiled model</strong>:

<pre><code class="language-bash">dotnet ef dbcontext optimize -c OrderDbContext -o CompiledModels
<p></code></pre></p>

<strong>Generated code</strong>:

<pre><code class="language-csharp">// CompiledModels/OrderDbContextModel.cs
<p>public partial class OrderDbContextModel : RuntimeModel {</p>
<p>  static OrderDbContextModel() {</p>
<p>    var model = new OrderDbContextModel();</p>
<p>    model.Initialize();</p>
<p>    _instance = model;</p>
<p>  }</p>

<p>  private static OrderDbContextModel _instance;</p>
<p>  public static IModel Instance => _instance;</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:

<pre><code class="language-csharp">public class OrderDbContext : DbContext {
<p>  protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) {</p>
<p>    optionsBuilder</p>
<p>      .UseNpgsql("Host=localhost;Database=orders;...")</p>
<p>      .UseModel(OrderDbContextModel.Instance);  // Use compiled model</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Dapper (AOT-Compatible)</h2>

<p>Dapper works with AOT, but avoid dynamic SQL:</p>

<strong>✅ GOOD</strong>:

<pre><code class="language-csharp">var orders = await connection.QueryAsync<OrderRow>(
<p>  """</p>
<p>  SELECT order_id, customer_id, total_amount</p>
<p>  FROM orders</p>
<p>  WHERE customer_id = @CustomerId</p>
<p>  """,</p>
<p>  new { CustomerId = "cust-123" }</p>
<p>);</p>
<p></code></pre></p>

<strong>❌ BAD</strong>:

<pre><code class="language-csharp">var orders = await connection.QueryAsync(  // Dynamic type
<p>  "SELECT * FROM orders WHERE customer_id = @CustomerId",</p>
<p>  new { CustomerId = "cust-123" }</p>
<p>);</p>
<p></code></pre></p>

<hr>

<h2>Azure Service Bus (AOT-Compatible)</h2>

<p>Azure Service Bus SDK is AOT-compatible in .NET 10:</p>

<strong>Program.cs</strong>:

<pre><code class="language-csharp">builder.Services.AddSingleton<ServiceBusClient>(sp => {
<p>  var connectionString = builder.Configuration["AzureServiceBus:ConnectionString"];</p>
<p>  return new ServiceBusClient(connectionString);</p>
<p>});</p>

<p>builder.Services.AddSingleton<ServiceBusSender>(sp => {</p>
<p>  var client = sp.GetRequiredService<ServiceBusClient>();</p>
<p>  return client.CreateSender("orders");</p>
<p>});</p>
<p></code></pre></p>

<hr>

<h2>Testing AOT Compatibility</h2>

<h3>1. Compile with AOT</h3>

<pre><code class="language-bash">dotnet publish -c Release -r linux-x64
<p></code></pre></p>

<p>If compilation succeeds, your code is AOT-compatible.</p>

<h3>2. Run Trim Analysis</h3>

<pre><code class="language-bash">dotnet publish -c Release -r linux-x64 -p:EnableTrimAnalyzer=true
<p></code></pre></p>

<p>Review warnings in build output.</p>

<h3>3. Validate at Runtime</h3>

<pre><code class="language-bash">./bin/Release/net10.0/linux-x64/publish/ECommerce.OrderService.API
<p></code></pre></p>

<p>If it starts and handles requests, AOT is working correctly.</p>

<hr>

<h2>Performance Comparison</h2>

<strong>Benchmark: Order Creation (1000 requests)</strong>

<p>| Runtime | Startup | Total Time | Memory |</p>
<p>|---------|---------|------------|--------|</p>
<p>| <strong>JIT</strong> | 1.2s | 3.5s | 142 MB |</p>
<p>| <strong>AOT</strong> | 0.09s | 2.4s | 28 MB |</p>

<strong>AOT wins</strong>:
<ul><li>✅ <strong>13x faster startup</strong></li>
<li>✅ <strong>1.5x faster overall</strong> (less GC pressure)</li>
<li>✅ <strong>5x smaller memory</strong></li>
</ul>
<hr>

<h2>Troubleshooting AOT Issues</h2>

<h3>Issue 1: Reflection Warnings</h3>

<strong>Error</strong>:

<pre><code class="language-">IL2026: Using member 'Type.GetType(string)' which has 'RequiresUnreferencedCodeAttribute'
<p></code></pre></p>

<strong>Fix</strong>: Replace reflection with compile-time types:

<pre><code class="language-csharp">// ❌ BAD
<p>var type = Type.GetType(typeName);</p>

<p>// ✅ GOOD</p>
<p>var type = typeName switch {</p>
<p>  "CreateOrder" => typeof(CreateOrder),</p>
<p>  "UpdateOrder" => typeof(UpdateOrder),</p>
<p>  _ => throw new InvalidOperationException($"Unknown type: {typeName}")</p>
<p>};</p>
<p></code></pre></p>

<h3>Issue 2: JSON Deserialization Fails</h3>

<strong>Error</strong>:

<pre><code class="language-">System.InvalidOperationException: Serialization and deserialization of 'CreateOrder' is not supported.
<p></code></pre></p>

<strong>Fix</strong>: Add <code>[JsonSerializable(typeof(CreateOrder))]</code> to <code>JsonSerializerContext</code>.

<h3>Issue 3: Missing Dependencies</h3>

<strong>Error</strong>:

<pre><code class="language-">Unhandled exception. System.DllNotFoundException: Unable to load shared library 'libssl.so.3'
<p></code></pre></p>

<strong>Fix</strong>: Include native dependencies in publish:

<pre><code class="language-xml"><ItemGroup>
<p>  <RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" /></p>
<p>  <TrimmerRootAssembly Include="System.Private.CoreLib" /></p>
<p></ItemGroup></p>
<p></code></pre></p>

<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>Whizbang is AOT-Ready</strong> - Zero reflection, source-generated code</p>
<p>✅ <strong>13x Faster Startup</strong> - < 100ms vs. 1-2 seconds</p>
<p>✅ <strong>5x Smaller Memory</strong> - 28 MB vs. 142 MB</p>
<p>✅ <strong>JSON Source Generators</strong> - MessageJsonContextGenerator</p>
<p>✅ <strong>Trim Analysis</strong> - Detect non-AOT-safe code at build time</p>
<p>✅ <strong>EF Core Compiled Models</strong> - <code>dotnet ef dbcontext optimize</code></p>

<hr>

<h2>When to Use Native AOT</h2>

<p>| Scenario | Use AOT? |</p>
<p>|----------|----------|</p>
<p>| <strong>Serverless (Azure Functions, AWS Lambda)</strong> | ✅ Yes (fast cold starts) |</p>
<p>| <strong>Containers (Kubernetes)</strong> | ✅ Yes (smaller images) |</p>
<p>| <strong>Edge Computing</strong> | ✅ Yes (resource-constrained) |</p>
<p>| <strong>Long-Running Services</strong> | ⚠️ Maybe (JIT eventually optimizes better) |</p>
<p>| <strong>Developer Workstations</strong> | ❌ No (longer build times) |</p>

<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-advanced-topics-performance-tuning" class="doc-section">
  <h3>Performance Tuning</h3>
  <p class="doc-path"><code>v1.0.0/advanced-topics/performance-tuning</code></p>
  <p class="doc-description"><em>Optimize Whizbang performance - zero-allocation patterns, pooling, batching, and profiling</em></p>
  <div class="doc-content">

<h1>Performance Tuning</h1>

<p>Optimize <strong>Whizbang performance</strong> with zero-allocation patterns, object pooling, batching, database optimizations, and profiling techniques.</p>

<hr>

<h2>Performance Benchmarks</h2>

<p>| Metric | Target | Typical |</p>
<p>|--------|--------|---------|</p>
<p>| <strong>Dispatcher Latency</strong> | < 20ns | 15ns |</p>
<p>| <strong>Message Throughput</strong> | > 100K msg/sec | 150K msg/sec |</p>
<p>| <strong>Memory Allocations</strong> | Zero | 0 per dispatch |</p>
<p>| <strong>Database Round-Trips</strong> | 1 per batch | 1 per 100 messages |</p>

<hr>

<h2>Zero-Allocation Dispatch</h2>

<p>Whizbang achieves zero allocations through direct method invocation:</p>

<pre><code class="language-csharp">// Generated code (ReceptorDiscoveryGenerator)
<p>public class GeneratedDispatcher : IDispatcher {</p>
<p>  private readonly IServiceProvider _services;</p>

<p>  public async Task<TResponse> DispatchAsync<TRequest, TResponse>(</p>
<p>    TRequest request,</p>
<p>    CancellationToken ct = default</p>
<p>  ) where TRequest : ICommand<TResponse> {</p>
<p>    // Direct method invocation - zero reflection, zero allocations</p>
<p>    return request switch {</p>
<p>      CreateOrder cmd => (TResponse)(object)await DispatchCreateOrderAsync(cmd, ct),</p>
<p>      UpdateOrder cmd => (TResponse)(object)await DispatchUpdateOrderAsync(cmd, ct),</p>
<p>      _ => throw new InvalidOperationException($"No handler for {typeof(TRequest).Name}")</p>
<p>    };</p>
<p>  }</p>

<p>  private async Task<OrderCreated> DispatchCreateOrderAsync(</p>
<p>    CreateOrder command,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    var receptor = _services.GetRequiredService<IReceptor<CreateOrder, OrderCreated>>();</p>
<p>    return await receptor.HandleAsync(command, ct);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Why this is fast</strong>:
<ul><li>✅ <strong>No reflection</strong> - Direct method calls compiled ahead-of-time</li>
<li>✅ <strong>No allocations</strong> - No boxing, no temporary objects</li>
<li>✅ <strong>Inlineable</strong> - JIT can inline small methods</li>
<li>✅ <strong>Branch prediction</strong> - Pattern matching optimized by JIT</li>
</ul>
<hr>

<h2>Object Pooling</h2>

<h3>1. Policy Context Pooling</h3>

<p>Reuse <code>PolicyContext</code> objects to avoid allocations:</p>

<pre><code class="language-csharp">public static class PolicyContextPool {
<p>  private static readonly ObjectPool<PolicyContext> Pool =</p>
<p>    ObjectPool.Create<PolicyContext>();</p>

<p>  public static PolicyContext Rent(</p>
<p>    object message,</p>
<p>    MessageEnvelope envelope,</p>
<p>    IServiceProvider services,</p>
<p>    string environment</p>
<p>  ) {</p>
<p>    var context = Pool.Get();</p>
<p>    context.Message = message;</p>
<p>    context.Envelope = envelope;</p>
<p>    context.Services = services;</p>
<p>    context.Environment = environment;</p>
<p>    return context;</p>
<p>  }</p>

<p>  public static void Return(PolicyContext context) {</p>
<p>    context.Clear();  // Reset state</p>
<p>    Pool.Return(context);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:

<pre><code class="language-csharp">var context = PolicyContextPool.Rent(message, envelope, services, "production");
<p>try {</p>
<p>  var config = await policyEngine.MatchAsync(context);</p>
<p>} finally {</p>
<p>  PolicyContextPool.Return(context);  // ALWAYS return to pool</p>
<p>}</p>
<p></code></pre></p>

<strong>Benchmarks</strong>:
<ul><li>Without pooling: <strong>1000 allocations/sec</strong></li>
<li>With pooling: <strong>0 allocations/sec</strong> (after warmup)</li>
</ul>
<h3>2. Bulk Processing Pools</h3>

<p>Pool arrays for bulk operations:</p>

<pre><code class="language-csharp">public static class ArrayPool {
<p>  public static T[] Rent<T>(int minLength) {</p>
<p>    return System.Buffers.ArrayPool<T>.Shared.Rent(minLength);</p>
<p>  }</p>

<p>  public static void Return<T>(T[] array, bool clearArray = false) {</p>
<p>    System.Buffers.ArrayPool<T>.Shared.Return(array, clearArray);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:

<pre><code class="language-csharp">var buffer = ArrayPool.Rent<OutboxMessage>(100);
<p>try {</p>
<p>  var count = await ClaimWorkAsync(buffer);</p>
<p>  await ProcessMessagesAsync(buffer.AsSpan(0, count));</p>
<p>} finally {</p>
<p>  ArrayPool.Return(buffer, clearArray: true);</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Batching</h2>

<h3>1. Database Batching</h3>

<p>Process multiple messages in single database transaction:</p>

<pre><code class="language-csharp">public async Task<WorkBatch> ProcessWorkBatchAsync(
<p>  Guid instanceId,</p>
<p>  string serviceName,</p>
<p>  MessageCompletion[] outboxCompletions,  // Batch of 100</p>
<p>  MessageFailure[] outboxFailures,        // Batch of failed</p>
<p>  OutboxMessage[] newOutboxMessages,      // Batch of new</p>
<p>  CancellationToken ct = default</p>
<p>) {</p>
<p>  await using var tx = await _db.BeginTransactionAsync(ct);</p>

<p>  try {</p>
<p>    // 1. Delete completed messages (single query)</p>
<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      DELETE FROM outbox</p>
<p>      WHERE message_id = ANY(@MessageIds)</p>
<p>      """,</p>
<p>      new { MessageIds = outboxCompletions.Select(c => c.MessageId).ToArray() },</p>
<p>      transaction: tx</p>
<p>    );</p>

<p>    // 2. Update failed messages (single query)</p>
<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      UPDATE outbox</p>
<p>      SET</p>
<p>        attempts = attempts + 1,</p>
<p>        next_retry_at = NOW() + INTERVAL '5 minutes',</p>
<p>        error_message = failures.error</p>
<p>      FROM (SELECT UNNEST(@MessageIds::uuid[]) AS message_id, UNNEST(@Errors::text[]) AS error) failures</p>
<p>      WHERE outbox.message_id = failures.message_id</p>
<p>      """,</p>
<p>      new {</p>
<p>        MessageIds = outboxFailures.Select(f => f.MessageId).ToArray(),</p>
<p>        Errors = outboxFailures.Select(f => f.ErrorMessage).ToArray()</p>
<p>      },</p>
<p>      transaction: tx</p>
<p>    );</p>

<p>    // 3. Insert new messages (single query)</p>
<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO outbox (message_id, message_type, message_body, created_at)</p>
<p>      SELECT UNNEST(@MessageIds::uuid[]), UNNEST(@MessageTypes::text[]), UNNEST(@MessageBodies::jsonb[]), NOW()</p>
<p>      """,</p>
<p>      new {</p>
<p>        MessageIds = newOutboxMessages.Select(m => m.MessageId).ToArray(),</p>
<p>        MessageTypes = newOutboxMessages.Select(m => m.MessageType).ToArray(),</p>
<p>        MessageBodies = newOutboxMessages.Select(m => m.MessageBody).ToArray()</p>
<p>      },</p>
<p>      transaction: tx</p>
<p>    );</p>

<p>    await tx.CommitAsync(ct);</p>
<p>  } catch {</p>
<p>    await tx.RollbackAsync(ct);</p>
<p>    throw;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Performance</strong>:
<ul><li>Without batching: 100 round-trips (100ms @ 1ms each)</li>
<li>With batching: 3 round-trips (3ms)</li>
<li><strong>33x faster</strong></li>
</ul>
<h3>2. Message Publishing Batching</h3>

<p>Batch events before publishing to Service Bus:</p>

<pre><code class="language-csharp">public class BatchingPublisher {
<p>  private readonly Channel<OutboxMessage> _channel = Channel.CreateUnbounded<OutboxMessage>();</p>
<p>  private readonly ServiceBusSender _sender;</p>

<p>  public BatchingPublisher(ServiceBusSender sender) {</p>
<p>    _sender = sender;</p>
<p>    _ = Task.Run(ProcessBatchesAsync);</p>
<p>  }</p>

<p>  public async Task PublishAsync(OutboxMessage message, CancellationToken ct) {</p>
<p>    await _channel.Writer.WriteAsync(message, ct);</p>
<p>  }</p>

<p>  private async Task ProcessBatchesAsync() {</p>
<p>    await foreach (var batch in _channel.Reader.ReadAllAsync().Buffer(TimeSpan.FromMilliseconds(100), 100)) {</p>
<p>      var serviceBusBatch = await _sender.CreateMessageBatchAsync();</p>

<p>      foreach (var message in batch) {</p>
<p>        serviceBusBatch.TryAddMessage(new ServiceBusMessage(message.MessageBody));</p>
<p>      }</p>

<p>      await _sender.SendMessagesAsync(serviceBusBatch);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Performance</strong>:
<ul><li>Without batching: 100 Service Bus calls (500ms)</li>
<li>With batching: 1 Service Bus call (5ms)</li>
<li><strong>100x faster</strong></li>
</ul>
<hr>

<h2>Database Optimizations</h2>

<h3>1. Connection Pooling</h3>

<p>Configure aggressive connection pooling:</p>

<strong>appsettings.json</strong>:

<pre><code class="language-json">{
<p>  "ConnectionStrings": {</p>
<p>    "OrdersDb": "Host=localhost;Database=orders;Username=postgres;Password=postgres;Pooling=true;MinPoolSize=10;MaxPoolSize=100;ConnectionIdleLifetime=300"</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>2. Prepared Statements</h3>

<p>Use Dapper with prepared statements:</p>

<pre><code class="language-csharp">var orders = await _db.QueryAsync<OrderRow>(
<p>  """</p>
<p>  SELECT * FROM orders</p>
<p>  WHERE customer_id = @CustomerId AND created_at >= @StartDate</p>
<p>  """,</p>
<p>  new { CustomerId = "cust-123", StartDate = DateTime.UtcNow.AddDays(-30) },</p>
<p>  commandType: CommandType.Text,</p>
<p>  commandTimeout: 30</p>
<p>);</p>
<p></code></pre></p>

<p>PostgreSQL caches prepared statements automatically.</p>

<h3>3. Indexes</h3>

<p>Create indexes for common queries:</p>

<pre><code class="language-sql">-- Outbox queries (claim work)
<p>CREATE INDEX idx_outbox_claim ON outbox(created_at, partition_number)</p>
<p>  WHERE processed_at IS NULL;</p>

<p>-- Inbox queries (deduplication)</p>
<p>CREATE INDEX idx_inbox_message_id ON inbox(message_id)</p>
<p>  WHERE processed_at IS NULL;</p>

<p>-- Perspective checkpoints</p>
<p>CREATE INDEX idx_checkpoints_stream ON perspective_checkpoints(stream_id, perspective_name);</p>
<p></code></pre></p>

<h3>4. Partitioning</h3>

<p>Partition large tables by date:</p>

<pre><code class="language-sql">CREATE TABLE outbox (
<p>  message_id UUID NOT NULL,</p>
<p>  created_at TIMESTAMP NOT NULL,</p>
<p>  -- ... other columns</p>
<p>) PARTITION BY RANGE (created_at);</p>

<p>CREATE TABLE outbox_2024_12 PARTITION OF outbox</p>
<p>  FOR VALUES FROM ('2024-12-01') TO ('2025-01-01');</p>

<p>CREATE TABLE outbox_2025_01 PARTITION OF outbox</p>
<p>  FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>Faster queries (scan only relevant partitions)</li>
<li>Easier maintenance (drop old partitions)</li>
</ul>
<hr>

<h2>Profiling</h2>

<h3>1. BenchmarkDotNet</h3>

<p>Benchmark critical paths:</p>

<strong>CreateOrderBenchmark.cs</strong>:

<pre><code class="language-csharp">using BenchmarkDotNet.Attributes;

<p>[MemoryDiagnoser]</p>
<p>[SimpleJob(warmupCount: 3, iterationCount: 10)]</p>
<p>public class CreateOrderBenchmark {</p>
<p>  private CreateOrderReceptor _receptor;</p>
<p>  private CreateOrder _command;</p>

<p>  [GlobalSetup]</p>
<p>  public void Setup() {</p>
<p>    _receptor = new CreateOrderReceptor(...);</p>
<p>    _command = new CreateOrder(...);</p>
<p>  }</p>

<p>  [Benchmark]</p>
<p>  public async Task<OrderCreated> CreateOrder() {</p>
<p>    return await _receptor.HandleAsync(_command);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Run</strong>:

<pre><code class="language-bash">dotnet run -c Release --project Benchmarks
<p></code></pre></p>

<strong>Output</strong>:

<pre><code class="language-">|      Method |     Mean |   Error |  StdDev | Allocated |
<p>|------------ |---------:|--------:|--------:|----------:|</p>
<p>| CreateOrder | 125.3 μs | 2.34 μs | 2.19 μs |     512 B |</p>
<p></code></pre></p>

<h3>2. dotnet-trace</h3>

<p>Profile production workloads:</p>

<pre><code class="language-bash"># Start tracing
<p>dotnet-trace collect --process-id 1234 --profile cpu-sampling</p>

<h1>Stop after 30 seconds</h1>
<h1>Open trace file in PerfView or Visual Studio</h1>
<p></code></pre></p>

<h3>3. Application Insights</h3>

<p>Monitor performance in production:</p>

<pre><code class="language-csharp">builder.Services.AddApplicationInsightsTelemetry();

<p>builder.Services.AddOpenTelemetryMetrics(metrics => {</p>
<p>  metrics</p>
<p>    .AddMeter("Whizbang.*")</p>
<p>    .AddAspNetCoreInstrumentation()</p>
<p>    .AddHttpClientInstrumentation();</p>
<p>});</p>
<p></code></pre></p>

<strong>Query in Azure</strong>:

<pre><code class="language-kusto">requests
<p>| where timestamp > ago(1h)</p>
<p>| summarize avg(duration), percentile(duration, 95) by name</p>
<p>| order by avg_duration desc</p>
<p></code></pre></p>

<hr>

<h2>Memory Optimizations</h2>

<h3>1. Struct Value Types</h3>

<p>Use structs for small, immutable data:</p>

<pre><code class="language-csharp">// ✅ GOOD - Struct (stack-allocated)
<p>public readonly struct MessageId {</p>
<p>  private readonly Guid _value;</p>

<p>  public MessageId(Guid value) => _value = value;</p>

<p>  public override string ToString() => _value.ToString("N");</p>
<p>}</p>

<p>// ❌ BAD - Class (heap-allocated)</p>
<p>public class MessageId {</p>
<p>  public Guid Value { get; }</p>
<p>  public MessageId(Guid value) => Value = value;</p>
<p>}</p>
<p></code></pre></p>

<h3>2. Span<T> for Slicing</h3>

<p>Avoid allocations when slicing arrays:</p>

<pre><code class="language-csharp">// ❌ BAD - Allocates new array
<p>var subset = array.Skip(10).Take(50).ToArray();</p>

<p>// ✅ GOOD - No allocation</p>
<p>var subset = array.AsSpan(10, 50);</p>
<p></code></pre></p>

<h3>3. ValueTask for Hot Paths</h3>

<p>Use <code>ValueTask</code> for frequently called async methods:</p>

<pre><code class="language-csharp">// ✅ GOOD - ValueTask avoids allocation if completed synchronously
<p>public ValueTask<OrderCreated> HandleAsync(</p>
<p>  CreateOrder command,</p>
<p>  CancellationToken ct = default</p>
<p>) {</p>
<p>  // If cached, return synchronously (no allocation)</p>
<p>  if (_cache.TryGetValue(command.CustomerId, out var cached)) {</p>
<p>    return new ValueTask<OrderCreated>(cached);</p>
<p>  }</p>

<p>  // Otherwise, await async operation</p>
<p>  return new ValueTask<OrderCreated>(HandleSlowPathAsync(command, ct));</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Concurrency Optimizations</h2>

<h3>1. Parallel Processing</h3>

<p>Process perspectives in parallel:</p>

<pre><code class="language-csharp">public async Task HandleEventAsync(object @event, CancellationToken ct) {
<p>  var perspectives = GetPerspectives(@event);</p>

<p>  await Parallel.ForEachAsync(</p>
<p>    perspectives,</p>
<p>    new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount, CancellationToken = ct },</p>
<p>    async (perspective, ct) => {</p>
<p>      await perspective.HandleAsync(@event, ct);</p>
<p>    }</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<h3>2. Async Coordination</h3>

<p>Use <code>SemaphoreSlim</code> for async locking:</p>

<pre><code class="language-csharp">// ✅ GOOD - Async-friendly
<p>private readonly SemaphoreSlim _lock = new(1, 1);</p>

<p>public async Task ProcessAsync() {</p>
<p>  await _lock.WaitAsync();</p>
<p>  try {</p>
<p>    // Critical section</p>
<p>  } finally {</p>
<p>    _lock.Release();</p>
<p>  }</p>
<p>}</p>

<p>// ❌ BAD - Blocks thread</p>
<p>private readonly object _lock = new();</p>

<p>public async Task ProcessAsync() {</p>
<p>  lock (_lock) {  // Don't use lock() with async</p>
<p>    await SomeAsyncOperation();  // Deadlock risk</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>Zero Allocations</strong> - Direct method invocation, no reflection</p>
<p>✅ <strong>Object Pooling</strong> - Reuse PolicyContext, arrays (1000x fewer allocations)</p>
<p>✅ <strong>Batching</strong> - Database batching (33x faster), message batching (100x faster)</p>
<p>✅ <strong>Indexes</strong> - Optimize common queries</p>
<p>✅ <strong>Profiling</strong> - BenchmarkDotNet, dotnet-trace, Application Insights</p>
<p>✅ <strong>Span<T></strong> - Avoid array allocations</p>
<p>✅ <strong>ValueTask</strong> - Reduce allocations for hot paths</p>

<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-advanced-topics-scaling" class="doc-section">
  <h3>Scaling Patterns</h3>
  <p class="doc-path"><code>v1.0.0/advanced-topics/scaling</code></p>
  <p class="doc-description"><em>Horizontal scaling - autoscaling, partitioning, load balancing, and performance under load</em></p>
  <div class="doc-content">

<h1>Scaling Patterns</h1>

<p>Comprehensive guide to <strong>scaling Whizbang applications</strong> - horizontal autoscaling, database partitioning, load balancing strategies, and performance optimization under load.</p>

<hr>

<h2>Scaling Approaches</h2>

<p>| Approach | When to Use | Cost | Complexity |</p>
<p>|----------|-------------|------|------------|</p>
<p>| <strong>Vertical Scaling</strong> | Quick fix, single database | Medium | Low |</p>
<p>| <strong>Horizontal Scaling</strong> | Production systems | Low per unit | Medium |</p>
<p>| <strong>Database Partitioning</strong> | > 100M rows | Medium | High |</p>
<p>| <strong>Read Replicas</strong> | Read-heavy workloads | Medium | Low |</p>

<hr>

<h2>Horizontal Pod Autoscaling (HPA)</h2>

<strong>Automatically scale pods</strong> based on CPU, memory, or custom metrics.

<h3>CPU-Based Autoscaling</h3>

<strong>hpa.yaml</strong>:

<pre><code class="language-yaml">apiVersion: autoscaling/v2
<p>kind: HorizontalPodAutoscaler</p>
<p>metadata:</p>
<p>  name: order-service-hpa</p>
<p>spec:</p>
<p>  scaleTargetRef:</p>
<p>    apiVersion: apps/v1</p>
<p>    kind: Deployment</p>
<p>    name: order-service</p>
<p>  minReplicas: 3</p>
<p>  maxReplicas: 100</p>
<p>  metrics:</p>
<p>  - type: Resource</p>
<p>    resource:</p>
<p>      name: cpu</p>
<p>      target:</p>
<p>        type: Utilization</p>
<p>        averageUtilization: 70  # Target 70% CPU</p>
<p>  behavior:</p>
<p>    scaleUp:</p>
<p>      stabilizationWindowSeconds: 60  # Wait 60s before scaling up</p>
<p>      policies:</p>
<p>      - type: Percent</p>
<p>        value: 50  # Scale up by 50% of current pods</p>
<p>        periodSeconds: 60</p>
<p>      - type: Pods</p>
<p>        value: 5  # Or add 5 pods (whichever is larger)</p>
<p>        periodSeconds: 60</p>
<p>    scaleDown:</p>
<p>      stabilizationWindowSeconds: 300  # Wait 5min before scaling down</p>
<p>      policies:</p>
<p>      - type: Percent</p>
<p>        value: 10  # Scale down by 10% of current pods</p>
<p>        periodSeconds: 60</p>
<p></code></pre></p>

<strong>deployment.yaml</strong> (with resource limits):

<pre><code class="language-yaml">apiVersion: apps/v1
<p>kind: Deployment</p>
<p>metadata:</p>
<p>  name: order-service</p>
<p>spec:</p>
<p>  replicas: 3</p>
<p>  template:</p>
<p>    spec:</p>
<p>      containers:</p>
<p>      - name: order-service</p>
<p>        image: myregistry.azurecr.io/order-service:1.0.0</p>
<p>        resources:</p>
<p>          requests:</p>
<p>            cpu: 500m      # 0.5 CPU cores</p>
<p>            memory: 512Mi</p>
<p>          limits:</p>
<p>            cpu: 1000m     # 1 CPU core</p>
<p>            memory: 1Gi</p>
<p></code></pre></p>

<h3>Custom Metrics Autoscaling</h3>

<strong>hpa-custom.yaml</strong>:

<pre><code class="language-yaml">apiVersion: autoscaling/v2
<p>kind: HorizontalPodAutoscaler</p>
<p>metadata:</p>
<p>  name: order-service-hpa</p>
<p>spec:</p>
<p>  scaleTargetRef:</p>
<p>    apiVersion: apps/v1</p>
<p>    kind: Deployment</p>
<p>    name: order-service</p>
<p>  minReplicas: 3</p>
<p>  maxReplicas: 100</p>
<p>  metrics:</p>
<p>  - type: Pods</p>
<p>    pods:</p>
<p>      metric:</p>
<p>        name: http_requests_per_second</p>
<p>      target:</p>
<p>        type: AverageValue</p>
<p>        averageValue: "1000"  # 1000 req/sec per pod</p>
<p>  - type: Pods</p>
<p>    pods:</p>
<p>      metric:</p>
<p>        name: outbox_backlog</p>
<p>      target:</p>
<p>        type: AverageValue</p>
<p>        averageValue: "100"  # 100 messages per pod</p>
<p></code></pre></p>

<strong>Expose custom metrics</strong> (Prometheus Adapter):

<pre><code class="language-yaml">apiVersion: v1
<p>kind: ConfigMap</p>
<p>metadata:</p>
<p>  name: adapter-config</p>
<p>data:</p>
<p>  config.yaml: |</p>
<p>    rules:</p>
<p>    - seriesQuery: 'http_requests_total{namespace="production"}'</p>
<p>      resources:</p>
<p>        overrides:</p>
<p>          namespace: {resource: "namespace"}</p>
<p>          pod: {resource: "pod"}</p>
<p>      name:</p>
<p>        matches: "^http_requests_total$"</p>
<p>        as: "http_requests_per_second"</p>
<p>      metricsQuery: 'rate(http_requests_total[1m])'</p>
<p></code></pre></p>

<hr>

<h2>Database Scaling</h2>

<h3>Read Replicas</h3>

<strong>PostgreSQL with read replicas</strong>:

<pre><code class="language-">┌────────────────────────────────────────────────────┐
<p>│  Database Scaling - Read Replicas                 │</p>
<p>│                                                     │</p>
<p>│  ┌───────────────┐                                 │</p>
<p>│  │ Order Service │                                 │</p>
<p>│  └───────┬───────┘                                 │</p>
<p>│          │                                          │</p>
<p>│          │ Writes                                   │</p>
<p>│          ▼                                          │</p>
<p>│  ┌────────────────┐                                │</p>
<p>│  │ Primary (Write)│──────┐                         │</p>
<p>│  └────────────────┘      │ Replication             │</p>
<p>│                          │                          │</p>
<p>│                     ┌────┴────┐                    │</p>
<p>│                     │         │                     │</p>
<p>│                     ▼         ▼                     │</p>
<p>│              ┌─────────┐ ┌─────────┐               │</p>
<p>│              │Replica-1│ │Replica-2│               │</p>
<p>│              │ (Read)  │ │ (Read)  │               │</p>
<p>│              └─────────┘ └─────────┘               │</p>
<p>│                     ▲         ▲                     │</p>
<p>│                     │ Reads   │                     │</p>
<p>│                     └─────────┘                     │</p>
<p>│                          │                          │</p>
<p>│                  ┌───────┴────────┐                │</p>
<p>│                  │  Order Service │                │</p>
<p>│                  │  (Read Queries)│                │</p>
<p>│                  └────────────────┘                │</p>
<p>└────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Connection factory</strong>:

<pre><code class="language-csharp">public interface IDbConnectionFactory {
<p>  Task<IDbConnection> CreateWriteConnectionAsync(CancellationToken ct = default);</p>
<p>  Task<IDbConnection> CreateReadConnectionAsync(CancellationToken ct = default);</p>
<p>}</p>

<p>public class PostgresConnectionFactory : IDbConnectionFactory {</p>
<p>  private readonly IConfiguration _config;</p>
<p>  private readonly Random _random = new();</p>

<p>  public async Task<IDbConnection> CreateWriteConnectionAsync(CancellationToken ct) {</p>
<p>    var connectionString = _config["Database:Primary:ConnectionString"];</p>
<p>    var connection = new NpgsqlConnection(connectionString);</p>
<p>    await connection.OpenAsync(ct);</p>
<p>    return connection;</p>
<p>  }</p>

<p>  public async Task<IDbConnection> CreateReadConnectionAsync(CancellationToken ct) {</p>
<p>    // Load balance across read replicas</p>
<p>    var replicas = _config.GetSection("Database:ReadReplicas").Get<string[]>();</p>
<p>    var connectionString = replicas[_random.Next(replicas.Length)];</p>

<p>    var connection = new NpgsqlConnection(connectionString);</p>
<p>    await connection.OpenAsync(ct);</p>
<p>    return connection;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>appsettings.json</strong>:

<pre><code class="language-json">{
<p>  "Database": {</p>
<p>    "Primary": {</p>
<p>      "ConnectionString": "Host=primary.postgres;Database=orders;..."</p>
<p>    },</p>
<p>    "ReadReplicas": [</p>
<p>      "Host=replica1.postgres;Database=orders;...",</p>
<p>      "Host=replica2.postgres;Database=orders;..."</p>
<p>    ]</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:

<pre><code class="language-csharp">// Write operations use primary
<p>public async Task<OrderCreated> HandleAsync(CreateOrder command, CancellationToken ct) {</p>
<p>  await using var connection = await _dbFactory.CreateWriteConnectionAsync(ct);</p>
<p>  // Insert order...</p>
<p>}</p>

<p>// Read operations use replicas</p>
<p>public async Task<OrderRow?> GetOrderAsync(string orderId, CancellationToken ct) {</p>
<p>  await using var connection = await _dbFactory.CreateReadConnectionAsync(ct);</p>
<p>  return await connection.QuerySingleOrDefaultAsync<OrderRow>(</p>
<p>    "SELECT * FROM orders WHERE order_id = @OrderId",</p>
<p>    new { OrderId = orderId }</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<h3>Table Partitioning</h3>

<strong>Partition by date</strong> (e.g., monthly partitions):

<pre><code class="language-sql">-- Create partitioned table
<p>CREATE TABLE orders (</p>
<p>  order_id UUID NOT NULL,</p>
<p>  customer_id TEXT NOT NULL,</p>
<p>  total_amount DECIMAL(18,2) NOT NULL,</p>
<p>  created_at TIMESTAMP NOT NULL</p>
<p>) PARTITION BY RANGE (created_at);</p>

<p>-- Create partitions</p>
<p>CREATE TABLE orders_2024_12 PARTITION OF orders</p>
<p>  FOR VALUES FROM ('2024-12-01') TO ('2025-01-01');</p>

<p>CREATE TABLE orders_2025_01 PARTITION OF orders</p>
<p>  FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');</p>

<p>CREATE TABLE orders_2025_02 PARTITION OF orders</p>
<p>  FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');</p>

<p>-- Create indexes on each partition</p>
<p>CREATE INDEX idx_orders_2024_12_customer ON orders_2024_12(customer_id);</p>
<p>CREATE INDEX idx_orders_2025_01_customer ON orders_2025_01(customer_id);</p>
<p>CREATE INDEX idx_orders_2025_02_customer ON orders_2025_02(customer_id);</p>
<p></code></pre></p>

<strong>Automated partition management</strong>:

<pre><code class="language-csharp">public class PartitionManagementService : BackgroundService {
<p>  private readonly IDbConnection _db;</p>
<p>  private readonly ILogger<PartitionManagementService> _logger;</p>

<p>  protected override async Task ExecuteAsync(CancellationToken ct) {</p>
<p>    while (!ct.IsCancellationRequested) {</p>
<p>      try {</p>
<p>        await CreateNextMonthPartitionAsync(ct);</p>
<p>        await DropOldPartitionsAsync(ct);</p>
<p>      } catch (Exception ex) {</p>
<p>        _logger.LogError(ex, "Failed to manage partitions");</p>
<p>      }</p>

<p>      // Run daily</p>
<p>      await Task.Delay(TimeSpan.FromDays(1), ct);</p>
<p>    }</p>
<p>  }</p>

<p>  private async Task CreateNextMonthPartitionAsync(CancellationToken ct) {</p>
<p>    var nextMonth = DateTime.UtcNow.AddMonths(2).ToString("yyyy-MM");</p>
<p>    var startDate = $"{nextMonth}-01";</p>
<p>    var endDate = DateTime.Parse(startDate).AddMonths(1).ToString("yyyy-MM-dd");</p>

<p>    _logger.LogInformation("Creating partition for {NextMonth}", nextMonth);</p>

<p>    await _db.ExecuteAsync($"""</p>
<p>      CREATE TABLE IF NOT EXISTS orders_{nextMonth.Replace("-", "_")} PARTITION OF orders</p>
<p>        FOR VALUES FROM ('{startDate}') TO ('{endDate}')</p>
<p>      """);</p>

<p>    await _db.ExecuteAsync($"""</p>
<p>      CREATE INDEX IF NOT EXISTS idx_orders_{nextMonth.Replace("-", "_")}_customer</p>
<p>        ON orders_{nextMonth.Replace("-", "_")}(customer_id)</p>
<p>      """);</p>
<p>  }</p>

<p>  private async Task DropOldPartitionsAsync(CancellationToken ct) {</p>
<p>    // Drop partitions older than 2 years</p>
<p>    var cutoffDate = DateTime.UtcNow.AddYears(-2);</p>
<p>    var cutoffMonth = cutoffDate.ToString("yyyy_MM");</p>

<p>    _logger.LogInformation("Dropping partitions older than {CutoffMonth}", cutoffMonth);</p>

<p>    await _db.ExecuteAsync($"DROP TABLE IF EXISTS orders_{cutoffMonth}");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Partition by Hash (Customer ID)</h3>

<pre><code class="language-sql">-- Partition by hash (distribute evenly across partitions)
<p>CREATE TABLE orders (</p>
<p>  order_id UUID NOT NULL,</p>
<p>  customer_id TEXT NOT NULL,</p>
<p>  total_amount DECIMAL(18,2) NOT NULL,</p>
<p>  created_at TIMESTAMP NOT NULL</p>
<p>) PARTITION BY HASH (customer_id);</p>

<p>-- Create 8 partitions</p>
<p>CREATE TABLE orders_0 PARTITION OF orders FOR VALUES WITH (MODULUS 8, REMAINDER 0);</p>
<p>CREATE TABLE orders_1 PARTITION OF orders FOR VALUES WITH (MODULUS 8, REMAINDER 1);</p>
<p>CREATE TABLE orders_2 PARTITION OF orders FOR VALUES WITH (MODULUS 8, REMAINDER 2);</p>
<p>CREATE TABLE orders_3 PARTITION OF orders FOR VALUES WITH (MODULUS 8, REMAINDER 3);</p>
<p>CREATE TABLE orders_4 PARTITION OF orders FOR VALUES WITH (MODULUS 8, REMAINDER 4);</p>
<p>CREATE TABLE orders_5 PARTITION OF orders FOR VALUES WITH (MODULUS 8, REMAINDER 5);</p>
<p>CREATE TABLE orders_6 PARTITION OF orders FOR VALUES WITH (MODULUS 8, REMAINDER 6);</p>
<p>CREATE TABLE orders_7 PARTITION OF orders FOR VALUES WITH (MODULUS 8, REMAINDER 7);</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ Queries scan only relevant partition(s)</li>
<li>✅ Easier maintenance (drop old partitions)</li>
<li>✅ Better index performance (smaller indexes)</li>
</ul>
<hr>

<h2>Outbox/Inbox Partitioning</h2>

<h3>Partition by Instance</h3>

<strong>Multiple instances claim work from different partitions</strong>:

<pre><code class="language-sql">CREATE TABLE outbox (
<p>  message_id UUID PRIMARY KEY,</p>
<p>  partition_number INT NOT NULL,  -- 0-9 (10 partitions)</p>
<p>  message_type TEXT NOT NULL,</p>
<p>  message_body JSONB NOT NULL,</p>
<p>  created_at TIMESTAMP NOT NULL,</p>
<p>  processed_at TIMESTAMP NULL</p>
<p>);</p>

<p>CREATE INDEX idx_outbox_partition ON outbox(partition_number, created_at)</p>
<p>  WHERE processed_at IS NULL;</p>
<p></code></pre></p>

<strong>Claim work from specific partition</strong>:

<pre><code class="language-csharp">public async Task<OutboxMessage[]> ClaimWorkAsync(
<p>  Guid instanceId,</p>
<p>  int partitionNumber,</p>
<p>  int batchSize,</p>
<p>  CancellationToken ct = default</p>
<p>) {</p>
<p>  return await _db.QueryAsync<OutboxMessage>(</p>
<p>    """</p>
<p>    UPDATE outbox</p>
<p>    SET processed_at = NOW(), processed_by = @InstanceId</p>
<p>    WHERE message_id IN (</p>
<p>      SELECT message_id</p>
<p>      FROM outbox</p>
<p>      WHERE partition_number = @PartitionNumber</p>
<p>        AND processed_at IS NULL</p>
<p>      ORDER BY created_at</p>
<p>      LIMIT @BatchSize</p>
<p>      FOR UPDATE SKIP LOCKED</p>
<p>    )</p>
<p>    RETURNING *</p>
<p>    """,</p>
<p>    new { InstanceId = instanceId, PartitionNumber = partitionNumber, BatchSize = batchSize }</p>
<p>  ).ToArray();</p>
<p>}</p>
<p></code></pre></p>

<strong>Assign partition to instance</strong>:

<pre><code class="language-csharp">public class OutboxWorker : BackgroundService {
<p>  private readonly int _partitionNumber;</p>

<p>  public OutboxWorker(IConfiguration config) {</p>
<p>    // Assign partition based on instance index (K8s pod ordinal)</p>
<p>    var podName = Environment.GetEnvironmentVariable("POD_NAME") ?? "pod-0";</p>
<p>    _partitionNumber = int.Parse(podName.Split('-').Last()) % 10;</p>
<p>  }</p>

<p>  protected override async Task ExecuteAsync(CancellationToken ct) {</p>
<p>    while (!ct.IsCancellationRequested) {</p>
<p>      var messages = await _outbox.ClaimWorkAsync(</p>
<p>        _instanceId,</p>
<p>        _partitionNumber,  // Only claim from assigned partition</p>
<p>        batchSize: 100,</p>
<p>        ct</p>
<p>      );</p>

<p>      await ProcessMessagesAsync(messages, ct);</p>
<p>      await Task.Delay(TimeSpan.FromSeconds(1), ct);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Load Balancing</h2>

<h3>Service Mesh (Istio)</h3>

<strong>destinationrule.yaml</strong> (connection pool settings):

<pre><code class="language-yaml">apiVersion: networking.istio.io/v1beta1
<p>kind: DestinationRule</p>
<p>metadata:</p>
<p>  name: order-service</p>
<p>spec:</p>
<p>  host: order-service</p>
<p>  trafficPolicy:</p>
<p>    connectionPool:</p>
<p>      tcp:</p>
<p>        maxConnections: 100</p>
<p>      http:</p>
<p>        http1MaxPendingRequests: 50</p>
<p>        http2MaxRequests: 100</p>
<p>        maxRequestsPerConnection: 2</p>
<p>    loadBalancer:</p>
<p>      simple: LEAST_REQUEST  # Route to pod with fewest active requests</p>
<p>    outlierDetection:</p>
<p>      consecutiveErrors: 5</p>
<p>      interval: 30s</p>
<p>      baseEjectionTime: 30s</p>
<p>      maxEjectionPercent: 50</p>
<p></code></pre></p>

<h3>Sticky Sessions (Session Affinity)</h3>

<strong>service.yaml</strong>:

<pre><code class="language-yaml">apiVersion: v1
<p>kind: Service</p>
<p>metadata:</p>
<p>  name: order-service</p>
<p>spec:</p>
<p>  selector:</p>
<p>    app: order-service</p>
<p>  sessionAffinity: ClientIP  # Route same client to same pod</p>
<p>  sessionAffinityConfig:</p>
<p>    clientIP:</p>
<p>      timeoutSeconds: 3600  # 1 hour</p>
<p>  ports:</p>
<p>  - protocol: TCP</p>
<p>    port: 80</p>
<p>    targetPort: 8080</p>
<p></code></pre></p>

<hr>

<h2>Caching</h2>

<h3>Distributed Cache (Redis)</h3>

<strong>Program.cs</strong>:

<pre><code class="language-csharp">builder.Services.AddStackExchangeRedisCache(options => {
<p>  options.Configuration = builder.Configuration["Redis:ConnectionString"];</p>
<p>  options.InstanceName = "whizbang:";</p>
<p>});</p>
<p></code></pre></p>

<strong>Usage</strong>:

<pre><code class="language-csharp">public class GetOrderReceptor : IReceptor<GetOrder, OrderRow?> {
<p>  private readonly IDistributedCache _cache;</p>
<p>  private readonly IDbConnection _db;</p>

<p>  public async Task<OrderRow?> HandleAsync(GetOrder query, CancellationToken ct) {</p>
<p>    var cacheKey = $"order:{query.OrderId}";</p>

<p>    // Try cache first</p>
<p>    var cached = await _cache.GetStringAsync(cacheKey, ct);</p>
<p>    if (cached != null) {</p>
<p>      return JsonSerializer.Deserialize<OrderRow>(cached);</p>
<p>    }</p>

<p>    // Cache miss - query database</p>
<p>    var order = await _db.QuerySingleOrDefaultAsync<OrderRow>(</p>
<p>      "SELECT * FROM orders WHERE order_id = @OrderId",</p>
<p>      new { OrderId = query.OrderId }</p>
<p>    );</p>

<p>    if (order != null) {</p>
<p>      // Cache for 5 minutes</p>
<p>      await _cache.SetStringAsync(</p>
<p>        cacheKey,</p>
<p>        JsonSerializer.Serialize(order),</p>
<p>        new DistributedCacheEntryOptions {</p>
<p>          AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5)</p>
<p>        },</p>
<p>        ct</p>
<p>      );</p>
<p>    }</p>

<p>    return order;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Cache Invalidation</h3>

<strong>OrderSummaryPerspective.cs</strong>:

<pre><code class="language-csharp">public async Task HandleAsync(OrderCreated @event, CancellationToken ct) {
<p>  // Update read model</p>
<p>  await _db.ExecuteAsync(</p>
<p>    "INSERT INTO order_summary (...) VALUES (...)"</p>
<p>  );</p>

<p>  // Invalidate cache</p>
<p>  await _cache.RemoveAsync($"order:{@event.OrderId}", ct);</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Connection Pooling</h2>

<h3>Npgsql Connection Pool</h3>

<strong>appsettings.json</strong>:

<pre><code class="language-json">{
<p>  "Database": {</p>
<p>    "ConnectionString": "Host=postgres;Database=orders;Username=app;Password=<em></em>*;Pooling=true;MinPoolSize=10;MaxPoolSize=100;ConnectionIdleLifetime=300"</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Connection pool metrics</strong>:

<pre><code class="language-csharp">public class ConnectionPoolMetrics {
<p>  private static readonly Gauge ActiveConnections = Metrics.CreateGauge(</p>
<p>    "npgsql_active_connections",</p>
<p>    "Number of active PostgreSQL connections"</p>
<p>  );</p>

<p>  public static void RecordMetrics() {</p>
<p>    var poolingDataSource = (NpgsqlDataSource)_dataSource;</p>
<p>    ActiveConnections.Set(poolingDataSource.Statistics.Idle + poolingDataSource.Statistics.Busy);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Rate Limiting</h2>

<h3>Distributed Rate Limiting (Redis)</h3>

<strong>RateLimitingMiddleware.cs</strong>:

<pre><code class="language-csharp">public class RateLimitingMiddleware {
<p>  private readonly RequestDelegate _next;</p>
<p>  private readonly IDistributedCache _cache;</p>

<p>  public async Task InvokeAsync(HttpContext context) {</p>
<p>    var userId = context.User.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "anonymous";</p>
<p>    var key = $"rate-limit:{userId}:{DateTime.UtcNow:yyyyMMddHHmm}";</p>

<p>    var countStr = await _cache.GetStringAsync(key);</p>
<p>    var count = int.Parse(countStr ?? "0");</p>

<p>    if (count >= 100) {</p>
<p>      context.Response.StatusCode = 429;</p>
<p>      await context.Response.WriteAsync("Rate limit exceeded");</p>
<p>      return;</p>
<p>    }</p>

<p>    await _cache.SetStringAsync(</p>
<p>      key,</p>
<p>      (count + 1).ToString(),</p>
<p>      new DistributedCacheEntryOptions {</p>
<p>        AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(1)</p>
<p>      }</p>
<p>    );</p>

<p>    await _next(context);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Load Testing</h2>

<h3>k6 Load Test</h3>

<strong>load-test.js</strong>:

<pre><code class="language-javascript">import http from 'k6/http';
<p>import { check, sleep } from 'k6';</p>

<p>export const options = {</p>
<p>  stages: [</p>
<p>    { duration: '2m', target: 100 },   // Ramp up to 100 users</p>
<p>    { duration: '5m', target: 100 },   // Stay at 100 users</p>
<p>    { duration: '2m', target: 200 },   // Ramp up to 200 users</p>
<p>    { duration: '5m', target: 200 },   // Stay at 200 users</p>
<p>    { duration: '2m', target: 0 },     // Ramp down to 0</p>
<p>  ],</p>
<p>  thresholds: {</p>
<p>    http_req_duration: ['p(95)<500'],  // 95% of requests < 500ms</p>
<p>    http_req_failed: ['rate<0.01'],    // Error rate < 1%</p>
<p>  },</p>
<p>};</p>

<p>export default function () {</p>
<p>  const payload = JSON.stringify({</p>
<p>    customerId: 'cust-123',</p>
<p>    items: [</p>
<p>      { productId: 'prod-456', quantity: 2, unitPrice: 19.99 }</p>
<p>    ]</p>
<p>  });</p>

<p>  const params = {</p>
<p>    headers: {</p>
<p>      'Content-Type': 'application/json',</p>
<p>      'Authorization': 'Bearer ...'</p>
<p>    },</p>
<p>  };</p>

<p>  const res = http.post('https://order-service.myapp.com/orders', payload, params);</p>

<p>  check(res, {</p>
<p>    'status is 201': (r) => r.status === 201,</p>
<p>    'response time < 500ms': (r) => r.timings.duration < 500,</p>
<p>  });</p>

<p>  sleep(1);</p>
<p>}</p>
<p></code></pre></p>

<strong>Run</strong>:

<pre><code class="language-bash">k6 run load-test.js
<p></code></pre></p>

<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>HPA</strong> - Autoscale pods based on CPU, memory, or custom metrics</p>
<p>✅ <strong>Read Replicas</strong> - Offload read traffic from primary database</p>
<p>✅ <strong>Partitioning</strong> - Improve query performance and maintenance</p>
<p>✅ <strong>Load Balancing</strong> - Distribute traffic evenly (LEAST_REQUEST)</p>
<p>✅ <strong>Caching</strong> - Reduce database load with Redis</p>
<p>✅ <strong>Connection Pooling</strong> - Reuse database connections</p>
<p>✅ <strong>Rate Limiting</strong> - Prevent abuse with distributed rate limiting</p>

<hr>

<h2>Scaling Checklist</h2>

<ul><li>[ ] HPA configured with appropriate min/max replicas</li>
<li>[ ] Resource requests/limits set on all pods</li>
<li>[ ] Read replicas configured for read-heavy workloads</li>
<li>[ ] Tables partitioned for > 100M rows</li>
<li>[ ] Indexes created for common queries</li>
<li>[ ] Redis cache configured with TTL</li>
<li>[ ] Connection pooling enabled (MinPoolSize=10, MaxPoolSize=100)</li>
<li>[ ] Load testing performed with k6</li>
<li>[ ] Metrics monitored (CPU, memory, request rate, error rate)</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-advanced-topics-security" class="doc-section">
  <h3>Security Best Practices</h3>
  <p class="doc-path"><code>v1.0.0/advanced-topics/security</code></p>
  <p class="doc-description"><em>Security guidelines - authentication, authorization, encryption, secrets management, OWASP Top 10</em></p>
  <div class="doc-content">

<h1>Security Best Practices</h1>

<p>Comprehensive <strong>security guide</strong> for Whizbang applications - authentication, authorization, data encryption, secrets management, and OWASP Top 10 mitigations.</p>

<hr>

<h2>Security Checklist</h2>

<p>| Category | Requirement | Status |</p>
<p>|----------|-------------|--------|</p>
<p>| <strong>Authentication</strong> | JWT with RS256 signing | ✅ |</p>
<p>| <strong>Authorization</strong> | Policy-based RBAC | ✅ |</p>
<p>| <strong>Encryption</strong> | TLS 1.3 in transit | ✅ |</p>
<p>| <strong>Encryption</strong> | AES-256 at rest | ✅ |</p>
<p>| <strong>Secrets</strong> | Azure Key Vault | ✅ |</p>
<p>| <strong>Input Validation</strong> | Command validation | ✅ |</p>
<p>| <strong>SQL Injection</strong> | Parameterized queries | ✅ |</p>
<p>| <strong>CSRF</strong> | SameSite cookies | ✅ |</p>

<hr>

<h2>Authentication</h2>

<h3>JWT with RS256</h3>

<strong>Why RS256 (asymmetric)?</strong>:
<ul><li>✅ Public key verification (no shared secret)</li>
<li>✅ Harder to compromise (private key stays on auth server)</li>
<li>✅ Standard for microservices</li>
</ul>
<strong>appsettings.json</strong>:

<pre><code class="language-json">{
<p>  "Authentication": {</p>
<p>    "Authority": "https://login.microsoftonline.com/{tenant-id}/v2.0",</p>
<p>    "Audience": "api://order-service",</p>
<p>    "ValidIssuer": "https://login.microsoftonline.com/{tenant-id}/v2.0"</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Program.cs</strong>:

<pre><code class="language-csharp">builder.Services
<p>  .AddAuthentication(JwtBearerDefaults.AuthenticationScheme)</p>
<p>  .AddJwtBearer(options => {</p>
<p>    options.Authority = builder.Configuration["Authentication:Authority"];</p>
<p>    options.Audience = builder.Configuration["Authentication:Audience"];</p>
<p>    options.TokenValidationParameters = new TokenValidationParameters {</p>
<p>      ValidateIssuer = true,</p>
<p>      ValidateAudience = true,</p>
<p>      ValidateLifetime = true,</p>
<p>      ValidateIssuerSigningKey = true,</p>
<p>      ValidIssuer = builder.Configuration["Authentication:ValidIssuer"],</p>
<p>      ClockSkew = TimeSpan.Zero  // No grace period for expired tokens</p>
<p>    };</p>
<p>  });</p>

<p>app.UseAuthentication();</p>
<p>app.UseAuthorization();</p>
<p></code></pre></p>

<h3>Require Authentication on Endpoints</h3>

<pre><code class="language-csharp">app.MapPost("/orders", async (
<p>  CreateOrder command,</p>
<p>  IDispatcher dispatcher,</p>
<p>  CancellationToken ct</p>
<p>) => {</p>
<p>  var result = await dispatcher.DispatchAsync<CreateOrder, OrderCreated>(command, ct);</p>
<p>  return Results.Created($"/orders/{result.OrderId}", result);</p>
<p>})</p>
<p>.RequireAuthorization();  // ✅ Require authentication</p>
<p></code></pre></p>

<hr>

<h2>Authorization</h2>

<h3>Policy-Based Authorization</h3>

<strong>Program.cs</strong>:

<pre><code class="language-csharp">builder.Services.AddAuthorizationBuilder()
<p>  .AddPolicy("CreateOrder", policy => policy</p>
<p>    .RequireAuthenticatedUser()</p>
<p>    .RequireClaim("scope", "orders.write"))</p>
<p>  .AddPolicy("ViewOrders", policy => policy</p>
<p>    .RequireAuthenticatedUser()</p>
<p>    .RequireClaim("scope", "orders.read"))</p>
<p>  .AddPolicy("AdminOnly", policy => policy</p>
<p>    .RequireAuthenticatedUser()</p>
<p>    .RequireRole("Admin"));</p>
<p></code></pre></p>

<strong>Usage</strong>:

<pre><code class="language-csharp">app.MapPost("/orders", async (
<p>  CreateOrder command,</p>
<p>  IDispatcher dispatcher,</p>
<p>  CancellationToken ct</p>
<p>) => {</p>
<p>  var result = await dispatcher.DispatchAsync<CreateOrder, OrderCreated>(command, ct);</p>
<p>  return Results.Created($"/orders/{result.OrderId}", result);</p>
<p>})</p>
<p>.RequireAuthorization("CreateOrder");  // ✅ Require specific policy</p>

<p>app.MapGet("/orders/{orderId}", async (</p>
<p>  string orderId,</p>
<p>  IDbConnection db</p>
<p>) => {</p>
<p>  var order = await db.QuerySingleOrDefaultAsync<OrderRow>(</p>
<p>    "SELECT * FROM orders WHERE order_id = @OrderId",</p>
<p>    new { OrderId = orderId }</p>
<p>  );</p>
<p>  return order is not null ? Results.Ok(order) : Results.NotFound();</p>
<p>})</p>
<p>.RequireAuthorization("ViewOrders");</p>
<p></code></pre></p>

<h3>Resource-Based Authorization</h3>

<strong>OrderAuthorizationHandler.cs</strong>:

<pre><code class="language-csharp">public class OrderAuthorizationHandler : AuthorizationHandler<OperationAuthorizationRequirement, OrderRow> {
<p>  protected override Task HandleRequirementAsync(</p>
<p>    AuthorizationHandlerContext context,</p>
<p>    OperationAuthorizationRequirement requirement,</p>
<p>    OrderRow order</p>
<p>  ) {</p>
<p>    var userId = context.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;</p>

<p>    // Users can only view their own orders (unless admin)</p>
<p>    if (requirement.Name == "View") {</p>
<p>      if (context.User.IsInRole("Admin") || order.CustomerId == userId) {</p>
<p>        context.Succeed(requirement);</p>
<p>      }</p>
<p>    }</p>

<p>    // Only admins can delete orders</p>
<p>    if (requirement.Name == "Delete") {</p>
<p>      if (context.User.IsInRole("Admin")) {</p>
<p>        context.Succeed(requirement);</p>
<p>      }</p>
<p>    }</p>

<p>    return Task.CompletedTask;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Registration</strong>:

<pre><code class="language-csharp">builder.Services.AddSingleton<IAuthorizationHandler, OrderAuthorizationHandler>();
<p></code></pre></p>

<strong>Usage</strong>:

<pre><code class="language-csharp">app.MapDelete("/orders/{orderId}", async (
<p>  string orderId,</p>
<p>  IDbConnection db,</p>
<p>  IAuthorizationService authz,</p>
<p>  HttpContext context</p>
<p>) => {</p>
<p>  var order = await db.QuerySingleOrDefaultAsync<OrderRow>(</p>
<p>    "SELECT * FROM orders WHERE order_id = @OrderId",</p>
<p>    new { OrderId = orderId }</p>
<p>  );</p>

<p>  if (order is null) {</p>
<p>    return Results.NotFound();</p>
<p>  }</p>

<p>  // Check authorization</p>
<p>  var authResult = await authz.AuthorizeAsync(</p>
<p>    context.User,</p>
<p>    order,</p>
<p>    new OperationAuthorizationRequirement { Name = "Delete" }</p>
<p>  );</p>

<p>  if (!authResult.Succeeded) {</p>
<p>    return Results.Forbid();</p>
<p>  }</p>

<p>  await db.ExecuteAsync(</p>
<p>    "DELETE FROM orders WHERE order_id = @OrderId",</p>
<p>    new { OrderId = orderId }</p>
<p>  );</p>

<p>  return Results.NoContent();</p>
<p>})</p>
<p>.RequireAuthorization();</p>
<p></code></pre></p>

<hr>

<h2>Encryption</h2>

<h3>TLS 1.3 (In Transit)</h3>

<strong>appsettings.json</strong>:

<pre><code class="language-json">{
<p>  "Kestrel": {</p>
<p>    "Endpoints": {</p>
<p>      "Https": {</p>
<p>        "Url": "https://0.0.0.0:443",</p>
<p>        "Certificate": {</p>
<p>          "Path": "/app/certs/certificate.pfx",</p>
<p>          "Password": "<em></em>*"</p>
<p>        },</p>
<p>        "Protocols": "Http1AndHttp2AndHttp3",</p>
<p>        "SslProtocols": ["Tls13"]</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>AES-256 Encryption (At Rest)</h3>

<strong>DataEncryptionService.cs</strong>:

<pre><code class="language-csharp">public interface IDataEncryptionService {
<p>  byte[] Encrypt(byte[] plaintext);</p>
<p>  byte[] Decrypt(byte[] ciphertext);</p>
<p>}</p>

<p>public class AesDataEncryptionService : IDataEncryptionService {</p>
<p>  private readonly byte[] _key;</p>

<p>  public AesDataEncryptionService(IConfiguration config) {</p>
<p>    // Get encryption key from Azure Key Vault</p>
<p>    _key = Convert.FromBase64String(config["Encryption:Key"]);</p>

<p>    if (_key.Length != 32) {</p>
<p>      throw new InvalidOperationException("Encryption key must be 256 bits (32 bytes)");</p>
<p>    }</p>
<p>  }</p>

<p>  public byte[] Encrypt(byte[] plaintext) {</p>
<p>    using var aes = Aes.Create();</p>
<p>    aes.Key = _key;</p>
<p>    aes.GenerateIV();  // Random IV for each encryption</p>

<p>    using var encryptor = aes.CreateEncryptor();</p>
<p>    using var ms = new MemoryStream();</p>

<p>    // Write IV first (needed for decryption)</p>
<p>    ms.Write(aes.IV, 0, aes.IV.Length);</p>

<p>    using (var cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write)) {</p>
<p>      cs.Write(plaintext, 0, plaintext.Length);</p>
<p>    }</p>

<p>    return ms.ToArray();</p>
<p>  }</p>

<p>  public byte[] Decrypt(byte[] ciphertext) {</p>
<p>    using var aes = Aes.Create();</p>
<p>    aes.Key = _key;</p>

<p>    // Read IV from ciphertext</p>
<p>    var iv = new byte[16];</p>
<p>    Array.Copy(ciphertext, 0, iv, 0, 16);</p>
<p>    aes.IV = iv;</p>

<p>    using var decryptor = aes.CreateDecryptor();</p>
<p>    using var ms = new MemoryStream(ciphertext, 16, ciphertext.Length - 16);</p>
<p>    using var cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read);</p>
<p>    using var result = new MemoryStream();</p>

<p>    cs.CopyTo(result);</p>
<p>    return result.ToArray();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:

<pre><code class="language-csharp">public async Task<PaymentProcessed> HandleAsync(
<p>  ProcessPayment command,</p>
<p>  CancellationToken ct = default</p>
<p>) {</p>
<p>  // Encrypt sensitive data before storing</p>
<p>  var encryptedCardNumber = _encryption.Encrypt(</p>
<p>    Encoding.UTF8.GetBytes(command.CardNumber)</p>
<p>  );</p>

<p>  await _db.ExecuteAsync(</p>
<p>    """</p>
<p>    INSERT INTO payments (payment_id, order_id, encrypted_card_number, created_at)</p>
<p>    VALUES (@PaymentId, @OrderId, @EncryptedCardNumber, NOW())</p>
<p>    """,</p>
<p>    new {</p>
<p>      PaymentId = paymentId,</p>
<p>      OrderId = command.OrderId,</p>
<p>      EncryptedCardNumber = encryptedCardNumber</p>
<p>    }</p>
<p>  );</p>

<p>  return new PaymentProcessed { PaymentId = paymentId };</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Secrets Management</h2>

<h3>Azure Key Vault</h3>

<strong>Program.cs</strong>:

<pre><code class="language-csharp">var keyVaultUri = new Uri(builder.Configuration["KeyVault:VaultUri"]);

<p>builder.Configuration.AddAzureKeyVault(</p>
<p>  keyVaultUri,</p>
<p>  new DefaultAzureCredential()</p>
<p>);</p>
<p></code></pre></p>

<strong>Azure Key Vault Secrets</strong>:

<pre><code class="language-bash"># Create secrets in Key Vault
<p>az keyvault secret set \</p>
<p>  --vault-name whizbang-kv \</p>
<p>  --name "Database--ConnectionString" \</p>
<p>  --value "Host=...;Database=orders;Username=app;Password=<em></em>*"</p>

<p>az keyvault secret set \</p>
<p>  --vault-name whizbang-kv \</p>
<p>  --name "AzureServiceBus--ConnectionString" \</p>
<p>  --value "Endpoint=sb://...;SharedAccessKeyName=...;SharedAccessKey=<em></em>*"</p>

<p>az keyvault secret set \</p>
<p>  --vault-name whizbang-kv \</p>
<p>  --name "Encryption--Key" \</p>
<p>  --value "base64-encoded-256-bit-key"</p>
<p></code></pre></p>

<strong>Usage</strong>:

<pre><code class="language-csharp">// Automatically resolved from Key Vault
<p>var connectionString = builder.Configuration["Database:ConnectionString"];</p>
<p>var serviceBusConnectionString = builder.Configuration["AzureServiceBus:ConnectionString"];</p>
<p>var encryptionKey = builder.Configuration["Encryption:Key"];</p>
<p></code></pre></p>

<h3>Managed Identity (Avoid Credentials)</h3>

<strong>appsettings.json</strong>:

<pre><code class="language-json">{
<p>  "KeyVault": {</p>
<p>    "VaultUri": "https://whizbang-kv.vault.azure.net/"</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>No credentials needed</strong> - Azure Managed Identity provides access:

<pre><code class="language-bash"># Assign Managed Identity to App Service
<p>az webapp identity assign --name whizbang-api --resource-group whizbang-rg</p>

<h1>Grant Key Vault access to Managed Identity</h1>
<p>az keyvault set-policy \</p>
<p>  --name whizbang-kv \</p>
<p>  --object-id <managed-identity-object-id> \</p>
<p>  --secret-permissions get list</p>
<p></code></pre></p>

<hr>

<h2>Input Validation</h2>

<h3>Command Validation</h3>

<strong>CreateOrderValidator.cs</strong>:

<pre><code class="language-csharp">public static class CreateOrderValidator {
<p>  public static ValidationResult Validate(CreateOrder command) {</p>
<p>    var errors = new List<string>();</p>

<p>    if (string.IsNullOrWhiteSpace(command.CustomerId)) {</p>
<p>      errors.Add("Customer ID is required");</p>
<p>    }</p>

<p>    if (command.Items.Length == 0) {</p>
<p>      errors.Add("Order must contain at least one item");</p>
<p>    }</p>

<p>    foreach (var item in command.Items) {</p>
<p>      if (item.Quantity <= 0) {</p>
<p>        errors.Add($"Item {item.ProductId}: Quantity must be greater than zero");</p>
<p>      }</p>

<p>      if (item.UnitPrice <= 0) {</p>
<p>        errors.Add($"Item {item.ProductId}: Unit price must be greater than zero");</p>
<p>      }</p>
<p>    }</p>

<p>    return errors.Count == 0</p>
<p>      ? ValidationResult.Success()</p>
<p>      : ValidationResult.Failure(errors);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>ValidationPolicy.cs</strong>:

<pre><code class="language-csharp">public class ValidationPolicy : IPolicy {
<p>  public async Task ApplyAsync(PolicyContext context, CancellationToken ct = default) {</p>
<p>    var result = context.Message switch {</p>
<p>      CreateOrder cmd => CreateOrderValidator.Validate(cmd),</p>
<p>      UpdateOrder cmd => UpdateOrderValidator.Validate(cmd),</p>
<p>      _ => ValidationResult.Success()</p>
<p>    };</p>

<p>    if (!result.IsSuccess) {</p>
<p>      throw new ValidationException(string.Join("; ", result.Errors));</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>SQL Injection Prevention</h3>

<strong>✅ ALWAYS use parameterized queries</strong>:

<pre><code class="language-csharp">// ✅ GOOD - Parameterized query (safe)
<p>var orders = await _db.QueryAsync<OrderRow>(</p>
<p>  """</p>
<p>  SELECT * FROM orders</p>
<p>  WHERE customer_id = @CustomerId AND created_at >= @StartDate</p>
<p>  """,</p>
<p>  new { CustomerId = customerId, StartDate = startDate }</p>
<p>);</p>

<p>// ❌ BAD - String interpolation (SQL injection risk)</p>
<p>var orders = await _db.QueryAsync<OrderRow>(</p>
<p>  $"SELECT * FROM orders WHERE customer_id = '{customerId}'"</p>
<p>);</p>
<p></code></pre></p>

<hr>

<h2>OWASP Top 10 Mitigations</h2>

<h3>1. Broken Access Control</h3>

<strong>✅ Mitigation</strong>: Policy-based authorization + resource-based authorization

<pre><code class="language-csharp">// Check user can access resource
<p>var authResult = await _authz.AuthorizeAsync(user, order, "View");</p>
<p>if (!authResult.Succeeded) {</p>
<p>  return Results.Forbid();</p>
<p>}</p>
<p></code></pre></p>

<h3>2. Cryptographic Failures</h3>

<strong>✅ Mitigation</strong>: TLS 1.3 + AES-256 encryption + Azure Key Vault

<pre><code class="language-csharp">// Encrypt sensitive data
<p>var encryptedData = _encryption.Encrypt(sensitiveData);</p>
<p></code></pre></p>

<h3>3. Injection</h3>

<strong>✅ Mitigation</strong>: Parameterized queries + input validation

<pre><code class="language-csharp">// Always use parameters
<p>await _db.ExecuteAsync(</p>
<p>  "INSERT INTO orders (...) VALUES (@Value)",</p>
<p>  new { Value = userInput }</p>
<p>);</p>
<p></code></pre></p>

<h3>4. Insecure Design</h3>

<strong>✅ Mitigation</strong>: Principle of least privilege + defense in depth

<pre><code class="language-csharp">// Multiple layers of security
<p>.RequireAuthorization("CreateOrder")  // Layer 1: Policy</p>
<p>.AddPolicy(new ValidationPolicy())    // Layer 2: Validation</p>
<p>.AddPolicy(new TenantIsolationPolicy())  // Layer 3: Tenant isolation</p>
<p></code></pre></p>

<h3>5. Security Misconfiguration</h3>

<strong>✅ Mitigation</strong>: Secure defaults + configuration validation

<pre><code class="language-csharp">// Validate configuration on startup
<p>var requiredSettings = new[] {</p>
<p>  "Database:ConnectionString",</p>
<p>  "AzureServiceBus:ConnectionString",</p>
<p>  "Encryption:Key"</p>
<p>};</p>

<p>foreach (var setting in requiredSettings) {</p>
<p>  if (string.IsNullOrEmpty(builder.Configuration[setting])) {</p>
<p>    throw new InvalidOperationException($"Missing required setting: {setting}");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>6. Vulnerable and Outdated Components</h3>

<strong>✅ Mitigation</strong>: Automated dependency scanning

<pre><code class="language-yaml"># .github/workflows/security-scan.yml
<p>name: Security Scan</p>

<p>on:</p>
<p>  push:</p>
<p>    branches: [main]</p>
<p>  schedule:</p>
<p>    - cron: '0 0 <em> </em> 0'  # Weekly</p>

<p>jobs:</p>
<p>  scan:</p>
<p>    runs-on: ubuntu-latest</p>
<p>    steps:</p>
<p>      - uses: actions/checkout@v4</p>
<p>      - name: Run Trivy vulnerability scanner</p>
<p>        uses: aquasecurity/trivy-action@master</p>
<p>        with:</p>
<p>          scan-type: 'fs'</p>
<p>          scan-ref: '.'</p>
<p>          format: 'sarif'</p>
<p>          output: 'trivy-results.sarif'</p>
<p>      - name: Upload results to GitHub Security</p>
<p>        uses: github/codeql-action/upload-sarif@v2</p>
<p>        with:</p>
<p>          sarif_file: 'trivy-results.sarif'</p>
<p></code></pre></p>

<h3>7. Identification and Authentication Failures</h3>

<strong>✅ Mitigation</strong>: JWT with short expiry + refresh tokens

<pre><code class="language-csharp">options.TokenValidationParameters = new TokenValidationParameters {
<p>  ValidateLifetime = true,</p>
<p>  ClockSkew = TimeSpan.Zero  // No grace period</p>
<p>};</p>
<p></code></pre></p>

<h3>8. Software and Data Integrity Failures</h3>

<strong>✅ Mitigation</strong>: Message signing + envelope validation

<pre><code class="language-csharp">public class MessageIntegrityPolicy : IPolicy {
<p>  public async Task ApplyAsync(PolicyContext context, CancellationToken ct = default) {</p>
<p>    var signature = context.Envelope.Headers.GetValueOrDefault("signature");</p>
<p>    if (string.IsNullOrEmpty(signature)) {</p>
<p>      throw new SecurityException("Missing message signature");</p>
<p>    }</p>

<p>    var expectedSignature = ComputeSignature(context.Message);</p>
<p>    if (signature != expectedSignature) {</p>
<p>      throw new SecurityException("Invalid message signature");</p>
<p>    }</p>
<p>  }</p>

<p>  private string ComputeSignature(object message) {</p>
<p>    var json = JsonSerializer.Serialize(message);</p>
<p>    var hash = SHA256.HashData(Encoding.UTF8.GetBytes(json));</p>
<p>    return Convert.ToBase64String(hash);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>9. Security Logging and Monitoring Failures</h3>

<strong>✅ Mitigation</strong>: Structured logging + Application Insights

<pre><code class="language-csharp">_logger.LogWarning(
<p>  "Unauthorized access attempt: User {UserId} attempted to access Order {OrderId}",</p>
<p>  userId,</p>
<p>  orderId</p>
<p>);</p>
<p></code></pre></p>

<h3>10. Server-Side Request Forgery (SSRF)</h3>

<strong>✅ Mitigation</strong>: Whitelist allowed hosts + URL validation

<pre><code class="language-csharp">public class UrlValidationPolicy : IPolicy {
<p>  private static readonly string[] AllowedHosts = [</p>
<p>    "api.stripe.com",</p>
<p>    "api.twilio.com"</p>
<p>  ];</p>

<p>  public async Task ApplyAsync(PolicyContext context, CancellationToken ct = default) {</p>
<p>    if (context.Message is IExternalApiCall apiCall) {</p>
<p>      var uri = new Uri(apiCall.Url);</p>
<p>      if (!AllowedHosts.Contains(uri.Host)) {</p>
<p>        throw new SecurityException($"Host not allowed: {uri.Host}");</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Security Headers</h2>

<strong>SecurityHeadersMiddleware.cs</strong>:

<pre><code class="language-csharp">app.Use(async (context, next) => {
<p>  // Prevent clickjacking</p>
<p>  context.Response.Headers.Append("X-Frame-Options", "DENY");</p>

<p>  // Prevent MIME sniffing</p>
<p>  context.Response.Headers.Append("X-Content-Type-Options", "nosniff");</p>

<p>  // Enable XSS protection</p>
<p>  context.Response.Headers.Append("X-XSS-Protection", "1; mode=block");</p>

<p>  // Content Security Policy</p>
<p>  context.Response.Headers.Append(</p>
<p>    "Content-Security-Policy",</p>
<p>    "default-src 'self'; script-src 'self'; style-src 'self'"</p>
<p>  );</p>

<p>  // Strict Transport Security (HSTS)</p>
<p>  context.Response.Headers.Append(</p>
<p>    "Strict-Transport-Security",</p>
<p>    "max-age=31536000; includeSubDomains"</p>
<p>  );</p>

<p>  await next();</p>
<p>});</p>
<p></code></pre></p>

<hr>

<h2>Rate Limiting</h2>

<strong>Program.cs</strong>:

<pre><code class="language-csharp">builder.Services.AddRateLimiter(options => {
<p>  options.AddFixedWindowLimiter("api", limiter => {</p>
<p>    limiter.PermitLimit = 100;</p>
<p>    limiter.Window = TimeSpan.FromMinutes(1);</p>
<p>    limiter.QueueProcessingOrder = QueueProcessingOrder.OldestFirst;</p>
<p>    limiter.QueueLimit = 10;</p>
<p>  });</p>
<p>});</p>

<p>app.UseRateLimiter();</p>
<p></code></pre></p>

<strong>Usage</strong>:

<pre><code class="language-csharp">app.MapPost("/orders", async (
<p>  CreateOrder command,</p>
<p>  IDispatcher dispatcher,</p>
<p>  CancellationToken ct</p>
<p>) => {</p>
<p>  var result = await dispatcher.DispatchAsync<CreateOrder, OrderCreated>(command, ct);</p>
<p>  return Results.Created($"/orders/{result.OrderId}", result);</p>
<p>})</p>
<p>.RequireAuthorization()</p>
<p>.RequireRateLimiting("api");</p>
<p></code></pre></p>

<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>JWT with RS256</strong> - Asymmetric signing for microservices</p>
<p>✅ <strong>Policy-Based Authorization</strong> - Fine-grained access control</p>
<p>✅ <strong>TLS 1.3 + AES-256</strong> - Encryption in transit and at rest</p>
<p>✅ <strong>Azure Key Vault</strong> - Centralized secrets management</p>
<p>✅ <strong>Input Validation</strong> - Validate all commands</p>
<p>✅ <strong>Parameterized Queries</strong> - Prevent SQL injection</p>
<p>✅ <strong>OWASP Top 10</strong> - Comprehensive mitigations</p>
<p>✅ <strong>Rate Limiting</strong> - Prevent abuse</p>

<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-advanced-topics-testing-receptors" class="doc-section">
  <h3>Testing Receptors &amp; Perspectives</h3>
  <p class="doc-path"><code>v1.0.0/advanced-topics/testing-receptors</code></p>
  <p class="doc-description"><em>Unit testing patterns for receptors and perspectives - mocking, fixtures, and test strategies</em></p>
  <div class="doc-content">

<h1>Testing Receptors & Perspectives</h1>

<p>Comprehensive <strong>testing strategies</strong> for receptors and perspectives using TUnit, mocking patterns, test fixtures, and integration testing techniques.</p>

<hr>

<h2>Testing Philosophy</h2>

<p>| Layer | Test Type | Coverage Target | Speed |</p>
<p>|-------|-----------|----------------|-------|</p>
<p>| <strong>Receptors</strong> | Unit Tests | 100% | < 10ms |</p>
<p>| <strong>Perspectives</strong> | Unit Tests | 100% | < 10ms |</p>
<p>| <strong>Integration</strong> | Integration Tests | Happy paths + error cases | < 500ms |</p>
<p>| <strong>End-to-End</strong> | E2E Tests | Critical user journeys | < 5s |</p>

<hr>

<h2>Testing Stack</h2>

<strong>Whizbang uses modern .NET testing tools</strong>:

<pre><code class="language-xml"><ItemGroup>
<p>  <PackageReference Include="TUnit" Version="1.0.0" /></p>
<p>  <PackageReference Include="TUnit.Assertions" Version="1.0.0" /></p>
<p>  <PackageReference Include="Rocks" Version="8.0.0" /></p>
<p>  <PackageReference Include="Bogus" Version="35.0.0" /></p>
<p>  <PackageReference Include="Testcontainers" Version="4.0.0" /></p>
<p></ItemGroup></p>
<p></code></pre></p>

<strong>Why these tools?</strong>:
<ul><li><strong>TUnit</strong> - Modern source-generation test framework (faster than xUnit)</li>
<li><strong>TUnit.Assertions</strong> - Fluent assertions native to TUnit</li>
<li><strong>Rocks</strong> - Source-generation mocking (AOT-compatible, faster than Moq)</li>
<li><strong>Bogus</strong> - Test data generation</li>
<li><strong>Testcontainers</strong> - Docker-based integration tests</li>
</ul>
<hr>

<h2>Unit Testing Receptors</h2>

<h3>Basic Receptor Test</h3>

<strong>CreateOrderReceptorTests.cs</strong>:

<pre><code class="language-csharp">using TUnit.Assertions;
<p>using TUnit.Core;</p>

<p>public class CreateOrderReceptorTests {</p>
<p>  [Test]</p>
<p>  public async Task HandleAsync_ValidOrder_ReturnsOrderCreated() {</p>
<p>    // Arrange</p>
<p>    var command = new CreateOrder {</p>
<p>      CustomerId = "cust-123",</p>
<p>      Items = [</p>
<p>        new OrderItem { ProductId = "prod-456", Quantity = 2, UnitPrice = 19.99m }</p>
<p>      ]</p>
<p>    };</p>

<p>    var mockDb = Rock.Create<IDbConnection>();</p>
<p>    mockDb.Methods(m => m.ExecuteAsync(Arg.Any<string>(), Arg.Any<object>(), Arg.Any<IDbTransaction>()))</p>
<p>      .Returns(Task.FromResult(1));</p>

<p>    var receptor = new CreateOrderReceptor(mockDb.Instance(), Mock.Of<ILogger<CreateOrderReceptor>>());</p>

<p>    // Act</p>
<p>    var result = await receptor.HandleAsync(command);</p>

<p>    // Assert</p>
<p>    await Assert.That(result).IsNotNull();</p>
<p>    await Assert.That(result.OrderId).IsNotNull();</p>
<p>    await Assert.That(result.CustomerId).IsEqualTo("cust-123");</p>
<p>    await Assert.That(result.TotalAmount).IsEqualTo(39.98m);</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task HandleAsync_EmptyOrder_ThrowsValidationException() {</p>
<p>    // Arrange</p>
<p>    var command = new CreateOrder {</p>
<p>      CustomerId = "cust-123",</p>
<p>      Items = []  // Empty items</p>
<p>    };</p>

<p>    var receptor = new CreateOrderReceptor(Mock.Of<IDbConnection>(), Mock.Of<ILogger<CreateOrderReceptor>>());</p>

<p>    // Act & Assert</p>
<p>    await Assert.That(() => receptor.HandleAsync(command))</p>
<p>      .ThrowsExactly<ValidationException>()</p>
<p>      .WithMessage("Order must contain at least one item");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Mocking with Rocks</h2>

<strong>Rocks</strong> generates mocks at compile-time using source generators (AOT-compatible):

<h3>Database Mocking</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task HandleAsync_DatabaseFailure_ThrowsException() {</p>
<p>  // Arrange</p>
<p>  var mockDb = Rock.Create<IDbConnection>();</p>
<p>  mockDb.Methods(m => m.BeginTransactionAsync(Arg.Any<CancellationToken>()))</p>
<p>    .Throws<InvalidOperationException>();</p>

<p>  var receptor = new CreateOrderReceptor(mockDb.Instance(), Mock.Of<ILogger<CreateOrderReceptor>>());</p>
<p>  var command = CreateValidOrder();</p>

<p>  // Act & Assert</p>
<p>  await Assert.That(() => receptor.HandleAsync(command))</p>
<p>    .ThrowsExactly<InvalidOperationException>();</p>
<p>}</p>
<p></code></pre></p>

<h3>Service Bus Mocking</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task HandleAsync_PublishesToServiceBus() {</p>
<p>  // Arrange</p>
<p>  var mockSender = Rock.Create<ServiceBusSender>();</p>
<p>  var capturedMessage = default(ServiceBusMessage);</p>

<p>  mockSender.Methods(m => m.SendMessageAsync(Arg.Any<ServiceBusMessage>(), Arg.Any<CancellationToken>()))</p>
<p>    .Callback<ServiceBusMessage, CancellationToken>((msg, ct) => {</p>
<p>      capturedMessage = msg;</p>
<p>      return Task.CompletedTask;</p>
<p>    });</p>

<p>  var receptor = new CreateOrderReceptor(Mock.Of<IDbConnection>(), mockSender.Instance());</p>
<p>  var command = CreateValidOrder();</p>

<p>  // Act</p>
<p>  await receptor.HandleAsync(command);</p>

<p>  // Assert</p>
<p>  await Assert.That(capturedMessage).IsNotNull();</p>
<p>  await Assert.That(capturedMessage.Subject).IsEqualTo("OrderCreated");</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Test Data Generation with Bogus</h2>

<strong>OrderTestData.cs</strong>:

<pre><code class="language-csharp">using Bogus;

<p>public static class OrderTestData {</p>
<p>  private static readonly Faker<CreateOrder> OrderFaker = new Faker<CreateOrder>()</p>
<p>    .RuleFor(o => o.CustomerId, f => $"cust-{f.Random.Guid()}")</p>
<p>    .RuleFor(o => o.Items, f => new[] {</p>
<p>      new OrderItem {</p>
<p>        ProductId = $"prod-{f.Random.Guid()}",</p>
<p>        Quantity = f.Random.Int(1, 10),</p>
<p>        UnitPrice = f.Finance.Amount(10, 100)</p>
<p>      }</p>
<p>    });</p>

<p>  public static CreateOrder CreateValidOrder() => OrderFaker.Generate();</p>

<p>  public static CreateOrder CreateOrderWithItems(int itemCount) {</p>
<p>    var order = OrderFaker.Generate();</p>
<p>    order.Items = Enumerable.Range(0, itemCount)</p>
<p>      .Select(_ => new OrderItem {</p>
<p>        ProductId = $"prod-{Guid.NewGuid()}",</p>
<p>        Quantity = Random.Shared.Next(1, 10),</p>
<p>        UnitPrice = Random.Shared.Next(10, 100)</p>
<p>      })</p>
<p>      .ToArray();</p>
<p>    return order;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:

<pre><code class="language-csharp">[Test]
<p>public async Task HandleAsync_MultipleItems_CalculatesTotalCorrectly() {</p>
<p>  // Arrange</p>
<p>  var order = OrderTestData.CreateOrderWithItems(5);</p>
<p>  var expectedTotal = order.Items.Sum(i => i.Quantity * i.UnitPrice);</p>

<p>  var receptor = new CreateOrderReceptor(Mock.Of<IDbConnection>());</p>

<p>  // Act</p>
<p>  var result = await receptor.HandleAsync(order);</p>

<p>  // Assert</p>
<p>  await Assert.That(result.TotalAmount).IsEqualTo(expectedTotal);</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Unit Testing Perspectives</h2>

<h3>Basic Perspective Test</h3>

<strong>OrderSummaryPerspectiveTests.cs</strong>:

<pre><code class="language-csharp">public class OrderSummaryPerspectiveTests {
<p>  [Test]</p>
<p>  public async Task HandleAsync_OrderCreated_InsertsOrderSummary() {</p>
<p>    // Arrange</p>
<p>    var @event = new OrderCreated {</p>
<p>      OrderId = "order-123",</p>
<p>      CustomerId = "cust-456",</p>
<p>      TotalAmount = 99.99m,</p>
<p>      CreatedAt = DateTime.UtcNow</p>
<p>    };</p>

<p>    var mockDb = Rock.Create<IDbConnection>();</p>
<p>    var capturedSql = default(string);</p>
<p>    var capturedParams = default(object);</p>

<p>    mockDb.Methods(m => m.ExecuteAsync(Arg.Any<string>(), Arg.Any<object>(), Arg.Any<IDbTransaction>()))</p>
<p>      .Callback<string, object, IDbTransaction>((sql, param, tx) => {</p>
<p>        capturedSql = sql;</p>
<p>        capturedParams = param;</p>
<p>        return Task.FromResult(1);</p>
<p>      });</p>

<p>    var perspective = new OrderSummaryPerspective(mockDb.Instance());</p>

<p>    // Act</p>
<p>    await perspective.HandleAsync(@event);</p>

<p>    // Assert</p>
<p>    await Assert.That(capturedSql).Contains("INSERT INTO order_summary");</p>
<p>    await Assert.That(capturedParams).IsNotNull();</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task HandleAsync_PaymentProcessed_UpdatesOrderSummary() {</p>
<p>    // Arrange</p>
<p>    var @event = new PaymentProcessed {</p>
<p>      OrderId = "order-123",</p>
<p>      PaymentId = "pay-789",</p>
<p>      Amount = 99.99m,</p>
<p>      ProcessedAt = DateTime.UtcNow</p>
<p>    };</p>

<p>    var mockDb = Rock.Create<IDbConnection>();</p>
<p>    var capturedSql = default(string);</p>

<p>    mockDb.Methods(m => m.ExecuteAsync(Arg.Any<string>(), Arg.Any<object>(), Arg.Any<IDbTransaction>()))</p>
<p>      .Callback<string, object, IDbTransaction>((sql, param, tx) => {</p>
<p>        capturedSql = sql;</p>
<p>        return Task.FromResult(1);</p>
<p>      });</p>

<p>    var perspective = new OrderSummaryPerspective(mockDb.Instance());</p>

<p>    // Act</p>
<p>    await perspective.HandleAsync(@event);</p>

<p>    // Assert</p>
<p>    await Assert.That(capturedSql).Contains("UPDATE order_summary");</p>
<p>    await Assert.That(capturedSql).Contains("payment_id = @PaymentId");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Test Fixtures</h2>

<strong>Shared test infrastructure</strong>:

<strong>DatabaseFixture.cs</strong>:

<pre><code class="language-csharp">public class DatabaseFixture : IAsyncLifetime {
<p>  public IDbConnection Connection { get; private set; } = null!;</p>

<p>  public async Task InitializeAsync() {</p>
<p>    Connection = new NpgsqlConnection("Host=localhost;Database=test_db;");</p>
<p>    await Connection.OpenAsync();</p>

<p>    // Create schema</p>
<p>    await Connection.ExecuteAsync("""</p>
<p>      CREATE TABLE IF NOT EXISTS orders (</p>
<p>        order_id TEXT PRIMARY KEY,</p>
<p>        customer_id TEXT NOT NULL,</p>
<p>        total_amount DECIMAL(18,2) NOT NULL,</p>
<p>        created_at TIMESTAMP NOT NULL</p>
<p>      )</p>
<p>      """);</p>
<p>  }</p>

<p>  public async Task DisposeAsync() {</p>
<p>    // Clean up</p>
<p>    await Connection.ExecuteAsync("DROP TABLE IF EXISTS orders");</p>
<p>    await Connection.DisposeAsync();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:

<pre><code class="language-csharp">public class CreateOrderReceptorIntegrationTests : IClassFixture<DatabaseFixture> {
<p>  private readonly DatabaseFixture _fixture;</p>

<p>  public CreateOrderReceptorIntegrationTests(DatabaseFixture fixture) {</p>
<p>    _fixture = fixture;</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task HandleAsync_WithRealDatabase_InsertsOrder() {</p>
<p>    // Arrange</p>
<p>    var receptor = new CreateOrderReceptor(_fixture.Connection);</p>
<p>    var command = OrderTestData.CreateValidOrder();</p>

<p>    // Act</p>
<p>    var result = await receptor.HandleAsync(command);</p>

<p>    // Assert</p>
<p>    var inserted = await _fixture.Connection.QuerySingleOrDefaultAsync<OrderRow>(</p>
<p>      "SELECT * FROM orders WHERE order_id = @OrderId",</p>
<p>      new { OrderId = result.OrderId }</p>
<p>    );</p>

<p>    await Assert.That(inserted).IsNotNull();</p>
<p>    await Assert.That(inserted.CustomerId).IsEqualTo(command.CustomerId);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Integration Testing with Testcontainers</h2>

<strong>PostgreSQL Container</strong>:

<pre><code class="language-csharp">using Testcontainers.PostgreSql;

<p>public class PostgresIntegrationTests : IAsyncLifetime {</p>
<p>  private PostgreSqlContainer _postgres = null!;</p>
<p>  private IDbConnection _connection = null!;</p>

<p>  public async Task InitializeAsync() {</p>
<p>    _postgres = new PostgreSqlBuilder()</p>
<p>      .WithImage("postgres:16")</p>
<p>      .WithDatabase("test_db")</p>
<p>      .WithUsername("postgres")</p>
<p>      .WithPassword("postgres")</p>
<p>      .Build();</p>

<p>    await _postgres.StartAsync();</p>

<p>    _connection = new NpgsqlConnection(_postgres.GetConnectionString());</p>
<p>    await _connection.OpenAsync();</p>

<p>    // Run migrations</p>
<p>    await _connection.ExecuteAsync(File.ReadAllText("schema.sql"));</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task HandleAsync_WithPostgres_FullIntegration() {</p>
<p>    // Arrange</p>
<p>    var receptor = new CreateOrderReceptor(_connection);</p>
<p>    var command = OrderTestData.CreateValidOrder();</p>

<p>    // Act</p>
<p>    var result = await receptor.HandleAsync(command);</p>

<p>    // Assert</p>
<p>    var order = await _connection.QuerySingleAsync<OrderRow>(</p>
<p>      "SELECT * FROM orders WHERE order_id = @OrderId",</p>
<p>      new { OrderId = result.OrderId }</p>
<p>    );</p>

<p>    await Assert.That(order.TotalAmount).IsEqualTo(result.TotalAmount);</p>
<p>  }</p>

<p>  public async Task DisposeAsync() {</p>
<p>    await _connection.DisposeAsync();</p>
<p>    await _postgres.DisposeAsync();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Azure Service Bus Container</strong>:

<pre><code class="language-csharp">using Testcontainers.Azurite;

<p>public class ServiceBusIntegrationTests : IAsyncLifetime {</p>
<p>  private AzuriteContainer _azurite = null!;</p>
<p>  private ServiceBusClient _client = null!;</p>

<p>  public async Task InitializeAsync() {</p>
<p>    _azurite = new AzuriteBuilder()</p>
<p>      .WithImage("mcr.microsoft.com/azure-storage/azurite:latest")</p>
<p>      .Build();</p>

<p>    await _azurite.StartAsync();</p>

<p>    _client = new ServiceBusClient(_azurite.GetConnectionString());</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task HandleAsync_PublishesToServiceBus_MessageReceived() {</p>
<p>    // Arrange</p>
<p>    var sender = _client.CreateSender("orders");</p>
<p>    var receiver = _client.CreateReceiver("orders");</p>

<p>    var @event = new OrderCreated {</p>
<p>      OrderId = "order-123",</p>
<p>      CustomerId = "cust-456",</p>
<p>      TotalAmount = 99.99m</p>
<p>    };</p>

<p>    // Act</p>
<p>    await sender.SendMessageAsync(new ServiceBusMessage(</p>
<p>      JsonSerializer.SerializeToUtf8Bytes(@event)</p>
<p>    ));</p>

<p>    // Assert</p>
<p>    var message = await receiver.ReceiveMessageAsync(TimeSpan.FromSeconds(5));</p>
<p>    await Assert.That(message).IsNotNull();</p>

<p>    var received = JsonSerializer.Deserialize<OrderCreated>(message.Body.ToArray());</p>
<p>    await Assert.That(received.OrderId).IsEqualTo("order-123");</p>
<p>  }</p>

<p>  public async Task DisposeAsync() {</p>
<p>    await _client.DisposeAsync();</p>
<p>    await _azurite.DisposeAsync();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Parameterized Tests</h2>

<strong>TUnit supports parameterized tests</strong>:

<pre><code class="language-csharp">public class OrderValidationTests {
<p>  [Test]</p>
<p>  [Arguments(0, "Quantity must be greater than zero")]</p>
<p>  [Arguments(-1, "Quantity must be greater than zero")]</p>
<p>  [Arguments(-100, "Quantity must be greater than zero")]</p>
<p>  public async Task HandleAsync_InvalidQuantity_ThrowsValidationException(</p>
<p>    int quantity,</p>
<p>    string expectedMessage</p>
<p>  ) {</p>
<p>    // Arrange</p>
<p>    var command = new CreateOrder {</p>
<p>      CustomerId = "cust-123",</p>
<p>      Items = [</p>
<p>        new OrderItem { ProductId = "prod-456", Quantity = quantity, UnitPrice = 19.99m }</p>
<p>      ]</p>
<p>    };</p>

<p>    var receptor = new CreateOrderReceptor(Mock.Of<IDbConnection>());</p>

<p>    // Act & Assert</p>
<p>    await Assert.That(() => receptor.HandleAsync(command))</p>
<p>      .ThrowsExactly<ValidationException>()</p>
<p>      .WithMessage(expectedMessage);</p>
<p>  }</p>

<p>  [Test]</p>
<p>  [Arguments("")]</p>
<p>  [Arguments(" ")]</p>
<p>  [Arguments(null)]</p>
<p>  public async Task HandleAsync_InvalidCustomerId_ThrowsValidationException(string customerId) {</p>
<p>    // Arrange</p>
<p>    var command = new CreateOrder {</p>
<p>      CustomerId = customerId,</p>
<p>      Items = [</p>
<p>        new OrderItem { ProductId = "prod-456", Quantity = 1, UnitPrice = 19.99m }</p>
<p>      ]</p>
<p>    };</p>

<p>    var receptor = new CreateOrderReceptor(Mock.Of<IDbConnection>());</p>

<p>    // Act & Assert</p>
<p>    await Assert.That(() => receptor.HandleAsync(command))</p>
<p>      .ThrowsExactly<ValidationException>()</p>
<p>      .WithMessage("Customer ID is required");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Async Testing Best Practices</h2>

<h3>1. Use <code>await</code> in Assertions</h3>

<pre><code class="language-csharp">// ✅ GOOD - Await TUnit assertions
<p>await Assert.That(result).IsNotNull();</p>
<p>await Assert.That(result.OrderId).IsEqualTo("order-123");</p>

<p>// ❌ BAD - Don't forget await</p>
<p>Assert.That(result).IsNotNull();  // Won't work in TUnit</p>
<p></code></pre></p>

<h3>2. Test Cancellation</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task HandleAsync_CancellationRequested_ThrowsOperationCanceledException() {</p>
<p>  // Arrange</p>
<p>  var cts = new CancellationTokenSource();</p>
<p>  cts.Cancel();</p>

<p>  var receptor = new CreateOrderReceptor(Mock.Of<IDbConnection>());</p>
<p>  var command = OrderTestData.CreateValidOrder();</p>

<p>  // Act & Assert</p>
<p>  await Assert.That(() => receptor.HandleAsync(command, cts.Token))</p>
<p>    .ThrowsExactly<OperationCanceledException>();</p>
<p>}</p>
<p></code></pre></p>

<h3>3. Test Timeout</h3>

<pre><code class="language-csharp">[Test]
<p>[Timeout(5000)]  // 5 seconds max</p>
<p>public async Task HandleAsync_SlowOperation_CompletesWithinTimeout() {</p>
<p>  // Arrange</p>
<p>  var receptor = new CreateOrderReceptor(Mock.Of<IDbConnection>());</p>
<p>  var command = OrderTestData.CreateValidOrder();</p>

<p>  // Act</p>
<p>  var result = await receptor.HandleAsync(command);</p>

<p>  // Assert</p>
<p>  await Assert.That(result).IsNotNull();</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Testing Policies</h2>

<strong>Testing custom policies</strong>:

<strong>PolicyTests.cs</strong>:

<pre><code class="language-csharp">public class TenantIsolationPolicyTests {
<p>  [Test]</p>
<p>  public async Task ApplyAsync_DifferentTenant_ThrowsUnauthorizedException() {</p>
<p>    // Arrange</p>
<p>    var context = new PolicyContext {</p>
<p>      Message = new CreateOrder { CustomerId = "cust-123" },</p>
<p>      Envelope = new MessageEnvelope {</p>
<p>        Headers = new Dictionary<string, string> {</p>
<p>          ["tenant-id"] = "tenant-A"</p>
<p>        }</p>
<p>      }</p>
<p>    };</p>

<p>    var policy = new TenantIsolationPolicy();</p>

<p>    // Assume current tenant is "tenant-B"</p>
<p>    TenantContext.CurrentTenantId = "tenant-B";</p>

<p>    // Act & Assert</p>
<p>    await Assert.That(() => policy.ApplyAsync(context))</p>
<p>      .ThrowsExactly<UnauthorizedException>()</p>
<p>      .WithMessage("Tenant mismatch");</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task ApplyAsync_SameTenant_Succeeds() {</p>
<p>    // Arrange</p>
<p>    var context = new PolicyContext {</p>
<p>      Message = new CreateOrder { CustomerId = "cust-123" },</p>
<p>      Envelope = new MessageEnvelope {</p>
<p>        Headers = new Dictionary<string, string> {</p>
<p>          ["tenant-id"] = "tenant-A"</p>
<p>        }</p>
<p>      }</p>
<p>    };</p>

<p>    var policy = new TenantIsolationPolicy();</p>
<p>    TenantContext.CurrentTenantId = "tenant-A";</p>

<p>    // Act</p>
<p>    await policy.ApplyAsync(context);</p>

<p>    // Assert - No exception thrown</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Code Coverage</h2>

<strong>Measure code coverage</strong>:

<pre><code class="language-bash">dotnet test --collect:"XPlat Code Coverage"
<p></code></pre></p>

<strong>Generate HTML report</strong>:

<pre><code class="language-bash">dotnet tool install -g dotnet-reportgenerator-globaltool

<p>reportgenerator \</p>
<p>  -reports:"<em></em>/coverage.cobertura.xml" \</p>
<p>  -targetdir:"coverage-report" \</p>
<p>  -reporttypes:Html</p>

<p>open coverage-report/index.html</p>
<p></code></pre></p>

<strong>Target coverage</strong>:
<ul><li><strong>Receptors</strong>: 100% (critical business logic)</li>
<li><strong>Perspectives</strong>: 100% (data consistency)</li>
<li><strong>Policies</strong>: 100% (security/validation)</li>
<li><strong>Infrastructure</strong>: 80%+ (lower priority)</li>
</ul>
<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>TUnit</strong> - Modern source-generation test framework</p>
<p>✅ <strong>Rocks</strong> - AOT-compatible mocking with source generators</p>
<p>✅ <strong>Bogus</strong> - Generate realistic test data</p>
<p>✅ <strong>Testcontainers</strong> - Docker-based integration tests</p>
<p>✅ <strong>100% Coverage</strong> - All receptors, perspectives, policies</p>
<p>✅ <strong>Parameterized Tests</strong> - Test multiple scenarios efficiently</p>
<p>✅ <strong>Async Testing</strong> - Proper async/await patterns</p>

<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-advanced-topics-troubleshooting" class="doc-section">
  <h3>Troubleshooting Guide</h3>
  <p class="doc-path"><code>v1.0.0/advanced-topics/troubleshooting</code></p>
  <p class="doc-description"><em>Common issues, debugging techniques, diagnostic tools, and solutions</em></p>
  <div class="doc-content">

<h1>Troubleshooting Guide</h1>

<p>Comprehensive <strong>troubleshooting guide</strong> for Whizbang applications - common issues, debugging techniques, diagnostic tools, and step-by-step solutions.</p>

<hr>

<h2>Common Issues</h2>

<p>| Issue | Symptom | Root Cause | Solution |</p>
<p>|-------|---------|------------|----------|</p>
<p>| <strong>No Handler Found</strong> | <code>InvalidOperationException</code> | Missing receptor registration | Check DI registration |</p>
<p>| <strong>Message Not Published</strong> | Events not reaching subscribers | Outbox stuck | Check outbox worker |</p>
<p>| <strong>Duplicate Processing</strong> | Message handled twice | Inbox not working | Check inbox deduplication |</p>
<p>| <strong>High Latency</strong> | Slow responses | Database query | Add indexes |</p>
<p>| <strong>Memory Leak</strong> | Memory grows indefinitely | Unclosed connections | Use <code>await using</code> |</p>

<hr>

<h2>Issue 1: No Handler Found</h2>

<h3>Symptom</h3>

<pre><code class="language-">System.InvalidOperationException: No handler registered for CreateOrder
<p></code></pre></p>

<h3>Diagnosis</h3>

<pre><code class="language-csharp">// Check DI container
<p>var dispatcher = serviceProvider.GetService<IDispatcher>();</p>
<p>var receptor = serviceProvider.GetService<IReceptor<CreateOrder, OrderCreated>>();</p>

<p>if (receptor is null) {</p>
<p>  Console.WriteLine("ERROR: Receptor not registered!");</p>
<p>}</p>
<p></code></pre></p>

<h3>Solution 1: Missing DI Registration</h3>

<strong>Problem</strong>:

<pre><code class="language-csharp">// ❌ Receptor not registered
<p>builder.Services.AddSingleton<IDispatcher, GeneratedDispatcher>();</p>
<p></code></pre></p>

<strong>Fix</strong>:

<pre><code class="language-csharp">// ✅ Register receptor
<p>builder.Services.AddSingleton<IDispatcher, GeneratedDispatcher>();</p>
<p>builder.Services.AddSingleton<IReceptor<CreateOrder, OrderCreated>, CreateOrderReceptor>();</p>
<p></code></pre></p>

<h3>Solution 2: Use Source-Generated Registration</h3>

<strong>Whizbang ReceptorDiscoveryGenerator</strong> automatically generates DI registrations:

<pre><code class="language-csharp">// Generated by Whizbang.Generators.ReceptorDiscoveryGenerator
<p>builder.Services.AddGeneratedReceptors();  // Registers all receptors</p>
<p></code></pre></p>

<hr>

<h2>Issue 2: Message Not Published</h2>

<h3>Symptom</h3>

<p>Events not reaching subscribers (no errors in logs).</p>

<h3>Diagnosis</h3>

<pre><code class="language-sql">-- Check outbox backlog
<p>SELECT COUNT(*) FROM outbox WHERE processed_at IS NULL;</p>

<p>-- If count > 0, outbox worker is stuck</p>
<p></code></pre></p>

<h3>Solution 1: Outbox Worker Not Running</h3>

<strong>Problem</strong>: Outbox worker background service not registered.

<strong>Fix</strong>:

<pre><code class="language-csharp">builder.Services.AddHostedService<OutboxWorker>();
<p></code></pre></p>

<h3>Solution 2: Database Transaction Not Committed</h3>

<strong>Problem</strong>:

<pre><code class="language-csharp">// ❌ Transaction never committed
<p>await using var tx = await _db.BeginTransactionAsync(ct);</p>

<p>await _db.ExecuteAsync("INSERT INTO orders (...)", transaction: tx);</p>
<p>await _db.ExecuteAsync("INSERT INTO outbox (...)", transaction: tx);</p>

<p>// Missing: await tx.CommitAsync(ct);</p>
<p></code></pre></p>

<strong>Fix</strong>:

<pre><code class="language-csharp">// ✅ Always commit transaction
<p>await using var tx = await _db.BeginTransactionAsync(ct);</p>

<p>try {</p>
<p>  await _db.ExecuteAsync("INSERT INTO orders (...)", transaction: tx);</p>
<p>  await _db.ExecuteAsync("INSERT INTO outbox (...)", transaction: tx);</p>

<p>  await tx.CommitAsync(ct);  // ✅ Commit</p>
<p>} catch {</p>
<p>  await tx.RollbackAsync(ct);</p>
<p>  throw;</p>
<p>}</p>
<p></code></pre></p>

<h3>Solution 3: Service Bus Connection String Wrong</h3>

<strong>Problem</strong>: Wrong connection string or permissions.

<strong>Diagnosis</strong>:

<pre><code class="language-bash"># Test Service Bus connection
<p>curl -X POST https://myservicebus.servicebus.windows.net/orders/messages \</p>
<p>  -H "Authorization: SharedAccessSignature ..." \</p>
<p>  -d '{"test": true}'</p>
<p></code></pre></p>

<strong>Fix</strong>:

<pre><code class="language-json">{
<p>  "AzureServiceBus": {</p>
<p>    "ConnectionString": "Endpoint=sb://myservicebus.servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=<em></em>*"</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Issue 3: Duplicate Processing</h2>

<h3>Symptom</h3>

<p>Message handled twice (duplicate database inserts).</p>

<h3>Diagnosis</h3>

<pre><code class="language-sql">-- Check inbox for duplicate messages
<p>SELECT message_id, COUNT(*) AS count</p>
<p>FROM inbox</p>
<p>GROUP BY message_id</p>
<p>HAVING COUNT(*) > 1;</p>
<p></code></pre></p>

<h3>Solution 1: Inbox Not Implemented</h3>

<strong>Problem</strong>: No inbox deduplication.

<strong>Fix</strong>: Implement inbox pattern:

<pre><code class="language-csharp">public async Task HandleAsync(OrderCreated @event, CancellationToken ct) {
<p>  await using var tx = await _db.BeginTransactionAsync(ct);</p>

<p>  try {</p>
<p>    // 1. Check inbox (deduplication)</p>
<p>    var exists = await _db.ExecuteScalarAsync<bool>(</p>
<p>      "SELECT EXISTS(SELECT 1 FROM inbox WHERE message_id = @MessageId)",</p>
<p>      new { MessageId = @event.MessageId },</p>
<p>      transaction: tx</p>
<p>    );</p>

<p>    if (exists) {</p>
<p>      _logger.LogWarning("Message {MessageId} already processed (duplicate)", @event.MessageId);</p>
<p>      await tx.CommitAsync(ct);</p>
<p>      return;  // ✅ Skip duplicate</p>
<p>    }</p>

<p>    // 2. Process message</p>
<p>    await _db.ExecuteAsync("UPDATE order_summary SET ...", transaction: tx);</p>

<p>    // 3. Record in inbox</p>
<p>    await _db.ExecuteAsync(</p>
<p>      "INSERT INTO inbox (message_id, processed_at) VALUES (@MessageId, NOW())",</p>
<p>      new { MessageId = @event.MessageId },</p>
<p>      transaction: tx</p>
<p>    );</p>

<p>    await tx.CommitAsync(ct);</p>
<p>  } catch {</p>
<p>    await tx.RollbackAsync(ct);</p>
<p>    throw;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Solution 2: Service Bus PeekLock Not Used</h3>

<strong>Problem</strong>: Using <code>ReceiveAndDelete</code> mode (at-most-once delivery).

<strong>Fix</strong>: Use <code>PeekLock</code> mode (at-least-once delivery):

<pre><code class="language-csharp">var processor = client.CreateProcessor("orders", new ServiceBusProcessorOptions {
<p>  ReceiveMode = ServiceBusReceiveMode.PeekLock,  // ✅ Use PeekLock</p>
<p>  MaxConcurrentCalls = 10</p>
<p>});</p>
<p></code></pre></p>

<hr>

<h2>Issue 4: High Latency</h2>

<h3>Symptom</h3>

<p>API responses taking > 1 second.</p>

<h3>Diagnosis</h3>

<strong>Application Insights query</strong>:

<pre><code class="language-kusto">requests
<p>| where timestamp > ago(1h)</p>
<p>| summarize p95 = percentile(duration, 95) by name</p>
<p>| where p95 > 1000  // > 1 second</p>
<p>| order by p95 desc</p>
<p></code></pre></p>

<strong>PostgreSQL slow query log</strong>:

<pre><code class="language-sql">-- Enable slow query log
<p>ALTER DATABASE orders SET log_min_duration_statement = 1000;  -- Log queries > 1s</p>

<p>-- View slow queries</p>
<p>SELECT query, mean_exec_time, calls</p>
<p>FROM pg_stat_statements</p>
<p>WHERE mean_exec_time > 1000</p>
<p>ORDER BY mean_exec_time DESC</p>
<p>LIMIT 10;</p>
<p></code></pre></p>

<h3>Solution 1: Missing Index</h3>

<strong>Problem</strong>: Full table scan on large table.

<strong>Diagnosis</strong>:

<pre><code class="language-sql">EXPLAIN ANALYZE
<p>SELECT * FROM orders WHERE customer_id = 'cust-123';</p>

<p>-- Output:</p>
<p>-- Seq Scan on orders (cost=0.00..100000.00 rows=1 width=100)</p>
<p>-- Planning Time: 0.5 ms</p>
<p>-- Execution Time: 1234.5 ms</p>
<p></code></pre></p>

<strong>Fix</strong>: Add index:

<pre><code class="language-sql">CREATE INDEX idx_orders_customer_id ON orders(customer_id);

<p>-- After index:</p>
<p>-- Index Scan using idx_orders_customer_id (cost=0.29..8.31 rows=1 width=100)</p>
<p>-- Planning Time: 0.5 ms</p>
<p>-- Execution Time: 1.2 ms</p>
<p></code></pre></p>

<h3>Solution 2: N+1 Query Problem</h3>

<strong>Problem</strong>:

<pre><code class="language-csharp">// ❌ N+1 queries (1 for orders, N for items)
<p>var orders = await _db.QueryAsync<OrderRow>("SELECT * FROM orders WHERE customer_id = @CustomerId");</p>

<p>foreach (var order in orders) {</p>
<p>  order.Items = await _db.QueryAsync<OrderItemRow>(</p>
<p>    "SELECT * FROM order_items WHERE order_id = @OrderId",</p>
<p>    new { OrderId = order.OrderId }</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<strong>Fix</strong>: Use JOIN or batch query:

<pre><code class="language-csharp">// ✅ Single query with JOIN
<p>var orders = await _db.QueryAsync<OrderRow, OrderItemRow, OrderRow>(</p>
<p>  """</p>
<p>  SELECT o.<em>, i.</em></p>
<p>  FROM orders o</p>
<p>  LEFT JOIN order_items i ON o.order_id = i.order_id</p>
<p>  WHERE o.customer_id = @CustomerId</p>
<p>  """,</p>
<p>  (order, item) => {</p>
<p>    order.Items.Add(item);</p>
<p>    return order;</p>
<p>  },</p>
<p>  new { CustomerId = customerId }</p>
<p>);</p>
<p></code></pre></p>

<hr>

<h2>Issue 5: Memory Leak</h2>

<h3>Symptom</h3>

<p>Memory usage grows indefinitely, eventually causing OOM.</p>

<h3>Diagnosis</h3>

<strong>dotnet-counters</strong>:

<pre><code class="language-bash">dotnet-counters monitor --process-id 1234 System.Runtime

<h1>Output:</h1>
<h1>[System.Runtime]</h1>
<h1>GC Heap Size (MB)                      500 -> 1000 -> 1500 -> 2000 (growing)</h1>
<h1>Gen 0 GC Count                         1000</h1>
<h1>Gen 1 GC Count                         100</h1>
<h1>Gen 2 GC Count                         10</h1>
<p></code></pre></p>

<strong>dotnet-gcdump</strong>:

<pre><code class="language-bash">dotnet-gcdump collect --process-id 1234
<p>dotnet-gcdump report gcdump_20250101_123456</p>
<p></code></pre></p>

<h3>Solution 1: Unclosed Connections</h3>

<strong>Problem</strong>:

<pre><code class="language-csharp">// ❌ Connection not disposed
<p>var connection = new NpgsqlConnection(connectionString);</p>
<p>await connection.OpenAsync();</p>

<p>// Process data...</p>

<p>// Missing: await connection.DisposeAsync();</p>
<p></code></pre></p>

<strong>Fix</strong>:

<pre><code class="language-csharp">// ✅ Use await using
<p>await using var connection = new NpgsqlConnection(connectionString);</p>
<p>await connection.OpenAsync();</p>

<p>// Process data...</p>

<p>// Automatically disposed</p>
<p></code></pre></p>

<h3>Solution 2: Event Handler Not Unsubscribed</h3>

<strong>Problem</strong>:

<pre><code class="language-csharp">// ❌ Event handler keeps object alive
<p>public class OrderProcessor {</p>
<p>  public OrderProcessor(IEventBus eventBus) {</p>
<p>    eventBus.OrderCreated += HandleOrderCreated;  // Never unsubscribed</p>
<p>  }</p>

<p>  private void HandleOrderCreated(OrderCreated @event) {</p>
<p>    // Process order...</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Fix</strong>:

<pre><code class="language-csharp">// ✅ Unsubscribe when disposed
<p>public class OrderProcessor : IDisposable {</p>
<p>  private readonly IEventBus _eventBus;</p>

<p>  public OrderProcessor(IEventBus eventBus) {</p>
<p>    _eventBus = eventBus;</p>
<p>    _eventBus.OrderCreated += HandleOrderCreated;</p>
<p>  }</p>

<p>  public void Dispose() {</p>
<p>    _eventBus.OrderCreated -= HandleOrderCreated;  // ✅ Unsubscribe</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Debugging Techniques</h2>

<h3>1. Enable Detailed Logging</h3>

<strong>appsettings.Development.json</strong>:

<pre><code class="language-json">{
<p>  "Logging": {</p>
<p>    "LogLevel": {</p>
<p>      "Default": "Debug",</p>
<p>      "Microsoft": "Information",</p>
<p>      "Whizbang": "Trace"</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>2. Use Correlation IDs</h3>

<pre><code class="language-csharp">public class CorrelationIdMiddleware {
<p>  private readonly RequestDelegate _next;</p>

<p>  public async Task InvokeAsync(HttpContext context) {</p>
<p>    var correlationId = context.Request.Headers["X-Correlation-ID"].FirstOrDefault()</p>
<p>      ?? Guid.NewGuid().ToString();</p>

<p>    context.Response.Headers.Add("X-Correlation-ID", correlationId);</p>

<p>    using (_logger.BeginScope(new Dictionary<string, object> {</p>
<p>      ["CorrelationId"] = correlationId</p>
<p>    })) {</p>
<p>      await _next(context);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Application Insights query</strong>:

<pre><code class="language-kusto">traces
<p>| where customDimensions.CorrelationId == "abc-123"</p>
<p>| order by timestamp asc</p>
<p></code></pre></p>

<h3>3. SQL Query Logging</h3>

<strong>Program.cs</strong>:

<pre><code class="language-csharp">builder.Logging.AddFilter("Microsoft.EntityFrameworkCore.Database.Command", LogLevel.Information);
<p></code></pre></p>

<strong>Output</strong>:

<pre><code class="language-">Executed DbCommand (123ms) [Parameters=[@CustomerId='cust-123'], CommandType='Text', CommandTimeout='30']
<p>SELECT * FROM orders WHERE customer_id = @CustomerId</p>
<p></code></pre></p>

<h3>4. Distributed Tracing</h3>

<strong>View trace in Application Insights</strong>:

<pre><code class="language-kusto">dependencies
<p>| where operation_Id == "abc-123"</p>
<p>| project timestamp, target, name, duration</p>
<p>| order by timestamp asc</p>

<p>// Output:</p>
<p>// timestamp                 target                    name                  duration</p>
<p>// 2025-01-01 12:00:00.000   postgres.myapp.com        SELECT * FROM orders  123ms</p>
<p>// 2025-01-01 12:00:00.150   servicebus.windows.net    Send message          45ms</p>
<p></code></pre></p>

<hr>

<h2>Diagnostic Tools</h2>

<h3>1. dotnet-counters (Live Metrics)</h3>

<pre><code class="language-bash"># Monitor live counters
<p>dotnet-counters monitor --process-id 1234</p>

<h1>Output:</h1>
<h1>[System.Runtime]</h1>
<h1>CPU Usage (%)                          45</h1>
<h1>GC Heap Size (MB)                      256</h1>
<h1>Gen 0 GC Count                         100</h1>
<h1>Gen 1 GC Count                         10</h1>
<h1>Gen 2 GC Count                         1</h1>
<h1>Exception Count                        5</h1>
<h1>ThreadPool Thread Count                25</h1>
<p></code></pre></p>

<h3>2. dotnet-trace (Performance Profiling)</h3>

<pre><code class="language-bash"># Collect trace
<p>dotnet-trace collect --process-id 1234 --profile cpu-sampling</p>

<h1>Convert to speedscope format</h1>
<p>dotnet-trace convert trace.nettrace --format speedscope</p>

<h1>Open in speedscope.app</h1>
<p></code></pre></p>

<h3>3. dotnet-dump (Memory Analysis)</h3>

<pre><code class="language-bash"># Capture memory dump
<p>dotnet-dump collect --process-id 1234</p>

<h1>Analyze dump</h1>
<p>dotnet-dump analyze dump_20250101_123456</p>

<h1>Commands:</h1>
<h1>> dumpheap -stat        # Object statistics</h1>
<h1>> gcroot <address>      # GC root analysis</h1>
<h1>> dumpheap -mt <type>   # Objects of specific type</h1>
<p></code></pre></p>

<h3>4. kubectl logs (Kubernetes)</h3>

<pre><code class="language-bash"># View logs
<p>kubectl logs order-service-abc123</p>

<h1>Follow logs</h1>
<p>kubectl logs -f order-service-abc123</p>

<h1>View logs from all pods</h1>
<p>kubectl logs -l app=order-service --tail=100</p>

<h1>View logs from previous pod (after crash)</h1>
<p>kubectl logs order-service-abc123 --previous</p>
<p></code></pre></p>

<h3>5. kubectl exec (Shell Access)</h3>

<pre><code class="language-bash"># Execute command in pod
<p>kubectl exec order-service-abc123 -- ps aux</p>

<h1>Interactive shell</h1>
<p>kubectl exec -it order-service-abc123 -- /bin/bash</p>

<h1>Test database connectivity</h1>
<p>kubectl exec order-service-abc123 -- psql $DATABASE_URL -c "SELECT 1"</p>
<p></code></pre></p>

<hr>

<h2>Performance Profiling</h2>

<h3>BenchmarkDotNet</h3>

<strong>CreateOrderBenchmark.cs</strong>:

<pre><code class="language-csharp">using BenchmarkDotNet.Attributes;
<p>using BenchmarkDotNet.Running;</p>

<p>[MemoryDiagnoser]</p>
<p>[SimpleJob(warmupCount: 3, iterationCount: 10)]</p>
<p>public class CreateOrderBenchmark {</p>
<p>  [Benchmark]</p>
<p>  public async Task<OrderCreated> CreateOrder() {</p>
<p>    return await _receptor.HandleAsync(_command);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Run</strong>:

<pre><code class="language-bash">dotnet run -c Release --project Benchmarks

<h1>Output:</h1>
<h1>| Method      | Mean     | Error   | StdDev | Allocated |</h1>
<h1>|------------ |---------:|--------:|-------:|----------:|</h1>
<h1>| CreateOrder | 125.3 μs | 2.34 μs | 2.19 μs |     512 B |</h1>
<p></code></pre></p>

<h3>PerfView (Windows)</h3>

<pre><code class="language-bash"># Collect CPU samples
<p>PerfView.exe collect /MaxCollectSec:30 /Zip:true</p>

<h1>Analyze trace</h1>
<p>PerfView.exe trace.etl</p>
<p></code></pre></p>

<hr>

<h2>Health Check Diagnostics</h2>

<h3>Check Health Endpoint</h3>

<pre><code class="language-bash">curl https://order-service.myapp.com/health

<h1>Output:</h1>
<h1>{</h1>
<h1>"status": "Unhealthy",</h1>
<h1>"results": {</h1>
<h1>"database": { "status": "Healthy" },</h1>
<h1>"servicebus": { "status": "Unhealthy", "description": "Connection failed" }</h1>
<h1>}</h1>
<h1>}</h1>
<p></code></pre></p>

<h3>Custom Health Check</h3>

<pre><code class="language-csharp">public class OutboxHealthCheck : IHealthCheck {
<p>  public async Task<HealthCheckResult> CheckHealthAsync(</p>
<p>    HealthCheckContext context,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var backlog = await _db.ExecuteScalarAsync<int>(</p>
<p>      "SELECT COUNT(*) FROM outbox WHERE processed_at IS NULL"</p>
<p>    );</p>

<p>    if (backlog > 10000) {</p>
<p>      return HealthCheckResult.Degraded(</p>
<p>        $"Outbox backlog is {backlog} messages",</p>
<p>        data: new Dictionary<string, object> { ["backlog"] = backlog }</p>
<p>      );</p>
<p>    }</p>

<p>    return HealthCheckResult.Healthy();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>No Handler Found</strong> - Check DI registration or use source-generated <code>AddGeneratedReceptors()</code></p>
<p>✅ <strong>Message Not Published</strong> - Check outbox worker, transaction commit, Service Bus connection</p>
<p>✅ <strong>Duplicate Processing</strong> - Implement inbox pattern for idempotency</p>
<p>✅ <strong>High Latency</strong> - Add database indexes, avoid N+1 queries</p>
<p>✅ <strong>Memory Leak</strong> - Use <code>await using</code> for connections, unsubscribe event handlers</p>
<p>✅ <strong>Diagnostic Tools</strong> - dotnet-counters, dotnet-trace, dotnet-dump, kubectl logs</p>

<hr>

<h2>Troubleshooting Checklist</h2>

<ul><li>[ ] Check logs in Application Insights or Kubernetes</li>
<li>[ ] Verify DI registrations (receptors, perspectives, policies)</li>
<li>[ ] Check database connectivity and connection string</li>
<li>[ ] Verify Service Bus connection and permissions</li>
<li>[ ] Check outbox/inbox tables for backlog</li>
<li>[ ] Review slow query log in PostgreSQL</li>
<li>[ ] Monitor metrics (CPU, memory, request rate, error rate)</li>
<li>[ ] Use correlation IDs to trace requests across services</li>
<li>[ ] Profile with dotnet-trace or BenchmarkDotNet</li>
<li>[ ] Check health endpoints for service status</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Architecture</h2>
<article id="v1-0-0-architecture-message-lifecycle" class="doc-section">
  <h3>Message Lifecycle &amp; Architecture</h3>
  <p class="doc-path"><code>v1.0.0/architecture/message-lifecycle</code></p>
  <p class="doc-description"><em>Complete guide to message flow through Whizbang - Commands, Events, Work Coordinator, and all the hooks between Dispatcher, Receptors, Perspectives, and Outbox/Inbox</em></p>
  <div class="doc-content">

<h1>Message Lifecycle & Architecture</h1>

<p>This document provides a complete view of how messages flow through Whizbang from initial dispatch through outbox publishing, including all the integration points with Receptors, Perspectives, Event Store, and the Work Coordinator.</p>

<hr>

<h2>Architecture Overview</h2>

<pre><code class="language-mermaid">graph TB
<p>    subgraph "API/Client Layer"</p>
<p>        API[API Controller]</p>
<p>    end</p>

<p>    subgraph "Dispatcher Layer"</p>
<p>        DISP[Dispatcher]</p>
<p>        STRAT[Work Coordinator Strategy]</p>
<p>    end</p>

<p>    subgraph "Business Logic Layer"</p>
<p>        REC[Receptor]</p>
<p>    end</p>

<p>    subgraph "Read Model Layer"</p>
<p>        PERSP[Perspectives]</p>
<p>    end</p>

<p>    subgraph "Persistence Layer"</p>
<p>        WC[Work Coordinator<br/>process_work_batch]</p>
<p>        ES[Event Store]</p>
<p>        OUTBOX[(Outbox Table)]</p>
<p>        INBOX[(Inbox Table)]</p>
<p>    end</p>

<p>    subgraph "Background Workers"</p>
<p>        PUB[Publisher Worker]</p>
<p>        CONS[Consumer Worker]</p>
<p>        OSP[Ordered Stream<br/>Processor]</p>
<p>    end</p>

<p>    subgraph "External Systems"</p>
<p>        SB[Azure Service Bus]</p>
<p>    end</p>

<p>    API -->|SendAsync<br/>LocalInvokeAsync<br/>PublishAsync| DISP</p>
<p>    DISP -->|1. Invoke| REC</p>
<p>    REC -->|2. Return Event| DISP</p>
<p>    DISP -->|3. Queue Outbox| STRAT</p>
<p>    STRAT -->|4. Batch Insert| WC</p>
<p>    WC -->|5. Store| OUTBOX</p>
<p>    WC -->|6. Store| ES</p>
<p>    DISP -->|7. PublishAsync| PERSP</p>

<p>    PUB -->|Poll| WC</p>
<p>    WC -->|Claim Work| PUB</p>
<p>    PUB -->|Stream Order| OSP</p>
<p>    OSP -->|Publish| SB</p>
<p>    OSP -->|Report Complete| WC</p>

<p>    SB -->|Receive| CONS</p>
<p>    CONS -->|Queue Inbox| STRAT</p>
<p>    STRAT -->|Dedup Insert| WC</p>
<p>    WC -->|Check Duplicate| INBOX</p>
<p>    WC -->|If New| CONS</p>
<p>    CONS -->|Stream Order| OSP</p>
<p>    OSP -->|Invoke| PERSP</p>
<p>    OSP -->|Report Complete| WC</p>

<p>    style WC fill:#4CAF50</p>
<p>    style ES fill:#2196F3</p>
<p>    style OSP fill:#FF9800</p>
<p></code></pre></p>

<hr>

<h2>Command Flow (Synchronous)</h2>

<h3>Pattern: LocalInvokeAsync</h3>

<strong>Use Case</strong>: API endpoint needs immediate typed response

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant Client</p>
<p>    participant Controller</p>
<p>    participant Dispatcher</p>
<p>    participant Receptor</p>
<p>    participant WorkStrategy as Work Coordinator<br/>Strategy (Scoped)</p>
<p>    participant WorkCoord as Work Coordinator<br/>process_work_batch</p>
<p>    participant EventStore</p>
<p>    participant Outbox</p>
<p>    participant Perspectives</p>

<p>    Client->>Controller: POST /orders</p>
<p>    Controller->>Dispatcher: LocalInvokeAsync<CreateOrder, OrderCreated>(command)</p>

<p>    Note over Dispatcher: Create MessageEnvelope<br/>(MessageId, CorrelationId, CausationId)</p>

<p>    Dispatcher->>Receptor: HandleAsync(CreateOrder)</p>

<p>    Note over Receptor: Validate command<br/>Apply business logic<br/>Generate event</p>

<p>    Receptor-->>Dispatcher: OrderCreated event</p>

<p>    Note over Dispatcher: Check if event implements IEvent<br/>(for Event Store)</p>

<p>    Dispatcher->>WorkStrategy: QueueOutboxMessage(event, isEvent=true)</p>
<p>    Note over WorkStrategy: Batch in scoped collection</p>

<p>    Dispatcher->>WorkStrategy: FlushAsync()</p>

<p>    WorkStrategy->>WorkCoord: ProcessWorkBatchAsync(<br/>  newOutboxMessages: [event],<br/>  flags: None<br/>)</p>

<p>    Note over WorkCoord: Single atomic transaction:</p>

<p>    WorkCoord->>Outbox: INSERT INTO wh_outbox</p>
<p>    Note over Outbox: Stream-based partitioning<br/>partition_number = hash(stream_id) % 10000</p>

<p>    WorkCoord->>EventStore: INSERT INTO wh_event_store<br/>(if isEvent=true AND ends with "Event")</p>
<p>    Note over EventStore: Auto-increment version per stream<br/>Global sequence for ordering</p>

<p>    WorkCoord-->>WorkStrategy: WorkBatch(claimedOutboxMessages, ...)</p>
<p>    WorkStrategy-->>Dispatcher: WorkBatch</p>

<p>    Dispatcher->>Perspectives: PublishAsync(OrderCreated)</p>

<p>    Note over Perspectives: Parallel invocation of all perspectives:</p>

<p>    par Update Read Models</p>
<p>        Perspectives->>Perspectives: OrderSummaryPerspective.UpdateAsync()</p>
<p>        Perspectives->>Perspectives: InventoryPerspective.UpdateAsync()</p>
<p>        Perspectives->>Perspectives: AnalyticsPerspective.UpdateAsync()</p>
<p>    end</p>

<p>    Dispatcher-->>Controller: OrderCreated result</p>
<p>    Controller-->>Client: 201 Created + OrderCreated JSON</p>

<p>    Note over WorkStrategy: Scope disposed<br/>(end of HTTP request)</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li><strong>Synchronous semantics</strong>: Controller waits for result</li>
<li><strong>Atomic Event Store + Outbox</strong>: Both persisted in single transaction</li>
<li><strong>Stream-based partitioning</strong>: Ensures same stream_id always maps to same partition</li>
<li><strong>Perspective update</strong>: Happens before response (read-your-writes consistency)</li>
<li><strong>Scoped strategy</strong>: Batches operations per HTTP request, flushes on disposal</li>
</ul>
<hr>

<h2>Command Flow (Asynchronous)</h2>

<h3>Pattern: SendAsync</h3>

<strong>Use Case</strong>: Long-running operation, return receipt for tracking

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant Client</p>
<p>    participant Controller</p>
<p>    participant Dispatcher</p>
<p>    participant Receptor</p>
<p>    participant WorkStrategy as Work Coordinator<br/>Strategy (Scoped)</p>
<p>    participant WorkCoord as Work Coordinator<br/>process_work_batch</p>
<p>    participant Outbox</p>

<p>    Client->>Controller: POST /orders/async</p>
<p>    Controller->>Dispatcher: SendAsync(CreateOrder)</p>

<p>    Note over Dispatcher: Create MessageEnvelope<br/>Generate MessageId, CorrelationId</p>

<p>    Dispatcher->>Receptor: HandleAsync(CreateOrder)</p>
<p>    Receptor-->>Dispatcher: OrderCreated event</p>

<p>    Dispatcher->>WorkStrategy: QueueOutboxMessage(event, isEvent=true)</p>
<p>    Dispatcher->>WorkStrategy: FlushAsync()</p>

<p>    WorkStrategy->>WorkCoord: ProcessWorkBatchAsync(<br/>  newOutboxMessages: [event]<br/>)</p>

<p>    WorkCoord->>Outbox: INSERT INTO wh_outbox</p>
<p>    WorkCoord-->>WorkStrategy: WorkBatch</p>
<p>    WorkStrategy-->>Dispatcher: WorkBatch</p>

<p>    Dispatcher-->>Controller: DeliveryReceipt(MessageId, CorrelationId, Timestamp)</p>
<p>    Controller-->>Client: 202 Accepted + tracking URL</p>

<p>    Note over Client: Poll tracking URL<br/>GET /orders/status/{correlationId}</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li><strong>Asynchronous semantics</strong>: Receipt doesn't mean processing complete</li>
<li><strong>Tracking via CorrelationId</strong>: Client polls status endpoint</li>
<li><strong>Outbox guarantees delivery</strong>: Event will be published eventually</li>
<li><strong>No perspective update</strong>: Happens asynchronously via background workers</li>
</ul>
<hr>

<h2>Event Flow (Publishing from Outbox)</h2>

<h3>Background Worker: WorkCoordinatorPublisherWorker</h3>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant Timer</p>
<p>    participant PublisherWorker as WorkCoordinator<br/>PublisherWorker</p>
<p>    participant WorkStrategy as Work Coordinator<br/>Strategy (Interval)</p>
<p>    participant WorkCoord as Work Coordinator<br/>process_work_batch</p>
<p>    participant Outbox</p>
<p>    participant OSP as Ordered Stream<br/>Processor</p>
<p>    participant Transport as Azure Service Bus</p>

<p>    loop Every 100ms (configurable interval)</p>
<p>        Timer->>PublisherWorker: Tick</p>

<p>        PublisherWorker->>WorkStrategy: FlushAsync()</p>

<p>        WorkStrategy->>WorkCoord: ProcessWorkBatchAsync(<br/>  instanceId: worker-guid,<br/>  serviceName: "OrderService",<br/>  partitionCount: 10000,<br/>  maxPartitionsPerInstance: 100,<br/>  leaseSeconds: 300<br/>)</p>

<p>        Note over WorkCoord: Atomic lease-based claiming:</p>

<p>        WorkCoord->>Outbox: SELECT * FROM wh_outbox<br/>WHERE partition_number IN (assigned_partitions)<br/>  AND (instance_id IS NULL OR lease_expiry < NOW())<br/>  AND status = 'Stored'<br/>FOR UPDATE SKIP LOCKED<br/>LIMIT 100</p>

<p>        WorkCoord->>Outbox: UPDATE wh_outbox SET<br/>  instance_id = @InstanceId,<br/>  lease_expiry = NOW() + @LeaseSeconds<br/>WHERE message_id IN (...)</p>

<p>        WorkCoord-->>WorkStrategy: WorkBatch(claimedOutboxMessages: [...])</p>

<p>        WorkStrategy-->>PublisherWorker: WorkBatch</p>

<p>        alt Has claimed messages</p>
<p>            PublisherWorker->>OSP: ProcessOutboxWorkAsync(messages)</p>

<p>            Note over OSP: Group by stream_id<br/>Sort by sequence_order per stream<br/>Process sequentially per stream</p>

<p>            loop For each stream (parallel)</p>
<p>                loop For each message in stream (sequential)</p>
<p>                    OSP->>Transport: PublishAsync(topic, messageId, payload)</p>

<p>                    alt Success</p>
<p>                        OSP->>WorkStrategy: QueueOutboxCompletion(messageId, Published)</p>
<p>                    else Failure</p>
<p>                        OSP->>WorkStrategy: QueueOutboxFailure(messageId, Failed, error)</p>
<p>                    end</p>
<p>                end</p>
<p>            end</p>

<p>            PublisherWorker->>WorkStrategy: FlushAsync()</p>

<p>            WorkStrategy->>WorkCoord: ProcessWorkBatchAsync(<br/>  outboxCompletions: [...],<br/>  outboxFailures: [...]<br/>)</p>

<p>            WorkCoord->>Outbox: DELETE FROM wh_outbox<br/>WHERE message_id IN (completions)</p>

<p>            WorkCoord->>Outbox: UPDATE wh_outbox SET<br/>  status = 'Failed',<br/>  error = ...,<br/>  retry_count = retry_count + 1<br/>WHERE message_id IN (failures)</p>
<p>        end</p>
<p>    end</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li><strong>Interval strategy</strong>: Polls every 100ms (configurable)</li>
<li><strong>Partition-based distribution</strong>: Each worker claims subset of partitions (max 100)</li>
<li><strong>Lease-based coordination</strong>: Prevents duplicate processing across workers</li>
<li><strong>Stream ordering via OrderedStreamProcessor</strong>: Events from same stream processed sequentially</li>
<li><strong>Parallel streams</strong>: Different streams can process concurrently</li>
<li><strong>Atomic completion reporting</strong>: Deletes completed, updates failed</li>
</ul>
<hr>

<h2>Event Flow (Consuming from Inbox)</h2>

<h3>Background Worker: ServiceBusConsumerWorker</h3>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant ServiceBus as Azure Service Bus</p>
<p>    participant ConsumerWorker as ServiceBus<br/>ConsumerWorker</p>
<p>    participant WorkStrategy as Work Coordinator<br/>Strategy (Scoped)</p>
<p>    participant WorkCoord as Work Coordinator<br/>process_work_batch</p>
<p>    participant Inbox</p>
<p>    participant OSP as Ordered Stream<br/>Processor</p>
<p>    participant Perspectives</p>

<p>    ServiceBus->>ConsumerWorker: Receive message</p>

<p>    Note over ConsumerWorker: Create scoped DI container<br/>(per message)</p>

<p>    ConsumerWorker->>ConsumerWorker: Deserialize MessageEnvelope</p>

<p>    ConsumerWorker->>WorkStrategy: QueueInboxMessage(envelope)</p>

<p>    ConsumerWorker->>WorkStrategy: FlushAsync()</p>

<p>    WorkStrategy->>WorkCoord: ProcessWorkBatchAsync(<br/>  newInboxMessages: [envelope]<br/>)</p>

<p>    Note over WorkCoord: Atomic deduplication:</p>

<p>    WorkCoord->>Inbox: INSERT INTO wh_inbox<br/>ON CONFLICT (message_id) DO NOTHING<br/>RETURNING *</p>

<p>    alt Message is duplicate</p>
<p>        WorkCoord-->>WorkStrategy: WorkBatch(claimedInboxMessages: [])</p>
<p>        WorkStrategy-->>ConsumerWorker: WorkBatch (empty)</p>

<p>        Note over ConsumerWorker: Duplicate detected,<br/>skip processing</p>

<p>        ConsumerWorker->>ServiceBus: Complete message</p>
<p>    else Message is new</p>
<p>        WorkCoord-->>WorkStrategy: WorkBatch(claimedInboxMessages: [envelope])</p>
<p>        WorkStrategy-->>ConsumerWorker: WorkBatch</p>

<p>        ConsumerWorker->>OSP: ProcessInboxWorkAsync(messages)</p>

<p>        Note over OSP: Group by stream_id<br/>Sort by sequence_order per stream<br/>Process sequentially per stream</p>

<p>        loop For each stream (parallel)</p>
<p>            loop For each message in stream (sequential)</p>
<p>                OSP->>OSP: Deserialize event payload</p>

<p>                OSP->>Perspectives: InvokePerspectivesAsync(event)</p>

<p>                Note over Perspectives: Find all perspectives<br/>registered for this event type</p>

<p>                par Update Read Models</p>
<p>                    Perspectives->>Perspectives: OrderSummaryPerspective.UpdateAsync()</p>
<p>                    Perspectives->>Perspectives: InventoryPerspective.UpdateAsync()</p>
<p>                    Perspectives->>Perspectives: AnalyticsPerspective.UpdateAsync()</p>
<p>                end</p>

<p>                alt All perspectives succeeded</p>
<p>                    OSP->>WorkStrategy: QueueInboxCompletion(messageId, Completed)</p>
<p>                else Any perspective failed</p>
<p>                    OSP->>WorkStrategy: QueueInboxFailure(messageId, Failed, error)</p>
<p>                end</p>
<p>            end</p>
<p>        end</p>

<p>        ConsumerWorker->>WorkStrategy: FlushAsync()</p>

<p>        WorkStrategy->>WorkCoord: ProcessWorkBatchAsync(<br/>  inboxCompletions: [...],<br/>  inboxFailures: [...]<br/>)</p>

<p>        WorkCoord->>Inbox: DELETE FROM wh_inbox<br/>WHERE message_id IN (completions)</p>

<p>        WorkCoord->>Inbox: UPDATE wh_inbox SET<br/>  status = 'Failed',<br/>  error = ...,<br/>  retry_count = retry_count + 1<br/>WHERE message_id IN (failures)</p>

<p>        ConsumerWorker->>ServiceBus: Complete message</p>
<p>    end</p>

<p>    Note over WorkStrategy: Scope disposed<br/>(end of message processing)</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li><strong>Scoped strategy</strong>: One scope per message</li>
<li><strong>Atomic deduplication</strong>: INSERT ... ON CONFLICT ensures exactly-once semantics</li>
<li><strong>Stream ordering</strong>: OrderedStreamProcessor ensures events from same stream process sequentially</li>
<li><strong>Perspective invocation</strong>: All registered perspectives updated in parallel</li>
<li><strong>Completion reporting</strong>: Atomic delete (success) or update (failure)</li>
<li><strong>Service Bus completion</strong>: Only after database commit</li>
</ul>
<hr>

<h2>Receptor Lifecycle Hooks</h2>

<p>Receptors have several integration points throughout the message lifecycle:</p>

<pre><code class="language-mermaid">graph TB
<p>    START[Message Arrives] --> VALIDATE[1. Validation Phase]</p>
<p>    VALIDATE --> LOGIC[2. Business Logic Phase]</p>
<p>    LOGIC --> EVENT[3. Event Generation Phase]</p>
<p>    EVENT --> STORE[4. Event Store Phase]</p>
<p>    STORE --> PERSP[5. Perspective Update Phase]</p>
<p>    PERSP --> COMPLETE[6. Completion Phase]</p>

<p>    VALIDATE -->|ValidationException| ERROR1[Return 400 Bad Request]</p>
<p>    LOGIC -->|Business Exception| ERROR2[Return 409 Conflict]</p>
<p>    STORE -->|DB Error| ERROR3[Rollback + Return 500]</p>
<p>    PERSP -->|Perspective Error| ERROR4[Rollback + Return 500]</p>

<p>    style VALIDATE fill:#FFC107</p>
<p>    style LOGIC fill:#4CAF50</p>
<p>    style EVENT fill:#2196F3</p>
<p>    style STORE fill:#9C27B0</p>
<p>    style PERSP fill:#FF5722</p>
<p>    style COMPLETE fill:#4CAF50</p>
<p></code></pre></p>

<h3>Phase 1: Validation</h3>

<pre><code class="language-csharp">public async ValueTask<OrderCreated> HandleAsync(
<p>    CreateOrder message,</p>
<p>    CancellationToken ct = default) {</p>

<p>    // HOOK 1: Input Validation</p>
<p>    if (message.Items.Length == 0) {</p>
<p>        throw new ValidationException("Order must contain at least one item");</p>
<p>    }</p>

<p>    if (message.Items.Any(i => i.Quantity <= 0)) {</p>
<p>        throw new ValidationException("All items must have quantity > 0");</p>
<p>    }</p>

<p>    // ... continue to business logic</p>
<p>}</p>
<p></code></pre></p>

<strong>Hook</strong>: Validate inputs <strong>before</strong> any database operations
<strong>Result</strong>: If validation fails, throw <code>ValidationException</code> → 400 Bad Request
<strong>Guarantees</strong>: No side effects (no database writes)

<h3>Phase 2: Business Logic</h3>

<pre><code class="language-csharp">public async ValueTask<OrderCreated> HandleAsync(
<p>    CreateOrder message,</p>
<p>    CancellationToken ct = default) {</p>

<p>    // Validation phase (above)</p>
<p>    // ...</p>

<p>    // HOOK 2: Business Logic</p>
<p>    await using var conn = _db.CreateConnection();</p>

<p>    // Check customer exists</p>
<p>    var customer = await conn.QuerySingleOrDefaultAsync<Customer>(</p>
<p>        "SELECT * FROM customers WHERE customer_id = @CustomerId",</p>
<p>        new { message.CustomerId },</p>
<p>        ct</p>
<p>    );</p>

<p>    if (customer is null) {</p>
<p>        throw new NotFoundException($"Customer {message.CustomerId} not found");</p>
<p>    }</p>

<p>    // Check inventory</p>
<p>    var hasStock = await _inventory.CheckStockAsync(message.Items, ct);</p>
<p>    if (!hasStock) {</p>
<p>        throw new InvalidOperationException("Insufficient inventory");</p>
<p>    }</p>

<p>    // ... continue to event generation</p>
<p>}</p>
<p></code></pre></p>

<strong>Hook</strong>: Execute business logic, load state, check invariants
<strong>Result</strong>: If business rules fail, throw appropriate exception
<strong>Guarantees</strong>: No state changes yet (read-only operations)

<h3>Phase 3: Event Generation</h3>

<pre><code class="language-csharp">public async ValueTask<OrderCreated> HandleAsync(
<p>    CreateOrder message,</p>
<p>    CancellationToken ct = default) {</p>

<p>    // Validation and business logic phases (above)</p>
<p>    // ...</p>

<p>    // HOOK 3: Event Generation</p>
<p>    var orderId = Guid.CreateVersion7();  // Time-ordered GUID</p>
<p>    var total = message.Items.Sum(i => i.Quantity * i.UnitPrice);</p>

<p>    var @event = new OrderCreated(</p>
<p>        OrderId: orderId,</p>
<p>        CustomerId: message.CustomerId,</p>
<p>        Items: message.Items,</p>
<p>        Total: total,</p>
<p>        CreatedAt: DateTimeOffset.UtcNow</p>
<p>    );</p>

<p>    return @event;</p>
<p>}</p>
<p></code></pre></p>

<strong>Hook</strong>: Generate event representing <strong>fact of what happened</strong>
<strong>Result</strong>: Return strongly-typed event
<strong>Guarantees</strong>: Event is immutable (record type), contains all relevant data

<h3>Phase 4: Event Store (Automatic)</h3>

<p>This phase is <strong>automatic</strong> - no receptor code needed:</p>

<pre><code class="language-csharp">// Inside Dispatcher.SendAsync():
<p>await _workCoordinatorStrategy.QueueOutboxMessage(</p>
<p>    new NewOutboxMessage {</p>
<p>        MessageId = envelope.MessageId.Value,</p>
<p>        StreamId = ExtractStreamId(envelope),  // From aggregate ID</p>
<p>        IsEvent = payload is IEvent,  // ← Automatic detection</p>
<p>        // ...</p>
<p>    }</p>
<p>);</p>
<p></code></pre></p>

<strong>Hook</strong>: Dispatcher checks if <code>payload is IEvent</code>
<strong>Result</strong>: If true, <code>process_work_batch</code> automatically inserts to <code>wb_event_store</code>
<strong>Guarantees</strong>: Event Store + Outbox insert in <strong>same atomic transaction</strong>

<h3>Phase 5: Perspective Update</h3>

<strong>Automatic via <code>PublishAsync()</code></strong>:

<pre><code class="language-csharp">// Inside Dispatcher after receptor returns
<p>if (result is not null) {</p>
<p>    await PublishAsync(result, cancellationToken);</p>
<p>}</p>
<p></code></pre></p>

<strong>Hook</strong>: Dispatcher finds all <code>IPerspectiveOf<TEvent></code> registrations
<strong>Result</strong>: All perspectives invoked in parallel
<strong>Guarantees</strong>: Read models updated before HTTP response

<h3>Phase 6: Completion</h3>

<strong>Automatic scope disposal</strong>:

<pre><code class="language-csharp">// Inside HTTP request handler
<p>await using var scope = _scopeFactory.CreateAsyncScope();</p>
<p>var dispatcher = scope.ServiceProvider.GetRequiredService<IDispatcher>();</p>

<p>var result = await dispatcher.LocalInvokeAsync<CreateOrder, OrderCreated>(command);</p>

<p>// Scope disposal triggers:</p>
<p>// 1. WorkCoordinatorStrategy.FlushAsync()</p>
<p>// 2. process_work_batch (commit transaction)</p>
<p>// 3. DbContext.SaveChangesAsync() (if using EF Core)</p>
<p></code></pre></p>

<strong>Hook</strong>: Scope disposal at end of request
<strong>Result</strong>: All queued work flushed to database
<strong>Guarantees</strong>: Atomic commit of all operations

<hr>

<h2>Strategy Pattern: Three Execution Models</h2>

<h3>1. Immediate Strategy (Lowest Latency)</h3>

<pre><code class="language-csharp">public class ImmediateWorkCoordinatorStrategy : IWorkCoordinatorStrategy {
<p>    public async Task QueueOutboxMessage(NewOutboxMessage message) {</p>
<p>        _pendingOutbox.Add(message);</p>

<p>        // Flush immediately (no batching)</p>
<p>        await FlushAsync();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Use Case</strong>: Real-time critical operations
<strong>Latency</strong>: ~10ms (1 DB call per message)
<strong>DB Load</strong>: High (1 call per message)

<h3>2. Scoped Strategy (Per-Request Batching)</h3>

<pre><code class="language-csharp">public class ScopedWorkCoordinatorStrategy : IWorkCoordinatorStrategy, IAsyncDisposable {
<p>    public async Task QueueOutboxMessage(NewOutboxMessage message) {</p>
<p>        _pendingOutbox.Add(message);</p>
<p>        // Don't flush yet - batch until scope disposal</p>
<p>    }</p>

<p>    public async ValueTask DisposeAsync() {</p>
<p>        // Flush on scope disposal (end of HTTP request)</p>
<p>        await FlushAsync();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Use Case</strong>: Web APIs, per-request batching
<strong>Latency</strong>: ~50ms (1 DB call per request)
<strong>DB Load</strong>: Medium (1 call per HTTP request)

<h3>3. Interval Strategy (Highest Throughput)</h3>

<pre><code class="language-csharp">public class IntervalWorkCoordinatorStrategy : IWorkCoordinatorStrategy {
<p>    public async Task QueueOutboxMessage(NewOutboxMessage message) {</p>
<p>        _pendingOutbox.Add(message);</p>
<p>        // Don't flush - timer will flush every 100ms</p>
<p>    }</p>

<p>    private async Task TimerCallback() {</p>
<p>        while (!_cts.IsCancellationRequested) {</p>
<p>            await Task.Delay(_options.IntervalMilliseconds, _cts.Token);</p>
<p>            await FlushAsync();  // Batch flush</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Use Case</strong>: Background workers, high throughput
<strong>Latency</strong>: ~100ms (1 DB call per interval)
<strong>DB Load</strong>: Low (1 call per 100ms, regardless of message count)

<hr>

<h2>Work Coordinator: Atomic Operations</h2>

<p>All operations in <code>process_work_batch</code> are <strong>atomic</strong> (single transaction):</p>

<pre><code class="language-sql">CREATE OR REPLACE FUNCTION process_work_batch(...)
<p>RETURNS TABLE (...) AS $$</p>
<p>BEGIN</p>
<p>    -- 1. Delete completed outbox messages</p>
<p>    DELETE FROM wh_outbox</p>
<p>    WHERE message_id IN (SELECT message_id FROM jsonb_array_elements(p_outbox_completions));</p>

<p>    -- 2. Update failed outbox messages</p>
<p>    UPDATE wh_outbox SET</p>
<p>        status = 'Failed',</p>
<p>        error = ...,</p>
<p>        retry_count = retry_count + 1</p>
<p>    WHERE message_id IN (...);</p>

<p>    -- 3. Insert new outbox messages (with partition assignment)</p>
<p>    INSERT INTO wh_outbox (message_id, stream_id, partition_number, ...)</p>
<p>    SELECT</p>
<p>        (elem->>'message_id')::UUID,</p>
<p>        (elem->>'stream_id')::UUID,</p>
<p>        abs(hashtext((elem->>'stream_id')::TEXT)) % p_partition_count,  -- Partition</p>
<p>        ...</p>
<p>    FROM jsonb_array_elements(p_new_outbox_messages) AS elem;</p>

<p>    -- 4. Insert to event store (if IsEvent = true)</p>
<p>    INSERT INTO wb_event_store (event_id, stream_id, aggregate_type, version, ...)</p>
<p>    SELECT</p>
<p>        (elem->>'message_id')::UUID,</p>
<p>        (elem->>'stream_id')::UUID,</p>
<p>        ExtractAggregateType((elem->>'message_type')::TEXT),  -- "Order" from "OrderCreated"</p>
<p>        COALESCE(</p>
<p>            (SELECT MAX(version) + 1 FROM wb_event_store WHERE stream_id = (elem->>'stream_id')::UUID),</p>
<p>            1</p>
<p>        ),</p>
<p>        ...</p>
<p>    FROM jsonb_array_elements(p_new_outbox_messages) AS elem</p>
<p>    WHERE (elem->>'is_event')::BOOLEAN = TRUE</p>
<p>      AND (elem->>'message_type')::TEXT LIKE '%Event';  -- Convention-based</p>

<p>    -- 5-8. Similar atomic operations for inbox</p>
<p>    -- ...</p>

<p>    -- 9. Claim new outbox work (lease-based)</p>
<p>    UPDATE wh_outbox</p>
<p>    SET</p>
<p>        instance_id = p_instance_id,</p>
<p>        lease_expiry = NOW() + (p_lease_seconds || ' seconds')::INTERVAL</p>
<p>    WHERE message_id IN (</p>
<p>        SELECT message_id FROM wh_outbox</p>
<p>        WHERE partition_number IN (SELECT * FROM assigned_partitions)</p>
<p>          AND (instance_id IS NULL OR lease_expiry < NOW())</p>
<p>          AND status = 'Stored'</p>
<p>        ORDER BY sequence_order</p>
<p>        LIMIT 100</p>
<p>        FOR UPDATE SKIP LOCKED  -- Non-blocking claim</p>
<p>    )</p>
<p>    RETURNING *;</p>

<p>    -- COMMIT (all operations succeed or fail together)</p>
<p>END;</p>
<p>$$ LANGUAGE plpgsql;</p>
<p></code></pre></p>

<strong>Guarantees</strong>:
<ul><li>✅ <strong>Atomicity</strong>: All operations succeed together or fail together</li>
<li>✅ <strong>No race conditions</strong>: Lease-based claiming prevents duplicate work</li>
<li>✅ <strong>Stream ordering</strong>: Partition assignment ensures same stream → same worker</li>
<li>✅ <strong>Event Store consistency</strong>: Event version conflicts detected automatically</li>
<li>✅ <strong>Deduplication</strong>: INSERT ... ON CONFLICT prevents duplicate inbox processing</li>
</ul>
<hr>

<h2>Further Reading</h2>

<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/dispatcher.md">Dispatcher Deep Dive</a> - Three dispatch patterns</li>
<li><a href="../core-concepts/receptors.md">Receptors Guide</a> - Message handlers and business logic</li>
<li><a href="../core-concepts/perspectives.md">Perspectives Guide</a> - Event listeners for read models</li>
</ul>
<strong>Messaging Patterns</strong>:
<ul><li><a href="../messaging/work-coordinator.md">Work Coordinator</a> - Atomic batch processing</li>
<li><a href="../messaging/outbox-pattern.md">Outbox Pattern</a> - Reliable event publishing</li>
<li><a href="../messaging/inbox-pattern.md">Inbox Pattern</a> - Exactly-once processing</li>
</ul>
<strong>Components</strong>:
<ul><li><a href="../components/ordered-stream-processor.md">Ordered Stream Processor</a> - Stream-based ordering guarantees</li>
</ul>
<strong>Examples</strong>:
<ul><li><a href="../examples/ecommerce/order-service.md">ECommerce: Order Service</a> - Real-world implementation</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2025-12-21</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Attributes</h2>
<article id="v1-0-0-attributes-streamkey" class="doc-section">
  <h3>StreamKey Attribute</h3>
  <p class="doc-path"><code>v1.0.0/attributes/streamkey</code></p>
  <p class="doc-description"><em>Marks a property as the stream key for event sourcing and perspective event ordering</em></p>
  <div class="doc-content">

<h1>StreamKey Attribute</h1>

<p>The <code>[StreamKey]</code> attribute marks a property as the stream key for event sourcing. The stream key identifies which stream (aggregate) an event belongs to, enabling ordered event processing in perspectives.</p>

<h2>Namespace</h2>

<pre><code class="language-csharp">using Whizbang.Core;
<p></code></pre></p>

<h2>Syntax</h2>

<pre><code class="language-csharp">[StreamKey]
<p>public Guid PropertyName { get; init; }</p>
<p></code></pre></p>

<h2>Applies To</h2>

<ul><li><strong>Event properties</strong> (types implementing <code>IEvent</code>)</li>
<li><strong>Model properties</strong> (types used as <code>TModel</code> in <code>IPerspectiveFor<TModel, ...></code>)</li>
</ul>
<h2>Purpose</h2>

<p>The <code>[StreamKey]</code> attribute serves two critical purposes:</p>

<ul><li><strong>Event Ordering</strong>: Groups events by stream for ordered processing in perspectives</li>
<li><strong>Compile-Time Extraction</strong>: Source generator creates zero-reflection <code>ExtractStreamId()</code> methods</li>
</ul>
<h2>Requirements</h2>

<ul><li><strong>Exactly one property</strong> per type must have <code>[StreamKey]</code></li>
<li>The property must have a <code>get</code> accessor (typically <code>public</code>)</li>
<li>The property should uniquely identify the aggregate/stream</li>
</ul>
<h2>Basic Example</h2>

<pre><code class="language-csharp">public record ProductCreatedEvent : IEvent {
<p>  [StreamKey]  // Identifies which product this event belongs to</p>
<p>  public Guid ProductId { get; init; }</p>
<p>  public string Name { get; init; } = string.Empty;</p>
<p>  public decimal Price { get; init; }</p>
<p>}</p>

<p>public record ProductDto {</p>
<p>  [StreamKey]  // Identifies which product this model represents</p>
<p>  public Guid ProductId { get; init; }</p>
<p>  public string Name { get; init; } = string.Empty;</p>
<p>  public decimal Price { get; init; }</p>
<p>}</p>

<p>public class ProductCatalogPerspective : IPerspectiveFor<ProductDto, ProductCreatedEvent> {</p>
<p>  public ProductDto Apply(ProductDto currentData, ProductCreatedEvent @event) {</p>
<p>    return new ProductDto {</p>
<p>      ProductId = @event.ProductId,</p>
<p>      Name = @event.Name,</p>
<p>      Price = @event.Price</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>How It Works</h2>

<h3>1. Compile-Time Stream ID Extraction</h3>

<p>The source generator finds properties marked with <code>[StreamKey]</code> and generates extraction methods:</p>

<pre><code class="language-csharp">// Generated by PerspectiveRunnerGenerator
<p>public class ProductCatalogPerspectiveRunner : IPerspectiveRunner {</p>
<p>  private static string ExtractStreamId(ProductCreatedEvent @event) {</p>
<p>    return @event.ProductId.ToString();  // Uses [StreamKey] property</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>2. Event Grouping and Ordering</h3>

<p>At runtime, the <code>PerspectiveWorker</code> uses the stream ID to:</p>
<ul><li>Group events by stream (e.g., all events for Product A vs Product B)</li>
<li>Process events in UUID7 timestamp order within each stream</li>
<li>Apply events using pure <code>Apply()</code> methods</li>
</ul>
<h3>3. Unit-of-Work Pattern</h3>

<p>Events are batched per stream:</p>

<pre><code class="language-csharp">// Pseudo-code showing how PerspectiveWorker uses StreamKey
<p>var streamId = ExtractStreamId(@event);  // Uses [StreamKey] property</p>
<p>var currentModel = await LoadModel(streamId);  // Load existing state</p>
<p>var updatedModel = perspective.Apply(currentModel, @event);  // Pure function</p>
<p>await SaveModel(streamId, updatedModel);  // Atomic save with checkpoint</p>
<p></code></pre></p>

<h2>Multiple Events Example</h2>

<p>All events for the same aggregate should use the same <code>[StreamKey]</code> property:</p>

<pre><code class="language-csharp">public record OrderCreatedEvent : IEvent {
<p>  [StreamKey]</p>
<p>  public Guid OrderId { get; init; }</p>
<p>  public Guid CustomerId { get; init; }</p>
<p>  public DateTime CreatedAt { get; init; }</p>
<p>}</p>

<p>public record OrderShippedEvent : IEvent {</p>
<p>  [StreamKey]</p>
<p>  public Guid OrderId { get; init; }  // Same stream key as OrderCreatedEvent</p>
<p>  public string TrackingNumber { get; init; } = string.Empty;</p>
<p>  public DateTime ShippedAt { get; init; }</p>
<p>}</p>

<p>public record OrderCancelledEvent : IEvent {</p>
<p>  [StreamKey]</p>
<p>  public Guid OrderId { get; init; }  // Same stream key</p>
<p>  public string Reason { get; init; } = string.Empty;</p>
<p>  public DateTime CancelledAt { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<p>This ensures all events for Order #123 are processed in timestamp order.</p>

<h2>Model StreamKey</h2>

<p>Models also need <code>[StreamKey]</code> to identify which stream they represent:</p>

<pre><code class="language-csharp">public record OrderDto {
<p>  [StreamKey]  // Matches OrderId from events</p>
<p>  public Guid OrderId { get; init; }</p>
<p>  public string Status { get; init; } = string.Empty;</p>
<p>  public string? TrackingNumber { get; init; }</p>
<p>  public DateTime? CancelledAt { get; init; }</p>
<p>}</p>

<p>public class OrderPerspective :</p>
<p>  IPerspectiveFor<OrderDto, OrderCreatedEvent, OrderShippedEvent, OrderCancelledEvent> {</p>

<p>  public OrderDto Apply(OrderDto currentData, OrderCreatedEvent @event) {</p>
<p>    return new OrderDto {</p>
<p>      OrderId = @event.OrderId,  // StreamKey property</p>
<p>      Status = "Created"</p>
<p>    };</p>
<p>  }</p>

<p>  public OrderDto Apply(OrderDto currentData, OrderShippedEvent @event) {</p>
<p>    return currentData with {</p>
<p>      Status = "Shipped",</p>
<p>      TrackingNumber = @event.TrackingNumber</p>
<p>    };</p>
<p>  }</p>

<p>  public OrderDto Apply(OrderDto currentData, OrderCancelledEvent @event) {</p>
<p>    return currentData with {</p>
<p>      Status = "Cancelled",</p>
<p>      CancelledAt = @event.CancelledAt</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Property Types</h2>

<p>Common property types for <code>[StreamKey]</code>:</p>

<pre><code class="language-csharp">// Guid (most common - UUID7 for time-ordering)
<p>[StreamKey]</p>
<p>public Guid ProductId { get; init; }</p>

<p>// String (for natural keys)</p>
<p>[StreamKey]</p>
<p>public string AccountNumber { get; init; } = string.Empty;</p>

<p>// Custom value object</p>
<p>[StreamKey]</p>
<p>public CustomerId CustomerId { get; init; }</p>
<p></code></pre></p>

<p>The property should implement <code>ToString()</code> for conversion to stream ID string.</p>

<h2>Diagnostics</h2>

<p>The source generator validates <code>[StreamKey]</code> usage:</p>

<h3>WHIZ030: Missing StreamKey</h3>

<strong>Error</strong>: Event used in perspective has no <code>[StreamKey]</code> property

<pre><code class="language-csharp">// ❌ Causes WHIZ030
<p>public record ProductEvent : IEvent {</p>
<p>  public Guid ProductId { get; init; }  // No [StreamKey]!</p>
<p>}</p>

<p>// ✅ Fixed</p>
<p>public record ProductEvent : IEvent {</p>
<p>  [StreamKey]</p>
<p>  public Guid ProductId { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<p>See <a href="../diagnostics/whiz030.md">WHIZ030 Diagnostic</a> for details.</p>

<h3>WHIZ031: Multiple StreamKeys</h3>

<strong>Error</strong>: Event has multiple properties with <code>[StreamKey]</code>

<pre><code class="language-csharp">// ❌ Causes WHIZ031
<p>public record OrderEvent : IEvent {</p>
<p>  [StreamKey]</p>
<p>  public Guid OrderId { get; init; }</p>

<p>  [StreamKey]  // Only one [StreamKey] allowed!</p>
<p>  public Guid CustomerId { get; init; }</p>
<p>}</p>

<p>// ✅ Fixed - Choose the primary aggregate</p>
<p>public record OrderEvent : IEvent {</p>
<p>  [StreamKey]  // Order is the primary aggregate</p>
<p>  public Guid OrderId { get; init; }</p>

<p>  public Guid CustomerId { get; init; }  // Related entity, not stream key</p>
<p>}</p>
<p></code></pre></p>

<p>See <a href="../diagnostics/whiz031.md">WHIZ031 Diagnostic</a> for details.</p>

<h2>Best Practices</h2>

<h3>✅ DO: Use on Aggregate ID</h3>

<pre><code class="language-csharp">public record ProductCreatedEvent : IEvent {
<p>  [StreamKey]  // Primary aggregate identifier</p>
<p>  public Guid ProductId { get; init; }</p>
<p>  public Guid CategoryId { get; init; }  // Related entity</p>
<p>}</p>
<p></code></pre></p>

<h3>✅ DO: Match Event and Model StreamKeys</h3>

<pre><code class="language-csharp">// Event
<p>public record ProductEvent : IEvent {</p>
<p>  [StreamKey]</p>
<p>  public Guid ProductId { get; init; }</p>
<p>}</p>

<p>// Model - Same property name</p>
<p>public record ProductDto {</p>
<p>  [StreamKey]</p>
<p>  public Guid ProductId { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h3>✅ DO: Use UUID7 for Time-Ordered IDs</h3>

<pre><code class="language-csharp">public record OrderCreatedEvent : IEvent {
<p>  [AggregateId]  // Can combine attributes</p>
<p>  [StreamKey]</p>
<p>  public Guid OrderId { get; init; }  // UUID7 provides time-ordering</p>
<p>}</p>
<p></code></pre></p>

<h3>❌ DON'T: Use on Multiple Properties</h3>

<pre><code class="language-csharp">// ❌ WRONG - Multiple [StreamKey]
<p>public record Event : IEvent {</p>
<p>  [StreamKey]</p>
<p>  public Guid Id1 { get; init; }</p>

<p>  [StreamKey]  // Causes WHIZ031</p>
<p>  public Guid Id2 { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h3>❌ DON'T: Use on Non-Aggregate Properties</h3>

<pre><code class="language-csharp">// ❌ WRONG - CreatedAt is not an aggregate identifier
<p>public record ProductEvent : IEvent {</p>
<p>  public Guid ProductId { get; init; }</p>

<p>  [StreamKey]  // Wrong property!</p>
<p>  public DateTime CreatedAt { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h2>Advanced: Composite Keys</h2>

<p>If you truly need a composite key (rare in event sourcing), create a single computed property:</p>

<pre><code class="language-csharp">public record OrderLineItemEvent : IEvent {
<p>  [StreamKey]</p>
<p>  public string StreamKey => $"{OrderId}:{LineItemId}";  // Composite key</p>

<p>  public Guid OrderId { get; init; }</p>
<p>  public int LineItemId { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<p>However, this indicates you may need to rethink your aggregate boundaries. Most domain events belong to a single aggregate.</p>

<h2>Zero Reflection and AOT</h2>

<p>The <code>[StreamKey]</code> attribute enables zero-reflection stream ID extraction:</p>

<strong>Without [StreamKey] (reflection)</strong>:
<pre><code class="language-csharp">// ❌ Runtime reflection - not AOT-compatible
<p>var streamId = @event.GetType()</p>
<p>    .GetProperty("ProductId")</p>
<p>    .GetValue(@event)</p>
<p>    .ToString();</p>
<p></code></pre></p>

<strong>With [StreamKey] (generated)</strong>:
<pre><code class="language-csharp">// ✅ Compile-time code generation - AOT-compatible
<p>private static string ExtractStreamId(ProductCreatedEvent @event) {</p>
<p>  return @event.ProductId.ToString();</p>
<p>}</p>
<p></code></pre></p>

<p>This generated code:</p>
<ul><li>Works with Native AOT</li>
<li>Has zero runtime overhead</li>
<li>Is type-safe at compile-time</li>
</ul>
<h2>See Also</h2>

<ul><li><a href="../core-concepts/perspectives.md">Perspectives</a> - Pure function perspectives using StreamKey</li>
<li><a href="../core-concepts/perspectives.md#perspectiverunner-architecture">PerspectiveRunner Architecture</a> - How runners use StreamKey</li>
<li><a href="../diagnostics/whiz030.md">WHIZ030 Diagnostic</a> - Missing StreamKey error</li>
<li><a href="../diagnostics/whiz031.md">WHIZ031 Diagnostic</a> - Multiple StreamKey error</li>
<li><a href="../core-concepts/event-sourcing.md">Event Sourcing</a> - Understanding aggregates and streams</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Components</h2>
<article id="v1-0-0-components-readme" class="doc-section">
  <h3>Core Components Overview</h3>
  <p class="doc-path"><code>v1.0.0/components/README</code></p>
  <p class="doc-description"><em>Overview of all core components in Whizbang v0.1.0</em></p>
  <div class="doc-content">

<h1>Core Components Overview</h1>

<h2>Component Architecture</h2>

<p>All components in Whizbang v1.0.0 work together to provide a complete message-driven architecture. Each component has a specific responsibility and clean interface.</p>

<pre><code class="language-mermaid">graph LR
<p>    CMD[Command] --> D[Dispatcher]</p>
<p>    D --> R[Receptor]</p>
<p>    R --> E[Event]</p>
<p>    E --> D</p>
<p>    D --> P[Perspectives]</p>
<p>    P --> S[(Storage)]</p>
<p>    </p>
<p>    Q[Query] --> L[Lens]</p>
<p>    L --> S</p>
<p>    </p>
<p>    POL[Policies] -.->|Wrap| R</p>
<p>    POL -.->|Wrap| P</p>
<p>    </p>
<p>    style CMD fill:#e3f2fd</p>
<p>    style E fill:#fff3e0</p>
<p>    style Q fill:#f3e5f5</p>
<p></code></pre></p>

<h2>Component Responsibilities</h2>

<h3>Message Flow Components</h3>

<p>| Component | Responsibility | Interface |</p>
<p>|-----------|---------------|-----------|</p>
<p>| <strong><a href="dispatcher.md">Dispatcher</a></strong> | Routes all messages | <code>IDispatcher</code> |</p>
<p>| <strong><a href="receptors.md">Receptors</a></strong> | Receive messages, make decisions | <code>IReceptor<T, R></code> |</p>
<p>| <strong><a href="perspectives.md">Perspectives</a></strong> | React to events, update state | <code>IPerspectiveOf<T></code> |</p>
<p>| <strong><a href="lenses.md">Lenses</a></strong> | Provide read-only queries | <code>ILens</code> |</p>

<h3>Infrastructure Components</h3>

<p>| Component | Responsibility | Interface |</p>
<p>|-----------|---------------|-----------|</p>
<p>| <strong><a href="policy-engine.md">Policy Engine</a></strong> | Cross-cutting concerns | <code>IPolicyOf<T></code> |</p>
<p>| <strong><a href="ledger.md">Ledger</a></strong> | Event storage abstraction | <code>ILedger</code> |</p>
<p>| <strong><a href="drivers.md">Drivers</a></strong> | Database abstraction | <code>IDriver</code> |</p>
<p>| <strong><a href="transports.md">Transports</a></strong> | Message broker abstraction | <code>ITransport</code> |</p>

<h2>In-Memory Implementations</h2>

<p>In v1.0.0, all components have in-memory implementations:</p>

<pre><code class="language-csharp">services.AddWhizbang(options => {
<p>    options.UseInMemory();  // Configures all in-memory implementations</p>
<p>});</p>
<p></code></pre></p>

<p>This configures:</p>
<ul><li><code>InMemoryDispatcher</code> - Routes messages via dictionary</li>
<li><code>InMemoryLedger</code> - Stores events in lists</li>
<li><code>InMemoryDriver</code> - Stores data in dictionaries</li>
<li><code>InMemoryTransport</code> - Pub/sub via event handlers</li>
</ul>
<h2>Component Interaction</h2>

<h3>Command Processing Flow</h3>

<ul><li><strong>Command</strong> submitted to <strong>Dispatcher</strong></li>
<li><strong>Dispatcher</strong> routes to appropriate <strong>Receptor</strong></li>
<li><strong>Receptor</strong> validates and makes decision</li>
<li><strong>Receptor</strong> returns <strong>Event(s)</strong></li>
<li><strong>Dispatcher</strong> publishes events to <strong>Perspectives</strong></li>
<li><strong>Perspectives</strong> update their state</li>
</ul>
<h3>Query Processing Flow</h3>

<ul><li><strong>Query</strong> request made</li>
<li><strong>Dispatcher</strong> provides appropriate <strong>Lens</strong></li>
<li><strong>Lens</strong> queries underlying storage</li>
<li>Results returned to caller</li>
</ul>
<h3>Policy Application</h3>

<p>Policies wrap component execution:</p>

<pre><code class="language-csharp">[Retry(3)]
<p>[Timeout(5000)]</p>
<p>public class PaymentReceptor : IReceptor<ProcessPayment> {</p>
<p>    // Policies applied automatically via source generation</p>
<p>}</p>
<p></code></pre></p>

<h2>Component Discovery</h2>

<p>All components are discovered at compile time:</p>

<pre><code class="language-csharp">[WhizbangHandler]  // Source generator finds this
<p>public class OrderReceptor : IReceptor<CreateOrder> { }</p>

<p>[WhizbangHandler]  // And this</p>
<p>public class OrderPerspective : IPerspectiveOf<OrderCreated> { }</p>

<p>[WhizbangLens]  // And this</p>
<p>public class OrderLens : IOrderLens { }</p>
<p></code></pre></p>

<h2>Component Registration</h2>

<p>Source generators create registration code:</p>

<pre><code class="language-csharp">// Generated code
<p>public static class WhizbangGenerated {</p>
<p>    public static void RegisterHandlers(IServiceCollection services) {</p>
<p>        services.AddScoped<IReceptor<CreateOrder>, OrderReceptor>();</p>
<p>        services.AddScoped<IPerspectiveOf<OrderCreated>, OrderPerspective>();</p>
<p>        services.AddScoped<IOrderLens, OrderLens>();</p>
<p>        // ... all discovered components</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Component Testing</h2>

<p>All components are testable via in-memory implementations:</p>

<pre><code class="language-csharp">[Test]
<p>public async Task TestOrderFlow() {</p>
<p>    var dispatcher = new InMemoryDispatcher();</p>
<p>    var ledger = new InMemoryLedger();</p>
<p>    </p>
<p>    // Register components</p>
<p>    dispatcher.Register(new OrderReceptor());</p>
<p>    dispatcher.Register(new OrderPerspective());</p>
<p>    </p>
<p>    // Test command flow</p>
<p>    var result = await dispatcher.Send(new CreateOrder(...));</p>
<p>    </p>
<p>    // Verify</p>
<p>    Assert.IsType<OrderCreated>(result);</p>
<p>}</p>
<p></code></pre></p>

<h2>Component Guidelines</h2>

<h3>Interface Segregation</h3>
<p>Each component has a focused interface with single responsibility.</p>

<h3>Dependency Injection</h3>
<p>All components are registered in DI container and resolved automatically.</p>

<h3>Testability</h3>
<p>Every component can be tested in isolation using in-memory implementations.</p>

<h3>Extensibility</h3>
<p>New components can be added by implementing the appropriate interface.</p>

<h2>Navigation</h2>

<h3>Detailed Documentation</h3>
<ul><li><a href="dispatcher.md">Dispatcher</a> - Message routing</li>
<li><a href="receptors.md">Receptors</a> - Command handling</li>
<li><a href="perspectives.md">Perspectives</a> - Event handling</li>
<li><a href="lenses.md">Lenses</a> - Queries</li>
<li><a href="policy-engine.md">Policy Engine</a> - Cross-cutting concerns</li>
<li><a href="ledger.md">Ledger</a> - Event storage</li>
<li><a href="drivers.md">Drivers</a> - Database abstraction</li>
<li><a href="transports.md">Transports</a> - Messaging abstraction</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-components-dispatcher" class="doc-section">
  <h3>Dispatcher Component</h3>
  <p class="doc-path"><code>v1.0.0/components/dispatcher</code></p>
  <p class="doc-description"><em>Core message routing and orchestration with basic handler discovery</em></p>
  <div class="doc-content">

<h1>Dispatcher Component</h1>

<p>!<a href="https://img.shields.io/badge/version-1.0.0-blue">Version</a></p>
<p>!<a href="https://img.shields.io/badge/status-stable-green">Status</a></p>

<h2>Version History</h2>

<p>:::new</p>
<strong>New in v1.0.0</strong>: Basic message dispatcher with handler discovery and in-process routing
<p>:::</p>


<h2>Overview</h2>

<p>The Dispatcher is the heart of Whizbang - it routes messages to handlers, orchestrates component interactions, and ensures proper execution flow. In v1.0.0, it provides basic handler discovery and routing with support for commands, events, and queries.</p>

<h2>What is a Dispatcher?</h2>

<p>A Dispatcher:</p>
<ul><li><strong>Routes</strong> messages to appropriate handlers</li>
<li><strong>Orchestrates</strong> component interactions</li>
<li><strong>Manages</strong> execution flow and dependencies</li>
<li><strong>Coordinates</strong> between receptors, perspectives, and lenses</li>
</ul>
<p>Think of the dispatcher as the conductor of an orchestra - it ensures each component plays its part at the right time.</p>

<h2>Core Interface (v1.0.0)</h2>

<p>:::new</p>
<p>The fundamental dispatcher interface with three distinct patterns:</p>
<p>:::</p>

<pre><code class="language-csharp">public interface IDispatcher {
<p>    // Send command - returns delivery receipt (can work over wire)</p>
<p>    Task<IDeliveryReceipt> SendAsync(object message);</p>
<p>    Task<IDeliveryReceipt> SendAsync(object message, IMessageContext context);</p>

<p>    // Local invocation - returns typed result (in-process only, zero allocation)</p>
<p>    Task<TResult> LocalInvokeAsync<TResult>(object message);</p>
<p>    Task<TResult> LocalInvokeAsync<TResult>(object message, IMessageContext context);</p>

<p>    // Publish event to all interested perspectives (fire-and-forget)</p>
<p>    Task PublishAsync<TEvent>(TEvent @event);</p>

<p>    // Batch operations</p>
<p>    Task<IEnumerable<IDeliveryReceipt>> SendManyAsync(IEnumerable<object> messages);</p>
<p>    Task<IEnumerable<TResult>> LocalInvokeManyAsync<TResult>(IEnumerable<object> messages);</p>
<p>}</p>
<p></code></pre></p>

<h2>Three Dispatch Patterns</h2>

<h3>SendAsync - Command Dispatch with Acknowledgment</h3>

<strong>Use when</strong>: Sending commands that may execute remotely or asynchronously

<pre><code class="language-csharp">// Returns delivery receipt, not business result
<p>var receipt = await dispatcher.SendAsync(new ProcessOrder(orderId));</p>

<p>// Receipt contains delivery metadata</p>
<p>Console.WriteLine($"Message {receipt.MessageId} delivered at {receipt.Timestamp}");</p>
<p>Console.WriteLine($"Status: {receipt.Status}"); // Accepted, Queued, Delivered</p>
<p></code></pre></p>

<strong>Characteristics</strong>:
<ul><li>Returns <code>IDeliveryReceipt</code> with correlation info</li>
<li>Can work over network transports (future versions)</li>
<li>Supports inbox pattern and async workflows</li>
<li>Includes full observability envelope</li>
</ul>
<h3>LocalInvokeAsync - In-Process RPC</h3>

<strong>Use when</strong>: Calling handlers within the same process and need the business result immediately

<pre><code class="language-csharp">// Returns typed business result
<p>var result = await dispatcher.LocalInvokeAsync<OrderCreated>(new CreateOrder(items));</p>

<p>// Access business data directly</p>
<p>Console.WriteLine($"Order created: {result.OrderId}");</p>
<p></code></pre></p>

<strong>Characteristics</strong>:
<ul><li>Returns strongly-typed business result</li>
<li><strong>In-process only</strong> - throws if used with remote transport</li>
<li><strong>Zero allocation</strong> - skips envelope creation for maximum performance</li>
<li>Target: < 20ns per invocation, 0 bytes allocated</li>
<li>Ideal for high-throughput local workflows</li>
</ul>
<h3>PublishAsync - Event Broadcasting</h3>

<strong>Use when</strong>: Notifying multiple handlers about an event

<pre><code class="language-csharp">// Fire-and-forget to all subscribers
<p>await dispatcher.PublishAsync(new OrderPlaced(orderId));</p>

<p>// All perspectives receive the event</p>
<p>// - OrderPerspective updates order view</p>
<p>// - InventoryPerspective reserves items</p>
<p>// - NotificationPerspective sends email</p>
<p></code></pre></p>

<strong>Characteristics</strong>:
<ul><li>Fire-and-forget semantics</li>
<li>No return value</li>
<li>Fans out to all registered handlers</li>
<li>Handlers execute independently</li>
</ul>
<h2>When To Use Which Pattern</h2>

<p>| Pattern | Use Case | Returns | Can Go Over Wire | Performance Target |</p>
<p>|---------|----------|---------|------------------|-------------------|</p>
<p>| <strong>SendAsync</strong> | Async workflows, remote execution, inbox pattern | Delivery receipt | ✅ Yes (future) | Normal |</p>
<p>| <strong>LocalInvokeAsync</strong> | High-throughput local calls, immediate results | Business result | ❌ No | < 20ns, 0B |</p>
<p>| <strong>PublishAsync</strong> | Event notification, fan-out | void | ✅ Yes (future) | Normal |</p>

<h2>Delivery Receipt</h2>

<p>The <code>IDeliveryReceipt</code> provides correlation and tracking information:</p>

<pre><code class="language-csharp">public interface IDeliveryReceipt {
<p>    MessageId MessageId { get; }         // Unique message identifier</p>
<p>    DateTimeOffset Timestamp { get; }     // When message was accepted</p>
<p>    string Destination { get; }           // Where message was routed</p>
<p>    DeliveryStatus Status { get; }        // Accepted, Queued, Delivered</p>
<p>    IReadOnlyDictionary<string, object> Metadata { get; } // Extensible data</p>
<p>}</p>

<p>public enum DeliveryStatus {</p>
<p>    Accepted,   // Message accepted by dispatcher</p>
<p>    Queued,     // Message queued for async processing</p>
<p>    Delivered   // Message delivered to handler</p>
<p>}</p>
<p></code></pre></p>

<h2>Pipeline Behaviors</h2>

<p>:::new</p>
<p>v1.0.0 introduces pipeline behavior support for cross-cutting concerns:</p>
<p>:::</p>

<p>Pipeline behaviors allow you to inject middleware-style logic into the dispatch flow. Common use cases include:</p>
<ul><li><strong>Inbox Pattern</strong> - De-duplicate messages, ensure idempotency</li>
<li><strong>Validation</strong> - Validate commands before execution</li>
<li><strong>Logging</strong> - Log all messages and results</li>
<li><strong>Retry Logic</strong> - Automatically retry failed operations</li>
<li><strong>Performance Monitoring</strong> - Track execution times</li>
<li><strong>Transaction Management</strong> - Wrap execution in transactions</li>
</ul>
<h3>IPipelineBehavior Interface</h3>

<pre><code class="language-csharp">public interface IPipelineBehavior<TRequest, TResponse> {
<p>    /// <summary></p>
<p>    /// Execute behavior and optionally call next in pipeline</p>
<p>    /// </summary></p>
<p>    /// <param name="request">The message being dispatched</param></p>
<p>    /// <param name="next">Delegate to invoke next behavior or handler</param></p>
<p>    /// <param name="cancellationToken">Cancellation token</param></p>
<p>    /// <returns>The response (potentially modified)</returns></p>
<p>    Task<TResponse> Handle(</p>
<p>        TRequest request,</p>
<p>        Func<Task<TResponse>> next,</p>
<p>        CancellationToken cancellationToken = default</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<h3>Example: Inbox Pattern Behavior</h3>

<pre><code class="language-csharp">public class InboxBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse> {
<p>    private readonly IInboxStore _inbox;</p>

<p>    public async Task<TResponse> Handle(</p>
<p>        TRequest request,</p>
<p>        Func<Task<TResponse>> next,</p>
<p>        CancellationToken cancellationToken</p>
<p>    ) {</p>
<p>        var messageId = GetMessageId(request);</p>

<p>        // Check if already processed</p>
<p>        if (await _inbox.HasProcessedAsync(messageId)) {</p>
<p>            return await _inbox.GetResultAsync<TResponse>(messageId);</p>
<p>        }</p>

<p>        // Mark as processing</p>
<p>        await _inbox.MarkProcessingAsync(messageId);</p>

<p>        try {</p>
<p>            // Execute handler</p>
<p>            var response = await next();</p>

<p>            // Store result</p>
<p>            await _inbox.StoreResultAsync(messageId, response);</p>

<p>            return response;</p>
<p>        } catch (Exception ex) {</p>
<p>            await _inbox.MarkFailedAsync(messageId, ex);</p>
<p>            throw;</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Example: Validation Behavior</h3>

<pre><code class="language-csharp">public class ValidationBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse> {
<p>    private readonly IValidator<TRequest> _validator;</p>

<p>    public async Task<TResponse> Handle(</p>
<p>        TRequest request,</p>
<p>        Func<Task<TResponse>> next,</p>
<p>        CancellationToken cancellationToken</p>
<p>    ) {</p>
<p>        // Validate request</p>
<p>        var validationResult = await _validator.ValidateAsync(request);</p>

<p>        if (!validationResult.IsValid) {</p>
<p>            throw new ValidationException(validationResult.Errors);</p>
<p>        }</p>

<p>        // Continue pipeline</p>
<p>        return await next();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Example: Logging Behavior</h3>

<pre><code class="language-csharp">public class LoggingBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse> {
<p>    private readonly ILogger _logger;</p>

<p>    public async Task<TResponse> Handle(</p>
<p>        TRequest request,</p>
<p>        Func<Task<TResponse>> next,</p>
<p>        CancellationToken cancellationToken</p>
<p>    ) {</p>
<p>        var requestName = typeof(TRequest).Name;</p>
<p>        _logger.LogInformation("Handling {Request}", requestName);</p>

<p>        var stopwatch = Stopwatch.StartNew();</p>

<p>        try {</p>
<p>            var response = await next();</p>

<p>            stopwatch.Stop();</p>
<p>            _logger.LogInformation(</p>
<p>                "Handled {Request} in {Elapsed}ms",</p>
<p>                requestName,</p>
<p>                stopwatch.ElapsedMilliseconds</p>
<p>            );</p>

<p>            return response;</p>
<p>        } catch (Exception ex) {</p>
<p>            stopwatch.Stop();</p>
<p>            _logger.LogError(</p>
<p>                ex,</p>
<p>                "Error handling {Request} after {Elapsed}ms",</p>
<p>                requestName,</p>
<p>                stopwatch.ElapsedMilliseconds</p>
<p>            );</p>
<p>            throw;</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Registering Behaviors</h3>

<pre><code class="language-csharp">services.AddWhizbangDispatcher(dispatcher => {
<p>    // Behaviors execute in registration order</p>
<p>    dispatcher.AddPipelineBehavior<InboxBehavior<,>>();</p>
<p>    dispatcher.AddPipelineBehavior<ValidationBehavior<,>>();</p>
<p>    dispatcher.AddPipelineBehavior<LoggingBehavior<,>>();</p>
<p>});</p>
<p></code></pre></p>

<h3>Performance Considerations</h3>

<p>Pipeline behaviors add overhead to each dispatch:</p>
<ul><li><strong>Target</strong>: < 5% overhead per behavior</li>
<li><strong>Recommendation</strong>: Keep behaviors lightweight</li>
<li><strong>Optimization</strong>: Use struct-based behaviors where possible</li>
<li><strong>Monitoring</strong>: Track behavior execution times</li>
</ul>
<h2>In-Memory Implementation</h2>

<pre><code class="language-csharp">public class InMemoryDispatcher : IDispatcher {
<p>    private readonly Dictionary<Type, Delegate> _handlers;</p>
<p>    private readonly Dictionary<Type, List<Delegate>> _eventHandlers;</p>
<p>    private readonly IServiceProvider _serviceProvider;</p>
<p>    </p>
<p>    public InMemoryDispatcher(IServiceProvider serviceProvider) {</p>
<p>        _serviceProvider = serviceProvider;</p>
<p>        _handlers = WhizbangGenerated.GetCommandHandlers();  // Source-generated</p>
<p>        _eventHandlers = WhizbangGenerated.GetEventHandlers();  // Source-generated</p>
<p>    }</p>
<p>    </p>
<p>    public async Task<TResult> Send<TResult>(ICommand<TResult> command) {</p>
<p>        var commandType = command.GetType();</p>
<p>        </p>
<p>        if (!_handlers.TryGetValue(commandType, out var handler)) {</p>
<p>            throw new HandlerNotFoundException(commandType);</p>
<p>        }</p>
<p>        </p>
<p>        // Apply policies (generated code handles this)</p>
<p>        var receptor = _serviceProvider.GetRequiredService(handler.Method.DeclaringType);</p>
<p>        var result = await handler.DynamicInvoke(receptor, command);</p>
<p>        </p>
<p>        // If result is an event, publish it</p>
<p>        if (result is IEvent @event) {</p>
<p>            await Publish(@event);</p>
<p>        }</p>
<p>        </p>
<p>        return (TResult)result;</p>
<p>    }</p>
<p>    </p>
<p>    public async Task Publish<TEvent>(TEvent @event) {</p>
<p>        var eventType = @event.GetType();</p>
<p>        </p>
<p>        if (_eventHandlers.TryGetValue(eventType, out var handlers)) {</p>
<p>            var tasks = handlers.Select(async handler => {</p>
<p>                var perspective = _serviceProvider.GetRequiredService(handler.Method.DeclaringType);</p>
<p>                await handler.DynamicInvoke(perspective, @event);</p>
<p>            });</p>
<p>            </p>
<p>            await Task.WhenAll(tasks);</p>
<p>        }</p>
<p>    }</p>
<p>    </p>
<p>    public TLens GetLens<TLens>() where TLens : ILens {</p>
<p>        return _serviceProvider.GetRequiredService<TLens>();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Source-Generated Routing</h2>

<p>The source generator creates efficient routing tables:</p>

<pre><code class="language-csharp">// Generated by Whizbang.Generators
<p>public static partial class WhizbangGenerated {</p>
<p>    public static Dictionary<Type, Delegate> GetCommandHandlers() {</p>
<p>        return new Dictionary<Type, Delegate> {</p>
<p>            [typeof(CreateOrder)] = (Func<OrderReceptor, CreateOrder, Task<OrderCreated>>)</p>
<p>                ((receptor, cmd) => receptor.Receive(cmd)),</p>
<p>                </p>
<p>            [typeof(CancelOrder)] = (Func<OrderReceptor, CancelOrder, Task<OrderCancelled>>)</p>
<p>                ((receptor, cmd) => receptor.Cancel(cmd)),</p>
<p>                </p>
<p>            // ... all discovered handlers</p>
<p>        };</p>
<p>    }</p>
<p>    </p>
<p>    public static Dictionary<Type, List<Delegate>> GetEventHandlers() {</p>
<p>        return new Dictionary<Type, List<Delegate>> {</p>
<p>            [typeof(OrderCreated)] = new List<Delegate> {</p>
<p>                (Func<OrderPerspective, OrderCreated, Task>)</p>
<p>                    ((perspective, e) => perspective.Update(e)),</p>
<p>                    </p>
<p>                (Func<InventoryPerspective, OrderCreated, Task>)</p>
<p>                    ((perspective, e) => perspective.Update(e)),</p>
<p>            },</p>
<p>            </p>
<p>            // ... all discovered event handlers</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Message Context</h2>

<p>Every message carries context for traceability:</p>

<pre><code class="language-csharp">public class MessageContext : IMessageContext {
<p>    public Guid MessageId { get; init; } = Guid.NewGuid();</p>
<p>    public Guid CorrelationId { get; init; }</p>
<p>    public Guid CausationId { get; init; }</p>
<p>    public DateTimeOffset Timestamp { get; init; } = DateTimeOffset.UtcNow();</p>
<p>    public string UserId { get; init; }</p>
<p>    public Dictionary<string, object> Metadata { get; init; } = new();</p>
<p>    public ISpan? Span { get; init; }  // OpenTelemetry span</p>
<p>}</p>
<p></code></pre></p>

<h2>Policy Application</h2>

<p>The dispatcher applies policies through generated decorators:</p>

<pre><code class="language-csharp">// Source-generated decorator for policies
<p>public class PolicyAwareDispatcher : IDispatcher {</p>
<p>    private readonly IDispatcher _inner;</p>
<p>    private readonly IPolicyEngine _policies;</p>
<p>    </p>
<p>    public async Task<TResult> Send<TResult>(ICommand<TResult> command) {</p>
<p>        // Get policies for this command type (compile-time determined)</p>
<p>        var policies = WhizbangGenerated.GetPoliciesFor(command.GetType());</p>
<p>        </p>
<p>        // Apply policies in order</p>
<p>        return await _policies.Execute(policies, async () => {</p>
<p>            return await _inner.Send(command);</p>
<p>        });</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Traceability Integration</h2>

<p>The dispatcher provides hooks for traceability:</p>

<pre><code class="language-csharp">public class TraceableDispatcher : IDispatcher {
<p>    private readonly IDispatcher _inner;</p>
<p>    private readonly ITraceabilityService _traceability;</p>
<p>    </p>
<p>    public async Task<TResult> Send<TResult>(ICommand<TResult> command) {</p>
<p>        var span = _traceability.StartSpan($"Send {command.GetType().Name}");</p>
<p>        </p>
<p>        try {</p>
<p>            var result = await _inner.Send(command);</p>
<p>            </p>
<p>            _traceability.RecordSuccess(span, command, result);</p>
<p>            </p>
<p>            // Update IDE overlay</p>
<p>            _traceability.UpdateOverlay(command.GetType(), result?.GetType());</p>
<p>            </p>
<p>            return result;</p>
<p>        }</p>
<p>        catch (Exception ex) {</p>
<p>            _traceability.RecordError(span, command, ex);</p>
<p>            throw;</p>
<p>        }</p>
<p>        finally {</p>
<p>            span.End();</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Error Handling</h2>

<p>The dispatcher provides comprehensive error information:</p>

<pre><code class="language-csharp">public class HandlerNotFoundException : Exception {
<p>    public Type CommandType { get; }</p>
<p>    </p>
<p>    public HandlerNotFoundException(Type commandType) </p>
<p>        : base(FormatMessage(commandType)) {</p>
<p>        CommandType = commandType;</p>
<p>    }</p>
<p>    </p>
<p>    private static string FormatMessage(Type commandType) {</p>
<p>        return $@"</p>
<p>No handler found for command '{commandType.Name}'.</p>

<p>To fix this:</p>
<ul><li>Create a receptor that implements IReceptor<{commandType.Name}></li>
<li>Add the [WhizbangHandler] attribute to the receptor</li>
<li>Ensure the receptor is in a scanned assembly</li>
</ul>
<p>Example:</p>
<p>[WhizbangHandler]</p>
<p>public class {commandType.Name.Replace("Command", "")}Receptor : IReceptor<{commandType.Name}, {commandType.Name.Replace("Command", "")}Result> {{</p>
<p>    public async Task<{commandType.Name.Replace("Command", "")}Result> Receive({commandType.Name} command) {{</p>
<p>        // Handle command</p>
<p>    }}</p>
<p>}}</p>

<p>Quick Fix: Press Ctrl+. to generate the handler automatically.</p>
<p>";</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Configuration</h2>

<pre><code class="language-csharp">public class DispatcherOptions {
<p>    /// <summary></p>
<p>    /// Maximum time to wait for a handler (milliseconds)</p>
<p>    /// </summary></p>
<p>    public int DefaultTimeout { get; set; } = 30000;</p>
<p>    </p>
<p>    /// <summary></p>
<p>    /// Enable parallel event publishing</p>
<p>    /// </summary></p>
<p>    public bool ParallelEventPublishing { get; set; } = true;</p>
<p>    </p>
<p>    /// <summary></p>
<p>    /// Maximum degree of parallelism for events</p>
<p>    /// </summary></p>
<p>    public int MaxEventParallelism { get; set; } = 10;</p>
<p>    </p>
<p>    /// <summary></p>
<p>    /// Enable traceability hooks</p>
<p>    /// </summary></p>
<p>    public bool EnableTraceability { get; set; } = true;</p>
<p>    </p>
<p>    /// <summary></p>
<p>    /// Record performance metrics</p>
<p>    /// </summary></p>
<p>    public bool EnableMetrics { get; set; } = true;</p>
<p>}</p>
<p></code></pre></p>

<h2>Testing</h2>

<pre><code class="language-csharp">[Test]
<p>public class DispatcherTests {</p>
<p>    private IDispatcher _dispatcher;</p>
<p>    </p>
<p>    [SetUp]</p>
<p>    public void Setup() {</p>
<p>        var services = new ServiceCollection();</p>
<p>        services.AddWhizbang(o => o.UseInMemory());</p>
<p>        </p>
<p>        var provider = services.BuildServiceProvider();</p>
<p>        _dispatcher = provider.GetRequiredService<IDispatcher>();</p>
<p>    }</p>
<p>    </p>
<p>    [Test]</p>
<p>    public async Task Send_Command_Should_Return_Result() {</p>
<p>        // Arrange</p>
<p>        var command = new CreateOrder(</p>
<p>            CustomerId: Guid.NewGuid(),</p>
<p>            Items: new[] { new OrderItem("SKU-001", 2, 29.99m) }</p>
<p>        );</p>
<p>        </p>
<p>        // Act</p>
<p>        var result = await _dispatcher.Send(command);</p>
<p>        </p>
<p>        // Assert</p>
<p>        Assert.IsType<OrderCreated>(result);</p>
<p>        Assert.NotEqual(Guid.Empty, result.OrderId);</p>
<p>    }</p>
<p>    </p>
<p>    [Test]</p>
<p>    public async Task Publish_Event_Should_Notify_All_Perspectives() {</p>
<p>        // Arrange</p>
<p>        var @event = new OrderCreated(Guid.NewGuid(), Guid.NewGuid());</p>
<p>        var notificationCount = 0;</p>
<p>        </p>
<p>        // Subscribe to notifications</p>
<p>        _dispatcher.Subscribe<OrderCreated>(e => {</p>
<p>            notificationCount++;</p>
<p>            return Task.CompletedTask;</p>
<p>        });</p>
<p>        </p>
<p>        // Act</p>
<p>        await _dispatcher.Publish(@event);</p>
<p>        </p>
<p>        // Assert</p>
<p>        Assert.Greater(notificationCount, 0);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Performance Characteristics</h2>

<p>| Operation | Target | Actual (v1.0.0) |</p>
<p>|-----------|--------|-----------------|</p>
<p>| Command Routing | < 100ns | TBD |</p>
<p>| Event Publishing (1 handler) | < 1μs | TBD |</p>
<p>| Event Publishing (10 handlers) | < 10μs | TBD |</p>
<p>| Context Creation | < 50ns | TBD |</p>
<p>| Policy Application | < 1μs per policy | TBD |</p>

<h2>IDE Integration</h2>

<p>The dispatcher provides real-time information to the IDE:</p>

<pre><code class="language-csharp">// IDE shows: "5 commands routed | 23 events published | Last: 2ms ago"
<p>public interface IDispatcher { }</p>

<p>// IDE shows: "Routed 15 times | Avg: 1.2ms | Last: CreateOrder"</p>
<p>public async Task<TResult> Send<TResult>(ICommand<TResult> command);</p>
<p></code></pre></p>

<h2>Limitations in v1.0.0</h2>

<p>:::info</p>
<p>These limitations are addressed in future versions:</p>
<p>:::</p>

<ul><li><strong>No middleware</strong> - Cannot inject cross-cutting concerns</li>
<li><strong>Sequential execution</strong> - Perspectives run one at a time</li>
<li><strong>No saga support</strong> - Cannot coordinate multi-step workflows</li>
<li><strong>No retry logic</strong> - Failed operations aren't retried</li>
<li><strong>Single instance</strong> - No distributed coordination</li>
</ul>
<h2>Migration Path</h2>

<h3>To v0.2.0 (Pipeline & Middleware)</h3>

<p>:::planned</p>
<p>v0.2.0 adds pipeline processing:</p>
<p>:::</p>

<pre><code class="language-csharp">// v0.2.0 - Middleware pipeline
<p>services.AddWhizbangDispatcher(dispatcher => {</p>
<p>    dispatcher.AddMiddleware<LoggingMiddleware>();</p>
<p>    dispatcher.AddMiddleware<ValidationMiddleware>();</p>
<p>    dispatcher.AddMiddleware<MetricsMiddleware>();</p>
<p>});</p>
<p></code></pre></p>

<h3>To v0.3.0 (Saga Orchestration)</h3>

<p>:::planned</p>
<p>v0.3.0 adds workflow support:</p>
<p>:::</p>

<pre><code class="language-csharp">// v0.3.0 - Saga orchestration
<p>public class OrderSaga : ISaga<CreateOrder> {</p>
<p>    public async Task<SagaResult> Execute(CreateOrder command) {</p>
<p>        // Multi-step workflow with compensation</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Best Practices</h2>

<ul><li><strong>Keep dispatcher thin</strong> - Logic belongs in handlers, not dispatcher</li>
<li><strong>Handle errors gracefully</strong> - Don't let one perspective failure break all</li>
<li><strong>Use dependency injection</strong> - Let DI container manage lifetimes</li>
<li><strong>Monitor performance</strong> - Track dispatch times and success rates</li>
<li><strong>Test handler discovery</strong> - Ensure all handlers are registered</li>
<li><strong>Design for async</strong> - All operations should be async</li>
</ul>
<h2>Related Documentation</h2>

<ul><li><a href="receptors.md">Receptors</a> - Command handlers</li>
<li><a href="perspectives.md">Perspectives</a> - Event handlers</li>
<li><a href="lenses.md">Lenses</a> - Query handlers</li>
<li><a href="ledger.md">Ledger</a> - Event storage</li>
<li><a href="../../roadmap/FEATURE-EVOLUTION.md">Feature Evolution</a> - How dispatcher evolves</li>
</ul>
<h2>Next Steps</h2>

<ul><li>See <a href="../../v0.2.0/enhancements/dispatcher.md">v0.2.0 Pipeline</a> for middleware support</li>
<li>See <a href="../../v0.3.0/features/dispatcher.md">v0.3.0 Orchestration</a> for saga patterns</li>
<li>Review <a href="../examples/dispatcher-patterns.md">Examples</a> for usage patterns</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-components-drivers" class="doc-section">
  <h3>Drivers Component</h3>
  <p class="doc-path"><code>v1.0.0/components/drivers</code></p>
  <p class="doc-description"><em>Basic in-memory storage driver for development and testing</em></p>
  <div class="doc-content">

<h1>Drivers Component</h1>

<p>!<a href="https://img.shields.io/badge/version-1.0.0-blue">Version</a></p>
<p>!<a href="https://img.shields.io/badge/status-stable-green">Status</a></p>

<h2>Version History</h2>

<p>:::new</p>
<strong>New in v1.0.0</strong>: Basic in-memory driver with simple key-value storage abstraction
<p>:::</p>


<h2>Overview</h2>

<p>Drivers provide the storage abstraction layer in Whizbang, allowing the framework to work with different storage backends without changing application code. In v1.0.0, we provide a simple in-memory driver perfect for development, testing, and prototyping.</p>

<h2>What is a Driver?</h2>

<p>A Driver:</p>
<ul><li><strong>Abstracts</strong> storage implementation details</li>
<li><strong>Provides</strong> a consistent interface for data operations</li>
<li><strong>Handles</strong> serialization and deserialization</li>
<li><strong>Manages</strong> connections and resources</li>
</ul>
<p>Think of drivers as adapters that allow Whizbang to speak different storage "languages" while maintaining a consistent programming model.</p>

<h2>Core Interface (v1.0.0)</h2>

<p>:::new</p>
<p>The basic driver interface for storage operations:</p>
<p>:::</p>

<pre><code class="language-csharp">public interface IDriver {
<p>    // Basic CRUD operations</p>
<p>    Task<T?> Get<T>(string key) where T : class;</p>
<p>    Task Set<T>(string key, T value) where T : class;</p>
<p>    Task<bool> Delete(string key);</p>
<p>    Task<bool> Exists(string key);</p>
<p>    </p>
<p>    // Collection operations</p>
<p>    Task<IEnumerable<T>> GetAll<T>(string prefix = "") where T : class;</p>
<p>    Task Clear(string prefix = "");</p>
<p>    </p>
<p>    // Driver metadata</p>
<p>    string Name { get; }</p>
<p>    DriverCapabilities Capabilities { get; }</p>
<p>}</p>

<p>public enum DriverCapabilities {</p>
<p>    None = 0,</p>
<p>    Persistence = 1,</p>
<p>    Transactions = 2,</p>
<p>    Queries = 4,</p>
<p>    Indexing = 8,</p>
<p>    Streaming = 16</p>
<p>}</p>
<p></code></pre></p>

<h2>In-Memory Driver</h2>

<p>:::new</p>
<p>The default in-memory driver for v1.0.0:</p>
<p>:::</p>

<pre><code class="language-csharp">[WhizbangDriver("InMemory")]
<p>public class InMemoryDriver : IDriver {</p>
<p>    private readonly ConcurrentDictionary<string, object> _store = new();</p>
<p>    private readonly ReaderWriterLockSlim _lock = new();</p>
<p>    </p>
<p>    public string Name => "InMemory";</p>
<p>    public DriverCapabilities Capabilities => DriverCapabilities.None;</p>
<p>    </p>
<p>    public Task<T?> Get<T>(string key) where T : class {</p>
<p>        _lock.EnterReadLock();</p>
<p>        try {</p>
<p>            if (_store.TryGetValue(key, out var value)) {</p>
<p>                return Task.FromResult(value as T);</p>
<p>            }</p>
<p>            return Task.FromResult<T?>(null);</p>
<p>        }</p>
<p>        finally {</p>
<p>            _lock.ExitReadLock();</p>
<p>        }</p>
<p>    }</p>
<p>    </p>
<p>    public Task Set<T>(string key, T value) where T : class {</p>
<p>        _lock.EnterWriteLock();</p>
<p>        try {</p>
<p>            _store[key] = value;</p>
<p>            return Task.CompletedTask;</p>
<p>        }</p>
<p>        finally {</p>
<p>            _lock.ExitWriteLock();</p>
<p>        }</p>
<p>    }</p>
<p>    </p>
<p>    public Task<bool> Delete(string key) {</p>
<p>        _lock.EnterWriteLock();</p>
<p>        try {</p>
<p>            return Task.FromResult(_store.TryRemove(key, out _));</p>
<p>        }</p>
<p>        finally {</p>
<p>            _lock.ExitWriteLock();</p>
<p>        }</p>
<p>    }</p>
<p>    </p>
<p>    public Task<bool> Exists(string key) {</p>
<p>        _lock.EnterReadLock();</p>
<p>        try {</p>
<p>            return Task.FromResult(_store.ContainsKey(key));</p>
<p>        }</p>
<p>        finally {</p>
<p>            _lock.ExitReadLock();</p>
<p>        }</p>
<p>    }</p>
<p>    </p>
<p>    public Task<IEnumerable<T>> GetAll<T>(string prefix = "") where T : class {</p>
<p>        _lock.EnterReadLock();</p>
<p>        try {</p>
<p>            var results = _store</p>
<p>                .Where(kvp => string.IsNullOrEmpty(prefix) || kvp.Key.StartsWith(prefix))</p>
<p>                .Select(kvp => kvp.Value)</p>
<p>                .OfType<T>();</p>
<p>            </p>
<p>            return Task.FromResult<IEnumerable<T>>(results.ToList());</p>
<p>        }</p>
<p>        finally {</p>
<p>            _lock.ExitReadLock();</p>
<p>        }</p>
<p>    }</p>
<p>    </p>
<p>    public Task Clear(string prefix = "") {</p>
<p>        _lock.EnterWriteLock();</p>
<p>        try {</p>
<p>            if (string.IsNullOrEmpty(prefix)) {</p>
<p>                _store.Clear();</p>
<p>            } else {</p>
<p>                var keysToRemove = _store.Keys</p>
<p>                    .Where(k => k.StartsWith(prefix))</p>
<p>                    .ToList();</p>
<p>                </p>
<p>                foreach (var key in keysToRemove) {</p>
<p>                    _store.TryRemove(key, out _);</p>
<p>                }</p>
<p>            }</p>
<p>            return Task.CompletedTask;</p>
<p>        }</p>
<p>        finally {</p>
<p>            _lock.ExitWriteLock();</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Driver Registration</h2>

<p>Drivers are registered at startup and discovered by source generators:</p>

<pre><code class="language-csharp">// Manual registration
<p>services.AddWhizbangDrivers(options => {</p>
<p>    options.UseInMemory();</p>
<p>});</p>

<p>// Or with configuration</p>
<p>services.AddWhizbangDrivers(options => {</p>
<p>    options.UseDriver<InMemoryDriver>("default");</p>
<p>    options.UseDriver<InMemoryDriver>("cache");</p>
<p>});</p>

<p>// Source generated registration</p>
<p>public static partial class WhizbangGenerated {</p>
<p>    public static void RegisterDrivers(IServiceCollection services) {</p>
<p>        services.AddSingleton<IDriver, InMemoryDriver>();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Store Abstraction</h2>

<p>:::new</p>
<p>Higher-level store abstraction built on drivers:</p>
<p>:::</p>

<pre><code class="language-csharp">public interface IStore<T> where T : class {
<p>    Task<T?> GetById(string id);</p>
<p>    Task Save(string id, T entity);</p>
<p>    Task Delete(string id);</p>
<p>    Task<IEnumerable<T>> GetAll();</p>
<p>}</p>

<p>public class DriverStore<T> : IStore<T> where T : class {</p>
<p>    private readonly IDriver _driver;</p>
<p>    private readonly string _prefix;</p>
<p>    </p>
<p>    public DriverStore(IDriver driver) {</p>
<p>        _driver = driver;</p>
<p>        _prefix = $"{typeof(T).Name}:";</p>
<p>    }</p>
<p>    </p>
<p>    public Task<T?> GetById(string id) {</p>
<p>        return _driver.Get<T>($"{_prefix}{id}");</p>
<p>    }</p>
<p>    </p>
<p>    public Task Save(string id, T entity) {</p>
<p>        return _driver.Set($"{_prefix}{id}", entity);</p>
<p>    }</p>
<p>    </p>
<p>    public Task Delete(string id) {</p>
<p>        return _driver.Delete($"{_prefix}{id}");</p>
<p>    }</p>
<p>    </p>
<p>    public Task<IEnumerable<T>> GetAll() {</p>
<p>        return _driver.GetAll<T>(_prefix);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Using Drivers in Components</h2>

<h3>In Perspectives</h3>

<pre><code class="language-csharp">public class OrderPerspective : IPerspectiveOf<OrderCreated> {
<p>    private readonly IStore<Order> _orderStore;</p>
<p>    </p>
<p>    public OrderPerspective(IDriver driver) {</p>
<p>        _orderStore = new DriverStore<Order>(driver);</p>
<p>    }</p>
<p>    </p>
<p>    public async Task Update(OrderCreated @event) {</p>
<p>        var order = new Order {</p>
<p>            Id = @event.OrderId,</p>
<p>            CustomerId = @event.CustomerId,</p>
<p>            Items = @event.Items,</p>
<p>            Total = @event.Total,</p>
<p>            Status = OrderStatus.Created</p>
<p>        };</p>
<p>        </p>
<p>        await _orderStore.Save(@event.OrderId.ToString(), order);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>In Lenses</h3>

<pre><code class="language-csharp">public class OrderLens : IOrderLens {
<p>    private readonly IStore<Order> _orderStore;</p>
<p>    </p>
<p>    public OrderLens(IDriver driver) {</p>
<p>        _orderStore = new DriverStore<Order>(driver);</p>
<p>    }</p>
<p>    </p>
<p>    public async Task<Order> Focus(Guid orderId) {</p>
<p>        return await _orderStore.GetById(orderId.ToString());</p>
<p>    }</p>
<p>    </p>
<p>    public async Task<IEnumerable<Order>> ViewAll() {</p>
<p>        return await _orderStore.GetAll();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Testing with Drivers</h2>

<pre><code class="language-csharp">[Test]
<p>public class DriverTests {</p>
<p>    private InMemoryDriver _driver;</p>
<p>    </p>
<p>    [SetUp]</p>
<p>    public void Setup() {</p>
<p>        _driver = new InMemoryDriver();</p>
<p>    }</p>
<p>    </p>
<p>    [Test]</p>
<p>    public async Task SetAndGet_ShouldStoreAndRetrieve() {</p>
<p>        // Arrange</p>
<p>        var testObject = new TestEntity { </p>
<p>            Id = "test-1", </p>
<p>            Name = "Test Entity" </p>
<p>        };</p>
<p>        </p>
<p>        // Act</p>
<p>        await _driver.Set("test-1", testObject);</p>
<p>        var retrieved = await _driver.Get<TestEntity>("test-1");</p>
<p>        </p>
<p>        // Assert</p>
<p>        Assert.NotNull(retrieved);</p>
<p>        Assert.Equal("Test Entity", retrieved.Name);</p>
<p>    }</p>
<p>    </p>
<p>    [Test]</p>
<p>    public async Task GetAll_WithPrefix_ShouldFilterResults() {</p>
<p>        // Arrange</p>
<p>        await _driver.Set("order:1", new Order { Id = Guid.NewGuid() });</p>
<p>        await _driver.Set("order:2", new Order { Id = Guid.NewGuid() });</p>
<p>        await _driver.Set("customer:1", new Customer { Id = Guid.NewGuid() });</p>
<p>        </p>
<p>        // Act</p>
<p>        var orders = await _driver.GetAll<Order>("order:");</p>
<p>        </p>
<p>        // Assert</p>
<p>        Assert.Equal(2, orders.Count());</p>
<p>    }</p>
<p>    </p>
<p>    [Test]</p>
<p>    public async Task Clear_WithPrefix_ShouldOnlyRemoveMatching() {</p>
<p>        // Arrange</p>
<p>        await _driver.Set("temp:1", new object());</p>
<p>        await _driver.Set("temp:2", new object());</p>
<p>        await _driver.Set("keep:1", new object());</p>
<p>        </p>
<p>        // Act</p>
<p>        await _driver.Clear("temp:");</p>
<p>        </p>
<p>        // Assert</p>
<p>        Assert.False(await _driver.Exists("temp:1"));</p>
<p>        Assert.False(await _driver.Exists("temp:2"));</p>
<p>        Assert.True(await _driver.Exists("keep:1"));</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Driver Selection Strategy</h2>

<pre><code class="language-csharp">public interface IDriverSelector {
<p>    IDriver GetDriver(string name);</p>
<p>    IDriver GetDriverForType<T>();</p>
<p>}</p>

<p>public class DriverSelector : IDriverSelector {</p>
<p>    private readonly Dictionary<string, IDriver> _drivers;</p>
<p>    </p>
<p>    public IDriver GetDriver(string name) {</p>
<p>        return _drivers.TryGetValue(name, out var driver) </p>
<p>            ? driver </p>
<p>            : _drivers["default"];</p>
<p>    }</p>
<p>    </p>
<p>    public IDriver GetDriverForType<T>() {</p>
<p>        // Can implement type-based routing</p>
<p>        var typeName = typeof(T).Name;</p>
<p>        </p>
<p>        return typeName switch {</p>
<p>            "Order" or "Customer" => GetDriver("primary"),</p>
<p>            "Cache" or "Session" => GetDriver("cache"),</p>
<p>            _ => GetDriver("default")</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>IDE Features</h2>

<pre><code class="language-csharp">// IDE shows: "Driver: InMemory | Objects: 234 | Memory: 5.2MB"
<p>public interface IDriver { }</p>

<p>// IDE shows: "Called 45 times | Avg: 0.1ms | Hit rate: 92%"</p>
<p>public Task<T?> Get<T>(string key) { }</p>

<p>// IDE shows: "Warning: No persistence - data lost on restart"</p>
<p>public class InMemoryDriver : IDriver { }</p>
<p></code></pre></p>

<h2>Performance Characteristics</h2>

<p>| Operation | Target | Actual |</p>
<p>|-----------|--------|--------|</p>
<p>| Get | < 100ns | TBD |</p>
<p>| Set | < 500ns | TBD |</p>
<p>| Delete | < 200ns | TBD |</p>
<p>| GetAll (1000 items) | < 1ms | TBD |</p>
<p>| Clear | < 100μs | TBD |</p>

<h2>Limitations in v1.0.0</h2>

<p>:::info</p>
<p>These limitations are addressed in future versions:</p>
<p>:::</p>

<ul><li><strong>No persistence</strong> - Data lost on restart</li>
<li><strong>No queries</strong> - Only key-based lookups</li>
<li><strong>No transactions</strong> - No atomicity guarantees</li>
<li><strong>No indexing</strong> - Linear scans for GetAll</li>
<li><strong>Memory only</strong> - Limited by available RAM</li>
</ul>
<h2>Migration Path</h2>

<h3>To v0.2.0 (File Storage)</h3>

<p>:::planned</p>
<p>v0.2.0 adds persistent file storage:</p>
<p>:::</p>

<pre><code class="language-csharp">// v0.2.0 - File-based driver
<p>services.AddWhizbangDrivers(options => {</p>
<p>    options.UseFileDriver(file => {</p>
<p>        file.DataDirectory = "./data";</p>
<p>        file.Format = SerializationFormat.Json;</p>
<p>        file.Compression = true;</p>
<p>    });</p>
<p>});</p>
<p></code></pre></p>

<h3>To v0.4.0 (Database Drivers)</h3>

<p>:::planned</p>
<p>v0.4.0 adds real database support:</p>
<p>:::</p>

<pre><code class="language-csharp">// v0.4.0 - SQL and NoSQL drivers
<p>services.AddWhizbangDrivers(options => {</p>
<p>    options.UsePostgreSQL("Host=localhost;Database=whizbang");</p>
<p>    options.UseMongoDB("mongodb://localhost:27017/whizbang");</p>
<p>    options.UseRedis("localhost:6379");</p>
<p>});</p>
<p></code></pre></p>

<h2>Best Practices</h2>

<ul><li><strong>Use abstractions</strong> - Depend on IDriver, not concrete implementations</li>
<li><strong>Plan for persistence</strong> - Design assuming data will persist</li>
<li><strong>Use prefixes</strong> - Organize keys with consistent prefixes</li>
<li><strong>Handle nulls</strong> - Always check for null returns from Get</li>
<li><strong>Test with different drivers</strong> - Ensure code works with any driver</li>
<li><strong>Consider capabilities</strong> - Check driver capabilities before using features</li>
</ul>
<h2>Related Documentation</h2>

<ul><li><a href="perspectives.md">Perspectives</a> - Using drivers for write models</li>
<li><a href="lenses.md">Lenses</a> - Using drivers for read models</li>
<li><a href="../testing/foundation.md">Testing</a> - Testing with in-memory driver</li>
<li><a href="../../roadmap/FEATURE-EVOLUTION.md">Feature Evolution</a> - How drivers evolve</li>
</ul>
<h2>Next Steps</h2>

<ul><li>See <a href="../../v0.2.0/enhancements/drivers.md">v0.2.0 File Storage</a> for persistence</li>
<li>See <a href="../../v0.4.0/database/drivers.md">v0.4.0 Databases</a> for SQL/NoSQL support</li>
<li>Review <a href="../examples/storage-patterns.md">Examples</a> for driver patterns</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-components-ledger" class="doc-section">
  <h3>Ledger Component</h3>
  <p class="doc-path"><code>v1.0.0/components/ledger</code></p>
  <p class="doc-description"><em>In-memory event store with basic append and read operations</em></p>
  <div class="doc-content">

<h1>Ledger Component</h1>

<p>!<a href="https://img.shields.io/badge/version-1.0.0-blue">Version</a></p>
<p>!<a href="https://img.shields.io/badge/status-stable-green">Status</a></p>

<h2>Version History</h2>

<p>:::new</p>
<strong>New in v1.0.0</strong>: Basic in-memory event store with append-only semantics
<p>:::</p>


<h2>Overview</h2>

<p>The Ledger is Whizbang's append-only event store, providing an immutable audit trail of all events in your system. In v1.0.0, it's a simple in-memory store that captures events and allows basic retrieval. This foundation will evolve into a full event sourcing system.</p>

<h2>What is a Ledger?</h2>

<p>A Ledger:</p>
<ul><li><strong>Stores</strong> events in append-only fashion</li>
<li><strong>Preserves</strong> the complete history of state changes</li>
<li><strong>Provides</strong> an immutable audit trail</li>
<li><strong>Enables</strong> event replay and debugging</li>
</ul>
<p>Think of the ledger as your system's permanent memory - every significant action is recorded and can never be altered or deleted.</p>

<h2>Core Interface (v1.0.0)</h2>

<p>:::new</p>
<p>The basic ledger interface for event storage:</p>
<p>:::</p>

<pre><code class="language-csharp">public interface ILedger {
<p>    // Append an event to the ledger</p>
<p>    Task<long> Append(IEvent @event);</p>
<p>    </p>
<p>    // Read events from the ledger</p>
<p>    IEnumerable<IEvent> Read(long fromPosition = 0);</p>
<p>    </p>
<p>    // Read events of a specific type</p>
<p>    IEnumerable<T> Read<T>(long fromPosition = 0) where T : IEvent;</p>
<p>    </p>
<p>    // Get the current position (last event number)</p>
<p>    long GetPosition();</p>
<p>}</p>
<p></code></pre></p>

<h2>Basic Implementation</h2>

<p>:::new</p>
<p>In v1.0.0, the ledger uses in-memory storage:</p>
<p>:::</p>

<pre><code class="language-csharp">[WhizbangLedger]
<p>public class InMemoryLedger : ILedger {</p>
<p>    private readonly List<StoredEvent> _events = new();</p>
<p>    private readonly object _lock = new();</p>
<p>    private long _position = 0;</p>
<p>    </p>
<p>    public Task<long> Append(IEvent @event) {</p>
<p>        lock (_lock) {</p>
<p>            var position = ++_position;</p>
<p>            </p>
<p>            _events.Add(new StoredEvent {</p>
<p>                Position = position,</p>
<p>                EventType = @event.GetType().Name,</p>
<p>                Event = @event,</p>
<p>                Timestamp = DateTimeOffset.UtcNow</p>
<p>            });</p>
<p>            </p>
<p>            return Task.FromResult(position);</p>
<p>        }</p>
<p>    }</p>
<p>    </p>
<p>    public IEnumerable<IEvent> Read(long fromPosition = 0) {</p>
<p>        lock (_lock) {</p>
<p>            return _events</p>
<p>                .Where(e => e.Position > fromPosition)</p>
<p>                .Select(e => e.Event);</p>
<p>        }</p>
<p>    }</p>
<p>    </p>
<p>    public IEnumerable<T> Read<T>(long fromPosition = 0) where T : IEvent {</p>
<p>        return Read(fromPosition).OfType<T>();</p>
<p>    }</p>
<p>    </p>
<p>    public long GetPosition() {</p>
<p>        lock (_lock) {</p>
<p>            return _position;</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Event Storage</h2>

<h3>Event Structure</h3>

<pre><code class="language-csharp">public interface IEvent {
<p>    Guid Id { get; }</p>
<p>    DateTimeOffset Timestamp { get; }</p>
<p>    string AggregateId { get; }</p>
<p>    int Version { get; }</p>
<p>}</p>

<p>// Stored event wrapper</p>
<p>internal class StoredEvent {</p>
<p>    public long Position { get; set; }</p>
<p>    public string EventType { get; set; }</p>
<p>    public IEvent Event { get; set; }</p>
<p>    public DateTimeOffset Timestamp { get; set; }</p>
<p>}</p>
<p></code></pre></p>

<h3>Appending Events</h3>

<p>:::new</p>
<p>Events are automatically appended by the dispatcher:</p>
<p>:::</p>

<pre><code class="language-csharp">// Events flow from receptors through dispatcher to ledger
<p>public class OrderReceptor : IReceptor<CreateOrder> {</p>
<p>    public OrderCreated Receive(CreateOrder cmd) {</p>
<p>        return new OrderCreated {</p>
<p>            Id = Guid.NewGuid(),</p>
<p>            Timestamp = DateTimeOffset.UtcNow,</p>
<p>            AggregateId = cmd.OrderId.ToString(),</p>
<p>            Version = 1,</p>
<p>            CustomerId = cmd.CustomerId,</p>
<p>            Items = cmd.Items,</p>
<p>            Total = cmd.Total</p>
<p>        };</p>
<p>        // Event automatically appended to ledger by dispatcher</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Reading Events</h3>

<p>:::new</p>
<p>Basic event retrieval in v1.0.0:</p>
<p>:::</p>

<pre><code class="language-csharp">public class EventReader {
<p>    private readonly ILedger _ledger;</p>
<p>    </p>
<p>    // Read all events</p>
<p>    public void ReadAllEvents() {</p>
<p>        var events = _ledger.Read();</p>
<p>        foreach (var @event in events) {</p>
<p>            Console.WriteLine($"{@event.Timestamp}: {@event.GetType().Name}");</p>
<p>        }</p>
<p>    }</p>
<p>    </p>
<p>    // Read specific event types</p>
<p>    public void ReadOrderEvents() {</p>
<p>        var orderEvents = _ledger.Read<OrderCreated>();</p>
<p>        foreach (var order in orderEvents) {</p>
<p>            Console.WriteLine($"Order {order.AggregateId}: {order.Total}");</p>
<p>        }</p>
<p>    }</p>
<p>    </p>
<p>    // Read from checkpoint</p>
<p>    public void ReadNewEvents(long lastPosition) {</p>
<p>        var newEvents = _ledger.Read(fromPosition: lastPosition);</p>
<p>        foreach (var @event in newEvents) {</p>
<p>            ProcessEvent(@event);</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Integration with Dispatcher</h2>

<p>The ledger is automatically integrated with the dispatcher:</p>

<pre><code class="language-csharp">// Source generated registration
<p>public static partial class WhizbangGenerated {</p>
<p>    public static void RegisterLedger(IServiceCollection services) {</p>
<p>        services.AddSingleton<ILedger, InMemoryLedger>();</p>
<p>    }</p>
<p>}</p>

<p>// Dispatcher automatically appends events</p>
<p>public class Dispatcher : IDispatcher {</p>
<p>    private readonly ILedger _ledger;</p>
<p>    </p>
<p>    public async Task<TResult> Dispatch<TCommand, TResult>(TCommand command) </p>
<p>        where TResult : IEvent {</p>
<p>        </p>
<p>        // Execute receptor</p>
<p>        var result = await ExecuteReceptor(command);</p>
<p>        </p>
<p>        // Append to ledger</p>
<p>        await _ledger.Append(result);</p>
<p>        </p>
<p>        // Update perspectives</p>
<p>        await UpdatePerspectives(result);</p>
<p>        </p>
<p>        return result;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Debugging with the Ledger</h2>

<p>:::new</p>
<p>The ledger enables powerful debugging capabilities:</p>
<p>:::</p>

<pre><code class="language-csharp">public class LedgerDebugger {
<p>    private readonly ILedger _ledger;</p>
<p>    </p>
<p>    // Show event timeline</p>
<p>    public void ShowTimeline(DateTime from, DateTime to) {</p>
<p>        var events = _ledger.Read()</p>
<p>            .Where(e => e.Timestamp >= from && e.Timestamp <= to)</p>
<p>            .OrderBy(e => e.Timestamp);</p>
<p>        </p>
<p>        foreach (var @event in events) {</p>
<p>            Console.WriteLine($"{@event.Timestamp:HH:mm:ss.fff} " +</p>
<p>                            $"[{@event.GetType().Name}] " +</p>
<p>                            $"Aggregate: {@event.AggregateId}");</p>
<p>        }</p>
<p>    }</p>
<p>    </p>
<p>    // Analyze event patterns</p>
<p>    public void AnalyzePatterns() {</p>
<p>        var events = _ledger.Read();</p>
<p>        </p>
<p>        var stats = events</p>
<p>            .GroupBy(e => e.GetType().Name)</p>
<p>            .Select(g => new {</p>
<p>                EventType = g.Key,</p>
<p>                Count = g.Count(),</p>
<p>                FirstOccurred = g.Min(e => e.Timestamp),</p>
<p>                LastOccurred = g.Max(e => e.Timestamp)</p>
<p>            });</p>
<p>        </p>
<p>        foreach (var stat in stats) {</p>
<p>            Console.WriteLine($"{stat.EventType}: {stat.Count} events");</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Testing with the Ledger</h2>

<pre><code class="language-csharp">[Test]
<p>public class LedgerTests {</p>
<p>    private InMemoryLedger _ledger;</p>
<p>    </p>
<p>    [SetUp]</p>
<p>    public void Setup() {</p>
<p>        _ledger = new InMemoryLedger();</p>
<p>    }</p>
<p>    </p>
<p>    [Test]</p>
<p>    public async Task Append_ShouldReturnIncrementingPosition() {</p>
<p>        // Arrange</p>
<p>        var event1 = new TestEvent { Id = Guid.NewGuid() };</p>
<p>        var event2 = new TestEvent { Id = Guid.NewGuid() };</p>
<p>        </p>
<p>        // Act</p>
<p>        var pos1 = await _ledger.Append(event1);</p>
<p>        var pos2 = await _ledger.Append(event2);</p>
<p>        </p>
<p>        // Assert</p>
<p>        Assert.Equal(1, pos1);</p>
<p>        Assert.Equal(2, pos2);</p>
<p>    }</p>
<p>    </p>
<p>    [Test]</p>
<p>    public async Task Read_ShouldReturnEventsInOrder() {</p>
<p>        // Arrange</p>
<p>        var events = new[] {</p>
<p>            new TestEvent { Id = Guid.NewGuid() },</p>
<p>            new TestEvent { Id = Guid.NewGuid() },</p>
<p>            new TestEvent { Id = Guid.NewGuid() }</p>
<p>        };</p>
<p>        </p>
<p>        foreach (var @event in events) {</p>
<p>            await _ledger.Append(@event);</p>
<p>        }</p>
<p>        </p>
<p>        // Act</p>
<p>        var readEvents = _ledger.Read().ToList();</p>
<p>        </p>
<p>        // Assert</p>
<p>        Assert.Equal(3, readEvents.Count);</p>
<p>        Assert.Equal(events[0].Id, readEvents[0].Id);</p>
<p>        Assert.Equal(events[2].Id, readEvents[2].Id);</p>
<p>    }</p>
<p>    </p>
<p>    [Test]</p>
<p>    public async Task Read_FromPosition_ShouldSkipEarlierEvents() {</p>
<p>        // Arrange</p>
<p>        for (int i = 0; i < 5; i++) {</p>
<p>            await _ledger.Append(new TestEvent());</p>
<p>        }</p>
<p>        </p>
<p>        // Act</p>
<p>        var events = _ledger.Read(fromPosition: 3).ToList();</p>
<p>        </p>
<p>        // Assert</p>
<p>        Assert.Equal(2, events.Count); // Only events 4 and 5</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>IDE Features</h2>

<pre><code class="language-csharp">// IDE shows: "Events stored: 1,234 | Size: 5.2MB | Last: 2s ago"
<p>public interface ILedger { }</p>

<p>// IDE shows: "Appended 45 times | Avg: 0.1ms"</p>
<p>public Task<long> Append(IEvent @event) { }</p>

<p>// IDE shows: "Warning: Reading all events can be expensive"</p>
<p>public IEnumerable<IEvent> Read(long fromPosition = 0) { }</p>
<p></code></pre></p>

<h2>Performance Characteristics</h2>

<p>| Operation | Target | Actual |</p>
<p>|-----------|--------|--------|</p>
<p>| Append | < 1μs | TBD |</p>
<p>| Read (1000 events) | < 1ms | TBD |</p>
<p>| Read by type | < 2ms | TBD |</p>
<p>| Get position | < 100ns | TBD |</p>

<h2>Limitations in v1.0.0</h2>

<p>:::info</p>
<p>These limitations are addressed in future versions:</p>
<p>:::</p>

<ul><li><strong>In-memory only</strong> - Events lost on restart</li>
<li><strong>No streaming</strong> - Must load all events at once</li>
<li><strong>No snapshots</strong> - Can't optimize long event streams</li>
<li><strong>Single stream</strong> - No concept of aggregate streams</li>
<li><strong>No queries</strong> - Basic sequential read only</li>
</ul>
<h2>Migration Path</h2>

<h3>To v0.2.0 (Persistence)</h3>

<p>:::planned</p>
<p>v0.2.0 adds persistent storage:</p>
<p>:::</p>

<pre><code class="language-csharp">// v0.2.0 - File-based persistence
<p>public interface ILedger {</p>
<p>    Task<long> Append(string streamId, IEvent @event);</p>
<p>    IAsyncEnumerable<IEvent> ReadStream(string streamId);</p>
<p>    Task<Snapshot> CreateSnapshot(string streamId);</p>
<p>}</p>
<p></code></pre></p>

<h3>To v0.3.0 (Event Sourcing)</h3>

<p>:::planned</p>
<p>v0.3.0 adds full event sourcing:</p>
<p>:::</p>

<pre><code class="language-csharp">// v0.3.0 - Event sourcing with projections
<p>public interface IEventStore : ILedger {</p>
<p>    Task<T> LoadAggregate<T>(string aggregateId) where T : IAggregate;</p>
<p>    Task SaveAggregate<T>(T aggregate) where T : IAggregate;</p>
<p>    Task<ProjectionState> GetProjection(string projectionName);</p>
<p>    Task RebuildProjection(string projectionName, DateTime? from = null);</p>
<p>}</p>
<p></code></pre></p>

<h2>Best Practices</h2>

<ul><li><strong>Events are immutable</strong> - Never modify events after creation</li>
<li><strong>Use meaningful event names</strong> - OrderCreated not Event1</li>
<li><strong>Include all relevant data</strong> - Events should be self-contained</li>
<li><strong>Keep events small</strong> - Large payloads impact performance</li>
<li><strong>Version your events</strong> - Plan for schema evolution</li>
<li><strong>Test with the ledger</strong> - Verify event flow in tests</li>
</ul>
<h2>Related Documentation</h2>

<ul><li><a href="receptors.md">Receptors</a> - Where events come from</li>
<li><a href="dispatcher.md">Dispatcher</a> - How events reach the ledger</li>
<li><a href="perspectives.md">Perspectives</a> - How events update views</li>
<li><a href="../testing/foundation.md">Testing</a> - Testing with the ledger</li>
<li><a href="../../roadmap/FEATURE-EVOLUTION.md">Feature Evolution</a> - How the ledger evolves</li>
</ul>
<h2>Next Steps</h2>

<ul><li>See <a href="../../v0.2.0/enhancements/ledger.md">v0.2.0 Persistence</a> for file-based storage</li>
<li>See <a href="../../v0.3.0/features/ledger.md">v0.3.0 Event Sourcing</a> for full ES/CQRS</li>
<li>Review <a href="../examples/event-patterns.md">Examples</a> for event design patterns</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-components-lenses" class="doc-section">
  <h3>Lenses Component</h3>
  <p class="doc-path"><code>v1.0.0/components/lenses</code></p>
  <p class="doc-description"><em>Read-only interfaces for querying data - the query side of Whizbang's CQRS implementation</em></p>
  <div class="doc-content">

<h1>Lenses Component</h1>

<p>!<a href="https://img.shields.io/badge/version-1.0.0-blue">Version</a></p>
<p>!<a href="https://img.shields.io/badge/status-stable-green">Status</a></p>

<h2>Version History</h2>

<p>:::new</p>
<strong>New in v1.0.0</strong>: Basic query interface with Focus, View, Glimpse, Exists, and Scan methods
<p>:::</p>


<h2>Overview</h2>

<p>Lenses provide focused, read-only views into your data. They are the query side of Whizbang's CQRS implementation, offering a clean separation between reads and writes. In v1.0.0, lenses work with in-memory data and establish the foundation for more advanced query capabilities.</p>

<h2>What is a Lens?</h2>

<p>A Lens:</p>
<ul><li><strong>Provides</strong> read-only access to data</li>
<li><strong>Focuses</strong> on specific query needs</li>
<li><strong>Never</strong> modifies state</li>
<li><strong>Abstracts</strong> the underlying storage mechanism</li>
</ul>
<p>Think of a lens as a window into your data - you can look through it from different angles to see different views, but you can't reach through it to change what you see.</p>

<h2>Core Interface (v1.0.0)</h2>

<p>:::new</p>
<p>The basic lens interface pattern with five core methods:</p>
<p>:::</p>

<pre><code class="language-csharp">public interface ILens {
<p>    // Focus on a single item</p>
<p>    T Focus<T>(object id);</p>
<p>    </p>
<p>    // View a filtered collection</p>
<p>    IEnumerable<T> View<T>(Expression<Func<T, bool>> filter);</p>
<p>    </p>
<p>    // Glimpse a summary or partial view</p>
<p>    TSummary Glimpse<TSummary>(object id);</p>
<p>    </p>
<p>    // Check existence</p>
<p>    bool Exists(object id);</p>
<p>    </p>
<p>    // Scan all items (use sparingly)</p>
<p>    IEnumerable<T> Scan<T>();</p>
<p>}</p>
<p></code></pre></p>

<h2>Domain-Specific Lenses</h2>

<p>:::new</p>
<p>Create specific lens interfaces for your domain:</p>
<p>:::</p>

<pre><code class="language-csharp">[WhizbangLens]  // Source generator discovers this
<p>public interface IOrderLens : ILens {</p>
<p>    // Strongly-typed methods</p>
<p>    Order Focus(Guid orderId);</p>
<p>    IEnumerable<Order> ViewByCustomer(Guid customerId);</p>
<p>    IEnumerable<Order> ViewByStatus(OrderStatus status);</p>
<p>    OrderSummary Glimpse(Guid orderId);</p>
<p>    bool Exists(Guid orderId);</p>
<p>    IEnumerable<Order> Scan();</p>
<p>}</p>

<p>// Implementation for v1.0.0 (in-memory)</p>
<p>public class OrderLens : IOrderLens {</p>
<p>    private readonly Dictionary<Guid, Order> _orders;</p>
<p>    </p>
<p>    public OrderLens(IInMemoryStore<Order> store) {</p>
<p>        _orders = store.Collection;</p>
<p>    }</p>
<p>    </p>
<p>    public Order Focus(Guid orderId) {</p>
<p>        return _orders.TryGetValue(orderId, out var order) </p>
<p>            ? order </p>
<p>            : null;</p>
<p>    }</p>
<p>    </p>
<p>    public IEnumerable<Order> ViewByCustomer(Guid customerId) {</p>
<p>        return _orders.Values.Where(o => o.CustomerId == customerId);</p>
<p>    }</p>
<p>    </p>
<p>    public IEnumerable<Order> ViewByStatus(OrderStatus status) {</p>
<p>        return _orders.Values.Where(o => o.Status == status);</p>
<p>    }</p>
<p>    </p>
<p>    public OrderSummary Glimpse(Guid orderId) {</p>
<p>        var order = Focus(orderId);</p>
<p>        return order == null ? null : new OrderSummary {</p>
<p>            Id = order.Id,</p>
<p>            CustomerName = GetCustomerName(order.CustomerId),</p>
<p>            Total = order.Total,</p>
<p>            ItemCount = order.Items.Count,</p>
<p>            Status = order.Status.ToString()</p>
<p>        };</p>
<p>    }</p>
<p>    </p>
<p>    public bool Exists(Guid orderId) {</p>
<p>        return _orders.ContainsKey(orderId);</p>
<p>    }</p>
<p>    </p>
<p>    public IEnumerable<Order> Scan() {</p>
<p>        return _orders.Values;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Core Lens Methods Explained</h2>

<h3>Focus - Single Item Retrieval</h3>

<p>:::new</p>
<p>Retrieve a single item by its identifier:</p>
<p>:::</p>

<pre><code class="language-csharp">public interface ICustomerLens : ILens {
<p>    Customer Focus(Guid customerId);</p>
<p>}</p>

<p>// Usage in receptor</p>
<p>public class OrderReceptor : IReceptor<UpdateOrder> {</p>
<p>    public OrderUpdated Receive(UpdateOrder cmd, ICustomerLens lens) {</p>
<p>        var customer = lens.Focus(cmd.CustomerId);</p>
<p>        if (customer == null) {</p>
<p>            throw new CustomerNotFoundException(cmd.CustomerId);</p>
<p>        }</p>
<p>        </p>
<p>        if (!customer.IsActive) {</p>
<p>            throw new InactiveCustomerException();</p>
<p>        }</p>
<p>        </p>
<p>        return new OrderUpdated(cmd.OrderId, cmd.Changes);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>View - Filtered Collections</h3>

<p>:::new</p>
<p>Query multiple items with filters:</p>
<p>:::</p>

<pre><code class="language-csharp">public interface IProductLens : ILens {
<p>    IEnumerable<Product> View(Expression<Func<Product, bool>> filter);</p>
<p>    IEnumerable<Product> ViewByCategory(string category);</p>
<p>    IEnumerable<Product> ViewInPriceRange(decimal min, decimal max);</p>
<p>}</p>

<p>// Implementation</p>
<p>public class ProductLens : IProductLens {</p>
<p>    public IEnumerable<Product> ViewByCategory(string category) {</p>
<p>        return _products.Values.Where(p => p.Category == category);</p>
<p>    }</p>
<p>    </p>
<p>    public IEnumerable<Product> ViewInPriceRange(decimal min, decimal max) {</p>
<p>        return _products.Values.Where(p => p.Price >= min && p.Price <= max);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Glimpse - Summaries and Projections</h3>

<p>:::new</p>
<p>Get lightweight summaries without full entity data:</p>
<p>:::</p>

<pre><code class="language-csharp">public interface IInventoryLens : ILens {
<p>    InventorySummary Glimpse(Guid productId);</p>
<p>    StockLevel GlimpseStock(Guid productId);</p>
<p>    IEnumerable<LowStockItem> GlimpseLowStock();</p>
<p>}</p>

<p>// Returns just what's needed</p>
<p>public InventorySummary Glimpse(Guid productId) {</p>
<p>    var product = _products[productId];</p>
<p>    return new InventorySummary {</p>
<p>        ProductId = product.Id,</p>
<p>        Name = product.Name,</p>
<p>        Available = product.Quantity - product.Reserved,</p>
<p>        Status = product.Quantity > 10 ? "In Stock" : "Low Stock"</p>
<p>    };</p>
<p>}</p>
<p></code></pre></p>

<h3>Exists - Efficient Existence Checks</h3>

<p>:::new</p>
<p>Check if an item exists without loading it:</p>
<p>:::</p>

<pre><code class="language-csharp">public class OrderReceptor : IReceptor<AddItemToOrder> {
<p>    public ItemAdded Receive(AddItemToOrder cmd, IOrderLens orderLens, IProductLens productLens) {</p>
<p>        if (!orderLens.Exists(cmd.OrderId)) {</p>
<p>            throw new OrderNotFoundException(cmd.OrderId);</p>
<p>        }</p>
<p>        </p>
<p>        if (!productLens.Exists(cmd.ProductId)) {</p>
<p>            throw new ProductNotFoundException(cmd.ProductId);</p>
<p>        }</p>
<p>        </p>
<p>        return new ItemAdded(cmd.OrderId, cmd.ProductId, cmd.Quantity);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Scan - Full Collection Access</h3>

<p>:::new</p>
<p>Retrieve all items (use sparingly):</p>
<p>:::</p>

<pre><code class="language-csharp">public interface IReportLens : ILens {
<p>    IEnumerable<Order> ScanOrders();</p>
<p>    IEnumerable<Customer> ScanCustomers();</p>
<p>}</p>

<p>// Use with caution - can be expensive</p>
<p>public DailyReport GenerateReport(IReportLens lens) {</p>
<p>    var allOrders = lens.ScanOrders();</p>
<p>    return new DailyReport {</p>
<p>        TotalOrders = allOrders.Count(),</p>
<p>        TotalRevenue = allOrders.Sum(o => o.Total),</p>
<p>        AverageOrderValue = allOrders.Average(o => o.Total)</p>
<p>    };</p>
<p>}</p>
<p></code></pre></p>

<h2>Composition Pattern</h2>

<p>:::new</p>
<p>Lenses can be composed for complex queries:</p>
<p>:::</p>

<pre><code class="language-csharp">public class OrderSearchLens : IOrderSearchLens {
<p>    private readonly IOrderLens _orderLens;</p>
<p>    private readonly ICustomerLens _customerLens;</p>
<p>    private readonly IProductLens _productLens;</p>
<p>    </p>
<p>    public IEnumerable<OrderSearchResult> Search(OrderSearchCriteria criteria) {</p>
<p>        var orders = _orderLens.Scan();</p>
<p>        </p>
<p>        if (criteria.CustomerId.HasValue) {</p>
<p>            var customer = _customerLens.Focus(criteria.CustomerId.Value);</p>
<p>            orders = orders.Where(o => o.CustomerId == customer.Id);</p>
<p>        }</p>
<p>        </p>
<p>        if (!string.IsNullOrEmpty(criteria.ProductSku)) {</p>
<p>            var product = _productLens.ViewBySku(criteria.ProductSku).FirstOrDefault();</p>
<p>            orders = orders.Where(o => o.Items.Any(i => i.ProductId == product?.Id));</p>
<p>        }</p>
<p>        </p>
<p>        return orders.Select(o => MapToSearchResult(o));</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Source Generation</h2>

<p>:::new</p>
<p>Lenses are discovered and registered at compile time:</p>
<p>:::</p>

<pre><code class="language-csharp">// Generated by Whizbang.Generators
<p>public static partial class WhizbangGenerated {</p>
<p>    public static void RegisterLenses(IServiceCollection services) {</p>
<p>        services.AddScoped<IOrderLens, OrderLens>();</p>
<p>        services.AddScoped<ICustomerLens, CustomerLens>();</p>
<p>        services.AddScoped<IProductLens, ProductLens>();</p>
<p>        services.AddScoped<IInventoryLens, InventoryLens>();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Testing Lenses</h2>

<pre><code class="language-csharp">[Test]
<p>public class OrderLensTests {</p>
<p>    private OrderLens _lens;</p>
<p>    private InMemoryStore<Order> _store;</p>
<p>    </p>
<p>    [SetUp]</p>
<p>    public void Setup() {</p>
<p>        _store = new InMemoryStore<Order>();</p>
<p>        _lens = new OrderLens(_store);</p>
<p>        </p>
<p>        // Add test data</p>
<p>        _store.Collection[Guid.Parse("123...")] = new Order {</p>
<p>            Id = Guid.Parse("123..."),</p>
<p>            CustomerId = Guid.Parse("456..."),</p>
<p>            Status = OrderStatus.Pending,</p>
<p>            Total = 99.99m</p>
<p>        };</p>
<p>    }</p>
<p>    </p>
<p>    [Test]</p>
<p>    public void Focus_ExistingOrder_ShouldReturnOrder() {</p>
<p>        var order = _lens.Focus(Guid.Parse("123..."));</p>
<p>        Assert.NotNull(order);</p>
<p>        Assert.Equal(99.99m, order.Total);</p>
<p>    }</p>
<p>    </p>
<p>    [Test]</p>
<p>    public void ViewByStatus_ShouldFilterCorrectly() {</p>
<p>        var pendingOrders = _lens.ViewByStatus(OrderStatus.Pending);</p>
<p>        Assert.Equal(1, pendingOrders.Count());</p>
<p>    }</p>
<p>    </p>
<p>    [Test]</p>
<p>    public void Exists_ExistingOrder_ShouldReturnTrue() {</p>
<p>        Assert.True(_lens.Exists(Guid.Parse("123...")));</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>IDE Features</h2>

<pre><code class="language-csharp">// IDE shows: "Used by: 5 receptors | Queries: 234 | Avg: 0.5ms"
<p>public interface IOrderLens : ILens { }</p>

<p>// IDE shows: "Called 45 times | Last: 2s ago | Avg: 0.3ms"</p>
<p>public Order Focus(Guid orderId) { }</p>

<p>// IDE shows: "Warning: Scan can be expensive - consider using View with filters"</p>
<p>public IEnumerable<Order> Scan() { }</p>
<p></code></pre></p>

<h2>Performance Characteristics</h2>

<p>| Operation | Target | Actual |</p>
<p>|-----------|--------|--------|</p>
<p>| Focus (in-memory) | < 100ns | TBD |</p>
<p>| View (filtered) | < 1μs per item | TBD |</p>
<p>| Glimpse | < 500ns | TBD |</p>
<p>| Exists | < 50ns | TBD |</p>
<p>| Scan (1000 items) | < 1ms | TBD |</p>

<h2>Limitations in v1.0.0</h2>

<p>:::info</p>
<p>These limitations are addressed in future versions:</p>
<p>:::</p>

<ul><li><strong>No pagination</strong> - All results returned at once</li>
<li><strong>Synchronous only</strong> - No async/await support</li>
<li><strong>In-memory only</strong> - No database queries</li>
<li><strong>No caching</strong> - Queries execute every time</li>
</ul>
<h2>Migration Path</h2>

<h3>To v0.2.0 (Enhanced Queries)</h3>

<p>:::planned</p>
<p>v0.2.0 adds pagination and async support:</p>
<p>:::</p>

<pre><code class="language-csharp">// v0.2.0 - Pagination
<p>public interface IOrderLens : ILens {</p>
<p>    PagedResult<Order> ViewByCustomer(Guid customerId, int page, int pageSize);</p>
<p>}</p>

<p>// v0.2.0 - Async enumeration</p>
<p>public interface IOrderLens : ILens {</p>
<p>    IAsyncEnumerable<Order> ScanAsync();</p>
<p>}</p>
<p></code></pre></p>

<h3>To v0.4.0 (Database Queries)</h3>

<p>:::planned</p>
<p>v0.4.0 adds real database support with SQL generation:</p>
<p>:::</p>

<pre><code class="language-csharp">// v0.4.0 - SQL generation
<p>[SqlOptimized]</p>
<p>public class OrderLens : IOrderLens {</p>
<p>    public Order Focus(Guid orderId) {</p>
<p>        // Generated SQL: SELECT * FROM Orders WHERE Id = @orderId</p>
<p>        return _db.QuerySingle<Order>("...", new { orderId });</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Best Practices</h2>

<ul><li><strong>Keep lenses read-only</strong> - Never modify state through a lens</li>
<li><strong>Use specific methods</strong> - ViewByCustomer over generic View</li>
<li><strong>Avoid Scan</strong> - Use filtered queries when possible</li>
<li><strong>Return summaries</strong> - Use Glimpse for lightweight results</li>
<li><strong>Check existence</strong> - Use Exists before Focus</li>
<li><strong>Compose lenses</strong> - Combine for complex queries</li>
</ul>
<h2>Related Documentation</h2>

<ul><li><a href="receptors.md">Receptors</a> - Using lenses in receptors</li>
<li><a href="perspectives.md">Perspectives</a> - Data that lenses query</li>
<li><a href="dispatcher.md">Dispatcher</a> - How lenses are provided</li>
<li><a href="../testing/foundation.md">Testing</a> - Testing lenses</li>
<li><a href="../../roadmap/FEATURE-EVOLUTION.md">Feature Evolution</a> - How lenses evolve</li>
</ul>
<h2>Next Steps</h2>

<ul><li>See <a href="../../v0.2.0/enhancements/lenses.md">v0.2.0 Enhancements</a> for pagination and async features</li>
<li>See <a href="../../v0.4.0/drivers/lenses.md">v0.4.0 Database Support</a> for SQL optimization</li>
<li>Review <a href="../examples/complex-queries.md">Examples</a> for query patterns</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-components-perspectives" class="doc-section">
  <h3>Perspectives Component</h3>
  <p class="doc-path"><code>v1.0.0/components/perspectives</code></p>
  <p class="doc-description"><em>Event handlers that update various views of your data - the write side of Whizbang</em></p>
  <div class="doc-content">

<h1>Perspectives Component</h1>

<p>!<a href="https://img.shields.io/badge/version-1.0.0-blue">Version</a></p>
<p>!<a href="https://img.shields.io/badge/status-stable-green">Status</a></p>

<h2>Version History</h2>

<p>:::new</p>
<strong>New in v1.0.0</strong>: Basic event handling with in-memory updates for multiple views
<p>:::</p>


<h2>Overview</h2>

<p>Perspectives are the components that react to events and update various views of your data. They handle all write operations in Whizbang, ensuring that state changes flow consistently from events to storage. In v1.0.0, perspectives work with in-memory storage and provide the foundation for more advanced features.</p>

<h2>What is a Perspective?</h2>

<p>A Perspective:</p>
<ul><li><strong>Reacts</strong> to events emitted by receptors</li>
<li><strong>Updates</strong> data stores (in-memory in v1.0.0)</li>
<li><strong>Maintains</strong> different views of the same data</li>
<li><strong>Executes</strong> all write operations in the system</li>
</ul>
<p>Think of perspectives as event handlers that maintain materialized views. Each perspective provides a different "perspective" on the events flowing through your system.</p>

<h2>Core Interface (v1.0.0)</h2>

<p>:::new</p>
<p>The fundamental perspective interface for handling events:</p>
<p>:::</p>

<pre><code class="language-csharp">public interface IPerspectiveOf<TEvent> {
<p>    Task Update(TEvent @event);</p>
<p>}</p>
<p></code></pre></p>

<p>Simple, yet powerful - perspectives react to specific events and update their views accordingly.</p>

<h2>Basic Implementation</h2>

<p>:::new</p>
<p>In v1.0.0, perspectives work with in-memory storage:</p>
<p>:::</p>

<pre><code class="language-csharp">[WhizbangHandler]  // Source generator discovers this
<p>public class OrderPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>    private readonly Dictionary<Guid, Order> _orders;</p>
<p>    </p>
<p>    public OrderPerspective(IInMemoryStore<Order> store) {</p>
<p>        _orders = store.Collection;</p>
<p>    }</p>
<p>    </p>
<p>    public Task Update(OrderCreated @event) {</p>
<p>        _orders[@event.OrderId] = new Order {</p>
<p>            Id = @event.OrderId,</p>
<p>            CustomerId = @event.CustomerId,</p>
<p>            Items = @event.Items,</p>
<p>            Total = @event.Total,</p>
<p>            Status = OrderStatus.Created,</p>
<p>            CreatedAt = @event.Timestamp</p>
<p>        };</p>
<p>        </p>
<p>        return Task.CompletedTask;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Multiple Perspectives Pattern</h2>

<p>:::new</p>
<p>Different perspectives can handle the same event to create different views:</p>
<p>:::</p>

<pre><code class="language-csharp">// Order list for display
<p>[WhizbangHandler]</p>
<p>public class OrderListPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>    private readonly List<OrderListItem> _orderList;</p>
<p>    </p>
<p>    public async Task Update(OrderCreated @event) {</p>
<p>        _orderList.Add(new OrderListItem {</p>
<p>            Id = @event.OrderId,</p>
<p>            CustomerName = await GetCustomerName(@event.CustomerId),</p>
<p>            Total = @event.Total,</p>
<p>            Status = "New",</p>
<p>            CreatedAt = @event.Timestamp</p>
<p>        });</p>
<p>    }</p>
<p>}</p>

<p>// Customer statistics</p>
<p>[WhizbangHandler]</p>
<p>public class CustomerStatsPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>    private readonly Dictionary<Guid, CustomerStats> _stats;</p>
<p>    </p>
<p>    public Task Update(OrderCreated @event) {</p>
<p>        if (!_stats.TryGetValue(@event.CustomerId, out var stats)) {</p>
<p>            stats = _stats[@event.CustomerId] = new CustomerStats();</p>
<p>        }</p>
<p>        </p>
<p>        stats.OrderCount++;</p>
<p>        stats.TotalSpent += @event.Total;</p>
<p>        stats.LastOrderDate = @event.Timestamp;</p>
<p>        </p>
<p>        return Task.CompletedTask;</p>
<p>    }</p>
<p>}</p>

<p>// Analytics perspective</p>
<p>[WhizbangHandler]</p>
<p>public class AnalyticsPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>    private readonly IAnalyticsStore _analytics;</p>
<p>    </p>
<p>    public Task Update(OrderCreated @event) {</p>
<p>        _analytics.RecordMetric("orders.created", 1);</p>
<p>        _analytics.RecordMetric("orders.value", @event.Total);</p>
<p>        return Task.CompletedTask;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Event Flow</h2>

<h3>How Events Reach Perspectives</h3>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant R as Receptor</p>
<p>    participant D as Dispatcher</p>
<p>    participant P1 as OrderPerspective</p>
<p>    participant P2 as StatsPerspective</p>
<p>    participant P3 as AnalyticsPerspective</p>
<p>    </p>
<p>    R->>D: OrderCreated event</p>
<p>    D->>P1: Update(event)</p>
<p>    D->>P2: Update(event)</p>
<p>    D->>P3: Update(event)</p>
<p>    Note over P1,P3: All perspectives update</p>
<p></code></pre></p>

<h2>Handling Multiple Event Types</h2>

<p>A perspective can handle multiple event types:</p>

<pre><code class="language-csharp">[WhizbangHandler]
<p>public class OrderPerspective : </p>
<p>    IPerspectiveOf<OrderCreated>,</p>
<p>    IPerspectiveOf<OrderUpdated>,</p>
<p>    IPerspectiveOf<OrderShipped>,</p>
<p>    IPerspectiveOf<OrderCancelled> {</p>
<p>    </p>
<p>    private readonly Dictionary<Guid, Order> _orders;</p>
<p>    </p>
<p>    public Task Update(OrderCreated @event) {</p>
<p>        _orders[@event.OrderId] = new Order { </p>
<p>            Status = OrderStatus.Created </p>
<p>        };</p>
<p>        return Task.CompletedTask;</p>
<p>    }</p>
<p>    </p>
<p>    public Task Update(OrderUpdated @event) {</p>
<p>        _orders[@event.OrderId].UpdatedAt = @event.Timestamp;</p>
<p>        return Task.CompletedTask;</p>
<p>    }</p>
<p>    </p>
<p>    public Task Update(OrderShipped @event) {</p>
<p>        _orders[@event.OrderId].Status = OrderStatus.Shipped;</p>
<p>        _orders[@event.OrderId].ShippedAt = @event.Timestamp;</p>
<p>        return Task.CompletedTask;</p>
<p>    }</p>
<p>    </p>
<p>    public Task Update(OrderCancelled @event) {</p>
<p>        _orders[@event.OrderId].Status = OrderStatus.Cancelled;</p>
<p>        return Task.CompletedTask;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Error Handling</h2>

<p>:::new</p>
<p>Basic error handling in v1.0.0:</p>
<p>:::</p>

<pre><code class="language-csharp">public class ResilientPerspective : IPerspectiveOf<OrderCreated> {
<p>    private readonly ILogger<ResilientPerspective> _logger;</p>
<p>    </p>
<p>    public async Task Update(OrderCreated @event) {</p>
<p>        try {</p>
<p>            // Update logic</p>
<p>            await UpdateDatabase(@event);</p>
<p>        }</p>
<p>        catch (Exception ex) {</p>
<p>            _logger.LogError(ex, "Failed to update perspective for order {OrderId}", </p>
<p>                @event.OrderId);</p>
<p>            </p>
<p>            // In v1.0.0, errors are logged but not retried</p>
<p>            // v0.2.0 adds retry policies and dead letter queues</p>
<p>            throw;</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Policy Application</h2>

<p>:::new</p>
<p>Policies can be applied to perspectives:</p>
<p>:::</p>

<pre><code class="language-csharp">[Retry(3)]
<p>[Timeout(5000)]</p>
<p>public class OrderPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>    public async Task Update(OrderCreated @event) {</p>
<p>        // Policies are applied automatically by the dispatcher</p>
<p>        await UpdateDatabase(@event);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Source Generation</h2>

<p>:::new</p>
<p>Perspectives are discovered at compile time:</p>
<p>:::</p>

<pre><code class="language-csharp">// Generated by Whizbang.Generators
<p>public static partial class WhizbangGenerated {</p>
<p>    public static void RegisterPerspectives(IServiceCollection services) {</p>
<p>        services.AddScoped<IPerspectiveOf<OrderCreated>, OrderPerspective>();</p>
<p>        services.AddScoped<IPerspectiveOf<OrderCreated>, CustomerStatsPerspective>();</p>
<p>        services.AddScoped<IPerspectiveOf<OrderCreated>, AnalyticsPerspective>();</p>
<p>    }</p>
<p>    </p>
<p>    public static Dictionary<Type, List<Type>> GetEventPerspectives() {</p>
<p>        return new() {</p>
<p>            [typeof(OrderCreated)] = new() {</p>
<p>                typeof(OrderPerspective),</p>
<p>                typeof(CustomerStatsPerspective),</p>
<p>                typeof(AnalyticsPerspective)</p>
<p>            }</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Testing Perspectives</h2>

<pre><code class="language-csharp">[Test]
<p>public class OrderPerspectiveTests {</p>
<p>    private OrderPerspective _perspective;</p>
<p>    private InMemoryStore<Order> _store;</p>
<p>    </p>
<p>    [SetUp]</p>
<p>    public void Setup() {</p>
<p>        _store = new InMemoryStore<Order>();</p>
<p>        _perspective = new OrderPerspective(_store);</p>
<p>    }</p>
<p>    </p>
<p>    [Test]</p>
<p>    public async Task Update_OrderCreated_ShouldStoreOrder() {</p>
<p>        // Arrange</p>
<p>        var @event = new OrderCreated(</p>
<p>            OrderId: Guid.NewGuid(),</p>
<p>            CustomerId: Guid.NewGuid(),</p>
<p>            Items: new[] { new OrderItem("SKU-001", 2, 29.99m) },</p>
<p>            Total: 59.98m,</p>
<p>            Timestamp: DateTimeOffset.UtcNow</p>
<p>        );</p>
<p>        </p>
<p>        // Act</p>
<p>        await _perspective.Update(@event);</p>
<p>        </p>
<p>        // Assert</p>
<p>        Assert.True(_store.Collection.ContainsKey(@event.OrderId));</p>
<p>        var order = _store.Collection[@event.OrderId];</p>
<p>        Assert.Equal(@event.CustomerId, order.CustomerId);</p>
<p>        Assert.Equal(@event.Total, order.Total);</p>
<p>        Assert.Equal(OrderStatus.Created, order.Status);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>IDE Features</h2>

<pre><code class="language-csharp">// IDE shows: "Handles: OrderCreated, OrderUpdated, OrderShipped | Updated by: 3 dispatchers"
<p>public class OrderPerspective : IPerspectiveOf<OrderCreated> { }</p>

<p>// IDE shows: "Published to: 3 perspectives"</p>
<p>public record OrderCreated(Guid OrderId);</p>

<p>// IDE shows: "Updates triggered: 127 times | Avg: 2.3ms | Last: 5s ago"</p>
<p>public async Task Update(OrderCreated @event) { }</p>
<p></code></pre></p>

<h2>Performance Characteristics</h2>

<p>| Operation | Target | Actual |</p>
<p>|-----------|--------|--------|</p>
<p>| Update invocation | < 1μs | TBD |</p>
<p>| In-memory write | < 100ns | TBD |</p>
<p>| Multiple perspectives | < 10μs | TBD |</p>
<p>| Error handling | < 1ms | TBD |</p>

<h2>Limitations in v1.0.0</h2>

<p>:::info</p>
<p>These limitations are addressed in future versions:</p>
<p>:::</p>

<ul><li><strong>No batch updates</strong> - Each event processed individually</li>
<li><strong>Sequential execution</strong> - Perspectives run one at a time</li>
<li><strong>Basic error handling</strong> - No retry or dead letter queues</li>
<li><strong>In-memory only</strong> - No database persistence</li>
</ul>
<h2>Migration Path</h2>

<h3>To v0.2.0 (Enhanced Features)</h3>

<p>:::planned</p>
<p>v0.2.0 adds performance and reliability features:</p>
<p>:::</p>

<pre><code class="language-csharp">// v0.2.0 - Batch updates
<p>public class OrderPerspective : IBatchPerspective<OrderCreated> {</p>
<p>    public async Task UpdateBatch(IEnumerable<OrderCreated> events) {</p>
<p>        // Process multiple events efficiently</p>
<p>        await BulkInsert(events);</p>
<p>    }</p>
<p>}</p>

<p>// v0.2.0 - Parallel execution</p>
<p>[ParallelExecution(MaxDegree = 4)]</p>
<p>public class AnalyticsPerspective : IPerspectiveOf<OrderCreated> { }</p>
<p></code></pre></p>

<h3>To v0.3.0 (Projections)</h3>

<p>:::planned</p>
<p>v0.3.0 transforms perspectives into full projections:</p>
<p>:::</p>

<pre><code class="language-csharp">// v0.3.0 - Projection with rebuild
<p>[Projection("OrderSummary")]</p>
<p>public class OrderProjection : IProjection {</p>
<p>    public async Task Handle(OrderCreated @event) {</p>
<p>        // Same as perspective but with checkpoint tracking</p>
<p>    }</p>
<p>    </p>
<p>    [Rebuild]</p>
<p>    public async Task RebuildFrom(DateTime from) {</p>
<p>        // Rebuild projection from event history</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Best Practices</h2>

<ul><li><strong>Keep perspectives focused</strong> - One concern per perspective</li>
<li><strong>Avoid complex logic</strong> - Perspectives should be simple updates</li>
<li><strong>Handle errors gracefully</strong> - Log and continue when possible</li>
<li><strong>Design for idempotency</strong> - Same event twice = same result</li>
<li><strong>Use multiple perspectives</strong> - Different views for different needs</li>
<li><strong>Test with events</strong> - Test perspectives with real event data</li>
</ul>
<h2>Related Documentation</h2>

<ul><li><a href="receptors.md">Receptors</a> - Where events come from</li>
<li><a href="dispatcher.md">Dispatcher</a> - How events reach perspectives</li>
<li><a href="lenses.md">Lenses</a> - Reading the data perspectives write</li>
<li><a href="../testing/foundation.md">Testing</a> - Testing perspectives</li>
<li><a href="../../roadmap/FEATURE-EVOLUTION.md">Feature Evolution</a> - How perspectives evolve</li>
</ul>
<h2>Next Steps</h2>

<ul><li>See <a href="../../v0.2.0/enhancements/perspectives.md">v0.2.0 Enhancements</a> for batch and parallel features</li>
<li>See <a href="../../v0.3.0/features/projections.md">v0.3.0 Projections</a> for full projection support</li>
<li>Review <a href="../examples/multiple-perspectives.md">Examples</a> for practical patterns</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-components-policy-engine" class="doc-section">
  <h3>Policy Engine Component</h3>
  <p class="doc-path"><code>v1.0.0/components/policy-engine</code></p>
  <p class="doc-description"><em>Cross-cutting concerns as composable policies - retry, timeout, cache, and circuit breaker</em></p>
  <div class="doc-content">

<h1>Policy Engine Component</h1>

<p>!<a href="https://img.shields.io/badge/version-1.0.0-blue">Version</a></p>
<p>!<a href="https://img.shields.io/badge/status-stable-green">Status</a></p>

<h2>Version History</h2>

<p>:::new</p>
<strong>New in v1.0.0</strong>: Basic policies - Retry, Timeout, Cache, and CircuitBreaker
<p>:::</p>


<h2>Overview</h2>

<p>The Policy Engine provides cross-cutting concerns as composable, declarative policies. Instead of cluttering your business logic with retry loops, timeout handling, and caching code, you declare policies that the framework applies automatically. In v1.0.0, we provide four essential policies to handle the most common scenarios.</p>

<h2>What is a Policy?</h2>

<p>A Policy:</p>
<ul><li><strong>Wraps</strong> component execution with additional behavior</li>
<li><strong>Handles</strong> cross-cutting concerns declaratively</li>
<li><strong>Composes</strong> with other policies</li>
<li><strong>Applies</strong> automatically via source generation</li>
</ul>
<p>Think of policies as aspects that modify how your components execute without changing their core logic.</p>

<h2>Core Interface (v1.0.0)</h2>

<p>:::new</p>
<p>The basic policy interface for wrapping execution:</p>
<p>:::</p>

<pre><code class="language-csharp">public interface IPolicyOf<T> {
<p>    Task<TResult> Execute<TResult>(</p>
<p>        Func<Task<TResult>> operation,</p>
<p>        IMessageContext context</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<h2>Available Policies in v1.0.0</h2>

<h3>1. Retry Policy</h3>

<p>:::new</p>
<p>Automatically retry failed operations with configurable backoff strategies:</p>
<p>:::</p>

<pre><code class="language-csharp">// Basic retry with fixed delay
<p>[Retry(3)]</p>
<p>public class PaymentReceptor : IReceptor<ProcessPayment, PaymentProcessed> {</p>
<p>    public async Task<PaymentProcessed> Receive(ProcessPayment cmd) {</p>
<p>        // If this throws, it will retry up to 3 times</p>
<p>        return ProcessPayment(cmd);</p>
<p>    }</p>
<p>}</p>

<p>// Exponential backoff</p>
<p>[Retry(3, BackoffStrategy.Exponential)]</p>
<p>public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    // Retries with delays: 1s, 2s, 4s</p>
<p>}</p>

<p>// Custom delays</p>
<p>[Retry(Delays = new[] { 100, 500, 2000 })]</p>
<p>public class InventoryReceptor : IReceptor<ReserveStock> {</p>
<p>    // Retries with specific delays: 100ms, 500ms, 2s</p>
<p>}</p>
<p></code></pre></p>

<h4>Configuration Options</h4>

<pre><code class="language-csharp">[Retry(
<p>    MaxAttempts = 3,</p>
<p>    BackoffStrategy = BackoffStrategy.Exponential,</p>
<p>    InitialDelayMs = 100,</p>
<p>    MaxDelayMs = 30000,</p>
<p>    RetryOn = typeof(TransientException),</p>
<p>    ExcludeOn = typeof(ValidationException)</p>
<p>)]</p>
<p></code></pre></p>

<h3>2. Timeout Policy</h3>

<p>:::new</p>
<p>Prevent operations from running indefinitely:</p>
<p>:::</p>

<pre><code class="language-csharp">// Simple timeout
<p>[Timeout(5000)]  // 5 seconds</p>
<p>public class DatabaseReceptor : IReceptor<QueryData> {</p>
<p>    public QueryResult Receive(QueryData cmd) {</p>
<p>        // Cancelled if takes longer than 5 seconds</p>
<p>        return ExecuteQuery(cmd);</p>
<p>    }</p>
<p>}</p>

<p>// Timeout with custom exception</p>
<p>[Timeout(3000, ThrowOnTimeout = true)]</p>
<p>public class CriticalReceptor : IReceptor<CriticalCommand> {</p>
<p>    // Throws TimeoutException instead of returning default</p>
<p>}</p>
<p></code></pre></p>

<h3>3. Cache Policy</h3>

<p>:::new</p>
<p>Cache results to avoid redundant processing:</p>
<p>:::</p>

<pre><code class="language-csharp">// Cache for 5 minutes
<p>[Cache(Duration = 300)]  // seconds</p>
<p>public class ProductLens : IProductLens {</p>
<p>    public Product Focus(Guid productId) {</p>
<p>        // Result cached for 5 minutes</p>
<p>        return LoadProduct(productId);</p>
<p>    }</p>
<p>}</p>

<p>// Cache with sliding expiration</p>
<p>[Cache(Duration = 600, Sliding = true)]</p>
<p>public class CustomerLens : ICustomerLens {</p>
<p>    // Cache extends on each access</p>
<p>}</p>

<p>// Cache with custom key</p>
<p>[Cache(Duration = 300, KeyProperty = "CustomerId")]</p>
<p>public class OrderHistoryReceptor : IReceptor<GetOrderHistory> {</p>
<p>    // Cached by CustomerId property</p>
<p>}</p>
<p></code></pre></p>

<h3>4. Circuit Breaker Policy</h3>

<p>:::new</p>
<p>Prevent cascading failures by breaking the circuit after repeated failures:</p>
<p>:::</p>

<pre><code class="language-csharp">// Basic circuit breaker
<p>[CircuitBreaker(</p>
<p>    FailureThreshold = 0.5,  // 50% failure rate</p>
<p>    SamplingDuration = 10,   // Over 10 seconds</p>
<p>    MinimumThroughput = 5,   // At least 5 calls</p>
<p>    BreakDuration = 30       // Break for 30 seconds</p>
<p>)]</p>
<p>public class ExternalServiceReceptor : IReceptor<CallExternalService> {</p>
<p>    public ServiceResult Receive(CallExternalService cmd) {</p>
<p>        // Circuit opens after 50% failures</p>
<p>        // Stays open for 30 seconds</p>
<p>        // Then half-open to test recovery</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h4>Circuit States</h4>

<pre><code class="language-mermaid">stateDiagram-v2
<p>    [*] --> Closed: Initial</p>
<p>    Closed --> Open: Threshold<br/>Exceeded</p>
<p>    Open --> HalfOpen: After<br/>BreakDuration</p>
<p>    HalfOpen --> Closed: Success</p>
<p>    HalfOpen --> Open: Failure</p>
<p></code></pre></p>

<h2>Applying Policies</h2>

<h3>Via Attributes</h3>

<p>:::new</p>
<p>The simplest way to apply policies is via attributes:</p>
<p>:::</p>

<pre><code class="language-csharp">[Retry(3)]
<p>[Timeout(5000)]</p>
<p>[Cache(300)]</p>
<p>[CircuitBreaker(0.5, 10)]</p>
<p>public class ResilientReceptor : IReceptor<ImportantCommand> {</p>
<p>    public CommandResult Receive(ImportantCommand cmd) {</p>
<p>        // All policies applied in order:</p>
<p>        // 1. Check cache</p>
<p>        // 2. Check circuit breaker</p>
<p>        // 3. Apply timeout</p>
<p>        // 4. Retry on failure</p>
<p>        return ProcessCommand(cmd);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Policy Execution Order</h3>

<p>Policies execute in a specific order (innermost to outermost):</p>
<ul><li><strong>Cache</strong> - Check cache first</li>
<li><strong>CircuitBreaker</strong> - Check if circuit is open</li>
<li><strong>Timeout</strong> - Apply timeout to operation</li>
<li><strong>Retry</strong> - Retry if operation fails</li>
</ul>
<h2>Custom Policies</h2>

<p>:::new</p>
<p>Create custom policies for specific needs:</p>
<p>:::</p>

<pre><code class="language-csharp">[WhizbangPolicy]
<p>public class LoggingPolicy : IPolicyOf<IReceptor> {</p>
<p>    private readonly ILogger _logger;</p>
<p>    </p>
<p>    public async Task<TResult> Execute<TResult>(</p>
<p>        Func<Task<TResult>> operation,</p>
<p>        IMessageContext context</p>
<p>    ) {</p>
<p>        var stopwatch = Stopwatch.StartNew();</p>
<p>        try {</p>
<p>            _logger.LogInformation("Executing {Operation}", context.MessageType);</p>
<p>            var result = await operation();</p>
<p>            _logger.LogInformation("Completed in {ElapsedMs}ms", stopwatch.ElapsedMilliseconds);</p>
<p>            return result;</p>
<p>        }</p>
<p>        catch (Exception ex) {</p>
<p>            _logger.LogError(ex, "Failed after {ElapsedMs}ms", stopwatch.ElapsedMilliseconds);</p>
<p>            throw;</p>
<p>        }</p>
<p>    }</p>
<p>}</p>

<p>// Usage</p>
<p>[LoggingPolicy]</p>
<p>[Retry(3)]</p>
<p>public class AuditedReceptor : IReceptor<AuditedCommand> { }</p>
<p></code></pre></p>

<h2>Source Generation</h2>

<p>:::new</p>
<p>Policies are woven at compile time for zero overhead:</p>
<p>:::</p>

<pre><code class="language-csharp">// Generated by Whizbang.Generators
<p>public static class PolicyWeaver {</p>
<p>    public static OrderReceptor WrapWithPolicies(OrderReceptor receptor) {</p>
<p>        return new RetryPolicyWrapper(</p>
<p>            new TimeoutPolicyWrapper(</p>
<p>                new CachePolicyWrapper(</p>
<p>                    new CircuitBreakerPolicyWrapper(receptor)</p>
<p>                )</p>
<p>            )</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Testing with Policies</h2>

<pre><code class="language-csharp">[Test]
<p>public class PolicyTests {</p>
<p>    [Test]</p>
<p>    public async Task Retry_ShouldRetryThreeTimes() {</p>
<p>        // Arrange</p>
<p>        var attempts = 0;</p>
<p>        var receptor = new TestReceptor(() => {</p>
<p>            attempts++;</p>
<p>            if (attempts < 3) throw new TransientException();</p>
<p>            return new TestResult();</p>
<p>        });</p>
<p>        </p>
<p>        var retryPolicy = new RetryPolicy(3);</p>
<p>        </p>
<p>        // Act</p>
<p>        var result = await retryPolicy.Execute(</p>
<p>            () => receptor.Receive(new TestCommand()),</p>
<p>            new MessageContext()</p>
<p>        );</p>
<p>        </p>
<p>        // Assert</p>
<p>        Assert.Equal(3, attempts);</p>
<p>        Assert.NotNull(result);</p>
<p>    }</p>
<p>    </p>
<p>    [Test]</p>
<p>    public async Task CircuitBreaker_ShouldOpenAfterFailures() {</p>
<p>        // Arrange</p>
<p>        var breaker = new CircuitBreakerPolicy(0.5, 10, 5, 30);</p>
<p>        var failingOperation = () => throw new Exception();</p>
<p>        </p>
<p>        // Act - cause failures</p>
<p>        for (int i = 0; i < 5; i++) {</p>
<p>            try {</p>
<p>                await breaker.Execute(failingOperation, new MessageContext());</p>
<p>            }</p>
<p>            catch { }</p>
<p>        }</p>
<p>        </p>
<p>        // Assert - circuit should be open</p>
<p>        Assert.Throws<CircuitBreakerOpenException>(</p>
<p>            () => breaker.Execute(failingOperation, new MessageContext())</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>IDE Features</h2>

<pre><code class="language-csharp">// IDE shows: "Policies: Retry(3), Timeout(5s), Cache(5m)"
<p>[Retry(3)][Timeout(5000)][Cache(300)]</p>
<p>public class PolicyReceptor : IReceptor<Command> { }</p>

<p>// IDE shows: "Circuit breaker state: Closed | Success: 95% | Calls: 1,234"</p>
<p>[CircuitBreaker(0.5, 10)]</p>
<p>public class ServiceReceptor { }</p>

<p>// IDE shows: "Cache hit rate: 78% | Entries: 234 | Memory: 5.2MB"</p>
<p>[Cache(300)]</p>
<p>public class CachedLens { }</p>
<p></code></pre></p>

<h2>Performance Characteristics</h2>

<p>| Policy | Overhead | Memory Impact |</p>
<p>|--------|----------|---------------|</p>
<p>| Retry | < 10ns per attempt | Minimal |</p>
<p>| Timeout | < 100ns | Timer allocation |</p>
<p>| Cache | < 50ns lookup | Depends on cache size |</p>
<p>| CircuitBreaker | < 20ns check | State tracking |</p>

<h2>Limitations in v1.0.0</h2>

<p>:::info</p>
<p>These limitations are addressed in future versions:</p>
<p>:::</p>

<ul><li><strong>No policy composition</strong> - Cannot combine policies dynamically</li>
<li><strong>Basic configuration</strong> - Limited to attribute parameters</li>
<li><strong>In-memory state</strong> - Policy state not persisted</li>
<li><strong>No distributed coordination</strong> - Policies are instance-local</li>
</ul>
<h2>Migration Path</h2>

<h3>To v0.2.0 (Enhanced Policies)</h3>

<p>:::planned</p>
<p>v0.2.0 adds composition and new policy types:</p>
<p>:::</p>

<pre><code class="language-csharp">// v0.2.0 - Policy composition
<p>[PolicySet("Resilient")]</p>
<p>public class OrderReceptor { }</p>

<p>// Define policy sets</p>
<p>services.AddPolicySet("Resilient", policies => {</p>
<p>    policies.AddRetry(3);</p>
<p>    policies.AddTimeout(5000);</p>
<p>    policies.AddBulkhead(10);  // New in v0.2.0</p>
<p>    policies.AddRateLimit(100, TimeSpan.FromMinute(1));  // New in v0.2.0</p>
<p>});</p>
<p></code></pre></p>

<h3>To v0.6.0 (Security Policies)</h3>

<p>:::planned</p>
<p>v0.6.0 adds security and compliance policies:</p>
<p>:::</p>

<pre><code class="language-csharp">// v0.6.0 - Security policies
<p>[Authorize(Roles = "Admin")]</p>
<p>[Audit(Level = AuditLevel.Full)]</p>
<p>[EncryptPII]</p>
<p>public class SecureReceptor { }</p>
<p></code></pre></p>

<h2>Best Practices</h2>

<ul><li><strong>Order matters</strong> - Apply policies in the right order</li>
<li><strong>Configure appropriately</strong> - Don't retry non-transient errors</li>
<li><strong>Monitor policy metrics</strong> - Track success rates and performance</li>
<li><strong>Test with policies</strong> - Include policies in your tests</li>
<li><strong>Use circuit breakers</strong> - Protect external dependencies</li>
<li><strong>Cache judiciously</strong> - Consider memory and staleness</li>
</ul>
<h2>Related Documentation</h2>

<ul><li><a href="receptors.md">Receptors</a> - Applying policies to receptors</li>
<li><a href="perspectives.md">Perspectives</a> - Applying policies to perspectives</li>
<li><a href="dispatcher.md">Dispatcher</a> - How policies are executed</li>
<li><a href="../testing/foundation.md">Testing</a> - Testing with policies</li>
<li><a href="../../roadmap/FEATURE-EVOLUTION.md">Feature Evolution</a> - How policies evolve</li>
</ul>
<h2>Next Steps</h2>

<ul><li>See <a href="../../v0.2.0/enhancements/policies.md">v0.2.0 Enhancements</a> for composition and new policies</li>
<li>See <a href="../../future/v0.6.0-production.md">v0.6.0 Production</a> for security policies</li>
<li>Review <a href="../examples/resilient-patterns.md">Examples</a> for policy patterns</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-components-receptors" class="doc-section">
  <h3>Receptors Component</h3>
  <p class="doc-path"><code>v1.0.0/components/receptors</code></p>
  <p class="doc-description"><em>Command receivers that make decisions and emit events - the foundation of Whizbang's event-driven architecture</em></p>
  <div class="doc-content">

<h1>Receptors Component</h1>

<p>!<a href="https://img.shields.io/badge/version-1.0.0-blue">Version</a></p>
<p>!<a href="https://img.shields.io/badge/status-stable-green">Status</a></p>

<h2>Version History</h2>

<p>:::new</p>
<strong>New in v1.0.0</strong>: Type-safe receptors with async support and automatic multi-destination routing
<p>:::</p>


<h2>Overview</h2>

<p>Receptors are the decision-making components in Whizbang. They receive commands, apply business rules, and emit events representing the decisions made. In v1.0.0, receptors are <strong>stateless</strong> and focus on simple command-to-event transformation.</p>

<h2>What is a Receptor?</h2>

<p>A Receptor:</p>
<ul><li><strong>Receives</strong> commands from the dispatcher</li>
<li><strong>Validates</strong> business rules</li>
<li><strong>Decides</strong> what should happen</li>
<li><strong>Emits</strong> events representing decisions</li>
<li><strong>Never</strong> performs side effects directly</li>
</ul>
<p>Think of a receptor as a pure decision function: given a command, what event(s) should occur?</p>

<h2>Core Interface (v1.0.0)</h2>

<p>:::new</p>
<p>The type-safe receptor interface with generic message and response types:</p>
<p>:::</p>

<pre><code class="language-csharp">public interface IReceptor<TMessage, TResponse> {
<p>    Task<TResponse> Receive(TMessage message);</p>
<p>}</p>
<p></code></pre></p>

<h3>Key Features</h3>

<ul><li><strong>Type Safety</strong>: Compile-time checking for message and response types</li>
<li><strong>Async Support</strong>: All operations return <code>Task<TResponse></code> for async handling</li>
<li><strong>Multi-Destination</strong>: Multiple receptors can handle the same message type</li>
<li><strong>Zero Reflection</strong>: Source generation provides maximum performance</li>
</ul>
<h3>Response Type Flexibility</h3>

<p>Receptors support flexible response types:</p>

<p>| Response Type | Behavior | Example |</p>
<p>|---------------|----------|---------|</p>
<p>| Single Response | Return typed response | <code>Task<OrderCreated></code> |</p>
<p>| Tuple Response | Return multiple related responses | <code>Task<(PaymentProcessed, AuditEvent)></code> |</p>
<p>| Array Response | Return dynamic number of responses | <code>Task<NotificationEvent[]></code> |</p>
<p>| Result Type | Success/failure handling | <code>Task<Result<OrderCreated>></code> |</p>

<h2>Stateless Implementation</h2>

<p>:::new</p>
<p>In v1.0.0, all receptors are stateless and get any needed state from parameters:</p>
<p>:::</p>

<pre><code class="language-csharp">[WhizbangHandler]  // Source generator discovers this
<p>public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    </p>
<p>    public async Task<OrderCreated> Receive(CreateOrder cmd) {</p>
<p>        // Simple validation</p>
<p>        if (cmd.Items.Count == 0) {</p>
<p>            throw new InvalidOperationException("Order must have items");</p>
<p>        }</p>
<p>        </p>
<p>        // Make decision and return response</p>
<p>        return new OrderCreated(</p>
<p>            OrderId: Guid.NewGuid(),</p>
<p>            CustomerId: cmd.CustomerId,</p>
<p>            Items: cmd.Items,</p>
<p>            Total: cmd.Items.Sum(i => i.Quantity * i.Price),</p>
<p>            CreatedAt: DateTimeOffset.UtcNow</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Multi-Destination Routing</h2>

<p>:::new</p>
<strong>Key Feature</strong>: Multiple receptors can handle the same message type, running automatically in parallel:
<p>:::</p>

<pre><code class="language-csharp">// Multiple receptors can handle the same message type

<p>public class OrderBusinessReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    public async Task<OrderCreated> Receive(CreateOrder cmd) {</p>
<p>        // Main business logic</p>
<p>        var order = await ProcessOrder(cmd);</p>
<p>        return new OrderCreated(order.Id, order.Items);</p>
<p>    }</p>
<p>}</p>

<p>public class OrderAuditReceptor : IReceptor<CreateOrder, AuditEvent> {</p>
<p>    public async Task<AuditEvent> Receive(CreateOrder cmd) {</p>
<p>        // Compliance logging runs in parallel</p>
<p>        await _auditLog.Record("OrderCreationAttempt", cmd);</p>
<p>        return new AuditEvent("OrderCreationAttempt", cmd.OrderId);</p>
<p>    }</p>
<p>}</p>

<p>public class OrderFraudReceptor : IReceptor<CreateOrder, FraudCheckResult> {</p>
<p>    public async Task<FraudCheckResult> Receive(CreateOrder cmd) {</p>
<p>        // Fraud detection runs in parallel</p>
<p>        var riskScore = await _fraudEngine.Analyze(cmd);</p>
<p>        return new FraudCheckResult(cmd.OrderId, riskScore);</p>
<p>    }</p>
<p>}</p>

<p>// Framework automatically routes CreateOrder to all three receptors</p>
<p>// All run in parallel, each returning their specific response type</p>
<p></code></pre></p>

<h2>Working with Lenses</h2>

<p>For queries, receptors can receive lens parameters:</p>

<pre><code class="language-csharp">public class OrderUpdateReceptor : IReceptor<UpdateOrder, OrderUpdated> {
<p>    </p>
<p>    public async Task<OrderUpdated> Receive(UpdateOrder cmd, IOrderLens lens) {</p>
<p>        // Use lens to query current state (read-only)</p>
<p>        var currentOrder = await lens.Focus(cmd.OrderId);</p>
<p>        </p>
<p>        if (currentOrder == null) {</p>
<p>            throw new OrderNotFoundException(cmd.OrderId);</p>
<p>        }</p>
<p>        </p>
<p>        if (currentOrder.Status == OrderStatus.Shipped) {</p>
<p>            throw new InvalidOperationException("Cannot update shipped order");</p>
<p>        }</p>
<p>        </p>
<p>        // Return response based on decision</p>
<p>        return new OrderUpdated(</p>
<p>            OrderId: cmd.OrderId,</p>
<p>            Changes: cmd.Changes,</p>
<p>            UpdatedAt: DateTimeOffset.UtcNow</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Flexible Response Types</h2>

<p>Receptors can return single responses, tuples, or arrays:</p>

<pre><code class="language-csharp">// Single response
<p>public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    public async Task<OrderCreated> Receive(CreateOrder cmd) {</p>
<p>        return new OrderCreated(cmd.OrderId);</p>
<p>    }</p>
<p>}</p>

<p>// Multiple responses via tuple</p>
<p>public class PaymentReceptor : IReceptor<ProcessPayment, (PaymentProcessed, AuditEvent)> {</p>
<p>    public async Task<(PaymentProcessed, AuditEvent)> Receive(ProcessPayment cmd) {</p>
<p>        var payment = await ProcessPayment(cmd);</p>
<p>        return (</p>
<p>            new PaymentProcessed(payment.Id),</p>
<p>            new AuditEvent("PaymentProcessed", payment.Id)</p>
<p>        );</p>
<p>    }</p>
<p>}</p>

<p>// Array for dynamic responses</p>
<p>public class NotificationReceptor : IReceptor<OrderCreated, NotificationEvent[]> {</p>
<p>    public async Task<NotificationEvent[]> Receive(OrderCreated evt) {</p>
<p>        var notifications = new List<NotificationEvent>();</p>
<p>        </p>
<p>        notifications.Add(new EmailSent(evt.CustomerId));</p>
<p>        </p>
<p>        if (evt.Total > 1000) {</p>
<p>            notifications.Add(new HighValueAlert(evt.OrderId));</p>
<p>        }</p>
<p>        </p>
<p>        return notifications.ToArray();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Error Handling</h2>

<p>Use <code>Result<T></code> for explicit success/failure:</p>

<pre><code class="language-csharp">public class OrderCancelReceptor : IReceptor<CancelOrder, Result<OrderCancelled>> {
<p>    </p>
<p>    public async Task<Result<OrderCancelled>> Receive(CancelOrder cmd, IOrderLens lens) {</p>
<p>        var order = await lens.Focus(cmd.OrderId);</p>
<p>        </p>
<p>        if (order == null) {</p>
<p>            return Result.Failure<OrderCancelled>("Order not found");</p>
<p>        }</p>
<p>        </p>
<p>        if (order.Status == OrderStatus.Shipped) {</p>
<p>            return Result.Failure<OrderCancelled>("Cannot cancel shipped order");</p>
<p>        }</p>
<p>        </p>
<p>        return Result.Success(new OrderCancelled(cmd.OrderId));</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Source Generation</h2>

<p>:::new</p>
<p>Receptors are discovered at compile time via source generators:</p>
<p>:::</p>

<pre><code class="language-csharp">// Generated by Whizbang.Generators
<p>public static partial class WhizbangGenerated {</p>
<p>    public static void RegisterReceptors(IServiceCollection services) {</p>
<p>        services.AddScoped<IReceptor<CreateOrder, OrderCreated>, OrderReceptor>();</p>
<p>        services.AddScoped<IReceptor<CreateOrder, AuditEvent>, OrderAuditReceptor>();</p>
<p>        services.AddScoped<IReceptor<CreateOrder, FraudCheckResult>, OrderFraudReceptor>();</p>
<p>        services.AddScoped<IReceptor<UpdateOrder, OrderUpdated>, OrderUpdateReceptor>();</p>
<p>        services.AddScoped<IReceptor<CancelOrder, Result<OrderCancelled>>, OrderCancelReceptor>();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Policy Application</h2>

<p>:::new</p>
<p>Policies can be applied to receptors via attributes:</p>
<p>:::</p>

<pre><code class="language-csharp">[Retry(3, BackoffStrategy.Exponential)]
<p>[Timeout(5000)]</p>
<p>[CircuitBreaker(0.5, TimeoutSeconds = 30)]</p>
<p>public class PaymentReceptor : IReceptor<ProcessPayment, PaymentProcessed> {</p>
<p>    public async Task<PaymentProcessed> Receive(ProcessPayment cmd) {</p>
<p>        // Policies are applied automatically by the dispatcher</p>
<p>        var result = await ProcessPaymentAsync(cmd);</p>
<p>        return new PaymentProcessed(cmd.PaymentId, result.Amount);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Testing Receptors</h2>

<pre><code class="language-csharp">[Test]
<p>public class OrderReceptorTests {</p>
<p>    private OrderReceptor _receptor;</p>
<p>    </p>
<p>    [SetUp]</p>
<p>    public void Setup() {</p>
<p>        _receptor = new OrderReceptor();</p>
<p>    }</p>
<p>    </p>
<p>    [Test]</p>
<p>    public async Task CreateOrder_WithItems_ShouldReturnOrderCreated() {</p>
<p>        // Arrange</p>
<p>        var command = new CreateOrder(</p>
<p>            CustomerId: Guid.NewGuid(),</p>
<p>            Items: new[] { new OrderItem("SKU-001", 2, 29.99m) }</p>
<p>        );</p>
<p>        </p>
<p>        // Act</p>
<p>        var result = await _receptor.Receive(command);</p>
<p>        </p>
<p>        // Assert</p>
<p>        Assert.IsType<OrderCreated>(result);</p>
<p>        Assert.NotEqual(Guid.Empty, result.OrderId);</p>
<p>        Assert.Equal(59.98m, result.Total);</p>
<p>    }</p>
<p>    </p>
<p>    [Test]</p>
<p>    public async Task CreateOrder_WithNoItems_ShouldThrow() {</p>
<p>        // Arrange</p>
<p>        var command = new CreateOrder(</p>
<p>            CustomerId: Guid.NewGuid(),</p>
<p>            Items: Array.Empty<OrderItem>()</p>
<p>        );</p>
<p>        </p>
<p>        // Act & Assert</p>
<p>        await Assert.ThrowsAsync<InvalidOperationException>(</p>
<p>            () => _receptor.Receive(command)</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>IDE Features</h2>

<p>The IDE provides rich support for receptors:</p>

<pre><code class="language-csharp">// IDE shows: "Handles: CreateOrder → OrderCreated | Type-safe async receptor"
<p>public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> { }</p>

<p>// IDE shows: "3 receptors handle this message type"</p>
<p>public record CreateOrder(Guid CustomerId, OrderItem[] Items);</p>

<p>// IDE shows: "Returned by: OrderReceptor.Receive, OrderBusinessReceptor.Receive"</p>
<p>public record OrderCreated(Guid OrderId, Guid CustomerId);</p>
<p></code></pre></p>

<h2>Dispatcher Integration</h2>

<p>The Dispatcher provides different ways to invoke receptors:</p>

<pre><code class="language-csharp">public interface IDispatcher {
<p>    // Inline async - wait for single response</p>
<p>    Task<TResponse> Send<TResponse>(object message);</p>
<p>    </p>
<p>    // Fire and forget - no response needed</p>
<p>    Task Fire(object message);</p>
<p>    </p>
<p>    // Callback - handle response asynchronously</p>
<p>    Task SendWithCallback<TResponse>(object message, Func<TResponse, Task> callback);</p>
<p>    </p>
<p>    // Multiple responses (from multiple receptors)</p>
<p>    Task<IEnumerable<object>> SendAll(object message);</p>
<p>}</p>
<p></code></pre></p>

<h3>Usage Examples</h3>

<pre><code class="language-csharp">public class OrderController {
<p>    private readonly IDispatcher _dispatcher;</p>
<p>    </p>
<p>    // Inline async - wait for result</p>
<p>    public async Task<IActionResult> CreateOrder(CreateOrderRequest request) {</p>
<p>        var command = new CreateOrder(request.CustomerId, request.Items);</p>
<p>        var result = await _dispatcher.Send<OrderCreated>(command);</p>
<p>        return Ok(result);</p>
<p>    }</p>
<p>    </p>
<p>    // Fire and forget - audit logging</p>
<p>    public async Task LogAction(string action) {</p>
<p>        var auditCommand = new LogAuditEvent(action, GetUserId());</p>
<p>        await _dispatcher.Fire(auditCommand); // Don't wait for completion</p>
<p>    }</p>
<p>    </p>
<p>    // Multiple responses - get all results</p>
<p>    public async Task<IActionResult> ProcessOrderWithAudit(CreateOrder command) {</p>
<p>        var results = await _dispatcher.SendAll(command);</p>
<p>        </p>
<p>        var orderCreated = results.OfType<OrderCreated>().Single();</p>
<p>        var auditEvent = results.OfType<AuditEvent>().Single();</p>
<p>        var fraudResult = results.OfType<FraudCheckResult>().Single();</p>
<p>        </p>
<p>        return Ok(new { orderCreated, auditEvent, fraudResult });</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Limitations in v1.0.0</h2>

<p>:::info</p>
<p>These limitations are addressed in future versions:</p>
<p>:::</p>

<ul><li><strong>No state management</strong> - Receptors cannot maintain state between calls</li>
<li><strong>Basic validation</strong> - Manual validation in code  </li>
<li><strong>Limited dependency injection</strong> - Cannot inject services directly into Receive method</li>
<li><strong>Single message handling</strong> - Each receptor handles one message type</li>
</ul>
<h2>Migration Path</h2>

<h3>To v0.2.0 (Non-Breaking)</h3>

<p>:::planned</p>
<p>v0.2.0 adds these enhancements without breaking existing code:</p>
<p>:::</p>

<pre><code class="language-csharp">// v1.0.0 - Current async interface
<p>public async Task<OrderCreated> Receive(CreateOrder cmd) { }</p>

<p>// v0.2.0 - Enhanced capabilities</p>
<p>public async Task<OrderCreated> Receive(</p>
<p>    [Valid] CreateOrder cmd,      // Automatic validation</p>
<p>    IOrderService service,        // Service injection</p>
<p>    IMessageContext context       // Context injection</p>
<p>) { }</p>
<p></code></pre></p>

<h3>To v0.3.0 (Stateful Receptors)</h3>

<p>:::planned</p>
<p>v0.3.0 introduces stateful receptors for event sourcing:</p>
<p>:::</p>

<pre><code class="language-csharp">// v0.3.0 - Stateful receptor
<p>[EventSourced]</p>
<p>public class OrderReceptor : IStatefulReceptor<Order> {</p>
<p>    private Order state;  // Maintained from events</p>
<p>    </p>
<p>    public OrderUpdated Receive(UpdateOrder cmd) {</p>
<p>        // Can access state directly</p>
<p>        if (state.Status == OrderStatus.Shipped) {</p>
<p>            throw new InvalidOperationException();</p>
<p>        }</p>
<p>        return new OrderUpdated(state.Id, cmd.Changes);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Performance Characteristics</h2>

<p>| Operation | Target | Actual |</p>
<p>|-----------|--------|--------|</p>
<p>| Receive invocation | < 100ns | TBD |</p>
<p>| Event creation | < 50ns | TBD |</p>
<p>| Validation | < 1μs | TBD |</p>
<p>| Policy application | < 10μs | TBD |</p>

<h2>Best Practices</h2>

<ul><li><strong>Keep receptors pure</strong> - No side effects, only decisions</li>
<li><strong>Return events</strong> - Always return events, not void</li>
<li><strong>Validate early</strong> - Check preconditions first</li>
<li><strong>Use meaningful names</strong> - OrderReceptor, not OrderHandler</li>
<li><strong>One command type</strong> - Each receptor handles one command</li>
<li><strong>Test thoroughly</strong> - Unit test all paths</li>
</ul>
<h2>Related Documentation</h2>

<ul><li><a href="dispatcher.md">Dispatcher</a> - How commands reach receptors</li>
<li><a href="perspectives.md">Perspectives</a> - What happens to emitted events</li>
<li><a href="lenses.md">Lenses</a> - Querying state in receptors</li>
<li><a href="policy-engine.md">Policy Engine</a> - Applying policies to receptors</li>
<li><a href="../testing/foundation.md">Testing</a> - Testing receptors</li>
</ul>
<h2>Next Steps</h2>

<ul><li>See <a href="../../v0.2.0/enhancements/receptors.md">v0.2.0 Enhancements</a> for validation and injection features</li>
<li>See <a href="../../v0.3.0/features/stateful-receptors.md">v0.3.0 Stateful Receptors</a> for event sourcing</li>
<li>Review <a href="../examples/basic-receptor.md">Examples</a> for practical usage</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-components-transports" class="doc-section">
  <h3>Transports Component</h3>
  <p class="doc-path"><code>v1.0.0/components/transports</code></p>
  <p class="doc-description"><em>Basic in-process message transport for local development</em></p>
  <div class="doc-content">

<h1>Transports Component</h1>

<p>!<a href="https://img.shields.io/badge/version-1.0.0-blue">Version</a></p>
<p>!<a href="https://img.shields.io/badge/status-stable-green">Status</a></p>

<h2>Version History</h2>

<p>:::new</p>
<strong>New in v1.0.0</strong>: Basic in-process transport with synchronous message passing
<p>:::</p>


<h2>Overview</h2>

<p>Transports provide the communication layer in Whizbang, enabling message exchange between components. In v1.0.0, we provide a simple in-process transport that passes messages directly in memory - perfect for monolithic applications and testing.</p>

<h2>What is a Transport?</h2>

<p>A Transport:</p>
<ul><li><strong>Carries</strong> messages between components</li>
<li><strong>Handles</strong> serialization and deserialization</li>
<li><strong>Manages</strong> connections and channels</li>
<li><strong>Provides</strong> delivery guarantees</li>
</ul>
<p>Think of transports as the postal service of your application - they ensure messages get from sender to receiver reliably.</p>

<h2>Core Interface (v1.0.0)</h2>

<p>:::new</p>
<p>The basic transport interface for message passing:</p>
<p>:::</p>

<pre><code class="language-csharp">public interface ITransport {
<p>    // Send a message</p>
<p>    Task<TResponse> Send<TRequest, TResponse>(TRequest request, string destination)</p>
<p>        where TRequest : IMessage</p>
<p>        where TResponse : IMessage;</p>
<p>    </p>
<p>    // Send without response</p>
<p>    Task Publish<TMessage>(TMessage message, string topic)</p>
<p>        where TMessage : IMessage;</p>
<p>    </p>
<p>    // Subscribe to messages</p>
<p>    Task Subscribe<TMessage>(string topic, Func<TMessage, Task> handler)</p>
<p>        where TMessage : IMessage;</p>
<p>    </p>
<p>    // Transport metadata</p>
<p>    string Name { get; }</p>
<p>    TransportCapabilities Capabilities { get; }</p>
<p>}</p>

<p>public enum TransportCapabilities {</p>
<p>    None = 0,</p>
<p>    RequestResponse = 1,</p>
<p>    PublishSubscribe = 2,</p>
<p>    Streaming = 4,</p>
<p>    Reliable = 8,</p>
<p>    Ordered = 16</p>
<p>}</p>
<p></code></pre></p>

<h2>In-Process Transport</h2>

<p>:::new</p>
<p>The default in-process transport for v1.0.0:</p>
<p>:::</p>

<pre><code class="language-csharp">[WhizbangTransport("InProcess")]
<p>public class InProcessTransport : ITransport {</p>
<p>    private readonly Dictionary<string, object> _handlers = new();</p>
<p>    private readonly Dictionary<string, List<Func<object, Task>>> _subscribers = new();</p>
<p>    private readonly object _lock = new();</p>
<p>    </p>
<p>    public string Name => "InProcess";</p>
<p>    public TransportCapabilities Capabilities => </p>
<p>        TransportCapabilities.RequestResponse | </p>
<p>        TransportCapabilities.PublishSubscribe |</p>
<p>        TransportCapabilities.Ordered;</p>
<p>    </p>
<p>    // Register a handler for request/response</p>
<p>    public void RegisterHandler<TRequest, TResponse>(</p>
<p>        string destination, </p>
<p>        Func<TRequest, Task<TResponse>> handler)</p>
<p>        where TRequest : IMessage</p>
<p>        where TResponse : IMessage {</p>
<p>        </p>
<p>        lock (_lock) {</p>
<p>            _handlers[destination] = handler;</p>
<p>        }</p>
<p>    }</p>
<p>    </p>
<p>    public async Task<TResponse> Send<TRequest, TResponse>(</p>
<p>        TRequest request, </p>
<p>        string destination)</p>
<p>        where TRequest : IMessage</p>
<p>        where TResponse : IMessage {</p>
<p>        </p>
<p>        object handler;</p>
<p>        lock (_lock) {</p>
<p>            if (!_handlers.TryGetValue(destination, out handler!)) {</p>
<p>                throw new TransportException($"No handler registered for {destination}");</p>
<p>            }</p>
<p>        }</p>
<p>        </p>
<p>        var typedHandler = (Func<TRequest, Task<TResponse>>)handler;</p>
<p>        return await typedHandler(request);</p>
<p>    }</p>
<p>    </p>
<p>    public async Task Publish<TMessage>(TMessage message, string topic)</p>
<p>        where TMessage : IMessage {</p>
<p>        </p>
<p>        List<Func<object, Task>> subscribers;</p>
<p>        lock (_lock) {</p>
<p>            if (!_subscribers.TryGetValue(topic, out subscribers!)) {</p>
<p>                return; // No subscribers</p>
<p>            }</p>
<p>            subscribers = subscribers.ToList(); // Copy to avoid lock during execution</p>
<p>        }</p>
<p>        </p>
<p>        // Execute all subscribers</p>
<p>        var tasks = subscribers.Select(sub => sub(message!));</p>
<p>        await Task.WhenAll(tasks);</p>
<p>    }</p>
<p>    </p>
<p>    public Task Subscribe<TMessage>(string topic, Func<TMessage, Task> handler)</p>
<p>        where TMessage : IMessage {</p>
<p>        </p>
<p>        lock (_lock) {</p>
<p>            if (!_subscribers.ContainsKey(topic)) {</p>
<p>                _subscribers[topic] = new List<Func<object, Task>>();</p>
<p>            }</p>
<p>            </p>
<p>            _subscribers[topic].Add(async obj => await handler((TMessage)obj));</p>
<p>        }</p>
<p>        </p>
<p>        return Task.CompletedTask;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Message Contracts</h2>

<p>:::new</p>
<p>Define messages for transport:</p>
<p>:::</p>

<pre><code class="language-csharp">public interface IMessage {
<p>    Guid Id { get; }</p>
<p>    DateTimeOffset Timestamp { get; }</p>
<p>    Dictionary<string, string> Headers { get; }</p>
<p>}</p>

<p>public abstract record Message : IMessage {</p>
<p>    public Guid Id { get; init; } = Guid.NewGuid();</p>
<p>    public DateTimeOffset Timestamp { get; init; } = DateTimeOffset.UtcNow;</p>
<p>    public Dictionary<string, string> Headers { get; init; } = new();</p>
<p>}</p>

<p>// Command message</p>
<p>public record CreateOrderCommand : Message {</p>
<p>    public Guid CustomerId { get; init; }</p>
<p>    public List<OrderItem> Items { get; init; }</p>
<p>    public decimal Total { get; init; }</p>
<p>}</p>

<p>// Event message</p>
<p>public record OrderCreatedEvent : Message {</p>
<p>    public Guid OrderId { get; init; }</p>
<p>    public Guid CustomerId { get; init; }</p>
<p>    public OrderStatus Status { get; init; }</p>
<p>}</p>

<p>// Query message</p>
<p>public record GetOrderQuery : Message {</p>
<p>    public Guid OrderId { get; init; }</p>
<p>}</p>

<p>// Response message</p>
<p>public record OrderResponse : Message {</p>
<p>    public Order Order { get; init; }</p>
<p>    public bool Success { get; init; }</p>
<p>    public string? Error { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h2>Transport Registration</h2>

<p>Transports are registered and configured at startup:</p>

<pre><code class="language-csharp">// Manual registration
<p>services.AddWhizbangTransports(options => {</p>
<p>    options.UseInProcess();</p>
<p>});</p>

<p>// Register handlers</p>
<p>services.AddTransportHandlers(handlers => {</p>
<p>    handlers.Handle<CreateOrderCommand, OrderCreatedEvent>("orders", </p>
<p>        async cmd => {</p>
<p>            // Process command</p>
<p>            return new OrderCreatedEvent { </p>
<p>                OrderId = Guid.NewGuid(),</p>
<p>                CustomerId = cmd.CustomerId </p>
<p>            };</p>
<p>        });</p>
<p>});</p>

<p>// Source generated registration</p>
<p>public static partial class WhizbangGenerated {</p>
<p>    public static void RegisterTransports(IServiceCollection services) {</p>
<p>        services.AddSingleton<ITransport, InProcessTransport>();</p>
<p>        </p>
<p>        // Auto-discover and register handlers</p>
<p>        services.AddScoped<IHandler<CreateOrderCommand>, CreateOrderHandler>();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Using Transports</h2>

<h3>In Receptors</h3>

<pre><code class="language-csharp">public class OrderReceptor : IReceptor<CreateOrder> {
<p>    private readonly ITransport _transport;</p>
<p>    </p>
<p>    public OrderReceptor(ITransport transport) {</p>
<p>        _transport = transport;</p>
<p>    }</p>
<p>    </p>
<p>    public async Task<OrderCreated> Receive(CreateOrder cmd) {</p>
<p>        // Validate locally</p>
<p>        if (!IsValid(cmd)) {</p>
<p>            throw new ValidationException("Invalid order");</p>
<p>        }</p>
<p>        </p>
<p>        // Send to inventory service (in-process for now)</p>
<p>        var inventoryCommand = new CheckInventoryCommand {</p>
<p>            Items = cmd.Items</p>
<p>        };</p>
<p>        </p>
<p>        var inventoryResponse = await _transport.Send<CheckInventoryCommand, InventoryResponse>(</p>
<p>            inventoryCommand, </p>
<p>            "inventory"</p>
<p>        );</p>
<p>        </p>
<p>        if (!inventoryResponse.Available) {</p>
<p>            throw new InsufficientInventoryException();</p>
<p>        }</p>
<p>        </p>
<p>        // Create order</p>
<p>        var orderCreated = new OrderCreated {</p>
<p>            OrderId = Guid.NewGuid(),</p>
<p>            CustomerId = cmd.CustomerId,</p>
<p>            Items = cmd.Items</p>
<p>        };</p>
<p>        </p>
<p>        // Publish event</p>
<p>        await _transport.Publish(orderCreated, "orders.created");</p>
<p>        </p>
<p>        return orderCreated;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Event Subscriptions</h3>

<pre><code class="language-csharp">public class NotificationService {
<p>    private readonly ITransport _transport;</p>
<p>    </p>
<p>    public async Task Start() {</p>
<p>        // Subscribe to order events</p>
<p>        await _transport.Subscribe<OrderCreatedEvent>(</p>
<p>            "orders.created",</p>
<p>            HandleOrderCreated</p>
<p>        );</p>
<p>        </p>
<p>        await _transport.Subscribe<OrderShippedEvent>(</p>
<p>            "orders.shipped",</p>
<p>            HandleOrderShipped</p>
<p>        );</p>
<p>    }</p>
<p>    </p>
<p>    private async Task HandleOrderCreated(OrderCreatedEvent evt) {</p>
<p>        // Send confirmation email</p>
<p>        await SendEmail(evt.CustomerId, "Order Confirmed", </p>
<p>            $"Your order {evt.OrderId} has been confirmed.");</p>
<p>    }</p>
<p>    </p>
<p>    private async Task HandleOrderShipped(OrderShippedEvent evt) {</p>
<p>        // Send shipping notification</p>
<p>        await SendEmail(evt.CustomerId, "Order Shipped",</p>
<p>            $"Your order {evt.OrderId} has been shipped!");</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Message Pipeline</h2>

<p>:::new</p>
<p>Simple message pipeline for v1.0.0:</p>
<p>:::</p>

<pre><code class="language-csharp">public interface IMessagePipeline {
<p>    Task<TResponse> Process<TRequest, TResponse>(</p>
<p>        TRequest request,</p>
<p>        Func<TRequest, Task<TResponse>> next);</p>
<p>}</p>

<p>public class MessagePipeline : IMessagePipeline {</p>
<p>    private readonly List<IMessageMiddleware> _middleware = new();</p>
<p>    </p>
<p>    public void Use(IMessageMiddleware middleware) {</p>
<p>        _middleware.Add(middleware);</p>
<p>    }</p>
<p>    </p>
<p>    public async Task<TResponse> Process<TRequest, TResponse>(</p>
<p>        TRequest request,</p>
<p>        Func<TRequest, Task<TResponse>> handler) {</p>
<p>        </p>
<p>        // Build pipeline</p>
<p>        Func<TRequest, Task<TResponse>> pipeline = handler;</p>
<p>        </p>
<p>        foreach (var middleware in _middleware.Reverse<IMessageMiddleware>()) {</p>
<p>            var next = pipeline;</p>
<p>            pipeline = async req => await middleware.Process(req, () => next(req));</p>
<p>        }</p>
<p>        </p>
<p>        return await pipeline(request);</p>
<p>    }</p>
<p>}</p>

<p>// Example middleware</p>
<p>public class LoggingMiddleware : IMessageMiddleware {</p>
<p>    private readonly ILogger _logger;</p>
<p>    </p>
<p>    public async Task<object> Process(object message, Func<Task<object>> next) {</p>
<p>        _logger.LogInformation("Processing {MessageType}", message.GetType().Name);</p>
<p>        var start = Stopwatch.StartNew();</p>
<p>        </p>
<p>        try {</p>
<p>            var result = await next();</p>
<p>            _logger.LogInformation("Processed in {ElapsedMs}ms", start.ElapsedMilliseconds);</p>
<p>            return result;</p>
<p>        }</p>
<p>        catch (Exception ex) {</p>
<p>            _logger.LogError(ex, "Failed after {ElapsedMs}ms", start.ElapsedMilliseconds);</p>
<p>            throw;</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Testing with Transports</h2>

<pre><code class="language-csharp">[Test]
<p>public class TransportTests {</p>
<p>    private InProcessTransport _transport;</p>
<p>    </p>
<p>    [SetUp]</p>
<p>    public void Setup() {</p>
<p>        _transport = new InProcessTransport();</p>
<p>    }</p>
<p>    </p>
<p>    [Test]</p>
<p>    public async Task Send_ShouldInvokeHandler() {</p>
<p>        // Arrange</p>
<p>        var handlerCalled = false;</p>
<p>        _transport.RegisterHandler<TestCommand, TestResponse>(</p>
<p>            "test",</p>
<p>            async cmd => {</p>
<p>                handlerCalled = true;</p>
<p>                return new TestResponse { Success = true };</p>
<p>            }</p>
<p>        );</p>
<p>        </p>
<p>        // Act</p>
<p>        var response = await _transport.Send<TestCommand, TestResponse>(</p>
<p>            new TestCommand(),</p>
<p>            "test"</p>
<p>        );</p>
<p>        </p>
<p>        // Assert</p>
<p>        Assert.True(handlerCalled);</p>
<p>        Assert.True(response.Success);</p>
<p>    }</p>
<p>    </p>
<p>    [Test]</p>
<p>    public async Task Publish_ShouldNotifyAllSubscribers() {</p>
<p>        // Arrange</p>
<p>        var received1 = false;</p>
<p>        var received2 = false;</p>
<p>        </p>
<p>        await _transport.Subscribe<TestEvent>("test.topic", evt => {</p>
<p>            received1 = true;</p>
<p>            return Task.CompletedTask;</p>
<p>        });</p>
<p>        </p>
<p>        await _transport.Subscribe<TestEvent>("test.topic", evt => {</p>
<p>            received2 = true;</p>
<p>            return Task.CompletedTask;</p>
<p>        });</p>
<p>        </p>
<p>        // Act</p>
<p>        await _transport.Publish(new TestEvent(), "test.topic");</p>
<p>        </p>
<p>        // Assert</p>
<p>        Assert.True(received1);</p>
<p>        Assert.True(received2);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>IDE Features</h2>

<pre><code class="language-csharp">// IDE shows: "Transport: InProcess | Handlers: 12 | Subscribers: 34"
<p>public interface ITransport { }</p>

<p>// IDE shows: "Called 234 times | Avg: 0.5ms | Success: 99.8%"</p>
<p>public Task<TResponse> Send<TRequest, TResponse>(...) { }</p>

<p>// IDE shows: "Topic: orders.created | Subscribers: 3"</p>
<p>public Task Publish<TMessage>(TMessage message, string topic) { }</p>
<p></code></pre></p>

<h2>Performance Characteristics</h2>

<p>| Operation | Target | Actual |</p>
<p>|-----------|--------|--------|</p>
<p>| Send (in-process) | < 100ns | TBD |</p>
<p>| Publish (10 subscribers) | < 1μs | TBD |</p>
<p>| Subscribe | < 50ns | TBD |</p>
<p>| Message serialization | N/A | N/A |</p>

<h2>Limitations in v1.0.0</h2>

<p>:::info</p>
<p>These limitations are addressed in future versions:</p>
<p>:::</p>

<ul><li><strong>In-process only</strong> - No network communication</li>
<li><strong>No persistence</strong> - Messages lost on crash</li>
<li><strong>No serialization</strong> - Direct object passing</li>
<li><strong>No retry</strong> - Failed messages are lost</li>
<li><strong>Single instance</strong> - No distributed messaging</li>
</ul>
<h2>Migration Path</h2>

<h3>To v0.2.0 (HTTP/WebSocket)</h3>

<p>:::planned</p>
<p>v0.2.0 adds network transports:</p>
<p>:::</p>

<pre><code class="language-csharp">// v0.2.0 - HTTP transport
<p>services.AddWhizbangTransports(options => {</p>
<p>    options.UseHttp(http => {</p>
<p>        http.BaseUrl = "https://api.example.com";</p>
<p>        http.Timeout = TimeSpan.FromSeconds(30);</p>
<p>    });</p>
<p>});</p>
<p></code></pre></p>

<h3>To v0.3.0 (Message Queues)</h3>

<p>:::planned</p>
<p>v0.3.0 adds message queue support:</p>
<p>:::</p>

<pre><code class="language-csharp">// v0.3.0 - RabbitMQ transport
<p>services.AddWhizbangTransports(options => {</p>
<p>    options.UseRabbitMQ(rabbit => {</p>
<p>        rabbit.ConnectionString = "amqp://localhost";</p>
<p>        rabbit.ExchangeName = "whizbang";</p>
<p>    });</p>
<p>});</p>
<p></code></pre></p>

<h2>Best Practices</h2>

<ul><li><strong>Design for distribution</strong> - Even with in-process, assume network</li>
<li><strong>Use message contracts</strong> - Define clear message schemas</li>
<li><strong>Handle failures</strong> - Plan for transport failures</li>
<li><strong>Version messages</strong> - Plan for message evolution</li>
<li><strong>Keep messages small</strong> - Large messages impact performance</li>
<li><strong>Test with different transports</strong> - Ensure transport agnostic code</li>
</ul>
<h2>Related Documentation</h2>

<ul><li><a href="dispatcher.md">Dispatcher</a> - How messages are routed</li>
<li><a href="receptors.md">Receptors</a> - Message handlers</li>
<li><a href="../testing/foundation.md">Testing</a> - Testing with transports</li>
<li><a href="../../roadmap/FEATURE-EVOLUTION.md">Feature Evolution</a> - How transports evolve</li>
</ul>
<h2>Next Steps</h2>

<ul><li>See <a href="../../v0.2.0/enhancements/transports.md">v0.2.0 HTTP Transport</a> for REST APIs</li>
<li>See <a href="../../v0.3.0/features/transports.md">v0.3.0 Message Queues</a> for async messaging</li>
<li>Review <a href="../examples/messaging-patterns.md">Examples</a> for transport patterns</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Core Concepts</h2>
<article id="v1-0-0-core-concepts-audit-logging" class="doc-section">
  <h3>Audit Logging</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/audit-logging</code></p>
  <p class="doc-description"><em>Implement compliance-ready audit logging using Whizbang's System Events - capture who changed what, when, and why</em></p>
  <div class="doc-content">

<h1>Audit Logging</h1>

<p>Whizbang provides audit logging through <strong>System Events</strong> - internal events emitted by Whizbang for audit, monitoring, and operations. When audit is enabled, Whizbang emits an <code>EventAudited</code> system event for each domain event, which can be captured by a simple perspective.</p>

<h2>Core Concept</h2>

<pre><code class="language-">┌─────────────────────────────────────────────────────────────────┐
<p>│  Domain Event Appended (OrderCreated, PaymentProcessed, ...)    │</p>
<p>│       │                                                          │</p>
<p>│       ▼                                                          │</p>
<p>│  [System Audit Enabled?] ──No──► (nothing emitted)              │</p>
<p>│       │                                                          │</p>
<p>│      Yes                                                         │</p>
<p>│       │                                                          │</p>
<p>│       ▼                                                          │</p>
<p>│  Emit EventAudited to $wb-system stream                         │</p>
<p>│       │                                                          │</p>
<p>│       ▼                                                          │</p>
<p>│  AuditPerspective : IPerspectiveFor<AuditLogEntry, EventAudited>│</p>
<p>│       │                                                          │</p>
<p>│       ▼                                                          │</p>
<p>│  wb_audit_log table (queryable via IAuditLogLens)               │</p>
<p>└─────────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Key insight</strong>: System events dogfood Whizbang's own event infrastructure - no special interfaces needed.

<strong>Benefits</strong>:
<ul><li><strong>Opt-in per host</strong>: Enable audit in BFF, skip in background workers</li>
<li><strong>Same infrastructure</strong>: Events, perspectives, and lenses work identically</li>
<li><strong>Exclude by exception</strong>: All events audited by default, opt-out specific types</li>
<li><strong>Dedicated stream</strong>: System events isolated in <code>$wb-system</code> stream</li>
</ul>
<hr>

<h2>Quick Start</h2>

<h3>1. Enable System Audit</h3>

<pre><code class="language-csharp">// In Program.cs - BFF or any host that needs audit logging
<p>services.AddWhizbang(options => {</p>
<p>  options.SystemEvents.EnableAudit();</p>
<p>});</p>
<p></code></pre></p>

<h3>2. Create Audit Perspective</h3>

<pre><code class="language-csharp">using Whizbang.Core.Audit;
<p>using Whizbang.Core.Perspectives;</p>
<p>using Whizbang.Core.SystemEvents;</p>

<p>/// <summary></p>
<p>/// Perspective that captures EventAudited system events into queryable audit log.</p>
<p>/// </summary></p>
<p>public sealed class AuditPerspective : IPerspectiveFor<AuditLogEntry, EventAudited> {</p>
<p>  public AuditLogEntry Apply(AuditLogEntry current, EventAudited @event) {</p>
<p>    return new AuditLogEntry {</p>
<p>      Id = @event.Id,</p>
<p>      StreamId = @event.OriginalStreamId,</p>
<p>      StreamPosition = @event.OriginalStreamPosition,</p>
<p>      EventType = @event.OriginalEventType,</p>
<p>      Timestamp = @event.Timestamp,</p>
<p>      TenantId = @event.TenantId,</p>
<p>      UserId = @event.UserId,</p>
<p>      UserName = @event.UserName,</p>
<p>      CorrelationId = @event.CorrelationId,</p>
<p>      CausationId = @event.CausationId,</p>
<p>      Body = @event.OriginalBody,</p>
<p>      AuditReason = @event.AuditReason</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>3. Query Audit Log</h3>

<pre><code class="language-csharp">public interface IAuditLogLens : ILensQuery<AuditLogEntry> { }

<p>public class ComplianceService {</p>
<p>  private readonly IAuditLogLens _auditLens;</p>

<p>  // Query: What did user X change?</p>
<p>  public async Task<IReadOnlyList<AuditLogEntry>> GetUserActivityAsync(</p>
<p>      string userId, CancellationToken ct) {</p>
<p>    return await _auditLens.QueryAsync(q => q</p>
<p>        .Where(a => a.UserId == userId)</p>
<p>        .OrderByDescending(a => a.Timestamp), ct);</p>
<p>  }</p>

<p>  // Query: Who changed entity X?</p>
<p>  public async Task<IReadOnlyList<AuditLogEntry>> GetEntityHistoryAsync(</p>
<p>      string streamId, CancellationToken ct) {</p>
<p>    return await _auditLens.QueryAsync(q => q</p>
<p>        .Where(a => a.StreamId == streamId)</p>
<p>        .OrderBy(a => a.StreamPosition), ct);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>System Events</h2>

<p>System events are internal Whizbang events stored in a dedicated <code>$wb-system</code> stream.</p>

<h3>ISystemEvent Interface</h3>

<pre><code class="language-csharp">namespace Whizbang.Core.SystemEvents;

<p>/// <summary></p>
<p>/// Marker interface for Whizbang system events.</p>
<p>/// System events flow through normal event infrastructure but are stored separately.</p>
<p>/// </summary></p>
<p>public interface ISystemEvent : IEvent { }</p>
<p></code></pre></p>

<h3>EventAudited</h3>

<p>The <code>EventAudited</code> event captures metadata about each domain event:</p>

<pre><code class="language-csharp">public sealed record EventAudited : ISystemEvent {
<p>  // Identity</p>
<p>  public required Guid Id { get; init; }</p>

<p>  // Original event info</p>
<p>  public required string OriginalEventType { get; init; }</p>
<p>  public required string OriginalStreamId { get; init; }</p>
<p>  public required long OriginalStreamPosition { get; init; }</p>
<p>  public required JsonElement OriginalBody { get; init; }</p>
<p>  public required DateTimeOffset Timestamp { get; init; }</p>

<p>  // Scope (who) - copied from event metadata</p>
<p>  public string? TenantId { get; init; }</p>
<p>  public string? UserId { get; init; }</p>
<p>  public string? UserName { get; init; }</p>
<p>  public string? CorrelationId { get; init; }</p>
<p>  public string? CausationId { get; init; }</p>

<p>  // Audit metadata</p>
<p>  public string? AuditReason { get; init; }</p>
<p>  public AuditLevel AuditLevel { get; init; } = AuditLevel.Info;</p>
<p>}</p>
<p></code></pre></p>

<h3>Dedicated System Stream</h3>

<pre><code class="language-csharp">public static class SystemEventStreams {
<p>  /// <summary>The dedicated system event stream name.</summary></p>
<p>  public static string Name => "$wb-system";</p>

<p>  /// <summary>Stream prefix for system events.</summary></p>
<p>  public static string Prefix => "$wb-";</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Excluding Events from Audit</h2>

<p>By default, <strong>all events are audited</strong> when system audit is enabled. Use <code>[AuditEvent(Exclude = true)]</code> to opt-out specific event types:</p>

<pre><code class="language-csharp">using Whizbang.Core.Attributes;

<p>// High-frequency event - exclude from audit to avoid log bloat</p>
<p>[AuditEvent(Exclude = true, Reason = "High-frequency heartbeat event")]</p>
<p>public record HeartbeatEvent(Guid ServiceId) : IEvent;</p>

<p>// Temporary/internal event - exclude from compliance audit</p>
<p>[AuditEvent(Exclude = true, Reason = "Internal processing state, not user-facing")]</p>
<p>public record ProcessingStepCompleted(Guid WorkflowId, int Step) : IEvent;</p>

<p>// Normal events are audited automatically</p>
<p>public record OrderCreated(Guid OrderId, Guid CustomerId) : IEvent;</p>
<p></code></pre></p>

<h3>Adding Audit Context</h3>

<p>Use <code>[AuditEvent]</code> without <code>Exclude</code> to add context to audited events:</p>

<pre><code class="language-csharp">// Mark with audit reason for compliance queries
<p>[AuditEvent(Reason = "PII access", Level = AuditLevel.Warning)]</p>
<p>public record CustomerDataViewed(Guid CustomerId, string ViewedBy) : IEvent;</p>

<p>// Critical operations get Critical level</p>
<p>[AuditEvent(Reason = "Financial transaction", Level = AuditLevel.Critical)]</p>
<p>public record PaymentProcessedEvent(Guid OrderId, decimal Amount) : IEvent;</p>
<p></code></pre></p>

<hr>

<h2>AuditEventAttribute</h2>

<pre><code class="language-csharp">[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
<p>public sealed class AuditEventAttribute : MessageTagAttribute {</p>
<p>  /// <summary></p>
<p>  /// When true, excludes this event type from system audit.</p>
<p>  /// Default is false (all events audited when audit is enabled).</p>
<p>  /// </summary></p>
<p>  public bool Exclude { get; init; }</p>

<p>  /// <summary></p>
<p>  /// Optional reason documenting why this event requires/skips auditing.</p>
<p>  /// </summary></p>
<p>  public string? Reason { get; init; }</p>

<p>  /// <summary></p>
<p>  /// Audit severity level. Default is Info.</p>
<p>  /// </summary></p>
<p>  public AuditLevel Level { get; init; } = AuditLevel.Info;</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>AuditLevel Enum</h2>

<p>Categorize audit entries by severity:</p>

<pre><code class="language-csharp">public enum AuditLevel {
<p>  Info,     // Routine operations (default)</p>
<p>  Warning,  // Sensitive data access, unusual patterns</p>
<p>  Critical  // Financial transactions, security events</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Real-Time Alerts (Optional)</h2>

<p>For real-time audit alerts in addition to durable persistence, use a tag hook:</p>

<pre><code class="language-csharp">// Hook provides real-time logging/alerts
<p>// Perspective provides durable persistence</p>
<p>services.AddWhizbang(options => {</p>
<p>  options.SystemEvents.EnableAudit();</p>
<p>  options.Tags.UseHook<AuditEventAttribute, AuditAlertHook>();</p>
<p>});</p>

<p>public sealed class AuditAlertHook : IMessageTagHook<AuditEventAttribute> {</p>
<p>  private readonly ILogger<AuditAlertHook> _logger;</p>

<p>  public ValueTask<JsonElement?> OnTaggedMessageAsync(</p>
<p>      TagContext<AuditEventAttribute> context, CancellationToken ct) {</p>

<p>    // Real-time logging - perspective handles persistence</p>
<p>    _logger.LogInformation(</p>
<p>      "Audit [{Level}]: {EventType} - {Reason}",</p>
<p>      context.Attribute.Level,</p>
<p>      context.MessageType.Name,</p>
<p>      context.Attribute.Reason);</p>

<p>    return ValueTask.FromResult<JsonElement?>(null);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Separation of concerns</strong>:
<ul><li><strong>Tag hook</strong>: Real-time alerts, logging, external notifications</li>
<li><strong>System Events + Perspective</strong>: Durable persistence</li>
</ul>
<hr>

<h2>Database Schema</h2>

<pre><code class="language-sql">-- Audit log table (perspective store)
<p>CREATE TABLE wb_audit_log (</p>
<p>    id UUID PRIMARY KEY,</p>
<p>    stream_id VARCHAR(255) NOT NULL,</p>
<p>    stream_position BIGINT NOT NULL,</p>
<p>    event_type VARCHAR(255) NOT NULL,</p>
<p>    timestamp TIMESTAMPTZ NOT NULL,</p>
<p>    tenant_id VARCHAR(100),</p>
<p>    user_id VARCHAR(100),</p>
<p>    user_name VARCHAR(255),</p>
<p>    correlation_id VARCHAR(100),</p>
<p>    causation_id VARCHAR(100),</p>
<p>    body JSONB NOT NULL,</p>
<p>    audit_reason VARCHAR(500),</p>
<p>    audit_level VARCHAR(20)</p>
<p>);</p>

<p>-- Indexes for compliance queries</p>
<p>CREATE INDEX idx_audit_log_user_id ON wb_audit_log(user_id, timestamp DESC);</p>
<p>CREATE INDEX idx_audit_log_stream_id ON wb_audit_log(stream_id, stream_position);</p>
<p>CREATE INDEX idx_audit_log_tenant_timestamp ON wb_audit_log(tenant_id, timestamp DESC);</p>
<p>CREATE INDEX idx_audit_log_level ON wb_audit_log(audit_level) WHERE audit_level IN ('Warning', 'Critical');</p>
<p></code></pre></p>

<hr>

<h2>Compliance Patterns</h2>

<h3>GDPR: User Activity Report</h3>

<pre><code class="language-csharp">public async Task<DataAccessReport> GenerateAccessReportAsync(
<p>    string userId, CancellationToken ct) {</p>
<p>  var entries = await _auditLens.QueryAsync(q => q</p>
<p>      .Where(a => a.UserId == userId)</p>
<p>      .OrderByDescending(a => a.Timestamp), ct);</p>

<p>  return new DataAccessReport {</p>
<p>    UserId = userId,</p>
<p>    GeneratedAt = DateTimeOffset.UtcNow,</p>
<p>    AccessEvents = entries.ToList()</p>
<p>  };</p>
<p>}</p>
<p></code></pre></p>

<h3>SOX: Financial Transaction Trail</h3>

<pre><code class="language-csharp">public async Task<IReadOnlyList<AuditLogEntry>> GetFinancialAuditTrailAsync(
<p>    DateTimeOffset from, DateTimeOffset to, CancellationToken ct) {</p>
<p>  return await _auditLens.QueryAsync(q => q</p>
<p>      .Where(a => a.Timestamp >= from && a.Timestamp <= to)</p>
<p>      .Where(a => a.AuditReason == "Financial transaction")</p>
<p>      .OrderBy(a => a.Timestamp), ct);</p>
<p>}</p>
<p></code></pre></p>

<h3>Critical Events Dashboard</h3>

<pre><code class="language-csharp">public async Task<IReadOnlyList<AuditLogEntry>> GetCriticalEventsAsync(
<p>    int hours, CancellationToken ct) {</p>
<p>  var since = DateTimeOffset.UtcNow.AddHours(-hours);</p>
<p>  return await _auditLens.QueryAsync(q => q</p>
<p>      .Where(a => a.Timestamp >= since)</p>
<p>      .Where(a => a.AuditLevel == AuditLevel.Critical)</p>
<p>      .OrderByDescending(a => a.Timestamp), ct);</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO</h3>

<ul><li><strong>Enable audit per host</strong>: Different services have different audit needs</li>
<li><strong>Exclude high-frequency events</strong>: Heartbeats, health checks, internal processing</li>
<li><strong>Add audit reasons</strong>: Document why events are audited for compliance</li>
<li><strong>Use appropriate levels</strong>: Info for routine, Warning for sensitive, Critical for financial</li>
<li><strong>Index audit tables</strong>: For common query patterns (user, tenant, timestamp)</li>
</ul>
<h3>DON'T</h3>

<ul><li><strong>Audit everything blindly</strong>: Exclude non-essential events to manage storage</li>
<li><strong>Store sensitive data</strong>: Passwords, tokens, PII that shouldn't be retained</li>
<li><strong>Skip the Reason</strong>: Essential for compliance audits</li>
<li><strong>Forget multi-tenancy</strong>: Partition or filter by TenantId</li>
<li><strong>Delete audit logs</strong>: Without proper retention policies</li>
</ul>
<hr>

<h2>Other System Events</h2>

<p>Audit is just one category of system events. Whizbang provides others for observability:</p>

<p>| Event | Description | Use Case |</p>
<p>|-------|-------------|----------|</p>
<p>| <code>EventAudited</code> | Domain event audited | Compliance, audit trail |</p>
<p>| <code>PerspectiveRebuilding</code> | Perspective rebuild started | Ops monitoring |</p>
<p>| <code>PerspectiveRebuilt</code> | Perspective rebuild completed | Ops monitoring |</p>
<p>| <code>ReceptorFailed</code> | Receptor threw exception | Error tracking |</p>
<p>| <code>MessageDeadLettered</code> | Message sent to DLQ | DLQ monitoring |</p>

<p>Enable specific categories:</p>
<pre><code class="language-csharp">services.AddWhizbang(options => {
<p>  options.SystemEvents.EnableAudit();           // EventAudited</p>
<p>  options.SystemEvents.EnablePerspectiveEvents(); // Rebuilding, rebuilt</p>
<p>  options.SystemEvents.EnableErrorEvents();      // Failed, dead-lettered</p>
<p>  options.SystemEvents.EnableAll();              // All system events</p>
<p>});</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Core Concepts</strong>:
<ul><li><a href="system-events.md">System Events</a> - Full system events documentation</li>
<li><a href="perspectives.md">Perspectives</a> - How perspectives work</li>
</ul>
<strong>Implementation</strong>:
<ul><li><a href="../data/perspective-store.md">Perspective Store</a> - Storage patterns</li>
<li><a href="../lenses/scoped-lenses.md">Scoped Lenses</a> - Multi-tenant queries</li>
<li><a href="../messaging/tag-hooks.md">Tag Hooks</a> - Real-time event processing</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2025-01-22</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-dispatcher" class="doc-section">
  <h3>Dispatcher Deep Dive</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/dispatcher</code></p>
  <p class="doc-description"><em>Master the Whizbang Dispatcher - three dispatch patterns (SendAsync, LocalInvokeAsync, PublishAsync) for commands, queries, and events</em></p>
  <div class="doc-content">

<h1>Dispatcher Deep Dive</h1>

<p>The <strong>Dispatcher</strong> is Whizbang's central message router. It provides three distinct dispatch patterns for different messaging scenarios: commands, queries, and events.</p>

<h2>Quick Reference</h2>

<p>| Pattern | Use Case | Return Type | Performance | Distribution |</p>
<p>|---------|----------|-------------|-------------|--------------|</p>
<p>| <code>SendAsync</code> | Commands with delivery tracking | <code>DeliveryReceipt</code> | ~100μs | Local or Remote |</p>
<p>| <code>LocalInvokeAsync</code> | In-process queries/commands | <code>TResponse</code> | < 20ns | Local only |</p>
<p>| <code>PublishAsync</code> | Event broadcasting | <code>void</code> | ~50μs | Local or Remote |</p>

<h2>IDispatcher Interface</h2>

<pre><code class="language-csharp">namespace Whizbang.Core;

<p>public interface IDispatcher {</p>
<p>    // Pattern 1: Command dispatch with delivery receipt</p>
<p>    Task<DeliveryReceipt> SendAsync<TMessage>(</p>
<p>        TMessage message,</p>
<p>        CancellationToken cancellationToken = default</p>
<p>    ) where TMessage : notnull;</p>

<p>    // Pattern 2: In-process RPC with typed response</p>
<p>    Task<TResponse> LocalInvokeAsync<TMessage, TResponse>(</p>
<p>        TMessage message,</p>
<p>        CancellationToken cancellationToken = default</p>
<p>    ) where TMessage : notnull;</p>

<p>    // Pattern 3: Event broadcasting (fire-and-forget)</p>
<p>    Task PublishAsync<TMessage>(</p>
<p>        TMessage message,</p>
<p>        CancellationToken cancellationToken = default</p>
<p>    ) where TMessage : notnull;</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Pattern 1: SendAsync - Command Dispatch</h2>

<strong>Use Case</strong>: Send commands with delivery tracking, supports both local and remote dispatch.

<strong>Signature</strong>:
<pre><code class="language-csharp">Task<DeliveryReceipt> SendAsync<TMessage>(
<p>    TMessage message,</p>
<p>    CancellationToken cancellationToken = default</p>
<p>) where TMessage : notnull;</p>
<p></code></pre></p>

<strong>Returns</strong>: <code>DeliveryReceipt</code> containing message ID, correlation ID, and timestamp.

<h3>Basic Usage</h3>

<pre><code class="language-csharp">public class OrdersController : ControllerBase {
<p>    private readonly IDispatcher _dispatcher;</p>

<p>    public OrdersController(IDispatcher dispatcher) {</p>
<p>        _dispatcher = dispatcher;</p>
<p>    }</p>

<p>    [HttpPost]</p>
<p>    public async Task<ActionResult> CreateOrder(</p>
<p>        [FromBody] CreateOrderRequest request,</p>
<p>        CancellationToken ct) {</p>

<p>        var command = new CreateOrder(</p>
<p>            CustomerId: request.CustomerId,</p>
<p>            Items: request.Items</p>
<p>        );</p>

<p>        // Send command, get delivery receipt</p>
<p>        var receipt = await _dispatcher.SendAsync(command, ct);</p>

<p>        return Accepted(new {</p>
<p>            messageId = receipt.MessageId,</p>
<p>            correlationId = receipt.CorrelationId,</p>
<p>            timestamp = receipt.Timestamp</p>
<p>        });</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>DeliveryReceipt Structure</h3>

<pre><code class="language-csharp">public record DeliveryReceipt(
<p>    Guid MessageId,        // Unique ID for this message</p>
<p>    Guid CorrelationId,    // ID for tracking related messages</p>
<p>    DateTimeOffset Timestamp</p>
<p>);</p>
<p></code></pre></p>

<strong>Use cases</strong>:
<ul><li>Long-running operations where you track completion separately</li>
<li>Commands that may be processed asynchronously</li>
<li>Remote command dispatch via transport (Azure Service Bus, etc.)</li>
<li>Idempotency tracking (store receipt, check for duplicates)</li>
</ul>
<h3>SendAsync Flow</h3>

<pre><code class="language-">Client
<p>  ├─> dispatcher.SendAsync(command)</p>
<p>  ├─> Envelope created (MessageId, CorrelationId)</p>
<p>  ├─> Receptor invoked locally</p>
<p>  ├─> Event stored in Outbox</p>
<p>  └─> DeliveryReceipt returned</p>

<p>Background Worker</p>
<p>  ├─> Polls Outbox</p>
<p>  ├─> Publishes event to transport (Azure Service Bus)</p>
<p>  └─> Marks message as Published</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li><strong>Asynchronous semantics</strong>: Receipt doesn't mean message is processed, just accepted</li>
<li><strong>Outbox integration</strong>: Event stored for reliable delivery</li>
<li><strong>Idempotency</strong>: Use <code>MessageId</code> to detect duplicates</li>
</ul>
<h3>Example: Long-Running Order Processing</h3>

<pre><code class="language-csharp">[HttpPost("orders")]
<p>public async Task<ActionResult> CreateOrder(</p>
<p>    [FromBody] CreateOrderRequest request,</p>
<p>    CancellationToken ct) {</p>

<p>    var command = new CreateOrder(</p>
<p>        CustomerId: request.CustomerId,</p>
<p>        Items: request.Items</p>
<p>    );</p>

<p>    // Send command - returns immediately with receipt</p>
<p>    var receipt = await _dispatcher.SendAsync(command, ct);</p>

<p>    // Store receipt for later tracking</p>
<p>    await _trackingService.StoreReceiptAsync(</p>
<p>        receipt.MessageId,</p>
<p>        receipt.CorrelationId,</p>
<p>        "Order creation initiated"</p>
<p>    );</p>

<p>    // Return 202 Accepted with tracking URL</p>
<p>    return Accepted(new {</p>
<p>        trackingUrl = $"/api/orders/status/{receipt.CorrelationId}",</p>
<p>        messageId = receipt.MessageId</p>
<p>    });</p>
<p>}</p>

<p>[HttpGet("orders/status/{correlationId:guid}")]</p>
<p>public async Task<ActionResult> GetOrderStatus(Guid correlationId) {</p>
<p>    var status = await _trackingService.GetStatusAsync(correlationId);</p>
<p>    return Ok(status);</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Pattern 2: LocalInvokeAsync - In-Process RPC</h2>

<strong>Use Case</strong>: Fast, synchronous-style command/query execution with typed response.

<strong>Signature</strong>:
<pre><code class="language-csharp">Task<TResponse> LocalInvokeAsync<TMessage, TResponse>(
<p>    TMessage message,</p>
<p>    CancellationToken cancellationToken = default</p>
<p>) where TMessage : notnull;</p>
<p></code></pre></p>

<strong>Returns</strong>: Typed response from receptor (<code>TResponse</code>).

<strong>Performance</strong>: < 20ns dispatch overhead, zero allocations (with object pooling).

<h3>Basic Usage</h3>

<pre><code class="language-csharp">[HttpPost("orders")]
<p>public async Task<ActionResult<OrderCreated>> CreateOrder(</p>
<p>    [FromBody] CreateOrderRequest request,</p>
<p>    CancellationToken ct) {</p>

<p>    var command = new CreateOrder(</p>
<p>        CustomerId: request.CustomerId,</p>
<p>        Items: request.Items</p>
<p>    );</p>

<p>    // Invoke receptor, get typed response</p>
<p>    var result = await _dispatcher.LocalInvokeAsync<CreateOrder, OrderCreated>(</p>
<p>        command,</p>
<p>        ct</p>
<p>    );</p>

<p>    // Publish event to perspectives</p>
<p>    await _dispatcher.PublishAsync(result, ct);</p>

<p>    return CreatedAtAction(</p>
<p>        nameof(GetOrder),</p>
<p>        new { orderId = result.OrderId },</p>
<p>        result</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<h3>LocalInvokeAsync Flow</h3>

<pre><code class="language-">Client
<p>  ├─> dispatcher.LocalInvokeAsync<CreateOrder, OrderCreated>(command)</p>
<p>  ├─> Lookup receptor in registry (compile-time, zero reflection)</p>
<p>  ├─> Invoke receptor.HandleAsync(command)</p>
<p>  ├─> Return typed response</p>
<p>  └─> < 20ns overhead (zero allocations)</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li><strong>Compile-time safety</strong>: Type mismatch = compiler error</li>
<li><strong>Zero reflection</strong>: Routing generated at compile time</li>
<li><strong>Synchronous semantics</strong>: Waits for receptor to complete</li>
<li><strong>Local only</strong>: Cannot cross process boundaries</li>
<li><strong>Performance</strong>: Optimal for in-process commands/queries</li>
</ul>
<h3>Example: Query with Typed Response</h3>

<pre><code class="language-csharp">public record GetOrderQuery(Guid OrderId);

<p>public record OrderDetails(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    OrderLineItem[] Items,</p>
<p>    decimal Total,</p>
<p>    string Status</p>
<p>);</p>

<p>public class GetOrderReceptor : IReceptor<GetOrderQuery, OrderDetails> {</p>
<p>    private readonly IOrderLens _lens;</p>

<p>    public GetOrderReceptor(IOrderLens lens) {</p>
<p>        _lens = lens;</p>
<p>    }</p>

<p>    public async ValueTask<OrderDetails> HandleAsync(</p>
<p>        GetOrderQuery query,</p>
<p>        CancellationToken ct = default) {</p>

<p>        var order = await _lens.GetOrderAsync(query.OrderId, ct);</p>

<p>        if (order is null) {</p>
<p>            throw new NotFoundException($"Order {query.OrderId} not found");</p>
<p>        }</p>

<p>        return new OrderDetails(</p>
<p>            OrderId: order.OrderId,</p>
<p>            CustomerId: order.CustomerId,</p>
<p>            Items: order.Items,</p>
<p>            Total: order.Total,</p>
<p>            Status: order.Status</p>
<p>        );</p>
<p>    }</p>
<p>}</p>

<p>// Controller usage</p>
<p>[HttpGet("orders/{orderId:guid}")]</p>
<p>public async Task<ActionResult<OrderDetails>> GetOrder(</p>
<p>    Guid orderId,</p>
<p>    CancellationToken ct) {</p>

<p>    var query = new GetOrderQuery(orderId);</p>

<p>    try {</p>
<p>        var details = await _dispatcher.LocalInvokeAsync<GetOrderQuery, OrderDetails>(</p>
<p>            query,</p>
<p>            ct</p>
<p>        );</p>

<p>        return Ok(details);</p>
<p>    } catch (NotFoundException ex) {</p>
<p>        return NotFound(new { error = ex.Message });</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Type Safety Enforcement</h3>

<pre><code class="language-csharp">// ✅ CORRECT - Type mismatch caught at compile time
<p>var result = await _dispatcher.LocalInvokeAsync<CreateOrder, OrderCreated>(command);</p>

<p>// ❌ COMPILER ERROR - Type mismatch</p>
<p>var wrong = await _dispatcher.LocalInvokeAsync<CreateOrder, PaymentProcessed>(command);</p>
<p>// Error: No receptor registered for CreateOrder → PaymentProcessed</p>
<p></code></pre></p>

<h3>Synchronous Receptor Invocation</h3>

<p>:::new</p>
<code>LocalInvokeAsync</code> supports both async (<code>IReceptor</code>) and sync (<code>ISyncReceptor</code>) receptors transparently:
<p>:::</p>

<pre><code class="language-csharp">// Async receptor - uses HandleAsync, returns ValueTask
<p>public class AsyncOrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken ct = default) {</p>
<p>        // Can use await</p>
<p>        await Task.Delay(1);</p>
<p>        return new OrderCreated(message.OrderId);</p>
<p>    }</p>
<p>}</p>

<p>// Sync receptor - uses Handle, returns directly</p>
<p>public class SyncOrderReceptor : ISyncReceptor<CreateOrder, OrderCreated> {</p>
<p>    public OrderCreated Handle(CreateOrder message) {</p>
<p>        // Pure computation, no await</p>
<p>        return new OrderCreated(message.OrderId);</p>
<p>    }</p>
<p>}</p>

<p>// Both invoked the same way</p>
<p>var result = await _dispatcher.LocalInvokeAsync<CreateOrder, OrderCreated>(command);</p>
<p></code></pre></p>

<strong>How it works</strong>:
<ul><li>Dispatcher first checks for async <code>IReceptor<TMessage, TResponse></code></li>
<li>If not found, checks for sync <code>ISyncReceptor<TMessage, TResponse></code></li>
<li>Sync receptors are invoked directly, result wrapped in pre-completed <code>ValueTask</code></li>
<li>Auto-cascade works identically for both sync and async receptors</li>
</ul>
<strong>Performance benefit</strong>: Sync receptors avoid async state machine overhead entirely. The returned <code>ValueTask</code> is pre-completed, resulting in zero allocations.

<pre><code class="language-">Async Receptor Flow:
<p>  LocalInvokeAsync → HandleAsync() → ValueTask (may allocate Task)</p>

<p>Sync Receptor Flow:</p>
<p>  LocalInvokeAsync → Handle() → new ValueTask(result) (pre-completed, zero alloc)</p>
<p></code></pre></p>

<strong>Precedence</strong>: If both <code>IReceptor</code> and <code>ISyncReceptor</code> exist for the same message type, the async <code>IReceptor</code> takes precedence to avoid breaking existing behavior.

<p>See <a href="receptors.md#isyncreceptor-interface">Receptors: ISyncReceptor Interface</a> for when to use sync vs async receptors.</p>

<h3>Performance Optimization</h3>

<p>LocalInvokeAsync achieves < 20ns overhead through:</p>

<ul><li><strong>Compile-time routing</strong>: Source generators create direct method calls</li>
<li><strong>Value types</strong>: Envelope and hops use structs where possible</li>
<li><strong>Object pooling</strong>: Reuse envelope instances</li>
<li><strong>Zero reflection</strong>: No runtime type discovery</li>
</ul>
<strong>Generated code example</strong>:
<pre><code class="language-csharp">// Generated by Whizbang.Generators
<p>protected override ReceptorInvoker<TResult>? GetReceptorInvoker<TResult>(</p>
<p>    object message,</p>
<p>    Type messageType) {</p>

<p>    // Direct type check, no reflection</p>
<p>    if (messageType == typeof(CreateOrder)) {</p>
<p>        var receptor = _serviceProvider.GetRequiredService<IReceptor<CreateOrder, OrderCreated>>();</p>
<p>        return async msg => (TResult)(object)await receptor.HandleAsync((CreateOrder)msg);</p>
<p>    }</p>

<p>    // ... other message types</p>

<p>    return null;</p>
<p>}</p>

<p>// Sync receptor routing (fallback if no async receptor)</p>
<p>protected override SyncReceptorInvoker<TResult>? GetSyncReceptorInvoker<TResult>(</p>
<p>    object message,</p>
<p>    Type messageType) {</p>

<p>    if (messageType == typeof(CreateOrder)) {</p>
<p>        var receptor = _serviceProvider.GetService<ISyncReceptor<CreateOrder, OrderCreated>>();</p>
<p>        if (receptor == null) return null;</p>
<p>        return msg => (TResult)(object)receptor.Handle((CreateOrder)msg)!;</p>
<p>    }</p>

<p>    return null;</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Pattern 3: PublishAsync - Event Broadcasting</h2>

<strong>Use Case</strong>: Broadcast events to multiple listeners (perspectives).

<strong>Signature</strong>:
<pre><code class="language-csharp">Task PublishAsync<TMessage>(
<p>    TMessage message,</p>
<p>    CancellationToken cancellationToken = default</p>
<p>) where TMessage : notnull;</p>
<p></code></pre></p>

<strong>Returns</strong>: <code>Task</code> (no return value, fire-and-forget).

<h3>Basic Usage</h3>

<pre><code class="language-csharp">[HttpPost("orders")]
<p>public async Task<ActionResult<OrderCreated>> CreateOrder(</p>
<p>    [FromBody] CreateOrderRequest request,</p>
<p>    CancellationToken ct) {</p>

<p>    var command = new CreateOrder(</p>
<p>        CustomerId: request.CustomerId,</p>
<p>        Items: request.Items</p>
<p>    );</p>

<p>    // 1. Execute command</p>
<p>    var result = await _dispatcher.LocalInvokeAsync<CreateOrder, OrderCreated>(</p>
<p>        command,</p>
<p>        ct</p>
<p>    );</p>

<p>    // 2. Publish event to all perspectives</p>
<p>    await _dispatcher.PublishAsync(result, ct);</p>

<p>    return CreatedAtAction(nameof(GetOrder), new { orderId = result.OrderId }, result);</p>
<p>}</p>
<p></code></pre></p>

<h3>PublishAsync Flow</h3>

<pre><code class="language-">Client
<p>  ├─> dispatcher.PublishAsync(event)</p>
<p>  ├─> Find all perspectives for event type</p>
<p>  ├─> Invoke each perspective.UpdateAsync(event)</p>
<p>  │   ├─> OrderSummaryPerspective.UpdateAsync(OrderCreated)</p>
<p>  │   ├─> InventoryPerspective.UpdateAsync(OrderCreated)</p>
<p>  │   └─> AnalyticsPerspective.UpdateAsync(OrderCreated)</p>
<p>  └─> All perspectives updated (parallel execution)</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li><strong>Multiple listeners</strong>: One event triggers multiple perspectives</li>
<li><strong>Fire-and-forget</strong>: Doesn't wait for perspectives to complete (async)</li>
<li><strong>Local broadcast</strong>: All perspectives in current process</li>
<li><strong>Outbox integration</strong>: Event can be stored for remote publishing</li>
</ul>
<h3>Example: Multiple Perspectives</h3>

<pre><code class="language-csharp">// Event
<p>public record OrderCreated(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    OrderLineItem[] Items,</p>
<p>    decimal Total,</p>
<p>    DateTimeOffset CreatedAt</p>
<p>);</p>

<p>// Perspective 1: Order summary for UI</p>
<p>public class OrderSummaryPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>        await using var conn = _db.CreateConnection();</p>
<p>        await conn.ExecuteAsync(</p>
<p>            "INSERT INTO order_summaries (order_id, customer_id, total, status, created_at) VALUES (@OrderId, @CustomerId, @Total, @Status, @CreatedAt)",</p>
<p>            new {</p>
<p>                @event.OrderId,</p>
<p>                @event.CustomerId,</p>
<p>                @event.Total,</p>
<p>                Status = "Created",</p>
<p>                @event.CreatedAt</p>
<p>            }</p>
<p>        );</p>
<p>    }</p>
<p>}</p>

<p>// Perspective 2: Analytics/reporting</p>
<p>public class OrderAnalyticsPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>        await using var conn = _db.CreateConnection();</p>
<p>        await conn.ExecuteAsync(</p>
<p>            "INSERT INTO order_analytics (order_id, customer_id, total, created_at) VALUES (@OrderId, @CustomerId, @Total, @CreatedAt)",</p>
<p>            new {</p>
<p>                @event.OrderId,</p>
<p>                @event.CustomerId,</p>
<p>                @event.Total,</p>
<p>                @event.CreatedAt</p>
<p>            }</p>
<p>        );</p>
<p>    }</p>
<p>}</p>

<p>// Perspective 3: Notification system</p>
<p>public class NotificationPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>    private readonly IEmailService _email;</p>

<p>    public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>        await _email.SendAsync(</p>
<p>            to: await GetCustomerEmailAsync(@event.CustomerId),</p>
<p>            subject: "Order Confirmed",</p>
<p>            body: $"Your order {@event.OrderId} has been created. Total: {@event.Total:C}"</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<p>When you call <code>PublishAsync(orderCreated)</code>, <strong>all three perspectives</strong> are invoked automatically.</p>

<h3>Remote Publishing with Outbox</h3>

<pre><code class="language-csharp">// In receptor - store event in outbox for remote publishing
<p>public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    private readonly IWorkCoordinator _coordinator;</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        // Business logic...</p>
<p>        var @event = new OrderCreated(/<em> ... </em>/);</p>

<p>        // Store in outbox for reliable publishing</p>
<p>        await _coordinator.ProcessWorkBatchAsync(</p>
<p>            instanceId: Guid.NewGuid(),</p>
<p>            serviceName: "OrderService",</p>
<p>            hostName: Environment.MachineName,</p>
<p>            processId: Environment.ProcessId,</p>
<p>            metadata: null,</p>
<p>            outboxCompletions: [],</p>
<p>            outboxFailures: [],</p>
<p>            inboxCompletions: [],</p>
<p>            inboxFailures: [],</p>
<p>            receptorCompletions: [],</p>
<p>            receptorFailures: [],</p>
<p>            perspectiveCompletions: [],</p>
<p>            perspectiveFailures: [],</p>
<p>            newOutboxMessages: [</p>
<p>                new OutboxMessage(</p>
<p>                    MessageId: Guid.CreateVersion7(),</p>
<p>                    MessageType: typeof(OrderCreated).FullName!,</p>
<p>                    Payload: JsonSerializer.Serialize(@event),</p>
<p>                    CorrelationId: GetCorrelationId(),</p>
<p>                    Topic: "orders",</p>
<p>                    PartitionKey: @event.CustomerId.ToString()</p>
<p>                )</p>
<p>            ],</p>
<p>            newInboxMessages: [],</p>
<p>            renewOutboxLeaseIds: [],</p>
<p>            renewInboxLeaseIds: [],</p>
<p>            flags: WorkBatchFlags.None,</p>
<p>            ct: ct</p>
<p>        );</p>

<p>        return @event;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>AppendAsync vs PublishAsync vs SendAsync</h2>

<p>:::new{type="important"}</p>
<p>Understanding when to use <code>IEventStore.AppendAsync</code> versus <code>IDispatcher.PublishAsync</code> is critical. Using both together is usually <strong>redundant</strong>.</p>
<p>:::</p>

<h3>Key Differences</h3>

<p>| Method | Responsibility | Triggers Perspectives | Uses Outbox | Return |</p>
<p>|--------|---------------|----------------------|-------------|--------|</p>
<p>| <code>IEventStore.AppendAsync</code> | Persist event to event store | No | No | <code>void</code> |</p>
<p>| <code>IDispatcher.PublishAsync</code> | Broadcast event | Yes (local) | Yes (remote) | <code>void</code> |</p>
<p>| <code>IDispatcher.SendAsync</code> | Route command | No | Yes | <code>DeliveryReceipt</code> |</p>

<h3>Correct Patterns</h3>

<strong>For Events (most common case):</strong>

<pre><code class="language-csharp">// ✅ CORRECT: Just publish - handles perspectives + outbox
<p>public async ValueTask<OrderCreated> HandleAsync(</p>
<p>    CreateOrder command,</p>
<p>    CancellationToken ct) {</p>

<p>    var @event = new OrderCreated(command.OrderId, command.Items);</p>

<p>    // PublishAsync triggers local perspectives AND queues for remote delivery</p>
<p>    await _dispatcher.PublishAsync(@event, ct);</p>

<p>    return @event;</p>
<p>}</p>
<p></code></pre></p>

<strong>For Commands:</strong>

<pre><code class="language-csharp">// ✅ CORRECT: Send command with delivery tracking
<p>await _dispatcher.SendAsync(new ProcessPayment(orderId, amount), ct);</p>
<p></code></pre></p>

<strong>For Direct Event Store Access (rare - infrastructure/workers only):</strong>

<pre><code class="language-csharp">// ✅ CORRECT: When you need explicit transactional control
<p>await using var work = await _workCoordinator.BeginAsync(ct);</p>
<p>await _eventStore.AppendAsync(streamId, @event, ct);</p>
<p>await work.CommitAsync(ct);</p>
<p></code></pre></p>

<h3>Anti-Patterns to Avoid</h3>

<pre><code class="language-csharp">// ❌ WRONG: Redundant - calling both AppendAsync and PublishAsync
<p>await _eventStore.AppendAsync(orderId, @event, ct);</p>
<p>await _dispatcher.PublishAsync(@event, ct);</p>
<p>// PublishAsync already handles persistence + perspectives + outbox!</p>
<p></code></pre></p>

<h3>When to Use Each</h3>

<p>| Scenario | Use |</p>
<p>|----------|-----|</p>
<p>| Publishing an event from a receptor | <code>PublishAsync</code> |</p>
<p>| Sending a command to another service | <code>SendAsync</code> |</p>
<p>| In-process query with typed response | <code>LocalInvokeAsync</code> |</p>
<p>| Background worker with explicit transaction control | <code>AppendAsync</code> + <code>IWorkCoordinator</code> |</p>
<p>| Event replay/migration scripts | <code>AppendAsync</code> |</p>

<hr>

<h2>Decision Matrix</h2>

<h3>When to Use Each Pattern</h3>

<p>| Scenario | Pattern | Reason |</p>
<p>|----------|---------|--------|</p>
<p>| <strong>Create order (synchronous response needed)</strong> | <code>LocalInvokeAsync</code> | Need typed <code>OrderCreated</code> response immediately |</p>
<p>| <strong>Create order (async processing)</strong> | <code>SendAsync</code> | Return receipt, process in background |</p>
<p>| <strong>Query order details</strong> | <code>LocalInvokeAsync</code> | Need typed <code>OrderDetails</code> response |</p>
<p>| <strong>Update read models after command</strong> | <code>PublishAsync</code> | Broadcast event to perspectives |</p>
<p>| <strong>Send email notification</strong> | <code>PublishAsync</code> | Fire-and-forget to notification perspective |</p>
<p>| <strong>Remote command (cross-service)</strong> | <code>SendAsync</code> | Delivery tracking, supports transport |</p>
<p>| <strong>In-process RPC-style call</strong> | <code>LocalInvokeAsync</code> | Fastest, type-safe |</p>

<h3>Pattern Comparison</h3>

<pre><code class="language-csharp">// Scenario: Create an order

<p>// Option 1: SendAsync (async semantics, delivery tracking)</p>
<p>var receipt = await _dispatcher.SendAsync(command);</p>
<p>// Returns: DeliveryReceipt { MessageId, CorrelationId, Timestamp }</p>
<p>// Use: When you need to track delivery or process asynchronously</p>

<p>// Option 2: LocalInvokeAsync (sync semantics, typed response)</p>
<p>var result = await _dispatcher.LocalInvokeAsync<CreateOrder, OrderCreated>(command);</p>
<p>// Returns: OrderCreated { OrderId, CustomerId, Total, ... }</p>
<p>// Use: When you need the result immediately (< 20ns overhead)</p>

<p>// Option 3: PublishAsync (broadcast to listeners)</p>
<p>await _dispatcher.PublishAsync(orderCreated);</p>
<p>// Returns: void</p>
<p>// Use: After command completes, update all perspectives</p>
<p></code></pre></p>

<hr>

<h2>Error Handling</h2>

<h3>LocalInvokeAsync Error Handling</h3>

<pre><code class="language-csharp">[HttpPost("orders")]
<p>public async Task<ActionResult> CreateOrder(</p>
<p>    [FromBody] CreateOrderRequest request,</p>
<p>    CancellationToken ct) {</p>

<p>    try {</p>
<p>        var command = new CreateOrder(request.CustomerId, request.Items);</p>

<p>        var result = await _dispatcher.LocalInvokeAsync<CreateOrder, OrderCreated>(</p>
<p>            command,</p>
<p>            ct</p>
<p>        );</p>

<p>        await _dispatcher.PublishAsync(result, ct);</p>

<p>        return CreatedAtAction(nameof(GetOrder), new { orderId = result.OrderId }, result);</p>

<p>    } catch (ValidationException ex) {</p>
<p>        // Business rule violation (e.g., invalid quantity)</p>
<p>        return BadRequest(new { error = ex.Message, errors = ex.ValidationErrors });</p>

<p>    } catch (NotFoundException ex) {</p>
<p>        // Entity not found (e.g., customer doesn't exist)</p>
<p>        return NotFound(new { error = ex.Message });</p>

<p>    } catch (InvalidOperationException ex) {</p>
<p>        // Business logic error (e.g., insufficient inventory)</p>
<p>        return Conflict(new { error = ex.Message });</p>

<p>    } catch (OperationCanceledException) {</p>
<p>        // Client cancelled request</p>
<p>        return StatusCode(499, new { error = "Request cancelled" });</p>

<p>    } catch (Exception ex) {</p>
<p>        // Unexpected error</p>
<p>        _logger.LogError(ex, "Failed to create order");</p>
<p>        return StatusCode(500, new { error: "An unexpected error occurred" });</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>SendAsync Error Handling</h3>

<pre><code class="language-csharp">try {
<p>    var receipt = await _dispatcher.SendAsync(command, ct);</p>

<p>    // Store receipt for tracking</p>
<p>    await _trackingService.StoreAsync(receipt);</p>

<p>    return Accepted(new { trackingId = receipt.CorrelationId });</p>

<p>} catch (Exception ex) {</p>
<p>    // SendAsync errors typically indicate infrastructure issues</p>
<p>    _logger.LogError(ex, "Failed to dispatch command");</p>
<p>    return StatusCode(503, new { error = "Service temporarily unavailable" });</p>
<p>}</p>
<p></code></pre></p>

<h3>PublishAsync Error Handling</h3>

<pre><code class="language-csharp">try {
<p>    await _dispatcher.PublishAsync(orderCreated, ct);</p>

<p>} catch (AggregateException ex) {</p>
<p>    // One or more perspectives failed</p>
<p>    foreach (var inner in ex.InnerExceptions) {</p>
<p>        _logger.LogError(inner, "Perspective update failed");</p>
<p>    }</p>

<p>    // Decide: fail request or continue?</p>
<p>    // Option 1: Fail entire request</p>
<p>    throw;</p>

<p>    // Option 2: Log and continue (eventual consistency)</p>
<p>    // Perspectives will catch up via event replay</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Advanced Patterns</h2>

<h3>Pattern: Command + Event in Single Transaction</h3>

<pre><code class="language-csharp">[HttpPost("orders")]
<p>public async Task<ActionResult<OrderCreated>> CreateOrder(</p>
<p>    [FromBody] CreateOrderRequest request,</p>
<p>    CancellationToken ct) {</p>

<p>    var command = new CreateOrder(request.CustomerId, request.Items);</p>

<p>    // Execute command</p>
<p>    var result = await _dispatcher.LocalInvokeAsync<CreateOrder, OrderCreated>(</p>
<p>        command,</p>
<p>        ct</p>
<p>    );</p>

<p>    // Publish event to local perspectives</p>
<p>    await _dispatcher.PublishAsync(result, ct);</p>

<p>    // Also send via SendAsync for outbox (remote publishing)</p>
<p>    await _dispatcher.SendAsync(result, ct);</p>

<p>    return CreatedAtAction(nameof(GetOrder), new { orderId = result.OrderId }, result);</p>
<p>}</p>
<p></code></pre></p>

<strong>Result</strong>:
<ul><li>Local perspectives updated immediately</li>
<li>Event stored in outbox for remote publishing</li>
<li>Background worker publishes to Azure Service Bus</li>
</ul>
<h3>Pattern: Conditional Publishing</h3>

<pre><code class="language-csharp">public async Task<ActionResult> ProcessPayment(
<p>    [FromBody] ProcessPaymentRequest request,</p>
<p>    CancellationToken ct) {</p>

<p>    var command = new ProcessPayment(request.OrderId, request.Amount);</p>

<p>    var result = await _dispatcher.LocalInvokeAsync<ProcessPayment, PaymentResult>(</p>
<p>        command,</p>
<p>        ct</p>
<p>    );</p>

<p>    // Publish different events based on result</p>
<p>    if (result.IsSuccess) {</p>
<p>        await _dispatcher.PublishAsync(</p>
<p>            new PaymentProcessed(result.OrderId, result.Amount, result.TransactionId),</p>
<p>            ct</p>
<p>        );</p>
<p>    } else {</p>
<p>        await _dispatcher.PublishAsync(</p>
<p>            new PaymentFailed(result.OrderId, result.Amount, result.ErrorCode),</p>
<p>            ct</p>
<p>        );</p>
<p>    }</p>

<p>    return Ok(result);</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern: Batch Processing</h3>

<pre><code class="language-csharp">public async Task<ActionResult> ProcessOrders(
<p>    [FromBody] ProcessOrdersRequest request,</p>
<p>    CancellationToken ct) {</p>

<p>    var results = new List<OrderCreated>();</p>

<p>    foreach (var item in request.Orders) {</p>
<p>        var command = new CreateOrder(item.CustomerId, item.Items);</p>

<p>        var result = await _dispatcher.LocalInvokeAsync<CreateOrder, OrderCreated>(</p>
<p>            command,</p>
<p>            ct</p>
<p>        );</p>

<p>        results.Add(result);</p>
<p>    }</p>

<p>    // Publish all events in batch</p>
<p>    foreach (var result in results) {</p>
<p>        await _dispatcher.PublishAsync(result, ct);</p>
<p>    }</p>

<p>    return Ok(new { ordersCreated = results.Count, orders = results });</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Automatic Message Cascade</h2>

<p>Whizbang automatically extracts and dispatches <code>IMessage</code> instances (both <code>IEvent</code> and <code>ICommand</code>) from receptor return values. This enables a cleaner pattern where receptors can return tuples or arrays containing messages without explicit <code>PublishAsync</code> or <code>SendAsync</code> calls.</p>

<h3>The Problem (Without Auto-Cascade)</h3>

<pre><code class="language-csharp">// ❌ VERBOSE: Explicit PublishAsync required
<p>public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    private readonly IDispatcher _dispatcher;</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder command,</p>
<p>        CancellationToken ct = default) {</p>

<p>        // Business logic...</p>
<p>        var @event = new OrderCreated(command.OrderId, command.CustomerId);</p>

<p>        // Manual publishing required</p>
<p>        await _dispatcher.PublishAsync(@event, ct);</p>

<p>        return @event;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>The Solution (With Auto-Cascade)</h3>

<pre><code class="language-csharp">// ✅ CLEAN: Framework auto-publishes events from return value
<p>public class CreateOrderReceptor : IReceptor<CreateOrder, (OrderResult, OrderCreated)> {</p>

<p>    public ValueTask<(OrderResult, OrderCreated)> HandleAsync(</p>
<p>        CreateOrder command,</p>
<p>        CancellationToken ct = default) {</p>

<p>        var result = new OrderResult(command.OrderId);</p>
<p>        var @event = new OrderCreated(command.OrderId, command.CustomerId);</p>

<p>        // Return tuple - framework automatically publishes OrderCreated</p>
<p>        return ValueTask.FromResult((result, @event));</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>What happens</strong>:
<ul><li>Receptor returns <code>(OrderResult, OrderCreated)</code> tuple</li>
<li>Dispatcher extracts <code>OrderCreated</code> (implements <code>IEvent</code>)</li>
<li>Dispatcher automatically publishes <code>OrderCreated</code> to all perspectives</li>
<li>Caller receives the full tuple result</li>
</ul>
<h3>Supported Return Types</h3>

<p>The auto-cascade feature supports several return patterns:</p>

<strong>Tuple with Event</strong>:
<pre><code class="language-csharp">public class OrderReceptor : IReceptor<CreateOrder, (OrderResult, OrderCreated)> {
<p>    public ValueTask<(OrderResult, OrderCreated)> HandleAsync(</p>
<p>        CreateOrder command, CancellationToken ct = default) {</p>

<p>        return ValueTask.FromResult((</p>
<p>            new OrderResult(command.OrderId),</p>
<p>            new OrderCreated(command.OrderId, command.CustomerId)</p>
<p>        ));</p>
<p>    }</p>
<p>}</p>
<p>// Result: OrderCreated auto-published</p>
<p></code></pre></p>

<strong>Tuple with Multiple Events</strong>:
<pre><code class="language-csharp">public class ShipOrderReceptor : IReceptor<ShipOrder, (ShipResult, OrderShipped, InventoryUpdated)> {
<p>    public ValueTask<(ShipResult, OrderShipped, InventoryUpdated)> HandleAsync(</p>
<p>        ShipOrder command, CancellationToken ct = default) {</p>

<p>        return ValueTask.FromResult((</p>
<p>            new ShipResult(command.OrderId),</p>
<p>            new OrderShipped(command.OrderId),</p>
<p>            new InventoryUpdated(command.ProductId, -command.Quantity)</p>
<p>        ));</p>
<p>    }</p>
<p>}</p>
<p>// Result: Both OrderShipped and InventoryUpdated auto-published</p>
<p></code></pre></p>

<strong>Array of Events</strong>:
<pre><code class="language-csharp">public class NotifyReceptor : IReceptor<SendNotifications, IEvent[]> {
<p>    public ValueTask<IEvent[]> HandleAsync(</p>
<p>        SendNotifications command, CancellationToken ct = default) {</p>

<p>        var events = new List<IEvent> {</p>
<p>            new EmailSent(command.CustomerId)</p>
<p>        };</p>

<p>        if (command.Amount >= 1000m) {</p>
<p>            events.Add(new HighValueAlert(command.OrderId));</p>
<p>        }</p>

<p>        return ValueTask.FromResult(events.ToArray());</p>
<p>    }</p>
<p>}</p>
<p>// Result: All events in array auto-published</p>
<p></code></pre></p>

<strong>Nested Tuples</strong>:
<pre><code class="language-csharp">public class ComplexReceptor : IReceptor<ComplexCommand, (Result, (Event1, Event2))> {
<p>    public ValueTask<(Result, (Event1, Event2))> HandleAsync(</p>
<p>        ComplexCommand command, CancellationToken ct = default) {</p>

<p>        return ValueTask.FromResult((</p>
<p>            new Result(command.Id),</p>
<p>            (new Event1(command.Id), new Event2(command.Id))</p>
<p>        ));</p>
<p>    }</p>
<p>}</p>
<p>// Result: Both Event1 and Event2 auto-published (recursive extraction)</p>
<p></code></pre></p>

<h3>How It Works</h3>

<p>The auto-cascade system uses the <code>ITuple</code> interface for efficient, AOT-compatible message extraction:</p>

<pre><code class="language-">Receptor Returns
<p>  ├─> Dispatcher receives result</p>
<p>  ├─> MessageExtractor.ExtractMessages(result)</p>
<p>  │   ├─> Checks if result implements IMessage (IEvent or ICommand) → yield return</p>
<p>  │   ├─> Checks if result implements ITuple → extract each item recursively</p>
<p>  │   ├─> Checks if result implements IEnumerable<IMessage> → yield return each</p>
<p>  │   ├─> Checks if result implements IEnumerable<IEvent> → yield return each</p>
<p>  │   └─> Checks if result implements IEnumerable<ICommand> → yield return each</p>
<p>  └─> For each extracted IMessage:</p>
<p>      └─> GetUntypedReceptorPublisher(messageType).Invoke(message)</p>
<p>          └─> All receptors for that message type invoked</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li><strong>Zero reflection</strong>: Uses <code>ITuple</code> interface (compile-time type info)</li>
<li><strong>AOT compatible</strong>: Works with Native AOT and trimming</li>
<li><strong>Recursive</strong>: Handles nested tuples and arrays</li>
<li><strong>Selective</strong>: Only extracts types implementing <code>IMessage</code> (events AND commands)</li>
<li><strong>Non-messages ignored</strong>: DTOs and value objects pass through unchanged</li>
</ul>
<h3>Cascades Through All Dispatch Paths</h3>

<p>Auto-cascade works with all dispatch methods and message types:</p>

<pre><code class="language-csharp">// Via LocalInvokeAsync - Events auto-published
<p>var result = await _dispatcher.LocalInvokeAsync<CreateOrder, (OrderResult, OrderCreated)>(command);</p>
<p>// OrderCreated auto-published ✓</p>

<p>// Via LocalInvokeAsync - Commands auto-dispatched</p>
<p>var result = await _dispatcher.LocalInvokeAsync<ProcessPayment, (PaymentResult, SendNotification)>(command);</p>
<p>// SendNotification command auto-dispatched ✓</p>

<p>// Via SendAsync</p>
<p>var receipt = await _dispatcher.SendAsync(command);</p>
<p>// Any returned IEvent or ICommand auto-cascaded ✓</p>
<p></code></pre></p>

<h3>Mixed Events and Commands</h3>

<p>Receptors can return both events and commands in a single tuple:</p>

<pre><code class="language-csharp">public class ProcessOrderReceptor : IReceptor<ProcessOrder, (OrderResult, OrderProcessed, SendInvoice)> {
<p>    public ValueTask<(OrderResult, OrderProcessed, SendInvoice)> HandleAsync(</p>
<p>        ProcessOrder command, CancellationToken ct = default) {</p>

<p>        var result = new OrderResult(command.OrderId, ProcessStatus.Completed);</p>
<p>        var orderEvent = new OrderProcessed(command.OrderId, DateTime.UtcNow);</p>
<p>        var invoiceCommand = new SendInvoice(command.OrderId, command.CustomerId);</p>

<p>        // Return tuple with both event AND command</p>
<p>        return ValueTask.FromResult((result, orderEvent, invoiceCommand));</p>
<p>    }</p>
<p>}</p>
<p>// Result: OrderProcessed event published to perspectives</p>
<p>// Result: SendInvoice command dispatched to invoice receptor</p>
<p></code></pre></p>

<h3>Best Practices</h3>

<strong>DO</strong>: Return messages (events and commands) alongside business results in tuples
<pre><code class="language-csharp">// ✅ GOOD: Event returned with result
<p>public ValueTask<(OrderResult, OrderCreated)> HandleAsync(</p>
<p>    CreateOrder command, CancellationToken ct) {</p>
<p>    return ValueTask.FromResult((</p>
<p>        new OrderResult(command.OrderId),</p>
<p>        new OrderCreated(command.OrderId, command.CustomerId)</p>
<p>    ));</p>
<p>}</p>

<p>// ✅ GOOD: Command returned triggers follow-up action</p>
<p>public ValueTask<(PaymentResult, SendReceipt)> HandleAsync(</p>
<p>    ProcessPayment command, CancellationToken ct) {</p>
<p>    return ValueTask.FromResult((</p>
<p>        new PaymentResult(command.OrderId, PaymentStatus.Success),</p>
<p>        new SendReceipt(command.OrderId, command.CustomerId)  // Command auto-dispatched</p>
<p>    ));</p>
<p>}</p>
<p></code></pre></p>

<strong>DON'T</strong>: Return messages AND manually dispatch them
<pre><code class="language-csharp">// ❌ BAD: Double publishing!
<p>public async ValueTask<(OrderResult, OrderCreated)> HandleAsync(</p>
<p>    CreateOrder command, CancellationToken ct) {</p>

<p>    var @event = new OrderCreated(command.OrderId, command.CustomerId);</p>

<p>    // DON'T DO THIS - framework already auto-publishes from return value</p>
<p>    await _dispatcher.PublishAsync(@event, ct);</p>

<p>    return (new OrderResult(command.OrderId), @event);</p>
<p>}</p>
<p></code></pre></p>

<strong>DON'T</strong>: Return empty arrays to avoid cascade
<pre><code class="language-csharp">// ⚠️ UNNECESSARY: Empty arrays are handled gracefully
<p>public ValueTask<(OrderResult, IMessage[])> HandleAsync(</p>
<p>    CreateOrder command, CancellationToken ct) {</p>

<p>    return ValueTask.FromResult((</p>
<p>        new OrderResult(command.OrderId),</p>
<p>        Array.Empty<IMessage>()  // Fine - no messages dispatched</p>
<p>    ));</p>
<p>}</p>
<p></code></pre></p>

<h3>Auto-Cascade to Outbox {#auto-cascade-to-outbox}</h3>

<p>By default, cascaded events are dispatched to local receptors only. To cascade events to the outbox for cross-service delivery, use the <code>Route</code> wrapper:</p>

<strong>Route Wrappers</strong>: {#routed-message-cascading}
<pre><code class="language-csharp">// Cascade to local receptors AND persist to event store (default)
<p>return (result, new OrderCreated(orderId));</p>

<p>// Explicit local + event store (same as default)</p>
<p>return (result, Route.Local(new OrderCreated(orderId)));</p>

<p>// Cascade to local receptors only - NO persistence (ephemeral)</p>
<p>return (result, Route.LocalNoPersist(new OrderCreated(orderId)));</p>

<p>// Persist to event store only - NO local receptors (audit events)</p>
<p>return (result, Route.EventStoreOnly(new AuditEvent(userId, action)));</p>

<p>// Cascade to outbox only (cross-service)</p>
<p>return (result, Route.Outbox(new OrderCreated(orderId)));</p>

<p>// Cascade to both local and outbox</p>
<p>return (result, Route.Both(new OrderCreated(orderId)));</p>
<p></code></pre></p>

<p>:::new</p>
<strong>New</strong>: <code>Route.Local()</code> now includes automatic event store persistence. Events are stored to <code>wh_event_store</code> and perspective events are created. Use <code>Route.LocalNoPersist()</code> for the previous behavior (local receptors only, no persistence).
<p>:::</p>

<h3>Event Store Only Mode {#event-store-only}</h3>

<code>Route.EventStoreOnly()</code> persists events to the event store without invoking local receptors or sending via transport. This is useful for:

<ul><li><strong>Audit events</strong>: Record actions without triggering business logic</li>
<li><strong>Historical events</strong>: Import or replay events into the store</li>
<li><strong>Deferred processing</strong>: Store events for later perspective rebuilds</li>
</ul>
<pre><code class="language-csharp">public class AuditReceptor : IReceptor<ProcessOrder, (OrderResult, Routed<AuditEvent>)> {
<p>    public ValueTask<(OrderResult, Routed<AuditEvent>)> HandleAsync(</p>
<p>        ProcessOrder command, CancellationToken ct = default) {</p>

<p>        var result = new OrderResult(command.OrderId);</p>

<p>        // Audit event stored to event store only - no local receptors invoked</p>
<p>        var auditEvent = new AuditEvent(</p>
<p>            UserId: command.UserId,</p>
<p>            Action: "OrderProcessed",</p>
<p>            ResourceId: command.OrderId</p>
<p>        );</p>

<p>        return ValueTask.FromResult((result, Route.EventStoreOnly(auditEvent)));</p>
<p>    }</p>
<p>}</p>
<p>// Result: AuditEvent persisted to wh_event_store</p>
<p>// Result: Perspective events created for downstream projections</p>
<p>// Result: NO local receptors invoked</p>
<p>// Result: NO transport publishing (destination=null)</p>
<p></code></pre></p>

<strong>How It Works</strong>:
<ul><li>Event is written to <code>wh_outbox</code> with <code>destination=null</code></li>
<li><code>process_work_batch</code> stores event in <code>wh_event_store</code> and creates perspective events</li>
<li><code>TransportPublishStrategy</code> skips transport (null destination = bypass)</li>
<li>Event is marked as published (completed)</li>
</ul>
<strong>Example: Cross-Service Event Publishing</strong>:
<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrder, (OrderResult, Routed<OrderCreated>)> {
<p>    public ValueTask<(OrderResult, Routed<OrderCreated>)> HandleAsync(</p>
<p>        CreateOrder command, CancellationToken ct = default) {</p>

<p>        var result = new OrderResult(command.OrderId);</p>
<p>        var @event = new OrderCreated(command.OrderId, command.CustomerId);</p>

<p>        // Wrap with Route.Both() to cascade to local perspectives AND outbox</p>
<p>        return ValueTask.FromResult((result, Route.Both(@event)));</p>
<p>    }</p>
<p>}</p>
<p>// Result: OrderCreated published to local perspectives</p>
<p>// Result: OrderCreated queued in outbox for remote services</p>
<p></code></pre></p>

<strong>How It Works</strong>:
<ul><li>Receptor returns a <code>Routed<TEvent></code> wrapped event</li>
<li>Dispatcher extracts the event and its routing mode</li>
<li>For <code>DispatchMode.Local</code> or <code>DispatchMode.Both</code>: Publishes to local receptors</li>
<li>For <code>DispatchMode.Outbox</code> or <code>DispatchMode.Both</code>: Calls <code>CascadeToOutboxAsync</code></li>
<li>Generated dispatcher uses type-switch dispatch (zero reflection, AOT compatible)</li>
</ul>
<strong>Generated Code Pattern</strong>:
<pre><code class="language-csharp">// Generated by Whizbang.Generators
<p>protected override Task CascadeToOutboxAsync(IMessage message, Type messageType) {</p>
<p>    if (messageType == typeof(OrderCreated)) {</p>
<p>        return PublishToOutboxAsync((OrderCreated)message, messageType, MessageId.New());</p>
<p>    }</p>
<p>    if (messageType == typeof(PaymentProcessed)) {</p>
<p>        return PublishToOutboxAsync((PaymentProcessed)message, messageType, MessageId.New());</p>
<p>    }</p>
<p>    // ... other event types</p>
<p>    return Task.CompletedTask;</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li><strong>Zero reflection</strong>: Source generators create compile-time type-switch dispatch</li>
<li><strong>AOT compatible</strong>: Works with Native AOT and trimming</li>
<li><strong>Automatic</strong>: No manual <code>PublishAsync</code> or <code>SendAsync</code> calls needed</li>
<li><strong>Configurable</strong>: Per-event routing via <code>Route.Local()</code>, <code>Route.LocalNoPersist()</code>, <code>Route.EventStoreOnly()</code>, <code>Route.Outbox()</code>, <code>Route.Both()</code>, <code>Route.None()</code></li>
</ul>
<p>:::new</p>
<strong>New in 0.1.0</strong>: Auto-cascade to outbox enables automatic cross-service event publishing from receptor return values without explicit outbox writes.
<p>:::</p>

<p>:::new</p>
<strong>New</strong>: <code>Route.LocalNoPersist()</code> and <code>Route.EventStoreOnly()</code> provide fine-grained control over event persistence and local dispatch.
<p>:::</p>

<h3>Comparison: Manual vs Auto-Cascade</h3>

<p>| Approach | Lines of Code | Injection Dependencies | Error Surface |</p>
<p>|----------|--------------|----------------------|---------------|</p>
<p>| Manual <code>PublishAsync</code>/<code>SendAsync</code> | More | Requires <code>IDispatcher</code> | Higher (can forget) |</p>
<p>| Auto-cascade (tuple return) | Fewer | None | Lower (automatic) |</p>

<p>:::new</p>
<strong>New in 0.1.0</strong>: Auto-cascade now supports both <code>IEvent</code> and <code>ICommand</code> types. Commands returned from receptors are automatically dispatched to their respective receptors.
<p>:::</p>

<hr>

<h2>Performance Considerations</h2>

<h3>LocalInvokeAsync Benchmarks</h3>

<p>| Scenario | Overhead | Allocations |</p>
<p>|----------|----------|-------------|</p>
<p>| Direct method call | 0ns | 0 bytes |</p>
<p>| LocalInvokeAsync (cold) | 15-20ns | 0 bytes (pooled) |</p>
<p>| LocalInvokeAsync (warm) | < 10ns | 0 bytes |</p>
<p>| SendAsync | ~100μs | Minimal (envelope) |</p>
<p>| PublishAsync | ~50μs | Minimal |</p>

<strong>Tips</strong>:
<ul><li>Use <code>LocalInvokeAsync</code> for hot paths (< 20ns)</li>
<li>Use <code>SendAsync</code> for asynchronous commands (acceptable ~100μs)</li>
<li>Use <code>PublishAsync</code> for events (fire-and-forget)</li>
</ul>
<h3>Object Pooling</h3>

<p>Whizbang uses object pooling for message envelopes:</p>

<pre><code class="language-csharp">// Automatically pooled
<p>var envelope = MessageEnvelope.Create(message, correlationId, causationId);</p>

<p>// After dispatch, envelope is returned to pool</p>
<p>// Next dispatch reuses pooled instance (zero allocation)</p>
<p></code></pre></p>

<strong>Result</strong>: Zero allocations in steady state (after warmup).

<hr>

<h2>Integration with Patterns</h2>

<h3>Outbox Pattern</h3>

<code>SendAsync</code> integrates with the Outbox pattern:

<pre><code class="language-csharp">// Receptor stores event in outbox
<p>var @event = new OrderCreated(/<em> ... </em>/);</p>

<p>await _coordinator.ProcessWorkBatchAsync(</p>
<p>    /<em> ... </em>/,</p>
<p>    newOutboxMessages: [</p>
<p>        new OutboxMessage(/<em> event data </em>/)</p>
<p>    ],</p>
<p>    /<em> ... </em>/</p>
<p>);</p>

<p>// Background worker publishes from outbox</p>
<p>var batch = await _coordinator.ProcessWorkBatchAsync(/<em> ... </em>/);</p>

<p>foreach (var msg in batch.ClaimedOutboxMessages) {</p>
<p>    await _transport.PublishAsync(msg);</p>
<p>}</p>
<p></code></pre></p>

<p>See <a href="../messaging/outbox-pattern.md">Outbox Pattern</a> for details.</p>

<h3>Inbox Pattern</h3>

<code>SendAsync</code> integrates with the Inbox pattern for exactly-once processing:

<pre><code class="language-csharp">// Check inbox for duplicate
<p>var existing = await _coordinator.FindInboxMessageAsync(messageId);</p>

<p>if (existing is not null) {</p>
<p>    // Duplicate detected - return cached result</p>
<p>    return existing.Result;</p>
<p>}</p>

<p>// Process message</p>
<p>var result = await _dispatcher.LocalInvokeAsync<TMessage, TResponse>(message);</p>

<p>// Store in inbox</p>
<p>await _coordinator.ProcessWorkBatchAsync(</p>
<p>    /<em> ... </em>/,</p>
<p>    newInboxMessages: [</p>
<p>        new InboxMessage(messageId, result)</p>
<p>    ],</p>
<p>    /<em> ... </em>/</p>
<p>);</p>
<p></code></pre></p>

<p>See <a href="../messaging/inbox-pattern.md">Inbox Pattern</a> for details.</p>

<hr>

<h2>Testing</h2>

<h3>Testing with Dispatcher</h3>

<pre><code class="language-csharp">public class OrderEndpointsTests {
<p>    private IDispatcher _dispatcher;</p>
<p>    private OrdersController _controller;</p>

<p>    [Before(Test)]</p>
<p>    public void Setup() {</p>
<p>        var services = new ServiceCollection();</p>
<p>        services.AddWhizbangCore();</p>
<p>        services.AddTransient<IReceptor<CreateOrder, OrderCreated>, CreateOrderReceptor>();</p>

<p>        var provider = services.BuildServiceProvider();</p>
<p>        _dispatcher = provider.GetRequiredService<IDispatcher>();</p>
<p>        _controller = new OrdersController(_dispatcher);</p>
<p>    }</p>

<p>    [Test]</p>
<p>    public async Task CreateOrder_ValidRequest_ReturnsCreatedAsync() {</p>
<p>        // Arrange</p>
<p>        var request = new CreateOrderRequest(</p>
<p>            CustomerId: Guid.NewGuid(),</p>
<p>            Items: [new OrderLineItem(Guid.NewGuid(), 5, 19.99m)]</p>
<p>        );</p>

<p>        // Act</p>
<p>        var result = await _controller.CreateOrder(request, CancellationToken.None);</p>

<p>        // Assert</p>
<p>        await Assert.That(result.Result).IsTypeOf<CreatedAtActionResult>();</p>

<p>        var createdResult = (CreatedAtActionResult)result.Result!;</p>
<p>        await Assert.That(createdResult.Value).IsTypeOf<OrderCreated>();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Core Concepts</strong>:
<ul><li><a href="receptors.md">Receptors</a> - Message handlers that dispatcher invokes</li>
<li><a href="perspectives.md">Perspectives</a> - Event listeners for read models</li>
<li><a href="message-context.md">Message Context</a> - Correlation and causation tracking</li>
</ul>
<strong>Messaging Patterns</strong>:
<ul><li><a href="../messaging/outbox-pattern.md">Outbox Pattern</a> - Reliable event publishing</li>
<li><a href="../messaging/inbox-pattern.md">Inbox Pattern</a> - Exactly-once processing</li>
<li><a href="../messaging/work-coordinator.md">Work Coordination</a> - Distributed work coordination</li>
</ul>
<strong>Examples</strong>:
<ul><li><a href="../examples/ecommerce/order-service.md">ECommerce: Order Service</a> - Real-world dispatcher usage</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-event-store-query" class="doc-section">
  <h3>Event Store Query</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/event-store-query</code></p>
  <p class="doc-description"><em>Query raw events in the event store with full LINQ support and automatic scope filtering</em></p>
  <div class="doc-content">

<h1>Event Store Query</h1>

<h2>Overview</h2>

<p>The Event Store Query feature provides <code>IQueryable<EventStoreRecord></code> access to raw events in the event store. This enables powerful LINQ queries across events with automatic scope filtering for multi-tenancy.</p>

<h2>Key Features</h2>

<ul><li><strong>Full LINQ Support</strong>: Query events using standard LINQ operators (Where, OrderBy, Select, etc.)</li>
<li><strong>Automatic Scope Filtering</strong>: Events are filtered by tenant/user based on the current security context</li>
<li><strong>Global Access</strong>: Admin users can query all events with proper permissions</li>
<li><strong>Singleton Service Support</strong>: <code>IScopedEventStoreQuery</code> for use in background workers</li>
</ul>
<h2>Basic Usage</h2>

<h3>Scoped Access (Web APIs, Receptors)</h3>

<pre><code class="language-csharp">public class EventsController : ControllerBase {
<p>  private readonly IScopedLensFactory _lensFactory;</p>

<p>  public EventsController(IScopedLensFactory lensFactory) {</p>
<p>    _lensFactory = lensFactory;</p>
<p>  }</p>

<p>  [HttpGet("stream/{streamId}")]</p>
<p>  public async Task<IActionResult> GetStreamEvents(Guid streamId) {</p>
<p>    // Get query filtered by tenant</p>
<p>    var query = _lensFactory.GetTenantEventStoreQuery();</p>

<p>    var events = await query.GetStreamEvents(streamId).ToListAsync();</p>
<p>    return Ok(events);</p>
<p>  }</p>

<p>  [HttpGet("recent")]</p>
<p>  public async Task<IActionResult> GetRecentEvents() {</p>
<p>    var query = _lensFactory.GetTenantEventStoreQuery();</p>

<p>    var events = await query.Query</p>
<p>        .Where(e => e.CreatedAt > DateTime.UtcNow.AddHours(-1))</p>
<p>        .OrderByDescending(e => e.CreatedAt)</p>
<p>        .Take(100)</p>
<p>        .ToListAsync();</p>

<p>    return Ok(events);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Global Access (Admin Operations)</h3>

<pre><code class="language-csharp">// Global access requires explicit permission
<p>var globalQuery = _lensFactory.GetEventStoreQuery(</p>
<p>    ScopeFilter.None,</p>
<p>    Permission.Read("events:global"));</p>

<p>// Or use convenience method (no permission check)</p>
<p>var allEvents = _lensFactory.GetGlobalEventStoreQuery();</p>
<p></code></pre></p>

<h3>Singleton Services (Background Workers)</h3>

<pre><code class="language-csharp">public class EventAnalyzerWorker : BackgroundService {
<p>  private readonly IScopedEventStoreQuery _scopedQuery;</p>

<p>  public EventAnalyzerWorker(IScopedEventStoreQuery scopedQuery) {</p>
<p>    _scopedQuery = scopedQuery;</p>
<p>  }</p>

<p>  protected override async Task ExecuteAsync(CancellationToken stoppingToken) {</p>
<p>    // Auto-scoping ensures fresh DbContext per operation</p>
<p>    await foreach (var evt in _scopedQuery.QueryAsync(</p>
<p>        q => q.Query.Where(e => e.EventType == "OrderPlaced"),</p>
<p>        stoppingToken)) {</p>
<p>      // Process event</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Batch Operations (Manual Scope Control)</h3>

<pre><code class="language-csharp">var factory = serviceProvider.GetRequiredService<IEventStoreQueryFactory>();

<p>using var scope = factory.CreateScoped();</p>
<p>var events = await scope.Value.Query</p>
<p>    .Where(e => e.StreamId == streamId)</p>
<p>    .ToListAsync();</p>
<p></code></pre></p>

<h2>Available Methods</h2>

<h3>IEventStoreQuery</h3>

<p>| Property/Method | Description |</p>
<p>|-----------------|-------------|</p>
<p>| <code>Query</code> | <code>IQueryable<EventStoreRecord></code> with automatic scope filtering |</p>
<p>| <code>GetStreamEvents(streamId)</code> | All events for a stream, ordered by version |</p>
<p>| <code>GetEventsByType(eventType)</code> | All events of a specific type |</p>

<h3>IScopedLensFactory (Event Store Methods)</h3>

<p>| Method | Scope Filter | Description |</p>
<p>|--------|--------------|-------------|</p>
<p>| <code>GetEventStoreQuery(filters)</code> | Custom | Composable scope filters |</p>
<p>| <code>GetEventStoreQuery(filters, permission)</code> | Custom | With permission check |</p>
<p>| <code>GetGlobalEventStoreQuery()</code> | None | No filtering (admin) |</p>
<p>| <code>GetTenantEventStoreQuery()</code> | Tenant | Filter by TenantId |</p>
<p>| <code>GetUserEventStoreQuery()</code> | Tenant + User | Filter by TenantId and UserId |</p>

<h2>Scope Filtering</h2>

<p>Event store queries support filtering by TenantId and UserId (the fields available in <code>MessageScope</code>).</p>

<pre><code class="language-csharp">// Tenant-only filtering
<p>var tenantQuery = _lensFactory.GetTenantEventStoreQuery();</p>
<p>// Generates: WHERE scope->>'TenantId' = 'tenant-123'</p>

<p>// Tenant + User filtering</p>
<p>var userQuery = _lensFactory.GetUserEventStoreQuery();</p>
<p>// Generates: WHERE scope->>'TenantId' = 'tenant-123' AND scope->>'UserId' = 'user-456'</p>
<p></code></pre></p>

<blockquote><strong>Note</strong>: Unlike perspective queries, event store queries do not support Organization, Customer, or Principal filtering because <code>MessageScope</code> only contains TenantId and UserId.</blockquote>

<h2>Dapper Integration</h2>

<p>For Dapper users, raw SQL access to the event store table is available:</p>

<pre><code class="language-csharp">var events = await connection.QueryAsync<EventStoreRecord>(@"
<p>    SELECT * FROM wh_event_store</p>
<p>    WHERE stream_id = @StreamId</p>
<p>    ORDER BY version",</p>
<p>    new { StreamId = streamId });</p>
<p></code></pre></p>

<p>The table schema is:</p>
<ul><li><code>event_id</code> (UUID) - Primary key</li>
<li><code>stream_id</code> (UUID) - Stream identifier (indexed)</li>
<li><code>aggregate_id</code>, <code>aggregate_type</code> - Backwards compatibility</li>
<li><code>version</code> (INT) - Sequence within stream</li>
<li><code>event_type</code> (VARCHAR) - Fully-qualified type name</li>
<li><code>event_data</code> (JSONB) - Event payload</li>
<li><code>metadata</code> (JSONB) - Envelope metadata</li>
<li><code>scope</code> (JSONB) - Multi-tenancy scope</li>
<li><code>created_at</code> (TIMESTAMPTZ) - Creation timestamp</li>
</ul>
<h2>Best Practices</h2>

<ul><li><strong>Use Scoped Queries</strong>: Prefer <code>IScopedLensFactory</code> methods for automatic scope filtering</li>
<li><strong>Limit Results</strong>: Always use <code>Take()</code> or pagination for large result sets</li>
<li><strong>Use Specific Methods</strong>: Prefer <code>GetStreamEvents()</code> over manual filtering when possible</li>
<li><strong>Permission Checks</strong>: Use <code>GetEventStoreQuery(filters, permission)</code> for sensitive operations</li>
</ul>
<h2>Related Topics</h2>

<ul><li><a href="event-store.md">Event Store</a> - Event persistence and append operations</li>
<li><a href="scoped-lenses.md">Scoped Lenses</a> - Scope filtering patterns</li>
<li><a href="multi-tenancy.md">Multi-Tenancy</a> - Tenant isolation strategies</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-fuzzy-matching" class="doc-section">
  <h3>fuzzy matching</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/fuzzy-matching</code></p>
  <div class="doc-content">
<h1>MatchStrictness: Fuzzy Type Matching Control</h1>

<p>MatchStrictness is a flag enum that controls how type names are compared during fuzzy matching. It enables flexible type matching by allowing you to ignore case, version, assembly, or namespace components.</p>

<h2>Overview</h2>

<strong>MatchStrictness</strong> provides:
<ul><li>✅ Flag-based control over type matching behavior</li>
<li>✅ Combinable flags for precise matching rules</li>
<li>✅ Composite presets for common scenarios</li>
<li>✅ Works with both formatted and raw type strings</li>
<li>✅ Used by message association queries and type matching APIs</li>
</ul>
<h2>Quick Start</h2>

<h3>Basic Fuzzy Matching</h3>

<pre><code class="language-csharp">using Whizbang.Core;

<p>var fullType = "ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts, Version=1.0.0";</p>
<p>var simpleType = "ProductCreatedEvent";</p>

<p>// Exact match (default)</p>
<p>bool exactMatch = TypeMatcher.Matches(fullType, simpleType, MatchStrictness.Exact);</p>
<p>// Result: false (types don't match exactly)</p>

<p>// Simple name match (ignore namespace, assembly, version)</p>
<p>bool simpleMatch = TypeMatcher.Matches(fullType, simpleType, MatchStrictness.SimpleName);</p>
<p>// Result: true (both have "ProductCreatedEvent")</p>

<p>// Case-insensitive match</p>
<p>bool caseMatch = TypeMatcher.Matches(</p>
<p>    "ProductCreatedEvent",</p>
<p>    "productcreatedevent",</p>
<p>    MatchStrictness.CaseInsensitive</p>
<p>);</p>
<p>// Result: true (case ignored)</p>
<p></code></pre></p>

<h3>Combining Multiple Flags</h3>

<pre><code class="language-csharp">// Ignore both case AND version
<p>var strictness = MatchStrictness.IgnoreCase | MatchStrictness.IgnoreVersion;</p>

<p>bool match = TypeMatcher.Matches(</p>
<p>    "MyApp.Events.OrderCreated, MyApp, Version=1.0.0",</p>
<p>    "myapp.events.ordercreated, myapp, version=2.0.0",</p>
<p>    strictness</p>
<p>);</p>
<p>// Result: true (version and case ignored)</p>

<p>// Ignore namespace and case</p>
<p>var flexibleMatch = MatchStrictness.IgnoreNamespace | MatchStrictness.IgnoreCase;</p>

<p>bool matches = TypeMatcher.Matches(</p>
<p>    "ECommerce.Events.ProductCreated",</p>
<p>    "productcreated",</p>
<p>    flexibleMatch</p>
<p>);</p>
<p>// Result: true (namespace and case ignored)</p>
<p></code></pre></p>

<h2>Individual Flags</h2>

<h3>Flag Definitions</h3>

<p>Each flag controls a specific transformation applied to type strings before comparison:</p>

<p>| Flag | Value | Description |</p>
<p>|------|-------|-------------|</p>
<p>| <code>None</code> | 0 | Exact match (no transformations) |</p>
<p>| <code>IgnoreCase</code> | 1 | Case-insensitive comparison |</p>
<p>| <code>IgnoreVersion</code> | 2 | Strip version, culture, and public key token |</p>
<p>| <code>IgnoreAssembly</code> | 4 | Remove assembly name |</p>
<p>| <code>IgnoreNamespace</code> | 8 | Extract simple type name only |</p>

<strong>Transformation Order</strong> (applied sequentially):
<ul><li><strong>IgnoreVersion</strong> → Strip version/culture/token</li>
<li><strong>IgnoreAssembly</strong> → Remove assembly name</li>
<li><strong>IgnoreNamespace</strong> → Extract simple type name</li>
<li><strong>IgnoreCase</strong> → Case-insensitive comparison</li>
</ul>
<h3>IgnoreCase</h3>

<strong>When</strong>: Case-insensitive type name matching

<pre><code class="language-csharp">var type1 = "ECommerce.Contracts.Events.ProductCreatedEvent";
<p>var type2 = "ecommerce.contracts.events.productcreatedevent";</p>

<p>bool match = TypeMatcher.Matches(type1, type2, MatchStrictness.IgnoreCase);</p>
<p>// Result: true</p>

<p>// Combine with other flags</p>
<p>var strictness = MatchStrictness.IgnoreCase | MatchStrictness.IgnoreNamespace;</p>
<p>bool simpleMatch = TypeMatcher.Matches(</p>
<p>    "MyApp.Events.OrderCreated",</p>
<p>    "ordercreated",</p>
<p>    strictness</p>
<p>);</p>
<p>// Result: true</p>
<p></code></pre></p>

<h3>IgnoreVersion</h3>

<strong>When</strong>: Matching types across different assembly versions

<pre><code class="language-csharp">var v1 = "MyApp.Events.OrderCreated, MyApp, Version=1.0.0, Culture=neutral";
<p>var v2 = "MyApp.Events.OrderCreated, MyApp, Version=2.0.0, Culture=neutral";</p>

<p>bool match = TypeMatcher.Matches(v1, v2, MatchStrictness.IgnoreVersion);</p>
<p>// Result: true (version, culture stripped before comparison)</p>

<p>// Original types remain unchanged</p>
<p>// After IgnoreVersion transformation:</p>
<p>// v1 → "MyApp.Events.OrderCreated, MyApp"</p>
<p>// v2 → "MyApp.Events.OrderCreated, MyApp"</p>
<p></code></pre></p>

<h3>IgnoreAssembly</h3>

<strong>When</strong>: Matching types by namespace.TypeName only

<pre><code class="language-csharp">var type1 = "ECommerce.Events.ProductCreated, ECommerce.Contracts";
<p>var type2 = "ECommerce.Events.ProductCreated, ECommerce.Core";</p>

<p>bool match = TypeMatcher.Matches(type1, type2, MatchStrictness.IgnoreAssembly);</p>
<p>// Result: true (assembly name removed before comparison)</p>

<p>// After IgnoreAssembly transformation:</p>
<p>// type1 → "ECommerce.Events.ProductCreated"</p>
<p>// type2 → "ECommerce.Events.ProductCreated"</p>
<p></code></pre></p>

<h3>IgnoreNamespace</h3>

<strong>When</strong>: Matching types by simple name only

<pre><code class="language-csharp">var type1 = "ECommerce.Contracts.Events.ProductCreatedEvent";
<p>var type2 = "MyApp.Domain.Events.ProductCreatedEvent";</p>
<p>var type3 = "ProductCreatedEvent";</p>

<p>bool match1 = TypeMatcher.Matches(type1, type2, MatchStrictness.IgnoreNamespace);</p>
<p>// Result: true</p>

<p>bool match2 = TypeMatcher.Matches(type1, type3, MatchStrictness.IgnoreNamespace);</p>
<p>// Result: true</p>

<p>// After IgnoreNamespace transformation:</p>
<p>// type1 → "ProductCreatedEvent"</p>
<p>// type2 → "ProductCreatedEvent"</p>
<p>// type3 → "ProductCreatedEvent"</p>
<p></code></pre></p>

<h2>Composite Presets</h2>

<h3>Pre-Defined Combinations</h3>

<p>| Preset | Flags | Use Case |</p>
<p>|--------|-------|----------|</p>
<p>| <code>Exact</code> | <code>None</code> | Exact string match (default) |</p>
<p>| <code>CaseInsensitive</code> | <code>IgnoreCase</code> | Case-insensitive match |</p>
<p>| <code>WithoutVersionInfo</code> | <code>IgnoreVersion</code> | Match across versions |</p>
<p>| <code>WithoutAssembly</code> | <code>IgnoreAssembly \| IgnoreVersion</code> | Match namespace.Type |</p>
<p>| <code>SimpleName</code> | <code>IgnoreNamespace \| IgnoreAssembly \| IgnoreVersion</code> | Match simple type name |</p>
<p>| <code>SimpleNameCaseInsensitive</code> | <code>SimpleName \| IgnoreCase</code> | Match simple name, any case |</p>

<h3>Preset Examples</h3>

<pre><code class="language-csharp">// Exact preset (default)
<p>bool exact = TypeMatcher.Matches(</p>
<p>    "MyApp.OrderCreated",</p>
<p>    "myapp.ordercreated",</p>
<p>    MatchStrictness.Exact</p>
<p>);</p>
<p>// Result: false (case matters)</p>

<p>// CaseInsensitive preset</p>
<p>bool caseInsensitive = TypeMatcher.Matches(</p>
<p>    "MyApp.OrderCreated",</p>
<p>    "myapp.ordercreated",</p>
<p>    MatchStrictness.CaseInsensitive</p>
<p>);</p>
<p>// Result: true</p>

<p>// WithoutVersionInfo preset</p>
<p>bool withoutVersion = TypeMatcher.Matches(</p>
<p>    "MyApp.Order, MyApp, Version=1.0.0",</p>
<p>    "MyApp.Order, MyApp, Version=2.0.0",</p>
<p>    MatchStrictness.WithoutVersionInfo</p>
<p>);</p>
<p>// Result: true</p>

<p>// SimpleName preset</p>
<p>bool simpleName = TypeMatcher.Matches(</p>
<p>    "ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts",</p>
<p>    "ProductCreatedEvent",</p>
<p>    MatchStrictness.SimpleName</p>
<p>);</p>
<p>// Result: true</p>

<p>// SimpleNameCaseInsensitive preset</p>
<p>bool simpleNameCI = TypeMatcher.Matches(</p>
<p>    "MyApp.Events.OrderCreated",</p>
<p>    "ordercreated",</p>
<p>    MatchStrictness.SimpleNameCaseInsensitive</p>
<p>);</p>
<p>// Result: true</p>
<p></code></pre></p>

<h2>Flag Combination Semantics</h2>

<h3>Additive Behavior</h3>

<p>Flags are combined using bitwise OR, and each flag adds a transformation:</p>

<pre><code class="language-csharp">// Single flag
<p>var ignoreCase = MatchStrictness.IgnoreCase;</p>

<p>// Two flags</p>
<p>var ignoreVer sionAndCase = MatchStrictness.IgnoreVersion | MatchStrictness.IgnoreCase;</p>

<p>// Three flags</p>
<p>var flexible = MatchStrictness.IgnoreVersion | MatchStrictness.IgnoreAssembly | MatchStrictness.IgnoreCase;</p>

<p>// Equivalent to SimpleName + IgnoreCase</p>
<p>var veryFlexible = MatchStrictness.SimpleName | MatchStrictness.IgnoreCase;</p>
<p>// Same as: SimpleNameCaseInsensitive</p>
<p></code></pre></p>

<h3>Order of Operations</h3>

<p>Transformations are applied in a specific order before comparison:</p>

<pre><code class="language-csharp">// Example input
<p>var type = "MyApp.Events.OrderCreated, MyApp, Version=1.0.0";</p>

<p>// Step 1: IgnoreVersion (if flag set)</p>
<p>// → "MyApp.Events.OrderCreated, MyApp"</p>

<p>// Step 2: IgnoreAssembly (if flag set)</p>
<p>// → "MyApp.Events.OrderCreated"</p>

<p>// Step 3: IgnoreNamespace (if flag set)</p>
<p>// → "OrderCreated"</p>

<p>// Step 4: IgnoreCase (if flag set)</p>
<p>// → Compare using StringComparison.OrdinalIgnoreCase</p>
<p></code></pre></p>

<h2>Common Scenarios</h2>

<h3>Scenario 1: Cross-Version Type Matching</h3>

<strong>When</strong>: Matching events from different assembly versions

<pre><code class="language-csharp">public bool IsProductEvent(string eventTypeName) {
<p>    var productEventTypes = new[] {</p>
<p>        "ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts, Version=1.0.0",</p>
<p>        "ECommerce.Contracts.Events.ProductUpdatedEvent, ECommerce.Contracts, Version=1.0.0",</p>
<p>        "ECommerce.Contracts.Events.ProductDeletedEvent, ECommerce.Contracts, Version=1.0.0"</p>
<p>    };</p>

<p>    // Match without version - works across all versions</p>
<p>    return productEventTypes.Any(knownType =></p>
<p>        TypeMatcher.Matches(</p>
<p>            eventTypeName,</p>
<p>            knownType,</p>
<p>            MatchStrictness.IgnoreVersion</p>
<p>        )</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<h3>Scenario 2: User Input Matching</h3>

<strong>When</strong>: Matching user-provided type names (case-insensitive)

<pre><code class="language-csharp">public IEnumerable<string> FindPerspectives(string eventName) {
<p>    // User types "ordercreated" - find "OrderCreated", "orderCreated", etc.</p>
<p>    return PerspectiveRegistrationExtensions.GetPerspectivesForEvent(</p>
<p>        eventName,</p>
<p>        serviceName,</p>
<p>        MatchStrictness.SimpleNameCaseInsensitive</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<h3>Scenario 3: Plugin System Type Discovery</h3>

<strong>When</strong>: Discovering types from external assemblies

<pre><code class="language-csharp">public IEnumerable<Type> FindEventHandlers(string eventTypeName) {
<p>    var allTypes = AppDomain.CurrentDomain.GetAssemblies()</p>
<p>        .SelectMany(a => a.GetTypes());</p>

<p>    // Match by simple name, ignore assembly and namespace</p>
<p>    return allTypes.Where(t => {</p>
<p>        var typeName = TypeFormatter.FormatType(t, TypeQualification.Simple);</p>
<p>        return TypeMatcher.Matches(</p>
<p>            typeName,</p>
<p>            eventTypeName,</p>
<p>            MatchStrictness.SimpleName</p>
<p>        );</p>
<p>    });</p>
<p>}</p>
<p></code></pre></p>

<h3>Scenario 4: Configuration-Based Routing</h3>

<strong>When</strong>: Routing messages based on configuration

<pre><code class="language-csharp">public class MessageRouteConfig {
<p>    public string EventPattern { get; set; } = null!;</p>
<p>    public MatchStrictness Strictness { get; set; }</p>
<p>    public string HandlerName { get; set; } = null!;</p>
<p>}</p>

<p>public string? FindHandler(string eventType, List<MessageRouteConfig> routes) {</p>
<p>    foreach (var route in routes) {</p>
<p>        if (TypeMatcher.Matches(eventType, route.EventPattern, route.Strictness)) {</p>
<p>            return route.HandlerName;</p>
<p>        }</p>
<p>    }</p>
<p>    return null;</p>
<p>}</p>

<p>// Configuration:</p>
<p>// - EventPattern: "ProductCreatedEvent"</p>
<p>//   Strictness: SimpleName</p>
<p>//   HandlerName: "ProductHandler"</p>
<p>//</p>
<p>// Matches:</p>
<p>// - "ECommerce.Events.ProductCreatedEvent"</p>
<p>// - "MyApp.Domain.ProductCreatedEvent"</p>
<p>// - "ProductCreatedEvent"</p>
<p></code></pre></p>

<h2>Flag Enum Mechanics</h2>

<h3>Checking Flags</h3>

<pre><code class="language-csharp">var strictness = MatchStrictness.IgnoreCase | MatchStrictness.IgnoreVersion;

<p>// Check if a flag is set</p>
<p>bool hasIgnoreCase = strictness.HasFlag(MatchStrictness.IgnoreCase);</p>
<p>// Result: true</p>

<p>bool hasIgnoreNamespace = strictness.HasFlag(MatchStrictness.IgnoreNamespace);</p>
<p>// Result: false</p>

<p>// Bitwise check (equivalent)</p>
<p>bool hasIgnoreCaseAlt = (strictness & MatchStrictness.IgnoreCase) == MatchStrictness.IgnoreCase;</p>
<p>// Result: true</p>
<p></code></pre></p>

<h3>Adding and Removing Flags</h3>

<pre><code class="language-csharp">var strictness = MatchStrictness.IgnoreVersion;

<p>// Add a flag</p>
<p>strictness |= MatchStrictness.IgnoreCase;</p>
<p>// Now: IgnoreVersion | IgnoreCase</p>

<p>// Remove a flag</p>
<p>strictness &= ~MatchStrictness.IgnoreVersion;</p>
<p>// Now: IgnoreCase</p>

<p>// Toggle a flag</p>
<p>strictness ^= MatchStrictness.IgnoreAssembly;</p>
<p>// Adds IgnoreAssembly if not present, removes if present</p>
<p></code></pre></p>

<h3>Building Strictness Dynamically</h3>

<pre><code class="language-csharp">public MatchStrictness BuildStrictness(
<p>    bool ignoreCase,</p>
<p>    bool ignoreVersion,</p>
<p>    bool ignoreAssembly) {</p>

<p>    var result = MatchStrictness.None;</p>

<p>    if (ignoreCase) {</p>
<p>        result |= MatchStrictness.IgnoreCase;</p>
<p>    }</p>

<p>    if (ignoreVersion) {</p>
<p>        result |= MatchStrictness.IgnoreVersion;</p>
<p>    }</p>

<p>    if (ignoreAssembly) {</p>
<p>        result |= MatchStrictness.IgnoreAssembly;</p>
<p>    }</p>

<p>    return result;</p>
<p>}</p>

<p>// Usage</p>
<p>var strictness = BuildStrictness(</p>
<p>    ignoreCase: true,</p>
<p>    ignoreVersion: true,</p>
<p>    ignoreAssembly: false</p>
<p>);</p>
<p>// Result: IgnoreCase | IgnoreVersion</p>
<p></code></pre></p>

<h2>Integration with Message Associations</h2>

<p>MatchStrictness is extensively used in message association queries:</p>

<pre><code class="language-csharp">// Find perspectives for event (exact)
<p>var exactPerspectives = PerspectiveRegistrationExtensions.GetPerspectivesForEvent(</p>
<p>    "ECommerce.Contracts.Events.ProductCreatedEvent",</p>
<p>    serviceName,</p>
<p>    MatchStrictness.Exact</p>
<p>);</p>

<p>// Find perspectives for event (simple name)</p>
<p>var simplePerspectives = PerspectiveRegistrationExtensions.GetPerspectivesForEvent(</p>
<p>    "ProductCreatedEvent",</p>
<p>    serviceName,</p>
<p>    MatchStrictness.SimpleName</p>
<p>);</p>

<p>// Find perspectives for event (case-insensitive simple name)</p>
<p>var flexiblePerspectives = PerspectiveRegistrationExtensions.GetPerspectivesForEvent(</p>
<p>    "productcreatedevent",</p>
<p>    serviceName,</p>
<p>    MatchStrictness.SimpleNameCaseInsensitive</p>
<p>);</p>

<p>// Find events for perspective (ignore assembly)</p>
<p>var events = PerspectiveRegistrationExtensions.GetEventsForPerspective(</p>
<p>    "InventoryPerspective",</p>
<p>    serviceName,</p>
<p>    MatchStrictness.WithoutAssembly</p>
<p>);</p>
<p></code></pre></p>

<h2>API Reference</h2>

<h3>Enum Definition</h3>

<strong>Namespace</strong>: <code>Whizbang.Core</code>

<pre><code class="language-csharp">[Flags]
<p>public enum MatchStrictness {</p>
<p>  None = 0,              // Exact match (default)</p>

<p>  // Individual flags (can be combined)</p>
<p>  IgnoreCase = 1 << 0,           // 1 - Case-insensitive comparison</p>
<p>  IgnoreVersion = 1 << 1,        // 2 - Ignore Version, Culture, PublicKeyToken</p>
<p>  IgnoreAssembly = 1 << 2,       // 4 - Ignore assembly name</p>
<p>  IgnoreNamespace = 1 << 3,      // 8 - Ignore namespace, keep type name only</p>

<p>  // Composite presets (for convenience)</p>
<p>  Exact = None,</p>
<p>  CaseInsensitive = IgnoreCase,</p>
<p>  WithoutVersionInfo = IgnoreVersion,</p>
<p>  WithoutAssembly = IgnoreAssembly | IgnoreVersion,  // Match namespace.Type</p>
<p>  SimpleName = IgnoreNamespace | IgnoreAssembly | IgnoreVersion,  // Just type name</p>
<p>  SimpleNameCaseInsensitive = SimpleName | IgnoreCase</p>
<p>}</p>
<p></code></pre></p>

<h3>Usage with TypeMatcher</h3>

<pre><code class="language-csharp">// Match two type strings with strictness
<p>bool match = TypeMatcher.Matches(</p>
<p>    string typeString1,</p>
<p>    string typeString2,</p>
<p>    MatchStrictness strictness</p>
<p>);</p>

<p>// Examples</p>
<p>bool exact = TypeMatcher.Matches("MyType", "MyType", MatchStrictness.Exact);</p>
<p>bool caseInsensitive = TypeMatcher.Matches("MyType", "mytype", MatchStrictness.CaseInsensitive);</p>
<p>bool simple = TypeMatcher.Matches("MyApp.MyType", "MyType", MatchStrictness.SimpleName);</p>
<p></code></pre></p>

<h2>Best Practices</h2>

<ul><li><strong>Use presets for common cases</strong> - <code>SimpleName</code>, <code>CaseInsensitive</code>, etc. are clearer than flag combinations</li>
<li><strong>Prefer SimpleNameCaseInsensitive for user input</strong> - Most forgiving for user-provided type names</li>
<li><strong>Use IgnoreVersion for production code</strong> - Avoids brittleness from version changes</li>
<li><strong>Combine flags for precise control</strong> - Use bitwise OR for exact matching needs</li>
<li><strong>Document strictness choices</strong> - Explain why a particular strictness level was chosen</li>
<li><strong>Test edge cases</strong> - Ensure matching behavior works with nested types, generics, etc.</li>
<li><strong>Consider security implications</strong> - Overly permissive matching may allow unintended type substitutions</li>
</ul>
<h2>Common Pitfalls</h2>

<h3>❌ Confusing Exact with None</h3>

<pre><code class="language-csharp">// ❌ WRONG: Assuming None means no matching
<p>bool match = TypeMatcher.Matches(type1, type2, MatchStrictness.None);</p>
<p>// Actually: Exact match (None = 0 = Exact)</p>

<p>// ✅ CORRECT: Use Exact for clarity</p>
<p>bool match = TypeMatcher.Matches(type1, type2, MatchStrictness.Exact);</p>
<p></code></pre></p>

<h3>❌ Over-Permissive Matching</h3>

<pre><code class="language-csharp">// ❌ WRONG: Too permissive for security-sensitive code
<p>var strictness = MatchStrictness.SimpleNameCaseInsensitive;</p>
<p>if (TypeMatcher.Matches(userProvidedType, "AdminCommand", strictness)) {</p>
<p>    ExecuteAdminCommand(); // Dangerous - could match many types!</p>
<p>}</p>

<p>// ✅ CORRECT: Use stricter matching for security</p>
<p>var strictness = MatchStrictness.FullyQualified;</p>
<p>if (TypeMatcher.Matches(userProvidedType, expectedType, strictness)) {</p>
<p>    ExecuteAdminCommand();</p>
<p>}</p>
<p></code></pre></p>

<h3>❌ Forgetting Version Implications</h3>

<pre><code class="language-csharp">// ❌ WRONG: Exact match breaks with version changes
<p>bool match = TypeMatcher.Matches(</p>
<p>    "MyType, MyAssembly, Version=1.0.0",</p>
<p>    "MyType, MyAssembly, Version=2.0.0",</p>
<p>    MatchStrictness.Exact</p>
<p>);</p>
<p>// Result: false (breaks when version changes)</p>

<p>// ✅ CORRECT: Ignore version for robustness</p>
<p>bool match = TypeMatcher.Matches(</p>
<p>    "MyType, MyAssembly, Version=1.0.0",</p>
<p>    "MyType, MyAssembly, Version=2.0.0",</p>
<p>    MatchStrictness.IgnoreVersion</p>
<p>);</p>
<p>// Result: true</p>
<p></code></pre></p>

<h2>See Also</h2>

<ul><li><a href="/v1.0.0/core-concepts/type-qualification">TypeQualification</a> - Formatting types for matching</li>
<li><a href="/v1.0.0/core-concepts/type-formatting">TypeFormatter</a> - Formatting Type objects to strings</li>
<li><a href="/v1.0.0/core-concepts/type-matching">TypeMatcher</a> - Type matching with MatchStrictness</li>
<li><a href="/v1.0.0/core-concepts/perspectives">Perspectives</a> - Message associations using fuzzy matching</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-lenses" class="doc-section">
  <h3>Lenses Guide</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/lenses</code></p>
  <p class="doc-description"><em>Master Whizbang Lenses - query-optimized repositories for fast, efficient access to read models maintained by Perspectives</em></p>
  <div class="doc-content">

<h1>Lenses Guide</h1>

<strong>Lenses</strong> are query-optimized repositories for reading data from read models (maintained by Perspectives). They complete the "Q" in CQRS - providing fast, efficient queries over denormalized data.

<h2>Core Concept</h2>

<p>A Lens is a <strong>focused view</strong> for querying specific read models:</p>
<ul><li><strong>Reads from denormalized tables</strong> (updated by Perspectives)</li>
<li><strong>Fast, simple queries</strong> (no joins, no complexity)</li>
<li><strong>Optimized for specific use cases</strong> (customer orders, inventory levels, analytics)</li>
<li><strong>Read-only</strong> (no write operations)</li>
</ul>
<h2>ILensQuery Interface</h2>

<pre><code class="language-csharp">namespace Whizbang.Core;

<p>public interface ILensQuery {</p>
<p>    // Marker interface - no required methods</p>
<p>    // Implement query methods specific to your read model</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Characteristics</strong>:
<ul><li><strong>Marker interface</strong>: Identifies lens implementations</li>
<li><strong>No prescribed methods</strong>: Define queries specific to your use case</li>
<li><strong>Read-only</strong>: Never mutates data</li>
<li><strong>Async</strong>: All methods return <code>Task<T></code> or <code>ValueTask<T></code></li>
</ul>
<hr>

<h2>Relationship to Perspectives</h2>

<strong>Perspectives</strong> and <strong>Lenses</strong> work together to implement CQRS:

<pre><code class="language-">┌──────────── WRITE SIDE ─────────────┐
<p>│                                      │</p>
<p>│  Command → Receptor → Event          │</p>
<p>│                                      │</p>
<p>└────────────┬─────────────────────────┘</p>
<p>             │</p>
<p>             │ dispatcher.PublishAsync()</p>
<p>             ↓</p>
<p>┌──────────── READ SIDE ──────────────┐</p>
<p>│                                      │</p>
<p>│  Event → Perspective → Read Model    │  ← Perspectives WRITE</p>
<p>│             ↓                        │</p>
<p>│  Read Model Table (denormalized)    │</p>
<p>│             ↓                        │</p>
<p>│  Lens → Query Read Model             │  ← Lenses READ</p>
<p>│             ↓                        │</p>
<p>│  Return DTO to Client                │</p>
<p>│                                      │</p>
<p>└──────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Division of Labor</strong>:
<ul><li><strong>Perspectives</strong>: Update read models (write-only)</li>
<li><strong>Lenses</strong>: Query read models (read-only)</li>
</ul>
<hr>

<h2>Basic Example</h2>

<pre><code class="language-csharp">using Whizbang.Core;
<p>using Dapper;</p>

<p>public class OrderLens : ILensQuery {</p>
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public OrderLens(IDbConnectionFactory db) {</p>
<p>        _db = db;</p>
<p>    }</p>

<p>    public async Task<OrderSummary?> GetOrderAsync(</p>
<p>        Guid orderId,</p>
<p>        CancellationToken ct = default) {</p>

<p>        await using var conn = _db.CreateConnection();</p>

<p>        return await conn.QuerySingleOrDefaultAsync<OrderSummary>(</p>
<p>            """</p>
<p>            SELECT</p>
<p>                order_id AS OrderId,</p>
<p>                customer_id AS CustomerId,</p>
<p>                customer_email AS CustomerEmail,</p>
<p>                customer_name AS CustomerName,</p>
<p>                item_count AS ItemCount,</p>
<p>                total AS Total,</p>
<p>                status AS Status,</p>
<p>                created_at AS CreatedAt,</p>
<p>                shipped_at AS ShippedAt,</p>
<p>                cancelled_at AS CancelledAt</p>
<p>            FROM order_summaries</p>
<p>            WHERE order_id = @OrderId</p>
<p>            """,</p>
<p>            new { OrderId = orderId },</p>
<p>            commandTimeout: 30,</p>
<p>            cancellationToken: ct</p>
<p>        );</p>
<p>    }</p>

<p>    public async Task<OrderSummary[]> GetOrdersByCustomerAsync(</p>
<p>        Guid customerId,</p>
<p>        CancellationToken ct = default) {</p>

<p>        await using var conn = _db.CreateConnection();</p>

<p>        var orders = await conn.QueryAsync<OrderSummary>(</p>
<p>            """</p>
<p>            SELECT</p>
<p>                order_id AS OrderId,</p>
<p>                customer_id AS CustomerId,</p>
<p>                customer_email AS CustomerEmail,</p>
<p>                customer_name AS CustomerName,</p>
<p>                item_count AS ItemCount,</p>
<p>                total AS Total,</p>
<p>                status AS Status,</p>
<p>                created_at AS CreatedAt,</p>
<p>                shipped_at AS ShippedAt,</p>
<p>                cancelled_at AS CancelledAt</p>
<p>            FROM order_summaries</p>
<p>            WHERE customer_id = @CustomerId</p>
<p>            ORDER BY created_at DESC</p>
<p>            """,</p>
<p>            new { CustomerId = customerId },</p>
<p>            commandTimeout: 30,</p>
<p>            cancellationToken: ct</p>
<p>        );</p>

<p>        return orders.ToArray();</p>
<p>    }</p>
<p>}</p>

<p>// DTO returned by lens</p>
<p>public record OrderSummary(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    string CustomerEmail,</p>
<p>    string CustomerName,</p>
<p>    int ItemCount,</p>
<p>    decimal Total,</p>
<p>    string Status,</p>
<p>    DateTimeOffset CreatedAt,</p>
<p>    DateTimeOffset? ShippedAt,</p>
<p>    DateTimeOffset? CancelledAt</p>
<p>);</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li>Simple SQL (single table, no joins)</li>
<li>Returns DTOs optimized for client</li>
<li>Async methods with CancellationToken</li>
<li>Nullable return for "not found" cases</li>
</ul>
<hr>

<h2>Query Patterns</h2>

<h3>Pattern 1: Get by ID</h3>

<pre><code class="language-csharp">public async Task<OrderSummary?> GetOrderAsync(
<p>    Guid orderId,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    return await conn.QuerySingleOrDefaultAsync<OrderSummary>(</p>
<p>        "SELECT * FROM order_summaries WHERE order_id = @OrderId",</p>
<p>        new { OrderId = orderId },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<strong>Use Case</strong>: Retrieve single entity by primary key.

<h3>Pattern 2: List with Filtering</h3>

<pre><code class="language-csharp">public async Task<OrderSummary[]> GetOrdersByStatusAsync(
<p>    string status,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    var orders = await conn.QueryAsync<OrderSummary>(</p>
<p>        """</p>
<p>        SELECT * FROM order_summaries</p>
<p>        WHERE status = @Status</p>
<p>        ORDER BY created_at DESC</p>
<p>        """,</p>
<p>        new { Status = status },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    return orders.ToArray();</p>
<p>}</p>
<p></code></pre></p>

<strong>Use Case</strong>: Filter and sort lists.

<h3>Pattern 3: Pagination</h3>

<pre><code class="language-csharp">public async Task<PagedResult<OrderSummary>> GetOrdersPagedAsync(
<p>    int pageNumber,</p>
<p>    int pageSize,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    var offset = (pageNumber - 1) * pageSize;</p>

<p>    // Get total count</p>
<p>    var totalCount = await conn.ExecuteScalarAsync<int>(</p>
<p>        "SELECT COUNT(*) FROM order_summaries",</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    // Get page of results</p>
<p>    var orders = await conn.QueryAsync<OrderSummary>(</p>
<p>        """</p>
<p>        SELECT * FROM order_summaries</p>
<p>        ORDER BY created_at DESC</p>
<p>        LIMIT @PageSize OFFSET @Offset</p>
<p>        """,</p>
<p>        new { PageSize = pageSize, Offset = offset },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    return new PagedResult<OrderSummary>(</p>
<p>        Items: orders.ToArray(),</p>
<p>        TotalCount: totalCount,</p>
<p>        PageNumber: pageNumber,</p>
<p>        PageSize: pageSize</p>
<p>    );</p>
<p>}</p>

<p>public record PagedResult<T>(</p>
<p>    T[] Items,</p>
<p>    int TotalCount,</p>
<p>    int PageNumber,</p>
<p>    int PageSize</p>
<p>) {</p>
<p>    public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);</p>
<p>    public bool HasPreviousPage => PageNumber > 1;</p>
<p>    public bool HasNextPage => PageNumber < TotalPages;</p>
<p>}</p>
<p></code></pre></p>

<strong>Use Case</strong>: Large result sets with pagination.

<h3>Pattern 4: Aggregations</h3>

<pre><code class="language-csharp">public async Task<OrderStatistics> GetOrderStatisticsAsync(
<p>    Guid customerId,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    return await conn.QuerySingleAsync<OrderStatistics>(</p>
<p>        """</p>
<p>        SELECT</p>
<p>            COUNT(*) AS TotalOrders,</p>
<p>            SUM(total) AS TotalSpent,</p>
<p>            AVG(total) AS AverageOrderValue,</p>
<p>            MAX(created_at) AS LastOrderDate</p>
<p>        FROM order_summaries</p>
<p>        WHERE customer_id = @CustomerId</p>
<p>        """,</p>
<p>        new { CustomerId = customerId },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>
<p>}</p>

<p>public record OrderStatistics(</p>
<p>    int TotalOrders,</p>
<p>    decimal TotalSpent,</p>
<p>    decimal AverageOrderValue,</p>
<p>    DateTimeOffset LastOrderDate</p>
<p>);</p>
<p></code></pre></p>

<strong>Use Case</strong>: Analytics and dashboard widgets.

<h3>Pattern 5: Search</h3>

<pre><code class="language-csharp">public async Task<OrderSummary[]> SearchOrdersAsync(
<p>    string searchTerm,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    var orders = await conn.QueryAsync<OrderSummary>(</p>
<p>        """</p>
<p>        SELECT * FROM order_summaries</p>
<p>        WHERE</p>
<p>            customer_email ILIKE @SearchPattern</p>
<p>            OR customer_name ILIKE @SearchPattern</p>
<p>            OR status ILIKE @SearchPattern</p>
<p>        ORDER BY created_at DESC</p>
<p>        LIMIT 100</p>
<p>        """,</p>
<p>        new { SearchPattern = $"%{searchTerm}%" },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    return orders.ToArray();</p>
<p>}</p>
<p></code></pre></p>

<strong>Use Case</strong>: Free-text search across multiple columns.

<hr>

<h2>Multiple Lenses for Same Read Model</h2>

<p>Different lenses can query the same read model with different methods:</p>

<pre><code class="language-csharp">// Lens 1: Customer-focused queries
<p>public class CustomerOrderLens : ILensQuery {</p>
<p>    public async Task<OrderSummary[]> GetOrdersByCustomerAsync(Guid customerId, CancellationToken ct = default) {</p>
<p>        // Query order_summaries filtered by customer_id</p>
<p>    }</p>

<p>    public async Task<OrderStatistics> GetCustomerOrderStatisticsAsync(Guid customerId, CancellationToken ct = default) {</p>
<p>        // Aggregate stats for customer</p>
<p>    }</p>
<p>}</p>

<p>// Lens 2: Admin-focused queries</p>
<p>public class AdminOrderLens : ILensQuery {</p>
<p>    public async Task<OrderSummary[]> GetAllOrdersAsync(int pageNumber, int pageSize, CancellationToken ct = default) {</p>
<p>        // Query all orders with pagination</p>
<p>    }</p>

<p>    public async Task<OrderSummary[]> GetOrdersByDateRangeAsync(DateOnly startDate, DateOnly endDate, CancellationToken ct = default) {</p>
<p>        // Query by date range</p>
<p>    }</p>

<p>    public async Task<decimal> GetTotalRevenueAsync(DateOnly date, CancellationToken ct = default) {</p>
<p>        // Sum total revenue for date</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Pattern</strong>: Organize lenses by <strong>use case</strong> (customer, admin, analytics).

<hr>

<h2>Complex Queries</h2>

<p>While lenses prefer simple queries, you can handle complexity when needed:</p>

<h3>Joining Denormalized Tables</h3>

<pre><code class="language-csharp">public async Task<CustomerOrderHistory> GetCustomerOrderHistoryAsync(
<p>    Guid customerId,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    // Join two denormalized read models</p>
<p>    var result = await conn.QueryAsync<CustomerOrderHistoryItem>(</p>
<p>        """</p>
<p>        SELECT</p>
<p>            os.order_id,</p>
<p>            os.total,</p>
<p>            os.status,</p>
<p>            os.created_at,</p>
<p>            ca.total_orders,</p>
<p>            ca.lifetime_value</p>
<p>        FROM order_summaries os</p>
<p>        JOIN customer_activity ca ON os.customer_id = ca.customer_id</p>
<p>        WHERE os.customer_id = @CustomerId</p>
<p>        ORDER BY os.created_at DESC</p>
<p>        """,</p>
<p>        new { CustomerId = customerId },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    return new CustomerOrderHistory(</p>
<p>        CustomerId: customerId,</p>
<p>        Orders: result.ToArray()</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<strong>Note</strong>: Even when joining, you're joining <strong>denormalized read models</strong>, not normalized write models. Still fast!

<h3>JSON Querying (PostgreSQL)</h3>

<pre><code class="language-csharp">public async Task<Product[]> GetProductsByCategoryAsync(
<p>    string category,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    // Query JSON column</p>
<p>    var products = await conn.QueryAsync<Product>(</p>
<p>        """</p>
<p>        SELECT * FROM product_catalog</p>
<p>        WHERE metadata->>'category' = @Category</p>
<p>        ORDER BY name</p>
<p>        """,</p>
<p>        new { Category = category },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    return products.ToArray();</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Dependency Injection</h2>

<h3>Registration</h3>

<strong>Manual</strong>:
<pre><code class="language-csharp">builder.Services.AddTransient<ILensQuery, OrderLens>();
<p>builder.Services.AddTransient<ILensQuery, InventoryLens>();</p>

<p>// Or register by interface name</p>
<p>builder.Services.AddTransient<IOrderLens, OrderLens>();</p>
<p>builder.Services.AddTransient<IInventoryLens, InventoryLens>();</p>
<p></code></pre></p>

<strong>Auto-Discovery</strong> (with Whizbang.Generators):
<pre><code class="language-csharp">builder.Services.AddDiscoveredLenses();  // Finds all ILensQuery implementations
<p></code></pre></p>

<h3>Lifetime</h3>

<strong>Recommended</strong>: <code>Transient</code> (new instance per request)

<strong>Why?</strong>
<ul><li>May inject scoped services (e.g., <code>DbContext</code>)</li>
<li>Stateless (no benefit to reusing instances)</li>
<li>Lightweight (minimal allocation cost)</li>
</ul>
<pre><code class="language-csharp">builder.Services.AddTransient<IOrderLens, OrderLens>();
<p></code></pre></p>

<hr>

<h2>Caching Strategies</h2>

<h3>In-Memory Caching</h3>

<pre><code class="language-csharp">public class OrderLens : ILensQuery {
<p>    private readonly IDbConnectionFactory _db;</p>
<p>    private readonly IMemoryCache _cache;</p>

<p>    public OrderLens(IDbConnectionFactory db, IMemoryCache cache) {</p>
<p>        _db = db;</p>
<p>        _cache = cache;</p>
<p>    }</p>

<p>    public async Task<OrderSummary?> GetOrderAsync(</p>
<p>        Guid orderId,</p>
<p>        CancellationToken ct = default) {</p>

<p>        // Try cache first</p>
<p>        if (_cache.TryGetValue(orderId, out OrderSummary? cached)) {</p>
<p>            return cached;</p>
<p>        }</p>

<p>        // Query database</p>
<p>        await using var conn = _db.CreateConnection();</p>

<p>        var order = await conn.QuerySingleOrDefaultAsync<OrderSummary>(</p>
<p>            "SELECT * FROM order_summaries WHERE order_id = @OrderId",</p>
<p>            new { OrderId = orderId },</p>
<p>            cancellationToken: ct</p>
<p>        );</p>

<p>        if (order is not null) {</p>
<p>            // Cache for 5 minutes</p>
<p>            _cache.Set(orderId, order, TimeSpan.FromMinutes(5));</p>
<p>        }</p>

<p>        return order;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Distributed Caching (Redis)</h3>

<pre><code class="language-csharp">public class OrderLens : ILensQuery {
<p>    private readonly IDbConnectionFactory _db;</p>
<p>    private readonly IDistributedCache _cache;</p>

<p>    public async Task<OrderSummary?> GetOrderAsync(</p>
<p>        Guid orderId,</p>
<p>        CancellationToken ct = default) {</p>

<p>        var cacheKey = $"order:{orderId}";</p>

<p>        // Try distributed cache</p>
<p>        var cachedJson = await _cache.GetStringAsync(cacheKey, ct);</p>

<p>        if (cachedJson is not null) {</p>
<p>            return JsonSerializer.Deserialize<OrderSummary>(cachedJson);</p>
<p>        }</p>

<p>        // Query database</p>
<p>        await using var conn = _db.CreateConnection();</p>

<p>        var order = await conn.QuerySingleOrDefaultAsync<OrderSummary>(</p>
<p>            "SELECT * FROM order_summaries WHERE order_id = @OrderId",</p>
<p>            new { OrderId = orderId },</p>
<p>            cancellationToken: ct</p>
<p>        );</p>

<p>        if (order is not null) {</p>
<p>            // Cache in Redis</p>
<p>            var json = JsonSerializer.Serialize(order);</p>
<p>            await _cache.SetStringAsync(</p>
<p>                cacheKey,</p>
<p>                json,</p>
<p>                new DistributedCacheEntryOptions {</p>
<p>                    AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5)</p>
<p>                },</p>
<p>                ct</p>
<p>            );</p>
<p>        }</p>

<p>        return order;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Cache Invalidation</strong>: Perspectives can invalidate cache when updating read models:

<pre><code class="language-csharp">public class OrderSummaryPerspective : IPerspectiveOf<OrderCreated> {
<p>    private readonly IDbConnectionFactory _db;</p>
<p>    private readonly IDistributedCache _cache;</p>

<p>    public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>        // Update database</p>
<p>        await using var conn = _db.CreateConnection();</p>
<p>        await conn.ExecuteAsync("INSERT INTO order_summaries (...) VALUES (...)", @event, ct);</p>

<p>        // Invalidate cache</p>
<p>        await _cache.RemoveAsync($"order:{@event.OrderId}", ct);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Testing Lenses</h2>

<h3>Unit Tests</h3>

<pre><code class="language-csharp">public class OrderLensTests {
<p>    [Test]</p>
<p>    public async Task GetOrderAsync_ExistingOrder_ReturnsOrderSummaryAsync() {</p>
<p>        // Arrange</p>
<p>        var mockDb = CreateMockDb();  // Returns mock with test data</p>
<p>        var lens = new OrderLens(mockDb);</p>

<p>        var orderId = TestData.ExistingOrderId;</p>

<p>        // Act</p>
<p>        var result = await lens.GetOrderAsync(orderId, CancellationToken.None);</p>

<p>        // Assert</p>
<p>        await Assert.That(result).IsNotNull();</p>
<p>        await Assert.That(result!.OrderId).IsEqualTo(orderId);</p>
<p>        await Assert.That(result.Total).IsGreaterThan(0m);</p>
<p>    }</p>

<p>    [Test]</p>
<p>    public async Task GetOrderAsync_NonExistentOrder_ReturnsNullAsync() {</p>
<p>        // Arrange</p>
<p>        var mockDb = CreateMockDb();  // Returns null for non-existent order</p>
<p>        var lens = new OrderLens(mockDb);</p>

<p>        var orderId = Guid.NewGuid();  // Doesn't exist</p>

<p>        // Act</p>
<p>        var result = await lens.GetOrderAsync(orderId, CancellationToken.None);</p>

<p>        // Assert</p>
<p>        await Assert.That(result).IsNull();</p>
<p>    }</p>

<p>    [Test]</p>
<p>    public async Task GetOrdersPagedAsync_ValidPage_ReturnsPagedResultAsync() {</p>
<p>        // Arrange</p>
<p>        var mockDb = CreateMockDbWithOrders(25);  // 25 orders total</p>
<p>        var lens = new OrderLens(mockDb);</p>

<p>        // Act</p>
<p>        var result = await lens.GetOrdersPagedAsync(</p>
<p>            pageNumber: 2,</p>
<p>            pageSize: 10,</p>
<p>            CancellationToken.None</p>
<p>        );</p>

<p>        // Assert</p>
<p>        await Assert.That(result.Items.Length).IsEqualTo(10);  // Second page</p>
<p>        await Assert.That(result.TotalCount).IsEqualTo(25);</p>
<p>        await Assert.That(result.TotalPages).IsEqualTo(3);  // 25 / 10 = 3 pages</p>
<p>        await Assert.That(result.HasPreviousPage).IsTrue();   // Page 2 has previous</p>
<p>        await Assert.That(result.HasNextPage).IsTrue();       // Page 2 has next</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Integration Tests</h3>

<pre><code class="language-csharp">public class OrderLensIntegrationTests {
<p>    private IDbConnectionFactory _db;</p>
<p>    private OrderLens _lens;</p>

<p>    [Before(Test)]</p>
<p>    public async Task SetupAsync() {</p>
<p>        _db = CreateTestDatabase();  // Real PostgreSQL test database</p>
<p>        _lens = new OrderLens(_db);</p>

<p>        // Seed test data</p>
<p>        await SeedTestDataAsync();</p>
<p>    }</p>

<p>    [Test]</p>
<p>    public async Task GetOrdersByCustomerAsync_WithOrders_ReturnsAllCustomerOrdersAsync() {</p>
<p>        // Arrange</p>
<p>        var customerId = TestData.CustomerWithOrdersId;</p>

<p>        // Act</p>
<p>        var orders = await _lens.GetOrdersByCustomerAsync(customerId, CancellationToken.None);</p>

<p>        // Assert</p>
<p>        await Assert.That(orders.Length).IsEqualTo(3);  // Customer has 3 orders</p>
<p>        await Assert.That(orders.All(o => o.CustomerId == customerId)).IsTrue();</p>
<p>        await Assert.That(orders).IsSortedDescending(o => o.CreatedAt);  // Sorted by date</p>
<p>    }</p>

<p>    private async Task SeedTestDataAsync() {</p>
<p>        await using var conn = _db.CreateConnection();</p>
<p>        await conn.ExecuteAsync(</p>
<p>            """</p>
<p>            INSERT INTO order_summaries (order_id, customer_id, total, status, created_at)</p>
<p>            VALUES</p>
<p>                (@OrderId1, @CustomerId, 100.00, 'Created', '2024-12-01'),</p>
<p>                (@OrderId2, @CustomerId, 200.00, 'Shipped', '2024-12-05'),</p>
<p>                (@OrderId3, @CustomerId, 150.00, 'Delivered', '2024-12-10')</p>
<p>            """,</p>
<p>            new {</p>
<p>                OrderId1 = Guid.NewGuid(),</p>
<p>                OrderId2 = Guid.NewGuid(),</p>
<p>                OrderId3 = Guid.NewGuid(),</p>
<p>                CustomerId = TestData.CustomerWithOrdersId</p>
<p>            }</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Advanced Patterns</h2>

<h3>Pattern: Lens with Multiple Read Models</h3>

<pre><code class="language-csharp">public class OrderDetailsLens : ILensQuery {
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public async Task<OrderDetailsView> GetOrderDetailsAsync(</p>
<p>        Guid orderId,</p>
<p>        CancellationToken ct = default) {</p>

<p>        await using var conn = _db.CreateConnection();</p>

<p>        // Query 1: Order summary</p>
<p>        var summary = await conn.QuerySingleOrDefaultAsync<OrderSummary>(</p>
<p>            "SELECT * FROM order_summaries WHERE order_id = @OrderId",</p>
<p>            new { OrderId = orderId },</p>
<p>            ct</p>
<p>        );</p>

<p>        if (summary is null) {</p>
<p>            throw new NotFoundException($"Order {orderId} not found");</p>
<p>        }</p>

<p>        // Query 2: Order items (separate read model)</p>
<p>        var items = await conn.QueryAsync<OrderItemDetail>(</p>
<p>            "SELECT * FROM order_item_details WHERE order_id = @OrderId",</p>
<p>            new { OrderId = orderId },</p>
<p>            ct</p>
<p>        );</p>

<p>        // Query 3: Shipping info (separate read model)</p>
<p>        var shipping = await conn.QuerySingleOrDefaultAsync<ShippingInfo>(</p>
<p>            "SELECT * FROM shipping_info WHERE order_id = @OrderId",</p>
<p>            new { OrderId = orderId },</p>
<p>            ct</p>
<p>        );</p>

<p>        // Combine into single DTO</p>
<p>        return new OrderDetailsView(</p>
<p>            Summary: summary,</p>
<p>            Items: items.ToArray(),</p>
<p>            Shipping: shipping</p>
<p>        );</p>
<p>    }</p>
<p>}</p>

<p>public record OrderDetailsView(</p>
<p>    OrderSummary Summary,</p>
<p>    OrderItemDetail[] Items,</p>
<p>    ShippingInfo? Shipping</p>
<p>);</p>
<p></code></pre></p>

<h3>Pattern: Graph QL Integration</h3>

<pre><code class="language-csharp">public class OrderQueries {
<p>    private readonly IOrderLens _lens;</p>

<p>    public OrderQueries(IOrderLens lens) {</p>
<p>        _lens = lens;</p>
<p>    }</p>

<p>    [GraphQLName("order")]</p>
<p>    public async Task<OrderSummary?> GetOrderAsync(Guid orderId, CancellationToken ct) {</p>
<p>        return await _lens.GetOrderAsync(orderId, ct);</p>
<p>    }</p>

<p>    [GraphQLName("orders")]</p>
<p>    public async Task<PagedResult<OrderSummary>> GetOrdersPagedAsync(</p>
<p>        int pageNumber = 1,</p>
<p>        int pageSize = 20,</p>
<p>        CancellationToken ct = default) {</p>

<p>        return await _lens.GetOrdersPagedAsync(pageNumber, pageSize, ct);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ Keep queries <strong>simple</strong> (single table or denormalized joins)</li>
<li>✅ Return <strong>DTOs</strong> specific to client needs</li>
<li>✅ Use <strong>async methods</strong> with CancellationToken</li>
<li>✅ Return <strong>null</strong> for "not found" (don't throw)</li>
<li>✅ Add <strong>indexes</strong> to read model tables for common queries</li>
<li>✅ Use <strong>pagination</strong> for large result sets</li>
<li>✅ Cache frequently accessed data</li>
<li>✅ Organize lenses by <strong>use case</strong> (customer, admin, analytics)</li>
<li>✅ Keep lenses <strong>stateless</strong></li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Query normalized write models directly (use denormalized read models)</li>
<li>❌ Perform complex joins across many tables (defeats purpose of CQRS)</li>
<li>❌ Mutate data in lenses (read-only!)</li>
<li>❌ Call receptors from lenses (lenses are read-only)</li>
<li>❌ Return IQueryable (forces deferred execution, breaks abstraction)</li>
<li>❌ Store state in lens instances</li>
<li>❌ Throw exceptions for "not found" (return null instead)</li>
<li>❌ Return unbounded result sets (always paginate large datasets)</li>
</ul>
<hr>

<h2>Further Reading</h2>

<strong>Core Concepts</strong>:
<ul><li><a href="perspectives.md">Perspectives</a> - Event listeners that maintain read models</li>
<li><a href="dispatcher.md">Dispatcher</a> - How to invoke receptors and publish events</li>
<li><a href="receptors.md">Receptors</a> - Command handlers that produce events</li>
</ul>
<strong>Data Access</strong>:
<ul><li><a href="../data/dapper-integration.md">Dapper Integration</a> - Lightweight data access</li>
<li><a href="../data/efcore-integration.md">EF Core Integration</a> - Full-featured ORM</li>
<li><a href="../data/perspectives-storage.md">Perspective Storage</a> - Schema design patterns</li>
</ul>
<strong>Examples</strong>:
<ul><li><a href="../examples/ecommerce/bff-pattern.md">ECommerce: BFF Pattern</a> - Real-world lens usage</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-lifecycle-receptors" class="doc-section">
  <h3>Lifecycle Receptors</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/lifecycle-receptors</code></p>
  <p class="doc-description"><em>Complete API reference for lifecycle receptors - [FireAt] attribute, ILifecycleContext injection, compile-time vs runtime registration, and AOT-compatible patterns</em></p>
  <div class="doc-content">

<h1>Lifecycle Receptors</h1>

<p>Lifecycle receptors are <strong>regular receptors</strong> that execute at specific stages in the message processing pipeline. Using the <code>[FireAt]</code> attribute, you can declaratively control when your receptors fire without changing any code.</p>

<h2>Core Concept</h2>

<strong>Lifecycle receptors reuse the existing <code>IReceptor<TMessage></code> interface</strong> - no new interfaces to learn. The <code>[FireAt]</code> attribute controls timing:

<pre><code class="language-csharp">// Regular receptor - fires at default stages (see below)
<p>public class CreateTenantHandler : IReceptor<CreateTenantCommand, TenantCreatedEvent> {</p>
<p>  public ValueTask<TenantCreatedEvent> HandleAsync(CreateTenantCommand cmd, CancellationToken ct) {</p>
<p>    // Business logic fires at:</p>
<p>    // - LocalImmediateInline (local path)</p>
<p>    // - PreOutboxInline (distributed sender)</p>
<p>    // - PostInboxInline (distributed receiver)</p>
<p>    return ValueTask.FromResult(new TenantCreatedEvent(Guid.NewGuid()));</p>
<p>  }</p>
<p>}</p>

<p>// Lifecycle receptor - fires ONLY at PostPerspectiveAsync</p>
<p>[FireAt(LifecycleStage.PostPerspectiveAsync)]</p>
<p>public class ProductMetricsReceptor : IReceptor<ProductCreatedEvent> {</p>
<p>  public ValueTask HandleAsync(ProductCreatedEvent evt, CancellationToken ct) {</p>
<p>    // Track metrics AFTER perspective completes</p>
<p>    // Does NOT fire at default stages!</p>
<p>    return ValueTask.CompletedTask;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Design</strong>:
<ul><li>Reuse existing <code>IReceptor<TMessage></code> interface</li>
<li><code>[FireAt]</code> attribute controls when receptor executes</li>
<li>Receptors without <code>[FireAt]</code> fire at <strong>default stages</strong> (LocalImmediateInline, PreOutboxInline, PostInboxInline)</li>
<li>Adding <code>[FireAt]</code> <strong>replaces</strong> defaults - receptor fires ONLY at specified stages</li>
<li>Can apply multiple <code>[FireAt]</code> attributes to fire at multiple stages</li>
<li>Optional <code>ILifecycleContext</code> injection for metadata access</li>
<li><strong>Scoped dependency support</strong> - receptors can inject scoped services like <code>DbContext</code>, <code>IOrchestratorAgent</code></li>
</ul>
<hr>

<h2>Scoped Dependency Support</h2>

<p>:::new</p>
<p>Scoped dependency support added in v1.0.0</p>
<p>:::</p>

<p>Lifecycle receptors can inject <strong>scoped dependencies</strong> just like regular receptors. The generated code creates a new <code>IServiceScope</code> for each lifecycle invocation, ensuring proper dependency resolution and lifecycle management.</p>

<h3>Example with Scoped Dependencies</h3>

<pre><code class="language-csharp">[FireAt(LifecycleStage.PostDistributeInline)]
<p>public class StartupHandler : IReceptor<StartedEvent> {</p>
<p>  private readonly AppDbContext _dbContext;        // Scoped!</p>
<p>  private readonly IOrchestratorAgent _agent;      // Scoped!</p>
<p>  private readonly ILogger<StartupHandler> _logger; // Transient</p>

<p>  public StartupHandler(</p>
<p>      AppDbContext dbContext,</p>
<p>      IOrchestratorAgent agent,</p>
<p>      ILogger<StartupHandler> logger) {</p>
<p>    _dbContext = dbContext;</p>
<p>    _agent = agent;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async ValueTask HandleAsync(StartedEvent evt, CancellationToken ct) {</p>
<p>    // All scoped dependencies work correctly!</p>
<p>    var config = await _dbContext.Configurations.FirstAsync(ct);</p>
<p>    await _agent.StartOrchestratorAsync(config, ct);</p>
<p>    _logger.LogInformation("Orchestrator started");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>How It Works</h3>

<p>The generated <code>LifecycleInvoker</code> uses <code>IServiceScopeFactory</code> to create a scope per invocation:</p>

<pre><code class="language-csharp">// Generated code pattern
<p>if (messageType == typeof(StartedEvent) && stage == LifecycleStage.PostDistributeInline) {</p>
<p>  using var scope = _scopeFactory.CreateScope();</p>
<p>  var receptor = scope.ServiceProvider.GetRequiredService<IReceptor<StartedEvent>>();</p>
<p>  await receptor.HandleAsync((StartedEvent)message, cancellationToken);</p>
<p>}</p>
<p>// Scope disposed after invocation - resources cleaned up</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ Same scoped dependency support as regular receptors</li>
<li>✅ Proper scope lifecycle (created before, disposed after each invocation)</li>
<li>✅ Compatible with <code>DbContext</code>, <code>IOrchestratorAgent</code>, and other scoped services</li>
<li>✅ No special configuration required</li>
</ul>
<hr>

<h2>The <code>[FireAt]</code> Attribute</h2>

<h3>Basic Usage</h3>

<p>Apply <code>[FireAt]</code> to receptor classes to control execution timing:</p>

<pre><code class="language-csharp">using Whizbang.Core;
<p>using Whizbang.Core.Observability;</p>

<p>[FireAt(LifecycleStage.PostPerspectiveAsync)]</p>
<p>public class EventMetricsReceptor : IReceptor<ProductCreatedEvent> {</p>
<p>  private readonly IMetricsCollector _metrics;</p>

<p>  public EventMetricsReceptor(IMetricsCollector metrics) {</p>
<p>    _metrics = metrics;</p>
<p>  }</p>

<p>  public ValueTask HandleAsync(ProductCreatedEvent evt, CancellationToken ct) {</p>
<p>    _metrics.RecordEvent("ProductCreated", evt.ProductId);</p>
<p>    return ValueTask.CompletedTask;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Attribute Properties</strong>:
<ul><li><strong>Stage</strong> (required) - The <code>LifecycleStage</code> when receptor should fire</li>
</ul>
<strong>Allowed Targets</strong>:
<ul><li>Classes implementing <code>IReceptor<TMessage></code></li>
<li>Can be applied multiple times (see below)</li>
<li>Not inherited (Inherited = false)</li>
</ul>
<hr>

<h3>Multiple Stages (Multiple Attributes)</h3>

<p>Apply <code>[FireAt]</code> multiple times to fire at multiple stages:</p>

<pre><code class="language-csharp">// Fire at BOTH PreOutbox and PostOutbox stages
<p>[FireAt(LifecycleStage.PreOutboxInline)]</p>
<p>[FireAt(LifecycleStage.PostOutboxAsync)]</p>
<p>public class OutboxMonitoringReceptor : IReceptor<IEvent> {</p>
<p>  private readonly ILogger<OutboxMonitoringReceptor> _logger;</p>
<p>  private readonly Stopwatch _timer = new();</p>

<p>  public ValueTask HandleAsync(IEvent evt, CancellationToken ct) {</p>
<p>    // Check which stage we're at (optional - via ILifecycleContext)</p>
<p>    if (_timer.IsRunning) {</p>
<p>      // PostOutbox - measure publish duration</p>
<p>      _logger.LogInformation("Published {EventType} in {Ms}ms",</p>
<p>        evt.GetType().Name, _timer.ElapsedMilliseconds);</p>
<p>      _timer.Reset();</p>
<p>    } else {</p>
<p>      // PreOutbox - start timing</p>
<p>      _timer.Start();</p>
<p>    }</p>
<p>    return ValueTask.CompletedTask;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Use Cases for Multiple Stages</strong>:
<ul><li>Measure operation duration (PreX + PostX)</li>
<li>Before/after validation</li>
<li>Consistent logging across multiple stages</li>
<li>Cross-cutting concerns (auditing, metrics)</li>
</ul>
<hr>

<h3>Default Behavior (No Attribute)</h3>

<p>:::updated</p>
<p>Default behavior changed in v1.0.0 to support the unified receptor invocation model.</p>
<p>:::</p>

<p>Receptors <strong>without <code>[FireAt]</code> fire at default stages</strong> based on the dispatch path:</p>

<p>| Path | Default Stage | When |</p>
<p>|------|--------------|------|</p>
<p>| <strong>Local</strong> | <code>LocalImmediateInline</code> | <code>DispatchAsync(msg, local: true)</code> |</p>
<p>| <strong>Distributed (Sender)</strong> | <code>PreOutboxInline</code> | Before publishing to transport |</p>
<p>| <strong>Distributed (Receiver)</strong> | <code>PostInboxInline</code> | After receiving from transport |</p>

<pre><code class="language-csharp">// No [FireAt] attribute = fires at default stages
<p>public class CreateProductReceptor : IReceptor<CreateProductCommand, ProductCreatedEvent> {</p>
<p>  public async ValueTask<ProductCreatedEvent> HandleAsync(</p>
<p>      CreateProductCommand cmd,</p>
<p>      CancellationToken ct) {</p>

<p>    // This executes at:</p>
<p>    // - LocalImmediateInline (when local: true)</p>
<p>    // - PreOutboxInline (distributed sender)</p>
<p>    // - PostInboxInline (distributed receiver)</p>
<p>    var product = new Product(cmd.Name, cmd.Price);</p>
<p>    await _dbContext.Products.AddAsync(product, ct);</p>

<p>    return new ProductCreatedEvent(product.Id, product.Name);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Why these defaults?</strong>
<ul><li><strong>Paths are mutually exclusive</strong> - a message goes local OR distributed, not both</li>
<li><strong>Default receptors "just work"</strong> regardless of how message is dispatched</li>
<li><strong>Adding <code>[FireAt]</code> opts OUT of defaults</strong> - you control exactly when receptor fires:</li>
</ul>
<pre><code class="language-csharp">// ONLY fires locally, never on distributed path
<p>[FireAt(LifecycleStage.LocalImmediateInline)]</p>
<p>public class LocalOnlyHandler : IReceptor<SomeCommand> { }</p>

<p>// ONLY fires on receiver, never on sender or local</p>
<p>[FireAt(LifecycleStage.PostInboxInline)]</p>
<p>public class ReceiverOnlyHandler : IReceptor<SomeEvent> { }</p>

<p>// Fires on BOTH sender AND receiver (but not local)</p>
<p>[FireAt(LifecycleStage.PreOutboxInline)]</p>
<p>[FireAt(LifecycleStage.PostInboxInline)]</p>
<p>public class DistributedOnlyHandler : IReceptor<SomeEvent> { }</p>
<p></code></pre></p>

<hr>

<h2>Optional <code>ILifecycleContext</code> Injection</h2>

<p>Receptors can optionally inject <code>ILifecycleContext</code> to access metadata about the current invocation:</p>

<h3>Interface Definition</h3>

<pre><code class="language-csharp">public interface ILifecycleContext {
<p>  /// <summary>The lifecycle stage currently executing</summary></p>
<p>  LifecycleStage CurrentStage { get; }</p>

<p>  /// <summary>The ID of the event being processed (null for commands)</summary></p>
<p>  Guid? EventId { get; }</p>

<p>  /// <summary>The stream ID (aggregate ID) for event-sourced messages</summary></p>
<p>  Guid? StreamId { get; }</p>

<p>  /// <summary>The perspective name processing this message (null if not perspective stage)</summary></p>
<p>  string? PerspectiveName { get; }</p>

<p>  /// <summary>The last processed event ID for the perspective (checkpoint position)</summary></p>
<p>  Guid? LastProcessedEventId { get; }</p>
<p>}</p>
<p></code></pre></p>

<h3>Constructor Injection</h3>

<pre><code class="language-csharp">[FireAt(LifecycleStage.PostPerspectiveAsync)]
<p>public class PerspectiveProgressReceptor : IReceptor<IEvent> {</p>
<p>  private readonly ILogger _logger;</p>
<p>  private readonly ILifecycleContext _context;  // Optional injection</p>

<p>  public PerspectiveProgressReceptor(</p>
<p>      ILogger<PerspectiveProgressReceptor> logger,</p>
<p>      ILifecycleContext context) {  // Injected by Whizbang</p>

<p>    _logger = logger;</p>
<p>    _context = context;</p>
<p>  }</p>

<p>  public ValueTask HandleAsync(IEvent evt, CancellationToken ct) {</p>
<p>    _logger.LogInformation(</p>
<p>      "Perspective {Perspective} processed event {EventId} from stream {StreamId}",</p>
<p>      _context.PerspectiveName,</p>
<p>      _context.EventId,</p>
<p>      _context.StreamId);</p>

<p>    return ValueTask.CompletedTask;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Filtering by Context</h3>

<p>Use context to filter invocations:</p>

<pre><code class="language-csharp">[FireAt(LifecycleStage.PostPerspectiveInline)]
<p>public class SpecificPerspectiveReceptor : IReceptor<ProductCreatedEvent> {</p>
<p>  private readonly ILifecycleContext _context;</p>

<p>  public SpecificPerspectiveReceptor(ILifecycleContext context) {</p>
<p>    _context = context;</p>
<p>  }</p>

<p>  public ValueTask HandleAsync(ProductCreatedEvent evt, CancellationToken ct) {</p>
<p>    // Only execute for "ProductCatalog" perspective</p>
<p>    if (_context.PerspectiveName != "ProductCatalog") {</p>
<p>      return ValueTask.CompletedTask;  // Skip</p>
<p>    }</p>

<p>    // Do work specific to ProductCatalog perspective</p>
<p>    Console.WriteLine($"ProductCatalog processed {evt.ProductId}");</p>
<p>    return ValueTask.CompletedTask;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>When to Inject Context</strong>:
<ul><li>✅ Need to know current stage (when using multiple <code>[FireAt]</code>)</li>
<li>✅ Need to filter by perspective name</li>
<li>✅ Need stream ID or event ID for logging</li>
<li>✅ Need checkpoint position for custom logic</li>
<li>❌ Don't need metadata - keep constructor simple</li>
</ul>
<hr>

<h2>Security Context in Lifecycle Receptors</h2>

<p>:::new</p>
<p>Security context is now established before lifecycle receptor invocation in PerspectiveWorker (v1.0.0).</p>
<p>:::</p>

<p>Lifecycle receptors have full access to security context from the message envelope via <code>IMessageContext</code>:</p>

<h3>Accessing Security Context</h3>

<pre><code class="language-csharp">[FireAt(LifecycleStage.PrePerspectiveAsync)]
<p>public class AuditReceptor : IReceptor<IEvent> {</p>
<p>  private readonly IMessageContext _messageContext;</p>
<p>  private readonly ILogger<AuditReceptor> _logger;</p>

<p>  public AuditReceptor(IMessageContext messageContext, ILogger<AuditReceptor> logger) {</p>
<p>    _messageContext = messageContext;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public ValueTask HandleAsync(IEvent evt, CancellationToken ct) {</p>
<p>    // UserId is available from the message envelope's security context</p>
<p>    var userId = _messageContext.UserId;</p>

<p>    _logger.LogInformation(</p>
<p>      "User {UserId} triggered perspective update for event {EventId}",</p>
<p>      userId,</p>
<p>      _messageContext.MessageId);</p>

<p>    return ValueTask.CompletedTask;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Available Security Properties</h3>

<p>The <code>IMessageContext</code> provides access to:</p>

<p>| Property | Type | Description |</p>
<p>|----------|------|-------------|</p>
<p>| <code>UserId</code> | <code>string?</code> | User identifier from the message's security context |</p>
<p>| <code>MessageId</code> | <code>MessageId</code> | The message identifier |</p>
<p>| <code>CorrelationId</code> | <code>CorrelationId</code> | Correlation ID for distributed tracing |</p>
<p>| <code>CausationId</code> | <code>MessageId</code> | ID of the message that caused this one |</p>
<p>| <code>Timestamp</code> | <code>DateTimeOffset</code> | When the message was created |</p>
<p>| <code>Metadata</code> | <code>IReadOnlyDictionary<string, object></code> | Custom metadata |</p>

<h3>Lifecycle Stages with Security Context</h3>

<p>Security context is established <strong>before</strong> each lifecycle receptor invocation for the following stages:</p>

<ul><li><code>PrePerspectiveAsync</code> - Before perspective processing</li>
<li><code>PrePerspectiveInline</code> - Before perspective processing (blocking)</li>
<li><code>PostPerspectiveInline</code> - After perspective checkpoint saved (blocking)</li>
</ul>
<h3>Example: User-Aware Audit Trail</h3>

<pre><code class="language-csharp">[FireAt(LifecycleStage.PostPerspectiveInline)]
<p>public class UserAuditReceptor : IReceptor<OrderPlacedEvent> {</p>
<p>  private readonly IMessageContext _messageContext;</p>
<p>  private readonly IAuditService _audit;</p>

<p>  public UserAuditReceptor(IMessageContext messageContext, IAuditService audit) {</p>
<p>    _messageContext = messageContext;</p>
<p>    _audit = audit;</p>
<p>  }</p>

<p>  public async ValueTask HandleAsync(OrderPlacedEvent evt, CancellationToken ct) {</p>
<p>    await _audit.RecordAsync(new AuditEntry {</p>
<p>      UserId = _messageContext.UserId,</p>
<p>      EventType = nameof(OrderPlacedEvent),</p>
<p>      EventId = _messageContext.MessageId.Value,</p>
<p>      CorrelationId = _messageContext.CorrelationId.Value,</p>
<p>      Timestamp = _messageContext.Timestamp,</p>
<p>      Details = $"Order {evt.OrderId} placed"</p>
<p>    });</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li>Security context is established from the message envelope's hops</li>
<li><code>UserId</code> will be <code>null</code> if no security context was attached to the message</li>
<li>Each envelope in a batch gets its own security context established before invocation</li>
</ul>
<hr>

<h2>Compile-Time Registration (Production)</h2>

<h3>How It Works</h3>

<p>Source generators discover lifecycle receptors and wire them automatically:</p>

<ul><li><strong>ReceptorDiscoveryGenerator</strong> scans your code for:</li>
</ul><p>   - Classes implementing <code>IReceptor<TMessage></code> or <code>IReceptor<TMessage, TResponse></code></p>
<p>   - <code>[FireAt]</code> attributes on those classes</p>
<p>   - Constructor parameters (including <code>ILifecycleContext</code>)</p>

<ul><li><strong>Generated Code</strong> creates invocation logic:</li>
</ul><p>   - <code>ReceptorInvoker.g.cs</code> - Switches on message type and lifecycle stage</p>
<p>   - <code>ReceptorRegistrations.g.cs</code> - Registers receptors with DI container</p>

<ul><li><strong>Zero Reflection</strong> - All routing is compile-time generated code</li>
</ul>
<h3>Example Generated Code</h3>

<strong>Your Receptor</strong>:
<pre><code class="language-csharp">[FireAt(LifecycleStage.PostPerspectiveAsync)]
<p>public class ProductMetricsReceptor : IReceptor<ProductCreatedEvent> {</p>
<p>  public ValueTask HandleAsync(ProductCreatedEvent evt, CancellationToken ct) {</p>
<p>    // Track metrics</p>
<p>    return ValueTask.CompletedTask;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Generated Invocation</strong> (simplified):
<pre><code class="language-csharp">// LifecycleInvoker.g.cs
<p>public async ValueTask InvokeAtStageAsync(</p>
<p>    object message,</p>
<p>    LifecycleStage stage,</p>
<p>    ILifecycleContext context,</p>
<p>    CancellationToken cancellationToken) {</p>

<p>  var messageType = message.GetType();</p>

<p>  // Generated routing for (ProductCreatedEvent, PostPerspectiveAsync)</p>
<p>  if (messageType == typeof(ProductCreatedEvent)</p>
<p>      && stage == LifecycleStage.PostPerspectiveAsync) {</p>

<p>    // Scope created per invocation - supports scoped dependencies</p>
<p>    using var scope = _scopeFactory.CreateScope();</p>
<p>    var receptor = scope.ServiceProvider.GetRequiredService<ProductMetricsReceptor>();</p>
<p>    await receptor.HandleAsync((ProductCreatedEvent)message, cancellationToken);</p>
<p>  }</p>

<p>  // ... more generated branches for other receptors</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ Zero reflection - fully AOT-compatible</li>
<li>✅ Compile-time validation</li>
<li>✅ Fast dispatch (no dictionary lookups)</li>
<li>✅ Incremental compilation (sealed records, syntactic filtering)</li>
<li>✅ <strong>Scoped dependency support</strong> - receptors can inject <code>DbContext</code>, <code>IOrchestratorAgent</code>, etc.</li>
</ul>
<hr>

<h2>Runtime Registration (Testing)</h2>

<h3>The <code>ILifecycleReceptorRegistry</code></h3>

<p>For test scenarios, use runtime registration to dynamically add/remove receptors:</p>

<pre><code class="language-csharp">public interface ILifecycleReceptorRegistry {
<p>  /// <summary>Register a receptor to fire at a specific lifecycle stage</summary></p>
<p>  void Register<TMessage>(object receptor, LifecycleStage stage)</p>
<p>    where TMessage : IMessage;</p>

<p>  /// <summary>Unregister a previously registered receptor</summary></p>
<p>  bool Unregister<TMessage>(object receptor, LifecycleStage stage)</p>
<p>    where TMessage : IMessage;</p>

<p>  /// <summary>Get all receptors registered for a message type and stage</summary></p>
<p>  IReadOnlyList<object> GetReceptors(Type messageType, LifecycleStage stage);</p>

<p>  /// <summary>Get handler delegates for AOT-compatible invocation</summary></p>
<p>  IReadOnlyList<Func<object, CancellationToken, ValueTask>> GetHandlers(</p>
<p>    Type messageType, LifecycleStage stage);</p>
<p>}</p>
<p></code></pre></p>

<h3>Test Pattern</h3>

<p>Use runtime registration for test synchronization:</p>

<pre><code class="language-csharp">[Test]
<p>public async Task CreateProduct_UpdatesPerspective_DeterministicallyAsync() {</p>
<p>  // Arrange</p>
<p>  var completionSource = new TaskCompletionSource<bool>();</p>
<p>  var receptor = new PerspectiveCompletionReceptor<ProductCreatedEvent>(completionSource);</p>

<p>  var registry = _host.Services.GetRequiredService<ILifecycleReceptorRegistry>();</p>

<p>  // Register receptor at PostPerspectiveInline (blocking stage)</p>
<p>  registry.Register<ProductCreatedEvent>(receptor, LifecycleStage.PostPerspectiveInline);</p>

<p>  try {</p>
<p>    // Act - dispatch command</p>
<p>    var command = new CreateProductCommand("Widget", 9.99m);</p>
<p>    await _dispatcher.SendAsync(command);</p>

<p>    // Wait for perspective processing to complete (deterministic!)</p>
<p>    await completionSource.Task.WaitAsync(TimeSpan.FromSeconds(15));</p>

<p>    // Assert - perspective data is guaranteed to be saved</p>
<p>    var product = await _productLens.GetByIdAsync(command.ProductId);</p>
<p>    Assert.That(product).IsNotNull();</p>
<p>    Assert.That(product!.Name).IsEqualTo("Widget");</p>

<p>  } finally {</p>
<p>    // Always unregister</p>
<p>    registry.Unregister<ProductCreatedEvent>(receptor, LifecycleStage.PostPerspectiveInline);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li><strong>Only supports void receptors</strong> (<code>IReceptor<TMessage></code>) - no response types</li>
<li><strong>AOT-compatible</strong> - uses pattern matching (<code>is IReceptor<TMessage></code>), not reflection</li>
<li><strong>Thread-safe</strong> - uses <code>ConcurrentDictionary</code> internally</li>
<li><strong>Must unregister</strong> - use try/finally to ensure cleanup</li>
</ul>
<p>See <a href="../testing/lifecycle-synchronization.md">Lifecycle Synchronization</a> for complete test patterns.</p>

<hr>

<h2>AOT-Compatible Design</h2>

<h3>Pattern Matching (Not Reflection)</h3>

<p>The runtime registry uses <strong>pattern matching</strong> instead of reflection:</p>

<pre><code class="language-csharp">// In DefaultLifecycleReceptorRegistry.cs
<p>private static Func<object, CancellationToken, ValueTask> _createHandler<TMessage>(object receptor)</p>
<p>    where TMessage : IMessage {</p>

<p>  // Pattern matching is compile-time, not reflection!</p>
<p>  if (receptor is not IReceptor<TMessage> voidReceptor) {</p>
<p>    throw new ArgumentException(</p>
<p>      $"Receptor must implement IReceptor<{typeof(TMessage).Name}>.");</p>
<p>  }</p>

<p>  // Return delegate that calls HandleAsync</p>
<p>  return async (msg, ct) => await voidReceptor.HandleAsync((TMessage)msg, ct);</p>
<p>}</p>
<p></code></pre></p>

<strong>Why This Works</strong>:
<ul><li><code>is IReceptor<TMessage></code> is pattern matching (compile-time check)</li>
<li>No <code>GetType()</code>, <code>GetInterfaces()</code>, or <code>Invoke()</code> calls</li>
<li>Fully trimmable and AOT-publishable</li>
<li>Creates delegate upfront, stores for fast invocation</li>
</ul>
<h3>Delegate-Based Invocation</h3>

<p>Registry stores <strong>delegates</strong> alongside receptors:</p>

<pre><code class="language-csharp">// Internal storage: (Receptor instance, Handler delegate)
<p>ConcurrentDictionary<</p>
<p>  (Type MessageType, LifecycleStage Stage),</p>
<p>  List<(object Receptor, Func<object, CancellationToken, ValueTask> Handler)></p>
<blockquote>_receptors;</blockquote>

<p>// Registration creates delegate immediately</p>
<p>public void Register<TMessage>(object receptor, LifecycleStage stage) {</p>
<p>  var handler = _createHandler<TMessage>(receptor);  // Pattern matching</p>
<p>  _receptors.AddOrUpdate(key,</p>
<p>    _ => new List<...> { (receptor, handler) },</p>
<p>    (_, list) => { list.Add((receptor, handler)); return list; });</p>
<p>}</p>

<p>// Invocation is direct delegate call (no reflection!)</p>
<p>var handlers = registry.GetHandlers(typeof(ProductCreatedEvent), LifecycleStage.PostPerspectiveAsync);</p>
<p>foreach (var handler in handlers) {</p>
<p>  await handler(message, cancellationToken);  // Direct call!</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ Zero reflection in hot path</li>
<li>✅ Native AOT compatible</li>
<li>✅ Fast invocation (delegates are inlined by JIT/AOT)</li>
<li>✅ Type-safe at registration time</li>
</ul>
<hr>

<h2>Lifecycle Receptor Patterns</h2>

<h3>Pattern 1: Metrics Collection</h3>

<p>Track metrics after specific stages:</p>

<pre><code class="language-csharp">[FireAt(LifecycleStage.PostOutboxAsync)]
<p>public class OutboxMetricsReceptor : IReceptor<IEvent> {</p>
<p>  private readonly IMetricsCollector _metrics;</p>

<p>  public OutboxMetricsReceptor(IMetricsCollector metrics) {</p>
<p>    _metrics = metrics;</p>
<p>  }</p>

<p>  public ValueTask HandleAsync(IEvent evt, CancellationToken ct) {</p>
<p>    _metrics.Increment("outbox.published",</p>
<p>      tags: new[] { $"event_type:{evt.GetType().Name}" });</p>
<p>    return ValueTask.CompletedTask;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern 2: Audit Logging</h3>

<p>Log message flow through pipeline:</p>

<pre><code class="language-csharp">[FireAt(LifecycleStage.PreInboxInline)]
<p>[FireAt(LifecycleStage.PostInboxAsync)]</p>
<p>public class InboxAuditReceptor : IReceptor<ICommand> {</p>
<p>  private readonly IAuditLog _audit;</p>
<p>  private readonly ILifecycleContext _context;</p>

<p>  public InboxAuditReceptor(IAuditLog audit, ILifecycleContext context) {</p>
<p>    _audit = audit;</p>
<p>    _context = context;</p>
<p>  }</p>

<p>  public ValueTask HandleAsync(ICommand cmd, CancellationToken ct) {</p>
<p>    var stage = _context.CurrentStage == LifecycleStage.PreInboxInline</p>
<p>      ? "received"</p>
<p>      : "processed";</p>

<p>    _audit.Log($"Command {cmd.GetType().Name} {stage} at {DateTime.UtcNow}");</p>
<p>    return ValueTask.CompletedTask;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern 3: Test Synchronization</h3>

<p>Wait for perspective processing to complete:</p>

<pre><code class="language-csharp">[FireAt(LifecycleStage.PostPerspectiveInline)]  // Blocking stage
<p>public class PerspectiveCompletionReceptor<TEvent> : IReceptor<TEvent></p>
<p>  where TEvent : IEvent {</p>

<p>  private readonly TaskCompletionSource<bool> _completionSource;</p>
<p>  private readonly string? _perspectiveName;</p>
<p>  private readonly ILifecycleContext? _context;</p>

<p>  public PerspectiveCompletionReceptor(</p>
<p>      TaskCompletionSource<bool> completionSource,</p>
<p>      string? perspectiveName = null,</p>
<p>      ILifecycleContext? context = null) {</p>

<p>    _completionSource = completionSource;</p>
<p>    _perspectiveName = perspectiveName;</p>
<p>    _context = context;</p>
<p>  }</p>

<p>  public ValueTask HandleAsync(TEvent message, CancellationToken ct) {</p>
<p>    // Filter by perspective if specified</p>
<p>    if (_context is not null && _perspectiveName is not null) {</p>
<p>      if (_context.PerspectiveName != _perspectiveName) {</p>
<p>        return ValueTask.CompletedTask;  // Not our perspective</p>
<p>      }</p>
<p>    }</p>

<p>    // Signal test to proceed</p>
<p>    _completionSource.TrySetResult(true);</p>
<p>    return ValueTask.CompletedTask;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<p>See <a href="../testing/lifecycle-synchronization.md">Lifecycle Synchronization</a> for complete test patterns.</p>

<h3>Pattern 4: Custom Indexing</h3>

<p>Build custom search indices after perspective updates:</p>

<pre><code class="language-csharp">[FireAt(LifecycleStage.PostPerspectiveAsync)]
<p>public class SearchIndexReceptor : IReceptor<ProductCreatedEvent> {</p>
<p>  private readonly ISearchIndexer _indexer;</p>

<p>  public SearchIndexReceptor(ISearchIndexer indexer) {</p>
<p>    _indexer = indexer;</p>
<p>  }</p>

<p>  public ValueTask HandleAsync(ProductCreatedEvent evt, CancellationToken ct) {</p>
<p>    // Index product for search (non-blocking)</p>
<p>    return _indexer.IndexProductAsync(evt.ProductId, evt.Name, ct);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern 5: Cache Invalidation</h3>

<p>Invalidate caches when perspectives update:</p>

<pre><code class="language-csharp">[FireAt(LifecycleStage.PostPerspectiveAsync)]
<p>public class CacheInvalidationReceptor : IReceptor<IEvent> {</p>
<p>  private readonly IDistributedCache _cache;</p>
<p>  private readonly ILifecycleContext _context;</p>

<p>  public CacheInvalidationReceptor(IDistributedCache cache, ILifecycleContext context) {</p>
<p>    _cache = cache;</p>
<p>    _context = context;</p>
<p>  }</p>

<p>  public async ValueTask HandleAsync(IEvent evt, CancellationToken ct) {</p>
<p>    // Invalidate cache for this stream (aggregate)</p>
<p>    if (_context.StreamId.HasValue) {</p>
<p>      var cacheKey = $"aggregate:{_context.StreamId.Value}";</p>
<p>      await _cache.RemoveAsync(cacheKey, ct);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Performance Considerations</h2>

<h3>Keep Lifecycle Receptors Fast</h3>

<p>Lifecycle receptors execute <strong>synchronously in the message processing path</strong>:</p>

<p>✅ <strong>Good Practices</strong>:</p>
<ul><li>Quick in-memory operations (< 5ms)</li>
<li>Async logging (fire-and-forget)</li>
<li>Metrics collection (counters, gauges)</li>
<li>Test signaling (TaskCompletionSource)</li>
<li>Cache key building</li>
</ul>
<p>❌ <strong>Avoid</strong>:</p>
<ul><li>Database queries (use separate handlers)</li>
<li>HTTP calls (use separate handlers)</li>
<li>Heavy computation (offload to background)</li>
<li>Blocking operations in Async stages</li>
<li>Long-running operations in Inline stages</li>
</ul>
<h3>Inline vs Async Stages</h3>

<strong>Inline stages block next step</strong> - keep them extremely fast:
<pre><code class="language-csharp">[FireAt(LifecycleStage.PostPerspectiveInline)]  // BLOCKING!
<p>public class FastCompletionReceptor : IReceptor<IEvent> {</p>
<p>  public ValueTask HandleAsync(IEvent evt, CancellationToken ct) {</p>
<p>    // ✅ Fast: Signal completion</p>
<p>    _completionSource.TrySetResult(true);</p>
<p>    return ValueTask.CompletedTask;</p>

<p>    // ❌ NEVER: Database query in inline stage</p>
<p>    // await _dbContext.Products.FirstAsync(...);  // BLOCKS ENTIRE PIPELINE!</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Async stages run in parallel</strong> - more flexible but still keep fast:
<pre><code class="language-csharp">[FireAt(LifecycleStage.PostPerspectiveAsync)]  // Non-blocking
<p>public class AsyncMetricsReceptor : IReceptor<IEvent> {</p>
<p>  public async ValueTask HandleAsync(IEvent evt, CancellationToken ct) {</p>
<p>    // ✅ Acceptable: Async logging (fast)</p>
<p>    await _logger.LogAsync($"Processed {evt.GetType().Name}");</p>

<p>    // ⚠️ Avoid: Slow operations still impact throughput</p>
<p>    // Better to use separate background handler</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Exception Handling</h3>

<strong>Lifecycle receptor errors are logged but don't fail message processing</strong>:

<pre><code class="language-csharp">[FireAt(LifecycleStage.PostPerspectiveAsync)]
<p>public class MetricsReceptor : IReceptor<IEvent> {</p>
<p>  public ValueTask HandleAsync(IEvent evt, CancellationToken ct) {</p>
<p>    try {</p>
<p>      _metrics.RecordEvent(evt.GetType().Name);</p>
<p>    } catch (Exception ex) {</p>
<p>      // Logged by framework, doesn't fail message processing</p>
<p>      // Perspective checkpoint still advances</p>
<p>    }</p>
<p>    return ValueTask.CompletedTask;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>For critical operations</strong>, use Inline stages to detect failures:
<pre><code class="language-csharp">[FireAt(LifecycleStage.PostPerspectiveInline)]  // Blocking - errors propagate
<p>public class CriticalReceptor : IReceptor<IEvent> {</p>
<p>  public ValueTask HandleAsync(IEvent evt, CancellationToken ct) {</p>
<p>    // If this throws, checkpoint won't advance</p>
<p>    // Use for critical operations only</p>
<p>    return ValueTask.CompletedTask;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Compile-Time vs Runtime Registration</h2>

<p>| Feature | Compile-Time ([FireAt]) | Runtime (ILifecycleReceptorRegistry) |</p>
<p>|---------|------------------------|-------------------------------------|</p>
<p>| <strong>Registration</strong> | Automatic via source generator | Manual via Register() |</p>
<p>| <strong>Discovery</strong> | Build-time | Runtime only |</p>
<p>| <strong>Performance</strong> | Fastest (no dictionary lookup) | Fast (delegate-based) |</p>
<p>| <strong>Use Cases</strong> | Production metrics, logging | Test synchronization |</p>
<p>| <strong>Lifecycle</strong> | Application lifetime | Scoped (register/unregister) |</p>
<p>| <strong>Response Types</strong> | ✅ Supported | ❌ Void only |</p>
<p>| <strong>AOT Compatible</strong> | ✅ Yes | ✅ Yes (pattern matching) |</p>
<p>| <strong>Reflection</strong> | ❌ Zero | ❌ Zero |</p>

<strong>Recommendation</strong>:
<ul><li><strong>Use [FireAt]</strong> for production features (metrics, logging, auditing)</li>
<li><strong>Use Registry</strong> for test scenarios (wait for perspective completion)</li>
</ul>
<hr>

<h2>Registration Setup</h2>

<h3>Production (Compile-Time)</h3>

<strong>Step 1</strong>: Apply <code>[FireAt]</code> to receptors:
<pre><code class="language-csharp">[FireAt(LifecycleStage.PostPerspectiveAsync)]
<p>public class MyMetricsReceptor : IReceptor<ProductCreatedEvent> {</p>
<p>  public ValueTask HandleAsync(ProductCreatedEvent evt, CancellationToken ct) {</p>
<p>    // Track metrics</p>
<p>    return ValueTask.CompletedTask;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Step 2</strong>: Register Whizbang services:
<pre><code class="language-csharp">// In Program.cs or Startup.cs
<p>services</p>
<p>  .AddWhizbang()</p>
<p>  .WithEFCore<MyDbContext>()</p>
<p>  .WithDriver.Postgres;</p>
<p></code></pre></p>

<strong>Done!</strong> Source generators discover your receptors automatically.

<h3>Testing (Runtime)</h3>

<strong>Step 1</strong>: Get registry from DI:
<pre><code class="language-csharp">var registry = _host.Services.GetRequiredService<ILifecycleReceptorRegistry>();
<p></code></pre></p>

<strong>Step 2</strong>: Register receptor:
<pre><code class="language-csharp">var completionSource = new TaskCompletionSource<bool>();
<p>var receptor = new PerspectiveCompletionReceptor<ProductCreatedEvent>(completionSource);</p>

<p>registry.Register<ProductCreatedEvent>(receptor, LifecycleStage.PostPerspectiveInline);</p>
<p></code></pre></p>

<strong>Step 3</strong>: Use and cleanup:
<pre><code class="language-csharp">try {
<p>  await _dispatcher.SendAsync(command);</p>
<p>  await completionSource.Task.WaitAsync(TimeSpan.FromSeconds(15));</p>
<p>} finally {</p>
<p>  registry.Unregister<ProductCreatedEvent>(receptor, LifecycleStage.PostPerspectiveInline);</p>
<p>}</p>
<p></code></pre></p>

<strong>Helper method available</strong>:
<pre><code class="language-csharp">// Extension method wraps registration/unregistration
<p>await _host.WaitForPerspectiveCompletionAsync<ProductCreatedEvent>(</p>
<p>  perspectiveName: "ProductCatalog",</p>
<p>  timeoutMilliseconds: 15000</p>
<p>);</p>
<p></code></pre></p>

<p>See <a href="../testing/lifecycle-synchronization.md">Lifecycle Synchronization</a> for complete patterns.</p>

<hr>

<h2>Related Topics</h2>

<ul><li><a href="lifecycle-stages.md">Lifecycle Stages</a> - All 18 stages with timing diagrams</li>
<li><a href="receptors.md">Receptors Guide</a> - Core receptor concepts and patterns</li>
<li><a href="../testing/lifecycle-synchronization.md">Testing: Lifecycle Synchronization</a> - Deterministic test patterns</li>
<li><a href="../advanced/source-generators.md">Source Generators</a> - How lifecycle receptors are discovered</li>
<li><a href="../deployment/aot-compatibility.md">AOT Compatibility</a> - Zero-reflection design</li>
</ul>
<hr>

<h2>Summary</h2>

<ul><li><strong>Reuse <code>IReceptor<TMessage></code> interface</strong> - No new interfaces to learn</li>
<li><strong><code>[FireAt]</code> controls timing</strong> - Declarative lifecycle stage selection</li>
<li><strong>Multiple attributes supported</strong> - Fire at multiple stages</li>
<li><strong>Default stages</strong>: <code>LocalImmediateInline</code>, <code>PreOutboxInline</code>, <code>PostInboxInline</code></li>
<li><strong>Adding <code>[FireAt]</code> replaces defaults</strong> - Receptor fires ONLY at specified stages</li>
<li><strong>Two mutually exclusive paths</strong>: Local (mediator) vs Distributed (outbox/inbox)</li>
<li><strong>Optional <code>ILifecycleContext</code> injection</strong> - Access metadata when needed</li>
<li><strong>Scoped dependency support</strong> - Receptors can inject <code>DbContext</code>, <code>IOrchestratorAgent</code>, etc.</li>
<li><strong>Compile-time registration</strong> - Source generators wire automatically via <code>IReceptorRegistry</code></li>
<li><strong>Runtime registration</strong> - <code>ILifecycleReceptorRegistry</code> for tests</li>
<li><strong>Zero reflection</strong> - Fully AOT-compatible via <code>IReceptorInvoker</code> (pattern matching + delegates)</li>
<li><strong>Keep receptors fast</strong> - < 5ms, avoid database queries in hot path</li>
<li><strong>Use Inline stages carefully</strong> - They block next step (for critical operations only)</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-lifecycle-stages" class="doc-section">
  <h3>Lifecycle Stages</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/lifecycle-stages</code></p>
  <p class="doc-description"><em>Complete reference for all 20 lifecycle stages in Whizbang message processing pipeline - timing, guarantees, and use cases</em></p>
  <div class="doc-content">

<h1>Lifecycle Stages</h1>

<p>Whizbang provides <strong>20 lifecycle stages</strong> where custom logic can execute during message processing. Lifecycle stages enable observability, metrics collection, test synchronization, and custom side effects without modifying core framework code.</p>

<h2>Core Concept</h2>

<p>Messages flow through <strong>two mutually exclusive paths</strong>:</p>

<h3>Local Path (Mediator Pattern)</h3>

<pre><code class="language-mermaid">graph LR
<p>    A[Dispatch<br>local: true] --> B[LocalImmediate]</p>
<p>    B --> C[Done]</p>

<p>    style A fill:#e1f5ff</p>
<p>    style B fill:#d4edda</p>
<p>    style C fill:#f0f0f0</p>
<p></code></pre></p>

<strong>Local dispatch</strong> acts as an in-memory mediator - no persistence, no transport. Messages are processed immediately.

<h3>Distributed Path (Outbox/Inbox)</h3>

<pre><code class="language-mermaid">graph LR
<p>    A[Dispatch] --> B[Distribute]</p>
<p>    B --> C[Outbox]</p>
<p>    C --> D[Transport]</p>
<p>    D --> E[Inbox]</p>
<p>    E --> F[Perspective]</p>

<p>    style A fill:#e1f5ff</p>
<p>    style B fill:#fff4e1</p>
<p>    style C fill:#ffe1e1</p>
<p>    style D fill:#f0f0f0</p>
<p>    style E fill:#e1ffe1</p>
<p>    style F fill:#f5e1ff</p>
<p></code></pre></p>

<strong>Distributed dispatch</strong> persists to outbox, publishes via transport (RabbitMQ, Service Bus), and processes in inbox on receiver side.

<hr>

<h2>Two Mutually Exclusive Paths</h2>

<p>:::new</p>
<p>Understanding the two dispatch paths is critical for using lifecycle stages correctly.</p>
<p>:::</p>

<p>| Path | Description | Default Stages | Persistence |</p>
<p>|------|-------------|---------------|-------------|</p>
<p>| <strong>Local</strong> | <code>DispatchAsync(msg, local: true)</code> | <code>LocalImmediateInline</code> | ❌ None (mediator) |</p>
<p>| <strong>Distributed</strong> | <code>DispatchAsync(msg)</code> or via transport | <code>PreOutboxInline</code> (sender) + <code>PostInboxInline</code> (receiver) | ✅ Outbox/Inbox |</p>

<strong>Key Points</strong>:
<ul><li>A message goes through ONE path, not both</li>
<li>Default receptors (no <code>[FireAt]</code>) fire ONCE per path</li>
<li><code>[FireAt]</code> attributes opt into specific stages and OUT of default behavior</li>
</ul>
<p>At each stage, <strong>lifecycle receptors</strong> can execute to:</p>
<ul><li>Track metrics and telemetry</li>
<li>Log diagnostic information</li>
<li>Synchronize integration tests</li>
<li>Trigger custom business logic</li>
<li>Implement cross-cutting concerns</li>
</ul>
<hr>

<h2>All 20 Lifecycle Stages</h2>

<h3>Immediate Stage</h3>

<h4><code>ImmediateAsync</code></h4>

<strong>Timing</strong>: Immediately after receptor <code>HandleAsync()</code> returns, before any database operations.

<strong>Use Cases</strong>:
<ul><li>Log command execution timing</li>
<li>Track user activity</li>
<li>Record metrics before persistence</li>
</ul>
<strong>Guarantees</strong>:
<ul><li>Fires in same transaction scope as receptor</li>
<li>No database writes have occurred yet</li>
<li>Errors propagate to caller</li>
</ul>
<strong>Example</strong>:
<pre><code class="language-csharp">[FireAt(LifecycleStage.ImmediateAsync)]
<p>public class CommandMetricsReceptor : IReceptor<ICommand> {</p>
<p>    private readonly IMetricsCollector _metrics;</p>

<p>    public ValueTask HandleAsync(ICommand cmd, CancellationToken ct) {</p>
<p>        _metrics.RecordCommand(cmd.GetType().Name);</p>
<p>        return ValueTask.CompletedTask;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h3>LocalImmediate Stages (2 stages) ⭐ NEW</h3>

<p>:::new</p>
<p>LocalImmediate stages are new in v1.0.0 and enable in-memory mediator-style message handling.</p>
<p>:::</p>

<h4><code>LocalImmediateInline</code> ⭐ <strong>Default Stage for Local Path</strong></h4>

<strong>Timing</strong>: After <code>DispatchAsync(message, local: true)</code> completes, blocking.

<strong>Use Cases</strong>:
<ul><li><strong>Business logic receptors</strong> (this is where your command handlers fire!)</li>
<li>Request-response patterns in same process</li>
<li>In-memory mediator workflows</li>
<li>Synchronous local dispatch</li>
</ul>
<strong>Guarantees</strong>:
<ul><li><strong>Blocking</strong> - dispatch waits for completion</li>
<li><strong>NO persistence</strong> - message never hits outbox/inbox</li>
<li><strong>Default stage</strong> for receptors WITHOUT <code>[FireAt]</code> on local path</li>
<li>Errors propagate to caller</li>
</ul>
<strong>Example</strong>:
<pre><code class="language-csharp">// Receptor WITHOUT [FireAt] fires here when dispatched locally!
<p>public class CreateTenantCommandHandler : IReceptor<CreateTenantCommand, TenantCreatedEvent> {</p>
<p>    public async ValueTask<TenantCreatedEvent> HandleAsync(CreateTenantCommand cmd, CancellationToken ct) {</p>
<p>        // Business logic executes at LocalImmediateInline stage</p>
<p>        var tenant = new Tenant(cmd.Name);</p>
<p>        await _dbContext.Tenants.AddAsync(tenant, ct);</p>
<p>        return new TenantCreatedEvent(tenant.Id);</p>
<p>    }</p>
<p>}</p>

<p>// Use local dispatch for in-process handling</p>
<p>await dispatcher.DispatchAsync(new CreateTenantCommand("Acme"), local: true);</p>
<p></code></pre></p>

<h4><code>LocalImmediateAsync</code></h4>

<strong>Timing</strong>: After <code>DispatchAsync(message, local: true)</code> completes, non-blocking.

<strong>Use Cases</strong>:
<ul><li>Non-critical logging after local dispatch</li>
<li>Fire-and-forget metrics</li>
<li>Background notifications</li>
</ul>
<strong>Guarantees</strong>:
<ul><li><strong>Non-blocking</strong> - dispatch returns immediately</li>
<li><strong>NO persistence</strong> - message never hits outbox/inbox</li>
<li>Runs via <code>Task.Run</code></li>
<li>Errors logged but don't affect caller</li>
</ul>
<strong>Example</strong>:
<pre><code class="language-csharp">[FireAt(LifecycleStage.LocalImmediateAsync)]
<p>public class LocalDispatchLogger : IReceptor<ICommand> {</p>
<p>    public ValueTask HandleAsync(ICommand cmd, CancellationToken ct) {</p>
<p>        Console.WriteLine($"Local dispatch completed for {cmd.GetType().Name}");</p>
<p>        return ValueTask.CompletedTask;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h3>Distribute Stages (5 stages)</h3>

<h4><code>PreDistributeInline</code></h4>

<strong>Timing</strong>: Before <code>ProcessWorkBatchAsync()</code> call in unit of work strategy.

<strong>Use Cases</strong>:
<ul><li>Pre-processing before batch distribution</li>
<li>Validation before work coordination</li>
</ul>
<strong>Guarantees</strong>:
<ul><li>Blocking - distribution waits for completion</li>
<li>Runs before any work is sent to coordinator</li>
</ul>
<h4><code>PreDistributeAsync</code></h4>

<strong>Timing</strong>: Before <code>ProcessWorkBatchAsync()</code> call in unit of work strategy (non-blocking, backgrounded).

<strong>Use Cases</strong>:
<ul><li>Non-critical logging before batch distribution</li>
<li>Async metrics collection</li>
<li>Pre-distribution notifications</li>
</ul>
<strong>Guarantees</strong>:
<ul><li>Non-blocking - fires in background via <code>Task.Run</code></li>
<li>Errors are logged but don't affect distribution</li>
<li>May still be running when distribution occurs</li>
</ul>
<h4><code>DistributeAsync</code></h4>

<strong>Timing</strong>: In parallel with <code>ProcessWorkBatchAsync()</code> call (non-blocking, backgrounded).

<strong>Use Cases</strong>:
<ul><li>Side effects that don't need to block (notifications, caching)</li>
<li>Fire-and-forget operations</li>
<li>Background metrics collection</li>
</ul>
<strong>Guarantees</strong>:
<ul><li>Non-blocking - fires in background via <code>Task.Run</code></li>
<li>Errors are logged but don't affect distribution</li>
<li>May complete after distribution finishes</li>
</ul>
<h4><code>PostDistributeAsync</code></h4>

<strong>Timing</strong>: After <code>ProcessWorkBatchAsync()</code> completes (non-blocking, backgrounded).

<strong>Use Cases</strong>:
<ul><li>Post-distribution metrics</li>
<li>Cleanup operations</li>
<li>Async notifications</li>
</ul>
<strong>Guarantees</strong>:
<ul><li>Non-blocking - fires in background via <code>Task.Run</code></li>
<li>Errors are logged but don't affect next steps</li>
<li>Work has been queued to coordinator</li>
</ul>
<h4><code>PostDistributeInline</code></h4>

<strong>Timing</strong>: After <code>ProcessWorkBatchAsync()</code> completes (blocking).

<strong>Use Cases</strong>:
<ul><li>Synchronization points in tests</li>
<li>Critical post-distribution validation</li>
</ul>
<strong>Guarantees</strong>:
<ul><li>Blocking - next step waits for completion</li>
<li>Work has been queued to coordinator</li>
</ul>
<hr>

<h3>Outbox Stages (4 stages)</h3>

<h4><code>PreOutboxInline</code> ⭐ <strong>Default Stage for Distributed Sender</strong></h4>

<strong>Timing</strong>: Before publishing message to transport (Service Bus, RabbitMQ, etc.).

<strong>Use Cases</strong>:
<ul><li><strong>Business logic receptors</strong> (this is where your command handlers fire on sender side!)</li>
<li>Pre-publish validation</li>
<li>Message enrichment</li>
<li>Transport-specific preparation</li>
</ul>
<strong>Guarantees</strong>:
<ul><li><strong>Blocking</strong> - publish waits for completion</li>
<li>Message not yet sent to transport</li>
<li><strong>Default stage</strong> for receptors WITHOUT <code>[FireAt]</code> on distributed path (sender side)</li>
</ul>
<h4><code>PreOutboxAsync</code></h4>

<strong>Timing</strong>: Parallel with transport publish (non-blocking).

<strong>Use Cases</strong>:
<ul><li>Async logging of outbound messages</li>
<li>Non-critical metrics</li>
</ul>
<strong>Guarantees</strong>:
<ul><li>Non-blocking - publish continues in parallel</li>
<li>Message may already be sent when receptor completes</li>
</ul>
<h4><code>PostOutboxAsync</code></h4>

<strong>Timing</strong>: After message published to transport (non-blocking).

<strong>Use Cases</strong>:
<ul><li>Delivery confirmation logging</li>
<li>Success metrics</li>
</ul>
<strong>Guarantees</strong>:
<ul><li>Non-blocking</li>
<li>Message successfully published to transport</li>
</ul>
<h4><code>PostOutboxInline</code></h4>

<strong>Timing</strong>: After message published to transport (blocking).

<strong>Use Cases</strong>:
<ul><li>Test synchronization for message publishing</li>
<li>Critical post-publish operations</li>
</ul>
<strong>Guarantees</strong>:
<ul><li>Blocking</li>
<li>Message successfully published to transport</li>
</ul>
<hr>

<h3>Inbox Stages (4 stages)</h3>

<h4><code>PreInboxInline</code></h4>

<strong>Timing</strong>: Before invoking local receptor for received message.

<strong>Use Cases</strong>:
<ul><li>Pre-processing received messages</li>
<li>Validation before handler invocation</li>
<li>Message deduplication checks</li>
</ul>
<strong>Guarantees</strong>:
<ul><li>Blocking - receptor invocation waits</li>
<li>Message received from transport but not yet processed</li>
</ul>
<h4><code>PreInboxAsync</code></h4>

<strong>Timing</strong>: Parallel with receptor invocation (non-blocking).

<strong>Use Cases</strong>:
<ul><li>Async logging of inbound messages</li>
<li>Non-critical metrics</li>
</ul>
<strong>Guarantees</strong>:
<ul><li>Non-blocking - receptor invocation continues in parallel</li>
<li>Receptor may complete before this stage finishes</li>
</ul>
<h4><code>PostInboxAsync</code></h4>

<strong>Timing</strong>: After receptor completes (non-blocking).

<strong>Use Cases</strong>:
<ul><li>Post-processing metrics</li>
<li>Success logging</li>
</ul>
<strong>Guarantees</strong>:
<ul><li>Non-blocking</li>
<li>Receptor has completed successfully</li>
</ul>
<h4><code>PostInboxInline</code> ⭐ <strong>Default Stage for Distributed Receiver</strong></h4>

<strong>Timing</strong>: After message received from transport and stored in inbox (blocking).

<strong>Use Cases</strong>:
<ul><li><strong>Business logic receptors</strong> (this is where your command handlers fire on receiver side!)</li>
<li>Test synchronization for message reception</li>
<li>Critical post-processing</li>
</ul>
<strong>Guarantees</strong>:
<ul><li><strong>Blocking</strong> - completion waits for all handlers</li>
<li>Message stored in inbox and deduplicated</li>
<li><strong>Default stage</strong> for receptors WITHOUT <code>[FireAt]</code> on distributed path (receiver side)</li>
</ul>
<hr>

<h3>Perspective Stages (4 stages)</h3>

<p>:::new</p>
<p>Perspective lifecycle stages are new in v1.0.0 and enable deterministic test synchronization.</p>
<p>:::</p>

<h4><code>PrePerspectiveInline</code></h4>

<strong>Timing</strong>: Before perspective <code>RunAsync()</code> processes events.

<strong>Use Cases</strong>:
<ul><li>Pre-processing before perspective updates</li>
<li>Checkpoint validation</li>
<li>Event enrichment</li>
</ul>
<strong>Guarantees</strong>:
<ul><li>Blocking - perspective processing waits</li>
<li>No events processed yet</li>
</ul>
<strong>Hook Location</strong>: Generated perspective runner (from <code>PerspectiveRunnerTemplate.cs</code>) before event processing loop begins

<h4><code>PrePerspectiveAsync</code></h4>

<strong>Timing</strong>: Parallel with perspective <code>RunAsync()</code> (non-blocking).

<strong>Use Cases</strong>:
<ul><li>Async logging</li>
<li>Non-critical metrics</li>
</ul>
<strong>Guarantees</strong>:
<ul><li>Non-blocking - perspective continues in parallel</li>
<li>Perspective may complete before this stage finishes</li>
</ul>
<strong>Hook Location</strong>: Generated perspective runner (from <code>PerspectiveRunnerTemplate.cs</code>) before event processing loop begins

<h4><code>PostPerspectiveAsync</code></h4>

<strong>Timing</strong>: After perspective completes, before checkpoint reported (non-blocking).

<strong>Use Cases</strong>:
<ul><li>Post-processing metrics</li>
<li>Event logging</li>
<li>Custom indexing</li>
</ul>
<strong>Guarantees</strong>:
<ul><li>Non-blocking</li>
<li>Perspective has processed all events</li>
<li>Checkpoint not yet reported to coordinator</li>
</ul>
<strong>Hook Location</strong>: Generated perspective runner (from <code>PerspectiveRunnerTemplate.cs</code>) during event processing loop, after <code>Apply()</code> and before checkpoint save

<strong>Example</strong>:
<pre><code class="language-csharp">[FireAt(LifecycleStage.PostPerspectiveAsync)]
<p>public class PerspectiveMetricsReceptor : IReceptor<IEvent> {</p>
<p>    private readonly IMetricsCollector _metrics;</p>

<p>    public ValueTask HandleAsync(IEvent evt, CancellationToken ct) {</p>
<p>        _metrics.RecordPerspectiveUpdate(evt.GetType().Name);</p>
<p>        return ValueTask.CompletedTask;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h4><code>PostPerspectiveInline</code> ⭐ <strong>Critical for Testing</strong></h4>

<strong>Timing</strong>: After perspective completes, before checkpoint reported (blocking).

<strong>Use Cases</strong>:
<ul><li><strong>Test synchronization</strong> - wait for perspective data to be saved</li>
<li>Critical post-processing that must complete before checkpoint</li>
</ul>
<strong>Guarantees</strong>:
<ul><li><strong>Blocking</strong> - checkpoint reporting waits for completion</li>
<li>Perspective has processed all events</li>
<li><strong>Database writes are committed</strong> - safe to query perspective data</li>
<li>Checkpoint not yet reported to coordinator</li>
</ul>
<strong>Hook Location</strong>: Generated perspective runner (from <code>PerspectiveRunnerTemplate.cs</code>) during event processing loop, after <code>Apply()</code> and before checkpoint save

<strong>Example</strong> (Test Synchronization):
<pre><code class="language-csharp">[FireAt(LifecycleStage.PostPerspectiveInline)]
<p>public class PerspectiveCompletionReceptor<TEvent> : IReceptor<TEvent></p>
<p>    where TEvent : IEvent {</p>

<p>    private readonly TaskCompletionSource<bool> _completion;</p>

<p>    public ValueTask HandleAsync(TEvent evt, CancellationToken ct) {</p>
<p>        _completion.SetResult(true);  // Signal test to proceed</p>
<p>        return ValueTask.CompletedTask;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<p>See <a href="../testing/lifecycle-synchronization.md">Lifecycle Synchronization</a> for complete test patterns.</p>

<hr>

<h2>Lifecycle Stage Timing Diagram</h2>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant Caller</p>
<p>    participant Receptor</p>
<p>    participant UOW as Unit of Work</p>
<p>    participant Coordinator as Work Coordinator</p>
<p>    participant Worker</p>
<p>    participant Perspective</p>

<p>    Note over Caller,Perspective: Dispatch Phase</p>
<p>    Caller->>Receptor: SendAsync(command)</p>
<p>    Receptor-->>Receptor: HandleAsync()</p>
<p>    Note right of Receptor: ImmediateAsync fires here</p>
<p>    Receptor->>UOW: SaveChangesAsync()</p>

<p>    Note over UOW,Coordinator: Distribute Phase</p>
<p>    Note right of UOW: PreDistributeInline</p>
<p>    UOW->>Coordinator: ProcessWorkBatchAsync()</p>
<p>    Note right of UOW: PostDistributeInline</p>

<p>    Note over Worker,Perspective: Outbox Phase</p>
<p>    Note right of Worker: PreOutboxInline</p>
<p>    Worker->>Transport: Publish()</p>
<p>    Note right of Worker: PostOutboxInline</p>

<p>    Note over Worker,Perspective: Inbox Phase</p>
<p>    Transport->>Worker: Receive()</p>
<p>    Note right of Worker: PreInboxInline</p>
<p>    Worker->>Receptor: HandleAsync()</p>
<p>    Note right of Worker: PostInboxInline</p>

<p>    Note over Worker,Perspective: Perspective Phase</p>
<p>    Note right of Worker: PrePerspectiveInline</p>
<p>    Worker->>Perspective: RunAsync()</p>
<p>    Perspective-->>Perspective: Apply events</p>
<p>    Note right of Worker: PostPerspectiveInline ⭐</p>
<p>    Worker->>Coordinator: ReportCompletionAsync()</p>
<p></code></pre></p>

<hr>

<h2>Async vs Inline Stages</h2>

<p>Most lifecycle stages come in pairs:</p>

<p>| Stage Type | Timing | Blocks Next Step | Use Case |</p>
<p>|------------|--------|------------------|----------|</p>
<p>| <code>*Inline</code> | Before/After | ✅ Yes | Critical operations, test sync |</p>
<p>| <code>*Async</code> | Parallel | ❌ No | Metrics, logging, non-critical |</p>

<strong>Guidelines</strong>:
<ul><li><strong>Use Inline</strong> for: Test synchronization, validation, critical operations</li>
<li><strong>Use Async</strong> for: Logging, metrics, observability</li>
</ul>
<hr>

<h2>Registering Lifecycle Receptors</h2>

<h3>Compile-Time (Production)</h3>

<p>Use <code>[FireAt]</code> attribute for compile-time registration:</p>

<pre><code class="language-csharp">[FireAt(LifecycleStage.PostPerspectiveAsync)]
<p>public class MyMetricsReceptor : IReceptor<ProductCreatedEvent> {</p>
<p>    public ValueTask HandleAsync(ProductCreatedEvent evt, CancellationToken ct) {</p>
<p>        // Track metrics</p>
<p>        return ValueTask.CompletedTask;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<p>Source generators discover and wire these automatically.</p>

<h3>Runtime (Testing)</h3>

<p>Use <code>ILifecycleReceptorRegistry</code> for dynamic registration:</p>

<pre><code class="language-csharp">var registry = host.Services.GetRequiredService<ILifecycleReceptorRegistry>();
<p>var receptor = new PerspectiveCompletionReceptor<ProductCreatedEvent>(completionSource);</p>

<p>registry.Register<ProductCreatedEvent>(receptor, LifecycleStage.PostPerspectiveInline);</p>
<p>try {</p>
<p>    // Dispatch command</p>
<p>    await dispatcher.SendAsync(command);</p>

<p>    // Wait for completion</p>
<p>    await completionSource.Task;</p>
<p>} finally {</p>
<p>    registry.Unregister<ProductCreatedEvent>(receptor, LifecycleStage.PostPerspectiveInline);</p>
<p>}</p>
<p></code></pre></p>

<p>See <a href="lifecycle-receptors.md">Lifecycle Receptors</a> for API details.</p>

<hr>

<h2>Performance Considerations</h2>

<strong>Lifecycle receptors execute synchronously in the message processing path</strong>. Keep them fast:

<p>✅ <strong>Good Practices</strong>:</p>
<ul><li>Quick in-memory operations</li>
<li>Async logging (non-blocking)</li>
<li>Metrics collection</li>
<li>Test signaling</li>
</ul>
<p>❌ <strong>Avoid</strong>:</p>
<ul><li>Database queries</li>
<li>HTTP calls</li>
<li>Heavy computation</li>
<li>Blocking operations (in Async stages)</li>
</ul>
<strong>Exception Handling</strong>:
<ul><li>Lifecycle receptor errors are logged but don't fail message processing</li>
<li>Checkpoint progress continues even if lifecycle receptors fail</li>
<li>Critical operations should use Inline stages to detect failures</li>
</ul>
<hr>

<h2>Hook Locations in Source Code</h2>

<p>| Stage | File | Method/Location |</p>
<p>|-------|------|-----------------|</p>
<p>| <code>ImmediateAsync</code> | <code>Dispatcher.cs</code> | After receptor <code>HandleAsync()</code> |</p>
<p>| <code>PreDistribute<em></code> / <code>DistributeAsync</code> / <code>PostDistribute</em></code> | <code>*WorkCoordinatorStrategy.cs</code> | Around <code>ProcessWorkBatchAsync()</code> (Immediate/Scoped/Interval) |</p>
<p>| <code>PreOutbox<em></code> / <code>PostOutbox</em></code> | <code>WorkCoordinatorPublisherWorker.cs</code> | Around <code>ProcessOutboxWorkAsync()</code> |</p>
<p>| <code>PreInbox<em></code> / <code>PostInbox</em></code> | <code>ServiceBusConsumerWorker.cs</code> | Around <code>ProcessInboxWorkAsync()</code> |</p>
<p>| <code>PrePerspective*</code> | <code>PerspectiveRunnerTemplate.cs</code> | Before event processing loop |</p>
<p>| <code>PostPerspective*</code> | <code>PerspectiveRunnerTemplate.cs</code> | During event processing loop (after <code>Apply()</code>, before checkpoint save) |</p>

<hr>

<h2>Related Topics</h2>

<ul><li><a href="lifecycle-receptors.md">Lifecycle Receptors API</a> - Using <code>[FireAt]</code> and <code>ILifecycleContext</code></li>
<li><a href="receptors.md">Receptors Guide</a> - Core receptor concepts</li>
<li><a href="../testing/lifecycle-synchronization.md">Testing: Lifecycle Synchronization</a> - Test patterns with lifecycle hooks</li>
<li><a href="../workers/perspective-worker.md">PerspectiveWorker</a> - Perspective processing worker</li>
<li><a href="../workers/work-coordination.md">Work Coordination</a> - Distributed work coordination</li>
</ul>
<hr>

<h2>Summary</h2>

<ul><li><strong>20 lifecycle stages</strong> across 6 phases (Immediate, LocalImmediate, Distribute, Outbox, Inbox, Perspective)</li>
<li><strong>Two mutually exclusive paths</strong>: Local (mediator) and Distributed (outbox/inbox)</li>
<li><strong>Default stages</strong> for receptors without <code>[FireAt]</code>:</li>
</ul><p>  - <strong>Local path</strong>: <code>LocalImmediateInline</code></p>
<p>  - <strong>Distributed path</strong>: <code>PreOutboxInline</code> (sender) + <code>PostInboxInline</code> (receiver)</p>
<ul><li><strong>Inline stages</strong> block next step - use for critical operations</li>
<li><strong>Async stages</strong> run in parallel - use for metrics and logging</li>
<li><strong><code>PostPerspectiveInline</code></strong> is critical for test synchronization</li>
<li><strong>Compile-time registration</strong> via <code>[FireAt]</code> attribute</li>
<li><strong>Runtime registration</strong> via <code>ILifecycleReceptorRegistry</code> for tests</li>
<li><strong>Zero reflection</strong> - fully AOT-compatible via <code>IReceptorInvoker</code> and <code>IReceptorRegistry</code></li>
<li><strong>Performance</strong> - keep lifecycle receptors fast and lightweight</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-message-context" class="doc-section">
  <h3>Message Context &amp; Tracing</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/message-context</code></p>
  <p class="doc-description"><em>Track message flow across distributed systems with MessageId, CorrelationId, and CausationId - automatic distributed tracing built into Whizbang</em></p>
  <div class="doc-content">

<h1>Message Context & Tracing</h1>

<p>Whizbang provides automatic <strong>distributed tracing</strong> through three key identifiers: <strong>MessageId</strong>, <strong>CorrelationId</strong>, and <strong>CausationId</strong>. These track message relationships across services, enabling powerful observability and debugging.</p>

<h2>Core Identifiers</h2>

<p>| Identifier | Purpose | Analogy |</p>
<p>|------------|---------|---------|</p>
<p>| <code>MessageId</code> | Unique ID for this message | Social Security Number (unique per person) |</p>
<p>| <code>CorrelationId</code> | Groups related messages in a workflow | Family ID (groups related people) |</p>
<p>| <code>CausationId</code> | Parent message that caused this message | Parent ID (who caused this person to exist) |</p>

<h3>Visual Example</h3>

<pre><code class="language-">User clicks "Create Order" button
<p>         ↓</p>
<p>┌────────────────────────────────────────────────────────────┐</p>
<p>│ CreateOrder Command                                         │</p>
<p>│ MessageId:     msg-001                                      │</p>
<p>│ CorrelationId: corr-abc (generated for this workflow)     │</p>
<p>│ CausationId:   null (no parent)                            │</p>
<p>└─────────────┬──────────────────────────────────────────────┘</p>
<p>              │</p>
<p>              │ OrderReceptor processes command</p>
<p>              ↓</p>
<p>┌────────────────────────────────────────────────────────────┐</p>
<p>│ OrderCreated Event                                          │</p>
<p>│ MessageId:     msg-002                                      │</p>
<p>│ CorrelationId: corr-abc (same as command)                 │</p>
<p>│ CausationId:   msg-001 (caused by CreateOrder)            │</p>
<p>└─────────────┬──────────────────────────────────────────────┘</p>
<p>              │</p>
<p>              │ Publishes to Azure Service Bus</p>
<p>              ↓</p>
<p>    ┌─────────────────┬─────────────────┬──────────────────┐</p>
<p>    │                 │                 │                  │</p>
<p>    ↓                 ↓                 ↓                  ↓</p>
<p>┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌──────────────┐</p>
<p>│ Inventory   │  │ Payment     │  │ Shipping    │  │ Notification │</p>
<p>│ Worker      │  │ Worker      │  │ Worker      │  │ Worker       │</p>
<p>└─────────────┘  └─────────────┘  └─────────────┘  └──────────────┘</p>
<p>      │                │                │                │</p>
<p>      ↓                ↓                ↓                ↓</p>
<p>┌────────────┐  ┌────────────┐  ┌────────────┐  ┌────────────┐</p>
<p>│ Inventory  │  │ Payment    │  │ Shipment   │  │ Email      │</p>
<p>│ Reserved   │  │ Processed  │  │ Created    │  │ Sent       │</p>
<p>│            │  │            │  │            │  │            │</p>
<p>│ corr-abc   │  │ corr-abc   │  │ corr-abc   │  │ corr-abc   │</p>
<p>│ msg-002    │  │ msg-002    │  │ msg-002    │  │ msg-002    │</p>
<p>└────────────┘  └────────────┘  └────────────┘  └────────────┘</p>
<p></code></pre></p>

<strong>All events share <code>corr-abc</code> - enabling you to query all messages in this workflow!</strong>

<hr>

<h2>MessageId</h2>

<strong>Purpose</strong>: Unique identifier for each message (never reused).

<strong>Type</strong>: Strongly-typed value object using UUIDv7.

<pre><code class="language-csharp">public record struct MessageId(Guid Value) {
<p>    public static MessageId New() => new(Guid.CreateVersion7());</p>

<p>    public override string ToString() => Value.ToString();</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Characteristics</strong>:
<ul><li><strong>Globally unique</strong>: No two messages ever have the same ID</li>
<li><strong>Time-ordered</strong>: UUIDv7 includes timestamp, sortable by creation time</li>
<li><strong>Database-friendly</strong>: Primary keys using MessageId don't fragment indexes</li>
<li><strong>Immutable</strong>: Once created, never changes</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-csharp">// Whizbang creates MessageId automatically
<p>var receipt = await _dispatcher.SendAsync(command);</p>

<p>Console.WriteLine($"Message ID: {receipt.MessageId}");</p>
<p>// Output: Message ID: 018d8f8e-1234-7890-abcd-ef1234567890</p>
<p></code></pre></p>

<strong>You rarely create MessageId manually - Whizbang handles this.</strong>

<hr>

<h2>CorrelationId</h2>

<strong>Purpose</strong>: Groups all messages related to the same workflow/transaction.

<strong>Type</strong>: Strongly-typed value object using UUIDv7.

<pre><code class="language-csharp">public record struct CorrelationId(Guid Value) {
<p>    public static CorrelationId New() => new(Guid.CreateVersion7());</p>

<p>    public override string ToString() => Value.ToString();</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Characteristics</strong>:
<ul><li><strong>Workflow identifier</strong>: All messages in same workflow share same CorrelationId</li>
<li><strong>Cross-service</strong>: Spans multiple services, receptors, perspectives</li>
<li><strong>Queryable</strong>: Find all messages for a specific customer action</li>
<li><strong>Persistent</strong>: Stored in database, logs, telemetry</li>
</ul>
<h3>How CorrelationId Flows</h3>

<pre><code class="language-">1. User Request → HTTP Request
<p>   CorrelationId: NEW (generated by API)</p>

<ul><li>CreateOrder Command</li>
</ul><p>   CorrelationId: INHERITED from HTTP request</p>

<ul><li>OrderCreated Event</li>
</ul><p>   CorrelationId: INHERITED from CreateOrder</p>

<ul><li>InventoryReserved Event (in different service)</li>
</ul><p>   CorrelationId: INHERITED from OrderCreated</p>

<ul><li>PaymentProcessed Event (in different service)</li>
</ul><p>   CorrelationId: INHERITED from InventoryReserved</p>

<p>... and so on</p>
<p></code></pre></p>

<strong>All messages inherit the same CorrelationId!</strong>

<h3>Usage</h3>

<pre><code class="language-csharp">// Create new correlation for HTTP request
<p>var correlationId = CorrelationId.New();</p>

<p>// Store in HTTP context</p>
<p>HttpContext.Items["CorrelationId"] = correlationId;</p>

<p>// Whizbang dispatcher automatically propagates it</p>
<p>var command = new CreateOrder(customerId, items);</p>
<p>var result = await _dispatcher.LocalInvokeAsync<CreateOrder, OrderCreated>(command);</p>

<p>// Result has same CorrelationId!</p>
<p>Console.WriteLine($"Correlation ID: {result.CorrelationId}");</p>
<p></code></pre></p>

<h3>Querying by CorrelationId</h3>

<pre><code class="language-csharp">// Find all messages in a workflow
<p>public async Task<Message[]> GetWorkflowMessagesAsync(</p>
<p>    CorrelationId correlationId,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    // Assuming messages are stored in event store</p>
<p>    var messages = await conn.QueryAsync<Message>(</p>
<p>        """</p>
<p>        SELECT * FROM wh_event_store</p>
<p>        WHERE correlation_id = @CorrelationId</p>
<p>        ORDER BY created_at</p>
<p>        """,</p>
<p>        new { CorrelationId = correlationId.Value },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    return messages.ToArray();</p>
<p>}</p>
<p></code></pre></p>

<strong>Result</strong>: Complete trace of every message in the workflow!

<hr>

<h2>CausationId</h2>

<strong>Purpose</strong>: Identifies the <strong>parent message</strong> that caused this message to exist.

<strong>Type</strong>: Strongly-typed value object using Guid (refers to a MessageId).

<pre><code class="language-csharp">public record struct CausationId(Guid Value) {
<p>    public static CausationId From(MessageId messageId) => new(messageId.Value);</p>

<p>    public override string ToString() => Value.ToString();</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Characteristics</strong>:
<ul><li><strong>Parent-child relationship</strong>: Links message to its creator</li>
<li><strong>Causality chain</strong>: Track how one message led to another</li>
<li><strong>Debugging</strong>: "What caused this message to be created?"</li>
<li><strong>Nullable</strong>: Root messages (HTTP requests) have no parent</li>
</ul>
<h3>Causation Chain Example</h3>

<pre><code class="language-">CreateOrder Command
<p>├─ MessageId:     msg-001</p>
<p>├─ CorrelationId: corr-abc</p>
<p>└─ CausationId:   null (no parent)</p>

<p>      ↓ Creates ↓</p>

<p>OrderCreated Event</p>
<p>├─ MessageId:     msg-002</p>
<p>├─ CorrelationId: corr-abc</p>
<p>└─ CausationId:   msg-001 (caused by CreateOrder)</p>

<p>      ↓ Creates ↓</p>

<p>InventoryReserved Event</p>
<p>├─ MessageId:     msg-003</p>
<p>├─ CorrelationId: corr-abc</p>
<p>└─ CausationId:   msg-002 (caused by OrderCreated)</p>

<p>      ↓ Creates ↓</p>

<p>PaymentProcessed Event</p>
<p>├─ MessageId:     msg-004</p>
<p>├─ CorrelationId: corr-abc</p>
<p>└─ CausationId:   msg-003 (caused by InventoryReserved)</p>
<p></code></pre></p>

<strong>Causation chain</strong>: msg-001 → msg-002 → msg-003 → msg-004

<h3>Usage</h3>

<pre><code class="language-csharp">// Receptor creates event with causation
<p>public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        // Business logic...</p>

<p>        return new OrderCreated(</p>
<p>            MessageId: MessageId.New(),              // New unique ID</p>
<p>            CorrelationId: message.CorrelationId,    // Inherit correlation</p>
<p>            CausationId: CausationId.From(message.MessageId),  // Parent is CreateOrder</p>
<p>            OrderId: Guid.CreateVersion7(),</p>
<p>            CustomerId: message.CustomerId,</p>
<p>            Items: message.Items,</p>
<p>            Total: CalculateTotal(message.Items),</p>
<p>            CreatedAt: DateTimeOffset.UtcNow</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang handles this automatically via MessageEnvelope!</strong>

<hr>

<h2>MessageEnvelope</h2>

<p>Whizbang wraps all messages in a <strong>MessageEnvelope</strong> containing context:</p>

<pre><code class="language-csharp">public class MessageEnvelope {
<p>    public MessageId MessageId { get; init; }</p>
<p>    public CorrelationId CorrelationId { get; init; }</p>
<p>    public CausationId? CausationId { get; init; }</p>
<p>    public object Payload { get; init; }  // Your actual message</p>
<p>    public List<MessageHop> Hops { get; init; }  // Trace hops</p>
<p>    public DateTimeOffset CreatedAt { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<strong>You rarely interact with MessageEnvelope directly</strong> - Whizbang manages it transparently.

<h3>Automatic Context Propagation</h3>

<pre><code class="language-csharp">// 1. HTTP Request arrives
<p>[HttpPost("orders")]</p>
<p>public async Task<ActionResult> CreateOrder(</p>
<p>    [FromBody] CreateOrderRequest request,</p>
<p>    CancellationToken ct) {</p>

<p>    // 2. Create command (Whizbang generates MessageId, CorrelationId)</p>
<p>    var command = new CreateOrder(request.CustomerId, request.Items);</p>

<p>    // 3. Dispatch command</p>
<p>    var result = await _dispatcher.LocalInvokeAsync<CreateOrder, OrderCreated>(command, ct);</p>

<p>    // 4. Result event has:</p>
<p>    //    - New MessageId (unique)</p>
<p>    //    - Same CorrelationId (inherited)</p>
<p>    //    - CausationId = command.MessageId (parent reference)</p>

<p>    return CreatedAtAction(nameof(GetOrder), new { orderId = result.OrderId }, result);</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang automatically</strong>:
<ul><li>Generates MessageId for command</li>
<li>Generates CorrelationId (or inherits from HTTP context)</li>
<li>Sets CausationId to command's MessageId when creating event</li>
</ul>
<hr>

<h2>Distributed Tracing</h2>

<h3>Querying Workflow History</h3>

<pre><code class="language-csharp">public class WorkflowTracer {
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public async Task<WorkflowTrace> TraceWorkflowAsync(</p>
<p>        CorrelationId correlationId,</p>
<p>        CancellationToken ct = default) {</p>

<p>        await using var conn = _db.CreateConnection();</p>

<p>        // Get all messages in workflow</p>
<p>        var messages = await conn.QueryAsync<TraceMessage>(</p>
<p>            """</p>
<p>            SELECT</p>
<p>                message_id,</p>
<p>                causation_id,</p>
<p>                message_type,</p>
<p>                created_at,</p>
<p>                payload</p>
<p>            FROM wh_event_store</p>
<p>            WHERE correlation_id = @CorrelationId</p>
<p>            ORDER BY created_at</p>
<p>            """,</p>
<p>            new { CorrelationId = correlationId.Value },</p>
<p>            cancellationToken: ct</p>
<p>        );</p>

<p>        return new WorkflowTrace(</p>
<p>            CorrelationId: correlationId,</p>
<p>            Messages: messages.ToArray()</p>
<p>        );</p>
<p>    }</p>
<p>}</p>

<p>public record WorkflowTrace(</p>
<p>    CorrelationId CorrelationId,</p>
<p>    TraceMessage[] Messages</p>
<p>) {</p>
<p>    public void PrintTrace() {</p>
<p>        Console.WriteLine($"Workflow: {CorrelationId}");</p>
<p>        foreach (var msg in Messages) {</p>
<p>            Console.WriteLine($"  {msg.CreatedAt:yyyy-MM-dd HH:mm:ss.fff} | {msg.MessageType}");</p>
<p>            if (msg.CausationId is not null) {</p>
<p>                Console.WriteLine($"    Caused by: {msg.CausationId}");</p>
<p>            }</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Output</strong>:
<pre><code class="language-">Workflow: corr-abc
<p>  2024-12-12 10:00:00.123 | CreateOrder</p>
<p>  2024-12-12 10:00:00.456 | OrderCreated</p>
<p>    Caused by: msg-001</p>
<p>  2024-12-12 10:00:01.234 | InventoryReserved</p>
<p>    Caused by: msg-002</p>
<p>  2024-12-12 10:00:02.567 | PaymentProcessed</p>
<p>    Caused by: msg-003</p>
<p>  2024-12-12 10:00:03.890 | ShipmentCreated</p>
<p>    Caused by: msg-004</p>
<p></code></pre></p>

<h3>Visualizing Causation Chains</h3>

<pre><code class="language-csharp">public class CausationVisualizer {
<p>    public void VisualizeCausationChain(TraceMessage[] messages) {</p>
<p>        var messageMap = messages.ToDictionary(m => m.MessageId);</p>

<p>        foreach (var msg in messages) {</p>
<p>            PrintMessageWithIndent(msg, messageMap, indent: 0);</p>
<p>        }</p>
<p>    }</p>

<p>    private void PrintMessageWithIndent(</p>
<p>        TraceMessage msg,</p>
<p>        Dictionary<Guid, TraceMessage> map,</p>
<p>        int indent) {</p>

<p>        var prefix = new string(' ', indent * 2);</p>
<p>        Console.WriteLine($"{prefix}├─ {msg.MessageType} ({msg.MessageId})");</p>

<p>        // Find children (messages caused by this message)</p>
<p>        var children = map.Values</p>
<p>            .Where(m => m.CausationId == msg.MessageId)</p>
<p>            .ToArray();</p>

<p>        foreach (var child in children) {</p>
<p>            PrintMessageWithIndent(child, map, indent + 1);</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Output</strong>:
<pre><code class="language-">├─ CreateOrder (msg-001)
<p>  ├─ OrderCreated (msg-002)</p>
<p>    ├─ InventoryReserved (msg-003)</p>
<p>      ├─ PaymentProcessed (msg-004)</p>
<p>        ├─ ShipmentCreated (msg-005)</p>
<p>          ├─ NotificationSent (msg-006)</p>
<p></code></pre></p>

<hr>

<h2>Integration with Logging</h2>

<h3>Structured Logging</h3>

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>    private readonly ILogger<CreateOrderReceptor> _logger;</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        // Log with correlation and causation context</p>
<p>        using (_logger.BeginScope(new Dictionary<string, object> {</p>
<p>            ["CorrelationId"] = message.CorrelationId,</p>
<p>            ["CausationId"] = message.CausationId?.ToString() ?? "null",</p>
<p>            ["MessageId"] = message.MessageId</p>
<p>        })) {</p>
<p>            _logger.LogInformation(</p>
<p>                "Processing CreateOrder for customer {CustomerId}",</p>
<p>                message.CustomerId</p>
<p>            );</p>

<p>            // Business logic...</p>

<p>            _logger.LogInformation(</p>
<p>                "Order {OrderId} created successfully",</p>
<p>                orderId</p>
<p>            );</p>

<p>            return new OrderCreated(/<em> ... </em>/);</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Log Output</strong> (JSON format):
<pre><code class="language-json">{
<p>  "Timestamp": "2024-12-12T10:00:00.123Z",</p>
<p>  "Level": "Information",</p>
<p>  "Message": "Processing CreateOrder for customer 550e8400-e29b-41d4-a716-446655440000",</p>
<p>  "CorrelationId": "corr-abc",</p>
<p>  "CausationId": "null",</p>
<p>  "MessageId": "msg-001"</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefit</strong>: Query logs by CorrelationId to see all log entries for a workflow!

<h3>Application Insights Integration</h3>

<pre><code class="language-csharp">public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>    private readonly TelemetryClient _telemetry;</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        using var operation = _telemetry.StartOperation<RequestTelemetry>("CreateOrder");</p>
<p>        operation.Telemetry.Properties["CorrelationId"] = message.CorrelationId.ToString();</p>
<p>        operation.Telemetry.Properties["CausationId"] = message.CausationId?.ToString() ?? "null";</p>
<p>        operation.Telemetry.Properties["MessageId"] = message.MessageId.ToString();</p>

<p>        try {</p>
<p>            // Business logic...</p>

<p>            operation.Telemetry.Success = true;</p>
<p>            return new OrderCreated(/<em> ... </em>/);</p>

<p>        } catch (Exception ex) {</p>
<p>            operation.Telemetry.Success = false;</p>
<p>            _telemetry.TrackException(ex);</p>
<p>            throw;</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ Let Whizbang <strong>generate MessageId automatically</strong></li>
<li>✅ <strong>Inherit CorrelationId</strong> from parent message</li>
<li>✅ <strong>Set CausationId</strong> to parent's MessageId</li>
<li>✅ <strong>Log CorrelationId</strong> in structured logging</li>
<li>✅ <strong>Store CorrelationId</strong> in database for querying</li>
<li>✅ <strong>Use CorrelationId</strong> for end-to-end workflow tracing</li>
<li>✅ <strong>Use CausationId</strong> for debugging (what caused this?)</li>
<li>✅ <strong>Propagate CorrelationId</strong> across HTTP boundaries</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Reuse MessageId (must be unique per message)</li>
<li>❌ Change CorrelationId mid-workflow (breaks tracing)</li>
<li>❌ Forget to propagate CorrelationId across services</li>
<li>❌ Use CorrelationId as business identifier (use OrderId, etc.)</li>
<li>❌ Store MessageId in business entities (use domain IDs like OrderId)</li>
<li>❌ Skip logging CorrelationId (critical for debugging)</li>
</ul>
<hr>

<h2>HTTP Context Integration</h2>

<h3>ASP.NET Core Middleware</h3>

<pre><code class="language-csharp">public class CorrelationIdMiddleware {
<p>    private readonly RequestDelegate _next;</p>

<p>    public CorrelationIdMiddleware(RequestDelegate next) {</p>
<p>        _next = next;</p>
<p>    }</p>

<p>    public async Task InvokeAsync(HttpContext context) {</p>
<p>        // Extract or generate CorrelationId</p>
<p>        var correlationId = context.Request.Headers["X-Correlation-ID"].FirstOrDefault()</p>
<p>            ?? CorrelationId.New().ToString();</p>

<p>        // Store in HttpContext</p>
<p>        context.Items["CorrelationId"] = CorrelationId.Parse(correlationId);</p>

<p>        // Add to response headers</p>
<p>        context.Response.Headers["X-Correlation-ID"] = correlationId;</p>

<p>        await _next(context);</p>
<p>    }</p>
<p>}</p>

<p>// Register middleware</p>
<p>app.UseMiddleware<CorrelationIdMiddleware>();</p>
<p></code></pre></p>

<h3>Propagating to Downstream Services</h3>

<pre><code class="language-csharp">public class HttpClientWithCorrelation {
<p>    private readonly HttpClient _httpClient;</p>
<p>    private readonly IHttpContextAccessor _httpContext;</p>

<p>    public async Task<HttpResponseMessage> PostAsync(string url, HttpContent content) {</p>
<p>        // Get CorrelationId from current request</p>
<p>        var correlationId = _httpContext.HttpContext?.Items["CorrelationId"] as CorrelationId?</p>
<p>            ?? CorrelationId.New();</p>

<p>        // Add to outgoing request</p>
<p>        var request = new HttpRequestMessage(HttpMethod.Post, url) {</p>
<p>            Content = content</p>
<p>        };</p>
<p>        request.Headers.Add("X-Correlation-ID", correlationId.ToString());</p>

<p>        return await _httpClient.SendAsync(request);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Core Concepts</strong>:
<ul><li><a href="observability.md">Observability</a> - MessageEnvelope and hops for distributed tracing</li>
<li><a href="dispatcher.md">Dispatcher</a> - How messages are routed</li>
<li><a href="receptors.md">Receptors</a> - Message handlers</li>
</ul>
<strong>Messaging Patterns</strong>:
<ul><li><a href="../messaging/outbox-pattern.md">Outbox Pattern</a> - Reliable messaging with context</li>
<li><a href="../messaging/message-envelopes.md">Message Envelopes</a> - Hop-based observability</li>
</ul>
<strong>Infrastructure</strong>:
<ul><li><a href="../infrastructure/observability-setup.md">Logging & Telemetry</a> - Application Insights integration</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-message-security" class="doc-section">
  <h3>message security</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/message-security</code></p>
  <div class="doc-content">
<h1>Message Security Context Propagation</h1>

<p>Whizbang provides automatic security context establishment for incoming messages, ensuring that security identity flows across service boundaries in distributed systems.</p>

<h2>Overview</h2>

<p>When messages arrive from external transports (Azure Service Bus, RabbitMQ, etc.), security context must be established <strong>before</strong> any business logic executes. The message security system:</p>

<ul><li>Extracts security information from message hops, payloads, or transport metadata</li>
<li>Populates <code>IScopeContextAccessor.Current</code> for scoped services</li>
<li>Invokes callbacks for custom service initialization</li>
<li>Emits audit events for security compliance</li>
</ul>
<h2>Architecture</h2>

<pre><code class="language-">Message Arrives
<p>      │</p>
<p>      ▼</p>
<p>┌─────────────────────────────────────┐</p>
<p>│  IMessageSecurityContextProvider    │</p>
<p>│  (DefaultMessageSecurityContextProvider) │</p>
<p>└─────────────────────────────────────┘</p>
<p>      │</p>
<p>      ▼ Calls extractors in priority order</p>
<p>┌─────────────────────────────────────┐</p>
<p>│  ISecurityContextExtractor[]        │</p>
<p>│  • MessageHopSecurityExtractor (100)│</p>
<p>│  • JwtPayloadExtractor (200)        │</p>
<p>│  • TransportMetadataExtractor (300) │</p>
<p>└─────────────────────────────────────┘</p>
<p>      │</p>
<p>      ▼ First successful extraction wins</p>
<p>┌─────────────────────────────────────┐</p>
<p>│  ImmutableScopeContext              │</p>
<p>│  (wraps SecurityExtraction)         │</p>
<p>└─────────────────────────────────────┘</p>
<p>      │</p>
<p>      ├─▶ Populates IScopeContextAccessor.Current</p>
<p>      │</p>
<p>      ▼ Invokes callbacks</p>
<p>┌─────────────────────────────────────┐</p>
<p>│  ISecurityContextCallback[]         │</p>
<p>│  • UserContextManagerCallback       │</p>
<p>│  • AuditLogCallback                 │</p>
<p>└─────────────────────────────────────┘</p>
<p></code></pre></p>

<h2>Quick Start</h2>

<h3>Registration</h3>

<pre><code class="language-csharp">services.AddWhizbangMessageSecurity(options => {
<p>  // AllowAnonymous defaults to FALSE (least privilege)</p>
<p>  // Must explicitly opt-in to allow anonymous messages</p>
<p>  options.AllowAnonymous = false;</p>

<p>  // Exempt specific message types</p>
<p>  options.ExemptMessageTypes.Add(typeof(HealthCheckMessage));</p>
<p>  options.ExemptMessageTypes.Add(typeof(SystemDiagnosticMessage));</p>

<p>  // Adjust timeout for slow token validation</p>
<p>  options.Timeout = TimeSpan.FromSeconds(10);</p>
<p>});</p>

<p>// Register custom extractors</p>
<p>services.AddSecurityExtractor<JdxMessageTokenExtractor>();</p>

<p>// Register callbacks</p>
<p>services.AddSecurityContextCallback<UserContextManagerCallback>();</p>
<p></code></pre></p>

<h3>How It Works</h3>

<p>When <code>ServiceBusConsumerWorker</code> receives a message:</p>

<ul><li>Creates DI scope</li>
<li>Calls <code>IMessageSecurityContextProvider.EstablishContextAsync()</code></li>
<li>Provider iterates through extractors in priority order (lower = earlier)</li>
<li>First successful extraction populates <code>IScopeContextAccessor.Current</code></li>
<li>All callbacks are invoked with the established context</li>
<li>Business logic runs with security context available</li>
</ul>
<h2>Configuration Options</h2>

<pre><code class="language-csharp">public sealed class MessageSecurityOptions {
<p>  // When true, allows messages without security context.</p>
<p>  // DEFAULT: FALSE (least privilege - must explicitly enable)</p>
<p>  public bool AllowAnonymous { get; set; }</p>

<p>  // When true, logs security context establishment for audit.</p>
<p>  // DEFAULT: TRUE</p>
<p>  public bool EnableAuditLogging { get; set; } = true;</p>

<p>  // When true, extractors should validate tokens/credentials.</p>
<p>  // DEFAULT: TRUE</p>
<p>  public bool ValidateCredentials { get; set; } = true;</p>

<p>  // Maximum time to wait for security context establishment.</p>
<p>  // DEFAULT: 5 seconds</p>
<p>  public TimeSpan Timeout { get; set; } = TimeSpan.FromSeconds(5);</p>

<p>  // Message types exempt from security requirements.</p>
<p>  public HashSet<Type> ExemptMessageTypes { get; } = new();</p>

<p>  // When true, propagates security context to cascaded events.</p>
<p>  // DEFAULT: TRUE</p>
<p>  public bool PropagateToOutgoingMessages { get; set; } = true;</p>
<p>}</p>
<p></code></pre></p>

<h2>Built-in Extractors</h2>

<h3>MessageHopSecurityExtractor (Priority: 100)</h3>

<p>Extracts security context from the message envelope's hop chain. This is the default extractor for distributed message security propagation.</p>

<pre><code class="language-csharp">// Message hops carry SecurityContext through the system
<p>var hop = new MessageHop {</p>
<p>  ServiceInstance = serviceInstance,</p>
<p>  SecurityContext = new SecurityContext {</p>
<p>    TenantId = "tenant-123",</p>
<p>    UserId = "user-456"</p>
<p>  }</p>
<p>};</p>

<p>// MessageHopSecurityExtractor reads this automatically</p>
<p></code></pre></p>

<strong>When to use</strong>: Messages flowing between Whizbang services that already have security context attached to their hop chain.

<h2>Custom Extractors</h2>

<p>Create custom extractors for different security sources:</p>

<pre><code class="language-csharp">public class JwtPayloadExtractor : ISecurityContextExtractor {
<p>  public int Priority => 50;  // Runs before MessageHopSecurityExtractor</p>

<p>  public ValueTask<SecurityExtraction?> ExtractAsync(</p>
<p>    IMessageEnvelope envelope,</p>
<p>    MessageSecurityOptions options,</p>
<p>    CancellationToken cancellationToken = default) {</p>

<p>    // Check if payload contains JWT token</p>
<p>    if (envelope.Payload is not IJdxMessage jdxMessage ||</p>
<p>        string.IsNullOrEmpty(jdxMessage.Token)) {</p>
<p>      return ValueTask.FromResult<SecurityExtraction?>(null);</p>
<p>    }</p>

<p>    // Decode and validate JWT</p>
<p>    var claims = DecodeJwt(jdxMessage.Token, options.ValidateCredentials);</p>

<p>    return ValueTask.FromResult<SecurityExtraction?>(new SecurityExtraction {</p>
<p>      Scope = new PerspectiveScope {</p>
<p>        TenantId = claims["tenant_id"],</p>
<p>        UserId = claims["sub"]</p>
<p>      },</p>
<p>      Roles = claims["roles"]?.Split(',').ToHashSet() ?? new HashSet<string>(),</p>
<p>      Permissions = new HashSet<Permission>(),</p>
<p>      SecurityPrincipals = new HashSet<SecurityPrincipalId>(),</p>
<p>      Claims = claims,</p>
<p>      Source = "JwtPayload"</p>
<p>    });</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Callbacks</h2>

<p>Callbacks run after security context is established, enabling custom service initialization:</p>

<pre><code class="language-csharp">public class UserContextManagerCallback : ISecurityContextCallback {
<p>  private readonly UserContextManager _userContextManager;</p>

<p>  public UserContextManagerCallback(UserContextManager userContextManager) {</p>
<p>    _userContextManager = userContextManager;</p>
<p>  }</p>

<p>  public ValueTask OnContextEstablishedAsync(</p>
<p>    IScopeContext context,</p>
<p>    IMessageEnvelope envelope,</p>
<p>    IServiceProvider scopedProvider,</p>
<p>    CancellationToken cancellationToken = default) {</p>

<p>    // Populate legacy UserContextManager from IScopeContext</p>
<p>    _userContextManager.SetFromScopeContext(context);</p>

<p>    return ValueTask.CompletedTask;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Transport Metadata</h2>

<p>For extracting security from transport-level headers (e.g., Azure Service Bus application properties):</p>

<pre><code class="language-csharp">public class ServiceBusMetadataExtractor : ISecurityContextExtractor {
<p>  public int Priority => 300;</p>

<p>  public ValueTask<SecurityExtraction?> ExtractAsync(</p>
<p>    IMessageEnvelope envelope,</p>
<p>    MessageSecurityOptions options,</p>
<p>    CancellationToken cancellationToken = default) {</p>

<p>    // Access transport metadata if available</p>
<p>    if (envelope is not ITransportMetadataAware metadataAware ||</p>
<p>        metadataAware.TransportMetadata is not ServiceBusTransportMetadata metadata) {</p>
<p>      return ValueTask.FromResult<SecurityExtraction?>(null);</p>
<p>    }</p>

<p>    // Extract from Service Bus application properties</p>
<p>    var tenantId = metadata.GetProperty<string>("X-Tenant-Id");</p>
<p>    var userId = metadata.GetProperty<string>("X-User-Id");</p>

<p>    if (string.IsNullOrEmpty(tenantId) && string.IsNullOrEmpty(userId)) {</p>
<p>      return ValueTask.FromResult<SecurityExtraction?>(null);</p>
<p>    }</p>

<p>    return ValueTask.FromResult<SecurityExtraction?>(new SecurityExtraction {</p>
<p>      Scope = new PerspectiveScope {</p>
<p>        TenantId = tenantId,</p>
<p>        UserId = userId</p>
<p>      },</p>
<p>      Roles = new HashSet<string>(),</p>
<p>      Permissions = new HashSet<Permission>(),</p>
<p>      SecurityPrincipals = new HashSet<SecurityPrincipalId>(),</p>
<p>      Claims = new Dictionary<string, string>(),</p>
<p>      Source = "ServiceBusMetadata"</p>
<p>    });</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Security Failure Handling</h2>

<p>When <code>AllowAnonymous</code> is <code>false</code> (default) and no extractor can establish context:</p>

<pre><code class="language-csharp">// SecurityContextRequiredException is thrown
<p>try {</p>
<p>  await provider.EstablishContextAsync(envelope, scopedProvider, ct);</p>
<p>} catch (SecurityContextRequiredException ex) {</p>
<p>  // ex.MessageType contains the message type that required security</p>
<p>  logger.LogWarning(</p>
<p>    "Security context required for {MessageType} but none established",</p>
<p>    ex.MessageType?.Name);</p>

<p>  // Message will be dead-lettered or rejected</p>
<p>  throw;</p>
<p>}</p>
<p></code></pre></p>

<h2>Audit Events</h2>

<p>When <code>EnableAuditLogging</code> is <code>true</code>, a <code>ScopeContextEstablished</code> system event is emitted:</p>

<pre><code class="language-csharp">public sealed record ScopeContextEstablished : ISystemEvent {
<p>  public required PerspectiveScope Scope { get; init; }</p>
<p>  public required IReadOnlySet<string> Roles { get; init; }</p>
<p>  public required IReadOnlySet<Permission> Permissions { get; init; }</p>
<p>  public required string Source { get; init; }  // "MessageHop", "JwtPayload", etc.</p>
<p>  public required DateTimeOffset Timestamp { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h2>ImmutableScopeContext</h2>

<p>The established security context is wrapped in <code>ImmutableScopeContext</code>, which provides:</p>

<ul><li><strong>Immutability</strong>: Cannot be modified after establishment</li>
<li><strong>Source tracking</strong>: Which extractor created it</li>
<li><strong>Timestamp</strong>: When it was established</li>
<li><strong>Propagation flag</strong>: Whether to include in outgoing messages</li>
</ul>
<pre><code class="language-csharp">var context = await provider.EstablishContextAsync(envelope, scopedProvider, ct);

<p>if (context is ImmutableScopeContext immutable) {</p>
<p>  Console.WriteLine($"Source: {immutable.Source}");</p>
<p>  Console.WriteLine($"Established: {immutable.EstablishedAt}");</p>
<p>  Console.WriteLine($"Propagate: {immutable.ShouldPropagate}");</p>
<p>}</p>
<p></code></pre></p>

<h2>Automatic Security Propagation</h2>

<p>When <code>MessageSecurityOptions.PropagateToOutgoingMessages</code> is <code>true</code> (the default), the Dispatcher automatically attaches security context from the ambient scope to all outgoing message hops:</p>

<ul><li><strong>Dispatcher checks</strong> <code>IScopeContextAccessor.Current</code> for an established security context</li>
<li><strong>If</strong> <code>ImmutableScopeContext.ShouldPropagate</code> is <code>true</code>, extracts <code>UserId</code> and <code>TenantId</code></li>
<li><strong>Populates</strong> <code>MessageHop.SecurityContext</code> on all outgoing envelopes</li>
<li><strong>Downstream services</strong> extract via <code>MessageHopSecurityExtractor</code></li>
</ul>
<p>This enables seamless security context flow across service boundaries without manual propagation.</p>

<h3>Default Registration</h3>

<code>AddWhizbangDispatcher()</code> automatically registers <code>IScopeContextAccessor</code> by default, enabling security propagation without additional configuration:

<pre><code class="language-csharp">// IScopeContextAccessor is registered automatically
<p>services.AddWhizbangDispatcher();</p>

<p>// You can override with your own implementation if needed</p>
<p>services.AddSingleton<IScopeContextAccessor, CustomScopeContextAccessor>();</p>
<p>services.AddWhizbangDispatcher(); // Uses your implementation (TryAddSingleton)</p>
<p></code></pre></p>

<p>To disable security propagation, set <code>ShouldPropagate = false</code> when creating <code>ImmutableScopeContext</code>.</p>

<h3>How It Works</h3>

<pre><code class="language-csharp">// When a message is sent, the Dispatcher:
<p>// 1. Reads IScopeContextAccessor.Current</p>
<p>// 2. If ImmutableScopeContext with ShouldPropagate=true, extracts security info</p>
<p>// 3. Attaches to outgoing MessageHop</p>

<p>var hop = new MessageHop {</p>
<p>  Type = HopType.Current,</p>
<p>  ServiceInstance = serviceInstance,</p>
<p>  SecurityContext = new SecurityContext {</p>
<p>    UserId = scopeContext.Scope.UserId,</p>
<p>    TenantId = scopeContext.Scope.TenantId</p>
<p>  }</p>
<p>};</p>
<p></code></pre></p>

<h3>Controlling Propagation</h3>

<p>Propagation can be controlled at multiple levels:</p>

<pre><code class="language-csharp">// 1. Globally via MessageSecurityOptions (default: true)
<p>services.AddWhizbangMessageSecurity(options => {</p>
<p>  options.PropagateToOutgoingMessages = true;  // default</p>
<p>});</p>

<p>// 2. Per-context via ImmutableScopeContext</p>
<p>var extraction = new SecurityExtraction { /<em> ... </em>/ };</p>

<p>// Propagation enabled - security flows to downstream services</p>
<p>var propagate = new ImmutableScopeContext(extraction, shouldPropagate: true);</p>

<p>// Propagation disabled - security stays local</p>
<p>var local = new ImmutableScopeContext(extraction, shouldPropagate: false);</p>
<p></code></pre></p>

<h3>End-to-End Flow</h3>

<pre><code class="language-">Service A (HTTP Request)          Service B (Message Consumer)
<p>┌─────────────────────────┐       ┌─────────────────────────┐</p>
<p>│ WhizbangScopeMiddleware │       │ ServiceBusConsumerWorker│</p>
<p>│ establishes IScopeContext│       │                         │</p>
<p>└───────────┬─────────────┘       └───────────┬─────────────┘</p>
<p>            │                                 │</p>
<p>            ▼                                 │</p>
<p>┌───────────────────────────┐                 │</p>
<p>│ Business logic calls      │                 │</p>
<p>│ dispatcher.SendAsync()    │                 │</p>
<p>└───────────┬───────────────┘                 │</p>
<p>            │                                 │</p>
<p>            ▼ Dispatcher attaches security    │</p>
<p>┌───────────────────────────┐                 │</p>
<p>│ MessageHop.SecurityContext│                 │</p>
<p>│ = { UserId, TenantId }    │ ───Message───▶ │</p>
<p>└───────────────────────────┘                 │</p>
<p>                                              ▼</p>
<p>                              ┌───────────────────────────┐</p>
<p>                              │ MessageHopSecurityExtractor│</p>
<p>                              │ reads SecurityContext      │</p>
<p>                              └───────────┬───────────────┘</p>
<p>                                          │</p>
<p>                                          ▼</p>
<p>                              ┌───────────────────────────┐</p>
<p>                              │ IScopeContextAccessor     │</p>
<p>                              │ .Current = context        │</p>
<p>                              └───────────────────────────┘</p>
<p></code></pre></p>

<h2>Explicit Security Context API</h2>

<p>For system-triggered operations (timers, schedulers) or impersonation scenarios, use the explicit security context API:</p>

<h3>AsSystem() - System Operations</h3>

<p>Use <code>AsSystem()</code> when dispatching messages from system contexts where no user identity exists, or when a user-initiated action should run with system privileges:</p>

<pre><code class="language-csharp">// Timer/scheduler with no user context
<p>await dispatcher.AsSystem().SendAsync(new ReseedSystemEvent());</p>
<p>// Audit: ContextType=System, ActualPrincipal=null, EffectivePrincipal="SYSTEM"</p>

<p>// Admin triggering system operation (preserves who triggered it)</p>
<p>await dispatcher.AsSystem().SendAsync(new ReseedSystemEvent());</p>
<p>// Audit: ContextType=System, ActualPrincipal="admin@example.com", EffectivePrincipal="SYSTEM"</p>
<p></code></pre></p>

<p>Key behaviors:</p>
<ul><li><code>EffectivePrincipal</code> is always set to <code>"SYSTEM"</code></li>
<li><code>ActualPrincipal</code> captures the current user if one exists (for audit trail)</li>
<li><code>ContextType</code> is set to <code>SecurityContextType.System</code></li>
<li>Previous security context is restored after dispatch completes</li>
</ul>
<h3>RunAs() - Impersonation</h3>

<p>Use <code>RunAs()</code> when a user needs to perform actions as another identity, with full audit trail:</p>

<pre><code class="language-csharp">// Support staff impersonating a user (full audit trail)
<p>await dispatcher.RunAs("target-user@example.com").SendAsync(command);</p>
<p>// Audit: ContextType=Impersonated, ActualPrincipal="support@example.com", EffectivePrincipal="target-user@example.com"</p>
<p></code></pre></p>

<p>Key behaviors:</p>
<ul><li><code>EffectivePrincipal</code> is set to the specified identity</li>
<li><code>ActualPrincipal</code> captures who initiated the impersonation</li>
<li><code>ContextType</code> is set to <code>SecurityContextType.Impersonated</code></li>
<li>Both identities are captured for security auditing</li>
</ul>
<h3>Supported Methods</h3>

<p>The security builder supports all dispatch methods:</p>

<pre><code class="language-csharp">// Send commands
<p>await dispatcher.AsSystem().SendAsync(command);</p>
<p>await dispatcher.AsSystem().SendAsync(command, options);</p>
<p>await dispatcher.AsSystem().SendAsync(command, messageContext);</p>

<p>// Local invoke (in-process)</p>
<p>await dispatcher.AsSystem().LocalInvokeAsync<TMessage, TResult>(message);</p>
<p>await dispatcher.AsSystem().LocalInvokeAsync(message);</p>

<p>// Publish events</p>
<p>await dispatcher.AsSystem().PublishAsync(eventData);</p>
<p></code></pre></p>

<h3>Audit Trail</h3>

<p>The explicit security API provides complete audit trail information:</p>

<p>| Scenario | ContextType | ActualPrincipal | EffectivePrincipal |</p>
<p>|----------|-------------|-----------------|-------------------|</p>
<p>| Timer job (no user) | System | null | SYSTEM |</p>
<p>| Admin runs as system | System | admin@example.com | SYSTEM |</p>
<p>| Support impersonates | Impersonated | support@example.com | target-user |</p>
<p>| Normal user | User | user@example.com | user@example.com |</p>

<h3>SecurityContextType Enum</h3>

<pre><code class="language-csharp">public enum SecurityContextType {
<p>  User,           // Normal user context from HTTP/message</p>
<p>  System,         // System-initiated (no user involved)</p>
<p>  Impersonated,   // User running as different identity</p>
<p>  ServiceAccount  // Service-to-service with service identity</p>
<p>}</p>
<p></code></pre></p>

<h3>Context Propagation</h3>

<p>The explicit security context is propagated to outgoing message hops when <code>ImmutableScopeContext.ShouldPropagate</code> is <code>true</code> (the default for explicit contexts). This ensures downstream services receive the security context:</p>

<pre><code class="language-csharp">// This message will carry SYSTEM context to downstream services
<p>await dispatcher.AsSystem().SendAsync(new MaintenanceCommand());</p>
<p></code></pre></p>

<h3>Design Principles</h3>

<ul><li><strong>No implicit fallback to elevated</strong> - Code must explicitly request system or elevated context</li>
<li><strong>Full audit trail</strong> - Both actual and effective identities are always captured</li>
<li><strong>Context restoration</strong> - Previous context is restored after dispatch completes (try/finally)</li>
<li><strong>Authorization not bypassed</strong> - This only sets context, not permissions</li>
</ul>
<h2>Integration with Existing Security</h2>

<p>This message security system complements existing security tools:</p>

<p>| Existing Tool | Relationship |</p>
<p>|--------------|--------------|</p>
<p>| <strong>IScopeContext/Accessor</strong> | Provider populates this - single source of truth |</p>
<p>| <strong>WhizbangScopeMiddleware</strong> | HTTP equivalent; this is the message equivalent |</p>
<p>| <strong>MessageHop.SecurityContext</strong> | Default extractor reads from this |</p>
<p>| <strong>PerspectiveScope</strong> | Included in IScopeContext.Scope |</p>
<p>| <strong>Scoped Lens Factory</strong> | Reads from IScopeContextAccessor (works automatically) |</p>
<p>| <strong>System Events</strong> | Provider emits <code>ScopeContextEstablished</code> for audit |</p>

<h2>AOT Compatibility</h2>

<p>The message security system is fully AOT-compatible:</p>

<ul><li>No reflection for extractor/callback discovery</li>
<li>Explicit generic registration: <code>AddSecurityExtractor<T>()</code></li>
<li><code>[DynamicallyAccessedMembers]</code> attributes on generic constraints</li>
<li>All type resolution at compile time</li>
</ul>
<h2>Related Documentation</h2>

<ul><li><a href="./security.md">Security System</a> - Permissions, roles, and scope context</li>
<li><a href="./scoping.md">Scoping</a> - PerspectiveScope and multi-tenancy</li>
<li><a href="./system-events.md">System Events</a> - Audit events</li>
<li><a href="./transport-consumer.md">Transport Consumer</a> - Message processing workers</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-observability" class="doc-section">
  <h3>Observability &amp; Message Hops</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/observability</code></p>
  <p class="doc-description"><em>Understand Whizbang's hop-based observability architecture - MessageEnvelope and MessageHop for distributed tracing and debugging</em></p>
  <div class="doc-content">

<h1>Observability & Message Hops</h1>

<p>Whizbang implements <strong>hop-based observability</strong>, inspired by network packet routing. Every message carries a <strong>MessageEnvelope</strong> containing <strong>hops</strong> - snapshots of contextual metadata at each stage of processing.</p>

<h2>Core Concept: Network Packet Analogy</h2>

<p>Just like IP packets travel through routers, accumulating hops along their journey, Whizbang messages travel through receptors and services, accumulating context hops:</p>

<pre><code class="language-">Network Packet:
<p>┌────────────────────────┐</p>
<p>│ IP Header              │</p>
<p>│ ├─ Source IP           │</p>
<p>│ ├─ Dest IP             │</p>
<p>│ └─ Hop Count: 3        │</p>
<p>├────────────────────────┤</p>
<p>│ Payload (your data)    │</p>
<p>└────────────────────────┘</p>

<p>Whizbang Message:</p>
<p>┌─────────────────────────┐</p>
<p>│ MessageEnvelope         │</p>
<p>│ ├─ MessageId            │</p>
<p>│ ├─ CorrelationId        │</p>
<p>│ ├─ CausationId          │</p>
<p>│ └─ Hops: [Hop1, Hop2]   │</p>
<p>├─────────────────────────┤</p>
<p>│ Payload (your message)  │</p>
<p>└─────────────────────────┘</p>
<p></code></pre></p>

<strong>Key Insight</strong>: Hops capture <strong>where the message has been</strong> and <strong>what decisions were made</strong> along the way.

<hr>

<h2>MessageEnvelope Structure</h2>

<pre><code class="language-csharp">public class MessageEnvelope {
<p>    // Identity</p>
<p>    public required MessageId MessageId { get; init; }</p>
<p>    public required CorrelationId CorrelationId { get; init; }</p>
<p>    public required CausationId? CausationId { get; init; }</p>

<p>    // Payload</p>
<p>    public required object Payload { get; init; }</p>

<p>    // Observability</p>
<p>    public required List<MessageHop> Hops { get; init; }  // THE KEY TO OBSERVABILITY</p>

<p>    // Metadata</p>
<p>    public DateTimeOffset CreatedAt { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<strong>MessageEnvelope wraps every message</strong>, providing:
<ul><li><strong>Identity</strong>: MessageId, CorrelationId, CausationId</li>
<li><strong>Payload</strong>: Your actual command/event/query</li>
<li><strong>Observability</strong>: List of hops showing the message's journey</li>
</ul>
<hr>

<h2>MessageHop Structure</h2>

<pre><code class="language-csharp">public class MessageHop {
<p>    // Hop Type</p>
<p>    public required MessageHopType Type { get; init; }  // Current or Causation</p>

<p>    // Routing</p>
<p>    public string? Topic { get; init; }</p>
<p>    public string? StreamKey { get; init; }</p>
<p>    public int? PartitionIndex { get; init; }</p>
<p>    public long? SequenceNumber { get; init; }</p>

<p>    // Security</p>
<p>    public SecurityContext? SecurityContext { get; init; }  // UserId, TenantId, etc.</p>

<p>    // Policy</p>
<p>    public PolicyDecisionTrail? PolicyDecisionTrail { get; init; }</p>

<p>    // Metadata (stitched across hops)</p>
<p>    public Dictionary<string, string> Metadata { get; init; } = new();</p>

<p>    // Debugging</p>
<p>    public string? CallerMemberName { get; init; }</p>
<p>    public string? CallerFilePath { get; init; }</p>
<p>    public int? CallerLineNumber { get; init; }</p>

<p>    // Timing</p>
<p>    public DateTimeOffset Timestamp { get; init; }</p>
<p>    public TimeSpan? Duration { get; init; }</p>
<p>}</p>

<p>public enum MessageHopType {</p>
<p>    Current,    // This message's context</p>
<p>    Causation   // Parent message's context (inherited)</p>
<p>}</p>
<p></code></pre></p>

<strong>MessageHop captures</strong>:
<ul><li><strong>Routing</strong>: Topic, stream, partition, sequence</li>
<li><strong>Security</strong>: Who is making this request?</li>
<li><strong>Policy</strong>: What decisions were made?</li>
<li><strong>Metadata</strong>: Custom key-value pairs</li>
<li><strong>Debugging</strong>: Source location (file, line, method)</li>
<li><strong>Timing</strong>: When did this happen, how long did it take?</li>
</ul>
<hr>

<h2>Hop Types</h2>

<h3>Current Hop</h3>

<strong>Purpose</strong>: Captures context for <strong>this message</strong>.

<pre><code class="language-csharp">var currentHop = new MessageHop {
<p>    Type = MessageHopType.Current,</p>
<p>    Topic = "orders",</p>
<p>    StreamKey = "customer-123",</p>
<p>    PartitionIndex = 42,</p>
<p>    SecurityContext = new SecurityContext {</p>
<p>        UserId = Guid.Parse("user-456"),</p>
<p>        TenantId = Guid.Parse("tenant-789")</p>
<p>    },</p>
<p>    Metadata = new Dictionary<string, string> {</p>
<p>        ["ServiceName"] = "OrderService",</p>
<p>        ["Version"] = "1.0.0"</p>
<p>    },</p>
<p>    Timestamp = DateTimeOffset.UtcNow</p>
<p>};</p>
<p></code></pre></p>

<strong>Use Case</strong>: Know where this message originated, who created it, and what metadata it carries.

<h3>Causation Hop</h3>

<strong>Purpose</strong>: Captures context from <strong>parent message</strong> (inherited).

<pre><code class="language-csharp">// When OrderCreated event is created from CreateOrder command:
<p>var envelope = MessageEnvelope.Create(</p>
<p>    messageId: MessageId.New(),</p>
<p>    correlationId: command.CorrelationId,  // Inherit</p>
<p>    causationId: CausationId.From(command.MessageId),  // Parent reference</p>
<p>    payload: orderCreatedEvent,</p>
<p>    currentHop: /<em> current hop </em>/,</p>
<p>    causationHops: command.Hops  // INHERIT parent's hops!</p>
<p>);</p>
<p></code></pre></p>

<strong>Result</strong>: <code>OrderCreated</code> envelope contains:
<ul><li><strong>Current hop</strong>: Context for OrderCreated</li>
<li><strong>Causation hops</strong>: All hops from CreateOrder (parent)</li>
</ul>
<strong>Benefit</strong>: Complete trace from HTTP request → Command → Event → Downstream events!

<hr>

<h2>Hop Flow Example</h2>

<h3>Scenario: Create Order Workflow</h3>

<pre><code class="language-">1. HTTP POST /api/orders (API Gateway)
<p>   ├─ Current Hop:</p>
<p>   │  ├─ Type: Current</p>
<p>   │  ├─ SecurityContext: { UserId: user-123, TenantId: tenant-456 }</p>
<p>   │  ├─ Metadata: { ServiceName: "API Gateway", RequestPath: "/api/orders" }</p>
<p>   │  └─ Timestamp: 2024-12-12T10:00:00Z</p>
<p>   └─ Causation Hops: (none)</p>

<p>      ↓ Creates CreateOrder Command</p>

<ul><li>CreateOrder Command (OrderService)</li>
</ul><p>   ├─ Current Hop:</p>
<p>   │  ├─ Type: Current</p>
<p>   │  ├─ Topic: "orders"</p>
<p>   │  ├─ StreamKey: "customer-123"</p>
<p>   │  ├─ SecurityContext: { UserId: user-123, TenantId: tenant-456 }  (inherited)</p>
<p>   │  ├─ Metadata: { ServiceName: "OrderService", ReceptorName: "CreateOrderReceptor" }</p>
<p>   │  └─ Timestamp: 2024-12-12T10:00:00.123Z</p>
<p>   └─ Causation Hops:</p>
<p>      └─ Hop from API Gateway (inherited)</p>

<p>      ↓ Creates OrderCreated Event</p>

<ul><li>OrderCreated Event</li>
</ul><p>   ├─ Current Hop:</p>
<p>   │  ├─ Type: Current</p>
<p>   │  ├─ Topic: "orders"</p>
<p>   │  ├─ StreamKey: "customer-123"</p>
<p>   │  ├─ SecurityContext: { UserId: user-123, TenantId: tenant-456 }  (inherited)</p>
<p>   │  ├─ Metadata: { ServiceName: "OrderService", EventType: "OrderCreated" }</p>
<p>   │  └─ Timestamp: 2024-12-12T10:00:00.456Z</p>
<p>   └─ Causation Hops:</p>
<p>      ├─ Hop from API Gateway (inherited)</p>
<p>      └─ Hop from CreateOrder Command (inherited)</p>

<p>      ↓ Published to Azure Service Bus</p>

<p>      ↓ Consumed by InventoryWorker</p>

<ul><li>InventoryReserved Event</li>
</ul><p>   ├─ Current Hop:</p>
<p>   │  ├─ Type: Current</p>
<p>   │  ├─ Topic: "inventory"</p>
<p>   │  ├─ StreamKey: "product-789"</p>
<p>   │  ├─ SecurityContext: { UserId: user-123, TenantId: tenant-456 }  (inherited)</p>
<p>   │  ├─ Metadata: { ServiceName: "InventoryWorker", EventType: "InventoryReserved" }</p>
<p>   │  └─ Timestamp: 2024-12-12T10:00:01.234Z</p>
<p>   └─ Causation Hops:</p>
<p>      ├─ Hop from API Gateway (inherited)</p>
<p>      ├─ Hop from CreateOrder Command (inherited)</p>
<p>      └─ Hop from OrderCreated Event (inherited)</p>
<p></code></pre></p>

<strong>Result</strong>: <code>InventoryReserved</code> event contains <strong>complete trace</strong> back to original HTTP request!

<hr>

<h2>Security Context</h2>

<pre><code class="language-csharp">public record SecurityContext {
<p>    public Guid? UserId { get; init; }</p>
<p>    public Guid? TenantId { get; init; }</p>
<p>    public string[]? Roles { get; init; }</p>
<p>    public Dictionary<string, string>? Claims { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<strong>Use Case</strong>: Authorization across services.

<h3>Example: Multi-Tenant Authorization</h3>

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>    private readonly IHttpContextAccessor _httpContext;</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        // Extract security context from hops</p>
<p>        var securityContext = message.Hops</p>
<p>            .FirstOrDefault(h => h.Type == MessageHopType.Current)?</p>
<p>            .SecurityContext;</p>

<p>        if (securityContext?.TenantId is null) {</p>
<p>            throw new UnauthorizedAccessException("No tenant context");</p>
<p>        }</p>

<p>        // Validate customer belongs to tenant</p>
<p>        if (!await _customerService.BelongsToTenantAsync(</p>
<p>            message.CustomerId,</p>
<p>            securityContext.TenantId.Value,</p>
<p>            ct)) {</p>

<p>            throw new ForbiddenException("Customer does not belong to tenant");</p>
<p>        }</p>

<p>        // Business logic...</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefit</strong>: Security context flows automatically across services!

<hr>

<h2>Policy Decision Trail</h2>

<pre><code class="language-csharp">public record PolicyDecisionTrail {
<p>    public List<PolicyDecision> Decisions { get; init; } = new();</p>
<p>}</p>

<p>public record PolicyDecision {</p>
<p>    public string PolicyName { get; init; }</p>
<p>    public bool Allowed { get; init; }</p>
<p>    public string? Reason { get; init; }</p>
<p>    public Dictionary<string, string> Context { get; init; } = new();</p>
<p>}</p>
<p></code></pre></p>

<strong>Use Case</strong>: Audit which policies allowed/denied actions.

<h3>Example: Rate Limiting Policy</h3>

<pre><code class="language-csharp">public class RateLimitingPolicy : IPolicy {
<p>    public async Task<PolicyDecision> EvaluateAsync(</p>
<p>        MessageEnvelope envelope,</p>
<p>        CancellationToken ct = default) {</p>

<p>        var securityContext = envelope.Hops</p>
<p>            .FirstOrDefault(h => h.Type == MessageHopType.Current)?</p>
<p>            .SecurityContext;</p>

<p>        var userId = securityContext?.UserId;</p>

<p>        if (userId is null) {</p>
<p>            return new PolicyDecision {</p>
<p>                PolicyName = "RateLimiting",</p>
<p>                Allowed = false,</p>
<p>                Reason = "No user context"</p>
<p>            };</p>
<p>        }</p>

<p>        var count = await _rateLimiter.GetRequestCountAsync(userId.Value, ct);</p>

<p>        if (count > 100) {  // Max 100 requests per minute</p>
<p>            return new PolicyDecision {</p>
<p>                PolicyName = "RateLimiting",</p>
<p>                Allowed = false,</p>
<p>                Reason = "Rate limit exceeded",</p>
<p>                Context = new Dictionary<string, string> {</p>
<p>                    ["RequestCount"] = count.ToString(),</p>
<p>                    ["Limit"] = "100"</p>
<p>                }</p>
<p>            };</p>
<p>        }</p>

<p>        return new PolicyDecision {</p>
<p>            PolicyName = "RateLimiting",</p>
<p>            Allowed = true,</p>
<p>            Context = new Dictionary<string, string> {</p>
<p>                ["RequestCount"] = count.ToString()</p>
<p>            }</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Result</strong>: Every hop contains policy decisions - full audit trail!

<hr>

<h2>Metadata Stitching</h2>

<p>Metadata <strong>stitches across hops</strong>, accumulating context:</p>

<pre><code class="language-csharp">// Hop 1 (API Gateway)
<p>Metadata: {</p>
<p>    "ServiceName": "API Gateway",</p>
<p>    "RequestPath": "/api/orders"</p>
<p>}</p>

<p>// Hop 2 (OrderService) - inherits + adds</p>
<p>Metadata: {</p>
<p>    "ServiceName": "OrderService",        // Overwrites</p>
<p>    "RequestPath": "/api/orders",         // Inherited</p>
<p>    "ReceptorName": "CreateOrderReceptor" // Added</p>
<p>}</p>

<p>// Hop 3 (InventoryWorker) - inherits + adds</p>
<p>Metadata: {</p>
<p>    "ServiceName": "InventoryWorker",     // Overwrites</p>
<p>    "RequestPath": "/api/orders",         // Inherited</p>
<p>    "ReceptorName": "ReserveInventoryReceptor", // Overwrites</p>
<p>    "InventoryCheck": "Passed"            // Added</p>
<p>}</p>
<p></code></pre></p>

<strong>Pattern</strong>: Each hop can:
<ul><li><strong>Inherit</strong> metadata from parent</li>
<li><strong>Overwrite</strong> existing keys</li>
<li><strong>Add</strong> new keys</li>
</ul>
<hr>

<h2>Debugging Information</h2>

<pre><code class="language-csharp">public async ValueTask<OrderCreated> HandleAsync(
<p>    CreateOrder message,</p>
<p>    [CallerMemberName] string memberName = "",</p>
<p>    [CallerFilePath] string filePath = "",</p>
<p>    [CallerLineNumber] int lineNumber = 0,</p>
<p>    CancellationToken ct = default) {</p>

<p>    var currentHop = new MessageHop {</p>
<p>        Type = MessageHopType.Current,</p>
<p>        CallerMemberName = memberName,  // "HandleAsync"</p>
<p>        CallerFilePath = filePath,      // "/src/OrderService/Receptors/CreateOrderReceptor.cs"</p>
<p>        CallerLineNumber = lineNumber,  // 42</p>
<p>        Timestamp = DateTimeOffset.UtcNow</p>
<p>    };</p>

<p>    // Add hop to envelope</p>
<p>    message.Envelope.Hops.Add(currentHop);</p>

<p>    // Business logic...</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefit</strong>: Know <strong>exactly</strong> which file/line created each hop!

<h3>Example: Error Debugging</h3>

<pre><code class="language-">Error: InvalidOperationException in OrderCreated processing

<p>Stack Trace from Hops:</p>
<ul><li>API Gateway</li>
</ul><p>   File: /src/API/Controllers/OrdersController.cs:45</p>

<ul><li>OrderService - CreateOrderReceptor</li>
</ul><p>   File: /src/OrderService/Receptors/CreateOrderReceptor.cs:78</p>

<ul><li>InventoryWorker - ReserveInventoryReceptor</li>
</ul><p>   File: /src/InventoryWorker/Receptors/ReserveInventoryReceptor.cs:102  ← ERROR HERE</p>
<p></code></pre></p>

<strong>Much easier than traditional stack traces in distributed systems!</strong>

<hr>

<h2>Timing & Performance</h2>

<pre><code class="language-csharp">public class MessageHop {
<p>    public DateTimeOffset Timestamp { get; init; }  // When hop was created</p>
<p>    public TimeSpan? Duration { get; init; }        // How long this hop took</p>
<p>}</p>
<p></code></pre></p>

<h3>Example: Performance Profiling</h3>

<pre><code class="language-csharp">var startTime = DateTimeOffset.UtcNow;

<p>// Business logic...</p>

<p>var duration = DateTimeOffset.UtcNow - startTime;</p>

<p>var currentHop = new MessageHop {</p>
<p>    Type = MessageHopType.Current,</p>
<p>    Timestamp = startTime,</p>
<p>    Duration = duration,  // How long this receptor took</p>
<p>    Metadata = new Dictionary<string, string> {</p>
<p>        ["ReceptorName"] = "CreateOrderReceptor"</p>
<p>    }</p>
<p>};</p>
<p></code></pre></p>

<strong>Query Performance</strong>:
<pre><code class="language-csharp">// Find slow hops
<p>var slowHops = envelope.Hops</p>
<p>    .Where(h => h.Duration > TimeSpan.FromMilliseconds(500))</p>
<p>    .OrderByDescending(h => h.Duration)</p>
<p>    .ToArray();</p>

<p>foreach (var hop in slowHops) {</p>
<p>    Console.WriteLine($"{hop.Metadata["ReceptorName"]}: {hop.Duration.TotalMilliseconds}ms");</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Visualizing Hops</h2>

<pre><code class="language-csharp">public class HopVisualizer {
<p>    public void PrintHops(MessageEnvelope envelope) {</p>
<p>        Console.WriteLine($"Message: {envelope.MessageId}");</p>
<p>        Console.WriteLine($"Correlation: {envelope.CorrelationId}");</p>
<p>        Console.WriteLine($"Causation: {envelope.CausationId}");</p>
<p>        Console.WriteLine();</p>
<p>        Console.WriteLine("Hops:");</p>

<p>        for (int i = 0; i < envelope.Hops.Count; i++) {</p>
<p>            var hop = envelope.Hops[i];</p>
<p>            var prefix = new string(' ', i * 2);</p>

<p>            Console.WriteLine($"{prefix}{i + 1}. {hop.Type}");</p>
<p>            Console.WriteLine($"{prefix}   Timestamp: {hop.Timestamp:yyyy-MM-dd HH:mm:ss.fff}");</p>

<p>            if (hop.Duration is not null) {</p>
<p>                Console.WriteLine($"{prefix}   Duration: {hop.Duration.Value.TotalMilliseconds}ms");</p>
<p>            }</p>

<p>            if (hop.SecurityContext is not null) {</p>
<p>                Console.WriteLine($"{prefix}   User: {hop.SecurityContext.UserId}");</p>
<p>                Console.WriteLine($"{prefix}   Tenant: {hop.SecurityContext.TenantId}");</p>
<p>            }</p>

<p>            foreach (var kvp in hop.Metadata) {</p>
<p>                Console.WriteLine($"{prefix}   {kvp.Key}: {kvp.Value}");</p>
<p>            }</p>

<p>            Console.WriteLine();</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Output</strong>:
<pre><code class="language-">Message: msg-003
<p>Correlation: corr-abc</p>
<p>Causation: msg-002</p>

<p>Hops:</p>
<ul><li>Causation</li>
</ul><p>   Timestamp: 2024-12-12 10:00:00.123</p>
<p>   Duration: 15ms</p>
<p>   User: user-123</p>
<p>   Tenant: tenant-456</p>
<p>   ServiceName: API Gateway</p>
<p>   RequestPath: /api/orders</p>

<p>  2. Causation</p>
<p>     Timestamp: 2024-12-12 10:00:00.456</p>
<p>     Duration: 50ms</p>
<p>     User: user-123</p>
<p>     Tenant: tenant-456</p>
<p>     ServiceName: OrderService</p>
<p>     ReceptorName: CreateOrderReceptor</p>

<p>    3. Current</p>
<p>       Timestamp: 2024-12-12 10:00:01.234</p>
<p>       Duration: 120ms</p>
<p>       User: user-123</p>
<p>       Tenant: tenant-456</p>
<p>       ServiceName: InventoryWorker</p>
<p>       ReceptorName: ReserveInventoryReceptor</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Add hops</strong> at each processing stage</li>
<li>✅ <strong>Include security context</strong> in first hop</li>
<li>✅ <strong>Inherit causation hops</strong> from parent message</li>
<li>✅ <strong>Stitch metadata</strong> across hops</li>
<li>✅ <strong>Record timing</strong> (Timestamp, Duration)</li>
<li>✅ <strong>Add debugging info</strong> (CallerMemberName, FilePath, LineNumber)</li>
<li>✅ <strong>Visualize hops</strong> for debugging</li>
<li>✅ <strong>Query hops</strong> for performance profiling</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Skip adding hops (breaks tracing)</li>
<li>❌ Forget to inherit causation hops</li>
<li>❌ Store sensitive data in metadata (use SecurityContext)</li>
<li>❌ Add excessive metadata (keep it lean)</li>
<li>❌ Ignore hop timestamps (critical for debugging)</li>
</ul>
<hr>

<h2>Integration with Event Store</h2>

<p>Hops are stored with events for full auditability:</p>

<pre><code class="language-sql">CREATE TABLE wh_event_store (
<p>    event_id UUID PRIMARY KEY,</p>
<p>    message_id UUID NOT NULL,</p>
<p>    correlation_id UUID NOT NULL,</p>
<p>    causation_id UUID NULL,</p>
<p>    event_type VARCHAR(255) NOT NULL,</p>
<p>    payload JSONB NOT NULL,</p>
<p>    hops JSONB NOT NULL,  -- Stored as JSON</p>
<p>    created_at TIMESTAMPTZ NOT NULL</p>
<p>);</p>

<p>CREATE INDEX idx_event_store_correlation_id ON wh_event_store(correlation_id);</p>
<p>CREATE INDEX idx_event_store_causation_id ON wh_event_store(causation_id);</p>
<p></code></pre></p>

<strong>Query hops</strong>:
<pre><code class="language-sql">SELECT
<p>    event_id,</p>
<p>    event_type,</p>
<p>    hops->>0->>'Metadata'->>'ServiceName' AS service_name,</p>
<p>    hops->>0->>'Timestamp' AS timestamp,</p>
<p>    hops->>0->>'Duration' AS duration</p>
<p>FROM wh_event_store</p>
<p>WHERE correlation_id = 'corr-abc'</p>
<p>ORDER BY created_at;</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Core Concepts</strong>:
<ul><li><a href="message-context.md">Message Context</a> - MessageId, CorrelationId, CausationId</li>
<li><a href="dispatcher.md">Dispatcher</a> - How messages flow through the system</li>
<li><a href="receptors.md">Receptors</a> - Message handlers</li>
</ul>
<strong>Messaging Patterns</strong>:
<ul><li><a href="../messaging/message-envelopes.md">Message Envelopes</a> - Deep dive into hop architecture</li>
<li><a href="../messaging/outbox-pattern.md">Outbox Pattern</a> - Reliable messaging with hops</li>
<li><a href="../data/event-store.md">Event Store</a> - Storing hops with events</li>
</ul>
<strong>Infrastructure</strong>:
<ul><li><a href="../infrastructure/observability-setup.md">Logging & Telemetry</a> - Application Insights integration</li>
<li><a href="../infrastructure/policies.md">Policy Engine</a> - Policy decision trails</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-perspectives" class="doc-section">
  <h3>Perspectives Guide</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/perspectives</code></p>
  <p class="doc-description"><em>Master Whizbang Perspectives - pure function event handlers that maintain eventually consistent read models optimized for queries</em></p>
  <div class="doc-content">

<h1>Perspectives Guide</h1>

<strong>Perspectives</strong> are pure function event handlers that maintain <strong>read models</strong> (projections) optimized for queries. They embody the "Q" in CQRS (Command Query Responsibility Segregation) - separate models for reading data.

<h2>Core Concept</h2>

<p>A Perspective is analogous to a <strong>viewpoint</strong> or <strong>lens through which you see data</strong>:</p>
<ul><li><strong>Listens to events</strong> (domain events)</li>
<li><strong>Applies events using pure functions</strong> (deterministic, no I/O)</li>
<li><strong>Maintains denormalized read models</strong> (optimized for queries)</li>
<li><strong>Eventually consistent</strong> (updates happen asynchronously)</li>
</ul>
<strong>Key Innovation</strong>: Perspectives use <strong>pure functions</strong> for event application, enabling deterministic event replay and reliable read model reconstruction.

<hr>

<h2>IPerspectiveFor Interface</h2>

<pre><code class="language-csharp">namespace Whizbang.Core.Perspectives;

<p>public interface IPerspectiveFor<TModel, TEvent></p>
<p>    where TModel : notnull</p>
<p>    where TEvent : notnull, IEvent {</p>

<p>    TModel Apply(TModel currentData, TEvent @event);</p>
<p>}</p>
<p></code></pre></p>

<strong>Type Parameters</strong>:
<ul><li><code>TModel</code>: The read model type (e.g., <code>ProductDto</code>)</li>
<li><code>TEvent</code>: The event type this perspective handles (e.g., <code>ProductCreatedEvent</code>)</li>
</ul>
<strong>Key Characteristics</strong>:
<ul><li><strong>Pure function</strong>: Synchronous, deterministic, no I/O or side effects</li>
<li><strong>Returns new state</strong>: Doesn't mutate <code>currentData</code>, returns new model instance</li>
<li><strong>Event replay</strong>: Runner applies events in UUID7 order</li>
<li><strong>Unit of work</strong>: All events applied, then model + checkpoint saved once</li>
</ul>
<hr>

<h2>StreamKey Attribute</h2>

<p>The <code>[StreamKey]</code> attribute marks the property that identifies the stream/aggregate for event ordering and perspective model identification.</p>

<strong>Required on</strong>:
<ul><li><strong>Event types</strong>: Identifies which stream the event belongs to</li>
<li><strong>Model types</strong>: Identifies which stream the model represents</li>
</ul>
<strong>Example</strong>:
<pre><code class="language-csharp">using Whizbang.Core;

<p>// Event with StreamKey</p>
<p>public record ProductCreatedEvent : IEvent {</p>
<p>    [AggregateId]  // Optional: marks as aggregate identifier</p>
<p>    [StreamKey]    // Required: used for event replay ordering</p>
<p>    public Guid ProductId { get; init; }</p>

<p>    public string Name { get; init; } = string.Empty;</p>
<p>    public string Description { get; init; } = string.Empty;</p>
<p>    public decimal Price { get; init; }</p>
<p>}</p>

<p>// Model with StreamKey</p>
<p>public record ProductDto {</p>
<p>    [StreamKey]</p>
<p>    public Guid ProductId { get; init; }</p>

<p>    public string Name { get; init; } = string.Empty;</p>
<p>    public string Description { get; init; } = string.Empty;</p>
<p>    public decimal Price { get; init; }</p>
<p>    public DateTime CreatedAt { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<strong>Diagnostics</strong>:
<ul><li><strong>WHIZ030</strong>: Event type must have exactly one property marked with <code>[StreamKey]</code></li>
<li><strong>WHIZ031</strong>: Event type has multiple properties marked with <code>[StreamKey]</code> (only one allowed)</li>
</ul>
<strong>Why required?</strong>
<ul><li>Enables stream-based event replay</li>
<li>Ensures events are applied to correct model instance</li>
<li>Supports UUID7-based ordering for deterministic replay</li>
</ul>
<hr>

<h2>Basic Example</h2>

<pre><code class="language-csharp">using Whizbang.Core;
<p>using Whizbang.Core.Perspectives;</p>

<p>// Event</p>
<p>public record ProductCreatedEvent : IEvent {</p>
<p>    [StreamKey]</p>
<p>    public Guid ProductId { get; init; }</p>
<p>    public string Name { get; init; } = string.Empty;</p>
<p>    public string Description { get; init; } = string.Empty;</p>
<p>    public decimal Price { get; init; }</p>
<p>    public DateTime CreatedAt { get; init; }</p>
<p>}</p>

<p>// Read Model</p>
<p>public record ProductDto {</p>
<p>    [StreamKey]</p>
<p>    public Guid ProductId { get; init; }</p>
<p>    public string Name { get; init; } = string.Empty;</p>
<p>    public string Description { get; init; } = string.Empty;</p>
<p>    public decimal Price { get; init; }</p>
<p>    public DateTime CreatedAt { get; init; }</p>
<p>    public DateTime? UpdatedAt { get; init; }</p>
<p>}</p>

<p>// Perspective (pure function)</p>
<p>public class ProductCatalogPerspective : IPerspectiveFor<ProductDto, ProductCreatedEvent> {</p>
<p>    public ProductDto Apply(ProductDto currentData, ProductCreatedEvent @event) {</p>
<p>        // Pure function: no I/O, no side effects, deterministic</p>
<p>        return new ProductDto {</p>
<p>            ProductId = @event.ProductId,</p>
<p>            Name = @event.Name,</p>
<p>            Description = @event.Description,</p>
<p>            Price = @event.Price,</p>
<p>            CreatedAt = @event.CreatedAt,</p>
<p>            UpdatedAt = null</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Notice</strong>:
<ul><li>No database access in <code>Apply()</code> - it's a pure function</li>
<li>Returns new <code>ProductDto</code> instance (immutability)</li>
<li>Deterministic: same input = same output every time</li>
</ul>
<hr>

<h2>CQRS Pattern</h2>

<p>Whizbang implements CQRS with:</p>
<ul><li><strong>Write side</strong>: Commands → Receptors → Events → Event Store</li>
<li><strong>Read side</strong>: PerspectiveWorker → Runners → Apply() → Read Models</li>
</ul>
<pre><code class="language-">┌─────────────── WRITE SIDE ───────────────┐
<p>│                                           │</p>
<p>│  CreateProduct Command                    │</p>
<p>│       ↓                                   │</p>
<p>│  CreateProductReceptor                    │</p>
<p>│       ↓                                   │</p>
<p>│  ProductCreatedEvent → Event Store        │</p>
<p>│                                           │</p>
<p>└───────────────┬───────────────────────────┘</p>
<p>                │</p>
<p>                │ PerspectiveWorker polls for new events</p>
<p>                ↓</p>
<p>┌─────────────── READ SIDE ────────────────┐</p>
<p>│                                           │</p>
<p>│  ProductCreatedEvent (from event store)  │</p>
<p>│       ↓                                   │</p>
<p>│  ProductCatalogPerspectiveRunner         │</p>
<p>│       ↓                                   │</p>
<p>│  perspective.Apply(currentModel, event)  │</p>
<p>│       ↓                                   │</p>
<p>│  IPerspectiveStore.UpsertAsync(model)    │</p>
<p>│       ↓                                   │</p>
<p>│  product_catalog table (denormalized)    │</p>
<p>│       ↓                                   │</p>
<p>│  ProductLens.GetProductAsync() ← Query   │</p>
<p>│                                           │</p>
<p>└───────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li><strong>Optimized reads</strong>: Denormalized data, no joins</li>
<li><strong>Scalability</strong>: Read and write databases can scale independently</li>
<li><strong>Flexibility</strong>: Multiple read models for different use cases</li>
<li><strong>Performance</strong>: Queries are simple, fast lookups</li>
<li><strong>Reliability</strong>: Pure functions enable deterministic event replay</li>
</ul>
<hr>

<h2>PerspectiveRunner Architecture</h2>

<p>Whizbang automatically generates <code>IPerspectiveRunner</code> implementations for each perspective via source generators.</p>

<strong>What gets generated</strong>:
<ul><li>Runner class per perspective (e.g., <code>ProductCatalogPerspectiveRunner</code>)</li>
<li><code>ExtractStreamId</code> methods per event type (extracts stream ID from event's <code>[StreamKey]</code> property)</li>
<li>Unit-of-work event replay logic</li>
<li>Checkpoint management</li>
</ul>
<strong>How it works</strong>:
<ul><li><code>PerspectiveWorker</code> polls <code>IWorkCoordinator</code> for streams with new events</li>
<li>Worker resolves appropriate runner via <code>IPerspectiveRunnerRegistry</code> (zero-reflection, AOT-compatible)</li>
<li>Runner loads current model from <code>IPerspectiveStore<TModel></code> (or creates new)</li>
<li>Runner applies <strong>all new events</strong> using perspective's pure <code>Apply()</code> methods</li>
<li>Runner saves model + checkpoint <strong>atomically</strong> (unit of work pattern)</li>
</ul>
<strong>Generated code example</strong>:
<pre><code class="language-csharp">// Auto-generated by Whizbang.Generators
<p>internal sealed class ProductCatalogPerspectiveRunner : IPerspectiveRunner {</p>
<p>    private readonly IServiceProvider _serviceProvider;</p>
<p>    private readonly IEventStore _eventStore;</p>
<p>    private readonly IPerspectiveStore<ProductDto> _perspectiveStore;</p>

<p>    public async Task<PerspectiveCheckpointCompletion> RunAsync(</p>
<p>        Guid streamId,</p>
<p>        string perspectiveName,</p>
<p>        Guid? lastProcessedEventId,</p>
<p>        CancellationToken cancellationToken) {</p>

<p>        // Load current model (or create new)</p>
<p>        var currentModel = await _perspectiveStore.GetByStreamIdAsync(streamId, cancellationToken)</p>
<p>            ?? CreateEmptyModel(streamId);</p>

<p>        // Get perspective instance from DI</p>
<p>        var perspective = _serviceProvider.GetRequiredService<ProductCatalogPerspective>();</p>

<p>        // Read events in UUID7 order</p>
<p>        await foreach (var envelope in _eventStore.ReadAsync<IEvent>(streamId, lastProcessedEventId, cancellationToken)) {</p>
<p>            var @event = envelope.Payload;</p>

<p>            // Apply event using perspective's pure Apply method</p>
<p>            currentModel = ApplyEvent(perspective, currentModel, @event);</p>
<p>            lastProcessedEventId = envelope.MessageId.Value;</p>
<p>        }</p>

<p>        // Unit of work: Save model + checkpoint ONCE</p>
<p>        await _perspectiveStore.UpsertAsync(streamId, currentModel, cancellationToken);</p>
<p>        // TODO: Save checkpoint</p>

<p>        return new PerspectiveCheckpointCompletion { /<em> ... </em>/ };</p>
<p>    }</p>

<p>    // Generated ExtractStreamId method per event type</p>
<p>    private static string ExtractStreamId(ProductCreatedEvent @event) {</p>
<p>        return @event.ProductId.ToString();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>Zero reflection (AOT-compatible)</li>
<li>Type-safe event handling</li>
<li>Deterministic replay (pure functions)</li>
<li>Atomic writes (model + checkpoint together)</li>
</ul>
<hr>

<h2>Pure Function Pattern</h2>

<p>Perspectives use <strong>pure functions</strong> for event application:</p>

<strong>Characteristics</strong>:
<ul><li>✅ <strong>Synchronous</strong> (not async) - <code>TModel Apply()</code> not <code>Task<TModel> UpdateAsync()</code></li>
<li>✅ <strong>Deterministic</strong> - Same input = same output every time</li>
<li>✅ <strong>No I/O</strong> - No database calls, no HTTP requests, no file system access</li>
<li>✅ <strong>No side effects</strong> - Doesn't mutate arguments or external state</li>
<li>✅ <strong>Returns new state</strong> - Creates and returns new model instance</li>
<li>✅ <strong>Immutable</strong> - Uses <code>record</code> types with <code>init</code> properties</li>
</ul>
<strong>Why pure functions?</strong>
<ul><li><strong>Deterministic replay</strong>: Rebuilding read models from events always produces same result</li>
<li><strong>Easy to test</strong>: No database mocking, no complex setup</li>
<li><strong>Compile-time safety</strong>: Type system enforces purity (future: Roslyn analyzer)</li>
<li><strong>Event sourcing</strong>: Pure functions are perfect for event replay</li>
<li><strong>Debugging</strong>: No hidden state changes, easy to reason about</li>
</ul>
<strong>Example - Pure vs. Impure</strong>:

<pre><code class="language-csharp">// ❌ IMPURE: Async I/O, side effects
<p>public class OldPerspective : IPerspectiveOf<ProductCreatedEvent> {</p>
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public async Task UpdateAsync(ProductCreatedEvent @event, CancellationToken ct) {</p>
<p>        // Direct I/O - not deterministic, can fail, impure</p>
<p>        await using var conn = _db.CreateConnection();</p>
<p>        await conn.ExecuteAsync(</p>
<p>            "INSERT INTO products (...) VALUES (...)",</p>
<p>            @event</p>
<p>        );</p>
<p>    }</p>
<p>}</p>

<p>// ✅ PURE: Synchronous, deterministic, no I/O</p>
<p>public class ProductCatalogPerspective : IPerspectiveFor<ProductDto, ProductCreatedEvent> {</p>
<p>    public ProductDto Apply(ProductDto currentData, ProductCreatedEvent @event) {</p>
<p>        // Pure function: no I/O, deterministic, returns new state</p>
<p>        return new ProductDto {</p>
<p>            ProductId = @event.ProductId,</p>
<p>            Name = @event.Name,</p>
<p>            Price = @event.Price,</p>
<p>            CreatedAt = @event.CreatedAt</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>The runner handles I/O</strong> (not the perspective):
<ul><li>Perspective: Pure function that computes new state</li>
<li>Runner: Loads model, calls Apply(), saves result</li>
</ul>
<hr>

<h2>Multiple Event Types</h2>

<p>A single perspective can handle <strong>multiple event types</strong>:</p>

<pre><code class="language-csharp">public class ProductCatalogPerspective :
<p>    IPerspectiveFor<ProductDto, ProductCreatedEvent>,</p>
<p>    IPerspectiveFor<ProductDto, ProductUpdatedEvent>,</p>
<p>    IPerspectiveFor<ProductDto, ProductDeletedEvent> {</p>

<p>    public ProductDto Apply(ProductDto currentData, ProductCreatedEvent @event) {</p>
<p>        return new ProductDto {</p>
<p>            ProductId = @event.ProductId,</p>
<p>            Name = @event.Name,</p>
<p>            Description = @event.Description,</p>
<p>            Price = @event.Price,</p>
<p>            CreatedAt = @event.CreatedAt,</p>
<p>            UpdatedAt = null,</p>
<p>            DeletedAt = null</p>
<p>        };</p>
<p>    }</p>

<p>    public ProductDto Apply(ProductDto currentData, ProductUpdatedEvent @event) {</p>
<p>        // Partial update: only non-null fields</p>
<p>        return new ProductDto {</p>
<p>            ProductId = currentData.ProductId,</p>
<p>            Name = @event.Name ?? currentData.Name,</p>
<p>            Description = @event.Description ?? currentData.Description,</p>
<p>            Price = @event.Price ?? currentData.Price,</p>
<p>            CreatedAt = currentData.CreatedAt,</p>
<p>            UpdatedAt = @event.UpdatedAt,</p>
<p>            DeletedAt = currentData.DeletedAt</p>
<p>        };</p>
<p>    }</p>

<p>    public ProductDto Apply(ProductDto currentData, ProductDeletedEvent @event) {</p>
<p>        // Soft delete</p>
<p>        return new ProductDto {</p>
<p>            ProductId = currentData.ProductId,</p>
<p>            Name = currentData.Name,</p>
<p>            Description = currentData.Description,</p>
<p>            Price = currentData.Price,</p>
<p>            CreatedAt = currentData.CreatedAt,</p>
<p>            UpdatedAt = currentData.UpdatedAt,</p>
<p>            DeletedAt = @event.DeletedAt</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Pattern</strong>: One read model, multiple events that update it over time.

<strong>Note</strong>: Maximum 5 event types per perspective (language limitation). For more events, create multiple perspectives targeting the same model.

<hr>

<h2>Multiple Perspectives per Event</h2>

<p>One event can update <strong>multiple read models</strong>:</p>

<pre><code class="language-csharp">// Event published once
<p>public record OrderCreatedEvent : IEvent {</p>
<p>    [StreamKey]</p>
<p>    public Guid OrderId { get; init; }</p>
<p>    public Guid CustomerId { get; init; }</p>
<p>    public OrderLineItem[] Items { get; init; } = [];</p>
<p>    public decimal Total { get; init; }</p>
<p>}</p>

<p>// Perspective 1: Order summary (for customer order history)</p>
<p>public class OrderSummaryPerspective : IPerspectiveFor<OrderSummaryDto, OrderCreatedEvent> {</p>
<p>    public OrderSummaryDto Apply(OrderSummaryDto currentData, OrderCreatedEvent @event) {</p>
<p>        return new OrderSummaryDto {</p>
<p>            OrderId = @event.OrderId,</p>
<p>            CustomerId = @event.CustomerId,</p>
<p>            ItemCount = @event.Items.Length,</p>
<p>            Total = @event.Total,</p>
<p>            Status = "Created"</p>
<p>        };</p>
<p>    }</p>
<p>}</p>

<p>// Perspective 2: Customer activity (for personalization)</p>
<p>public class CustomerActivityPerspective : IPerspectiveFor<CustomerActivityDto, OrderCreatedEvent> {</p>
<p>    public CustomerActivityDto Apply(CustomerActivityDto currentData, OrderCreatedEvent @event) {</p>
<p>        return new CustomerActivityDto {</p>
<p>            CustomerId = @event.CustomerId,</p>
<p>            LastOrderDate = DateTime.UtcNow,</p>
<p>            OrderCount = (currentData?.OrderCount ?? 0) + 1,</p>
<p>            TotalSpent = (currentData?.TotalSpent ?? 0) + @event.Total</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Result</strong>: Publishing <code>OrderCreatedEvent</code> updates <strong>two separate read models</strong> automatically via their respective runners.

<hr>

<h2>Read Model Design</h2>

<h3>Denormalization</h3>

<p>Read models are <strong>denormalized</strong> for query performance:</p>

<strong>Write Model</strong> (normalized):
<pre><code class="language-sql">-- Normalized schema (write side)
<p>CREATE TABLE products (</p>
<p>    product_id UUID PRIMARY KEY,</p>
<p>    name VARCHAR(255) NOT NULL,</p>
<p>    description TEXT,</p>
<p>    price DECIMAL(10,2) NOT NULL,</p>
<p>    created_at TIMESTAMPTZ NOT NULL</p>
<p>);</p>

<p>CREATE TABLE inventory (</p>
<p>    product_id UUID PRIMARY KEY,</p>
<p>    quantity INT NOT NULL,</p>
<p>    reserved INT NOT NULL,</p>
<p>    FOREIGN KEY (product_id) REFERENCES products(product_id)</p>
<p>);</p>
<p></code></pre></p>

<strong>Read Model</strong> (denormalized):
<pre><code class="language-sql">-- Denormalized schema (read side)
<p>CREATE TABLE product_catalog (</p>
<p>    product_id UUID PRIMARY KEY,</p>
<p>    name VARCHAR(255) NOT NULL,</p>
<p>    description TEXT,</p>
<p>    price DECIMAL(10,2) NOT NULL,</p>
<p>    quantity INT NOT NULL,              -- Denormalized from inventory</p>
<p>    available INT NOT NULL,              -- Denormalized from inventory</p>
<p>    created_at TIMESTAMPTZ NOT NULL,</p>
<p>    updated_at TIMESTAMPTZ NULL,</p>
<p>    deleted_at TIMESTAMPTZ NULL</p>
<p>);</p>

<p>-- Simple index for fast lookups</p>
<p>CREATE INDEX idx_product_catalog_created_at ON product_catalog(created_at DESC);</p>
<p></code></pre></p>

<strong>Query Performance</strong>:
<pre><code class="language-sql">-- ❌ SLOW: Normalized (requires join)
<p>SELECT p.product_id, p.name, p.price, i.quantity, (i.quantity - i.reserved) AS available</p>
<p>FROM products p</p>
<p>JOIN inventory i ON p.product_id = i.product_id</p>
<p>WHERE p.product_id = '...';</p>

<p>-- ✅ FAST: Denormalized (single table lookup)</p>
<p>SELECT product_id, name, price, quantity, available</p>
<p>FROM product_catalog</p>
<p>WHERE product_id = '...';</p>
<p></code></pre></p>

<h3>Multiple Read Models</h3>

<p>Different perspectives for different use cases:</p>

<pre><code class="language-csharp">// Read Model 1: Product catalog (for product listing UI)
<p>public record ProductCatalogDto {</p>
<p>    [StreamKey]</p>
<p>    public Guid ProductId { get; init; }</p>
<p>    public string Name { get; init; } = string.Empty;</p>
<p>    public decimal Price { get; init; }</p>
<p>    public int Available { get; init; }</p>
<p>}</p>

<p>// Read Model 2: Product details (for product detail page)</p>
<p>public record ProductDetailsDto {</p>
<p>    [StreamKey]</p>
<p>    public Guid ProductId { get; init; }</p>
<p>    public string Name { get; init; } = string.Empty;</p>
<p>    public string Description { get; init; } = string.Empty;</p>
<p>    public decimal Price { get; init; }</p>
<p>    public string? ImageUrl { get; init; }</p>
<p>    public DateTime CreatedAt { get; init; }</p>
<p>    public DateTime? UpdatedAt { get; init; }</p>
<p>}</p>

<p>// Read Model 3: Inventory levels (for warehouse dashboard)</p>
<p>public record InventoryLevelsDto {</p>
<p>    [StreamKey]</p>
<p>    public Guid ProductId { get; init; }</p>
<p>    public int Quantity { get; init; }</p>
<p>    public int Reserved { get; init; }</p>
<p>    public int Available { get; init; }</p>
<p>    public DateTime LastUpdated { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<p>Each read model has its own <strong>perspective</strong> and <strong>table schema</strong> optimized for its queries.</p>

<hr>

<h2>Dependency Injection</h2>

<h3>Registration</h3>

<strong>Manual</strong>:
<pre><code class="language-csharp">// Register perspective (transient recommended)
<p>builder.Services.AddTransient<ProductCatalogPerspective>();</p>

<p>// Register perspective store (scoped - per request)</p>
<p>builder.Services.AddScoped<IPerspectiveStore<ProductDto>, PostgresPerspectiveStore<ProductDto>>();</p>
<p></code></pre></p>

<strong>Auto-Discovery</strong> (with Whizbang.Generators):
<pre><code class="language-csharp">// Discovers all IPerspectiveFor implementations and registers runners
<p>builder.Services.AddPerspectiveRunners();  // Generated by source generator</p>
<p></code></pre></p>

<h3>Lifetime</h3>

<strong>Perspectives</strong>: <code>Transient</code> (new instance per Apply call)
<ul><li>Stateless (no benefit to reusing instances)</li>
<li>May be created multiple times during batch event replay</li>
</ul>
<strong>Perspective Stores</strong>: <code>Scoped</code> (per unit of work)
<ul><li>May manage database connections</li>
<li>Reused across batch of events in same stream</li>
</ul>
<strong>Runners</strong>: <code>Transient</code> (created per RunAsync call)
<ul><li>Stateless (no shared state between runs)</li>
</ul>
<pre><code class="language-csharp">builder.Services.AddTransient<ProductCatalogPerspective>();
<p>builder.Services.AddScoped<IPerspectiveStore<ProductDto>, PostgresPerspectiveStore<ProductDto>>();</p>
<p></code></pre></p>

<hr>

<h2>Testing Perspectives</h2>

<h3>Unit Tests (Pure Functions)</h3>

<pre><code class="language-csharp">public class ProductCatalogPerspectiveTests {
<p>    [Test]</p>
<p>    public async Task Apply_ProductCreatedEvent_CreatesNewModelAsync() {</p>
<p>        // Arrange</p>
<p>        var perspective = new ProductCatalogPerspective();</p>
<p>        var currentData = new ProductDto();  // Empty model</p>

<p>        var @event = new ProductCreatedEvent {</p>
<p>            ProductId = Guid.NewGuid(),</p>
<p>            Name = "Test Product",</p>
<p>            Description = "Test Description",</p>
<p>            Price = 19.99m,</p>
<p>            CreatedAt = DateTime.UtcNow</p>
<p>        };</p>

<p>        // Act - pure function, no I/O, no mocking!</p>
<p>        var result = perspective.Apply(currentData, @event);</p>

<p>        // Assert</p>
<p>        await Assert.That(result).IsNotNull();</p>
<p>        await Assert.That(result.ProductId).IsEqualTo(@event.ProductId);</p>
<p>        await Assert.That(result.Name).IsEqualTo("Test Product");</p>
<p>        await Assert.That(result.Price).IsEqualTo(19.99m);</p>
<p>        await Assert.That(currentData.Name).IsEqualTo(string.Empty);  // Not mutated!</p>
<p>    }</p>

<p>    [Test]</p>
<p>    public async Task Apply_Deterministic_SameInputProducesSameOutputAsync() {</p>
<p>        // Arrange</p>
<p>        var perspective = new ProductCatalogPerspective();</p>
<p>        var currentData = new ProductDto { ProductId = Guid.NewGuid() };</p>
<p>        var @event = new ProductUpdatedEvent {</p>
<p>            ProductId = currentData.ProductId,</p>
<p>            Name = "Updated Name",</p>
<p>            Price = 29.99m,</p>
<p>            UpdatedAt = DateTime.UtcNow</p>
<p>        };</p>

<p>        // Act - call Apply multiple times</p>
<p>        var result1 = perspective.Apply(currentData, @event);</p>
<p>        var result2 = perspective.Apply(currentData, @event);</p>

<p>        // Assert - pure function always returns same result</p>
<p>        await Assert.That(result1.Name).IsEqualTo(result2.Name);</p>
<p>        await Assert.That(result1.Price).IsEqualTo(result2.Price);</p>
<p>    }</p>

<p>    [Test]</p>
<p>    public async Task Apply_MultipleEvents_SequentialApplicationAsync() {</p>
<p>        // Arrange</p>
<p>        var perspective = new ProductCatalogPerspective();</p>
<p>        var createEvent = new ProductCreatedEvent {</p>
<p>            ProductId = Guid.NewGuid(),</p>
<p>            Name = "Product",</p>
<p>            Price = 10m,</p>
<p>            CreatedAt = DateTime.UtcNow</p>
<p>        };</p>
<p>        var updateEvent = new ProductUpdatedEvent {</p>
<p>            ProductId = createEvent.ProductId,</p>
<p>            Name = "Updated Product",</p>
<p>            Price = 20m,</p>
<p>            UpdatedAt = DateTime.UtcNow</p>
<p>        };</p>

<p>        // Act - apply events in sequence</p>
<p>        var emptyModel = new ProductDto();</p>
<p>        var afterCreate = perspective.Apply(emptyModel, createEvent);</p>
<p>        var afterUpdate = perspective.Apply(afterCreate, updateEvent);</p>

<p>        // Assert</p>
<p>        await Assert.That(afterUpdate.Name).IsEqualTo("Updated Product");</p>
<p>        await Assert.That(afterUpdate.Price).IsEqualTo(20m);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits of testing pure functions</strong>:
<ul><li>No database mocking required</li>
<li>No complex setup/teardown</li>
<li>Fast (no I/O)</li>
<li>Deterministic (no flaky tests)</li>
<li>Easy to reason about</li>
</ul>
<hr>

<h2>Event Sourcing Integration</h2>

<p>Perspectives can rebuild from event history (event replay):</p>

<pre><code class="language-csharp">// Runner automatically handles event replay
<p>public class PerspectiveWorker : BackgroundService {</p>
<p>    protected override async Task ExecuteAsync(CancellationToken ct) {</p>
<p>        while (!ct.IsCancellationRequested) {</p>
<p>            // Poll for streams with new events</p>
<p>            var workBatch = await _workCoordinator.ProcessWorkBatchAsync(...);</p>

<p>            foreach (var perspectiveWork in workBatch.PerspectiveWork) {</p>
<p>                // Resolve runner for this perspective</p>
<p>                var runner = _registry.GetRunner(perspectiveWork.PerspectiveName, _serviceProvider);</p>

<p>                // Runner applies all events since last checkpoint</p>
<p>                var result = await runner.RunAsync(</p>
<p>                    perspectiveWork.StreamId,</p>
<p>                    perspectiveWork.PerspectiveName,</p>
<p>                    perspectiveWork.LastProcessedEventId,  // Checkpoint</p>
<p>                    ct</p>
<p>                );</p>
<p>            }</p>

<p>            await Task.Delay(_options.PollingIntervalMilliseconds, ct);</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Unit of Work Pattern</strong>:
<ul><li>Load current model (or create new)</li>
<li>Apply <strong>ALL</strong> events since last checkpoint using pure <code>Apply()</code> methods</li>
<li>Save model + checkpoint <strong>atomically</strong></li>
</ul>
<strong>Use cases</strong>:
<ul><li><strong>Rebuild corrupted read models</strong>: Truncate table, replay all events</li>
<li><strong>Add new perspectives</strong>: Replay historical events into new read model</li>
<li><strong>Time-travel queries</strong>: Rebuild model up to specific point in time</li>
<li><strong>Model schema changes</strong>: Replay events into new schema</li>
</ul>
<strong>Manual rebuild example</strong>:
<pre><code class="language-csharp">public async Task RebuildProductCatalogAsync(CancellationToken ct) {
<p>    var perspective = new ProductCatalogPerspective();</p>
<p>    var store = _serviceProvider.GetRequiredService<IPerspectiveStore<ProductDto>>();</p>

<p>    // Truncate read model</p>
<p>    await store.TruncateAsync(ct);</p>

<p>    // Replay all events</p>
<p>    await foreach (var envelope in _eventStore.ReadAllAsync<IEvent>(ct)) {</p>
<p>        var streamId = Guid.Parse(ExtractStreamId(envelope.Payload));</p>

<p>        // Load current model for this stream</p>
<p>        var currentModel = await store.GetByStreamIdAsync(streamId, ct)</p>
<p>            ?? CreateEmptyModel(streamId);</p>

<p>        // Apply event</p>
<p>        var updatedModel = ApplyEvent(perspective, currentModel, envelope.Payload);</p>

<p>        // Save updated model</p>
<p>        await store.UpsertAsync(streamId, updatedModel, ct);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Error Handling</h2>

<h3>Pure Functions Don't Throw I/O Errors</h3>

<p>Since <code>Apply()</code> methods are pure functions with no I/O, they rarely throw exceptions. Common cases:</p>

<pre><code class="language-csharp">public ProductDto Apply(ProductDto currentData, ProductUpdatedEvent @event) {
<p>    // Defensive: handle null current data</p>
<p>    if (currentData == null) {</p>
<p>        // Treat update as create</p>
<p>        return new ProductDto {</p>
<p>            ProductId = @event.ProductId,</p>
<p>            Name = @event.Name ?? string.Empty,</p>
<p>            Price = @event.Price ?? 0,</p>
<p>            CreatedAt = @event.UpdatedAt</p>
<p>        };</p>
<p>    }</p>

<p>    // Normal update</p>
<p>    return new ProductDto {</p>
<p>        ProductId = currentData.ProductId,</p>
<p>        Name = @event.Name ?? currentData.Name,</p>
<p>        Price = @event.Price ?? currentData.Price,</p>
<p>        CreatedAt = currentData.CreatedAt,</p>
<p>        UpdatedAt = @event.UpdatedAt</p>
<p>    };</p>
<p>}</p>
<p></code></pre></p>

<h3>Runner-Level Error Handling</h3>

<strong>Runners</strong> handle I/O errors and implement retry logic:

<pre><code class="language-csharp">// Generated runner handles errors
<p>public async Task<PerspectiveCheckpointCompletion> RunAsync(...) {</p>
<p>    try {</p>
<p>        // Apply all events</p>
<p>        foreach (var envelope in events) {</p>
<p>            updatedModel = ApplyEvent(perspective, updatedModel, envelope.Payload);</p>
<p>            lastSuccessfulEventId = envelope.MessageId.Value;</p>
<p>        }</p>

<p>        // Save model + checkpoint atomically</p>
<p>        await SaveModelAndCheckpointAsync(streamId, updatedModel, lastSuccessfulEventId, ct);</p>

<p>        return new PerspectiveCheckpointCompletion { Status = Completed };</p>

<p>    } catch (Exception ex) {</p>
<p>        // Partial success: save checkpoint up to last successful event</p>
<p>        if (lastSuccessfulEventId != null) {</p>
<p>            await SaveModelAndCheckpointAsync(streamId, updatedModel, lastSuccessfulEventId.Value, ct);</p>
<p>        }</p>

<p>        throw;  // Let PerspectiveWorker catch and convert to failure</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Strategies</strong>:
<ul><li><strong>Partial progress</strong>: Save checkpoint up to last successful event</li>
<li><strong>Retry</strong>: Worker retries failed perspective work on next poll</li>
<li><strong>Dead letter</strong>: Log persistent failures for manual review</li>
</ul>
<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ Make <code>Apply()</code> methods <strong>pure functions</strong> (synchronous, deterministic, no I/O)</li>
<li>✅ Use <code>[StreamKey]</code> on <strong>both events and models</strong></li>
<li>✅ Return <strong>new model instance</strong> from <code>Apply()</code> (don't mutate currentData)</li>
<li>✅ Use <code>record</code> types for immutability</li>
<li>✅ Handle null <code>currentData</code> defensively</li>
<li>✅ Denormalize read models for query performance</li>
<li>✅ Create <strong>multiple read models</strong> for different use cases</li>
<li>✅ Use <strong>transient lifetime</strong> for perspectives</li>
<li>✅ Test <code>Apply()</code> methods as pure functions (no database mocking)</li>
<li>✅ Index read model tables for fast queries</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Perform I/O in <code>Apply()</code> methods (database, HTTP, file system)</li>
<li>❌ Make <code>Apply()</code> async (pure functions are synchronous)</li>
<li>❌ Mutate <code>currentData</code> parameter</li>
<li>❌ Store state in perspective instances</li>
<li>❌ Forget <code>[StreamKey]</code> attribute (will fail at runtime)</li>
<li>❌ Use multiple <code>[StreamKey]</code> attributes (WHIZ031 error)</li>
<li>❌ Perform complex joins in read models (defeats denormalization)</li>
<li>❌ Call receptors from perspectives (perspectives are read-only)</li>
<li>❌ Throw exceptions for business logic (return appropriate model state)</li>
</ul>
<hr>

<h2>Further Reading</h2>

<strong>Core Concepts</strong>:
<ul><li><a href="dispatcher.md">Dispatcher</a> - How to publish events</li>
<li><a href="lenses.md">Lenses</a> - Query interfaces for read models</li>
<li><a href="receptors.md">Receptors</a> - Command handlers that produce events</li>
<li><a href="../attributes/streamkey.md">StreamKey Attribute</a> - Stream identification</li>
</ul>
<strong>Source Generators</strong>:
<ul><li><a href="../source-generators/perspective-discovery.md">Perspective Discovery</a> - Auto-discovery and runner generation</li>
<li><a href="../diagnostics/whiz030-whiz031.md">Diagnostics (WHIZ030/WHIZ031)</a> - StreamKey validation</li>
</ul>
<strong>Data Access</strong>:
<ul><li><a href="../data/perspective-store.md">IPerspectiveStore</a> - Persistence abstraction</li>
<li><a href="../data/perspectives-storage.md">Perspective Storage</a> - Schema design patterns</li>
<li><a href="../data/efcore-integration.md">EF Core Integration</a> - Using EF Core for read models</li>
</ul>
<strong>Workers</strong>:
<ul><li><a href="../workers/perspective-worker.md">Perspective Worker</a> - Checkpoint processing lifecycle and runtime behavior</li>
<li><a href="../workers/execution-lifecycle.md">Execution Lifecycle</a> - Startup/shutdown coordination</li>
<li><a href="../workers/database-readiness.md">Database Readiness</a> - Dependency coordination</li>
</ul>
<strong>Examples</strong>:
<ul><li><a href="../examples/ecommerce/bff-pattern.md">ECommerce: BFF Pattern</a> - Real-world perspectives</li>
<li><a href="../examples/ecommerce/product-catalog.md">ECommerce: Product Catalog</a> - Complete example</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2025-12-21</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-receptors" class="doc-section">
  <h3>Receptors Guide</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/receptors</code></p>
  <p class="doc-description"><em>Master Whizbang Receptors - stateless message handlers that encapsulate business logic, validation, and decision-making</em></p>
  <div class="doc-content">

<h1>Receptors Guide</h1>

<strong>Receptors</strong> are stateless message handlers that encapsulate business logic and decision-making in Whizbang applications. They receive commands/queries and return events/responses.

<h2>Core Concept</h2>

<p>A Receptor is analogous to a biological receptor:</p>
<ul><li><strong>Receives signals</strong> (messages/commands)</li>
<li><strong>Makes decisions</strong> (business logic)</li>
<li><strong>Produces responses</strong> (events/responses)</li>
<li><strong>Stateless</strong> (no internal state, everything via parameters)</li>
</ul>
<h2>IReceptor Interface</h2>

<pre><code class="language-csharp">namespace Whizbang.Core;

<p>public interface IReceptor<in TMessage, TResponse></p>
<p>    where TMessage : notnull {</p>

<p>    ValueTask<TResponse> HandleAsync(</p>
<p>        TMessage message,</p>
<p>        CancellationToken cancellationToken = default</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<strong>Type Parameters</strong>:
<ul><li><code>TMessage</code>: The incoming message/command type</li>
<li><code>TResponse</code>: The response/event type</li>
</ul>
<strong>Key Characteristics</strong>:
<ul><li><strong>Stateless</strong>: No instance fields, all data via parameters</li>
<li><strong>Single Responsibility</strong>: One receptor per message type</li>
<li><strong>Async</strong>: Returns <code>ValueTask<T></code> for optimal performance</li>
<li><strong>Type Safe</strong>: Compile-time enforcement of message → response mapping</li>
</ul>
<hr>

<h2>ISyncReceptor Interface</h2>

<p>:::new</p>
<p>For receptors that perform pure computation without async operations, use <code>ISyncReceptor</code>:</p>
<p>:::</p>

<pre><code class="language-csharp">namespace Whizbang.Core;

<p>public interface ISyncReceptor<in TMessage, out TResponse></p>
<p>    where TMessage : notnull {</p>

<p>    TResponse Handle(TMessage message);</p>
<p>}</p>

<p>// Void variant for side-effect-only operations</p>
<p>public interface ISyncReceptor<in TMessage></p>
<p>    where TMessage : notnull {</p>

<p>    void Handle(TMessage message);</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences from IReceptor</strong>:
<ul><li><strong>Synchronous</strong>: Returns <code>TResponse</code> directly (no <code>ValueTask</code>)</li>
<li><strong>No CancellationToken</strong>: Sync operations can't be cancelled mid-execution</li>
<li><strong>Covariant TResponse</strong>: Uses <code>out TResponse</code> for flexibility</li>
<li><strong>Zero async overhead</strong>: No state machine generated, pre-completed <code>ValueTask</code> returned</li>
</ul>
<h3>When to Use Sync vs Async</h3>

<p>| Use <code>ISyncReceptor</code> | Use <code>IReceptor</code> (async) |</p>
<p>|---------------------|-------------------------|</p>
<p>| Pure computation | Database access |</p>
<p>| In-memory transformations | External API calls |</p>
<p>| Validation logic | File I/O |</p>
<p>| ID generation | Message queue operations |</p>
<p>| Calculations | HTTP requests |</p>
<p>| State machine transitions | Any <code>await</code> operation |</p>

<h3>Sync Receptor Example</h3>

<pre><code class="language-csharp">// Before (async ceremony for pure computation)
<p>public class CreateOrderReceptor : IReceptor<CreateOrder, (OrderResult, OrderCreated)> {</p>
<p>    public ValueTask<(OrderResult, OrderCreated)> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        var orderId = Guid.CreateVersion7();</p>
<p>        var total = message.Items.Sum(i => i.Quantity * i.UnitPrice);</p>

<p>        return ValueTask.FromResult((</p>
<p>            new OrderResult(orderId),</p>
<p>            new OrderCreated(orderId, message.CustomerId, total, DateTimeOffset.UtcNow)</p>
<p>        ));</p>
<p>    }</p>
<p>}</p>

<p>// After (clean sync pattern)</p>
<p>public class CreateOrderReceptor : ISyncReceptor<CreateOrder, (OrderResult, OrderCreated)> {</p>
<p>    public (OrderResult, OrderCreated) Handle(CreateOrder message) {</p>
<p>        var orderId = Guid.CreateVersion7();</p>
<p>        var total = message.Items.Sum(i => i.Quantity * i.UnitPrice);</p>

<p>        return (</p>
<p>            new OrderResult(orderId),</p>
<p>            new OrderCreated(orderId, message.CustomerId, total, DateTimeOffset.UtcNow)</p>
<p>        );</p>
<p>        // OrderCreated is AUTO-PUBLISHED (same as async)</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Void Sync Receptor Example</h3>

<pre><code class="language-csharp">// For side-effect-only operations (logging, caching, etc.)
<p>public class LogUserActionReceptor : ISyncReceptor<LogUserAction> {</p>
<p>    private readonly ILogger<LogUserActionReceptor> _logger;</p>

<p>    public LogUserActionReceptor(ILogger<LogUserActionReceptor> logger) {</p>
<p>        _logger = logger;</p>
<p>    }</p>

<p>    public void Handle(LogUserAction message) {</p>
<p>        _logger.LogInformation(</p>
<p>            "User {UserId} performed action {Action} at {Timestamp}",</p>
<p>            message.UserId, message.Action, message.Timestamp</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Auto-Cascade Works Identically</h3>

<p>Sync receptors support the same auto-cascade feature as async receptors:</p>

<pre><code class="language-csharp">public class ShipOrderReceptor : ISyncReceptor<ShipOrder, (ShipResult, OrderShipped, InventoryUpdated)> {
<p>    public (ShipResult, OrderShipped, InventoryUpdated) Handle(ShipOrder message) {</p>
<p>        return (</p>
<p>            new ShipResult(message.OrderId),</p>
<p>            new OrderShipped(message.OrderId, DateTimeOffset.UtcNow),</p>
<p>            new InventoryUpdated(message.ProductId, -message.Quantity)</p>
<p>        );</p>
<p>        // Both OrderShipped AND InventoryUpdated auto-published!</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Invocation via Dispatcher</h3>

<p>The Dispatcher API is unchanged - <code>LocalInvokeAsync</code> works with both sync and async receptors:</p>

<pre><code class="language-csharp">// Invoking a sync receptor
<p>var result = await _dispatcher.LocalInvokeAsync<CreateOrder, (OrderResult, OrderCreated)>(command);</p>
<p>// Internally: sync Handle() called, result wrapped in pre-completed ValueTask</p>

<p>// Invoking an async receptor</p>
<p>var result = await _dispatcher.LocalInvokeAsync<ProcessPayment, PaymentResult>(command);</p>
<p>// Internally: async HandleAsync() called, ValueTask awaited</p>
<p></code></pre></p>

<strong>Precedence</strong>: If both <code>IReceptor</code> and <code>ISyncReceptor</code> exist for the same message type, the async <code>IReceptor</code> takes precedence.

<hr>

<h2>Basic Example</h2>

<pre><code class="language-csharp">using Whizbang.Core;

<p>public record CreateOrder(</p>
<p>    Guid CustomerId,</p>
<p>    OrderLineItem[] Items</p>
<p>);</p>

<p>public record OrderCreated(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    OrderLineItem[] Items,</p>
<p>    decimal Total,</p>
<p>    DateTimeOffset CreatedAt</p>
<p>);</p>

<p>public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    private readonly ILogger<CreateOrderReceptor> _logger;</p>

<p>    public CreateOrderReceptor(ILogger<CreateOrderReceptor> logger) {</p>
<p>        _logger = logger;</p>
<p>    }</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken cancellationToken = default) {</p>

<p>        // Validation</p>
<p>        if (message.Items.Length == 0) {</p>
<p>            throw new ValidationException("Order must contain at least one item");</p>
<p>        }</p>

<p>        // Business logic</p>
<p>        var orderId = Guid.CreateVersion7();</p>
<p>        var total = message.Items.Sum(i => i.Quantity * i.UnitPrice);</p>

<p>        _logger.LogInformation(</p>
<p>            "Creating order {OrderId} for customer {CustomerId} with {ItemCount} items, total {Total:C}",</p>
<p>            orderId, message.CustomerId, message.Items.Length, total</p>
<p>        );</p>

<p>        // Return event (fact of what happened)</p>
<p>        return new OrderCreated(</p>
<p>            OrderId: orderId,</p>
<p>            CustomerId: message.CustomerId,</p>
<p>            Items: message.Items,</p>
<p>            Total: total,</p>
<p>            CreatedAt: DateTimeOffset.UtcNow</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Receptor Patterns</h2>

<h3>Pattern 1: Command → Event</h3>

<strong>Use Case</strong>: State-changing operations

<pre><code class="language-csharp">public class CancelOrderReceptor : IReceptor<CancelOrder, OrderCancelled> {
<p>    private readonly IDbConnectionFactory _db;</p>
<p>    private readonly ILogger<CancelOrderReceptor> _logger;</p>

<p>    public CancelOrderReceptor(</p>
<p>        IDbConnectionFactory db,</p>
<p>        ILogger<CancelOrderReceptor> logger) {</p>
<p>        _db = db;</p>
<p>        _logger = logger;</p>
<p>    }</p>

<p>    public async ValueTask<OrderCancelled> HandleAsync(</p>
<p>        CancelOrder message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        await using var conn = _db.CreateConnection();</p>

<p>        // Load current state</p>
<p>        var order = await conn.QuerySingleOrDefaultAsync<Order>(</p>
<p>            "SELECT * FROM orders WHERE order_id = @OrderId",</p>
<p>            new { message.OrderId },</p>
<p>            ct</p>
<p>        );</p>

<p>        // Validation</p>
<p>        if (order is null) {</p>
<p>            throw new NotFoundException($"Order {message.OrderId} not found");</p>
<p>        }</p>

<p>        if (order.Status == "Shipped") {</p>
<p>            throw new InvalidOperationException("Cannot cancel shipped order");</p>
<p>        }</p>

<p>        _logger.LogInformation(</p>
<p>            "Cancelling order {OrderId}, reason: {Reason}",</p>
<p>            message.OrderId, message.Reason</p>
<p>        );</p>

<p>        // Return event</p>
<p>        return new OrderCancelled(</p>
<p>            OrderId: message.OrderId,</p>
<p>            Reason: message.Reason,</p>
<p>            CancelledAt: DateTimeOffset.UtcNow</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li>Commands are <strong>imperative</strong> (CancelOrder - intent to change state)</li>
<li>Events are <strong>past tense</strong> (OrderCancelled - fact of what happened)</li>
<li>Validation before event creation</li>
<li>Event contains all relevant data for downstream consumers</li>
</ul>
<h3>Pattern 2: Query → Response</h3>

<strong>Use Case</strong>: Read operations

<pre><code class="language-csharp">public record GetOrderDetails(Guid OrderId);

<p>public record OrderDetails(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    OrderLineItem[] Items,</p>
<p>    decimal Total,</p>
<p>    string Status,</p>
<p>    DateTimeOffset CreatedAt</p>
<p>);</p>

<p>public class GetOrderDetailsReceptor : IReceptor<GetOrderDetails, OrderDetails> {</p>
<p>    private readonly IOrderLens _lens;</p>

<p>    public GetOrderDetailsReceptor(IOrderLens lens) {</p>
<p>        _lens = lens;</p>
<p>    }</p>

<p>    public async ValueTask<OrderDetails> HandleAsync(</p>
<p>        GetOrderDetails query,</p>
<p>        CancellationToken ct = default) {</p>

<p>        var order = await _lens.GetOrderAsync(query.OrderId, ct);</p>

<p>        if (order is null) {</p>
<p>            throw new NotFoundException($"Order {query.OrderId} not found");</p>
<p>        }</p>

<p>        return new OrderDetails(</p>
<p>            OrderId: order.OrderId,</p>
<p>            CustomerId: order.CustomerId,</p>
<p>            Items: order.Items,</p>
<p>            Total: order.Total,</p>
<p>            Status: order.Status,</p>
<p>            CreatedAt: order.CreatedAt</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li>Queries are <strong>questions</strong> (GetOrderDetails)</li>
<li>Responses are <strong>answers</strong> (OrderDetails)</li>
<li>Read from optimized read models (via Lenses)</li>
<li>No side effects (pure read operation)</li>
</ul>
<h3>Pattern 3: Validation-Heavy Receptor</h3>

<strong>Use Case</strong>: Complex business rules

<pre><code class="language-csharp">public class ProcessPaymentReceptor : IReceptor<ProcessPayment, PaymentResult> {
<p>    private readonly IPaymentGateway _gateway;</p>
<p>    private readonly IDbConnectionFactory _db;</p>
<p>    private readonly ILogger<ProcessPaymentReceptor> _logger;</p>

<p>    public ProcessPaymentReceptor(</p>
<p>        IPaymentGateway gateway,</p>
<p>        IDbConnectionFactory db,</p>
<p>        ILogger<ProcessPaymentReceptor> logger) {</p>
<p>        _gateway = gateway;</p>
<p>        _db = db;</p>
<p>        _logger = logger;</p>
<p>    }</p>

<p>    public async ValueTask<PaymentResult> HandleAsync(</p>
<p>        ProcessPayment message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        // Validation Step 1: Order exists and is valid</p>
<p>        await ValidateOrderAsync(message.OrderId, ct);</p>

<p>        // Validation Step 2: Payment amount matches order total</p>
<p>        await ValidateAmountAsync(message.OrderId, message.Amount, ct);</p>

<p>        // Validation Step 3: Payment method is valid</p>
<p>        ValidatePaymentMethod(message.PaymentMethod);</p>

<p>        // Business Logic: Process payment</p>
<p>        try {</p>
<p>            var transactionId = await _gateway.ChargeAsync(</p>
<p>                message.PaymentMethod,</p>
<p>                message.Amount,</p>
<p>                ct</p>
<p>            );</p>

<p>            _logger.LogInformation(</p>
<p>                "Payment processed for order {OrderId}, transaction {TransactionId}",</p>
<p>                message.OrderId, transactionId</p>
<p>            );</p>

<p>            return new PaymentResult(</p>
<p>                OrderId: message.OrderId,</p>
<p>                Amount: message.Amount,</p>
<p>                TransactionId: transactionId,</p>
<p>                IsSuccess: true,</p>
<p>                ErrorCode: null</p>
<p>            );</p>

<p>        } catch (PaymentDeclinedException ex) {</p>
<p>            _logger.LogWarning(</p>
<p>                ex,</p>
<p>                "Payment declined for order {OrderId}",</p>
<p>                message.OrderId</p>
<p>            );</p>

<p>            return new PaymentResult(</p>
<p>                OrderId: message.OrderId,</p>
<p>                Amount: message.Amount,</p>
<p>                TransactionId: null,</p>
<p>                IsSuccess: false,</p>
<p>                ErrorCode: ex.ErrorCode</p>
<p>            );</p>
<p>        }</p>
<p>    }</p>

<p>    private async Task ValidateOrderAsync(Guid orderId, CancellationToken ct) {</p>
<p>        await using var conn = _db.CreateConnection();</p>
<p>        var order = await conn.QuerySingleOrDefaultAsync<Order>(</p>
<p>            "SELECT * FROM orders WHERE order_id = @OrderId",</p>
<p>            new { OrderId = orderId },</p>
<p>            ct</p>
<p>        );</p>

<p>        if (order is null) {</p>
<p>            throw new NotFoundException($"Order {orderId} not found");</p>
<p>        }</p>

<p>        if (order.Status != "Created") {</p>
<p>            throw new InvalidOperationException(</p>
<p>                $"Order {orderId} is not in valid state for payment (status: {order.Status})"</p>
<p>            );</p>
<p>        }</p>
<p>    }</p>

<p>    private async Task ValidateAmountAsync(</p>
<p>        Guid orderId,</p>
<p>        decimal amount,</p>
<p>        CancellationToken ct) {</p>

<p>        await using var conn = _db.CreateConnection();</p>
<p>        var total = await conn.ExecuteScalarAsync<decimal>(</p>
<p>            "SELECT total FROM orders WHERE order_id = @OrderId",</p>
<p>            new { OrderId = orderId },</p>
<p>            ct</p>
<p>        );</p>

<p>        if (amount != total) {</p>
<p>            throw new ValidationException(</p>
<p>                $"Payment amount {amount:C} does not match order total {total:C}"</p>
<p>            );</p>
<p>        }</p>
<p>    }</p>

<p>    private static void ValidatePaymentMethod(PaymentMethod method) {</p>
<p>        if (string.IsNullOrWhiteSpace(method.CardNumber)) {</p>
<p>            throw new ValidationException("Card number is required");</p>
<p>        }</p>

<p>        if (method.ExpiryDate < DateOnly.FromDateTime(DateTime.UtcNow)) {</p>
<p>            throw new ValidationException("Card has expired");</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li>Extract validation into private methods</li>
<li>Validate early, fail fast</li>
<li>Clear error messages</li>
<li>Structured logging</li>
</ul>
<h3>Pattern 4: Tuple Return with Auto-Cascade</h3>

<strong>Use Case</strong>: Commands that produce events alongside business results

<p>The <strong>auto-cascade</strong> feature automatically publishes <code>IEvent</code> instances extracted from receptor return values. This enables a cleaner pattern where receptors return tuples containing both results and events.</p>

<pre><code class="language-csharp">public record CreateOrder(Guid CustomerId, OrderLineItem[] Items);

<p>public record OrderResult(Guid OrderId);</p>

<p>public record OrderCreated(</p>
<p>    [property: StreamKey] Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    decimal Total,</p>
<p>    DateTimeOffset CreatedAt</p>
<p>) : IEvent;</p>

<p>// Return tuple: (Result, Event)</p>
<p>public class CreateOrderReceptor : IReceptor<CreateOrder, (OrderResult, OrderCreated)> {</p>
<p>    private readonly ILogger<CreateOrderReceptor> _logger;</p>

<p>    public CreateOrderReceptor(ILogger<CreateOrderReceptor> logger) {</p>
<p>        _logger = logger;</p>
<p>    }</p>

<p>    public ValueTask<(OrderResult, OrderCreated)> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        // Validation</p>
<p>        if (message.Items.Length == 0) {</p>
<p>            throw new ValidationException("Order must have at least one item");</p>
<p>        }</p>

<p>        // Business logic</p>
<p>        var orderId = Guid.CreateVersion7();</p>
<p>        var total = message.Items.Sum(i => i.Quantity * i.UnitPrice);</p>

<p>        _logger.LogInformation(</p>
<p>            "Order {OrderId} created for customer {CustomerId}, total {Total:C}",</p>
<p>            orderId, message.CustomerId, total</p>
<p>        );</p>

<p>        // Return tuple - OrderCreated is AUTO-PUBLISHED to all perspectives!</p>
<p>        return ValueTask.FromResult((</p>
<p>            new OrderResult(orderId),</p>
<p>            new OrderCreated(orderId, message.CustomerId, total, DateTimeOffset.UtcNow)</p>
<p>        ));</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li>Return type is <code>(OrderResult, OrderCreated)</code> tuple</li>
<li><code>OrderCreated</code> implements <code>IEvent</code> → automatically extracted and published</li>
<li><code>OrderResult</code> does not implement <code>IEvent</code> → passed through unchanged</li>
<li>No explicit <code>_dispatcher.PublishAsync()</code> call needed</li>
<li>All perspectives subscribing to <code>OrderCreated</code> receive the event automatically</li>
</ul>
<strong>Benefits</strong>:
<ul><li><strong>Fewer dependencies</strong>: No need to inject <code>IDispatcher</code> just for publishing</li>
<li><strong>Cleaner code</strong>: Return events declaratively, not imperatively</li>
<li><strong>Safer</strong>: Can't forget to publish events</li>
<li><strong>Type-safe</strong>: Compiler enforces the return contract</li>
</ul>
<p>See <a href="dispatcher.md#automatic-event-cascade">Dispatcher: Automatic Event Cascade</a> for full details on supported return types.</p>

<p>For RPC-style calls where the caller extracts a specific response type from the tuple, see <a href="rpc-extraction.md">RPC Response Extraction</a>.</p>

<hr>

<h2>Dependency Injection</h2>

<h3>Constructor Injection</h3>

<p>Receptors use <strong>constructor injection</strong> for dependencies:</p>

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>    private readonly IDbConnectionFactory _db;</p>
<p>    private readonly IInventoryService _inventory;</p>
<p>    private readonly ILogger<CreateOrderReceptor> _logger;</p>

<p>    // Dependencies injected via constructor</p>
<p>    public CreateOrderReceptor(</p>
<p>        IDbConnectionFactory db,</p>
<p>        IInventoryService inventory,</p>
<p>        ILogger<CreateOrderReceptor> logger) {</p>

<p>        _db = db;</p>
<p>        _inventory = inventory;</p>
<p>        _logger = logger;</p>
<p>    }</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        // Use injected dependencies</p>
<p>        await using var conn = _db.CreateConnection();</p>
<p>        var hasStock = await _inventory.CheckStockAsync(message.Items, ct);</p>

<p>        // ...</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Registration</h3>

<strong>Manual Registration</strong>:
<pre><code class="language-csharp">builder.Services.AddTransient<IReceptor<CreateOrder, OrderCreated>, CreateOrderReceptor>();
<p></code></pre></p>

<strong>Auto-Discovery</strong> (with Whizbang.Generators):
<pre><code class="language-csharp">builder.Services.AddDiscoveredReceptors();  // Automatically finds all IReceptor implementations
<p></code></pre></p>

<h3>Lifetime</h3>

<strong>Recommended</strong>: <code>Transient</code> (new instance per request)

<strong>Why?</strong>
<ul><li>May inject scoped services (e.g., <code>DbContext</code>)</li>
<li>Stateless (no benefit to reusing instances)</li>
<li>Minimal allocation cost</li>
</ul>
<pre><code class="language-csharp">// Correct
<p>builder.Services.AddTransient<IReceptor<CreateOrder, OrderCreated>, CreateOrderReceptor>();</p>

<p>// Avoid (unless you have specific performance needs)</p>
<p>builder.Services.AddScoped<IReceptor<CreateOrder, OrderCreated>, CreateOrderReceptor>();</p>
<p>builder.Services.AddSingleton<IReceptor<CreateOrder, OrderCreated>, CreateOrderReceptor>();</p>
<p></code></pre></p>

<hr>

<h2>Error Handling</h2>

<h3>Validation Errors</h3>

<p>Use exceptions for validation failures:</p>

<pre><code class="language-csharp">public async ValueTask<OrderCreated> HandleAsync(
<p>    CreateOrder message,</p>
<p>    CancellationToken ct = default) {</p>

<p>    // Early validation</p>
<p>    if (message.Items.Length == 0) {</p>
<p>        throw new ValidationException("Order must contain at least one item");</p>
<p>    }</p>

<p>    if (message.Items.Any(i => i.Quantity <= 0)) {</p>
<p>        throw new ValidationException("All items must have quantity greater than zero");</p>
<p>    }</p>

<p>    if (message.Items.Any(i => i.UnitPrice <= 0)) {</p>
<p>        throw new ValidationException("All items must have price greater than zero");</p>
<p>    }</p>

<p>    // Business logic</p>
<p>    // ...</p>
<p>}</p>
<p></code></pre></p>

<strong>Exception Types</strong>:
<ul><li><code>ValidationException</code> - Input validation failures (400 Bad Request)</li>
<li><code>NotFoundException</code> - Entity not found (404 Not Found)</li>
<li><code>InvalidOperationException</code> - Business rule violations (409 Conflict)</li>
<li><code>UnauthorizedAccessException</code> - Authorization failures (403 Forbidden)</li>
</ul>
<h3>Business Logic Errors</h3>

<p>Return error responses for expected failures:</p>

<pre><code class="language-csharp">public record PaymentResult(
<p>    Guid OrderId,</p>
<p>    decimal Amount,</p>
<p>    string? TransactionId,</p>
<p>    bool IsSuccess,</p>
<p>    string? ErrorCode</p>
<p>);</p>

<p>public async ValueTask<PaymentResult> HandleAsync(</p>
<p>    ProcessPayment message,</p>
<p>    CancellationToken ct = default) {</p>

<p>    try {</p>
<p>        var transactionId = await _gateway.ChargeAsync(</p>
<p>            message.PaymentMethod,</p>
<p>            message.Amount,</p>
<p>            ct</p>
<p>        );</p>

<p>        return new PaymentResult(</p>
<p>            OrderId: message.OrderId,</p>
<p>            Amount: message.Amount,</p>
<p>            TransactionId: transactionId,</p>
<p>            IsSuccess: true,</p>
<p>            ErrorCode: null</p>
<p>        );</p>

<p>    } catch (PaymentDeclinedException ex) {</p>
<p>        // Don't throw - return error response</p>
<p>        return new PaymentResult(</p>
<p>            OrderId: message.OrderId,</p>
<p>            Amount: message.Amount,</p>
<p>            TransactionId: null,</p>
<p>            IsSuccess: false,</p>
<p>            ErrorCode: ex.ErrorCode</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>When to throw vs return error</strong>:
<ul><li><strong>Throw</strong>: Unexpected errors, validation failures, system errors</li>
<li><strong>Return error</strong>: Expected business failures (payment declined, insufficient inventory)</li>
</ul>
<hr>

<h2>Async/Await Patterns</h2>

<h3>ValueTask vs Task</h3>

<p>Use <code>ValueTask<T></code> for receptor signatures:</p>

<pre><code class="language-csharp">// ✅ CORRECT - ValueTask<T>
<p>public async ValueTask<OrderCreated> HandleAsync(</p>
<p>    CreateOrder message,</p>
<p>    CancellationToken ct = default) {</p>
<p>    // ...</p>
<p>}</p>

<p>// ❌ WRONG - Task<T></p>
<p>public async Task<OrderCreated> HandleAsync(</p>
<p>    CreateOrder message,</p>
<p>    CancellationToken ct = default) {</p>
<p>    // ...</p>
<p>}</p>
<p></code></pre></p>

<strong>Why ValueTask?</strong>
<ul><li>Can complete synchronously (no heap allocation for sync paths)</li>
<li>Can be cached/pooled</li>
<li>Better performance for hot paths</li>
</ul>
<h3>Cancellation Token</h3>

<p>Always accept and pass <code>CancellationToken</code>:</p>

<pre><code class="language-csharp">public async ValueTask<OrderCreated> HandleAsync(
<p>    CreateOrder message,</p>
<p>    CancellationToken ct = default) {  // Accept ct</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    // Pass ct to all async operations</p>
<p>    var customer = await conn.QuerySingleOrDefaultAsync<Customer>(</p>
<p>        "SELECT * FROM customers WHERE customer_id = @CustomerId",</p>
<p>        new { message.CustomerId },</p>
<p>        ct  // ← Pass cancellation token</p>
<p>    );</p>

<p>    // ...</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>Request cancellation support</li>
<li>Graceful shutdown</li>
<li>Resource cleanup</li>
</ul>
<hr>

<h2>Testing Receptors</h2>

<h3>Unit Tests</h3>

<p>Test receptors in isolation:</p>

<pre><code class="language-csharp">public class CreateOrderReceptorTests {
<p>    [Test]</p>
<p>    public async Task HandleAsync_ValidOrder_ReturnsOrderCreatedAsync() {</p>
<p>        // Arrange</p>
<p>        var logger = new NullLogger<CreateOrderReceptor>();</p>
<p>        var receptor = new CreateOrderReceptor(logger);</p>

<p>        var command = new CreateOrder(</p>
<p>            CustomerId: Guid.NewGuid(),</p>
<p>            Items: [</p>
<p>                new OrderLineItem(Guid.NewGuid(), 2, 19.99m),</p>
<p>                new OrderLineItem(Guid.NewGuid(), 1, 49.99m)</p>
<p>            ]</p>
<p>        );</p>

<p>        // Act</p>
<p>        var result = await receptor.HandleAsync(command);</p>

<p>        // Assert</p>
<p>        await Assert.That(result.OrderId).IsNotEqualTo(Guid.Empty);</p>
<p>        await Assert.That(result.CustomerId).IsEqualTo(command.CustomerId);</p>
<p>        await Assert.That(result.Items.Length).IsEqualTo(2);</p>
<p>        await Assert.That(result.Total).IsEqualTo(89.97m);  // (2 * 19.99) + 49.99</p>
<p>    }</p>

<p>    [Test]</p>
<p>    public async Task HandleAsync_EmptyItems_ThrowsValidationExceptionAsync() {</p>
<p>        // Arrange</p>
<p>        var logger = new NullLogger<CreateOrderReceptor>();</p>
<p>        var receptor = new CreateOrderReceptor(logger);</p>

<p>        var command = new CreateOrder(</p>
<p>            CustomerId: Guid.NewGuid(),</p>
<p>            Items: []  // Empty!</p>
<p>        );</p>

<p>        // Act & Assert</p>
<p>        await Assert.That(async () => await receptor.HandleAsync(command))</p>
<p>            .ThrowsException<ValidationException>()</p>
<p>            .WithMessage("Order must contain at least one item");</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Mocking Dependencies</h3>

<p>Use mocks for external dependencies:</p>

<pre><code class="language-csharp">public class CancelOrderReceptorTests {
<p>    [Test]</p>
<p>    public async Task HandleAsync_ExistingOrder_ReturnsOrderCancelledAsync() {</p>
<p>        // Arrange</p>
<p>        var mockDb = CreateMockDb();  // Returns mock with test data</p>
<p>        var logger = new NullLogger<CancelOrderReceptor>();</p>
<p>        var receptor = new CancelOrderReceptor(mockDb, logger);</p>

<p>        var command = new CancelOrder(</p>
<p>            OrderId: TestData.ExistingOrderId,</p>
<p>            Reason: "Customer request"</p>
<p>        );</p>

<p>        // Act</p>
<p>        var result = await receptor.HandleAsync(command);</p>

<p>        // Assert</p>
<p>        await Assert.That(result.OrderId).IsEqualTo(command.OrderId);</p>
<p>        await Assert.That(result.Reason).IsEqualTo("Customer request");</p>
<p>    }</p>

<p>    [Test]</p>
<p>    public async Task HandleAsync_NonExistentOrder_ThrowsNotFoundExceptionAsync() {</p>
<p>        // Arrange</p>
<p>        var mockDb = CreateMockDb();  // Returns null for non-existent order</p>
<p>        var logger = new NullLogger<CancelOrderReceptor>();</p>
<p>        var receptor = new CancelOrderReceptor(mockDb, logger);</p>

<p>        var command = new CancelOrder(</p>
<p>            OrderId: Guid.NewGuid(),  // Doesn't exist</p>
<p>            Reason: "Customer request"</p>
<p>        );</p>

<p>        // Act & Assert</p>
<p>        await Assert.That(async () => await receptor.HandleAsync(command))</p>
<p>            .ThrowsException<NotFoundException>();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Advanced Patterns</h2>

<h3>Pattern: Multi-Step Validation</h3>

<pre><code class="language-csharp">public class ReserveInventoryReceptor : IReceptor<ReserveInventory, InventoryReserved> {
<p>    private readonly IDbConnectionFactory _db;</p>
<p>    private readonly ILogger<ReserveInventoryReceptor> _logger;</p>

<p>    public async ValueTask<InventoryReserved> HandleAsync(</p>
<p>        ReserveInventory message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        // Step 1: Validate order exists</p>
<p>        var order = await ValidateOrderExistsAsync(message.OrderId, ct);</p>

<p>        // Step 2: Check inventory levels</p>
<p>        var inventoryChecks = await CheckInventoryLevelsAsync(order.Items, ct);</p>

<p>        // Step 3: Validate all items in stock</p>
<p>        ValidateAllItemsInStock(inventoryChecks);</p>

<p>        // Step 4: Reserve inventory (business logic)</p>
<p>        var reservations = await CreateReservationsAsync(</p>
<p>            message.OrderId,</p>
<p>            inventoryChecks,</p>
<p>            ct</p>
<p>        );</p>

<p>        // Return event</p>
<p>        return new InventoryReserved(</p>
<p>            OrderId: message.OrderId,</p>
<p>            Reservations: reservations,</p>
<p>            ReservedAt: DateTimeOffset.UtcNow</p>
<p>        );</p>
<p>    }</p>

<p>    private async Task<Order> ValidateOrderExistsAsync(Guid orderId, CancellationToken ct) {</p>
<p>        await using var conn = _db.CreateConnection();</p>
<p>        var order = await conn.QuerySingleOrDefaultAsync<Order>(</p>
<p>            "SELECT * FROM orders WHERE order_id = @OrderId",</p>
<p>            new { OrderId = orderId },</p>
<p>            ct</p>
<p>        );</p>

<p>        if (order is null) {</p>
<p>            throw new NotFoundException($"Order {orderId} not found");</p>
<p>        }</p>

<p>        return order;</p>
<p>    }</p>

<p>    private async Task<InventoryCheck[]> CheckInventoryLevelsAsync(</p>
<p>        OrderLineItem[] items,</p>
<p>        CancellationToken ct) {</p>

<p>        await using var conn = _db.CreateConnection();</p>

<p>        var checks = new List<InventoryCheck>();</p>

<p>        foreach (var item in items) {</p>
<p>            var available = await conn.ExecuteScalarAsync<int>(</p>
<p>                "SELECT available_quantity FROM inventory WHERE product_id = @ProductId",</p>
<p>                new { ProductId = item.ProductId },</p>
<p>                ct</p>
<p>            );</p>

<p>            checks.Add(new InventoryCheck(</p>
<p>                ProductId: item.ProductId,</p>
<p>                RequestedQuantity: item.Quantity,</p>
<p>                AvailableQuantity: available</p>
<p>            ));</p>
<p>        }</p>

<p>        return checks.ToArray();</p>
<p>    }</p>

<p>    private static void ValidateAllItemsInStock(InventoryCheck[] checks) {</p>
<p>        var outOfStock = checks.Where(c => c.AvailableQuantity < c.RequestedQuantity).ToArray();</p>

<p>        if (outOfStock.Length > 0) {</p>
<p>            var productIds = string.Join(", ", outOfStock.Select(c => c.ProductId));</p>
<p>            throw new InsufficientInventoryException(</p>
<p>                $"Insufficient inventory for products: {productIds}"</p>
<p>            );</p>
<p>        }</p>
<p>    }</p>

<p>    private async Task<Reservation[]> CreateReservationsAsync(</p>
<p>        Guid orderId,</p>
<p>        InventoryCheck[] checks,</p>
<p>        CancellationToken ct) {</p>

<p>        await using var conn = _db.CreateConnection();</p>

<p>        var reservations = new List<Reservation>();</p>

<p>        foreach (var check in checks) {</p>
<p>            await conn.ExecuteAsync(</p>
<p>                "UPDATE inventory SET available_quantity = available_quantity - @Quantity WHERE product_id = @ProductId",</p>
<p>                new { ProductId = check.ProductId, Quantity = check.RequestedQuantity },</p>
<p>                ct</p>
<p>            );</p>

<p>            reservations.Add(new Reservation(</p>
<p>                ProductId: check.ProductId,</p>
<p>                Quantity: check.RequestedQuantity</p>
<p>            ));</p>
<p>        }</p>

<p>        return reservations.ToArray();</p>
<p>    }</p>
<p>}</p>

<p>internal record InventoryCheck(</p>
<p>    Guid ProductId,</p>
<p>    int RequestedQuantity,</p>
<p>    int AvailableQuantity</p>
<p>);</p>
<p></code></pre></p>

<h3>Pattern: Saga Coordination</h3>

<pre><code class="language-csharp">public class CompleteOrderReceptor : IReceptor<CompleteOrder, OrderCompleted> {
<p>    private readonly IDispatcher _dispatcher;</p>
<p>    private readonly ILogger<CompleteOrderReceptor> _logger;</p>

<p>    public async ValueTask<OrderCompleted> HandleAsync(</p>
<p>        CompleteOrder message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        // Step 1: Reserve inventory</p>
<p>        var inventoryResult = await _dispatcher.LocalInvokeAsync<ReserveInventory, InventoryReserved>(</p>
<p>            new ReserveInventory(message.OrderId),</p>
<p>            ct</p>
<p>        );</p>

<p>        try {</p>
<p>            // Step 2: Process payment</p>
<p>            var paymentResult = await _dispatcher.LocalInvokeAsync<ProcessPayment, PaymentResult>(</p>
<p>                new ProcessPayment(message.OrderId, message.Amount, message.PaymentMethod),</p>
<p>                ct</p>
<p>            );</p>

<p>            if (!paymentResult.IsSuccess) {</p>
<p>                // Compensate: Release inventory</p>
<p>                await _dispatcher.LocalInvokeAsync<ReleaseInventory, InventoryReleased>(</p>
<p>                    new ReleaseInventory(message.OrderId),</p>
<p>                    ct</p>
<p>                );</p>

<p>                throw new PaymentFailedException($"Payment declined: {paymentResult.ErrorCode}");</p>
<p>            }</p>

<p>            // Step 3: Create shipment</p>
<p>            var shipmentResult = await _dispatcher.LocalInvokeAsync<CreateShipment, ShipmentCreated>(</p>
<p>                new CreateShipment(message.OrderId),</p>
<p>                ct</p>
<p>            );</p>

<p>            return new OrderCompleted(</p>
<p>                OrderId: message.OrderId,</p>
<p>                CompletedAt: DateTimeOffset.UtcNow</p>
<p>            );</p>

<p>        } catch {</p>
<p>            // Compensate: Release inventory if anything fails</p>
<p>            await _dispatcher.LocalInvokeAsync<ReleaseInventory, InventoryReleased>(</p>
<p>                new ReleaseInventory(message.OrderId),</p>
<p>                ct</p>
<p>            );</p>

<p>            throw;</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ Keep receptors <strong>stateless</strong> (no instance fields except injected dependencies)</li>
<li>✅ Use <strong>constructor injection</strong> for dependencies</li>
<li>✅ Validate early, fail fast</li>
<li>✅ Return <strong>events</strong> for commands (facts of what happened)</li>
<li>✅ Use <strong>ValueTask<T></strong> for HandleAsync</li>
<li>✅ Always pass <strong>CancellationToken</strong> to async operations</li>
<li>✅ Log important decisions and errors</li>
<li>✅ Test receptors in isolation</li>
<li>✅ Extract complex validation into private methods</li>
<li>✅ Use <strong>Guid.CreateVersion7()</strong> for IDs (time-ordered)</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Store state in instance fields (except injected dependencies)</li>
<li>❌ Call other receptors directly (use Dispatcher)</li>
<li>❌ Perform long-running operations (offload to background workers)</li>
<li>❌ Catch and suppress exceptions without logging</li>
<li>❌ Return null (throw exception or return error response)</li>
<li>❌ Mix read and write logic (use separate receptors)</li>
<li>❌ Ignore CancellationToken</li>
<li>❌ Use Guid.NewGuid() (use Guid.CreateVersion7() for time-ordering)</li>
</ul>
<hr>

<h2>Further Reading</h2>

<strong>Core Concepts</strong>:
<ul><li><a href="dispatcher.md">Dispatcher</a> - How to invoke receptors</li>
<li><a href="rpc-extraction.md">RPC Response Extraction</a> - Extract specific types from tuple returns</li>
<li><a href="perspectives.md">Perspectives</a> - Event listeners for read models</li>
<li><a href="message-context.md">Message Context</a> - Correlation and causation tracking</li>
</ul>
<strong>Messaging Patterns</strong>:
<ul><li><a href="../messaging/outbox-pattern.md">Outbox Pattern</a> - Reliable event publishing</li>
<li><a href="../messaging/inbox-pattern.md">Inbox Pattern</a> - Exactly-once processing</li>
</ul>
<strong>Testing</strong>:
<ul><li><a href="../testing/receptor-testing.md">Receptor Testing</a> - Comprehensive testing guide</li>
</ul>
<strong>Examples</strong>:
<ul><li><a href="../examples/ecommerce/order-service.md">ECommerce: Order Service</a> - Real-world receptor patterns</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-routing" class="doc-section">
  <h3>routing</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/routing</code></p>
  <div class="doc-content">
<h1>Namespace-Based Routing</h1>

<p>Whizbang uses namespace-based routing to determine where messages flow. Commands and events follow distinct routing patterns optimized for their specific use cases.</p>

<h2>Overview</h2>

<p>Routing in Whizbang is built on two key principles:</p>

<ul><li><strong>Commands → Shared Inbox</strong>: All commands route to a single shared "inbox" topic. Services filter by owned namespaces using routing key patterns.</li>
<li><strong>Events → Namespace Topics</strong>: Events publish to namespace-specific topics. Services subscribe directly to namespaces they care about.</li>
</ul>
<p>This separation provides:</p>
<ul><li><strong>Point-to-point delivery</strong> for commands (exactly one handler)</li>
<li><strong>Pub/sub distribution</strong> for events (multiple subscribers)</li>
<li><strong>Automatic subscription discovery</strong> via source generation</li>
</ul>
<h2>Command Flow</h2>

<p>Commands follow a point-to-point pattern with namespace-based filtering:</p>

<pre><code class="language-">BFF sends CreateTenantCommand (namespace: MyApp.Users.Commands)
<p>    ↓</p>
<p>BFF Outbox → Broker "inbox" topic</p>
<p>    ↓</p>
<p>    RoutingKey: "myapp.users.commands.createtenantcommand"</p>
<p>    ↓</p>
<p>ALL services subscribed to "inbox" (single shared topic)</p>
<p>    ↓</p>
<p>Each service filters by owned namespaces:</p>
<p>    - User Service owns "myapp.users.commands" → RECEIVES</p>
<p>    - Workflow Service owns "myapp.workflow.commands" → FILTERED OUT</p>
<p>    ↓</p>
<p>User Service processes command</p>
<p></code></pre></p>

<h3>How Command Filtering Works</h3>

<p>When a service starts, it declares which command namespaces it owns:</p>

<pre><code class="language-csharp">services.Configure<RoutingOptions>(opts => {
<p>  opts.OwnDomains("myapp.users.commands");</p>
<p>  opts.OwnDomains("myapp.inventory.commands");</p>
<p>});</p>
<p></code></pre></p>

<p>The <code>SharedTopicInboxStrategy</code> builds routing patterns from these namespaces:</p>

<pre><code class="language-csharp">// Generated routing patterns:
<p>// - "whizbang.core.commands.system.#"  (always included)</p>
<p>// - "myapp.users.commands.#"</p>
<p>// - "myapp.inventory.commands.#"</p>
<p></code></pre></p>

<strong>Note</strong>: All services automatically subscribe to system commands (<code>whizbang.core.commands.system.#</code>) for framework-level operations.

<h3>Wildcard Namespaces</h3>

<p>Support pattern matching for flexible ownership:</p>

<pre><code class="language-csharp">// Own all commands under myapp.orders
<p>opts.OwnDomains("myapp.orders.*");</p>
<p>// Converts to pattern: "myapp.orders.#"</p>
<p></code></pre></p>

<h2>Event Flow</h2>

<p>Events follow a pub/sub pattern with namespace-based topics:</p>

<pre><code class="language-">User Service publishes TenantCreatedEvent (namespace: MyApp.Users.Events)
<p>    ↓</p>
<p>User Service Outbox → Broker topic "myapp.users.events"</p>
<p>    ↓</p>
<p>    RoutingKey: "tenantcreatedevent"</p>
<p>    ↓</p>
<p>Services subscribed to "myapp.users.events":</p>
<p>    - BFF → RECEIVES</p>
<p>    - Workflow Service → RECEIVES</p>
<p>    - Notifications Service → RECEIVES</p>
<p></code></pre></p>

<h3>Automatic Event Subscription Discovery</h3>

<p>Event subscriptions are <strong>automatically discovered</strong> from your code via source generation:</p>

<ul><li><strong>Perspectives</strong>: Events your service projects</li>
<li><strong>Receptors</strong>: Events your service handles</li>
</ul>
<pre><code class="language-csharp">// This perspective automatically subscribes to "myapp.orders.events"
<p>[Perspective<OrderSummary>]</p>
<p>public class OrderSummaryPerspective : IPerspective<OrderCreatedEvent> {</p>
<p>  // OrderCreatedEvent is in namespace MyApp.Orders.Events</p>
<p>}</p>

<p>// This receptor automatically subscribes to "myapp.payments.events"</p>
<p>public class PaymentReceptor : IReceptor<PaymentCompletedEvent> {</p>
<p>  // PaymentCompletedEvent is in namespace MyApp.Payments.Events</p>
<p>}</p>
<p></code></pre></p>

<p>The <code>EventNamespaceRegistryGenerator</code> source generator extracts these namespaces at compile time:</p>

<pre><code class="language-csharp">// Generated code (example)
<p>public sealed class GeneratedEventNamespaceRegistry : IEventNamespaceRegistry {</p>
<p>  public IReadOnlySet<string> GetPerspectiveEventNamespaces() =></p>
<p>    new HashSet<string>(StringComparer.OrdinalIgnoreCase) {</p>
<p>      "myapp.orders.events"</p>
<p>    };</p>

<p>  public IReadOnlySet<string> GetReceptorEventNamespaces() =></p>
<p>    new HashSet<string>(StringComparer.OrdinalIgnoreCase) {</p>
<p>      "myapp.payments.events"</p>
<p>    };</p>
<p>}</p>
<p></code></pre></p>

<h3>Manual Event Subscriptions</h3>

<p>Override or supplement auto-discovery with manual subscriptions:</p>

<pre><code class="language-csharp">services.Configure<RoutingOptions>(opts => {
<p>  // Explicitly subscribe to additional event namespaces</p>
<p>  opts.SubscribeTo("myapp.notifications.events");</p>
<p>  opts.SubscribeTo("myapp.audit.events");</p>
<p>});</p>
<p></code></pre></p>

<h2>System Commands</h2>

<p>All services automatically subscribe to system commands for framework-level operations:</p>

<pre><code class="language-csharp">namespace Whizbang.Core.Commands.System;

<p>// Rebuild a perspective across all services</p>
<p>public record RebuildPerspectiveCommand(</p>
<p>    string PerspectiveName,</p>
<p>    long? FromEventId = null</p>
<p>) : ICommand;</p>

<p>// Clear cached data</p>
<p>public record ClearCacheCommand(</p>
<p>    string? CacheKey = null,</p>
<p>    string? CacheRegion = null</p>
<p>) : ICommand;</p>

<p>// Collect diagnostics from all services</p>
<p>public record DiagnosticsCommand(</p>
<p>    DiagnosticType Type,</p>
<p>    Guid? CorrelationId = null</p>
<p>) : ICommand;</p>

<p>// Pause message processing (coordinated maintenance)</p>
<p>public record PauseProcessingCommand(</p>
<p>    int? DurationSeconds = null,</p>
<p>    string? Reason = null</p>
<p>) : ICommand;</p>

<p>// Resume message processing</p>
<p>public record ResumeProcessingCommand(</p>
<p>    string? Reason = null</p>
<p>) : ICommand;</p>
<p></code></pre></p>

<h3>Sending System Commands</h3>

<pre><code class="language-csharp">// Rebuild a perspective across all services
<p>await dispatcher.SendAsync(new RebuildPerspectiveCommand("OrderSummary"));</p>

<p>// Clear all caches</p>
<p>await dispatcher.SendAsync(new ClearCacheCommand());</p>

<p>// Pause processing for 5 minutes</p>
<p>await dispatcher.SendAsync(new PauseProcessingCommand(</p>
<p>    DurationSeconds: 300,</p>
<p>    Reason: "Scheduled maintenance"</p>
<p>));</p>
<p></code></pre></p>

<h2>Configuration</h2>

<h3>Fluent Configuration with WithRouting {#with-routing}</h3>

<p>The recommended approach uses the fluent <code>WithRouting()</code> extension method:</p>

<pre><code class="language-csharp">services.AddWhizbang()
<p>    .WithRouting(routing => {</p>
<p>        routing</p>
<p>            .OwnDomains("myapp.users.commands")</p>
<p>            .SubscribeTo("myapp.notifications.events")</p>
<p>            .Inbox.UseSharedTopic("inbox");</p>
<p>    })</p>
<p>    .WithEFCore<MyDbContext>()</p>
<p>    .WithDriver.Postgres</p>
<p>    .AddTransportConsumer();  // Auto-generates subscriptions!</p>
<p></code></pre></p>

<p>This approach:</p>
<ul><li><strong>Chains with other Whizbang configuration</strong> - Integrates with EF Core, drivers, and transport setup</li>
<li><strong>Auto-generates subscriptions</strong> - When paired with <code>AddTransportConsumer()</code>, subscriptions are created automatically</li>
<li><strong>Type-safe</strong> - All configuration is compile-time verified</li>
</ul>
<h3>Complete Example</h3>

<pre><code class="language-csharp">// User Service - handles user commands, subscribes to order events
<p>services.AddWhizbang()</p>
<p>    .WithRouting(routing => {</p>
<p>        // Commands this service handles</p>
<p>        routing.OwnDomains("myapp.users.commands");</p>

<p>        // Events are auto-discovered from perspectives/receptors</p>
<p>        // Manual override (adds to auto-discovered):</p>
<p>        routing.SubscribeTo("myapp.notifications.events");</p>

<p>        // Inbox strategy</p>
<p>        routing.Inbox.UseSharedTopic("inbox");</p>
<p>    })</p>
<p>    .AddTransportConsumer();</p>

<p>// BFF Service - sends commands, receives events</p>
<p>services.AddWhizbang()</p>
<p>    .WithRouting(routing => {</p>
<p>        // No OwnDomains (BFF doesn't handle commands directly)</p>
<p>        // Events auto-discovered from its receptors/perspectives</p>
<p>        routing.Inbox.UseSharedTopic("inbox");</p>
<p>    })</p>
<p>    .AddTransportConsumer();</p>
<p></code></pre></p>

<h3>Legacy Configuration</h3>

<p>For backwards compatibility, you can still configure routing options directly:</p>

<pre><code class="language-csharp">services.Configure<RoutingOptions>(opts => {
<p>  opts.OwnDomains("myapp.users.commands");</p>
<p>  opts.SubscribeTo("myapp.notifications.events");</p>
<p>});</p>
<p></code></pre></p>

<h3>Strongly-Typed Configuration</h3>

<p>Use the generic overloads for compile-time safety and refactor-friendly configuration:</p>

<pre><code class="language-csharp">services.Configure<RoutingOptions>(opts => {
<p>  // Strongly-typed: extracts namespace from the type</p>
<p>  opts.OwnNamespaceOf<CreateUserCommand>()      // "myapp.users.commands"</p>
<p>      .OwnNamespaceOf<UpdateInventoryCommand>() // "myapp.inventory.commands"</p>
<p>      .SubscribeToNamespaceOf<OrderCreatedEvent>()   // "myapp.orders.events"</p>
<p>      .SubscribeToNamespaceOf<PaymentCompletedEvent>(); // "myapp.payments.events"</p>

<p>  // Can mix with string-based for wildcards</p>
<p>  opts.OwnDomains("myapp.legacy.*");</p>
<p>});</p>
<p></code></pre></p>

<strong>Benefits:</strong>
<ul><li><strong>Compile-time safety</strong> - Invalid types won't compile</li>
<li><strong>Refactor-friendly</strong> - Rename/move types automatically updates references</li>
<li><strong>IDE navigation</strong> - Ctrl+click to go to type definition</li>
<li><strong>No magic strings</strong> - For known namespaces</li>
</ul>
<h3>Inbox Strategies</h3>

<p>Two inbox routing strategies are available:</p>

<h4>SharedTopicInboxStrategy (Default)</h4>

<p>All commands go to a single "inbox" topic with namespace-based filtering:</p>

<pre><code class="language-csharp">services.Configure<RoutingOptions>(opts => {
<p>  opts.Inbox.UseSharedTopic("inbox");  // Default</p>
<p>});</p>
<p></code></pre></p>

<h4>DomainTopicInboxStrategy</h4>

<p>Each domain gets its own inbox topic:</p>

<pre><code class="language-csharp">services.Configure<RoutingOptions>(opts => {
<p>  opts.Inbox.UseDomainTopics(".in");</p>
<p>  // Creates topics: "myapp.users.in", "myapp.orders.in", etc.</p>
<p>});</p>
<p></code></pre></p>

<h2>Domain Topic Provisioning {#domain-topic-provisioning}</h2>

<p>:::new</p>
<p>When a service declares domain ownership via <code>OwnDomains()</code>, Whizbang automatically provisions the corresponding topics/exchanges on the message broker at worker startup. This ensures the domain owner (publisher) creates infrastructure that subscribers will use.</p>
<p>:::</p>

<h3>How It Works</h3>

<p>At <code>TransportConsumerWorker</code> startup, before creating subscriptions:</p>

<ul><li>The worker checks for a registered <code>IInfrastructureProvisioner</code></li>
<li>If present, it calls <code>ProvisionOwnedDomainsAsync()</code> with the service's owned domains</li>
<li>The provisioner creates topics/exchanges for each owned domain</li>
<li>Then subscriptions are created as normal</li>
</ul>
<pre><code class="language-csharp">// When you configure:
<p>services.AddWhizbang()</p>
<p>    .WithRouting(routing => {</p>
<p>        routing.OwnDomains("myapp.users", "myapp.orders");</p>
<p>    })</p>
<p>    .AddTransportConsumer();</p>

<p>// At startup, these topics are automatically provisioned:</p>
<p>// - myapp.users (topic/exchange)</p>
<p>// - myapp.orders (topic/exchange)</p>
<p></code></pre></p>

<h3>Transport-Specific Behavior</h3>

<p>| Transport | Provisioned Resource | Idempotent |</p>
<p>|-----------|---------------------|------------|</p>
<p>| RabbitMQ | Topic exchange (durable) | Yes |</p>
<p>| Azure Service Bus | Topic | Yes |</p>

<h3>RabbitMQ</h3>

<p>For RabbitMQ, <code>RabbitMQInfrastructureProvisioner</code> declares topic exchanges:</p>

<pre><code class="language-csharp">// Provisioning is automatic when using AddRabbitMQTransport
<p>services.AddRabbitMQTransport(connectionString);</p>

<p>// Results in ExchangeDeclareAsync for each owned domain:</p>
<p>// - Exchange: "myapp.users", Type: "topic", Durable: true</p>
<p>// - Exchange: "myapp.orders", Type: "topic", Durable: true</p>
<p></code></pre></p>

<p>Exchange creation is idempotent - calling <code>ExchangeDeclareAsync</code> multiple times is safe.</p>

<h3>Azure Service Bus</h3>

<p>For Azure Service Bus, <code>ServiceBusInfrastructureProvisioner</code> creates topics via the Administration API:</p>

<pre><code class="language-csharp">// Add transport and provisioner separately
<p>// (provisioning requires Manage permissions)</p>
<p>services.AddAzureServiceBusTransport(connectionString);</p>
<p>services.AddAzureServiceBusProvisioner(adminConnectionString);</p>

<p>// Results in CreateTopicIfNotExistsAsync for each owned domain:</p>
<p>// - Topic: "myapp.users"</p>
<p>// - Topic: "myapp.orders"</p>
<p></code></pre></p>

<strong>Note</strong>: Topic provisioning requires a connection string with <strong>Manage</strong> permissions. In production, topics are often pre-provisioned via infrastructure-as-code, so <code>AddAzureServiceBusProvisioner</code> is optional.

<h3>Custom Provisioners</h3>

<p>Implement <code>IInfrastructureProvisioner</code> for custom transport providers:</p>

<pre><code class="language-csharp">public interface IInfrastructureProvisioner {
<p>    Task ProvisionOwnedDomainsAsync(</p>
<p>        IReadOnlySet<string> ownedDomains,</p>
<p>        CancellationToken cancellationToken = default);</p>
<p>}</p>

<p>// Example custom implementation</p>
<p>public class MyCustomProvisioner : IInfrastructureProvisioner {</p>
<p>    public async Task ProvisionOwnedDomainsAsync(</p>
<p>        IReadOnlySet<string> ownedDomains,</p>
<p>        CancellationToken cancellationToken = default) {</p>
<p>        foreach (var domain in ownedDomains) {</p>
<p>            var topicName = domain.ToLowerInvariant();</p>
<p>            await CreateTopicAsync(topicName, cancellationToken);</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Transport Subscription Builder</h2>

<p>The <code>TransportSubscriptionBuilder</code> combines inbox and event subscriptions for transport configuration:</p>

<pre><code class="language-csharp">// Build all destinations for transport subscription
<p>var builder = new TransportSubscriptionBuilder(</p>
<p>    routingOptions,</p>
<p>    eventSubscriptionDiscovery,</p>
<p>    serviceName: "OrderService"</p>
<p>);</p>

<p>var destinations = builder.BuildDestinations();</p>
<p>// Returns:</p>
<p>// - Inbox destination with command filtering</p>
<p>// - Event namespace destinations (auto + manual)</p>

<p>// Configure transport options</p>
<p>builder.ConfigureOptions(transportOptions);</p>
<p></code></pre></p>

<h3>Destination Structure</h3>

<p>Each destination contains:</p>

<pre><code class="language-csharp">public record TransportDestination(
<p>    string Address,        // Topic/queue name</p>
<p>    string? RoutingKey,    // Routing key pattern (e.g., "#" for all)</p>
<p>    IReadOnlyDictionary<string, JsonElement>? Metadata</p>
<p>);</p>
<p></code></pre></p>

<h2>Broker Integration</h2>

<h3>RabbitMQ</h3>

<ul><li><strong>Commands</strong>: Single "inbox" exchange with routing key pattern matching</li>
<li><strong>Events</strong>: One exchange per namespace with topic routing</li>
</ul>
<pre><code class="language-">Exchange: inbox
<p>  Binding: myapp.users.commands.# → queue: user-service-inbox</p>
<p>  Binding: myapp.inventory.commands.# → queue: inventory-service-inbox</p>

<p>Exchange: myapp.orders.events</p>
<p>  Binding: # → queue: user-service-orders</p>
<p>  Binding: # → queue: bff-orders</p>
<p></code></pre></p>

<h3>Azure Service Bus</h3>

<ul><li><strong>Commands</strong>: Single "inbox" topic with CorrelationFilter on routing key</li>
<li><strong>Events</strong>: One topic per namespace with subscriptions</li>
</ul>
<pre><code class="language-">Topic: inbox
<p>  Subscription: user-service (filter: RoutingKey LIKE 'myapp.users.commands.%')</p>
<p>  Subscription: inventory-service (filter: RoutingKey LIKE 'myapp.inventory.commands.%')</p>

<p>Topic: myapp.orders.events</p>
<p>  Subscription: user-service</p>
<p>  Subscription: bff</p>
<p></code></pre></p>

<h2>Best Practices</h2>

<h3>1. Use Consistent Namespace Conventions</h3>

<pre><code class="language-csharp">// ✅ GOOD: Clear, hierarchical namespaces
<p>namespace MyApp.Users.Commands;</p>
<p>namespace MyApp.Users.Events;</p>
<p>namespace MyApp.Orders.Commands;</p>
<p>namespace MyApp.Orders.Events;</p>

<p>// ❌ BAD: Flat or inconsistent namespaces</p>
<p>namespace MyAppCommands;</p>
<p>namespace OrderEvents;</p>
<p></code></pre></p>

<h3>2. Prefer Strongly-Typed Configuration</h3>

<pre><code class="language-csharp">// ✅ GOOD: Strongly-typed, refactor-safe
<p>opts.OwnNamespaceOf<CreateUserCommand>()</p>
<p>    .SubscribeToNamespaceOf<OrderCreatedEvent>();</p>

<p>// ❌ BAD: Magic strings, typo-prone</p>
<p>opts.OwnDomains("myapp.users.comands");  // Typo won't be caught until runtime</p>
<p></code></pre></p>

<h3>3. Let Auto-Discovery Do the Work</h3>

<pre><code class="language-csharp">// ✅ GOOD: Events discovered automatically
<p>[Perspective<OrderSummary>]</p>
<p>public class OrderSummaryPerspective : IPerspective<OrderCreatedEvent> {</p>
<p>  // Auto-subscribes to "myapp.orders.events"</p>
<p>}</p>

<p>// ❌ BAD: Manually subscribing to everything</p>
<p>opts.SubscribeTo("myapp.orders.events");</p>
<p>opts.SubscribeTo("myapp.payments.events");</p>
<p>opts.SubscribeTo("myapp.users.events");</p>
<p>// ... 20 more manual subscriptions</p>
<p></code></pre></p>

<h3>4. Use Manual Subscriptions for Cross-Cutting Concerns</h3>

<pre><code class="language-csharp">// ✅ GOOD: Manual subscription for audit/logging service
<p>services.Configure<RoutingOptions>(opts => {</p>
<p>  opts.SubscribeTo("myapp.*.events");  // All events for auditing</p>
<p>});</p>
<p></code></pre></p>

<h3>5. Validate Subscriptions at Startup</h3>

<pre><code class="language-csharp">// Ensure all expected namespaces are subscribed
<p>var discovery = services.GetRequiredService<EventSubscriptionDiscovery>();</p>
<p>var namespaces = discovery.DiscoverAll();</p>

<p>logger.LogInformation(</p>
<p>    "Subscribed to {Count} event namespaces: {Namespaces}",</p>
<p>    namespaces.Count,</p>
<p>    string.Join(", ", namespaces)</p>
<p>);</p>
<p></code></pre></p>

<h2>Related Documentation</h2>

<ul><li><a href="./transport-consumer.md">Transport Consumer</a> - Auto-generated transport subscriptions</li>
<li><a href="./system-events.md">System Events</a> - System-level event auditing</li>
<li><a href="./security.md">Security</a> - Permissions and access control</li>
<li><a href="./scoping.md">Scoping</a> - Multi-tenancy and data isolation</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-rpc-extraction" class="doc-section">
  <h3>rpc extraction</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/rpc-extraction</code></p>
  <div class="doc-content">
<h1>RPC Response Extraction</h1>

<p>RPC (Remote Procedure Call) style invocations allow you to call a receptor and receive a specific response type back, while other returned values cascade through normal routing.</p>

<h2>Overview</h2>

<p>When using <code>LocalInvokeAsync<TResponse>(command)</code>, the dispatcher:</p>

<ul><li><strong>Extracts</strong> the requested <code>TResponse</code> type from the receptor's return value</li>
<li><strong>Returns</strong> that value directly to the caller</li>
<li><strong>Cascades</strong> all other returned values through normal routing (outbox by default)</li>
</ul>
<p>This enables receptors to return multiple values (via tuples) while callers receive only what they need.</p>

<h2>Example</h2>

<pre><code class="language-csharp">// Command
<p>public record CreateOrder(Guid OrderId, decimal Amount);</p>

<p>// Response types</p>
<p>public record OrderConfirmation {</p>
<p>  public required Guid OrderId { get; init; }</p>
<p>  public required string ConfirmationCode { get; init; }</p>
<p>}</p>

<p>[DefaultRouting(DispatchMode.Outbox)]</p>
<p>public record InventoryReserved([property: StreamKey] Guid OrderId) : IEvent;</p>

<p>// Receptor returns tuple: (response to caller, event to cascade)</p>
<p>public class CreateOrderReceptor</p>
<p>    : IReceptor<CreateOrder, (OrderConfirmation, InventoryReserved)> {</p>

<p>  public ValueTask<(OrderConfirmation, InventoryReserved)> HandleAsync(</p>
<p>      CreateOrder command,</p>
<p>      CancellationToken ct = default) {</p>

<p>    var confirmation = new OrderConfirmation {</p>
<p>      OrderId = command.OrderId,</p>
<p>      ConfirmationCode = $"CONF-{command.OrderId:N}"</p>
<p>    };</p>

<p>    var inventory = new InventoryReserved(command.OrderId);</p>

<p>    return ValueTask.FromResult((confirmation, inventory));</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Caller Side</h3>

<pre><code class="language-csharp">// RPC call - OrderConfirmation returned to caller
<p>var confirmation = await dispatcher.LocalInvokeAsync<OrderConfirmation>(</p>
<p>    new CreateOrder(Guid.NewGuid(), 99.99m));</p>

<p>// InventoryReserved automatically cascades to outbox (per [DefaultRouting])</p>
<p>// confirmation.ConfirmationCode is available to caller</p>
<p></code></pre></p>

<h2>How It Works</h2>

<h3>Response Extraction</h3>

<p>The <code>ResponseExtractor</code> utility extracts the requested type from complex return values:</p>

<p>| Return Type | Extraction Behavior |</p>
<p>|-------------|---------------------|</p>
<p>| Single value | Direct match returns immediately |</p>
<p>| Tuple <code>(A, B, C)</code> | Searches each element for match |</p>
<p>| Array/List | Searches each element for match |</p>
<p>| <code>Routed<T></code> wrapper | Unwraps and extracts from inner value |</p>

<h3>Cascade Exclusion</h3>

<p>After extraction, remaining values cascade based on their routing:</p>

<ul><li><strong>Extracted response</strong>: Returned to RPC caller (NOT cascaded)</li>
<li><strong>Other <code>IEvent</code> values</strong>: Cascade per routing (<code>[DefaultRouting]</code> or wrapper)</li>
<li><strong>Non-message values</strong>: Ignored (not cascaded)</li>
</ul>
<h3>Routing Wrappers Ignored for RPC</h3>

<p>RPC responses are extracted regardless of routing wrappers:</p>

<pre><code class="language-csharp">// Even if wrapped in Route.Local() or Route.Outbox(),
<p>// the value is still extracted and returned to RPC caller</p>
<p>return (Route.Local(confirmation), inventory);</p>
<p>// confirmation goes to caller, inventory cascades</p>
<p></code></pre></p>

<h2>Supported Return Types</h2>

<h3>Tuples (2-8 elements)</h3>

<pre><code class="language-csharp">// 2-tuple
<p>IReceptor<Cmd, (Response, Event)></p>

<p>// 3-tuple</p>
<p>IReceptor<Cmd, (Response, Event1, Event2)></p>
<p></code></pre></p>

<h3>Mixed with Routing</h3>

<pre><code class="language-csharp">// Explicit routing on cascaded events
<p>IReceptor<Cmd, (Response, Routed<CacheInvalidated>)></p>
<p></code></pre></p>

<h3>Interface-Based Extraction</h3>

<pre><code class="language-csharp">// Extract by interface
<p>var evt = await dispatcher.LocalInvokeAsync<IEvent>(command);</p>
<p>// Returns first IEvent found in tuple</p>
<p></code></pre></p>

<h2>Discriminated Unions</h2>

<p>Receptors can return discriminated union-style tuples where only one value is populated and others are explicitly empty using <code>Route.None()</code> or <code>null</code>.</p>

<h3>Using Route.None()</h3>

<code>Route.None()</code> explicitly marks a tuple position as "no value":

<pre><code class="language-csharp">// Receptor returning success OR failure
<p>public class ProcessPaymentReceptor</p>
<p>    : IReceptor<ProcessPayment, (PaymentSucceeded?, PaymentFailed?)> {</p>

<p>  public async ValueTask<(PaymentSucceeded?, PaymentFailed?)> HandleAsync(</p>
<p>      ProcessPayment command,</p>
<p>      CancellationToken ct = default) {</p>

<p>    var result = await _paymentService.ProcessAsync(command);</p>

<p>    if (result.Success) {</p>
<p>      // Success path - failure is Route.None()</p>
<p>      return (new PaymentSucceeded(command.PaymentId), null);</p>
<p>    } else {</p>
<p>      // Failure path - success is null</p>
<p>      return (null, new PaymentFailed(command.PaymentId, result.Error));</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Extracting from Discriminated Unions</h3>

<p>The caller extracts whichever value is present:</p>

<pre><code class="language-csharp">// Try to extract success
<p>var success = await dispatcher.LocalInvokeAsync<PaymentSucceeded>(command);</p>
<p>// Returns PaymentSucceeded if success path was taken</p>
<p>// Throws InvalidOperationException if failure path (success was null)</p>
<p></code></pre></p>

<h3>Explicit Route.None() Syntax</h3>

<p>For more explicit code, use <code>Route.None()</code> instead of <code>null</code>:</p>

<pre><code class="language-csharp">return (success: Route.None(), failure: new PaymentFailed(...));
<p></code></pre></p>

<code>Route.None()</code> values are:
<ul><li><strong>Never extracted</strong> as RPC responses</li>
<li><strong>Never cascaded</strong> as events</li>
<li><strong>AOT-compatible</strong> (simple struct with <code>DispatchMode.None</code>)</li>
</ul>
<h3>Three-Way Unions</h3>

<p>Discriminated unions can have more than two paths:</p>

<pre><code class="language-csharp">// Success, validation error, or system error
<p>IReceptor<Cmd, (SuccessResult?, ValidationError?, SystemError?)></p>

<p>// Implementation</p>
<p>return command.Amount < 0</p>
<p>    ? (null, new ValidationError("Amount must be positive"), null)</p>
<p>    : command.Amount > 10000</p>
<p>    ? (null, null, new SystemError("Amount exceeds limit"))</p>
<p>    : (new SuccessResult(command.Amount), null, null);</p>
<p></code></pre></p>

<h2>Error Handling</h2>

<h3>Type Not Found</h3>

<p>If the requested type doesn't exist in the return value:</p>

<pre><code class="language-csharp">// Receptor returns (OrderConfirmation, InventoryReserved)
<p>// But caller requests PaymentProcessed</p>
<p>await dispatcher.LocalInvokeAsync<PaymentProcessed>(command);</p>
<p>// Throws InvalidOperationException</p>
<p></code></pre></p>

<h3>Multiple Matches</h3>

<p>If multiple values match the requested type, the <strong>first</strong> match is returned:</p>

<pre><code class="language-csharp">// Tuple: (OrderCreated{Id="first"}, OrderCreated{Id="second"})
<p>var order = await dispatcher.LocalInvokeAsync<OrderCreated>(command);</p>
<p>// order.Id == "first"</p>
<p></code></pre></p>

<h2>Performance Considerations</h2>

<h3>Fast Path (Exact Match)</h3>

<p>When the receptor's return type exactly matches <code>TResponse</code>, no extraction is needed:</p>

<pre><code class="language-csharp">// Receptor: IReceptor<Cmd, OrderConfirmation>
<p>// Caller: LocalInvokeAsync<OrderConfirmation>(cmd)</p>
<p>// Result: Fast path - no extraction overhead</p>
<p></code></pre></p>

<h3>Extraction Path</h3>

<p>When types differ, extraction adds minimal overhead:</p>

<ul><li>Uses <code>ITuple</code> interface (AOT-compatible)</li>
<li>No reflection - pattern matching only</li>
<li>Single pass through tuple elements</li>
</ul>
<h2>AOT Compatibility</h2>

<p>RPC extraction is fully AOT-compatible:</p>

<ul><li>Uses <code>ITuple</code> interface for tuple handling</li>
<li>Pattern matching with <code>is TResponse</code></li>
<li>No <code>Type.GetType()</code> or reflection APIs</li>
<li><code>ReferenceEquals</code> for cascade exclusion</li>
</ul>
<h2>Best Practices</h2>

<ul><li><strong>Return tuples for multi-value responses</strong></li>
</ul><p>   - Clear separation between RPC response and events</p>
<p>   - Explicit about what cascades vs returns</p>

<ul><li><strong>Use <code>[DefaultRouting]</code> on events</strong></li>
</ul><p>   - Cascaded events route automatically</p>
<p>   - No need for explicit <code>Route.Outbox()</code> wrappers</p>

<ul><li><strong>Request specific types</strong></li>
</ul><p>   - Avoid interface-based extraction when possible</p>
<p>   - More predictable behavior with concrete types</p>

<ul><li><strong>Handle extraction failures</strong></li>
</ul><p>   - Wrap calls in try-catch for production code</p>
<p>   - Log when extraction fails for debugging</p>

<h2>Related Documentation</h2>

<ul><li><a href="dispatcher.md">Dispatcher</a> - Core dispatch mechanics</li>
<li><a href="receptors.md">Receptors</a> - Handler implementation</li>
<li><a href="../messaging/routing.md">Message Routing</a> - Routing configuration</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-scoping" class="doc-section">
  <h3>scoping</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/scoping</code></p>
  <div class="doc-content">
<h1>Scoping System</h1>

<p>Whizbang's scoping system provides flexible multi-tenancy and data isolation through composable filters, enabling tenant, user, organization, and principal-based access patterns.</p>

<h2>Overview</h2>

<p>Scoping in Whizbang separates data isolation concerns from your domain models:</p>

<ul><li><strong>PerspectiveScope</strong> - Metadata stored with each row (TenantId, UserId, etc.)</li>
<li><strong>ScopeFilter</strong> - Composable flags for query filtering</li>
<li><strong>ScopeFilterBuilder</strong> - Builds filter info from flags and context</li>
<li><strong>IScopedLensFactory</strong> - Resolves lenses with scope filters applied</li>
</ul>
<h2>PerspectiveScope</h2>

<code>PerspectiveScope</code> is stored in the <code>scope</code> column of perspective rows, separate from your data model.

<pre><code class="language-csharp">public record PerspectiveScope {
<p>  // Standard scope properties</p>
<p>  public string? TenantId { get; init; }</p>
<p>  public string? UserId { get; init; }</p>
<p>  public string? OrganizationId { get; init; }</p>
<p>  public string? CustomerId { get; init; }</p>

<p>  // Security principal access list</p>
<p>  public IReadOnlyList<SecurityPrincipalId>? AllowedPrincipals { get; init; }</p>

<p>  // Custom extension properties</p>
<p>  public IReadOnlyDictionary<string, string?>? Extensions { get; init; }</p>

<p>  // Unified indexer access</p>
<p>  public string? this[string key] => ...;</p>
<p>}</p>
<p></code></pre></p>

<h3>Why Separate from Data?</h3>

<p>Storing scope separately from your domain data provides:</p>

<ul><li><strong>Clean domain models</strong> - Your <code>Order</code> class doesn't need <code>TenantId</code></li>
<li><strong>Consistent filtering</strong> - All perspectives filter the same way</li>
<li><strong>Flexible extensions</strong> - Add custom scope properties without schema changes</li>
<li><strong>Security isolation</strong> - Scope enforcement happens at infrastructure level</li>
</ul>
<h3>Accessing Scope Values</h3>

<pre><code class="language-csharp">var scope = new PerspectiveScope {
<p>  TenantId = "tenant-123",</p>
<p>  UserId = "user-456",</p>
<p>  Extensions = new Dictionary<string, string?> {</p>
<p>    ["department"] = "Engineering",</p>
<p>    ["region"] = "us-west"</p>
<p>  }</p>
<p>};</p>

<p>// Via properties</p>
<p>var tenant = scope.TenantId;  // "tenant-123"</p>

<p>// Via indexer (standard + extensions)</p>
<p>var tenant = scope["TenantId"];     // "tenant-123"</p>
<p>var dept = scope["department"];     // "Engineering"</p>
<p>var unknown = scope["unknown"];     // null</p>
<p></code></pre></p>

<h2>Scope Filters</h2>

<code>ScopeFilter</code> is a flags enum for composable filtering.

<pre><code class="language-csharp">[Flags]
<p>public enum ScopeFilter {</p>
<p>  None = 0,           // No filtering (global access)</p>
<p>  Tenant = 1 << 0,    // Filter by TenantId</p>
<p>  Organization = 1 << 1,</p>
<p>  Customer = 1 << 2,</p>
<p>  User = 1 << 3,      // Filter by UserId</p>
<p>  Principal = 1 << 4  // Filter by security principal overlap</p>
<p>}</p>
<p></code></pre></p>

<h3>Filter Composition</h3>

<p>Combine filters with bitwise OR:</p>

<pre><code class="language-csharp">// Single filter
<p>var tenantOnly = ScopeFilter.Tenant;</p>

<p>// Multiple filters (AND'd together)</p>
<p>var tenantAndUser = ScopeFilter.Tenant | ScopeFilter.User;</p>

<p>// Complex combination</p>
<p>var complex = ScopeFilter.Tenant | ScopeFilter.Organization | ScopeFilter.Principal;</p>
<p></code></pre></p>

<h3>Filter Application</h3>

<p>| Filter | Generated WHERE |</p>
<p>|--------|-----------------|</p>
<p>| <code>None</code> | <em>(no filter)</em> |</p>
<p>| <code>Tenant</code> | <code>WHERE scope->>'TenantId' = ?</code> |</p>
<p>| <code>Tenant \| User</code> | <code>WHERE scope->>'TenantId' = ? AND scope->>'UserId' = ?</code> |</p>
<p>| <code>Tenant \| Principal</code> | <code>WHERE scope->>'TenantId' = ? AND scope->'AllowedPrincipals' ?| [...]</code> |</p>
<p>| <code>Tenant \| User \| Principal</code> | <code>WHERE scope->>'TenantId' = ? AND (scope->>'UserId' = ? OR scope->'AllowedPrincipals' ?| [...])</code> |</p>

<h3>Special OR Logic</h3>

<p>When both <code>User</code> and <code>Principal</code> filters are specified, they're OR'd together (not AND'd). This enables the "my records OR shared with me" pattern:</p>

<pre><code class="language-csharp">// Get my orders and orders shared with my groups
<p>var lens = factory.GetMyOrSharedLens<IOrderLens>();</p>
<p>// Equivalent to: Tenant | User | Principal</p>

<p>// Generated: WHERE TenantId = ? AND (UserId = ? OR AllowedPrincipals ?| [...])</p>
<p></code></pre></p>

<h2>Scope Filter Builder</h2>

<code>ScopeFilterBuilder</code> builds filter information from flags and the current scope context.

<pre><code class="language-csharp">// Build filter info
<p>var filterInfo = ScopeFilterBuilder.Build(</p>
<p>  ScopeFilter.Tenant | ScopeFilter.User,</p>
<p>  scopeContext);</p>

<p>// Filter info contains:</p>
<p>filterInfo.Filters;        // ScopeFilter.Tenant | ScopeFilter.User</p>
<p>filterInfo.TenantId;       // "tenant-123"</p>
<p>filterInfo.UserId;         // "user-456"</p>
<p>filterInfo.UseOrLogicForUserAndPrincipal;  // false</p>
<p></code></pre></p>

<h3>ScopeFilterInfo</h3>

<pre><code class="language-csharp">public readonly record struct ScopeFilterInfo {
<p>  public ScopeFilter Filters { get; init; }</p>
<p>  public string? TenantId { get; init; }</p>
<p>  public string? UserId { get; init; }</p>
<p>  public string? OrganizationId { get; init; }</p>
<p>  public string? CustomerId { get; init; }</p>
<p>  public IReadOnlySet<SecurityPrincipalId> SecurityPrincipals { get; init; }</p>
<p>  public bool UseOrLogicForUserAndPrincipal { get; init; }</p>
<p>  public bool IsEmpty { get; }</p>
<p>}</p>
<p></code></pre></p>

<h2>IScopedLensFactory</h2>

<p>The factory resolves lenses with scope filters automatically applied.</p>

<pre><code class="language-csharp">// Get lens with specific filters
<p>var lens = factory.GetLens<IOrderLens>(ScopeFilter.Tenant);</p>

<p>// Get lens with filters + permission check</p>
<p>var lens = factory.GetLens<IOrderLens>(</p>
<p>  ScopeFilter.Tenant,</p>
<p>  Permission.Read("orders"));</p>

<p>// Convenience methods</p>
<p>factory.GetGlobalLens<T>();       // ScopeFilter.None</p>
<p>factory.GetTenantLens<T>();       // ScopeFilter.Tenant</p>
<p>factory.GetUserLens<T>();         // Tenant | User</p>
<p>factory.GetOrganizationLens<T>(); // Tenant | Organization</p>
<p>factory.GetCustomerLens<T>();     // Tenant | Customer</p>
<p>factory.GetPrincipalLens<T>();    // Tenant | Principal</p>
<p>factory.GetMyOrSharedLens<T>();   // Tenant | User | Principal</p>
<p></code></pre></p>

<h3>IFilterableLens</h3>

<p>Lenses that support filtering implement <code>IFilterableLens</code>:</p>

<pre><code class="language-csharp">public interface IFilterableLens {
<p>  void ApplyFilter(ScopeFilterInfo filterInfo);</p>
<p>}</p>
<p></code></pre></p>

<p>When a lens is resolved through <code>IScopedLensFactory</code>, the filter info is automatically applied.</p>

<h2>Common Patterns</h2>

<h3>Tenant Isolation</h3>

<p>Every record belongs to exactly one tenant:</p>

<pre><code class="language-csharp">// Store with tenant scope
<p>await perspective.UpsertAsync(streamId, order, new PerspectiveScope {</p>
<p>  TenantId = currentTenant</p>
<p>});</p>

<p>// Query within tenant</p>
<p>var lens = factory.GetTenantLens<IOrderLens>();</p>
<p>var orders = await lens.GetAllAsync();  // Only current tenant's orders</p>
<p></code></pre></p>

<h3>User Ownership</h3>

<p>Records owned by specific users:</p>

<pre><code class="language-csharp">// Store with user scope
<p>await perspective.UpsertAsync(streamId, savedSearch, new PerspectiveScope {</p>
<p>  TenantId = currentTenant,</p>
<p>  UserId = currentUser</p>
<p>});</p>

<p>// Query user's records</p>
<p>var lens = factory.GetUserLens<ISavedSearchLens>();</p>
<p>var searches = await lens.GetAllAsync();  // Only current user's searches</p>
<p></code></pre></p>

<h3>Group-Based Sharing</h3>

<p>Records shared with security groups:</p>

<pre><code class="language-csharp">// Store with allowed principals
<p>await perspective.UpsertAsync(streamId, report, new PerspectiveScope {</p>
<p>  TenantId = currentTenant,</p>
<p>  AllowedPrincipals = new[] {</p>
<p>    SecurityPrincipalId.User("creator-123"),</p>
<p>    SecurityPrincipalId.Group("finance-team"),</p>
<p>    SecurityPrincipalId.Group("executives")</p>
<p>  }</p>
<p>});</p>

<p>// Query records shared with caller's groups</p>
<p>var lens = factory.GetPrincipalLens<IReportLens>();</p>
<p>var reports = await lens.GetAllAsync();  // Reports accessible to caller</p>
<p></code></pre></p>

<h3>My Records OR Shared With Me</h3>

<p>Combining user ownership and group sharing:</p>

<pre><code class="language-csharp">// Get lens for "my records + shared"
<p>var lens = factory.GetMyOrSharedLens<IDocumentLens>();</p>
<p>var docs = await lens.GetAllAsync();</p>

<p>// Returns documents where:</p>
<p>// - UserId = current user, OR</p>
<p>// - AllowedPrincipals contains any of caller's security principals</p>
<p></code></pre></p>

<h2>Extension Properties</h2>

<p>Add custom scope properties without schema changes:</p>

<pre><code class="language-csharp">// Store with extensions
<p>await perspective.UpsertAsync(streamId, order, new PerspectiveScope {</p>
<p>  TenantId = currentTenant,</p>
<p>  Extensions = new Dictionary<string, string?> {</p>
<p>    ["region"] = "us-west",</p>
<p>    ["department"] = "sales",</p>
<p>    ["costCenter"] = "CC-123"</p>
<p>  }</p>
<p>});</p>

<p>// Access via indexer</p>
<p>var region = scope["region"];  // "us-west"</p>
<p></code></pre></p>

<h2>Related Documentation</h2>

<ul><li><a href="./security.md">Security</a> - Permissions, roles, and access control</li>
<li><a href="./system-events.md">System Events</a> - Audit and monitoring events</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-security" class="doc-section">
  <h3>security</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/security</code></p>
  <div class="doc-content">
<h1>Security System</h1>

<p>Whizbang provides a comprehensive security system supporting RBAC (Role-Based Access Control) and ABAC (Attribute-Based Access Control) patterns with composable scope filters, permission checks, and security event auditing.</p>

<h2>Overview</h2>

<p>The security system consists of:</p>

<ul><li><strong>Permissions</strong> - Type-safe permission identifiers with wildcard matching</li>
<li><strong>Roles</strong> - Named collections of permissions</li>
<li><strong>Scope Context</strong> - Ambient security context for current operation</li>
<li><strong>Security Principals</strong> - Users, groups, and services with hierarchical membership</li>
<li><strong>Scoped Lens Factory</strong> - Permission-aware lens resolution with composable filters</li>
<li><strong>System Events</strong> - Security audit trail (AccessDenied, AccessGranted, etc.)</li>
</ul>
<h2>Permissions</h2>

<p>Permissions use a <code>resource:action</code> pattern and support wildcard matching.</p>

<pre><code class="language-csharp">// Factory methods for common patterns
<p>var readOrders = Permission.Read("orders");      // "orders:read"</p>
<p>var writeOrders = Permission.Write("orders");    // "orders:write"</p>
<p>var deleteOrders = Permission.Delete("orders");  // "orders:delete"</p>
<p>var adminOrders = Permission.Admin("orders");    // "orders:admin"</p>
<p>var allOrders = Permission.All("orders");        // "orders:*"</p>

<p>// Custom permissions</p>
<p>var permission = new Permission("orders:export");</p>

<p>// Wildcard matching</p>
<p>var allResources = new Permission("<em>:</em>");        // Matches everything</p>
<p>var allOrderActions = Permission.All("orders");  // Matches orders:*</p>
<p></code></pre></p>

<h3>Wildcard Rules</h3>

<p>| Permission | Matches |</p>
<p>|------------|---------|</p>
<p>| <code>orders:read</code> | Exactly <code>orders:read</code> |</p>
<p>| <code>orders:*</code> | Any action on orders (<code>orders:read</code>, <code>orders:write</code>, etc.) |</p>
<p>| <code>*:read</code> | Read on any resource (<code>orders:read</code>, <code>customers:read</code>, etc.) |</p>
<p>| <code><em>:</em></code> | Everything (super-admin) |</p>

<h2>Roles</h2>

<p>Roles are named collections of permissions, defined via fluent configuration.</p>

<pre><code class="language-csharp">var options = new SecurityOptions()
<p>  .DefineRole("Admin", b => b</p>
<p>    .HasAllPermissions("*"))              // Super-admin</p>
<p>  .DefineRole("Manager", b => b</p>
<p>    .HasAllPermissions("orders")          // orders:*</p>
<p>    .HasReadPermission("reports")         // reports:read</p>
<p>    .HasWritePermission("schedules"))     // schedules:write</p>
<p>  .DefineRole("User", b => b</p>
<p>    .HasReadPermission("orders")          // orders:read</p>
<p>    .HasReadPermission("products"));      // products:read</p>

<p>// Check role permissions</p>
<p>var managerRole = options.Roles["Manager"];</p>
<p>managerRole.HasPermission(Permission.Delete("orders"));  // true (orders:*)</p>
<p>managerRole.HasPermission(Permission.Read("reports"));   // true</p>
<p>managerRole.HasPermission(Permission.Delete("reports")); // false</p>
<p></code></pre></p>

<h2>Security Principals</h2>

<p>Security principals identify users, groups, and services with type prefixes for clarity.</p>

<pre><code class="language-csharp">// Factory methods
<p>var user = SecurityPrincipalId.User("alice");           // "user:alice"</p>
<p>var group = SecurityPrincipalId.Group("sales-team");    // "group:sales-team"</p>
<p>var service = SecurityPrincipalId.Service("api-gateway"); // "svc:api-gateway"</p>
<p>var app = SecurityPrincipalId.Application("mobile-app"); // "app:mobile-app"</p>

<p>// Type checks</p>
<p>user.IsUser;     // true</p>
<p>group.IsGroup;   // true</p>
<p>service.IsService; // true</p>
<p></code></pre></p>

<h3>Nested Group Support</h3>

<p>Security principals support hierarchical group membership. When a user belongs to a group that's nested within another group, all memberships are pre-flattened in the scope context.</p>

<pre><code class="language-csharp">// Alice is in "sales-team" which is in "all-employees"
<p>var context = new ScopeContext {</p>
<p>  SecurityPrincipals = new HashSet<SecurityPrincipalId> {</p>
<p>    SecurityPrincipalId.User("alice"),</p>
<p>    SecurityPrincipalId.Group("sales-team"),</p>
<p>    SecurityPrincipalId.Group("all-employees")  // Inherited from sales-team</p>
<p>  }</p>
<p>  // ...</p>
<p>};</p>
<p></code></pre></p>

<h2>Scope Context</h2>

<code>IScopeContext</code> is the ambient security context for the current operation, populated from JWT claims, message headers, or explicit injection.

<pre><code class="language-csharp">public interface IScopeContext {
<p>  PerspectiveScope Scope { get; }           // TenantId, UserId, etc.</p>
<p>  IReadOnlySet<string> Roles { get; }</p>
<p>  IReadOnlySet<Permission> Permissions { get; }</p>
<p>  IReadOnlySet<SecurityPrincipalId> SecurityPrincipals { get; }</p>
<p>  IReadOnlyDictionary<string, string> Claims { get; }</p>

<p>  // Helper methods</p>
<p>  bool HasPermission(Permission permission);</p>
<p>  bool HasAnyPermission(params Permission[] permissions);</p>
<p>  bool HasAllPermissions(params Permission[] permissions);</p>
<p>  bool HasRole(string roleName);</p>
<p>  bool HasAnyRole(params string[] roleNames);</p>
<p>  bool IsMemberOfAny(params SecurityPrincipalId[] principals);</p>
<p>}</p>
<p></code></pre></p>

<h3>Creating Scope Context</h3>

<pre><code class="language-csharp">var context = new ScopeContext {
<p>  Scope = new PerspectiveScope {</p>
<p>    TenantId = "tenant-123",</p>
<p>    UserId = "user-456",</p>
<p>    OrganizationId = "org-789"</p>
<p>  },</p>
<p>  Roles = new HashSet<string> { "Admin", "Support" },</p>
<p>  Permissions = new HashSet<Permission> {</p>
<p>    Permission.All("orders"),</p>
<p>    Permission.Read("customers")</p>
<p>  },</p>
<p>  SecurityPrincipals = new HashSet<SecurityPrincipalId> {</p>
<p>    SecurityPrincipalId.User("user-456"),</p>
<p>    SecurityPrincipalId.Group("support-team")</p>
<p>  },</p>
<p>  Claims = new Dictionary<string, string> {</p>
<p>    ["sub"] = "user-456",</p>
<p>    ["tenant"] = "tenant-123"</p>
<p>  }</p>
<p>};</p>
<p></code></pre></p>

<h3>Scope Context Accessor</h3>

<p>Access the current scope context via <code>IScopeContextAccessor</code>, which uses <code>AsyncLocal</code> for request-scoped propagation.</p>

<pre><code class="language-csharp">public interface IScopeContextAccessor {
<p>  IScopeContext? Current { get; set; }</p>
<p>}</p>

<p>// Usage in a service</p>
<p>public class OrderService {</p>
<p>  private readonly IScopeContextAccessor _accessor;</p>

<p>  public void Process() {</p>
<p>    var context = _accessor.Current;</p>
<p>    if (context?.HasPermission(Permission.Write("orders")) != true) {</p>
<p>      throw new AccessDeniedException(...);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Scoped Lens Factory</h2>

<code>IScopedLensFactory</code> provides permission-aware lens resolution with composable scope filters.

<h3>Composable Scope Filters</h3>

<pre><code class="language-csharp">[Flags]
<p>public enum ScopeFilter {</p>
<p>  None = 0,           // No filtering (admin access)</p>
<p>  Tenant = 1 << 0,    // Filter by TenantId</p>
<p>  Organization = 1 << 1,</p>
<p>  Customer = 1 << 2,</p>
<p>  User = 1 << 3,      // Filter by UserId</p>
<p>  Principal = 1 << 4  // Filter by security principal membership</p>
<p>}</p>
<p></code></pre></p>

<h3>Filter Combinations</h3>

<p>Filters are combined with bitwise OR and applied as AND conditions (except User+Principal which uses OR).</p>

<pre><code class="language-csharp">// Tenant only
<p>var lens = factory.GetLens<IOrderLens>(ScopeFilter.Tenant);</p>
<p>// WHERE TenantId = ?</p>

<p>// Tenant + User</p>
<p>var lens = factory.GetLens<IOrderLens>(ScopeFilter.Tenant | ScopeFilter.User);</p>
<p>// WHERE TenantId = ? AND UserId = ?</p>

<p>// Tenant + Principal (group-based access)</p>
<p>var lens = factory.GetLens<IOrderLens>(ScopeFilter.Tenant | ScopeFilter.Principal);</p>
<p>// WHERE TenantId = ? AND AllowedPrincipals ?| [caller's principals]</p>

<p>// My records OR shared with me</p>
<p>var lens = factory.GetMyOrSharedLens<IOrderLens>();</p>
<p>// WHERE TenantId = ? AND (UserId = ? OR AllowedPrincipals ?| [...])</p>
<p></code></pre></p>

<h3>Convenience Methods</h3>

<pre><code class="language-csharp">// No filtering (admin)
<p>factory.GetGlobalLens<IOrderLens>();</p>

<p>// Tenant-scoped</p>
<p>factory.GetTenantLens<IOrderLens>();</p>

<p>// Tenant + User</p>
<p>factory.GetUserLens<IOrderLens>();</p>

<p>// Tenant + Organization</p>
<p>factory.GetOrganizationLens<IOrderLens>();</p>

<p>// Tenant + Principal</p>
<p>factory.GetPrincipalLens<IOrderLens>();</p>

<p>// My records OR shared with me</p>
<p>factory.GetMyOrSharedLens<IOrderLens>();</p>
<p></code></pre></p>

<h3>Permission Checks</h3>

<p>The factory can enforce permission checks before returning a lens.</p>

<pre><code class="language-csharp">// Single permission required
<p>var lens = factory.GetLens<IOrderLens>(</p>
<p>  ScopeFilter.Tenant,</p>
<p>  Permission.Read("orders"));</p>

<p>// Any of these permissions</p>
<p>var lens = factory.GetLens<IOrderLens>(</p>
<p>  ScopeFilter.Tenant,</p>
<p>  Permission.Read("orders"),</p>
<p>  Permission.Write("orders"));</p>
<p></code></pre></p>

<p>If permissions are not satisfied, <code>AccessDeniedException</code> is thrown and an <code>AccessDenied</code> system event is emitted.</p>

<h2>Perspective Scope</h2>

<code>PerspectiveScope</code> stores scope metadata on perspective rows, separate from the data model.

<pre><code class="language-csharp">public record PerspectiveScope {
<p>  public string? TenantId { get; init; }</p>
<p>  public string? CustomerId { get; init; }</p>
<p>  public string? UserId { get; init; }</p>
<p>  public string? OrganizationId { get; init; }</p>

<p>  // Security principals that have access to this record</p>
<p>  public IReadOnlyList<SecurityPrincipalId>? AllowedPrincipals { get; init; }</p>

<p>  // Custom extension properties</p>
<p>  public IReadOnlyDictionary<string, string?>? Extensions { get; init; }</p>

<p>  // Unified access via indexer</p>
<p>  public string? this[string key] => key switch {</p>
<p>    nameof(TenantId) => TenantId,</p>
<p>    nameof(UserId) => UserId,</p>
<p>    // ... falls back to Extensions</p>
<p>  };</p>
<p>}</p>
<p></code></pre></p>

<h3>Row-Level Security via AllowedPrincipals</h3>

<p>Records can specify which security principals have access:</p>

<pre><code class="language-csharp">var row = new PerspectiveRow<Order> {
<p>  Data = order,</p>
<p>  Scope = new PerspectiveScope {</p>
<p>    TenantId = "tenant-123",</p>
<p>    AllowedPrincipals = new List<SecurityPrincipalId> {</p>
<p>      SecurityPrincipalId.User("creator-456"),</p>
<p>      SecurityPrincipalId.Group("sales-team"),</p>
<p>      SecurityPrincipalId.Group("managers")</p>
<p>    }</p>
<p>  }</p>
<p>};</p>
<p></code></pre></p>

<p>When querying with <code>ScopeFilter.Principal</code>, records are returned where the caller's security principals overlap with <code>AllowedPrincipals</code>.</p>

<h2>Security System Events</h2>

<p>The security system emits events for auditing.</p>

<h3>AccessDenied</h3>

<p>Emitted when access is denied due to insufficient permissions.</p>

<pre><code class="language-csharp">public sealed record AccessDenied : ISystemEvent {
<p>  public required string ResourceType { get; init; }</p>
<p>  public string? ResourceId { get; init; }</p>
<p>  public required Permission RequiredPermission { get; init; }</p>
<p>  public required IReadOnlySet<Permission> CallerPermissions { get; init; }</p>
<p>  public required IReadOnlySet<string> CallerRoles { get; init; }</p>
<p>  public required PerspectiveScope Scope { get; init; }</p>
<p>  public required AccessDenialReason Reason { get; init; }</p>
<p>  public required DateTimeOffset Timestamp { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h3>AccessGranted</h3>

<p>Emitted when access to a sensitive resource is granted (optional, for audit trails).</p>

<pre><code class="language-csharp">public sealed record AccessGranted : ISystemEvent {
<p>  public required string ResourceType { get; init; }</p>
<p>  public string? ResourceId { get; init; }</p>
<p>  public required Permission UsedPermission { get; init; }</p>
<p>  public required ScopeFilter AccessFilter { get; init; }</p>
<p>  public required PerspectiveScope Scope { get; init; }</p>
<p>  public required DateTimeOffset Timestamp { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h2>Configuration</h2>

<h3>Registering Security Services</h3>

<pre><code class="language-csharp">services.AddSingleton<IScopeContextAccessor, ScopeContextAccessor>();
<p>services.AddSingleton<ISystemEventEmitter, SystemEventEmitter>();</p>
<p>services.AddSingleton<LensOptions>();</p>
<p>services.AddScoped<IScopedLensFactory, ScopedLensFactory>();</p>

<p>// Configure security options</p>
<p>services.AddSingleton(new SecurityOptions()</p>
<p>  .DefineRole("Admin", b => b.HasAllPermissions("*"))</p>
<p>  .DefineRole("User", b => b.HasReadPermission("orders"))</p>
<p>  .ExtractPermissionsFromClaim("permissions")</p>
<p>  .ExtractRolesFromClaim("roles")</p>
<p>  .ExtractSecurityPrincipalsFromClaim("groups"));</p>
<p></code></pre></p>

<h3>Extracting from JWT Claims</h3>

<pre><code class="language-csharp">var options = new SecurityOptions()
<p>  .ExtractPermissionsFromClaim("permissions")  // "orders:read, orders:write"</p>
<p>  .ExtractRolesFromClaim("roles")              // "Admin, Support"</p>
<p>  .ExtractSecurityPrincipalsFromClaim("groups"); // "group:sales, group:managers"</p>
<p></code></pre></p>

<h2>Marker Interfaces</h2>

<p>Optional marker interfaces for models that include scope in their data:</p>

<pre><code class="language-csharp">public interface ITenantScoped {
<p>  string TenantId { get; }</p>
<p>}</p>

<p>public interface IUserScoped : ITenantScoped {</p>
<p>  string UserId { get; }</p>
<p>}</p>

<p>public interface IOrganizationScoped : ITenantScoped {</p>
<p>  string OrganizationId { get; }</p>
<p>}</p>

<p>public interface ICustomerScoped : ITenantScoped {</p>
<p>  string CustomerId { get; }</p>
<p>}</p>
<p></code></pre></p>

<h2>Exception Handling</h2>

<pre><code class="language-csharp">try {
<p>  var lens = factory.GetLens<IOrderLens>(</p>
<p>    ScopeFilter.Tenant,</p>
<p>    Permission.Delete("orders"));</p>
<p>} catch (AccessDeniedException ex) {</p>
<p>  // ex.RequiredPermission - What was needed</p>
<p>  // ex.ResourceType - What was being accessed</p>
<p>  // ex.ResourceId - Optional specific resource</p>
<p>  // ex.Reason - Why access was denied</p>
<p>  logger.LogWarning(</p>
<p>    "Access denied: {Resource} requires {Permission}",</p>
<p>    ex.ResourceType,</p>
<p>    ex.RequiredPermission);</p>
<p>}</p>
<p></code></pre></p>

<h2>Related Documentation</h2>

<ul><li><a href="./scoping.md">Scoping</a> - Scope system overview</li>
<li><a href="./system-events.md">System Events</a> - Audit and monitoring events</li>
<li><a href="../guides/implementing-multi-tenancy.md">Implementing Multi-Tenancy</a> - End-to-end guide</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-system-events" class="doc-section">
  <h3>system events</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/system-events</code></p>
  <div class="doc-content">
<h1>System Events</h1>

<p>Whizbang emits system events for auditing, monitoring, and observability. Events are written to the dedicated <code>$wb-system</code> stream, isolated from domain events.</p>

<h2>Overview</h2>

<p>System events enable:</p>

<ul><li><strong>Audit trails</strong> - Who accessed what, when, and with what permissions</li>
<li><strong>Security monitoring</strong> - Track access denials and suspicious activity</li>
<li><strong>Performance observability</strong> - Measure processing times and throughput</li>
<li><strong>Compliance</strong> - Meet regulatory requirements for access logging</li>
</ul>
<h2>Security Events</h2>

<h3>AccessDenied</h3>

<p>Emitted when access to a resource is denied due to insufficient permissions.</p>

<pre><code class="language-csharp">public sealed record AccessDenied : ISystemEvent {
<p>  // What was being accessed</p>
<p>  public required string ResourceType { get; init; }</p>
<p>  public string? ResourceId { get; init; }</p>

<p>  // What was required</p>
<p>  public required Permission RequiredPermission { get; init; }</p>

<p>  // What the caller had</p>
<p>  public required IReadOnlySet<Permission> CallerPermissions { get; init; }</p>
<p>  public required IReadOnlySet<string> CallerRoles { get; init; }</p>

<p>  // Context</p>
<p>  public required PerspectiveScope Scope { get; init; }</p>
<p>  public required AccessDenialReason Reason { get; init; }</p>
<p>  public required DateTimeOffset Timestamp { get; init; }</p>
<p>}</p>

<p>public enum AccessDenialReason {</p>
<p>  InsufficientPermission,</p>
<p>  InsufficientRole,</p>
<p>  ScopeViolation,</p>
<p>  PolicyRejected</p>
<p>}</p>
<p></code></pre></p>

<strong>Example</strong>:
<pre><code class="language-json">{
<p>  "resourceType": "IOrderLens",</p>
<p>  "resourceId": null,</p>
<p>  "requiredPermission": "orders:delete",</p>
<p>  "callerPermissions": ["orders:read", "orders:write"],</p>
<p>  "callerRoles": ["User"],</p>
<p>  "scope": {</p>
<p>    "tenantId": "tenant-123",</p>
<p>    "userId": "user-456"</p>
<p>  },</p>
<p>  "reason": "InsufficientPermission",</p>
<p>  "timestamp": "2024-01-15T10:30:00Z"</p>
<p>}</p>
<p></code></pre></p>

<h3>AccessGranted</h3>

<p>Emitted when access to a sensitive resource is granted. Useful for audit trails of privileged access.</p>

<pre><code class="language-csharp">public sealed record AccessGranted : ISystemEvent {
<p>  public required string ResourceType { get; init; }</p>
<p>  public string? ResourceId { get; init; }</p>
<p>  public required Permission UsedPermission { get; init; }</p>
<p>  public required ScopeFilter AccessFilter { get; init; }</p>
<p>  public required PerspectiveScope Scope { get; init; }</p>
<p>  public required DateTimeOffset Timestamp { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h3>PermissionChanged</h3>

<p>Emitted when a user's permissions or roles are modified.</p>

<pre><code class="language-csharp">public sealed record PermissionChanged : ISystemEvent {
<p>  public required string UserId { get; init; }</p>
<p>  public required string TenantId { get; init; }</p>
<p>  public required PermissionChangeType ChangeType { get; init; }</p>

<p>  // What changed</p>
<p>  public IReadOnlySet<string>? RolesAdded { get; init; }</p>
<p>  public IReadOnlySet<string>? RolesRemoved { get; init; }</p>
<p>  public IReadOnlySet<Permission>? PermissionsAdded { get; init; }</p>
<p>  public IReadOnlySet<Permission>? PermissionsRemoved { get; init; }</p>

<p>  // Who made the change</p>
<p>  public required string ChangedBy { get; init; }</p>
<p>  public required DateTimeOffset Timestamp { get; init; }</p>
<p>}</p>

<p>public enum PermissionChangeType {</p>
<p>  RolesAdded,</p>
<p>  RolesRemoved,</p>
<p>  PermissionsAdded,</p>
<p>  PermissionsRemoved,</p>
<p>  FullReassignment</p>
<p>}</p>
<p></code></pre></p>

<h3>ScopeContextEstablished</h3>

<p>Emitted when a scope context is established for a request/operation.</p>

<pre><code class="language-csharp">public sealed record ScopeContextEstablished : ISystemEvent {
<p>  public required PerspectiveScope Scope { get; init; }</p>
<p>  public required IReadOnlySet<string> Roles { get; init; }</p>
<p>  public required IReadOnlySet<Permission> Permissions { get; init; }</p>
<p>  public required string Source { get; init; }  // "JWT", "ApiKey", etc.</p>
<p>  public required DateTimeOffset Timestamp { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h2>Audit Events</h2>

<h3>EventAudited</h3>

<p>Emitted when a domain event is appended to a stream.</p>

<pre><code class="language-csharp">public sealed record EventAudited : ISystemEvent {
<p>  public required Guid StreamId { get; init; }</p>
<p>  public required long StreamPosition { get; init; }</p>
<p>  public required string EventType { get; init; }</p>
<p>  public required string EventId { get; init; }</p>
<p>  public required DateTimeOffset Timestamp { get; init; }</p>
<p>  public PerspectiveScope? Scope { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h3>CommandAudited</h3>

<p>Emitted when a command is processed by a receptor.</p>

<pre><code class="language-csharp">public sealed record CommandAudited : ISystemEvent {
<p>  public required string CommandType { get; init; }</p>
<p>  public required string ReceptorName { get; init; }</p>
<p>  public required bool Succeeded { get; init; }</p>
<p>  public string? ErrorMessage { get; init; }</p>
<p>  public required TimeSpan Duration { get; init; }</p>
<p>  public required DateTimeOffset Timestamp { get; init; }</p>
<p>  public PerspectiveScope? Scope { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h2>Emitting Events</h2>

<p>Use <code>ISystemEventEmitter</code> to emit system events.</p>

<pre><code class="language-csharp">public interface ISystemEventEmitter {
<p>  Task EmitEventAuditedAsync<TEvent>(</p>
<p>    Guid streamId,</p>
<p>    long streamPosition,</p>
<p>    MessageEnvelope<TEvent> envelope,</p>
<p>    CancellationToken cancellationToken = default);</p>

<p>  Task EmitCommandAuditedAsync<TCommand, TResponse>(</p>
<p>    TCommand command,</p>
<p>    TResponse response,</p>
<p>    string receptorName,</p>
<p>    IMessageContext? context,</p>
<p>    CancellationToken cancellationToken = default) where TCommand : notnull;</p>

<p>  Task EmitAsync<TSystemEvent>(</p>
<p>    TSystemEvent systemEvent,</p>
<p>    CancellationToken cancellationToken = default) where TSystemEvent : ISystemEvent;</p>

<p>  bool ShouldExcludeFromAudit(Type type);</p>
<p>}</p>
<p></code></pre></p>

<h3>Example Usage</h3>

<pre><code class="language-csharp">public class OrderService {
<p>  private readonly ISystemEventEmitter _emitter;</p>

<p>  public async Task GrantAccess(string userId, Permission permission) {</p>
<p>    // ... grant access logic ...</p>

<p>    await _emitter.EmitAsync(new PermissionChanged {</p>
<p>      UserId = userId,</p>
<p>      TenantId = currentTenant,</p>
<p>      ChangeType = PermissionChangeType.PermissionsAdded,</p>
<p>      PermissionsAdded = new HashSet<Permission> { permission },</p>
<p>      ChangedBy = currentUser,</p>
<p>      Timestamp = DateTimeOffset.UtcNow</p>
<p>    });</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Excluding Events from Audit</h2>

<p>Mark events with <code>[AuditEvent(Exclude = true)]</code> to prevent re-auditing:</p>

<pre><code class="language-csharp">[AuditEvent(Exclude = true)]
<p>public record InternalHealthCheckEvent : IEvent {</p>
<p>  // Won't be audited (prevents infinite loops)</p>
<p>}</p>
<p></code></pre></p>

<p>The emitter checks <code>ShouldExcludeFromAudit()</code> before emitting.</p>

<h2>Configuration</h2>

<h3>Registering the Emitter</h3>

<pre><code class="language-csharp">builder.Services.AddSingleton<ISystemEventEmitter, SystemEventEmitter>();
<p></code></pre></p>

<h3>Configuring Event Options</h3>

<pre><code class="language-csharp">builder.Services.AddSingleton(new SystemEventOptions {
<p>  // System event stream name</p>
<p>  StreamName = "$wb-system",</p>

<p>  // Enable/disable specific event types</p>
<p>  EmitAccessGranted = true,  // Default: false (noisy)</p>
<p>  EmitScopeContextEstablished = false,  // Default: false</p>

<p>  // Filtering</p>
<p>  ExcludedEventTypes = new[] { typeof(HealthCheckEvent) }</p>
<p>});</p>
<p></code></pre></p>

<h2>Subscribing to System Events</h2>

<p>Process system events for alerting, dashboards, or external systems.</p>

<pre><code class="language-csharp">public class SecurityAlertHandler {
<p>  public async Task HandleAccessDenied(AccessDenied @event) {</p>
<p>    if (@event.Reason == AccessDenialReason.PolicyRejected) {</p>
<p>      // Alert on policy violations</p>
<p>      await _alertService.SendSecurityAlert(</p>
<p>        $"Policy rejection for {event.ResourceType}",</p>
<p>        @event);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Related Documentation</h2>

<ul><li><a href="./security.md">Security</a> - Permissions and access control</li>
<li><a href="./scoping.md">Scoping</a> - Multi-tenancy and data isolation</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-transport-consumer" class="doc-section">
  <h3>transport consumer</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/transport-consumer</code></p>
  <div class="doc-content">
<h1>Transport Consumer</h1>

<p>The transport consumer automatically subscribes to message broker destinations and processes incoming messages. When combined with <code>WithRouting()</code>, subscriptions are auto-generated from your routing configuration.</p>

<h2>Overview</h2>

<p>The <code>AddTransportConsumer()</code> extension method:</p>

<ul><li><strong>Auto-generates subscriptions</strong> from <code>RoutingOptions</code> configured via <code>WithRouting()</code></li>
<li><strong>Registers <code>TransportConsumerOptions</code></strong> with populated destinations</li>
<li><strong>Starts <code>TransportConsumerWorker</code></strong> as a hosted service</li>
</ul>
<h2>Auto-Configuration {#auto-configuration}</h2>

<p>The recommended approach chains <code>WithRouting()</code> and <code>AddTransportConsumer()</code>:</p>

<pre><code class="language-csharp">services.AddWhizbang()
<p>    .WithRouting(routing => {</p>
<p>        routing</p>
<p>            .OwnDomains("myapp.orders.commands")</p>
<p>            .SubscribeTo("myapp.payments.events")</p>
<p>            .Inbox.UseSharedTopic("inbox");</p>
<p>    })</p>
<p>    .WithEFCore<OrderDbContext>()</p>
<p>    .WithDriver.Postgres</p>
<p>    .AddTransportConsumer();</p>
<p></code></pre></p>

<p>This auto-generates subscriptions:</p>
<ul><li><strong>Inbox subscription</strong> from <code>OwnDomains()</code> - Filters commands by namespace pattern</li>
<li><strong>Event subscriptions</strong> from <code>SubscribeTo()</code> - Subscribes to each namespace topic</li>
<li><strong>Auto-discovered events</strong> from perspectives and receptors</li>
</ul>
<h3>What Gets Generated</h3>

<p>For the configuration above, <code>AddTransportConsumer()</code> generates:</p>

<p>| Destination | Address | Routing Key |</p>
<p>|-------------|---------|-------------|</p>
<p>| Inbox | <code>inbox</code> | <code>myapp.orders.commands.#</code> |</p>
<p>| Payment Events | <code>myapp.payments.events</code> | <code>#</code> |</p>

<p>If your service has perspectives or receptors that handle events from other namespaces, those are automatically discovered and added.</p>

<h2>Additional Destinations {#additional-destinations}</h2>

<p>Add custom destinations beyond auto-generated ones:</p>

<pre><code class="language-csharp">services.AddWhizbang()
<p>    .WithRouting(routing => {</p>
<p>        routing.OwnDomains("myapp.orders.commands");</p>
<p>    })</p>
<p>    .AddTransportConsumer(config => {</p>
<p>        // Add custom destination</p>
<p>        config.AdditionalDestinations.Add(</p>
<p>            new TransportDestination("custom-topic", "my-subscription"));</p>

<p>        // Add multiple custom destinations</p>
<p>        config.AdditionalDestinations.Add(</p>
<p>            new TransportDestination("audit-events", "#"));</p>
<p>    });</p>
<p></code></pre></p>

<p>Additional destinations are appended after auto-generated ones.</p>

<h2>Complete Worker Setup</h2>

<p>A typical worker service includes transport registration, routing, and consumer:</p>

<pre><code class="language-csharp">var builder = Host.CreateApplicationBuilder(args);

<p>// 1. Register transport (Azure Service Bus or RabbitMQ)</p>
<p>var serviceBusConnection = builder.Configuration.GetConnectionString("servicebus")</p>
<p>    ?? throw new InvalidOperationException("Connection string not found");</p>
<p>builder.Services.AddAzureServiceBusTransport(serviceBusConnection);</p>

<p>// 2. Configure Whizbang with routing and consumer</p>
<p>builder.Services.AddWhizbang()</p>
<p>    .WithRouting(routing => {</p>
<p>        routing</p>
<p>            .OwnDomains("myapp.orders.commands")</p>
<p>            .SubscribeTo("myapp.payments.events", "myapp.users.events")</p>
<p>            .Inbox.UseSharedTopic("inbox");</p>
<p>    })</p>
<p>    .WithEFCore<OrderDbContext>()</p>
<p>    .WithDriver.Postgres</p>
<p>    .AddTransportConsumer();</p>

<p>// 3. Register generated services</p>
<p>builder.Services.AddReceptors();</p>
<p>builder.Services.AddWhizbangDispatcher();</p>

<p>var host = builder.Build();</p>
<p>host.Run();</p>
<p></code></pre></p>

<h2>Transport Independence</h2>

<p>The consumer configuration is transport-agnostic. The same <code>WithRouting()</code> and <code>AddTransportConsumer()</code> calls work with:</p>

<ul><li><strong>Azure Service Bus</strong> - Creates topics and subscriptions</li>
<li><strong>RabbitMQ</strong> - Creates exchanges and queues</li>
<li><strong>In-Memory</strong> (testing) - Direct message routing</li>
</ul>
<p>Transport-specific behavior is handled by the transport implementation registered separately.</p>

<h2>Error Handling</h2>

<p>When <code>WithRouting()</code> is not called before <code>AddTransportConsumer()</code>:</p>

<pre><code class="language-csharp">// This throws InvalidOperationException at runtime
<p>services.AddWhizbang()</p>
<p>    .AddTransportConsumer();  // Error: WithRouting() must be called first</p>
<p></code></pre></p>

<p>The error occurs when resolving <code>TransportConsumerOptions</code> from the service provider, not at registration time.</p>

<h2>Subscription Resilience {#subscription-resilience}</h2>

<p>:::new</p>
<p>Added in v1.0.0</p>
<p>:::</p>

<p>By default, the transport consumer includes built-in resilience for subscription failures. Subscriptions retry <strong>forever</strong> until success or cancellation - critical for production systems where transient broker issues should not cause permanent failures.</p>

<h3>Retry Behavior</h3>

<p>The retry system uses <strong>exponential backoff</strong>:</p>

<p>| Property | Default | Description |</p>
<p>|----------|---------|-------------|</p>
<p>| <code>InitialRetryDelay</code> | 1 second | Starting delay between retries |</p>
<p>| <code>MaxRetryDelay</code> | 120 seconds | Cap on exponential backoff |</p>
<p>| <code>BackoffMultiplier</code> | 2.0 | Delay multiplier per attempt |</p>
<p>| <code>InitialRetryAttempts</code> | 5 | Attempts before reducing log verbosity |</p>
<p>| <code>RetryIndefinitely</code> | true | Never give up (recommended) |</p>

<h3>Configuration</h3>

<p>Customize resilience behavior through <code>TransportConsumerConfiguration</code>:</p>

<pre><code class="language-csharp">services.AddWhizbang()
<p>    .WithRouting(routing => {</p>
<p>        routing.OwnDomains("myapp.orders.commands");</p>
<p>    })</p>
<p>    .AddTransportConsumer(config => {</p>
<p>        // Customize retry behavior</p>
<p>        config.ResilienceOptions.InitialRetryDelay = TimeSpan.FromSeconds(2);</p>
<p>        config.ResilienceOptions.MaxRetryDelay = TimeSpan.FromMinutes(5);</p>
<p>        config.ResilienceOptions.BackoffMultiplier = 1.5;</p>

<p>        // Allow partial failures (some subscriptions can fail)</p>
<p>        config.ResilienceOptions.AllowPartialSubscriptions = true;</p>
<p>    });</p>
<p></code></pre></p>

<h3>Disabling Resilience</h3>

<p>For testing or simple scenarios, resilience can be disabled:</p>

<pre><code class="language-csharp">services.AddWhizbang()
<p>    .WithRouting(routing => {</p>
<p>        routing.OwnDomains("myapp.orders.commands");</p>
<p>    })</p>
<p>    .AddTransportConsumer(config => {</p>
<p>        config.EnableResilience = false;  // Uses non-resilient worker</p>
<p>    });</p>
<p></code></pre></p>

<h3>Health Monitoring</h3>

<p>When resilience is enabled, a health check is automatically registered:</p>

<pre><code class="language-csharp">app.MapHealthChecks("/health");  // Includes subscription health
<p></code></pre></p>

<p>Health check results:</p>
<ul><li><strong>Healthy</strong>: All subscriptions active</li>
<li><strong>Degraded</strong>: Some subscriptions recovering or pending</li>
<li><strong>Unhealthy</strong>: All subscriptions failed</li>
</ul>
<p>The health check includes diagnostic data:</p>
<ul><li><code>failed_destinations</code>: List of failed subscription addresses</li>
<li><code>recovering_destinations</code>: List of subscriptions currently retrying</li>
</ul>
<h3>Connection Recovery</h3>

<p>For transports that support connection recovery (RabbitMQ, Azure Service Bus), subscriptions are automatically re-established after connection loss:</p>

<ul><li>Transport detects connection recovery</li>
<li>Worker receives recovery notification via <code>ITransportWithRecovery</code></li>
<li>All subscriptions are reset to pending</li>
<li>Retry loop re-establishes each subscription</li>
</ul>
<p>This ensures subscriptions survive both initial failures and runtime connection issues.</p>

<h2>Service Name Resolution</h2>

<p>The consumer uses service name for subscription naming:</p>

<ul><li><strong><code>IServiceInstanceProvider</code></strong> - If registered, uses <code>ServiceName</code> property</li>
<li><strong>Entry Assembly</strong> - Falls back to assembly name</li>
<li><strong>Default</strong> - Uses "UnknownService" as ultimate fallback</li>
</ul>
<p>Register a custom provider for explicit control:</p>

<pre><code class="language-csharp">builder.Services.AddSingleton<IServiceInstanceProvider>(
<p>    new ServiceInstanceProvider("MyOrderService"));</p>
<p></code></pre></p>

<h2>Prerequisites</h2>

<p>Before calling <code>AddTransportConsumer()</code>:</p>

<ul><li><strong>Transport Registration</strong> - Call <code>AddAzureServiceBusTransport()</code> or <code>AddRabbitMQTransport()</code></li>
<li><strong>Routing Configuration</strong> - Call <code>WithRouting()</code> to configure routing options</li>
<li><strong>Receptors</strong> (optional) - Call <code>AddReceptors()</code> for message handlers</li>
</ul>
<h2>Related Documentation</h2>

<ul><li><a href="./routing.md">Routing</a> - Namespace-based routing configuration</li>
<li><a href="./inbox-outbox.md">Inbox/Outbox</a> - Message persistence and delivery guarantees</li>
<li><a href="./workers.md">Workers</a> - Background processing workers</li>
<li><a href="../components/transports/rabbitmq.md">RabbitMQ Transport</a> - RabbitMQ transport configuration</li>
<li><a href="../components/transports/azure-service-bus.md">Azure Service Bus Transport</a> - Azure Service Bus transport configuration</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-type-formatting" class="doc-section">
  <h3>type formatting</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/type-formatting</code></p>
  <div class="doc-content">
<h1>TypeFormatter: Type Name Formatting Utility</h1>

<p>TypeFormatter is a static utility class that formats .NET Type objects into string representations according to TypeQualification flags. It handles namespace, assembly, version, culture, and public key token formatting with culture-invariant output.</p>

<h2>Overview</h2>

<strong>TypeFormatter</strong> provides:
<ul><li>✅ Culture-invariant type name formatting</li>
<li>✅ Respects all TypeQualification flags</li>
<li>✅ Handles null types safely</li>
<li>✅ Fully AOT-compatible (no reflection beyond Type.GetName)</li>
<li>✅ Used by source generators and message association APIs</li>
</ul>
<h2>Quick Start</h2>

<h3>Basic Formatting</h3>

<pre><code class="language-csharp">using Whizbang.Core;

<p>var type = typeof(ECommerce.Contracts.Events.ProductCreatedEvent);</p>

<p>// Format with preset</p>
<p>var simple = TypeFormatter.FormatType(type, TypeQualification.Simple);</p>
<p>Console.WriteLine(simple);</p>
<p>// Output: "ProductCreatedEvent"</p>

<p>var fullyQualified = TypeFormatter.FormatType(type, TypeQualification.FullyQualified);</p>
<p>Console.WriteLine(fullyQualified);</p>
<p>// Output: "ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts"</p>

<p>// Format with custom flags</p>
<p>var custom = TypeFormatter.FormatType(</p>
<p>    type,</p>
<p>    TypeQualification.Namespace | TypeQualification.TypeName</p>
<p>);</p>
<p>Console.WriteLine(custom);</p>
<p>// Output: "ECommerce.Contracts.Events.ProductCreatedEvent"</p>
<p></code></pre></p>

<h3>Formatting with Version Information</h3>

<pre><code class="language-csharp">// Full assembly qualification with version
<p>var withVersion = TypeFormatter.FormatType(</p>
<p>    type,</p>
<p>    TypeQualification.FullyQualifiedWithVersion</p>
<p>);</p>
<p>Console.WriteLine(withVersion);</p>
<p>// Output: "ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null"</p>

<p>// Without version</p>
<p>var withoutVersion = TypeFormatter.FormatType(</p>
<p>    type,</p>
<p>    TypeQualification.FullyQualified</p>
<p>);</p>
<p>Console.WriteLine(withoutVersion);</p>
<p>// Output: "ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts"</p>
<p></code></pre></p>

<h2>Formatting Rules</h2>

<h3>Component Order</h3>

<p>TypeFormatter outputs components in this order:</p>
<ul><li><strong>GlobalPrefix</strong> (<code>global::</code>) - if flag is set</li>
<li><strong>Namespace</strong> (<code>MyApp.Events</code>) - if flag is set</li>
<li><strong>Dot separator</strong> (<code>.</code>) - if both Namespace and TypeName are set</li>
<li><strong>TypeName</strong> (<code>ProductCreatedEvent</code>) - if flag is set</li>
<li><strong>Comma separator</strong> (<code>, </code>) - if TypeName and Assembly are set</li>
<li><strong>Assembly</strong> (<code>MyApp</code>) - if flag is set</li>
<li><strong>Version</strong> (<code>, Version=1.0.0.0</code>) - if flag is set</li>
<li><strong>Culture</strong> (<code>, Culture=neutral</code>) - if flag is set</li>
<li><strong>PublicKeyToken</strong> (<code>, PublicKeyToken=null</code>) - if flag is set</li>
</ul>
<h3>Flag Combinations</h3>

<pre><code class="language-csharp">var type = typeof(OrderCreatedEvent);

<p>// TypeName only</p>
<p>var name = TypeFormatter.FormatType(type, TypeQualification.TypeName);</p>
<p>// Result: "OrderCreatedEvent"</p>

<p>// Namespace + TypeName</p>
<p>var ns = TypeFormatter.FormatType(</p>
<p>    type,</p>
<p>    TypeQualification.Namespace | TypeQualification.TypeName</p>
<p>);</p>
<p>// Result: "MyApp.Events.OrderCreatedEvent"</p>

<p>// GlobalPrefix + TypeName</p>
<p>var global = TypeFormatter.FormatType(</p>
<p>    type,</p>
<p>    TypeQualification.GlobalPrefix | TypeQualification.TypeName</p>
<p>);</p>
<p>// Result: "global::OrderCreatedEvent"</p>

<p>// GlobalPrefix + Namespace + TypeName</p>
<p>var globalFull = TypeFormatter.FormatType(</p>
<p>    type,</p>
<p>    TypeQualification.GlobalPrefix | TypeQualification.Namespace | TypeQualification.TypeName</p>
<p>);</p>
<p>// Result: "global::MyApp.Events.OrderCreatedEvent"</p>

<p>// Assembly without TypeName (edge case)</p>
<p>var assemblyOnly = TypeFormatter.FormatType(type, TypeQualification.Assembly);</p>
<p>// Result: "MyApp"</p>

<p>// None flag</p>
<p>var empty = TypeFormatter.FormatType(type, TypeQualification.None);</p>
<p>// Result: ""</p>
<p></code></pre></p>

<h2>Culture-Invariant Formatting</h2>

<p>TypeFormatter uses <code>CultureInfo.InvariantCulture</code> for all formatting to ensure consistent output across locales:</p>

<pre><code class="language-csharp">// Version, Culture, and PublicKeyToken always use InvariantCulture
<p>var withVersion = TypeFormatter.FormatType(</p>
<p>    type,</p>
<p>    TypeQualification.FullyQualifiedWithVersion</p>
<p>);</p>

<p>// Formatted string interpolation uses InvariantCulture</p>
<p>// This ensures version numbers, hex strings, etc. are consistent</p>
<p>// Example: "Version=1.0.0.0" not "Version=1,0,0,0" (some locales use commas)</p>
<p></code></pre></p>

<h2>Common Scenarios</h2>

<h3>Scenario 1: Source Generator Output</h3>

<strong>When</strong>: Generating C# code that references types

<pre><code class="language-csharp">public string GenerateEventHandler(Type eventType) {
<p>    // Use GlobalQualified to avoid namespace conflicts</p>
<p>    var typeName = TypeFormatter.FormatType(</p>
<p>        eventType,</p>
<p>        TypeQualification.GlobalQualified</p>
<p>    );</p>

<p>    return $@"</p>
<p>public class GeneratedHandler {{</p>
<p>    public void Handle({typeName} evt) {{</p>
<p>        // Handle event</p>
<p>    }}</p>
<p>}}</p>
<p>";</p>
<p>}</p>

<p>// Output:</p>
<p>// public class GeneratedHandler {</p>
<p>//     public void Handle(global::ECommerce.Contracts.Events.ProductCreatedEvent evt) {</p>
<p>//         // Handle event</p>
<p>//     }</p>
<p>// }</p>
<p></code></pre></p>

<h3>Scenario 2: Logging and Diagnostics</h3>

<strong>When</strong>: Displaying type information in logs

<pre><code class="language-csharp">public void LogTypeInfo(Type type) {
<p>    // Simple name for user-friendly output</p>
<p>    var simple = TypeFormatter.FormatType(type, TypeQualification.Simple);</p>
<p>    _logger.LogInformation("Processing: {TypeName}", simple);</p>

<p>    // Fully qualified for diagnostic details</p>
<p>    var full = TypeFormatter.FormatType(type, TypeQualification.FullyQualified);</p>
<p>    _logger.LogDebug("Full type: {FullType}", full);</p>

<p>    // With version for complete diagnostics</p>
<p>    var withVersion = TypeFormatter.FormatType(</p>
<p>        type,</p>
<p>        TypeQualification.FullyQualifiedWithVersion</p>
<p>    );</p>
<p>    _logger.LogTrace("Type with version: {VersionedType}", withVersion);</p>
<p>}</p>

<p>// Output:</p>
<p>// Information: Processing: ProductCreatedEvent</p>
<p>// Debug: Full type: ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts</p>
<p>// Trace: Type with version: ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null</p>
<p></code></pre></p>

<h3>Scenario 3: Configuration and Serialization</h3>

<strong>When</strong>: Storing type names in configuration or serializing to JSON

<pre><code class="language-csharp">public class EventConfiguration {
<p>    // Store fully qualified name for reliable deserialization</p>
<p>    public string EventType { get; set; } = null!;</p>
<p>}</p>

<p>public EventConfiguration CreateConfig(Type eventType) {</p>
<p>    return new EventConfiguration {</p>
<p>        EventType = TypeFormatter.FormatType(</p>
<p>            eventType,</p>
<p>            TypeQualification.FullyQualified</p>
<p>        )</p>
<p>    };</p>
<p>}</p>

<p>// Later: Deserialize</p>
<p>public Type GetEventType(EventConfiguration config) {</p>
<p>    // Use fully qualified name for reliable Type.GetType()</p>
<p>    return Type.GetType(config.EventType)</p>
<p>        ?? throw new InvalidOperationException($"Type not found: {config.EventType}");</p>
<p>}</p>
<p></code></pre></p>

<h3>Scenario 4: Dynamic Type Display</h3>

<strong>When</strong>: Building UI that shows type information

<pre><code class="language-csharp">public class TypeDisplayInfo {
<p>    public string SimpleName { get; init; } = null!;</p>
<p>    public string FullName { get; init; } = null!;</p>
<p>    public string AssemblyName { get; init; } = null!;</p>
<p>}</p>

<p>public TypeDisplayInfo GetDisplayInfo(Type type) {</p>
<p>    return new TypeDisplayInfo {</p>
<p>        SimpleName = TypeFormatter.FormatType(type, TypeQualification.Simple),</p>
<p>        FullName = TypeFormatter.FormatType(type, TypeQualification.NamespaceQualified),</p>
<p>        AssemblyName = TypeFormatter.FormatType(type, TypeQualification.Assembly)</p>
<p>    };</p>
<p>}</p>

<p>// Usage in UI:</p>
<p>// Simple: "ProductCreatedEvent"</p>
<p>// Full: "ECommerce.Contracts.Events.ProductCreatedEvent"</p>
<p>// Assembly: "ECommerce.Contracts"</p>
<p></code></pre></p>

<h2>Edge Cases and Special Handling</h2>

<h3>Empty Namespace</h3>

<pre><code class="language-csharp">// Type with no namespace (global namespace)
<p>public class GlobalType { }</p>

<p>var formatted = TypeFormatter.FormatType(</p>
<p>    typeof(GlobalType),</p>
<p>    TypeQualification.NamespaceQualified</p>
<p>);</p>
<p>// Result: "GlobalType" (no leading dot)</p>
<p></code></pre></p>

<h3>Generic Types</h3>

<pre><code class="language-csharp">var genericType = typeof(List<OrderCreatedEvent>);

<p>var formatted = TypeFormatter.FormatType(</p>
<p>    genericType,</p>
<p>    TypeQualification.FullyQualified</p>
<p>);</p>
<p>// Result: "System.Collections.Generic.List<code>1, System.Collections"</p>
<p>// Note: Generic type parameters are shown as </code>1, <code>2, etc.</p>
<p></code></pre></p>

<h3>Nested Types</h3>

<pre><code class="language-csharp">public class OuterClass {
<p>    public class InnerClass { }</p>
<p>}</p>

<p>var nestedType = typeof(OuterClass.InnerClass);</p>
<p>var formatted = TypeFormatter.FormatType(</p>
<p>    nestedType,</p>
<p>    TypeQualification.NamespaceQualified</p>
<p>);</p>
<p>// Result: "MyApp.OuterClass+InnerClass"</p>
<p>// Note: Nested types use '+' separator</p>
<p></code></pre></p>

<h3>Public Key Token</h3>

<pre><code class="language-csharp">// Strong-named assembly
<p>var strongType = typeof(System.String);</p>

<p>var withToken = TypeFormatter.FormatType(</p>
<p>    strongType,</p>
<p>    TypeQualification.FullyQualifiedWithVersion</p>
<p>);</p>
<p>// Result: "System.String, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e"</p>

<p>// Non-strong-named assembly</p>
<p>var weakType = typeof(MyApp.CustomType);</p>

<p>var withoutToken = TypeFormatter.FormatType(</p>
<p>    weakType,</p>
<p>    TypeQualification.FullyQualifiedWithVersion</p>
<p>);</p>
<p>// Result: "MyApp.CustomType, MyApp, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null"</p>
<p></code></pre></p>

<h2>Performance Considerations</h2>

<h3>StringBuilder Allocation</h3>

<p>TypeFormatter uses </code>StringBuilder<code> internally for efficient string building:</p>

<pre><code class="language-csharp">// Efficient - single StringBuilder allocation
<p>var formatted = TypeFormatter.FormatType(type, TypeQualification.FullyQualified);</p>

<p>// Less efficient - multiple string concatenations</p>
<p>var manual = type.Namespace + "." + type.Name + ", " + type.Assembly.GetName().Name;</p>
<p></code></pre></p>

<h3>Caching Formatted Results</h3>

<p>Since type formatting is deterministic, consider caching results:</p>

<pre><code class="language-csharp">public class CachedTypeFormatter {
<p>    private readonly ConcurrentDictionary<(Type, TypeQualification), string> _cache = new();</p>

<p>    public string FormatType(Type type, TypeQualification qualification) {</p>
<p>        return _cache.GetOrAdd(</p>
<p>            (type, qualification),</p>
<p>            key => TypeFormatter.FormatType(key.Item1, key.Item2)</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Integration with Message Associations</h2>

<p>TypeFormatter is used extensively in message association APIs:</p>

<pre><code class="language-csharp">// Format event type for lookup
<p>var eventType = typeof(ProductCreatedEvent);</p>
<p>var simpleType = TypeFormatter.FormatType(eventType, TypeQualification.Simple);</p>

<p>// Find perspectives handling this event (simple name)</p>
<p>var perspectives = PerspectiveRegistrationExtensions.GetPerspectivesForEvent(</p>
<p>    simpleType,</p>
<p>    serviceName,</p>
<p>    MatchStrictness.SimpleName</p>
<p>);</p>

<p>// Format for storage in message associations</p>
<p>var storedType = TypeFormatter.FormatType(eventType, TypeQualification.FullyQualified);</p>
<p></code></pre></p>

<h2>API Reference</h2>

<h3>Method Signature</h3>

<strong>Namespace</strong>: </code>Whizbang.Core<code>

<pre><code class="language-csharp">public static class TypeFormatter {
<p>    /// <summary></p>
<p>    /// Formats a Type according to the specified TypeQualification flags.</p>
<p>    /// Uses culture-invariant formatting for consistent output.</p>
<p>    /// </summary></p>
<p>    /// <param name="type">The Type to format</param></p>
<p>    /// <param name="qualification">Flags controlling which components to include</param></p>
<p>    /// <returns>Formatted type name string</returns></p>
<p>    /// <exception cref="ArgumentNullException">Thrown if type is null</exception></p>
<p>    public static string FormatType(Type type, TypeQualification qualification);</p>
<p>}</p>
<p></code></pre></p>

<h3>Parameters</h3>

<ul><li><strong>type</strong>: The </code>Type<code> object to format (cannot be null)</li>
<li><strong>qualification</strong>: </code>TypeQualification<code> flags controlling output format</li>
</ul>
<h3>Return Value</h3>

<ul><li>Returns formatted type name as </code>string<code></li>
<li>Returns empty string if </code>qualification<code> is </code>TypeQualification.None<code></li>
<li>Never returns null</li>
</ul>
<h3>Exceptions</h3>

<ul><li><strong>ArgumentNullException</strong>: Thrown if </code>type<code> parameter is null</li>
</ul>
<h2>Best Practices</h2>

<ul><li><strong>Use FullyQualified for persistence</strong> - Ensures reliable deserialization with </code>Type.GetType()<code></li>
<li><strong>Use Simple for user-facing displays</strong> - More readable in UI and logs</li>
<li><strong>Use GlobalQualified in generated code</strong> - Avoids namespace conflicts with </code>global::`</li>
<li><strong>Cache formatted results</strong> - Formatting is expensive, memoize when calling frequently</li>
<li><strong>Use culture-invariant output</strong> - TypeFormatter already does this, safe for serialization</li>
<li><strong>Avoid formatting in hot paths</strong> - Pre-format and cache if used repeatedly</li>
<li><strong>Consider version implications</strong> - Decide if version matching matters for your use case</li>
</ul>
<h2>Common Pitfalls</h2>

<h3>❌ Formatting Null Types</h3>

<pre><code class="language-csharp">// ❌ WRONG: Null type
<p>Type? nullType = null;</p>
<p>var formatted = TypeFormatter.FormatType(nullType!, TypeQualification.Simple);</p>
<p>// Throws: ArgumentNullException</p>

<p>// ✅ CORRECT: Check for null first</p>
<p>if (type != null) {</p>
<p>    var formatted = TypeFormatter.FormatType(type, TypeQualification.Simple);</p>
<p>}</p>
<p></code></pre></p>

<h3>❌ Assuming Default Format</h3>

<pre><code class="language-csharp">// ❌ WRONG: Assuming ToString() matches formatted output
<p>var toString = type.ToString();</p>
<p>var formatted = TypeFormatter.FormatType(type, TypeQualification.FullyQualified);</p>
<p>// These may not match!</p>

<p>// ✅ CORRECT: Always use TypeFormatter for consistent results</p>
<p>var formatted = TypeFormatter.FormatType(type, TypeQualification.FullyQualified);</p>
<p></code></pre></p>

<h3>❌ Hardcoding Type Names</h3>

<pre><code class="language-csharp">// ❌ WRONG: Hardcoded type name
<p>var typeName = "ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts";</p>

<p>// ✅ CORRECT: Use TypeFormatter</p>
<p>var typeName = TypeFormatter.FormatType(</p>
<p>    typeof(ProductCreatedEvent),</p>
<p>    TypeQualification.FullyQualified</p>
<p>);</p>
<p></code></pre></p>

<h3>❌ Ignoring Culture in Manual Formatting</h3>

<pre><code class="language-csharp">// ❌ WRONG: Culture-dependent formatting
<p>var version = type.Assembly.GetName().Version;</p>
<p>var formatted = $"Version={version}"; // May use locale-specific format</p>

<p>// ✅ CORRECT: Use TypeFormatter with InvariantCulture</p>
<p>var formatted = TypeFormatter.FormatType(type, TypeQualification.FullyQualifiedWithVersion);</p>
<p></code></pre></p>

<h2>See Also</h2>

<ul><li><a href="/v1.0.0/core-concepts/type-qualification">TypeQualification</a> - Flag enum controlling formatting</li>
<li><a href="/v1.0.0/core-concepts/fuzzy-matching">MatchStrictness</a> - Fuzzy matching with formatted types</li>
<li><a href="/v1.0.0/core-concepts/type-matching">TypeMatcher</a> - Matching formatted type strings</li>
<li><a href="/v1.0.0/core-concepts/perspectives">Perspectives</a> - Message associations using formatted types</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-type-matching" class="doc-section">
  <h3>type matching</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/type-matching</code></p>
  <div class="doc-content">
<h1>TypeMatcher: Type Name Matching Utilities</h1>

<p>TypeMatcher is a static utility class that provides flexible type name matching with support for fuzzy matching via MatchStrictness flags and regex pattern matching. It handles the transformation pipeline for type string comparisons.</p>

<h2>Overview</h2>

<strong>TypeMatcher</strong> provides:
<ul><li>✅ Fuzzy type name matching with MatchStrictness control</li>
<li>✅ Regex pattern matching for advanced scenarios</li>
<li>✅ Sequential transformation pipeline (Version → Assembly → Namespace → Case)</li>
<li>✅ Null-safe string comparisons</li>
<li>✅ Used by message association queries and type discovery</li>
</ul>
<h2>Quick Start</h2>

<h3>Basic Matching</h3>

<pre><code class="language-csharp">using Whizbang.Core;

<p>var type1 = "ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts";</p>
<p>var type2 = "ProductCreatedEvent";</p>

<p>// Exact match</p>
<p>bool exact = TypeMatcher.Matches(type1, type2, MatchStrictness.Exact);</p>
<p>// Result: false</p>

<p>// Simple name match</p>
<p>bool simple = TypeMatcher.Matches(type1, type2, MatchStrictness.SimpleName);</p>
<p>// Result: true</p>

<p>// Case-insensitive match</p>
<p>bool caseInsensitive = TypeMatcher.Matches(</p>
<p>    "ProductCreatedEvent",</p>
<p>    "productcreatedevent",</p>
<p>    MatchStrictness.CaseInsensitive</p>
<p>);</p>
<p>// Result: true</p>
<p></code></pre></p>

<h3>Pattern Matching</h3>

<pre><code class="language-csharp">using System.Text.RegularExpressions;

<p>var typeString = "ECommerce.Contracts.Events.ProductCreatedEvent";</p>

<p>// Match any type containing "Product"</p>
<p>var pattern = new Regex(".<em>Product.</em>");</p>
<p>bool matches = TypeMatcher.Matches(typeString, pattern);</p>
<p>// Result: true</p>

<p>// Match event types ending with "Event"</p>
<p>var eventPattern = new Regex(".*Event$");</p>
<p>bool isEvent = TypeMatcher.Matches(typeString, eventPattern);</p>
<p>// Result: true</p>

<p>// Match types in ECommerce namespace</p>
<p>var namespacePattern = new Regex("^ECommerce\\.");</p>
<p>bool inNamespace = TypeMatcher.Matches(typeString, namespacePattern);</p>
<p>// Result: true</p>
<p></code></pre></p>

<h2>Matching with Strictness</h2>

<h3>Transformation Pipeline</h3>

<p>TypeMatcher applies transformations sequentially based on MatchStrictness flags:</p>

<pre><code class="language-csharp">// Example input
<p>var type = "MyApp.Events.OrderCreated, MyApp, Version=1.0.0";</p>

<p>// Step 1: IgnoreVersion (if flag set)</p>
<p>// Strips: ", Version=1.0.0", ", Culture=...", ", PublicKeyToken=..."</p>
<p>// Result: "MyApp.Events.OrderCreated, MyApp"</p>

<p>// Step 2: IgnoreAssembly (if flag set)</p>
<p>// Strips: ", MyApp"</p>
<p>// Result: "MyApp.Events.OrderCreated"</p>

<p>// Step 3: IgnoreNamespace (if flag set)</p>
<p>// Extracts simple name after last dot</p>
<p>// Result: "OrderCreated"</p>

<p>// Step 4: IgnoreCase (if flag set)</p>
<p>// Uses StringComparison.OrdinalIgnoreCase for comparison</p>
<p></code></pre></p>

<h3>Strictness Examples</h3>

<pre><code class="language-csharp">var fullType = "ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts, Version=1.0.0";

<p>// Exact (no transformations)</p>
<p>bool exact = TypeMatcher.Matches(</p>
<p>    fullType,</p>
<p>    "ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts, Version=1.0.0",</p>
<p>    MatchStrictness.Exact</p>
<p>);</p>
<p>// Result: true</p>

<p>// IgnoreVersion</p>
<p>bool ignoreVer = TypeMatcher.Matches(</p>
<p>    fullType,</p>
<p>    "ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts",</p>
<p>    MatchStrictness.IgnoreVersion</p>
<p>);</p>
<p>// Result: true</p>

<p>// IgnoreAssembly</p>
<p>bool ignoreAsm = TypeMatcher.Matches(</p>
<p>    fullType,</p>
<p>    "ECommerce.Contracts.Events.ProductCreatedEvent",</p>
<p>    MatchStrictness.WithoutAssembly</p>
<p>);</p>
<p>// Result: true (WithoutAssembly = IgnoreAssembly | IgnoreVersion)</p>

<p>// SimpleName</p>
<p>bool simpleName = TypeMatcher.Matches(</p>
<p>    fullType,</p>
<p>    "ProductCreatedEvent",</p>
<p>    MatchStrictness.SimpleName</p>
<p>);</p>
<p>// Result: true</p>

<p>// SimpleNameCaseInsensitive</p>
<p>bool simpleCI = TypeMatcher.Matches(</p>
<p>    fullType,</p>
<p>    "productcreatedevent",</p>
<p>    MatchStrictness.SimpleNameCaseInsensitive</p>
<p>);</p>
<p>// Result: true</p>
<p></code></pre></p>

<h2>Common Scenarios</h2>

<h3>Scenario 1: Message Association Lookup</h3>

<strong>When</strong>: Finding perspectives that handle specific events

<pre><code class="language-csharp">public IEnumerable<string> FindPerspectivesForEvent(string eventName) {
<p>    var associations = PerspectiveRegistrationExtensions</p>
<p>        .GetMessageAssociations(serviceName);</p>

<p>    // Find all perspectives handling this event (simple name)</p>
<p>    return associations</p>
<p>        .Where(a => {</p>
<p>            return a.AssociationType == "perspective" &&</p>
<p>                   TypeMatcher.Matches(a.MessageType, eventName, MatchStrictness.SimpleName);</p>
<p>        })</p>
<p>        .Select(a => a.TargetName);</p>
<p>}</p>

<p>// Usage</p>
<p>var perspectives = FindPerspectivesForEvent("ProductCreatedEvent");</p>
<p>// Matches:</p>
<p>// - "ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts"</p>
<p>// - "MyApp.Domain.Events.ProductCreatedEvent, MyApp.Domain"</p>
<p></code></pre></p>

<h3>Scenario 2: Plugin Discovery</h3>

<strong>When</strong>: Discovering handlers from external assemblies

<pre><code class="language-csharp">public IEnumerable<Type> FindHandlers(string eventPattern) {
<p>    var pattern = new Regex(eventPattern);</p>
<p>    var allTypes = AppDomain.CurrentDomain.GetAssemblies()</p>
<p>        .SelectMany(a => a.GetTypes());</p>

<p>    return allTypes.Where(t => {</p>
<p>        var typeName = TypeFormatter.FormatType(t, TypeQualification.FullyQualified);</p>
<p>        return TypeMatcher.Matches(typeName, pattern);</p>
<p>    });</p>
<p>}</p>

<p>// Usage: Find all types in "ECommerce.Events" namespace</p>
<p>var handlers = FindHandlers("ECommerce\\.Events\\..*");</p>
<p></code></pre></p>

<h3>Scenario 3: Cross-Version Type Resolution</h3>

<strong>When</strong>: Resolving types across different assembly versions

<pre><code class="language-csharp">public Type? ResolveType(string typeString, IEnumerable<Assembly> assemblies) {
<p>    foreach (var assembly in assemblies) {</p>
<p>        foreach (var type in assembly.GetTypes()) {</p>
<p>            var candidateType = TypeFormatter.FormatType(</p>
<p>                type,</p>
<p>                TypeQualification.FullyQualified</p>
<p>            );</p>

<p>            // Match without version - works across all versions</p>
<p>            if (TypeMatcher.Matches(candidateType, typeString, MatchStrictness.IgnoreVersion)) {</p>
<p>                return type;</p>
<p>            }</p>
<p>        }</p>
<p>    }</p>
<p>    return null;</p>
<p>}</p>
<p></code></pre></p>

<h3>Scenario 4: Configuration-Based Filtering</h3>

<strong>When</strong>: Filtering messages based on configuration

<pre><code class="language-csharp">public class MessageFilter {
<p>    public string Pattern { get; set; } = null!;</p>
<p>    public MatchStrictness Strictness { get; set; }</p>
<p>}</p>

<p>public bool ShouldProcess(string messageType, List<MessageFilter> filters) {</p>
<p>    return filters.Any(filter => {</p>
<p>        if (filter.Strictness == MatchStrictness.Exact) {</p>
<p>            // Use exact string matching</p>
<p>            return TypeMatcher.Matches(messageType, filter.Pattern, MatchStrictness.Exact);</p>
<p>        } else {</p>
<p>            // Use fuzzy matching</p>
<p>            return TypeMatcher.Matches(messageType, filter.Pattern, filter.Strictness);</p>
<p>        }</p>
<p>    });</p>
<p>}</p>

<p>// Configuration:</p>
<p>// - Pattern: "ProductCreatedEvent"</p>
<p>//   Strictness: SimpleName</p>
<p>// - Pattern: ".<em>Order.</em>"</p>
<p>//   Strictness: Exact (treated as regex)</p>
<p></code></pre></p>

<h2>Pattern Matching</h2>

<h3>Regex Overload</h3>

<p>TypeMatcher provides a regex overload for advanced pattern matching:</p>

<pre><code class="language-csharp">// Method signature
<p>public static bool Matches(string typeString, Regex pattern);</p>

<p>// Null handling</p>
<p>TypeMatcher.Matches(null, pattern);        // Returns: false</p>
<p>TypeMatcher.Matches("", pattern);          // Returns: false</p>
<p>TypeMatcher.Matches(typeString, null);     // Throws: ArgumentNullException</p>
<p></code></pre></p>

<h3>Common Patterns</h3>

<pre><code class="language-csharp">// Match any event type
<p>var eventPattern = new Regex(".*Event$");</p>
<p>bool isEvent = TypeMatcher.Matches("ProductCreatedEvent", eventPattern);</p>
<p>// Result: true</p>

<p>// Match types in specific namespace</p>
<p>var namespacePattern = new Regex("^ECommerce\\.Contracts\\.");</p>
<p>bool inNamespace = TypeMatcher.Matches(</p>
<p>    "ECommerce.Contracts.Events.ProductCreatedEvent",</p>
<p>    namespacePattern</p>
<p>);</p>
<p>// Result: true</p>

<p>// Match command types</p>
<p>var commandPattern = new Regex(".*Command$");</p>
<p>bool isCommand = TypeMatcher.Matches("CreateOrderCommand", commandPattern);</p>
<p>// Result: true</p>

<p>// Match domain events (case-insensitive)</p>
<p>var domainPattern = new Regex(".*DomainEvent$", RegexOptions.IgnoreCase);</p>
<p>bool isDomainEvent = TypeMatcher.Matches("productcreateddomainevent", domainPattern);</p>
<p>// Result: true</p>

<p>// Match types containing "Product"</p>
<p>var productPattern = new Regex(".<em>Product.</em>");</p>
<p>bool hasProduct = TypeMatcher.Matches("CreateProductCommand", productPattern);</p>
<p>// Result: true</p>

<p>// Match fully qualified names in specific assembly</p>
<p>var assemblyPattern = new Regex(".*, MyAssembly$");</p>
<p>bool inAssembly = TypeMatcher.Matches(</p>
<p>    "MyApp.Events.OrderCreated, MyAssembly",</p>
<p>    assemblyPattern</p>
<p>);</p>
<p>// Result: true</p>
<p></code></pre></p>

<h3>Combining Pattern and Fuzzy Matching</h3>

<pre><code class="language-csharp">public IEnumerable<string> FindMatchingTypes(
<p>    IEnumerable<string> types,</p>
<p>    string pattern,</p>
<p>    bool useRegex,</p>
<p>    MatchStrictness strictness) {</p>

<p>    if (useRegex) {</p>
<p>        var regex = new Regex(pattern);</p>
<p>        return types.Where(t => TypeMatcher.Matches(t, regex));</p>
<p>    } else {</p>
<p>        return types.Where(t => TypeMatcher.Matches(t, pattern, strictness));</p>
<p>    }</p>
<p>}</p>

<p>// Usage</p>
<p>var types = new[] {</p>
<p>    "ECommerce.Events.ProductCreatedEvent",</p>
<p>    "ECommerce.Events.OrderCreatedEvent",</p>
<p>    "MyApp.Commands.CreateProductCommand"</p>
<p>};</p>

<p>// Regex: All events</p>
<p>var events = FindMatchingTypes(types, ".*Event$", useRegex: true, MatchStrictness.Exact);</p>
<p>// Result: ["ECommerce.Events.ProductCreatedEvent", "ECommerce.Events.OrderCreatedEvent"]</p>

<p>// Fuzzy: Types containing "Product"</p>
<p>var products = FindMatchingTypes(types, "Product", useRegex: false, MatchStrictness.SimpleName);</p>
<p>// Result: ["ECommerce.Events.ProductCreatedEvent", "MyApp.Commands.CreateProductCommand"]</p>
<p></code></pre></p>

<h2>Null and Empty String Handling</h2>

<p>TypeMatcher handles edge cases gracefully:</p>

<pre><code class="language-csharp">// Both null or empty: true
<p>bool match1 = TypeMatcher.Matches(null, null, MatchStrictness.Exact);</p>
<p>// Result: true</p>

<p>bool match2 = TypeMatcher.Matches("", "", MatchStrictness.Exact);</p>
<p>// Result: true</p>

<p>// One null or empty: false</p>
<p>bool match3 = TypeMatcher.Matches("MyType", null, MatchStrictness.Exact);</p>
<p>// Result: false</p>

<p>bool match4 = TypeMatcher.Matches(null, "MyType", MatchStrictness.Exact);</p>
<p>// Result: false</p>

<p>bool match5 = TypeMatcher.Matches("MyType", "", MatchStrictness.Exact);</p>
<p>// Result: false</p>

<p>// Regex with null or empty string</p>
<p>var pattern = new Regex(".*");</p>
<p>bool match6 = TypeMatcher.Matches(null, pattern);</p>
<p>// Result: false</p>

<p>bool match7 = TypeMatcher.Matches("", pattern);</p>
<p>// Result: false</p>

<p>// Null pattern throws</p>
<p>bool match8 = TypeMatcher.Matches("MyType", (Regex)null!);</p>
<p>// Throws: ArgumentNullException</p>
<p></code></pre></p>

<h2>String Comparison Details</h2>

<h3>Case Sensitivity</h3>

<pre><code class="language-csharp">// Case-sensitive (default)
<p>bool caseSensitive = TypeMatcher.Matches(</p>
<p>    "ProductCreatedEvent",</p>
<p>    "productcreatedevent",</p>
<p>    MatchStrictness.Exact</p>
<p>);</p>
<p>// Result: false (uses StringComparison.Ordinal)</p>

<p>// Case-insensitive</p>
<p>bool caseInsensitive = TypeMatcher.Matches(</p>
<p>    "ProductCreatedEvent",</p>
<p>    "productcreatedevent",</p>
<p>    MatchStrictness.CaseInsensitive</p>
<p>);</p>
<p>// Result: true (uses StringComparison.OrdinalIgnoreCase)</p>
<p></code></pre></p>

<h3>Ordinal Comparison</h3>

<p>TypeMatcher uses ordinal (binary) comparison for performance and consistency:</p>

<pre><code class="language-csharp">// Uses StringComparison.Ordinal (case-sensitive)
<p>TypeMatcher.Matches(type1, type2, MatchStrictness.Exact);</p>

<p>// Uses StringComparison.OrdinalIgnoreCase (case-insensitive)</p>
<p>TypeMatcher.Matches(type1, type2, MatchStrictness.CaseInsensitive);</p>

<p>// NOT culture-sensitive (e.g., Turkish I/i)</p>
<p>// This is intentional for type matching consistency</p>
<p></code></pre></p>

<h2>Integration with Message Associations</h2>

<p>TypeMatcher powers the fuzzy matching in message association queries:</p>

<pre><code class="language-csharp">// GetPerspectivesForEvent with MatchStrictness
<p>var perspectives = PerspectiveRegistrationExtensions.GetPerspectivesForEvent(</p>
<p>    eventType,</p>
<p>    serviceName,</p>
<p>    MatchStrictness.SimpleName</p>
<p>);</p>
<p>// Internally uses: TypeMatcher.Matches(a.MessageType, eventType, MatchStrictness.SimpleName)</p>

<p>// GetPerspectivesForEvent with Regex</p>
<p>var eventPattern = new Regex(".<em>Product.</em>");</p>
<p>var productPerspectives = PerspectiveRegistrationExtensions.GetPerspectivesForEvent(</p>
<p>    eventPattern,</p>
<p>    serviceName</p>
<p>);</p>
<p>// Internally uses: TypeMatcher.Matches(a.MessageType, eventPattern)</p>

<p>// GetEventsForPerspective with MatchStrictness</p>
<p>var events = PerspectiveRegistrationExtensions.GetEventsForPerspective(</p>
<p>    perspectiveName,</p>
<p>    serviceName,</p>
<p>    MatchStrictness.SimpleName</p>
<p>);</p>
<p>// Internally uses: TypeMatcher.Matches(a.TargetName, perspectiveName, MatchStrictness.SimpleName)</p>

<p>// GetEventsForPerspective with Regex</p>
<p>var perspectivePattern = new Regex(".<em>Inventory.</em>");</p>
<p>var inventoryEvents = PerspectiveRegistrationExtensions.GetEventsForPerspective(</p>
<p>    perspectivePattern,</p>
<p>    serviceName</p>
<p>);</p>
<p>// Internally uses: TypeMatcher.Matches(a.TargetName, perspectivePattern)</p>
<p></code></pre></p>

<h2>API Reference</h2>

<h3>Method Signatures</h3>

<strong>Namespace</strong>: <code>Whizbang.Core</code>

<pre><code class="language-csharp">public static class TypeMatcher {
<p>    /// <summary></p>
<p>    /// Matches two type strings using the specified MatchStrictness flags.</p>
<p>    /// Applies transformations sequentially: Version → Assembly → Namespace → Case.</p>
<p>    /// </summary></p>
<p>    /// <param name="typeString1">First type string to compare</param></p>
<p>    /// <param name="typeString2">Second type string to compare</param></p>
<p>    /// <param name="strictness">Flags controlling matching behavior</param></p>
<p>    /// <returns>True if types match according to strictness rules</returns></p>
<p>    public static bool Matches(</p>
<p>        string? typeString1,</p>
<p>        string? typeString2,</p>
<p>        MatchStrictness strictness</p>
<p>    );</p>

<p>    /// <summary></p>
<p>    /// Matches a type string against a regex pattern.</p>
<p>    /// </summary></p>
<p>    /// <param name="typeString">Type string to match</param></p>
<p>    /// <param name="pattern">Regex pattern to match against</param></p>
<p>    /// <returns>True if type string matches the pattern</returns></p>
<p>    /// <exception cref="ArgumentNullException">Thrown if pattern is null</exception></p>
<p>    public static bool Matches(string? typeString, Regex pattern);</p>
<p>}</p>
<p></code></pre></p>

<h3>Return Values</h3>

<ul><li>Returns <code>true</code> if strings match according to rules</li>
<li>Returns <code>false</code> if strings don't match</li>
<li>Returns <code>true</code> if both strings are null or empty</li>
<li>Returns <code>false</code> if one string is null/empty and the other is not</li>
<li>Returns <code>false</code> if type string is null/empty (regex overload)</li>
</ul>
<h3>Exceptions</h3>

<ul><li><strong>ArgumentNullException</strong>: Thrown if regex pattern parameter is null</li>
</ul>
<h2>Best Practices</h2>

<ul><li><strong>Use SimpleName for user-facing searches</strong> - Most forgiving for user input</li>
<li><strong>Use IgnoreVersion in production</strong> - Avoids brittleness from version changes</li>
<li><strong>Cache regex patterns</strong> - Create once, reuse for better performance</li>
<li><strong>Combine with TypeFormatter</strong> - Format types consistently before matching</li>
<li><strong>Test null/empty cases</strong> - Ensure edge cases are handled correctly</li>
<li><strong>Document matching rules</strong> - Explain why a particular strictness level was chosen</li>
<li><strong>Use ordinal comparison</strong> - TypeMatcher already does this, don't override</li>
<li><strong>Prefer presets over raw flags</strong> - Clearer intent with <code>SimpleName</code> vs <code>IgnoreNamespace | IgnoreAssembly | IgnoreVersion</code></li>
</ul>
<h2>Common Pitfalls</h2>

<h3>❌ Assuming Culture-Sensitive Matching</h3>

<pre><code class="language-csharp">// ❌ WRONG: Expecting culture-sensitive comparison
<p>// TypeMatcher always uses Ordinal/OrdinalIgnoreCase</p>
<p>bool match = TypeMatcher.Matches("Straße", "Strasse", MatchStrictness.CaseInsensitive);</p>
<p>// Result: false (ordinal comparison, not culture-sensitive)</p>

<p>// ✅ CORRECT: Use ordinal-aware expectations</p>
<p>// TypeMatcher is designed for type names, not natural language</p>
<p></code></pre></p>

<h3>❌ Forgetting Transformation Order</h3>

<pre><code class="language-csharp">// ❌ WRONG: Assuming IgnoreNamespace strips everything
<p>var type = "MyApp.Events.OrderCreated, MyApp, Version=1.0.0";</p>
<p>bool match = TypeMatcher.Matches(type, "OrderCreated", MatchStrictness.IgnoreNamespace);</p>
<p>// Result: false (assembly and version not stripped!)</p>

<p>// ✅ CORRECT: Use SimpleName preset (all flags)</p>
<p>bool match = TypeMatcher.Matches(type, "OrderCreated", MatchStrictness.SimpleName);</p>
<p>// Result: true</p>
<p></code></pre></p>

<h3>❌ Not Checking for Null Pattern</h3>

<pre><code class="language-csharp">// ❌ WRONG: Passing null regex
<p>Regex? pattern = null;</p>
<p>bool match = TypeMatcher.Matches("MyType", pattern!);</p>
<p>// Throws: ArgumentNullException</p>

<p>// ✅ CORRECT: Check for null first</p>
<p>if (pattern != null) {</p>
<p>    bool match = TypeMatcher.Matches("MyType", pattern);</p>
<p>}</p>
<p></code></pre></p>

<h3>❌ Overly Broad Patterns</h3>

<pre><code class="language-csharp">// ❌ WRONG: Pattern matches too many types
<p>var pattern = new Regex(".*"); // Matches EVERYTHING!</p>
<p>if (TypeMatcher.Matches(userType, pattern)) {</p>
<p>    ExecutePrivilegedAction(); // Dangerous!</p>
<p>}</p>

<p>// ✅ CORRECT: Specific pattern</p>
<p>var pattern = new Regex("^MyApp\\.Admin\\.Commands\\..*Command$");</p>
<p>if (TypeMatcher.Matches(userType, pattern)) {</p>
<p>    ExecutePrivilegedAction();</p>
<p>}</p>
<p></code></pre></p>

<h2>Performance Considerations</h2>

<h3>String Allocations</h3>

<p>TypeMatcher may allocate new strings during transformations:</p>

<pre><code class="language-csharp">// Each transformation may allocate a new string
<p>// - StripVersionInfo: 1 allocation</p>
<p>// - StripAssembly: 1 allocation</p>
<p>// - GetSimpleName: 1 allocation</p>

<p>// Consider caching if matching frequently</p>
<p>private readonly ConcurrentDictionary<(string, MatchStrictness), string> _transformCache = new();</p>

<p>public bool CachedMatch(string type1, string type2, MatchStrictness strictness) {</p>
<p>    var transformed1 = _transformCache.GetOrAdd((type1, strictness), _ => Transform(type1, strictness));</p>
<p>    var transformed2 = _transformCache.GetOrAdd((type2, strictness), _ => Transform(type2, strictness));</p>
<p>    return string.Equals(transformed1, transformed2, GetComparison(strictness));</p>
<p>}</p>
<p></code></pre></p>

<h3>Regex Performance</h3>

<pre><code class="language-csharp">// ❌ WRONG: Create regex in hot path
<p>for (int i = 0; i < 10000; i++) {</p>
<p>    var pattern = new Regex(".*Event$"); // Creates 10,000 regex instances!</p>
<p>    TypeMatcher.Matches(types[i], pattern);</p>
<p>}</p>

<p>// ✅ CORRECT: Cache regex</p>
<p>var pattern = new Regex(".*Event$", RegexOptions.Compiled);</p>
<p>for (int i = 0; i < 10000; i++) {</p>
<p>    TypeMatcher.Matches(types[i], pattern);</p>
<p>}</p>
<p></code></pre></p>

<h2>See Also</h2>

<ul><li><a href="/v1.0.0/core-concepts/type-qualification">TypeQualification</a> - Type name formatting flags</li>
<li><a href="/v1.0.0/core-concepts/type-formatting">TypeFormatter</a> - Format types for matching</li>
<li><a href="/v1.0.0/core-concepts/fuzzy-matching">MatchStrictness</a> - Fuzzy matching control</li>
<li><a href="/v1.0.0/core-concepts/perspectives">Perspectives</a> - Message associations using TypeMatcher</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-type-qualification" class="doc-section">
  <h3>type qualification</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/type-qualification</code></p>
  <div class="doc-content">
<h1>TypeQualification: Type Name Formatting Control</h1>

<p>TypeQualification is a flag enum that controls how .NET type names are formatted in generated code. It enables fine-grained control over namespace, assembly, version, and other type name components.</p>

<h2>Overview</h2>

<strong>TypeQualification</strong> provides:
<ul><li>✅ Flag-based control over type name components</li>
<li>✅ Individual component flags for fine-grained control</li>
<li>✅ Composite presets for common scenarios</li>
<li>✅ Fully AOT-compatible (no reflection)</li>
<li>✅ Used by source generators and message association APIs</li>
</ul>
<h2>Quick Start</h2>

<h3>Using TypeQualification Flags</h3>

<pre><code class="language-csharp">using Whizbang.Core;

<p>var type = typeof(ECommerce.Contracts.Events.ProductCreatedEvent);</p>

<p>// Simple type name only</p>
<p>var simple = TypeFormatter.FormatType(type, TypeQualification.Simple);</p>
<p>// Result: "ProductCreatedEvent"</p>

<p>// Namespace + type name</p>
<p>var namespaced = TypeFormatter.FormatType(type, TypeQualification.NamespaceQualified);</p>
<p>// Result: "ECommerce.Contracts.Events.ProductCreatedEvent"</p>

<p>// Namespace + type + assembly</p>
<p>var fullyQualified = TypeFormatter.FormatType(type, TypeQualification.FullyQualified);</p>
<p>// Result: "ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts"</p>

<p>// With version information</p>
<p>var withVersion = TypeFormatter.FormatType(type, TypeQualification.FullyQualifiedWithVersion);</p>
<p>// Result: "ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts, Version=1.0.0, Culture=neutral, PublicKeyToken=null"</p>
<p></code></pre></p>

<h3>Combining Individual Flags</h3>

<pre><code class="language-csharp">// Custom combination: Namespace + Type + Assembly (no version)
<p>var custom = TypeFormatter.FormatType(</p>
<p>    type,</p>
<p>    TypeQualification.Namespace | TypeQualification.TypeName | TypeQualification.Assembly</p>
<p>);</p>
<p>// Result: "ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts"</p>

<p>// With global prefix</p>
<p>var globalQualified = TypeFormatter.FormatType(</p>
<p>    type,</p>
<p>    TypeQualification.GlobalPrefix | TypeQualification.Namespace | TypeQualification.TypeName</p>
<p>);</p>
<p>// Result: "global::ECommerce.Contracts.Events.ProductCreatedEvent"</p>
<p></code></pre></p>

<h2>Component Flags</h2>

<h3>Individual Component Flags</h3>

<p>Each flag controls a specific part of the type name:</p>

<p>| Flag | Value | Description |</p>
<p>|------|-------|-------------|</p>
<p>| <code>None</code> | 0 | Empty string (no components) |</p>
<p>| <code>TypeName</code> | 1 | Type name only (e.g., "ProductCreatedEvent") |</p>
<p>| <code>Namespace</code> | 2 | Namespace prefix (e.g., "ECommerce.Contracts.Events") |</p>
<p>| <code>Assembly</code> | 4 | Assembly name (e.g., "ECommerce.Contracts") |</p>
<p>| <code>Version</code> | 8 | Assembly version (e.g., "Version=1.0.0") |</p>
<p>| <code>Culture</code> | 16 | Culture info (e.g., "Culture=neutral") |</p>
<p>| <code>PublicKeyToken</code> | 32 | Public key token (e.g., "PublicKeyToken=null") |</p>
<p>| <code>GlobalPrefix</code> | 64 | Global namespace prefix (e.g., "global::") |</p>

<strong>Example - Combining Flags</strong>:
<pre><code class="language-csharp">// Just namespace and type name
<p>var flags = TypeQualification.Namespace | TypeQualification.TypeName;</p>
<p>var result = TypeFormatter.FormatType(typeof(OrderCreatedEvent), flags);</p>
<p>// Result: "MyApp.Events.OrderCreatedEvent"</p>

<p>// Type name with global prefix</p>
<p>var globalFlags = TypeQualification.GlobalPrefix | TypeQualification.TypeName;</p>
<p>var globalResult = TypeFormatter.FormatType(typeof(OrderCreatedEvent), globalFlags);</p>
<p>// Result: "global::OrderCreatedEvent"</p>
<p></code></pre></p>

<h3>Composite Presets</h3>

<p>Pre-defined combinations for common scenarios:</p>

<p>| Preset | Flags | Example Output |</p>
<p>|--------|-------|----------------|</p>
<p>| <code>Simple</code> | <code>TypeName</code> | <code>"ProductCreatedEvent"</code> |</p>
<p>| <code>NamespaceQualified</code> | <code>Namespace \| TypeName</code> | <code>"ECommerce.Contracts.Events.ProductCreatedEvent"</code> |</p>
<p>| <code>FullyQualified</code> | <code>Namespace \| TypeName \| Assembly</code> | <code>"ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts"</code> |</p>
<p>| <code>GlobalQualified</code> | <code>GlobalPrefix \| Namespace \| TypeName</code> | <code>"global::ECommerce.Contracts.Events.ProductCreatedEvent"</code> |</p>
<p>| <code>FullyQualifiedWithVersion</code> | All flags except <code>GlobalPrefix</code> | <code>"..., Version=1.0.0, Culture=neutral, PublicKeyToken=null"</code> |</p>

<strong>Example - Using Presets</strong>:
<pre><code class="language-csharp">var type = typeof(ProductCreatedEvent);

<p>// Simple preset</p>
<p>var simple = TypeFormatter.FormatType(type, TypeQualification.Simple);</p>
<p>// "ProductCreatedEvent"</p>

<p>// FullyQualified preset</p>
<p>var full = TypeFormatter.FormatType(type, TypeQualification.FullyQualified);</p>
<p>// "ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts"</p>

<p>// GlobalQualified preset</p>
<p>var global = TypeFormatter.FormatType(type, TypeQualification.GlobalQualified);</p>
<p>// "global::ECommerce.Contracts.Events.ProductCreatedEvent"</p>
<p></code></pre></p>

<h2>Common Scenarios</h2>

<h3>Scenario 1: Source Generator Output</h3>

<strong>When</strong>: Generating code that references types

<pre><code class="language-csharp">// Generate code with fully qualified type names
<p>var messageType = TypeFormatter.FormatType(</p>
<p>    typeof(OrderCreatedEvent),</p>
<p>    TypeQualification.FullyQualified</p>
<p>);</p>

<p>var generatedCode = $@"</p>
<p>    if (messageType == typeof({messageType})) {{</p>
<p>        return HandleOrderCreated();</p>
<p>    }}</p>
<p>";</p>
<p>// Output:</p>
<p>// if (messageType == typeof(ECommerce.Contracts.Events.OrderCreatedEvent, ECommerce.Contracts)) {</p>
<p>//     return HandleOrderCreated();</p>
<p>// }</p>
<p></code></pre></p>

<h3>Scenario 2: Message Association Lookup</h3>

<strong>When</strong>: Matching message types by name with different qualification levels

<pre><code class="language-csharp">// Lookup by simple name
<p>var associations = GetMessageAssociations(serviceName)</p>
<p>    .Where(a => {</p>
<p>        var simpleName = TypeFormatter.FormatType(</p>
<p>            Type.GetType(a.MessageType)!,</p>
<p>            TypeQualification.Simple</p>
<p>        );</p>
<p>        return simpleName == "ProductCreatedEvent";</p>
<p>    });</p>

<p>// Lookup by fully qualified name</p>
<p>var fullyQualifiedAssociations = GetMessageAssociations(serviceName)</p>
<p>    .Where(a => {</p>
<p>        var fullName = TypeFormatter.FormatType(</p>
<p>            Type.GetType(a.MessageType)!,</p>
<p>            TypeQualification.FullyQualified</p>
<p>        );</p>
<p>        return fullName == "ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts";</p>
<p>    });</p>
<p></code></pre></p>

<h3>Scenario 3: User-Facing Display</h3>

<strong>When</strong>: Showing type names in logs or UI

<pre><code class="language-csharp">public void LogEventProcessing(Type eventType) {
<p>    // Simple name for user-friendly display</p>
<p>    var displayName = TypeFormatter.FormatType(eventType, TypeQualification.Simple);</p>
<p>    _logger.LogInformation("Processing event: {EventName}", displayName);</p>
<p>    // Output: "Processing event: ProductCreatedEvent"</p>

<p>    // Fully qualified for diagnostics</p>
<p>    var fullName = TypeFormatter.FormatType(eventType, TypeQualification.FullyQualified);</p>
<p>    _logger.LogDebug("Full event type: {EventType}", fullName);</p>
<p>    // Output: "Full event type: ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts"</p>
<p>}</p>
<p></code></pre></p>

<h3>Scenario 4: Version-Aware Type Matching</h3>

<strong>When</strong>: Matching types across different assembly versions

<pre><code class="language-csharp">// Format without version information
<p>var typeWithoutVersion = TypeFormatter.FormatType(</p>
<p>    type,</p>
<p>    TypeQualification.Namespace | TypeQualification.TypeName | TypeQualification.Assembly</p>
<p>);</p>

<p>// Format with version information</p>
<p>var typeWithVersion = TypeFormatter.FormatType(</p>
<p>    type,</p>
<p>    TypeQualification.FullyQualifiedWithVersion</p>
<p>);</p>

<p>// Compare without version</p>
<p>bool matchesIgnoringVersion = TypeMatcher.Matches(</p>
<p>    typeWithoutVersion,</p>
<p>    "ECommerce.Contracts.Events.ProductCreatedEvent, ECommerce.Contracts",</p>
<p>    MatchStrictness.Exact</p>
<p>);</p>
<p></code></pre></p>

<h2>Flag Enum Mechanics</h2>

<h3>Bitwise Operations</h3>

<p>TypeQualification uses the <code>[Flags]</code> attribute, enabling bitwise operations:</p>

<pre><code class="language-csharp">// Check if a flag is set
<p>bool hasNamespace = (qualification & TypeQualification.Namespace) == TypeQualification.Namespace;</p>
<p>// OR</p>
<p>bool hasNamespaceAlt = qualification.HasFlag(TypeQualification.Namespace);</p>

<p>// Add a flag</p>
<p>var withAssembly = qualification | TypeQualification.Assembly;</p>

<p>// Remove a flag</p>
<p>var withoutVersion = qualification & ~TypeQualification.Version;</p>

<p>// Toggle a flag</p>
<p>var toggled = qualification ^ TypeQualification.GlobalPrefix;</p>
<p></code></pre></p>

<h3>Building Qualification Dynamically</h3>

<pre><code class="language-csharp">public TypeQualification BuildQualification(
<p>    bool includeNamespace,</p>
<p>    bool includeAssembly,</p>
<p>    bool includeVersion) {</p>

<p>    var result = TypeQualification.TypeName; // Always include type name</p>

<p>    if (includeNamespace) {</p>
<p>        result |= TypeQualification.Namespace;</p>
<p>    }</p>

<p>    if (includeAssembly) {</p>
<p>        result |= TypeQualification.Assembly;</p>
<p>    }</p>

<p>    if (includeVersion) {</p>
<p>        result |= TypeQualification.Version | TypeQualification.Culture | TypeQualification.PublicKeyToken;</p>
<p>    }</p>

<p>    return result;</p>
<p>}</p>

<p>// Usage</p>
<p>var qual = BuildQualification(</p>
<p>    includeNamespace: true,</p>
<p>    includeAssembly: true,</p>
<p>    includeVersion: false</p>
<p>);</p>
<p>// Result: TypeQualification.Namespace | TypeQualification.TypeName | TypeQualification.Assembly</p>
<p></code></pre></p>

<h2>Integration with TypeFormatter</h2>

<p>TypeQualification is designed to work seamlessly with TypeFormatter:</p>

<pre><code class="language-csharp">// TypeFormatter respects all flags
<p>var formatted = TypeFormatter.FormatType(type, TypeQualification.FullyQualified);</p>

<p>// Empty result for None</p>
<p>var empty = TypeFormatter.FormatType(type, TypeQualification.None);</p>
<p>// Result: ""</p>

<p>// Handles combinations correctly</p>
<p>var custom = TypeFormatter.FormatType(</p>
<p>    type,</p>
<p>    TypeQualification.GlobalPrefix | TypeQualification.TypeName</p>
<p>);</p>
<p>// Result: "global::ProductCreatedEvent"</p>
<p></code></pre></p>

<h2>API Reference</h2>

<h3>Enum Definition</h3>

<strong>Namespace</strong>: <code>Whizbang.Core</code>

<pre><code class="language-csharp">[Flags]
<p>public enum TypeQualification {</p>
<p>  None = 0,</p>

<p>  // Component flags (individual bits)</p>
<p>  TypeName = 1 << 0,           // 1</p>
<p>  Namespace = 1 << 1,          // 2</p>
<p>  Assembly = 1 << 2,           // 4</p>
<p>  Version = 1 << 3,            // 8</p>
<p>  Culture = 1 << 4,            // 16</p>
<p>  PublicKeyToken = 1 << 5,     // 32</p>
<p>  GlobalPrefix = 1 << 6,       // 64</p>

<p>  // Composite presets (combinations)</p>
<p>  Simple = TypeName,</p>
<p>  NamespaceQualified = Namespace | TypeName,</p>
<p>  FullyQualified = Namespace | TypeName | Assembly,</p>
<p>  GlobalQualified = GlobalPrefix | Namespace | TypeName,</p>
<p>  FullyQualifiedWithVersion = Namespace | TypeName | Assembly | Version | Culture | PublicKeyToken</p>
<p>}</p>
<p></code></pre></p>

<h3>Usage with TypeFormatter</h3>

<pre><code class="language-csharp">// Format a type with qualification
<p>string formatted = TypeFormatter.FormatType(Type type, TypeQualification qualification);</p>

<p>// Examples</p>
<p>var simple = TypeFormatter.FormatType(typeof(OrderCreatedEvent), TypeQualification.Simple);</p>
<p>var full = TypeFormatter.FormatType(typeof(OrderCreatedEvent), TypeQualification.FullyQualified);</p>
<p>var custom = TypeFormatter.FormatType(</p>
<p>    typeof(OrderCreatedEvent),</p>
<p>    TypeQualification.Namespace | TypeQualification.TypeName</p>
<p>);</p>
<p></code></pre></p>

<h2>Best Practices</h2>

<ul><li><strong>Use composite presets for common cases</strong> - <code>Simple</code>, <code>FullyQualified</code>, etc. are easier to read</li>
<li><strong>Combine individual flags for custom needs</strong> - Use bitwise OR for specific combinations</li>
<li><strong>Default to FullyQualified for generated code</strong> - Avoids ambiguity in generated source</li>
<li><strong>Use Simple for user-facing displays</strong> - More readable in logs and UI</li>
<li><strong>Consider IgnoreVersion for matching</strong> - Combine with MatchStrictness for flexible type matching</li>
<li><strong>Use GlobalPrefix in generated code</strong> - Avoids namespace conflicts with <code>global::</code></li>
<li><strong>Cache formatted results when possible</strong> - Formatting is deterministic, can be memoized</li>
</ul>
<h2>Common Pitfalls</h2>

<h3>❌ Forgetting TypeName Flag</h3>

<pre><code class="language-csharp">// ❌ WRONG: Missing TypeName
<p>var qual = TypeQualification.Namespace | TypeQualification.Assembly;</p>
<p>var result = TypeFormatter.FormatType(type, qual);</p>
<p>// Result: ", MyAssembly" - Invalid!</p>

<p>// ✅ CORRECT: Include TypeName</p>
<p>var qual = TypeQualification.Namespace | TypeQualification.TypeName | TypeQualification.Assembly;</p>
<p>var result = TypeFormatter.FormatType(type, qual);</p>
<p>// Result: "MyNamespace.MyType, MyAssembly"</p>
<p></code></pre></p>

<h3>❌ Confusing Component Flags with Presets</h3>

<pre><code class="language-csharp">// ❌ WRONG: Trying to "remove" from a preset
<p>var qualification = TypeQualification.FullyQualified & ~TypeQualification.Assembly;</p>
<p>// This works but is less clear</p>

<p>// ✅ CORRECT: Build from component flags</p>
<p>var qualification = TypeQualification.Namespace | TypeQualification.TypeName;</p>
<p></code></pre></p>

<h3>❌ Assuming Default Behavior</h3>

<pre><code class="language-csharp">// ❌ WRONG: Assuming default includes namespace
<p>var formatted = TypeFormatter.FormatType(type, TypeQualification.TypeName);</p>
<p>// Result: "ProductCreatedEvent" - No namespace!</p>

<p>// ✅ CORRECT: Explicit about what you want</p>
<p>var formatted = TypeFormatter.FormatType(type, TypeQualification.NamespaceQualified);</p>
<p>// Result: "ECommerce.Contracts.Events.ProductCreatedEvent"</p>
<p></code></pre></p>

<h2>See Also</h2>

<ul><li><a href="/v1.0.0/core-concepts/type-formatting">TypeFormatter</a> - Formatting types according to qualification</li>
<li><a href="/v1.0.0/core-concepts/fuzzy-matching">MatchStrictness</a> - Fuzzy matching with type qualification</li>
<li><a href="/v1.0.0/core-concepts/type-matching">TypeMatcher</a> - Type matching utilities</li>
<li><a href="/v1.0.0/core-concepts/perspectives">Perspectives</a> - Using type qualification in message associations</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-whizbang-ids" class="doc-section">
  <h3>whizbang ids</h3>
  <p class="doc-path"><code>v1.0.0/core-concepts/whizbang-ids</code></p>
  <div class="doc-content">
<h1>WhizbangIds: Strongly-Typed Identity Values</h1>

<p>Whizbang uses strongly-typed identity values based on UUIDv7 for all identifiers. This provides type safety, prevents ID mixing mistakes, and enables AOT-compatible dependency injection.</p>

<h2>Overview</h2>

<strong>WhizbangIds</strong> are source-generated value types that:
<ul><li>✅ Wrap UUIDv7 GUIDs for time-ordered, database-friendly identities</li>
<li>✅ Provide compile-time type safety (can't mix OrderId with CustomerId)</li>
<li>✅ Support both static and DI-based ID generation</li>
<li>✅ Are fully AOT-compatible (zero reflection)</li>
<li>✅ Auto-register with DI via ModuleInitializer</li>
</ul>
<h2>TrackedGuid: Metadata-Aware GUID Wrapper</h2>

<p>For scenarios where you need to work with raw GUIDs while preserving generation metadata, Whizbang provides <code>TrackedGuid</code>:</p>

<pre><code class="language-csharp">using Whizbang.Core.ValueObjects;

<p>// Create with sub-millisecond precision (recommended)</p>
<p>var tracked = TrackedGuid.NewMedo();  // Uses Medo.Uuid7 internally</p>

<p>// Check metadata</p>
<p>bool isTimeOrdered = tracked.IsTimeOrdered;           // true</p>
<p>bool subMs = tracked.SubMillisecondPrecision;         // true</p>
<p>DateTimeOffset when = tracked.Timestamp;              // Extracted from UUIDv7</p>

<p>// Implicit conversion to Guid</p>
<p>Guid guid = tracked;</p>

<p>// Parse from external sources (database, API)</p>
<p>var parsed = TrackedGuid.Parse("550e8400-e29b-41d4-a716-446655440000");</p>
<p>var external = TrackedGuid.FromExternal(someGuid);</p>
<p></code></pre></p>

<h3>Why TrackedGuid?</h3>

<p>| Feature | <code>Guid.NewGuid()</code> | <code>Guid.CreateVersion7()</code> | <code>TrackedGuid.NewMedo()</code> |</p>
<p>|---------|------------------|-------------------------|-------------------------|</p>
<p>| Time-ordered | ❌ No (v4) | ✅ Yes (v7) | ✅ Yes (v7) |</p>
<p>| Sub-millisecond precision | ❌ N/A | ❌ No (ms only) | ✅ Yes |</p>
<p>| Metadata preserved | ❌ No | ❌ No | ✅ Yes |</p>
<p>| Monotonic counter | ❌ No | ❌ No | ✅ Yes |</p>
<p>| Database index friendly | ❌ Poor | ✅ Good | ✅ Excellent |</p>

<strong>Recommendation</strong>: Use <code>[WhizbangId]</code> types for domain identities, <code>TrackedGuid</code> for infrastructure code that needs GUID flexibility with metadata preservation.

<h2>TrackedGuid Interception (Opt-In)</h2>

<p>Whizbang includes an optional compile-time interceptor that automatically wraps GUID creation calls with <code>TrackedGuid</code>, preserving metadata about the GUID source and version.</p>

<h3>Enabling Interception</h3>

<p>Add to your project file to enable automatic interception:</p>

<pre><code class="language-xml"><PropertyGroup>
<p>  <WhizbangGuidInterceptionEnabled>true</WhizbangGuidInterceptionEnabled></p>
<p></PropertyGroup></p>
<p></code></pre></p>

<p>When enabled, the following calls are intercepted:</p>
<ul><li><code>Guid.NewGuid()</code> → <code>TrackedGuid</code> with <code>Version4 | SourceMicrosoft</code></li>
<li><code>Guid.CreateVersion7()</code> → <code>TrackedGuid</code> with <code>Version7 | SourceMicrosoft</code></li>
<li>Third-party libraries (Marten, UUIDNext, Medo.Uuid7)</li>
</ul>
<h3>How It Works</h3>

<p>The <code>GuidInterceptorGenerator</code> uses C# 12 <code>[InterceptsLocation]</code> to replace GUID creation calls at compile-time:</p>

<pre><code class="language-csharp">// Your code (with interception enabled)
<p>var id = Guid.NewGuid();</p>

<p>// After interception (generated code)</p>
<p>var id = TrackedGuid.FromIntercepted(</p>
<p>    Guid.NewGuid(),</p>
<p>    GuidMetadata.Version4 | GuidMetadata.SourceMicrosoft);</p>
<p></code></pre></p>

<h3>Suppressing Interception</h3>

<p>Use <code>[SuppressGuidInterception]</code> to opt-out of interception:</p>

<pre><code class="language-csharp">using Whizbang.Core;

<p>public class LegacyService {</p>
<p>  [SuppressGuidInterception]</p>
<p>  public Guid CreateLegacyId() {</p>
<p>    return Guid.NewGuid();  // Not intercepted</p>
<p>  }</p>
<p>}</p>

<p>// Or suppress entire class</p>
<p>[SuppressGuidInterception]</p>
<p>public class TestFixtures {</p>
<p>  // All Guid calls in this class are not intercepted</p>
<p>}</p>
<p></code></pre></p>

<h3>Runtime Validation</h3>

<p>Use <code>GuidOrderingValidator</code> to validate TrackedGuids at runtime:</p>

<pre><code class="language-csharp">using Whizbang.Core.Configuration;
<p>using Whizbang.Core.Validation;</p>

<p>var options = new WhizbangOptions {</p>
<p>  GuidOrderingViolationSeverity = GuidOrderingSeverity.Warning</p>
<p>};</p>
<p>var validator = new GuidOrderingValidator(options, logger);</p>

<p>// Validates that the GUID is time-ordered (v7)</p>
<p>validator.ValidateForTimeOrdering(trackedGuid, "EventId");</p>
<p>// Logs warning if v4 GUID is used where v7 is expected</p>
<p></code></pre></p>

<p>Configuration options:</p>
<ul><li><code>DisableGuidTracking</code> - Bypass all validation (default: <code>false</code>)</li>
<li><code>GuidOrderingViolationSeverity</code> - <code>None</code>, <code>Info</code>, <code>Warning</code> (default), <code>Error</code></li>
</ul>
<h3>Diagnostics</h3>

<ul><li><strong><a href="../diagnostics/whiz058.md">WHIZ058</a></strong> - Info: GUID call intercepted</li>
<li><strong><a href="../diagnostics/whiz059.md">WHIZ059</a></strong> - Info: Interception suppressed</li>
</ul>
<h2>Roslyn Analyzers (WHIZ055-WHIZ056)</h2>

<p>Whizbang includes Roslyn analyzers that detect problematic GUID generation patterns:</p>

<h3>WHIZ055: Guid.NewGuid() Usage</h3>

<pre><code class="language-csharp">// ⚠️ Warning: Use TrackedGuid.NewMedo() or a [WhizbangId] type instead
<p>var id = Guid.NewGuid();  // WHIZ055</p>

<p>// ✅ Fix: Use TrackedGuid</p>
<p>var id = TrackedGuid.NewMedo();</p>

<p>// ✅ Or use strongly-typed ID</p>
<p>var orderId = OrderId.New();</p>
<p></code></pre></p>

<strong>Why</strong>: <code>Guid.NewGuid()</code> creates UUIDv4 (random) which is not time-ordered and fragments database indexes.

<h3>WHIZ056: Guid.CreateVersion7() Usage</h3>

<pre><code class="language-csharp">// ⚠️ Warning: Use TrackedGuid.NewMedo() for sub-millisecond precision
<p>var id = Guid.CreateVersion7();  // WHIZ056</p>

<p>// ✅ Fix: Use TrackedGuid for sub-millisecond precision</p>
<p>var id = TrackedGuid.NewMedo();</p>
<p></code></pre></p>

<strong>Why</strong>: <code>Guid.CreateVersion7()</code> only has millisecond precision. In high-throughput scenarios, multiple IDs within the same millisecond may not sort correctly.

<h3>Suppressing Analyzer Warnings</h3>

<p>For legitimate cases where you need raw GUID operations:</p>

<pre><code class="language-csharp">// Suppress for specific line
<p>#pragma warning disable WHIZ055</p>
<p>var testId = Guid.NewGuid();  // Intentional for test fixture</p>
<p>#pragma warning restore WHIZ055</p>

<p>// Or suppress in project file (for test projects)</p>
<p><PropertyGroup></p>
<p>  <NoWarn>$(NoWarn);WHIZ055;WHIZ056</NoWarn></p>
<p></PropertyGroup></p>
<p></code></pre></p>

<h2>Quick Start</h2>

<h3>Defining a WhizbangId</h3>

<pre><code class="language-csharp">using Whizbang.Core;

<p>[WhizbangId]</p>
<p>public readonly partial struct OrderId;</p>

<p>[WhizbangId]</p>
<p>public readonly partial struct CustomerId;</p>
<p></code></pre></p>

<p>The <code>[WhizbangId]</code> attribute triggers source generation that creates:</p>
<ul><li>Value object with <code>Value</code> property (Guid)</li>
<li><code>New()</code> static method for creating new IDs</li>
<li><code>From(Guid)</code> static method for wrapping existing GUIDs</li>
<li><code>Parse(string)</code> method for deserialization</li>
<li>Equality operators and <code>IComparable<T></code></li>
<li>Implicit conversion to Guid</li>
<li>JSON converter</li>
<li><strong>Strongly-typed provider</strong> (<code>IWhizbangIdProvider<TId></code>)</li>
<li><strong>Auto-registration</strong> via ModuleInitializer</li>
</ul>
<h3>Using WhizbangIds</h3>

<pre><code class="language-csharp">// Static creation (uses global WhizbangIdProvider)
<p>var orderId = OrderId.New();</p>

<p>// From existing GUID</p>
<p>var existingId = OrderId.From(guid);</p>

<p>// Parse from string</p>
<p>var parsedId = OrderId.Parse("3c5e4...");</p>

<p>// Implicit conversion to Guid</p>
<p>Guid guid = orderId;</p>

<p>// Get underlying Guid</p>
<p>Guid underlyingGuid = orderId.Value;</p>
<p></code></pre></p>

<h2>Strongly-Typed ID Providers</h2>

<h3>The Problem: Generic Code Needs Type-Safe IDs</h3>

<p>When writing generic services or utilities, you need type-safe ID generation:</p>

<pre><code class="language-csharp">// ❌ WRONG: Loses type safety
<p>public class Repository<TEntity> {</p>
<p>    private readonly IWhizbangIdProvider _idProvider;</p>

<p>    public async Task<TEntity> CreateAsync(TEntity entity) {</p>
<p>        entity.Id = _idProvider.NewGuid(); // Returns Guid - not type-safe!</p>
<p>    }</p>
<p>}</p>

<p>// ✅ CORRECT: Type-safe with IWhizbangIdProvider<TId></p>
<p>public class Repository<TEntity, TId></p>
<p>    where TId : struct {</p>

<p>    private readonly IWhizbangIdProvider<TId> _idProvider;</p>

<p>    public async Task<TEntity> CreateAsync(TEntity entity) {</p>
<p>        entity.Id = _idProvider.NewId(); // Returns TId - type-safe!</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Interface: <code>IWhizbangIdProvider<TId></code></h3>

<pre><code class="language-csharp">/// <summary>
<p>/// Strongly-typed provider for generating WhizbangId instances.</p>
<p>/// </summary></p>
<p>public interface IWhizbangIdProvider<TId> where TId : struct {</p>
<p>    /// <summary></p>
<p>    /// Generates a new strongly-typed ID instance.</p>
<p>    /// </summary></p>
<p>    TId NewId();</p>
<p>}</p>
<p></code></pre></p>

<h3>How It Works</h3>

<ul><li><strong>Source Generation</strong>: For each <code>[WhizbangId]</code>, the generator creates:</li>
</ul><p>   - <code>OrderIdProvider</code> class implementing <code>IWhizbangIdProvider<OrderId></code></p>
<p>   - Auto-registration in <code>WhizbangIdProviderRegistration.g.cs</code></p>

<ul><li><strong>ModuleInitializer</strong>: Runs when assembly loads, registers all providers</li>
</ul><p>   <pre><code class="language-csharp">   [ModuleInitializer]</p>
<p>   public static void Initialize() {</p>
<p>       WhizbangIdProviderRegistry.RegisterFactory<OrderId>(</p>
<p>           baseProvider => new OrderIdProvider(baseProvider)</p>
<p>       );</p>
<p>   }</p>
<p>   </code></pre></p>

<ul><li><strong>DI Integration</strong>: <code>AddWhizbangIdProviders()</code> registers all typed providers</li>
</ul><p>   <pre><code class="language-csharp">   services.AddSingleton<IWhizbangIdProvider<OrderId>>(</p>
<p>       sp => new OrderIdProvider(sp.GetRequiredService<IWhizbangIdProvider>())</p>
<p>   );</p>
<p>   </code></pre></p>

<h2>10+ Provider Registration Patterns</h2>

<h3>1. Auto-Register All Providers (Recommended)</h3>

<strong>When</strong>: Standard application setup

<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);

<p>// Registers IWhizbangIdProvider (Uuid7IdProvider by default)</p>
<p>// AND all IWhizbangIdProvider<TId> for discovered WhizbangIds</p>
<p>builder.Services.AddWhizbangIdProviders();</p>

<p>var app = builder.Build();</p>
<p></code></pre></p>

<strong>What gets registered</strong>:
<ul><li><code>IWhizbangIdProvider</code> → <code>Uuid7IdProvider</code> (singleton)</li>
<li><code>IWhizbangIdProvider<OrderId></code> → <code>OrderIdProvider</code> (singleton)</li>
<li><code>IWhizbangIdProvider<CustomerId></code> → <code>CustomerIdProvider</code> (singleton)</li>
<li>... (all WhizbangIds in all loaded assemblies)</li>
</ul>
<h3>2. Custom Base Provider</h3>

<strong>When</strong>: Using database sequences, tenant-specific IDs, or custom ID generation

<pre><code class="language-csharp">// Custom ID generator
<p>public class SequenceBasedIdProvider : IWhizbangIdProvider {</p>
<p>    private readonly IDbConnection _db;</p>

<p>    public Guid NewGuid() {</p>
<p>        var sequence = _db.GetNextSequence("id_sequence");</p>
<p>        return GuidFromSequence(sequence);</p>
<p>    }</p>
<p>}</p>

<p>// Register custom provider</p>
<p>builder.Services.AddSingleton<IWhizbangIdProvider, SequenceBasedIdProvider>();</p>
<p>builder.Services.AddWhizbangIdProviders();</p>
<p>// Now ALL typed providers use SequenceBasedIdProvider</p>
<p></code></pre></p>

<h3>3. Override Specific ID Types</h3>

<strong>When</strong>: Some IDs need special generation (e.g., CustomerIds from external system)

<pre><code class="language-csharp">builder.Services.AddWhizbangIdProviders();

<p>// Override CustomerIdProvider</p>
<p>builder.Services.AddSingleton<IWhizbangIdProvider<CustomerId>>(sp => {</p>
<p>    var externalSystem = sp.GetRequiredService<IExternalCustomerService>();</p>
<p>    return new ExternalCustomerIdProvider(externalSystem);</p>
<p>});</p>
<p></code></pre></p>

<h3>4. Test Project Overrides</h3>

<strong>When</strong>: Tests need deterministic or custom IDs

<pre><code class="language-csharp">// Test setup
<p>var services = new ServiceCollection();</p>

<p>// Use sequential IDs for tests</p>
<p>services.AddSingleton<IWhizbangIdProvider, SequentialTestIdProvider>();</p>
<p>services.AddWhizbangIdProviders();</p>

<p>// All typed providers now use SequentialTestIdProvider</p>
<p>var provider = services.BuildServiceProvider();</p>
<p>var orderIdProvider = provider.GetRequiredService<IWhizbangIdProvider<TestOrderId>>();</p>
<p>var id1 = orderIdProvider.NewId(); // TestOrderId(00000000-0000-0000-0000-000000000001)</p>
<p>var id2 = orderIdProvider.NewId(); // TestOrderId(00000000-0000-0000-0000-000000000002)</p>
<p></code></pre></p>

<h3>5. No DI - Direct Provider Creation</h3>

<strong>When</strong>: Console apps, scripts, or areas without DI

<pre><code class="language-csharp">// Create typed provider directly
<p>var baseProvider = new Uuid7IdProvider();</p>
<p>var orderIdProvider = OrderId.CreateProvider(baseProvider);</p>

<p>var orderId = orderIdProvider.NewId();</p>
<p></code></pre></p>

<h3>6. Global Provider Configuration</h3>

<strong>When</strong>: Want to use global static provider AND DI

<pre><code class="language-csharp">// Configure global provider (affects OrderId.New())
<p>WhizbangIdProvider.Configure(new Uuid7IdProvider());</p>

<p>// ALSO register with DI (for injection)</p>
<p>builder.Services.AddWhizbangIdProviders();</p>

<p>// Now works both ways:</p>
<p>var id1 = OrderId.New(); // Uses global provider</p>
<p>var id2 = orderIdProvider.NewId(); // Uses injected provider (same implementation)</p>
<p></code></pre></p>

<h3>7. Hybrid - Static + DI</h3>

<strong>When</strong>: Some code uses static <code>New()</code>, some uses DI

<pre><code class="language-csharp">// Configure global provider
<p>WhizbangIdProvider.Configure(new Uuid7IdProvider());</p>

<p>// Register for DI</p>
<p>builder.Services.AddWhizbangIdProviders();</p>

<p>public class OrderService {</p>
<p>    // Option 1: Use static New()</p>
<p>    public Order CreateOrder() {</p>
<p>        return new Order {</p>
<p>            Id = OrderId.New() // Uses global provider</p>
<p>        };</p>
<p>    }</p>

<p>    // Option 2: Inject typed provider</p>
<p>    public class OrderRepository {</p>
<p>        private readonly IWhizbangIdProvider<OrderId> _idProvider;</p>

<p>        public OrderRepository(IWhizbangIdProvider<OrderId> idProvider) {</p>
<p>            _idProvider = idProvider;</p>
<p>        }</p>

<p>        public Order CreateOrder() {</p>
<p>            return new Order {</p>
<p>                Id = _idProvider.NewId() // Uses injected provider</p>
<p>            };</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>8. Multi-Tenant ID Generation</h3>

<strong>When</strong>: IDs need tenant prefix or tenant-specific sequences

<pre><code class="language-csharp">public class TenantAwareIdProvider : IWhizbangIdProvider {
<p>    private readonly IHttpContextAccessor _contextAccessor;</p>

<p>    public Guid NewGuid() {</p>
<p>        var tenantId = _contextAccessor.HttpContext?.User.FindFirst("tenant_id")?.Value;</p>
<p>        return GenerateTenantPrefixedGuid(tenantId);</p>
<p>    }</p>
<p>}</p>

<p>builder.Services.AddScoped<IWhizbangIdProvider, TenantAwareIdProvider>();</p>
<p>builder.Services.AddWhizbangIdProviders();</p>
<p>// All typed providers now include tenant context</p>
<p></code></pre></p>

<h3>9. Database Sequence IDs</h3>

<strong>When</strong>: Using database-generated sequences for distributed ID generation

<pre><code class="language-csharp">public class PostgresSequenceIdProvider : IWhizbangIdProvider {
<p>    private readonly NpgsqlConnection _connection;</p>

<p>    public Guid NewGuid() {</p>
<p>        var sequence = _connection.ExecuteScalar<long>(</p>
<p>            "SELECT nextval('global_id_sequence')"</p>
<p>        );</p>
<p>        return ConvertSequenceToGuid(sequence);</p>
<p>    }</p>
<p>}</p>

<p>builder.Services.AddSingleton<IWhizbangIdProvider, PostgresSequenceIdProvider>();</p>
<p>builder.Services.AddWhizbangIdProviders();</p>
<p></code></pre></p>

<h3>10. Scoped vs Singleton Providers</h3>

<strong>When</strong>: Provider needs request-scoped dependencies

<pre><code class="language-csharp">// Scoped base provider
<p>builder.Services.AddScoped<IWhizbangIdProvider, RequestScopedIdProvider>();</p>

<p>// Register typed providers as scoped</p>
<p>builder.Services.AddWhizbangIdProviders();</p>

<p>// Now IWhizbangIdProvider<OrderId> is scoped, uses scoped base provider</p>
<p></code></pre></p>

<h2>Advanced Scenarios</h2>

<h3>Custom Provider Implementation</h3>

<pre><code class="language-csharp">public class CustomOrderIdProvider : IWhizbangIdProvider<OrderId> {
<p>    private readonly ILogger<CustomOrderIdProvider> _logger;</p>

<p>    public CustomOrderIdProvider(ILogger<CustomOrderIdProvider> logger) {</p>
<p>        _logger = logger;</p>
<p>    }</p>

<p>    public OrderId NewId() {</p>
<p>        var id = OrderId.From(Guid.CreateVersion7());</p>
<p>        _logger.LogDebug("Generated OrderId: {OrderId}", id);</p>
<p>        return id;</p>
<p>    }</p>
<p>}</p>

<p>// Register custom implementation</p>
<p>builder.Services.AddSingleton<IWhizbangIdProvider<OrderId>, CustomOrderIdProvider>();</p>
<p></code></pre></p>

<h3>Composite Provider (Multiple Strategies)</h3>

<pre><code class="language-csharp">public class CompositeIdProvider : IWhizbangIdProvider {
<p>    private readonly IWhizbangIdProvider _primary;</p>
<p>    private readonly IWhizbangIdProvider _fallback;</p>

<p>    public Guid NewGuid() {</p>
<p>        try {</p>
<p>            return _primary.NewGuid();</p>
<p>        }</p>
<p>        catch {</p>
<p>            return _fallback.NewGuid();</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Logging Wrapper</h3>

<pre><code class="language-csharp">public class LoggingIdProviderWrapper<TId> : IWhizbangIdProvider<TId>
<p>    where TId : struct {</p>

<p>    private readonly IWhizbangIdProvider<TId> _inner;</p>
<p>    private readonly ILogger _logger;</p>

<p>    public TId NewId() {</p>
<p>        var id = _inner.NewId();</p>
<p>        _logger.LogDebug("Generated {IdType}: {Id}", typeof(TId).Name, id);</p>
<p>        return id;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>API Reference</h2>

<h3>IWhizbangIdProvider&lt;TId&gt;</h3>

<strong>Namespace</strong>: <code>Whizbang.Core</code>

<strong>Purpose</strong>: Strongly-typed provider for generating WhizbangId instances.

<strong>Methods</strong>:
<ul><li><code>TId NewId()</code> - Generates a new ID instance</li>
</ul>
<strong>Usage</strong>:
<pre><code class="language-csharp">public class OrderService {
<p>    private readonly IWhizbangIdProvider<OrderId> _idProvider;</p>

<p>    public OrderService(IWhizbangIdProvider<OrderId> idProvider) {</p>
<p>        _idProvider = idProvider;</p>
<p>    }</p>

<p>    public Order CreateOrder() {</p>
<p>        return new Order {</p>
<p>            Id = _idProvider.NewId()</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>WhizbangIdProviderRegistry</h3>

<strong>Namespace</strong>: <code>Whizbang.Core</code>

<strong>Purpose</strong>: Global registry for typed ID provider factories (used by generated code).

<strong>Methods</strong>:
<ul><li><code>RegisterFactory<TId>(Func<IWhizbangIdProvider, IWhizbangIdProvider<TId>>)</code> - Register factory (called by ModuleInitializer)</li>
<li><code>CreateProvider<TId>(IWhizbangIdProvider)</code> - Create typed provider from registry</li>
<li><code>RegisterDICallback(Action<IServiceCollection, IWhizbangIdProvider>)</code> - Register DI callback</li>
<li><code>RegisterAllWithDI(IServiceCollection, IWhizbangIdProvider)</code> - Call all DI callbacks</li>
<li><code>GetRegisteredIdTypes()</code> - Get all registered ID types</li>
</ul>
<strong>Note</strong>: Typically not used directly - ModuleInitializer handles registration automatically.

<h3>AddWhizbangIdProviders Extension</h3>

<strong>Namespace</strong>: <code>Microsoft.Extensions.DependencyInjection</code>

<strong>Purpose</strong>: Registers all WhizbangId providers with DI.

<strong>Signature</strong>:
<pre><code class="language-csharp">public static IServiceCollection AddWhizbangIdProviders(
<p>    this IServiceCollection services,</p>
<p>    IWhizbangIdProvider? baseProvider = null</p>
<p>)</p>
<p></code></pre></p>

<strong>Parameters</strong>:
<ul><li><code>baseProvider</code> - Custom base provider (default: <code>new Uuid7IdProvider()</code>)</li>
</ul>
<strong>Returns</strong>: <code>IServiceCollection</code> for chaining

<strong>Example</strong>:
<pre><code class="language-csharp">builder.Services.AddWhizbangIdProviders(); // Uses Uuid7IdProvider
<p>// OR</p>
<p>builder.Services.AddWhizbangIdProviders(new CustomIdProvider());</p>
<p></code></pre></p>

<h2>Testing Patterns</h2>

<h3>Test with Sequential IDs</h3>

<pre><code class="language-csharp">public class SequentialTestIdProvider : IWhizbangIdProvider {
<p>    private long _counter = 0;</p>

<p>    public Guid NewGuid() {</p>
<p>        var value = Interlocked.Increment(ref _counter);</p>
<p>        return new Guid($"00000000-0000-0000-0000-{value:D12}");</p>
<p>    }</p>
<p>}</p>

<p>// In tests</p>
<p>var services = new ServiceCollection();</p>
<p>services.AddSingleton<IWhizbangIdProvider, SequentialTestIdProvider>();</p>
<p>services.AddWhizbangIdProviders();</p>
<p></code></pre></p>

<h3>Test with Known IDs</h3>

<pre><code class="language-csharp">public class KnownIdProvider<TId> : IWhizbangIdProvider<TId>
<p>    where TId : struct {</p>

<p>    private readonly Queue<TId> _ids;</p>

<p>    public KnownIdProvider(params TId[] ids) {</p>
<p>        _ids = new Queue<TId>(ids);</p>
<p>    }</p>

<p>    public TId NewId() => _ids.Dequeue();</p>
<p>}</p>

<p>// In tests</p>
<p>var knownOrderId = OrderId.From(new Guid("11111111-1111-1111-1111-111111111111"));</p>
<p>var provider = new KnownIdProvider<OrderId>(knownOrderId);</p>

<p>var order = new Order { Id = provider.NewId() };</p>
<p>Assert.Equal(knownOrderId, order.Id);</p>
<p></code></pre></p>

<h3>Test Direct Provider Creation</h3>

<pre><code class="language-csharp">[Test]
<p>public void OrderId_CreateProvider_GeneratesValidIds() {</p>
<p>    // Arrange</p>
<p>    var baseProvider = new Uuid7IdProvider();</p>
<p>    var orderIdProvider = OrderId.CreateProvider(baseProvider);</p>

<p>    // Act</p>
<p>    var id1 = orderIdProvider.NewId();</p>
<p>    var id2 = orderIdProvider.NewId();</p>

<p>    // Assert</p>
<p>    Assert.NotEqual(id1, id2);</p>
<p>    Assert.NotEqual(Guid.Empty, id1.Value);</p>
<p>}</p>
<p></code></pre></p>

<h2>Migration Guide</h2>

<h3>Automated Migration with <code>whizbang-migrate</code></h3>

<p>Whizbang provides automated code transformation for migrating from raw Guid usage:</p>

<pre><code class="language-bash"># Analyze codebase for Guid patterns
<p>whizbang-migrate analyze ./src</p>

<h1>Transform Guid.NewGuid()/CreateVersion7() to TrackedGuid.NewMedo()</h1>
<p>whizbang-migrate transform --transformer GuidToTrackedGuid ./src</p>

<h1>Or transform to IWhizbangIdProvider pattern (for DI)</h1>
<p>whizbang-migrate transform --transformer GuidToIdProvider ./src</p>
<p></code></pre></p>

<p>The <code>GuidToTrackedGuidTransformer</code> automatically:</p>
<ul><li>Converts <code>Guid.NewGuid()</code> → <code>TrackedGuid.NewMedo()</code></li>
<li>Converts <code>Guid.CreateVersion7()</code> → <code>TrackedGuid.NewMedo()</code></li>
<li>Adds <code>using Whizbang.Core.ValueObjects;</code> directive</li>
<li>Emits warnings about return types that may need updating</li>
</ul>
<h3>Migrating from Guid to WhizbangId</h3>

<strong>Before</strong>:
<pre><code class="language-csharp">public class Order {
<p>    public Guid OrderId { get; init; }</p>
<p>}</p>

<p>public class OrderService {</p>
<p>    public Order CreateOrder() {</p>
<p>        return new Order {</p>
<p>            OrderId = Guid.NewGuid() // ❌ Not time-ordered, not type-safe</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>After</strong>:
<pre><code class="language-csharp">[WhizbangId]
<p>public readonly partial struct OrderId;</p>

<p>public class Order {</p>
<p>    public OrderId OrderId { get; init; } // ✅ Type-safe</p>
<p>}</p>

<p>public class OrderService {</p>
<p>    private readonly IWhizbangIdProvider<OrderId> _idProvider;</p>

<p>    public OrderService(IWhizbangIdProvider<OrderId> idProvider) {</p>
<p>        _idProvider = idProvider;</p>
<p>    }</p>

<p>    public Order CreateOrder() {</p>
<p>        return new Order {</p>
<p>            OrderId = _idProvider.NewId() // ✅ Time-ordered UUIDv7, type-safe</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Migrating from IWhizbangIdProvider to IWhizbangIdProvider&lt;TId&gt;</h3>

<strong>Before</strong>:
<pre><code class="language-csharp">public class Repository<TEntity> {
<p>    private readonly IWhizbangIdProvider _idProvider;</p>

<p>    public Repository(IWhizbangIdProvider idProvider) {</p>
<p>        _idProvider = idProvider;</p>
<p>    }</p>

<p>    public TEntity Create(TEntity entity) {</p>
<p>        entity.Id = _idProvider.NewGuid(); // ❌ Returns Guid</p>
<p>        return entity;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>After</strong>:
<pre><code class="language-csharp">public class Repository<TEntity, TId>
<p>    where TId : struct {</p>

<p>    private readonly IWhizbangIdProvider<TId> _idProvider;</p>

<p>    public Repository(IWhizbangIdProvider<TId> idProvider) {</p>
<p>        _idProvider = idProvider;</p>
<p>    }</p>

<p>    public TEntity Create(TEntity entity) {</p>
<p>        entity.Id = _idProvider.NewId(); // ✅ Returns TId</p>
<p>        return entity;</p>
<p>    }</p>
<p>}</p>

<p>// Usage</p>
<p>var orderRepo = new Repository<Order, OrderId>(orderIdProvider);</p>
<p></code></pre></p>

<h2>Best Practices</h2>

<ul><li><strong>Use typed providers in generic code</strong> - Enables type safety in repositories, services, utilities</li>
<li><strong>Prefer DI over static New()</strong> - Makes testing easier, allows custom providers</li>
<li><strong>Configure global provider early</strong> - In <code>Program.cs</code> before any IDs are created</li>
<li><strong>Use auto-registration</strong> - Let ModuleInitializer handle registration automatically</li>
<li><strong>Override specific types when needed</strong> - Register custom implementations after <code>AddWhizbangIdProviders()</code></li>
<li><strong>Test with sequential IDs</strong> - Makes tests predictable and debuggable</li>
<li><strong>Document custom providers</strong> - Explain why/when custom generation is needed</li>
</ul>
<h2>See Also</h2>

<ul><li><a href="/v1.0.0/core-concepts/message-context">Message Context</a> - How IDs flow through message processing</li>
<li><a href="/v1.0.0/core-concepts/observability">Observability</a> - Correlation and causation tracking</li>
<li><a href="/v1.0.0/testing/testing-strategy">Testing Strategy</a> - Testing with WhizbangIds</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<section class="doc-category">
  <h3 class="category-header">Perspectives</h3>
<article id="v1-0-0-core-concepts-perspectives-association-info" class="doc-section">
  <h4>association info</h4>
  <p class="doc-path"><code>v1.0.0/core-concepts/perspectives/association-info</code></p>
  <div class="doc-content">
<h1>PerspectiveAssociationInfo: Strongly-Typed Associations with Delegates</h1>

<p>PerspectiveAssociationInfo is a generic record type that provides strongly-typed perspective associations with AOT-compatible delegates to perspective Apply methods. It enables compile-time type safety and performant perspective invocation without reflection.</p>

<h2>Overview</h2>

<strong>PerspectiveAssociationInfo&lt;TModel, TEvent&gt;</strong> provides:
<ul><li>✅ Strongly-typed delegate access to perspective Apply methods</li>
<li>✅ Compile-time type safety (no runtime type checks)</li>
<li>✅ AOT-compatible (zero reflection at runtime)</li>
<li>✅ Generated by source generators for all perspectives</li>
<li>✅ Supports generic perspective invocation</li>
</ul>
<h2>Quick Start</h2>

<h3>Getting Typed Associations</h3>

<pre><code class="language-csharp">using Whizbang.Core.Generated;

<p>// Get associations for specific model and event types</p>
<p>var associations = PerspectiveRegistrationExtensions</p>
<p>    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>("ECommerce.BFF.API");</p>

<p>foreach (var assoc in associations) {</p>
<p>    Console.WriteLine($"Perspective: {assoc.TargetName}");</p>
<p>    Console.WriteLine($"Event: {assoc.MessageType}");</p>
<p>    Console.WriteLine($"Service: {assoc.ServiceName}");</p>

<p>    // Invoke delegate directly</p>
<p>    var currentModel = new ProductModel();</p>
<p>    var evt = new ProductCreatedEvent { ProductId = "prod-123" };</p>
<p>    var updatedModel = assoc.ApplyDelegate(currentModel, evt);</p>
<p>}</p>
<p></code></pre></p>

<h3>Using Delegates</h3>

<pre><code class="language-csharp">// Example: Generic perspective applier
<p>public TModel ApplyEvent<TModel, TEvent>(</p>
<p>    TModel model,</p>
<p>    TEvent evt,</p>
<p>    string serviceName)</p>
<p>    where TEvent : IEvent {</p>

<p>    var associations = PerspectiveRegistrationExtensions</p>
<p>        .GetPerspectiveAssociations<TModel, TEvent>(serviceName);</p>

<p>    // Apply all matching perspectives</p>
<p>    foreach (var assoc in associations) {</p>
<p>        model = assoc.ApplyDelegate(model, evt);</p>
<p>    }</p>

<p>    return model;</p>
<p>}</p>

<p>// Usage</p>
<p>var productModel = new ProductModel();</p>
<p>var productEvent = new ProductCreatedEvent { ProductId = "prod-123" };</p>
<p>var updated = ApplyEvent(productModel, productEvent, "ECommerce.BFF.API");</p>
<p></code></pre></p>

<h2>Record Structure</h2>

<h3>Type Definition</h3>

<pre><code class="language-csharp">/// <summary>
<p>/// Rich association info with strongly-typed delegate for perspective Apply method.</p>
<p>/// Provides compile-time type safety and AOT-compatible delegate invocation.</p>
<p>/// </summary></p>
<p>/// <typeparam name="TModel">The model type maintained by the perspective</typeparam></p>
<p>/// <typeparam name="TEvent">The event type handled by the perspective</typeparam></p>
<p>/// <param name="MessageType">Fully qualified event type name</param></p>
<p>/// <param name="TargetName">Name of the perspective class</param></p>
<p>/// <param name="ServiceName">Service name (assembly name)</param></p>
<p>/// <param name="ApplyDelegate">Strongly-typed delegate to perspective's Apply method</param></p>
<p>public sealed record PerspectiveAssociationInfo<TModel, TEvent>(</p>
<p>    string MessageType,</p>
<p>    string TargetName,</p>
<p>    string ServiceName,</p>
<p>    Func<TModel, TEvent, TModel> ApplyDelegate</p>
<p>) where TEvent : IEvent;</p>
<p></code></pre></p>

<h3>Properties</h3>

<p>| Property | Type | Description |</p>
<p>|----------|------|-------------|</p>
<p>| <code>MessageType</code> | <code>string</code> | Fully qualified event type name (e.g., "ECommerce.Contracts.Events.ProductCreatedEvent") |</p>
<p>| <code>TargetName</code> | <code>string</code> | Simple name of the perspective class (e.g., "ProductPerspective") |</p>
<p>| <code>ServiceName</code> | <code>string</code> | Service name / assembly name (e.g., "ECommerce.BFF.API") |</p>
<p>| <code>ApplyDelegate</code> | <code>Func<TModel, TEvent, TModel></code> | Strongly-typed delegate invoking the perspective's Apply method |</p>

<h3>Type Constraints</h3>

<ul><li><code>TModel</code>: No constraints (any type)</li>
<li><code>TEvent</code>: Must implement <code>IEvent</code> interface</li>
</ul>
<h2>Delegate Invocation</h2>

<h3>Direct Invocation</h3>

<pre><code class="language-csharp">var associations = PerspectiveRegistrationExtensions
<p>    .GetPerspectiveAssociations<InventoryModel, ProductCreatedEvent>("ECommerce.BFF.API");</p>

<p>var model = new InventoryModel { ProductCount = 10 };</p>
<p>var evt = new ProductCreatedEvent { ProductId = "prod-123" };</p>

<p>foreach (var assoc in associations) {</p>
<p>    // Direct delegate invocation</p>
<p>    model = assoc.ApplyDelegate(model, evt);</p>
<p>    Console.WriteLine($"Applied {assoc.TargetName}: ProductCount = {model.ProductCount}");</p>
<p>}</p>
<p></code></pre></p>

<h3>Generic Invocation Helper</h3>

<pre><code class="language-csharp">public class PerspectiveApplier {
<p>    private readonly string _serviceName;</p>

<p>    public PerspectiveApplier(string serviceName) {</p>
<p>        _serviceName = serviceName;</p>
<p>    }</p>

<p>    public TModel ApplyAll<TModel, TEvent>(TModel model, TEvent evt)</p>
<p>        where TEvent : IEvent {</p>

<p>        var associations = PerspectiveRegistrationExtensions</p>
<p>            .GetPerspectiveAssociations<TModel, TEvent>(_serviceName);</p>

<p>        foreach (var assoc in associations) {</p>
<p>            model = assoc.ApplyDelegate(model, evt);</p>
<p>        }</p>

<p>        return model;</p>
<p>    }</p>
<p>}</p>

<p>// Usage</p>
<p>var applier = new PerspectiveApplier("ECommerce.BFF.API");</p>
<p>var updatedModel = applier.ApplyAll(currentModel, newEvent);</p>
<p></code></pre></p>

<h2>Common Scenarios</h2>

<h3>Scenario 1: Generic Perspective Runner</h3>

<strong>When</strong>: Building a generic perspective materialization engine

<pre><code class="language-csharp">public class PerspectiveMaterializer {
<p>    public async Task<TModel> MaterializeAsync<TModel, TEvent>(</p>
<p>        TModel initialModel,</p>
<p>        IEnumerable<TEvent> events,</p>
<p>        string serviceName)</p>
<p>        where TEvent : IEvent {</p>

<p>        // Get associations once (outside loop for performance)</p>
<p>        var associations = PerspectiveRegistrationExtensions</p>
<p>            .GetPerspectiveAssociations<TModel, TEvent>(serviceName);</p>

<p>        if (!associations.Any()) {</p>
<p>            throw new InvalidOperationException(</p>
<p>                $"No perspectives found for {typeof(TModel).Name} handling {typeof(TEvent).Name}"</p>
<p>            );</p>
<p>        }</p>

<p>        var model = initialModel;</p>

<p>        // Apply each event through all perspectives</p>
<p>        foreach (var evt in events) {</p>
<p>            foreach (var assoc in associations) {</p>
<p>                model = assoc.ApplyDelegate(model, evt);</p>
<p>            }</p>
<p>        }</p>

<p>        return model;</p>
<p>    }</p>
<p>}</p>

<p>// Usage</p>
<p>var materializer = new PerspectiveMaterializer();</p>
<p>var events = await LoadEventsAsync();</p>
<p>var model = await materializer.MaterializeAsync(</p>
<p>    new ProductModel(),</p>
<p>    events,</p>
<p>    "ECommerce.BFF.API"</p>
<p>);</p>
<p></code></pre></p>

<h3>Scenario 2: Perspective Discovery and Diagnostics</h3>

<strong>When</strong>: Discovering available perspectives at runtime

<pre><code class="language-csharp">public class PerspectiveDiagnostics {
<p>    public void PrintPerspectiveInfo<TModel, TEvent>(string serviceName)</p>
<p>        where TEvent : IEvent {</p>

<p>        var associations = PerspectiveRegistrationExtensions</p>
<p>            .GetPerspectiveAssociations<TModel, TEvent>(serviceName);</p>

<p>        Console.WriteLine($"Perspectives handling {typeof(TEvent).Name}:");</p>
<p>        Console.WriteLine($"Model Type: {typeof(TModel).FullName}");</p>
<p>        Console.WriteLine($"Event Type: {typeof(TEvent).FullName}");</p>
<p>        Console.WriteLine();</p>

<p>        foreach (var assoc in associations) {</p>
<p>            Console.WriteLine($"  Perspective: {assoc.TargetName}");</p>
<p>            Console.WriteLine($"  Message Type: {assoc.MessageType}");</p>
<p>            Console.WriteLine($"  Service: {assoc.ServiceName}");</p>
<p>            Console.WriteLine($"  Delegate: {assoc.ApplyDelegate.Method.Name}");</p>
<p>            Console.WriteLine();</p>
<p>        }</p>
<p>    }</p>
<p>}</p>

<p>// Usage</p>
<p>var diagnostics = new PerspectiveDiagnostics();</p>
<p>diagnostics.PrintPerspectiveInfo<ProductModel, ProductCreatedEvent>("ECommerce.BFF.API");</p>

<p>// Output:</p>
<p>// Perspectives handling ProductCreatedEvent:</p>
<p>// Model Type: ECommerce.BFF.API.Models.ProductModel</p>
<p>// Event Type: ECommerce.Contracts.Events.ProductCreatedEvent</p>
<p>//</p>
<p>//   Perspective: ProductPerspective</p>
<p>//   Message Type: ECommerce.Contracts.Events.ProductCreatedEvent</p>
<p>//   Service: ECommerce.BFF.API</p>
<p>//   Delegate: <lambda_method></p>
<p></code></pre></p>

<h3>Scenario 3: Testing Perspective Behavior</h3>

<strong>When</strong>: Unit testing perspectives in isolation

<pre><code class="language-csharp">[Test]
<p>public async Task ProductPerspective_ApplyProductCreatedEvent_IncrementsCountAsync() {</p>
<p>    // Arrange</p>
<p>    var associations = PerspectiveRegistrationExtensions</p>
<p>        .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>("ECommerce.BFF.API");</p>

<p>    var assoc = associations.Single(a => a.TargetName == "ProductPerspective");</p>

<p>    var initialModel = new ProductModel { ProductCount = 5 };</p>
<p>    var evt = new ProductCreatedEvent { ProductId = "prod-123" };</p>

<p>    // Act</p>
<p>    var updatedModel = assoc.ApplyDelegate(initialModel, evt);</p>

<p>    // Assert</p>
<p>    await Assert.That(updatedModel.ProductCount).IsEqualTo(6);</p>
<p>}</p>
<p></code></pre></p>

<h3>Scenario 4: Performance Optimization with Caching</h3>

<strong>When</strong>: Caching associations for high-throughput scenarios

<pre><code class="language-csharp">public class CachedPerspectiveApplier {
<p>    private readonly ConcurrentDictionary<Type, object> _associationCache = new();</p>
<p>    private readonly string _serviceName;</p>

<p>    public CachedPerspectiveApplier(string serviceName) {</p>
<p>        _serviceName = serviceName;</p>
<p>    }</p>

<p>    public TModel ApplyEvent<TModel, TEvent>(TModel model, TEvent evt)</p>
<p>        where TEvent : IEvent {</p>

<p>        // Get from cache or create</p>
<p>        var cacheKey = typeof((TModel, TEvent));</p>
<p>        var associations = (IReadOnlyList<PerspectiveAssociationInfo<TModel, TEvent>>)</p>
<p>            _associationCache.GetOrAdd(cacheKey, _ =></p>
<p>                PerspectiveRegistrationExtensions</p>
<p>                    .GetPerspectiveAssociations<TModel, TEvent>(_serviceName)</p>
<p>            );</p>

<p>        // Apply all perspectives</p>
<p>        foreach (var assoc in associations) {</p>
<p>            model = assoc.ApplyDelegate(model, evt);</p>
<p>        }</p>

<p>        return model;</p>
<p>    }</p>
<p>}</p>

<p>// Usage - associations cached after first call</p>
<p>var applier = new CachedPerspectiveApplier("ECommerce.BFF.API");</p>
<p>for (int i = 0; i < 10000; i++) {</p>
<p>    model = applier.ApplyEvent(model, events[i]); // Fast after first call</p>
<p>}</p>
<p></code></pre></p>

<h2>AOT Compatibility</h2>

<h3>No Reflection at Runtime</h3>

<p>PerspectiveAssociationInfo delegates are generated at compile time:</p>

<pre><code class="language-csharp">// Generated code (example)
<p>public static IReadOnlyList<PerspectiveAssociationInfo<TModel, TEvent>></p>
<p>    GetPerspectiveAssociations<TModel, TEvent>(string serviceName)</p>
<p>    where TEvent : IEvent {</p>

<p>    // Compile-time type checking</p>
<p>    if (typeof(TModel) == typeof(ProductModel) &&</p>
<p>        typeof(TEvent) == typeof(ProductCreatedEvent)) {</p>

<p>        return new[] {</p>
<p>            new PerspectiveAssociationInfo<TModel, TEvent>(</p>
<p>                "ECommerce.Contracts.Events.ProductCreatedEvent",</p>
<p>                "ProductPerspective",</p>
<p>                "ECommerce.BFF.API",</p>
<p>                (model, evt) => {</p>
<p>                    // Direct instantiation - no reflection!</p>
<p>                    var perspective = new ProductPerspective();</p>
<p>                    var typedModel = (ProductModel)((object)model);</p>
<p>                    var typedEvent = (ProductCreatedEvent)((object)evt);</p>
<p>                    var result = perspective.Apply(typedModel, typedEvent);</p>
<p>                    return (TModel)((object)result);</p>
<p>                }</p>
<p>            )</p>
<p>        };</p>
<p>    }</p>

<p>    return Array.Empty<PerspectiveAssociationInfo<TModel, TEvent>>();</p>
<p>}</p>
<p></code></pre></p>

<h3>Key AOT Features</h3>

<ul><li>✅ No <code>Activator.CreateInstance</code> - uses <code>new</code> keyword</li>
<li>✅ No <code>MethodInfo.Invoke</code> - uses direct method calls</li>
<li>✅ No reflection-based type discovery - uses <code>typeof()</code> checks</li>
<li>✅ All type checking at compile time</li>
<li>✅ Trim-safe (no dynamic type loading)</li>
</ul>
<h2>Integration with MessageAssociation</h2>

<p>PerspectiveAssociationInfo complements the simpler MessageAssociation type:</p>

<pre><code class="language-csharp">// MessageAssociation: Simple string-based association
<p>public sealed record MessageAssociation(</p>
<p>    string MessageType,</p>
<p>    string AssociationType,</p>
<p>    string TargetName,</p>
<p>    string ServiceName</p>
<p>);</p>

<p>// PerspectiveAssociationInfo: Strongly-typed with delegates</p>
<p>public sealed record PerspectiveAssociationInfo<TModel, TEvent>(</p>
<p>    string MessageType,</p>
<p>    string TargetName,</p>
<p>    string ServiceName,</p>
<p>    Func<TModel, TEvent, TModel> ApplyDelegate</p>
<p>) where TEvent : IEvent;</p>
<p></code></pre></p>

<strong>Use MessageAssociation when</strong>:
<ul><li>Querying available associations</li>
<li>String-based type matching</li>
<li>Discovery and metadata</li>
</ul>
<strong>Use PerspectiveAssociationInfo when</strong>:
<ul><li>Invoking perspectives</li>
<li>Generic perspective handling</li>
<li>Performance-critical code paths</li>
<li>Type-safe operations</li>
</ul>
<h3>Converting Between Types</h3>

<pre><code class="language-csharp">// Get MessageAssociations (all perspectives)
<p>var messageAssocs = PerspectiveRegistrationExtensions</p>
<p>    .GetMessageAssociations("ECommerce.BFF.API");</p>

<p>// Filter to specific event</p>
<p>var productAssocs = messageAssocs</p>
<p>    .Where(a => a.MessageType.Contains("ProductCreatedEvent"));</p>

<p>// Get typed associations for invocation</p>
<p>var typedAssocs = PerspectiveRegistrationExtensions</p>
<p>    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>("ECommerce.BFF.API");</p>

<p>// Now can invoke via delegates</p>
<p>foreach (var assoc in typedAssocs) {</p>
<p>    model = assoc.ApplyDelegate(model, evt);</p>
<p>}</p>
<p></code></pre></p>

<h2>API Reference</h2>

<h3>Method Signature</h3>

<strong>Namespace</strong>: <code>Whizbang.Core.Generated</code>

<pre><code class="language-csharp">public static IReadOnlyList<PerspectiveAssociationInfo<TModel, TEvent>>
<p>    GetPerspectiveAssociations<TModel, TEvent>(string serviceName)</p>
<p>    where TEvent : IEvent;</p>
<p></code></pre></p>

<h3>Parameters</h3>

<ul><li><strong>serviceName</strong>: Service name / assembly name (e.g., "ECommerce.BFF.API")</li>
</ul>
<h3>Type Parameters</h3>

<ul><li><strong>TModel</strong>: Model type maintained by the perspective</li>
<li><strong>TEvent</strong>: Event type handled by the perspective (must implement IEvent)</li>
</ul>
<h3>Return Value</h3>

<ul><li>Returns <code>IReadOnlyList<PerspectiveAssociationInfo<TModel, TEvent>></code></li>
<li>Returns empty list if no matching perspectives found</li>
<li>Never returns null</li>
</ul>
<h2>Best Practices</h2>

<ul><li><strong>Cache associations in hot paths</strong> - <code>GetPerspectiveAssociations</code> is fast but not free</li>
<li><strong>Use for generic perspective invocation</strong> - Ideal for frameworks and libraries</li>
<li><strong>Prefer over reflection</strong> - Delegates are much faster than <code>MethodInfo.Invoke</code></li>
<li><strong>Combine with MessageAssociation</strong> - Use MessageAssociation for discovery, PerspectiveAssociationInfo for invocation</li>
<li><strong>Handle empty results</strong> - Check if list is empty before invoking</li>
<li><strong>Use in AOT scenarios</strong> - Fully trim-safe and AOT-compatible</li>
<li><strong>Leverage compile-time type safety</strong> - Compiler enforces TModel and TEvent constraints</li>
</ul>
<h2>Common Pitfalls</h2>

<h3>❌ Forgetting to Check for Empty Results</h3>

<pre><code class="language-csharp">// ❌ WRONG: Assuming associations exist
<p>var associations = PerspectiveRegistrationExtensions</p>
<p>    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);</p>

<p>var assoc = associations.First(); // May throw if empty!</p>

<p>// ✅ CORRECT: Check for empty</p>
<p>var associations = PerspectiveRegistrationExtensions</p>
<p>    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);</p>

<p>if (!associations.Any()) {</p>
<p>    throw new InvalidOperationException("No perspectives found");</p>
<p>}</p>
<p></code></pre></p>

<h3>❌ Not Caching in Loops</h3>

<pre><code class="language-csharp">// ❌ WRONG: Getting associations in loop
<p>foreach (var evt in events) {</p>
<p>    var associations = PerspectiveRegistrationExtensions</p>
<p>        .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);</p>
<p>    // ... apply</p>
<p>}</p>

<p>// ✅ CORRECT: Get associations once</p>
<p>var associations = PerspectiveRegistrationExtensions</p>
<p>    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);</p>

<p>foreach (var evt in events) {</p>
<p>    foreach (var assoc in associations) {</p>
<p>        model = assoc.ApplyDelegate(model, evt);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>❌ Mixing Type Parameters</h3>

<pre><code class="language-csharp">// ❌ WRONG: Mismatched types
<p>var associations = PerspectiveRegistrationExtensions</p>
<p>    .GetPerspectiveAssociations<ProductModel, OrderCreatedEvent>(serviceName);</p>

<p>var productEvent = new ProductCreatedEvent();</p>
<p>var assoc = associations.First();</p>
<p>assoc.ApplyDelegate(model, productEvent); // Compile error!</p>

<p>// ✅ CORRECT: Matching types</p>
<p>var associations = PerspectiveRegistrationExtensions</p>
<p>    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);</p>

<p>var productEvent = new ProductCreatedEvent();</p>
<p>var assoc = associations.First();</p>
<p>assoc.ApplyDelegate(model, productEvent); // Works!</p>
<p></code></pre></p>

<h2>Performance Considerations</h2>

<h3>Delegate Invocation Cost</h3>

<pre><code class="language-csharp">// Delegate invocation: ~1-2ns per call (very fast)
<p>var model = assoc.ApplyDelegate(currentModel, evt);</p>

<p>// Compare to reflection: ~100-1000ns per call</p>
<p>// TypeMatcher is 50-500x faster than reflection!</p>
<p></code></pre></p>

<h3>Caching Strategy</h3>

<pre><code class="language-csharp">// For high-throughput scenarios, cache associations
<p>private readonly IReadOnlyList<PerspectiveAssociationInfo<ProductModel, ProductCreatedEvent>> _cached;</p>

<p>public MyClass(string serviceName) {</p>
<p>    _cached = PerspectiveRegistrationExtensions</p>
<p>        .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);</p>
<p>}</p>

<p>public ProductModel ApplyEvent(ProductModel model, ProductCreatedEvent evt) {</p>
<p>    foreach (var assoc in _cached) {</p>
<p>        model = assoc.ApplyDelegate(model, evt);</p>
<p>    }</p>
<p>    return model;</p>
<p>}</p>
<p></code></pre></p>

<h2>See Also</h2>

<ul><li><a href="/v1.0.0/core-concepts/perspectives">Perspectives</a> - Overview of perspective system</li>
<li><a href="/v1.0.0/core-concepts/perspectives/typed-associations">Typed Associations</a> - GetPerspectiveAssociations method details</li>
<li><a href="/v1.0.0/core-concepts/perspectives#message-associations">Message Associations</a> - String-based associations</li>
<li><a href="/v1.0.0/advanced-topics/aot-compatibility">AOT Compatibility</a> - Native AOT support</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-perspectives-multi-stream" class="doc-section">
  <h4>Multi-Stream Perspectives</h4>
  <p class="doc-path"><code>v1.0.0/core-concepts/perspectives/multi-stream</code></p>
  <p class="doc-description"><em>IGlobalPerspectiveFor pattern for aggregating events across multiple streams using partition keys - inspired by Marten's MultiStreamProjection</em></p>
  <div class="doc-content">

<h1>Multi-Stream Perspectives</h1>

<strong>Multi-stream perspectives</strong> (also called <strong>global perspectives</strong>) aggregate events from <strong>multiple streams</strong> based on a <strong>partition key</strong>. They enable read models that span across aggregates.

<h2>Core Concept</h2>

<h3>Single-Stream vs. Multi-Stream</h3>

<strong>Single-Stream Perspective</strong> (<code>IPerspectiveFor<TModel, TEvent></code>):
<ul><li>One stream → One model instance</li>
<li>Stream ID identifies the model</li>
<li>Example: <code>ProductPerspective</code> - one model per product stream</li>
</ul>
<strong>Multi-Stream Perspective</strong> (<code>IGlobalPerspectiveFor<TModel, TPartitionKey, TEvent></code>):
<ul><li>Many streams → One model instance (per partition key)</li>
<li>Partition key extracted from events identifies the model</li>
<li>Example: <code>CustomerStatisticsPerspective</code> - aggregates order events from many order streams into one customer model</li>
</ul>
<pre><code class="language-">Single-Stream (IPerspectiveFor):
<p>┌─────────────────┐</p>
<p>│  Order Stream 1 │ ──────> Order Summary Model 1</p>
<p>└─────────────────┘</p>
<p>┌─────────────────┐</p>
<p>│  Order Stream 2 │ ──────> Order Summary Model 2</p>
<p>└─────────────────┘</p>


<p>Multi-Stream (IGlobalPerspectiveFor):</p>
<p>┌─────────────────┐</p>
<p>│  Order Stream 1 │ ──┐</p>
<p>└─────────────────┘   │</p>
<p>┌─────────────────┐   │    Customer Statistics Model</p>
<p>│  Order Stream 2 │ ──┼──> (Partition Key: CustomerId)</p>
<p>└─────────────────┘   │</p>
<p>┌─────────────────┐   │</p>
<p>│  Order Stream 3 │ ──┘</p>
<p>└─────────────────┘</p>
<p></code></pre></p>

<hr>

<h2>IGlobalPerspectiveFor Interface</h2>

<pre><code class="language-csharp">/// <summary>
<p>/// Multi-stream perspective that handles a single event type with partition key extraction.</p>
<p>/// GetPartitionKey extracts the partition from events (like Marten's Identity method).</p>
<p>/// Apply methods must be pure functions: no I/O, no side effects, deterministic.</p>
<p>/// </summary></p>
<p>public interface IGlobalPerspectiveFor<TModel, TPartitionKey, TEvent1></p>
<p>  where TModel : class</p>
<p>  where TPartitionKey : notnull</p>
<p>  where TEvent1 : IEvent {</p>

<p>  /// <summary></p>
<p>  /// Extracts the partition key from an event to determine which model instance to update.</p>
<p>  /// MUST be a pure function: deterministic, no side effects.</p>
<p>  /// </summary></p>
<p>  TPartitionKey GetPartitionKey(TEvent1 @event);</p>

<p>  /// <summary></p>
<p>  /// Applies an event to the model and returns a new model.</p>
<p>  /// MUST be a pure function: no I/O, no side effects, deterministic.</p>
<p>  /// </summary></p>
<p>  TModel Apply(TModel currentData, TEvent1 @event);</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Methods</strong>:
<ul><li><code>GetPartitionKey()</code> - Extracts partition key from event (which model to update)</li>
<li><code>Apply()</code> - Pure function that applies event to model (same as single-stream)</li>
</ul>
<hr>

<h2>Basic Example: Customer Statistics</h2>

<h3>Scenario</h3>

<p>Aggregate order statistics per customer across all order streams.</p>

<h3>Events</h3>

<pre><code class="language-csharp">using Whizbang.Core;

<p>// Order created event (separate stream per order)</p>
<p>public record OrderCreatedEvent : IEvent {</p>
<p>  [StreamKey]</p>
<p>  public Guid OrderId { get; init; }        // Stream key (order stream)</p>

<p>  public Guid CustomerId { get; init; }     // Partition key (customer)</p>
<p>  public decimal Total { get; init; }</p>
<p>  public DateTime CreatedAt { get; init; }</p>
<p>}</p>

<p>// Order completed event</p>
<p>public record OrderCompletedEvent : IEvent {</p>
<p>  [StreamKey]</p>
<p>  public Guid OrderId { get; init; }        // Stream key</p>

<p>  public Guid CustomerId { get; init; }     // Partition key</p>
<p>  public DateTime CompletedAt { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h3>Read Model</h3>

<pre><code class="language-csharp">// Customer statistics model (one per customer)
<p>public record CustomerStatisticsDto {</p>
<p>  public Guid CustomerId { get; init; }           // Partition key</p>
<p>  public int TotalOrders { get; init; }</p>
<p>  public decimal TotalSpent { get; init; }</p>
<p>  public DateTime? LastOrderDate { get; init; }</p>
<p>  public DateTime? LastCompletedDate { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h3>Multi-Stream Perspective</h3>

<pre><code class="language-csharp">using Whizbang.Core.Perspectives;

<p>public class CustomerStatisticsPerspective :</p>
<p>  IGlobalPerspectiveFor<CustomerStatisticsDto, Guid, OrderCreatedEvent>,</p>
<p>  IGlobalPerspectiveFor<CustomerStatisticsDto, Guid, OrderCompletedEvent> {</p>

<p>  // Extract partition key from OrderCreatedEvent</p>
<p>  public Guid GetPartitionKey(OrderCreatedEvent @event) {</p>
<p>    return @event.CustomerId;  // Group by customer ID</p>
<p>  }</p>

<p>  // Extract partition key from OrderCompletedEvent</p>
<p>  public Guid GetPartitionKey(OrderCompletedEvent @event) {</p>
<p>    return @event.CustomerId;  // Group by customer ID</p>
<p>  }</p>

<p>  // Apply OrderCreatedEvent</p>
<p>  public CustomerStatisticsDto Apply(CustomerStatisticsDto currentData, OrderCreatedEvent @event) {</p>
<p>    return new CustomerStatisticsDto {</p>
<p>      CustomerId = @event.CustomerId,</p>
<p>      TotalOrders = (currentData?.TotalOrders ?? 0) + 1,</p>
<p>      TotalSpent = (currentData?.TotalSpent ?? 0) + @event.Total,</p>
<p>      LastOrderDate = @event.CreatedAt,</p>
<p>      LastCompletedDate = currentData?.LastCompletedDate</p>
<p>    };</p>
<p>  }</p>

<p>  // Apply OrderCompletedEvent</p>
<p>  public CustomerStatisticsDto Apply(CustomerStatisticsDto currentData, OrderCompletedEvent @event) {</p>
<p>    return new CustomerStatisticsDto {</p>
<p>      CustomerId = currentData.CustomerId,</p>
<p>      TotalOrders = currentData.TotalOrders,</p>
<p>      TotalSpent = currentData.TotalSpent,</p>
<p>      LastOrderDate = currentData.LastOrderDate,</p>
<p>      LastCompletedDate = @event.CompletedAt</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Result</strong>:
<ul><li>Events from <strong>many order streams</strong> (order-001, order-002, order-003)</li>
<li>All update the <strong>same customer model</strong> (customer-abc-123)</li>
<li>Partition key (<code>CustomerId</code>) groups events into customer-specific aggregates</li>
</ul>
<hr>

<h2>Partition Key Types</h2>

<h3>Guid Partition Key</h3>

<pre><code class="language-csharp">// Partition by customer ID
<p>public class CustomerActivityPerspective :</p>
<p>  IGlobalPerspectiveFor<CustomerActivityDto, Guid, OrderCreatedEvent> {</p>

<p>  public Guid GetPartitionKey(OrderCreatedEvent @event) {</p>
<p>    return @event.CustomerId;  // Guid partition key</p>
<p>  }</p>

<p>  public CustomerActivityDto Apply(CustomerActivityDto currentData, OrderCreatedEvent @event) {</p>
<p>    // ...</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>String Partition Key</h3>

<pre><code class="language-csharp">// Partition by product category
<p>public class CategorySalesPerspective :</p>
<p>  IGlobalPerspectiveFor<CategorySalesDto, string, ProductSoldEvent> {</p>

<p>  public string GetPartitionKey(ProductSoldEvent @event) {</p>
<p>    return @event.Category;  // String partition key (e.g., "Electronics", "Clothing")</p>
<p>  }</p>

<p>  public CategorySalesDto Apply(CategorySalesDto currentData, ProductSoldEvent @event) {</p>
<p>    return new CategorySalesDto {</p>
<p>      Category = @event.Category,</p>
<p>      TotalSales = (currentData?.TotalSales ?? 0) + @event.Quantity,</p>
<p>      Revenue = (currentData?.Revenue ?? 0) + @event.Price</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Composite Partition Key</h3>

<pre><code class="language-csharp">// Partition by tenant + customer
<p>public record TenantCustomerKey(Guid TenantId, Guid CustomerId);</p>

<p>public class TenantCustomerPerspective :</p>
<p>  IGlobalPerspectiveFor<CustomerDto, TenantCustomerKey, OrderCreatedEvent> {</p>

<p>  public TenantCustomerKey GetPartitionKey(OrderCreatedEvent @event) {</p>
<p>    return new TenantCustomerKey(@event.TenantId, @event.CustomerId);</p>
<p>  }</p>

<p>  public CustomerDto Apply(CustomerDto currentData, OrderCreatedEvent @event) {</p>
<p>    // ...</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Multiple Event Types</h2>

<p>Multi-stream perspectives can handle up to 3 event types (v1.0.0):</p>

<pre><code class="language-csharp">public class CustomerLifecyclePerspective :
<p>  IGlobalPerspectiveFor<CustomerDto, Guid, CustomerRegisteredEvent>,</p>
<p>  IGlobalPerspectiveFor<CustomerDto, Guid, OrderCreatedEvent>,</p>
<p>  IGlobalPerspectiveFor<CustomerDto, Guid, CustomerDeactivatedEvent> {</p>

<p>  // GetPartitionKey for each event type</p>
<p>  public Guid GetPartitionKey(CustomerRegisteredEvent @event) => @event.CustomerId;</p>
<p>  public Guid GetPartitionKey(OrderCreatedEvent @event) => @event.CustomerId;</p>
<p>  public Guid GetPartitionKey(CustomerDeactivatedEvent @event) => @event.CustomerId;</p>

<p>  // Apply for each event type</p>
<p>  public CustomerDto Apply(CustomerDto currentData, CustomerRegisteredEvent @event) {</p>
<p>    return new CustomerDto {</p>
<p>      CustomerId = @event.CustomerId,</p>
<p>      Name = @event.Name,</p>
<p>      Email = @event.Email,</p>
<p>      RegisteredAt = @event.RegisteredAt,</p>
<p>      TotalOrders = 0,</p>
<p>      Status = "Active"</p>
<p>    };</p>
<p>  }</p>

<p>  public CustomerDto Apply(CustomerDto currentData, OrderCreatedEvent @event) {</p>
<p>    return new CustomerDto {</p>
<p>      CustomerId = currentData.CustomerId,</p>
<p>      Name = currentData.Name,</p>
<p>      Email = currentData.Email,</p>
<p>      RegisteredAt = currentData.RegisteredAt,</p>
<p>      TotalOrders = currentData.TotalOrders + 1,</p>
<p>      Status = currentData.Status</p>
<p>    };</p>
<p>  }</p>

<p>  public CustomerDto Apply(CustomerDto currentData, CustomerDeactivatedEvent @event) {</p>
<p>    return new CustomerDto {</p>
<p>      CustomerId = currentData.CustomerId,</p>
<p>      Name = currentData.Name,</p>
<p>      Email = currentData.Email,</p>
<p>      RegisteredAt = currentData.RegisteredAt,</p>
<p>      TotalOrders = currentData.TotalOrders,</p>
<p>      Status = "Deactivated"</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Note</strong>: Maximum 3 event types per perspective in v1.0.0. For more events, create multiple perspectives targeting the same model.

<hr>

<h2>Comparison with Marten</h2>

<p>Whizbang's multi-stream perspectives are inspired by <a href="https://martendb.io/events/projections/multi-stream-projections.html">Marten's MultiStreamProjection</a>:</p>

<h3>Marten Pattern</h3>

<pre><code class="language-csharp">// Marten (C#)
<p>public class TripProjection : MultiStreamProjection<Trip, string> {</p>
<p>  public TripProjection() {</p>
<p>    // Identity method extracts partition key</p>
<p>    Identity<TripStarted>(x => x.TripId);</p>
<p>    Identity<TripEnded>(x => x.TripId);</p>
<p>  }</p>

<p>  public void Apply(Trip trip, TripStarted started) {</p>
<p>    trip.Id = started.TripId;</p>
<p>    trip.Started = started.StartedAt;</p>
<p>  }</p>

<p>  public void Apply(Trip trip, TripEnded ended) {</p>
<p>    trip.Ended = ended.EndedAt;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Whizbang Pattern</h3>

<pre><code class="language-csharp">// Whizbang (C#)
<p>public class TripPerspective :</p>
<p>  IGlobalPerspectiveFor<TripDto, string, TripStartedEvent>,</p>
<p>  IGlobalPerspectiveFor<TripDto, string, TripEndedEvent> {</p>

<p>  // GetPartitionKey is like Marten's Identity</p>
<p>  public string GetPartitionKey(TripStartedEvent @event) => @event.TripId;</p>
<p>  public string GetPartitionKey(TripEndedEvent @event) => @event.TripId;</p>

<p>  // Apply must be pure (return new instance)</p>
<p>  public TripDto Apply(TripDto currentData, TripStartedEvent @event) {</p>
<p>    return new TripDto {</p>
<p>      Id = @event.TripId,</p>
<p>      Started = @event.StartedAt,</p>
<p>      Ended = currentData?.Ended</p>
<p>    };</p>
<p>  }</p>

<p>  public TripDto Apply(TripDto currentData, TripEndedEvent @event) {</p>
<p>    return new TripDto {</p>
<p>      Id = currentData.Id,</p>
<p>      Started = currentData.Started,</p>
<p>      Ended = @event.EndedAt</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences</strong>:
<ul><li><strong>Whizbang</strong>: <code>GetPartitionKey()</code> method per event type (explicit)</li>
<li><strong>Marten</strong>: <code>Identity<T>()</code> configuration in constructor (implicit)</li>
<li><strong>Whizbang</strong>: <code>Apply()</code> returns new instance (pure function)</li>
<li><strong>Marten</strong>: <code>Apply()</code> mutates existing instance (imperative)</li>
</ul>
<strong>Philosophical Difference</strong>:
<ul><li><strong>Whizbang</strong>: Pure functional approach (immutability, determinism)</li>
<li><strong>Marten</strong>: Object-oriented approach (mutation, state changes)</li>
</ul>
<hr>

<h2>Use Cases</h2>

<h3>1. Customer Aggregates</h3>

<p>Aggregate customer data from multiple event streams:</p>

<pre><code class="language-csharp">// Events from different streams
<p>OrderCreatedEvent (order-001) → CustomerId: abc-123</p>
<p>PaymentReceivedEvent (payment-042) → CustomerId: abc-123</p>
<p>SupportTicketCreatedEvent (ticket-789) → CustomerId: abc-123</p>

<p>// All update same CustomerDto</p>
<p>CustomerDto (partition: abc-123) {</p>
<p>  TotalOrders: 15,</p>
<p>  TotalSpent: $1,250.00,</p>
<p>  OpenTickets: 2</p>
<p>}</p>
<p></code></pre></p>

<h3>2. Analytics & Reporting</h3>

<p>Pre-compute analytics across streams:</p>

<pre><code class="language-csharp">// Category sales perspective
<p>public class CategorySalesPerspective :</p>
<p>  IGlobalPerspectiveFor<CategorySalesDto, string, ProductSoldEvent> {</p>

<p>  public string GetPartitionKey(ProductSoldEvent @event) => @event.Category;</p>

<p>  public CategorySalesDto Apply(CategorySalesDto currentData, ProductSoldEvent @event) {</p>
<p>    return new CategorySalesDto {</p>
<p>      Category = @event.Category,</p>
<p>      UnitsSold = (currentData?.UnitsSold ?? 0) + @event.Quantity,</p>
<p>      Revenue = (currentData?.Revenue ?? 0) + (@event.Quantity * @event.UnitPrice),</p>
<p>      LastSaleDate = @event.SoldAt</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>3. Multi-Tenant Aggregates</h3>

<p>Partition by tenant for SaaS applications:</p>

<pre><code class="language-csharp">public class TenantUsagePerspective :
<p>  IGlobalPerspectiveFor<TenantUsageDto, Guid, ApiRequestEvent>,</p>
<p>  IGlobalPerspectiveFor<TenantUsageDto, Guid, DataStoredEvent> {</p>

<p>  public Guid GetPartitionKey(ApiRequestEvent @event) => @event.TenantId;</p>
<p>  public Guid GetPartitionKey(DataStoredEvent @event) => @event.TenantId;</p>

<p>  public TenantUsageDto Apply(TenantUsageDto currentData, ApiRequestEvent @event) {</p>
<p>    return new TenantUsageDto {</p>
<p>      TenantId = @event.TenantId,</p>
<p>      ApiRequests = (currentData?.ApiRequests ?? 0) + 1,</p>
<p>      StorageBytes = currentData?.StorageBytes ?? 0</p>
<p>    };</p>
<p>  }</p>

<p>  public TenantUsageDto Apply(TenantUsageDto currentData, DataStoredEvent @event) {</p>
<p>    return new TenantUsageDto {</p>
<p>      TenantId = @event.TenantId,</p>
<p>      ApiRequests = currentData?.ApiRequests ?? 0,</p>
<p>      StorageBytes = (currentData?.StorageBytes ?? 0) + @event.Bytes</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Pure Function Requirements</h2>

<strong>CRITICAL</strong>: Multi-stream perspectives must use <strong>pure functions</strong> in both <code>GetPartitionKey()</code> and <code>Apply()</code>.

<h3>GetPartitionKey - Pure Function</h3>

<pre><code class="language-csharp">// ✅ CORRECT: Pure function (deterministic, no side effects)
<p>public Guid GetPartitionKey(OrderCreatedEvent @event) {</p>
<p>  return @event.CustomerId;</p>
<p>}</p>

<p>// ❌ WRONG: Impure (calls external service)</p>
<p>public Guid GetPartitionKey(OrderCreatedEvent @event) {</p>
<p>  var customer = _customerService.GetCustomer(@event.CustomerId);  // I/O!</p>
<p>  return customer.Id;</p>
<p>}</p>

<p>// ❌ WRONG: Non-deterministic</p>
<p>public string GetPartitionKey(OrderCreatedEvent @event) {</p>
<p>  return Guid.NewGuid().ToString();  // Different result each time!</p>
<p>}</p>
<p></code></pre></p>

<h3>Apply - Pure Function</h3>

<pre><code class="language-csharp">// ✅ CORRECT: Pure function (returns new instance)
<p>public CustomerDto Apply(CustomerDto currentData, OrderCreatedEvent @event) {</p>
<p>  return new CustomerDto {</p>
<p>    CustomerId = @event.CustomerId,</p>
<p>    TotalOrders = (currentData?.TotalOrders ?? 0) + 1,</p>
<p>    TotalSpent = (currentData?.TotalSpent ?? 0) + @event.Total</p>
<p>  };</p>
<p>}</p>

<p>// ❌ WRONG: Mutates current data</p>
<p>public CustomerDto Apply(CustomerDto currentData, OrderCreatedEvent @event) {</p>
<p>  currentData.TotalOrders += 1;  // Mutation!</p>
<p>  return currentData;</p>
<p>}</p>

<p>// ❌ WRONG: Performs I/O</p>
<p>public CustomerDto Apply(CustomerDto currentData, OrderCreatedEvent @event) {</p>
<p>  var customer = await _db.GetCustomerAsync(@event.CustomerId);  // I/O!</p>
<p>  return new CustomerDto { /<em> ... </em>/ };</p>
<p>}</p>
<p></code></pre></p>

<strong>Why pure functions?</strong>
<ul><li><strong>Deterministic replay</strong>: Rebuilding read models always produces same result</li>
<li><strong>Event sourcing</strong>: Can replay events from any point</li>
<li><strong>Testing</strong>: No mocking required, simple unit tests</li>
</ul>
<hr>

<h2>Storage & Checkpointing</h2>

<h3>Storage</h3>

<p>Multi-stream perspectives use the same storage pattern as single-stream perspectives:</p>

<pre><code class="language-sql">-- Perspective table
<p>CREATE TABLE wh_per_customer_statistics (</p>
<p>  partition_key UUID PRIMARY KEY,      -- CustomerId (not stream_id!)</p>
<p>  data JSONB NOT NULL,                 -- CustomerStatisticsDto</p>
<p>  version BIGINT NOT NULL,</p>
<p>  updated_at TIMESTAMPTZ NOT NULL</p>
<p>);</p>
<p></code></pre></p>

<strong>Key Difference</strong>: <code>partition_key</code> instead of <code>stream_id</code>.

<h3>Checkpointing</h3>

<p>Multi-stream perspectives track checkpoints per partition:</p>

<pre><code class="language-sql">-- Perspective checkpoints
<p>INSERT INTO wh_perspective_checkpoints (</p>
<p>  partition_key,              -- CustomerId</p>
<p>  perspective_name,           -- "CustomerStatisticsPerspective"</p>
<p>  last_event_id,              -- UUIDv7 of last processed event</p>
<p>  last_sequence_number,</p>
<p>  status</p>
<p>) VALUES (</p>
<p>  'abc-123',</p>
<p>  'CustomerStatisticsPerspective',</p>
<p>  'event-uuid-789',</p>
<p>  42,</p>
<p>  'UpToDate'</p>
<p>);</p>
<p></code></pre></p>

<hr>

<h2>Testing Multi-Stream Perspectives</h2>

<h3>Unit Tests</h3>

<pre><code class="language-csharp">using TUnit.Assertions;
<p>using TUnit.Core;</p>

<p>public class CustomerStatisticsPerspectiveTests {</p>
<p>  [Test]</p>
<p>  public async Task GetPartitionKey_OrderCreatedEvent_ReturnsCustomerIdAsync() {</p>
<p>    // Arrange</p>
<p>    var perspective = new CustomerStatisticsPerspective();</p>
<p>    var @event = new OrderCreatedEvent {</p>
<p>      OrderId = Guid.NewGuid(),</p>
<p>      CustomerId = Guid.Parse("abc-123"),</p>
<p>      Total = 100m</p>
<p>    };</p>

<p>    // Act</p>
<p>    var partitionKey = perspective.GetPartitionKey(@event);</p>

<p>    // Assert</p>
<p>    await Assert.That(partitionKey).IsEqualTo(Guid.Parse("abc-123"));</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task Apply_OrderCreatedEvent_IncrementsCountersAsync() {</p>
<p>    // Arrange</p>
<p>    var perspective = new CustomerStatisticsPerspective();</p>
<p>    var currentData = new CustomerStatisticsDto {</p>
<p>      CustomerId = Guid.Parse("abc-123"),</p>
<p>      TotalOrders = 5,</p>
<p>      TotalSpent = 500m</p>
<p>    };</p>
<p>    var @event = new OrderCreatedEvent {</p>
<p>      CustomerId = Guid.Parse("abc-123"),</p>
<p>      Total = 100m,</p>
<p>      CreatedAt = DateTime.UtcNow</p>
<p>    };</p>

<p>    // Act</p>
<p>    var result = perspective.Apply(currentData, @event);</p>

<p>    // Assert</p>
<p>    await Assert.That(result.TotalOrders).IsEqualTo(6);</p>
<p>    await Assert.That(result.TotalSpent).IsEqualTo(600m);</p>
<p>    await Assert.That(currentData.TotalOrders).IsEqualTo(5);  // Not mutated!</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task Apply_MultipleEvents_SamePartition_AggregatesCorrectlyAsync() {</p>
<p>    // Arrange</p>
<p>    var perspective = new CustomerStatisticsPerspective();</p>
<p>    var emptyData = new CustomerStatisticsDto {</p>
<p>      CustomerId = Guid.Parse("abc-123")</p>
<p>    };</p>

<p>    var event1 = new OrderCreatedEvent {</p>
<p>      CustomerId = Guid.Parse("abc-123"),</p>
<p>      Total = 100m,</p>
<p>      CreatedAt = DateTime.UtcNow</p>
<p>    };</p>

<p>    var event2 = new OrderCreatedEvent {</p>
<p>      CustomerId = Guid.Parse("abc-123"),</p>
<p>      Total = 200m,</p>
<p>      CreatedAt = DateTime.UtcNow.AddMinutes(5)</p>
<p>    };</p>

<p>    // Act - apply events sequentially</p>
<p>    var afterEvent1 = perspective.Apply(emptyData, event1);</p>
<p>    var afterEvent2 = perspective.Apply(afterEvent1, event2);</p>

<p>    // Assert</p>
<p>    await Assert.That(afterEvent2.TotalOrders).IsEqualTo(2);</p>
<p>    await Assert.That(afterEvent2.TotalSpent).IsEqualTo(300m);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ Use <code>GetPartitionKey()</code> as pure function (deterministic)</li>
<li>✅ Use <code>Apply()</code> as pure function (no I/O, returns new instance)</li>
<li>✅ Partition by stable identifiers (CustomerId, TenantId, Category)</li>
<li>✅ Handle null <code>currentData</code> defensively (first event for partition)</li>
<li>✅ Use partition keys that make sense for your domain</li>
<li>✅ Test partition key extraction separately</li>
<li>✅ Test Apply logic independently</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Perform I/O in <code>GetPartitionKey()</code> or <code>Apply()</code></li>
<li>❌ Use non-deterministic partition keys (Guid.NewGuid(), DateTime.Now)</li>
<li>❌ Mutate <code>currentData</code> in <code>Apply()</code></li>
<li>❌ Partition by high-cardinality keys (RequestId, MessageId)</li>
<li>❌ Mix single-stream and multi-stream patterns (choose one)</li>
<li>❌ Forget to handle null <code>currentData</code> (first event case)</li>
</ul>
<hr>

<h2>Limitations (v1.0.0)</h2>

<ul><li><strong>Maximum 3 event types</strong> per multi-stream perspective</li>
<li><strong>Partition key must be notnull</strong> (<code>where TPartitionKey : notnull</code>)</li>
<li><strong>Model must be class</strong> (<code>where TModel : class</code>)</li>
<li><strong>No built-in UI for v1.0.0</strong> (manual perspective registration)</li>
</ul>
<strong>Workaround for >3 events</strong>: Create multiple perspectives targeting the same model type.

<hr>

<h2>Further Reading</h2>

<strong>Core Concepts</strong>:
<ul><li><a href="../perspectives.md">Perspectives</a> - Single-stream perspectives (IPerspectiveFor)</li>
<li><a href="../lenses.md">Lenses</a> - Query interfaces for read models</li>
<li><a href="../../attributes/streamkey.md">StreamKey Attribute</a> - Stream identification</li>
</ul>
<strong>Source Generators</strong>:
<ul><li><a href="../../source-generators/perspective-discovery.md">Perspective Discovery</a> - Auto-discovery and runner generation</li>
</ul>
<strong>Data Access</strong>:
<ul><li><a href="../../data/perspectives-storage.md">Perspective Storage</a> - Read model persistence</li>
<li><a href="../../data/event-store.md">Event Store</a> - Event sourcing foundation</li>
</ul>
<strong>Workers</strong>:
<ul><li><a href="../../workers/perspective-worker.md">Perspective Worker</a> - Checkpoint processing and runtime</li>
</ul>
<strong>External Resources</strong>:
<ul><li><a href="https://martendb.io/events/projections/multi-stream-projections.html">Marten MultiStreamProjection</a> - Inspiration for this pattern</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2025-12-22</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-perspectives-perspective-sync" class="doc-section">
  <h4>Perspective Synchronization</h4>
  <p class="doc-path"><code>v1.0.0/core-concepts/perspectives/perspective-sync</code></p>
  <p class="doc-description"><em>Read-your-writes consistency for perspectives - wait for perspective updates before querying to ensure handlers see their own changes</em></p>
  <div class="doc-content">

<h1>Perspective Synchronization</h1>

<strong>Perspective Synchronization</strong> enables <strong>read-your-writes consistency</strong> for perspectives. When a handler emits events, it can wait for perspectives to process those events before querying, ensuring the handler sees its own changes.

<h2>The Problem</h2>

<p>In event-sourced systems, perspective updates happen asynchronously via background workers. This creates a delay (typically 2-30 seconds) where perspectives aren't yet queryable:</p>

<pre><code class="language-">Handler A emits OrderCreatedEvent
<p>         │</p>
<p>         ▼</p>
<p>┌──────────────────────┐</p>
<p>│   Event Store        │  ◄── Event stored immediately</p>
<p>└──────────────────────┘</p>
<p>         │</p>
<p>         │ (2-30 second gap)</p>
<p>         ▼</p>
<p>┌──────────────────────┐</p>
<p>│   Perspective Worker │  ◄── Updates perspective async</p>
<p>└──────────────────────┘</p>
<p>         │</p>
<p>         ▼</p>
<p>Handler B queries OrderPerspective  ◄── May not see the order!</p>
<p></code></pre></p>

<strong>The solution</strong>: Wait for perspective synchronization before querying.

<hr>

<h2>Core Components</h2>

<h3>SyncFilter - Fluent Filter Builder</h3>

<p>Build synchronization filters with fluent AND/OR logic:</p>

<pre><code class="language-csharp">using Whizbang.Core.Perspectives.Sync;

<p>// Wait for all events in current scope</p>
<p>var options = SyncFilter.CurrentScope().Build();</p>

<p>// Wait for specific event types</p>
<p>var options = SyncFilter.ForEventTypes<OrderCreatedEvent>().Build();</p>

<p>// Wait for events on a specific stream</p>
<p>var options = SyncFilter.ForStream(orderId)</p>
<p>    .AndEventTypes<OrderCreatedEvent, OrderUpdatedEvent>()</p>
<p>    .Build();</p>

<p>// OR logic - wait for either event type</p>
<p>var options = SyncFilter.ForEventTypes<OrderCreatedEvent>()</p>
<p>    .OrEventTypes<OrderCancelledEvent>()</p>
<p>    .Build();</p>
<p></code></pre></p>

<h3>Database-Based Sync</h3>

<p>Perspective sync uses <strong>database queries</strong> to check if events have been processed. This works reliably across all deployment scenarios:</p>

<ul><li>Single instance deployments</li>
<li>Multi-instance/scaled deployments</li>
<li>Load-balanced environments</li>
<li>Blue-green deployments</li>
</ul>
<p>The sync inquiry is batched with regular work coordination calls via <code>process_work_batch</code>, making it efficient with no additional round-trips.</p>

<h3>Explicit EventId Tracking</h3>

<p>When events are emitted within a scope, the <code>IScopedEventTracker</code> immediately captures their EventIds. This enables <strong>explicit EventId tracking</strong> for sync operations:</p>

<pre><code class="language-">Handler emits OrderCreatedEvent
<p>         │</p>
<p>         ▼</p>
<p>┌──────────────────────┐</p>
<p>│ IScopedEventTracker  │  ◄── Captures EventId immediately</p>
<p>│ [eventId: abc123]    │</p>
<p>└──────────────────────┘</p>
<p>         │</p>
<p>         ▼</p>
<p>┌──────────────────────┐</p>
<p>│   Sync Inquiry       │  ◄── Sends ExpectedEventIds=[abc123]</p>
<p>│   to Database        │</p>
<p>└──────────────────────┘</p>
<p>         │</p>
<p>         ▼</p>
<p>┌──────────────────────┐</p>
<p>│   IsFullySynced      │  ◄── Checks: Are ALL expected events</p>
<p>│   Evaluation         │      in ProcessedEventIds?</p>
<p>└──────────────────────┘</p>
<p></code></pre></p>

<p>This prevents <strong>false positives</strong> when events are still in the outbox and haven't reached the perspective table yet. The sync awaiter compares explicit EventIds rather than just checking <code>PendingCount == 0</code>.</p>

<h4>Cross-Scope Sync with <code>[AwaitPerspectiveSync]</code></h4>

<p>When using <code>[AwaitPerspectiveSync]</code> attributes, the incoming event being processed was emitted in a <strong>different scope</strong> (the original command handler). The attribute handler automatically passes the incoming event's ID to <code>WaitForStreamAsync</code>:</p>

<pre><code class="language-">Scope A (Command Handler):              Scope B (Receptor):
<p>┌────────────────────────┐              ┌────────────────────────┐</p>
<p>│ emits OrderCreatedEvent│              │ [AwaitPerspectiveSync] │</p>
<p>│ EventId = abc123       │──────────────►│ handles OrderCreated   │</p>
<p>└────────────────────────┘              │ waits for abc123       │</p>
<p>                                        └────────────────────────┘</p>
<p>                                                   │</p>
<p>                                                   ▼</p>
<p>                                        ┌────────────────────────┐</p>
<p>                                        │ WaitForStreamAsync     │</p>
<p>                                        │ eventIdToAwait=abc123  │</p>
<p>                                        └────────────────────────┘</p>
<p></code></pre></p>

<p>This ensures the receptor waits for <strong>the specific event it's processing</strong>, not just any events on the stream. Without this, cross-scope sync would fail because:</p>
<ul><li>The receptor's scope tracker has no events (they were emitted elsewhere)</li>
<li>A stream-wide query would return <code>PendingCount = 0</code> (no rows in perspective table yet)</li>
<li><code>IsFullySynced</code> would incorrectly return <code>true</code></li>
</ul>
<h4>SyncInquiryResult Properties</h4>

<p>| Property | Description |</p>
<p>|----------|-------------|</p>
<p>| <code>PendingCount</code> | Number of events pending processing |</p>
<p>| <code>ProcessedCount</code> | Number of events already processed |</p>
<p>| <code>ProcessedEventIds</code> | Array of EventIds that have been processed |</p>
<p>| <code>ExpectedEventIds</code> | Array of EventIds we expect to be processed |</p>
<p>| <code>IsFullySynced</code> | True when ALL expected events are processed |</p>

<p>The <code>IsFullySynced</code> property evaluates:</p>
<ul><li>If <code>ExpectedEventIds</code> is set: All expected IDs must be in <code>ProcessedEventIds</code></li>
<li>Otherwise: Falls back to <code>PendingCount == 0</code> (stream-wide query)</li>
</ul>
<h3>PerspectiveSyncOptions</h3>

<p>Configuration for synchronization:</p>

<pre><code class="language-csharp">public sealed class PerspectiveSyncOptions {
<p>    // Filter tree (supports AND/OR combinations)</p>
<p>    public SyncFilterNode Filter { get; init; }</p>

<p>    // Timeout configuration</p>
<p>    public TimeSpan Timeout { get; init; } = TimeSpan.FromSeconds(5);</p>

<p>    // Debugger-aware timeout (prevents false timeouts when breakpointed)</p>
<p>    public bool DebuggerAwareTimeout { get; init; } = true;</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Usage Approaches</h2>

<h3>Approach 1: Sync-Aware Lens Queries</h3>

<p>Wrap lens queries with synchronization:</p>

<pre><code class="language-csharp">using Whizbang.Core.Lenses;
<p>using Whizbang.Core.Perspectives.Sync;</p>

<p>public class OrderHandler : IReceptor<OrderCreatedEvent> {</p>
<p>    private readonly ILensQuery<Order> _orderLens;</p>
<p>    private readonly IPerspectiveSyncAwaiter _syncAwaiter;</p>

<p>    public async ValueTask HandleAsync(OrderCreatedEvent evt, CancellationToken ct) {</p>
<p>        // Option 1: Fluent wrapper with generic type parameters (recommended)</p>
<p>        var syncQuery = _orderLens.WithSync<Order, OrderPerspective>(</p>
<p>            _syncAwaiter,</p>
<p>            SyncFilter.CurrentScope().Build());</p>

<p>        var order = await syncQuery.GetByIdAsync(evt.OrderId, ct);</p>

<p>        // Option 2: Direct extension method with generic type parameters</p>
<p>        var order = await _orderLens.GetByIdAsync<Order, OrderPerspective>(</p>
<p>            evt.OrderId,</p>
<p>            _syncAwaiter,</p>
<p>            SyncFilter.CurrentScope().Build(),</p>
<p>            ct);</p>

<p>        // Option 3: Using Type parameter (for dynamic scenarios)</p>
<p>        var order = await _orderLens.GetByIdAsync(</p>
<p>            evt.OrderId,</p>
<p>            _syncAwaiter,</p>
<p>            typeof(OrderPerspective),</p>
<p>            SyncFilter.CurrentScope().Build(),</p>
<p>            ct);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Approach 2: Lifecycle Attribute</h3>

<p>Declaratively wait before receptor execution:</p>

<pre><code class="language-csharp">using Whizbang.Core.Messaging;
<p>using Whizbang.Core.Perspectives.Sync;</p>

<p>// Wait for specific event types</p>
<p>[FireAt(LifecycleStage.PostDistributeInline)]</p>
<p>[AwaitPerspectiveSync(typeof(OrderPerspective),</p>
<p>    EventTypes = [typeof(OrderCreatedEvent)])]</p>
<p>public class NotificationHandler : IReceptor<OrderCreatedEvent> {</p>
<p>    private readonly ILensQuery<Order> _orderLens;</p>

<p>    public async ValueTask HandleAsync(OrderCreatedEvent evt, CancellationToken ct) {</p>
<p>        // Perspective is guaranteed caught up due to attribute</p>
<p>        var order = await _orderLens.GetByIdAsync(evt.OrderId, ct);</p>
<p>        await _notifications.SendOrderConfirmation(order.Data);</p>
<p>    }</p>
<p>}</p>

<p>// Wait for ALL events the perspective handles (auto-discovered)</p>
<p>[FireAt(LifecycleStage.PostDistributeInline)]</p>
<p>[AwaitPerspectiveSync(typeof(OrderPerspective))]</p>
<p>public class FullSyncHandler : IReceptor<OrderCreatedEvent> {</p>
<p>    // Handler code</p>
<p>}</p>
<p></code></pre></p>

<h3>Approach 3: Explicit Awaiter</h3>

<p>Maximum control over synchronization:</p>

<pre><code class="language-csharp">using Whizbang.Core.Perspectives.Sync;

<p>public class ReconciliationHandler : IReceptor<ReconcileOrdersCommand> {</p>
<p>    private readonly IPerspectiveSyncAwaiter _syncAwaiter;</p>
<p>    private readonly ILensQuery<Order> _orderLens;</p>

<p>    public async ValueTask HandleAsync(ReconcileOrdersCommand cmd, CancellationToken ct) {</p>
<p>        var result = await _syncAwaiter.WaitAsync(</p>
<p>            typeof(OrderPerspective),</p>
<p>            SyncFilter.ForStream(cmd.OrderId)</p>
<p>                .AndEventTypes<OrderCreatedEvent>()</p>
<p>                .WithTimeout(TimeSpan.FromSeconds(10)),</p>
<p>            ct);</p>

<p>        switch (result.Outcome) {</p>
<p>            case SyncOutcome.Synced:</p>
<p>                _logger.LogInformation("Synced {Count} events in {Elapsed}ms",</p>
<p>                    result.EventsAwaited, result.ElapsedTime.TotalMilliseconds);</p>
<p>                break;</p>
<p>            case SyncOutcome.TimedOut:</p>
<p>                _logger.LogWarning("Sync timed out, proceeding with eventual consistency");</p>
<p>                break;</p>
<p>            case SyncOutcome.NoPendingEvents:</p>
<p>                _logger.LogDebug("No pending events matched filter");</p>
<p>                break;</p>
<p>        }</p>

<p>        var order = await _orderLens.GetByIdAsync(cmd.OrderId, ct);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>API Response Consistency</h2>

<p>Ensure API responses include just-created data:</p>

<pre><code class="language-csharp">[HttpPost]
<p>public async Task<IActionResult> CreateOrder(CreateOrderRequest request) {</p>
<p>    var orderId = await _dispatcher.SendAsync(new CreateOrderCommand {</p>
<p>        CustomerId = request.CustomerId,</p>
<p>        Items = request.Items</p>
<p>    });</p>

<p>    // Wait for all events emitted in this request (using generic type parameters)</p>
<p>    var order = await _orderLens.GetByIdAsync<Order, OrderPerspective>(</p>
<p>        orderId,</p>
<p>        _syncAwaiter,</p>
<p>        SyncFilter.CurrentScope().Build(),</p>
<p>        cancellationToken);</p>

<p>    return Ok(order);</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Complex Filter Examples</h2>

<h3>AND Logic</h3>

<p>Wait for multiple conditions:</p>

<pre><code class="language-csharp">// Stream AND specific event types
<p>var options = SyncFilter.ForStream(orderId)</p>
<p>    .AndEventTypes<OrderCreatedEvent, PaymentProcessedEvent>()</p>
<p>    .Build();</p>

<p>// Current scope AND event types</p>
<p>var options = SyncFilter.CurrentScope()</p>
<p>    .AndEventTypes<OrderCreatedEvent>()</p>
<p>    .Build();</p>
<p></code></pre></p>

<h3>OR Logic</h3>

<p>Wait for any matching condition:</p>

<pre><code class="language-csharp">// Either order created OR order cancelled
<p>var options = SyncFilter.ForEventTypes<OrderCreatedEvent>()</p>
<p>    .OrEventTypes<OrderCancelledEvent>()</p>
<p>    .Build();</p>
<p></code></pre></p>

<h3>Combined AND/OR</h3>

<pre><code class="language-csharp">// (OrderCreated AND PaymentProcessed) OR OrderCancelled
<p>var options = SyncFilter.ForStream(orderId)</p>
<p>    .AndEventTypes<OrderCreatedEvent>()</p>
<p>    .And(SyncFilter.ForEventTypes<PaymentProcessedEvent>())</p>
<p>    .Or(SyncFilter.ForEventTypes<OrderCancelledEvent>())</p>
<p>    .WithTimeout(TimeSpan.FromSeconds(10));</p>
<p></code></pre></p>

<hr>

<h2>Debugger-Aware Timeout</h2>

<p>By default, synchronization uses <strong>debugger-aware timeouts</strong>. When you hit a breakpoint:</p>

<ul><li><strong>Wall clock time</strong> continues</li>
<li><strong>Active time</strong> pauses</li>
<li><strong>No false timeouts</strong> during debugging</li>
</ul>
<p>This is controlled by <code>DebuggerAwareTimeout</code>:</p>

<pre><code class="language-csharp">var options = SyncFilter.CurrentScope()
<p>    .WithTimeout(TimeSpan.FromSeconds(5))</p>
<p>    .Build();</p>

<p>// options.DebuggerAwareTimeout is true by default</p>
<p></code></pre></p>

<p>The system uses CPU time sampling to detect when execution is frozen at a breakpoint.</p>

<hr>

<h2>Sync Outcomes</h2>

<p>| Outcome | Description |</p>
<p>|---------|-------------|</p>
<p>| <code>Synced</code> | All matching events have been processed |</p>
<p>| <code>TimedOut</code> | Timeout reached before synchronization |</p>
<p>| <code>NoPendingEvents</code> | No events matched the filter |</p>

<hr>

<h2>Best Practices</h2>

<h3>Do: Use CurrentScope for Same-Request Consistency</h3>

<pre><code class="language-csharp">// Handler chain within same HTTP request - tracks all emitted events
<p>SyncFilter.CurrentScope()</p>
<p></code></pre></p>

<h3>Do: Use ForStream for Specific Stream Consistency</h3>

<pre><code class="language-csharp">// Wait for events on a specific stream
<p>SyncFilter.ForStream(orderId)</p>
<p></code></pre></p>

<h3>Don't: Over-synchronize</h3>

<pre><code class="language-csharp">// Avoid: Waiting for all events when you only need specific ones
<p>SyncFilter.All()  // Too broad</p>

<p>// Better: Wait only for relevant event types</p>
<p>SyncFilter.ForEventTypes<OrderCreatedEvent>()</p>
<p></code></pre></p>

<h3>Do: Set Appropriate Timeouts</h3>

<pre><code class="language-csharp">// Short timeout for real-time responses
<p>.WithTimeout(TimeSpan.FromMilliseconds(500))</p>

<p>// Longer timeout for background processing</p>
<p>.WithTimeout(TimeSpan.FromSeconds(30))</p>
<p></code></pre></p>

<hr>

<h2>Industry Precedent</h2>

<p>This pattern is well-established:</p>

<ul><li><strong>Kafka</strong>: <code>acks=all</code> + consumer offset tracking</li>
<li><strong>DynamoDB</strong>: <code>ConsistentRead</code> option on queries</li>
<li><strong>Cosmos DB</strong>: <code>Session</code> and <code>BoundedStaleness</code> consistency levels</li>
<li><strong>PostgreSQL</strong>: <code>synchronous_commit</code> + replication lag monitoring</li>
<li><strong>Marten</strong>: <code>IDocumentSession.Query<T>().WaitForNonStaleResults()</code></li>
</ul>
<p>The key insight is tracking "what did I emit" vs "what has been processed" and bridging that gap on-demand.</p>

<hr>

<h2>Related</h2>

<ul><li><strong>Source Code</strong>: <a href="../../../code/Whizbang.Core/Perspectives/Sync/SyncFilter.cs">SyncFilter.cs</a></li>
<li><strong>Tests</strong>: <a href="../../../tests/Whizbang.Core.Tests/Perspectives/Sync/">SyncFilterBuilderTests.cs</a></li>
<li><strong>Concepts</strong>: <a href="../perspectives.md">Perspectives</a> | <a href="../lenses.md">Lenses</a></li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-core-concepts-perspectives-typed-associations" class="doc-section">
  <h4>typed associations</h4>
  <p class="doc-path"><code>v1.0.0/core-concepts/perspectives/typed-associations</code></p>
  <div class="doc-content">
<h1>GetPerspectiveAssociations: Strongly-Typed Perspective Queries</h1>

<p>GetPerspectiveAssociations is a source-generated method that returns strongly-typed perspective associations filtered by model and event type. It provides compile-time type safety and AOT-compatible delegate access to perspective Apply methods.</p>

<h2>Overview</h2>

<strong>GetPerspectiveAssociations&lt;TModel, TEvent&gt;</strong> provides:
<ul><li>✅ Type-filtered perspective associations</li>
<li>✅ Compile-time type checking with generic constraints</li>
<li>✅ AOT-compatible delegates (zero reflection)</li>
<li>✅ Empty array for non-matching types</li>
<li>✅ Source-generated for all discovered perspectives</li>
</ul>
<h2>Quick Start</h2>

<h3>Basic Usage</h3>

<pre><code class="language-csharp">using Whizbang.Core.Generated;

<p>// Get all perspectives handling ProductCreatedEvent for ProductModel</p>
<p>var associations = PerspectiveRegistrationExtensions</p>
<p>    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>("ECommerce.BFF.API");</p>

<p>// Iterate and invoke</p>
<p>var model = new ProductModel();</p>
<p>var evt = new ProductCreatedEvent { ProductId = "prod-123" };</p>

<p>foreach (var assoc in associations) {</p>
<p>    Console.WriteLine($"Applying: {assoc.TargetName}");</p>
<p>    model = assoc.ApplyDelegate(model, evt);</p>
<p>}</p>

<p>Console.WriteLine($"Final model: {model}");</p>
<p></code></pre></p>

<h3>Type Safety</h3>

<pre><code class="language-csharp">// Compile-time type safety ensures matching types
<p>var associations = PerspectiveRegistrationExtensions</p>
<p>    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);</p>

<p>// Compiler enforces correct types</p>
<p>var productModel = new ProductModel();</p>
<p>var productEvent = new ProductCreatedEvent();</p>

<p>foreach (var assoc in associations) {</p>
<p>    // ✅ Types match - compiles</p>
<p>    productModel = assoc.ApplyDelegate(productModel, productEvent);</p>
<p>}</p>

<p>// ❌ Won't compile - type mismatch</p>
<p>var orderEvent = new OrderCreatedEvent();</p>
<p>productModel = assoc.ApplyDelegate(productModel, orderEvent); // Compiler error!</p>
<p></code></pre></p>

<h2>Method Signature</h2>

<h3>Declaration</h3>

<pre><code class="language-csharp">namespace Whizbang.Core.Generated;

<p>public static class PerspectiveRegistrationExtensions {</p>
<p>    /// <summary></p>
<p>    /// Gets strongly-typed perspective associations with AOT-compatible delegates.</p>
<p>    /// Returns associations only for the specified TModel and TEvent types.</p>
<p>    /// Uses compile-time type checking - no reflection.</p>
<p>    /// </summary></p>
<p>    /// <typeparam name="TModel">The model type to filter by</typeparam></p>
<p>    /// <typeparam name="TEvent">The event type to filter by</typeparam></p>
<p>    /// <param name="serviceName">The service name (assembly name)</param></p>
<p>    /// <returns>Read-only list of typed perspective associations with delegates</returns></p>
<p>    public static IReadOnlyList<PerspectiveAssociationInfo<TModel, TEvent>></p>
<p>        GetPerspectiveAssociations<TModel, TEvent>(string serviceName)</p>
<p>        where TEvent : IEvent;</p>
<p>}</p>
<p></code></pre></p>

<h3>Parameters</h3>

<ul><li><strong>serviceName</strong>: Service name / assembly name (e.g., "ECommerce.BFF.API")</li>
</ul>
<h3>Type Parameters</h3>

<ul><li><strong>TModel</strong>: Model type maintained by perspectives</li>
</ul><p>  - No constraints (can be any type)</p>
<p>  - Must match perspective's <code>IPerspectiveFor<TModel, TEvent></code> first type argument</p>

<ul><li><strong>TEvent</strong>: Event type handled by perspectives</li>
</ul><p>  - Must implement <code>IEvent</code> interface</p>
<p>  - Must match perspective's <code>IPerspectiveFor<TModel, TEvent></code> second type argument</p>

<h3>Return Value</h3>

<ul><li>Returns <code>IReadOnlyList<PerspectiveAssociationInfo<TModel, TEvent>></code></li>
<li>Returns empty list if no perspectives match the specified types</li>
<li>Never returns null</li>
<li>List is immutable (read-only)</li>
</ul>
<h2>Generated Code Structure</h2>

<h3>How It Works</h3>

<p>The source generator produces compile-time type checks for each perspective:</p>

<pre><code class="language-csharp">// Generated method (simplified example)
<p>public static IReadOnlyList<PerspectiveAssociationInfo<TModel, TEvent>></p>
<p>    GetPerspectiveAssociations<TModel, TEvent>(string serviceName)</p>
<p>    where TEvent : IEvent {</p>

<p>    // ProductPerspective: IPerspectiveFor<ProductModel, ProductCreatedEvent></p>
<p>    if (typeof(TModel) == typeof(ProductModel) &&</p>
<p>        typeof(TEvent) == typeof(ProductCreatedEvent)) {</p>

<p>        return new[] {</p>
<p>            new PerspectiveAssociationInfo<TModel, TEvent>(</p>
<p>                "ECommerce.Contracts.Events.ProductCreatedEvent",</p>
<p>                "ProductPerspective",</p>
<p>                "ECommerce.BFF.API",</p>
<p>                (model, evt) => {</p>
<p>                    var perspective = new ProductPerspective();</p>
<p>                    var typedModel = (ProductModel)((object)model);</p>
<p>                    var typedEvent = (ProductCreatedEvent)((object)evt);</p>
<p>                    var result = perspective.Apply(typedModel, typedEvent);</p>
<p>                    return (TModel)((object)result);</p>
<p>                }</p>
<p>            )</p>
<p>        };</p>
<p>    }</p>

<p>    // OrderPerspective: IPerspectiveFor<OrderModel, OrderCreatedEvent></p>
<p>    if (typeof(TModel) == typeof(OrderModel) &&</p>
<p>        typeof(TEvent) == typeof(OrderCreatedEvent)) {</p>

<p>        return new[] {</p>
<p>            new PerspectiveAssociationInfo<TModel, TEvent>(</p>
<p>                "ECommerce.Contracts.Events.OrderCreatedEvent",</p>
<p>                "OrderPerspective",</p>
<p>                "ECommerce.BFF.API",</p>
<p>                (model, evt) => {</p>
<p>                    var perspective = new OrderPerspective();</p>
<p>                    var typedModel = (OrderModel)((object)model);</p>
<p>                    var typedEvent = (OrderCreatedEvent)((object)evt);</p>
<p>                    var result = perspective.Apply(typedModel, typedEvent);</p>
<p>                    return (TModel)((object)result);</p>
<p>                }</p>
<p>            )</p>
<p>        };</p>
<p>    }</p>

<p>    // No match - return empty</p>
<p>    return Array.Empty<PerspectiveAssociationInfo<TModel, TEvent>>();</p>
<p>}</p>
<p></code></pre></p>

<h3>AOT Compatibility</h3>

<p>Key features ensuring AOT compatibility:</p>

<ul><li><strong>Compile-time type checking</strong>: Uses <code>typeof()</code> comparisons</li>
<li><strong>Direct instantiation</strong>: Uses <code>new</code> keyword (no <code>Activator.CreateInstance</code>)</li>
<li><strong>Direct method calls</strong>: No <code>MethodInfo.Invoke</code></li>
<li><strong>No reflection</strong>: All types known at compile time</li>
<li><strong>Trim-safe</strong>: No dynamic type loading</li>
</ul>
<h2>Common Scenarios</h2>

<h3>Scenario 1: Generic Event Processor</h3>

<strong>When</strong>: Building a generic event processing pipeline

<pre><code class="language-csharp">public class EventProcessor {
<p>    private readonly string _serviceName;</p>

<p>    public EventProcessor(string serviceName) {</p>
<p>        _serviceName = serviceName;</p>
<p>    }</p>

<p>    public TModel ProcessEvent<TModel, TEvent>(TModel model, TEvent evt)</p>
<p>        where TEvent : IEvent {</p>

<p>        // Get associations for this model/event combination</p>
<p>        var associations = PerspectiveRegistrationExtensions</p>
<p>            .GetPerspectiveAssociations<TModel, TEvent>(_serviceName);</p>

<p>        if (!associations.Any()) {</p>
<p>            throw new InvalidOperationException(</p>
<p>                $"No perspectives found for {typeof(TModel).Name} + {typeof(TEvent).Name}"</p>
<p>            );</p>
<p>        }</p>

<p>        // Apply all matching perspectives</p>
<p>        foreach (var assoc in associations) {</p>
<p>            model = assoc.ApplyDelegate(model, evt);</p>
<p>        }</p>

<p>        return model;</p>
<p>    }</p>
<p>}</p>

<p>// Usage</p>
<p>var processor = new EventProcessor("ECommerce.BFF.API");</p>
<p>var updatedProduct = processor.ProcessEvent(productModel, productCreatedEvent);</p>
<p>var updatedOrder = processor.ProcessEvent(orderModel, orderCreatedEvent);</p>
<p></code></pre></p>

<h3>Scenario 2: Event Replay Engine</h3>

<strong>When</strong>: Replaying historical events to rebuild state

<pre><code class="language-csharp">public class EventReplayEngine {
<p>    public async Task<TModel> ReplayAsync<TModel, TEvent>(</p>
<p>        TModel initialModel,</p>
<p>        IAsyncEnumerable<TEvent> events,</p>
<p>        string serviceName)</p>
<p>        where TEvent : IEvent {</p>

<p>        // Get associations once (before loop)</p>
<p>        var associations = PerspectiveRegistrationExtensions</p>
<p>            .GetPerspectiveAssociations<TModel, TEvent>(serviceName);</p>

<p>        if (!associations.Any()) {</p>
<p>            return initialModel; // No perspectives, return unchanged</p>
<p>        }</p>

<p>        var model = initialModel;</p>

<p>        // Replay each event</p>
<p>        await foreach (var evt in events) {</p>
<p>            foreach (var assoc in associations) {</p>
<p>                model = assoc.ApplyDelegate(model, evt);</p>
<p>            }</p>
<p>        }</p>

<p>        return model;</p>
<p>    }</p>
<p>}</p>

<p>// Usage</p>
<p>var replayEngine = new EventReplayEngine();</p>
<p>var events = LoadHistoricalEvents();</p>
<p>var currentState = await replayEngine.ReplayAsync(</p>
<p>    new ProductModel(),</p>
<p>    events,</p>
<p>    "ECommerce.BFF.API"</p>
<p>);</p>
<p></code></pre></p>

<h3>Scenario 3: Multi-Perspective Testing</h3>

<strong>When</strong>: Testing that all perspectives handle an event correctly

<pre><code class="language-csharp">[Test]
<p>public async Task AllPerspectives_HandleProductCreatedEvent_CorrectlyAsync() {</p>
<p>    // Arrange</p>
<p>    var associations = PerspectiveRegistrationExtensions</p>
<p>        .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>("ECommerce.BFF.API");</p>

<p>    var model = new ProductModel { ProductCount = 0 };</p>
<p>    var evt = new ProductCreatedEvent { ProductId = "prod-123" };</p>

<p>    // Act & Assert - test each perspective</p>
<p>    foreach (var assoc in associations) {</p>
<p>        Console.WriteLine($"Testing perspective: {assoc.TargetName}");</p>

<p>        var result = assoc.ApplyDelegate(model, evt);</p>

<p>        // Verify perspective applied changes</p>
<p>        await Assert.That(result).IsNotEqualTo(model);</p>
<p>        await Assert.That(result.ProductCount).IsGreaterThan(model.ProductCount);</p>

<p>        model = result; // Update for next perspective</p>
<p>    }</p>

<p>    // Final assertion</p>
<p>    await Assert.That(model.ProductCount).IsGreaterThan(0);</p>
<p>}</p>
<p></code></pre></p>

<h3>Scenario 4: Conditional Perspective Application</h3>

<strong>When</strong>: Applying perspectives based on runtime conditions

<pre><code class="language-csharp">public class ConditionalPerspectiveApplier {
<p>    public TModel ApplyWithFilter<TModel, TEvent>(</p>
<p>        TModel model,</p>
<p>        TEvent evt,</p>
<p>        string serviceName,</p>
<p>        Func<PerspectiveAssociationInfo<TModel, TEvent>, bool> filter)</p>
<p>        where TEvent : IEvent {</p>

<p>        var associations = PerspectiveRegistrationExtensions</p>
<p>            .GetPerspectiveAssociations<TModel, TEvent>(serviceName);</p>

<p>        // Apply only perspectives matching filter</p>
<p>        foreach (var assoc in associations.Where(filter)) {</p>
<p>            model = assoc.ApplyDelegate(model, evt);</p>
<p>        }</p>

<p>        return model;</p>
<p>    }</p>
<p>}</p>

<p>// Usage: Apply only specific perspectives</p>
<p>var applier = new ConditionalPerspectiveApplier();</p>
<p>var filtered = applier.ApplyWithFilter(</p>
<p>    productModel,</p>
<p>    productEvent,</p>
<p>    serviceName,</p>
<p>    assoc => assoc.TargetName.Contains("Inventory") // Only inventory perspectives</p>
<p>);</p>
<p></code></pre></p>

<h3>Scenario 5: Performance Monitoring</h3>

<strong>When</strong>: Monitoring perspective performance

<pre><code class="language-csharp">public class MonitoredPerspectiveApplier {
<p>    private readonly ILogger _logger;</p>

<p>    public TModel ApplyWithMonitoring<TModel, TEvent>(</p>
<p>        TModel model,</p>
<p>        TEvent evt,</p>
<p>        string serviceName)</p>
<p>        where TEvent : IEvent {</p>

<p>        var associations = PerspectiveRegistrationExtensions</p>
<p>            .GetPerspectiveAssociations<TModel, TEvent>(serviceName);</p>

<p>        foreach (var assoc in associations) {</p>
<p>            var sw = Stopwatch.StartNew();</p>

<p>            model = assoc.ApplyDelegate(model, evt);</p>

<p>            sw.Stop();</p>
<p>            _logger.LogDebug(</p>
<p>                "Perspective {PerspectiveName} took {ElapsedMs}ms",</p>
<p>                assoc.TargetName,</p>
<p>                sw.ElapsedMilliseconds</p>
<p>            );</p>
<p>        }</p>

<p>        return model;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Type Filtering Behavior</h2>

<h3>Exact Type Matching</h3>

<p>GetPerspectiveAssociations uses exact type matching (not assignable types):</p>

<pre><code class="language-csharp">// Perspective definition
<p>public class ProductPerspective : IPerspectiveFor<ProductModel, ProductCreatedEvent> {</p>
<p>    public ProductModel Apply(ProductModel model, ProductCreatedEvent evt) {</p>
<p>        // ...</p>
<p>    }</p>
<p>}</p>

<p>// ✅ Exact match - returns association</p>
<p>var associations1 = PerspectiveRegistrationExtensions</p>
<p>    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);</p>
<p>// Returns: [ProductPerspective]</p>

<p>// ❌ Base class - no match</p>
<p>var associations2 = PerspectiveRegistrationExtensions</p>
<p>    .GetPerspectiveAssociations<BaseModel, ProductCreatedEvent>(serviceName);</p>
<p>// Returns: [] (empty)</p>

<p>// ❌ Interface - no match</p>
<p>var associations3 = PerspectiveRegistrationExtensions</p>
<p>    .GetPerspectiveAssociations<IModel, ProductCreatedEvent>(serviceName);</p>
<p>// Returns: [] (empty)</p>
<p></code></pre></p>

<h3>Multiple Perspectives</h3>

<p>If multiple perspectives handle the same model/event combination, all are returned:</p>

<pre><code class="language-csharp">// Two perspectives handling ProductModel + ProductCreatedEvent
<p>public class InventoryPerspective : IPerspectiveFor<ProductModel, ProductCreatedEvent> { }</p>
<p>public class CatalogPerspective : IPerspectiveFor<ProductModel, ProductCreatedEvent> { }</p>

<p>var associations = PerspectiveRegistrationExtensions</p>
<p>    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);</p>

<p>// Returns: [InventoryPerspective, CatalogPerspective]</p>
<p>Console.WriteLine($"Found {associations.Count} perspectives");</p>

<p>// Apply both</p>
<p>foreach (var assoc in associations) {</p>
<p>    model = assoc.ApplyDelegate(model, evt);</p>
<p>}</p>
<p></code></pre></p>

<h2>Performance Considerations</h2>

<h3>Caching Associations</h3>

<pre><code class="language-csharp">// ❌ WRONG: Calling in loop
<p>foreach (var evt in events) {</p>
<p>    var associations = PerspectiveRegistrationExtensions</p>
<p>        .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);</p>
<p>    // Unnecessary overhead!</p>
<p>}</p>

<p>// ✅ CORRECT: Cache outside loop</p>
<p>var associations = PerspectiveRegistrationExtensions</p>
<p>    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);</p>

<p>foreach (var evt in events) {</p>
<p>    foreach (var assoc in associations) {</p>
<p>        model = assoc.ApplyDelegate(model, evt);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Compile-Time Optimization</h3>

<p>The method uses compile-time type checks, so the JIT compiler can optimize aggressively:</p>

<pre><code class="language-csharp">// JIT can inline typeof() checks
<p>// Result: Very fast (~1-2ns per call once JIT'd)</p>
<p>var associations = PerspectiveRegistrationExtensions</p>
<p>    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);</p>
<p></code></pre></p>

<h3>Delegate Invocation Cost</h3>

<pre><code class="language-csharp">// Delegate invocation is extremely fast
<p>// Approximately 1-2ns per invocation (similar to virtual method call)</p>
<p>var result = assoc.ApplyDelegate(model, evt);</p>

<p>// Compare to reflection: ~100-1000ns per call</p>
<p>// Delegates are 50-500x faster!</p>
<p></code></pre></p>

<h2>Integration with Message Associations</h2>

<h3>Complementary APIs</h3>

<pre><code class="language-csharp">// 1. Discovery with MessageAssociation (string-based)
<p>var allAssociations = PerspectiveRegistrationExtensions</p>
<p>    .GetMessageAssociations(serviceName);</p>

<p>var productEvents = allAssociations</p>
<p>    .Where(a => a.TargetName == "ProductPerspective")</p>
<p>    .Select(a => a.MessageType);</p>

<p>Console.WriteLine($"ProductPerspective handles: {string.Join(", ", productEvents)}");</p>

<p>// 2. Invocation with GetPerspectiveAssociations (typed)</p>
<p>var typedAssociations = PerspectiveRegistrationExtensions</p>
<p>    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);</p>

<p>foreach (var assoc in typedAssociations) {</p>
<p>    model = assoc.ApplyDelegate(model, evt);</p>
<p>}</p>
<p></code></pre></p>

<h3>Workflow</h3>

<ul><li><strong>Discovery</strong>: Use <code>GetMessageAssociations()</code> to find available perspectives</li>
<li><strong>Filtering</strong>: Use fuzzy matching and queries to filter</li>
<li><strong>Invocation</strong>: Use <code>GetPerspectiveAssociations<TModel, TEvent>()</code> to invoke</li>
</ul>
<h2>API Reference</h2>

<h3>Method Details</h3>

<strong>Namespace</strong>: <code>Whizbang.Core.Generated</code>

<strong>Class</strong>: <code>PerspectiveRegistrationExtensions</code>

<strong>Method</strong>: <code>GetPerspectiveAssociations<TModel, TEvent></code>

<h3>Parameters</h3>

<p>| Parameter | Type | Description |</p>
<p>|-----------|------|-------------|</p>
<p>| <code>serviceName</code> | <code>string</code> | Service name / assembly name |</p>

<h3>Type Parameters</h3>

<p>| Parameter | Constraints | Description |</p>
<p>|-----------|-------------|-------------|</p>
<p>| <code>TModel</code> | None | Model type maintained by perspectives |</p>
<p>| <code>TEvent</code> | <code>where TEvent : IEvent</code> | Event type handled by perspectives |</p>

<h3>Return Value</h3>

<p>| Type | Description |</p>
<p>|------|-------------|</p>
<p>| <code>IReadOnlyList<PerspectiveAssociationInfo<TModel, TEvent>></code> | Immutable list of typed associations |</p>

<ul><li><strong>Empty list</strong>: No perspectives match the specified types</li>
<li><strong>One or more items</strong>: All perspectives handling TModel + TEvent</li>
<li><strong>Never null</strong>: Always returns a list (empty or populated)</li>
</ul>
<h2>Best Practices</h2>

<ul><li><strong>Cache associations outside loops</strong> - Method is fast but caching improves performance</li>
<li><strong>Handle empty results gracefully</strong> - Check <code>Count</code> or <code>Any()</code> before iterating</li>
<li><strong>Use for type-safe invocation</strong> - Prefer over reflection or dynamic invocation</li>
<li><strong>Combine with MessageAssociation</strong> - Use MessageAssociation for discovery, GetPerspectiveAssociations for invocation</li>
<li><strong>Leverage compile-time safety</strong> - Let compiler enforce type constraints</li>
<li><strong>Monitor performance</strong> - Add logging/metrics to track perspective execution time</li>
<li><strong>Test with multiple perspectives</strong> - Verify behavior when multiple perspectives match</li>
</ul>
<h2>Common Pitfalls</h2>

<h3>❌ Not Handling Empty Results</h3>

<pre><code class="language-csharp">// ❌ WRONG: Assuming results exist
<p>var associations = PerspectiveRegistrationExtensions</p>
<p>    .GetPerspectiveAssociations<ProductModel, ProductCreatedEvent>(serviceName);</p>

<p>var first = associations.First(); // May throw InvalidOperationException!</p>

<p>// ✅ CORRECT: Check first</p>
<p>if (associations.Any()) {</p>
<p>    var first = associations.First();</p>
<p>} else {</p>
<p>    _logger.LogWarning("No perspectives found for ProductModel + ProductCreatedEvent");</p>
<p>}</p>
<p></code></pre></p>

<h3>❌ Calling in Hot Paths</h3>

<pre><code class="language-csharp">// ❌ WRONG: Calling repeatedly
<p>public TModel ProcessEvents<TModel, TEvent>(</p>
<p>    TModel model,</p>
<p>    IEnumerable<TEvent> events,</p>
<p>    string serviceName)</p>
<p>    where TEvent : IEvent {</p>

<p>    foreach (var evt in events) {</p>
<p>        var associations = PerspectiveRegistrationExtensions</p>
<p>            .GetPerspectiveAssociations<TModel, TEvent>(serviceName); // Called 1000 times!</p>
<p>        // ...</p>
<p>    }</p>
<p>}</p>

<p>// ✅ CORRECT: Cache before loop</p>
<p>public TModel ProcessEvents<TModel, TEvent>(</p>
<p>    TModel model,</p>
<p>    IEnumerable<TEvent> events,</p>
<p>    string serviceName)</p>
<p>    where TEvent : IEvent {</p>

<p>    var associations = PerspectiveRegistrationExtensions</p>
<p>        .GetPerspectiveAssociations<TModel, TEvent>(serviceName); // Called once!</p>

<p>    foreach (var evt in events) {</p>
<p>        foreach (var assoc in associations) {</p>
<p>            model = assoc.ApplyDelegate(model, evt);</p>
<p>        }</p>
<p>    }</p>

<p>    return model;</p>
<p>}</p>
<p></code></pre></p>

<h3>❌ Ignoring Type Constraints</h3>

<pre><code class="language-csharp">// ❌ WRONG: Forgetting IEvent constraint
<p>public void ProcessEvent<TModel, TMessage>(TModel model, TMessage message) {</p>
<p>    var associations = PerspectiveRegistrationExtensions</p>
<p>        .GetPerspectiveAssociations<TModel, TMessage>(serviceName);</p>
<p>    // Compiler error: TMessage doesn't have IEvent constraint!</p>
<p>}</p>

<p>// ✅ CORRECT: Add constraint</p>
<p>public void ProcessEvent<TModel, TMessage>(TModel model, TMessage message)</p>
<p>    where TMessage : IEvent {</p>

<p>    var associations = PerspectiveRegistrationExtensions</p>
<p>        .GetPerspectiveAssociations<TModel, TMessage>(serviceName);</p>
<p>}</p>
<p></code></pre></p>

<h2>See Also</h2>

<ul><li><a href="/v1.0.0/core-concepts/perspectives/association-info">PerspectiveAssociationInfo</a> - Association record with delegates</li>
<li><a href="/v1.0.0/core-concepts/perspectives">Perspectives</a> - Overview of perspective system</li>
<li><a href="/v1.0.0/core-concepts/perspectives#message-associations">Message Associations</a> - String-based discovery</li>
<li><a href="/v1.0.0/advanced-topics/aot-compatibility">AOT Compatibility</a> - Native AOT support</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

</section>

<section class="doc-category">
  <h2 class="category-header">Customization Examples</h2>
<article id="v1-0-0-customization-examples-event-sourcing-cqrs" class="doc-section">
  <h3>Event Sourcing &amp; CQRS</h3>
  <p class="doc-path"><code>v1.0.0/customization-examples/event-sourcing-cqrs</code></p>
  <p class="doc-description"><em>Implement full event sourcing with CQRS - event store, snapshots, temporal queries, and projections</em></p>
  <div class="doc-content">

<h1>Event Sourcing & CQRS</h1>

<p>Implement <strong>full event sourcing with CQRS</strong> using Whizbang - event store, aggregate reconstruction, snapshots, temporal queries, and read model projections.</p>

<hr>

<h2>Architecture</h2>

<pre><code class="language-">┌────────────────────────────────────────────────────────────┐
<p>│  Event Sourcing Architecture                               │</p>
<p>│                                                             │</p>
<p>│  WRITE SIDE (Commands)                                     │</p>
<p>│  ┌──────────────────────────────────────────────────────┐  │</p>
<p>│  │  1. Load Aggregate from Event Store                  │  │</p>
<p>│  │  2. Execute Command (domain logic)                   │  │</p>
<p>│  │  3. Generate Events                                  │  │</p>
<p>│  │  4. Persist Events to Event Store                    │  │</p>
<p>│  │  5. Publish Events to Bus                            │  │</p>
<p>│  └──────────────────────────────────────────────────────┘  │</p>
<p>│                                                             │</p>
<p>│  ┌──────────────────────────────────────────────────────┐  │</p>
<p>│  │  Event Store (Append-Only Log)                       │  │</p>
<p>│  │  ┌────────┬────────┬────────┬────────┬────────┐      │  │</p>
<p>│  │  │Event 1 │Event 2 │Event 3 │Event 4 │Event 5 │      │  │</p>
<p>│  │  └────────┴────────┴────────┴────────┴────────┘      │  │</p>
<p>│  └──────────────────────────────────────────────────────┘  │</p>
<p>│                          │                                  │</p>
<p>│                          ▼                                  │</p>
<p>│  READ SIDE (Queries)                                       │</p>
<p>│  ┌──────────────────────────────────────────────────────┐  │</p>
<p>│  │  Projections (Perspectives)                          │  │</p>
<p>│  │  - OrderSummaryProjection                            │  │</p>
<p>│  │  - CustomerActivityProjection                        │  │</p>
<p>│  │  - InventoryProjection                               │  │</p>
<p>│  └──────────────────────────────────────────────────────┘  │</p>
<p>└────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<hr>

<h2>Event Store Schema</h2>

<strong>Migrations/001_CreateEventStore.sql</strong>:

<pre><code class="language-sql">CREATE TABLE event_store (
<p>  event_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),</p>
<p>  stream_id UUID NOT NULL,</p>
<p>  stream_type TEXT NOT NULL,</p>
<p>  event_type TEXT NOT NULL,</p>
<p>  event_version INTEGER NOT NULL,</p>
<p>  event_data JSONB NOT NULL,</p>
<p>  metadata JSONB NOT NULL DEFAULT '{}'::jsonb,</p>
<p>  timestamp TIMESTAMP NOT NULL DEFAULT NOW(),</p>
<p>  CONSTRAINT unique_stream_version UNIQUE (stream_id, event_version)</p>
<p>);</p>

<p>CREATE INDEX idx_event_store_stream_id ON event_store(stream_id);</p>
<p>CREATE INDEX idx_event_store_timestamp ON event_store(timestamp DESC);</p>
<p>CREATE INDEX idx_event_store_event_type ON event_store(event_type);</p>

<p>-- Snapshots for performance (optional)</p>
<p>CREATE TABLE event_store_snapshots (</p>
<p>  snapshot_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),</p>
<p>  stream_id UUID NOT NULL UNIQUE,</p>
<p>  stream_type TEXT NOT NULL,</p>
<p>  version INTEGER NOT NULL,</p>
<p>  state JSONB NOT NULL,</p>
<p>  timestamp TIMESTAMP NOT NULL DEFAULT NOW()</p>
<p>);</p>

<p>CREATE INDEX idx_snapshots_stream_id ON event_store_snapshots(stream_id);</p>
<p></code></pre></p>

<hr>

<h2>Domain Events</h2>

<strong>OrderEvents.cs</strong>:

<pre><code class="language-csharp">public record OrderCreatedEvent(
<p>  string CustomerId,</p>
<p>  OrderItem[] Items,</p>
<p>  decimal TotalAmount,</p>
<p>  DateTime CreatedAt</p>
<p>);</p>

<p>public record PaymentProcessedEvent(</p>
<p>  string PaymentId,</p>
<p>  decimal Amount,</p>
<p>  DateTime ProcessedAt</p>
<p>);</p>

<p>public record OrderShippedEvent(</p>
<p>  string TrackingNumber,</p>
<p>  DateTime ShippedAt</p>
<p>);</p>

<p>public record OrderCancelledEvent(</p>
<p>  string Reason,</p>
<p>  DateTime CancelledAt</p>
<p>);</p>
<p></code></pre></p>

<hr>

<h2>Aggregate Root</h2>

<strong>OrderAggregate.cs</strong>:

<pre><code class="language-csharp">public class OrderAggregate {
<p>  private readonly List<object> _uncommittedEvents = [];</p>

<p>  // State</p>
<p>  public Guid OrderId { get; private set; }</p>
<p>  public string? CustomerId { get; private set; }</p>
<p>  public decimal TotalAmount { get; private set; }</p>
<p>  public OrderStatus Status { get; private set; }</p>
<p>  public int Version { get; private set; }</p>

<p>  // Create new aggregate</p>
<p>  public static OrderAggregate Create(</p>
<p>    Guid orderId,</p>
<p>    string customerId,</p>
<p>    OrderItem[] items</p>
<p>  ) {</p>
<p>    var aggregate = new OrderAggregate();</p>
<p>    var totalAmount = items.Sum(i => i.Quantity * i.UnitPrice);</p>

<p>    var @event = new OrderCreatedEvent(</p>
<p>      CustomerId: customerId,</p>
<p>      Items: items,</p>
<p>      TotalAmount: totalAmount,</p>
<p>      CreatedAt: DateTime.UtcNow</p>
<p>    );</p>

<p>    aggregate.Apply(@event);</p>
<p>    aggregate._uncommittedEvents.Add(@event);</p>

<p>    return aggregate;</p>
<p>  }</p>

<p>  // Load from event history</p>
<p>  public static OrderAggregate LoadFromHistory(IEnumerable<object> events) {</p>
<p>    var aggregate = new OrderAggregate();</p>
<p>    foreach (var @event in events) {</p>
<p>      aggregate.Apply(@event);</p>
<p>      aggregate.Version++;</p>
<p>    }</p>
<p>    return aggregate;</p>
<p>  }</p>

<p>  // Commands</p>
<p>  public void ProcessPayment(string paymentId, decimal amount) {</p>
<p>    if (Status != OrderStatus.Pending) {</p>
<p>      throw new InvalidOperationException($"Cannot process payment for order in {Status} status");</p>
<p>    }</p>

<p>    var @event = new PaymentProcessedEvent(</p>
<p>      PaymentId: paymentId,</p>
<p>      Amount: amount,</p>
<p>      ProcessedAt: DateTime.UtcNow</p>
<p>    );</p>

<p>    Apply(@event);</p>
<p>    _uncommittedEvents.Add(@event);</p>
<p>  }</p>

<p>  public void Ship(string trackingNumber) {</p>
<p>    if (Status != OrderStatus.PaymentProcessed) {</p>
<p>      throw new InvalidOperationException($"Cannot ship order in {Status} status");</p>
<p>    }</p>

<p>    var @event = new OrderShippedEvent(</p>
<p>      TrackingNumber: trackingNumber,</p>
<p>      ShippedAt: DateTime.UtcNow</p>
<p>    );</p>

<p>    Apply(@event);</p>
<p>    _uncommittedEvents.Add(@event);</p>
<p>  }</p>

<p>  public void Cancel(string reason) {</p>
<p>    if (Status == OrderStatus.Shipped || Status == OrderStatus.Delivered) {</p>
<p>      throw new InvalidOperationException($"Cannot cancel order in {Status} status");</p>
<p>    }</p>

<p>    var @event = new OrderCancelledEvent(</p>
<p>      Reason: reason,</p>
<p>      CancelledAt: DateTime.UtcNow</p>
<p>    );</p>

<p>    Apply(@event);</p>
<p>    _uncommittedEvents.Add(@event);</p>
<p>  }</p>

<p>  // Event application (state transitions)</p>
<p>  private void Apply(OrderCreatedEvent @event) {</p>
<p>    OrderId = Guid.NewGuid();</p>
<p>    CustomerId = @event.CustomerId;</p>
<p>    TotalAmount = @event.TotalAmount;</p>
<p>    Status = OrderStatus.Pending;</p>
<p>  }</p>

<p>  private void Apply(PaymentProcessedEvent @event) {</p>
<p>    Status = OrderStatus.PaymentProcessed;</p>
<p>  }</p>

<p>  private void Apply(OrderShippedEvent @event) {</p>
<p>    Status = OrderStatus.Shipped;</p>
<p>  }</p>

<p>  private void Apply(OrderCancelledEvent @event) {</p>
<p>    Status = OrderStatus.Cancelled;</p>
<p>  }</p>

<p>  // Apply dynamic event</p>
<p>  private void Apply(object @event) {</p>
<p>    switch (@event) {</p>
<p>      case OrderCreatedEvent e:</p>
<p>        Apply(e);</p>
<p>        break;</p>
<p>      case PaymentProcessedEvent e:</p>
<p>        Apply(e);</p>
<p>        break;</p>
<p>      case OrderShippedEvent e:</p>
<p>        Apply(e);</p>
<p>        break;</p>
<p>      case OrderCancelledEvent e:</p>
<p>        Apply(e);</p>
<p>        break;</p>
<p>      default:</p>
<p>        throw new InvalidOperationException($"Unknown event type: {@event.GetType().Name}");</p>
<p>    }</p>
<p>  }</p>

<p>  // Get uncommitted events for persistence</p>
<p>  public IEnumerable<object> GetUncommittedEvents() => _uncommittedEvents;</p>

<p>  // Clear after persistence</p>
<p>  public void MarkChangesAsCommitted() => _uncommittedEvents.Clear();</p>
<p>}</p>

<p>public enum OrderStatus {</p>
<p>  Pending,</p>
<p>  PaymentProcessed,</p>
<p>  Shipped,</p>
<p>  Delivered,</p>
<p>  Cancelled</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Event Store Repository</h2>

<strong>EventStoreRepository.cs</strong>:

<pre><code class="language-csharp">public class EventStoreRepository {
<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly ILogger<EventStoreRepository> _logger;</p>

<p>  public async Task<OrderAggregate?> LoadAsync(</p>
<p>    Guid streamId,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    // 1. Try to load from snapshot</p>
<p>    var snapshot = await _db.QuerySingleOrDefaultAsync<SnapshotRow>(</p>
<p>      """</p>
<p>      SELECT version, state</p>
<p>      FROM event_store_snapshots</p>
<p>      WHERE stream_id = @StreamId</p>
<p>      """,</p>
<p>      new { StreamId = streamId }</p>
<p>    );</p>

<p>    var fromVersion = 0;</p>
<p>    OrderAggregate? aggregate = null;</p>

<p>    if (snapshot != null) {</p>
<p>      // Deserialize snapshot</p>
<p>      var state = JsonSerializer.Deserialize<OrderAggregateState>(snapshot.State);</p>
<p>      aggregate = OrderAggregate.FromSnapshot(state!);</p>
<p>      fromVersion = snapshot.Version + 1;</p>

<p>      _logger.LogInformation(</p>
<p>        "Loaded aggregate {StreamId} from snapshot at version {Version}",</p>
<p>        streamId,</p>
<p>        snapshot.Version</p>
<p>      );</p>
<p>    }</p>

<p>    // 2. Load events after snapshot</p>
<p>    var events = await _db.QueryAsync<EventRow>(</p>
<p>      """</p>
<p>      SELECT event_type, event_data, event_version</p>
<p>      FROM event_store</p>
<p>      WHERE stream_id = @StreamId AND event_version >= @FromVersion</p>
<p>      ORDER BY event_version ASC</p>
<p>      """,</p>
<p>      new { StreamId = streamId, FromVersion = fromVersion }</p>
<p>    );</p>

<p>    if (!events.Any() && aggregate == null) {</p>
<p>      return null;  // Aggregate doesn't exist</p>
<p>    }</p>

<p>    // 3. Reconstruct aggregate from events</p>
<p>    var domainEvents = events.Select(e => DeserializeEvent(e.EventType, e.EventData));</p>

<p>    if (aggregate == null) {</p>
<p>      aggregate = OrderAggregate.LoadFromHistory(domainEvents);</p>
<p>    } else {</p>
<p>      aggregate.ApplyEvents(domainEvents);</p>
<p>    }</p>

<p>    _logger.LogInformation(</p>
<p>      "Loaded aggregate {StreamId} with {EventCount} events",</p>
<p>      streamId,</p>
<p>      events.Count()</p>
<p>    );</p>

<p>    return aggregate;</p>
<p>  }</p>

<p>  public async Task SaveAsync(</p>
<p>    OrderAggregate aggregate,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var uncommittedEvents = aggregate.GetUncommittedEvents().ToArray();</p>
<p>    if (!uncommittedEvents.Any()) {</p>
<p>      return;  // No changes to persist</p>
<p>    }</p>

<p>    await using var tx = await _db.BeginTransactionAsync(ct);</p>

<p>    try {</p>
<p>      var currentVersion = aggregate.Version - uncommittedEvents.Length;</p>

<p>      // Persist events</p>
<p>      foreach (var @event in uncommittedEvents) {</p>
<p>        currentVersion++;</p>

<p>        await _db.ExecuteAsync(</p>
<p>          """</p>
<p>          INSERT INTO event_store (stream_id, stream_type, event_type, event_version, event_data, metadata)</p>
<p>          VALUES (@StreamId, @StreamType, @EventType, @EventVersion, @EventData::jsonb, @Metadata::jsonb)</p>
<p>          """,</p>
<p>          new {</p>
<p>            StreamId = aggregate.OrderId,</p>
<p>            StreamType = "Order",</p>
<p>            EventType = @event.GetType().Name,</p>
<p>            EventVersion = currentVersion,</p>
<p>            EventData = JsonSerializer.Serialize(@event),</p>
<p>            Metadata = JsonSerializer.Serialize(new { Timestamp = DateTime.UtcNow })</p>
<p>          },</p>
<p>          transaction: tx</p>
<p>        );</p>
<p>      }</p>

<p>      // Optional: Create snapshot every N events</p>
<p>      if (currentVersion % 100 == 0) {</p>
<p>        await SaveSnapshotAsync(aggregate, currentVersion, tx, ct);</p>
<p>      }</p>

<p>      await tx.CommitAsync(ct);</p>

<p>      aggregate.MarkChangesAsCommitted();</p>

<p>      _logger.LogInformation(</p>
<p>        "Saved {EventCount} events for aggregate {StreamId}, version {Version}",</p>
<p>        uncommittedEvents.Length,</p>
<p>        aggregate.OrderId,</p>
<p>        currentVersion</p>
<p>      );</p>
<p>    } catch {</p>
<p>      await tx.RollbackAsync(ct);</p>
<p>      throw;</p>
<p>    }</p>
<p>  }</p>

<p>  private async Task SaveSnapshotAsync(</p>
<p>    OrderAggregate aggregate,</p>
<p>    int version,</p>
<p>    NpgsqlTransaction tx,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    var state = aggregate.ToSnapshot();</p>

<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO event_store_snapshots (stream_id, stream_type, version, state)</p>
<p>      VALUES (@StreamId, @StreamType, @Version, @State::jsonb)</p>
<p>      ON CONFLICT (stream_id) DO UPDATE SET</p>
<p>        version = @Version,</p>
<p>        state = @State::jsonb,</p>
<p>        timestamp = NOW()</p>
<p>      """,</p>
<p>      new {</p>
<p>        StreamId = aggregate.OrderId,</p>
<p>        StreamType = "Order",</p>
<p>        Version = version,</p>
<p>        State = JsonSerializer.Serialize(state)</p>
<p>      },</p>
<p>      transaction: tx</p>
<p>    );</p>

<p>    _logger.LogInformation(</p>
<p>      "Created snapshot for aggregate {StreamId} at version {Version}",</p>
<p>      aggregate.OrderId,</p>
<p>      version</p>
<p>    );</p>
<p>  }</p>

<p>  private object DeserializeEvent(string eventType, string eventData) {</p>
<p>    var type = Type.GetType($"YourNamespace.{eventType}")</p>
<p>      ?? throw new InvalidOperationException($"Unknown event type: {eventType}");</p>

<p>    return JsonSerializer.Deserialize(eventData, type)!;</p>
<p>  }</p>
<p>}</p>

<p>public record EventRow(string EventType, string EventData, int EventVersion);</p>
<p>public record SnapshotRow(int Version, string State);</p>
<p></code></pre></p>

<hr>

<h2>Command Handler (Receptor)</h2>

<strong>CreateOrderReceptor.cs</strong>:

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>  private readonly EventStoreRepository _eventStore;</p>
<p>  private readonly IMessageBus _bus;</p>
<p>  private readonly ILogger<CreateOrderReceptor> _logger;</p>

<p>  public async Task<OrderCreated> HandleAsync(</p>
<p>    CreateOrder command,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    // 1. Create aggregate</p>
<p>    var aggregate = OrderAggregate.Create(</p>
<p>      orderId: Guid.NewGuid(),</p>
<p>      customerId: command.CustomerId,</p>
<p>      items: command.Items</p>
<p>    );</p>

<p>    // 2. Save to event store</p>
<p>    await _eventStore.SaveAsync(aggregate, ct);</p>

<p>    // 3. Publish events to bus</p>
<p>    foreach (var @event in aggregate.GetUncommittedEvents()) {</p>
<p>      await _bus.PublishAsync(@event, ct);</p>
<p>    }</p>

<p>    _logger.LogInformation(</p>
<p>      "Order {OrderId} created for customer {CustomerId}",</p>
<p>      aggregate.OrderId,</p>
<p>      command.CustomerId</p>
<p>    );</p>

<p>    return new OrderCreated(</p>
<p>      OrderId: aggregate.OrderId.ToString(),</p>
<p>      CustomerId: command.CustomerId,</p>
<p>      Items: command.Items,</p>
<p>      TotalAmount: aggregate.TotalAmount,</p>
<p>      CreatedAt: DateTime.UtcNow</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Temporal Queries</h2>

<strong>Get aggregate state at specific point in time</strong>:

<pre><code class="language-csharp">public class EventStoreQueryService {
<p>  private readonly NpgsqlConnection _db;</p>

<p>  public async Task<OrderAggregate?> LoadAsOfAsync(</p>
<p>    Guid streamId,</p>
<p>    DateTime asOf,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    // Load events up to specified timestamp</p>
<p>    var events = await _db.QueryAsync<EventRow>(</p>
<p>      """</p>
<p>      SELECT event_type, event_data</p>
<p>      FROM event_store</p>
<p>      WHERE stream_id = @StreamId AND timestamp <= @AsOf</p>
<p>      ORDER BY event_version ASC</p>
<p>      """,</p>
<p>      new { StreamId = streamId, AsOf = asOf }</p>
<p>    );</p>

<p>    if (!events.Any()) {</p>
<p>      return null;</p>
<p>    }</p>

<p>    var domainEvents = events.Select(e => DeserializeEvent(e.EventType, e.EventData));</p>
<p>    return OrderAggregate.LoadFromHistory(domainEvents);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:

<pre><code class="language-csharp">// Get order state as of yesterday
<p>var orderYesterday = await queryService.LoadAsOfAsync(</p>
<p>  orderId,</p>
<p>  asOf: DateTime.UtcNow.AddDays(-1)</p>
<p>);</p>

<p>Console.WriteLine($"Order status yesterday: {orderYesterday?.Status}");</p>
<p></code></pre></p>

<hr>

<h2>Projections (Read Models)</h2>

<strong>OrderSummaryProjection.cs</strong>:

<pre><code class="language-csharp">public class OrderSummaryProjection :
<p>  IPerspectiveOf<OrderCreatedEvent>,</p>
<p>  IPerspectiveOf<PaymentProcessedEvent>,</p>
<p>  IPerspectiveOf<OrderShippedEvent> {</p>

<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly ILogger<OrderSummaryProjection> _logger;</p>

<p>  public async Task HandleAsync(</p>
<p>    OrderCreatedEvent @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO order_summary (order_id, customer_id, total_amount, status, created_at)</p>
<p>      VALUES (@OrderId, @CustomerId, @TotalAmount, 'Pending', @CreatedAt)</p>
<p>      """,</p>
<p>      new {</p>
<p>        OrderId = Guid.NewGuid(),  // From event metadata</p>
<p>        CustomerId = @event.CustomerId,</p>
<p>        TotalAmount = @event.TotalAmount,</p>
<p>        CreatedAt = @event.CreatedAt</p>
<p>      }</p>
<p>    );</p>
<p>  }</p>

<p>  public async Task HandleAsync(</p>
<p>    PaymentProcessedEvent @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      UPDATE order_summary</p>
<p>      SET status = 'PaymentProcessed', payment_processed_at = @ProcessedAt</p>
<p>      WHERE order_id = @OrderId</p>
<p>      """,</p>
<p>      new {</p>
<p>        OrderId = Guid.NewGuid(),  // From event metadata</p>
<p>        ProcessedAt = @event.ProcessedAt</p>
<p>      }</p>
<p>    );</p>
<p>  }</p>

<p>  public async Task HandleAsync(</p>
<p>    OrderShippedEvent @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      UPDATE order_summary</p>
<p>      SET status = 'Shipped', shipped_at = @ShippedAt, tracking_number = @TrackingNumber</p>
<p>      WHERE order_id = @OrderId</p>
<p>      """,</p>
<p>      new {</p>
<p>        OrderId = Guid.NewGuid(),  // From event metadata</p>
<p>        ShippedAt = @event.ShippedAt,</p>
<p>        TrackingNumber = @event.TrackingNumber</p>
<p>      }</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Rebuilding Projections</h2>

<strong>Rebuild all projections from event store</strong>:

<pre><code class="language-csharp">public class ProjectionRebuilder {
<p>  private readonly EventStoreRepository _eventStore;</p>
<p>  private readonly OrderSummaryProjection _projection;</p>
<p>  private readonly ILogger<ProjectionRebuilder> _logger;</p>

<p>  public async Task RebuildOrderSummaryAsync(CancellationToken ct = default) {</p>
<p>    _logger.LogInformation("Starting projection rebuild...");</p>

<p>    // 1. Truncate read model</p>
<p>    await _db.ExecuteAsync("TRUNCATE TABLE order_summary");</p>

<p>    // 2. Replay all events</p>
<p>    var events = await _db.QueryAsync<EventRow>(</p>
<p>      """</p>
<p>      SELECT stream_id, event_type, event_data</p>
<p>      FROM event_store</p>
<p>      WHERE stream_type = 'Order'</p>
<p>      ORDER BY event_version ASC</p>
<p>      """</p>
<p>    );</p>

<p>    var count = 0;</p>
<p>    foreach (var eventRow in events) {</p>
<p>      var @event = DeserializeEvent(eventRow.EventType, eventRow.EventData);</p>

<p>      // Apply event to projection</p>
<p>      await ApplyToProjectionAsync(@event, ct);</p>

<p>      count++;</p>
<p>      if (count % 1000 == 0) {</p>
<p>        _logger.LogInformation("Processed {Count} events...", count);</p>
<p>      }</p>
<p>    }</p>

<p>    _logger.LogInformation("Projection rebuild complete. {Count} events processed.", count);</p>
<p>  }</p>

<p>  private async Task ApplyToProjectionAsync(object @event, CancellationToken ct) {</p>
<p>    switch (@event) {</p>
<p>      case OrderCreatedEvent e:</p>
<p>        await _projection.HandleAsync(e, ct);</p>
<p>        break;</p>
<p>      case PaymentProcessedEvent e:</p>
<p>        await _projection.HandleAsync(e, ct);</p>
<p>        break;</p>
<p>      case OrderShippedEvent e:</p>
<p>        await _projection.HandleAsync(e, ct);</p>
<p>        break;</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>Event Store</strong> - Append-only log of all domain events</p>
<p>✅ <strong>Aggregate Reconstruction</strong> - Rebuild state from event history</p>
<p>✅ <strong>Snapshots</strong> - Performance optimization for large event streams</p>
<p>✅ <strong>Temporal Queries</strong> - Query state at any point in time</p>
<p>✅ <strong>Projections</strong> - Event-driven read models (CQRS)</p>
<p>✅ <strong>Projection Rebuilding</strong> - Replay events to rebuild read models</p>

<hr>

<h2>Performance Optimizations</h2>

<h3>1. Snapshots</h3>

<p>Create snapshots every 100 events to avoid replaying thousands of events.</p>

<h3>2. Caching</h3>

<p>Cache frequently accessed aggregates in memory:</p>

<pre><code class="language-csharp">public class CachedEventStoreRepository {
<p>  private readonly EventStoreRepository _inner;</p>
<p>  private readonly IMemoryCache _cache;</p>

<p>  public async Task<OrderAggregate?> LoadAsync(Guid streamId, CancellationToken ct) {</p>
<p>    if (_cache.TryGetValue(streamId, out OrderAggregate? cached)) {</p>
<p>      return cached;</p>
<p>    }</p>

<p>    var aggregate = await _inner.LoadAsync(streamId, ct);</p>
<p>    if (aggregate != null) {</p>
<p>      _cache.Set(streamId, aggregate, TimeSpan.FromMinutes(5));</p>
<p>    }</p>

<p>    return aggregate;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-customization-examples-microservices-orchestration" class="doc-section">
  <h3>Microservices Orchestration</h3>
  <p class="doc-path"><code>v1.0.0/customization-examples/microservices-orchestration</code></p>
  <p class="doc-description"><em>Implement saga orchestration patterns - distributed workflows, compensation, and process managers</em></p>
  <div class="doc-content">

<h1>Microservices Orchestration</h1>

<p>Implement <strong>saga orchestration patterns</strong> with Whizbang for distributed workflows, compensation handling, and complex multi-service coordination.</p>

<hr>

<h2>Orchestration vs. Choreography</h2>

<pre><code class="language-">┌────────────────────────────────────────────────────────────┐
<p>│  Choreography (Decentralized)                              │</p>
<p>│                                                             │</p>
<p>│  OrderService → OrderCreated → InventoryService            │</p>
<p>│                                      ↓                      │</p>
<p>│                            InventoryReserved                │</p>
<p>│                                      ↓                      │</p>
<p>│                              PaymentService                 │</p>
<p>│                                      ↓                      │</p>
<p>│                             PaymentProcessed                │</p>
<p>│                                                             │</p>
<p>│  ❌ No central coordinator                                 │</p>
<p>│  ❌ Hard to track overall state                            │</p>
<p>│  ✅ Loose coupling                                         │</p>
<p>└────────────────────────────────────────────────────────────┘</p>

<p>┌────────────────────────────────────────────────────────────┐</p>
<p>│  Orchestration (Centralized)                               │</p>
<p>│                                                             │</p>
<p>│           ┌──────────────────────┐                         │</p>
<p>│           │ OrderSaga            │                         │</p>
<p>│           │ (Process Manager)    │                         │</p>
<p>│           └──────────┬───────────┘                         │</p>
<p>│                      │                                      │</p>
<p>│         ┌────────────┼────────────┐                        │</p>
<p>│         │            │            │                        │</p>
<p>│         ▼            ▼            ▼                        │</p>
<p>│  ┌──────────┐  ┌──────────┐  ┌──────────┐                │</p>
<p>│  │Inventory │  │ Payment  │  │ Shipping │                │</p>
<p>│  │ Service  │  │ Service  │  │ Service  │                │</p>
<p>│  └──────────┘  └──────────┘  └──────────┘                │</p>
<p>│                                                             │</p>
<p>│  ✅ Central coordinator                                    │</p>
<p>│  ✅ Easy to track state                                    │</p>
<p>│  ✅ Complex workflows                                      │</p>
<p>│  ❌ Tighter coupling                                       │</p>
<p>└────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<hr>

<h2>Saga State Machine</h2>

<strong>OrderSagaState.cs</strong>:

<pre><code class="language-csharp">public record OrderSagaState {
<p>  public required string SagaId { get; init; }</p>
<p>  public required string OrderId { get; init; }</p>
<p>  public required SagaStatus Status { get; init; }</p>
<p>  public required SagaStep CurrentStep { get; init; }</p>
<p>  public string? PaymentId { get; init; }</p>
<p>  public string? ShipmentId { get; init; }</p>
<p>  public string? ErrorMessage { get; init; }</p>
<p>  public DateTime CreatedAt { get; init; }</p>
<p>  public DateTime UpdatedAt { get; init; }</p>
<p>  public Dictionary<string, string> Metadata { get; init; } = new();</p>
<p>}</p>

<p>public enum SagaStatus {</p>
<p>  Started,</p>
<p>  InProgress,</p>
<p>  Completed,</p>
<p>  Compensating,</p>
<p>  Compensated,</p>
<p>  Failed</p>
<p>}</p>

<p>public enum SagaStep {</p>
<p>  OrderCreated,</p>
<p>  InventoryReserving,</p>
<p>  InventoryReserved,</p>
<p>  PaymentProcessing,</p>
<p>  PaymentProcessed,</p>
<p>  ShipmentCreating,</p>
<p>  ShipmentCreated,</p>
<p>  OrderCompleted</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Saga Orchestrator</h2>

<strong>OrderSagaOrchestrator.cs</strong>:

<pre><code class="language-csharp">public class OrderSagaOrchestrator :
<p>  IPerspectiveOf<OrderCreated>,</p>
<p>  IPerspectiveOf<InventoryReserved>,</p>
<p>  IPerspectiveOf<InventoryInsufficient>,</p>
<p>  IPerspectiveOf<PaymentProcessed>,</p>
<p>  IPerspectiveOf<PaymentFailed>,</p>
<p>  IPerspectiveOf<ShipmentCreated> {</p>

<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly IMessageBus _bus;</p>
<p>  private readonly ILogger<OrderSagaOrchestrator> _logger;</p>

<p>  // Handle OrderCreated - Start saga</p>
<p>  public async Task HandleAsync(</p>
<p>    OrderCreated @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var sagaId = Guid.NewGuid().ToString("N");</p>

<p>    // 1. Create saga state</p>
<p>    var state = new OrderSagaState {</p>
<p>      SagaId = sagaId,</p>
<p>      OrderId = @event.OrderId,</p>
<p>      Status = SagaStatus.InProgress,</p>
<p>      CurrentStep = SagaStep.InventoryReserving,</p>
<p>      CreatedAt = DateTime.UtcNow,</p>
<p>      UpdatedAt = DateTime.UtcNow</p>
<p>    };</p>

<p>    await SaveSagaStateAsync(state, ct);</p>

<p>    // 2. Send first command</p>
<p>    var reserveInventoryCommand = new ReserveInventory(</p>
<p>      OrderId: @event.OrderId,</p>
<p>      Items: @event.Items</p>
<p>    );</p>

<p>    await _bus.SendCommandAsync(reserveInventoryCommand, ct);</p>

<p>    _logger.LogInformation(</p>
<p>      "Order saga {SagaId} started for order {OrderId}",</p>
<p>      sagaId,</p>
<p>      @event.OrderId</p>
<p>    );</p>
<p>  }</p>

<p>  // Handle InventoryReserved - Continue saga</p>
<p>  public async Task HandleAsync(</p>
<p>    InventoryReserved @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var state = await LoadSagaStateByOrderIdAsync(@event.OrderId, ct);</p>
<p>    if (state == null) {</p>
<p>      _logger.LogWarning("Saga not found for order {OrderId}", @event.OrderId);</p>
<p>      return;</p>
<p>    }</p>

<p>    // Update state</p>
<p>    state = state with {</p>
<p>      CurrentStep = SagaStep.PaymentProcessing,</p>
<p>      UpdatedAt = DateTime.UtcNow</p>
<p>    };</p>
<p>    await SaveSagaStateAsync(state, ct);</p>

<p>    // Send next command</p>
<p>    var processPaymentCommand = new ProcessPayment(</p>
<p>      OrderId: @event.OrderId,</p>
<p>      Amount: @event.TotalAmount</p>
<p>    );</p>

<p>    await _bus.SendCommandAsync(processPaymentCommand, ct);</p>

<p>    _logger.LogInformation(</p>
<p>      "Saga {SagaId}: Inventory reserved, processing payment",</p>
<p>      state.SagaId</p>
<p>    );</p>
<p>  }</p>

<p>  // Handle InventoryInsufficient - Compensate</p>
<p>  public async Task HandleAsync(</p>
<p>    InventoryInsufficient @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var state = await LoadSagaStateByOrderIdAsync(@event.OrderId, ct);</p>
<p>    if (state == null) return;</p>

<p>    // Update state to compensating</p>
<p>    state = state with {</p>
<p>      Status = SagaStatus.Compensating,</p>
<p>      CurrentStep = SagaStep.OrderCreated,</p>
<p>      ErrorMessage = $"Insufficient inventory for product {@event.ProductId}",</p>
<p>      UpdatedAt = DateTime.UtcNow</p>
<p>    };</p>
<p>    await SaveSagaStateAsync(state, ct);</p>

<p>    // Send compensation command</p>
<p>    var cancelOrderCommand = new CancelOrder(</p>
<p>      OrderId: @event.OrderId,</p>
<p>      Reason: "Insufficient inventory"</p>
<p>    );</p>

<p>    await _bus.SendCommandAsync(cancelOrderCommand, ct);</p>

<p>    _logger.LogWarning(</p>
<p>      "Saga {SagaId}: Insufficient inventory, compensating",</p>
<p>      state.SagaId</p>
<p>    );</p>
<p>  }</p>

<p>  // Handle PaymentProcessed - Continue saga</p>
<p>  public async Task HandleAsync(</p>
<p>    PaymentProcessed @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var state = await LoadSagaStateByOrderIdAsync(@event.OrderId, ct);</p>
<p>    if (state == null) return;</p>

<p>    // Update state</p>
<p>    state = state with {</p>
<p>      CurrentStep = SagaStep.ShipmentCreating,</p>
<p>      PaymentId = @event.PaymentId,</p>
<p>      UpdatedAt = DateTime.UtcNow</p>
<p>    };</p>
<p>    await SaveSagaStateAsync(state, ct);</p>

<p>    // Send next command</p>
<p>    var createShipmentCommand = new CreateShipment(</p>
<p>      OrderId: @event.OrderId,</p>
<p>      PaymentId: @event.PaymentId</p>
<p>    );</p>

<p>    await _bus.SendCommandAsync(createShipmentCommand, ct);</p>

<p>    _logger.LogInformation(</p>
<p>      "Saga {SagaId}: Payment processed, creating shipment",</p>
<p>      state.SagaId</p>
<p>    );</p>
<p>  }</p>

<p>  // Handle PaymentFailed - Compensate</p>
<p>  public async Task HandleAsync(</p>
<p>    PaymentFailed @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var state = await LoadSagaStateByOrderIdAsync(@event.OrderId, ct);</p>
<p>    if (state == null) return;</p>

<p>    // Update state to compensating</p>
<p>    state = state with {</p>
<p>      Status = SagaStatus.Compensating,</p>
<p>      CurrentStep = SagaStep.InventoryReserved,</p>
<p>      ErrorMessage = @event.Reason,</p>
<p>      UpdatedAt = DateTime.UtcNow</p>
<p>    };</p>
<p>    await SaveSagaStateAsync(state, ct);</p>

<p>    // Send compensation command</p>
<p>    var releaseInventoryCommand = new ReleaseInventory(</p>
<p>      OrderId: @event.OrderId</p>
<p>    );</p>

<p>    await _bus.SendCommandAsync(releaseInventoryCommand, ct);</p>

<p>    _logger.LogWarning(</p>
<p>      "Saga {SagaId}: Payment failed, releasing inventory",</p>
<p>      state.SagaId</p>
<p>    );</p>
<p>  }</p>

<p>  // Handle ShipmentCreated - Complete saga</p>
<p>  public async Task HandleAsync(</p>
<p>    ShipmentCreated @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var state = await LoadSagaStateByOrderIdAsync(@event.OrderId, ct);</p>
<p>    if (state == null) return;</p>

<p>    // Update state to completed</p>
<p>    state = state with {</p>
<p>      Status = SagaStatus.Completed,</p>
<p>      CurrentStep = SagaStep.OrderCompleted,</p>
<p>      ShipmentId = @event.ShipmentId,</p>
<p>      UpdatedAt = DateTime.UtcNow</p>
<p>    };</p>
<p>    await SaveSagaStateAsync(state, ct);</p>

<p>    _logger.LogInformation(</p>
<p>      "Saga {SagaId}: Order completed successfully",</p>
<p>      state.SagaId</p>
<p>    );</p>
<p>  }</p>

<p>  private async Task SaveSagaStateAsync(</p>
<p>    OrderSagaState state,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO saga_state (</p>
<p>        saga_id, order_id, status, current_step, payment_id, shipment_id, error_message, created_at, updated_at, metadata</p>
<p>      )</p>
<p>      VALUES (@SagaId, @OrderId, @Status, @CurrentStep, @PaymentId, @ShipmentId, @ErrorMessage, @CreatedAt, @UpdatedAt, @Metadata::jsonb)</p>
<p>      ON CONFLICT (saga_id) DO UPDATE SET</p>
<p>        status = @Status,</p>
<p>        current_step = @CurrentStep,</p>
<p>        payment_id = @PaymentId,</p>
<p>        shipment_id = @ShipmentId,</p>
<p>        error_message = @ErrorMessage,</p>
<p>        updated_at = @UpdatedAt</p>
<p>      """,</p>
<p>      new {</p>
<p>        state.SagaId,</p>
<p>        state.OrderId,</p>
<p>        Status = state.Status.ToString(),</p>
<p>        CurrentStep = state.CurrentStep.ToString(),</p>
<p>        state.PaymentId,</p>
<p>        state.ShipmentId,</p>
<p>        state.ErrorMessage,</p>
<p>        state.CreatedAt,</p>
<p>        state.UpdatedAt,</p>
<p>        Metadata = JsonSerializer.Serialize(state.Metadata)</p>
<p>      }</p>
<p>    );</p>
<p>  }</p>

<p>  private async Task<OrderSagaState?> LoadSagaStateByOrderIdAsync(</p>
<p>    string orderId,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    return await _db.QuerySingleOrDefaultAsync<OrderSagaState>(</p>
<p>      """</p>
<p>      SELECT saga_id, order_id, status, current_step, payment_id, shipment_id, error_message, created_at, updated_at</p>
<p>      FROM saga_state</p>
<p>      WHERE order_id = @OrderId</p>
<p>      """,</p>
<p>      new { OrderId = orderId }</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Saga Database Schema</h2>

<strong>Migrations/001_CreateSagaTables.sql</strong>:

<pre><code class="language-sql">CREATE TABLE saga_state (
<p>  saga_id TEXT PRIMARY KEY,</p>
<p>  order_id TEXT NOT NULL UNIQUE,</p>
<p>  status TEXT NOT NULL,</p>
<p>  current_step TEXT NOT NULL,</p>
<p>  payment_id TEXT,</p>
<p>  shipment_id TEXT,</p>
<p>  error_message TEXT,</p>
<p>  created_at TIMESTAMP NOT NULL DEFAULT NOW(),</p>
<p>  updated_at TIMESTAMP NOT NULL DEFAULT NOW(),</p>
<p>  metadata JSONB NOT NULL DEFAULT '{}'::jsonb</p>
<p>);</p>

<p>CREATE INDEX idx_saga_state_order_id ON saga_state(order_id);</p>
<p>CREATE INDEX idx_saga_state_status ON saga_state(status);</p>
<p>CREATE INDEX idx_saga_state_created_at ON saga_state(created_at DESC);</p>
<p></code></pre></p>

<hr>

<h2>Timeout Handling</h2>

<strong>Saga timeouts for hung processes</strong>:

<strong>SagaTimeoutMonitor.cs</strong>:

<pre><code class="language-csharp">public class SagaTimeoutMonitor : BackgroundService {
<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly IMessageBus _bus;</p>
<p>  private readonly ILogger<SagaTimeoutMonitor> _logger;</p>

<p>  protected override async Task ExecuteAsync(CancellationToken stoppingToken) {</p>
<p>    while (!stoppingToken.IsCancellationRequested) {</p>
<p>      try {</p>
<p>        // Find sagas stuck in progress for > 10 minutes</p>
<p>        var stuckSagas = await _db.QueryAsync<OrderSagaState>(</p>
<p>          """</p>
<p>          SELECT saga_id, order_id, status, current_step, updated_at</p>
<p>          FROM saga_state</p>
<p>          WHERE status = 'InProgress'</p>
<p>            AND updated_at < NOW() - INTERVAL '10 minutes'</p>
<p>          """</p>
<p>        );</p>

<p>        foreach (var saga in stuckSagas) {</p>
<p>          _logger.LogWarning(</p>
<p>            "Saga {SagaId} timed out at step {CurrentStep}, compensating",</p>
<p>            saga.SagaId,</p>
<p>            saga.CurrentStep</p>
<p>          );</p>

<p>          // Trigger compensation</p>
<p>          await CompensateSagaAsync(saga, stoppingToken);</p>
<p>        }</p>

<p>        await Task.Delay(TimeSpan.FromMinutes(1), stoppingToken);</p>
<p>      } catch (Exception ex) when (ex is not OperationCanceledException) {</p>
<p>        _logger.LogError(ex, "Error in saga timeout monitor");</p>
<p>        await Task.Delay(TimeSpan.FromSeconds(30), stoppingToken);</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>

<p>  private async Task CompensateSagaAsync(</p>
<p>    OrderSagaState saga,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    // Send compensation commands based on current step</p>
<p>    switch (saga.CurrentStep) {</p>
<p>      case SagaStep.PaymentProcessing:</p>
<p>        // Release inventory</p>
<p>        await _bus.SendCommandAsync(</p>
<p>          new ReleaseInventory(saga.OrderId),</p>
<p>          ct</p>
<p>        );</p>
<p>        break;</p>

<p>      case SagaStep.ShipmentCreating:</p>
<p>        // Refund payment and release inventory</p>
<p>        await _bus.SendCommandAsync(</p>
<p>          new RefundPayment(saga.OrderId, saga.PaymentId!),</p>
<p>          ct</p>
<p>        );</p>
<p>        await _bus.SendCommandAsync(</p>
<p>          new ReleaseInventory(saga.OrderId),</p>
<p>          ct</p>
<p>        );</p>
<p>        break;</p>
<p>    }</p>

<p>    // Update saga to compensating</p>
<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      UPDATE saga_state</p>
<p>      SET status = 'Compensating', error_message = 'Timeout', updated_at = NOW()</p>
<p>      WHERE saga_id = @SagaId</p>
<p>      """,</p>
<p>      new { SagaId = saga.SagaId }</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Saga Visualization API</h2>

<strong>SagasController.cs</strong>:

<pre><code class="language-csharp">[ApiController]
<p>[Route("api/[controller]")]</p>
<p>public class SagasController : ControllerBase {</p>
<p>  private readonly NpgsqlConnection _db;</p>

<p>  [HttpGet("{sagaId}")]</p>
<p>  public async Task<IActionResult> GetSaga(string sagaId) {</p>
<p>    var saga = await _db.QuerySingleOrDefaultAsync<OrderSagaState>(</p>
<p>      "SELECT * FROM saga_state WHERE saga_id = @SagaId",</p>
<p>      new { SagaId = sagaId }</p>
<p>    );</p>

<p>    if (saga == null) {</p>
<p>      return NotFound();</p>
<p>    }</p>

<p>    return Ok(new {</p>
<p>      saga.SagaId,</p>
<p>      saga.OrderId,</p>
<p>      saga.Status,</p>
<p>      saga.CurrentStep,</p>
<p>      saga.PaymentId,</p>
<p>      saga.ShipmentId,</p>
<p>      saga.ErrorMessage,</p>
<p>      saga.CreatedAt,</p>
<p>      saga.UpdatedAt,</p>
<p>      Steps = GetSagaSteps(saga)</p>
<p>    });</p>
<p>  }</p>

<p>  private object[] GetSagaSteps(OrderSagaState saga) {</p>
<p>    var steps = new[] {</p>
<p>      new { Step = "OrderCreated", Status = "Completed", Timestamp = saga.CreatedAt },</p>
<p>      new { Step = "InventoryReserving", Status = GetStepStatus(saga, SagaStep.InventoryReserving), Timestamp = (DateTime?)null },</p>
<p>      new { Step = "InventoryReserved", Status = GetStepStatus(saga, SagaStep.InventoryReserved), Timestamp = (DateTime?)null },</p>
<p>      new { Step = "PaymentProcessing", Status = GetStepStatus(saga, SagaStep.PaymentProcessing), Timestamp = (DateTime?)null },</p>
<p>      new { Step = "PaymentProcessed", Status = GetStepStatus(saga, SagaStep.PaymentProcessed), Timestamp = (DateTime?)null },</p>
<p>      new { Step = "ShipmentCreating", Status = GetStepStatus(saga, SagaStep.ShipmentCreating), Timestamp = (DateTime?)null },</p>
<p>      new { Step = "ShipmentCreated", Status = GetStepStatus(saga, SagaStep.ShipmentCreated), Timestamp = (DateTime?)null }</p>
<p>    };</p>

<p>    return steps;</p>
<p>  }</p>

<p>  private string GetStepStatus(OrderSagaState saga, SagaStep step) {</p>
<p>    if (saga.CurrentStep == step) return "InProgress";</p>
<p>    if ((int)saga.CurrentStep > (int)step) return "Completed";</p>
<p>    return "Pending";</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Response</strong>:

<pre><code class="language-json">{
<p>  "sagaId": "abc123",</p>
<p>  "orderId": "order-456",</p>
<p>  "status": "InProgress",</p>
<p>  "currentStep": "PaymentProcessing",</p>
<p>  "steps": [</p>
<p>    { "step": "OrderCreated", "status": "Completed", "timestamp": "2024-12-12T10:00:00Z" },</p>
<p>    { "step": "InventoryReserving", "status": "Completed", "timestamp": "2024-12-12T10:01:00Z" },</p>
<p>    { "step": "InventoryReserved", "status": "Completed", "timestamp": "2024-12-12T10:02:00Z" },</p>
<p>    { "step": "PaymentProcessing", "status": "InProgress", "timestamp": null },</p>
<p>    { "step": "PaymentProcessed", "status": "Pending", "timestamp": null },</p>
<p>    { "step": "ShipmentCreating", "status": "Pending", "timestamp": null },</p>
<p>    { "step": "ShipmentCreated", "status": "Pending", "timestamp": null }</p>
<p>  ]</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>Centralized Coordination</strong> - Saga orchestrator manages workflow</p>
<p>✅ <strong>State Tracking</strong> - Saga state persisted at each step</p>
<p>✅ <strong>Compensation</strong> - Automatic rollback on failures</p>
<p>✅ <strong>Timeout Handling</strong> - Monitor and compensate hung sagas</p>
<p>✅ <strong>Visualization</strong> - API for tracking saga progress</p>

<hr>

<h2>When to Use Orchestration</h2>

<p>| Scenario | Orchestration | Choreography |</p>
<p>|----------|--------------|--------------|</p>
<p>| <strong>Simple workflows</strong> | ❌ Overkill | ✅ Recommended |</p>
<p>| <strong>Complex workflows</strong> | ✅ Recommended | ❌ Hard to track |</p>
<p>| <strong>Long-running processes</strong> | ✅ Recommended | ❌ No visibility |</p>
<p>| <strong>High failure rates</strong> | ✅ Better control | ❌ Hard to compensate |</p>
<p>| <strong>Loose coupling</strong> | ❌ Tighter coupling | ✅ Decoupled |</p>

<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-customization-examples-multi-tenant-saas" class="doc-section">
  <h3>Multi-Tenant SaaS</h3>
  <p class="doc-path"><code>v1.0.0/customization-examples/multi-tenant-saas</code></p>
  <p class="doc-description"><em>Build multi-tenant SaaS applications with tenant isolation, per-tenant databases, and cross-tenant analytics</em></p>
  <div class="doc-content">

<h1>Multi-Tenant SaaS</h1>

<p>Build <strong>multi-tenant SaaS applications</strong> with Whizbang featuring tenant isolation, per-tenant databases, cross-tenant analytics, and tenant-specific customizations.</p>

<hr>

<h2>Architecture</h2>

<pre><code class="language-">┌────────────────────────────────────────────────────────────┐
<p>│  Multi-Tenant SaaS Architecture                            │</p>
<p>│                                                             │</p>
<p>│  ┌──────────────┐                                          │</p>
<p>│  │  HTTP Request│  X-Tenant-Id: tenant-a                   │</p>
<p>│  └──────┬───────┘                                          │</p>
<p>│         │                                                   │</p>
<p>│         ▼                                                   │</p>
<p>│  ┌────────────────────────────┐                            │</p>
<p>│  │  Tenant Identification     │                            │</p>
<p>│  │  Middleware                │                            │</p>
<p>│  └──────┬─────────────────────┘                            │</p>
<p>│         │                                                   │</p>
<p>│         ▼                                                   │</p>
<p>│  ┌────────────────────────────┐                            │</p>
<p>│  │  Tenant-Aware Dispatcher   │                            │</p>
<p>│  │  (Routes to tenant DB)     │                            │</p>
<p>│  └──────┬─────────────────────┘                            │</p>
<p>│         │                                                   │</p>
<p>│         ├──────────────┬──────────────┬─────────────┐      │</p>
<p>│         ▼              ▼              ▼             ▼      │</p>
<p>│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │</p>
<p>│  │ Tenant A │  │ Tenant B │  │ Tenant C │  │ Shared   │  │</p>
<p>│  │    DB    │  │    DB    │  │    DB    │  │    DB    │  │</p>
<p>│  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │</p>
<p>└────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Key features</strong>:
<ul><li>✅ Database per tenant (strongest isolation)</li>
<li>✅ Tenant context propagation</li>
<li>✅ Cross-tenant analytics</li>
<li>✅ Tenant-specific customizations</li>
<li>✅ Tenant onboarding automation</li>
</ul>
<hr>

<h2>Tenant Identification</h2>

<h3>Tenant Context</h3>

<strong>TenantContext.cs</strong>:

<pre><code class="language-csharp">public class TenantContext {
<p>  private static readonly AsyncLocal<string?> _tenantId = new();</p>

<p>  public static string? CurrentTenantId {</p>
<p>    get => _tenantId.Value;</p>
<p>    set => _tenantId.Value = value;</p>
<p>  }</p>

<p>  public static void Set(string tenantId) {</p>
<p>    if (string.IsNullOrWhiteSpace(tenantId)) {</p>
<p>      throw new ArgumentException("Tenant ID cannot be null or empty", nameof(tenantId));</p>
<p>    }</p>
<p>    _tenantId.Value = tenantId;</p>
<p>  }</p>

<p>  public static void Clear() {</p>
<p>    _tenantId.Value = null;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Tenant Middleware</h3>

<strong>TenantIdentificationMiddleware.cs</strong>:

<pre><code class="language-csharp">public class TenantIdentificationMiddleware {
<p>  private readonly RequestDelegate _next;</p>
<p>  private readonly ILogger<TenantIdentificationMiddleware> _logger;</p>

<p>  public TenantIdentificationMiddleware(</p>
<p>    RequestDelegate next,</p>
<p>    ILogger<TenantIdentificationMiddleware> logger</p>
<p>  ) {</p>
<p>    _next = next;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task InvokeAsync(HttpContext context) {</p>
<p>    // 1. Extract tenant ID from header</p>
<p>    var tenantId = context.Request.Headers["X-Tenant-Id"].FirstOrDefault();</p>

<p>    // 2. Fallback: Extract from subdomain (e.g., tenant-a.example.com)</p>
<p>    if (string.IsNullOrWhiteSpace(tenantId)) {</p>
<p>      var host = context.Request.Host.Host;</p>
<p>      var parts = host.Split('.');</p>
<p>      if (parts.Length > 2) {</p>
<p>        tenantId = parts[0];</p>
<p>      }</p>
<p>    }</p>

<p>    // 3. Fallback: Extract from JWT claim</p>
<p>    if (string.IsNullOrWhiteSpace(tenantId)) {</p>
<p>      tenantId = context.User.FindFirst("tenant_id")?.Value;</p>
<p>    }</p>

<p>    if (string.IsNullOrWhiteSpace(tenantId)) {</p>
<p>      context.Response.StatusCode = 400;</p>
<p>      await context.Response.WriteAsJsonAsync(new {</p>
<p>        error = "Tenant ID is required"</p>
<p>      });</p>
<p>      return;</p>
<p>    }</p>

<p>    // 4. Set tenant context</p>
<p>    TenantContext.Set(tenantId);</p>
<p>    _logger.LogInformation("Request for tenant {TenantId}", tenantId);</p>

<p>    try {</p>
<p>      await _next(context);</p>
<p>    } finally {</p>
<p>      TenantContext.Clear();</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Program.cs registration</strong>:

<pre><code class="language-csharp">app.UseMiddleware<TenantIdentificationMiddleware>();
<p></code></pre></p>

<hr>

<h2>Database Per Tenant</h2>

<h3>Tenant Database Resolver</h3>

<strong>ITenantDatabaseResolver.cs</strong>:

<pre><code class="language-csharp">public interface ITenantDatabaseResolver {
<p>  string GetConnectionString(string tenantId);</p>
<p>}</p>

<p>public class TenantDatabaseResolver : ITenantDatabaseResolver {</p>
<p>  private readonly Dictionary<string, string> _tenantConnectionStrings;</p>

<p>  public TenantDatabaseResolver(IConfiguration configuration) {</p>
<p>    _tenantConnectionStrings = configuration</p>
<p>      .GetSection("Tenants")</p>
<p>      .Get<Dictionary<string, TenantConfig>>()</p>
<p>      ?.ToDictionary(</p>
<p>        kvp => kvp.Key,</p>
<p>        kvp => kvp.Value.ConnectionString</p>
<p>      ) ?? new Dictionary<string, string>();</p>
<p>  }</p>

<p>  public string GetConnectionString(string tenantId) {</p>
<p>    if (_tenantConnectionStrings.TryGetValue(tenantId, out var connectionString)) {</p>
<p>      return connectionString;</p>
<p>    }</p>

<p>    throw new InvalidOperationException($"Tenant {tenantId} not found");</p>
<p>  }</p>
<p>}</p>

<p>public record TenantConfig(</p>
<p>  string ConnectionString,</p>
<p>  string? CustomDomain,</p>
<p>  Dictionary<string, string>? Settings</p>
<p>);</p>
<p></code></pre></p>

<strong>appsettings.json</strong>:

<pre><code class="language-json">{
<p>  "Tenants": {</p>
<p>    "tenant-a": {</p>
<p>      "ConnectionString": "Host=localhost;Database=tenant_a;Username=postgres;Password=postgres",</p>
<p>      "CustomDomain": "tenant-a.example.com",</p>
<p>      "Settings": {</p>
<p>        "MaxUsers": "100",</p>
<p>        "Features": "analytics,exports"</p>
<p>      }</p>
<p>    },</p>
<p>    "tenant-b": {</p>
<p>      "ConnectionString": "Host=localhost;Database=tenant_b;Username=postgres;Password=postgres",</p>
<p>      "CustomDomain": "tenant-b.example.com",</p>
<p>      "Settings": {</p>
<p>        "MaxUsers": "500",</p>
<p>        "Features": "analytics,exports,api-access"</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Tenant-Aware Database Connection</h3>

<strong>Program.cs</strong>:

<pre><code class="language-csharp">builder.Services.AddScoped<NpgsqlConnection>(sp => {
<p>  var tenantId = TenantContext.CurrentTenantId</p>
<p>    ?? throw new InvalidOperationException("Tenant context not set");</p>

<p>  var resolver = sp.GetRequiredService<ITenantDatabaseResolver>();</p>
<p>  var connectionString = resolver.GetConnectionString(tenantId);</p>

<p>  return new NpgsqlConnection(connectionString);</p>
<p>});</p>

<p>builder.Services.AddSingleton<ITenantDatabaseResolver, TenantDatabaseResolver>();</p>
<p></code></pre></p>

<hr>

<h2>Tenant-Aware Receptors</h2>

<strong>CreateOrderReceptor.cs</strong>:

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>  private readonly NpgsqlConnection _db;  // Tenant-specific database</p>
<p>  private readonly IMessageContext _context;</p>
<p>  private readonly ILogger<CreateOrderReceptor> _logger;</p>

<p>  public async Task<OrderCreated> HandleAsync(</p>
<p>    CreateOrder command,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var tenantId = TenantContext.CurrentTenantId</p>
<p>      ?? throw new InvalidOperationException("Tenant context not set");</p>

<p>    _logger.LogInformation(</p>
<p>      "Creating order for tenant {TenantId}, customer {CustomerId}",</p>
<p>      tenantId,</p>
<p>      command.CustomerId</p>
<p>    );</p>

<p>    // Database operations automatically scoped to tenant</p>
<p>    await using var tx = await _db.BeginTransactionAsync(ct);</p>

<p>    try {</p>
<p>      // Insert order (tenant-specific table)</p>
<p>      await _db.ExecuteAsync(</p>
<p>        """</p>
<p>        INSERT INTO orders (order_id, customer_id, total_amount, tenant_id, created_at)</p>
<p>        VALUES (@OrderId, @CustomerId, @TotalAmount, @TenantId, NOW())</p>
<p>        """,</p>
<p>        new {</p>
<p>          OrderId = Guid.NewGuid().ToString("N"),</p>
<p>          CustomerId = command.CustomerId,</p>
<p>          TotalAmount = command.Items.Sum(i => i.Quantity * i.UnitPrice),</p>
<p>          TenantId = tenantId</p>
<p>        },</p>
<p>        transaction: tx</p>
<p>      );</p>

<p>      // ... rest of implementation</p>

<p>      await tx.CommitAsync(ct);</p>
<p>      return @event;</p>
<p>    } catch {</p>
<p>      await tx.RollbackAsync(ct);</p>
<p>      throw;</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Message Context Propagation</h2>

<strong>Automatic tenant ID propagation in events</strong>:

<strong>TenantAwareMessageContext.cs</strong>:

<pre><code class="language-csharp">public class TenantAwareMessageContext : IMessageContext {
<p>  private readonly IMessageContext _inner;</p>

<p>  public TenantAwareMessageContext(IMessageContext inner) {</p>
<p>    _inner = inner;</p>
<p>  }</p>

<p>  public Guid MessageId => _inner.MessageId;</p>
<p>  public Guid? CorrelationId => _inner.CorrelationId;</p>
<p>  public Guid? CausationId => _inner.CausationId;</p>
<p>  public string? UserId => _inner.UserId;</p>

<p>  public IDictionary<string, string> Metadata {</p>
<p>    get {</p>
<p>      var metadata = new Dictionary<string, string>(_inner.Metadata);</p>

<p>      // Auto-inject tenant ID</p>
<p>      if (TenantContext.CurrentTenantId != null) {</p>
<p>        metadata["tenant_id"] = TenantContext.CurrentTenantId;</p>
<p>      }</p>

<p>      return metadata;</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Program.cs</strong>:

<pre><code class="language-csharp">builder.Services.Decorate<IMessageContext, TenantAwareMessageContext>();
<p></code></pre></p>

<strong>Result</strong>: All events automatically include <code>tenant_id</code> in metadata.

<hr>

<h2>Cross-Tenant Analytics</h2>

<h3>Shared Analytics Database</h3>

<strong>AnalyticsDbConnection.cs</strong>:

<pre><code class="language-csharp">public class AnalyticsDbConnectionFactory {
<p>  private readonly string _connectionString;</p>

<p>  public AnalyticsDbConnectionFactory(IConfiguration configuration) {</p>
<p>    _connectionString = configuration.GetConnectionString("AnalyticsDb")</p>
<p>      ?? throw new InvalidOperationException("AnalyticsDb connection string not configured");</p>
<p>  }</p>

<p>  public NpgsqlConnection CreateConnection() {</p>
<p>    return new NpgsqlConnection(_connectionString);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Cross-Tenant Analytics Perspective</h3>

<strong>CrossTenantSalesPerspective.cs</strong>:

<pre><code class="language-csharp">public class CrossTenantSalesPerspective : IPerspectiveOf<OrderCreated> {
<p>  private readonly AnalyticsDbConnectionFactory _analyticsDbFactory;</p>
<p>  private readonly ILogger<CrossTenantSalesPerspective> _logger;</p>

<p>  public CrossTenantSalesPerspective(</p>
<p>    AnalyticsDbConnectionFactory analyticsDbFactory,</p>
<p>    ILogger<CrossTenantSalesPerspective> logger</p>
<p>  ) {</p>
<p>    _analyticsDbFactory = analyticsDbFactory;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task HandleAsync(</p>
<p>    OrderCreated @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    // Extract tenant ID from event metadata</p>
<p>    var tenantId = @event.Metadata.GetValueOrDefault("tenant_id")</p>
<p>      ?? throw new InvalidOperationException("Tenant ID not found in event metadata");</p>

<p>    using var analyticsDb = _analyticsDbFactory.CreateConnection();</p>
<p>    await analyticsDb.OpenAsync(ct);</p>

<p>    // Aggregate across all tenants in shared analytics database</p>
<p>    await analyticsDb.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO cross_tenant_daily_sales (date, tenant_id, total_orders, total_revenue)</p>
<p>      VALUES (CURRENT_DATE, @TenantId, 1, @TotalAmount)</p>
<p>      ON CONFLICT (date, tenant_id) DO UPDATE SET</p>
<p>        total_orders = cross_tenant_daily_sales.total_orders + 1,</p>
<p>        total_revenue = cross_tenant_daily_sales.total_revenue + @TotalAmount</p>
<p>      """,</p>
<p>      new {</p>
<p>        TenantId = tenantId,</p>
<p>        TotalAmount = @event.TotalAmount</p>
<p>      }</p>
<p>    );</p>

<p>    _logger.LogInformation(</p>
<p>      "Cross-tenant analytics updated for tenant {TenantId}: +${Amount}",</p>
<p>      tenantId,</p>
<p>      @event.TotalAmount</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Schema (shared analytics database)</strong>:

<pre><code class="language-sql">CREATE TABLE cross_tenant_daily_sales (
<p>  date DATE NOT NULL,</p>
<p>  tenant_id TEXT NOT NULL,</p>
<p>  total_orders BIGINT NOT NULL DEFAULT 0,</p>
<p>  total_revenue NUMERIC(12, 2) NOT NULL DEFAULT 0,</p>
<p>  PRIMARY KEY (date, tenant_id)</p>
<p>);</p>

<p>CREATE INDEX idx_cross_tenant_sales_date ON cross_tenant_daily_sales(date DESC);</p>
<p>CREATE INDEX idx_cross_tenant_sales_tenant ON cross_tenant_daily_sales(tenant_id);</p>
<p></code></pre></p>

<hr>

<h2>Tenant Onboarding</h2>

<strong>TenantProvisioningService.cs</strong>:

<pre><code class="language-csharp">public class TenantProvisioningService {
<p>  private readonly NpgsqlConnection _masterDb;</p>
<p>  private readonly ILogger<TenantProvisioningService> _logger;</p>

<p>  public async Task ProvisionTenantAsync(</p>
<p>    string tenantId,</p>
<p>    string adminEmail,</p>
<p>    string companyName,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    _logger.LogInformation("Provisioning tenant {TenantId}", tenantId);</p>

<p>    // 1. Create tenant database</p>
<p>    await _masterDb.ExecuteAsync(</p>
<p>      $"CREATE DATABASE tenant_{tenantId}"</p>
<p>    );</p>

<p>    // 2. Run migrations on new database</p>
<p>    var tenantConnectionString = $"Host=localhost;Database=tenant_{tenantId};Username=postgres;Password=postgres";</p>
<p>    using var tenantDb = new NpgsqlConnection(tenantConnectionString);</p>
<p>    await tenantDb.OpenAsync(ct);</p>

<p>    await ApplyMigrationsAsync(tenantDb, ct);</p>

<p>    // 3. Create admin user</p>
<p>    await tenantDb.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO users (user_id, email, role, tenant_id, created_at)</p>
<p>      VALUES (@UserId, @Email, 'admin', @TenantId, NOW())</p>
<p>      """,</p>
<p>      new {</p>
<p>        UserId = Guid.NewGuid().ToString("N"),</p>
<p>        Email = adminEmail,</p>
<p>        TenantId = tenantId</p>
<p>      }</p>
<p>    );</p>

<p>    // 4. Create default settings</p>
<p>    await tenantDb.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO tenant_settings (tenant_id, company_name, max_users, features, created_at)</p>
<p>      VALUES (@TenantId, @CompanyName, 100, 'basic', NOW())</p>
<p>      """,</p>
<p>      new {</p>
<p>        TenantId = tenantId,</p>
<p>        CompanyName = companyName</p>
<p>      }</p>
<p>    );</p>

<p>    _logger.LogInformation("Tenant {TenantId} provisioned successfully", tenantId);</p>
<p>  }</p>

<p>  private async Task ApplyMigrationsAsync(NpgsqlConnection db, CancellationToken ct) {</p>
<p>    var migrationFiles = Directory.GetFiles("Migrations", "*.sql").OrderBy(f => f);</p>
<p>    foreach (var file in migrationFiles) {</p>
<p>      var sql = await File.ReadAllTextAsync(file, ct);</p>
<p>      await db.ExecuteAsync(sql);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Tenant-Specific Customizations</h2>

<strong>Feature Flags per Tenant</strong>:

<pre><code class="language-csharp">public class TenantFeatureService {
<p>  private readonly ITenantDatabaseResolver _resolver;</p>

<p>  public async Task<bool> IsFeatureEnabledAsync(string feature) {</p>
<p>    var tenantId = TenantContext.CurrentTenantId</p>
<p>      ?? throw new InvalidOperationException("Tenant context not set");</p>

<p>    var connectionString = _resolver.GetConnectionString(tenantId);</p>
<p>    using var db = new NpgsqlConnection(connectionString);</p>
<p>    await db.OpenAsync();</p>

<p>    var features = await db.QuerySingleOrDefaultAsync<string>(</p>
<p>      "SELECT features FROM tenant_settings WHERE tenant_id = @TenantId",</p>
<p>      new { TenantId = tenantId }</p>
<p>    );</p>

<p>    return features?.Contains(feature) ?? false;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:

<pre><code class="language-csharp">public async Task<OrderCreated> HandleAsync(CreateOrder command, CancellationToken ct) {
<p>  // Check if tenant has analytics feature</p>
<p>  var hasAnalytics = await _featureService.IsFeatureEnabledAsync("analytics");</p>

<p>  if (hasAnalytics) {</p>
<p>    // Publish additional analytics events</p>
<p>    await PublishAnalyticsEventAsync(@event, ct);</p>
<p>  }</p>

<p>  return @event;</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>Database Per Tenant</strong> - Strongest isolation, independent scaling</p>
<p>✅ <strong>Tenant Context Propagation</strong> - Automatic tenant ID in all messages</p>
<p>✅ <strong>Cross-Tenant Analytics</strong> - Shared database for platform-wide metrics</p>
<p>✅ <strong>Tenant Onboarding</strong> - Automated provisioning with migrations</p>
<p>✅ <strong>Feature Flags</strong> - Tenant-specific customizations</p>

<hr>

<h2>Alternative Patterns</h2>

<h3>Shared Database with Row-Level Security</h3>

<pre><code class="language-sql">-- PostgreSQL Row-Level Security
<p>ALTER TABLE orders ENABLE ROW LEVEL SECURITY;</p>

<p>CREATE POLICY tenant_isolation_policy ON orders</p>
<p>  USING (tenant_id = current_setting('app.current_tenant')::text);</p>

<p>-- Set tenant before query</p>
<p>SET app.current_tenant = 'tenant-a';</p>
<p>SELECT * FROM orders;  -- Only returns tenant-a orders</p>
<p></code></pre></p>

<strong>Pros</strong>: Single database, simpler infrastructure
<strong>Cons</strong>: Weaker isolation, shared resources

<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-customization-examples-real-time-analytics" class="doc-section">
  <h3>Real-Time Analytics</h3>
  <p class="doc-path"><code>v1.0.0/customization-examples/real-time-analytics</code></p>
  <p class="doc-description"><em>Build real-time analytics dashboards - streaming metrics, SignalR updates, and live KPIs</em></p>
  <div class="doc-content">

<h1>Real-Time Analytics</h1>

<p>Build <strong>real-time analytics dashboards</strong> with Whizbang featuring streaming metrics, SignalR updates, live KPIs, and event-driven data aggregation.</p>

<hr>

<h2>Architecture</h2>

<pre><code class="language-">┌────────────────────────────────────────────────────────────┐
<p>│  Real-Time Analytics Architecture                          │</p>
<p>│                                                             │</p>
<p>│  ┌─────────────┐                                           │</p>
<p>│  │Azure Service│  Domain Events (OrderCreated, etc.)       │</p>
<p>│  │     Bus     │──────────────────┐                        │</p>
<p>│  └─────────────┘                  │                        │</p>
<p>│                                    ▼                        │</p>
<p>│              ┌────────────────────────────────┐            │</p>
<p>│              │ Analytics Worker               │            │</p>
<p>│              │  - DailySalesPerspective       │            │</p>
<p>│              │  - RealtimeMetricsPerspective  │            │</p>
<p>│              └──────────┬─────────────────────┘            │</p>
<p>│                         │                                   │</p>
<p>│                         ▼                                   │</p>
<p>│              ┌────────────────────────────────┐            │</p>
<p>│              │ PostgreSQL + Redis Cache       │            │</p>
<p>│              └──────────┬─────────────────────┘            │</p>
<p>│                         │                                   │</p>
<p>│                         ▼                                   │</p>
<p>│              ┌────────────────────────────────┐            │</p>
<p>│              │ SignalR Hub                    │            │</p>
<p>│              │  - Broadcast metrics to clients│            │</p>
<p>│              └──────────┬─────────────────────┘            │</p>
<p>│                         │                                   │</p>
<p>│                         ▼                                   │</p>
<p>│              ┌────────────────────────────────┐            │</p>
<p>│              │  Web Clients (Dashboards)      │            │</p>
<p>│              │  - Live KPI updates            │            │</p>
<p>│              │  - Charts auto-refresh         │            │</p>
<p>│              └────────────────────────────────┘            │</p>
<p>└────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<hr>

<h2>SignalR Hub</h2>

<strong>MetricsHub.cs</strong>:

<pre><code class="language-csharp">using Microsoft.AspNetCore.SignalR;

<p>public class MetricsHub : Hub {</p>
<p>  private readonly ILogger<MetricsHub> _logger;</p>

<p>  public MetricsHub(ILogger<MetricsHub> logger) {</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public override async Task OnConnectedAsync() {</p>
<p>    _logger.LogInformation(</p>
<p>      "Client {ConnectionId} connected to MetricsHub",</p>
<p>      Context.ConnectionId</p>
<p>    );</p>

<p>    // Send current metrics on connect</p>
<p>    await Clients.Caller.SendAsync(</p>
<p>      "ReceiveCurrentMetrics",</p>
<p>      await GetCurrentMetricsAsync()</p>
<p>    );</p>

<p>    await base.OnConnectedAsync();</p>
<p>  }</p>

<p>  public override Task OnDisconnectedAsync(Exception? exception) {</p>
<p>    _logger.LogInformation(</p>
<p>      "Client {ConnectionId} disconnected from MetricsHub",</p>
<p>      Context.ConnectionId</p>
<p>    );</p>

<p>    return base.OnDisconnectedAsync(exception);</p>
<p>  }</p>

<p>  private async Task<object> GetCurrentMetricsAsync() {</p>
<p>    // Fetch current metrics from cache or database</p>
<p>    return new {</p>
<p>      TotalOrders = 1234,</p>
<p>      TotalRevenue = 45678.90m,</p>
<p>      AverageOrderValue = 37.02m,</p>
<p>      Timestamp = DateTime.UtcNow</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Program.cs registration</strong>:

<pre><code class="language-csharp">builder.Services.AddSignalR();

<p>app.MapHub<MetricsHub>("/hubs/metrics");</p>
<p></code></pre></p>

<hr>

<h2>Real-Time Metrics Perspective</h2>

<strong>RealtimeMetricsPerspective.cs</strong>:

<pre><code class="language-csharp">public class RealtimeMetricsPerspective :
<p>  IPerspectiveOf<OrderCreated>,</p>
<p>  IPerspectiveOf<PaymentProcessed> {</p>

<p>  private readonly IHubContext<MetricsHub> _hubContext;</p>
<p>  private readonly IDistributedCache _cache;</p>
<p>  private readonly ILogger<RealtimeMetricsPerspective> _logger;</p>

<p>  public async Task HandleAsync(</p>
<p>    OrderCreated @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    // 1. Update metrics in cache (Redis)</p>
<p>    var metrics = await GetCurrentMetricsAsync(ct);</p>

<p>    metrics = metrics with {</p>
<p>      TotalOrders = metrics.TotalOrders + 1,</p>
<p>      TotalRevenue = metrics.TotalRevenue + @event.TotalAmount,</p>
<p>      AverageOrderValue = (metrics.TotalRevenue + @event.TotalAmount) / (metrics.TotalOrders + 1),</p>
<p>      LastUpdated = DateTime.UtcNow</p>
<p>    };</p>

<p>    await SaveMetricsAsync(metrics, ct);</p>

<p>    // 2. Broadcast to all connected clients</p>
<p>    await _hubContext.Clients.All.SendAsync(</p>
<p>      "ReceiveMetricsUpdate",</p>
<p>      new {</p>
<p>        metrics.TotalOrders,</p>
<p>        metrics.TotalRevenue,</p>
<p>        metrics.AverageOrderValue,</p>
<p>        Timestamp = DateTime.UtcNow</p>
<p>      },</p>
<p>      ct</p>
<p>    );</p>

<p>    _logger.LogInformation(</p>
<p>      "Broadcasted metrics update: {TotalOrders} orders, ${TotalRevenue}",</p>
<p>      metrics.TotalOrders,</p>
<p>      metrics.TotalRevenue</p>
<p>    );</p>
<p>  }</p>

<p>  public async Task HandleAsync(</p>
<p>    PaymentProcessed @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    // Update payment-specific metrics</p>
<p>    var metrics = await GetCurrentMetricsAsync(ct);</p>

<p>    metrics = metrics with {</p>
<p>      TotalPaymentsProcessed = metrics.TotalPaymentsProcessed + 1,</p>
<p>      LastUpdated = DateTime.UtcNow</p>
<p>    };</p>

<p>    await SaveMetricsAsync(metrics, ct);</p>

<p>    await _hubContext.Clients.All.SendAsync(</p>
<p>      "ReceivePaymentMetricsUpdate",</p>
<p>      new {</p>
<p>        metrics.TotalPaymentsProcessed,</p>
<p>        Timestamp = DateTime.UtcNow</p>
<p>      },</p>
<p>      ct</p>
<p>    );</p>
<p>  }</p>

<p>  private async Task<RealtimeMetrics> GetCurrentMetricsAsync(CancellationToken ct) {</p>
<p>    var cached = await _cache.GetStringAsync("realtime-metrics", ct);</p>
<p>    if (cached != null) {</p>
<p>      return JsonSerializer.Deserialize<RealtimeMetrics>(cached)!;</p>
<p>    }</p>

<p>    // Initialize if not exists</p>
<p>    return new RealtimeMetrics {</p>
<p>      TotalOrders = 0,</p>
<p>      TotalRevenue = 0,</p>
<p>      AverageOrderValue = 0,</p>
<p>      TotalPaymentsProcessed = 0,</p>
<p>      LastUpdated = DateTime.UtcNow</p>
<p>    };</p>
<p>  }</p>

<p>  private async Task SaveMetricsAsync(RealtimeMetrics metrics, CancellationToken ct) {</p>
<p>    var json = JsonSerializer.Serialize(metrics);</p>
<p>    await _cache.SetStringAsync(</p>
<p>      "realtime-metrics",</p>
<p>      json,</p>
<p>      new DistributedCacheEntryOptions {</p>
<p>        AbsoluteExpirationRelativeToNow = TimeSpan.FromDays(1)</p>
<p>      },</p>
<p>      ct</p>
<p>    );</p>
<p>  }</p>
<p>}</p>

<p>public record RealtimeMetrics {</p>
<p>  public long TotalOrders { get; init; }</p>
<p>  public decimal TotalRevenue { get; init; }</p>
<p>  public decimal AverageOrderValue { get; init; }</p>
<p>  public long TotalPaymentsProcessed { get; init; }</p>
<p>  public DateTime LastUpdated { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Client-Side (TypeScript)</h2>

<strong>metrics-dashboard.ts</strong>:

<pre><code class="language-typescript">import * as signalR from "@microsoft/signalr";

<p>class MetricsDashboard {</p>
<p>  private connection: signalR.HubConnection;</p>

<p>  constructor() {</p>
<p>    // Connect to SignalR hub</p>
<p>    this.connection = new signalR.HubConnectionBuilder()</p>
<p>      .withUrl("/hubs/metrics")</p>
<p>      .withAutomaticReconnect()</p>
<p>      .build();</p>

<p>    this.setupEventHandlers();</p>
<p>    this.connect();</p>
<p>  }</p>

<p>  private setupEventHandlers() {</p>
<p>    // Receive current metrics on connect</p>
<p>    this.connection.on("ReceiveCurrentMetrics", (metrics: any) => {</p>
<p>      console.log("Current metrics:", metrics);</p>
<p>      this.updateDashboard(metrics);</p>
<p>    });</p>

<p>    // Receive live updates</p>
<p>    this.connection.on("ReceiveMetricsUpdate", (metrics: any) => {</p>
<p>      console.log("Metrics update:", metrics);</p>
<p>      this.updateDashboard(metrics);</p>
<p>      this.showNotification(<code>New order: $${metrics.TotalRevenue}</code>);</p>
<p>    });</p>

<p>    // Receive payment updates</p>
<p>    this.connection.on("ReceivePaymentMetricsUpdate", (metrics: any) => {</p>
<p>      console.log("Payment metrics update:", metrics);</p>
<p>      this.updatePaymentMetrics(metrics);</p>
<p>    });</p>
<p>  }</p>

<p>  private async connect() {</p>
<p>    try {</p>
<p>      await this.connection.start();</p>
<p>      console.log("Connected to MetricsHub");</p>
<p>    } catch (err) {</p>
<p>      console.error("Error connecting to MetricsHub:", err);</p>
<p>      setTimeout(() => this.connect(), 5000);</p>
<p>    }</p>
<p>  }</p>

<p>  private updateDashboard(metrics: any) {</p>
<p>    document.getElementById("total-orders")!.textContent = metrics.TotalOrders;</p>
<p>    document.getElementById("total-revenue")!.textContent = <code>$${metrics.TotalRevenue.toFixed(2)}</code>;</p>
<p>    document.getElementById("avg-order-value")!.textContent = <code>$${metrics.AverageOrderValue.toFixed(2)}</code>;</p>
<p>    document.getElementById("last-updated")!.textContent = new Date(metrics.Timestamp).toLocaleTimeString();</p>
<p>  }</p>

<p>  private updatePaymentMetrics(metrics: any) {</p>
<p>    document.getElementById("total-payments")!.textContent = metrics.TotalPaymentsProcessed;</p>
<p>  }</p>

<p>  private showNotification(message: string) {</p>
<p>    // Show toast notification</p>
<p>    const toast = document.createElement("div");</p>
<p>    toast.className = "toast";</p>
<p>    toast.textContent = message;</p>
<p>    document.body.appendChild(toast);</p>

<p>    setTimeout(() => toast.remove(), 3000);</p>
<p>  }</p>
<p>}</p>

<p>// Initialize dashboard</p>
<p>new MetricsDashboard();</p>
<p></code></pre></p>

<strong>HTML</strong>:

<pre><code class="language-html"><!DOCTYPE html>
<html>
<head>
<p>  <title>Real-Time Analytics Dashboard</title></p>
<p>  <style></p>
<p>    .metric-card {</p>
<p>      display: inline-block;</p>
<p>      padding: 20px;</p>
<p>      margin: 10px;</p>
<p>      background: #f5f5f5;</p>
<p>      border-radius: 8px;</p>
<p>    }</p>
<p>    .metric-value {</p>
<p>      font-size: 36px;</p>
<p>      font-weight: bold;</p>
<p>    }</p>
<p>    .metric-label {</p>
<p>      font-size: 14px;</p>
<p>      color: #666;</p>
<p>    }</p>
<p>    .toast {</p>
<p>      position: fixed;</p>
<p>      bottom: 20px;</p>
<p>      right: 20px;</p>
<p>      padding: 15px;</p>
<p>      background: #28a745;</p>
<p>      color: white;</p>
<p>      border-radius: 4px;</p>
<p>    }</p>
<p>  </style></p>
<p></head></p>
<body>
<p>  <h1>Real-Time Analytics Dashboard</h1></p>

<p>  <div class="metric-card"></p>
<p>    <div class="metric-value" id="total-orders">0</div></p>
<p>    <div class="metric-label">Total Orders</div></p>
<p>  </div></p>

<p>  <div class="metric-card"></p>
<p>    <div class="metric-value" id="total-revenue">$0.00</div></p>
<p>    <div class="metric-label">Total Revenue</div></p>
<p>  </div></p>

<p>  <div class="metric-card"></p>
<p>    <div class="metric-value" id="avg-order-value">$0.00</div></p>
<p>    <div class="metric-label">Avg Order Value</div></p>
<p>  </div></p>

<p>  <div class="metric-card"></p>
<p>    <div class="metric-value" id="total-payments">0</div></p>
<p>    <div class="metric-label">Total Payments</div></p>
<p>  </div></p>

<p>  <div></p>
<p>    <small>Last updated: <span id="last-updated">-</span></small></p>
<p>  </div></p>

<p>  <script src="/dist/metrics-dashboard.js"></script></p>
<p></body></p>
<p></html></p>
<p></code></pre></p>

<hr>

<h2>Streaming Aggregations</h2>

<strong>Sliding Window Analytics</strong>:

<pre><code class="language-csharp">public class SlidingWindowAnalyticsPerspective : IPerspectiveOf<OrderCreated> {
<p>  private readonly IDistributedCache _cache;</p>
<p>  private readonly IHubContext<MetricsHub> _hubContext;</p>

<p>  public async Task HandleAsync(</p>
<p>    OrderCreated @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    // Add event to sliding window (last 5 minutes)</p>
<p>    var windowKey = "orders:last5min";</p>
<p>    var events = await GetWindowEventsAsync(windowKey, ct);</p>

<p>    events.Add(new OrderEventData {</p>
<p>      OrderId = @event.OrderId,</p>
<p>      Amount = @event.TotalAmount,</p>
<p>      Timestamp = DateTime.UtcNow</p>
<p>    });</p>

<p>    // Remove events older than 5 minutes</p>
<p>    var cutoff = DateTime.UtcNow.AddMinutes(-5);</p>
<p>    events = events.Where(e => e.Timestamp >= cutoff).ToList();</p>

<p>    await SaveWindowEventsAsync(windowKey, events, ct);</p>

<p>    // Calculate metrics for last 5 minutes</p>
<p>    var metrics = new {</p>
<p>      OrderCount = events.Count,</p>
<p>      TotalRevenue = events.Sum(e => e.Amount),</p>
<p>      AverageOrderValue = events.Any() ? events.Average(e => e.Amount) : 0,</p>
<p>      WindowStart = cutoff,</p>
<p>      WindowEnd = DateTime.UtcNow</p>
<p>    };</p>

<p>    // Broadcast sliding window metrics</p>
<p>    await _hubContext.Clients.All.SendAsync(</p>
<p>      "ReceiveSlidingWindowUpdate",</p>
<p>      metrics,</p>
<p>      ct</p>
<p>    );</p>
<p>  }</p>

<p>  private async Task<List<OrderEventData>> GetWindowEventsAsync(</p>
<p>    string key,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    var cached = await _cache.GetStringAsync(key, ct);</p>
<p>    return cached != null</p>
<p>      ? JsonSerializer.Deserialize<List<OrderEventData>>(cached)!</p>
<p>      : new List<OrderEventData>();</p>
<p>  }</p>

<p>  private async Task SaveWindowEventsAsync(</p>
<p>    string key,</p>
<p>    List<OrderEventData> events,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    var json = JsonSerializer.Serialize(events);</p>
<p>    await _cache.SetStringAsync(</p>
<p>      key,</p>
<p>      json,</p>
<p>      new DistributedCacheEntryOptions {</p>
<p>        AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(10)</p>
<p>      },</p>
<p>      ct</p>
<p>    );</p>
<p>  }</p>
<p>}</p>

<p>public record OrderEventData {</p>
<p>  public required string OrderId { get; init; }</p>
<p>  public required decimal Amount { get; init; }</p>
<p>  public required DateTime Timestamp { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Performance Optimizations</h2>

<h3>1. Throttling</h3>

<p>Limit broadcast frequency to avoid overwhelming clients:</p>

<pre><code class="language-csharp">public class ThrottledMetricsPerspective : IPerspectiveOf<OrderCreated> {
<p>  private readonly IHubContext<MetricsHub> _hubContext;</p>
<p>  private readonly SemaphoreSlim _semaphore = new(1, 1);</p>
<p>  private DateTime _lastBroadcast = DateTime.MinValue;</p>
<p>  private static readonly TimeSpan BroadcastInterval = TimeSpan.FromSeconds(1);</p>

<p>  public async Task HandleAsync(OrderCreated @event, CancellationToken ct) {</p>
<p>    // Update metrics immediately</p>
<p>    await UpdateMetricsAsync(@event, ct);</p>

<p>    // Throttle broadcasts (max once per second)</p>
<p>    await _semaphore.WaitAsync(ct);</p>
<p>    try {</p>
<p>      if (DateTime.UtcNow - _lastBroadcast >= BroadcastInterval) {</p>
<p>        await BroadcastMetricsAsync(ct);</p>
<p>        _lastBroadcast = DateTime.UtcNow;</p>
<p>      }</p>
<p>    } finally {</p>
<p>      _semaphore.Release();</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>2. Batching</h3>

<p>Batch multiple updates before broadcasting:</p>

<pre><code class="language-csharp">public class BatchedMetricsPerspective {
<p>  private readonly Channel<OrderCreated> _channel = Channel.CreateUnbounded<OrderCreated>();</p>

<p>  public BatchedMetricsPerspective(IHubContext<MetricsHub> hubContext) {</p>
<p>    _ = Task.Run(async () => await ProcessBatchesAsync(hubContext));</p>
<p>  }</p>

<p>  public async Task HandleAsync(OrderCreated @event, CancellationToken ct) {</p>
<p>    await _channel.Writer.WriteAsync(@event, ct);</p>
<p>  }</p>

<p>  private async Task ProcessBatchesAsync(IHubContext<MetricsHub> hubContext) {</p>
<p>    await foreach (var batch in _channel.Reader.ReadAllAsync().Buffer(TimeSpan.FromSeconds(1), 100)) {</p>
<p>      var metrics = new {</p>
<p>        OrderCount = batch.Count,</p>
<p>        TotalRevenue = batch.Sum(e => e.TotalAmount),</p>
<p>        Timestamp = DateTime.UtcNow</p>
<p>      };</p>

<p>      await hubContext.Clients.All.SendAsync("ReceiveBatchUpdate", metrics);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>SignalR</strong> - Real-time WebSocket communication</p>
<p>✅ <strong>Event-Driven Updates</strong> - Perspectives broadcast to clients</p>
<p>✅ <strong>Redis Caching</strong> - Fast metric aggregation</p>
<p>✅ <strong>Sliding Windows</strong> - Last N minutes/hours analytics</p>
<p>✅ <strong>Throttling</strong> - Prevent client overload</p>
<p>✅ <strong>Batching</strong> - Reduce broadcast frequency</p>

<hr>

<h2>Alternative Architectures</h2>

<h3>Server-Sent Events (SSE)</h3>

<p>Simpler than SignalR for one-way updates:</p>

<pre><code class="language-csharp">app.MapGet("/sse/metrics", async (HttpContext context) => {
<p>  context.Response.Headers.Add("Content-Type", "text/event-stream");</p>
<p>  context.Response.Headers.Add("Cache-Control", "no-cache");</p>

<p>  while (!context.RequestAborted.IsCancellationRequested) {</p>
<p>    var metrics = await GetCurrentMetricsAsync();</p>
<p>    await context.Response.WriteAsync($"data: {JsonSerializer.Serialize(metrics)}\n\n");</p>
<p>    await context.Response.Body.FlushAsync();</p>

<p>    await Task.Delay(TimeSpan.FromSeconds(1));</p>
<p>  }</p>
<p>});</p>
<p></code></pre></p>

<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Data</h2>
<article id="v1-0-0-data-dapper-integration" class="doc-section">
  <h3>Dapper Integration</h3>
  <p class="doc-path"><code>v1.0.0/data/dapper-integration</code></p>
  <p class="doc-description"><em>Lightweight, high-performance data access with Dapper for Whizbang perspectives and lenses - simple SQL, minimal overhead</em></p>
  <div class="doc-content">

<h1>Dapper Integration</h1>

<strong>Dapper</strong> is Whizbang's recommended micro-ORM for lightweight, high-performance data access in <strong>Perspectives</strong> and <strong>Lenses</strong>. It provides simple SQL execution with minimal overhead - perfect for read models.

<h2>Why Dapper?</h2>

<p>| Feature | Dapper | EF Core |</p>
<p>|---------|--------|---------|</p>
<p>| <strong>Performance</strong> | ~20x faster queries | Slower (change tracking overhead) |</p>
<p>| <strong>Control</strong> | Full SQL control | LINQ translated to SQL |</p>
<p>| <strong>Learning curve</strong> | Simple (just SQL) | Complex (LINQ, migrations, tracking) |</p>
<p>| <strong>Use case</strong> | Perspectives/Lenses | Complex domain models |</p>
<p>| <strong>Recommended for</strong> | ✅ Read models | Write models |</p>

<strong>Whizbang Philosophy</strong>: Use <strong>Dapper for reads</strong> (perspectives, lenses), <strong>EF Core for writes</strong> (optional, if needed).

<hr>

<h2>Installation</h2>

<pre><code class="language-bash">dotnet add package Whizbang.Data.Dapper.Postgres
<p></code></pre></p>

<strong>Includes</strong>:
<ul><li><code>IDbConnectionFactory</code> - Connection factory interface</li>
<li><code>PostgresConnectionFactory</code> - PostgreSQL implementation</li>
<li>Dapper (latest version)</li>
<li>Npgsql (PostgreSQL driver)</li>
</ul>
<hr>

<h2>IDbConnectionFactory</h2>

<p>Whizbang uses <strong><code>IDbConnectionFactory</code></strong> pattern for database connections.</p>

<h3>Interface</h3>

<pre><code class="language-csharp">public interface IDbConnectionFactory {
<p>    IDbConnection CreateConnection();</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ <strong>Testable</strong>: Easy to mock for unit tests</li>
<li>✅ <strong>Flexible</strong>: Swap implementations (PostgreSQL, SQLite, etc.)</li>
<li>✅ <strong>Connection pooling</strong>: Npgsql handles pooling automatically</li>
<li>✅ <strong>Minimal</strong>: No dependencies on specific ORM</li>
</ul>
<h3>PostgreSQL Implementation</h3>

<pre><code class="language-csharp">public class PostgresConnectionFactory : IDbConnectionFactory {
<p>    private readonly string _connectionString;</p>

<p>    public PostgresConnectionFactory(string connectionString) {</p>
<p>        _connectionString = connectionString;</p>
<p>    }</p>

<p>    public IDbConnection CreateConnection() {</p>
<p>        return new NpgsqlConnection(_connectionString);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Registration</h3>

<pre><code class="language-csharp">// appsettings.json
<p>{</p>
<p>  "ConnectionStrings": {</p>
<p>    "DefaultConnection": "Host=localhost;Database=whizbang;Username=postgres;Password=your_password"</p>
<p>  }</p>
<p>}</p>

<p>// Program.cs</p>
<p>var connectionString = builder.Configuration.GetConnectionString("DefaultConnection")!;</p>

<p>builder.Services.AddWhizbangDapper(connectionString);</p>
<p>// OR manually:</p>
<p>builder.Services.AddSingleton<IDbConnectionFactory>(</p>
<p>    new PostgresConnectionFactory(connectionString)</p>
<p>);</p>
<p></code></pre></p>

<hr>

<h2>Basic Usage</h2>

<h3>Query Single Row</h3>

<pre><code class="language-csharp">public class OrderLens : ILensQuery {
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public OrderLens(IDbConnectionFactory db) {</p>
<p>        _db = db;</p>
<p>    }</p>

<p>    public async Task<OrderSummary?> GetOrderAsync(</p>
<p>        Guid orderId,</p>
<p>        CancellationToken ct = default) {</p>

<p>        await using var conn = _db.CreateConnection();</p>

<p>        return await conn.QuerySingleOrDefaultAsync<OrderSummary>(</p>
<p>            """</p>
<p>            SELECT</p>
<p>                order_id,</p>
<p>                customer_id,</p>
<p>                total,</p>
<p>                status,</p>
<p>                created_at</p>
<p>            FROM order_summaries</p>
<p>            WHERE order_id = @OrderId</p>
<p>            """,</p>
<p>            new { OrderId = orderId },</p>
<p>            commandTimeout: 30,</p>
<p>            cancellationToken: ct</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li>Use <code>await using</code> for automatic disposal</li>
<li><code>QuerySingleOrDefaultAsync</code> returns null if not found</li>
<li>Pass parameters as anonymous object</li>
<li>Always pass <code>CancellationToken</code></li>
</ul>
<h3>Query Multiple Rows</h3>

<pre><code class="language-csharp">public async Task<OrderSummary[]> GetOrdersByCustomerAsync(
<p>    Guid customerId,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    var orders = await conn.QueryAsync<OrderSummary>(</p>
<p>        """</p>
<p>        SELECT</p>
<p>            order_id,</p>
<p>            customer_id,</p>
<p>            total,</p>
<p>            status,</p>
<p>            created_at</p>
<p>        FROM order_summaries</p>
<p>        WHERE customer_id = @CustomerId</p>
<p>        ORDER BY created_at DESC</p>
<p>        """,</p>
<p>        new { CustomerId = customerId },</p>
<p>        commandTimeout: 30,</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    return orders.ToArray();</p>
<p>}</p>
<p></code></pre></p>

<h3>Execute Non-Query</h3>

<pre><code class="language-csharp">public class OrderSummaryPerspective : IPerspectiveOf<OrderCreated> {
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>        await using var conn = _db.CreateConnection();</p>

<p>        await conn.ExecuteAsync(</p>
<p>            """</p>
<p>            INSERT INTO order_summaries (</p>
<p>                order_id, customer_id, total, status, created_at</p>
<p>            ) VALUES (</p>
<p>                @OrderId, @CustomerId, @Total, @Status, @CreatedAt</p>
<p>            )</p>
<p>            """,</p>
<p>            new {</p>
<p>                @event.OrderId,</p>
<p>                @event.CustomerId,</p>
<p>                @event.Total,</p>
<p>                Status = "Created",</p>
<p>                @event.CreatedAt</p>
<p>            },</p>
<p>            commandTimeout: 30,</p>
<p>            cancellationToken: ct</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>PostgreSQL-Specific Features</h2>

<h3>JSONB Columns</h3>

<pre><code class="language-csharp">// Query JSONB column
<p>public async Task<Product[]> GetProductsByCategoryAsync(</p>
<p>    string category,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    var products = await conn.QueryAsync<Product>(</p>
<p>        """</p>
<p>        SELECT</p>
<p>            product_id,</p>
<p>            name,</p>
<p>            price,</p>
<p>            metadata</p>
<p>        FROM products</p>
<p>        WHERE metadata->>'category' = @Category</p>
<p>        ORDER BY name</p>
<p>        """,</p>
<p>        new { Category = category },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    return products.ToArray();</p>
<p>}</p>

<p>// Store JSONB</p>
<p>public async Task UpdateProductMetadataAsync(</p>
<p>    Guid productId,</p>
<p>    Dictionary<string, string> metadata,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    await conn.ExecuteAsync(</p>
<p>        """</p>
<p>        UPDATE products</p>
<p>        SET metadata = @Metadata::jsonb</p>
<p>        WHERE product_id = @ProductId</p>
<p>        """,</p>
<p>        new {</p>
<p>            ProductId = productId,</p>
<p>            Metadata = JsonSerializer.Serialize(metadata)</p>
<p>        },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<h3>Array Parameters</h3>

<pre><code class="language-csharp">public async Task<Product[]> GetProductsByIdsAsync(
<p>    Guid[] productIds,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    var products = await conn.QueryAsync<Product>(</p>
<p>        """</p>
<p>        SELECT * FROM products</p>
<p>        WHERE product_id = ANY(@ProductIds)</p>
<p>        """,</p>
<p>        new { ProductIds = productIds },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    return products.ToArray();</p>
<p>}</p>
<p></code></pre></p>

<h3>UPSERT (ON CONFLICT)</h3>

<pre><code class="language-csharp">public async Task UpsertInventoryAsync(
<p>    Guid productId,</p>
<p>    int quantity,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    await conn.ExecuteAsync(</p>
<p>        """</p>
<p>        INSERT INTO inventory (product_id, available)</p>
<p>        VALUES (@ProductId, @Quantity)</p>
<p>        ON CONFLICT (product_id) DO UPDATE</p>
<p>        SET available = EXCLUDED.available</p>
<p>        """,</p>
<p>        new { ProductId = productId, Quantity = quantity },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Transactions</h2>

<h3>Basic Transaction</h3>

<pre><code class="language-csharp">public async Task CreateOrderWithItemsAsync(
<p>    Order order,</p>
<p>    OrderItem[] items,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>
<p>    await conn.OpenAsync(ct);</p>

<p>    await using var transaction = await conn.BeginTransactionAsync(ct);</p>

<p>    try {</p>
<p>        // Insert order</p>
<p>        await conn.ExecuteAsync(</p>
<p>            "INSERT INTO orders (order_id, customer_id, total, status, created_at) VALUES (@OrderId, @CustomerId, @Total, @Status, @CreatedAt)",</p>
<p>            order,</p>
<p>            transaction: transaction,</p>
<p>            cancellationToken: ct</p>
<p>        );</p>

<p>        // Insert order items</p>
<p>        foreach (var item in items) {</p>
<p>            await conn.ExecuteAsync(</p>
<p>                "INSERT INTO order_items (order_item_id, order_id, product_id, quantity, unit_price) VALUES (@OrderItemId, @OrderId, @ProductId, @Quantity, @UnitPrice)",</p>
<p>                item,</p>
<p>                transaction: transaction,</p>
<p>                cancellationToken: ct</p>
<p>            );</p>
<p>        }</p>

<p>        await transaction.CommitAsync(ct);</p>

<p>    } catch {</p>
<p>        await transaction.RollbackAsync(ct);</p>
<p>        throw;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Transaction Scope (Distributed Transactions)</h3>

<pre><code class="language-csharp">using var scope = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled);

<p>await using var conn = _db.CreateConnection();</p>

<p>// All operations in this scope are transactional</p>
<p>await conn.ExecuteAsync("INSERT INTO orders ...");</p>
<p>await conn.ExecuteAsync("INSERT INTO order_items ...");</p>

<p>scope.Complete();  // Commit</p>
<p></code></pre></p>

<hr>

<h2>Mapping</h2>

<h3>Custom Type Mapping</h3>

<pre><code class="language-csharp">// Map custom types
<p>SqlMapper.AddTypeHandler(new GuidTypeHandler());</p>
<p>SqlMapper.AddTypeHandler(new DateTimeOffsetTypeHandler());</p>

<p>public class GuidTypeHandler : SqlMapper.TypeHandler<Guid> {</p>
<p>    public override Guid Parse(object value) {</p>
<p>        return Guid.Parse((string)value);</p>
<p>    }</p>

<p>    public override void SetValue(IDbDataParameter parameter, Guid value) {</p>
<p>        parameter.Value = value.ToString();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Column Name Mapping</h3>

<pre><code class="language-csharp">// Explicit column mapping
<p>public async Task<OrderSummary?> GetOrderAsync(Guid orderId) {</p>
<p>    await using var conn = _db.CreateConnection();</p>

<p>    return await conn.QuerySingleOrDefaultAsync<OrderSummary>(</p>
<p>        """</p>
<p>        SELECT</p>
<p>            order_id AS OrderId,</p>
<p>            customer_id AS CustomerId,</p>
<p>            total AS Total,</p>
<p>            status AS Status,</p>
<p>            created_at AS CreatedAt</p>
<p>        FROM order_summaries</p>
<p>        WHERE order_id = @OrderId</p>
<p>        """,</p>
<p>        new { OrderId = orderId }</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<strong>Note</strong>: Dapper matches columns to properties by name (case-insensitive).

<hr>

<h2>Performance Patterns</h2>

<h3>Buffered vs Unbuffered</h3>

<pre><code class="language-csharp">// ✅ Buffered (default) - loads all rows into memory
<p>var orders = await conn.QueryAsync<OrderSummary>(sql);</p>

<p>// ⚠️ Unbuffered - streams rows (use for large result sets)</p>
<p>var orders = await conn.QueryAsync<OrderSummary>(sql, buffered: false);</p>

<p>await foreach (var order in orders) {</p>
<p>    // Process one at a time (low memory)</p>
<p>}</p>
<p></code></pre></p>

<h3>Batch Operations</h3>

<pre><code class="language-csharp">// ✅ Batch insert (single roundtrip)
<p>await conn.ExecuteAsync(</p>
<p>    "INSERT INTO order_items (order_item_id, order_id, product_id, quantity) VALUES (@OrderItemId, @OrderId, @ProductId, @Quantity)",</p>
<p>    items  // Pass array - Dapper executes once per item</p>
<p>);</p>

<p>// ❌ Loop insert (multiple roundtrips)</p>
<p>foreach (var item in items) {</p>
<p>    await conn.ExecuteAsync("INSERT INTO order_items ...", item);  // Slow!</p>
<p>}</p>
<p></code></pre></p>

<h3>Connection Pooling</h3>

<p>Npgsql handles connection pooling automatically:</p>

<pre><code class="language-">Connection String:
<p>Host=localhost;Database=whizbang;Username=postgres;Password=pass;Minimum Pool Size=5;Maximum Pool Size=100</p>
<p></code></pre></p>

<strong>Configuration</strong>:
<ul><li><code>Minimum Pool Size</code>: Connections kept open (default: 1)</li>
<li><code>Maximum Pool Size</code>: Max connections (default: 100)</li>
<li><code>Connection Lifetime</code>: Max seconds before recreate (default: 0 = infinite)</li>
</ul>
<hr>

<h2>Testing</h2>

<h3>Unit Tests with Mock</h3>

<pre><code class="language-csharp">public class OrderLensTests {
<p>    [Test]</p>
<p>    public async Task GetOrderAsync_ExistingOrder_ReturnsOrderAsync() {</p>
<p>        // Arrange</p>
<p>        var mockDb = CreateMockDbConnectionFactory();</p>
<p>        var lens = new OrderLens(mockDb);</p>

<p>        var orderId = Guid.NewGuid();</p>

<p>        // Act</p>
<p>        var result = await lens.GetOrderAsync(orderId);</p>

<p>        // Assert</p>
<p>        await Assert.That(result).IsNotNull();</p>
<p>        await Assert.That(result!.OrderId).IsEqualTo(orderId);</p>
<p>    }</p>

<p>    private IDbConnectionFactory CreateMockDbConnectionFactory() {</p>
<p>        // Use in-memory database or mock</p>
<p>        return new InMemoryDbConnectionFactory(/<em> test data </em>/);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Integration Tests with PostgreSQL</h3>

<pre><code class="language-csharp">public class OrderLensIntegrationTests {
<p>    private IDbConnectionFactory _db;</p>
<p>    private OrderLens _lens;</p>

<p>    [Before(Test)]</p>
<p>    public async Task SetupAsync() {</p>
<p>        _db = CreateTestDatabase();  // Real PostgreSQL</p>
<p>        _lens = new OrderLens(_db);</p>

<p>        await SeedTestDataAsync();</p>
<p>    }</p>

<p>    [Test]</p>
<p>    public async Task GetOrdersByCustomerAsync_WithOrders_ReturnsAllAsync() {</p>
<p>        // Arrange</p>
<p>        var customerId = TestData.CustomerWithOrdersId;</p>

<p>        // Act</p>
<p>        var orders = await _lens.GetOrdersByCustomerAsync(customerId);</p>

<p>        // Assert</p>
<p>        await Assert.That(orders.Length).IsEqualTo(3);</p>
<p>    }</p>

<p>    private async Task SeedTestDataAsync() {</p>
<p>        await using var conn = _db.CreateConnection();</p>
<p>        await conn.ExecuteAsync(</p>
<p>            "INSERT INTO order_summaries (order_id, customer_id, total, status, created_at) VALUES (@OrderId, @CustomerId, @Total, @Status, @CreatedAt)",</p>
<p>            new {</p>
<p>                OrderId = Guid.NewGuid(),</p>
<p>                CustomerId = TestData.CustomerWithOrdersId,</p>
<p>                Total = 100.00m,</p>
<p>                Status = "Created",</p>
<p>                CreatedAt = DateTimeOffset.UtcNow</p>
<p>            }</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ Use <code>await using</code> for connections (automatic disposal)</li>
<li>✅ Pass <code>CancellationToken</code> to all async methods</li>
<li>✅ Use <code>QuerySingleOrDefaultAsync</code> for single row (returns null if not found)</li>
<li>✅ Use <code>QueryAsync</code> for multiple rows</li>
<li>✅ Use <code>ExecuteAsync</code> for non-queries (INSERT, UPDATE, DELETE)</li>
<li>✅ Use transactions for multi-statement operations</li>
<li>✅ Use batch operations for multiple inserts/updates</li>
<li>✅ Set <code>commandTimeout</code> for long-running queries</li>
<li>✅ Use parameterized queries (prevents SQL injection)</li>
<li>✅ Use connection pooling (automatic with Npgsql)</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Forget <code>await using</code> (connection leak!)</li>
<li>❌ Use string concatenation for SQL (SQL injection risk)</li>
<li>❌ Ignore <code>CancellationToken</code> (can't cancel long queries)</li>
<li>❌ Open connections manually (let Dapper handle it)</li>
<li>❌ Use <code>Query</code> instead of <code>QueryAsync</code> (blocks thread)</li>
<li>❌ Use <code>Execute</code> instead of <code>ExecuteAsync</code> (blocks thread)</li>
<li>❌ Skip transactions for multi-statement operations (data inconsistency)</li>
<li>❌ Loop instead of batch (slow!)</li>
</ul>
<hr>

<h2>Common Patterns</h2>

<h3>Pattern 1: Perspective Update</h3>

<pre><code class="language-csharp">public class OrderSummaryPerspective : IPerspectiveOf<OrderCreated> {
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>        await using var conn = _db.CreateConnection();</p>

<p>        await conn.ExecuteAsync(</p>
<p>            """</p>
<p>            INSERT INTO order_summaries (order_id, customer_id, total, status, created_at)</p>
<p>            VALUES (@OrderId, @CustomerId, @Total, @Status, @CreatedAt)</p>
<p>            ON CONFLICT (order_id) DO NOTHING</p>
<p>            """,</p>
<p>            new {</p>
<p>                @event.OrderId,</p>
<p>                @event.CustomerId,</p>
<p>                @event.Total,</p>
<p>                Status = "Created",</p>
<p>                @event.CreatedAt</p>
<p>            },</p>
<p>            cancellationToken: ct</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern 2: Lens Query</h3>

<pre><code class="language-csharp">public class OrderLens : ILensQuery {
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public async Task<OrderSummary[]> GetRecentOrdersAsync(</p>
<p>        int limit,</p>
<p>        CancellationToken ct = default) {</p>

<p>        await using var conn = _db.CreateConnection();</p>

<p>        var orders = await conn.QueryAsync<OrderSummary>(</p>
<p>            """</p>
<p>            SELECT * FROM order_summaries</p>
<p>            ORDER BY created_at DESC</p>
<p>            LIMIT @Limit</p>
<p>            """,</p>
<p>            new { Limit = limit },</p>
<p>            cancellationToken: ct</p>
<p>        );</p>

<p>        return orders.ToArray();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern 3: Aggregation</h3>

<pre><code class="language-csharp">public async Task<OrderStatistics> GetOrderStatisticsAsync(
<p>    Guid customerId,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    return await conn.QuerySingleAsync<OrderStatistics>(</p>
<p>        """</p>
<p>        SELECT</p>
<p>            COUNT(*) AS TotalOrders,</p>
<p>            SUM(total) AS TotalSpent,</p>
<p>            AVG(total) AS AverageOrderValue,</p>
<p>            MAX(created_at) AS LastOrderDate</p>
<p>        FROM order_summaries</p>
<p>        WHERE customer_id = @CustomerId</p>
<p>        """,</p>
<p>        new { CustomerId = customerId },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/perspectives.md">Perspectives</a> - Event-driven read models</li>
<li><a href="../core-concepts/lenses.md">Lenses</a> - Query repositories</li>
</ul>
<strong>Data Access</strong>:
<ul><li><a href="efcore-integration.md">EF Core Integration</a> - Full-featured ORM</li>
<li><a href="perspectives-storage.md">Perspectives Storage</a> - Read model schema design</li>
<li><a href="event-store.md">Event Store</a> - Event storage and replay</li>
</ul>
<strong>Examples</strong>:
<ul><li><a href="../examples/ecommerce/bff-pattern.md">ECommerce: BFF Perspectives</a> - Real-world Dapper usage</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-data-efcore-integration" class="doc-section">
  <h3>EF Core Integration</h3>
  <p class="doc-path"><code>v1.0.0/data/efcore-integration</code></p>
  <p class="doc-description"><em>Full-featured ORM with EF Core 10 for complex domain models - JSONB support, UUIDv7, migrations, and advanced querying</em></p>
  <div class="doc-content">

<h1>EF Core Integration</h1>

<strong>EF Core</strong> is a full-featured Object-Relational Mapper (ORM) for .NET, recommended for <strong>complex domain models</strong> and <strong>write operations</strong> in Whizbang applications. While Dapper excels at read models, EF Core provides rich modeling capabilities, change tracking, and migrations.

<h2>EF Core vs Dapper</h2>

<p>| Feature | EF Core | Dapper |</p>
<p>|---------|---------|--------|</p>
<p>| <strong>Best for</strong> | Write models, complex domain logic | Read models, simple queries |</p>
<p>| <strong>Performance</strong> | Slower (change tracking overhead) | ~20x faster for reads |</p>
<p>| <strong>Learning curve</strong> | Complex (LINQ, migrations, tracking) | Simple (just SQL) |</p>
<p>| <strong>Features</strong> | Migrations, change tracking, navigation properties | Direct SQL execution |</p>
<p>| <strong>Type safety</strong> | Full LINQ type safety | SQL string-based |</p>
<p>| <strong>Use in Whizbang</strong> | ✅ Domain aggregates, write operations | ✅ Perspectives, Lenses |</p>

<strong>Whizbang Philosophy</strong>: Use <strong>Dapper for reads</strong> (perspectives, lenses), <strong>EF Core for writes</strong> (domain models, commands).

<hr>

<h2>Installation</h2>

<pre><code class="language-bash">dotnet add package Whizbang.Data.EFCore.Postgres
<p></code></pre></p>

<strong>Includes</strong>:
<ul><li><code>WhizbangDbContext</code> - Base DbContext with conventions</li>
<li>EF Core 10.x (latest version)</li>
<li>Npgsql.EntityFrameworkCore.PostgreSQL (PostgreSQL provider)</li>
<li>Migration utilities</li>
</ul>
<strong>Additional Tools</strong> (for migrations):
<pre><code class="language-bash">dotnet tool install --global dotnet-ef
<p></code></pre></p>

<hr>

<h2>EF Core 10 Features</h2>

<h3>JSONB Column Support</h3>

<p>EF Core 10 has native <strong>JSONB</strong> support for PostgreSQL:</p>

<pre><code class="language-csharp">public class Product {
<p>    public Guid Id { get; set; }</p>
<p>    public string Name { get; set; } = default!;</p>

<p>    // Native JSONB column</p>
<p>    public ProductMetadata Metadata { get; set; } = default!;</p>
<p>}</p>

<p>public class ProductMetadata {</p>
<p>    public string Category { get; set; } = default!;</p>
<p>    public string[] Tags { get; set; } = Array.Empty<string>();</p>
<p>    public Dictionary<string, string> Attributes { get; set; } = new();</p>
<p>}</p>

<p>// DbContext configuration</p>
<p>protected override void OnModelCreating(ModelBuilder modelBuilder) {</p>
<p>    modelBuilder.Entity<Product>(entity => {</p>
<p>        entity.ToTable("products");</p>

<p>        // JSONB column (automatic in EF Core 10 for PostgreSQL)</p>
<p>        entity.OwnsOne(p => p.Metadata, owned => {</p>
<p>            owned.ToJson();  // Stores as JSONB</p>
<p>        });</p>
<p>    });</p>
<p>}</p>
<p></code></pre></p>

<strong>Query JSONB</strong>:
<pre><code class="language-csharp">// Query nested JSONB properties
<p>var products = await context.Products</p>
<p>    .Where(p => p.Metadata.Category == "Electronics")</p>
<p>    .ToListAsync();</p>

<p>// Query JSONB array contains</p>
<p>var products = await context.Products</p>
<p>    .Where(p => p.Metadata.Tags.Contains("featured"))</p>
<p>    .ToListAsync();</p>
<p></code></pre></p>

<h3>UUIDv7 Support</h3>

<p>EF Core 10 with Npgsql supports <strong>UUIDv7</strong> (time-ordered GUIDs):</p>

<pre><code class="language-csharp">public class Order {
<p>    public Guid Id { get; set; }  // Will be UUIDv7</p>
<p>    public Guid CustomerId { get; set; }</p>
<p>    public DateTimeOffset CreatedAt { get; set; }</p>
<p>}</p>

<p>// DbContext configuration</p>
<p>protected override void OnModelCreating(ModelBuilder modelBuilder) {</p>
<p>    modelBuilder.Entity<Order>(entity => {</p>
<p>        entity.ToTable("orders");</p>

<p>        entity.Property(e => e.Id)</p>
<p>            .HasDefaultValueSql("uuid_generate_v7()")  // PostgreSQL function</p>
<p>            .ValueGeneratedOnAdd();</p>

<p>        entity.Property(e => e.CreatedAt)</p>
<p>            .HasDefaultValueSql("NOW()");</p>
<p>    });</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>Time-ordered: Natural chronological sorting</li>
<li>Database-friendly: Sequential inserts, no index fragmentation</li>
<li>Timestamp embedded: Extract creation time from ID</li>
</ul>
<h3>Complex Types</h3>

<p>EF Core 10 supports <strong>complex types</strong> (value objects without separate tables):</p>

<pre><code class="language-csharp">public class Order {
<p>    public Guid Id { get; set; }</p>
<p>    public Money Total { get; set; }  // Complex type</p>
<p>    public Address ShippingAddress { get; set; }  // Complex type</p>
<p>}</p>

<p>[ComplexType]</p>
<p>public record Money(decimal Amount, string Currency);</p>

<p>[ComplexType]</p>
<p>public record Address(</p>
<p>    string Street,</p>
<p>    string City,</p>
<p>    string State,</p>
<p>    string PostalCode</p>
<p>);</p>

<p>// DbContext configuration</p>
<p>protected override void OnModelCreating(ModelBuilder modelBuilder) {</p>
<p>    modelBuilder.Entity<Order>(entity => {</p>
<p>        // Complex types map to columns: total_amount, total_currency</p>
<p>        entity.ComplexProperty(e => e.Total);</p>

<p>        // Maps to: address_street, address_city, address_state, address_postal_code</p>
<p>        entity.ComplexProperty(e => e.ShippingAddress);</p>
<p>    });</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>DbContext Setup</h2>

<h3>Basic Configuration</h3>

<pre><code class="language-csharp">public class ECommerceDbContext : DbContext {
<p>    public ECommerceDbContext(DbContextOptions<ECommerceDbContext> options)</p>
<p>        : base(options) {</p>
<p>    }</p>

<p>    public DbSet<Order> Orders => Set<Order>();</p>
<p>    public DbSet<Customer> Customers => Set<Customer>();</p>
<p>    public DbSet<Product> Products => Set<Product>();</p>

<p>    protected override void OnModelCreating(ModelBuilder modelBuilder) {</p>
<p>        base.OnModelCreating(modelBuilder);</p>

<p>        // Apply configurations</p>
<p>        modelBuilder.ApplyConfigurationsFromAssembly(typeof(ECommerceDbContext).Assembly);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Entity Type Configuration</h3>

<pre><code class="language-csharp">public class OrderConfiguration : IEntityTypeConfiguration<Order> {
<p>    public void Configure(EntityTypeBuilder<Order> builder) {</p>
<p>        builder.ToTable("orders");</p>

<p>        builder.HasKey(e => e.Id);</p>

<p>        builder.Property(e => e.Id)</p>
<p>            .HasDefaultValueSql("uuid_generate_v7()")</p>
<p>            .ValueGeneratedOnAdd();</p>

<p>        builder.Property(e => e.CustomerId)</p>
<p>            .IsRequired();</p>

<p>        builder.Property(e => e.Status)</p>
<p>            .HasMaxLength(50)</p>
<p>            .IsRequired();</p>

<p>        builder.Property(e => e.Total)</p>
<p>            .HasPrecision(18, 2)  // decimal(18,2)</p>
<p>            .IsRequired();</p>

<p>        builder.Property(e => e.CreatedAt)</p>
<p>            .HasDefaultValueSql("NOW()")</p>
<p>            .ValueGeneratedOnAdd();</p>

<p>        // Navigation properties</p>
<p>        builder.HasOne(e => e.Customer)</p>
<p>            .WithMany(c => c.Orders)</p>
<p>            .HasForeignKey(e => e.CustomerId)</p>
<p>            .OnDelete(DeleteBehavior.Restrict);</p>

<p>        builder.HasMany(e => e.Items)</p>
<p>            .WithOne()</p>
<p>            .HasForeignKey("OrderId")</p>
<p>            .OnDelete(DeleteBehavior.Cascade);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Registration (Program.cs)</h3>

<pre><code class="language-csharp">var connectionString = builder.Configuration.GetConnectionString("DefaultConnection")!;

<p>builder.Services.AddDbContext<ECommerceDbContext>(options => {</p>
<p>    options.UseNpgsql(connectionString, npgsqlOptions => {</p>
<p>        npgsqlOptions.MigrationsAssembly("ECommerce.Infrastructure");</p>
<p>        npgsqlOptions.UseQuerySplittingBehavior(QuerySplittingBehavior.SplitQuery);</p>
<p>    });</p>

<p>    // Development settings</p>
<p>    if (builder.Environment.IsDevelopment()) {</p>
<p>        options.EnableSensitiveDataLogging();</p>
<p>        options.EnableDetailedErrors();</p>
<p>    }</p>
<p>});</p>
<p></code></pre></p>

<hr>

<h2>Migrations</h2>

<h3>Creating Migrations</h3>

<pre><code class="language-bash"># Add new migration
<p>dotnet ef migrations add InitialCreate --project src/ECommerce.Infrastructure --startup-project src/ECommerce.API</p>

<h1>Apply migrations to database</h1>
<p>dotnet ef database update --project src/ECommerce.Infrastructure --startup-project src/ECommerce.API</p>

<h1>Remove last migration (if not applied)</h1>
<p>dotnet ef migrations remove --project src/ECommerce.Infrastructure --startup-project src/ECommerce.API</p>

<h1>List all migrations</h1>
<p>dotnet ef migrations list --project src/ECommerce.Infrastructure --startup-project src/ECommerce.API</p>
<p></code></pre></p>

<h3>Migration Example</h3>

<pre><code class="language-csharp">public partial class InitialCreate : Migration {
<p>    protected override void Up(MigrationBuilder migrationBuilder) {</p>
<p>        // Enable UUIDv7 extension</p>
<p>        migrationBuilder.Sql("CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";");</p>

<p>        migrationBuilder.CreateTable(</p>
<p>            name: "orders",</p>
<p>            columns: table => new {</p>
<p>                id = table.Column<Guid>(nullable: false, defaultValueSql: "uuid_generate_v7()"),</p>
<p>                customer_id = table.Column<Guid>(nullable: false),</p>
<p>                total = table.Column<decimal>(type: "decimal(18,2)", nullable: false),</p>
<p>                status = table.Column<string>(maxLength: 50, nullable: false),</p>
<p>                created_at = table.Column<DateTimeOffset>(nullable: false, defaultValueSql: "NOW()")</p>
<p>            },</p>
<p>            constraints: table => {</p>
<p>                table.PrimaryKey("pk_orders", x => x.id);</p>
<p>            }</p>
<p>        );</p>

<p>        migrationBuilder.CreateIndex(</p>
<p>            name: "ix_orders_customer_id",</p>
<p>            table: "orders",</p>
<p>            column: "customer_id"</p>
<p>        );</p>

<p>        migrationBuilder.CreateIndex(</p>
<p>            name: "ix_orders_created_at",</p>
<p>            table: "orders",</p>
<p>            column: "created_at"</p>
<p>        );</p>
<p>    }</p>

<p>    protected override void Down(MigrationBuilder migrationBuilder) {</p>
<p>        migrationBuilder.DropTable(name: "orders");</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Apply Migrations at Startup</h3>

<pre><code class="language-csharp">// Program.cs - Apply migrations on startup (Development only)
<p>if (app.Environment.IsDevelopment()) {</p>
<p>    using var scope = app.Services.CreateScope();</p>
<p>    var context = scope.ServiceProvider.GetRequiredService<ECommerceDbContext>();</p>
<p>    await context.Database.MigrateAsync();  // Apply pending migrations</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Basic Usage</h2>

<h3>Insert</h3>

<pre><code class="language-csharp">public class OrderService {
<p>    private readonly ECommerceDbContext _context;</p>

<p>    public async Task<Order> CreateOrderAsync(</p>
<p>        Guid customerId,</p>
<p>        OrderItem[] items,</p>
<p>        CancellationToken ct = default) {</p>

<p>        var order = new Order {</p>
<p>            CustomerId = customerId,</p>
<p>            Status = "Created",</p>
<p>            Total = items.Sum(i => i.UnitPrice * i.Quantity),</p>
<p>            CreatedAt = DateTimeOffset.UtcNow</p>
<p>        };</p>

<p>        // Add order items</p>
<p>        foreach (var item in items) {</p>
<p>            order.Items.Add(new OrderItem {</p>
<p>                ProductId = item.ProductId,</p>
<p>                Quantity = item.Quantity,</p>
<p>                UnitPrice = item.UnitPrice</p>
<p>            });</p>
<p>        }</p>

<p>        _context.Orders.Add(order);</p>
<p>        await _context.SaveChangesAsync(ct);</p>

<p>        return order;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Query</h3>

<pre><code class="language-csharp">public async Task<Order?> GetOrderAsync(
<p>    Guid orderId,</p>
<p>    CancellationToken ct = default) {</p>

<p>    return await _context.Orders</p>
<p>        .Include(o => o.Items)  // Eager load items</p>
<p>        .Include(o => o.Customer)  // Eager load customer</p>
<p>        .FirstOrDefaultAsync(o => o.Id == orderId, ct);</p>
<p>}</p>

<p>public async Task<Order[]> GetOrdersByCustomerAsync(</p>
<p>    Guid customerId,</p>
<p>    CancellationToken ct = default) {</p>

<p>    return await _context.Orders</p>
<p>        .Where(o => o.CustomerId == customerId)</p>
<p>        .OrderByDescending(o => o.CreatedAt)</p>
<p>        .ToArrayAsync(ct);</p>
<p>}</p>
<p></code></pre></p>

<h3>Update</h3>

<pre><code class="language-csharp">public async Task UpdateOrderStatusAsync(
<p>    Guid orderId,</p>
<p>    string newStatus,</p>
<p>    CancellationToken ct = default) {</p>

<p>    var order = await _context.Orders</p>
<p>        .FirstOrDefaultAsync(o => o.Id == orderId, ct);</p>

<p>    if (order is null) {</p>
<p>        throw new NotFoundException($"Order {orderId} not found");</p>
<p>    }</p>

<p>    order.Status = newStatus;</p>
<p>    order.UpdatedAt = DateTimeOffset.UtcNow;</p>

<p>    await _context.SaveChangesAsync(ct);</p>
<p>}</p>
<p></code></pre></p>

<h3>Delete</h3>

<pre><code class="language-csharp">public async Task DeleteOrderAsync(
<p>    Guid orderId,</p>
<p>    CancellationToken ct = default) {</p>

<p>    var order = await _context.Orders</p>
<p>        .FirstOrDefaultAsync(o => o.Id == orderId, ct);</p>

<p>    if (order is not null) {</p>
<p>        _context.Orders.Remove(order);</p>
<p>        await _context.SaveChangesAsync(ct);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Advanced Querying</h2>

<h3>Pagination</h3>

<pre><code class="language-csharp">public async Task<PagedResult<Order>> GetOrdersPagedAsync(
<p>    int pageNumber,</p>
<p>    int pageSize,</p>
<p>    CancellationToken ct = default) {</p>

<p>    var query = _context.Orders</p>
<p>        .OrderByDescending(o => o.CreatedAt);</p>

<p>    var total = await query.CountAsync(ct);</p>

<p>    var orders = await query</p>
<p>        .Skip((pageNumber - 1) * pageSize)</p>
<p>        .Take(pageSize)</p>
<p>        .ToArrayAsync(ct);</p>

<p>    return new PagedResult<Order> {</p>
<p>        Items = orders,</p>
<p>        TotalCount = total,</p>
<p>        PageNumber = pageNumber,</p>
<p>        PageSize = pageSize</p>
<p>    };</p>
<p>}</p>
<p></code></pre></p>

<h3>Search</h3>

<pre><code class="language-csharp">public async Task<Order[]> SearchOrdersAsync(
<p>    string searchTerm,</p>
<p>    CancellationToken ct = default) {</p>

<p>    return await _context.Orders</p>
<p>        .Include(o => o.Customer)</p>
<p>        .Where(o =></p>
<p>            o.Id.ToString().Contains(searchTerm) ||</p>
<p>            o.Customer.Name.Contains(searchTerm) ||</p>
<p>            o.Customer.Email.Contains(searchTerm)</p>
<p>        )</p>
<p>        .OrderByDescending(o => o.CreatedAt)</p>
<p>        .Take(100)</p>
<p>        .ToArrayAsync(ct);</p>
<p>}</p>
<p></code></pre></p>

<h3>Aggregations</h3>

<pre><code class="language-csharp">public async Task<OrderStatistics> GetOrderStatisticsAsync(
<p>    Guid customerId,</p>
<p>    CancellationToken ct = default) {</p>

<p>    var stats = await _context.Orders</p>
<p>        .Where(o => o.CustomerId == customerId)</p>
<p>        .GroupBy(o => o.CustomerId)</p>
<p>        .Select(g => new OrderStatistics {</p>
<p>            TotalOrders = g.Count(),</p>
<p>            TotalSpent = g.Sum(o => o.Total),</p>
<p>            AverageOrderValue = g.Average(o => o.Total),</p>
<p>            LastOrderDate = g.Max(o => o.CreatedAt)</p>
<p>        })</p>
<p>        .FirstOrDefaultAsync(ct);</p>

<p>    return stats ?? new OrderStatistics();</p>
<p>}</p>
<p></code></pre></p>

<h3>Raw SQL Queries</h3>

<pre><code class="language-csharp">public async Task<OrderSummary[]> GetTopCustomersAsync(
<p>    int limit,</p>
<p>    CancellationToken ct = default) {</p>

<p>    return await _context.Database</p>
<p>        .SqlQuery<OrderSummary>($"""</p>
<p>            SELECT</p>
<p>                customer_id AS CustomerId,</p>
<p>                COUNT(*) AS TotalOrders,</p>
<p>                SUM(total) AS TotalSpent</p>
<p>            FROM orders</p>
<p>            GROUP BY customer_id</p>
<p>            ORDER BY SUM(total) DESC</p>
<p>            LIMIT {limit}</p>
<p>        """)</p>
<p>        .ToArrayAsync(ct);</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Transactions</h2>

<h3>Explicit Transactions</h3>

<pre><code class="language-csharp">public async Task TransferInventoryAsync(
<p>    Guid fromWarehouseId,</p>
<p>    Guid toWarehouseId,</p>
<p>    Guid productId,</p>
<p>    int quantity,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var transaction = await _context.Database.BeginTransactionAsync(ct);</p>

<p>    try {</p>
<p>        // Deduct from source warehouse</p>
<p>        var fromInventory = await _context.Inventory</p>
<p>            .FirstAsync(i => i.WarehouseId == fromWarehouseId && i.ProductId == productId, ct);</p>

<p>        fromInventory.Available -= quantity;</p>

<p>        // Add to destination warehouse</p>
<p>        var toInventory = await _context.Inventory</p>
<p>            .FirstAsync(i => i.WarehouseId == toWarehouseId && i.ProductId == productId, ct);</p>

<p>        toInventory.Available += quantity;</p>

<p>        await _context.SaveChangesAsync(ct);</p>
<p>        await transaction.CommitAsync(ct);</p>

<p>    } catch {</p>
<p>        await transaction.RollbackAsync(ct);</p>
<p>        throw;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Implicit Transactions</h3>

<pre><code class="language-csharp">// SaveChangesAsync wraps all changes in a transaction automatically
<p>public async Task CreateOrderWithItemsAsync(</p>
<p>    Order order,</p>
<p>    OrderItem[] items,</p>
<p>    CancellationToken ct = default) {</p>

<p>    _context.Orders.Add(order);</p>

<p>    foreach (var item in items) {</p>
<p>        order.Items.Add(item);  // EF tracks relationship</p>
<p>    }</p>

<p>    await _context.SaveChangesAsync(ct);  // ← Atomic transaction</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Change Tracking</h2>

<h3>No-Tracking Queries</h3>

<p>Use <code>.AsNoTracking()</code> for read-only queries (better performance):</p>

<pre><code class="language-csharp">// ✅ Read-only query (no change tracking overhead)
<p>public async Task<Order[]> GetOrdersForDisplayAsync(CancellationToken ct = default) {</p>
<p>    return await _context.Orders</p>
<p>        .AsNoTracking()  // ← No change tracking!</p>
<p>        .Include(o => o.Items)</p>
<p>        .ToArrayAsync(ct);</p>
<p>}</p>

<p>// ❌ Change tracking enabled (slower)</p>
<p>public async Task<Order[]> GetOrdersAsync(CancellationToken ct = default) {</p>
<p>    return await _context.Orders</p>
<p>        .Include(o => o.Items)</p>
<p>        .ToArrayAsync(ct);  // EF tracks all entities for changes</p>
<p>}</p>
<p></code></pre></p>

<h3>Tracking State</h3>

<pre><code class="language-csharp">public void DemoTrackingStates() {
<p>    var order = new Order { /<em> ... </em>/ };</p>

<p>    // EntityState.Detached (not tracked)</p>
<p>    Console.WriteLine(_context.Entry(order).State);  // Detached</p>

<p>    _context.Orders.Add(order);</p>
<p>    // EntityState.Added (will INSERT on SaveChanges)</p>
<p>    Console.WriteLine(_context.Entry(order).State);  // Added</p>

<p>    _context.SaveChanges();</p>
<p>    // EntityState.Unchanged (no pending changes)</p>
<p>    Console.WriteLine(_context.Entry(order).State);  // Unchanged</p>

<p>    order.Status = "Shipped";</p>
<p>    // EntityState.Modified (will UPDATE on SaveChanges)</p>
<p>    Console.WriteLine(_context.Entry(order).State);  // Modified</p>

<p>    _context.Orders.Remove(order);</p>
<p>    // EntityState.Deleted (will DELETE on SaveChanges)</p>
<p>    Console.WriteLine(_context.Entry(order).State);  // Deleted</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Performance Patterns</h2>

<h3>Split Queries</h3>

<pre><code class="language-csharp">// ✅ Split query (multiple queries, better for large data)
<p>var orders = await _context.Orders</p>
<p>    .Include(o => o.Items)</p>
<p>    .Include(o => o.Customer)</p>
<p>    .AsSplitQuery()  // ← Executes 3 queries (orders, items, customers)</p>
<p>    .ToListAsync();</p>

<p>// ❌ Single query (cartesian explosion for large data)</p>
<p>var orders = await _context.Orders</p>
<p>    .Include(o => o.Items)</p>
<p>    .Include(o => o.Customer)</p>
<p>    .AsSingleQuery()  // ← Executes 1 query with JOINs</p>
<p>    .ToListAsync();</p>
<p></code></pre></p>

<strong>When to use</strong>:
<ul><li><strong>Split Query</strong>: Multiple includes, large result sets</li>
<li><strong>Single Query</strong>: Few includes, small result sets</li>
</ul>
<h3>Batch Operations</h3>

<pre><code class="language-csharp">// ✅ Batch insert (single SaveChanges)
<p>public async Task BulkInsertOrdersAsync(Order[] orders, CancellationToken ct = default) {</p>
<p>    _context.Orders.AddRange(orders);</p>
<p>    await _context.SaveChangesAsync(ct);  // Single database roundtrip</p>
<p>}</p>

<p>// ❌ Loop insert (multiple SaveChanges)</p>
<p>public async Task SlowInsertOrdersAsync(Order[] orders, CancellationToken ct = default) {</p>
<p>    foreach (var order in orders) {</p>
<p>        _context.Orders.Add(order);</p>
<p>        await _context.SaveChangesAsync(ct);  // N database roundtrips!</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Compiled Queries</h3>

<pre><code class="language-csharp">// Compiled query (cached expression tree)
<p>private static readonly Func<ECommerceDbContext, Guid, Task<Order?>> GetOrderByIdQuery =</p>
<p>    EF.CompileAsyncQuery(</p>
<p>        (ECommerceDbContext context, Guid orderId) =></p>
<p>            context.Orders</p>
<p>                .Include(o => o.Items)</p>
<p>                .FirstOrDefault(o => o.Id == orderId)</p>
<p>    );</p>

<p>public async Task<Order?> GetOrderFastAsync(Guid orderId) {</p>
<p>    return await GetOrderByIdQuery(_context, orderId);</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefit</strong>: Expression tree compiled once, reused on every call.

<hr>

<h2>Testing</h2>

<h3>In-Memory Provider</h3>

<pre><code class="language-csharp">public class OrderServiceTests {
<p>    private ECommerceDbContext CreateInMemoryContext() {</p>
<p>        var options = new DbContextOptionsBuilder<ECommerceDbContext>()</p>
<p>            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())</p>
<p>            .Options;</p>

<p>        return new ECommerceDbContext(options);</p>
<p>    }</p>

<p>    [Test]</p>
<p>    public async Task CreateOrderAsync_ValidOrder_CreatesOrderAsync() {</p>
<p>        // Arrange</p>
<p>        await using var context = CreateInMemoryContext();</p>
<p>        var service = new OrderService(context);</p>

<p>        var items = new[] {</p>
<p>            new OrderItem { ProductId = Guid.NewGuid(), Quantity = 2, UnitPrice = 10.00m }</p>
<p>        };</p>

<p>        // Act</p>
<p>        var order = await service.CreateOrderAsync(Guid.NewGuid(), items);</p>

<p>        // Assert</p>
<p>        await Assert.That(order.Id).IsNotEqualTo(Guid.Empty);</p>
<p>        await Assert.That(order.Items).HasCount().EqualTo(1);</p>
<p>        await Assert.That(context.Orders).HasCount().EqualTo(1);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>SQLite Provider (Better for Testing)</h3>

<pre><code class="language-csharp">public class OrderServiceTests {
<p>    private ECommerceDbContext CreateSqliteContext() {</p>
<p>        var connection = new SqliteConnection("DataSource=:memory:");</p>
<p>        connection.Open();</p>

<p>        var options = new DbContextOptionsBuilder<ECommerceDbContext>()</p>
<p>            .UseSqlite(connection)</p>
<p>            .Options;</p>

<p>        var context = new ECommerceDbContext(options);</p>
<p>        context.Database.EnsureCreated();  // Create schema</p>

<p>        return context;</p>
<p>    }</p>

<p>    [Test]</p>
<p>    public async Task GetOrderAsync_ExistingOrder_ReturnsOrderAsync() {</p>
<p>        // Arrange</p>
<p>        await using var context = CreateSqliteContext();</p>

<p>        var order = new Order {</p>
<p>            Id = Guid.NewGuid(),</p>
<p>            CustomerId = Guid.NewGuid(),</p>
<p>            Status = "Created",</p>
<p>            Total = 100.00m,</p>
<p>            CreatedAt = DateTimeOffset.UtcNow</p>
<p>        };</p>

<p>        context.Orders.Add(order);</p>
<p>        await context.SaveChangesAsync();</p>

<p>        var service = new OrderService(context);</p>

<p>        // Act</p>
<p>        var result = await service.GetOrderAsync(order.Id);</p>

<p>        // Assert</p>
<p>        await Assert.That(result).IsNotNull();</p>
<p>        await Assert.That(result!.Id).IsEqualTo(order.Id);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Why SQLite?</strong> More accurate for testing (real SQL, constraints, indexes).

<h3>Integration Tests with PostgreSQL</h3>

<pre><code class="language-csharp">public class OrderServiceIntegrationTests {
<p>    private ECommerceDbContext _context = default!;</p>

<p>    [Before(Test)]</p>
<p>    public async Task SetupAsync() {</p>
<p>        var connectionString = "Host=localhost;Database=whizbang_test;Username=postgres;Password=test";</p>

<p>        var options = new DbContextOptionsBuilder<ECommerceDbContext>()</p>
<p>            .UseNpgsql(connectionString)</p>
<p>            .Options;</p>

<p>        _context = new ECommerceDbContext(options);</p>

<p>        // Recreate database for clean slate</p>
<p>        await _context.Database.EnsureDeletedAsync();</p>
<p>        await _context.Database.EnsureCreatedAsync();</p>
<p>    }</p>

<p>    [After(Test)]</p>
<p>    public async Task TeardownAsync() {</p>
<p>        await _context.DisposeAsync();</p>
<p>    }</p>

<p>    [Test]</p>
<p>    public async Task CreateOrderAsync_WithRealDatabase_PersistsOrderAsync() {</p>
<p>        // Arrange</p>
<p>        var service = new OrderService(_context);</p>

<p>        var items = new[] {</p>
<p>            new OrderItem { ProductId = Guid.NewGuid(), Quantity = 2, UnitPrice = 10.00m }</p>
<p>        };</p>

<p>        // Act</p>
<p>        var order = await service.CreateOrderAsync(Guid.NewGuid(), items);</p>

<p>        // Assert</p>
<p>        await Assert.That(order.Id).IsNotEqualTo(Guid.Empty);</p>

<p>        // Verify in database</p>
<p>        var savedOrder = await _context.Orders</p>
<p>            .Include(o => o.Items)</p>
<p>            .FirstOrDefaultAsync(o => o.Id == order.Id);</p>

<p>        await Assert.That(savedOrder).IsNotNull();</p>
<p>        await Assert.That(savedOrder!.Items).HasCount().EqualTo(1);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Native AOT Support</h2>

<p>:::new</p>
<p>Whizbang's EF Core integration is <strong>fully AOT-compatible</strong> with zero reflection. The schema generation system uses source generators to pre-generate all SQL at build time.</p>
<p>:::</p>

<strong>Whizbang EF Core</strong> is designed for Native AOT compilation from the ground up:
<ul><li>✅ <strong>Zero Reflection</strong>: All schema SQL pre-generated at build time</li>
<li>✅ <strong>Embedded Resources</strong>: Core infrastructure schema shipped as embedded SQL</li>
<li>✅ <strong>Source Generators</strong>: Perspective tables generated from discovered types</li>
<li>✅ <strong>No IL3050 Warnings</strong>: Fully compatible with <code>PublishAot=true</code></li>
</ul>
<h3>How It Works</h3>

<p>When you build your application, the <strong>EF Core source generator</strong> runs automatically and:</p>

<ul><li><strong>Embeds Core Infrastructure Schema</strong> - Reads pre-generated SQL from embedded resources (9 core tables: service_instances, message_deduplication, inbox, outbox, event_store, receptor_processing, perspective_checkpoints, request_response, sequences)</li>
</ul>
<ul><li><strong>Discovers Perspective Tables</strong> - Scans your DbContext for <code>PerspectiveRow<TModel></code> properties and generates DDL at build time</li>
</ul>
<ul><li><strong>Bundles Migration Scripts</strong> - Embeds all PostgreSQL functions and migration SQL as string constants</li>
</ul>
<ul><li><strong>Generates Extension Methods</strong> - Creates <code>EnsureWhizbangDatabaseInitializedAsync()</code> that uses only <code>ExecuteSqlRawAsync()</code> (AOT-safe)</li>
</ul>
<h3>Schema Initialization</h3>

<p>Initialize your database schema with a single call:</p>

<pre><code class="language-csharp">public class Program {
<p>    public static async Task Main(string[] args) {</p>
<p>        var builder = WebApplication.CreateBuilder(args);</p>

<p>        // Register DbContext</p>
<p>        builder.Services.AddDbContext<OrderDbContext>(options => {</p>
<p>            options.UseNpgsql(connectionString);</p>
<p>        });</p>

<p>        var app = builder.Build();</p>

<p>        // Initialize Whizbang database schema (AOT-compatible!)</p>
<p>        using var scope = app.Services.CreateScope();</p>
<p>        var dbContext = scope.ServiceProvider.GetRequiredService<OrderDbContext>();</p>
<p>        await dbContext.EnsureWhizbangDatabaseInitializedAsync();</p>

<p>        await app.RunAsync();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>What <code>EnsureWhizbangDatabaseInitializedAsync()</code> does</strong>:
<ul><li>Creates core infrastructure tables (9 tables)</li>
<li>Creates perspective tables (one per <code>PerspectiveRow<TModel></code> in your DbContext)</li>
<li>Applies PostgreSQL functions and migrations</li>
<li>All operations are <strong>idempotent</strong> (safe to call multiple times)</li>
</ul>
<h3>Generated Code Example</h3>

<p>When you build your project, the source generator creates this extension method:</p>

<pre><code class="language-csharp">// Auto-generated: OrderDbContext_SchemaExtensions.g.cs
<p>public static partial class OrderDbContextSchemaExtensions {</p>
<p>    public static async Task EnsureWhizbangDatabaseInitializedAsync(</p>
<p>        this OrderDbContext dbContext,</p>
<p>        ILogger? logger = null,</p>
<p>        CancellationToken cancellationToken = default) {</p>

<p>        // Step 1: Execute core infrastructure schema (embedded resource)</p>
<p>        await ExecuteCoreInfrastructureSchemaAsync(dbContext, logger, cancellationToken);</p>

<p>        // Step 2: Execute perspective tables (generated at build time)</p>
<p>        await ExecutePerspectiveTablesAsync(dbContext, logger, cancellationToken);</p>

<p>        // Step 3: Execute PostgreSQL functions (embedded migrations)</p>
<p>        await ExecuteMigrationsAsync(dbContext, logger, cancellationToken);</p>
<p>    }</p>

<p>    private static async Task ExecuteCoreInfrastructureSchemaAsync(...) {</p>
<p>        // Pre-generated SQL from PostgresSchemaBuilder (5,327 bytes)</p>
<p>        const string CoreInfrastructureSchema = @"</p>
<p>            CREATE TABLE IF NOT EXISTS wh_service_instances (...);</p>
<p>            CREATE TABLE IF NOT EXISTS wh_message_deduplication (...);</p>
<p>            -- ... all 9 tables</p>
<p>        ";</p>

<p>        await dbContext.Database.ExecuteSqlRawAsync(</p>
<p>            CoreInfrastructureSchema,</p>
<p>            cancellationToken</p>
<p>        );</p>
<p>    }</p>

<p>    private static async Task ExecutePerspectiveTablesAsync(...) {</p>
<p>        // Generated from discovered PerspectiveRow<TModel> types</p>
<p>        const string PerspectiveTablesSchema = @"</p>
<p>            CREATE TABLE IF NOT EXISTS wh_per_order (</p>
<p>                stream_id UUID NOT NULL PRIMARY KEY,</p>
<p>                data JSONB NOT NULL,</p>
<p>                version BIGINT NOT NULL,</p>
<p>                updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP</p>
<p>            );</p>
<p>            -- ... one per perspective</p>
<p>        ";</p>

<p>        await dbContext.Database.ExecuteSqlRawAsync(</p>
<p>            PerspectiveTablesSchema,</p>
<p>            cancellationToken</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Publishing with AOT</h3>

<p>Enable Native AOT in your <code>.csproj</code>:</p>

<pre><code class="language-xml"><Project Sdk="Microsoft.NET.Sdk.Web">
<p>  <PropertyGroup></p>
<p>    <TargetFramework>net10.0</TargetFramework></p>
<p>    <PublishAot>true</PublishAot></p>
<p>  </PropertyGroup></p>
<p></Project></p>
<p></code></pre></p>

<p>Build and publish:</p>

<pre><code class="language-bash">dotnet publish -c Release -r linux-x64
<p></code></pre></p>

<strong>Result</strong>: Self-contained executable with no reflection, fast startup, and minimal memory footprint.

<h3>Benefits of AOT Schema Generation</h3>

<p>| Benefit | Description |</p>
<p>|---------|-------------|</p>
<p>| <strong>Zero Reflection</strong> | No <code>GenerateCreateScript()</code> calls - all SQL pre-generated |</p>
<p>| <strong>Fast Startup</strong> | No runtime schema inspection or compilation |</p>
<p>| <strong>Predictable</strong> | Schema SQL version-controlled and visible in generated code |</p>
<p>| <strong>Debuggable</strong> | View exact SQL being executed in <code>*.g.cs</code> files |</p>
<p>| <strong>Portable</strong> | No .NET SDK required in production |</p>

<hr>

<h2>EF Core vs Dapper: When to Use What</h2>

<h3>Use EF Core When:</h3>

<ul><li>✅ <strong>Write operations</strong> (commands, domain logic)</li>
<li>✅ <strong>Complex domain models</strong> with rich relationships</li>
<li>✅ <strong>Change tracking</strong> needed (detecting modifications)</li>
<li>✅ <strong>Navigation properties</strong> simplify code</li>
<li>✅ <strong>Migrations</strong> for schema evolution</li>
<li>✅ <strong>Type-safe queries</strong> via LINQ</li>
</ul>
<h3>Use Dapper When:</h3>

<ul><li>✅ <strong>Read operations</strong> (perspectives, lenses)</li>
<li>✅ <strong>High performance</strong> required (~20x faster than EF Core)</li>
<li>✅ <strong>Simple queries</strong> without complex relationships</li>
<li>✅ <strong>SQL control</strong> needed (optimization, PostgreSQL-specific features)</li>
<li>✅ <strong>Denormalized read models</strong> (no navigation properties)</li>
</ul>
<h3>Hybrid Approach (Recommended)</h3>

<pre><code class="language-csharp">// ✅ EF Core for write model (domain aggregates)
<p>public class OrderService {</p>
<p>    private readonly ECommerceDbContext _context;</p>

<p>    public async Task<Order> CreateOrderAsync(CreateOrderCommand cmd) {</p>
<p>        var order = new Order(cmd.CustomerId, cmd.Items);</p>
<p>        _context.Orders.Add(order);</p>
<p>        await _context.SaveChangesAsync();</p>
<p>        return order;</p>
<p>    }</p>
<p>}</p>

<p>// ✅ Dapper for read model (perspectives/lenses)</p>
<p>public class OrderLens : ILensQuery {</p>
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public async Task<OrderSummary[]> GetRecentOrdersAsync(int limit) {</p>
<p>        await using var conn = _db.CreateConnection();</p>

<p>        var orders = await conn.QueryAsync<OrderSummary>(</p>
<p>            "SELECT * FROM order_summaries ORDER BY created_at DESC LIMIT @Limit",</p>
<p>            new { Limit = limit }</p>
<p>        );</p>

<p>        return orders.ToArray();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ Use <strong>DbContext per request</strong> (scoped lifetime)</li>
<li>✅ Use <strong>AsNoTracking()</strong> for read-only queries</li>
<li>✅ Use <strong>AsSplitQuery()</strong> for multiple includes</li>
<li>✅ Use <strong>migrations</strong> for schema changes</li>
<li>✅ Use <strong>IEntityTypeConfiguration</strong> for entity config</li>
<li>✅ Use <strong>UUIDv7</strong> for primary keys</li>
<li>✅ Use <strong>JSONB</strong> for complex nested data</li>
<li>✅ Use <strong>complex types</strong> for value objects</li>
<li>✅ Use <strong>compiled queries</strong> for hot paths</li>
<li>✅ Use <strong>batch operations</strong> (AddRange, RemoveRange)</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Reuse DbContext across requests (not thread-safe)</li>
<li>❌ Use change tracking for read-only queries</li>
<li>❌ Use EF Core for high-performance read models (use Dapper)</li>
<li>❌ Manually write SQL migrations (use <code>dotnet ef migrations add</code>)</li>
<li>❌ Use <code>Guid.NewGuid()</code> for primary keys (use UUIDv7)</li>
<li>❌ Call SaveChanges() in loops (batch instead)</li>
<li>❌ Use Include() for every query (consider projections)</li>
<li>❌ Ignore N+1 query problems (use Include or SplitQuery)</li>
</ul>
<hr>

<h2>Common Patterns</h2>

<h3>Pattern 1: Command Handler with EF Core</h3>

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>    private readonly ECommerceDbContext _context;</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        var order = new Order {</p>
<p>            CustomerId = message.CustomerId,</p>
<p>            Status = "Created",</p>
<p>            Total = message.Items.Sum(i => i.UnitPrice * i.Quantity),</p>
<p>            CreatedAt = DateTimeOffset.UtcNow</p>
<p>        };</p>

<p>        foreach (var item in message.Items) {</p>
<p>            order.Items.Add(new OrderItem {</p>
<p>                ProductId = item.ProductId,</p>
<p>                Quantity = item.Quantity,</p>
<p>                UnitPrice = item.UnitPrice</p>
<p>            });</p>
<p>        }</p>

<p>        _context.Orders.Add(order);</p>
<p>        await _context.SaveChangesAsync(ct);</p>

<p>        return new OrderCreated(</p>
<p>            OrderId: order.Id,</p>
<p>            CustomerId: order.CustomerId,</p>
<p>            Total: order.Total,</p>
<p>            CreatedAt: order.CreatedAt</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern 2: Query with Projection</h3>

<pre><code class="language-csharp">public async Task<OrderListItem[]> GetOrderListAsync(
<p>    Guid customerId,</p>
<p>    CancellationToken ct = default) {</p>

<p>    return await _context.Orders</p>
<p>        .Where(o => o.CustomerId == customerId)</p>
<p>        .OrderByDescending(o => o.CreatedAt)</p>
<p>        .Select(o => new OrderListItem {</p>
<p>            OrderId = o.Id,</p>
<p>            Total = o.Total,</p>
<p>            Status = o.Status,</p>
<p>            CreatedAt = o.CreatedAt,</p>
<p>            ItemCount = o.Items.Count</p>
<p>        })</p>
<p>        .ToArrayAsync(ct);</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefit</strong>: Projection avoids loading full entities (faster, less memory).

<h3>Pattern 3: Optimistic Concurrency</h3>

<pre><code class="language-csharp">public class Order {
<p>    public Guid Id { get; set; }</p>
<p>    public string Status { get; set; } = default!;</p>

<p>    [Timestamp]</p>
<p>    public byte[] RowVersion { get; set; } = Array.Empty<byte>();  // Concurrency token</p>
<p>}</p>

<p>public async Task UpdateOrderStatusAsync(Guid orderId, string newStatus) {</p>
<p>    var order = await _context.Orders.FirstAsync(o => o.Id == orderId);</p>

<p>    order.Status = newStatus;</p>

<p>    try {</p>
<p>        await _context.SaveChangesAsync();</p>
<p>    } catch (DbUpdateConcurrencyException) {</p>
<p>        // Row was modified by another process</p>
<p>        throw new ConcurrencyException("Order was modified by another user");</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/perspectives.md">Perspectives</a> - Event-driven read models</li>
<li><a href="../core-concepts/lenses.md">Lenses</a> - Query repositories</li>
<li><a href="../core-concepts/receptors.md">Receptors</a> - Message handlers</li>
</ul>
<strong>Data Access</strong>:
<ul><li><a href="dapper-integration.md">Dapper Integration</a> - Lightweight data access</li>
<li><a href="perspectives-storage.md">Perspectives Storage</a> - Read model schema design</li>
<li><a href="event-store.md">Event Store</a> - Event storage and replay</li>
</ul>
<strong>Examples</strong>:
<ul><li><a href="../examples/ecommerce/order-service.md">ECommerce: Order Service</a> - EF Core in practice</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-data-efcore-json-configuration" class="doc-section">
  <h3>EF Core 10 JSON Configuration</h3>
  <p class="doc-path"><code>v1.0.0/data/efcore-json-configuration</code></p>
  <p class="doc-description"><em>Configuring EF Core 10 with custom JSON converters for JSONB columns</em></p>
  <div class="doc-content">

<h1>EF Core 10 JSON Configuration with Custom Converters</h1>

<h2>Overview</h2>

<p>EF Core 10 has native JSONB support for PostgreSQL. When using custom JSON converters (like WhizbangId converters from source generators), you should configure EF Core through dependency injection, NOT through NpgsqlDataSource directly.</p>

<h2>✅ Correct Approach</h2>

<pre><code class="language-csharp">// 1. Create JsonSerializerOptions with your custom converters
<p>var jsonOptions = WhizbangJsonContext.CreateOptions();</p>

<p>// 2. Register in DI - EF Core will use this automatically for JSONB columns</p>
<p>builder.Services.AddSingleton(jsonOptions);</p>

<p>// 3. Configure DbContext with simple connection string</p>
<p>builder.Services.AddDbContext<MyDbContext>(options => {</p>
<p>  options.UseNpgsql(connectionString);</p>
<p>  // EF Core 10 automatically picks up JsonSerializerOptions from DI</p>
<p>});</p>
<p></code></pre></p>

<h2>❌ Incorrect Approach (Bypasses EF Core ORM)</h2>

<pre><code class="language-csharp">// DON'T DO THIS - it bypasses EF Core's ORM layer
<p>var dataSourceBuilder = new NpgsqlDataSourceBuilder(connectionString);</p>
<p>dataSourceBuilder.ConfigureJsonOptions(jsonOptions);</p>
<p>var dataSource = dataSourceBuilder.Build();</p>
<p>builder.Services.AddSingleton(dataSource);</p>

<p>builder.Services.AddDbContext<MyDbContext>(options => {</p>
<p>  options.UseNpgsql(dataSource); // Bypasses EF Core's JSON handling</p>
<p>});</p>
<p></code></pre></p>

<h2>Why This Matters</h2>

<strong>Using NpgsqlDataSource directly</strong>:
<ul><li>Gives JSON configuration to Npgsql, not EF Core</li>
<li>Bypasses EF Core's ORM layer and change tracking</li>
<li>Breaks the abstraction - you're configuring the provider directly instead of the ORM</li>
</ul>
<strong>Using DI registration</strong>:
<ul><li>EF Core picks up JsonSerializerOptions from DI automatically</li>
<li>Stays within EF Core's ORM layer (proper separation of concerns)</li>
<li>Follows the "use the ORM" principle</li>
<li>Cleaner code, better integration</li>
</ul>
<h2>When to Use This Pattern</h2>

<p>Use this pattern when:</p>
<ul><li>You have custom JSON converters (like WhizbangId converters)</li>
<li>You're storing complex objects in JSONB columns (like perspective lens DTOs)</li>
<li>You want EF Core to handle JSON serialization for owned types or JSON columns</li>
</ul>
<h2>Example: Perspective Row Storage</h2>

<p>Perspective rows store lens DTOs in JSONB columns:</p>

<pre><code class="language-csharp">public class PerspectiveRow<TLensDto> where TLensDto : class {
<p>  public Guid Id { get; set; }</p>
<p>  public TLensDto Data { get; set; } // Stored as JSONB</p>
<p>}</p>
<p></code></pre></p>

<p>EF Core 10 will automatically:</p>
<ul><li>Use JsonSerializerOptions from DI to serialize TLensDto to JSONB</li>
<li>Apply your custom converters (like WhizbangId converters)</li>
<li>Track changes properly through the ORM</li>
</ul>
<h2>References</h2>

<ul><li><a href="https://learn.microsoft.com/en-us/ef/core/what-is-new/ef-core-10.0/whatsnew#json-columns">EF Core 10 JSON columns</a></li>
<li><a href="https://www.npgsql.org/efcore/">Npgsql EF Core provider</a></li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-data-event-store" class="doc-section">
  <h3>Event Store</h3>
  <p class="doc-path"><code>v1.0.0/data/event-store</code></p>
  <p class="doc-description"><em>Event sourcing and stream storage - event streams, replay, checkpoints, snapshots, and temporal queries</em></p>
  <div class="doc-content">

<h1>Event Store</h1>

<p>The <strong>Event Store</strong> is the append-only log of all domain events in your system. It provides event sourcing capabilities, stream-based processing, and time-travel queries for rebuilding read models from any point in history.</p>

<h2>Event Sourcing Fundamentals</h2>

<strong>Event Sourcing</strong> stores state changes as a sequence of events rather than current state:

<pre><code class="language-">Traditional State Storage:        Event Sourcing:
<p>┌──────────────────────┐         ┌──────────────────────┐</p>
<p>│  Order Table         │         │  Event Stream        │</p>
<p>├──────────────────────┤         ├──────────────────────┤</p>
<p>│ order_id: abc        │         │ OrderCreated         │</p>
<p>│ status: Shipped      │   ←──   │ OrderPaid            │</p>
<p>│ total: $100          │         │ OrderShipped         │</p>
<p>└──────────────────────┘         └──────────────────────┘</p>
<p>  (current state)                  (full history)</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li><strong>Complete Audit Trail</strong>: Every state change recorded forever</li>
<li><strong>Temporal Queries</strong>: "What was the order status at 2PM yesterday?"</li>
<li><strong>Replay</strong>: Rebuild read models from events</li>
<li><strong>Debugging</strong>: Reproduce exact system state for troubleshooting</li>
<li><strong>Analytics</strong>: Mine event history for business insights</li>
</ul>
<hr>

<h2>Event Stream Schema</h2>

<h3>Core Tables</h3>

<pre><code class="language-sql">-- Event stream (append-only)
<p>CREATE TABLE wh_events (</p>
<p>    event_id UUID PRIMARY KEY DEFAULT uuid_generate_v7(),  -- Time-ordered</p>
<p>    stream_id UUID NOT NULL,                               -- Aggregate/entity ID</p>
<p>    stream_type VARCHAR(200) NOT NULL,                     -- 'Order', 'Customer', etc.</p>

<p>    event_type VARCHAR(200) NOT NULL,                      -- 'OrderCreated', 'OrderShipped', etc.</p>
<p>    event_data JSONB NOT NULL,                             -- Event payload</p>
<p>    event_metadata JSONB DEFAULT '{}',                     -- Context (user, tenant, correlation)</p>

<p>    sequence_number BIGINT NOT NULL,                       -- Position in stream (1, 2, 3, ...)</p>
<p>    global_sequence BIGSERIAL NOT NULL UNIQUE,             -- Global ordering across all streams</p>

<p>    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),</p>
<p>    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),</p>

<p>    -- Composite unique constraint (one sequence per stream)</p>
<p>    CONSTRAINT uq_stream_sequence UNIQUE (stream_id, sequence_number)</p>
<p>);</p>

<p>-- Indexes</p>
<p>CREATE INDEX idx_events_stream_id ON wh_events (stream_id, sequence_number);</p>
<p>CREATE INDEX idx_events_stream_type ON wh_events (stream_type);</p>
<p>CREATE INDEX idx_events_event_type ON wh_events (event_type);</p>
<p>CREATE INDEX idx_events_timestamp ON wh_events (timestamp DESC);</p>
<p>CREATE INDEX idx_events_global_sequence ON wh_events (global_sequence);</p>
<p></code></pre></p>

<strong>Key Design Decisions</strong>:
<ul><li><strong>UUIDv7</strong> for <code>event_id</code>: Time-ordered, insert-friendly</li>
<li><strong>sequence_number</strong>: Position within a single stream (1, 2, 3, ...)</li>
<li><strong>global_sequence</strong>: Total ordering across all streams (for projections)</li>
<li><strong>JSONB</strong> for <code>event_data</code>: Flexible schema, queryable</li>
<li><strong>stream_type</strong>: Partition by aggregate type (Order, Customer, Product, etc.)</li>
</ul>
<hr>

<h3>Event Processing Tracking</h3>

<pre><code class="language-sql">-- Receptor processing (log-style tracking)
<p>CREATE TABLE wh_receptor_processing (</p>
<p>    event_id UUID NOT NULL,</p>
<p>    receptor_name VARCHAR(200) NOT NULL,</p>
<p>    status VARCHAR(50) NOT NULL,  -- 'Processed', 'Failed', 'Skipped'</p>
<p>    processed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),</p>
<p>    error TEXT,</p>

<p>    PRIMARY KEY (event_id, receptor_name),</p>
<p>    FOREIGN KEY (event_id) REFERENCES wh_events (event_id) ON DELETE CASCADE</p>
<p>);</p>

<p>CREATE INDEX idx_receptor_processing_status ON wh_receptor_processing (status);</p>

<p>-- Perspective checkpoints (stream-based projections)</p>
<p>CREATE TABLE wh_perspective_checkpoints (</p>
<p>    stream_id UUID NOT NULL,</p>
<p>    perspective_name VARCHAR(200) NOT NULL,</p>
<p>    last_event_id UUID NOT NULL,</p>
<p>    last_sequence_number BIGINT NOT NULL,</p>
<p>    status VARCHAR(50) NOT NULL,  -- 'UpToDate', 'Rebuilding', 'Failed'</p>
<p>    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),</p>
<p>    error TEXT,</p>

<p>    PRIMARY KEY (stream_id, perspective_name),</p>
<p>    FOREIGN KEY (last_event_id) REFERENCES wh_events (event_id) ON DELETE CASCADE</p>
<p>);</p>

<p>CREATE INDEX idx_perspective_checkpoints_perspective ON wh_perspective_checkpoints (perspective_name);</p>
<p>CREATE INDEX idx_perspective_checkpoints_status ON wh_perspective_checkpoints (status);</p>
<p></code></pre></p>

<strong>Design Differences</strong>:

<p>| Aspect | Receptors (wh_receptor_processing) | Perspectives (wh_perspective_checkpoints) |</p>
<p>|--------|-------------------------------------|------------------------------------------|</p>
<p>| <strong>Tracking</strong> | Per event + receptor | Per stream + perspective |</p>
<p>| <strong>Ordering</strong> | No ordering (parallel) | Ordered within stream |</p>
<p>| <strong>Use Case</strong> | Side effects, notifications | Read model projections |</p>
<p>| <strong>Replay</strong> | Re-process individual events | Rebuild from checkpoint |</p>

<hr>

<h2>Appending Events</h2>

<h3>Simple Event Storage (Recommended)</h3>

<p>The simplest way to append events is to pass just the stream ID and event. Whizbang automatically captures tracing context from the <code>IEnvelopeRegistry</code>:</p>

<pre><code class="language-csharp">public class OrderReceptor(IEventStore eventStore) : IReceptor<CreateOrder, OrderCreated> {
<p>    public async ValueTask<OrderCreated> ReceiveAsync(CreateOrder command, CancellationToken ct) {</p>
<p>        var orderId = Guid.CreateVersion7();</p>

<p>        var @event = new OrderCreated(orderId, command.CustomerId, command.Total);</p>

<p>        // Simple pattern - just pass stream ID and event</p>
<p>        await eventStore.AppendAsync(orderId, @event, ct);</p>

<p>        return @event;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>How it works</strong>: When the Dispatcher invokes your receptor, it registers the <code>MessageEnvelope</code> in the <code>IEnvelopeRegistry</code>. When you call <code>AppendAsync(streamId, message)</code>, the event store looks up the envelope to preserve:
<ul><li><strong>MessageId</strong> - Correlation across systems</li>
<li><strong>Hops</strong> - Service-to-service tracing</li>
<li><strong>CorrelationId/CausationId</strong> - Request chain tracking</li>
</ul>
<p>If no envelope is found (e.g., in tests without Dispatcher), a minimal envelope is created automatically.</p>

<h3>Full Control with Envelope</h3>

<p>For advanced scenarios where you need full control over the envelope:</p>

<pre><code class="language-csharp">// Create explicit envelope with custom tracing
<p>var envelope = new MessageEnvelope<OrderCreated> {</p>
<p>    MessageId = MessageId.New(),</p>
<p>    Payload = @event,</p>
<p>    Hops = [new MessageHop {</p>
<p>        ServiceInstance = serviceInstanceProvider.ToInfo(),</p>
<p>        Timestamp = DateTimeOffset.UtcNow</p>
<p>    }]</p>
<p>};</p>

<p>await eventStore.AppendAsync(orderId, envelope, ct);</p>
<p></code></pre></p>

<h3>Low-Level Event Storage (Implementation Detail)</h3>

<p>For reference, here's the underlying storage implementation:</p>

<pre><code class="language-csharp">public class EventStore : IEventStore {
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public async Task<Guid> AppendAsync(</p>
<p>        Guid streamId,</p>
<p>        string streamType,</p>
<p>        string eventType,</p>
<p>        object eventData,</p>
<p>        Dictionary<string, object>? metadata = null,</p>
<p>        CancellationToken ct = default) {</p>

<p>        await using var conn = _db.CreateConnection();</p>

<p>        // Get next sequence number for stream</p>
<p>        var nextSequence = await conn.QuerySingleAsync<long>(</p>
<p>            "SELECT COALESCE(MAX(sequence_number), 0) + 1 FROM wh_events WHERE stream_id = @StreamId",</p>
<p>            new { StreamId = streamId }</p>
<p>        );</p>

<p>        var eventId = Guid.CreateVersion7();</p>

<p>        await conn.ExecuteAsync(</p>
<p>            """</p>
<p>            INSERT INTO wh_events (</p>
<p>                event_id, stream_id, stream_type, event_type, event_data, event_metadata, sequence_number, timestamp</p>
<p>            ) VALUES (</p>
<p>                @EventId, @StreamId, @StreamType, @EventType, @EventData::jsonb, @EventMetadata::jsonb, @SequenceNumber, @Timestamp</p>
<p>            )</p>
<p>            """,</p>
<p>            new {</p>
<p>                EventId = eventId,</p>
<p>                StreamId = streamId,</p>
<p>                StreamType = streamType,</p>
<p>                EventType = eventType,</p>
<p>                EventData = JsonSerializer.Serialize(eventData),</p>
<p>                EventMetadata = JsonSerializer.Serialize(metadata ?? new Dictionary<string, object>()),</p>
<p>                SequenceNumber = nextSequence,</p>
<p>                Timestamp = DateTimeOffset.UtcNow</p>
<p>            },</p>
<p>            cancellationToken: ct</p>
<p>        );</p>

<p>        return eventId;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Optimistic Concurrency (Expected Version)</h3>

<pre><code class="language-csharp">public async Task<Guid> AppendAsync(
<p>    Guid streamId,</p>
<p>    string streamType,</p>
<p>    string eventType,</p>
<p>    object eventData,</p>
<p>    long? expectedVersion = null,  // ← Optimistic concurrency</p>
<p>    Dictionary<string, object>? metadata = null,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>
<p>    await conn.OpenAsync(ct);</p>

<p>    await using var transaction = await conn.BeginTransactionAsync(ct);</p>

<p>    try {</p>
<p>        // Get current version</p>
<p>        var currentVersion = await conn.QuerySingleOrDefaultAsync<long?>(</p>
<p>            "SELECT MAX(sequence_number) FROM wh_events WHERE stream_id = @StreamId",</p>
<p>            new { StreamId = streamId },</p>
<p>            transaction: transaction</p>
<p>        );</p>

<p>        var actualVersion = currentVersion ?? 0;</p>

<p>        // Check expected version</p>
<p>        if (expectedVersion.HasValue && actualVersion != expectedVersion.Value) {</p>
<p>            throw new ConcurrencyException(</p>
<p>                $"Stream {streamId} expected version {expectedVersion}, but was {actualVersion}"</p>
<p>            );</p>
<p>        }</p>

<p>        var nextSequence = actualVersion + 1;</p>
<p>        var eventId = Guid.CreateVersion7();</p>

<p>        await conn.ExecuteAsync(</p>
<p>            """</p>
<p>            INSERT INTO wh_events (</p>
<p>                event_id, stream_id, stream_type, event_type, event_data, event_metadata, sequence_number, timestamp</p>
<p>            ) VALUES (</p>
<p>                @EventId, @StreamId, @StreamType, @EventType, @EventData::jsonb, @EventMetadata::jsonb, @SequenceNumber, @Timestamp</p>
<p>            )</p>
<p>            """,</p>
<p>            new {</p>
<p>                EventId = eventId,</p>
<p>                StreamId = streamId,</p>
<p>                StreamType = streamType,</p>
<p>                EventType = eventType,</p>
<p>                EventData = JsonSerializer.Serialize(eventData),</p>
<p>                EventMetadata = JsonSerializer.Serialize(metadata ?? new Dictionary<string, object>()),</p>
<p>                SequenceNumber = nextSequence,</p>
<p>                Timestamp = DateTimeOffset.UtcNow</p>
<p>            },</p>
<p>            transaction: transaction,</p>
<p>            cancellationToken: ct</p>
<p>        );</p>

<p>        await transaction.CommitAsync(ct);</p>

<p>        return eventId;</p>

<p>    } catch {</p>
<p>        await transaction.RollbackAsync(ct);</p>
<p>        throw;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Reading Event Streams</h2>

<h3>Read Full Stream</h3>

<pre><code class="language-csharp">public async Task<StoredEvent[]> ReadStreamAsync(
<p>    Guid streamId,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    var events = await conn.QueryAsync<StoredEvent>(</p>
<p>        """</p>
<p>        SELECT</p>
<p>            event_id, stream_id, stream_type, event_type,</p>
<p>            event_data, event_metadata, sequence_number, global_sequence, timestamp</p>
<p>        FROM wh_events</p>
<p>        WHERE stream_id = @StreamId</p>
<p>        ORDER BY sequence_number</p>
<p>        """,</p>
<p>        new { StreamId = streamId },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    return events.ToArray();</p>
<p>}</p>
<p></code></pre></p>

<h3>Read Stream from Version</h3>

<pre><code class="language-csharp">public async Task<StoredEvent[]> ReadStreamAsync(
<p>    Guid streamId,</p>
<p>    long fromVersion,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    var events = await conn.QueryAsync<StoredEvent>(</p>
<p>        """</p>
<p>        SELECT * FROM wh_events</p>
<p>        WHERE stream_id = @StreamId</p>
<p>          AND sequence_number >= @FromVersion</p>
<p>        ORDER BY sequence_number</p>
<p>        """,</p>
<p>        new { StreamId = streamId, FromVersion = fromVersion },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    return events.ToArray();</p>
<p>}</p>
<p></code></pre></p>

<h3>Read All Events (Global Stream)</h3>

<pre><code class="language-csharp">public async Task<StoredEvent[]> ReadAllEventsAsync(
<p>    long fromGlobalSequence,</p>
<p>    int limit = 1000,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    var events = await conn.QueryAsync<StoredEvent>(</p>
<p>        """</p>
<p>        SELECT * FROM wh_events</p>
<p>        WHERE global_sequence >= @FromGlobalSequence</p>
<p>        ORDER BY global_sequence</p>
<p>        LIMIT @Limit</p>
<p>        """,</p>
<p>        new { FromGlobalSequence = fromGlobalSequence, Limit = limit },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    return events.ToArray();</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Rebuilding Perspectives from Events</h2>

<h3>Checkpoint-Based Replay</h3>

<pre><code class="language-csharp">public class PerspectiveRebuilder {
<p>    private readonly IDbConnectionFactory _db;</p>
<p>    private readonly IServiceProvider _services;</p>

<p>    public async Task RebuildPerspectiveAsync(</p>
<p>        Guid streamId,</p>
<p>        string perspectiveName,</p>
<p>        CancellationToken ct = default) {</p>

<p>        await using var conn = _db.CreateConnection();</p>

<p>        // Get last checkpoint (if any)</p>
<p>        var checkpoint = await conn.QuerySingleOrDefaultAsync<PerspectiveCheckpoint>(</p>
<p>            """</p>
<p>            SELECT * FROM wh_perspective_checkpoints</p>
<p>            WHERE stream_id = @StreamId AND perspective_name = @PerspectiveName</p>
<p>            """,</p>
<p>            new { StreamId = streamId, PerspectiveName = perspectiveName }</p>
<p>        );</p>

<p>        var fromSequence = checkpoint?.LastSequenceNumber + 1 ?? 1;</p>

<p>        // Read events from checkpoint</p>
<p>        var events = await conn.QueryAsync<StoredEvent>(</p>
<p>            """</p>
<p>            SELECT * FROM wh_events</p>
<p>            WHERE stream_id = @StreamId</p>
<p>              AND sequence_number >= @FromSequence</p>
<p>            ORDER BY sequence_number</p>
<p>            """,</p>
<p>            new { StreamId = streamId, FromSequence = fromSequence },</p>
<p>            cancellationToken: ct</p>
<p>        );</p>

<p>        // Resolve perspective handler</p>
<p>        var perspective = ResolvePerspective(perspectiveName);</p>

<p>        // Replay events</p>
<p>        foreach (var storedEvent in events) {</p>
<p>            var @event = DeserializeEvent(storedEvent);</p>

<p>            await perspective.UpdateAsync(@event, ct);</p>

<p>            // Update checkpoint</p>
<p>            await conn.ExecuteAsync(</p>
<p>                """</p>
<p>                INSERT INTO wh_perspective_checkpoints (</p>
<p>                    stream_id, perspective_name, last_event_id, last_sequence_number, status, updated_at</p>
<p>                ) VALUES (</p>
<p>                    @StreamId, @PerspectiveName, @EventId, @SequenceNumber, 'UpToDate', NOW()</p>
<p>                )</p>
<p>                ON CONFLICT (stream_id, perspective_name) DO UPDATE SET</p>
<p>                    last_event_id = EXCLUDED.last_event_id,</p>
<p>                    last_sequence_number = EXCLUDED.last_sequence_number,</p>
<p>                    status = EXCLUDED.status,</p>
<p>                    updated_at = EXCLUDED.updated_at</p>
<p>                """,</p>
<p>                new {</p>
<p>                    StreamId = streamId,</p>
<p>                    PerspectiveName = perspectiveName,</p>
<p>                    EventId = storedEvent.EventId,</p>
<p>                    SequenceNumber = storedEvent.SequenceNumber</p>
<p>                },</p>
<p>                cancellationToken: ct</p>
<p>            );</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Full Rebuild (Delete + Replay)</h3>

<pre><code class="language-csharp">public async Task FullRebuildPerspectiveAsync(
<p>    string perspectiveName,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    // 1. Delete existing perspective data</p>
<p>    await conn.ExecuteAsync($"TRUNCATE TABLE {GetPerspectiveTableName(perspectiveName)}");</p>

<p>    // 2. Reset checkpoints</p>
<p>    await conn.ExecuteAsync(</p>
<p>        "DELETE FROM wh_perspective_checkpoints WHERE perspective_name = @PerspectiveName",</p>
<p>        new { PerspectiveName = perspectiveName }</p>
<p>    );</p>

<p>    // 3. Read all events (global sequence)</p>
<p>    var events = await conn.QueryAsync<StoredEvent>(</p>
<p>        "SELECT * FROM wh_events ORDER BY global_sequence",</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    // 4. Resolve perspective handler</p>
<p>    var perspective = ResolvePerspective(perspectiveName);</p>

<p>    // 5. Replay ALL events</p>
<p>    foreach (var storedEvent in events) {</p>
<p>        var @event = DeserializeEvent(storedEvent);</p>

<p>        // Check if perspective handles this event type</p>
<p>        if (CanHandle(perspective, @event)) {</p>
<p>            await perspective.UpdateAsync(@event, ct);</p>

<p>            // Update checkpoint</p>
<p>            await conn.ExecuteAsync(</p>
<p>                """</p>
<p>                INSERT INTO wh_perspective_checkpoints (</p>
<p>                    stream_id, perspective_name, last_event_id, last_sequence_number, status, updated_at</p>
<p>                ) VALUES (</p>
<p>                    @StreamId, @PerspectiveName, @EventId, @SequenceNumber, 'UpToDate', NOW()</p>
<p>                )</p>
<p>                ON CONFLICT (stream_id, perspective_name) DO UPDATE SET</p>
<p>                    last_event_id = EXCLUDED.last_event_id,</p>
<p>                    last_sequence_number = EXCLUDED.last_sequence_number,</p>
<p>                    status = EXCLUDED.status,</p>
<p>                    updated_at = EXCLUDED.updated_at</p>
<p>                """,</p>
<p>                new {</p>
<p>                    StreamId = storedEvent.StreamId,</p>
<p>                    PerspectiveName = perspectiveName,</p>
<p>                    EventId = storedEvent.EventId,</p>
<p>                    SequenceNumber = storedEvent.SequenceNumber</p>
<p>                },</p>
<p>                cancellationToken: ct</p>
<p>            );</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Snapshots (Performance Optimization)</h2>

<strong>Problem</strong>: Replaying 10,000 events to rebuild an aggregate is slow.

<strong>Solution</strong>: Store periodic snapshots of aggregate state.

<h3>Snapshot Schema</h3>

<pre><code class="language-sql">CREATE TABLE wh_snapshots (
<p>    stream_id UUID NOT NULL,</p>
<p>    snapshot_type VARCHAR(200) NOT NULL,  -- Aggregate type</p>
<p>    snapshot_data JSONB NOT NULL,</p>
<p>    sequence_number BIGINT NOT NULL,      -- Last event included in snapshot</p>
<p>    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),</p>

<p>    PRIMARY KEY (stream_id, sequence_number)</p>
<p>);</p>

<p>CREATE INDEX idx_snapshots_stream_id ON wh_snapshots (stream_id, sequence_number DESC);</p>
<p></code></pre></p>

<h3>Snapshot Creation</h3>

<pre><code class="language-csharp">public async Task CreateSnapshotAsync(
<p>    Guid streamId,</p>
<p>    string snapshotType,</p>
<p>    object snapshot,</p>
<p>    long sequenceNumber,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    await conn.ExecuteAsync(</p>
<p>        """</p>
<p>        INSERT INTO wh_snapshots (</p>
<p>            stream_id, snapshot_type, snapshot_data, sequence_number, created_at</p>
<p>        ) VALUES (</p>
<p>            @StreamId, @SnapshotType, @SnapshotData::jsonb, @SequenceNumber, NOW()</p>
<p>        )</p>
<p>        """,</p>
<p>        new {</p>
<p>            StreamId = streamId,</p>
<p>            SnapshotType = snapshotType,</p>
<p>            SnapshotData = JsonSerializer.Serialize(snapshot),</p>
<p>            SequenceNumber = sequenceNumber</p>
<p>        },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<h3>Snapshot-Based Replay</h3>

<pre><code class="language-csharp">public async Task<Order> RehydrateOrderAsync(
<p>    Guid orderId,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    // 1. Get latest snapshot</p>
<p>    var snapshot = await conn.QuerySingleOrDefaultAsync<StoredSnapshot>(</p>
<p>        """</p>
<p>        SELECT * FROM wh_snapshots</p>
<p>        WHERE stream_id = @StreamId</p>
<p>        ORDER BY sequence_number DESC</p>
<p>        LIMIT 1</p>
<p>        """,</p>
<p>        new { StreamId = orderId }</p>
<p>    );</p>

<p>    Order order;</p>
<p>    long fromSequence;</p>

<p>    if (snapshot is not null) {</p>
<p>        // Deserialize snapshot</p>
<p>        order = JsonSerializer.Deserialize<Order>(snapshot.SnapshotData)!;</p>
<p>        fromSequence = snapshot.SequenceNumber + 1;</p>
<p>    } else {</p>
<p>        // No snapshot, start from beginning</p>
<p>        order = new Order();</p>
<p>        fromSequence = 1;</p>
<p>    }</p>

<p>    // 2. Read events after snapshot</p>
<p>    var events = await conn.QueryAsync<StoredEvent>(</p>
<p>        """</p>
<p>        SELECT * FROM wh_events</p>
<p>        WHERE stream_id = @StreamId</p>
<p>          AND sequence_number >= @FromSequence</p>
<p>        ORDER BY sequence_number</p>
<p>        """,</p>
<p>        new { StreamId = orderId, FromSequence = fromSequence },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    // 3. Apply remaining events</p>
<p>    foreach (var storedEvent in events) {</p>
<p>        var @event = DeserializeEvent(storedEvent);</p>
<p>        order.Apply(@event);  // Aggregate applies event to mutate state</p>
<p>    }</p>

<p>    return order;</p>
<p>}</p>
<p></code></pre></p>

<strong>Snapshot Strategy</strong>:
<ul><li>Create snapshot every N events (e.g., every 100 events)</li>
<li>Keep last 3 snapshots (delete older ones)</li>
<li>Balance: More snapshots = faster replay, more storage</li>
</ul>
<hr>

<h2>Temporal Queries (Time Travel)</h2>

<h3>Query State at Specific Time</h3>

<pre><code class="language-csharp">public async Task<Order> GetOrderAsOfAsync(
<p>    Guid orderId,</p>
<p>    DateTimeOffset asOfTime,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    // Read events up to specific time</p>
<p>    var events = await conn.QueryAsync<StoredEvent>(</p>
<p>        """</p>
<p>        SELECT * FROM wh_events</p>
<p>        WHERE stream_id = @StreamId</p>
<p>          AND timestamp <= @AsOfTime</p>
<p>        ORDER BY sequence_number</p>
<p>        """,</p>
<p>        new { StreamId = orderId, AsOfTime = asOfTime },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    // Rebuild aggregate state from events</p>
<p>    var order = new Order();</p>

<p>    foreach (var storedEvent in events) {</p>
<p>        var @event = DeserializeEvent(storedEvent);</p>
<p>        order.Apply(@event);</p>
<p>    }</p>

<p>    return order;</p>
<p>}</p>
<p></code></pre></p>

<h3>Perspective Projection at Specific Time</h3>

<pre><code class="language-csharp">public async Task RebuildPerspectiveAsOfAsync(
<p>    string perspectiveName,</p>
<p>    DateTimeOffset asOfTime,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    // 1. Truncate perspective table</p>
<p>    await conn.ExecuteAsync($"TRUNCATE TABLE {GetPerspectiveTableName(perspectiveName)}");</p>

<p>    // 2. Read events up to specific time</p>
<p>    var events = await conn.QueryAsync<StoredEvent>(</p>
<p>        """</p>
<p>        SELECT * FROM wh_events</p>
<p>        WHERE timestamp <= @AsOfTime</p>
<p>        ORDER BY global_sequence</p>
<p>        """,</p>
<p>        new { AsOfTime = asOfTime },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    // 3. Replay events</p>
<p>    var perspective = ResolvePerspective(perspectiveName);</p>

<p>    foreach (var storedEvent in events) {</p>
<p>        var @event = DeserializeEvent(storedEvent);</p>

<p>        if (CanHandle(perspective, @event)) {</p>
<p>            await perspective.UpdateAsync(@event, ct);</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Use Cases</strong>:
<ul><li><strong>Debugging</strong>: "What did the order look like when the bug occurred?"</li>
<li><strong>Compliance</strong>: "Show me customer data as of December 31st for audit"</li>
<li><strong>Analytics</strong>: "How many active customers did we have at the end of Q3?"</li>
</ul>
<hr>

<h2>Event Versioning</h2>

<h3>Problem: Event Schema Changes</h3>

<pre><code class="language-csharp">// Version 1
<p>public record OrderCreatedV1(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    decimal Total</p>
<p>);</p>

<p>// Version 2 (added new field)</p>
<p>public record OrderCreatedV2(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    decimal Total,</p>
<p>    string Currency  // ← New field!</p>
<p>);</p>
<p></code></pre></p>

<h3>Strategy 1: Upcasting</h3>

<pre><code class="language-csharp">public class EventUpcast {
<p>    public object Upcast(StoredEvent storedEvent) {</p>
<p>        return storedEvent.EventType switch {</p>
<p>            "OrderCreatedV1" => UpcastV1ToV2(storedEvent),</p>
<p>            "OrderCreatedV2" => JsonSerializer.Deserialize<OrderCreatedV2>(storedEvent.EventData),</p>
<p>            _ => throw new UnknownEventTypeException(storedEvent.EventType)</p>
<p>        };</p>
<p>    }</p>

<p>    private OrderCreatedV2 UpcastV1ToV2(StoredEvent storedEvent) {</p>
<p>        var v1 = JsonSerializer.Deserialize<OrderCreatedV1>(storedEvent.EventData)!;</p>

<p>        return new OrderCreatedV2(</p>
<p>            OrderId: v1.OrderId,</p>
<p>            CustomerId: v1.CustomerId,</p>
<p>            Total: v1.Total,</p>
<p>            Currency: "USD"  // ← Default value for missing field</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Strategy 2: Copy-and-Transform (Migration)</h3>

<pre><code class="language-sql">-- Add new event type with transformed data
<p>INSERT INTO wh_events (</p>
<p>    event_id, stream_id, stream_type, event_type, event_data, event_metadata, sequence_number, timestamp</p>
<p>)</p>
<p>SELECT</p>
<p>    uuid_generate_v7(),</p>
<p>    stream_id,</p>
<p>    stream_type,</p>
<p>    'OrderCreatedV2',  -- New event type</p>
<p>    jsonb_set(event_data, '{Currency}', '"USD"'),  -- Add default Currency</p>
<p>    event_metadata,</p>
<p>    sequence_number,</p>
<p>    timestamp</p>
<p>FROM wh_events</p>
<p>WHERE event_type = 'OrderCreatedV1';</p>

<p>-- Delete old events (after verification!)</p>
<p>-- DELETE FROM wh_events WHERE event_type = 'OrderCreatedV1';</p>
<p></code></pre></p>

<hr>

<h2>Event Store Performance</h2>

<h3>Partitioning by Stream Type</h3>

<pre><code class="language-sql">CREATE TABLE wh_events (
<p>    event_id UUID PRIMARY KEY,</p>
<p>    stream_id UUID NOT NULL,</p>
<p>    stream_type VARCHAR(200) NOT NULL,</p>
<p>    -- ... other columns</p>
<p>) PARTITION BY LIST (stream_type);</p>

<p>-- Create partitions per stream type</p>
<p>CREATE TABLE wh_events_orders PARTITION OF wh_events</p>
<p>FOR VALUES IN ('Order');</p>

<p>CREATE TABLE wh_events_customers PARTITION OF wh_events</p>
<p>FOR VALUES IN ('Customer');</p>

<p>CREATE TABLE wh_events_products PARTITION OF wh_events</p>
<p>FOR VALUES IN ('Product');</p>
<p></code></pre></p>

<strong>Benefit</strong>: Queries filtered by <code>stream_type</code> only scan relevant partition.

<h3>Partitioning by Time Range</h3>

<pre><code class="language-sql">CREATE TABLE wh_events (
<p>    event_id UUID PRIMARY KEY,</p>
<p>    stream_id UUID NOT NULL,</p>
<p>    timestamp TIMESTAMPTZ NOT NULL,</p>
<p>    -- ... other columns</p>
<p>) PARTITION BY RANGE (timestamp);</p>

<p>-- Monthly partitions</p>
<p>CREATE TABLE wh_events_2024_12 PARTITION OF wh_events</p>
<p>FOR VALUES FROM ('2024-12-01') TO ('2025-01-01');</p>

<p>CREATE TABLE wh_events_2025_01 PARTITION OF wh_events</p>
<p>FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');</p>
<p></code></pre></p>

<strong>Benefit</strong>: Time-based queries automatically prune old partitions.

<h3>Archiving Old Events</h3>

<pre><code class="language-sql">-- Archive events older than 1 year
<p>INSERT INTO wh_events_archive</p>
<p>SELECT * FROM wh_events</p>
<p>WHERE timestamp < NOW() - INTERVAL '1 year';</p>

<p>-- Delete from main table</p>
<p>DELETE FROM wh_events</p>
<p>WHERE timestamp < NOW() - INTERVAL '1 year';</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Append-only</strong> - Never update or delete events</li>
<li>✅ <strong>Use UUIDv7</strong> for event_id (time-ordered)</li>
<li>✅ <strong>Sequence numbers</strong> within streams (1, 2, 3, ...)</li>
<li>✅ <strong>Global sequence</strong> for cross-stream ordering</li>
<li>✅ <strong>JSONB</strong> for event_data (flexible, queryable)</li>
<li>✅ <strong>Snapshots</strong> for long streams (> 100 events)</li>
<li>✅ <strong>Upcasting</strong> for event versioning</li>
<li>✅ <strong>Partition</strong> by stream_type or timestamp for large stores</li>
<li>✅ <strong>Archive</strong> old events (> 1 year)</li>
<li>✅ <strong>Checkpoint-based replay</strong> for perspectives</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Update events (immutable!)</li>
<li>❌ Delete events (append-only!)</li>
<li>❌ Use random UUIDs (index fragmentation)</li>
<li>❌ Skip sequence numbers (breaks ordering)</li>
<li>❌ Store large BLOBs in events (use object storage, store URL)</li>
<li>❌ Replay without snapshots (slow!)</li>
<li>❌ Break event schemas (upcast instead)</li>
<li>❌ Query events for current state (use perspectives/lenses)</li>
</ul>
<hr>

<h2>Common Patterns</h2>

<h3>Pattern 1: Event-Sourced Aggregate</h3>

<pre><code class="language-csharp">public class Order {
<p>    public Guid Id { get; private set; }</p>
<p>    public string Status { get; private set; } = "Created";</p>
<p>    public decimal Total { get; private set; }</p>

<p>    private readonly List<object> _uncommittedEvents = new();</p>

<p>    public IReadOnlyList<object> GetUncommittedEvents() => _uncommittedEvents.AsReadOnly();</p>

<p>    public void ClearUncommittedEvents() => _uncommittedEvents.Clear();</p>

<p>    // Apply event to mutate state</p>
<p>    public void Apply(object @event) {</p>
<p>        switch (@event) {</p>
<p>            case OrderCreated e:</p>
<p>                Id = e.OrderId;</p>
<p>                Status = "Created";</p>
<p>                Total = e.Total;</p>
<p>                break;</p>

<p>            case OrderShipped e:</p>
<p>                Status = "Shipped";</p>
<p>                break;</p>

<p>            default:</p>
<p>                throw new UnknownEventException(@event.GetType().Name);</p>
<p>        }</p>
<p>    }</p>

<p>    // Business logic produces events</p>
<p>    public void Ship() {</p>
<p>        if (Status != "Created") {</p>
<p>            throw new InvalidOperationException("Can only ship created orders");</p>
<p>        }</p>

<p>        var @event = new OrderShipped(Id, DateTimeOffset.UtcNow);</p>

<p>        Apply(@event);  // Mutate state</p>
<p>        _uncommittedEvents.Add(@event);  // Track for persistence</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern 2: Repository with Event Store</h3>

<pre><code class="language-csharp">public class OrderRepository(IEventStore eventStore) {
<p>    public async Task<Order> GetByIdAsync(Guid orderId, CancellationToken ct = default) {</p>
<p>        var events = await eventStore.ReadStreamAsync(orderId, ct);</p>

<p>        var order = new Order();</p>

<p>        foreach (var @event in events) {</p>
<p>            order.Apply(@event);</p>
<p>        }</p>

<p>        return order;</p>
<p>    }</p>

<p>    public async Task SaveAsync(Order order, CancellationToken ct = default) {</p>
<p>        var uncommittedEvents = order.GetUncommittedEvents();</p>

<p>        foreach (var @event in uncommittedEvents) {</p>
<p>            // Simple pattern - stream ID and event only</p>
<p>            await eventStore.AppendAsync(order.Id, @event, ct);</p>
<p>        }</p>

<p>        order.ClearUncommittedEvents();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Workers</strong>:
<ul><li><a href="../workers/perspective-worker.md">Perspective Worker</a> - Checkpoint processing lifecycle and runtime behavior</li>
<li><a href="../workers/execution-lifecycle.md">Execution Lifecycle</a> - Startup/shutdown coordination</li>
</ul>
<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/perspectives.md">Perspectives</a> - Event-driven read models</li>
<li><a href="../core-concepts/observability.md">Observability</a> - Message hops and tracing</li>
</ul>
<strong>Data Access</strong>:
<ul><li><a href="dapper-integration.md">Dapper Integration</a> - Lightweight data access</li>
<li><a href="efcore-integration.md">EF Core Integration</a> - Full-featured ORM</li>
<li><a href="perspectives-storage.md">Perspectives Storage</a> - Read model schema design</li>
</ul>
<strong>Messaging</strong>:
<ul><li><a href="../messaging/outbox-pattern.md">Outbox Pattern</a> - Reliable event publishing</li>
<li><a href="../messaging/work-coordinator.md">Work Coordinator</a> - Atomic batch processing</li>
</ul>
<strong>Examples</strong>:
<ul><li><a href="../examples/ecommerce/event-sourcing.md">ECommerce: Event Sourcing</a> - Real-world event store usage</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2025-12-21</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-data-perspectives-storage" class="doc-section">
  <h3>Perspectives Storage</h3>
  <p class="doc-path"><code>v1.0.0/data/perspectives-storage</code></p>
  <p class="doc-description"><em>Read model schema design for perspectives - denormalization strategies, JSONB columns, indexing, and high-volume partitioning</em></p>
  <div class="doc-content">

<h1>Perspectives Storage</h1>

<strong>Perspectives</strong> are event-driven read models that maintain denormalized, query-optimized views of your domain. This guide covers schema design patterns, denormalization strategies, and PostgreSQL-specific features for building high-performance read models.

<h2>Read Models vs Write Models</h2>

<p>| Aspect | Write Models (Domain) | Read Models (Perspectives) |</p>
<p>|--------|----------------------|---------------------------|</p>
<p>| <strong>Normalization</strong> | Normalized (3NF) | Denormalized (flat) |</p>
<p>| <strong>Purpose</strong> | Enforce business rules | Optimize queries |</p>
<p>| <strong>Updates</strong> | Command-driven | Event-driven |</p>
<p>| <strong>Consistency</strong> | Immediate (strong) | Eventual (async) |</p>
<p>| <strong>Technology</strong> | EF Core (optional) | Dapper + PostgreSQL |</p>
<p>| <strong>Schema</strong> | Foreign keys, constraints | Flat, JSONB, indexes |</p>

<strong>Whizbang Philosophy</strong>: Separate write models (domain aggregates) from read models (perspectives) for optimal performance.

<hr>

<h2>Design Principles</h2>

<h3>1. Denormalization</h3>

<strong>Goal</strong>: Minimize JOINs at query time by storing all data needed for a query in a single table.

<pre><code class="language-sql">-- ❌ Normalized (requires JOINs)
<p>SELECT o.order_id, o.total, c.name, c.email</p>
<p>FROM orders o</p>
<p>INNER JOIN customers c ON o.customer_id = c.customer_id;</p>

<p>-- ✅ Denormalized (single table lookup)</p>
<p>SELECT order_id, total, customer_name, customer_email</p>
<p>FROM order_summaries</p>
<p>WHERE order_id = '...';</p>
<p></code></pre></p>

<h3>2. Query-Driven Design</h3>

<strong>Start with queries, design schema to support them</strong>:

<pre><code class="language-sql">-- Common queries drive schema design:
<p>-- 1. Get order by ID</p>
<p>SELECT * FROM order_summaries WHERE order_id = ?;</p>

<p>-- 2. Get orders by customer</p>
<p>SELECT * FROM order_summaries WHERE customer_id = ? ORDER BY created_at DESC;</p>

<p>-- 3. Search orders</p>
<p>SELECT * FROM order_summaries WHERE customer_name ILIKE ? OR customer_email ILIKE ?;</p>

<p>-- Schema includes customer_id, customer_name, customer_email for direct lookup</p>
<p></code></pre></p>

<h3>3. Eventual Consistency</h3>

<strong>Accept stale reads</strong> for massive performance gains:

<pre><code class="language-">Command → Write Model → Event → Perspective Update (async)
<p>                                      ↓</p>
<p>                                Read Model (slightly stale, but fast!)</p>
<p></code></pre></p>

<strong>Typical lag</strong>: < 100ms in most systems

<hr>

<h2>Schema Design Patterns</h2>

<h3>Pattern 1: Flat Denormalized Table</h3>

<strong>Use Case</strong>: Simple read models with all data in columns.

<pre><code class="language-sql">CREATE TABLE order_summaries (
<p>    order_id UUID PRIMARY KEY,</p>

<p>    -- Order data</p>
<p>    status VARCHAR(50) NOT NULL,</p>
<p>    total DECIMAL(18, 2) NOT NULL,</p>
<p>    item_count INT NOT NULL,</p>
<p>    created_at TIMESTAMPTZ NOT NULL,</p>
<p>    updated_at TIMESTAMPTZ NOT NULL,</p>

<p>    -- Denormalized customer data</p>
<p>    customer_id UUID NOT NULL,</p>
<p>    customer_name VARCHAR(200) NOT NULL,</p>
<p>    customer_email VARCHAR(200) NOT NULL,</p>

<p>    -- Denormalized shipping data</p>
<p>    shipping_street VARCHAR(200),</p>
<p>    shipping_city VARCHAR(100),</p>
<p>    shipping_state VARCHAR(50),</p>
<p>    shipping_postal_code VARCHAR(20),</p>

<p>    -- Indexes for common queries</p>
<p>    INDEX idx_customer_id (customer_id),</p>
<p>    INDEX idx_created_at (created_at DESC),</p>
<p>    INDEX idx_status (status)</p>
<p>);</p>
<p></code></pre></p>

<strong>Perspective Update</strong>:
<pre><code class="language-csharp">public class OrderSummaryPerspective : IPerspectiveOf<OrderCreated> {
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>        await using var conn = _db.CreateConnection();</p>

<p>        await conn.ExecuteAsync(</p>
<p>            """</p>
<p>            INSERT INTO order_summaries (</p>
<p>                order_id, status, total, item_count, created_at, updated_at,</p>
<p>                customer_id, customer_name, customer_email,</p>
<p>                shipping_street, shipping_city, shipping_state, shipping_postal_code</p>
<p>            ) VALUES (</p>
<p>                @OrderId, @Status, @Total, @ItemCount, @CreatedAt, @UpdatedAt,</p>
<p>                @CustomerId, @CustomerName, @CustomerEmail,</p>
<p>                @ShippingStreet, @ShippingCity, @ShippingState, @ShippingPostalCode</p>
<p>            )</p>
<p>            ON CONFLICT (order_id) DO UPDATE SET</p>
<p>                status = EXCLUDED.status,</p>
<p>                updated_at = EXCLUDED.updated_at</p>
<p>            """,</p>
<p>            new {</p>
<p>                @event.OrderId,</p>
<p>                Status = "Created",</p>
<p>                @event.Total,</p>
<p>                ItemCount = @event.Items.Length,</p>
<p>                @event.CreatedAt,</p>
<p>                UpdatedAt = @event.CreatedAt,</p>
<p>                @event.CustomerId,</p>
<p>                @event.CustomerName,</p>
<p>                @event.CustomerEmail,</p>
<p>                @event.ShippingAddress.Street,</p>
<p>                @event.ShippingAddress.City,</p>
<p>                @event.ShippingAddress.State,</p>
<p>                @event.ShippingAddress.PostalCode</p>
<p>            },</p>
<p>            cancellationToken: ct</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h3>Pattern 2: JSONB for Flexible Data</h3>

<strong>Use Case</strong>: Complex nested data, evolving schemas, metadata.

<pre><code class="language-sql">CREATE TABLE product_catalog (
<p>    product_id UUID PRIMARY KEY,</p>

<p>    -- Core columns</p>
<p>    name VARCHAR(200) NOT NULL,</p>
<p>    sku VARCHAR(100) NOT NULL UNIQUE,</p>
<p>    price DECIMAL(18, 2) NOT NULL,</p>
<p>    available INT NOT NULL DEFAULT 0,</p>

<p>    -- JSONB for flexible metadata</p>
<p>    metadata JSONB NOT NULL DEFAULT '{}',</p>

<p>    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),</p>
<p>    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),</p>

<p>    -- GIN index for JSONB queries</p>
<p>    INDEX idx_metadata_gin ON product_catalog USING GIN (metadata)</p>
<p>);</p>
<p></code></pre></p>

<strong>Example JSONB Content</strong>:
<pre><code class="language-json">{
<p>  "category": "Electronics",</p>
<p>  "subcategory": "Laptops",</p>
<p>  "brand": "TechCorp",</p>
<p>  "tags": ["featured", "sale", "new-arrival"],</p>
<p>  "specifications": {</p>
<p>    "cpu": "Intel i7",</p>
<p>    "ram": "16GB",</p>
<p>    "storage": "512GB SSD"</p>
<p>  },</p>
<p>  "images": [</p>
<p>    {"url": "https://...", "alt": "Front view"},</p>
<p>    {"url": "https://...", "alt": "Side view"}</p>
<p>  ]</p>
<p>}</p>
<p></code></pre></p>

<strong>Query JSONB</strong>:
<pre><code class="language-sql">-- Filter by category
<p>SELECT * FROM product_catalog</p>
<p>WHERE metadata->>'category' = 'Electronics';</p>

<p>-- Filter by nested property</p>
<p>SELECT * FROM product_catalog</p>
<p>WHERE metadata->'specifications'->>'cpu' = 'Intel i7';</p>

<p>-- Array contains</p>
<p>SELECT * FROM product_catalog</p>
<p>WHERE metadata->'tags' @> '["featured"]';</p>

<p>-- Full-text search in JSONB</p>
<p>SELECT * FROM product_catalog</p>
<p>WHERE metadata->>'brand' ILIKE '%TechCorp%';</p>
<p></code></pre></p>

<strong>Perspective Update</strong>:
<pre><code class="language-csharp">public async Task UpdateAsync(ProductAdded @event, CancellationToken ct = default) {
<p>    await using var conn = _db.CreateConnection();</p>

<p>    var metadata = new {</p>
<p>        category = @event.Category,</p>
<p>        subcategory = @event.Subcategory,</p>
<p>        brand = @event.Brand,</p>
<p>        tags = @event.Tags,</p>
<p>        specifications = @event.Specifications,</p>
<p>        images = @event.Images</p>
<p>    };</p>

<p>    await conn.ExecuteAsync(</p>
<p>        """</p>
<p>        INSERT INTO product_catalog (</p>
<p>            product_id, name, sku, price, available, metadata, created_at</p>
<p>        ) VALUES (</p>
<p>            @ProductId, @Name, @Sku, @Price, @Available, @Metadata::jsonb, @CreatedAt</p>
<p>        )</p>
<p>        """,</p>
<p>        new {</p>
<p>            @event.ProductId,</p>
<p>            @event.Name,</p>
<p>            @event.Sku,</p>
<p>            @event.Price,</p>
<p>            Available = @event.InitialStock,</p>
<p>            Metadata = JsonSerializer.Serialize(metadata),</p>
<p>            @event.CreatedAt</p>
<p>        },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h3>Pattern 3: Aggregated Data</h3>

<strong>Use Case</strong>: Pre-computed aggregations for analytics dashboards.

<pre><code class="language-sql">CREATE TABLE customer_statistics (
<p>    customer_id UUID PRIMARY KEY,</p>

<p>    -- Aggregated metrics</p>
<p>    total_orders INT NOT NULL DEFAULT 0,</p>
<p>    total_spent DECIMAL(18, 2) NOT NULL DEFAULT 0,</p>
<p>    average_order_value DECIMAL(18, 2) NOT NULL DEFAULT 0,</p>

<p>    -- Temporal data</p>
<p>    first_order_at TIMESTAMPTZ,</p>
<p>    last_order_at TIMESTAMPTZ,</p>

<p>    -- Behavioral flags</p>
<p>    is_vip BOOLEAN NOT NULL DEFAULT FALSE,</p>
<p>    is_at_risk BOOLEAN NOT NULL DEFAULT FALSE,</p>

<p>    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()</p>
<p>);</p>
<p></code></pre></p>

<strong>Perspective Update</strong> (incremental):
<pre><code class="language-csharp">public class CustomerStatisticsPerspective : IPerspectiveOf<OrderCreated> {
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>        await using var conn = _db.CreateConnection();</p>

<p>        await conn.ExecuteAsync(</p>
<p>            """</p>
<p>            INSERT INTO customer_statistics (</p>
<p>                customer_id, total_orders, total_spent, average_order_value,</p>
<p>                first_order_at, last_order_at, is_vip, updated_at</p>
<p>            ) VALUES (</p>
<p>                @CustomerId, 1, @Total, @Total, @OrderDate, @OrderDate, FALSE, NOW()</p>
<p>            )</p>
<p>            ON CONFLICT (customer_id) DO UPDATE SET</p>
<p>                total_orders = customer_statistics.total_orders + 1,</p>
<p>                total_spent = customer_statistics.total_spent + @Total,</p>
<p>                average_order_value = (customer_statistics.total_spent + @Total) / (customer_statistics.total_orders + 1),</p>
<p>                last_order_at = @OrderDate,</p>
<p>                is_vip = (customer_statistics.total_spent + @Total) > 10000,  -- VIP threshold</p>
<p>                updated_at = NOW()</p>
<p>            """,</p>
<p>            new {</p>
<p>                @event.CustomerId,</p>
<p>                @event.Total,</p>
<p>                OrderDate = @event.CreatedAt</p>
<p>            },</p>
<p>            cancellationToken: ct</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Query</strong>:
<pre><code class="language-csharp">public async Task<CustomerStatistics?> GetCustomerStatsAsync(
<p>    Guid customerId,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    return await conn.QuerySingleOrDefaultAsync<CustomerStatistics>(</p>
<p>        "SELECT * FROM customer_statistics WHERE customer_id = @CustomerId",</p>
<p>        new { CustomerId = customerId },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h3>Pattern 4: Time-Series Data</h3>

<strong>Use Case</strong>: High-volume temporal data (metrics, logs, analytics).

<pre><code class="language-sql">CREATE TABLE order_metrics (
<p>    metric_id UUID PRIMARY KEY DEFAULT uuid_generate_v7(),  -- Time-ordered</p>

<p>    -- Dimensions</p>
<p>    tenant_id UUID NOT NULL,</p>
<p>    customer_id UUID,</p>
<p>    product_id UUID,</p>

<p>    -- Metrics</p>
<p>    metric_type VARCHAR(50) NOT NULL,  -- 'order_created', 'order_shipped', etc.</p>
<p>    metric_value DECIMAL(18, 2),</p>

<p>    -- Temporal</p>
<p>    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),</p>
<p>    date DATE NOT NULL GENERATED ALWAYS AS (DATE(timestamp)) STORED,</p>

<p>    -- Metadata</p>
<p>    metadata JSONB DEFAULT '{}'</p>

<p>) PARTITION BY RANGE (date);</p>

<p>-- Create partitions (monthly)</p>
<p>CREATE TABLE order_metrics_2024_12 PARTITION OF order_metrics</p>
<p>FOR VALUES FROM ('2024-12-01') TO ('2025-01-01');</p>

<p>CREATE TABLE order_metrics_2025_01 PARTITION OF order_metrics</p>
<p>FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');</p>

<p>-- Indexes on partitions</p>
<p>CREATE INDEX idx_order_metrics_2024_12_timestamp ON order_metrics_2024_12 (timestamp DESC);</p>
<p>CREATE INDEX idx_order_metrics_2024_12_tenant_id ON order_metrics_2024_12 (tenant_id);</p>
<p></code></pre></p>

<strong>Perspective Update</strong>:
<pre><code class="language-csharp">public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {
<p>    await using var conn = _db.CreateConnection();</p>

<p>    await conn.ExecuteAsync(</p>
<p>        """</p>
<p>        INSERT INTO order_metrics (</p>
<p>            tenant_id, customer_id, metric_type, metric_value, timestamp, metadata</p>
<p>        ) VALUES (</p>
<p>            @TenantId, @CustomerId, 'order_created', @Total, @Timestamp, @Metadata::jsonb</p>
<p>        )</p>
<p>        """,</p>
<p>        new {</p>
<p>            @event.TenantId,</p>
<p>            @event.CustomerId,</p>
<p>            @event.Total,</p>
<p>            Timestamp = @event.CreatedAt,</p>
<p>            Metadata = JsonSerializer.Serialize(new {</p>
<p>                order_id = @event.OrderId,</p>
<p>                item_count = @event.Items.Length</p>
<p>            })</p>
<p>        },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<strong>Query</strong> (time-range with partition pruning):
<pre><code class="language-sql">-- Query specific time range (PostgreSQL automatically prunes partitions)
<p>SELECT</p>
<p>    DATE(timestamp) AS date,</p>
<p>    COUNT(*) AS order_count,</p>
<p>    SUM(metric_value) AS total_revenue</p>
<p>FROM order_metrics</p>
<p>WHERE tenant_id = '...'</p>
<p>  AND metric_type = 'order_created'</p>
<p>  AND timestamp >= '2024-12-01'</p>
<p>  AND timestamp < '2025-01-01'</p>
<p>GROUP BY DATE(timestamp)</p>
<p>ORDER BY date;</p>
<p></code></pre></p>

<hr>

<h2>Indexing Strategies</h2>

<h3>Primary Key</h3>

<pre><code class="language-sql">-- ✅ UUIDv7 (time-ordered, insert-friendly)
<p>order_id UUID PRIMARY KEY DEFAULT uuid_generate_v7()</p>

<p>-- ❌ Random UUID (index fragmentation)</p>
<p>order_id UUID PRIMARY KEY DEFAULT gen_random_uuid()</p>
<p></code></pre></p>

<h3>Lookup Indexes</h3>

<pre><code class="language-sql">-- Single-column indexes for common filters
<p>CREATE INDEX idx_customer_id ON order_summaries (customer_id);</p>
<p>CREATE INDEX idx_status ON order_summaries (status);</p>

<p>-- Composite indexes for combined filters</p>
<p>CREATE INDEX idx_customer_status ON order_summaries (customer_id, status);</p>

<p>-- Descending indexes for ORDER BY DESC</p>
<p>CREATE INDEX idx_created_at_desc ON order_summaries (created_at DESC);</p>
<p></code></pre></p>

<h3>JSONB Indexes</h3>

<pre><code class="language-sql">-- GIN index for JSONB queries
<p>CREATE INDEX idx_metadata_gin ON products USING GIN (metadata);</p>

<p>-- Specific path index (more efficient)</p>
<p>CREATE INDEX idx_metadata_category ON products ((metadata->>'category'));</p>
<p></code></pre></p>

<h3>Partial Indexes</h3>

<pre><code class="language-sql">-- Index only active orders (saves space)
<p>CREATE INDEX idx_active_orders ON order_summaries (customer_id)</p>
<p>WHERE status IN ('Created', 'Processing', 'Shipped');</p>

<p>-- Index only recent orders (saves space)</p>
<p>CREATE INDEX idx_recent_orders ON order_summaries (created_at DESC)</p>
<p>WHERE created_at > NOW() - INTERVAL '90 days';</p>
<p></code></pre></p>

<h3>Full-Text Search</h3>

<pre><code class="language-sql">-- Add tsvector column for full-text search
<p>ALTER TABLE order_summaries</p>
<p>ADD COLUMN search_vector tsvector</p>
<p>GENERATED ALWAYS AS (</p>
<p>    setweight(to_tsvector('english', COALESCE(customer_name, '')), 'A') ||</p>
<p>    setweight(to_tsvector('english', COALESCE(customer_email, '')), 'B')</p>
<p>) STORED;</p>

<p>-- GIN index for full-text search</p>
<p>CREATE INDEX idx_search_vector ON order_summaries USING GIN (search_vector);</p>

<p>-- Query</p>
<p>SELECT * FROM order_summaries</p>
<p>WHERE search_vector @@ to_tsquery('english', 'john & doe');</p>
<p></code></pre></p>

<hr>

<h2>Multi-Tenancy Patterns</h2>

<h3>Pattern 1: Tenant Column + Row-Level Security</h3>

<pre><code class="language-sql">CREATE TABLE order_summaries (
<p>    order_id UUID PRIMARY KEY,</p>
<p>    tenant_id UUID NOT NULL,</p>
<p>    -- ... other columns</p>

<p>    INDEX idx_tenant_id (tenant_id)</p>
<p>);</p>

<p>-- Row-Level Security (RLS)</p>
<p>ALTER TABLE order_summaries ENABLE ROW LEVEL SECURITY;</p>

<p>CREATE POLICY tenant_isolation ON order_summaries</p>
<p>USING (tenant_id = current_setting('app.current_tenant_id')::UUID);</p>
<p></code></pre></p>

<strong>Application</strong>:
<pre><code class="language-csharp">public async Task<OrderSummary[]> GetOrdersAsync(
<p>    Guid tenantId,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>
<p>    await conn.OpenAsync(ct);</p>

<p>    // Set tenant context</p>
<p>    await conn.ExecuteAsync($"SET app.current_tenant_id = '{tenantId}'");</p>

<p>    // Query (RLS automatically filters by tenant_id)</p>
<p>    var orders = await conn.QueryAsync<OrderSummary>(</p>
<p>        "SELECT * FROM order_summaries ORDER BY created_at DESC",</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    return orders.ToArray();</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern 2: Schema-Per-Tenant</h3>

<pre><code class="language-sql">-- Create schema per tenant
<p>CREATE SCHEMA tenant_abc123;</p>
<p>CREATE SCHEMA tenant_def456;</p>

<p>-- Same table structure in each schema</p>
<p>CREATE TABLE tenant_abc123.order_summaries (</p>
<p>    order_id UUID PRIMARY KEY,</p>
<p>    -- ... columns (no tenant_id needed!)</p>
<p>);</p>

<p>CREATE TABLE tenant_def456.order_summaries (</p>
<p>    order_id UUID PRIMARY KEY,</p>
<p>    -- ... columns</p>
<p>);</p>
<p></code></pre></p>

<strong>Application</strong>:
<pre><code class="language-csharp">public async Task<OrderSummary[]> GetOrdersAsync(
<p>    string tenantSchemaName,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    // Query tenant-specific schema</p>
<p>    var orders = await conn.QueryAsync<OrderSummary>(</p>
<p>        $"SELECT * FROM {tenantSchemaName}.order_summaries ORDER BY created_at DESC",</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    return orders.ToArray();</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefit</strong>: Complete data isolation, easier to move tenants to separate databases.

<hr>

<h2>Materialized Views (Alternative to Perspectives)</h2>

<strong>Materialized Views</strong> are an alternative to perspectives for complex queries:

<pre><code class="language-sql">-- Create materialized view
<p>CREATE MATERIALIZED VIEW order_daily_summary AS</p>
<p>SELECT</p>
<p>    DATE(created_at) AS order_date,</p>
<p>    status,</p>
<p>    COUNT(*) AS order_count,</p>
<p>    SUM(total) AS total_revenue,</p>
<p>    AVG(total) AS average_order_value</p>
<p>FROM order_summaries</p>
<p>GROUP BY DATE(created_at), status;</p>

<p>-- Index for fast lookups</p>
<p>CREATE INDEX idx_order_daily_summary_date ON order_daily_summary (order_date DESC);</p>

<p>-- Refresh (manual)</p>
<p>REFRESH MATERIALIZED VIEW order_daily_summary;</p>

<p>-- Refresh (concurrent - doesn't block reads)</p>
<p>REFRESH MATERIALIZED VIEW CONCURRENTLY order_daily_summary;</p>
<p></code></pre></p>

<strong>Comparison</strong>:

<p>| Aspect | Perspectives (Event-Driven) | Materialized Views |</p>
<p>|--------|----------------------------|-------------------|</p>
<p>| <strong>Updates</strong> | Real-time (event-driven) | Manual/scheduled refresh |</p>
<p>| <strong>Freshness</strong> | < 100ms typical lag | Depends on refresh frequency |</p>
<p>| <strong>Flexibility</strong> | Custom business logic | SQL-only |</p>
<p>| <strong>Performance</strong> | Excellent (indexed table) | Excellent (indexed view) |</p>
<p>| <strong>Use Case</strong> | Real-time dashboards | Batch reports, analytics |</p>

<strong>Recommendation</strong>: Use perspectives for real-time, materialized views for batch reports.

<hr>

<h2>Migration Strategies</h2>

<h3>Strategy 1: Schema Migrations with EF Core</h3>

<pre><code class="language-csharp">// Migration: Add order_summaries table
<p>public partial class AddOrderSummaries : Migration {</p>
<p>    protected override void Up(MigrationBuilder migrationBuilder) {</p>
<p>        migrationBuilder.Sql("CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";");</p>

<p>        migrationBuilder.CreateTable(</p>
<p>            name: "order_summaries",</p>
<p>            columns: table => new {</p>
<p>                order_id = table.Column<Guid>(nullable: false, defaultValueSql: "uuid_generate_v7()"),</p>
<p>                status = table.Column<string>(maxLength: 50, nullable: false),</p>
<p>                total = table.Column<decimal>(type: "decimal(18,2)", nullable: false),</p>
<p>                created_at = table.Column<DateTimeOffset>(nullable: false, defaultValueSql: "NOW()"),</p>
<p>                customer_id = table.Column<Guid>(nullable: false),</p>
<p>                customer_name = table.Column<string>(maxLength: 200, nullable: false),</p>
<p>                customer_email = table.Column<string>(maxLength: 200, nullable: false)</p>
<p>            },</p>
<p>            constraints: table => {</p>
<p>                table.PrimaryKey("pk_order_summaries", x => x.order_id);</p>
<p>            }</p>
<p>        );</p>

<p>        migrationBuilder.CreateIndex(</p>
<p>            name: "ix_order_summaries_customer_id",</p>
<p>            table: "order_summaries",</p>
<p>            column: "customer_id"</p>
<p>        );</p>

<p>        migrationBuilder.CreateIndex(</p>
<p>            name: "ix_order_summaries_created_at",</p>
<p>            table: "order_summaries",</p>
<p>            column: "created_at",</p>
<p>            descending: true</p>
<p>        );</p>
<p>    }</p>

<p>    protected override void Down(MigrationBuilder migrationBuilder) {</p>
<p>        migrationBuilder.DropTable(name: "order_summaries");</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Strategy 2: SQL Scripts</h3>

<pre><code class="language-sql">-- migrations/001_create_order_summaries.sql
<p>CREATE EXTENSION IF NOT EXISTS "uuid-ossp";</p>

<p>CREATE TABLE order_summaries (</p>
<p>    order_id UUID PRIMARY KEY DEFAULT uuid_generate_v7(),</p>
<p>    status VARCHAR(50) NOT NULL,</p>
<p>    total DECIMAL(18, 2) NOT NULL,</p>
<p>    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),</p>
<p>    customer_id UUID NOT NULL,</p>
<p>    customer_name VARCHAR(200) NOT NULL,</p>
<p>    customer_email VARCHAR(200) NOT NULL</p>
<p>);</p>

<p>CREATE INDEX idx_order_summaries_customer_id ON order_summaries (customer_id);</p>
<p>CREATE INDEX idx_order_summaries_created_at ON order_summaries (created_at DESC);</p>
<p></code></pre></p>

<strong>Apply with psql</strong>:
<pre><code class="language-bash">psql -U postgres -d whizbang -f migrations/001_create_order_summaries.sql
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Denormalize aggressively</strong> - Store all data needed for queries in one table</li>
<li>✅ <strong>Use UUIDv7</strong> for primary keys (time-ordered, insert-friendly)</li>
<li>✅ <strong>Use JSONB</strong> for flexible, evolving data</li>
<li>✅ <strong>Index common filters</strong> - customer_id, status, created_at</li>
<li>✅ <strong>Use partial indexes</strong> - Index only relevant data (active records, recent records)</li>
<li>✅ <strong>Use GIN indexes</strong> for JSONB queries</li>
<li>✅ <strong>Use partitioning</strong> for high-volume time-series data</li>
<li>✅ <strong>Test query performance</strong> with EXPLAIN ANALYZE</li>
<li>✅ <strong>Monitor index usage</strong> - Drop unused indexes</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Normalize perspectives (defeats the purpose)</li>
<li>❌ Use random UUIDs (index fragmentation)</li>
<li>❌ Skip indexes on foreign keys (customer_id, product_id)</li>
<li>❌ Over-index (every index slows writes)</li>
<li>❌ Store BLOBs in PostgreSQL (use object storage)</li>
<li>❌ Use triggers for perspective updates (use events)</li>
<li>❌ Use materialized views for real-time data (use perspectives)</li>
</ul>
<hr>

<h2>Performance Tuning</h2>

<h3>Query Analysis</h3>

<pre><code class="language-sql">-- Analyze query performance
<p>EXPLAIN ANALYZE</p>
<p>SELECT * FROM order_summaries</p>
<p>WHERE customer_id = '...'</p>
<p>ORDER BY created_at DESC</p>
<p>LIMIT 10;</p>
<p></code></pre></p>

<strong>Look for</strong>:
<ul><li><strong>Seq Scan</strong> (bad) → Add index</li>
<li><strong>Index Scan</strong> (good)</li>
<li><strong>Bitmap Heap Scan</strong> (good for low selectivity)</li>
</ul>
<h3>Index Usage Monitoring</h3>

<pre><code class="language-sql">-- Find unused indexes
<p>SELECT</p>
<p>    schemaname,</p>
<p>    tablename,</p>
<p>    indexname,</p>
<p>    idx_scan AS index_scans</p>
<p>FROM pg_stat_user_indexes</p>
<p>WHERE idx_scan = 0</p>
<p>  AND indexrelname NOT LIKE 'pg_%'</p>
<p>ORDER BY schemaname, tablename;</p>
<p></code></pre></p>

<h3>Table Bloat Monitoring</h3>

<pre><code class="language-sql">-- Check table bloat (dead rows)
<p>SELECT</p>
<p>    schemaname,</p>
<p>    tablename,</p>
<p>    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,</p>
<p>    n_dead_tup AS dead_tuples</p>
<p>FROM pg_stat_user_tables</p>
<p>WHERE n_dead_tup > 1000</p>
<p>ORDER BY n_dead_tup DESC;</p>

<p>-- Fix bloat</p>
<p>VACUUM ANALYZE order_summaries;</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/perspectives.md">Perspectives</a> - Event-driven read models</li>
<li><a href="../core-concepts/lenses.md">Lenses</a> - Query repositories</li>
</ul>
<strong>Data Access</strong>:
<ul><li><a href="dapper-integration.md">Dapper Integration</a> - Lightweight data access</li>
<li><a href="efcore-integration.md">EF Core Integration</a> - Full-featured ORM</li>
<li><a href="event-store.md">Event Store</a> - Event storage and replay</li>
</ul>
<strong>Messaging</strong>:
<ul><li><a href="../messaging/outbox-pattern.md">Outbox Pattern</a> - Reliable event publishing</li>
<li><a href="../messaging/inbox-pattern.md">Inbox Pattern</a> - Exactly-once processing</li>
</ul>
<strong>Examples</strong>:
<ul><li><a href="../examples/ecommerce/bff-pattern.md">ECommerce: BFF Perspectives</a> - Real-world perspective design</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-data-schema-migration" class="doc-section">
  <h3>schema migration</h3>
  <p class="doc-path"><code>v1.0.0/data/schema-migration</code></p>
  <div class="doc-content">
<h1>Schema Migration</h1>

<p>Whizbang provides automatic schema management for perspective tables, with built-in drift detection and safe rename operations. This page covers how Whizbang handles schema changes across deployments.</p>

<h2>Automatic Schema Creation</h2>

<p>When your application starts, Whizbang automatically creates all required infrastructure tables and perspective tables:</p>

<pre><code class="language-csharp">// In your startup code
<p>await dbContext.EnsureWhizbangDatabaseInitializedAsync();</p>
<p></code></pre></p>

<p>This single call:</p>
<ul><li>Creates infrastructure tables (<code>wh_inbox</code>, <code>wh_outbox</code>, <code>wh_event_store</code>, etc.)</li>
<li>Creates perspective tables for all discovered perspectives</li>
<li>Registers perspectives in the <a href="/docs/v1.0.0/perspectives/registry">perspective registry</a></li>
<li>Detects and logs any schema drift</li>
</ul>
<h2>Schema Drift Detection</h2>

<p>Schema drift occurs when your C# perspective definition doesn't match the database table. Whizbang detects this by comparing SHA-256 hashes of the schema definition.</p>

<h3>Detection Flow</h3>

<pre><code class="language-">┌─────────────────────┐
<p>│  Compile Time       │</p>
<p>├─────────────────────┤</p>
<p>│ Generate schema     │</p>
<p>│ JSON from C# class  │</p>
<p>│ Compute SHA-256     │</p>
<p>│ hash of schema      │</p>
<p>└─────────┬───────────┘</p>
<p>          │</p>
<p>          ▼</p>
<p>┌─────────────────────┐</p>
<p>│  Runtime            │</p>
<p>├─────────────────────┤</p>
<p>│ Compare hash with   │</p>
<p>│ stored hash in      │</p>
<p>│ perspective_registry│</p>
<p>└─────────┬───────────┘</p>
<p>          │</p>
<p>          ▼</p>
<p>┌─────────────────────┐</p>
<p>│  If Different       │</p>
<p>├─────────────────────┤</p>
<p>│ Log drift warning   │</p>
<p>│ Update registry     │</p>
<p>└─────────────────────┘</p>
<p></code></pre></p>

<h3>What Causes Drift</h3>

<p>| Change Type | Example | Drift Detected? |</p>
<p>|-------------|---------|-----------------|</p>
<p>| Add property | Add <code>Email</code> to <code>CustomerData</code> | Yes |</p>
<p>| Remove property | Remove <code>Phone</code> from <code>CustomerData</code> | Yes |</p>
<p>| Change type | <code>int CustomerId</code> → <code>Guid CustomerId</code> | Yes |</p>
<p>| Add physical field | Add <code>[PhysicalField]</code> attribute | Yes |</p>
<p>| Add index | Add <code>[Index]</code> attribute | Yes |</p>
<p>| Rename property | <code>Name</code> → <code>FullName</code> | Yes |</p>
<p>| Reorder properties | Move <code>Email</code> before <code>Name</code> | No* |</p>

<p>*Property order doesn't affect the schema hash.</p>

<h3>Handling Drift</h3>

<p>When drift is detected, Whizbang logs a warning:</p>

<pre><code class="language-">[WRN] Schema drift detected for MyApp.CustomerProjection
<p>      Expected hash: a1b2c3d4...</p>
<p>      Stored hash:   e5f6g7h8...</p>
<p>      Table: wh_per_customer</p>
<p></code></pre></p>

<p>You have several options:</p>

<h4>Option 1: Ignore (Default)</h4>

<p>If the changes are backward-compatible (adding nullable columns), you can proceed safely:</p>

<pre><code class="language-csharp">services.AddWhizbang(options => {
<p>  options.Perspectives.OnSchemaDrift = SchemaDriftBehavior.LogWarning;</p>
<p>});</p>
<p></code></pre></p>

<h4>Option 2: Throw Exception</h4>

<p>For strict environments where drift should block deployment:</p>

<pre><code class="language-csharp">services.AddWhizbang(options => {
<p>  options.Perspectives.OnSchemaDrift = SchemaDriftBehavior.ThrowException;</p>
<p>});</p>
<p></code></pre></p>

<h4>Option 3: Manual Migration</h4>

<p>For breaking changes, create a migration:</p>

<pre><code class="language-sql">-- Add new column
<p>ALTER TABLE wh_per_customer</p>
<p>ADD COLUMN email VARCHAR(255);</p>

<p>-- Update existing rows if needed</p>
<p>UPDATE wh_per_customer</p>
<p>SET data = jsonb_set(data, '{email}', '"unknown@example.com"')</p>
<p>WHERE data->>'email' IS NULL;</p>
<p></code></pre></p>

<h2>Automatic Table Renaming</h2>

<p>When you rename a perspective class or change its <a href="/docs/v1.0.0/perspectives/table-naming">table naming</a> configuration, Whizbang automatically renames the table:</p>

<h3>How It Works</h3>

<ul><li>Source generator computes new table name</li>
<li>Application starts and calls reconciliation</li>
<li>Registry finds existing entry for the CLR type</li>
<li>Detects table name mismatch</li>
<li>Executes <code>ALTER TABLE ... RENAME TO ...</code></li>
<li>Updates registry with new name</li>
</ul>
<h3>Example</h3>

<pre><code class="language-csharp">// Before: Table is wh_per_customer_dto
<p>public class CustomerDto : IPerspectiveFor<CustomerData, CustomerEvent> { }</p>

<p>// After: You enable suffix stripping (default in v1.0.0)</p>
<p>// Table becomes wh_per_customer</p>
<p>public class CustomerDto : IPerspectiveFor<CustomerData, CustomerEvent> { }</p>
<p></code></pre></p>

<p>On deployment:</p>
<pre><code class="language-sql">-- Executed automatically
<p>ALTER TABLE wh_per_customer_dto RENAME TO wh_per_customer;</p>
<p></code></pre></p>

<h3>Rename Safety</h3>

<p>The rename operation is safe because:</p>
<ul><li>It's atomic (single DDL statement)</li>
<li>No data is modified or lost</li>
<li>Indexes and constraints are preserved</li>
<li>Registry tracks the change for auditing</li>
</ul>
<h2>Multi-Environment Considerations</h2>

<h3>Development vs Production</h3>

<pre><code class="language-csharp">services.AddWhizbang(options => {
<p>  if (env.IsDevelopment()) {</p>
<p>    // Recreate tables on schema change (lose data)</p>
<p>    options.Perspectives.OnSchemaDrift = SchemaDriftBehavior.RecreateTable;</p>
<p>  } else {</p>
<p>    // Strict mode for production</p>
<p>    options.Perspectives.OnSchemaDrift = SchemaDriftBehavior.ThrowException;</p>
<p>  }</p>
<p>});</p>
<p></code></pre></p>

<h3>CI/CD Pipeline</h3>

<p>Include schema validation in your deployment pipeline:</p>

<pre><code class="language-yaml"># Azure DevOps / GitHub Actions example
<ul><li>name: Validate Schema</li>
</ul><p>  run: |</p>
<p>    dotnet run --project MyApp.Api -- --validate-schema-only</p>
<p>    if [ $? -ne 0 ]; then</p>
<p>      echo "Schema drift detected! Run migrations before deploying."</p>
<p>      exit 1</p>
<p>    fi</p>
<p></code></pre></p>

<h2>Infrastructure Schema</h2>

<p>Whizbang infrastructure tables are versioned and migrated automatically:</p>

<p>| Table | Purpose |</p>
<p>|-------|---------|</p>
<p>| <code>wh_inbox</code> | Message deduplication |</p>
<p>| <code>wh_outbox</code> | Transactional messaging |</p>
<p>| <code>wh_event_store</code> | Event persistence |</p>
<p>| <code>wh_perspective_registry</code> | CLR type → table mapping |</p>
<p>| <code>wh_perspective_checkpoints</code> | Projection progress tracking |</p>
<p>| <code>wh_service_instances</code> | Distributed coordination |</p>

<h3>Migration Files</h3>

<p>Infrastructure migrations are embedded in the Whizbang.Data.Postgres package:</p>

<pre><code class="language-">Migrations/
<p>├── 001_CreateComputePartitionFunction.sql</p>
<p>├── 002_CreateAcquireReceptorProcessingFunction.sql</p>
<p>├── ...</p>
<p>├── 030_DecompositionComplete.sql</p>
<p>└── 031_ReconcilePerspectiveRegistry.sql</p>
<p></code></pre></p>

<p>Migrations are applied automatically and idempotently.</p>

<h2>Schema JSON Format</h2>

<p>The registry stores full schema definitions as JSON:</p>

<pre><code class="language-json">{
<p>  "columns": [</p>
<p>    {</p>
<p>      "name": "id",</p>
<p>      "type": "uuid",</p>
<p>      "nullable": false,</p>
<p>      "isPrimaryKey": true</p>
<p>    },</p>
<p>    {</p>
<p>      "name": "data",</p>
<p>      "type": "jsonb",</p>
<p>      "nullable": false</p>
<p>    },</p>
<p>    {</p>
<p>      "name": "customer_id",</p>
<p>      "type": "uuid",</p>
<p>      "nullable": true,</p>
<p>      "isPhysicalField": true</p>
<p>    }</p>
<p>  ],</p>
<p>  "indexes": [</p>
<p>    {</p>
<p>      "name": "idx_customer_customer_id",</p>
<p>      "columns": ["customer_id"],</p>
<p>      "type": "btree",</p>
<p>      "isUnique": false</p>
<p>    }</p>
<p>  ]</p>
<p>}</p>
<p></code></pre></p>

<h3>Supported Column Types</h3>

<p>| C# Type | PostgreSQL | JSON Key |</p>
<p>|---------|------------|----------|</p>
<p>| <code>Guid</code> | <code>UUID</code> | <code>"uuid"</code> |</p>
<p>| <code>string</code> | <code>TEXT</code> | <code>"text"</code> |</p>
<p>| <code>int</code> | <code>INTEGER</code> | <code>"integer"</code> |</p>
<p>| <code>long</code> | <code>BIGINT</code> | <code>"bigint"</code> |</p>
<p>| <code>bool</code> | <code>BOOLEAN</code> | <code>"boolean"</code> |</p>
<p>| <code>DateTime</code> | <code>TIMESTAMPTZ</code> | <code>"timestamptz"</code> |</p>
<p>| <code>byte[]</code> | <code>BYTEA</code> | <code>"bytea"</code> |</p>
<p>| JSON data | <code>JSONB</code> | <code>"jsonb"</code> |</p>
<p>| <code>Vector</code> | <code>VECTOR(n)</code> | <code>"vector"</code> |</p>

<h3>Index Types</h3>

<p>| Index Type | PostgreSQL | Use Case |</p>
<p>|------------|------------|----------|</p>
<p>| <code>btree</code> | B-Tree | General queries, sorting |</p>
<p>| <code>gin</code> | GIN | JSONB containment, full-text |</p>
<p>| <code>ivfflat</code> | IVF Flat | Vector similarity (approximate) |</p>
<p>| <code>hnsw</code> | HNSW | Vector similarity (fast) |</p>

<h2>Rollback Strategies</h2>

<h3>Preserve Old Table</h3>

<p>Before making breaking changes, rename the old table:</p>

<pre><code class="language-sql">-- Before deployment
<p>ALTER TABLE wh_per_customer RENAME TO wh_per_customer_backup;</p>

<p>-- After verifying new version works</p>
<p>DROP TABLE wh_per_customer_backup;</p>
<p></code></pre></p>

<h3>Dual-Write Period</h3>

<p>For zero-downtime migrations:</p>

<ul><li>Deploy new code that writes to both old and new tables</li>
<li>Backfill new table from old table</li>
<li>Switch reads to new table</li>
<li>Remove dual-write code</li>
<li>Drop old table</li>
</ul>
<h2>Troubleshooting</h2>

<h3>"Schema drift detected" Warning</h3>

<strong>Cause</strong>: C# class changed but database table wasn't updated.

<strong>Solutions</strong>:
<ul><li>For nullable additions: Safe to ignore</li>
<li>For breaking changes: Run migration</li>
<li>For development: Set <code>RecreateTable</code> behavior</li>
</ul>
<h3>"Table rename failed"</h3>

<strong>Cause</strong>: Old table doesn't exist or name collision.

<strong>Solutions</strong>:
<ul><li>Check if table was already renamed manually</li>
<li>Check for existing table with new name</li>
<li>Run <code>SELECT * FROM wh_perspective_registry</code> to see current state</li>
</ul>
<h3>"Perspective not found in registry"</h3>

<strong>Cause</strong>: First deployment or registry was cleared.

<strong>Solutions</strong>:
<ul><li>Expected on first run - table will be created</li>
<li>If registry was cleared, tables still exist but aren't tracked</li>
<li>Manually insert registry entries if needed</li>
</ul>
<h2>See Also</h2>

<ul><li><a href="/docs/v1.0.0/perspectives/registry">Perspective Registry</a> - CLR type tracking</li>
<li><a href="/docs/v1.0.0/perspectives/table-naming">Table Naming</a> - Naming conventions</li>
<li><a href="/docs/v1.0.0/data/efcore-json-configuration">EF Core JSON Configuration</a> - JSON column setup</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-data-turnkey-initialization" class="doc-section">
  <h3>turnkey initialization</h3>
  <p class="doc-path"><code>v1.0.0/data/turnkey-initialization</code></p>
  <div class="doc-content">
<h1>Turnkey Database Initialization</h1>

<p>Whizbang provides a simple one-line initialization method that ensures your database schema is ready before your application starts. This prevents race conditions where background services might try to query the database before tables or extensions (like pgvector) are created.</p>

<h2>Quick Start</h2>

<pre><code class="language-csharp">var app = builder.Build();

<p>// Initialize Whizbang database BEFORE starting the app</p>
<p>await app.EnsureWhizbangInitializedAsync();</p>

<p>await app.RunAsync();</p>
<p></code></pre></p>

<h2>What It Does</h2>

<code>EnsureWhizbangInitializedAsync()</code> performs the following for each registered <code>[WhizbangDbContext]</code>:

<ul><li><strong>Creates core infrastructure tables</strong> - Inbox, Outbox, EventStore, and other Whizbang tables</li>
<li><strong>Creates perspective tables</strong> - Tables for your <code>PerspectiveRow<TModel></code> types</li>
<li><strong>Adds constraints and indexes</strong> - Foreign keys, composite primary keys, GIN indexes on JSONB columns</li>
<li><strong>Installs PostgreSQL extensions</strong> - Creates <code>vector</code> extension if any perspectives have <code>[VectorField]</code> columns</li>
<li><strong>Creates PostgreSQL functions</strong> - <code>process_work_batch</code>, <code>register_message_associations</code>, etc.</li>
<li><strong>Registers perspective associations</strong> - Populates routing metadata for event dispatching</li>
</ul>
<h2>Why Use It</h2>

<h3>Before (Manual Initialization)</h3>

<pre><code class="language-csharp">// Error-prone: Must remember to do this for each DbContext
<p>// Risk: Code might run in the wrong order or be forgotten</p>
<p>{</p>
<p>  using var scope = app.Services.CreateScope();</p>
<p>  var logger = scope.ServiceProvider.GetRequiredService<ILogger<Program>>();</p>
<p>  var dbContext = scope.ServiceProvider.GetRequiredService<MyDbContext>();</p>
<p>  await dbContext.EnsureWhizbangDatabaseInitializedAsync(logger);</p>
<p>}</p>
<p>await app.RunAsync();</p>
<p></code></pre></p>

<h3>After (Turnkey Initialization)</h3>

<pre><code class="language-csharp">// Simple: One line initializes ALL registered DbContexts
<p>// Safe: Runs before app starts, preventing race conditions</p>
<p>await app.EnsureWhizbangInitializedAsync();</p>
<p>await app.RunAsync();</p>
<p></code></pre></p>

<h2>How It Works</h2>

<p>The source generator automatically registers each <code>[WhizbangDbContext]</code>-annotated DbContext with <code>DbContextInitializationRegistry</code>. When you call <code>EnsureWhizbangInitializedAsync()</code>, it:</p>

<ul><li>Iterates through all registered DbContexts</li>
<li>Resolves each DbContext from the service provider</li>
<li>Calls <code>EnsureWhizbangDatabaseInitializedAsync()</code> on each</li>
</ul>
<p>This is AOT-compatible with no reflection - all registration happens via source-generated module initializers.</p>

<h2>Multiple DbContexts</h2>

<p>If your application has multiple Whizbang DbContexts, they are all initialized automatically:</p>

<pre><code class="language-csharp">// Both DbContexts are initialized with one call
<p>builder.Services.AddWhizbang()</p>
<p>    .WithEFCore<OrderDbContext>()</p>
<p>    .WithDriver.Postgres;</p>

<p>builder.Services.AddWhizbang()</p>
<p>    .WithEFCore<InventoryDbContext>()</p>
<p>    .WithDriver.Postgres;</p>

<p>var app = builder.Build();</p>
<p>await app.EnsureWhizbangInitializedAsync(); // Initializes both!</p>
<p>await app.RunAsync();</p>
<p></code></pre></p>

<h2>Logging</h2>

<p>Initialization progress is logged at <code>Information</code> level:</p>

<pre><code class="language-">info: Whizbang.Initialization[0]
<p>      Initializing 1 Whizbang DbContext(s)...</p>
<p>info: Whizbang.Initialization[0]</p>
<p>      Initializing ChatDbContext...</p>
<p>info: Whizbang.Initialization[0]</p>
<p>      All Whizbang DbContext(s) initialized successfully</p>
<p></code></pre></p>

<h2>Idempotency</h2>

<p>All initialization operations are idempotent. It's safe to call <code>EnsureWhizbangInitializedAsync()</code> multiple times - existing tables and functions are not recreated.</p>

<h2>See Also</h2>

<ul><li><a href="./efcore-json-configuration.md">EF Core JSON Configuration</a></li>
<li><a href="./schema-migration.md">Schema Migration</a></li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Data Access</h2>
<article id="v1-0-0-data-access-schema-generation-pattern" class="doc-section">
  <h3>Schema Generation Pattern</h3>
  <p class="doc-path"><code>v1.0.0/data-access/schema-generation-pattern</code></p>
  <p class="doc-description"><em>Database-agnostic schema definitions with ISchemaBuilder for Postgres, SQLite, and custom database engines</em></p>
  <div class="doc-content">

<h1>Schema Generation Pattern</h1>

<p>Whizbang uses a <strong>database-agnostic schema definition pattern</strong> where infrastructure schemas are defined once in C# and transformed into database-specific DDL via the <code>ISchemaBuilder</code> interface.</p>

<h2>Core Concept</h2>

<strong>Problem</strong>: Different databases (Postgres, SQLite, MySQL) have different DDL syntax, but the logical schema structure is the same.

<strong>Solution</strong>: Define schema once using <code>TableDefinition</code>, <code>ColumnDefinition</code>, <code>IndexDefinition</code>, then transform to database-specific SQL via <code>ISchemaBuilder</code> implementations.

<pre><code class="language-">┌─────────────────────────────┐
<p>│  C# Schema Definitions      │</p>
<p>│  (Database-Agnostic)        │</p>
<p>│                             │</p>
<p>│  - InboxSchema              │</p>
<p>│  - OutboxSchema             │</p>
<p>│  - EventStoreSchema         │</p>
<p>│  - PerspectiveCheckpoints   │</p>
<p>└──────────────┬──────────────┘</p>
<p>               │</p>
<p>               ▼</p>
<p>      ┌────────────────┐</p>
<p>      │ ISchemaBuilder │</p>
<p>      └────────┬───────┘</p>
<p>               │</p>
<p>      ┌────────┼────────┐</p>
<p>      │        │        │</p>
<p>      ▼        ▼        ▼</p>
<p>┌─────────┐ ┌────────┐ ┌────────┐</p>
<p>│ Postgres│ │ SQLite │ │ MySQL  │</p>
<p>│ Builder │ │ Builder│ │ Builder│</p>
<p>└────┬────┘ └───┬────┘ └───┬────┘</p>
<p>     │          │           │</p>
<p>     ▼          ▼           ▼</p>
<p>  Postgres   SQLite      MySQL</p>
<p>    DDL        DDL         DDL</p>
<p></code></pre></p>

<hr>

<h2>ISchemaBuilder Interface</h2>

<pre><code class="language-csharp">public interface ISchemaBuilder {
<p>  /// <summary></p>
<p>  /// Database engine name (e.g., "Postgres", "SQLite", "MySQL").</p>
<p>  /// </summary></p>
<p>  string DatabaseEngine { get; }</p>

<p>  /// <summary></p>
<p>  /// Builds CREATE TABLE DDL for a single table.</p>
<p>  /// </summary></p>
<p>  string BuildCreateTable(TableDefinition table, string prefix);</p>

<p>  /// <summary></p>
<p>  /// Builds CREATE INDEX DDL for a single index.</p>
<p>  /// </summary></p>
<p>  string BuildCreateIndex(IndexDefinition index, string tableName, string prefix);</p>

<p>  /// <summary></p>
<p>  /// Builds CREATE SEQUENCE DDL for a single sequence.</p>
<p>  /// </summary></p>
<p>  string BuildCreateSequence(SequenceDefinition sequence, string prefix);</p>

<p>  /// <summary></p>
<p>  /// Builds complete infrastructure schema DDL.</p>
<p>  /// AUTHORITATIVE method - all consumers MUST use this for consistency.</p>
<p>  /// </summary></p>
<p>  string BuildInfrastructureSchema(SchemaConfiguration config);</p>

<p>  /// <summary></p>
<p>  /// Builds perspective table DDL.</p>
<p>  /// Fixed schema: stream_id (PK), data (JSON), version, updated_at.</p>
<p>  /// </summary></p>
<p>  string BuildPerspectiveTable(string tableName);</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Methods</strong>:
<ul><li><code>BuildInfrastructureSchema()</code> - <strong>Primary method</strong> for generating all infrastructure tables</li>
<li><code>BuildCreateTable()</code> - Individual table generation</li>
<li><code>BuildCreateIndex()</code> - Individual index generation</li>
<li><code>BuildPerspectiveTable()</code> - Perspective-specific tables with fixed schema</li>
</ul>
<hr>

<h2>Database-Agnostic Schema Definitions</h2>

<h3>TableDefinition</h3>

<pre><code class="language-csharp">public sealed record TableDefinition(
<p>  string Name,                                    // Table name without prefix</p>
<p>  ImmutableArray<ColumnDefinition> Columns,       // Column definitions</p>
<p>  ImmutableArray<IndexDefinition> Indexes,        // Index definitions</p>
<p>  ImmutableArray<UniqueConstraintDefinition> UniqueConstraints</p>
<p>);</p>
<p></code></pre></p>

<strong>Example - Inbox Table</strong>:

<pre><code class="language-csharp">using System.Collections.Immutable;
<p>using Whizbang.Data.Schema;</p>

<p>public static class InboxSchema {</p>
<p>  public static readonly TableDefinition Table = new(</p>
<p>    Name: "inbox",</p>
<p>    Columns: ImmutableArray.Create(</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "message_id",</p>
<p>        DataType: WhizbangDataType.Uuid,</p>
<p>        PrimaryKey: true,</p>
<p>        Nullable: false</p>
<p>      ),</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "handler_name",</p>
<p>        DataType: WhizbangDataType.String,</p>
<p>        MaxLength: 500,</p>
<p>        Nullable: false</p>
<p>      ),</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "received_at",</p>
<p>        DataType: WhizbangDataType.TimestampTz,</p>
<p>        Nullable: false,</p>
<p>        DefaultValue: DefaultValue.Function(DefaultValueFunction.DateTime_Now)</p>
<p>      )</p>
<p>    ),</p>
<p>    Indexes: ImmutableArray.Create(</p>
<p>      new IndexDefinition(</p>
<p>        Name: "idx_inbox_received_at",</p>
<p>        Columns: ImmutableArray.Create("received_at")</p>
<p>      )</p>
<p>    )</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<h3>ColumnDefinition</h3>

<pre><code class="language-csharp">public sealed record ColumnDefinition(
<p>  string Name,                     // Column name</p>
<p>  WhizbangDataType DataType,       // Database-agnostic type</p>
<p>  int? MaxLength = null,           // For strings</p>
<p>  bool PrimaryKey = false,         // Is primary key</p>
<p>  bool Nullable = false,           // Can be null</p>
<p>  bool Unique = false,             // Has unique constraint</p>
<p>  DefaultValue? DefaultValue = null // Default value</p>
<p>);</p>
<p></code></pre></p>

<strong>WhizbangDataType Enum</strong>:
<pre><code class="language-csharp">public enum WhizbangDataType {
<p>  Uuid,           // UUID/GUID</p>
<p>  String,         // VARCHAR</p>
<p>  Integer,        // INT/BIGINT</p>
<p>  BigInt,         // BIGINT</p>
<p>  Boolean,        // BOOL</p>
<p>  TimestampTz,    // TIMESTAMPTZ</p>
<p>  Json,           // JSON/JSONB</p>
<p>  Decimal         // DECIMAL/NUMERIC</p>
<p>}</p>
<p></code></pre></p>

<h3>IndexDefinition</h3>

<pre><code class="language-csharp">public sealed record IndexDefinition(
<p>  string Name,                            // Index name</p>
<p>  ImmutableArray<string> Columns,         // Indexed columns</p>
<p>  bool Unique = false,                    // Unique index</p>
<p>  string? WhereClause = null              // Partial index (Postgres)</p>
<p>);</p>
<p></code></pre></p>

<strong>Example - Partial Index</strong>:
<pre><code class="language-csharp">new IndexDefinition(
<p>  Name: "idx_inbox_lease_expiry",</p>
<p>  Columns: ImmutableArray.Create("lease_expiry"),</p>
<p>  WhereClause: "lease_expiry IS NOT NULL"  // Only index non-null</p>
<p>)</p>
<p></code></pre></p>

<hr>

<h2>PostgreSQL Implementation</h2>

<h3>PostgresSchemaBuilder</h3>

<pre><code class="language-csharp">using Whizbang.Data.Schema;

<p>public class PostgresSchemaBuilder : ISchemaBuilder {</p>
<p>  public string DatabaseEngine => "Postgres";</p>

<p>  public string BuildCreateTable(TableDefinition table, string prefix) {</p>
<p>    var tableName = $"{prefix}{table.Name}";</p>

<p>    // Generate: CREATE TABLE IF NOT EXISTS {tableName} ( ... );</p>
<p>    // - Handle composite primary keys</p>
<p>    // - Handle unique constraints</p>
<p>    // - Handle default values</p>

<p>    return sql;</p>
<p>  }</p>

<p>  public string BuildCreateIndex(IndexDefinition index, string tableName, string prefix) {</p>
<p>    var fullTableName = $"{prefix}{tableName}";</p>
<p>    var unique = index.Unique ? "UNIQUE " : "";</p>
<p>    var columns = string.Join(", ", index.Columns);</p>
<p>    var whereClause = index.WhereClause != null ? $" WHERE {index.WhereClause}" : "";</p>

<p>    return $"CREATE {unique}INDEX IF NOT EXISTS {index.Name} ON {fullTableName} ({columns}){whereClause};";</p>
<p>  }</p>

<p>  public string BuildInfrastructureSchema(SchemaConfiguration config) {</p>
<p>    var sb = new StringBuilder();</p>

<p>    // Generate all infrastructure tables</p>
<p>    var tables = new[] {</p>
<p>      InboxSchema.Table,</p>
<p>      OutboxSchema.Table,</p>
<p>      EventStoreSchema.Table,</p>
<p>      PerspectiveCheckpointsSchema.Table,</p>
<p>      // ... etc</p>
<p>    };</p>

<p>    foreach (var table in tables) {</p>
<p>      sb.AppendLine(BuildCreateTable(table, config.InfrastructurePrefix));</p>

<p>      foreach (var index in table.Indexes) {</p>
<p>        sb.AppendLine(BuildCreateIndex(index, table.Name, config.InfrastructurePrefix));</p>
<p>      }</p>
<p>    }</p>

<p>    return sb.ToString();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Type Mapping - Postgres</strong>:
<pre><code class="language-csharp">internal static class PostgresTypeMapper {
<p>  public static string MapDataType(WhizbangDataType type, int? maxLength) {</p>
<p>    return type switch {</p>
<p>      WhizbangDataType.Uuid => "UUID",</p>
<p>      WhizbangDataType.String => maxLength.HasValue</p>
<p>        ? $"VARCHAR({maxLength.Value})"</p>
<p>        : "TEXT",</p>
<p>      WhizbangDataType.Integer => "INT",</p>
<p>      WhizbangDataType.BigInt => "BIGINT",</p>
<p>      WhizbangDataType.Boolean => "BOOLEAN",</p>
<p>      WhizbangDataType.TimestampTz => "TIMESTAMPTZ",</p>
<p>      WhizbangDataType.Json => "JSONB",  // Postgres-specific: JSONB not JSON</p>
<p>      WhizbangDataType.Decimal => "DECIMAL(18,2)",</p>
<p>      _ => throw new ArgumentException($"Unsupported data type: {type}")</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Usage Patterns</h2>

<h3>Pattern 1: EF Core Migration Generator</h3>

<pre><code class="language-csharp">using Whizbang.Data.Schema;
<p>using Whizbang.Data.Postgres.Schema;</p>

<p>public class InfrastructureMigration {</p>
<p>  public void BuildSchema(MigrationBuilder migrationBuilder) {</p>
<p>    var builder = new PostgresSchemaBuilder();</p>
<p>    var config = new SchemaConfiguration {</p>
<p>      InfrastructurePrefix = "wh_",</p>
<p>      PerspectivePrefix = "wh_per_"</p>
<p>    };</p>

<p>    // Generate complete DDL</p>
<p>    var ddl = builder.BuildInfrastructureSchema(config);</p>

<p>    // Execute via EF Core</p>
<p>    migrationBuilder.Sql(ddl);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern 2: Dapper Embedded Schema</h3>

<pre><code class="language-csharp">using Whizbang.Data.Schema;
<p>using Whizbang.Data.Postgres.Schema;</p>

<p>public class PostgresDatabaseInitializer {</p>
<p>  private readonly IDbConnection _connection;</p>

<p>  public async Task InitializeSchemaAsync() {</p>
<p>    var builder = new PostgresSchemaBuilder();</p>
<p>    var config = new SchemaConfiguration {</p>
<p>      InfrastructurePrefix = "wh_",</p>
<p>      PerspectivePrefix = "wh_per_"</p>
<p>    };</p>

<p>    var ddl = builder.BuildInfrastructureSchema(config);</p>

<p>    // Execute directly with Dapper</p>
<p>    await _connection.ExecuteAsync(ddl);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern 3: Custom Perspective Tables</h3>

<pre><code class="language-csharp">using Whizbang.Data.Schema;
<p>using Whizbang.Data.Postgres.Schema;</p>

<p>public class PerspectiveSchemaGenerator {</p>
<p>  public string GeneratePerspectiveTable<TModel>() {</p>
<p>    var builder = new PostgresSchemaBuilder();</p>
<p>    var tableName = $"wh_per_{typeof(TModel).Name.ToLower()}";</p>

<p>    // Perspective tables have fixed schema:</p>
<p>    // - stream_id UUID PRIMARY KEY</p>
<p>    // - data JSONB NOT NULL</p>
<p>    // - version BIGINT NOT NULL</p>
<p>    // - updated_at TIMESTAMPTZ NOT NULL</p>
<p>    return builder.BuildPerspectiveTable(tableName);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>SchemaConfiguration</h2>

<pre><code class="language-csharp">public record SchemaConfiguration {
<p>  /// <summary></p>
<p>  /// Prefix for infrastructure tables (inbox, outbox, events).</p>
<p>  /// Default: "wh_"</p>
<p>  /// </summary></p>
<p>  public string InfrastructurePrefix { get; init; } = "wh_";</p>

<p>  /// <summary></p>
<p>  /// Prefix for perspective tables (read models).</p>
<p>  /// Default: "wh_per_"</p>
<p>  /// </summary></p>
<p>  public string PerspectivePrefix { get; init; } = "wh_per_";</p>
<p>}</p>
<p></code></pre></p>

<strong>Example Prefixes</strong>:
<pre><code class="language-">Infrastructure Tables:
<ul><li>wh_inbox</li>
<li>wh_outbox</li>
<li>wh_events</li>
<li>wh_perspective_checkpoints</li>
</ul>
<p>Perspective Tables:</p>
<ul><li>wh_per_product_catalog</li>
<li>wh_per_order_summary</li>
<li>wh_per_customer_statistics</li>
</ul><p></code></pre></p>

<hr>

<h2>Infrastructure Schemas</h2>

<p>Whizbang provides pre-defined schemas for core infrastructure:</p>

<h3>InboxSchema</h3>

<pre><code class="language-csharp">public static class InboxSchema {
<p>  public static readonly TableDefinition Table = new(</p>
<p>    Name: "inbox",</p>
<p>    Columns: ImmutableArray.Create(</p>
<p>      // message_id (PK)</p>
<p>      // handler_name</p>
<p>      // event_type</p>
<p>      // event_data (JSONB)</p>
<p>      // metadata (JSONB)</p>
<p>      // status, attempts, error</p>
<p>      // lease_expiry, instance_id</p>
<p>      // received_at, processed_at</p>
<p>    ),</p>
<p>    Indexes: ImmutableArray.Create(</p>
<p>      // idx_inbox_received_at</p>
<p>      // idx_inbox_lease_expiry (partial: WHERE lease_expiry IS NOT NULL)</p>
<p>      // idx_inbox_status_lease (partial: for claiming work)</p>
<p>    )</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<h3>OutboxSchema</h3>

<pre><code class="language-csharp">public static class OutboxSchema {
<p>  public static readonly TableDefinition Table = new(</p>
<p>    Name: "outbox",</p>
<p>    Columns: ImmutableArray.Create(</p>
<p>      // message_id (PK)</p>
<p>      // correlation_id, causation_id</p>
<p>      // message_type</p>
<p>      // payload (JSONB)</p>
<p>      // topic, stream_key, partition_key</p>
<p>      // status, attempts, error</p>
<p>      // lease_expiry, instance_id</p>
<p>      // created_at, processed_at</p>
<p>    ),</p>
<p>    Indexes: ImmutableArray.Create(</p>
<p>      // idx_outbox_created_at</p>
<p>      // idx_outbox_lease_expiry (partial)</p>
<p>      // idx_outbox_status_lease (partial)</p>
<p>    )</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<h3>EventStoreSchema</h3>

<pre><code class="language-csharp">public static class EventStoreSchema {
<p>  public static readonly TableDefinition Table = new(</p>
<p>    Name: "events",</p>
<p>    Columns: ImmutableArray.Create(</p>
<p>      // event_id (PK, UUIDv7)</p>
<p>      // stream_id (UUID)</p>
<p>      // sequence_number (per stream)</p>
<p>      // global_sequence (across all streams)</p>
<p>      // event_type</p>
<p>      // event_data (JSONB)</p>
<p>      // metadata (JSONB)</p>
<p>      // timestamp</p>
<p>    ),</p>
<p>    Indexes: ImmutableArray.Create(</p>
<p>      // idx_events_stream_id_sequence (for event replay)</p>
<p>      // idx_events_global_sequence (for global ordering)</p>
<p>    ),</p>
<p>    UniqueConstraints: ImmutableArray.Create(</p>
<p>      new UniqueConstraintDefinition(</p>
<p>        Name: "uq_events_stream_sequence",</p>
<p>        Columns: ImmutableArray.Create("stream_id", "sequence_number")</p>
<p>      )</p>
<p>    )</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<h3>PerspectiveCheckpointsSchema</h3>

<pre><code class="language-csharp">public static class PerspectiveCheckpointsSchema {
<p>  public static readonly TableDefinition Table = new(</p>
<p>    Name: "perspective_checkpoints",</p>
<p>    Columns: ImmutableArray.Create(</p>
<p>      // stream_id (composite PK)</p>
<p>      // perspective_name (composite PK)</p>
<p>      // last_event_id</p>
<p>      // last_sequence_number</p>
<p>      // status</p>
<p>      // error_message</p>
<p>      // updated_at</p>
<p>    ),</p>
<p>    Indexes: ImmutableArray.Create(</p>
<p>      // idx_perspective_checkpoints_status</p>
<p>      // idx_perspective_checkpoints_updated_at</p>
<p>    )</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Testing Schema Generation</h2>

<h3>Unit Test Pattern</h3>

<pre><code class="language-csharp">using TUnit.Assertions;
<p>using TUnit.Core;</p>
<p>using Whizbang.Data.Schema;</p>
<p>using Whizbang.Data.Postgres.Schema;</p>

<p>public class PostgresSchemaBuilderTests {</p>
<p>  [Test]</p>
<p>  public async Task BuildCreateTable_SimpleTable_GeneratesCreateStatementAsync() {</p>
<p>    // Arrange</p>
<p>    var table = new TableDefinition(</p>
<p>      Name: "test_table",</p>
<p>      Columns: ImmutableArray.Create(</p>
<p>        new ColumnDefinition("id", WhizbangDataType.Uuid, PrimaryKey: true),</p>
<p>        new ColumnDefinition("name", WhizbangDataType.String, MaxLength: 100)</p>
<p>      )</p>
<p>    );</p>

<p>    var builder = new PostgresSchemaBuilder();</p>

<p>    // Act</p>
<p>    var sql = builder.BuildCreateTable(table, "wh_");</p>

<p>    // Assert</p>
<p>    await Assert.That(sql).Contains("CREATE TABLE IF NOT EXISTS wh_test_table");</p>
<p>    await Assert.That(sql).Contains("id UUID");</p>
<p>    await Assert.That(sql).Contains("name VARCHAR(100)");</p>
<p>    await Assert.That(sql).Contains("PRIMARY KEY");</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task BuildInfrastructureSchema_GeneratesAllTablesAsync() {</p>
<p>    // Arrange</p>
<p>    var builder = new PostgresSchemaBuilder();</p>
<p>    var config = new SchemaConfiguration {</p>
<p>      InfrastructurePrefix = "wh_",</p>
<p>      PerspectivePrefix = "wh_per_"</p>
<p>    };</p>

<p>    // Act</p>
<p>    var ddl = builder.BuildInfrastructureSchema(config);</p>

<p>    // Assert - all infrastructure tables present</p>
<p>    await Assert.That(ddl).Contains("CREATE TABLE IF NOT EXISTS wh_inbox");</p>
<p>    await Assert.That(ddl).Contains("CREATE TABLE IF NOT EXISTS wh_outbox");</p>
<p>    await Assert.That(ddl).Contains("CREATE TABLE IF NOT EXISTS wh_events");</p>
<p>    await Assert.That(ddl).Contains("CREATE TABLE IF NOT EXISTS wh_perspective_checkpoints");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Implementing Custom Database Support</h2>

<h3>Step 1: Create ISchemaBuilder Implementation</h3>

<pre><code class="language-csharp">using Whizbang.Data.Schema;

<p>public class MySqlSchemaBuilder : ISchemaBuilder {</p>
<p>  public string DatabaseEngine => "MySQL";</p>

<p>  public string BuildCreateTable(TableDefinition table, string prefix) {</p>
<p>    // Implement MySQL-specific DDL syntax</p>
<p>    // - AUTO_INCREMENT instead of SERIAL</p>
<p>    // - Different JSON type name</p>
<p>    // - Different timestamp syntax</p>
<p>  }</p>

<p>  public string BuildCreateIndex(IndexDefinition index, string tableName, string prefix) {</p>
<p>    // MySQL: CREATE INDEX idx_name ON table_name (columns);</p>
<p>  }</p>

<p>  public string BuildInfrastructureSchema(SchemaConfiguration config) {</p>
<p>    // Same logic as Postgres, different SQL syntax</p>
<p>  }</p>

<p>  public string BuildPerspectiveTable(string tableName) {</p>
<p>    // MySQL perspective table DDL</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Step 2: Implement Type Mapper</h3>

<pre><code class="language-csharp">internal static class MySqlTypeMapper {
<p>  public static string MapDataType(WhizbangDataType type, int? maxLength) {</p>
<p>    return type switch {</p>
<p>      WhizbangDataType.Uuid => "CHAR(36)",  // MySQL doesn't have UUID type</p>
<p>      WhizbangDataType.String => maxLength.HasValue</p>
<p>        ? $"VARCHAR({maxLength.Value})"</p>
<p>        : "TEXT",</p>
<p>      WhizbangDataType.Integer => "INT",</p>
<p>      WhizbangDataType.BigInt => "BIGINT",</p>
<p>      WhizbangDataType.Boolean => "TINYINT(1)",  // MySQL bool</p>
<p>      WhizbangDataType.TimestampTz => "DATETIME",  // No TZ in MySQL < 8.0.19</p>
<p>      WhizbangDataType.Json => "JSON",  // MySQL 5.7+</p>
<p>      WhizbangDataType.Decimal => "DECIMAL(18,2)",</p>
<p>      _ => throw new ArgumentException($"Unsupported data type: {type}")</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ Define schemas once in C# using <code>TableDefinition</code></li>
<li>✅ Use <code>ImmutableArray</code> for collections (value equality)</li>
<li>✅ Implement <code>ISchemaBuilder</code> for each database engine</li>
<li>✅ Use <code>BuildInfrastructureSchema()</code> as authoritative source</li>
<li>✅ Test generated DDL compiles and executes</li>
<li>✅ Use sealed records for all schema types (caching!)</li>
<li>✅ Provide default values via <code>DefaultValue</code> types</li>
<li>✅ Use partial indexes (<code>WhereClause</code>) for performance</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Manually write DDL strings</li>
<li>❌ Duplicate schema definitions per database</li>
<li>❌ Use database-specific types in schema definitions</li>
<li>❌ Forget to test generated DDL against real database</li>
<li>❌ Skip indexes on frequently queried columns</li>
<li>❌ Use reflection for schema generation (AOT incompatible)</li>
</ul>
<hr>

<h2>Further Reading</h2>

<strong>Data Access</strong>:
<ul><li><a href="event-store.md">Event Store</a> - Event sourcing schema and storage</li>
<li><a href="perspectives-storage.md">Perspective Storage</a> - Read model schema patterns</li>
</ul>
<strong>Extensibility</strong>:
<ul><li><a href="../extensibility/database-schema-framework.md">Database Schema Framework</a> - Complete framework overview</li>
</ul>
<strong>Source Generators</strong>:
<ul><li><a href="../source-generators/perspective-schema-generator.md">Perspective Schema Generator</a> - Auto-generate perspective tables</li>
</ul>
<strong>Messaging</strong>:
<ul><li><a href="../messaging/outbox-pattern.md">Outbox Pattern</a> - Transactional messaging schema</li>
<li><a href="../messaging/inbox-pattern.md">Inbox Pattern</a> - Deduplication schema</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2025-12-22</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Diagnostics</h2>
<article id="v1-0-0-diagnostics-whiz030" class="doc-section">
  <h3>WHIZ030: Perspective Event Missing StreamKey</h3>
  <p class="doc-path"><code>v1.0.0/diagnostics/whiz030</code></p>
  <p class="doc-description"><em>Event type used in perspective must have exactly one property marked with [StreamKey] attribute</em></p>
  <div class="doc-content">

<h1>WHIZ030: Perspective Event Missing StreamKey</h1>

<strong>Severity</strong>: Error
<strong>Category</strong>: Source Generation

<h2>Description</h2>

<p>This error occurs when an event type is used in a perspective (via <code>IPerspectiveFor<TModel, TEvent></code>) but does not have a property marked with the <code>[StreamKey]</code> attribute.</p>

<p>The <code>[StreamKey]</code> attribute is required on all events used in perspectives because it identifies which stream (aggregate) the event belongs to. This enables the perspective runner to:</p>
<ul><li>Group events by stream for ordered processing</li>
<li>Apply events in UUID7 timestamp order within each stream</li>
<li>Maintain consistency per aggregate</li>
</ul>
<h2>Error Message</h2>

<pre><code class="language-">Event type 'MyNamespace.ProductCreatedEvent' used in perspective 'ProductCatalogPerspective' must have exactly one property marked with [StreamKey] attribute
<p></code></pre></p>

<h2>How to Fix</h2>

<p>Add the <code>[StreamKey]</code> attribute to exactly one property on your event type:</p>

<pre><code class="language-csharp">public record ProductCreatedEvent : IEvent {
<p>  [StreamKey]  // ✅ Add this attribute</p>
<p>  public Guid ProductId { get; init; }</p>
<p>  public string Name { get; init; } = string.Empty;</p>
<p>  public decimal Price { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h2>Requirements</h2>

<ul><li><strong>Exactly one property</strong> must have <code>[StreamKey]</code></li>
<li>The property should identify the aggregate/stream (e.g., <code>OrderId</code>, <code>ProductId</code>, <code>CustomerId</code>)</li>
<li>The property must be accessible (typically <code>public</code> with <code>get</code> accessor)</li>
</ul>
<h2>Example: Product Catalog Perspective</h2>

<strong>Before (causes WHIZ030)</strong>:
<pre><code class="language-csharp">// ❌ Missing [StreamKey] attribute
<p>public record ProductCreatedEvent : IEvent {</p>
<p>  public Guid ProductId { get; init; }  // No [StreamKey]!</p>
<p>  public string Name { get; init; } = string.Empty;</p>
<p>}</p>

<p>public record ProductDto {</p>
<p>  [StreamKey]</p>
<p>  public Guid ProductId { get; init; }</p>
<p>  public string Name { get; init; } = string.Empty;</p>
<p>}</p>

<p>public class ProductCatalogPerspective : IPerspectiveFor<ProductDto, ProductCreatedEvent> {</p>
<p>  public ProductDto Apply(ProductDto currentData, ProductCreatedEvent @event) {</p>
<p>    return new ProductDto {</p>
<p>      ProductId = @event.ProductId,</p>
<p>      Name = @event.Name</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>After (error resolved)</strong>:
<pre><code class="language-csharp">// ✅ [StreamKey] added to event
<p>public record ProductCreatedEvent : IEvent {</p>
<p>  [StreamKey]  // Identifies the stream</p>
<p>  public Guid ProductId { get; init; }</p>
<p>  public string Name { get; init; } = string.Empty;</p>
<p>}</p>

<p>public record ProductDto {</p>
<p>  [StreamKey]</p>
<p>  public Guid ProductId { get; init; }</p>
<p>  public string Name { get; init; } = string.Empty;</p>
<p>}</p>

<p>public class ProductCatalogPerspective : IPerspectiveFor<ProductDto, ProductCreatedEvent> {</p>
<p>  public ProductDto Apply(ProductDto currentData, ProductCreatedEvent @event) {</p>
<p>    return new ProductDto {</p>
<p>      ProductId = @event.ProductId,</p>
<p>      Name = @event.Name</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Why This Matters</h2>

<p>Without a <code>[StreamKey]</code>, the perspective runner cannot:</p>
<ul><li><strong>Extract the stream ID</strong> from events at compile-time (zero reflection)</li>
<li><strong>Group events by stream</strong> for ordered processing</li>
<li><strong>Apply events in order</strong> within each aggregate</li>
<li><strong>Maintain consistency</strong> per aggregate instance</li>
</ul>
<h2>Related Diagnostics</h2>

<ul><li><strong><a href="whiz031.md">WHIZ031</a></strong> - Event type has multiple <code>[StreamKey]</code> attributes</li>
<li><strong><a href="whiz009.md">WHIZ009</a></strong> - Warning for IEvent implementations missing <code>[StreamKey]</code> (general case)</li>
</ul>
<h2>See Also</h2>

<ul><li><a href="../attributes/streamkey.md">StreamKey Attribute</a> - Detailed attribute documentation</li>
<li><a href="../core-concepts/perspectives.md">Perspectives</a> - Pure function perspectives with StreamKey</li>
<li><a href="../core-concepts/perspectives.md#perspectiverunner-architecture">PerspectiveRunner Architecture</a> - How runners use StreamKey</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-diagnostics-whiz031" class="doc-section">
  <h3>WHIZ031: Multiple StreamKey Attributes</h3>
  <p class="doc-path"><code>v1.0.0/diagnostics/whiz031</code></p>
  <p class="doc-description"><em>Event type has multiple properties marked with [StreamKey] - only one is allowed</em></p>
  <div class="doc-content">

<h1>WHIZ031: Multiple StreamKey Attributes</h1>

<strong>Severity</strong>: Error
<strong>Category</strong>: Source Generation

<h2>Description</h2>

<p>This error occurs when an event type has more than one property marked with the <code>[StreamKey]</code> attribute. Each event can only have <strong>exactly one</strong> stream key property because it uniquely identifies which stream (aggregate) the event belongs to.</p>

<h2>Error Message</h2>

<pre><code class="language-">Event type 'MyNamespace.OrderEvent' has multiple properties marked with [StreamKey]. Only one property can be the stream key.
<p></code></pre></p>

<h2>How to Fix</h2>

<p>Remove the <code>[StreamKey]</code> attribute from all but one property. Keep it only on the property that identifies the aggregate/stream:</p>

<strong>Before (causes WHIZ031)</strong>:
<pre><code class="language-csharp">public record OrderEvent : IEvent {
<p>  [StreamKey]  // ❌ Multiple [StreamKey] attributes!</p>
<p>  public Guid OrderId { get; init; }</p>

<p>  [StreamKey]  // ❌ Remove this!</p>
<p>  public Guid CustomerId { get; init; }</p>

<p>  public decimal Amount { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<strong>After (error resolved)</strong>:
<pre><code class="language-csharp">public record OrderEvent : IEvent {
<p>  [StreamKey]  // ✅ Single [StreamKey] on the aggregate ID</p>
<p>  public Guid OrderId { get; init; }</p>

<p>  // CustomerId is just a regular property</p>
<p>  public Guid CustomerId { get; init; }</p>

<p>  public decimal Amount { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h2>Choosing the Right Property</h2>

<p>The <code>[StreamKey]</code> should mark the property that identifies the <strong>primary aggregate</strong> for this event:</p>

<pre><code class="language-csharp">// Order-centric events
<p>public record OrderCreatedEvent : IEvent {</p>
<p>  [StreamKey]  // Order is the aggregate</p>
<p>  public Guid OrderId { get; init; }</p>
<p>  public Guid CustomerId { get; init; }  // Related entity, not stream key</p>
<p>}</p>

<p>// Customer-centric events</p>
<p>public record CustomerRegisteredEvent : IEvent {</p>
<p>  [StreamKey]  // Customer is the aggregate</p>
<p>  public Guid CustomerId { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h3>Rule of Thumb</h3>

<p>Ask: "Which entity does this event primarily describe?"</p>
<ul><li><code>OrderCreatedEvent</code> describes an <strong>Order</strong> → <code>OrderId</code> gets <code>[StreamKey]</code></li>
<li><code>ProductUpdatedEvent</code> describes a <strong>Product</strong> → <code>ProductId</code> gets <code>[StreamKey]</code></li>
<li><code>CustomerRegisteredEvent</code> describes a <strong>Customer</strong> → <code>CustomerId</code> gets <code>[StreamKey]</code></li>
</ul>
<h2>Why Only One?</h2>

<p>The <code>[StreamKey]</code> serves a specific purpose in perspective runners:</p>

<ul><li><strong>Stream Identification</strong>: Groups events by aggregate for ordered processing</li>
<li><strong>UUID7 Ordering</strong>: Events within the same stream are processed in timestamp order</li>
<li><strong>Compile-Time Extraction</strong>: Source generator creates <code>ExtractStreamId()</code> methods</li>
</ul>
<p>Having multiple stream keys would create ambiguity:</p>
<ul><li>Which property identifies the stream?</li>
<li>How should events be grouped?</li>
<li>Which ordering should be used?</li>
</ul>
<h2>Example: Order Aggregate</h2>

<strong>Correct - Single stream key</strong>:
<pre><code class="language-csharp">public record OrderCreatedEvent : IEvent {
<p>  [StreamKey]</p>
<p>  public Guid OrderId { get; init; }</p>
<p>  public Guid CustomerId { get; init; }</p>
<p>  public DateTime CreatedAt { get; init; }</p>
<p>}</p>

<p>public record OrderShippedEvent : IEvent {</p>
<p>  [StreamKey]</p>
<p>  public Guid OrderId { get; init; }  // Same stream as OrderCreatedEvent</p>
<p>  public string TrackingNumber { get; init; } = string.Empty;</p>
<p>  public DateTime ShippedAt { get; init; }</p>
<p>}</p>

<p>public record OrderDto {</p>
<p>  [StreamKey]</p>
<p>  public Guid OrderId { get; init; }</p>
<p>  public string Status { get; init; } = string.Empty;</p>
<p>  public string? TrackingNumber { get; init; }</p>
<p>}</p>

<p>public class OrderPerspective :</p>
<p>  IPerspectiveFor<OrderDto, OrderCreatedEvent, OrderShippedEvent> {</p>

<p>  public OrderDto Apply(OrderDto currentData, OrderCreatedEvent @event) {</p>
<p>    return new OrderDto {</p>
<p>      OrderId = @event.OrderId,</p>
<p>      Status = "Created"</p>
<p>    };</p>
<p>  }</p>

<p>  public OrderDto Apply(OrderDto currentData, OrderShippedEvent @event) {</p>
<p>    return currentData with {</p>
<p>      Status = "Shipped",</p>
<p>      TrackingNumber = @event.TrackingNumber</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Common Scenarios</h2>

<h3>Scenario 1: Event with Multiple IDs</h3>

<p>If your event references multiple entities, only mark the <strong>primary aggregate</strong>:</p>

<pre><code class="language-csharp">public record OrderLineItemAddedEvent : IEvent {
<p>  [StreamKey]  // Order is the primary aggregate</p>
<p>  public Guid OrderId { get; init; }</p>

<p>  // Product is referenced but not the stream key</p>
<p>  public Guid ProductId { get; init; }</p>
<p>  public int Quantity { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h3>Scenario 2: Composite Keys</h3>

<p>If you truly need a composite key, create a single property that represents it:</p>

<pre><code class="language-csharp">public record OrderLineItemEvent : IEvent {
<p>  [StreamKey]  // Composite key as single property</p>
<p>  public string StreamKey => $"{OrderId}:{ProductId}";</p>

<p>  public Guid OrderId { get; init; }</p>
<p>  public Guid ProductId { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<p>However, this is rare. Most domain events belong to a single aggregate.</p>

<h2>Related Diagnostics</h2>

<ul><li><strong><a href="whiz030.md">WHIZ030</a></strong> - Event type missing <code>[StreamKey]</code> attribute</li>
<li><strong><a href="whiz009.md">WHIZ009</a></strong> - Warning for IEvent implementations missing <code>[StreamKey]</code> (general case)</li>
</ul>
<h2>See Also</h2>

<ul><li><a href="../attributes/streamkey.md">StreamKey Attribute</a> - Detailed attribute documentation</li>
<li><a href="../core-concepts/perspectives.md">Perspectives</a> - Pure function perspectives with StreamKey</li>
<li><a href="../core-concepts/event-sourcing.md">Event Sourcing</a> - Understanding aggregates and streams</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-diagnostics-whiz058" class="doc-section">
  <h3>WHIZ058: GUID Call Intercepted</h3>
  <p class="doc-path"><code>v1.0.0/diagnostics/whiz058</code></p>
  <p class="doc-description"><em>Informational diagnostic indicating a GUID creation call has been intercepted and wrapped with TrackedGuid</em></p>
  <div class="doc-content">

<h1>WHIZ058: GUID Call Intercepted</h1>

<strong>Severity</strong>: Info
<strong>Category</strong>: Source Generation

<h2>Description</h2>

<p>This informational diagnostic is reported when the <code>GuidInterceptorGenerator</code> intercepts a GUID creation call and wraps it with <code>TrackedGuid</code>. This enables metadata tracking for the generated GUID.</p>

<p>This diagnostic is only reported when GUID interception is enabled via the MSBuild property <code>WhizbangGuidInterceptionEnabled=true</code>.</p>

<h2>Diagnostic Message</h2>

<pre><code class="language-">GUID call 'System.Guid.NewGuid()' at file.cs:15 intercepted and wrapped with TrackedGuid
<p></code></pre></p>

<h2>What Gets Intercepted</h2>

<p>The following GUID creation methods are intercepted:</p>

<p>| Method | Metadata |</p>
<p>|--------|----------|</p>
<p>| <code>Guid.NewGuid()</code> | <code>Version4 \| SourceMicrosoft</code> |</p>
<p>| <code>Guid.CreateVersion7()</code> | <code>Version7 \| SourceMicrosoft</code> |</p>
<p>| <code>CombGuidIdGeneration.NewGuid()</code> | <code>Version7 \| SourceMarten</code> |</p>
<p>| <code>UUIDNext.Uuid.NewSequential()</code> | <code>Version7 \| SourceUuidNext</code> |</p>
<p>| <code>UUIDNext.Uuid.NewDatabaseFriendly()</code> | <code>Version7 \| SourceUuidNext</code> |</p>
<p>| <code>Medo.Uuid7.NewUuid7()</code> | <code>Version7 \| SourceMedo</code> |</p>

<h2>Enabling Interception</h2>

<p>Add to your project file:</p>

<pre><code class="language-xml"><PropertyGroup>
<p>  <WhizbangGuidInterceptionEnabled>true</WhizbangGuidInterceptionEnabled></p>
<p></PropertyGroup></p>
<p></code></pre></p>

<h2>Suppressing This Diagnostic</h2>

<p>If you want to suppress interception for specific code:</p>

<h3>Method-Level Suppression</h3>

<pre><code class="language-csharp">using Whizbang.Core;

<p>[SuppressGuidInterception]</p>
<p>public Guid CreateRawGuid() {</p>
<p>  return Guid.NewGuid();  // Not intercepted, no WHIZ058</p>
<p>}</p>
<p></code></pre></p>

<h3>Class-Level Suppression</h3>

<pre><code class="language-csharp">[SuppressGuidInterception]
<p>public class TestFixtures {</p>
<p>  // All GUID calls in this class are not intercepted</p>
<p>}</p>
<p></code></pre></p>

<h3>Pragma Suppression</h3>

<pre><code class="language-csharp">#pragma warning disable WHIZ058
<p>var id = Guid.NewGuid();</p>
<p>#pragma warning restore WHIZ058</p>
<p></code></pre></p>

<h3>Project-Level Suppression</h3>

<pre><code class="language-xml"><PropertyGroup>
<p>  <NoWarn>$(NoWarn);WHIZ058</NoWarn></p>
<p></PropertyGroup></p>
<p></code></pre></p>

<h2>Why This Matters</h2>

<p>TrackedGuid interception provides:</p>
<ul><li><strong>Version tracking</strong> - Know if a GUID is v4 (random) or v7 (time-ordered)</li>
<li><strong>Source tracking</strong> - Know which library generated the GUID</li>
<li><strong>Runtime validation</strong> - Validate that time-ordered GUIDs are used where required</li>
<li><strong>Debugging</strong> - Trace GUID origins in complex systems</li>
</ul>
<h2>Related Diagnostics</h2>

<ul><li><strong><a href="whiz059.md">WHIZ059</a></strong> - Interception suppressed (when <code>[SuppressGuidInterception]</code> is used)</li>
<li><strong><a href="whiz055.md">WHIZ055</a></strong> - Warning for <code>Guid.NewGuid()</code> usage (analyzer, separate from interception)</li>
<li><strong><a href="whiz056.md">WHIZ056</a></strong> - Warning for <code>Guid.CreateVersion7()</code> usage (analyzer)</li>
</ul>
<h2>See Also</h2>

<ul><li><a href="../core-concepts/whizbang-ids.md">WhizbangIds</a> - TrackedGuid and strongly-typed IDs</li>
<li><a href="../core-concepts/whizbang-ids.md#trackedguid-interception-opt-in">TrackedGuid Interception</a> - Full interception documentation</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-diagnostics-whiz059" class="doc-section">
  <h3>WHIZ059: GUID Interception Suppressed</h3>
  <p class="doc-path"><code>v1.0.0/diagnostics/whiz059</code></p>
  <p class="doc-description"><em>Informational diagnostic indicating a GUID creation call was not intercepted due to suppression</em></p>
  <div class="doc-content">

<h1>WHIZ059: GUID Interception Suppressed</h1>

<strong>Severity</strong>: Info
<strong>Category</strong>: Source Generation

<h2>Description</h2>

<p>This informational diagnostic is reported when a GUID creation call could be intercepted but was suppressed via the <code>[SuppressGuidInterception]</code> attribute. This indicates intentional opt-out from TrackedGuid wrapping.</p>

<p>This diagnostic is only reported when GUID interception is enabled via the MSBuild property <code>WhizbangGuidInterceptionEnabled=true</code>.</p>

<h2>Diagnostic Message</h2>

<pre><code class="language-">GUID call 'System.Guid.NewGuid()' at file.cs:15 suppressed by SuppressGuidInterceptionAttribute on method
<p></code></pre></p>

<h2>Why Suppress Interception</h2>

<p>Common reasons to suppress GUID interception:</p>

<h3>1. Test Fixtures</h3>

<pre><code class="language-csharp">using Whizbang.Core;

<p>[SuppressGuidInterception]</p>
<p>public static class TestData {</p>
<p>  // Tests may need raw GUIDs for fixture data</p>
<p>  public static readonly Guid KnownOrderId = Guid.Parse("550e8400-e29b-41d4-a716-446655440000");</p>

<p>  public static Guid CreateTestGuid() {</p>
<p>    return Guid.NewGuid();  // WHIZ059 reported here</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>2. Integration with External Systems</h3>

<pre><code class="language-csharp">public class ExternalApiClient {
<p>  [SuppressGuidInterception]</p>
<p>  public Guid CreateExternalRequestId() {</p>
<p>    // External system expects raw GUID format</p>
<p>    return Guid.NewGuid();  // WHIZ059 reported here</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>3. Performance-Critical Paths</h3>

<pre><code class="language-csharp">public class HighThroughputProcessor {
<p>  [SuppressGuidInterception]</p>
<p>  public Guid CreateTransientId() {</p>
<p>    // Avoid TrackedGuid overhead for transient IDs</p>
<p>    return Guid.NewGuid();  // WHIZ059 reported here</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>4. Legacy Code Migration</h3>

<pre><code class="language-csharp">[SuppressGuidInterception]
<p>public class LegacyService {</p>
<p>  // Gradual migration - suppress for now</p>
<p>  public Guid CreateId() => Guid.NewGuid();</p>
<p>}</p>
<p></code></pre></p>

<h2>Suppression Scopes</h2>

<p>The <code>[SuppressGuidInterception]</code> attribute can be applied at different scopes:</p>

<h3>Method Scope</h3>

<pre><code class="language-csharp">public class MyService {
<p>  [SuppressGuidInterception]</p>
<p>  public Guid CreateRawGuid() {</p>
<p>    return Guid.NewGuid();  // Suppressed</p>
<p>  }</p>

<p>  public Guid CreateTrackedGuid() {</p>
<p>    return Guid.NewGuid();  // Intercepted</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Class Scope</h3>

<pre><code class="language-csharp">[SuppressGuidInterception]
<p>public class TestFixtures {</p>
<p>  public Guid Id1 => Guid.NewGuid();  // Suppressed</p>
<p>  public Guid Id2 => Guid.NewGuid();  // Suppressed</p>
<p>}</p>
<p></code></pre></p>

<h3>Assembly Scope</h3>

<pre><code class="language-csharp">// In AssemblyInfo.cs or any file
<p>[assembly: SuppressGuidInterception]</p>
<p>// All GUID calls in this assembly are suppressed</p>
<p></code></pre></p>

<h2>Suppressing This Diagnostic</h2>

<p>If you don't want to see WHIZ059 diagnostics:</p>

<h3>Project-Level</h3>

<pre><code class="language-xml"><PropertyGroup>
<p>  <NoWarn>$(NoWarn);WHIZ059</NoWarn></p>
<p></PropertyGroup></p>
<p></code></pre></p>

<h3>Code-Level</h3>

<pre><code class="language-csharp">#pragma warning disable WHIZ059
<p>[SuppressGuidInterception]</p>
<p>public Guid CreateId() => Guid.NewGuid();</p>
<p>#pragma warning restore WHIZ059</p>
<p></code></pre></p>

<h2>Related Diagnostics</h2>

<ul><li><strong><a href="whiz058.md">WHIZ058</a></strong> - GUID call intercepted (the inverse - when interception happens)</li>
<li><strong><a href="whiz055.md">WHIZ055</a></strong> - Warning for <code>Guid.NewGuid()</code> usage</li>
<li><strong><a href="whiz056.md">WHIZ056</a></strong> - Warning for <code>Guid.CreateVersion7()</code> usage</li>
</ul>
<h2>See Also</h2>

<ul><li><a href="../core-concepts/whizbang-ids.md">WhizbangIds</a> - TrackedGuid and strongly-typed IDs</li>
<li><a href="../core-concepts/whizbang-ids.md#trackedguid-interception-opt-in">TrackedGuid Interception</a> - Full interception documentation</li>
<li><a href="../attributes/suppressguidinterception.md">SuppressGuidInterceptionAttribute</a> - Attribute documentation</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-diagnostics-whiz070" class="doc-section">
  <h3>WHIZ070: Missing Pgvector.EntityFrameworkCore Package</h3>
  <p class="doc-path"><code>v1.0.0/diagnostics/whiz070</code></p>
  <p class="doc-description"><em>Error diagnostic when a perspective model uses [VectorField] but the required Pgvector.EntityFrameworkCore package is not referenced</em></p>
  <div class="doc-content">

<h1>WHIZ070: Missing Pgvector.EntityFrameworkCore Package</h1>

<strong>Severity</strong>: Error
<strong>Category</strong>: Package Reference

<h2>Description</h2>

<p>This error is reported when a perspective model property has the <code>[VectorField]</code> attribute but the project does not reference the <code>Pgvector.EntityFrameworkCore</code> package. This package is required for EF Core to map vector columns to PostgreSQL's <code>vector</code> type.</p>

<h2>Diagnostic Message</h2>

<pre><code class="language-">Perspective model uses [VectorField] but Pgvector.EntityFrameworkCore package is not referenced. Add <PackageReference Include="Pgvector.EntityFrameworkCore" /> to use vector columns.
<p></code></pre></p>

<h2>Common Causes</h2>

<ul><li><strong>Forgot to add package reference</strong> - Added <code>[VectorField]</code> attribute but didn't install the required NuGet package</li>
<li><strong>Package accidentally removed</strong> - Package reference was removed during dependency cleanup</li>
<li><strong>Wrong package</strong> - Referenced <code>Pgvector</code> base package but not the EF Core integration package</li>
</ul>
<h2>How to Fix</h2>

<p>Add the <code>Pgvector.EntityFrameworkCore</code> package reference to your project:</p>

<h3>Using .NET CLI</h3>

<pre><code class="language-bash">dotnet add package Pgvector.EntityFrameworkCore
<p></code></pre></p>

<h3>Using Package Manager Console</h3>

<pre><code class="language-powershell">Install-Package Pgvector.EntityFrameworkCore
<p></code></pre></p>

<h3>Using PackageReference in .csproj</h3>

<pre><code class="language-xml"><ItemGroup>
<p>  <PackageReference Include="Pgvector.EntityFrameworkCore" Version="0.3.0" /></p>
<p></ItemGroup></p>
<p></code></pre></p>

<h3>Using Central Package Management</h3>

<p>In <code>Directory.Packages.props</code>:</p>

<pre><code class="language-xml"><ItemGroup>
<p>  <PackageVersion Include="Pgvector.EntityFrameworkCore" Version="0.3.0" /></p>
<p></ItemGroup></p>
<p></code></pre></p>

<p>In your project file:</p>

<pre><code class="language-xml"><ItemGroup>
<p>  <PackageReference Include="Pgvector.EntityFrameworkCore" /></p>
<p></ItemGroup></p>
<p></code></pre></p>

<h2>Code Example</h2>

<h3>Before (causes WHIZ070)</h3>

<pre><code class="language-csharp">// Missing: <PackageReference Include="Pgvector.EntityFrameworkCore" />

<p>public record ProductDto {</p>
<p>  public Guid Id { get; init; }</p>
<p>  public string Name { get; init; } = string.Empty;</p>

<p>  [VectorField(1536)]  // WHIZ070: Package not referenced</p>
<p>  public float[]? Embedding { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h3>After (compiles successfully)</h3>

<pre><code class="language-csharp">// Added: <PackageReference Include="Pgvector.EntityFrameworkCore" />

<p>public record ProductDto {</p>
<p>  public Guid Id { get; init; }</p>
<p>  public string Name { get; init; } = string.Empty;</p>

<p>  [VectorField(1536)]  // Works - package is referenced</p>
<p>  public float[]? Embedding { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h2>Suppressing This Diagnostic</h2>

<p>If you intentionally want to use <code>[VectorField]</code> without the EF Core package (e.g., for testing or code generation scenarios), add the assembly-level suppression attribute:</p>

<pre><code class="language-csharp">[assembly: SuppressVectorPackageCheck]
<p></code></pre></p>

<p>Or use pragma suppression:</p>

<pre><code class="language-csharp">#pragma warning disable WHIZ070
<p>[VectorField(1536)]</p>
<p>public float[]? Embedding { get; init; }</p>
<p>#pragma warning restore WHIZ070</p>
<p></code></pre></p>

<h2>Why This Matters</h2>

<p>The <code>Pgvector.EntityFrameworkCore</code> package provides:</p>

<ul><li><strong>EF Core type mapping</strong> - Maps <code>float[]</code> properties to PostgreSQL <code>vector</code> columns</li>
<li><strong>UseVector() extension</strong> - Configures EF Core options for pgvector support</li>
<li><strong>Query translation</strong> - Translates LINQ queries with vector operations to SQL</li>
</ul>
<p>Without this package, EF Core cannot properly handle vector columns, leading to runtime errors.</p>

<h2>Related Diagnostics</h2>

<ul><li><strong><a href="whiz071.md">WHIZ071</a></strong> - Missing base Pgvector package (for NpgsqlDataSourceBuilder.UseVector())</li>
</ul>
<h2>See Also</h2>

<ul><li><a href="../features/vector-search.md">Vector Search</a> - Complete vector search documentation</li>
<li><a href="../features/vector-search.md#vectorfield-attribute">VectorField Attribute</a> - Using the VectorField attribute</li>
<li><a href="../features/vector-search.md#turnkey-setup">Turnkey Setup</a> - Automatic vector configuration</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-diagnostics-whiz071" class="doc-section">
  <h3>WHIZ071: Missing Pgvector Package</h3>
  <p class="doc-path"><code>v1.0.0/diagnostics/whiz071</code></p>
  <p class="doc-description"><em>Error diagnostic when a perspective model uses [VectorField] but the required base Pgvector package is not referenced</em></p>
  <div class="doc-content">

<h1>WHIZ071: Missing Pgvector Package</h1>

<strong>Severity</strong>: Error
<strong>Category</strong>: Package Reference

<h2>Description</h2>

<p>This error is reported when a perspective model property has the <code>[VectorField]</code> attribute but the project does not reference the base <code>Pgvector</code> package. This package is required for <code>NpgsqlDataSourceBuilder.UseVector()</code> support.</p>

<h2>Diagnostic Message</h2>

<pre><code class="language-">Perspective model uses [VectorField] but Pgvector package is not referenced. Add <PackageReference Include="Pgvector" /> for NpgsqlDataSourceBuilder.UseVector() support.
<p></code></pre></p>

<h2>Common Causes</h2>

<ul><li><strong>Forgot to add package reference</strong> - Added <code>[VectorField]</code> attribute but didn't install the required NuGet package</li>
<li><strong>Only installed EF Core package</strong> - Installed <code>Pgvector.EntityFrameworkCore</code> but not the base <code>Pgvector</code> package</li>
<li><strong>Package accidentally removed</strong> - Package reference was removed during dependency cleanup</li>
</ul>
<h2>How to Fix</h2>

<p>Add the <code>Pgvector</code> package reference to your project:</p>

<h3>Using .NET CLI</h3>

<pre><code class="language-bash">dotnet add package Pgvector
<p></code></pre></p>

<h3>Using Package Manager Console</h3>

<pre><code class="language-powershell">Install-Package Pgvector
<p></code></pre></p>

<h3>Using PackageReference in .csproj</h3>

<pre><code class="language-xml"><ItemGroup>
<p>  <PackageReference Include="Pgvector" Version="0.3.0" /></p>
<p></ItemGroup></p>
<p></code></pre></p>

<h3>Using Central Package Management</h3>

<p>In <code>Directory.Packages.props</code>:</p>

<pre><code class="language-xml"><ItemGroup>
<p>  <PackageVersion Include="Pgvector" Version="0.3.0" /></p>
<p></ItemGroup></p>
<p></code></pre></p>

<p>In your project file:</p>

<pre><code class="language-xml"><ItemGroup>
<p>  <PackageReference Include="Pgvector" /></p>
<p></ItemGroup></p>
<p></code></pre></p>

<h2>Required Packages</h2>

<p>When using <code>[VectorField]</code>, you typically need <strong>both</strong> packages:</p>

<pre><code class="language-xml"><ItemGroup>
<p>  <!-- Base package for NpgsqlDataSourceBuilder.UseVector() --></p>
<p>  <PackageReference Include="Pgvector" Version="0.3.0" /></p>

<p>  <!-- EF Core integration for type mapping and queries --></p>
<p>  <PackageReference Include="Pgvector.EntityFrameworkCore" Version="0.3.0" /></p>
<p></ItemGroup></p>
<p></code></pre></p>

<h2>Code Example</h2>

<h3>Before (causes WHIZ071)</h3>

<pre><code class="language-csharp">// Missing: <PackageReference Include="Pgvector" />

<p>public record ProductDto {</p>
<p>  public Guid Id { get; init; }</p>
<p>  public string Name { get; init; } = string.Empty;</p>

<p>  [VectorField(1536)]  // WHIZ071: Package not referenced</p>
<p>  public float[]? Embedding { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h3>After (compiles successfully)</h3>

<pre><code class="language-csharp">// Added: <PackageReference Include="Pgvector" />

<p>public record ProductDto {</p>
<p>  public Guid Id { get; init; }</p>
<p>  public string Name { get; init; } = string.Empty;</p>

<p>  [VectorField(1536)]  // Works - package is referenced</p>
<p>  public float[]? Embedding { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h2>Suppressing This Diagnostic</h2>

<p>If you intentionally want to use <code>[VectorField]</code> without the Pgvector package (e.g., for testing or code generation scenarios), add the assembly-level suppression attribute:</p>

<pre><code class="language-csharp">[assembly: SuppressVectorPackageCheck]
<p></code></pre></p>

<p>Or use pragma suppression:</p>

<pre><code class="language-csharp">#pragma warning disable WHIZ071
<p>[VectorField(1536)]</p>
<p>public float[]? Embedding { get; init; }</p>
<p>#pragma warning restore WHIZ071</p>
<p></code></pre></p>

<h2>Why This Matters</h2>

<p>The base <code>Pgvector</code> package provides:</p>

<ul><li><strong>Npgsql type handler</strong> - Enables Npgsql to read/write PostgreSQL vector types</li>
<li><strong>UseVector() extension</strong> - Configures <code>NpgsqlDataSourceBuilder</code> for vector support</li>
<li><strong>Vector type</strong> - The <code>Pgvector.Vector</code> type for direct vector manipulation</li>
</ul>
<p>Without this package, Npgsql cannot serialize or deserialize vector data, leading to runtime errors when reading or writing vector columns.</p>

<h2>Related Diagnostics</h2>

<ul><li><strong><a href="whiz070.md">WHIZ070</a></strong> - Missing Pgvector.EntityFrameworkCore package (for EF Core integration)</li>
</ul>
<h2>See Also</h2>

<ul><li><a href="../features/vector-search.md">Vector Search</a> - Complete vector search documentation</li>
<li><a href="../features/vector-search.md#vectorfield-attribute">VectorField Attribute</a> - Using the VectorField attribute</li>
<li><a href="../features/vector-search.md#turnkey-setup">Turnkey Setup</a> - Automatic vector configuration</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Extensibility</h2>
<article id="v1-0-0-extensibility-custom-dispatchers" class="doc-section">
  <h3>Custom Dispatchers</h3>
  <p class="doc-path"><code>v1.0.0/extensibility/custom-dispatchers</code></p>
  <p class="doc-description"><em>Implement custom dispatcher patterns - mediator, event sourcing, multi-tenant routing</em></p>
  <div class="doc-content">

<h1>Custom Dispatchers</h1>

<strong>Custom dispatchers</strong> enable alternative message routing strategies beyond the default dispatcher. Implement mediator patterns, event sourcing dispatchers, or multi-tenant routing.

<p>:::note</p>
<p>Whizbang's default dispatcher provides AOT-compatible, zero-reflection routing. Custom dispatchers are for specialized architectural patterns.</p>
<p>:::</p>

<hr>

<h2>Why Custom Dispatchers?</h2>

<p>| Pattern | Default Dispatcher | Custom Dispatcher |</p>
<p>|---------|-------------------|-------------------|</p>
<p>| <strong>Direct Routing</strong> | ✅ Perfect | No customization needed |</p>
<p>| <strong>Mediator Pattern</strong> | ❌ Not built-in | ✅ Custom mediator |</p>
<p>| <strong>Event Sourcing</strong> | ❌ Append-only needed | ✅ Event store dispatcher |</p>
<p>| <strong>Multi-Tenant</strong> | ❌ Requires policies | ✅ Tenant-aware routing |</p>

<strong>When to use custom dispatchers</strong>:
<ul><li>✅ Mediator pattern requirements</li>
<li>✅ Event sourcing architecture</li>
<li>✅ Complex multi-tenant routing</li>
<li>✅ Custom middleware pipelines</li>
</ul>
<hr>

<h2>Mediator Dispatcher</h2>

<h3>Pattern 1: MediatR-Style Dispatcher</h3>

<pre><code class="language-csharp">public class MediatorDispatcher : IDispatcher {
<p>  private readonly IServiceProvider _services;</p>

<p>  public MediatorDispatcher(IServiceProvider services) {</p>
<p>    _services = services;</p>
<p>  }</p>

<p>  public async Task<TResponse> SendAsync<TResponse>(</p>
<p>    object request,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var requestType = request.GetType();</p>
<p>    var handlerType = typeof(IRequestHandler<,>).MakeGenericType(requestType, typeof(TResponse));</p>

<p>    var handler = _services.GetRequiredService(handlerType);</p>
<p>    var method = handlerType.GetMethod("Handle");</p>

<p>    var result = await (Task<TResponse>)method!.Invoke(handler, new[] { request, ct })!;</p>
<p>    return result;</p>
<p>  }</p>
<p>}</p>

<p>public interface IRequestHandler<in TRequest, TResponse> {</p>
<p>  Task<TResponse> Handle(TRequest request, CancellationToken ct);</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Event Sourcing Dispatcher</h2>

<h3>Pattern 2: Append-Only Event Store</h3>

<pre><code class="language-csharp">public class EventSourcingDispatcher : IDispatcher {
<p>  private readonly IEventStore _eventStore;</p>
<p>  private readonly IDispatcher _innerDispatcher;</p>

<p>  public EventSourcingDispatcher(</p>
<p>    IEventStore eventStore,</p>
<p>    IDispatcher innerDispatcher</p>
<p>  ) {</p>
<p>    _eventStore = eventStore;</p>
<p>    _innerDispatcher = innerDispatcher;</p>
<p>  }</p>

<p>  public async Task<TResponse> SendAsync<TResponse>(</p>
<p>    object command,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    // Dispatch command → get event response</p>
<p>    var @event = await _innerDispatcher.SendAsync<TResponse>(command, ct);</p>

<p>    // Append event to event store</p>
<p>    var streamId = GetStreamId(command);</p>
<p>    await _eventStore.AppendAsync(streamId, @event, ct);</p>

<p>    return @event;</p>
<p>  }</p>

<p>  private Guid GetStreamId(object command) {</p>
<p>    // Extract aggregate ID from command</p>
<p>    var aggregateIdProperty = command.GetType().GetProperty("AggregateId");</p>
<p>    return (Guid)aggregateIdProperty!.GetValue(command)!;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/dispatcher.md">Dispatcher</a> - Default dispatcher</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-extensibility-custom-health-checks" class="doc-section">
  <h3>Custom Health Checks</h3>
  <p class="doc-path"><code>v1.0.0/extensibility/custom-health-checks</code></p>
  <p class="doc-description"><em>Implement custom health checks for transports, databases, external APIs, and custom services</em></p>
  <div class="doc-content">

<h1>Custom Health Checks</h1>

<strong>Custom health checks</strong> enable monitoring application health for Kubernetes, load balancers, and observability tools. Implement checks for transports, databases, caches, external APIs, and custom services.

<p>:::note</p>
<p>For built-in health checks, see <a href="../infrastructure/health-checks.md">Health Checks</a>. This guide focuses on <strong>implementing custom health checks</strong>.</p>
<p>:::</p>

<hr>

<h2>Why Custom Health Checks?</h2>

<strong>Built-in checks cover common scenarios</strong>, but custom checks enable monitoring of:

<p>| Component | Built-In Check | Custom Check |</p>
<p>|-----------|---------------|--------------|</p>
<p>| <strong>Azure Service Bus</strong> | ✅ Built-in | No customization needed |</p>
<p>| <strong>PostgreSQL</strong> | ✅ Built-in | No customization needed |</p>
<p>| <strong>Redis</strong> | ❌ Not included | ✅ Custom Redis check |</p>
<p>| <strong>Kafka</strong> | ❌ Not included | ✅ Custom Kafka check |</p>
<p>| <strong>External APIs</strong> | ❌ Not included | ✅ Custom HTTP check |</p>
<p>| <strong>Custom Services</strong> | ❌ Not included | ✅ Custom logic check |</p>

<strong>Use Cases</strong>:
<ul><li>✅ Monitor transport connectivity</li>
<li>✅ Verify database availability</li>
<li>✅ Check external API dependencies</li>
<li>✅ Validate custom service health</li>
<li>✅ Kubernetes readiness/liveness probes</li>
</ul>
<hr>

<h2>IHealthCheck Interface</h2>

<pre><code class="language-csharp">using Microsoft.Extensions.Diagnostics.HealthChecks;

<p>public interface IHealthCheck {</p>
<p>  Task<HealthCheckResult> CheckHealthAsync(</p>
<p>    HealthCheckContext context,</p>
<p>    CancellationToken ct = default</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<strong>HealthCheckResult States</strong>:
<ul><li><strong>Healthy</strong>: Service operational</li>
<li><strong>Degraded</strong>: Service operational but impaired</li>
<li><strong>Unhealthy</strong>: Service not operational</li>
</ul>
<hr>

<h2>Transport Health Checks</h2>

<h3>Pattern 1: Kafka Transport Check</h3>

<pre><code class="language-csharp">using Microsoft.Extensions.Diagnostics.HealthChecks;
<p>using Confluent.Kafka;</p>

<p>public class KafkaHealthCheck : IHealthCheck {</p>
<p>  private readonly IProducer<string, string> _producer;</p>
<p>  private readonly ILogger<KafkaHealthCheck> _logger;</p>

<p>  public KafkaHealthCheck(</p>
<p>    IProducer<string, string> producer,</p>
<p>    ILogger<KafkaHealthCheck> logger</p>
<p>  ) {</p>
<p>    _producer = producer;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public Task<HealthCheckResult> CheckHealthAsync(</p>
<p>    HealthCheckContext context,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    try {</p>
<p>      // Get cluster metadata (verifies connectivity)</p>
<p>      var metadata = _producer.GetMetadata(TimeSpan.FromSeconds(5));</p>
<p>      var brokerCount = metadata.Brokers.Count;</p>

<p>      if (brokerCount == 0) {</p>
<p>        return Task.FromResult(HealthCheckResult.Unhealthy(</p>
<p>          "No Kafka brokers available"</p>
<p>        ));</p>
<p>      }</p>

<p>      return Task.FromResult(HealthCheckResult.Healthy(</p>
<p>        $"Kafka healthy, {brokerCount} brokers connected"</p>
<p>      ));</p>

<p>    } catch (KafkaException ex) {</p>
<p>      _logger.LogError(ex, "Kafka health check failed");</p>
<p>      return Task.FromResult(HealthCheckResult.Unhealthy(</p>
<p>        "Kafka cluster unreachable",</p>
<p>        ex</p>
<p>      ));</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern 2: Redis Cache Check</h3>

<pre><code class="language-csharp">using Microsoft.Extensions.Diagnostics.HealthChecks;
<p>using StackExchange.Redis;</p>

<p>public class RedisHealthCheck : IHealthCheck {</p>
<p>  private readonly IConnectionMultiplexer _redis;</p>

<p>  public RedisHealthCheck(IConnectionMultiplexer redis) {</p>
<p>    _redis = redis;</p>
<p>  }</p>

<p>  public async Task<HealthCheckResult> CheckHealthAsync(</p>
<p>    HealthCheckContext context,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    try {</p>
<p>      var db = _redis.GetDatabase();</p>

<p>      // Ping Redis</p>
<p>      var latency = await db.PingAsync();</p>

<p>      if (latency > TimeSpan.FromSeconds(1)) {</p>
<p>        return HealthCheckResult.Degraded(</p>
<p>          $"Redis responding slowly ({latency.TotalMilliseconds:F0}ms)"</p>
<p>        );</p>
<p>      }</p>

<p>      return HealthCheckResult.Healthy(</p>
<p>        $"Redis healthy ({latency.TotalMilliseconds:F0}ms latency)"</p>
<p>      );</p>

<p>    } catch (Exception ex) {</p>
<p>      return HealthCheckResult.Unhealthy(</p>
<p>        "Redis unavailable",</p>
<p>        ex</p>
<p>      );</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Database Health Checks</h2>

<h3>Pattern 3: PostgreSQL Check (Advanced)</h3>

<pre><code class="language-csharp">using Microsoft.Extensions.Diagnostics.HealthChecks;
<p>using Npgsql;</p>

<p>public class PostgresHealthCheck : IHealthCheck {</p>
<p>  private readonly string _connectionString;</p>
<p>  private readonly int _timeoutSeconds;</p>

<p>  public PostgresHealthCheck(string connectionString, int timeoutSeconds = 5) {</p>
<p>    _connectionString = connectionString;</p>
<p>    _timeoutSeconds = timeoutSeconds;</p>
<p>  }</p>

<p>  public async Task<HealthCheckResult> CheckHealthAsync(</p>
<p>    HealthCheckContext context,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    try {</p>
<p>      await using var conn = new NpgsqlConnection(_connectionString);</p>

<p>      // Set connection timeout</p>
<p>      var csBuilder = new NpgsqlConnectionStringBuilder(_connectionString) {</p>
<p>        Timeout = _timeoutSeconds</p>
<p>      };</p>
<p>      conn.ConnectionString = csBuilder.ToString();</p>

<p>      await conn.OpenAsync(ct);</p>

<p>      // Execute simple query to verify connectivity</p>
<p>      await using var cmd = new NpgsqlCommand("SELECT 1", conn);</p>
<p>      await cmd.ExecuteScalarAsync(ct);</p>

<p>      // Check connection pool stats</p>
<p>      var poolStats = conn.GetConnectionState();</p>

<p>      return HealthCheckResult.Healthy(</p>
<p>        $"PostgreSQL healthy (pool: {poolStats})"</p>
<p>      );</p>

<p>    } catch (TimeoutException ex) {</p>
<p>      return HealthCheckResult.Unhealthy(</p>
<p>        $"PostgreSQL connection timeout ({_timeoutSeconds}s)",</p>
<p>        ex</p>
<p>      );</p>
<p>    } catch (Exception ex) {</p>
<p>      return HealthCheckResult.Unhealthy(</p>
<p>        "PostgreSQL unavailable",</p>
<p>        ex</p>
<p>      );</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>External API Health Checks</h2>

<h3>Pattern 4: HTTP Dependency Check</h3>

<pre><code class="language-csharp">using Microsoft.Extensions.Diagnostics.HealthChecks;

<p>public class ExternalApiHealthCheck : IHealthCheck {</p>
<p>  private readonly HttpClient _http;</p>
<p>  private readonly string _healthEndpoint;</p>

<p>  public ExternalApiHealthCheck(</p>
<p>    HttpClient http,</p>
<p>    string healthEndpoint = "/health"</p>
<p>  ) {</p>
<p>    _http = http;</p>
<p>    _healthEndpoint = healthEndpoint;</p>
<p>  }</p>

<p>  public async Task<HealthCheckResult> CheckHealthAsync(</p>
<p>    HealthCheckContext context,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    try {</p>
<p>      var response = await _http.GetAsync(_healthEndpoint, ct);</p>

<p>      if (response.IsSuccessStatusCode) {</p>
<p>        return HealthCheckResult.Healthy(</p>
<p>          $"External API healthy (status {response.StatusCode})"</p>
<p>        );</p>
<p>      }</p>

<p>      return HealthCheckResult.Degraded(</p>
<p>        $"External API degraded (status {response.StatusCode})"</p>
<p>      );</p>

<p>    } catch (HttpRequestException ex) {</p>
<p>      return HealthCheckResult.Unhealthy(</p>
<p>        "External API unreachable",</p>
<p>        ex</p>
<p>      );</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Composite Health Checks</h2>

<h3>Pattern 5: Multi-Component Check</h3>

<pre><code class="language-csharp">using Microsoft.Extensions.Diagnostics.HealthChecks;

<p>public class WhizbangSystemHealthCheck : IHealthCheck {</p>
<p>  private readonly IEnumerable<IHealthCheck> _checks;</p>

<p>  public WhizbangSystemHealthCheck(IEnumerable<IHealthCheck> checks) {</p>
<p>    _checks = checks;</p>
<p>  }</p>

<p>  public async Task<HealthCheckResult> CheckHealthAsync(</p>
<p>    HealthCheckContext context,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var results = new List<(string Name, HealthCheckResult Result)>();</p>

<p>    foreach (var check in _checks) {</p>
<p>      var name = check.GetType().Name;</p>
<p>      var result = await check.CheckHealthAsync(context, ct);</p>
<p>      results.Add((name, result));</p>
<p>    }</p>

<p>    // Aggregate results</p>
<p>    var unhealthy = results.Where(r => r.Result.Status == HealthStatus.Unhealthy).ToList();</p>
<p>    var degraded = results.Where(r => r.Result.Status == HealthStatus.Degraded).ToList();</p>

<p>    if (unhealthy.Any()) {</p>
<p>      var failedChecks = string.Join(", ", unhealthy.Select(r => r.Name));</p>
<p>      return HealthCheckResult.Unhealthy(</p>
<p>        $"System unhealthy: {failedChecks} failed"</p>
<p>      );</p>
<p>    }</p>

<p>    if (degraded.Any()) {</p>
<p>      var degradedChecks = string.Join(", ", degraded.Select(r => r.Name));</p>
<p>      return HealthCheckResult.Degraded(</p>
<p>        $"System degraded: {degradedChecks} impaired"</p>
<p>      );</p>
<p>    }</p>

<p>    return HealthCheckResult.Healthy("All systems operational");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Registration and Configuration</h2>

<pre><code class="language-csharp">// Startup.cs
<p>builder.Services.AddHealthChecks()</p>
<p>  .AddCheck<KafkaHealthCheck>("kafka", tags: new[] { "transport" })</p>
<p>  .AddCheck<RedisHealthCheck>("redis", tags: new[] { "cache" })</p>
<p>  .AddCheck<PostgresHealthCheck>("postgres", tags: new[] { "database" })</p>
<p>  .AddCheck<ExternalApiHealthCheck>("external_api", tags: new[] { "external" });</p>

<p>// Health check endpoint</p>
<p>app.MapHealthChecks("/health");</p>

<p>// Filtered endpoints (Kubernetes)</p>
<p>app.MapHealthChecks("/health/ready", new HealthCheckOptions {</p>
<p>  Predicate = check => check.Tags.Contains("transport") || check.Tags.Contains("database")</p>
<p>});</p>

<p>app.MapHealthChecks("/health/live", new HealthCheckOptions {</p>
<p>  Predicate = check => true  // All checks</p>
<p>});</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Set timeouts</strong> for external checks (5s max)</li>
<li>✅ <strong>Use tags</strong> for filtering (readiness vs liveness)</li>
<li>✅ <strong>Return meaningful descriptions</strong> in results</li>
<li>✅ <strong>Handle exceptions gracefully</strong> (Unhealthy state)</li>
<li>✅ <strong>Test health checks</strong> in isolation</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Perform expensive operations (full table scans)</li>
<li>❌ Throw exceptions (return Unhealthy instead)</li>
<li>❌ Skip timeouts (infinite waits)</li>
<li>❌ Check every dependency (focus on critical)</li>
</ul>
<hr>

<h2>Further Reading</h2>

<strong>Infrastructure</strong>:
<ul><li><a href="../infrastructure/health-checks.md">Health Checks</a> - Built-in health checks</li>
</ul>
<strong>Transports</strong>:
<ul><li><a href="custom-transports.md">Custom Transports</a> - Transport implementations</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-extensibility-custom-id-generators" class="doc-section">
  <h3>Custom ID Generators</h3>
  <p class="doc-path"><code>v1.0.0/extensibility/custom-id-generators</code></p>
  <p class="doc-description"><em>Implement custom ID generation strategies - Snowflake IDs, ULID, CUID, or custom schemes</em></p>
  <div class="doc-content">

<h1>Custom ID Generators</h1>

<strong>Custom ID generators</strong> provide alternative ID schemes beyond UUIDv7. Implement Snowflake IDs, ULID, CUID, or custom distributed ID generation strategies.

<p>:::note</p>
<p>Whizbang uses UUIDv7 by default for time-ordered, database-friendly IDs. Custom generators are for specialized scenarios.</p>
<p>:::</p>

<hr>

<h2>Why Custom ID Generators?</h2>

<p>| ID Scheme | Benefits | Trade-offs |</p>
<p>|-----------|----------|------------|</p>
<p>| <strong>UUIDv7</strong> (default) | Time-ordered, standard | 128-bit size |</p>
<p>| <strong>Snowflake</strong> | 64-bit, Twitter-scale | Requires clock sync |</p>
<p>| <strong>ULID</strong> | Lexicographically sortable | Custom parsing |</p>
<p>| <strong>CUID</strong> | Collision-resistant | Custom format |</p>

<strong>When to use custom IDs</strong>:
<ul><li>✅ 64-bit ID requirements</li>
<li>✅ Specific ordering needs</li>
<li>✅ Custom collision resistance</li>
<li>✅ Legacy system compatibility</li>
</ul>
<hr>

<h2>Snowflake ID Generator</h2>

<h3>Pattern 1: Twitter Snowflake</h3>

<pre><code class="language-csharp">public class SnowflakeIdGenerator {
<p>  private readonly long _epoch = 1_640_995_200_000L;  // Jan 1, 2022</p>
<p>  private readonly long _machineId;</p>
<p>  private readonly object _lock = new();</p>
<p>  private long _sequence = 0L;</p>
<p>  private long _lastTimestamp = -1L;</p>

<p>  public SnowflakeIdGenerator(long machineId) {</p>
<p>    if (machineId < 0 || machineId > 1023) {</p>
<p>      throw new ArgumentException("Machine ID must be 0-1023");</p>
<p>    }</p>
<p>    _machineId = machineId;</p>
<p>  }</p>

<p>  public long NextId() {</p>
<p>    lock (_lock) {</p>
<p>      var timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();</p>

<p>      if (timestamp < _lastTimestamp) {</p>
<p>        throw new InvalidOperationException("Clock moved backwards");</p>
<p>      }</p>

<p>      if (timestamp == _lastTimestamp) {</p>
<p>        _sequence = (_sequence + 1) & 4095;  // 12-bit sequence</p>
<p>        if (_sequence == 0) {</p>
<p>          // Sequence overflow - wait for next millisecond</p>
<p>          timestamp = WaitNextMillis(_lastTimestamp);</p>
<p>        }</p>
<p>      } else {</p>
<p>        _sequence = 0;</p>
<p>      }</p>

<p>      _lastTimestamp = timestamp;</p>

<p>      // 41 bits: timestamp | 10 bits: machine | 12 bits: sequence</p>
<p>      return ((timestamp - _epoch) << 22) |</p>
<p>             (_machineId << 12) |</p>
<p>             _sequence;</p>
<p>    }</p>
<p>  }</p>

<p>  private long WaitNextMillis(long lastTimestamp) {</p>
<p>    var timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();</p>
<p>    while (timestamp <= lastTimestamp) {</p>
<p>      timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();</p>
<p>    }</p>
<p>    return timestamp;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">var generator = new SnowflakeIdGenerator(machineId: 42);
<p>var id = generator.NextId();  // 64-bit time-ordered ID</p>
<p></code></pre></p>

<hr>

<h2>ULID Generator</h2>

<h3>Pattern 2: Universally Unique Lexicographically Sortable ID</h3>

<pre><code class="language-csharp">using Ulid;

<p>public class UlidGenerator {</p>
<p>  public static string NewId() {</p>
<p>    return Ulid.NewUlid().ToString();  // 26-character string</p>
<p>  }</p>

<p>  public static Ulid Parse(string ulidString) {</p>
<p>    return Ulid.Parse(ulidString);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">var id = UlidGenerator.NewId();  // "01ARZ3NDEKTSV4RRFFQ69G5FAV"
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/message-context.md">Message Context</a> - MessageId, CorrelationId</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-extensibility-custom-perspectives" class="doc-section">
  <h3>Custom Perspectives</h3>
  <p class="doc-path"><code>v1.0.0/extensibility/custom-perspectives</code></p>
  <p class="doc-description"><em>Advanced perspective patterns - time-travel, snapshots, caching, batching, and custom storage backends</em></p>
  <div class="doc-content">

<h1>Custom Perspectives</h1>

<strong>Custom perspectives</strong> extend the basic <code>IPerspectiveOf<TEvent></code> pattern with advanced capabilities like time-travel (event replay), snapshots, caching layers, batch processing, and custom storage backends.

<p>:::note</p>
<p>For basic perspective usage, see <a href="../core-concepts/perspectives.md">Perspectives Guide</a>. This guide focuses on <strong>advanced customization patterns</strong> for specialized scenarios.</p>
<p>:::</p>

<hr>

<h2>Why Custom Perspective Patterns?</h2>

<strong>Built-in <code>IPerspectiveOf<TEvent></code> handles most cases</strong>, but some scenarios benefit from custom patterns:

<p>| Scenario | Standard Perspective | Custom Pattern |</p>
<p>|----------|---------------------|----------------|</p>
<p>| <strong>Event → Read Model</strong> | ✅ Perfect fit | No customization needed |</p>
<p>| <strong>Time-Travel Queries</strong> | ❌ No built-in support | ✅ Checkpoint-based replay |</p>
<p>| <strong>Performance (Large Events)</strong> | ❌ Full replay expensive | ✅ Snapshot + incremental |</p>
<p>| <strong>Caching Layer</strong> | ❌ Database-only | ✅ In-memory + database |</p>
<p>| <strong>Batch Updates</strong> | ❌ One-at-a-time | ✅ Batched for throughput |</p>
<p>| <strong>Custom Storage</strong> | ❌ SQL-only | ✅ Custom backends (Redis, Elasticsearch) |</p>
<p>| <strong>Hierarchical Models</strong> | ❌ Flat models | ✅ Parent-child relationships |</p>

<strong>When to customize</strong>:
<ul><li>✅ Time-travel / event replay scenarios</li>
<li>✅ High-frequency events (> 10K/sec per stream)</li>
<li>✅ Large event streams (> 1M events)</li>
<li>✅ Specialized storage (search engines, caches)</li>
<li>✅ Complex read model requirements</li>
</ul>
<strong>When NOT to customize</strong>:
<ul><li>❌ Simple event → table updates</li>
<li>❌ Low-volume scenarios (< 100 events/sec)</li>
<li>❌ Standard SQL read models</li>
</ul>
<hr>

<h2>Checkpoint System Overview</h2>

<p>:::note</p>
<p>For comprehensive coverage of perspective checkpoints including automatic creation, fuzzy type matching, error tracking, and the complete 4-phase checkpoint system, see <a href="../workers/perspective-worker.md">Perspective Worker</a>.</p>
<p>:::</p>

<strong>Core checkpoint concepts</strong>:
<ul><li><strong>Event Store</strong>: Immutable log of all events per stream</li>
<li><strong>Checkpoint</strong>: Last processed event per (stream, perspective) pair</li>
<li><strong>Auto-Creation</strong>: Checkpoints created automatically when events arrive (Phase 1)</li>
<li><strong>Fuzzy Matching</strong>: Perspectives matched to events via regex patterns (Phase 2)</li>
<li><strong>Processing</strong>: PerspectiveWorker polls and processes checkpoints (Phase 3)</li>
<li><strong>Error Tracking</strong>: Failed checkpoints persist error messages (Phase 4)</li>
</ul>
<p>See <a href="../workers/perspective-worker.md">Perspective Worker</a> for detailed checkpoint lifecycle, sequence diagrams, and runtime behavior.</p>

<hr>

<h2>Custom Base Classes</h2>

<h3>Pattern 1: Checkpoint-Aware Perspective Base</h3>

<strong>Use Case</strong>: Automatically track checkpoint after processing each event.

<pre><code class="language-csharp">using Whizbang.Core;
<p>using Whizbang.Core.Messaging;</p>

<p>public abstract class CheckpointPerspective<TEvent> : IPerspectiveOf<TEvent> where TEvent : IEvent {</p>
<p>  private readonly IWorkCoordinator _coordinator;</p>
<p>  protected readonly ILogger Logger;</p>

<p>  protected CheckpointPerspective(</p>
<p>    IWorkCoordinator coordinator,</p>
<p>    ILogger logger</p>
<p>  ) {</p>
<p>    _coordinator = coordinator;</p>
<p>    Logger = logger;</p>
<p>  }</p>

<p>  public async Task UpdateAsync(TEvent @event, CancellationToken ct = default) {</p>
<p>    // 1. Process event (implemented by subclass)</p>
<p>    await ProcessEventAsync(@event, ct);</p>

<p>    // 2. Update checkpoint automatically</p>
<p>    await UpdateCheckpointAsync(@event, ct);</p>

<p>    Logger.LogInformation(</p>
<p>      "Processed {EventType} for stream {StreamId}, checkpoint updated to {EventId}",</p>
<p>      typeof(TEvent).Name,</p>
<p>      @event.StreamId,</p>
<p>      @event.EventId</p>
<p>    );</p>
<p>  }</p>

<p>  /// <summary></p>
<p>  /// Implement event processing logic here.</p>
<p>  /// Checkpoint is updated automatically after success.</p>
<p>  /// </summary></p>
<p>  protected abstract Task ProcessEventAsync(TEvent @event, CancellationToken ct);</p>

<p>  /// <summary></p>
<p>  /// Get the perspective name for checkpoint tracking.</p>
<p>  /// Default: class name. Override for custom names.</p>
<p>  /// </summary></p>
<p>  protected virtual string GetPerspectiveName() => GetType().Name;</p>

<p>  private async Task UpdateCheckpointAsync(TEvent @event, CancellationToken ct) {</p>
<p>    var completion = new PerspectiveCheckpointCompletion {</p>
<p>      StreamId = @event.StreamId,</p>
<p>      PerspectiveName = GetPerspectiveName(),</p>
<p>      LastEventId = @event.EventId,</p>
<p>      Status = PerspectiveProcessingStatus.Completed</p>
<p>    };</p>

<p>    // Update checkpoint via work coordinator</p>
<p>    await _coordinator.ProcessWorkBatchAsync(</p>
<p>      instanceId: Guid.NewGuid(),</p>
<p>      serviceName: "Perspective",</p>
<p>      hostName: Environment.MachineName,</p>
<p>      processId: Environment.ProcessId,</p>
<p>      metadata: null,</p>
<p>      outboxCompletions: [],</p>
<p>      outboxFailures: [],</p>
<p>      inboxCompletions: [],</p>
<p>      inboxFailures: [],</p>
<p>      receptorCompletions: [],</p>
<p>      receptorFailures: [],</p>
<p>      perspectiveCompletions: [completion],  // ← Update checkpoint</p>
<p>      perspectiveFailures: [],</p>
<p>      newOutboxMessages: [],</p>
<p>      newInboxMessages: [],</p>
<p>      renewOutboxLeaseIds: [],</p>
<p>      renewInboxLeaseIds: [],</p>
<p>      cancellationToken: ct</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">public record OrderCreated(
<p>  Guid StreamId,</p>
<p>  Guid EventId,</p>
<p>  Guid OrderId,</p>
<p>  Guid CustomerId,</p>
<p>  decimal Total</p>
<p>) : IEvent;</p>

<p>public class OrderSummaryPerspective : CheckpointPerspective<OrderCreated> {</p>
<p>  private readonly IDbConnectionFactory _db;</p>

<p>  public OrderSummaryPerspective(</p>
<p>    IWorkCoordinator coordinator,</p>
<p>    ILogger<OrderSummaryPerspective> logger,</p>
<p>    IDbConnectionFactory db</p>
<p>  ) : base(coordinator, logger) {</p>
<p>    _db = db;</p>
<p>  }</p>

<p>  // Checkpoint updated automatically after ProcessEventAsync completes</p>
<p>  protected override async Task ProcessEventAsync(</p>
<p>    OrderCreated @event,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    await using var conn = _db.CreateConnection();</p>
<p>    await conn.ExecuteAsync(</p>
<p>      "INSERT INTO order_summaries (order_id, customer_id, total, status) VALUES (@OrderId, @CustomerId, @Total, 'Created')",</p>
<p>      new { @event.OrderId, @event.CustomerId, @event.Total },</p>
<p>      ct</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li><strong>Automatic Checkpoint Tracking</strong>: No manual checkpoint management</li>
<li><strong>Time-Travel Ready</strong>: Can replay from any checkpoint</li>
<li><strong>Consistent Pattern</strong>: Same checkpoint logic across perspectives</li>
</ul>
<hr>

<h3>Pattern 2: Snapshot Perspective Base</h3>

<strong>Use Case</strong>: Periodic snapshots instead of full event replay for large streams.

<pre><code class="language-csharp">using Whizbang.Core;

<p>public abstract class SnapshotPerspective<TEvent, TSnapshot> : IPerspectiveOf<TEvent></p>
<p>  where TEvent : IEvent</p>
<p>  where TSnapshot : class, new() {</p>

<p>  private readonly IPerspectiveStore<TSnapshot> _store;</p>
<p>  protected readonly ILogger Logger;</p>

<p>  // Snapshot every N events (configurable)</p>
<p>  protected virtual int SnapshotInterval => 100;</p>

<p>  protected SnapshotPerspective(</p>
<p>    IPerspectiveStore<TSnapshot> store,</p>
<p>    ILogger logger</p>
<p>  ) {</p>
<p>    _store = store;</p>
<p>    Logger = logger;</p>
<p>  }</p>

<p>  public async Task UpdateAsync(TEvent @event, CancellationToken ct = default) {</p>
<p>    // 1. Load current snapshot (or create new)</p>
<p>    var snapshot = await LoadSnapshotAsync(@event.StreamId.ToString(), ct)</p>
<p>                   ?? new TSnapshot();</p>

<p>    // 2. Apply event to snapshot</p>
<p>    ApplyEvent(@event, snapshot);</p>

<p>    // 3. Save updated snapshot</p>
<p>    await _store.UpsertAsync(@event.StreamId.ToString(), snapshot, ct);</p>

<p>    Logger.LogDebug(</p>
<p>      "Applied {EventType} to snapshot for stream {StreamId}",</p>
<p>      typeof(TEvent).Name,</p>
<p>      @event.StreamId</p>
<p>    );</p>
<p>  }</p>

<p>  /// <summary></p>
<p>  /// Apply event to snapshot (implement delta update).</p>
<p>  /// </summary></p>
<p>  protected abstract void ApplyEvent(TEvent @event, TSnapshot snapshot);</p>

<p>  /// <summary></p>
<p>  /// Load snapshot from store.</p>
<p>  /// </summary></p>
<p>  protected virtual async Task<TSnapshot?> LoadSnapshotAsync(</p>
<p>    string streamId,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    // IPerspectiveStore doesn't expose reads - this is write-only</p>
<p>    // For reads, use a separate query service/lens</p>
<p>    return new TSnapshot();  // Simplified for example</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">public record OrderSnapshot {
<p>  public Guid OrderId { get; set; }</p>
<p>  public Guid CustomerId { get; set; }</p>
<p>  public decimal Total { get; set; }</p>
<p>  public string Status { get; set; } = "Created";</p>
<p>  public int EventCount { get; set; }  // Track events applied</p>
<p>}</p>

<p>public class OrderSnapshotPerspective : SnapshotPerspective<OrderCreated, OrderSnapshot> {</p>
<p>  public OrderSnapshotPerspective(</p>
<p>    IPerspectiveStore<OrderSnapshot> store,</p>
<p>    ILogger<OrderSnapshotPerspective> logger</p>
<p>  ) : base(store, logger) { }</p>

<p>  protected override void ApplyEvent(OrderCreated @event, OrderSnapshot snapshot) {</p>
<p>    // Delta update - only change what's new</p>
<p>    snapshot.OrderId = @event.OrderId;</p>
<p>    snapshot.CustomerId = @event.CustomerId;</p>
<p>    snapshot.Total = @event.Total;</p>
<p>    snapshot.Status = "Created";</p>
<p>    snapshot.EventCount++;</p>

<p>    Logger.LogInformation(</p>
<p>      "Applied OrderCreated to snapshot, now at {EventCount} events",</p>
<p>      snapshot.EventCount</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li><strong>Fast Rebuild</strong>: Snapshot + recent events (not full replay)</li>
<li><strong>Performance</strong>: O(recent events) instead of O(all events)</li>
<li><strong>Scalability</strong>: Works with millions of events per stream</li>
</ul>
<hr>

<h2>Time-Travel Perspectives</h2>

<h3>Pattern 3: Event Replay Perspective</h3>

<strong>Use Case</strong>: Rebuild read model from event history for any point in time.

<pre><code class="language-csharp">using Whizbang.Core;

<p>public class TimeravelOrderSummaryPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>  private readonly IEventStore _eventStore;</p>
<p>  private readonly IDbConnectionFactory _db;</p>
<p>  private readonly ILogger<TimeravelOrderSummaryPerspective> _logger;</p>

<p>  public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>    // Standard event processing</p>
<p>    await using var conn = _db.CreateConnection();</p>
<p>    await conn.ExecuteAsync(</p>
<p>      "INSERT INTO order_summaries (...) VALUES (...)",</p>
<p>      @event,</p>
<p>      ct</p>
<p>    );</p>
<p>  }</p>

<p>  /// <summary></p>
<p>  /// Rebuild read model from event history up to specific event.</p>
<p>  /// Enables "what did the order look like at 2:00 PM yesterday?"</p>
<p>  /// </summary></p>
<p>  public async Task RebuildToEventAsync(</p>
<p>    Guid streamId,</p>
<p>    Guid targetEventId,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    _logger.LogInformation(</p>
<p>      "Rebuilding OrderSummary for stream {StreamId} up to event {EventId}",</p>
<p>      streamId,</p>
<p>      targetEventId</p>
<p>    );</p>

<p>    // 1. Clear existing read model for this stream</p>
<p>    await ClearReadModelAsync(streamId, ct);</p>

<p>    // 2. Replay events in order until target event</p>
<p>    await foreach (var @event in _eventStore.GetEventsAsync<OrderCreated>(</p>
<p>      streamId,</p>
<p>      untilEventId: targetEventId,  // Stop at target</p>
<p>      ct</p>
<p>    )) {</p>
<p>      await UpdateAsync(@event, ct);</p>
<p>    }</p>

<p>    _logger.LogInformation(</p>
<p>      "Rebuilt OrderSummary for stream {StreamId} to event {EventId}",</p>
<p>      streamId,</p>
<p>      targetEventId</p>
<p>    );</p>
<p>  }</p>

<p>  /// <summary></p>
<p>  /// Rebuild entire read model from scratch.</p>
<p>  /// </summary></p>
<p>  public async Task RebuildAllAsync(CancellationToken ct = default) {</p>
<p>    _logger.LogInformation("Rebuilding all OrderSummary read models");</p>

<p>    // 1. Truncate read model table</p>
<p>    await using var conn = _db.CreateConnection();</p>
<p>    await conn.ExecuteAsync("TRUNCATE TABLE order_summaries", ct);</p>

<p>    // 2. Replay all events</p>
<p>    await foreach (var @event in _eventStore.GetAllEventsAsync<OrderCreated>(ct)) {</p>
<p>      await UpdateAsync(@event, ct);</p>
<p>    }</p>

<p>    _logger.LogInformation("Rebuilt all OrderSummary read models");</p>
<p>  }</p>

<p>  private async Task ClearReadModelAsync(Guid streamId, CancellationToken ct) {</p>
<p>    await using var conn = _db.CreateConnection();</p>
<p>    await conn.ExecuteAsync(</p>
<p>      "DELETE FROM order_summaries WHERE stream_id = @StreamId",</p>
<p>      new { StreamId = streamId },</p>
<p>      ct</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">// Standard event processing
<p>await perspective.UpdateAsync(orderCreated, ct);</p>

<p>// Time-travel: rebuild to specific event</p>
<p>var specificEventId = Guid.Parse("...");  // Event from 2:00 PM yesterday</p>
<p>await perspective.RebuildToEventAsync(orderId, specificEventId, ct);</p>

<p>// Rebuild entire read model (after schema change)</p>
<p>await perspective.RebuildAllAsync(ct);</p>
<p></code></pre></p>

<strong>Use Cases</strong>:
<ul><li><strong>Debugging</strong>: What did the order look like when bug occurred?</li>
<li><strong>Auditing</strong>: Reconstruct state at regulatory compliance checkpoint</li>
<li><strong>Schema Evolution</strong>: Rebuild read model after adding new fields</li>
<li><strong>Testing</strong>: Verify read model correctness by replaying production events</li>
</ul>
<hr>

<h2>Performance Optimization</h2>

<h3>Pattern 4: Batching Perspective</h3>

<strong>Use Case</strong>: Batch multiple events for single database roundtrip.

<pre><code class="language-csharp">using Whizbang.Core;
<p>using System.Threading.Channels;</p>

<p>public class BatchingOrderSummaryPerspective : IPerspectiveOf<OrderCreated>, IAsyncDisposable {</p>
<p>  private readonly IDbConnectionFactory _db;</p>
<p>  private readonly ILogger<BatchingOrderSummaryPerspective> _logger;</p>

<p>  private readonly Channel<OrderCreated> _eventQueue;</p>
<p>  private readonly Task _batchProcessor;</p>
<p>  private readonly CancellationTokenSource _cts;</p>

<p>  // Batch settings</p>
<p>  private const int BatchSize = 100;</p>
<p>  private static readonly TimeSpan BatchTimeout = TimeSpan.FromMilliseconds(500);</p>

<p>  public BatchingOrderSummaryPerspective(</p>
<p>    IDbConnectionFactory db,</p>
<p>    ILogger<BatchingOrderSummaryPerspective> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _logger = logger;</p>

<p>    // Bounded channel for backpressure</p>
<p>    _eventQueue = Channel.CreateBounded<OrderCreated>(new BoundedChannelOptions(10000) {</p>
<p>      FullMode = BoundedChannelFullMode.Wait</p>
<p>    });</p>

<p>    _cts = new CancellationTokenSource();</p>
<p>    _batchProcessor = Task.Run(() => ProcessBatchesAsync(_cts.Token));</p>
<p>  }</p>

<p>  public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>    // Queue event for batch processing</p>
<p>    await _eventQueue.Writer.WriteAsync(@event, ct);</p>
<p>  }</p>

<p>  private async Task ProcessBatchesAsync(CancellationToken ct) {</p>
<p>    var batch = new List<OrderCreated>(BatchSize);</p>

<p>    while (!ct.IsCancellationRequested) {</p>
<p>      try {</p>
<p>        // Read up to BatchSize events or timeout</p>
<p>        while (batch.Count < BatchSize) {</p>
<p>          using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(ct);</p>
<p>          timeoutCts.CancelAfter(BatchTimeout);</p>

<p>          try {</p>
<p>            var @event = await _eventQueue.Reader.ReadAsync(timeoutCts.Token);</p>
<p>            batch.Add(@event);</p>
<p>          } catch (OperationCanceledException) {</p>
<p>            // Timeout or cancellation - process what we have</p>
<p>            break;</p>
<p>          }</p>
<p>        }</p>

<p>        // Process batch if we have any events</p>
<p>        if (batch.Count > 0) {</p>
<p>          await ProcessBatchAsync(batch, ct);</p>
<p>          batch.Clear();</p>
<p>        }</p>

<p>      } catch (Exception ex) when (ex is not OperationCanceledException) {</p>
<p>        _logger.LogError(ex, "Error processing event batch");</p>
<p>        await Task.Delay(TimeSpan.FromSeconds(1), ct);  // Backoff</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>

<p>  private async Task ProcessBatchAsync(List<OrderCreated> events, CancellationToken ct) {</p>
<p>    await using var conn = _db.CreateConnection();</p>

<p>    // Single INSERT for entire batch</p>
<p>    await conn.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO order_summaries (order_id, customer_id, total, status, created_at)</p>
<p>      VALUES (@OrderId, @CustomerId, @Total, 'Created', @CreatedAt)</p>
<p>      ON CONFLICT (order_id) DO NOTHING</p>
<p>      """,</p>
<p>      events,  // ← Dapper executes once per item, but single roundtrip</p>
<p>      ct</p>
<p>    );</p>

<p>    _logger.LogInformation(</p>
<p>      "Processed batch of {Count} events",</p>
<p>      events.Count</p>
<p>    );</p>
<p>  }</p>

<p>  public async ValueTask DisposeAsync() {</p>
<p>    // Shutdown gracefully</p>
<p>    _eventQueue.Writer.Complete();</p>
<p>    _cts.Cancel();</p>

<p>    try {</p>
<p>      await _batchProcessor.WaitAsync(TimeSpan.FromSeconds(10));</p>
<p>    } catch (TimeoutException) {</p>
<p>      _logger.LogWarning("Batch processor did not complete within timeout");</p>
<p>    }</p>

<p>    _cts.Dispose();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Performance</strong>:
<ul><li><strong>Throughput</strong>: 10x improvement (100 events/batch vs 1 event/call)</li>
<li><strong>Latency</strong>: Slightly higher (max 500ms batching delay)</li>
<li><strong>Database Load</strong>: 10x reduction in connections/queries</li>
</ul>
<hr>

<h3>Pattern 5: Cached Perspective</h3>

<strong>Use Case</strong>: In-memory cache + database for read-heavy scenarios.

<pre><code class="language-csharp">using Whizbang.Core;
<p>using Microsoft.Extensions.Caching.Memory;</p>

<p>public class CachedOrderSummaryPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>  private readonly IDbConnectionFactory _db;</p>
<p>  private readonly IMemoryCache _cache;</p>
<p>  private readonly ILogger<CachedOrderSummaryPerspective> _logger;</p>

<p>  private static readonly MemoryCacheEntryOptions CacheOptions = new() {</p>
<p>    AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5),</p>
<p>    SlidingExpiration = TimeSpan.FromMinutes(1)</p>
<p>  };</p>

<p>  public CachedOrderSummaryPerspective(</p>
<p>    IDbConnectionFactory db,</p>
<p>    IMemoryCache cache,</p>
<p>    ILogger<CachedOrderSummaryPerspective> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _cache = cache;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>    // 1. Update database (source of truth)</p>
<p>    await using var conn = _db.CreateConnection();</p>
<p>    await conn.ExecuteAsync(</p>
<p>      "INSERT INTO order_summaries (order_id, customer_id, total, status) VALUES (@OrderId, @CustomerId, @Total, 'Created')",</p>
<p>      new { @event.OrderId, @event.CustomerId, @event.Total },</p>
<p>      ct</p>
<p>    );</p>

<p>    // 2. Update cache</p>
<p>    var cacheKey = GetCacheKey(@event.OrderId);</p>
<p>    var summary = new OrderSummary {</p>
<p>      OrderId = @event.OrderId,</p>
<p>      CustomerId = @event.CustomerId,</p>
<p>      Total = @event.Total,</p>
<p>      Status = "Created"</p>
<p>    };</p>

<p>    _cache.Set(cacheKey, summary, CacheOptions);</p>

<p>    _logger.LogDebug(</p>
<p>      "Updated order summary for {OrderId} in database and cache",</p>
<p>      @event.OrderId</p>
<p>    );</p>
<p>  }</p>

<p>  /// <summary></p>
<p>  /// Read from cache, fall back to database if cache miss.</p>
<p>  /// </summary></p>
<p>  public async Task<OrderSummary?> GetAsync(Guid orderId, CancellationToken ct = default) {</p>
<p>    var cacheKey = GetCacheKey(orderId);</p>

<p>    // Try cache first</p>
<p>    if (_cache.TryGetValue(cacheKey, out OrderSummary? cached)) {</p>
<p>      _logger.LogDebug("Cache hit for order {OrderId}", orderId);</p>
<p>      return cached;</p>
<p>    }</p>

<p>    // Cache miss - load from database</p>
<p>    _logger.LogDebug("Cache miss for order {OrderId}, loading from database", orderId);</p>

<p>    await using var conn = _db.CreateConnection();</p>
<p>    var summary = await conn.QuerySingleOrDefaultAsync<OrderSummary>(</p>
<p>      "SELECT * FROM order_summaries WHERE order_id = @OrderId",</p>
<p>      new { OrderId = orderId },</p>
<p>      ct</p>
<p>    );</p>

<p>    if (summary is not null) {</p>
<p>      // Populate cache for next time</p>
<p>      _cache.Set(cacheKey, summary, CacheOptions);</p>
<p>    }</p>

<p>    return summary;</p>
<p>  }</p>

<p>  private static string GetCacheKey(Guid orderId) => $"order-summary:{orderId}";</p>
<p>}</p>

<p>public record OrderSummary {</p>
<p>  public Guid OrderId { get; set; }</p>
<p>  public Guid CustomerId { get; set; }</p>
<p>  public decimal Total { get; set; }</p>
<p>  public string Status { get; set; } = string.Empty;</p>
<p>}</p>
<p></code></pre></p>

<strong>Performance</strong>:
<ul><li><strong>Cache Hit Rate</strong>: 95%+ for read-heavy workloads</li>
<li><strong>Latency</strong>: ~1µs (cache) vs ~5ms (database)</li>
<li><strong>Database Load</strong>: 95% reduction in reads</li>
</ul>
<hr>

<h2>Custom Storage Backends</h2>

<h3>Pattern 6: IPerspectiveStore Implementation</h3>

<strong>Use Case</strong>: Custom storage backend (Redis, Elasticsearch, etc.).

<pre><code class="language-csharp">using Whizbang.Core.Perspectives;
<p>using StackExchange.Redis;</p>
<p>using System.Text.Json;</p>

<p>/// <summary></p>
<p>/// Redis-based perspective store for high-performance read models.</p>
<p>/// </summary></p>
<p>public class RedisPerspectiveStore<TModel> : IPerspectiveStore<TModel> where TModel : class {</p>
<p>  private readonly IConnectionMultiplexer _redis;</p>
<p>  private readonly ILogger<RedisPerspectiveStore<TModel>> _logger;</p>
<p>  private readonly string _keyPrefix;</p>

<p>  private static readonly JsonSerializerOptions JsonOptions = new() {</p>
<p>    PropertyNamingPolicy = JsonNamingPolicy.CamelCase</p>
<p>  };</p>

<p>  public RedisPerspectiveStore(</p>
<p>    IConnectionMultiplexer redis,</p>
<p>    ILogger<RedisPerspectiveStore<TModel>> logger,</p>
<p>    string? keyPrefix = null</p>
<p>  ) {</p>
<p>    _redis = redis;</p>
<p>    _logger = logger;</p>
<p>    _keyPrefix = keyPrefix ?? typeof(TModel).Name.ToLowerInvariant();</p>
<p>  }</p>

<p>  public async Task UpsertAsync(</p>
<p>    string id,</p>
<p>    TModel model,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var db = _redis.GetDatabase();</p>
<p>    var key = GetRedisKey(id);</p>

<p>    // Serialize model to JSON</p>
<p>    var json = JsonSerializer.Serialize(model, JsonOptions);</p>

<p>    // Store in Redis with expiration</p>
<p>    await db.StringSetAsync(</p>
<p>      key,</p>
<p>      json,</p>
<p>      expiry: TimeSpan.FromHours(24)  // TTL for read models</p>
<p>    );</p>

<p>    _logger.LogDebug(</p>
<p>      "Upserted {ModelType} with id {Id} to Redis",</p>
<p>      typeof(TModel).Name,</p>
<p>      id</p>
<p>    );</p>
<p>  }</p>

<p>  /// <summary></p>
<p>  /// Get model from Redis (not part of IPerspectiveStore, but useful for reads).</p>
<p>  /// </summary></p>
<p>  public async Task<TModel?> GetAsync(string id, CancellationToken ct = default) {</p>
<p>    var db = _redis.GetDatabase();</p>
<p>    var key = GetRedisKey(id);</p>

<p>    var json = await db.StringGetAsync(key);</p>
<p>    if (json.IsNullOrEmpty) {</p>
<p>      return null;</p>
<p>    }</p>

<p>    return JsonSerializer.Deserialize<TModel>(json!, JsonOptions);</p>
<p>  }</p>

<p>  private string GetRedisKey(string id) => $"{_keyPrefix}:{id}";</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">// Register Redis perspective store
<p>builder.Services.AddSingleton<IConnectionMultiplexer>(</p>
<p>  ConnectionMultiplexer.Connect("localhost:6379")</p>
<p>);</p>
<p>builder.Services.AddSingleton<IPerspectiveStore<OrderSummary>, RedisPerspectiveStore<OrderSummary>>();</p>

<p>// Use in perspective</p>
<p>public class OrderSummaryPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>  private readonly IPerspectiveStore<OrderSummary> _store;</p>

<p>  public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>    var summary = new OrderSummary {</p>
<p>      OrderId = @event.OrderId,</p>
<p>      CustomerId = @event.CustomerId,</p>
<p>      Total = @event.Total,</p>
<p>      Status = "Created"</p>
<p>    };</p>

<p>    // Store in Redis (via IPerspectiveStore abstraction)</p>
<p>    await _store.UpsertAsync(@event.OrderId.ToString(), summary, ct);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li><strong>Storage Flexibility</strong>: Redis, Elasticsearch, MongoDB, etc.</li>
<li><strong>Abstraction</strong>: Perspectives don't know storage details</li>
<li><strong>Testability</strong>: Mock IPerspectiveStore for unit tests</li>
</ul>
<hr>

<h2>Advanced Patterns</h2>

<h3>Pattern 7: Hierarchical Perspective</h3>

<strong>Use Case</strong>: Parent-child read models (order → order items).

<pre><code class="language-csharp">using Whizbang.Core;

<p>public class OrderDetailsPerspective :</p>
<p>  IPerspectiveOf<OrderCreated>,</p>
<p>  IPerspectiveOf<OrderItemAdded> {</p>

<p>  private readonly IDbConnectionFactory _db;</p>

<p>  public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>    await using var conn = _db.CreateConnection();</p>

<p>    // Insert parent record</p>
<p>    await conn.ExecuteAsync(</p>
<p>      "INSERT INTO order_details (order_id, customer_id, total, status) VALUES (@OrderId, @CustomerId, @Total, 'Created')",</p>
<p>      new { @event.OrderId, @event.CustomerId, @event.Total },</p>
<p>      ct</p>
<p>    );</p>
<p>  }</p>

<p>  public async Task UpdateAsync(OrderItemAdded @event, CancellationToken ct = default) {</p>
<p>    await using var conn = _db.CreateConnection();</p>

<p>    // Insert child record</p>
<p>    await conn.ExecuteAsync(</p>
<p>      "INSERT INTO order_detail_items (order_id, product_id, quantity, unit_price) VALUES (@OrderId, @ProductId, @Quantity, @UnitPrice)",</p>
<p>      new { @event.OrderId, @event.ProductId, @event.Quantity, @event.UnitPrice },</p>
<p>      ct</p>
<p>    );</p>

<p>    // Update parent aggregate</p>
<p>    await conn.ExecuteAsync(</p>
<p>      "UPDATE order_details SET total = total + (@Quantity * @UnitPrice) WHERE order_id = @OrderId",</p>
<p>      new { @event.OrderId, @event.Quantity, @event.UnitPrice },</p>
<p>      ct</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Schema</strong>:
<pre><code class="language-sql">CREATE TABLE order_details (
<p>    order_id UUID PRIMARY KEY,</p>
<p>    customer_id UUID NOT NULL,</p>
<p>    total DECIMAL(10,2) NOT NULL,</p>
<p>    status VARCHAR(50) NOT NULL</p>
<p>);</p>

<p>CREATE TABLE order_detail_items (</p>
<p>    order_item_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),</p>
<p>    order_id UUID NOT NULL REFERENCES order_details(order_id),</p>
<p>    product_id UUID NOT NULL,</p>
<p>    quantity INT NOT NULL,</p>
<p>    unit_price DECIMAL(10,2) NOT NULL</p>
<p>);</p>
<p></code></pre></p>

<hr>

<h3>Pattern 8: Transformation Perspective</h3>

<strong>Use Case</strong>: Transform events before storing (enrich, filter, aggregate).

<pre><code class="language-csharp">using Whizbang.Core;

<p>public class EnrichedOrderPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>  private readonly IDbConnectionFactory _db;</p>
<p>  private readonly ICustomerService _customerService;</p>
<p>  private readonly ILogger<EnrichedOrderPerspective> _logger;</p>

<p>  public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>    // 1. Enrich event with customer data</p>
<p>    var customer = await _customerService.GetCustomerAsync(@event.CustomerId, ct);</p>

<p>    // 2. Transform and store enriched data</p>
<p>    await using var conn = _db.CreateConnection();</p>
<p>    await conn.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO enriched_orders (</p>
<p>          order_id, customer_id, customer_name, customer_email, customer_tier,</p>
<p>          total, status, created_at</p>
<p>      ) VALUES (</p>
<p>          @OrderId, @CustomerId, @CustomerName, @CustomerEmail, @CustomerTier,</p>
<p>          @Total, 'Created', @CreatedAt</p>
<p>      )</p>
<p>      """,</p>
<p>      new {</p>
<p>        @event.OrderId,</p>
<p>        @event.CustomerId,</p>
<p>        CustomerName = customer.FullName,       // ← Enriched</p>
<p>        CustomerEmail = customer.Email,         // ← Enriched</p>
<p>        CustomerTier = customer.LoyaltyTier,    // ← Enriched</p>
<p>        @event.Total,</p>
<p>        @event.CreatedAt</p>
<p>      },</p>
<p>      ct</p>
<p>    );</p>

<p>    _logger.LogInformation(</p>
<p>      "Enriched order {OrderId} with customer data for {CustomerName}",</p>
<p>      @event.OrderId,</p>
<p>      customer.FullName</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Testing Custom Perspectives</h2>

<h3>Testing Checkpoint Perspectives</h3>

<pre><code class="language-csharp">public class CheckpointPerspectiveTests {
<p>  [Test]</p>
<p>  public async Task UpdateAsync_UpdatesCheckpointAfterProcessingAsync() {</p>
<p>    // Arrange</p>
<p>    var mockCoordinator = CreateMockWorkCoordinator();</p>
<p>    var mockDb = CreateMockDb();</p>
<p>    var logger = new NullLogger<OrderSummaryPerspective>();</p>

<p>    var perspective = new OrderSummaryPerspective(mockCoordinator, logger, mockDb);</p>

<p>    var @event = new OrderCreated(</p>
<p>      StreamId: Guid.NewGuid(),</p>
<p>      EventId: Guid.NewGuid(),</p>
<p>      OrderId: Guid.NewGuid(),</p>
<p>      CustomerId: Guid.NewGuid(),</p>
<p>      Total: 99.99m</p>
<p>    );</p>

<p>    // Act</p>
<p>    await perspective.UpdateAsync(@event);</p>

<p>    // Assert - checkpoint updated</p>
<p>    var checkpoints = mockCoordinator.GetPerspectiveCheckpoints();</p>
<p>    await Assert.That(checkpoints).HasCount().EqualTo(1);</p>
<p>    await Assert.That(checkpoints[0].StreamId).IsEqualTo(@event.StreamId);</p>
<p>    await Assert.That(checkpoints[0].LastEventId).IsEqualTo(@event.EventId);</p>
<p>    await Assert.That(checkpoints[0].PerspectiveName).IsEqualTo("OrderSummaryPerspective");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Testing Time-Travel Perspectives</h3>

<pre><code class="language-csharp">public class TimeravelPerspectiveTests {
<p>  [Test]</p>
<p>  public async Task RebuildToEventAsync_ReplaysEventsUpToTargetAsync() {</p>
<p>    // Arrange</p>
<p>    var mockEventStore = CreateMockEventStore(eventCount: 10);</p>
<p>    var mockDb = CreateMockDb();</p>
<p>    var logger = new NullLogger<TimeravelOrderSummaryPerspective>();</p>

<p>    var perspective = new TimeravelOrderSummaryPerspective(mockEventStore, mockDb, logger);</p>

<p>    var streamId = Guid.NewGuid();</p>
<p>    var targetEventId = mockEventStore.GetEventId(streamId, eventIndex: 5);  // Event #5</p>

<p>    // Act - rebuild to event #5 (should process events 1-5)</p>
<p>    await perspective.RebuildToEventAsync(streamId, targetEventId);</p>

<p>    // Assert - only 5 events processed</p>
<p>    var summaries = await mockDb.QueryAsync<OrderSummary>(</p>
<p>      "SELECT * FROM order_summaries WHERE stream_id = @StreamId",</p>
<p>      new { StreamId = streamId }</p>
<p>    );</p>

<p>    await Assert.That(summaries).HasCount().EqualTo(5);  // Not 10!</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Track checkpoints</strong> for time-travel scenarios</li>
<li>✅ <strong>Use snapshots</strong> for large event streams (> 1M events)</li>
<li>✅ <strong>Batch updates</strong> for high-throughput scenarios (> 10K events/sec)</li>
<li>✅ <strong>Cache read models</strong> for read-heavy workloads</li>
<li>✅ <strong>Make perspectives idempotent</strong> (same event = same result)</li>
<li>✅ <strong>Test time-travel scenarios</strong> (rebuild from any point)</li>
<li>✅ <strong>Log checkpoint progress</strong> for debugging</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Store state in perspective instances (stateless only)</li>
<li>❌ Skip checkpoint updates (breaks time-travel)</li>
<li>❌ Replay all events for every query (use snapshots)</li>
<li>❌ Block perspective processing (async all the way)</li>
<li>❌ Ignore idempotency (duplicate events will happen)</li>
<li>❌ Mix read and write logic in perspectives</li>
</ul>
<hr>

<h2>Further Reading</h2>

<strong>Workers</strong>:
<ul><li><a href="../workers/perspective-worker.md">Perspective Worker</a> - <strong>Comprehensive checkpoint lifecycle and 4-phase system</strong></li>
<li><a href="../workers/execution-lifecycle.md">Execution Lifecycle</a> - Startup/shutdown coordination</li>
<li><a href="../workers/database-readiness.md">Database Readiness</a> - Dependency coordination</li>
</ul>
<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/perspectives.md">Perspectives Guide</a> - Basic perspective usage</li>
<li><a href="../core-concepts/dispatcher.md">Dispatcher</a> - Publishing events</li>
<li><a href="../data/event-store.md">Event Store</a> - Event storage patterns</li>
</ul>
<strong>Extensibility</strong>:
<ul><li><a href="custom-receptors.md">Custom Receptors</a> - Advanced receptor patterns</li>
<li><a href="custom-storage.md">Custom Storage</a> - Storage backend implementations</li>
</ul>
<strong>Data Access</strong>:
<ul><li><a href="../data/perspectives-storage.md">Perspectives Storage</a> - Schema design</li>
</ul>
<strong>Messaging</strong>:
<ul><li><a href="../messaging/work-coordinator.md">Work Coordinator</a> - Atomic batch processing and checkpoint tracking</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2025-12-21</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-extensibility-custom-policies" class="doc-section">
  <h3>Custom Policies</h3>
  <p class="doc-path"><code>v1.0.0/extensibility/custom-policies</code></p>
  <p class="doc-description"><em>Advanced policy patterns - weighted policies, dynamic registration, async evaluation, caching, and A/B testing</em></p>
  <div class="doc-content">

<h1>Custom Policies</h1>

<strong>Custom policies</strong> extend the basic policy system with advanced patterns like weighted evaluation, priority-based matching, async predicates (database lookups), dynamic registration, caching, and A/B testing.

<p>:::note</p>
<p>For basic policy usage, see <a href="../infrastructure/policies.md">Policy-Based Routing</a>. This guide focuses on <strong>advanced policy extensibility</strong>.</p>
<p>:::</p>

<hr>

<h2>Why Custom Policy Patterns?</h2>

<strong>Built-in PolicyEngine uses first-match evaluation</strong>, but some scenarios benefit from custom patterns:

<p>| Scenario | Standard PolicyEngine | Custom Pattern |</p>
<p>|----------|----------------------|----------------|</p>
<p>| <strong>First-Match Evaluation</strong> | ✅ Perfect fit | No customization needed |</p>
<p>| <strong>Weighted/Priority Policies</strong> | ❌ No priorities | ✅ Weighted policy engine |</p>
<p>| <strong>Async Predicates</strong> | ❌ Sync only | ✅ Async policy engine |</p>
<p>| <strong>Policy Caching</strong> | ❌ Evaluate every time | ✅ Cached policy results |</p>
<p>| <strong>Dynamic Registration</strong> | ❌ Static at startup | ✅ Runtime policy updates |</p>
<p>| <strong>A/B Testing</strong> | ❌ No traffic splitting | ✅ Percentage-based routing |</p>

<strong>When to customize</strong>:
<ul><li>✅ Complex policy priority/weighting</li>
<li>✅ Async predicates (database, API calls)</li>
<li>✅ Dynamic policy updates (feature flags)</li>
<li>✅ High-frequency evaluation (caching needed)</li>
<li>✅ A/B testing / canary deployments</li>
</ul>
<hr>

<h2>Weighted Policy Engine</h2>

<h3>Pattern 1: Priority-Based Evaluation</h3>

<strong>Use Case</strong>: Policies have explicit priorities instead of first-match.

<pre><code class="language-csharp">using Whizbang.Core.Policies;

<p>public class WeightedPolicyEngine : IPolicyEngine {</p>
<p>  private readonly List<WeightedPolicy> _policies = [];</p>
<p>  private readonly ILogger<WeightedPolicyEngine> _logger;</p>

<p>  public WeightedPolicyEngine(ILogger<WeightedPolicyEngine> logger) {</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public void AddPolicy(</p>
<p>    string name,</p>
<p>    Func<PolicyContext, bool> predicate,</p>
<p>    Action<PolicyConfiguration> configure,</p>
<p>    int priority = 0  // ← Custom parameter</p>
<p>  ) {</p>
<p>    _policies.Add(new WeightedPolicy {</p>
<p>      Name = name,</p>
<p>      Predicate = predicate,</p>
<p>      Configure = configure,</p>
<p>      Priority = priority</p>
<p>    });</p>

<p>    // Sort by priority (highest first)</p>
<p>    _policies.Sort((a, b) => b.Priority.CompareTo(a.Priority));</p>

<p>    _logger.LogDebug(</p>
<p>      "Added policy {PolicyName} with priority {Priority}",</p>
<p>      name,</p>
<p>      priority</p>
<p>    );</p>
<p>  }</p>

<p>  // Standard AddPolicy delegates to weighted version</p>
<p>  void IPolicyEngine.AddPolicy(</p>
<p>    string name,</p>
<p>    Func<PolicyContext, bool> predicate,</p>
<p>    Action<PolicyConfiguration> configure</p>
<p>  ) {</p>
<p>    AddPolicy(name, predicate, configure, priority: 0);</p>
<p>  }</p>

<p>  public async Task<PolicyConfiguration?> MatchAsync(PolicyContext context) {</p>
<p>    foreach (var policy in _policies) {  // Ordered by priority</p>
<p>      try {</p>
<p>        if (policy.Predicate(context)) {</p>
<p>          var config = new PolicyConfiguration();</p>
<p>          policy.Configure(config);</p>

<p>          context.Trail.RecordDecision(</p>
<p>            policyName: policy.Name,</p>
<p>            rule: $"Priority: {policy.Priority}",</p>
<p>            matched: true,</p>
<p>            configuration: config,</p>
<p>            reason: $"Matched with priority {policy.Priority}"</p>
<p>          );</p>

<p>          return config;</p>
<p>        }</p>

<p>      } catch (Exception ex) {</p>
<p>        context.Trail.RecordDecision(</p>
<p>          policyName: policy.Name,</p>
<p>          rule: $"Priority: {policy.Priority}",</p>
<p>          matched: false,</p>
<p>          configuration: null,</p>
<p>          reason: $"Evaluation failed: {ex.Message}"</p>
<p>        );</p>
<p>      }</p>
<p>    }</p>

<p>    return null;  // No match</p>
<p>  }</p>

<p>  private class WeightedPolicy {</p>
<p>    public required string Name { get; init; }</p>
<p>    public required Func<PolicyContext, bool> Predicate { get; init; }</p>
<p>    public required Action<PolicyConfiguration> Configure { get; init; }</p>
<p>    public int Priority { get; init; }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">var engine = new WeightedPolicyEngine(logger);

<p>// High-priority tenant routing (priority 100)</p>
<p>engine.AddPolicy(</p>
<p>  name: "PremiumTenantRouting",</p>
<p>  predicate: ctx => ctx.GetMetadata("tier")?.ToString() == "premium",</p>
<p>  configure: config => config.PublishToServiceBus("premium-events"),</p>
<p>  priority: 100  // ← Evaluated first</p>
<p>);</p>

<p>// Medium-priority standard routing (priority 50)</p>
<p>engine.AddPolicy(</p>
<p>  name: "StandardRouting",</p>
<p>  predicate: ctx => true,</p>
<p>  configure: config => config.PublishToServiceBus("standard-events"),</p>
<p>  priority: 50</p>
<p>);</p>

<p>// Evaluation: PremiumTenantRouting checked first (higher priority)</p>
<p></code></pre></p>

<hr>

<h2>Async Policy Engine</h2>

<h3>Pattern 2: Async Predicate Evaluation</h3>

<strong>Use Case</strong>: Predicates need database lookups, API calls, feature flags.

<pre><code class="language-csharp">using Whizbang.Core.Policies;

<p>public class AsyncPolicyEngine : IPolicyEngine {</p>
<p>  private readonly List<AsyncPolicy> _policies = [];</p>
<p>  private readonly ILogger<AsyncPolicyEngine> _logger;</p>

<p>  public AsyncPolicyEngine(ILogger<AsyncPolicyEngine> logger) {</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  /// <summary></p>
<p>  /// Add async policy with async predicate.</p>
<p>  /// </summary></p>
<p>  public void AddAsyncPolicy(</p>
<p>    string name,</p>
<p>    Func<PolicyContext, CancellationToken, Task<bool>> asyncPredicate,</p>
<p>    Action<PolicyConfiguration> configure</p>
<p>  ) {</p>
<p>    _policies.Add(new AsyncPolicy {</p>
<p>      Name = name,</p>
<p>      AsyncPredicate = asyncPredicate,</p>
<p>      Configure = configure</p>
<p>    });</p>
<p>  }</p>

<p>  // Standard AddPolicy wraps sync predicate in async</p>
<p>  void IPolicyEngine.AddPolicy(</p>
<p>    string name,</p>
<p>    Func<PolicyContext, bool> predicate,</p>
<p>    Action<PolicyConfiguration> configure</p>
<p>  ) {</p>
<p>    AddAsyncPolicy(</p>
<p>      name,</p>
<p>      asyncPredicate: (ctx, ct) => Task.FromResult(predicate(ctx)),</p>
<p>      configure</p>
<p>    );</p>
<p>  }</p>

<p>  public async Task<PolicyConfiguration?> MatchAsync(</p>
<p>    PolicyContext context,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    foreach (var policy in _policies) {</p>
<p>      try {</p>
<p>        if (await policy.AsyncPredicate(context, ct)) {</p>
<p>          var config = new PolicyConfiguration();</p>
<p>          policy.Configure(config);</p>

<p>          context.Trail.RecordDecision(</p>
<p>            policyName: policy.Name,</p>
<p>            rule: "Async evaluation",</p>
<p>            matched: true,</p>
<p>            configuration: config,</p>
<p>            reason: "Async predicate matched"</p>
<p>          );</p>

<p>          return config;</p>
<p>        }</p>

<p>      } catch (Exception ex) {</p>
<p>        context.Trail.RecordDecision(</p>
<p>          policyName: policy.Name,</p>
<p>          rule: "Async evaluation",</p>
<p>          matched: false,</p>
<p>          configuration: null,</p>
<p>          reason: $"Async evaluation failed: {ex.Message}"</p>
<p>        );</p>
<p>      }</p>
<p>    }</p>

<p>    return null;</p>
<p>  }</p>

<p>  // Overload standard MatchAsync</p>
<p>  Task<PolicyConfiguration?> IPolicyEngine.MatchAsync(PolicyContext context) =></p>
<p>    MatchAsync(context, CancellationToken.None);</p>

<p>  private class AsyncPolicy {</p>
<p>    public required string Name { get; init; }</p>
<p>    public required Func<PolicyContext, CancellationToken, Task<bool>> AsyncPredicate { get; init; }</p>
<p>    public required Action<PolicyConfiguration> Configure { get; init; }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">var engine = new AsyncPolicyEngine(logger);

<p>// Async predicate: lookup feature flag from database</p>
<p>engine.AddAsyncPolicy(</p>
<p>  name: "FeatureFlagRouting",</p>
<p>  asyncPredicate: async (ctx, ct) => {</p>
<p>    var featureService = ctx.GetService<IFeatureFlagService>();</p>
<p>    return await featureService.IsEnabledAsync("new-routing", ct);</p>
<p>  },</p>
<p>  configure: config => config.PublishToServiceBus("new-events")</p>
<p>);</p>

<p>// Async predicate: lookup tenant configuration</p>
<p>engine.AddAsyncPolicy(</p>
<p>  name: "TenantConfigRouting",</p>
<p>  asyncPredicate: async (ctx, ct) => {</p>
<p>    var tenantId = ctx.GetMetadata("tenantId")?.ToString();</p>
<p>    if (tenantId is null) return false;</p>

<p>    var tenantService = ctx.GetService<ITenantService>();</p>
<p>    var tenant = await tenantService.GetTenantAsync(tenantId, ct);</p>

<p>    return tenant?.IsActive == true;</p>
<p>  },</p>
<p>  configure: config => config.PublishToServiceBus("active-tenant-events")</p>
<p>);</p>
<p></code></pre></p>

<hr>

<h2>Cached Policy Engine</h2>

<h3>Pattern 3: Policy Result Caching</h3>

<strong>Use Case</strong>: Reduce policy evaluation overhead for high-frequency messages.

<pre><code class="language-csharp">using Whizbang.Core.Policies;
<p>using Microsoft.Extensions.Caching.Memory;</p>

<p>public class CachedPolicyEngine : IPolicyEngine {</p>
<p>  private readonly IPolicyEngine _innerEngine;</p>
<p>  private readonly IMemoryCache _cache;</p>
<p>  private readonly ILogger<CachedPolicyEngine> _logger;</p>

<p>  private static readonly MemoryCacheEntryOptions CacheOptions = new() {</p>
<p>    AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5),</p>
<p>    SlidingExpiration = TimeSpan.FromMinutes(1)</p>
<p>  };</p>

<p>  public CachedPolicyEngine(</p>
<p>    IPolicyEngine innerEngine,</p>
<p>    IMemoryCache cache,</p>
<p>    ILogger<CachedPolicyEngine> logger</p>
<p>  ) {</p>
<p>    _innerEngine = innerEngine;</p>
<p>    _cache = cache;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  void IPolicyEngine.AddPolicy(</p>
<p>    string name,</p>
<p>    Func<PolicyContext, bool> predicate,</p>
<p>    Action<PolicyConfiguration> configure</p>
<p>  ) {</p>
<p>    _innerEngine.AddPolicy(name, predicate, configure);</p>
<p>  }</p>

<p>  public async Task<PolicyConfiguration?> MatchAsync(PolicyContext context) {</p>
<p>    // Generate cache key from context</p>
<p>    var cacheKey = GenerateCacheKey(context);</p>

<p>    // Try cache first</p>
<p>    if (_cache.TryGetValue(cacheKey, out PolicyConfiguration? cached)) {</p>
<p>      _logger.LogDebug(</p>
<p>        "Policy cache hit for key {CacheKey}",</p>
<p>        cacheKey</p>
<p>      );</p>
<p>      return cached;</p>
<p>    }</p>

<p>    // Cache miss - evaluate policies</p>
<p>    _logger.LogDebug(</p>
<p>      "Policy cache miss for key {CacheKey}, evaluating policies",</p>
<p>      cacheKey</p>
<p>    );</p>

<p>    var config = await _innerEngine.MatchAsync(context);</p>

<p>    // Cache result (including null)</p>
<p>    _cache.Set(cacheKey, config, CacheOptions);</p>

<p>    return config;</p>
<p>  }</p>

<p>  private static string GenerateCacheKey(PolicyContext context) {</p>
<p>    // Cache key based on message type + metadata</p>
<p>    var tenantId = context.GetMetadata("tenantId")?.ToString() ?? "default";</p>
<p>    var environment = context.Environment;</p>
<p>    var messageType = context.MessageType.Name;</p>

<p>    return $"policy:{messageType}:{tenantId}:{environment}";</p>
<p>  }</p>

<p>  /// <summary></p>
<p>  /// Clear policy cache (e.g., after policy updates).</p>
<p>  /// </summary></p>
<p>  public void ClearCache() {</p>
<p>    if (_cache is MemoryCache memoryCache) {</p>
<p>      memoryCache.Compact(1.0);  // Remove 100% of entries</p>
<p>      _logger.LogInformation("Policy cache cleared");</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">var baseEngine = new PolicyEngine();
<p>var cachedEngine = new CachedPolicyEngine(baseEngine, memoryCache, logger);</p>

<p>// Add policies to base engine</p>
<p>baseEngine.AddPolicy(...);</p>

<p>// Use cached engine - first call evaluates, subsequent calls use cache</p>
<p>var config1 = await cachedEngine.MatchAsync(context);  // Cache miss - evaluate</p>
<p>var config2 = await cachedEngine.MatchAsync(context);  // Cache hit - instant</p>

<p>// Clear cache after policy updates</p>
<p>cachedEngine.ClearCache();</p>
<p></code></pre></p>

<strong>Performance</strong>:
<ul><li><strong>Cache Hit</strong>: ~1µs (memory lookup)</li>
<li><strong>Cache Miss</strong>: ~100µs (full evaluation)</li>
<li><strong>Improvement</strong>: ~100x for cached scenarios</li>
</ul>
<hr>

<h2>Dynamic Policy Registration</h2>

<h3>Pattern 4: Runtime Policy Updates</h3>

<strong>Use Case</strong>: Add/remove policies at runtime based on feature flags, tenant config.

<pre><code class="language-csharp">using Whizbang.Core.Policies;

<p>public class DynamicPolicyEngine : IPolicyEngine {</p>
<p>  private readonly List<Policy> _policies = [];</p>
<p>  private readonly ReaderWriterLockSlim _lock = new();</p>
<p>  private readonly ILogger<DynamicPolicyEngine> _logger;</p>

<p>  public DynamicPolicyEngine(ILogger<DynamicPolicyEngine> logger) {</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  void IPolicyEngine.AddPolicy(</p>
<p>    string name,</p>
<p>    Func<PolicyContext, bool> predicate,</p>
<p>    Action<PolicyConfiguration> configure</p>
<p>  ) {</p>
<p>    _lock.EnterWriteLock();</p>
<p>    try {</p>
<p>      _policies.Add(new Policy {</p>
<p>        Name = name,</p>
<p>        Predicate = predicate,</p>
<p>        Configure = configure</p>
<p>      });</p>

<p>      _logger.LogInformation("Added policy {PolicyName}", name);</p>
<p>    } finally {</p>
<p>      _lock.ExitWriteLock();</p>
<p>    }</p>
<p>  }</p>

<p>  /// <summary></p>
<p>  /// Remove policy by name (custom method).</p>
<p>  /// </summary></p>
<p>  public bool RemovePolicy(string name) {</p>
<p>    _lock.EnterWriteLock();</p>
<p>    try {</p>
<p>      var removed = _policies.RemoveAll(p => p.Name == name);</p>

<p>      if (removed > 0) {</p>
<p>        _logger.LogInformation("Removed policy {PolicyName}", name);</p>
<p>        return true;</p>
<p>      }</p>

<p>      return false;</p>
<p>    } finally {</p>
<p>      _lock.ExitWriteLock();</p>
<p>    }</p>
<p>  }</p>

<p>  public async Task<PolicyConfiguration?> MatchAsync(PolicyContext context) {</p>
<p>    _lock.EnterReadLock();</p>
<p>    try {</p>
<p>      foreach (var policy in _policies) {</p>
<p>        try {</p>
<p>          if (policy.Predicate(context)) {</p>
<p>            var config = new PolicyConfiguration();</p>
<p>            policy.Configure(config);</p>
<p>            return config;</p>
<p>          }</p>
<p>        } catch (Exception ex) {</p>
<p>          _logger.LogWarning(</p>
<p>            ex,</p>
<p>            "Policy {PolicyName} evaluation failed",</p>
<p>            policy.Name</p>
<p>          );</p>
<p>        }</p>
<p>      }</p>

<p>      return null;</p>
<p>    } finally {</p>
<p>      _lock.ExitReadLock();</p>
<p>    }</p>
<p>  }</p>

<p>  private class Policy {</p>
<p>    public required string Name { get; init; }</p>
<p>    public required Func<PolicyContext, bool> Predicate { get; init; }</p>
<p>    public required Action<PolicyConfiguration> Configure { get; init; }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">var engine = new DynamicPolicyEngine(logger);

<p>// Add initial policies</p>
<p>engine.AddPolicy("DefaultRouting", ctx => true, config => config.PublishToServiceBus("default"));</p>

<p>// Runtime: Add tenant-specific policy when tenant onboards</p>
<p>await OnTenantOnboardedAsync(tenantId: "tenant-a");</p>

<p>public async Task OnTenantOnboardedAsync(string tenantId) {</p>
<p>  engine.AddPolicy(</p>
<p>    name: $"Tenant{tenantId}Routing",</p>
<p>    predicate: ctx => ctx.GetMetadata("tenantId")?.ToString() == tenantId,</p>
<p>    configure: config => config.PublishToServiceBus($"{tenantId}-events")</p>
<p>  );</p>
<p>}</p>

<p>// Runtime: Remove policy when tenant offboards</p>
<p>await OnTenantOffboardedAsync(tenantId: "tenant-a");</p>

<p>public async Task OnTenantOffboardedAsync(string tenantId) {</p>
<p>  engine.RemovePolicy($"Tenant{tenantId}Routing");</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>A/B Testing Policy Engine</h2>

<h3>Pattern 5: Percentage-Based Traffic Splitting</h3>

<strong>Use Case</strong>: Route X% of traffic to new feature for canary/gradual rollout.

<pre><code class="language-csharp">using Whizbang.Core.Policies;

<p>public class ABTestingPolicyEngine : IPolicyEngine {</p>
<p>  private readonly IPolicyEngine _innerEngine;</p>
<p>  private readonly ILogger<ABTestingPolicyEngine> _logger;</p>
<p>  private readonly Dictionary<string, ABTestConfig> _abTests = [];</p>

<p>  public ABTestingPolicyEngine(</p>
<p>    IPolicyEngine innerEngine,</p>
<p>    ILogger<ABTestingPolicyEngine> logger</p>
<p>  ) {</p>
<p>    _innerEngine = innerEngine;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  /// <summary></p>
<p>  /// Configure A/B test: route percentage of traffic to variant.</p>
<p>  /// </summary></p>
<p>  public void ConfigureABTest(</p>
<p>    string testName,</p>
<p>    double percentageToVariant,  // 0.0 - 100.0</p>
<p>    Action<PolicyConfiguration> variantConfig,</p>
<p>    Action<PolicyConfiguration> controlConfig</p>
<p>  ) {</p>
<p>    _abTests[testName] = new ABTestConfig {</p>
<p>      TestName = testName,</p>
<p>      PercentageToVariant = percentageToVariant,</p>
<p>      VariantConfig = variantConfig,</p>
<p>      ControlConfig = controlConfig</p>
<p>    };</p>

<p>    _logger.LogInformation(</p>
<p>      "Configured A/B test {TestName}: {Percentage}% to variant",</p>
<p>      testName,</p>
<p>      percentageToVariant</p>
<p>    );</p>
<p>  }</p>

<p>  void IPolicyEngine.AddPolicy(</p>
<p>    string name,</p>
<p>    Func<PolicyContext, bool> predicate,</p>
<p>    Action<PolicyConfiguration> configure</p>
<p>  ) {</p>
<p>    _innerEngine.AddPolicy(name, predicate, configure);</p>
<p>  }</p>

<p>  public async Task<PolicyConfiguration?> MatchAsync(PolicyContext context) {</p>
<p>    // Check if message participates in A/B test</p>
<p>    var testName = context.GetMetadata("abTestName")?.ToString();</p>

<p>    if (testName != null && _abTests.TryGetValue(testName, out var abTest)) {</p>
<p>      // Determine variant via consistent hashing (same message → same variant)</p>
<p>      var messageId = context.Envelope?.MessageId.Value.ToString() ?? Guid.NewGuid().ToString();</p>
<p>      var hash = Math.Abs(messageId.GetHashCode());</p>
<p>      var percentage = (hash % 100);  // 0-99</p>

<p>      bool isVariant = percentage < abTest.PercentageToVariant;</p>

<p>      var config = new PolicyConfiguration();</p>
<p>      if (isVariant) {</p>
<p>        abTest.VariantConfig(config);</p>
<p>        _logger.LogDebug(</p>
<p>          "A/B test {TestName}: Routed to VARIANT (hash {Hash}%)",</p>
<p>          testName,</p>
<p>          percentage</p>
<p>        );</p>
<p>      } else {</p>
<p>        abTest.ControlConfig(config);</p>
<p>        _logger.LogDebug(</p>
<p>          "A/B test {TestName}: Routed to CONTROL (hash {Hash}%)",</p>
<p>          testName,</p>
<p>          percentage</p>
<p>        );</p>
<p>      }</p>

<p>      return config;</p>
<p>    }</p>

<p>    // No A/B test - use standard policy evaluation</p>
<p>    return await _innerEngine.MatchAsync(context);</p>
<p>  }</p>

<p>  private class ABTestConfig {</p>
<p>    public required string TestName { get; init; }</p>
<p>    public double PercentageToVariant { get; init; }</p>
<p>    public required Action<PolicyConfiguration> VariantConfig { get; init; }</p>
<p>    public required Action<PolicyConfiguration> ControlConfig { get; init; }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">var baseEngine = new PolicyEngine();
<p>var abEngine = new ABTestingPolicyEngine(baseEngine, logger);</p>

<p>// Configure A/B test: 10% to new routing, 90% to old routing</p>
<p>abEngine.ConfigureABTest(</p>
<p>  testName: "new-routing-experiment",</p>
<p>  percentageToVariant: 10.0,</p>
<p>  variantConfig: config => config.PublishToServiceBus("new-events"),  // 10%</p>
<p>  controlConfig: config => config.PublishToServiceBus("old-events")   // 90%</p>
<p>);</p>

<p>// Messages with abTestName metadata participate in A/B test</p>
<p>var context = PolicyContextPool.Rent(</p>
<p>  message: message,</p>
<p>  envelope: envelope,</p>
<p>  services: services,</p>
<p>  environment: "production"</p>
<p>);</p>

<p>// Add A/B test metadata</p>
<p>context.Envelope.Metadata["abTestName"] = "new-routing-experiment";</p>

<p>// Evaluation: 10% → new-events, 90% → old-events (consistent per message ID)</p>
<p>var config = await abEngine.MatchAsync(context);</p>
<p></code></pre></p>

<hr>

<h2>Testing Custom Policies</h2>

<h3>Testing Weighted Policies</h3>

<pre><code class="language-csharp">public class WeightedPolicyEngineTests {
<p>  [Test]</p>
<p>  public async Task MatchAsync_HighPriorityMatchesFirst_SkipsLowerPriorityAsync() {</p>
<p>    // Arrange</p>
<p>    var logger = new NullLogger<WeightedPolicyEngine>();</p>
<p>    var engine = new WeightedPolicyEngine(logger);</p>

<p>    engine.AddPolicy(</p>
<p>      name: "LowPriority",</p>
<p>      predicate: ctx => true,  // Would match</p>
<p>      configure: config => config.PublishToServiceBus("low"),</p>
<p>      priority: 10</p>
<p>    );</p>

<p>    engine.AddPolicy(</p>
<p>      name: "HighPriority",</p>
<p>      predicate: ctx => true,  // Matches first</p>
<p>      configure: config => config.PublishToServiceBus("high"),</p>
<p>      priority: 100</p>
<p>    );</p>

<p>    var context = new PolicyContext(new TestMessage(), null, null, "test");</p>

<p>    // Act</p>
<p>    var result = await engine.MatchAsync(context);</p>

<p>    // Assert - HighPriority matched (higher priority)</p>
<p>    await Assert.That(result).IsNotNull();</p>
<p>    await Assert.That(result!.PublishTargets[0].Destination).IsEqualTo("high");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Testing Async Policies</h3>

<pre><code class="language-csharp">public class AsyncPolicyEngineTests {
<p>  [Test]</p>
<p>  public async Task MatchAsync_AsyncPredicate_CallsDatabaseAsync() {</p>
<p>    // Arrange</p>
<p>    var logger = new NullLogger<AsyncPolicyEngine>();</p>
<p>    var engine = new AsyncPolicyEngine(logger);</p>

<p>    var dbCallCount = 0;</p>

<p>    engine.AddAsyncPolicy(</p>
<p>      name: "DatabasePolicy",</p>
<p>      asyncPredicate: async (ctx, ct) => {</p>
<p>        dbCallCount++;  // Track async call</p>
<p>        await Task.Delay(10, ct);  // Simulate database</p>
<p>        return true;</p>
<p>      },</p>
<p>      configure: config => config.PublishToServiceBus("test")</p>
<p>    );</p>

<p>    var context = new PolicyContext(new TestMessage(), null, null, "test");</p>

<p>    // Act</p>
<p>    var result = await engine.MatchAsync(context);</p>

<p>    // Assert - Async predicate executed</p>
<p>    await Assert.That(result).IsNotNull();</p>
<p>    await Assert.That(dbCallCount).IsEqualTo(1);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Testing Cached Policies</h3>

<pre><code class="language-csharp">public class CachedPolicyEngineTests {
<p>  [Test]</p>
<p>  public async Task MatchAsync_SecondCall_UsesCacheAsync() {</p>
<p>    // Arrange</p>
<p>    var baseEngine = new PolicyEngine();</p>
<p>    var memoryCache = new MemoryCache(new MemoryCacheOptions());</p>
<p>    var logger = new NullLogger<CachedPolicyEngine>();</p>
<p>    var cachedEngine = new CachedPolicyEngine(baseEngine, memoryCache, logger);</p>

<p>    var evaluationCount = 0;</p>

<p>    baseEngine.AddPolicy(</p>
<p>      name: "TestPolicy",</p>
<p>      predicate: ctx => {</p>
<p>        evaluationCount++;  // Track evaluations</p>
<p>        return true;</p>
<p>      },</p>
<p>      configure: config => config.PublishToServiceBus("test")</p>
<p>    );</p>

<p>    var context = new PolicyContext(new TestMessage(), null, null, "test");</p>

<p>    // Act - First call (cache miss)</p>
<p>    var result1 = await cachedEngine.MatchAsync(context);</p>

<p>    // Act - Second call (cache hit)</p>
<p>    var result2 = await cachedEngine.MatchAsync(context);</p>

<p>    // Assert - Only evaluated once (cached)</p>
<p>    await Assert.That(result1).IsNotNull();</p>
<p>    await Assert.That(result2).IsNotNull();</p>
<p>    await Assert.That(evaluationCount).IsEqualTo(1);  // Not 2!</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Wrap base PolicyEngine</strong> for compatibility</li>
<li>✅ <strong>Use thread-safe collections</strong> for dynamic policies</li>
<li>✅ <strong>Cache policy results</strong> for high-frequency scenarios</li>
<li>✅ <strong>Log policy decisions</strong> via PolicyDecisionTrail</li>
<li>✅ <strong>Test async predicates</strong> with real dependencies</li>
<li>✅ <strong>Clear cache after updates</strong> (dynamic policies)</li>
<li>✅ <strong>Use consistent hashing</strong> for A/B tests</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Block async operations in predicates</li>
<li>❌ Throw exceptions from predicates (caught and logged)</li>
<li>❌ Cache results with tenant-specific data (isolation issue)</li>
<li>❌ Skip thread safety for dynamic policies</li>
<li>❌ Use reflection in predicates (breaks AOT)</li>
<li>❌ Forget to invalidate cache after policy changes</li>
</ul>
<hr>

<h2>Further Reading</h2>

<strong>Infrastructure</strong>:
<ul><li><a href="../infrastructure/policies.md">Policy-Based Routing</a> - Basic policy usage</li>
<li><a href="../infrastructure/pooling.md">Object Pooling</a> - PolicyContext pooling</li>
</ul>
<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/message-context.md">Message Context</a> - Envelope metadata</li>
</ul>
<strong>Advanced</strong>:
<ul><li><a href="../advanced/multi-tenancy.md">Multi-Tenancy</a> - Tenant isolation patterns</li>
<li><a href="../advanced/performance-tuning.md">Performance Tuning</a> - Optimization strategies</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-extensibility-custom-receptors" class="doc-section">
  <h3>Custom Receptors</h3>
  <p class="doc-path"><code>v1.0.0/extensibility/custom-receptors</code></p>
  <p class="doc-description"><em>Advanced receptor customization patterns - streaming, lifecycle hooks, base classes, and performance optimization</em></p>
  <div class="doc-content">

<h1>Custom Receptors</h1>

<strong>Custom receptors</strong> extend the basic <code>IReceptor<TMessage, TResponse></code> pattern with advanced capabilities like streaming, lifecycle management, custom base classes, and specialized execution patterns.

<p>:::note</p>
<p>For basic receptor usage, see <a href="../core-concepts/receptors.md">Receptors Guide</a>. This guide focuses on <strong>advanced customization patterns</strong> for specialized scenarios.</p>
<p>:::</p>

<hr>

<h2>Why Custom Receptor Patterns?</h2>

<strong>Built-in <code>IReceptor<T, TResponse></code> handles most cases</strong>, but some scenarios benefit from custom patterns:

<p>| Scenario | Standard Receptor | Custom Pattern |</p>
<p>|----------|------------------|----------------|</p>
<p>| <strong>Request/Response</strong> | ✅ Perfect fit | No customization needed |</p>
<p>| <strong>Streaming Results</strong> | ❌ Returns single response | ✅ IAsyncEnumerable streaming |</p>
<p>| <strong>Shared Logic</strong> | ❌ Copy-paste across receptors | ✅ Custom base class |</p>
<p>| <strong>Resource Lifecycle</strong> | ❌ Manual setup/teardown | ✅ Lifecycle hooks |</p>
<p>| <strong>Complex Validation</strong> | ❌ Repetitive code | ✅ Base class validation |</p>
<p>| <strong>Multi-Tenancy</strong> | ❌ Manual tenant resolution | ✅ Base class with tenant context |</p>
<p>| <strong>Performance Critical</strong> | ❌ Defensive allocations | ✅ Zero-allocation patterns |</p>

<strong>When to customize</strong>:
<ul><li>✅ Shared behavior across many receptors</li>
<li>✅ Streaming/pagination scenarios</li>
<li>✅ Complex lifecycle management</li>
<li>✅ Domain-specific validation</li>
<li>✅ Multi-tenant applications</li>
</ul>
<strong>When NOT to customize</strong>:
<ul><li>❌ One-off requirements (use standard receptor)</li>
<li>❌ Simple request/response (over-engineering)</li>
<li>❌ Adding state (receptors must be stateless)</li>
</ul>
<hr>

<h2>Architecture</h2>

<h3>Receptor Execution Pipeline</h3>

<pre><code class="language-">┌────────────────────────────────────────────────────────┐
<p>│  Dispatcher.InvokeAsync<TMessage, TResponse>()         │</p>
<p>└────────────────────┬───────────────────────────────────┘</p>
<p>                     │</p>
<p>                     ↓</p>
<p>           ┌─────────────────────┐</p>
<p>           │  Resolve Receptor   │ ← DI Container</p>
<p>           │  IReceptor<T, R>    │</p>
<p>           └──────────┬──────────┘</p>
<p>                      │</p>
<p>                      ↓</p>
<p>         ┌────────────────────────┐</p>
<p>         │  Pipeline Behaviors    │ ← IPipelineBehavior<T, R></p>
<p>         │  (Logging, Validation) │</p>
<p>         └──────────┬─────────────┘</p>
<p>                    │</p>
<p>                    ↓</p>
<p>    ┌───────────────────────────────────┐</p>
<p>    │  receptor.HandleAsync(message)    │ ← Your Custom Receptor</p>
<p>    │                                   │</p>
<p>    │  Lifecycle:                       │</p>
<p>    │  1. Constructor (DI)              │</p>
<p>    │  2. HandleAsync (business logic)  │</p>
<p>    │  3. Dispose (if IAsyncDisposable) │</p>
<p>    └───────────────┬───────────────────┘</p>
<p>                    │</p>
<p>                    ↓</p>
<p>           ┌────────────────┐</p>
<p>           │  Return TResponse │</p>
<p>           └────────────────┘</p>
<p></code></pre></p>

<h3>Custom Receptor Base Class Pattern</h3>

<pre><code class="language-">┌────────────────────────────────────────────────┐
<p>│  ReceptorBase<TMessage, TResponse>             │</p>
<p>│                                                │</p>
<p>│  + Constructor(IServiceProvider)               │</p>
<p>│  + abstract ValidateAsync(message)             │</p>
<p>│  + abstract ExecuteAsync(message)              │</p>
<p>│  + LogInformation(message)                     │</p>
<p>│  + GetService<T>()                             │</p>
<p>│  + HandleAsync(message) [sealed]               │</p>
<p>│    ├─ ValidateAsync(message)                   │</p>
<p>│    ├─ ExecuteAsync(message)                    │</p>
<p>│    └─ Log result                               │</p>
<p>└────────────────────────────────────────────────┘</p>
<p>                    ▲</p>
<p>                    │ Inherits</p>
<p>                    │</p>
<p>    ┌───────────────┴──────────────┐</p>
<p>    │  CreateOrderReceptor          │</p>
<p>    │                               │</p>
<p>    │  + ValidateAsync(message)     │ ← Override</p>
<p>    │  + ExecuteAsync(message)      │ ← Override</p>
<p>    └───────────────────────────────┘</p>
<p></code></pre></p>

<hr>

<h2>Custom Base Classes</h2>

<h3>Pattern 1: Base Class with Shared Logic</h3>

<strong>Use Case</strong>: Multiple receptors sharing common validation, logging, or setup logic.

<pre><code class="language-csharp">using Whizbang.Core;

<p>/// <summary></p>
<p>/// Base class for receptors with shared validation and logging.</p>
<p>/// </summary></p>
<p>public abstract class ReceptorBase<TMessage, TResponse> : IReceptor<TMessage, TResponse> {</p>
<p>  protected readonly ILogger<ReceptorBase<TMessage, TResponse>> Logger;</p>
<p>  protected readonly IServiceProvider Services;</p>

<p>  protected ReceptorBase(</p>
<p>    ILogger<ReceptorBase<TMessage, TResponse>> logger,</p>
<p>    IServiceProvider services</p>
<p>  ) {</p>
<p>    Logger = logger;</p>
<p>    Services = services;</p>
<p>  }</p>

<p>  /// <summary></p>
<p>  /// Template method pattern: validates, executes, logs.</p>
<p>  /// </summary></p>
<p>  public async ValueTask<TResponse> HandleAsync(</p>
<p>    TMessage message,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    Logger.LogInformation(</p>
<p>      "Handling {MessageType}",</p>
<p>      typeof(TMessage).Name</p>
<p>    );</p>

<p>    // 1. Validate (can be overridden)</p>
<p>    await ValidateAsync(message, ct);</p>

<p>    // 2. Execute business logic (must be implemented)</p>
<p>    var response = await ExecuteAsync(message, ct);</p>

<p>    // 3. Log result</p>
<p>    Logger.LogInformation(</p>
<p>      "Handled {MessageType} successfully",</p>
<p>      typeof(TMessage).Name</p>
<p>    );</p>

<p>    return response;</p>
<p>  }</p>

<p>  /// <summary></p>
<p>  /// Override to add message-specific validation.</p>
<p>  /// Default: no validation.</p>
<p>  /// </summary></p>
<p>  protected virtual ValueTask ValidateAsync(</p>
<p>    TMessage message,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    return ValueTask.CompletedTask;</p>
<p>  }</p>

<p>  /// <summary></p>
<p>  /// Implement business logic here.</p>
<p>  /// </summary></p>
<p>  protected abstract ValueTask<TResponse> ExecuteAsync(</p>
<p>    TMessage message,</p>
<p>    CancellationToken ct</p>
<p>  );</p>

<p>  /// <summary></p>
<p>  /// Helper: Resolve service from DI container.</p>
<p>  /// </summary></p>
<p>  protected T GetService<T>() where T : notnull {</p>
<p>    return Services.GetRequiredService<T>();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">public record CreateOrder(Guid CustomerId, OrderLineItem[] Items);
<p>public record OrderCreated(Guid OrderId, Guid CustomerId, decimal Total);</p>

<p>public class CreateOrderReceptor : ReceptorBase<CreateOrder, OrderCreated> {</p>
<p>  private readonly IDbConnectionFactory _db;</p>

<p>  public CreateOrderReceptor(</p>
<p>    ILogger<ReceptorBase<CreateOrder, OrderCreated>> logger,</p>
<p>    IServiceProvider services,</p>
<p>    IDbConnectionFactory db</p>
<p>  ) : base(logger, services) {</p>
<p>    _db = db;</p>
<p>  }</p>

<p>  // Override: Add validation logic</p>
<p>  protected override ValueTask ValidateAsync(</p>
<p>    CreateOrder message,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    if (message.Items.Length == 0) {</p>
<p>      throw new ValidationException("Order must contain at least one item");</p>
<p>    }</p>

<p>    if (message.Items.Any(i => i.Quantity <= 0)) {</p>
<p>      throw new ValidationException("All items must have quantity > 0");</p>
<p>    }</p>

<p>    return ValueTask.CompletedTask;</p>
<p>  }</p>

<p>  // Implement: Business logic</p>
<p>  protected override async ValueTask<OrderCreated> ExecuteAsync(</p>
<p>    CreateOrder message,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    var orderId = Guid.CreateVersion7();</p>
<p>    var total = message.Items.Sum(i => i.Quantity * i.UnitPrice);</p>

<p>    await using var conn = _db.CreateConnection();</p>
<p>    await conn.ExecuteAsync(</p>
<p>      "INSERT INTO orders (order_id, customer_id, total) VALUES (@OrderId, @CustomerId, @Total)",</p>
<p>      new { OrderId = orderId, message.CustomerId, Total = total },</p>
<p>      ct</p>
<p>    );</p>

<p>    return new OrderCreated(orderId, message.CustomerId, total);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li><strong>DRY</strong>: Shared validation, logging, setup logic</li>
<li><strong>Template Method Pattern</strong>: Enforces consistent execution flow</li>
<li><strong>Easy Testing</strong>: Test base class once, focus on business logic in subclasses</li>
</ul>
<hr>

<h3>Pattern 2: Transactional Receptor Base</h3>

<strong>Use Case</strong>: Automatically wrap HandleAsync in a database transaction.

<pre><code class="language-csharp">using Whizbang.Core;
<p>using System.Data;</p>

<p>public abstract class TransactionalReceptor<TMessage, TResponse> : IReceptor<TMessage, TResponse> {</p>
<p>  private readonly IDbConnectionFactory _db;</p>
<p>  protected readonly ILogger Logger;</p>

<p>  protected TransactionalReceptor(</p>
<p>    IDbConnectionFactory db,</p>
<p>    ILogger logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    Logger = logger;</p>
<p>  }</p>

<p>  public async ValueTask<TResponse> HandleAsync(</p>
<p>    TMessage message,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    await using var conn = _db.CreateConnection();</p>
<p>    await conn.OpenAsync(ct);</p>

<p>    await using var tx = await conn.BeginTransactionAsync(</p>
<p>      IsolationLevel.ReadCommitted,</p>
<p>      ct</p>
<p>    );</p>

<p>    try {</p>
<p>      // Execute business logic within transaction</p>
<p>      var response = await ExecuteAsync(message, conn, tx, ct);</p>

<p>      // Commit on success</p>
<p>      await tx.CommitAsync(ct);</p>

<p>      Logger.LogInformation(</p>
<p>        "Transaction committed for {MessageType}",</p>
<p>        typeof(TMessage).Name</p>
<p>      );</p>

<p>      return response;</p>

<p>    } catch {</p>
<p>      // Rollback on failure</p>
<p>      await tx.RollbackAsync(ct);</p>

<p>      Logger.LogWarning(</p>
<p>        "Transaction rolled back for {MessageType}",</p>
<p>        typeof(TMessage).Name</p>
<p>      );</p>

<p>      throw;</p>
<p>    }</p>
<p>  }</p>

<p>  /// <summary></p>
<p>  /// Execute business logic within transaction.</p>
<p>  /// </summary></p>
<p>  protected abstract ValueTask<TResponse> ExecuteAsync(</p>
<p>    TMessage message,</p>
<p>    IDbConnection connection,</p>
<p>    IDbTransaction transaction,</p>
<p>    CancellationToken ct</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">public record TransferFunds(Guid FromAccountId, Guid ToAccountId, decimal Amount);
<p>public record FundsTransferred(Guid TransactionId, DateTimeOffset CompletedAt);</p>

<p>public class TransferFundsReceptor : TransactionalReceptor<TransferFunds, FundsTransferred> {</p>
<p>  public TransferFundsReceptor(</p>
<p>    IDbConnectionFactory db,</p>
<p>    ILogger<TransferFundsReceptor> logger</p>
<p>  ) : base(db, logger) { }</p>

<p>  protected override async ValueTask<FundsTransferred> ExecuteAsync(</p>
<p>    TransferFunds message,</p>
<p>    IDbConnection conn,</p>
<p>    IDbTransaction tx,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    // Both operations in same transaction</p>
<p>    await conn.ExecuteAsync(</p>
<p>      "UPDATE accounts SET balance = balance - @Amount WHERE account_id = @AccountId",</p>
<p>      new { message.FromAccountId, message.Amount },</p>
<p>      transaction: tx,</p>
<p>      cancellationToken: ct</p>
<p>    );</p>

<p>    await conn.ExecuteAsync(</p>
<p>      "UPDATE accounts SET balance = balance + @Amount WHERE account_id = @AccountId",</p>
<p>      new { message.ToAccountId, message.Amount },</p>
<p>      transaction: tx,</p>
<p>      cancellationToken: ct</p>
<p>    );</p>

<p>    var transactionId = Guid.CreateVersion7();</p>
<p>    return new FundsTransferred(transactionId, DateTimeOffset.UtcNow);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li><strong>Atomic Operations</strong>: All-or-nothing guarantees</li>
<li><strong>Automatic Rollback</strong>: No manual transaction management</li>
<li><strong>Consistent Pattern</strong>: Same transaction handling across receptors</li>
</ul>
<hr>

<h3>Pattern 3: Multi-Tenant Receptor Base</h3>

<strong>Use Case</strong>: Automatically resolve tenant context for all receptors.

<pre><code class="language-csharp">using Whizbang.Core;

<p>public interface ITenantContext {</p>
<p>  Guid TenantId { get; }</p>
<p>  string TenantName { get; }</p>
<p>}</p>

<p>public abstract class TenantReceptor<TMessage, TResponse> : IReceptor<TMessage, TResponse> {</p>
<p>  protected readonly ITenantContext Tenant;</p>
<p>  protected readonly ILogger Logger;</p>

<p>  protected TenantReceptor(</p>
<p>    ITenantContext tenant,</p>
<p>    ILogger logger</p>
<p>  ) {</p>
<p>    Tenant = tenant;</p>
<p>    Logger = logger;</p>
<p>  }</p>

<p>  public async ValueTask<TResponse> HandleAsync(</p>
<p>    TMessage message,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    Logger.LogInformation(</p>
<p>      "Processing {MessageType} for tenant {TenantId}",</p>
<p>      typeof(TMessage).Name,</p>
<p>      Tenant.TenantId</p>
<p>    );</p>

<p>    // Validate tenant access</p>
<p>    await ValidateTenantAccessAsync(message, ct);</p>

<p>    // Execute with tenant context</p>
<p>    var response = await ExecuteAsync(message, ct);</p>

<p>    return response;</p>
<p>  }</p>

<p>  /// <summary></p>
<p>  /// Override to validate tenant-specific access rules.</p>
<p>  /// Default: allows all access.</p>
<p>  /// </summary></p>
<p>  protected virtual ValueTask ValidateTenantAccessAsync(</p>
<p>    TMessage message,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    return ValueTask.CompletedTask;</p>
<p>  }</p>

<p>  /// <summary></p>
<p>  /// Execute business logic with tenant context.</p>
<p>  /// </summary></p>
<p>  protected abstract ValueTask<TResponse> ExecuteAsync(</p>
<p>    TMessage message,</p>
<p>    CancellationToken ct</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">public record CreateProduct(string Name, decimal Price);
<p>public record ProductCreated(Guid ProductId, Guid TenantId);</p>

<p>public class CreateProductReceptor : TenantReceptor<CreateProduct, ProductCreated> {</p>
<p>  private readonly IDbConnectionFactory _db;</p>

<p>  public CreateProductReceptor(</p>
<p>    ITenantContext tenant,</p>
<p>    ILogger<CreateProductReceptor> logger,</p>
<p>    IDbConnectionFactory db</p>
<p>  ) : base(tenant, logger) {</p>
<p>    _db = db;</p>
<p>  }</p>

<p>  protected override async ValueTask<ProductCreated> ExecuteAsync(</p>
<p>    CreateProduct message,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    var productId = Guid.CreateVersion7();</p>

<p>    await using var conn = _db.CreateConnection();</p>
<p>    await conn.ExecuteAsync(</p>
<p>      "INSERT INTO products (product_id, tenant_id, name, price) VALUES (@ProductId, @TenantId, @Name, @Price)",</p>
<p>      new {</p>
<p>        ProductId = productId,</p>
<p>        TenantId = Tenant.TenantId,  // ← Automatic tenant isolation</p>
<p>        message.Name,</p>
<p>        message.Price</p>
<p>      },</p>
<p>      ct</p>
<p>    );</p>

<p>    return new ProductCreated(productId, Tenant.TenantId);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li><strong>Automatic Tenant Isolation</strong>: No manual tenant filtering</li>
<li><strong>Tenant-Aware Logging</strong>: All logs include tenant context</li>
<li><strong>Security by Default</strong>: Tenant validation enforced</li>
</ul>
<hr>

<h2>Streaming Receptors</h2>

<h3>Pattern 4: IAsyncEnumerable Streaming</h3>

<strong>Use Case</strong>: Stream large result sets without loading everything into memory.

<pre><code class="language-csharp">using Whizbang.Core;

<p>/// <summary></p>
<p>/// Streaming receptor for paginated/large results.</p>
<p>/// </summary></p>
<p>public interface IStreamingReceptor<in TMessage, out TResponse> {</p>
<p>  /// <summary></p>
<p>  /// Streams results as they become available.</p>
<p>  /// </summary></p>
<p>  IAsyncEnumerable<TResponse> StreamAsync(</p>
<p>    TMessage message,</p>
<p>    CancellationToken ct = default</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<strong>Implementation</strong>:
<pre><code class="language-csharp">public record GetOrderHistory(Guid CustomerId);
<p>public record OrderSummary(Guid OrderId, decimal Total, DateTimeOffset CreatedAt);</p>

<p>public class GetOrderHistoryReceptor : IStreamingReceptor<GetOrderHistory, OrderSummary> {</p>
<p>  private readonly IDbConnectionFactory _db;</p>
<p>  private readonly ILogger<GetOrderHistoryReceptor> _logger;</p>

<p>  public GetOrderHistoryReceptor(</p>
<p>    IDbConnectionFactory db,</p>
<p>    ILogger<GetOrderHistoryReceptor> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async IAsyncEnumerable<OrderSummary> StreamAsync(</p>
<p>    GetOrderHistory query,</p>
<p>    [EnumeratorCancellation] CancellationToken ct = default</p>
<p>  ) {</p>
<p>    await using var conn = _db.CreateConnection();</p>

<p>    // Stream results without loading all into memory</p>
<p>    await using var reader = await conn.ExecuteReaderAsync(</p>
<p>      "SELECT order_id, total, created_at FROM orders WHERE customer_id = @CustomerId ORDER BY created_at DESC",</p>
<p>      new { query.CustomerId },</p>
<p>      ct</p>
<p>    );</p>

<p>    while (await reader.ReadAsync(ct)) {</p>
<p>      yield return new OrderSummary(</p>
<p>        OrderId: reader.GetGuid(0),</p>
<p>        Total: reader.GetDecimal(1),</p>
<p>        CreatedAt: reader.GetDateTime(2)</p>
<p>      );</p>
<p>    }</p>

<p>    _logger.LogInformation(</p>
<p>      "Streamed order history for customer {CustomerId}",</p>
<p>      query.CustomerId</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">public class OrderHistoryController : ControllerBase {
<p>  private readonly GetOrderHistoryReceptor _receptor;</p>

<p>  [HttpGet("orders/history/{customerId}")]</p>
<p>  public async IAsyncEnumerable<OrderSummary> GetOrderHistory(</p>
<p>    Guid customerId,</p>
<p>    [EnumeratorCancellation] CancellationToken ct</p>
<p>  ) {</p>
<p>    var query = new GetOrderHistory(customerId);</p>

<p>    await foreach (var order in _receptor.StreamAsync(query, ct)) {</p>
<p>      yield return order;  // Stream to client</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li><strong>Memory Efficient</strong>: No buffering of entire result set</li>
<li><strong>Responsive</strong>: First results arrive immediately</li>
<li><strong>Cancellable</strong>: Stop streaming mid-flight</li>
</ul>
<hr>

<h2>Lifecycle Management</h2>

<h3>Pattern 5: IAsyncDisposable Receptor</h3>

<strong>Use Case</strong>: Receptor manages expensive resources (connections, file handles).

<pre><code class="language-csharp">using Whizbang.Core;

<p>public record ImportCsv(string FilePath);</p>
<p>public record CsvImported(int RowsImported);</p>

<p>public class ImportCsvReceptor : IReceptor<ImportCsv, CsvImported>, IAsyncDisposable {</p>
<p>  private readonly ILogger<ImportCsvReceptor> _logger;</p>
<p>  private FileStream? _fileStream;</p>
<p>  private StreamReader? _reader;</p>

<p>  public ImportCsvReceptor(ILogger<ImportCsvReceptor> logger) {</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async ValueTask<CsvImported> HandleAsync(</p>
<p>    ImportCsv message,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    // Open file</p>
<p>    _fileStream = File.OpenRead(message.FilePath);</p>
<p>    _reader = new StreamReader(_fileStream);</p>

<p>    int rowsImported = 0;</p>

<p>    // Skip header</p>
<p>    await _reader.ReadLineAsync(ct);</p>

<p>    // Process rows</p>
<p>    while (!_reader.EndOfStream) {</p>
<p>      var line = await _reader.ReadLineAsync(ct);</p>
<p>      if (string.IsNullOrWhiteSpace(line)) continue;</p>

<p>      // Process row...</p>
<p>      rowsImported++;</p>
<p>    }</p>

<p>    _logger.LogInformation(</p>
<p>      "Imported {RowCount} rows from {FilePath}",</p>
<p>      rowsImported,</p>
<p>      message.FilePath</p>
<p>    );</p>

<p>    return new CsvImported(rowsImported);</p>
<p>  }</p>

<p>  // Automatic cleanup by dispatcher</p>
<p>  public async ValueTask DisposeAsync() {</p>
<p>    if (_reader is not null) {</p>
<p>      await _reader.DisposeAsync();</p>
<p>    }</p>

<p>    if (_fileStream is not null) {</p>
<p>      await _fileStream.DisposeAsync();</p>
<p>    }</p>

<p>    _logger.LogDebug("Disposed ImportCsvReceptor resources");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Registration</strong>:
<pre><code class="language-csharp">// Transient lifetime ensures new instance per invocation
<p>builder.Services.AddTransient<IReceptor<ImportCsv, CsvImported>, ImportCsvReceptor>();</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li><strong>Automatic Cleanup</strong>: Dispatcher calls DisposeAsync after HandleAsync</li>
<li><strong>Exception Safe</strong>: Resources disposed even if HandleAsync throws</li>
<li><strong>Clear Pattern</strong>: Standard .NET async disposal</li>
</ul>
<hr>

<h2>Performance Optimization</h2>

<h3>Pattern 6: Zero-Allocation Void Receptor</h3>

<strong>Use Case</strong>: High-throughput event processing with no response needed.

<pre><code class="language-csharp">using Whizbang.Core;

<p>public record OrderShipped(Guid OrderId, string TrackingNumber);</p>

<p>/// <summary></p>
<p>/// Zero-allocation receptor for void (no response) operations.</p>
<p>/// </summary></p>
<p>public class OrderShippedReceptor : IReceptor<OrderShipped> {</p>
<p>  private readonly ILogger<OrderShippedReceptor> _logger;</p>

<p>  public OrderShippedReceptor(ILogger<OrderShippedReceptor> logger) {</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public ValueTask HandleAsync(</p>
<p>    OrderShipped message,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    // Synchronous execution - return ValueTask.CompletedTask (zero allocation)</p>
<p>    _logger.LogInformation(</p>
<p>      "Order {OrderId} shipped with tracking {TrackingNumber}",</p>
<p>      message.OrderId,</p>
<p>      message.TrackingNumber</p>
<p>    );</p>

<p>    // If async work needed:</p>
<p>    // return new ValueTask(AsyncWork(message, ct));</p>

<p>    return ValueTask.CompletedTask;  // ← Zero allocation!</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Performance</strong>:
<ul><li><strong>Zero Allocations</strong>: <code>ValueTask.CompletedTask</code> is cached</li>
<li><strong>Synchronous Path</strong>: No async state machine overhead</li>
<li><strong>High Throughput</strong>: Ideal for 100K+ msg/sec scenarios</li>
</ul>
<hr>

<h3>Pattern 7: Pooled Resources</h3>

<strong>Use Case</strong>: Reuse expensive objects across receptor invocations.

<pre><code class="language-csharp">using Whizbang.Core;
<p>using System.Buffers;</p>

<p>public record ProcessLargeFile(string FilePath);</p>
<p>public record FileProcessed(int BytesProcessed);</p>

<p>public class ProcessLargeFileReceptor : IReceptor<ProcessLargeFile, FileProcessed> {</p>
<p>  private readonly ILogger<ProcessLargeFileReceptor> _logger;</p>
<p>  private readonly ArrayPool<byte> _bufferPool;</p>

<p>  public ProcessLargeFileReceptor(ILogger<ProcessLargeFileReceptor> logger) {</p>
<p>    _logger = logger;</p>
<p>    _bufferPool = ArrayPool<byte>.Shared;</p>
<p>  }</p>

<p>  public async ValueTask<FileProcessed> HandleAsync(</p>
<p>    ProcessLargeFile message,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    // Rent buffer from pool (no allocation)</p>
<p>    byte[] buffer = _bufferPool.Rent(8192);</p>

<p>    try {</p>
<p>      await using var fileStream = File.OpenRead(message.FilePath);</p>
<p>      int totalBytesRead = 0;</p>

<p>      int bytesRead;</p>
<p>      while ((bytesRead = await fileStream.ReadAsync(buffer, ct)) > 0) {</p>
<p>        // Process buffer...</p>
<p>        totalBytesRead += bytesRead;</p>
<p>      }</p>

<p>      _logger.LogInformation(</p>
<p>        "Processed {Bytes} bytes from {FilePath}",</p>
<p>        totalBytesRead,</p>
<p>        message.FilePath</p>
<p>      );</p>

<p>      return new FileProcessed(totalBytesRead);</p>

<p>    } finally {</p>
<p>      // Return buffer to pool</p>
<p>      _bufferPool.Return(buffer);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li><strong>Reduced GC Pressure</strong>: No repeated allocations</li>
<li><strong>Better Performance</strong>: ~10x faster than repeated allocations</li>
<li><strong>Industry Standard</strong>: <code>ArrayPool<T></code> used throughout .NET</li>
</ul>
<hr>

<h2>Advanced Patterns</h2>

<h3>Pattern 8: Resilient Receptor (Retry + Circuit Breaker)</h3>

<strong>Use Case</strong>: Automatically retry transient failures.

<pre><code class="language-csharp">using Whizbang.Core;
<p>using Polly;</p>
<p>using Polly.CircuitBreaker;</p>

<p>public abstract class ResilientReceptor<TMessage, TResponse> : IReceptor<TMessage, TResponse> {</p>
<p>  protected readonly ILogger Logger;</p>
<p>  private readonly ResiliencePipeline _pipeline;</p>

<p>  protected ResilientReceptor(ILogger logger) {</p>
<p>    Logger = logger;</p>

<p>    // Configure retry + circuit breaker</p>
<p>    _pipeline = new ResiliencePipelineBuilder()</p>
<p>      .AddRetry(new RetryStrategyOptions {</p>
<p>        MaxRetryAttempts = 3,</p>
<p>        Delay = TimeSpan.FromSeconds(1),</p>
<p>        BackoffType = DelayBackoffType.Exponential,</p>
<p>        OnRetry = args => {</p>
<p>          Logger.LogWarning(</p>
<p>            "Retry attempt {Attempt} for {MessageType}",</p>
<p>            args.AttemptNumber,</p>
<p>            typeof(TMessage).Name</p>
<p>          );</p>
<p>          return ValueTask.CompletedTask;</p>
<p>        }</p>
<p>      })</p>
<p>      .AddCircuitBreaker(new CircuitBreakerStrategyOptions {</p>
<p>        FailureRatio = 0.5,</p>
<p>        MinimumThroughput = 10,</p>
<p>        SamplingDuration = TimeSpan.FromSeconds(30),</p>
<p>        BreakDuration = TimeSpan.FromSeconds(60),</p>
<p>        OnOpened = args => {</p>
<p>          Logger.LogError("Circuit breaker opened for {MessageType}", typeof(TMessage).Name);</p>
<p>          return ValueTask.CompletedTask;</p>
<p>        }</p>
<p>      })</p>
<p>      .Build();</p>
<p>  }</p>

<p>  public async ValueTask<TResponse> HandleAsync(</p>
<p>    TMessage message,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    // Execute with resilience pipeline</p>
<p>    return await _pipeline.ExecuteAsync(</p>
<p>      async ct => await ExecuteAsync(message, ct),</p>
<p>      ct</p>
<p>    );</p>
<p>  }</p>

<p>  /// <summary></p>
<p>  /// Implement business logic here - retries/circuit breaker applied automatically.</p>
<p>  /// </summary></p>
<p>  protected abstract ValueTask<TResponse> ExecuteAsync(</p>
<p>    TMessage message,</p>
<p>    CancellationToken ct</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">public record CallExternalApi(string Endpoint);
<p>public record ApiResponse(string Data);</p>

<p>public class CallExternalApiReceptor : ResilientReceptor<CallExternalApi, ApiResponse> {</p>
<p>  private readonly HttpClient _http;</p>

<p>  public CallExternalApiReceptor(</p>
<p>    ILogger<CallExternalApiReceptor> logger,</p>
<p>    HttpClient http</p>
<p>  ) : base(logger) {</p>
<p>    _http = http;</p>
<p>  }</p>

<p>  protected override async ValueTask<ApiResponse> ExecuteAsync(</p>
<p>    CallExternalApi message,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    // Automatically retried on transient failures</p>
<p>    var response = await _http.GetStringAsync(message.Endpoint, ct);</p>
<p>    return new ApiResponse(response);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Use base classes for shared logic</strong> across multiple receptors</li>
<li>✅ <strong>Implement IAsyncDisposable</strong> for resource cleanup</li>
<li>✅ <strong>Use IAsyncEnumerable</strong> for streaming large result sets</li>
<li>✅ <strong>Pool expensive resources</strong> (buffers, connections)</li>
<li>✅ <strong>Return ValueTask.CompletedTask</strong> for synchronous void receptors</li>
<li>✅ <strong>Add resilience patterns</strong> (retry, circuit breaker) for external calls</li>
<li>✅ <strong>Test base classes independently</strong> from concrete implementations</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Add instance state (except injected dependencies)</li>
<li>❌ Use singleton lifetime for receptors with scoped dependencies</li>
<li>❌ Create deep inheritance hierarchies (max 2 levels)</li>
<li>❌ Mix business logic with framework concerns (use pipeline behaviors)</li>
<li>❌ Block async operations with <code>.Result</code> or <code>.Wait()</code></li>
<li>❌ Forget to pass CancellationToken through call chain</li>
</ul>
<hr>

<h2>Testing Custom Receptors</h2>

<h3>Testing Base Classes</h3>

<pre><code class="language-csharp">public class ReceptorBaseTests {
<p>  [Test]</p>
<p>  public async Task HandleAsync_CallsValidateAndExecuteAsync() {</p>
<p>    // Arrange</p>
<p>    var logger = new NullLogger<ReceptorBase<TestMessage, TestResponse>>();</p>
<p>    var services = new ServiceCollection().BuildServiceProvider();</p>

<p>    var receptor = new TestReceptor(logger, services);</p>
<p>    var message = new TestMessage();</p>

<p>    // Act</p>
<p>    var response = await receptor.HandleAsync(message);</p>

<p>    // Assert</p>
<p>    await Assert.That(receptor.ValidateCalled).IsTrue();</p>
<p>    await Assert.That(receptor.ExecuteCalled).IsTrue();</p>
<p>    await Assert.That(response).IsNotNull();</p>
<p>  }</p>
<p>}</p>

<p>// Test receptor exposing internal state for testing</p>
<p>internal class TestReceptor : ReceptorBase<TestMessage, TestResponse> {</p>
<p>  public bool ValidateCalled { get; private set; }</p>
<p>  public bool ExecuteCalled { get; private set; }</p>

<p>  public TestReceptor(</p>
<p>    ILogger<ReceptorBase<TestMessage, TestResponse>> logger,</p>
<p>    IServiceProvider services</p>
<p>  ) : base(logger, services) { }</p>

<p>  protected override ValueTask ValidateAsync(TestMessage message, CancellationToken ct) {</p>
<p>    ValidateCalled = true;</p>
<p>    return ValueTask.CompletedTask;</p>
<p>  }</p>

<p>  protected override ValueTask<TestResponse> ExecuteAsync(TestMessage message, CancellationToken ct) {</p>
<p>    ExecuteCalled = true;</p>
<p>    return ValueTask.FromResult(new TestResponse());</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Testing Streaming Receptors</h3>

<pre><code class="language-csharp">public class StreamingReceptorTests {
<p>  [Test]</p>
<p>  public async Task StreamAsync_YieldsAllResultsAsync() {</p>
<p>    // Arrange</p>
<p>    var db = CreateMockDb();  // Returns 3 test orders</p>
<p>    var logger = new NullLogger<GetOrderHistoryReceptor>();</p>
<p>    var receptor = new GetOrderHistoryReceptor(db, logger);</p>

<p>    var query = new GetOrderHistory(CustomerId: Guid.NewGuid());</p>

<p>    // Act</p>
<p>    var results = new List<OrderSummary>();</p>
<p>    await foreach (var item in receptor.StreamAsync(query)) {</p>
<p>      results.Add(item);</p>
<p>    }</p>

<p>    // Assert</p>
<p>    await Assert.That(results).HasCount().EqualTo(3);</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task StreamAsync_SupportsEarlyCancellationAsync() {</p>
<p>    // Arrange</p>
<p>    var db = CreateMockDb();  // Returns 100 orders</p>
<p>    var logger = new NullLogger<GetOrderHistoryReceptor>();</p>
<p>    var receptor = new GetOrderHistoryReceptor(db, logger);</p>

<p>    var query = new GetOrderHistory(CustomerId: Guid.NewGuid());</p>
<p>    var cts = new CancellationTokenSource();</p>

<p>    // Act - cancel after first item</p>
<p>    var count = 0;</p>
<p>    await foreach (var item in receptor.StreamAsync(query, cts.Token)) {</p>
<p>      count++;</p>
<p>      if (count == 1) {</p>
<p>        cts.Cancel();</p>
<p>      }</p>
<p>    }</p>

<p>    // Assert - only 1 item processed</p>
<p>    await Assert.That(count).IsEqualTo(1);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/receptors.md">Receptors Guide</a> - Basic receptor usage</li>
<li><a href="../core-concepts/dispatcher.md">Dispatcher</a> - Invoking receptors</li>
<li><a href="hooks-and-middleware.md">Pipeline Behaviors</a> - Cross-cutting concerns</li>
</ul>
<strong>Extensibility</strong>:
<ul><li><a href="custom-perspectives.md">Custom Perspectives</a> - Custom event listeners</li>
<li><a href="custom-transports.md">Custom Transports</a> - Custom messaging implementations</li>
</ul>
<strong>Advanced</strong>:
<ul><li><a href="../advanced/performance-tuning.md">Performance Tuning</a> - Optimization strategies</li>
<li><a href="../advanced/testing-receptors.md">Testing Receptors</a> - Comprehensive testing guide</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-extensibility-custom-serializers" class="doc-section">
  <h3>Custom Serializers</h3>
  <p class="doc-path"><code>v1.0.0/extensibility/custom-serializers</code></p>
  <p class="doc-description"><em>Implement custom serializers for Protobuf, MessagePack, or custom binary formats - AOT-compatible patterns</em></p>
  <div class="doc-content">

<h1>Custom Serializers</h1>

<strong>Custom serializers</strong> enable alternative message formats beyond JSON. Implement Protobuf, MessagePack, Avro, or custom binary formats while maintaining AOT compatibility.

<p>:::note</p>
<p>Whizbang uses JSON by default with <code>JsonContextRegistry</code> for AOT support. Custom serializers are for specialized scenarios requiring different formats.</p>
<p>:::</p>

<hr>

<h2>Why Custom Serializers?</h2>

<p>| Scenario | JSON (Default) | Custom Serializer |</p>
<p>|----------|---------------|-------------------|</p>
<p>| <strong>Human-Readable</strong> | ✅ Perfect | No need |</p>
<p>| <strong>Compact Binary</strong> | ❌ Text overhead | ✅ Protobuf/MessagePack |</p>
<p>| <strong>Schema Evolution</strong> | ❌ Manual | ✅ Protobuf/Avro |</p>
<p>| <strong>Cross-Language</strong> | ✅ Universal | ✅ Protobuf |</p>
<p>| <strong>Performance</strong> | ✅ Fast enough | ✅ MessagePack faster |</p>

<strong>When to use custom serializers</strong>:
<ul><li>✅ Extreme performance requirements</li>
<li>✅ Bandwidth constraints (IoT, mobile)</li>
<li>✅ Schema evolution needs</li>
<li>✅ Cross-language interop (gRPC)</li>
</ul>
<hr>

<h2>Protobuf Serializer</h2>

<h3>Pattern 1: Protobuf with AOT</h3>

<pre><code class="language-csharp">using Google.Protobuf;
<p>using System.Text.Json;</p>

<p>public class ProtobufSerializer : IMessageSerializer {</p>
<p>  public byte[] Serialize<T>(T message) where T : IMessage<T> {</p>
<p>    return message.ToByteArray();  // AOT-safe</p>
<p>  }</p>

<p>  public T Deserialize<T>(byte[] data) where T : IMessage<T>, new() {</p>
<p>    var parser = new MessageParser<T>(() => new T());</p>
<p>    return parser.ParseFrom(data);  // AOT-safe</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">// Define protobuf message
<p>message OrderCreated {</p>
<p>  string order_id = 1;</p>
<p>  string customer_id = 2;</p>
<p>  double total = 3;</p>
<p>}</p>

<p>// Serialize</p>
<p>var serializer = new ProtobufSerializer();</p>
<p>var @event = new OrderCreated {</p>
<p>  OrderId = orderId.ToString(),</p>
<p>  CustomerId = customerId.ToString(),</p>
<p>  Total = 99.99</p>
<p>};</p>

<p>var bytes = serializer.Serialize(@event);</p>

<p>// Deserialize</p>
<p>var deserialized = serializer.Deserialize<OrderCreated>(bytes);</p>
<p></code></pre></p>

<hr>

<h2>MessagePack Serializer</h2>

<h3>Pattern 2: MessagePack with AOT</h3>

<pre><code class="language-csharp">using MessagePack;

<p>[MessagePackObject]</p>
<p>public record OrderCreated {</p>
<p>  [Key(0)] public Guid OrderId { get; init; }</p>
<p>  [Key(1)] public Guid CustomerId { get; init; }</p>
<p>  [Key(2)] public decimal Total { get; init; }</p>
<p>}</p>

<p>public class MessagePackSerializer : IMessageSerializer {</p>
<p>  private readonly MessagePackSerializerOptions _options;</p>

<p>  public MessagePackSerializer() {</p>
<p>    _options = MessagePackSerializerOptions.Standard</p>
<p>      .WithResolver(MessagePack.Resolvers.ContractlessStandardResolver.Instance);</p>
<p>  }</p>

<p>  public byte[] Serialize<T>(T message) {</p>
<p>    return MessagePackSerializer.Serialize(message, _options);</p>
<p>  }</p>

<p>  public T Deserialize<T>(byte[] data) {</p>
<p>    return MessagePackSerializer.Deserialize<T>(data, _options);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Source Generators</strong>:
<ul><li><a href="../source-generators/json-contexts.md">JSON Contexts</a> - AOT-compatible JSON</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-extensibility-custom-storage" class="doc-section">
  <h3>Custom Storage</h3>
  <p class="doc-path"><code>v1.0.0/extensibility/custom-storage</code></p>
  <p class="doc-description"><em>Implement custom storage backends - Redis, MongoDB, Elasticsearch, Cassandra, or custom databases</em></p>
  <div class="doc-content">

<h1>Custom Storage</h1>

<strong>Custom storage backends</strong> enable alternative data stores beyond PostgreSQL. Implement Redis, MongoDB, Elasticsearch, Cassandra, or custom databases for perspective read models.

<p>:::note</p>
<p>Whizbang uses PostgreSQL by default. Custom storage is for specialized scenarios requiring different persistence strategies.</p>
<p>:::</p>

<hr>

<h2>Why Custom Storage?</h2>

<p>| Backend | Use Case | Benefits |</p>
<p>|---------|----------|----------|</p>
<p>| <strong>PostgreSQL</strong> (default) | Relational data | ACID, SQL queries |</p>
<p>| <strong>Redis</strong> | High-speed cache | In-memory, fast reads |</p>
<p>| <strong>MongoDB</strong> | Document store | Schema flexibility |</p>
<p>| <strong>Elasticsearch</strong> | Search/analytics | Full-text search |</p>
<p>| <strong>Cassandra</strong> | Time-series | Horizontal scaling |</p>

<strong>When to use custom storage</strong>:
<ul><li>✅ Specialized query patterns</li>
<li>✅ Extreme performance needs</li>
<li>✅ Existing infrastructure</li>
<li>✅ Multi-region replication</li>
</ul>
<hr>

<h2>IPerspectiveStore<TModel></h2>

<pre><code class="language-csharp">public interface IPerspectiveStore<TModel> where TModel : class {
<p>  Task UpsertAsync(</p>
<p>    string id,</p>
<p>    TModel model,</p>
<p>    CancellationToken ct = default</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>MongoDB Implementation</h2>

<h3>Pattern 1: MongoDB Perspective Store</h3>

<pre><code class="language-csharp">using MongoDB.Driver;

<p>public class MongoPerspectiveStore<TModel> : IPerspectiveStore<TModel></p>
<p>  where TModel : class {</p>

<p>  private readonly IMongoCollection<TModel> _collection;</p>

<p>  public MongoPerspectiveStore(IMongoDatabase database, string collectionName) {</p>
<p>    _collection = database.GetCollection<TModel>(collectionName);</p>
<p>  }</p>

<p>  public async Task UpsertAsync(</p>
<p>    string id,</p>
<p>    TModel model,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var filter = Builders<TModel>.Filter.Eq("_id", id);</p>
<p>    await _collection.ReplaceOneAsync(</p>
<p>      filter,</p>
<p>      model,</p>
<p>      new ReplaceOptions { IsUpsert = true },</p>
<p>      ct</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Elasticsearch Implementation</h2>

<h3>Pattern 2: Elasticsearch Perspective Store</h3>

<pre><code class="language-csharp">using Elastic.Clients.Elasticsearch;

<p>public class ElasticsearchPerspectiveStore<TModel> : IPerspectiveStore<TModel></p>
<p>  where TModel : class {</p>

<p>  private readonly ElasticsearchClient _client;</p>
<p>  private readonly string _indexName;</p>

<p>  public ElasticsearchPerspectiveStore(</p>
<p>    ElasticsearchClient client,</p>
<p>    string indexName</p>
<p>  ) {</p>
<p>    _client = client;</p>
<p>    _indexName = indexName;</p>
<p>  }</p>

<p>  public async Task UpsertAsync(</p>
<p>    string id,</p>
<p>    TModel model,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    await _client.IndexAsync(</p>
<p>      model,</p>
<p>      idx => idx.Index(_indexName).Id(id),</p>
<p>      ct</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Data Access</strong>:
<ul><li><a href="../data-access/perspectives-storage.md">Perspectives Storage</a> - PostgreSQL schema</li>
</ul>
<strong>Extensibility</strong>:
<ul><li><a href="custom-perspectives.md">Custom Perspectives</a> - Advanced perspective patterns</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-extensibility-custom-transports" class="doc-section">
  <h3>Custom Transports</h3>
  <p class="doc-path"><code>v1.0.0/extensibility/custom-transports</code></p>
  <p class="doc-description"><em>Implement custom transports for HTTP, gRPC, Kafka, RabbitMQ, or any messaging system - AOT-compatible patterns</em></p>
  <div class="doc-content">

<h1>Custom Transports</h1>

<strong>Custom transports</strong> enable Whizbang to work with any messaging system by implementing the <code>ITransport</code> interface. Support HTTP, gRPC, Kafka, RabbitMQ, NATS, or any custom communication protocol.

<p>:::note</p>
<p>For built-in transports, see <a href="../transports/azure-service-bus.md">Azure Service Bus</a> and <a href="../transports/in-memory.md">In-Memory</a>. This guide focuses on <strong>implementing custom transport backends</strong>.</p>
<p>:::</p>

<hr>

<h2>Why Custom Transports?</h2>

<strong>Built-in transports</strong> cover common scenarios, but custom transports enable:

<p>| Scenario | Built-In Transport | Custom Transport |</p>
<p>|----------|-------------------|------------------|</p>
<p>| <strong>Azure Service Bus</strong> | ✅ Built-in | No customization needed |</p>
<p>| <strong>In-Memory (Testing)</strong> | ✅ Built-in | No customization needed |</p>
<p>| <strong>HTTP/REST APIs</strong> | ❌ Not included | ✅ HTTP client transport |</p>
<p>| <strong>gRPC</strong> | ❌ Not included | ✅ gRPC channel transport |</p>
<p>| <strong>Kafka</strong> | ❌ Not included | ✅ Kafka producer/consumer |</p>
<p>| <strong>RabbitMQ</strong> | ❌ Not included | ✅ AMQP channel transport |</p>
<p>| <strong>NATS</strong> | ❌ Not included | ✅ NATS client transport |</p>
<p>| <strong>Redis Pub/Sub</strong> | ❌ Not included | ✅ Redis channel transport |</p>

<strong>When to implement custom transport</strong>:
<ul><li>✅ Existing messaging infrastructure (Kafka, RabbitMQ)</li>
<li>✅ HTTP/gRPC microservices</li>
<li>✅ Legacy systems integration</li>
<li>✅ Custom protocols (IoT, WebSockets)</li>
<li>✅ Multi-cloud deployments</li>
</ul>
<hr>

<h2>Architecture</h2>

<h3>ITransport Interface</h3>

<pre><code class="language-csharp">namespace Whizbang.Core.Transports;

<p>public interface ITransport {</p>
<p>  /// <summary></p>
<p>  /// Whether transport is initialized and ready.</p>
<p>  /// </summary></p>
<p>  bool IsInitialized { get; }</p>

<p>  /// <summary></p>
<p>  /// Initialize transport and verify connectivity.</p>
<p>  /// Idempotent - safe to call multiple times.</p>
<p>  /// </summary></p>
<p>  Task InitializeAsync(CancellationToken ct = default);</p>

<p>  /// <summary></p>
<p>  /// Capabilities this transport supports.</p>
<p>  /// </summary></p>
<p>  TransportCapabilities Capabilities { get; }</p>

<p>  /// <summary></p>
<p>  /// Publish message (fire-and-forget).</p>
<p>  /// </summary></p>
<p>  Task PublishAsync(</p>
<p>    IMessageEnvelope envelope,</p>
<p>    TransportDestination destination,</p>
<p>    CancellationToken ct = default</p>
<p>  );</p>

<p>  /// <summary></p>
<p>  /// Subscribe to messages from destination.</p>
<p>  /// Returns subscription handle for lifecycle management.</p>
<p>  /// </summary></p>
<p>  Task<ISubscription> SubscribeAsync(</p>
<p>    Func<IMessageEnvelope, CancellationToken, Task> handler,</p>
<p>    TransportDestination destination,</p>
<p>    CancellationToken ct = default</p>
<p>  );</p>

<p>  /// <summary></p>
<p>  /// Send request and wait for response (request/response pattern).</p>
<p>  /// Only supported if Capabilities includes RequestResponse.</p>
<p>  /// </summary></p>
<p>  Task<IMessageEnvelope> SendAsync<TRequest, TResponse>(</p>
<p>    IMessageEnvelope requestEnvelope,</p>
<p>    TransportDestination destination,</p>
<p>    CancellationToken ct = default</p>
<p>  ) where TRequest : notnull where TResponse : notnull;</p>
<p>}</p>
<p></code></pre></p>

<h3>Transport Capabilities</h3>

<pre><code class="language-csharp">[Flags]
<p>public enum TransportCapabilities {</p>
<p>  None = 0,</p>
<p>  RequestResponse = 1 << 0,    // Send/Receive (HTTP, gRPC)</p>
<p>  PublishSubscribe = 1 << 1,   // Pub/Sub (Kafka, Service Bus)</p>
<p>  Streaming = 1 << 2,          // IAsyncEnumerable streaming</p>
<p>  Reliable = 1 << 3,           // At-least-once delivery</p>
<p>  Ordered = 1 << 4,            // FIFO ordering</p>
<p>  ExactlyOnce = 1 << 5         // Exactly-once semantics</p>
<p>}</p>
<p></code></pre></p>

<strong>Example Capability Declarations</strong>:

<p>| Transport | Capabilities |</p>
<p>|-----------|-------------|</p>
<p>| <strong>HTTP</strong> | <code>RequestResponse</code> |</p>
<p>| <strong>gRPC</strong> | <code>RequestResponse \| Streaming</code> |</p>
<p>| <strong>Kafka</strong> | <code>PublishSubscribe \| Reliable \| Ordered</code> |</p>
<p>| <strong>RabbitMQ</strong> | <code>PublishSubscribe \| Reliable</code> |</p>
<p>| <strong>In-Memory</strong> | <code>PublishSubscribe \| Reliable \| Ordered \| ExactlyOnce</code> |</p>
<p>| <strong>Azure Service Bus</strong> | <code>PublishSubscribe \| Reliable \| Ordered</code> |</p>

<hr>

<h2>HTTP Transport Implementation</h2>

<h3>Pattern 1: HTTP Client Transport</h3>

<strong>Use Case</strong>: Call remote HTTP APIs using Whizbang message patterns.

<pre><code class="language-csharp">using Whizbang.Core;
<p>using Whizbang.Core.Transports;</p>
<p>using System.Net.Http.Json;</p>
<p>using System.Text.Json;</p>

<p>public class HttpTransport : ITransport {</p>
<p>  private readonly HttpClient _http;</p>
<p>  private readonly JsonSerializerOptions _jsonOptions;</p>
<p>  private readonly ILogger<HttpTransport> _logger;</p>
<p>  private bool _isInitialized;</p>

<p>  public HttpTransport(</p>
<p>    HttpClient http,</p>
<p>    JsonSerializerOptions jsonOptions,</p>
<p>    ILogger<HttpTransport> logger</p>
<p>  ) {</p>
<p>    _http = http;</p>
<p>    _jsonOptions = jsonOptions;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public bool IsInitialized => _isInitialized;</p>

<p>  public TransportCapabilities Capabilities =></p>
<p>    TransportCapabilities.RequestResponse;  // HTTP supports request/response only</p>

<p>  public async Task InitializeAsync(CancellationToken ct = default) {</p>
<p>    // Verify HTTP endpoint is reachable</p>
<p>    try {</p>
<p>      var healthCheck = await _http.GetAsync("/health", ct);</p>
<p>      healthCheck.EnsureSuccessStatusCode();</p>

<p>      _isInitialized = true;</p>
<p>      _logger.LogInformation("HTTP transport initialized successfully");</p>

<p>    } catch (HttpRequestException ex) {</p>
<p>      throw new InvalidOperationException("HTTP transport initialization failed", ex);</p>
<p>    }</p>
<p>  }</p>

<p>  public Task PublishAsync(</p>
<p>    IMessageEnvelope envelope,</p>
<p>    TransportDestination destination,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    throw new NotSupportedException("HTTP transport does not support publish (use SendAsync instead)");</p>
<p>  }</p>

<p>  public Task<ISubscription> SubscribeAsync(</p>
<p>    Func<IMessageEnvelope, CancellationToken, Task> handler,</p>
<p>    TransportDestination destination,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    throw new NotSupportedException("HTTP transport does not support subscribe (use polling or webhooks)");</p>
<p>  }</p>

<p>  public async Task<IMessageEnvelope> SendAsync<TRequest, TResponse>(</p>
<p>    IMessageEnvelope requestEnvelope,</p>
<p>    TransportDestination destination,</p>
<p>    CancellationToken ct = default</p>
<p>  ) where TRequest : notnull where TResponse : notnull {</p>
<p>    // Serialize request envelope</p>
<p>    var envelopeType = requestEnvelope.GetType();</p>
<p>    var typeInfo = _jsonOptions.GetTypeInfo(envelopeType)</p>
<p>      ?? throw new InvalidOperationException($"No JsonTypeInfo for {envelopeType.Name}");</p>

<p>    // POST envelope to remote endpoint</p>
<p>    var response = await _http.PostAsJsonAsync(</p>
<p>      destination.Address,  // e.g., "https://api.example.com/orders/create"</p>
<p>      requestEnvelope,</p>
<p>      typeInfo,</p>
<p>      ct</p>
<p>    );</p>

<p>    response.EnsureSuccessStatusCode();</p>

<p>    // Deserialize response envelope</p>
<p>    var responseEnvelopeType = typeof(MessageEnvelope<TResponse>);</p>
<p>    var responseTypeInfo = _jsonOptions.GetTypeInfo(responseEnvelopeType)</p>
<p>      ?? throw new InvalidOperationException($"No JsonTypeInfo for {responseEnvelopeType.Name}");</p>

<p>    var responseEnvelope = await response.Content.ReadFromJsonAsync(responseTypeInfo, ct)</p>
<p>      as IMessageEnvelope;</p>

<p>    if (responseEnvelope is null) {</p>
<p>      throw new InvalidOperationException("Failed to deserialize response envelope");</p>
<p>    }</p>

<p>    _logger.LogInformation(</p>
<p>      "HTTP request sent to {Address}, received response {MessageId}",</p>
<p>      destination.Address,</p>
<p>      responseEnvelope.MessageId</p>
<p>    );</p>

<p>    return responseEnvelope;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Registration</strong>:
<pre><code class="language-csharp">builder.Services.AddHttpClient<HttpTransport>(client => {
<p>  client.BaseAddress = new Uri("https://api.example.com");</p>
<p>  client.Timeout = TimeSpan.FromSeconds(30);</p>
<p>});</p>

<p>builder.Services.AddSingleton<ITransport, HttpTransport>();</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">var request = MessageEnvelope.Create(
<p>  messageId: MessageId.New(),</p>
<p>  correlationId: CorrelationId.New(),</p>
<p>  causationId: null,</p>
<p>  payload: new CreateOrder(orderId, customerId, items)</p>
<p>);</p>

<p>var destination = new TransportDestination(Address: "/orders/create");</p>

<p>var response = await transport.SendAsync<CreateOrder, OrderCreated>(request, destination);</p>
<p></code></pre></p>

<hr>

<h2>gRPC Transport Implementation</h2>

<h3>Pattern 2: gRPC Channel Transport</h3>

<strong>Use Case</strong>: High-performance RPC with streaming support.

<pre><code class="language-csharp">using Whizbang.Core;
<p>using Whizbang.Core.Transports;</p>
<p>using Grpc.Net.Client;</p>
<p>using System.Text.Json;</p>

<p>public class GrpcTransport : ITransport {</p>
<p>  private readonly GrpcChannel _channel;</p>
<p>  private readonly JsonSerializerOptions _jsonOptions;</p>
<p>  private readonly ILogger<GrpcTransport> _logger;</p>
<p>  private bool _isInitialized;</p>

<p>  public GrpcTransport(</p>
<p>    GrpcChannel channel,</p>
<p>    JsonSerializerOptions jsonOptions,</p>
<p>    ILogger<GrpcTransport> logger</p>
<p>  ) {</p>
<p>    _channel = channel;</p>
<p>    _jsonOptions = jsonOptions;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public bool IsInitialized => _isInitialized;</p>

<p>  public TransportCapabilities Capabilities =></p>
<p>    TransportCapabilities.RequestResponse |</p>
<p>    TransportCapabilities.Streaming;  // gRPC supports both</p>

<p>  public async Task InitializeAsync(CancellationToken ct = default) {</p>
<p>    // Verify gRPC channel is connected</p>
<p>    await _channel.ConnectAsync(ct);</p>

<p>    _isInitialized = true;</p>
<p>    _logger.LogInformation(</p>
<p>      "gRPC transport initialized for {Target}",</p>
<p>      _channel.Target</p>
<p>    );</p>
<p>  }</p>

<p>  public async Task<IMessageEnvelope> SendAsync<TRequest, TResponse>(</p>
<p>    IMessageEnvelope requestEnvelope,</p>
<p>    TransportDestination destination,</p>
<p>    CancellationToken ct = default</p>
<p>  ) where TRequest : notnull where TResponse : notnull {</p>
<p>    // Create gRPC client for service</p>
<p>    var client = CreateClient(destination.Address);  // e.g., "OrderService"</p>

<p>    // Serialize request envelope to protobuf/JSON</p>
<p>    var request = SerializeEnvelope(requestEnvelope);</p>

<p>    // Invoke gRPC method</p>
<p>    var response = await client.ProcessMessageAsync(request, cancellationToken: ct);</p>

<p>    // Deserialize response envelope</p>
<p>    var responseEnvelope = DeserializeEnvelope<TResponse>(response);</p>

<p>    _logger.LogInformation(</p>
<p>      "gRPC request sent to {Service}, method {Method}",</p>
<p>      destination.Address,</p>
<p>      destination.RoutingKey</p>
<p>    );</p>

<p>    return responseEnvelope;</p>
<p>  }</p>

<p>  // Simplified for example - actual implementation depends on protobuf schema</p>
<p>  private dynamic CreateClient(string serviceName) {</p>
<p>    // Use reflection or code generation to create gRPC client</p>
<p>    // e.g., var client = new OrderService.OrderServiceClient(_channel);</p>
<p>    throw new NotImplementedException("gRPC client creation");</p>
<p>  }</p>

<p>  private object SerializeEnvelope(IMessageEnvelope envelope) {</p>
<p>    // Convert MessageEnvelope to protobuf message</p>
<p>    throw new NotImplementedException("Protobuf serialization");</p>
<p>  }</p>

<p>  private IMessageEnvelope DeserializeEnvelope<T>(object response) {</p>
<p>    // Convert protobuf message to MessageEnvelope<T></p>
<p>    throw new NotImplementedException("Protobuf deserialization");</p>
<p>  }</p>

<p>  public Task PublishAsync(</p>
<p>    IMessageEnvelope envelope,</p>
<p>    TransportDestination destination,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    throw new NotSupportedException("gRPC transport is request/response only (use streaming for pub/sub)");</p>
<p>  }</p>

<p>  public Task<ISubscription> SubscribeAsync(</p>
<p>    Func<IMessageEnvelope, CancellationToken, Task> handler,</p>
<p>    TransportDestination destination,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    // For streaming gRPC, implement server-side streaming subscription</p>
<p>    throw new NotImplementedException("gRPC streaming subscription");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Kafka Transport Implementation</h2>

<h3>Pattern 3: Kafka Producer/Consumer Transport</h3>

<strong>Use Case</strong>: High-throughput event streaming with ordering and persistence.

<pre><code class="language-csharp">using Whizbang.Core;
<p>using Whizbang.Core.Transports;</p>
<p>using Confluent.Kafka;</p>
<p>using System.Text.Json;</p>

<p>public class KafkaTransport : ITransport {</p>
<p>  private readonly IProducer<string, string> _producer;</p>
<p>  private readonly ConsumerConfig _consumerConfig;</p>
<p>  private readonly JsonSerializerOptions _jsonOptions;</p>
<p>  private readonly ILogger<KafkaTransport> _logger;</p>
<p>  private bool _isInitialized;</p>

<p>  public KafkaTransport(</p>
<p>    ProducerConfig producerConfig,</p>
<p>    ConsumerConfig consumerConfig,</p>
<p>    JsonSerializerOptions jsonOptions,</p>
<p>    ILogger<KafkaTransport> logger</p>
<p>  ) {</p>
<p>    _producer = new ProducerBuilder<string, string>(producerConfig).Build();</p>
<p>    _consumerConfig = consumerConfig;</p>
<p>    _jsonOptions = jsonOptions;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public bool IsInitialized => _isInitialized;</p>

<p>  public TransportCapabilities Capabilities =></p>
<p>    TransportCapabilities.PublishSubscribe |</p>
<p>    TransportCapabilities.Reliable |</p>
<p>    TransportCapabilities.Ordered;  // Kafka guarantees within partitions</p>

<p>  public async Task InitializeAsync(CancellationToken ct = default) {</p>
<p>    // Verify Kafka cluster is reachable</p>
<p>    try {</p>
<p>      // Produce a test message to verify connectivity</p>
<p>      var metadata = _producer.GetMetadata(TimeSpan.FromSeconds(5));</p>

<p>      _isInitialized = true;</p>
<p>      _logger.LogInformation(</p>
<p>        "Kafka transport initialized, connected to {BrokerCount} brokers",</p>
<p>        metadata.Brokers.Count</p>
<p>      );</p>

<p>    } catch (KafkaException ex) {</p>
<p>      throw new InvalidOperationException("Kafka transport initialization failed", ex);</p>
<p>    }</p>
<p>  }</p>

<p>  public async Task PublishAsync(</p>
<p>    IMessageEnvelope envelope,</p>
<p>    TransportDestination destination,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    // Serialize envelope to JSON</p>
<p>    var envelopeType = envelope.GetType();</p>
<p>    var typeInfo = _jsonOptions.GetTypeInfo(envelopeType)</p>
<p>      ?? throw new InvalidOperationException($"No JsonTypeInfo for {envelopeType.Name}");</p>

<p>    var json = JsonSerializer.Serialize(envelope, typeInfo);</p>

<p>    // Create Kafka message</p>
<p>    var message = new Message<string, string> {</p>
<p>      Key = envelope.StreamKey ?? envelope.MessageId.Value.ToString(),  // Partition by stream</p>
<p>      Value = json,</p>
<p>      Headers = new Headers {</p>
<p>        { "MessageId", System.Text.Encoding.UTF8.GetBytes(envelope.MessageId.Value.ToString()) },</p>
<p>        { "CorrelationId", System.Text.Encoding.UTF8.GetBytes(envelope.CorrelationId.Value.ToString()) },</p>
<p>        { "EnvelopeType", System.Text.Encoding.UTF8.GetBytes(envelopeType.AssemblyQualifiedName!) }</p>
<p>      }</p>
<p>    };</p>

<p>    // Publish to topic</p>
<p>    var result = await _producer.ProduceAsync(</p>
<p>      destination.Address,  // Kafka topic name</p>
<p>      message,</p>
<p>      ct</p>
<p>    );</p>

<p>    _logger.LogInformation(</p>
<p>      "Published message {MessageId} to Kafka topic {Topic}, partition {Partition}, offset {Offset}",</p>
<p>      envelope.MessageId,</p>
<p>      destination.Address,</p>
<p>      result.Partition.Value,</p>
<p>      result.Offset.Value</p>
<p>    );</p>
<p>  }</p>

<p>  public async Task<ISubscription> SubscribeAsync(</p>
<p>    Func<IMessageEnvelope, CancellationToken, Task> handler,</p>
<p>    TransportDestination destination,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    // Create Kafka consumer</p>
<p>    var consumer = new ConsumerBuilder<string, string>(_consumerConfig).Build();</p>

<p>    // Subscribe to topic</p>
<p>    consumer.Subscribe(destination.Address);  // Kafka topic name</p>

<p>    _logger.LogInformation(</p>
<p>      "Subscribed to Kafka topic {Topic}, consumer group {ConsumerGroup}",</p>
<p>      destination.Address,</p>
<p>      _consumerConfig.GroupId</p>
<p>    );</p>

<p>    // Background task to consume messages</p>
<p>    var consumeTask = Task.Run(async () => {</p>
<p>      try {</p>
<p>        while (!ct.IsCancellationRequested) {</p>
<p>          var consumeResult = consumer.Consume(ct);</p>

<p>          if (consumeResult?.Message != null) {</p>
<p>            try {</p>
<p>              // Deserialize envelope</p>
<p>              var envelopeTypeName = System.Text.Encoding.UTF8.GetString(</p>
<p>                consumeResult.Message.Headers.GetLastBytes("EnvelopeType")</p>
<p>              );</p>
<p>              var envelopeType = Type.GetType(envelopeTypeName)</p>
<p>                ?? throw new InvalidOperationException($"Unknown envelope type: {envelopeTypeName}");</p>

<p>              var typeInfo = _jsonOptions.GetTypeInfo(envelopeType)</p>
<p>                ?? throw new InvalidOperationException($"No JsonTypeInfo for {envelopeType.Name}");</p>

<p>              var envelope = JsonSerializer.Deserialize(</p>
<p>                consumeResult.Message.Value,</p>
<p>                typeInfo</p>
<p>              ) as IMessageEnvelope</p>
<p>                ?? throw new InvalidOperationException("Failed to deserialize envelope");</p>

<p>              // Invoke handler</p>
<p>              await handler(envelope, ct);</p>

<p>              // Commit offset after successful processing</p>
<p>              consumer.Commit(consumeResult);</p>

<p>              _logger.LogDebug(</p>
<p>                "Processed Kafka message from topic {Topic}, partition {Partition}, offset {Offset}",</p>
<p>                consumeResult.Topic,</p>
<p>                consumeResult.Partition.Value,</p>
<p>                consumeResult.Offset.Value</p>
<p>              );</p>

<p>            } catch (Exception ex) {</p>
<p>              _logger.LogError(</p>
<p>                ex,</p>
<p>                "Error processing Kafka message from topic {Topic}, partition {Partition}, offset {Offset}",</p>
<p>                consumeResult.Topic,</p>
<p>                consumeResult.Partition.Value,</p>
<p>                consumeResult.Offset.Value</p>
<p>              );</p>

<p>              // Don't commit - message will be retried</p>
<p>            }</p>
<p>          }</p>
<p>        }</p>
<p>      } catch (OperationCanceledException) {</p>
<p>        // Expected on shutdown</p>
<p>      } finally {</p>
<p>        consumer.Close();</p>
<p>      }</p>
<p>    }, ct);</p>

<p>    return new KafkaSubscription(consumer, consumeTask);</p>
<p>  }</p>

<p>  public Task<IMessageEnvelope> SendAsync<TRequest, TResponse>(</p>
<p>    IMessageEnvelope requestEnvelope,</p>
<p>    TransportDestination destination,</p>
<p>    CancellationToken ct = default</p>
<p>  ) where TRequest : notnull where TResponse : notnull {</p>
<p>    throw new NotSupportedException("Kafka transport does not support request/response (use pub/sub instead)");</p>
<p>  }</p>
<p>}</p>

<p>/// <summary></p>
<p>/// Subscription handle for Kafka consumer.</p>
<p>/// </summary></p>
<p>internal class KafkaSubscription : ISubscription {</p>
<p>  private readonly IConsumer<string, string> _consumer;</p>
<p>  private readonly Task _consumeTask;</p>

<p>  public KafkaSubscription(IConsumer<string, string> consumer, Task consumeTask) {</p>
<p>    _consumer = consumer;</p>
<p>    _consumeTask = consumeTask;</p>
<p>  }</p>

<p>  public async ValueTask DisposeAsync() {</p>
<p>    // Stop consuming</p>
<p>    _consumer.Close();</p>

<p>    // Wait for consume task to complete</p>
<p>    try {</p>
<p>      await _consumeTask.WaitAsync(TimeSpan.FromSeconds(10));</p>
<p>    } catch (TimeoutException) {</p>
<p>      // Consume task didn't complete in time</p>
<p>    }</p>

<p>    _consumer.Dispose();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Registration</strong>:
<pre><code class="language-csharp">var producerConfig = new ProducerConfig {
<p>  BootstrapServers = "localhost:9092",</p>
<p>  Acks = Acks.All,  // Wait for all replicas</p>
<p>  EnableIdempotence = true  // Exactly-once producer</p>
<p>};</p>

<p>var consumerConfig = new ConsumerConfig {</p>
<p>  BootstrapServers = "localhost:9092",</p>
<p>  GroupId = "whizbang-consumer-group",</p>
<p>  AutoOffsetReset = AutoOffsetReset.Earliest,</p>
<p>  EnableAutoCommit = false  // Manual commit after processing</p>
<p>};</p>

<p>builder.Services.AddSingleton<ITransport>(sp =></p>
<p>  new KafkaTransport(</p>
<p>    producerConfig,</p>
<p>    consumerConfig,</p>
<p>    sp.GetRequiredService<JsonSerializerOptions>(),</p>
<p>    sp.GetRequiredService<ILogger<KafkaTransport>>()</p>
<p>  )</p>
<p>);</p>
<p></code></pre></p>

<hr>

<h2>Advanced Patterns</h2>

<h3>Pattern 4: Transport with Health Checks</h3>

<pre><code class="language-csharp">using Whizbang.Core.Transports;
<p>using Microsoft.Extensions.Diagnostics.HealthChecks;</p>

<p>public class KafkaTransportHealthCheck : IHealthCheck {</p>
<p>  private readonly KafkaTransport _transport;</p>

<p>  public KafkaTransportHealthCheck(ITransport transport) {</p>
<p>    _transport = (KafkaTransport)transport;</p>
<p>  }</p>

<p>  public async Task<HealthCheckResult> CheckHealthAsync(</p>
<p>    HealthCheckContext context,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    if (!_transport.IsInitialized) {</p>
<p>      return HealthCheckResult.Unhealthy("Kafka transport not initialized");</p>
<p>    }</p>

<p>    try {</p>
<p>      // Verify producer is healthy</p>
<p>      var metadata = _transport.GetMetadata(TimeSpan.FromSeconds(2));</p>
<p>      var brokerCount = metadata.Brokers.Count;</p>

<p>      if (brokerCount == 0) {</p>
<p>        return HealthCheckResult.Degraded("No Kafka brokers available");</p>
<p>      }</p>

<p>      return HealthCheckResult.Healthy($"Kafka transport healthy, {brokerCount} brokers connected");</p>

<p>    } catch (KafkaException ex) {</p>
<p>      return HealthCheckResult.Unhealthy("Kafka transport unhealthy", ex);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>

<p>// Registration</p>
<p>builder.Services.AddHealthChecks()</p>
<p>  .AddCheck<KafkaTransportHealthCheck>("kafka_transport");</p>
<p></code></pre></p>

<hr>

<h3>Pattern 5: Batching Transport (High Throughput)</h3>

<pre><code class="language-csharp">using Whizbang.Core.Transports;
<p>using System.Threading.Channels;</p>

<p>public class BatchingTransport : ITransport {</p>
<p>  private readonly ITransport _innerTransport;</p>
<p>  private readonly Channel<(IMessageEnvelope, TransportDestination)> _queue;</p>
<p>  private readonly Task _batchProcessor;</p>
<p>  private readonly CancellationTokenSource _cts;</p>

<p>  private const int BatchSize = 100;</p>
<p>  private static readonly TimeSpan BatchTimeout = TimeSpan.FromMilliseconds(100);</p>

<p>  public BatchingTransport(ITransport innerTransport) {</p>
<p>    _innerTransport = innerTransport;</p>

<p>    _queue = Channel.CreateBounded<(IMessageEnvelope, TransportDestination)>(10000);</p>

<p>    _cts = new CancellationTokenSource();</p>
<p>    _batchProcessor = Task.Run(() => ProcessBatchesAsync(_cts.Token));</p>
<p>  }</p>

<p>  public bool IsInitialized => _innerTransport.IsInitialized;</p>
<p>  public TransportCapabilities Capabilities => _innerTransport.Capabilities;</p>

<p>  public Task InitializeAsync(CancellationToken ct = default) =></p>
<p>    _innerTransport.InitializeAsync(ct);</p>

<p>  public async Task PublishAsync(</p>
<p>    IMessageEnvelope envelope,</p>
<p>    TransportDestination destination,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    // Queue message for batching</p>
<p>    await _queue.Writer.WriteAsync((envelope, destination), ct);</p>
<p>  }</p>

<p>  private async Task ProcessBatchesAsync(CancellationToken ct) {</p>
<p>    var batch = new List<(IMessageEnvelope, TransportDestination)>(BatchSize);</p>

<p>    while (!ct.IsCancellationRequested) {</p>
<p>      // Collect batch</p>
<p>      while (batch.Count < BatchSize) {</p>
<p>        using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(ct);</p>
<p>        timeoutCts.CancelAfter(BatchTimeout);</p>

<p>        try {</p>
<p>          var item = await _queue.Reader.ReadAsync(timeoutCts.Token);</p>
<p>          batch.Add(item);</p>
<p>        } catch (OperationCanceledException) {</p>
<p>          break;  // Timeout or cancellation</p>
<p>        }</p>
<p>      }</p>

<p>      // Publish batch in parallel</p>
<p>      if (batch.Count > 0) {</p>
<p>        await Task.WhenAll(</p>
<p>          batch.Select(item =></p>
<p>            _innerTransport.PublishAsync(item.Item1, item.Item2, ct)</p>
<p>          )</p>
<p>        );</p>

<p>        batch.Clear();</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>

<p>  // Other ITransport methods delegate to _innerTransport</p>
<p>  public Task<ISubscription> SubscribeAsync(...) =></p>
<p>    _innerTransport.SubscribeAsync(handler, destination, ct);</p>

<p>  public Task<IMessageEnvelope> SendAsync<TRequest, TResponse>(...) =></p>
<p>    _innerTransport.SendAsync<TRequest, TResponse>(requestEnvelope, destination, ct);</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">// Wrap existing transport with batching
<p>var kafkaTransport = new KafkaTransport(...);</p>
<p>var batchingTransport = new BatchingTransport(kafkaTransport);</p>

<p>builder.Services.AddSingleton<ITransport>(batchingTransport);</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li><strong>10x Throughput</strong>: Batch 100 messages in single Kafka produce call</li>
<li><strong>Lower Latency</strong>: Parallel publishing within batch</li>
<li><strong>Backpressure</strong>: Bounded channel prevents memory issues</li>
</ul>
<hr>

<h2>Testing Custom Transports</h2>

<h3>Testing Initialization</h3>

<pre><code class="language-csharp">public class KafkaTransportTests {
<p>  [Test]</p>
<p>  public async Task InitializeAsync_ValidBroker_SucceedsAsync() {</p>
<p>    // Arrange</p>
<p>    var producerConfig = new ProducerConfig { BootstrapServers = "localhost:9092" };</p>
<p>    var consumerConfig = new ConsumerConfig { BootstrapServers = "localhost:9092", GroupId = "test" };</p>
<p>    var jsonOptions = JsonContextRegistry.CreateCombinedOptions();</p>
<p>    var logger = new NullLogger<KafkaTransport>();</p>

<p>    var transport = new KafkaTransport(producerConfig, consumerConfig, jsonOptions, logger);</p>

<p>    // Act</p>
<p>    await transport.InitializeAsync();</p>

<p>    // Assert</p>
<p>    await Assert.That(transport.IsInitialized).IsTrue();</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task InitializeAsync_InvalidBroker_ThrowsAsync() {</p>
<p>    // Arrange</p>
<p>    var producerConfig = new ProducerConfig { BootstrapServers = "invalid:9092" };</p>
<p>    var consumerConfig = new ConsumerConfig { BootstrapServers = "invalid:9092", GroupId = "test" };</p>
<p>    var jsonOptions = JsonContextRegistry.CreateCombinedOptions();</p>
<p>    var logger = new NullLogger<KafkaTransport>();</p>

<p>    var transport = new KafkaTransport(producerConfig, consumerConfig, jsonOptions, logger);</p>

<p>    // Act & Assert</p>
<p>    await Assert.That(async () => await transport.InitializeAsync())</p>
<p>      .ThrowsException<InvalidOperationException>()</p>
<p>      .WithMessage("Kafka transport initialization failed");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Testing Publish/Subscribe</h3>

<pre><code class="language-csharp">public class KafkaTransportIntegrationTests {
<p>  [Test]</p>
<p>  public async Task PublishAndSubscribe_MessageReceivedAsync() {</p>
<p>    // Arrange</p>
<p>    var transport = CreateKafkaTransport();</p>
<p>    await transport.InitializeAsync();</p>

<p>    var receivedEnvelope = default(IMessageEnvelope);</p>
<p>    var messageReceived = new TaskCompletionSource<bool>();</p>

<p>    var destination = new TransportDestination(Address: "test-topic");</p>

<p>    // Subscribe</p>
<p>    await transport.SubscribeAsync(</p>
<p>      handler: async (envelope, ct) => {</p>
<p>        receivedEnvelope = envelope;</p>
<p>        messageReceived.SetResult(true);</p>
<p>      },</p>
<p>      destination: destination</p>
<p>    );</p>

<p>    // Act - Publish</p>
<p>    var envelope = MessageEnvelope.Create(</p>
<p>      messageId: MessageId.New(),</p>
<p>      correlationId: CorrelationId.New(),</p>
<p>      causationId: null,</p>
<p>      payload: new TestMessage("Hello Kafka!")</p>
<p>    );</p>

<p>    await transport.PublishAsync(envelope, destination);</p>

<p>    // Assert - Wait for message</p>
<p>    var received = await messageReceived.Task.WaitAsync(TimeSpan.FromSeconds(10));</p>

<p>    await Assert.That(received).IsTrue();</p>
<p>    await Assert.That(receivedEnvelope).IsNotNull();</p>
<p>    await Assert.That(receivedEnvelope!.MessageId).IsEqualTo(envelope.MessageId);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Implement InitializeAsync</strong> for connectivity verification</li>
<li>✅ <strong>Declare accurate Capabilities</strong> flags</li>
<li>✅ <strong>Use AOT-compatible serialization</strong> (JsonTypeInfo)</li>
<li>✅ <strong>Handle errors gracefully</strong> with retry logic</li>
<li>✅ <strong>Log all operations</strong> for observability</li>
<li>✅ <strong>Support cancellation</strong> via CancellationToken</li>
<li>✅ <strong>Add health checks</strong> for transport status</li>
<li>✅ <strong>Test with real backends</strong> (Docker containers)</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Block async operations with <code>.Result</code> or <code>.Wait()</code></li>
<li>❌ Skip initialization verification (fail fast!)</li>
<li>❌ Ignore Capabilities (declare what you support)</li>
<li>❌ Forget to dispose subscriptions (memory leaks)</li>
<li>❌ Use reflection for serialization (breaks AOT)</li>
<li>❌ Swallow exceptions silently (log errors!)</li>
<li>❌ Hardcode configuration (use options pattern)</li>
</ul>
<hr>

<h2>Further Reading</h2>

<strong>Transports</strong>:
<ul><li><a href="../transports/azure-service-bus.md">Azure Service Bus</a> - Built-in Service Bus transport</li>
<li><a href="../transports/in-memory.md">In-Memory</a> - Testing transport</li>
</ul>
<strong>Messaging</strong>:
<ul><li><a href="../messaging/outbox-pattern.md">Outbox Pattern</a> - Reliable event publishing</li>
<li><a href="../messaging/work-coordination.md">Work Coordination</a> - Lease-based processing</li>
</ul>
<strong>Source Generators</strong>:
<ul><li><a href="../source-generators/json-contexts.md">JSON Contexts</a> - AOT-compatible serialization</li>
</ul>
<strong>Infrastructure</strong>:
<ul><li><a href="../infrastructure/health-checks.md">Health Checks</a> - Transport health monitoring</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-extensibility-custom-work-coordinators" class="doc-section">
  <h3>Custom Work Coordinators</h3>
  <p class="doc-path"><code>v1.0.0/extensibility/custom-work-coordinators</code></p>
  <p class="doc-description"><em>Implement custom work coordination strategies - distributed locks, Redis queues, or custom lease management</em></p>
  <div class="doc-content">

<h1>Custom Work Coordinators</h1>

<strong>Custom work coordinators</strong> enable alternative work distribution strategies beyond PostgreSQL-based leasing. Implement Redis-based queues, distributed locks, or custom lease management.

<p>:::note</p>
<p>Whizbang uses PostgreSQL stored procedures for work coordination by default. Custom coordinators are for specialized scenarios.</p>
<p>:::</p>

<hr>

<h2>Why Custom Work Coordinators?</h2>

<p>| Strategy | Use Case | Benefits |</p>
<p>|----------|----------|----------|</p>
<p>| <strong>PostgreSQL</strong> (default) | Standard apps | ACID, atomic batches |</p>
<p>| <strong>Redis</strong> | High-throughput | In-memory, fast locks |</p>
<p>| <strong>Distributed Locks</strong> | Multi-region | Consensus-based |</p>
<p>| <strong>Kafka</strong> | Event streaming | Offset-based tracking |</p>

<strong>When to use custom coordinators</strong>:
<ul><li>✅ Extreme throughput (> 100K msg/sec)</li>
<li>✅ Multi-region deployments</li>
<li>✅ Existing infrastructure</li>
<li>✅ Custom lease strategies</li>
</ul>
<hr>

<h2>IWorkCoordinator Interface</h2>

<pre><code class="language-csharp">public interface IWorkCoordinator {
<p>  Task<WorkBatch> ProcessWorkBatchAsync(</p>
<p>    Guid instanceId,</p>
<p>    string serviceName,</p>
<p>    // ... parameters</p>
<p>    CancellationToken ct = default</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Redis Work Coordinator</h2>

<h3>Pattern 1: Redis Queue-Based Coordination</h3>

<pre><code class="language-csharp">using StackExchange.Redis;

<p>public class RedisWorkCoordinator : IWorkCoordinator {</p>
<p>  private readonly IConnectionMultiplexer _redis;</p>
<p>  private readonly ILogger<RedisWorkCoordinator> _logger;</p>

<p>  public RedisWorkCoordinator(</p>
<p>    IConnectionMultiplexer redis,</p>
<p>    ILogger<RedisWorkCoordinator> logger</p>
<p>  ) {</p>
<p>    _redis = redis;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task<WorkBatch> ProcessWorkBatchAsync(</p>
<p>    Guid instanceId,</p>
<p>    string serviceName,</p>
<p>    string hostName,</p>
<p>    int processId,</p>
<p>    Dictionary<string, JsonElement>? metadata,</p>
<p>    MessageCompletion[] outboxCompletions,</p>
<p>    MessageFailure[] outboxFailures,</p>
<p>    // ... other parameters</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var db = _redis.GetDatabase();</p>

<p>    // 1. Process completions (remove from Redis)</p>
<p>    foreach (var completion in outboxCompletions) {</p>
<p>      await db.ListRemoveAsync(</p>
<p>        "outbox:pending",</p>
<p>        JsonSerializer.Serialize(completion.MessageId),</p>
<p>        ct</p>
<p>      );</p>
<p>    }</p>

<p>    // 2. Process failures (update retry count)</p>
<p>    foreach (var failure in outboxFailures) {</p>
<p>      // Increment retry count, re-queue if needed</p>
<p>      // ...</p>
<p>    }</p>

<p>    // 3. Claim new work (atomic LPOP)</p>
<p>    var claimedWork = new List<OutboxMessage>();</p>
<p>    for (int i = 0; i < 100; i++) {</p>
<p>      var workItem = await db.ListLeftPopAsync("outbox:pending", ct);</p>
<p>      if (workItem.IsNullOrEmpty) break;</p>

<p>      var message = JsonSerializer.Deserialize<OutboxMessage>(workItem!);</p>
<p>      claimedWork.Add(message!);</p>
<p>    }</p>

<p>    return new WorkBatch {</p>
<p>      ClaimedOutboxMessages = claimedWork.ToArray()</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Messaging</strong>:
<ul><li><a href="../messaging/work-coordination.md">Work Coordination</a> - PostgreSQL work coordination</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-extensibility-database-schema-framework" class="doc-section">
  <h3>Database Schema Framework</h3>
  <p class="doc-path"><code>v1.0.0/extensibility/database-schema-framework</code></p>
  <p class="doc-description"><em>Implement database drivers using the Whizbang.Data.Schema framework - database-agnostic table and column definitions for PostgreSQL, SQLite, SQL Server, and custom databases</em></p>
  <div class="doc-content">

<h1>Database Schema Framework</h1>

<strong>The Whizbang.Data.Schema framework</strong> provides a database-agnostic abstraction layer for defining infrastructure tables. This enables library developers to implement database drivers for PostgreSQL, SQLite, SQL Server, and custom databases while maintaining a single canonical schema definition.

<p>:::note</p>
<p>This documentation is for <strong>library developers</strong> implementing database drivers. For application developers using Whizbang, see <a href="../data/postgres-data.md">PostgreSQL Data</a> or <a href="../data/sqlite-data.md">SQLite Data</a>.</p>
<p>:::</p>

<hr>

<h2>Why Schema Framework?</h2>

<strong>Single Source of Truth</strong>: Define infrastructure tables (outbox, inbox, event_store, etc.) once, generate SQL for multiple databases.

<p>| Database | Without Framework | With Framework |</p>
<p>|----------|-------------------|----------------|</p>
<p>| <strong>PostgreSQL</strong> | Hand-write CREATE TABLE | Generate from TableDefinition |</p>
<p>| <strong>SQLite</strong> | Hand-write CREATE TABLE | Generate from TableDefinition |</p>
<p>| <strong>SQL Server</strong> | Hand-write CREATE TABLE | Generate from TableDefinition |</p>
<p>| <strong>Dapper SQL</strong> | Duplicate schema in SQL files | Generate from TableDefinition |</p>
<p>| <strong>EF Core</strong> | Duplicate schema in migrations | Generate from TableDefinition |</p>

<strong>Benefits</strong>:
<ul><li>✅ <strong>Single Canonical Definition</strong> - Schema defined once in C# (e.g., OutboxSchema)</li>
<li>✅ <strong>Type Safety</strong> - Compile-time validation of column names and types</li>
<li>✅ <strong>Database Portability</strong> - Support PostgreSQL, SQLite, SQL Server from one definition</li>
<li>✅ <strong>AOT Compatible</strong> - Value-type records with structural equality</li>
<li>✅ <strong>Incremental Generator Support</strong> - ImmutableArray enables efficient source generation</li>
</ul>
<hr>

<h2>Architecture</h2>

<h3>Core Types</h3>

<pre><code class="language-csharp">namespace Whizbang.Data.Schema;

<p>// Complete table definition</p>
<p>public sealed record TableDefinition(</p>
<p>  string Name,</p>
<p>  ImmutableArray<ColumnDefinition> Columns,</p>
<p>  ImmutableArray<IndexDefinition> Indexes = default</p>
<p>);</p>

<p>// Column definition with type and constraints</p>
<p>public sealed record ColumnDefinition(</p>
<p>  string Name,</p>
<p>  WhizbangDataType DataType,</p>
<p>  int? MaxLength = null,</p>
<p>  bool Nullable = true,</p>
<p>  bool PrimaryKey = false,</p>
<p>  DefaultValue? DefaultValue = null</p>
<p>);</p>

<p>// Index definition (simple or composite)</p>
<p>public sealed record IndexDefinition(</p>
<p>  string Name,</p>
<p>  ImmutableArray<string> Columns,</p>
<p>  bool Unique = false,</p>
<p>  string? WhereClause = null</p>
<p>);</p>

<p>// Database-agnostic type system</p>
<p>public enum WhizbangDataType {</p>
<p>  Uuid,         // UUID/GUID</p>
<p>  String,       // VARCHAR/TEXT/NVARCHAR</p>
<p>  TimestampTz,  // TIMESTAMPTZ/DATETIMEOFFSET</p>
<p>  Json,         // JSONB/TEXT/NVARCHAR(MAX)</p>
<p>  BigInt,       // 64-bit integer</p>
<p>  Integer,      // 32-bit integer</p>
<p>  SmallInt,     // 16-bit integer</p>
<p>  Boolean       // BOOLEAN/BIT/INTEGER(0/1)</p>
<p>}</p>

<p>// Default value abstraction</p>
<p>public abstract record DefaultValue {</p>
<p>  public static DefaultValue Integer(int value) => new IntegerDefault(value);</p>
<p>  public static DefaultValue Function(DefaultValueFunction func) => new FunctionDefault(func);</p>
<p>}</p>

<p>// Database functions for defaults</p>
<p>public enum DefaultValueFunction {</p>
<p>  DateTime_Now,  // CURRENT_TIMESTAMP/NOW()/GETDATE()</p>
<p>  Guid_New       // gen_random_uuid()/NEWID()/uuid()</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Simple Table Example</h2>

<h3>Pattern 1: Message Deduplication Table (2 Columns)</h3>

<strong>Use Case</strong>: Minimal table for permanent message deduplication tracking.

<pre><code class="language-csharp">using System.Collections.Immutable;
<p>using Whizbang.Data.Schema;</p>

<p>public static class MessageDeduplicationSchema {</p>
<p>  public static readonly TableDefinition Table = new(</p>
<p>    Name: "message_deduplication",</p>
<p>    Columns: ImmutableArray.Create(</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "message_id",</p>
<p>        DataType: WhizbangDataType.Uuid,</p>
<p>        PrimaryKey: true,</p>
<p>        Nullable: false</p>
<p>      ),</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "first_seen_at",</p>
<p>        DataType: WhizbangDataType.TimestampTz,</p>
<p>        Nullable: false,</p>
<p>        DefaultValue: DefaultValue.Function(DefaultValueFunction.DateTime_Now)</p>
<p>      )</p>
<p>    ),</p>
<p>    Indexes: ImmutableArray.Create(</p>
<p>      new IndexDefinition(</p>
<p>        Name: "idx_message_dedup_first_seen",</p>
<p>        Columns: ImmutableArray.Create("first_seen_at")</p>
<p>      )</p>
<p>    )</p>
<p>  );</p>

<p>  public static class Columns {</p>
<p>    public const string MessageId = "message_id";</p>
<p>    public const string FirstSeenAt = "first_seen_at";</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Why This Works</strong>:
<ul><li><strong>Sealed record</strong> - Value-type semantics with structural equality (critical for incremental generators)</li>
<li><strong>ImmutableArray</strong> - Enables value equality for collections (no reference equality issues)</li>
<li><strong>Constants class</strong> - Type-safe column name access in queries</li>
<li><strong>AOT Compatible</strong> - No reflection, all types known at compile time</li>
</ul>
<hr>

<h2>Complex Table Example</h2>

<h3>Pattern 2: Outbox Table (18 Columns, 6 Indexes)</h3>

<strong>Use Case</strong>: Complete transactional outbox with work coordination, partitioning, and leasing.

<pre><code class="language-csharp">using System.Collections.Immutable;
<p>using Whizbang.Data.Schema;</p>

<p>public static class OutboxSchema {</p>
<p>  public static readonly TableDefinition Table = new(</p>
<p>    Name: "outbox",</p>
<p>    Columns: ImmutableArray.Create(</p>
<p>      // Identity</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "message_id",</p>
<p>        DataType: WhizbangDataType.Uuid,</p>
<p>        PrimaryKey: true,</p>
<p>        Nullable: false</p>
<p>      ),</p>
<p>      // Routing</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "destination",</p>
<p>        DataType: WhizbangDataType.String,</p>
<p>        MaxLength: 500,</p>
<p>        Nullable: false</p>
<p>      ),</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "stream_id",</p>
<p>        DataType: WhizbangDataType.Uuid,</p>
<p>        Nullable: true</p>
<p>      ),</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "partition_number",</p>
<p>        DataType: WhizbangDataType.Integer,</p>
<p>        Nullable: true</p>
<p>      ),</p>
<p>      // Message content</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "event_type",</p>
<p>        DataType: WhizbangDataType.String,</p>
<p>        MaxLength: 500,</p>
<p>        Nullable: false</p>
<p>      ),</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "event_data",</p>
<p>        DataType: WhizbangDataType.Json,</p>
<p>        Nullable: false</p>
<p>      ),</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "metadata",</p>
<p>        DataType: WhizbangDataType.Json,</p>
<p>        Nullable: false</p>
<p>      ),</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "scope",</p>
<p>        DataType: WhizbangDataType.Json,</p>
<p>        Nullable: true</p>
<p>      ),</p>
<p>      // Work coordination</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "status",</p>
<p>        DataType: WhizbangDataType.Integer,</p>
<p>        Nullable: false,</p>
<p>        DefaultValue: DefaultValue.Integer(1)  // Stored = 1</p>
<p>      ),</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "attempts",</p>
<p>        DataType: WhizbangDataType.Integer,</p>
<p>        Nullable: false,</p>
<p>        DefaultValue: DefaultValue.Integer(0)</p>
<p>      ),</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "error",</p>
<p>        DataType: WhizbangDataType.String,</p>
<p>        Nullable: true</p>
<p>      ),</p>
<p>      // Leasing</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "instance_id",</p>
<p>        DataType: WhizbangDataType.Uuid,</p>
<p>        Nullable: true</p>
<p>      ),</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "lease_expiry",</p>
<p>        DataType: WhizbangDataType.TimestampTz,</p>
<p>        Nullable: true</p>
<p>      ),</p>
<p>      // Failure tracking</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "failure_reason",</p>
<p>        DataType: WhizbangDataType.Integer,</p>
<p>        Nullable: false,</p>
<p>        DefaultValue: DefaultValue.Integer(99)  // None = 99</p>
<p>      ),</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "scheduled_for",</p>
<p>        DataType: WhizbangDataType.TimestampTz,</p>
<p>        Nullable: true</p>
<p>      ),</p>
<p>      // Timestamps</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "created_at",</p>
<p>        DataType: WhizbangDataType.TimestampTz,</p>
<p>        Nullable: false,</p>
<p>        DefaultValue: DefaultValue.Function(DefaultValueFunction.DateTime_Now)</p>
<p>      ),</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "published_at",</p>
<p>        DataType: WhizbangDataType.TimestampTz,</p>
<p>        Nullable: true</p>
<p>      ),</p>
<p>      // Flags</p>
<p>      new ColumnDefinition(</p>
<p>        Name: "is_event",</p>
<p>        DataType: WhizbangDataType.Boolean,</p>
<p>        Nullable: false,</p>
<p>        DefaultValue: DefaultValue.Integer(0)  // false = 0</p>
<p>      )</p>
<p>    ),</p>
<p>    Indexes: ImmutableArray.Create(</p>
<p>      new IndexDefinition(</p>
<p>        Name: "idx_outbox_status_created_at",</p>
<p>        Columns: ImmutableArray.Create("status", "created_at")</p>
<p>      ),</p>
<p>      new IndexDefinition(</p>
<p>        Name: "idx_outbox_published_at",</p>
<p>        Columns: ImmutableArray.Create("published_at")</p>
<p>      ),</p>
<p>      new IndexDefinition(</p>
<p>        Name: "idx_outbox_lease_expiry",</p>
<p>        Columns: ImmutableArray.Create("lease_expiry"),</p>
<p>        WhereClause: "lease_expiry IS NOT NULL"</p>
<p>      ),</p>
<p>      new IndexDefinition(</p>
<p>        Name: "idx_outbox_status_lease",</p>
<p>        Columns: ImmutableArray.Create("status", "lease_expiry"),</p>
<p>        WhereClause: "(status & 32768) = 0 AND (status & 2) != 2"  // Not terminal, not completed</p>
<p>      ),</p>
<p>      new IndexDefinition(</p>
<p>        Name: "idx_outbox_failure_reason",</p>
<p>        Columns: ImmutableArray.Create("failure_reason"),</p>
<p>        WhereClause: "(status & 32768) = 32768"  // Terminal status</p>
<p>      ),</p>
<p>      new IndexDefinition(</p>
<p>        Name: "idx_outbox_scheduled_for",</p>
<p>        Columns: ImmutableArray.Create("stream_id", "scheduled_for", "created_at"),</p>
<p>        WhereClause: "scheduled_for IS NOT NULL"</p>
<p>      )</p>
<p>    )</p>
<p>  );</p>

<p>  public static class Columns {</p>
<p>    public const string MessageId = "message_id";</p>
<p>    public const string Destination = "destination";</p>
<p>    public const string StreamId = "stream_id";</p>
<p>    public const string PartitionNumber = "partition_number";</p>
<p>    public const string EventType = "event_type";</p>
<p>    public const string EventData = "event_data";</p>
<p>    public const string Metadata = "metadata";</p>
<p>    public const string Scope = "scope";</p>
<p>    public const string Status = "status";</p>
<p>    public const string Attempts = "attempts";</p>
<p>    public const string Error = "error";</p>
<p>    public const string InstanceId = "instance_id";</p>
<p>    public const string LeaseExpiry = "lease_expiry";</p>
<p>    public const string FailureReason = "failure_reason";</p>
<p>    public const string ScheduledFor = "scheduled_for";</p>
<p>    public const string CreatedAt = "created_at";</p>
<p>    public const string PublishedAt = "published_at";</p>
<p>    public const string IsEvent = "is_event";</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Patterns</strong>:
<ul><li><strong>Composite Indexes</strong> - Multi-column indexes for complex queries</li>
<li><strong>Partial Indexes</strong> - <code>WhereClause</code> for filtered indexes (PostgreSQL only)</li>
<li><strong>Integer Defaults</strong> - Enums stored as integers (status flags, failure reasons)</li>
<li><strong>Optional Columns</strong> - <code>Nullable: true</code> for conditional data (stream_id, error, etc.)</li>
</ul>
<hr>

<h2>PostgreSQL Schema Generator</h2>

<h3>Pattern 3: Generating CREATE TABLE for PostgreSQL</h3>

<strong>Use Case</strong>: Convert TableDefinition to PostgreSQL DDL.

<pre><code class="language-csharp">using Whizbang.Data.Schema;
<p>using System.Text;</p>

<p>public static class PostgresSchemaGenerator {</p>
<p>  public static string GenerateCreateTable(</p>
<p>    TableDefinition table,</p>
<p>    string prefix = "wh_"</p>
<p>  ) {</p>
<p>    var sb = new StringBuilder();</p>
<p>    var tableName = $"{prefix}{table.Name}";</p>

<p>    sb.AppendLine($"CREATE TABLE IF NOT EXISTS {tableName} (");</p>

<p>    // Columns</p>
<p>    var columns = table.Columns.Select(c => GenerateColumn(c));</p>
<p>    sb.AppendLine($"  {string.Join(",\n  ", columns)}");</p>

<p>    sb.AppendLine(");");</p>

<p>    // Indexes</p>
<p>    foreach (var index in table.Indexes) {</p>
<p>      sb.AppendLine();</p>
<p>      sb.AppendLine(GenerateIndex(tableName, index));</p>
<p>    }</p>

<p>    return sb.ToString();</p>
<p>  }</p>

<p>  private static string GenerateColumn(ColumnDefinition column) {</p>
<p>    var parts = new List<string> { column.Name, MapType(column) };</p>

<p>    if (!column.Nullable) {</p>
<p>      parts.Add("NOT NULL");</p>
<p>    }</p>

<p>    if (column.PrimaryKey) {</p>
<p>      parts.Add("PRIMARY KEY");</p>
<p>    }</p>

<p>    if (column.DefaultValue != null) {</p>
<p>      parts.Add($"DEFAULT {MapDefault(column.DefaultValue)}");</p>
<p>    }</p>

<p>    return string.Join(" ", parts);</p>
<p>  }</p>

<p>  private static string MapType(ColumnDefinition column) {</p>
<p>    return column.DataType switch {</p>
<p>      WhizbangDataType.Uuid => "UUID",</p>
<p>      WhizbangDataType.String => column.MaxLength.HasValue</p>
<p>        ? $"VARCHAR({column.MaxLength})"</p>
<p>        : "TEXT",</p>
<p>      WhizbangDataType.TimestampTz => "TIMESTAMPTZ",</p>
<p>      WhizbangDataType.Json => "JSONB",</p>
<p>      WhizbangDataType.BigInt => "BIGINT",</p>
<p>      WhizbangDataType.Integer => "INTEGER",</p>
<p>      WhizbangDataType.SmallInt => "SMALLINT",</p>
<p>      WhizbangDataType.Boolean => "BOOLEAN",</p>
<p>      _ => throw new NotSupportedException($"Unsupported type: {column.DataType}")</p>
<p>    };</p>
<p>  }</p>

<p>  private static string MapDefault(DefaultValue defaultValue) {</p>
<p>    return defaultValue switch {</p>
<p>      IntegerDefault i => i.Value.ToString(),</p>
<p>      FunctionDefault f => f.FunctionType switch {</p>
<p>        DefaultValueFunction.DateTime_Now => "CURRENT_TIMESTAMP",</p>
<p>        DefaultValueFunction.Guid_New => "gen_random_uuid()",</p>
<p>        _ => throw new NotSupportedException($"Unsupported function: {f.FunctionType}")</p>
<p>      },</p>
<p>      _ => throw new NotSupportedException($"Unsupported default: {defaultValue}")</p>
<p>    };</p>
<p>  }</p>

<p>  private static string GenerateIndex(string tableName, IndexDefinition index) {</p>
<p>    var sb = new StringBuilder();</p>

<p>    var uniqueKeyword = index.Unique ? "UNIQUE " : "";</p>
<p>    var columns = string.Join(", ", index.Columns);</p>

<p>    sb.Append($"CREATE {uniqueKeyword}INDEX IF NOT EXISTS {index.Name} ");</p>
<p>    sb.Append($"ON {tableName} ({columns})");</p>

<p>    if (!string.IsNullOrEmpty(index.WhereClause)) {</p>
<p>      sb.Append($" WHERE {index.WhereClause}");</p>
<p>    }</p>

<p>    sb.Append(";");</p>

<p>    return sb.ToString();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">var createTableSql = PostgresSchemaGenerator.GenerateCreateTable(
<p>  OutboxSchema.Table,</p>
<p>  prefix: "wh_"</p>
<p>);</p>

<p>// Output:</p>
<p>// CREATE TABLE IF NOT EXISTS wh_outbox (</p>
<p>//   message_id UUID NOT NULL PRIMARY KEY,</p>
<p>//   destination VARCHAR(500) NOT NULL,</p>
<p>//   stream_id UUID,</p>
<p>//   ...</p>
<p>//   created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,</p>
<p>//   published_at TIMESTAMPTZ</p>
<p>// );</p>
<p>//</p>
<p>// CREATE INDEX IF NOT EXISTS idx_outbox_status_created_at ON wh_outbox (status, created_at);</p>
<p>// ...</p>
<p></code></pre></p>

<hr>

<h2>SQLite Schema Generator</h2>

<h3>Pattern 4: Generating CREATE TABLE for SQLite</h3>

<strong>Use Case</strong>: Convert TableDefinition to SQLite DDL (different type mappings).

<pre><code class="language-csharp">using Whizbang.Data.Schema;
<p>using System.Text;</p>

<p>public static class SqliteSchemaGenerator {</p>
<p>  public static string GenerateCreateTable(</p>
<p>    TableDefinition table,</p>
<p>    string prefix = "wh_"</p>
<p>  ) {</p>
<p>    var sb = new StringBuilder();</p>
<p>    var tableName = $"{prefix}{table.Name}";</p>

<p>    sb.AppendLine($"CREATE TABLE IF NOT EXISTS {tableName} (");</p>

<p>    // Columns</p>
<p>    var columns = table.Columns.Select(c => GenerateColumn(c));</p>
<p>    sb.AppendLine($"  {string.Join(",\n  ", columns)}");</p>

<p>    sb.AppendLine(");");</p>

<p>    // Indexes</p>
<p>    foreach (var index in table.Indexes) {</p>
<p>      sb.AppendLine();</p>
<p>      sb.AppendLine(GenerateIndex(tableName, index));</p>
<p>    }</p>

<p>    return sb.ToString();</p>
<p>  }</p>

<p>  private static string GenerateColumn(ColumnDefinition column) {</p>
<p>    var parts = new List<string> { column.Name, MapType(column) };</p>

<p>    if (!column.Nullable) {</p>
<p>      parts.Add("NOT NULL");</p>
<p>    }</p>

<p>    if (column.PrimaryKey) {</p>
<p>      parts.Add("PRIMARY KEY");</p>
<p>    }</p>

<p>    if (column.DefaultValue != null) {</p>
<p>      parts.Add($"DEFAULT {MapDefault(column.DefaultValue)}");</p>
<p>    }</p>

<p>    return string.Join(" ", parts);</p>
<p>  }</p>

<p>  private static string MapType(ColumnDefinition column) {</p>
<p>    return column.DataType switch {</p>
<p>      WhizbangDataType.Uuid => "BLOB",  // SQLite stores UUIDs as BLOB</p>
<p>      WhizbangDataType.String => "TEXT",  // SQLite ignores VARCHAR length</p>
<p>      WhizbangDataType.TimestampTz => "TEXT",  // ISO8601 string</p>
<p>      WhizbangDataType.Json => "TEXT",  // JSON stored as TEXT</p>
<p>      WhizbangDataType.BigInt => "INTEGER",  // SQLite uses INTEGER for all ints</p>
<p>      WhizbangDataType.Integer => "INTEGER",</p>
<p>      WhizbangDataType.SmallInt => "INTEGER",</p>
<p>      WhizbangDataType.Boolean => "INTEGER",  // 0/1</p>
<p>      _ => throw new NotSupportedException($"Unsupported type: {column.DataType}")</p>
<p>    };</p>
<p>  }</p>

<p>  private static string MapDefault(DefaultValue defaultValue) {</p>
<p>    return defaultValue switch {</p>
<p>      IntegerDefault i => i.Value.ToString(),</p>
<p>      FunctionDefault f => f.FunctionType switch {</p>
<p>        DefaultValueFunction.DateTime_Now => "(datetime('now'))",</p>
<p>        DefaultValueFunction.Guid_New => "(randomblob(16))",  // Random UUID</p>
<p>        _ => throw new NotSupportedException($"Unsupported function: {f.FunctionType}")</p>
<p>      },</p>
<p>      _ => throw new NotSupportedException($"Unsupported default: {defaultValue}")</p>
<p>    };</p>
<p>  }</p>

<p>  private static string GenerateIndex(string tableName, IndexDefinition index) {</p>
<p>    var sb = new StringBuilder();</p>

<p>    var uniqueKeyword = index.Unique ? "UNIQUE " : "";</p>
<p>    var columns = string.Join(", ", index.Columns);</p>

<p>    sb.Append($"CREATE {uniqueKeyword}INDEX IF NOT EXISTS {index.Name} ");</p>
<p>    sb.Append($"ON {tableName} ({columns})");</p>

<p>    // SQLite supports WHERE clauses on indexes</p>
<p>    if (!string.IsNullOrEmpty(index.WhereClause)) {</p>
<p>      sb.Append($" WHERE {index.WhereClause}");</p>
<p>    }</p>

<p>    sb.Append(";");</p>

<p>    return sb.ToString();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences from PostgreSQL</strong>:
<ul><li><strong>UUID</strong> - <code>BLOB</code> instead of native UUID type</li>
<li><strong>TimestampTz</strong> - <code>TEXT</code> (ISO8601 format) instead of TIMESTAMPTZ</li>
<li><strong>JSON</strong> - <code>TEXT</code> instead of JSONB</li>
<li><strong>All Integer Types</strong> - <code>INTEGER</code> (SQLite only has INTEGER affinity)</li>
<li><strong>Boolean</strong> - <code>INTEGER</code> (0/1) instead of BOOLEAN</li>
<li><strong>Default Functions</strong> - <code>datetime('now')</code> instead of CURRENT_TIMESTAMP</li>
</ul>
<hr>

<h2>Schema Configuration</h2>

<h3>Pattern 5: Using SchemaConfiguration</h3>

<strong>Use Case</strong>: Generate schemas for all infrastructure tables with custom prefix.

<pre><code class="language-csharp">using Whizbang.Data.Schema;
<p>using Whizbang.Data.Schema.Schemas;</p>

<p>public class SchemaConfiguration {</p>
<p>  public string Prefix { get; init; } = "wh_";</p>

<p>  public IReadOnlyList<TableDefinition> GetAllTables() {</p>
<p>    return new[] {</p>
<p>      OutboxSchema.Table,</p>
<p>      InboxSchema.Table,</p>
<p>      EventStoreSchema.Table,</p>
<p>      ReceptorProcessingSchema.Table,</p>
<p>      PerspectiveCheckpointsSchema.Table,</p>
<p>      ServiceInstancesSchema.Table,</p>
<p>      MessageDeduplicationSchema.Table,</p>
<p>      RequestResponseSchema.Table,</p>
<p>      SequencesSchema.Table</p>
<p>    };</p>
<p>  }</p>

<p>  public string GenerateFullSchema(ISchemaGenerator generator) {</p>
<p>    var sb = new StringBuilder();</p>

<p>    foreach (var table in GetAllTables()) {</p>
<p>      sb.AppendLine(generator.GenerateCreateTable(table, Prefix));</p>
<p>      sb.AppendLine();</p>
<p>    }</p>

<p>    return sb.ToString();</p>
<p>  }</p>
<p>}</p>

<p>public interface ISchemaGenerator {</p>
<p>  string GenerateCreateTable(TableDefinition table, string prefix);</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">var config = new SchemaConfiguration { Prefix = "prod_" };
<p>var postgresGenerator = new PostgresSchemaGenerator();</p>

<p>var fullSchemaSql = config.GenerateFullSchema(postgresGenerator);</p>

<p>// Generates CREATE TABLE statements for all 9 infrastructure tables</p>
<p>// with "prod_" prefix (prod_outbox, prod_inbox, etc.)</p>
<p></code></pre></p>

<hr>

<h2>Testing Schema Generators</h2>

<h3>Testing Table Generation</h3>

<pre><code class="language-csharp">using TUnit.Assertions;
<p>using TUnit.Core;</p>
<p>using Whizbang.Data.Schema;</p>

<p>public class PostgresSchemaGeneratorTests {</p>
<p>  [Test]</p>
<p>  public async Task GenerateCreateTable_SimpleTable_GeneratesCorrectSqlAsync() {</p>
<p>    // Arrange</p>
<p>    var table = new TableDefinition(</p>
<p>      Name: "test",</p>
<p>      Columns: ImmutableArray.Create(</p>
<p>        new ColumnDefinition(</p>
<p>          Name: "id",</p>
<p>          DataType: WhizbangDataType.Uuid,</p>
<p>          PrimaryKey: true,</p>
<p>          Nullable: false</p>
<p>        ),</p>
<p>        new ColumnDefinition(</p>
<p>          Name: "name",</p>
<p>          DataType: WhizbangDataType.String,</p>
<p>          MaxLength: 100,</p>
<p>          Nullable: false</p>
<p>        )</p>
<p>      )</p>
<p>    );</p>

<p>    // Act</p>
<p>    var sql = PostgresSchemaGenerator.GenerateCreateTable(table, prefix: "test_");</p>

<p>    // Assert</p>
<p>    await Assert.That(sql).Contains("CREATE TABLE IF NOT EXISTS test_test");</p>
<p>    await Assert.That(sql).Contains("id UUID NOT NULL PRIMARY KEY");</p>
<p>    await Assert.That(sql).Contains("name VARCHAR(100) NOT NULL");</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task GenerateCreateTable_WithIndexes_GeneratesIndexSqlAsync() {</p>
<p>    // Arrange</p>
<p>    var table = new TableDefinition(</p>
<p>      Name: "test",</p>
<p>      Columns: ImmutableArray.Create(</p>
<p>        new ColumnDefinition(Name: "id", DataType: WhizbangDataType.Uuid, PrimaryKey: true, Nullable: false),</p>
<p>        new ColumnDefinition(Name: "created_at", DataType: WhizbangDataType.TimestampTz, Nullable: false)</p>
<p>      ),</p>
<p>      Indexes: ImmutableArray.Create(</p>
<p>        new IndexDefinition(</p>
<p>          Name: "idx_test_created_at",</p>
<p>          Columns: ImmutableArray.Create("created_at")</p>
<p>        )</p>
<p>      )</p>
<p>    );</p>

<p>    // Act</p>
<p>    var sql = PostgresSchemaGenerator.GenerateCreateTable(table, prefix: "test_");</p>

<p>    // Assert</p>
<p>    await Assert.That(sql).Contains("CREATE INDEX IF NOT EXISTS idx_test_created_at");</p>
<p>    await Assert.That(sql).Contains("ON test_test (created_at)");</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task GenerateCreateTable_WithDefaults_GeneratesDefaultsAsync() {</p>
<p>    // Arrange</p>
<p>    var table = new TableDefinition(</p>
<p>      Name: "test",</p>
<p>      Columns: ImmutableArray.Create(</p>
<p>        new ColumnDefinition(Name: "id", DataType: WhizbangDataType.Uuid, PrimaryKey: true, Nullable: false),</p>
<p>        new ColumnDefinition(</p>
<p>          Name: "created_at",</p>
<p>          DataType: WhizbangDataType.TimestampTz,</p>
<p>          Nullable: false,</p>
<p>          DefaultValue: DefaultValue.Function(DefaultValueFunction.DateTime_Now)</p>
<p>        ),</p>
<p>        new ColumnDefinition(</p>
<p>          Name: "status",</p>
<p>          DataType: WhizbangDataType.Integer,</p>
<p>          Nullable: false,</p>
<p>          DefaultValue: DefaultValue.Integer(1)</p>
<p>        )</p>
<p>      )</p>
<p>    );</p>

<p>    // Act</p>
<p>    var sql = PostgresSchemaGenerator.GenerateCreateTable(table, prefix: "test_");</p>

<p>    // Assert</p>
<p>    await Assert.That(sql).Contains("created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP");</p>
<p>    await Assert.That(sql).Contains("status INTEGER NOT NULL DEFAULT 1");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Use sealed record</strong> for TableDefinition, ColumnDefinition, IndexDefinition (structural equality)</li>
<li>✅ <strong>Use ImmutableArray</strong> for collections (enables value equality)</li>
<li>✅ <strong>Define column constants</strong> in nested Columns class for type safety</li>
<li>✅ <strong>Map database-agnostic types</strong> correctly for each database (UUID → BLOB in SQLite, UUID in Postgres)</li>
<li>✅ <strong>Support partial indexes</strong> via WhereClause (PostgreSQL feature)</li>
<li>✅ <strong>Test generated SQL</strong> with real databases (Testcontainers)</li>
<li>✅ <strong>Use default prefixes</strong> ("wh_") but allow customization</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Use class instead of sealed record (breaks structural equality)</li>
<li>❌ Use List or Array (reference equality, breaks incremental generators)</li>
<li>❌ Hardcode table names in queries (use Columns.ColumnName constants)</li>
<li>❌ Skip database-specific type mapping (VARCHAR(n) works in Postgres, not SQLite)</li>
<li>❌ Forget WHERE clauses on partial indexes (only supported in PostgreSQL)</li>
<li>❌ Mix schema definition and SQL generation (separate concerns)</li>
<li>❌ Use reflection for schema generation (breaks AOT)</li>
</ul>
<hr>

<h2>Further Reading</h2>

<strong>Data Access</strong>:
<ul><li><a href="../data/postgres-data.md">PostgreSQL Data</a> - PostgreSQL implementation</li>
<li><a href="../data/sqlite-data.md">SQLite Data</a> - SQLite implementation</li>
<li><a href="../data/event-store.md">Event Store</a> - Event sourcing tables</li>
</ul>
<strong>Extensibility</strong>:
<ul><li><a href="custom-storage.md">Custom Storage</a> - Custom perspective stores</li>
<li><a href="custom-work-coordinators.md">Custom Work Coordinators</a> - Work coordination</li>
</ul>
<strong>Infrastructure</strong>:
<ul><li><a href="../messaging/outbox-pattern.md">Outbox Pattern</a> - Transactional outbox</li>
<li><a href="../messaging/work-coordination.md">Work Coordination</a> - Lease-based processing</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-16</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-extensibility-hooks-and-middleware" class="doc-section">
  <h3>Hooks and Middleware</h3>
  <p class="doc-path"><code>v1.0.0/extensibility/hooks-and-middleware</code></p>
  <p class="doc-description"><em>Pipeline behaviors for cross-cutting concerns - logging, validation, retry, caching, and custom pre/post processing</em></p>
  <div class="doc-content">

<h1>Hooks and Middleware</h1>

<strong>Pipeline behaviors</strong> enable cross-cutting concerns without modifying business logic. Behaviors intercept messages before/after receptor execution, allowing logging, validation, retry logic, caching, and other concerns to be injected declaratively.

<h2>Why Pipeline Behaviors?</h2>

<strong>Separate cross-cutting concerns from business logic</strong>:

<p>| Without Behaviors | With Behaviors | Benefit |</p>
<p>|-------------------|----------------|---------|</p>
<p>| <strong>Logging in every receptor</strong> | Single logging behavior | DRY principle |</p>
<p>| <strong>Validation scattered</strong> | Centralized validation behavior | Consistency |</p>
<p>| <strong>Retry logic duplicated</strong> | Reusable retry behavior | Maintainability |</p>
<p>| <strong>Caching per-handler</strong> | Generic caching behavior | Reduced complexity |</p>
<p>| <strong>Timing/metrics manual</strong> | Automatic timing behavior | Complete coverage |</p>

<strong>Use Cases</strong>:
<ul><li>✅ <strong>Logging</strong> - Structured logging for all messages</li>
<li>✅ <strong>Validation</strong> - Input validation before processing</li>
<li>✅ <strong>Retry Logic</strong> - Automatic retry on transient failures</li>
<li>✅ <strong>Caching</strong> - Response caching for idempotent queries</li>
<li>✅ <strong>Performance Metrics</strong> - Timing and throughput tracking</li>
<li>✅ <strong>Authorization</strong> - Permission checks</li>
<li>✅ <strong>Transaction Management</strong> - Automatic transaction boundaries</li>
<li>✅ <strong>Error Handling</strong> - Centralized exception handling</li>
</ul>
<hr>

<h2>Architecture</h2>

<h3>Pipeline Execution Flow</h3>

<pre><code class="language-">IDispatcher.SendAsync(command)
<p>  │</p>
<p>  │ 1. Create pipeline</p>
<p>  ▼</p>
<p>┌────────────────────────────────────────────────────────┐</p>
<p>│  Pipeline Chain (behaviors + receptor)                 │</p>
<p>│                                                         │</p>
<p>│  ┌──────────────────────────────────────────────────┐ │</p>
<p>│  │  LoggingBehavior                                 │ │</p>
<p>│  │  ├─ Before: Log request                          │ │</p>
<p>│  │  ├─ Call next() → ValidationBehavior             │ │</p>
<p>│  │  └─ After: Log response                          │ │</p>
<p>│  └──────────────────────────────────────────────────┘ │</p>
<p>│                  │                                      │</p>
<p>│                  ▼                                      │</p>
<p>│  ┌──────────────────────────────────────────────────┐ │</p>
<p>│  │  ValidationBehavior                              │ │</p>
<p>│  │  ├─ Before: Validate request                     │ │</p>
<p>│  │  ├─ Call next() → RetryBehavior                  │ │</p>
<p>│  │  └─ After: No post-processing                    │ │</p>
<p>│  └──────────────────────────────────────────────────┘ │</p>
<p>│                  │                                      │</p>
<p>│                  ▼                                      │</p>
<p>│  ┌──────────────────────────────────────────────────┐ │</p>
<p>│  │  RetryBehavior                                   │ │</p>
<p>│  │  ├─ Before: No pre-processing                    │ │</p>
<p>│  │  ├─ Call next() → OrderReceptor (with retry)     │ │</p>
<p>│  │  └─ After: No post-processing                    │ │</p>
<p>│  └──────────────────────────────────────────────────┘ │</p>
<p>│                  │                                      │</p>
<p>│                  ▼                                      │</p>
<p>│  ┌──────────────────────────────────────────────────┐ │</p>
<p>│  │  OrderReceptor.HandleAsync()                     │ │</p>
<p>│  │  └─ Business logic execution                     │ │</p>
<p>│  └──────────────────────────────────────────────────┘ │</p>
<p>└────────────────────────────────────────────────────────┘</p>
<p>  │</p>
<p>  │ 2. Return result</p>
<p>  ▼</p>
<p>Response</p>
<p></code></pre></p>

<hr>

<h2>IPipelineBehavior Interface</h2>

<h3>Definition</h3>

<pre><code class="language-csharp">public interface IPipelineBehavior<in TRequest, TResponse> {
<p>  Task<TResponse> Handle(</p>
<p>    TRequest request,</p>
<p>    Func<Task<TResponse>> next,</p>
<p>    CancellationToken cancellationToken = default</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<strong>Parameters</strong>:
<ul><li><code>request</code> - The message being processed (command or query)</li>
<li><code>next</code> - Delegate to invoke next behavior or receptor</li>
<li><code>cancellationToken</code> - Cancellation token</li>
</ul>
<strong>Return</strong>: Response from receptor (potentially modified by behavior)

<h3>Base Class</h3>

<pre><code class="language-csharp">public abstract class PipelineBehavior<TRequest, TResponse>
<p>  : IPipelineBehavior<TRequest, TResponse> {</p>

<p>  public abstract Task<TResponse> Handle(</p>
<p>    TRequest request,</p>
<p>    Func<Task<TResponse>> next,</p>
<p>    CancellationToken cancellationToken = default</p>
<p>  );</p>

<p>  protected async Task<TResponse> ExecuteNextAsync(Func<Task<TResponse>> next) {</p>
<p>    return await next();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Built-In Behaviors</h2>

<h3>1. Logging Behavior</h3>

<pre><code class="language-csharp">using Microsoft.Extensions.Logging;
<p>using Whizbang.Core.Pipeline;</p>

<p>public class LoggingBehavior<TRequest, TResponse></p>
<p>  : IPipelineBehavior<TRequest, TResponse> {</p>

<p>  private readonly ILogger<LoggingBehavior<TRequest, TResponse>> _logger;</p>

<p>  public LoggingBehavior(ILogger<LoggingBehavior<TRequest, TResponse>> logger) {</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task<TResponse> Handle(</p>
<p>    TRequest request,</p>
<p>    Func<Task<TResponse>> next,</p>
<p>    CancellationToken cancellationToken</p>
<p>  ) {</p>
<p>    var requestName = typeof(TRequest).Name;</p>
<p>    var requestId = Guid.NewGuid();</p>

<p>    // Before: Log request</p>
<p>    _logger.LogInformation(</p>
<p>      "Processing {RequestName} ({RequestId}): {@Request}",</p>
<p>      requestName,</p>
<p>      requestId,</p>
<p>      request</p>
<p>    );</p>

<p>    try {</p>
<p>      // Execute next behavior or receptor</p>
<p>      var response = await next();</p>

<p>      // After: Log success</p>
<p>      _logger.LogInformation(</p>
<p>        "Completed {RequestName} ({RequestId}): {@Response}",</p>
<p>        requestName,</p>
<p>        requestId,</p>
<p>        response</p>
<p>      );</p>

<p>      return response;</p>
<p>    } catch (Exception ex) {</p>
<p>      // After: Log failure</p>
<p>      _logger.LogError(</p>
<p>        ex,</p>
<p>        "Failed {RequestName} ({RequestId}): {Error}",</p>
<p>        requestName,</p>
<p>        requestId,</p>
<p>        ex.Message</p>
<p>      );</p>
<p>      throw;</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Registration</strong>:
<pre><code class="language-csharp">builder.Services.AddTransient(
<p>  typeof(IPipelineBehavior<,>),</p>
<p>  typeof(LoggingBehavior<,>)</p>
<p>);</p>
<p></code></pre></p>

<h3>2. Validation Behavior</h3>

<pre><code class="language-csharp">using FluentValidation;
<p>using Whizbang.Core.Pipeline;</p>

<p>public class ValidationBehavior<TRequest, TResponse></p>
<p>  : IPipelineBehavior<TRequest, TResponse> {</p>

<p>  private readonly IEnumerable<IValidator<TRequest>> _validators;</p>

<p>  public ValidationBehavior(IEnumerable<IValidator<TRequest>> validators) {</p>
<p>    _validators = validators;</p>
<p>  }</p>

<p>  public async Task<TResponse> Handle(</p>
<p>    TRequest request,</p>
<p>    Func<Task<TResponse>> next,</p>
<p>    CancellationToken cancellationToken</p>
<p>  ) {</p>
<p>    // No validators registered - skip validation</p>
<p>    if (!_validators.Any()) {</p>
<p>      return await next();</p>
<p>    }</p>

<p>    // Validate request</p>
<p>    var context = new ValidationContext<TRequest>(request);</p>
<p>    var validationResults = await Task.WhenAll(</p>
<p>      _validators.Select(v => v.ValidateAsync(context, cancellationToken))</p>
<p>    );</p>

<p>    var failures = validationResults</p>
<p>      .SelectMany(r => r.Errors)</p>
<p>      .Where(f => f != null)</p>
<p>      .ToList();</p>

<p>    if (failures.Any()) {</p>
<p>      throw new ValidationException(failures);</p>
<p>    }</p>

<p>    // Validation passed - continue</p>
<p>    return await next();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Registration</strong>:
<pre><code class="language-csharp">// Register validators
<p>builder.Services.AddValidatorsFromAssemblyContaining<CreateOrderValidator>();</p>

<p>// Register behavior</p>
<p>builder.Services.AddTransient(</p>
<p>  typeof(IPipelineBehavior<,>),</p>
<p>  typeof(ValidationBehavior<,>)</p>
<p>);</p>
<p></code></pre></p>

<h3>3. Retry Behavior</h3>

<pre><code class="language-csharp">using Polly;
<p>using Whizbang.Core.Pipeline;</p>

<p>public class RetryBehavior<TRequest, TResponse></p>
<p>  : IPipelineBehavior<TRequest, TResponse> {</p>

<p>  private readonly ILogger<RetryBehavior<TRequest, TResponse>> _logger;</p>

<p>  public RetryBehavior(ILogger<RetryBehavior<TRequest, TResponse>> logger) {</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task<TResponse> Handle(</p>
<p>    TRequest request,</p>
<p>    Func<Task<TResponse>> next,</p>
<p>    CancellationToken cancellationToken</p>
<p>  ) {</p>
<p>    // Define retry policy</p>
<p>    var retryPolicy = Policy</p>
<p>      .Handle<DbException>()  // Transient database failures</p>
<p>      .Or<HttpRequestException>()  // Transient HTTP failures</p>
<p>      .WaitAndRetryAsync(</p>
<p>        retryCount: 3,</p>
<p>        sleepDurationProvider: retryAttempt =></p>
<p>          TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),  // Exponential backoff</p>
<p>        onRetry: (exception, timeSpan, retryCount, context) => {</p>
<p>          _logger.LogWarning(</p>
<p>            exception,</p>
<p>            "Retry {RetryCount} for {RequestName} after {Delay}s",</p>
<p>            retryCount,</p>
<p>            typeof(TRequest).Name,</p>
<p>            timeSpan.TotalSeconds</p>
<p>          );</p>
<p>        }</p>
<p>      );</p>

<p>    // Execute with retry</p>
<p>    return await retryPolicy.ExecuteAsync(async () => await next());</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>4. Caching Behavior</h3>

<pre><code class="language-csharp">using Microsoft.Extensions.Caching.Memory;
<p>using Whizbang.Core.Pipeline;</p>

<p>public class CachingBehavior<TRequest, TResponse></p>
<p>  : IPipelineBehavior<TRequest, TResponse></p>
<p>  where TRequest : ICacheableQuery {  // Marker interface</p>

<p>  private readonly IMemoryCache _cache;</p>
<p>  private readonly ILogger<CachingBehavior<TRequest, TResponse>> _logger;</p>

<p>  public CachingBehavior(</p>
<p>    IMemoryCache cache,</p>
<p>    ILogger<CachingBehavior<TRequest, TResponse>> logger</p>
<p>  ) {</p>
<p>    _cache = cache;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task<TResponse> Handle(</p>
<p>    TRequest request,</p>
<p>    Func<Task<TResponse>> next,</p>
<p>    CancellationToken cancellationToken</p>
<p>  ) {</p>
<p>    var cacheKey = $"{typeof(TRequest).Name}:{request.GetCacheKey()}";</p>

<p>    // Check cache</p>
<p>    if (_cache.TryGetValue<TResponse>(cacheKey, out var cachedResponse)) {</p>
<p>      _logger.LogDebug("Cache hit for {CacheKey}", cacheKey);</p>
<p>      return cachedResponse!;</p>
<p>    }</p>

<p>    // Cache miss - execute handler</p>
<p>    _logger.LogDebug("Cache miss for {CacheKey}", cacheKey);</p>
<p>    var response = await next();</p>

<p>    // Store in cache</p>
<p>    var cacheOptions = new MemoryCacheEntryOptions {</p>
<p>      AbsoluteExpirationRelativeToNow = request.GetCacheDuration()</p>
<p>    };</p>

<p>    _cache.Set(cacheKey, response, cacheOptions);</p>
<p>    return response;</p>
<p>  }</p>
<p>}</p>

<p>// Marker interface for cacheable queries</p>
<p>public interface ICacheableQuery {</p>
<p>  string GetCacheKey();</p>
<p>  TimeSpan GetCacheDuration();</p>
<p>}</p>
<p></code></pre></p>

<h3>5. Performance Timing Behavior</h3>

<pre><code class="language-csharp">using System.Diagnostics;
<p>using Whizbang.Core.Pipeline;</p>

<p>public class PerformanceBehavior<TRequest, TResponse></p>
<p>  : IPipelineBehavior<TRequest, TResponse> {</p>

<p>  private readonly ILogger<PerformanceBehavior<TRequest, TResponse>> _logger;</p>

<p>  public PerformanceBehavior(ILogger<PerformanceBehavior<TRequest, TResponse>> logger) {</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task<TResponse> Handle(</p>
<p>    TRequest request,</p>
<p>    Func<Task<TResponse>> next,</p>
<p>    CancellationToken cancellationToken</p>
<p>  ) {</p>
<p>    var stopwatch = Stopwatch.StartNew();</p>

<p>    try {</p>
<p>      var response = await next();</p>
<p>      stopwatch.Stop();</p>

<p>      var elapsedMs = stopwatch.ElapsedMilliseconds;</p>
<p>      var requestName = typeof(TRequest).Name;</p>

<p>      if (elapsedMs > 500) {</p>
<p>        // Slow request warning</p>
<p>        _logger.LogWarning(</p>
<p>          "Slow request: {RequestName} took {ElapsedMs}ms",</p>
<p>          requestName,</p>
<p>          elapsedMs</p>
<p>        );</p>
<p>      } else {</p>
<p>        _logger.LogInformation(</p>
<p>          "{RequestName} completed in {ElapsedMs}ms",</p>
<p>          requestName,</p>
<p>          elapsedMs</p>
<p>        );</p>
<p>      }</p>

<p>      return response;</p>
<p>    } catch {</p>
<p>      stopwatch.Stop();</p>
<p>      throw;</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Registration and Ordering</h2>

<h3>Registration</h3>

<pre><code class="language-csharp">using Microsoft.Extensions.DependencyInjection;

<p>var builder = WebApplication.CreateBuilder(args);</p>

<p>// Behaviors execute in registration order</p>
<p>builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(LoggingBehavior<,>));       // 1st</p>
<p>builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(ValidationBehavior<,>));   // 2nd</p>
<p>builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(RetryBehavior<,>));        // 3rd</p>
<p>builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(PerformanceBehavior<,>));  // 4th</p>

<p>var app = builder.Build();</p>
<p></code></pre></p>

<strong>Execution Order</strong>:
<ul><li><strong>LoggingBehavior</strong> - Logs request</li>
<li><strong>ValidationBehavior</strong> - Validates request</li>
<li><strong>RetryBehavior</strong> - Wraps execution with retry</li>
<li><strong>PerformanceBehavior</strong> - Measures timing</li>
<li><strong>Receptor</strong> - Business logic</li>
</ul>
<h3>Conditional Registration</h3>

<pre><code class="language-csharp">// Only register in development
<p>if (builder.Environment.IsDevelopment()) {</p>
<p>  builder.Services.AddTransient(</p>
<p>    typeof(IPipelineBehavior<,>),</p>
<p>    typeof(DebugBehavior<,>)</p>
<p>  );</p>
<p>}</p>

<p>// Only register for specific message types</p>
<p>builder.Services.AddTransient<IPipelineBehavior<CreateOrder, OrderCreated>,</p>
<p>  OrderValidationBehavior>();</p>
<p></code></pre></p>

<hr>

<h2>Advanced Patterns</h2>

<h3>Short-Circuiting</h3>

<pre><code class="language-csharp">public class AuthorizationBehavior<TRequest, TResponse>
<p>  : IPipelineBehavior<TRequest, TResponse></p>
<p>  where TRequest : IAuthorizedRequest {</p>

<p>  private readonly IAuthorizationService _authService;</p>

<p>  public async Task<TResponse> Handle(</p>
<p>    TRequest request,</p>
<p>    Func<Task<TResponse>> next,</p>
<p>    CancellationToken cancellationToken</p>
<p>  ) {</p>
<p>    // Check authorization</p>
<p>    var isAuthorized = await _authService.IsAuthorizedAsync(</p>
<p>      request.UserId,</p>
<p>      request.RequiredPermission</p>
<p>    );</p>

<p>    if (!isAuthorized) {</p>
<p>      // Short-circuit - do NOT call next()</p>
<p>      throw new UnauthorizedAccessException(</p>
<p>        $"User {request.UserId} lacks permission {request.RequiredPermission}"</p>
<p>      );</p>
<p>    }</p>

<p>    // Authorized - continue</p>
<p>    return await next();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Response Modification</h3>

<pre><code class="language-csharp">public class EnrichmentBehavior<TRequest, TResponse>
<p>  : IPipelineBehavior<TRequest, TResponse></p>
<p>  where TResponse : IEnrichableResponse {</p>

<p>  private readonly IUserContextService _userContext;</p>

<p>  public async Task<TResponse> Handle(</p>
<p>    TRequest request,</p>
<p>    Func<Task<TResponse>> next,</p>
<p>    CancellationToken cancellationToken</p>
<p>  ) {</p>
<p>    // Execute handler</p>
<p>    var response = await next();</p>

<p>    // Modify response</p>
<p>    response.UserId = _userContext.GetCurrentUserId();</p>
<p>    response.Timestamp = DateTimeOffset.UtcNow;</p>

<p>    return response;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Transaction Management</h3>

<pre><code class="language-csharp">public class TransactionBehavior<TRequest, TResponse>
<p>  : IPipelineBehavior<TRequest, TResponse></p>
<p>  where TRequest : ITransactionalCommand {</p>

<p>  private readonly IDbConnectionFactory _connectionFactory;</p>

<p>  public async Task<TResponse> Handle(</p>
<p>    TRequest request,</p>
<p>    Func<Task<TResponse>> next,</p>
<p>    CancellationToken cancellationToken</p>
<p>  ) {</p>
<p>    using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);</p>
<p>    using var transaction = await connection.BeginTransactionAsync(cancellationToken);</p>

<p>    try {</p>
<p>      // Execute within transaction</p>
<p>      var response = await next();</p>

<p>      // Commit on success</p>
<p>      await transaction.CommitAsync(cancellationToken);</p>
<p>      return response;</p>
<p>    } catch {</p>
<p>      // Rollback on failure</p>
<p>      await transaction.RollbackAsync(cancellationToken);</p>
<p>      throw;</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Keep behaviors small and focused</strong> - Single responsibility</li>
<li>✅ <strong>Register in logical order</strong> (logging → validation → retry → handler)</li>
<li>✅ <strong>Use marker interfaces</strong> for conditional behaviors (ICacheableQuery)</li>
<li>✅ <strong>Always call next()</strong> unless intentionally short-circuiting</li>
<li>✅ <strong>Handle exceptions appropriately</strong> (log, wrap, or propagate)</li>
<li>✅ <strong>Use async/await consistently</strong> - Don't block</li>
<li>✅ <strong>Make behaviors reusable</strong> - Generic across message types</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Put business logic in behaviors (keep in receptors)</li>
<li>❌ Mutate request in behaviors (immutable messages)</li>
<li>❌ Forget to call next() (pipeline will hang)</li>
<li>❌ Swallow exceptions silently (breaks error handling)</li>
<li>❌ Register too many behaviors (keep pipeline lean)</li>
<li>❌ Use behaviors for message routing (use policies instead)</li>
</ul>
<hr>

<h2>Troubleshooting</h2>

<h3>Problem: Behavior Not Executing</h3>

<strong>Symptoms</strong>: Behavior code never runs.

<strong>Causes</strong>:
<ul><li>Not registered in DI</li>
<li>Wrong generic type registration</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-csharp">// ❌ WRONG: Concrete type registration
<p>builder.Services.AddTransient<LoggingBehavior<CreateOrder, OrderCreated>>();</p>

<p>// ✅ CORRECT: Open generic registration</p>
<p>builder.Services.AddTransient(</p>
<p>  typeof(IPipelineBehavior<,>),</p>
<p>  typeof(LoggingBehavior<,>)</p>
<p>);</p>
<p></code></pre></p>

<h3>Problem: Pipeline Hangs</h3>

<strong>Symptoms</strong>: Request never completes.

<strong>Cause</strong>: Behavior doesn't call <code>next()</code>.

<strong>Solution</strong>:
<pre><code class="language-csharp">// ❌ WRONG: Forgot to call next()
<p>public async Task<TResponse> Handle(TRequest request, Func<Task<TResponse>> next, ...) {</p>
<p>  _logger.LogInformation("Processing...");</p>
<p>  // Missing: await next()</p>
<p>  return default!;  // Never executes handler!</p>
<p>}</p>

<p>// ✅ CORRECT: Always call next()</p>
<p>public async Task<TResponse> Handle(TRequest request, Func<Task<TResponse>> next, ...) {</p>
<p>  _logger.LogInformation("Processing...");</p>
<p>  return await next();  // ⭐ Essential</p>
<p>}</p>
<p></code></pre></p>

<h3>Problem: Wrong Execution Order</h3>

<strong>Symptoms</strong>: Behaviors run in unexpected order.

<strong>Cause</strong>: Registration order determines execution order.

<strong>Solution</strong>:
<pre><code class="language-csharp">// Execution order = registration order
<p>builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(FirstBehavior<,>));   // Runs 1st</p>
<p>builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(SecondBehavior<,>));  // Runs 2nd</p>
<p>builder.Services.AddTransient(typeof(IPipelineBehavior<,>), typeof(ThirdBehavior<,>));   // Runs 3rd</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Extensibility</strong>:
<ul><li><a href="custom-receptors.md">Custom Receptors</a> - Advanced receptor patterns</li>
<li><a href="custom-policies.md">Custom Policies</a> - Dynamic routing logic</li>
</ul>
<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/receptors.md">Receptors</a> - Message handlers</li>
<li><a href="../core-concepts/dispatcher.md">Dispatcher</a> - Message routing</li>
</ul>
<strong>Infrastructure</strong>:
<ul><li><a href="../infrastructure/policies.md">Policies</a> - Policy-based routing</li>
</ul>
<strong>External Resources</strong>:
<ul><li><a href="https://github.com/jbogard/MediatR/wiki/Behaviors">MediatR Pipeline Behaviors</a></li>
<li><a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/">ASP.NET Core Middleware</a></li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-extensibility-plugin-architecture" class="doc-section">
  <h3>Plugin Architecture</h3>
  <p class="doc-path"><code>v1.0.0/extensibility/plugin-architecture</code></p>
  <p class="doc-description"><em>Design plugin systems - dynamic assembly loading, hot-reload, and extension points</em></p>
  <div class="doc-content">

<h1>Plugin Architecture</h1>

<strong>Plugin architectures</strong> enable dynamic extensibility through loadable assemblies, hot-reload capabilities, and well-defined extension points.

<p>:::note</p>
<p>This is an advanced topic for building extensible systems on top of Whizbang. Most applications don't need plugin capabilities.</p>
<p>:::</p>

<hr>

<h2>Why Plugin Architecture?</h2>

<p>| Scenario | Static Assembly | Plugin System |</p>
<p>|----------|----------------|---------------|</p>
<p>| <strong>Fixed Features</strong> | ✅ Simple | No need |</p>
<p>| <strong>Dynamic Extensions</strong> | ❌ Recompile required | ✅ Load at runtime |</p>
<p>| <strong>Hot-Reload</strong> | ❌ Restart required | ✅ Update without restart |</p>
<p>| <strong>3rd-Party Extensions</strong> | ❌ Code access needed | ✅ Interface-based |</p>

<strong>When to use plugins</strong>:
<ul><li>✅ Extensible platforms (like VS Code)</li>
<li>✅ Multi-tenant customizations</li>
<li>✅ Hot-reloadable features</li>
<li>✅ 3rd-party integrations</li>
</ul>
<hr>

<h2>Plugin Interface Pattern</h2>

<h3>Pattern 1: IPlugin Contract</h3>

<pre><code class="language-csharp">public interface IWhizbangPlugin {
<p>  string Name { get; }</p>
<p>  Version Version { get; }</p>

<p>  void Initialize(IServiceCollection services);</p>
<p>  void Configure(IApplicationBuilder app);</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern 2: Plugin Loader</h3>

<pre><code class="language-csharp">using System.Reflection;
<p>using System.Runtime.Loader;</p>

<p>public class PluginLoader {</p>
<p>  public IEnumerable<IWhizbangPlugin> LoadPlugins(string pluginDirectory) {</p>
<p>    var plugins = new List<IWhizbangPlugin>();</p>

<p>    foreach (var dllPath in Directory.GetFiles(pluginDirectory, "*.dll")) {</p>
<p>      var context = new AssemblyLoadContext(Path.GetFileName(dllPath), isCollectible: true);</p>
<p>      var assembly = context.LoadFromAssemblyPath(dllPath);</p>

<p>      foreach (var type in assembly.GetTypes()) {</p>
<p>        if (typeof(IWhizbangPlugin).IsAssignableFrom(type) && !type.IsInterface) {</p>
<p>          var plugin = (IWhizbangPlugin)Activator.CreateInstance(type)!;</p>
<p>          plugins.Add(plugin);</p>
<p>        }</p>
<p>      }</p>
<p>    }</p>

<p>    return plugins;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Extension Points</h2>

<h3>Pattern 3: Receptor Plugin</h3>

<pre><code class="language-csharp">// Plugin assembly
<p>public class CustomReceptorPlugin : IWhizbangPlugin {</p>
<p>  public string Name => "CustomReceptors";</p>
<p>  public Version Version => new(1, 0, 0);</p>

<p>  public void Initialize(IServiceCollection services) {</p>
<p>    services.AddTransient<IReceptor<CustomCommand, CustomEvent>, CustomReceptor>();</p>
<p>  }</p>

<p>  public void Configure(IApplicationBuilder app) {</p>
<p>    // No app configuration needed</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Hot-Reload Support</h2>

<h3>Pattern 4: Reloadable Plugins</h3>

<pre><code class="language-csharp">public class HotReloadPluginManager {
<p>  private readonly Dictionary<string, AssemblyLoadContext> _contexts = [];</p>
<p>  private FileSystemWatcher? _watcher;</p>

<p>  public void EnableHotReload(string pluginDirectory) {</p>
<p>    _watcher = new FileSystemWatcher(pluginDirectory, "*.dll");</p>
<p>    _watcher.Changed += (s, e) => ReloadPlugin(e.FullPath);</p>
<p>    _watcher.EnableRaisingEvents = true;</p>
<p>  }</p>

<p>  private void ReloadPlugin(string path) {</p>
<p>    var name = Path.GetFileName(path);</p>

<p>    // Unload existing</p>
<p>    if (_contexts.TryGetValue(name, out var oldContext)) {</p>
<p>      oldContext.Unload();</p>
<p>      _contexts.Remove(name);</p>
<p>    }</p>

<p>    // Load new version</p>
<p>    var newContext = new AssemblyLoadContext(name, isCollectible: true);</p>
<p>    newContext.LoadFromAssemblyPath(path);</p>
<p>    _contexts[name] = newContext;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Define clear interfaces</strong> for plugins</li>
<li>✅ <strong>Use AssemblyLoadContext</strong> for isolation</li>
<li>✅ <strong>Version plugin APIs</strong> carefully</li>
<li>✅ <strong>Validate plugins</strong> before loading</li>
<li>✅ <strong>Handle load failures</strong> gracefully</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Share state between plugins (isolation)</li>
<li>❌ Allow reflection-heavy plugins (breaks AOT)</li>
<li>❌ Skip versioning (compatibility issues)</li>
<li>❌ Load untrusted plugins (security risk)</li>
</ul>
<hr>

<h2>Further Reading</h2>

<strong>Extensibility</strong>:
<ul><li><a href="custom-receptors.md">Custom Receptors</a> - Receptor extension patterns</li>
<li><a href="custom-transports.md">Custom Transports</a> - Transport plugins</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Getting Started</h2>
<article id="v1-0-0-getting-started-installation" class="doc-section">
  <h3>Installation Guide</h3>
  <p class="doc-path"><code>v1.0.0/getting-started/installation</code></p>
  <p class="doc-description"><em>Install Whizbang and set up your first project with NuGet packages, project templates, and IDE configuration</em></p>
  <div class="doc-content">

<h1>Installation Guide</h1>

<p>This guide walks you through installing Whizbang and setting up your first project.</p>

<h2>Prerequisites</h2>

<p>Before installing Whizbang, ensure you have:</p>

<h3>Required</h3>

<ul><li><strong>.NET 10.0 SDK</strong> (RC2 or later)</li>
</ul><p>  <pre><code class="language-bash">  dotnet --version</p>
<p>  # Should show 10.0.0 or later</p>
<p>  </code></pre></p>

<ul><li><strong>C# 13</strong> language support (included with .NET 10 SDK)</li>
</ul>
<h3>Recommended</h3>

<ul><li><strong>Visual Studio 2024</strong> (17.12+) or <strong>Visual Studio Code</strong> with C# Dev Kit</li>
<li><strong>Docker Desktop</strong> (for PostgreSQL and Azure Service Bus Emulator)</li>
<li><strong>.NET Aspire Workload</strong> (for orchestration):</li>
</ul><p>  <pre><code class="language-bash">  dotnet workload install aspire</p>
<p>  </code></pre></p>

<h2>Installation Options</h2>

<h3>Option 1: NuGet Packages (Recommended)</h3>

<p>Install Whizbang packages for your specific needs:</p>

<h4>Core Package</h4>

<pre><code class="language-bash">dotnet add package Whizbang.Core
<p></code></pre></p>

<strong>Includes</strong>:
<ul><li>Core interfaces (<code>IDispatcher</code>, <code>IReceptor</code>, <code>IPerspectiveOf</code>)</li>
<li>Message envelope and observability</li>
<li>Object pooling for performance</li>
<li>Policy engine foundation</li>
</ul>
<h4>Data Access Packages</h4>

<strong>Dapper + PostgreSQL</strong> (lightweight, fast):
<pre><code class="language-bash">dotnet add package Whizbang.Data.Dapper.Postgres
<p></code></pre></p>

<strong>EF Core + PostgreSQL</strong> (full-featured):
<pre><code class="language-bash">dotnet add package Whizbang.Data.EFCore.Postgres
<p>dotnet add package Whizbang.Data.EFCore.Postgres.Generators</p>
<p></code></pre></p>

<strong>SQLite</strong> (development/testing):
<pre><code class="language-bash">dotnet add package Whizbang.Data.Dapper.Sqlite
<p></code></pre></p>

<h4>Transport Packages</h4>

<strong>Azure Service Bus</strong>:
<pre><code class="language-bash">dotnet add package Whizbang.Transports.AzureServiceBus
<p>dotnet add package Whizbang.Hosting.Azure.ServiceBus</p>
<p></code></pre></p>

<h4>Source Generators</h4>

<strong>Automatic Discovery</strong>:
<pre><code class="language-bash">dotnet add package Whizbang.Generators
<p></code></pre></p>

<strong>Includes</strong>:
<ul><li>Receptor discovery and registration</li>
<li>Perspective discovery</li>
<li>Message registry generation (VSCode extension)</li>
<li>Aggregate ID generation</li>
<li>AOT-compatible JSON contexts</li>
</ul>
<h3>Option 2: Package Bundle</h3>

<p>For complete functionality, add all packages:</p>

<pre><code class="language-xml"><!-- YourProject.csproj -->
<p><ItemGroup></p>
<p>  <PackageReference Include="Whizbang.Core" Version="0.1.0" /></p>
<p>  <PackageReference Include="Whizbang.Generators" Version="0.1.0" /></p>
<p>  <PackageReference Include="Whizbang.Data.Dapper.Postgres" Version="0.1.0" /></p>
<p>  <PackageReference Include="Whizbang.Transports.AzureServiceBus" Version="0.1.0" /></p>
<p>  <PackageReference Include="Whizbang.Hosting.Azure.ServiceBus" Version="0.1.0" /></p>
<p></ItemGroup></p>
<p></code></pre></p>

<h3>Option 3: Central Package Management (Recommended for Solutions)</h3>

<p>Use <code>Directory.Packages.props</code> for version management:</p>

<pre><code class="language-xml"><!-- Directory.Packages.props -->
<p><Project></p>
<p>  <PropertyGroup></p>
<p>    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally></p>
<p>  </PropertyGroup></p>

<p>  <ItemGroup></p>
<p>    <!-- Whizbang Packages --></p>
<p>    <PackageVersion Include="Whizbang.Core" Version="0.1.0" /></p>
<p>    <PackageVersion Include="Whizbang.Generators" Version="0.1.0" /></p>
<p>    <PackageVersion Include="Whizbang.Data.Dapper.Postgres" Version="0.1.0" /></p>
<p>    <PackageVersion Include="Whizbang.Data.EFCore.Postgres" Version="0.1.0" /></p>
<p>    <PackageVersion Include="Whizbang.Data.EFCore.Postgres.Generators" Version="0.1.0" /></p>
<p>    <PackageVersion Include="Whizbang.Transports.AzureServiceBus" Version="0.1.0" /></p>
<p>    <PackageVersion Include="Whizbang.Hosting.Azure.ServiceBus" Version="0.1.0" /></p>
<p>  </ItemGroup></p>
<p></Project></p>
<p></code></pre></p>

<p>Then in project files:</p>

<pre><code class="language-xml"><!-- YourProject.csproj -->
<p><ItemGroup></p>
<p>  <PackageReference Include="Whizbang.Core" /></p>
<p>  <PackageReference Include="Whizbang.Generators" /></p>
<p>  <!-- Versions come from Directory.Packages.props --></p>
<p></ItemGroup></p>
<p></code></pre></p>

<h2>Project Setup</h2>

<h3>1. Create New Project</h3>

<pre><code class="language-bash"># Create solution
<p>dotnet new sln -n MyWhizbangApp</p>

<h1>Create ASP.NET Core Web API project</h1>
<p>dotnet new webapi -n MyWhizbangApp.API</p>
<p>dotnet sln add MyWhizbangApp.API</p>

<h1>Add Whizbang packages</h1>
<p>cd MyWhizbangApp.API</p>
<p>dotnet add package Whizbang.Core</p>
<p>dotnet add package Whizbang.Generators</p>
<p>dotnet add package Whizbang.Data.Dapper.Postgres</p>
<p></code></pre></p>

<h3>2. Configure Target Framework</h3>

<p>Ensure your project targets .NET 10:</p>

<pre><code class="language-xml"><!-- MyWhizbangApp.API.csproj -->
<p><Project Sdk="Microsoft.NET.Sdk.Web"></p>
<p>  <PropertyGroup></p>
<p>    <TargetFramework>net10.0</TargetFramework></p>
<p>    <Nullable>enable</Nullable></p>
<p>    <ImplicitUsings>enable</ImplicitUsings></p>
<p>    <LangVersion>13</LangVersion> <!-- C# 13 for latest features --></p>
<p>  </PropertyGroup></p>
<p></Project></p>
<p></code></pre></p>

<h3>3. Add Directory.Build.props (Optional but Recommended)</h3>

<p>Create solution-level build configuration:</p>

<pre><code class="language-xml"><!-- Directory.Build.props -->
<p><Project></p>
<p>  <PropertyGroup></p>
<p>    <TargetFramework>net10.0</TargetFramework></p>
<p>    <LangVersion>13</LangVersion></p>
<p>    <Nullable>enable</Nullable></p>
<p>    <ImplicitUsings>enable</ImplicitUsings></p>
<p>    <TreatWarningsAsErrors>true</TreatWarningsAsErrors></p>
<p>  </PropertyGroup></p>

<p>  <PropertyGroup></p>
<p>    <!-- Source Generator Settings --></p>
<p>    <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles></p>
<p>    <CompilerGeneratedFilesOutputPath>$(MSBuildProjectDirectory)/.whizbang-generated</CompilerGeneratedFilesOutputPath></p>
<p>  </PropertyGroup></p>
<p></Project></p>
<p></code></pre></p>

<h3>4. Configure .editorconfig (K&R/Egyptian Braces)</h3>

<p>Whizbang follows K&R/Egyptian braces style:</p>

<pre><code class="language-ini"># .editorconfig
<p>root = true</p>

<p>[*.cs]</p>
<h1>Brace style - K&R/Egyptian (opening brace on same line)</h1>
<p>csharp_new_line_before_open_brace = none</p>
<p>csharp_new_line_before_else = false</p>
<p>csharp_new_line_before_catch = false</p>
<p>csharp_new_line_before_finally = false</p>

<h1>Indentation</h1>
<p>indent_style = space</p>
<p>indent_size = 4</p>

<h1>Naming conventions</h1>
<p>dotnet_naming_rule.async_methods_end_in_async.severity = warning</p>
<p>dotnet_naming_rule.async_methods_end_in_async.symbols = async_methods</p>
<p>dotnet_naming_rule.async_methods_end_in_async.style = end_in_async</p>

<p>dotnet_naming_symbols.async_methods.applicable_kinds = method</p>
<p>dotnet_naming_symbols.async_methods.required_modifiers = async</p>

<p>dotnet_naming_style.end_in_async.required_suffix = Async</p>
<p>dotnet_naming_style.end_in_async.capitalization = pascal_case</p>
<p></code></pre></p>

<h2>Database Setup</h2>

<h3>PostgreSQL (Recommended for Production)</h3>

<h4>Option A: Docker (Easiest)</h4>

<pre><code class="language-bash">docker run -d \
<p>  --name whizbang-postgres \</p>
<p>  -e POSTGRES_PASSWORD=your_password \</p>
<p>  -e POSTGRES_USER=whizbang \</p>
<p>  -e POSTGRES_DB=whizbang \</p>
<p>  -p 5432:5432 \</p>
<p>  postgres:16</p>
<p></code></pre></p>

<h4>Option B: .NET Aspire (Automatic)</h4>

<p>With Aspire, PostgreSQL starts automatically:</p>

<pre><code class="language-csharp">// AppHost/Program.cs
<p>var builder = DistributedApplication.CreateBuilder(args);</p>

<p>var postgres = builder.AddPostgres("postgres")</p>
<p>    .WithPgAdmin()</p>
<p>    .AddDatabase("whizbangdb");</p>

<p>var api = builder.AddProject<Projects.MyWhizbangApp_API>("api")</p>
<p>    .WithReference(postgres);</p>

<p>builder.Build().Run();</p>
<p></code></pre></p>

<h3>Connection String Configuration</h3>

<strong>appsettings.Development.json</strong>:
<pre><code class="language-json">{
<p>  "ConnectionStrings": {</p>
<p>    "DefaultConnection": "Host=localhost;Database=whizbang;Username=whizbang;Password=your_password"</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>IDE Configuration</h2>

<h3>Visual Studio 2024</h3>

<ul><li><strong>Install .NET 10 SDK</strong> (included with VS 2024 17.12+)</li>
<li><strong>Enable Source Generators</strong>:</li>
</ul><p>   - Tools → Options → Text Editor → C# → Advanced</p>
<p>   - Check "Enable source generators"</p>
<ul><li><strong>View Generated Files</strong>:</li>
</ul><p>   - Solution Explorer → Show All Files</p>
<p>   - Expand <code>.whizbang-generated/</code> folder</p>

<h3>Visual Studio Code</h3>

<ul><li><strong>Install Extensions</strong>:</li>
</ul><p>   <pre><code class="language-bash">   code --install-extension ms-dotnettools.csdevkit</p>
<p>   code --install-extension ms-dotnettools.csharp</p>
<p>   </code></pre></p>

<ul><li><strong>Configure settings.json</strong>:</li>
</ul><p>   <pre><code class="language-json">   {</p>
<p>     "dotnet.testWindow.useTestingPlatformProtocol": true,</p>
<p>     "omnisharp.enableRoslynAnalyzers": true,</p>
<p>     "omnisharp.enableEditorConfigSupport": true</p>
<p>   }</p>
<p>   </code></pre></p>

<ul><li><strong>Install Whizbang VSCode Extension</strong> (Optional):</li>
</ul><p>   - Provides CodeLens annotations</p>
<p>   - Message flow visualization</p>
<p>   - Jump-to-definition for handlers</p>

<h3>JetBrains Rider</h3>

<ul><li><strong>Enable Source Generators</strong>:</li>
</ul><p>   - Settings → Build, Execution, Deployment → Toolset and Build</p>
<p>   - Check "Enable source generators"</p>

<ul><li><strong>Configure NuGet Sources</strong>:</li>
</ul><p>   - Settings → NuGet → Sources</p>
<p>   - Add nuget.org if not present</p>

<h2>Verify Installation</h2>

<h3>1. Build Project</h3>

<pre><code class="language-bash">dotnet build
<p></code></pre></p>

<strong>Expected output</strong>:
<pre><code class="language-">Build succeeded.
<p>    0 Warning(s)</p>
<p>    0 Error(s)</p>
<p></code></pre></p>

<h3>2. Check Source Generators</h3>

<pre><code class="language-bash">ls .whizbang-generated/
<p></code></pre></p>

<strong>Expected files</strong> (after adding receptors):
<pre><code class="language-">Whizbang.Generators/
<p>├── ReceptorDiscoveryGenerator/</p>
<p>│   └── ReceptorRegistrations.g.cs</p>
<p>├── PerspectiveDiscoveryGenerator/</p>
<p>│   └── PerspectiveRegistrations.g.cs</p>
<p>└── MessageRegistryGenerator/</p>
<p>    └── MessageRegistry.g.cs</p>
<p></code></pre></p>

<h3>3. Run Tests (if added)</h3>

<pre><code class="language-bash">dotnet test
<p></code></pre></p>

<h2>Troubleshooting</h2>

<h3>Issue: Source Generators Not Running</h3>

<strong>Symptoms</strong>: No files in <code>.whizbang-generated/</code>

<strong>Solutions</strong>:
<ul><li>Rebuild solution: <code>dotnet clean && dotnet build</code></li>
<li>Check generator package is referenced:</li>
</ul><p>   <pre><code class="language-bash">   dotnet list package | grep Whizbang.Generators</p>
<p>   </code></pre></p>
<ul><li>Enable verbose MSBuild output:</li>
</ul><p>   <pre><code class="language-bash">   dotnet build -v:detailed | grep Whizbang</p>
<p>   </code></pre></p>

<h3>Issue: "Type 'IReceptor' Not Found"</h3>

<strong>Symptoms</strong>: Cannot resolve Whizbang types

<strong>Solutions</strong>:
<ul><li>Verify package installation:</li>
</ul><p>   <pre><code class="language-bash">   dotnet restore</p>
<p>   dotnet list package</p>
<p>   </code></pre></p>
<ul><li>Check target framework is net10.0</li>
<li>Add using directive:</li>
</ul><p>   <pre><code class="language-csharp">   using Whizbang.Core;</p>
<p>   </code></pre></p>

<h3>Issue: PostgreSQL Connection Fails</h3>

<strong>Symptoms</strong>: "Connection refused" or timeout errors

<strong>Solutions</strong>:
<ul><li>Check PostgreSQL is running:</li>
</ul><p>   <pre><code class="language-bash">   docker ps | grep postgres</p>
<p>   </code></pre></p>
<ul><li>Test connection:</li>
</ul><p>   <pre><code class="language-bash">   psql -h localhost -U whizbang -d whizbang</p>
<p>   </code></pre></p>
<ul><li>Verify connection string in appsettings.json</li>
</ul>
<h3>Issue: Native AOT Warnings</h3>

<strong>Symptoms</strong>: Trimming warnings during publish

<strong>Solutions</strong>:
<ul><li>Whizbang is trimming-safe by design</li>
<li>Ensure all JSON contexts are generated:</li>
</ul><p>   <pre><code class="language-csharp">   [JsonSerializable(typeof(YourMessage))]</p>
<p>   partial class YourJsonContext : JsonSerializerContext { }</p>
<p>   </code></pre></p>
<ul><li>Use Whizbang.Generators to auto-generate contexts</li>
</ul>
<h2>Next Steps</h2>

<p>✅ <strong>Installation Complete!</strong></p>

<strong>What's Next?</strong>

<ul><li><strong><a href="quick-start.md">Quick Start Tutorial</a></strong> - Build your first Whizbang app</li>
<li><strong><a href="project-structure.md">Project Structure Guide</a></strong> - Organize your application</li>
<li><strong><a href="../core-concepts/receptors.md">Core Concepts: Receptors</a></strong> - Understand message handling</li>
</ul>
<h2>Additional Resources</h2>

<ul><li><strong>Sample Projects</strong>: <code>/samples/ECommerce</code> in the Whizbang repository</li>
<li><strong>Package Documentation</strong>: https://nuget.org/packages/Whizbang.Core</li>
<li><strong>GitHub Issues</strong>: https://github.com/whizbang-lib/whizbang/issues</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-getting-started-introduction" class="doc-section">
  <h3>Introduction to Whizbang</h3>
  <p class="doc-path"><code>v1.0.0/getting-started/introduction</code></p>
  <p class="doc-description"><em>Learn about Whizbang - a zero-reflection, AOT-compatible .NET library for building event-driven, CQRS, and event-sourced applications</em></p>
  <div class="doc-content">

<h1>Introduction to Whizbang</h1>

<p>Whizbang is a comprehensive .NET library for building event-driven, CQRS, and event-sourced applications with <strong>zero reflection</strong> and <strong>native AOT compatibility</strong> from day one.</p>

<h2>What is Whizbang?</h2>

<p>Whizbang provides a complete foundation for building modern, scalable applications using message-driven architecture patterns. Unlike traditional frameworks that rely on runtime reflection, Whizbang uses <strong>source generators</strong> to discover and wire up your application components at compile time, resulting in:</p>

<ul><li><strong>Blazing Performance</strong>: < 20ns in-process message dispatch with zero allocations</li>
<li><strong>AOT Ready</strong>: Full Native AOT support with no runtime surprises</li>
<li><strong>Type Safety</strong>: Compile-time verification of message handlers and routing</li>
<li><strong>Developer Experience</strong>: Rich IDE support with code navigation and discovery</li>
</ul>
<h2>Philosophy</h2>

<h3>Zero Reflection</h3>

<p>Every feature in Whizbang is built without runtime reflection:</p>

<pre><code class="language-csharp">// Source generators discover this at compile time
<p>public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken cancellationToken = default) {</p>

<p>        // Business logic here</p>
<p>        return new OrderCreated(OrderId: Guid.CreateVersion7(), /<em> ... </em>/);</p>
<p>    }</p>
<p>}</p>

<p>// Generated dispatcher code - no reflection!</p>
<p>// Routes messages at compile time with optimal performance</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>Native AOT deployment out of the box</li>
<li>Predictable performance (no reflection overhead)</li>
<li>Compile-time safety (broken handlers = compiler errors)</li>
<li>Faster startup times</li>
</ul>
<h3>Type-Safe Messaging</h3>

<p>Whizbang enforces type safety at compile time:</p>

<pre><code class="language-csharp">// Compiler knows CreateOrder → OrderCreated
<p>var result = await dispatcher.LocalInvokeAsync<CreateOrder, OrderCreated>(command);</p>

<p>// Type mismatch? Compiler error!</p>
<p>// var wrong = await dispatcher.LocalInvokeAsync<CreateOrder, PaymentProcessed>(command); // ❌</p>
<p></code></pre></p>

<h3>Event-Driven Architecture</h3>

<p>Built around three core patterns:</p>

<ul><li><strong>Receptors</strong>: Stateless message handlers that make decisions</li>
<li><strong>Perspectives</strong>: Event listeners that maintain read models</li>
<li><strong>Lenses</strong>: Query interfaces for optimized data access</li>
</ul>
<pre><code class="language-csharp">// Receptor: Receives command, produces event
<p>public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> { }</p>

<p>// Perspective: Listens to events, updates read model</p>
<p>public class OrderSummaryPerspective : IPerspectiveOf<OrderCreated> { }</p>

<p>// Lens: Query interface for read model</p>
<p>public class OrderLens : ILensQuery { }</p>
<p></code></pre></p>

<h2>Core Concepts (Quick Overview)</h2>

<h3>Dispatcher</h3>

<p>Central message router with three dispatch patterns:</p>

<pre><code class="language-csharp">// SendAsync: Command dispatch with delivery receipt (can work over wire)
<p>var receipt = await dispatcher.SendAsync(new CreateOrder(/<em> ... </em>/));</p>

<p>// LocalInvokeAsync: In-process RPC with typed result (< 20ns, zero allocation)</p>
<p>var result = await dispatcher.LocalInvokeAsync<CreateOrder, OrderCreated>(command);</p>

<p>// PublishAsync: Event broadcasting (fire-and-forget)</p>
<p>await dispatcher.PublishAsync(@event);</p>
<p></code></pre></p>

<h3>Receptors</h3>

<p>Stateless message handlers:</p>

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken cancellationToken = default) {</p>

<p>        // Validate</p>
<p>        if (message.Items.Count == 0) {</p>
<p>            throw new InvalidOperationException("Order must have items");</p>
<p>        }</p>

<p>        // Make decision, return event</p>
<p>        return new OrderCreated(</p>
<p>            OrderId: Guid.CreateVersion7(),</p>
<p>            CustomerId: message.CustomerId,</p>
<p>            Items: message.Items,</p>
<p>            Total: message.Items.Sum(i => i.Quantity * i.Price),</p>
<p>            CreatedAt: DateTimeOffset.UtcNow</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Perspectives</h3>

<p>Event-driven read model updates:</p>

<pre><code class="language-csharp">public class OrderSummaryPerspective : IPerspectiveOf<OrderCreated> {
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public async Task Update(OrderCreated @event, CancellationToken ct = default) {</p>
<p>        // Update denormalized read model</p>
<p>        await using var conn = _db.CreateConnection();</p>
<p>        await conn.ExecuteAsync(</p>
<p>            "INSERT INTO order_summaries (order_id, customer_id, total, status, created_at) VALUES (@OrderId, @CustomerId, @Total, @Status, @CreatedAt)",</p>
<p>            new {</p>
<p>                @event.OrderId,</p>
<p>                @event.CustomerId,</p>
<p>                @event.Total,</p>
<p>                Status = "Created",</p>
<p>                @event.CreatedAt</p>
<p>            }</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Lenses</h3>

<p>Query-optimized read repositories:</p>

<pre><code class="language-csharp">public class OrderLens : ILensQuery {
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public async Task<OrderSummary?> GetOrderAsync(Guid orderId) {</p>
<p>        await using var conn = _db.CreateConnection();</p>
<p>        return await conn.QuerySingleOrDefaultAsync<OrderSummary>(</p>
<p>            "SELECT * FROM order_summaries WHERE order_id = @OrderId",</p>
<p>            new { OrderId = orderId }</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Technology Stack (v1.0.0)</h2>

<p>Whizbang is built on modern .NET:</p>

<p>| Technology | Version | Purpose |</p>
<p>|------------|---------|---------|</p>
<p>| .NET | 10.0 | Target framework (RC2+) |</p>
<p>| Source Generators | Roslyn 4.8+ | Compile-time discovery |</p>
<p>| Vogen | 8.0+ | Strongly-typed IDs |</p>
<p>| Dapper | Latest | Lightweight data access |</p>
<p>| EF Core | 10.0 | Full-featured ORM option |</p>
<p>| Azure Service Bus | Latest | Message transport |</p>
<p>| PostgreSQL | 16+ | Primary database |</p>
<p>| .NET Aspire | Latest | Orchestration & observability |</p>

<h2>Project Structure (15 Library Projects)</h2>

<pre><code class="language-">whizbang/
<p>├── src/</p>
<p>│   ├── Whizbang.Core/                          # Core interfaces, dispatcher, pooling</p>
<p>│   ├── Whizbang.Generators/                    # Source generators (discovery)</p>
<p>│   ├── Whizbang.Generators.Shared/             # Shared generator utilities</p>
<p>│   ├── Whizbang.Data.Dapper.Postgres/          # Dapper + PostgreSQL</p>
<p>│   ├── Whizbang.Data.Dapper.Sqlite/            # Dapper + SQLite</p>
<p>│   ├── Whizbang.Data.Dapper.Custom/            # Dapper base classes</p>
<p>│   ├── Whizbang.Data.EFCore.Postgres/          # EF Core + PostgreSQL</p>
<p>│   ├── Whizbang.Data.EFCore.Postgres.Generators/ # EF Core generators</p>
<p>│   ├── Whizbang.Data.EFCore.Custom/            # EF Core attributes</p>
<p>│   ├── Whizbang.Data.Postgres/                 # PostgreSQL utilities</p>
<p>│   ├── Whizbang.Data.Schema/                   # Schema definition</p>
<p>│   ├── Whizbang.Transports.AzureServiceBus/    # Azure Service Bus transport</p>
<p>│   ├── Whizbang.Hosting.Azure.ServiceBus/      # Hosting extensions</p>
<p>│   └── Whizbang.Testing/                       # Testing utilities</p>
<p>└── samples/</p>
<p>    └── ECommerce/                               # 12-project production sample</p>
<p></code></pre></p>

<h2>Key Features (v1.0.0)</h2>

<h3>Messaging Patterns</h3>

<ul><li>✅ <strong>Outbox Pattern</strong>: Reliable cross-service event publishing</li>
<li>✅ <strong>Inbox Pattern</strong>: Exactly-once message processing with deduplication</li>
<li>✅ <strong>Work Coordination</strong>: Atomic batch processing with lease-based distribution</li>
<li>✅ <strong>Message Envelopes</strong>: Hop-based observability for distributed tracing</li>
</ul>
<h3>Data Access</h3>

<ul><li>✅ <strong>Dapper Integration</strong>: Lightweight, high-performance SQL</li>
<li>✅ <strong>EF Core Integration</strong>: Full-featured ORM with code-first migrations</li>
<li>✅ <strong>Perspective Storage</strong>: Optimized read model management</li>
<li>✅ <strong>Event Store</strong>: Append-only event storage with PostgreSQL</li>
</ul>
<h3>Source Generators</h3>

<ul><li>✅ <strong>Receptor Discovery</strong>: Automatic handler registration</li>
<li>✅ <strong>Perspective Discovery</strong>: Event listener wiring</li>
<li>✅ <strong>Message Registry</strong>: VSCode extension integration</li>
<li>✅ <strong>Aggregate IDs</strong>: Strongly-typed identity generation</li>
<li>✅ <strong>JSON Contexts</strong>: AOT-compatible serialization</li>
</ul>
<h3>Infrastructure</h3>

<ul><li>✅ <strong>.NET Aspire</strong>: Automatic orchestration and service discovery</li>
<li>✅ <strong>Health Checks</strong>: Database and message transport readiness</li>
<li>✅ <strong>Object Pooling</strong>: Zero-allocation performance patterns</li>
<li>✅ <strong>Policy Engine</strong>: Decision trails and cross-cutting concerns</li>
</ul>
<h3>Transports</h3>

<ul><li>✅ <strong>Azure Service Bus</strong>: Production-ready message transport</li>
<li>✅ <strong>In-Memory</strong>: Fast testing and development</li>
</ul>
<h2>Real-World Example: ECommerce Sample</h2>

<p>Whizbang includes a complete <strong>12-project production sample</strong> demonstrating:</p>

<ul><li><strong>Backend for Frontend (BFF)</strong> with SignalR real-time updates</li>
<li><strong>Microservices</strong> (Order, Inventory, Payment, Shipping, Notification)</li>
<li><strong>Angular 20 UI</strong> with NgRx state management</li>
<li><strong>Event-driven workflows</strong> with Outbox/Inbox patterns</li>
<li><strong>.NET Aspire orchestration</strong> for local development</li>
<li><strong>Integration testing</strong> with TUnit</li>
</ul>
<strong>Services</strong>:
<ul><li><code>ECommerce.BFF.API</code> - Backend for Frontend (perspectives + lenses + SignalR)</li>
<li><code>ECommerce.OrderService.API</code> - REST + GraphQL order management</li>
<li><code>ECommerce.InventoryWorker</code> - Inventory reservation</li>
<li><code>ECommerce.PaymentWorker</code> - Payment processing</li>
<li><code>ECommerce.ShippingWorker</code> - Fulfillment coordination</li>
<li><code>ECommerce.NotificationWorker</code> - Cross-cutting notifications</li>
<li><code>ECommerce.UI</code> - Angular 20 application</li>
</ul>
<p>See <a href="../examples/ecommerce/overview.md">ECommerce Tutorial</a> for complete walkthrough.</p>

<h2>When to Use Whizbang</h2>

<h3>Perfect For</h3>

<p>✅ <strong>Event-Driven Applications</strong>: Microservices, event sourcing, CQRS</p>
<p>✅ <strong>High-Performance Systems</strong>: Need < 20ns in-process dispatch</p>
<p>✅ <strong>Native AOT Deployment</strong>: Cloud-native, serverless, edge computing</p>
<p>✅ <strong>Type-Safe Messaging</strong>: Compile-time verification required</p>
<p>✅ <strong>Complex Workflows</strong>: Order processing, sagas, distributed transactions</p>
<p>✅ <strong>Real-Time Systems</strong>: SignalR integration for live updates</p>

<h3>Consider Alternatives If</h3>

<p>❌ <strong>Simple CRUD</strong>: Whizbang is overkill for basic data entry apps</p>
<p>❌ <strong>No Messaging Needs</strong>: Traditional MVC/Razor Pages may be simpler</p>
<p>❌ <strong>Learning Curve</strong>: Team unfamiliar with event-driven patterns</p>
<p>❌ <strong>Rapid Prototyping</strong>: Source generators add compile-time overhead</p>

<h2>Performance Characteristics</h2>

<p>| Operation | Target | Description |</p>
<p>|-----------|--------|-------------|</p>
<p>| LocalInvoke | < 20ns | In-process receptor invocation (zero allocation) |</p>
<p>| SendAsync | < 100μs | Outbox write + receipt generation |</p>
<p>| Perspective Update | < 50μs | Read model update via Dapper |</p>
<p>| Lens Query | < 10μs | Dapper query execution |</p>
<p>| Source Generation | < 500ms | Full rebuild with all generators |</p>

<h2>Learning Path</h2>

<h3>Beginner</h3>

<ul><li><a href="installation.md">Installation</a> - Set up your first project</li>
<li><a href="quick-start.md">Quick Start</a> - Hello World with Receptors + Dispatcher</li>
<li><a href="project-structure.md">Project Structure</a> - Organize your application</li>
<li><a href="../core-concepts/receptors.md">Core Concepts: Receptors</a> - Understand message handling</li>
<li><a href="../core-concepts/dispatcher.md">Core Concepts: Dispatcher</a> - Master message routing</li>
</ul>
<h3>Intermediate</h3>

<ul><li><a href="../core-concepts/perspectives.md">Perspectives</a> - Build read models</li>
<li><a href="../core-concepts/lenses.md">Lenses</a> - Query optimization</li>
<li><a href="../messaging/outbox-pattern.md">Outbox Pattern</a> - Reliable messaging</li>
<li><a href="../messaging/inbox-pattern.md">Inbox Pattern</a> - Exactly-once processing</li>
<li><a href="../examples/ecommerce/overview.md">ECommerce Sample</a> - Production patterns</li>
</ul>
<h3>Advanced</h3>

<ul><li><a href="../generators/receptor-discovery.md">Source Generators</a> - Understand code generation</li>
<li><a href="../extensibility/overview.md">Extensibility</a> - Custom implementations</li>
<li><a href="../performance/pooling-strategies.md">Performance Tuning</a> - Optimize for scale</li>
<li><a href="../deployment/aspire-production.md">Deployment</a> - Production deployment</li>
</ul>
<h2>Next Steps</h2>

<p>Ready to get started?</p>

<p>→ <strong><a href="installation.md">Installation Guide</a></strong> - Install Whizbang and create your first project</p>

<p>→ <strong><a href="quick-start.md">Quick Start Tutorial</a></strong> - Build a working app in 10 minutes</p>

<p>→ <strong><a href="../examples/ecommerce/overview.md">ECommerce Sample</a></strong> - Explore a production-ready example</p>

<h2>Community & Support</h2>

<ul><li><strong>Documentation</strong>: https://whizbang-lib.github.io</li>
<li><strong>Source Code</strong>: https://github.com/whizbang-lib/whizbang</li>
<li><strong>Issues</strong>: https://github.com/whizbang-lib/whizbang/issues</li>
<li><strong>Samples</strong>: https://github.com/whizbang-lib/whizbang/tree/main/samples</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-getting-started-project-structure" class="doc-section">
  <h3>Project Structure Guide</h3>
  <p class="doc-path"><code>v1.0.0/getting-started/project-structure</code></p>
  <p class="doc-description"><em>Organize your Whizbang application with recommended project structures, separation of concerns, and multi-service architectures</em></p>
  <div class="doc-content">

<h1>Project Structure Guide</h1>

<p>This guide shows recommended project structures for Whizbang applications, from simple single-project apps to complex multi-service architectures.</p>

<h2>Quick Reference</h2>

<p>| Architecture | When to Use | Example |</p>
<p>|--------------|-------------|---------|</p>
<p>| <a href="#single-project-structure">Single Project</a> | Simple apps, prototypes, learning | Todo app, simple API |</p>
<p>| <a href="#clean-architecture-structure">Clean Architecture</a> | Medium apps, clear boundaries | E-commerce site, CRM |</p>
<p>| <a href="#microservices-structure">Microservices</a> | Distributed systems, team scaling | Multi-tenant SaaS, complex domains |</p>

<h2>Core Principles</h2>

<p>Regardless of project size, follow these principles:</p>

<ul><li><strong>Separate Messages from Logic</strong> - Commands/Events in dedicated projects</li>
<li><strong>Stateless Receptors</strong> - No state in message handlers</li>
<li><strong>Read Model Isolation</strong> - Perspectives maintain their own data</li>
<li><strong>Explicit Dependencies</strong> - Clear project references, no circular dependencies</li>
<li><strong>Configuration by Environment</strong> - appsettings.{Environment}.json pattern</li>
</ul>
<hr>

<h2>Single Project Structure</h2>

<strong>Best for</strong>: Learning, prototypes, simple APIs (< 10 message types)

<pre><code class="language-">MyApp/
<p>├── MyApp.API/                          # Single ASP.NET Core project</p>
<p>│   ├── Program.cs                      # DI configuration + app setup</p>
<p>│   ├── appsettings.json</p>
<p>│   ├── appsettings.Development.json</p>
<p>│   │</p>
<p>│   ├── Messages/                       # Commands and Events</p>
<p>│   │   ├── Commands/</p>
<p>│   │   │   ├── CreateOrder.cs</p>
<p>│   │   │   └── CancelOrder.cs</p>
<p>│   │   └── Events/</p>
<p>│   │       ├── OrderCreated.cs</p>
<p>│   │       └── OrderCancelled.cs</p>
<p>│   │</p>
<p>│   ├── Receptors/                      # Message handlers</p>
<p>│   │   ├── CreateOrderReceptor.cs</p>
<p>│   │   └── CancelOrderReceptor.cs</p>
<p>│   │</p>
<p>│   ├── Perspectives/                   # Read model updaters</p>
<p>│   │   └── OrderSummaryPerspective.cs</p>
<p>│   │</p>
<p>│   ├── Lenses/                         # Query interfaces</p>
<p>│   │   └── OrderLens.cs</p>
<p>│   │</p>
<p>│   ├── Endpoints/                      # HTTP endpoints</p>
<p>│   │   └── OrdersController.cs</p>
<p>│   │</p>
<p>│   └── Models/                         # Read models / DTOs</p>
<p>│       └── OrderSummary.cs</p>
<p>│</p>
<p>└── MyApp.API.Tests/                    # Tests</p>
<p>    ├── Receptors/</p>
<p>    │   └── CreateOrderReceptorTests.cs</p>
<p>    └── Perspectives/</p>
<p>        └── OrderSummaryPerspectiveTests.cs</p>
<p></code></pre></p>

<h3>Program.cs Setup</h3>

<pre><code class="language-csharp">using Whizbang.Core;
<p>using Whizbang.Data.Dapper.Postgres;</p>

<p>var builder = WebApplication.CreateBuilder(args);</p>

<p>// Whizbang Core</p>
<p>builder.Services.AddWhizbangCore();</p>

<p>// Auto-discovery (with Whizbang.Generators)</p>
<p>builder.Services.AddDiscoveredReceptors();</p>
<p>builder.Services.AddDiscoveredPerspectives();</p>

<p>// Data access</p>
<p>var connectionString = builder.Configuration.GetConnectionString("DefaultConnection")!;</p>
<p>builder.Services.AddWhizbangDapper(connectionString);</p>

<p>// Controllers</p>
<p>builder.Services.AddControllers();</p>
<p>builder.Services.AddEndpointsApiExplorer();</p>
<p>builder.Services.AddSwaggerGen();</p>

<p>var app = builder.Build();</p>

<p>if (app.Environment.IsDevelopment()) {</p>
<p>    app.UseSwagger();</p>
<p>    app.UseSwaggerUI();</p>
<p>}</p>

<p>app.UseHttpsRedirection();</p>
<p>app.UseAuthorization();</p>
<p>app.MapControllers();</p>

<p>app.Run();</p>
<p></code></pre></p>

<h3>Message Organization</h3>

<strong>Commands</strong> (imperative - intent to change state):
<pre><code class="language-csharp">// Messages/Commands/CreateOrder.cs
<p>namespace MyApp.API.Messages.Commands;</p>

<p>public record CreateOrder(</p>
<p>    Guid CustomerId,</p>
<p>    OrderLineItem[] Items</p>
<p>);</p>

<p>public record OrderLineItem(</p>
<p>    Guid ProductId,</p>
<p>    int Quantity,</p>
<p>    decimal UnitPrice</p>
<p>);</p>
<p></code></pre></p>

<strong>Events</strong> (past tense - fact of what happened):
<pre><code class="language-csharp">// Messages/Events/OrderCreated.cs
<p>namespace MyApp.API.Messages.Events;</p>

<p>public record OrderCreated(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    OrderLineItem[] Items,</p>
<p>    decimal Total,</p>
<p>    DateTimeOffset CreatedAt</p>
<p>);</p>
<p></code></pre></p>

<h3>Pros and Cons</h3>

<strong>Pros</strong>:
<ul><li>✅ Simple to understand and navigate</li>
<li>✅ Fast to set up and iterate</li>
<li>✅ Single deployment unit</li>
<li>✅ Easy debugging (single process)</li>
</ul>
<strong>Cons</strong>:
<ul><li>❌ Limited scalability (single service)</li>
<li>❌ Can become cluttered as app grows</li>
<li>❌ All logic in one deployable</li>
<li>❌ Hard to scale specific components independently</li>
</ul>
<hr>

<h2>Clean Architecture Structure</h2>

<strong>Best for</strong>: Medium-sized applications with clear domain boundaries

<pre><code class="language-">MyApp/
<p>├── src/</p>
<p>│   ├── MyApp.Messages/                 # Shared message contracts</p>
<p>│   │   ├── Commands/</p>
<p>│   │   │   ├── CreateOrder.cs</p>
<p>│   │   │   └── CancelOrder.cs</p>
<p>│   │   ├── Events/</p>
<p>│   │   │   ├── OrderCreated.cs</p>
<p>│   │   │   └── OrderCancelled.cs</p>
<p>│   │   └── MyApp.Messages.csproj</p>
<p>│   │</p>
<p>│   ├── MyApp.Domain/                   # Business logic (receptors)</p>
<p>│   │   ├── Receptors/</p>
<p>│   │   │   ├── CreateOrderReceptor.cs</p>
<p>│   │   │   └── CancelOrderReceptor.cs</p>
<p>│   │   └── MyApp.Domain.csproj         # References: Messages, Whizbang.Core</p>
<p>│   │</p>
<p>│   ├── MyApp.ReadModels/               # Perspectives and Lenses</p>
<p>│   │   ├── Perspectives/</p>
<p>│   │   │   ├── OrderSummaryPerspective.cs</p>
<p>│   │   │   └── InventoryPerspective.cs</p>
<p>│   │   ├── Lenses/</p>
<p>│   │   │   ├── OrderLens.cs</p>
<p>│   │   │   └── InventoryLens.cs</p>
<p>│   │   ├── Models/</p>
<p>│   │   │   ├── OrderSummary.cs</p>
<p>│   │   │   └── InventoryLevel.cs</p>
<p>│   │   └── MyApp.ReadModels.csproj     # References: Messages, Whizbang.Core</p>
<p>│   │</p>
<p>│   └── MyApp.API/                      # HTTP API</p>
<p>│       ├── Program.cs</p>
<p>│       ├── Endpoints/</p>
<p>│       │   ├── OrderEndpoints.cs</p>
<p>│       │   └── InventoryEndpoints.cs</p>
<p>│       └── MyApp.API.csproj            # References: Domain, ReadModels</p>
<p>│</p>
<p>├── tests/</p>
<p>│   ├── MyApp.Domain.Tests/</p>
<p>│   │   └── Receptors/</p>
<p>│   │       └── CreateOrderReceptorTests.cs</p>
<p>│   ├── MyApp.ReadModels.Tests/</p>
<p>│   │   └── Perspectives/</p>
<p>│   │       └── OrderSummaryPerspectiveTests.cs</p>
<p>│   └── MyApp.Integration.Tests/</p>
<p>│       └── OrderWorkflowTests.cs</p>
<p>│</p>
<p>└── MyApp.sln</p>
<p></code></pre></p>

<h3>Project Dependencies</h3>

<pre><code class="language-">MyApp.API
<p>  ├─> MyApp.Domain</p>
<p>  ├─> MyApp.ReadModels</p>
<p>  └─> Whizbang.Core</p>

<p>MyApp.Domain</p>
<p>  ├─> MyApp.Messages</p>
<p>  └─> Whizbang.Core</p>

<p>MyApp.ReadModels</p>
<p>  ├─> MyApp.Messages</p>
<p>  ├─> Whizbang.Core</p>
<p>  └─> Whizbang.Data.Dapper.Postgres</p>

<p>MyApp.Messages</p>
<p>  └─> (no dependencies - pure DTOs)</p>
<p></code></pre></p>

<strong>Key Point</strong>: Messages project has <strong>no dependencies</strong> - makes it easy to share across services.

<h3>Central Package Management</h3>

<p>Use <code>Directory.Packages.props</code> for version consistency:</p>

<pre><code class="language-xml"><!-- Directory.Packages.props (solution root) -->
<p><Project></p>
<p>  <PropertyGroup></p>
<p>    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally></p>
<p>  </PropertyGroup></p>

<p>  <ItemGroup></p>
<p>    <PackageVersion Include="Whizbang.Core" Version="0.1.0" /></p>
<p>    <PackageVersion Include="Whizbang.Generators" Version="0.1.0" /></p>
<p>    <PackageVersion Include="Whizbang.Data.Dapper.Postgres" Version="0.1.0" /></p>
<p>    <PackageVersion Include="Whizbang.Transports.AzureServiceBus" Version="0.1.0" /></p>
<p>  </ItemGroup></p>
<p></Project></p>
<p></code></pre></p>

<p>Then in project files:</p>
<pre><code class="language-xml"><!-- MyApp.API.csproj -->
<p><ItemGroup></p>
<p>  <PackageReference Include="Whizbang.Core" />  <!-- Version comes from Directory.Packages.props --></p>
<p>  <PackageReference Include="Whizbang.Generators" /></p>
<p></ItemGroup></p>
<p></code></pre></p>

<h3>Shared Build Properties</h3>

<p>Use <code>Directory.Build.props</code> for consistent settings:</p>

<pre><code class="language-xml"><!-- Directory.Build.props (solution root) -->
<p><Project></p>
<p>  <PropertyGroup></p>
<p>    <TargetFramework>net10.0</TargetFramework></p>
<p>    <LangVersion>13</LangVersion></p>
<p>    <Nullable>enable</Nullable></p>
<p>    <ImplicitUsings>enable</ImplicitUsings></p>
<p>    <TreatWarningsAsErrors>true</TreatWarningsAsErrors></p>
<p>  </PropertyGroup></p>

<p>  <PropertyGroup></p>
<p>    <!-- Source Generator Settings --></p>
<p>    <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles></p>
<p>    <CompilerGeneratedFilesOutputPath>$(MSBuildProjectDirectory)/.whizbang-generated</CompilerGeneratedFilesOutputPath></p>
<p>  </PropertyGroup></p>
<p></Project></p>
<p></code></pre></p>

<h3>Pros and Cons</h3>

<strong>Pros</strong>:
<ul><li>✅ Clear separation of concerns</li>
<li>✅ Testable in isolation</li>
<li>✅ Reusable message contracts</li>
<li>✅ Easy to understand dependencies</li>
<li>✅ Can grow to microservices later</li>
</ul>
<strong>Cons</strong>:
<ul><li>❌ More projects to manage</li>
<li>❌ Still a single deployable</li>
<li>❌ Some indirection (navigate across projects)</li>
</ul>
<hr>

<h2>Microservices Structure</h2>

<strong>Best for</strong>: Distributed systems, team scaling, independent deployment needs

<p>This is the structure used in the <strong>ECommerce sample</strong> (12 projects).</p>

<pre><code class="language-">ECommerce/
<p>├── src/</p>
<p>│   ├── ECommerce.Messages/             # Shared contracts (commands + events)</p>
<p>│   │   ├── Commands/</p>
<p>│   │   │   ├── CreateOrder.cs</p>
<p>│   │   │   ├── ReserveInventory.cs</p>
<p>│   │   │   └── ProcessPayment.cs</p>
<p>│   │   ├── Events/</p>
<p>│   │   │   ├── OrderCreated.cs</p>
<p>│   │   │   ├── InventoryReserved.cs</p>
<p>│   │   │   └── PaymentProcessed.cs</p>
<p>│   │   └── ECommerce.Messages.csproj</p>
<p>│   │</p>
<p>│   ├── ECommerce.BFF.API/              # Backend for Frontend (UI layer)</p>
<p>│   │   ├── Program.cs</p>
<p>│   │   ├── Perspectives/               # Read models for UI</p>
<p>│   │   │   ├── OrderSummaryPerspective.cs</p>
<p>│   │   │   ├── InventoryPerspective.cs</p>
<p>│   │   │   └── ShippingPerspective.cs</p>
<p>│   │   ├── Lenses/                     # Query interfaces</p>
<p>│   │   │   ├── OrderLens.cs</p>
<p>│   │   │   └── InventoryLens.cs</p>
<p>│   │   ├── Hubs/                       # SignalR real-time</p>
<p>│   │   │   └── OrderHub.cs</p>
<p>│   │   └── Endpoints/</p>
<p>│   │       └── OrderEndpoints.cs</p>
<p>│   │</p>
<p>│   ├── ECommerce.OrderService.API/     # Order management service</p>
<p>│   │   ├── Program.cs</p>
<p>│   │   ├── Receptors/</p>
<p>│   │   │   ├── CreateOrderReceptor.cs</p>
<p>│   │   │   └── CancelOrderReceptor.cs</p>
<p>│   │   └── Endpoints/</p>
<p>│   │       └── OrdersController.cs</p>
<p>│   │</p>
<p>│   ├── ECommerce.InventoryWorker/      # Inventory reservation (background worker)</p>
<p>│   │   ├── Program.cs</p>
<p>│   │   ├── Receptors/</p>
<p>│   │   │   └── ReserveInventoryReceptor.cs</p>
<p>│   │   └── Workers/</p>
<p>│   │       └── InventoryWorker.cs</p>
<p>│   │</p>
<p>│   ├── ECommerce.PaymentWorker/        # Payment processing (background worker)</p>
<p>│   │   ├── Program.cs</p>
<p>│   │   ├── Receptors/</p>
<p>│   │   │   └── ProcessPaymentReceptor.cs</p>
<p>│   │   └── Workers/</p>
<p>│   │       └── PaymentWorker.cs</p>
<p>│   │</p>
<p>│   ├── ECommerce.ShippingWorker/       # Fulfillment coordination (background worker)</p>
<p>│   │   ├── Program.cs</p>
<p>│   │   ├── Receptors/</p>
<p>│   │   │   └── ShipOrderReceptor.cs</p>
<p>│   │   └── Workers/</p>
<p>│   │       └── ShippingWorker.cs</p>
<p>│   │</p>
<p>│   ├── ECommerce.NotificationWorker/   # Cross-cutting notifications (background worker)</p>
<p>│   │   ├── Program.cs</p>
<p>│   │   ├── Perspectives/               # Listens to ALL events</p>
<p>│   │   │   └── NotificationPerspective.cs</p>
<p>│   │   └── Workers/</p>
<p>│   │       └── NotificationWorker.cs</p>
<p>│   │</p>
<p>│   └── ECommerce.UI/                   # Angular 20 frontend</p>
<p>│       └── (Angular project)</p>
<p>│</p>
<p>├── ECommerce.AppHost/                  # .NET Aspire orchestration</p>
<p>│   └── Program.cs</p>
<p>│</p>
<p>├── tests/</p>
<p>│   ├── ECommerce.OrderService.Tests/</p>
<p>│   ├── ECommerce.InventoryWorker.Tests/</p>
<p>│   └── ECommerce.Integration.Tests/</p>
<p>│</p>
<p>└── ECommerce.sln</p>
<p></code></pre></p>

<h3>Service Responsibilities</h3>

<p>| Service | Type | Responsibilities |</p>
<p>|---------|------|------------------|</p>
<p>| <strong>BFF.API</strong> | ASP.NET Core API | UI aggregation, SignalR, read models, GraphQL |</p>
<p>| <strong>OrderService.API</strong> | ASP.NET Core API | Order creation, REST + GraphQL |</p>
<p>| <strong>InventoryWorker</strong> | Background Worker | Inventory reservation, stock management |</p>
<p>| <strong>PaymentWorker</strong> | Background Worker | Payment processing, refunds |</p>
<p>| <strong>ShippingWorker</strong> | Background Worker | Fulfillment coordination |</p>
<p>| <strong>NotificationWorker</strong> | Background Worker | Email, SMS, push notifications |</p>

<h3>Communication Pattern</h3>

<pre><code class="language-">1. UI → BFF.API
<p>   └─> Send CreateOrder command (via HTTP POST)</p>

<ul><li>BFF.API → Dispatcher (local)</li>
</ul><p>   └─> LocalInvokeAsync<CreateOrder, OrderCreated>()</p>

<ul><li>Receptor → Outbox</li>
</ul><p>   └─> Stores OrderCreated event in outbox</p>

<ul><li>WorkCoordinatorPublisher → Azure Service Bus</li>
</ul><p>   └─> Publishes OrderCreated to topic</p>

<ul><li>InventoryWorker subscribes to OrderCreated</li>
</ul><p>   └─> Processes event, publishes InventoryReserved</p>

<ul><li>PaymentWorker subscribes to InventoryReserved</li>
</ul><p>   └─> Processes event, publishes PaymentProcessed</p>

<ul><li>BFF Perspectives subscribe to all events</li>
</ul><p>   └─> Update read models, trigger SignalR updates to UI</p>
<p></code></pre></p>

<h3>.NET Aspire Orchestration</h3>

<strong>ECommerce.AppHost/Program.cs</strong>:
<pre><code class="language-csharp">var builder = DistributedApplication.CreateBuilder(args);

<p>// Infrastructure</p>
<p>var postgres = builder.AddPostgres("postgres")</p>
<p>    .WithPgAdmin()</p>
<p>    .AddDatabase("ecommerce");</p>

<p>var serviceBus = builder.AddAzureServiceBus("servicebus")</p>
<p>    .RunAsEmulator();</p>

<p>// Services</p>
<p>var orderService = builder.AddProject<Projects.ECommerce_OrderService_API>("orderservice")</p>
<p>    .WithReference(postgres)</p>
<p>    .WithReference(serviceBus);</p>

<p>var inventoryWorker = builder.AddProject<Projects.ECommerce_InventoryWorker>("inventoryworker")</p>
<p>    .WithReference(postgres)</p>
<p>    .WithReference(serviceBus);</p>

<p>var paymentWorker = builder.AddProject<Projects.ECommerce_PaymentWorker>("paymentworker")</p>
<p>    .WithReference(postgres)</p>
<p>    .WithReference(serviceBus);</p>

<p>var shippingWorker = builder.AddProject<Projects.ECommerce_ShippingWorker>("shippingworker")</p>
<p>    .WithReference(postgres)</p>
<p>    .WithReference(serviceBus);</p>

<p>var notificationWorker = builder.AddProject<Projects.ECommerce_NotificationWorker>("notificationworker")</p>
<p>    .WithReference(postgres)</p>
<p>    .WithReference(serviceBus);</p>

<p>var bff = builder.AddProject<Projects.ECommerce_BFF_API>("bff")</p>
<p>    .WithReference(postgres)</p>
<p>    .WithReference(serviceBus)</p>
<p>    .WithReference(orderService);</p>

<p>var ui = builder.AddNpmApp("ui", "../ECommerce.UI")</p>
<p>    .WithReference(bff)</p>
<p>    .WithHttpEndpoint(env: "PORT")</p>
<p>    .WithExternalHttpEndpoints();</p>

<p>builder.Build().Run();</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>One-command local development: <code>dotnet run --project ECommerce.AppHost</code></li>
<li>Automatic service discovery</li>
<li>Built-in dashboard (http://localhost:15000)</li>
<li>PostgreSQL and Service Bus emulators</li>
<li>Health checks and observability</li>
</ul>
<h3>Pros and Cons</h3>

<strong>Pros</strong>:
<ul><li>✅ Independent deployment per service</li>
<li>✅ Scalability (scale specific services)</li>
<li>✅ Team autonomy (own services)</li>
<li>✅ Technology diversity (different stacks per service if needed)</li>
<li>✅ Fault isolation</li>
</ul>
<strong>Cons</strong>:
<ul><li>❌ Complexity (distributed system challenges)</li>
<li>❌ Eventual consistency</li>
<li>❌ Debugging across services</li>
<li>❌ Infrastructure overhead</li>
</ul>
<hr>

<h2>Configuration Patterns</h2>

<h3>appsettings.json Structure</h3>

<strong>Development</strong> (<code>appsettings.Development.json</code>):
<pre><code class="language-json">{
<p>  "Logging": {</p>
<p>    "LogLevel": {</p>
<p>      "Default": "Information",</p>
<p>      "Whizbang": "Debug",</p>
<p>      "Microsoft.AspNetCore": "Warning"</p>
<p>    }</p>
<p>  },</p>
<p>  "ConnectionStrings": {</p>
<p>    "DefaultConnection": "Host=localhost;Database=myapp;Username=postgres;Password=dev_password"</p>
<p>  },</p>
<p>  "Whizbang": {</p>
<p>    "Outbox": {</p>
<p>      "PollingIntervalMilliseconds": 1000,</p>
<p>      "LeaseSeconds": 300</p>
<p>    },</p>
<p>    "Inbox": {</p>
<p>      "PollingIntervalMilliseconds": 1000</p>
<p>    }</p>
<p>  },</p>
<p>  "AzureServiceBus": {</p>
<p>    "ConnectionString": "Endpoint=sb://localhost;..."</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Production</strong> (<code>appsettings.Production.json</code>):
<pre><code class="language-json">{
<p>  "Logging": {</p>
<p>    "LogLevel": {</p>
<p>      "Default": "Warning",</p>
<p>      "Whizbang": "Information"</p>
<p>    }</p>
<p>  },</p>
<p>  "ConnectionStrings": {</p>
<p>    "DefaultConnection": "${DATABASE_URL}"  // Injected from environment</p>
<p>  },</p>
<p>  "Whizbang": {</p>
<p>    "Outbox": {</p>
<p>      "PollingIntervalMilliseconds": 5000,</p>
<p>      "LeaseSeconds": 600</p>
<p>    }</p>
<p>  },</p>
<p>  "AzureServiceBus": {</p>
<p>    "ConnectionString": "${SERVICE_BUS_CONNECTION_STRING}"</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Environment Variables</h3>

<p>Use environment variables for secrets:</p>

<pre><code class="language-bash"># .env (local development - NOT committed)
<p>DATABASE_URL=Host=localhost;Database=myapp;Username=postgres;Password=dev_password</p>
<p>SERVICE_BUS_CONNECTION_STRING=Endpoint=sb://localhost;...</p>

<h1>Kubernetes/Docker secrets</h1>
<p>kubectl create secret generic myapp-db --from-literal=connection-string="Host=..."</p>
<p></code></pre></p>

<hr>

<h2>Dependency Injection Patterns</h2>

<h3>Service Registration Layers</h3>

<strong>Layer 1: Whizbang Core</strong>:
<pre><code class="language-csharp">builder.Services.AddWhizbangCore();  // IDispatcher, MessageEnvelope, etc.
<p></code></pre></p>

<strong>Layer 2: Auto-Discovery</strong> (with Whizbang.Generators):
<pre><code class="language-csharp">builder.Services.AddDiscoveredReceptors();      // All IReceptor implementations
<p>builder.Services.AddDiscoveredPerspectives();   // All IPerspectiveOf implementations</p>
<p></code></pre></p>

<strong>Layer 3: Data Access</strong>:
<pre><code class="language-csharp">builder.Services.AddWhizbangDapper(connectionString);        // Dapper + PostgreSQL
<p>// OR</p>
<p>builder.Services.AddWhizbangEFCore(connectionString);        // EF Core + PostgreSQL</p>
<p></code></pre></p>

<strong>Layer 4: Transports</strong>:
<pre><code class="language-csharp">builder.Services.AddWhizbangAzureServiceBus(
<p>    builder.Configuration.GetSection("AzureServiceBus")</p>
<p>);</p>
<p></code></pre></p>

<strong>Layer 5: Application Services</strong>:
<pre><code class="language-csharp">builder.Services.AddTransient<IOrderLens, OrderLens>();
<p>builder.Services.AddSingleton<IEmailService, SendGridEmailService>();</p>
<p></code></pre></p>

<h3>Lifetime Guidelines</h3>

<p>| Component | Lifetime | Reason |</p>
<p>|-----------|----------|--------|</p>
<p>| <code>IDispatcher</code> | Singleton | Shared router, no state |</p>
<p>| <code>IReceptor<,></code> | Transient | May inject scoped services (DbContext) |</p>
<p>| <code>IPerspectiveOf<></code> | Transient | May inject scoped services |</p>
<p>| <code>ILensQuery</code> | Transient | Lightweight, may inject scoped services |</p>
<p>| <code>DbContext</code> | Scoped | Per-request database context |</p>
<p>| <code>IDbConnectionFactory</code> | Singleton | Connection factory (Dapper) |</p>

<hr>

<h2>Testing Structure</h2>

<h3>Unit Tests</h3>

<strong>Test receptors in isolation</strong>:
<pre><code class="language-csharp">// tests/MyApp.Domain.Tests/Receptors/CreateOrderReceptorTests.cs
<p>public class CreateOrderReceptorTests {</p>
<p>    [Test]</p>
<p>    public async Task HandleAsync_ValidOrder_ReturnsOrderCreatedAsync() {</p>
<p>        // Arrange</p>
<p>        var receptor = new CreateOrderReceptor(/<em> mock dependencies </em>/);</p>
<p>        var command = new CreateOrder(/<em> ... </em>/);</p>

<p>        // Act</p>
<p>        var result = await receptor.HandleAsync(command);</p>

<p>        // Assert</p>
<p>        await Assert.That(result.OrderId).IsNotEqualTo(Guid.Empty);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Integration Tests</h3>

<strong>Test full message flow</strong>:
<pre><code class="language-csharp">// tests/MyApp.Integration.Tests/OrderWorkflowTests.cs
<p>public class OrderWorkflowTests {</p>
<p>    private WebApplicationFactory<Program> _factory;</p>
<p>    private IDispatcher _dispatcher;</p>

<p>    [Before(Test)]</p>
<p>    public async Task SetupAsync() {</p>
<p>        _factory = new WebApplicationFactory<Program>();</p>
<p>        _dispatcher = _factory.Services.GetRequiredService<IDispatcher>();</p>
<p>    }</p>

<p>    [Test]</p>
<p>    public async Task CreateOrder_FullWorkflow_UpdatesReadModelAsync() {</p>
<p>        // Arrange</p>
<p>        var command = new CreateOrder(/<em> ... </em>/);</p>

<p>        // Act - dispatch command</p>
<p>        var result = await _dispatcher.LocalInvokeAsync<CreateOrder, OrderCreated>(command);</p>

<p>        // Publish event to perspectives</p>
<p>        await _dispatcher.PublishAsync(result);</p>

<p>        // Assert - query read model</p>
<p>        var lens = _factory.Services.GetRequiredService<IOrderLens>();</p>
<p>        var order = await lens.GetOrderAsync(result.OrderId);</p>

<p>        await Assert.That(order).IsNotNull();</p>
<p>        await Assert.That(order!.Status).IsEqualTo("Created");</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Migration Paths</h2>

<h3>Single → Clean Architecture</h3>

<ul><li>Create <code>MyApp.Messages</code> project</li>
<li>Move commands/events to Messages project</li>
<li>Create <code>MyApp.Domain</code> project</li>
<li>Move receptors to Domain project</li>
<li>Create <code>MyApp.ReadModels</code> project</li>
<li>Move perspectives/lenses to ReadModels project</li>
<li>Update API project to reference Domain + ReadModels</li>
</ul>
<strong>Timeline</strong>: 1-2 hours for small app

<h3>Clean Architecture → Microservices</h3>

<ul><li>Identify service boundaries (order, inventory, payment, etc.)</li>
<li>Create service projects (API or Worker)</li>
<li>Add transport (Azure Service Bus)</li>
<li>Implement Outbox/Inbox patterns</li>
<li>Split receptors across services</li>
<li>Create BFF for UI aggregation</li>
<li>Add .NET Aspire AppHost for orchestration</li>
</ul>
<strong>Timeline</strong>: 1-2 weeks for initial split, iterative refinement

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ Use central package management (<code>Directory.Packages.props</code>)</li>
<li>✅ Use shared build properties (<code>Directory.Build.props</code>)</li>
<li>✅ Keep messages in separate project (no dependencies)</li>
<li>✅ Use auto-discovery for receptors/perspectives (Whizbang.Generators)</li>
<li>✅ Follow namespace conventions (Messages.Commands, Messages.Events)</li>
<li>✅ Use environment-specific appsettings</li>
<li>✅ Keep receptors stateless</li>
<li>✅ Test receptors in isolation</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Put business logic in controllers/endpoints</li>
<li>❌ Create circular dependencies between projects</li>
<li>❌ Reference domain projects from Messages project</li>
<li>❌ Hard-code connection strings</li>
<li>❌ Share database contexts across services</li>
<li>❌ Use static state in receptors</li>
<li>❌ Mix read and write logic in same class</li>
</ul>
<hr>

<h2>Example: Adding a New Feature</h2>

<strong>Scenario</strong>: Add "Cancel Order" feature to Clean Architecture app

<h3>Step 1: Define Message</h3>

<pre><code class="language-csharp">// MyApp.Messages/Commands/CancelOrder.cs
<p>public record CancelOrder(</p>
<p>    Guid OrderId,</p>
<p>    string Reason</p>
<p>);</p>

<p>// MyApp.Messages/Events/OrderCancelled.cs</p>
<p>public record OrderCancelled(</p>
<p>    Guid OrderId,</p>
<p>    string Reason,</p>
<p>    DateTimeOffset CancelledAt</p>
<p>);</p>
<p></code></pre></p>

<h3>Step 2: Create Receptor</h3>

<pre><code class="language-csharp">// MyApp.Domain/Receptors/CancelOrderReceptor.cs
<p>using Whizbang.Core;</p>
<p>using MyApp.Messages.Commands;</p>
<p>using MyApp.Messages.Events;</p>

<p>public class CancelOrderReceptor : IReceptor<CancelOrder, OrderCancelled> {</p>
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public CancelOrderReceptor(IDbConnectionFactory db) {</p>
<p>        _db = db;</p>
<p>    }</p>

<p>    public async ValueTask<OrderCancelled> HandleAsync(</p>
<p>        CancelOrder message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        // Validation</p>
<p>        await using var conn = _db.CreateConnection();</p>
<p>        var order = await conn.QuerySingleOrDefaultAsync<Order>(</p>
<p>            "SELECT * FROM orders WHERE order_id = @OrderId",</p>
<p>            new { message.OrderId }</p>
<p>        );</p>

<p>        if (order is null) {</p>
<p>            throw new InvalidOperationException($"Order {message.OrderId} not found");</p>
<p>        }</p>

<p>        if (order.Status == "Shipped") {</p>
<p>            throw new InvalidOperationException("Cannot cancel shipped order");</p>
<p>        }</p>

<p>        // Return event</p>
<p>        return new OrderCancelled(</p>
<p>            OrderId: message.OrderId,</p>
<p>            Reason: message.Reason,</p>
<p>            CancelledAt: DateTimeOffset.UtcNow</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Step 3: Update Perspective</h3>

<pre><code class="language-csharp">// MyApp.ReadModels/Perspectives/OrderSummaryPerspective.cs
<p>public class OrderSummaryPerspective :</p>
<p>    IPerspectiveOf<OrderCreated>,</p>
<p>    IPerspectiveOf<OrderCancelled> {  // Add new event</p>

<p>    public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>        // Existing logic</p>
<p>    }</p>

<p>    public async Task UpdateAsync(OrderCancelled @event, CancellationToken ct = default) {</p>
<p>        await using var conn = _db.CreateConnection();</p>
<p>        await conn.ExecuteAsync(</p>
<p>            "UPDATE order_summaries SET status = 'Cancelled', cancelled_at = @CancelledAt WHERE order_id = @OrderId",</p>
<p>            new { @event.OrderId, @event.CancelledAt }</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Step 4: Add Endpoint</h3>

<pre><code class="language-csharp">// MyApp.API/Endpoints/OrdersController.cs
<p>[HttpPost("{orderId:guid}/cancel")]</p>
<p>public async Task<ActionResult> CancelOrder(</p>
<p>    Guid orderId,</p>
<p>    [FromBody] CancelOrderRequest request,</p>
<p>    CancellationToken ct) {</p>

<p>    var command = new CancelOrder(orderId, request.Reason);</p>

<p>    var result = await _dispatcher.LocalInvokeAsync<CancelOrder, OrderCancelled>(command, ct);</p>
<p>    await _dispatcher.PublishAsync(result, ct);</p>

<p>    return Ok(result);</p>
<p>}</p>
<p></code></pre></p>

<h3>Step 5: Test</h3>

<pre><code class="language-csharp">// MyApp.Domain.Tests/Receptors/CancelOrderReceptorTests.cs
<p>[Test]</p>
<p>public async Task HandleAsync_ValidOrder_ReturnsOrderCancelledAsync() {</p>
<p>    // Arrange</p>
<p>    var receptor = new CancelOrderReceptor(mockDb);</p>
<p>    var command = new CancelOrder(Guid.NewGuid(), "Customer request");</p>

<p>    // Act</p>
<p>    var result = await receptor.HandleAsync(command);</p>

<p>    // Assert</p>
<p>    await Assert.That(result.Reason).IsEqualTo("Customer request");</p>
<p>}</p>
<p></code></pre></p>

<strong>Done!</strong> Auto-discovery registers the receptor automatically on next build.

<hr>

<h2>Further Reading</h2>

<strong>Architecture Patterns</strong>:
<ul><li><a href="../core-concepts/dispatcher.md">Core Concepts: Dispatcher</a></li>
<li><a href="../core-concepts/receptors.md">Core Concepts: Receptors</a></li>
<li><a href="../core-concepts/perspectives.md">Core Concepts: Perspectives</a></li>
</ul>
<strong>Messaging</strong>:
<ul><li><a href="../messaging/outbox-pattern.md">Outbox Pattern</a></li>
<li><a href="../messaging/inbox-pattern.md">Inbox Pattern</a></li>
<li><a href="../messaging/work-coordinator.md">Work Coordination</a></li>
</ul>
<strong>Examples</strong>:
<ul><li><a href="../examples/ecommerce/overview.md">ECommerce Sample Overview</a></li>
<li><a href="../examples/ecommerce/bff-pattern.md">BFF Pattern</a></li>
</ul>
<hr>

<strong>Next</strong>: Dive into <a href="../core-concepts/dispatcher.md">Core Concepts: Dispatcher</a> to master message routing patterns.

<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-getting-started-quick-start" class="doc-section">
  <h3>Quick Start Tutorial</h3>
  <p class="doc-path"><code>v1.0.0/getting-started/quick-start</code></p>
  <p class="doc-description"><em>Build your first Whizbang application in 10 minutes - create messages, receptors, and dispatch commands with complete working examples</em></p>
  <div class="doc-content">

<h1>Quick Start Tutorial</h1>

<p>Build your first Whizbang application in <strong>10 minutes</strong>. This tutorial walks you through creating a simple order management system using Whizbang's core patterns.</p>

<h2>What You'll Build</h2>

<p>A minimal ASP.NET Core API that:</p>
<ul><li>Accepts <strong>CreateOrder</strong> commands via HTTP endpoint</li>
<li>Processes orders using a <strong>Receptor</strong> (message handler)</li>
<li>Returns <strong>OrderCreated</strong> events with validation</li>
<li>Uses <strong>Dispatcher</strong> for type-safe message routing</li>
</ul>
<strong>Prerequisites</strong>: Complete the <a href="installation.md">Installation Guide</a> first.

<h2>Step 1: Create Project Structure</h2>

<pre><code class="language-bash"># Create solution and project
<p>dotnet new sln -n QuickStartApp</p>
<p>dotnet new webapi -n QuickStartApp.API</p>
<p>dotnet sln add QuickStartApp.API</p>

<p>cd QuickStartApp.API</p>

<h1>Add Whizbang packages</h1>
<p>dotnet add package Whizbang.Core</p>
<p>dotnet add package Whizbang.Generators</p>
<p></code></pre></p>

<h2>Step 2: Define Your Messages</h2>

<p>Create a <code>Messages</code> folder and define your command and event:</p>

<strong>Messages/CreateOrder.cs</strong>:
<pre><code class="language-csharp">namespace QuickStartApp.API.Messages;

<p>public record CreateOrder(</p>
<p>    Guid CustomerId,</p>
<p>    string ProductName,</p>
<p>    int Quantity,</p>
<p>    decimal UnitPrice</p>
<p>);</p>
<p></code></pre></p>

<strong>Messages/OrderCreated.cs</strong>:
<pre><code class="language-csharp">namespace QuickStartApp.API.Messages;

<p>public record OrderCreated(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    string ProductName,</p>
<p>    int Quantity,</p>
<p>    decimal UnitPrice,</p>
<p>    decimal Total,</p>
<p>    DateTimeOffset CreatedAt</p>
<p>);</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li>Use <strong>records</strong> for immutability and value semantics</li>
<li>Commands are <strong>requests</strong> (CreateOrder)</li>
<li>Events are <strong>facts</strong> (OrderCreated - past tense)</li>
<li>Include all necessary data for downstream consumers</li>
</ul>
<h2>Step 3: Create Your First Receptor</h2>

<p>Receptors are <strong>stateless message handlers</strong> that implement business logic.</p>

<strong>Receptors/CreateOrderReceptor.cs</strong>:
<pre><code class="language-csharp">using Whizbang.Core;
<p>using QuickStartApp.API.Messages;</p>

<p>namespace QuickStartApp.API.Receptors;</p>

<p>public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    private readonly ILogger<CreateOrderReceptor> _logger;</p>

<p>    public CreateOrderReceptor(ILogger<CreateOrderReceptor> logger) {</p>
<p>        _logger = logger;</p>
<p>    }</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken cancellationToken = default) {</p>

<p>        // Validation</p>
<p>        if (message.Quantity <= 0) {</p>
<p>            throw new InvalidOperationException("Quantity must be greater than zero");</p>
<p>        }</p>

<p>        if (message.UnitPrice <= 0) {</p>
<p>            throw new InvalidOperationException("Unit price must be greater than zero");</p>
<p>        }</p>

<p>        if (string.IsNullOrWhiteSpace(message.ProductName)) {</p>
<p>            throw new InvalidOperationException("Product name is required");</p>
<p>        }</p>

<p>        // Business logic</p>
<p>        var orderId = Guid.CreateVersion7(); // Time-ordered GUID</p>
<p>        var total = message.Quantity * message.UnitPrice;</p>

<p>        _logger.LogInformation(</p>
<p>            "Creating order {OrderId} for customer {CustomerId}: {Quantity}x {ProductName} = {Total:C}",</p>
<p>            orderId, message.CustomerId, message.Quantity, message.ProductName, total</p>
<p>        );</p>

<p>        // Return event (fact of what happened)</p>
<p>        return new OrderCreated(</p>
<p>            OrderId: orderId,</p>
<p>            CustomerId: message.CustomerId,</p>
<p>            ProductName: message.ProductName,</p>
<p>            Quantity: message.Quantity,</p>
<p>            UnitPrice: message.UnitPrice,</p>
<p>            Total: total,</p>
<p>            CreatedAt: DateTimeOffset.UtcNow</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Patterns</strong>:
<ul><li>Implement <code>IReceptor<TMessage, TResponse></code></li>
<li>Use constructor injection for dependencies</li>
<li>Validate inputs and throw exceptions for invalid requests</li>
<li>Return domain events (OrderCreated) describing what happened</li>
<li>Use <code>ValueTask<T></code> for performance (may be synchronous or async)</li>
</ul>
<h2>Step 4: Register Whizbang Services</h2>

<p>Configure dependency injection in <strong>Program.cs</strong>:</p>

<pre><code class="language-csharp">using Whizbang.Core;
<p>using QuickStartApp.API.Messages;</p>
<p>using QuickStartApp.API.Receptors;</p>

<p>var builder = WebApplication.CreateBuilder(args);</p>

<p>// Add Whizbang Core</p>
<p>builder.Services.AddWhizbangCore();</p>

<p>// Register receptors manually (or use Whizbang.Generators for auto-discovery)</p>
<p>builder.Services.AddTransient<IReceptor<CreateOrder, OrderCreated>, CreateOrderReceptor>();</p>

<p>// Add controllers (if using MVC/API)</p>
<p>builder.Services.AddControllers();</p>
<p>builder.Services.AddEndpointsApiExplorer();</p>
<p>builder.Services.AddSwaggerGen();</p>

<p>var app = builder.Build();</p>

<p>if (app.Environment.IsDevelopment()) {</p>
<p>    app.UseSwagger();</p>
<p>    app.UseSwaggerUI();</p>
<p>}</p>

<p>app.UseHttpsRedirection();</p>
<p>app.UseAuthorization();</p>
<p>app.MapControllers();</p>

<p>app.Run();</p>
<p></code></pre></p>

<strong>Important</strong>:
<ul><li><code>AddWhizbangCore()</code> registers the dispatcher and core services</li>
<li>Receptors can be registered manually or auto-discovered (with Whizbang.Generators)</li>
<li>Receptors are typically <strong>transient</strong> (new instance per request)</li>
</ul>
<h2>Step 5: Create API Endpoint</h2>

<p>Create a minimal API endpoint to dispatch your command:</p>

<strong>Endpoints/OrderEndpoints.cs</strong>:
<pre><code class="language-csharp">using Microsoft.AspNetCore.Mvc;
<p>using Whizbang.Core;</p>
<p>using QuickStartApp.API.Messages;</p>

<p>namespace QuickStartApp.API.Endpoints;</p>

<p>[ApiController]</p>
<p>[Route("api/[controller]")]</p>
<p>public class OrdersController : ControllerBase {</p>
<p>    private readonly IDispatcher _dispatcher;</p>
<p>    private readonly ILogger<OrdersController> _logger;</p>

<p>    public OrdersController(IDispatcher dispatcher, ILogger<OrdersController> logger) {</p>
<p>        _dispatcher = dispatcher;</p>
<p>        _logger = logger;</p>
<p>    }</p>

<p>    [HttpPost]</p>
<p>    public async Task<ActionResult<OrderCreated>> CreateOrder(</p>
<p>        [FromBody] CreateOrderRequest request,</p>
<p>        CancellationToken cancellationToken) {</p>

<p>        try {</p>
<p>            var command = new CreateOrder(</p>
<p>                CustomerId: request.CustomerId,</p>
<p>                ProductName: request.ProductName,</p>
<p>                Quantity: request.Quantity,</p>
<p>                UnitPrice: request.UnitPrice</p>
<p>            );</p>

<p>            // Dispatch command and get typed result (< 20ns, zero allocation)</p>
<p>            var result = await _dispatcher.LocalInvokeAsync<CreateOrder, OrderCreated>(</p>
<p>                command,</p>
<p>                cancellationToken</p>
<p>            );</p>

<p>            _logger.LogInformation("Order {OrderId} created successfully", result.OrderId);</p>

<p>            return CreatedAtAction(</p>
<p>                nameof(GetOrder),</p>
<p>                new { orderId = result.OrderId },</p>
<p>                result</p>
<p>            );</p>
<p>        } catch (InvalidOperationException ex) {</p>
<p>            _logger.LogWarning(ex, "Invalid order request");</p>
<p>            return BadRequest(new { error = ex.Message });</p>
<p>        } catch (Exception ex) {</p>
<p>            _logger.LogError(ex, "Failed to create order");</p>
<p>            return StatusCode(500, new { error = "An unexpected error occurred" });</p>
<p>        }</p>
<p>    }</p>

<p>    [HttpGet("{orderId:guid}")]</p>
<p>    public ActionResult<OrderCreated> GetOrder(Guid orderId) {</p>
<p>        // Placeholder - in real app, query from read model via Lens</p>
<p>        return NotFound(new { error = "Order retrieval not implemented in quick start" });</p>
<p>    }</p>
<p>}</p>

<p>// Request DTO for API</p>
<p>public record CreateOrderRequest(</p>
<p>    Guid CustomerId,</p>
<p>    string ProductName,</p>
<p>    int Quantity,</p>
<p>    decimal UnitPrice</p>
<p>);</p>
<p></code></pre></p>

<strong>Key Patterns</strong>:
<ul><li>Inject <code>IDispatcher</code> into your controller/endpoint</li>
<li>Use <code>LocalInvokeAsync<TMessage, TResponse></code> for <strong>in-process</strong> dispatch with typed result</li>
<li>Handle exceptions from receptors (validation errors, business rule violations)</li>
<li>Return appropriate HTTP status codes (201 Created, 400 Bad Request, 500 Internal Server Error)</li>
</ul>
<h2>Step 6: Run and Test</h2>

<h3>Start the Application</h3>

<pre><code class="language-bash">dotnet run
<p></code></pre></p>

<strong>Expected output</strong>:
<pre><code class="language-">info: Microsoft.Hosting.Lifetime[14]
<p>      Now listening on: https://localhost:7001</p>
<p>info: Microsoft.Hosting.Lifetime[14]</p>
<p>      Now listening on: http://localhost:5001</p>
<p></code></pre></p>

<h3>Test with curl</h3>

<strong>Valid request</strong>:
<pre><code class="language-bash">curl -X POST https://localhost:7001/api/orders \
<p>  -H "Content-Type: application/json" \</p>
<p>  -d '{</p>
<p>    "customerId": "550e8400-e29b-41d4-a716-446655440000",</p>
<p>    "productName": "Laptop",</p>
<p>    "quantity": 2,</p>
<p>    "unitPrice": 999.99</p>
<p>  }'</p>
<p></code></pre></p>

<strong>Expected response</strong> (201 Created):
<pre><code class="language-json">{
<p>  "orderId": "018d8f8e-1234-7890-abcd-ef1234567890",</p>
<p>  "customerId": "550e8400-e29b-41d4-a716-446655440000",</p>
<p>  "productName": "Laptop",</p>
<p>  "quantity": 2,</p>
<p>  "unitPrice": 999.99,</p>
<p>  "total": 1999.98,</p>
<p>  "createdAt": "2024-12-12T10:30:00Z"</p>
<p>}</p>
<p></code></pre></p>

<strong>Invalid request</strong> (negative quantity):
<pre><code class="language-bash">curl -X POST https://localhost:7001/api/orders \
<p>  -H "Content-Type: application/json" \</p>
<p>  -d '{</p>
<p>    "customerId": "550e8400-e29b-41d4-a716-446655440000",</p>
<p>    "productName": "Laptop",</p>
<p>    "quantity": -5,</p>
<p>    "unitPrice": 999.99</p>
<p>  }'</p>
<p></code></pre></p>

<strong>Expected response</strong> (400 Bad Request):
<pre><code class="language-json">{
<p>  "error": "Quantity must be greater than zero"</p>
<p>}</p>
<p></code></pre></p>

<h3>Test with Swagger</h3>

<ul><li>Navigate to <code>https://localhost:7001/swagger</code></li>
<li>Expand <strong>POST /api/orders</strong></li>
<li>Click <strong>Try it out</strong></li>
<li>Enter request body:</li>
</ul><p>   <pre><code class="language-json">   {</p>
<p>     "customerId": "550e8400-e29b-41d4-a716-446655440000",</p>
<p>     "productName": "Mechanical Keyboard",</p>
<p>     "quantity": 1,</p>
<p>     "unitPrice": 149.99</p>
<p>   }</p>
<p>   </code></pre></p>
<ul><li>Click <strong>Execute</strong></li>
<li>Verify <strong>201 Created</strong> response</li>
</ul>
<h2>What You Just Built</h2>

<p>Congratulations! You've created a working Whizbang application with:</p>

<p>✅ <strong>Type-safe messaging</strong> - Compiler enforces CreateOrder → OrderCreated</p>
<p>✅ <strong>Zero reflection</strong> - All routing happens at compile time</p>
<p>✅ <strong>Clean architecture</strong> - Commands, events, and handlers are separated</p>
<p>✅ <strong>Business logic isolation</strong> - Validation and rules in receptor, not controller</p>
<p>✅ <strong>Performance</strong> - < 20ns dispatch with zero allocations</p>

<h2>Understanding the Flow</h2>

<pre><code class="language-">HTTP POST /api/orders
<p>    ↓</p>
<p>OrdersController.CreateOrder()</p>
<p>    ↓</p>
<p>dispatcher.LocalInvokeAsync<CreateOrder, OrderCreated>(command)</p>
<p>    ↓</p>
<p>CreateOrderReceptor.HandleAsync(command)</p>
<p>    ↓</p>
<p>Validation → Business Logic → Return OrderCreated event</p>
<p>    ↓</p>
<p>Return 201 Created with OrderCreated response</p>
<p></code></pre></p>

<h2>Next Steps</h2>

<h3>Add Source Generators (Auto-Discovery)</h3>

<p>Currently, you're registering receptors manually:</p>
<pre><code class="language-csharp">builder.Services.AddTransient<IReceptor<CreateOrder, OrderCreated>, CreateOrderReceptor>();
<p></code></pre></p>

<p>With <strong>Whizbang.Generators</strong>, receptors are discovered automatically:</p>

<ul><li>Ensure <code>Whizbang.Generators</code> package is referenced</li>
<li>Remove manual receptor registrations</li>
<li>Add auto-discovery:</li>
</ul><p>   <pre><code class="language-csharp">   builder.Services.AddWhizbangCore();</p>
<p>   builder.Services.AddDiscoveredReceptors(); // Auto-registers all IReceptor implementations</p>
<p>   </code></pre></p>
<ul><li>Rebuild: <code>dotnet build</code></li>
<li>Check <code>.whizbang-generated/ReceptorRegistrations.g.cs</code> for generated code</li>
</ul>
<strong>Benefits</strong>:
<ul><li>No manual registration needed</li>
<li>Compile-time verification</li>
<li>AOT-compatible</li>
<li>Zero reflection</li>
</ul>
<h3>Add Perspectives (Read Models)</h3>

<p>Perspectives listen to events and update read models:</p>

<strong>Perspectives/OrderSummaryPerspective.cs</strong>:
<pre><code class="language-csharp">using Whizbang.Core;
<p>using QuickStartApp.API.Messages;</p>

<p>public class OrderSummaryPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>    private readonly ILogger<OrderSummaryPerspective> _logger;</p>
<p>    // In real app: inject IDbConnectionFactory or DbContext</p>

<p>    public OrderSummaryPerspective(ILogger<OrderSummaryPerspective> logger) {</p>
<p>        _logger = logger;</p>
<p>    }</p>

<p>    public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>        _logger.LogInformation(</p>
<p>            "Updating order summary for {OrderId} - Total: {Total:C}",</p>
<p>            @event.OrderId, @event.Total</p>
<p>        );</p>

<p>        // In real app: update denormalized read model in database</p>
<p>        // await _db.ExecuteAsync("INSERT INTO order_summaries (...) VALUES (...)", @event);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<p>Register perspective:</p>
<pre><code class="language-csharp">builder.Services.AddTransient<IPerspectiveOf<OrderCreated>, OrderSummaryPerspective>();
<p>// Or use AddDiscoveredPerspectives() with Whizbang.Generators</p>
<p></code></pre></p>

<p>Publish events after receptor completes:</p>
<pre><code class="language-csharp">var result = await _dispatcher.LocalInvokeAsync<CreateOrder, OrderCreated>(command, ct);

<p>// Publish event to all perspectives</p>
<p>await _dispatcher.PublishAsync(result, ct);</p>
<p></code></pre></p>

<h3>Add Data Persistence</h3>

<p>Install Dapper + PostgreSQL:</p>
<pre><code class="language-bash">dotnet add package Whizbang.Data.Dapper.Postgres
<p></code></pre></p>

<p>Configure connection string in <strong>appsettings.Development.json</strong>:</p>
<pre><code class="language-json">{
<p>  "ConnectionStrings": {</p>
<p>    "DefaultConnection": "Host=localhost;Database=quickstart;Username=postgres;Password=your_password"</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<p>Register database:</p>
<pre><code class="language-csharp">builder.Services.AddWhizbangDapper(
<p>    builder.Configuration.GetConnectionString("DefaultConnection")!</p>
<p>);</p>
<p></code></pre></p>

<p>Use in receptor:</p>
<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public CreateOrderReceptor(IDbConnectionFactory db) {</p>
<p>        _db = db;</p>
<p>    }</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(CreateOrder message, CancellationToken ct = default) {</p>
<p>        // Save to database</p>
<p>        await using var conn = _db.CreateConnection();</p>
<p>        await conn.ExecuteAsync(</p>
<p>            "INSERT INTO orders (order_id, customer_id, product_name, quantity, unit_price, total, created_at) VALUES (@OrderId, @CustomerId, @ProductName, @Quantity, @UnitPrice, @Total, @CreatedAt)",</p>
<p>            new {</p>
<p>                OrderId = orderId,</p>
<p>                message.CustomerId,</p>
<p>                message.ProductName,</p>
<p>                message.Quantity,</p>
<p>                message.UnitPrice,</p>
<p>                Total = total,</p>
<p>                CreatedAt = DateTimeOffset.UtcNow</p>
<p>            }</p>
<p>        );</p>

<p>        return new OrderCreated(/<em> ... </em>/);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Add Tests</h3>

<p>Install testing packages:</p>
<pre><code class="language-bash">dotnet new tunit -n QuickStartApp.API.Tests
<p>cd QuickStartApp.API.Tests</p>
<p>dotnet add package Whizbang.Testing</p>
<p>dotnet add package TUnit.Assertions</p>
<p>dotnet add reference ../QuickStartApp.API</p>
<p></code></pre></p>

<p>Test your receptor:</p>
<pre><code class="language-csharp">using TUnit.Assertions;
<p>using QuickStartApp.API.Messages;</p>
<p>using QuickStartApp.API.Receptors;</p>

<p>public class CreateOrderReceptorTests {</p>
<p>    [Test]</p>
<p>    public async Task HandleAsync_ValidOrder_ReturnsOrderCreated() {</p>
<p>        // Arrange</p>
<p>        var logger = new NullLogger<CreateOrderReceptor>();</p>
<p>        var receptor = new CreateOrderReceptor(logger);</p>

<p>        var command = new CreateOrder(</p>
<p>            CustomerId: Guid.NewGuid(),</p>
<p>            ProductName: "Test Product",</p>
<p>            Quantity: 5,</p>
<p>            UnitPrice: 19.99m</p>
<p>        );</p>

<p>        // Act</p>
<p>        var result = await receptor.HandleAsync(command);</p>

<p>        // Assert</p>
<p>        await Assert.That(result.OrderId).IsNotEqualTo(Guid.Empty);</p>
<p>        await Assert.That(result.CustomerId).IsEqualTo(command.CustomerId);</p>
<p>        await Assert.That(result.ProductName).IsEqualTo("Test Product");</p>
<p>        await Assert.That(result.Quantity).IsEqualTo(5);</p>
<p>        await Assert.That(result.UnitPrice).IsEqualTo(19.99m);</p>
<p>        await Assert.That(result.Total).IsEqualTo(99.95m);</p>
<p>    }</p>

<p>    [Test]</p>
<p>    public async Task HandleAsync_InvalidQuantity_ThrowsException() {</p>
<p>        // Arrange</p>
<p>        var logger = new NullLogger<CreateOrderReceptor>();</p>
<p>        var receptor = new CreateOrderReceptor(logger);</p>

<p>        var command = new CreateOrder(</p>
<p>            CustomerId: Guid.NewGuid(),</p>
<p>            ProductName: "Test Product",</p>
<p>            Quantity: -1, // Invalid</p>
<p>            UnitPrice: 19.99m</p>
<p>        );</p>

<p>        // Act & Assert</p>
<p>        await Assert.That(async () => await receptor.HandleAsync(command))</p>
<p>            .ThrowsException<InvalidOperationException>()</p>
<p>            .WithMessage("Quantity must be greater than zero");</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<p>Run tests:</p>
<pre><code class="language-bash">dotnet test
<p></code></pre></p>

<h3>Explore the ECommerce Sample</h3>

<p>The complete ECommerce sample demonstrates:</p>
<ul><li><strong>Backend for Frontend (BFF)</strong> with SignalR real-time updates</li>
<li><strong>Microservices</strong> architecture (Order, Inventory, Payment, Shipping, Notification)</li>
<li><strong>Event-driven workflows</strong> with Outbox/Inbox patterns</li>
<li><strong>.NET Aspire orchestration</strong> for local development</li>
<li><strong>Angular 20 UI</strong> with NgRx state management</li>
<li><strong>Integration testing</strong> with TUnit</li>
</ul>
<p>See <a href="../examples/ecommerce/overview.md">ECommerce Tutorial</a> for complete walkthrough.</p>

<h2>Common Patterns</h2>

<h3>Pattern 1: Command → Event</h3>
<pre><code class="language-csharp">CreateOrder (command) → CreateOrderReceptor → OrderCreated (event)
<p></code></pre></p>
<ul><li>Commands express <strong>intent</strong> (imperative: "create order")</li>
<li>Events express <strong>facts</strong> (past tense: "order created")</li>
<li>Receptors make <strong>decisions</strong> and return events</li>
</ul>
<h3>Pattern 2: Event → Perspectives</h3>
<pre><code class="language-csharp">OrderCreated (event) → OrderSummaryPerspective → Update read model
<p>                     → InventoryPerspective → Update stock levels</p>
<p>                     → AnalyticsPerspective → Update dashboards</p>
<p></code></pre></p>
<ul><li>One event can trigger multiple perspectives</li>
<li>Perspectives are <strong>eventually consistent</strong></li>
<li>Each perspective maintains its own optimized read model</li>
</ul>
<h3>Pattern 3: Query via Lenses</h3>
<pre><code class="language-csharp">GET /api/orders/{id} → OrderLens → Query read model → Return DTO
<p></code></pre></p>
<ul><li>Lenses are <strong>query-optimized</strong> repositories</li>
<li>Read from perspectives' denormalized tables</li>
<li>Fast, simple SQL queries (no joins)</li>
</ul>
<h2>Troubleshooting</h2>

<h3>Issue: "No receptor registered for CreateOrder"</h3>

<strong>Symptom</strong>: Runtime exception when calling <code>LocalInvokeAsync</code>

<strong>Solution</strong>:
<ul><li>Verify receptor is registered in <code>Program.cs</code>:</li>
</ul><p>   <pre><code class="language-csharp">   builder.Services.AddTransient<IReceptor<CreateOrder, OrderCreated>, CreateOrderReceptor>();</p>
<p>   </code></pre></p>
<ul><li>Or use auto-discovery:</li>
</ul><p>   <pre><code class="language-csharp">   builder.Services.AddDiscoveredReceptors();</p>
<p>   </code></pre></p>
<ul><li>Rebuild: <code>dotnet clean && dotnet build</code></li>
</ul>
<h3>Issue: "Type 'IDispatcher' not found"</h3>

<strong>Symptom</strong>: Compiler error when injecting IDispatcher

<strong>Solution</strong>:
<ul><li>Add using directive:</li>
</ul><p>   <pre><code class="language-csharp">   using Whizbang.Core;</p>
<p>   </code></pre></p>
<ul><li>Verify package reference:</li>
</ul><p>   <pre><code class="language-bash">   dotnet list package | grep Whizbang.Core</p>
<p>   </code></pre></p>
<ul><li>Restore if missing:</li>
</ul><p>   <pre><code class="language-bash">   dotnet restore</p>
<p>   </code></pre></p>

<h3>Issue: Generated files not appearing</h3>

<strong>Symptom</strong>: Source generators not creating files in <code>.whizbang-generated/</code>

<strong>Solution</strong>:
<ul><li>Ensure <code>Whizbang.Generators</code> package is referenced</li>
<li>Check MSBuild properties in <code>.csproj</code>:</li>
</ul><p>   <pre><code class="language-xml">   <PropertyGroup></p>
<p>     <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles></p>
<p>     <CompilerGeneratedFilesOutputPath>$(MSBuildProjectDirectory)/.whizbang-generated</CompilerGeneratedFilesOutputPath></p>
<p>   </PropertyGroup></p>
<p>   </code></pre></p>
<ul><li>Rebuild:</li>
</ul><p>   <pre><code class="language-bash">   dotnet clean && dotnet build</p>
<p>   </code></pre></p>

<h2>Key Takeaways</h2>

<p>🎯 <strong>Receptors</strong> handle commands and return events</p>
<p>🎯 <strong>Dispatcher</strong> routes messages with compile-time type safety</p>
<p>🎯 <strong>Zero Reflection</strong> - all wiring happens via source generators</p>
<p>🎯 <strong>Type Safety</strong> - compiler enforces message → response relationships</p>
<p>🎯 <strong>Performance</strong> - < 20ns in-process dispatch with zero allocations</p>

<h2>Further Reading</h2>

<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/dispatcher.md">Dispatcher Deep Dive</a> - Three dispatch patterns explained</li>
<li><a href="../core-concepts/receptors.md">Receptors Guide</a> - Advanced receptor patterns</li>
<li><a href="../core-concepts/perspectives.md">Perspectives Guide</a> - Building read models</li>
<li><a href="../core-concepts/lenses.md">Lenses Guide</a> - Query optimization</li>
</ul>
<strong>Messaging Patterns</strong>:
<ul><li><a href="../messaging/outbox-pattern.md">Outbox Pattern</a> - Reliable cross-service messaging</li>
<li><a href="../messaging/inbox-pattern.md">Inbox Pattern</a> - Exactly-once message processing</li>
<li><a href="../messaging/work-coordinator.md">Work Coordination</a> - Distributed work coordination</li>
</ul>
<strong>Advanced Topics</strong>:
<ul><li><a href="../generators/receptor-discovery.md">Source Generators</a> - Auto-discovery internals</li>
<li><a href="../performance/pooling-strategies.md">Performance Tuning</a> - Optimize for scale</li>
<li><a href="../testing/receptor-testing.md">Testing Strategies</a> - Comprehensive testing guide</li>
</ul>
<hr>

<strong>Next</strong>: <a href="project-structure.md">Project Structure Guide</a> - Organize your Whizbang application

<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Graphql</h2>
<article id="v1-0-0-graphql-filtering" class="doc-section">
  <h3>filtering</h3>
  <p class="doc-path"><code>v1.0.0/graphql/filtering</code></p>
  <div class="doc-content">
<h1>GraphQL Filtering</h1>

<p>Whizbang's HotChocolate integration provides powerful filtering capabilities for <code>PerspectiveRow<T></code> data using the standard HotChocolate filtering syntax.</p>

<h2>Basic Filtering</h2>

<p>Filter on data properties using the <code>where</code> argument:</p>

<pre><code class="language-graphql">{
<p>  orders(where: { data: { status: { eq: "Completed" } } }) {</p>
<p>    nodes {</p>
<p>      data {</p>
<p>        customerName</p>
<p>        status</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Filter Operators</h2>

<h3>String Operators</h3>

<pre><code class="language-graphql"># Exact match
<p>where: { data: { customerName: { eq: "Alice" } } }</p>

<h1>Not equal</h1>
<p>where: { data: { customerName: { neq: "Bob" } } }</p>

<h1>Contains</h1>
<p>where: { data: { customerName: { contains: "Corp" } } }</p>

<h1>Starts with</h1>
<p>where: { data: { customerName: { startsWith: "Acme" } } }</p>

<h1>Ends with</h1>
<p>where: { data: { customerName: { endsWith: "Inc" } } }</p>

<h1>In list</h1>
<p>where: { data: { status: { in: ["Pending", "Processing"] } } }</p>

<h1>Not in list</h1>
<p>where: { data: { status: { nin: ["Cancelled", "Refunded"] } } }</p>
<p></code></pre></p>

<h3>Numeric Operators</h3>

<pre><code class="language-graphql"># Equal
<p>where: { data: { totalAmount: { eq: 100.00 } } }</p>

<h1>Greater than</h1>
<p>where: { data: { totalAmount: { gt: 50.00 } } }</p>

<h1>Greater than or equal</h1>
<p>where: { data: { totalAmount: { gte: 100.00 } } }</p>

<h1>Less than</h1>
<p>where: { data: { totalAmount: { lt: 1000.00 } } }</p>

<h1>Less than or equal</h1>
<p>where: { data: { totalAmount: { lte: 500.00 } } }</p>

<h1>Range (between)</h1>
<p>where: {</p>
<p>  and: [</p>
<p>    { data: { totalAmount: { gte: 100.00 } } }</p>
<p>    { data: { totalAmount: { lte: 500.00 } } }</p>
<p>  ]</p>
<p>}</p>
<p></code></pre></p>

<h3>Date/Time Operators</h3>

<pre><code class="language-graphql"># Exact date
<p>where: { data: { createdAt: { eq: "2024-01-15T00:00:00Z" } } }</p>

<h1>After date</h1>
<p>where: { data: { createdAt: { gt: "2024-01-01T00:00:00Z" } } }</p>

<h1>Before date</h1>
<p>where: { data: { createdAt: { lt: "2024-12-31T23:59:59Z" } } }</p>

<h1>Date range</h1>
<p>where: {</p>
<p>  and: [</p>
<p>    { data: { createdAt: { gte: "2024-01-01T00:00:00Z" } } }</p>
<p>    { data: { createdAt: { lt: "2024-02-01T00:00:00Z" } } }</p>
<p>  ]</p>
<p>}</p>
<p></code></pre></p>

<h3>Boolean Operators</h3>

<pre><code class="language-graphql">where: { data: { isActive: { eq: true } } }
<p>where: { data: { isDeleted: { eq: false } } }</p>
<p></code></pre></p>

<h3>Null Checks</h3>

<pre><code class="language-graphql"># Is null
<p>where: { data: { deletedAt: { eq: null } } }</p>

<h1>Is not null</h1>
<p>where: { data: { deletedAt: { neq: null } } }</p>
<p></code></pre></p>

<h2>Logical Operators</h2>

<h3>AND (Implicit)</h3>

<p>Multiple conditions at the same level are AND'd together:</p>

<pre><code class="language-graphql">{
<p>  orders(where: {</p>
<p>    data: {</p>
<p>      status: { eq: "Completed" }</p>
<p>      totalAmount: { gte: 100.00 }</p>
<p>    }</p>
<p>  }) {</p>
<p>    nodes { ... }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>AND (Explicit)</h3>

<pre><code class="language-graphql">{
<p>  orders(where: {</p>
<p>    and: [</p>
<p>      { data: { status: { eq: "Completed" } } }</p>
<p>      { data: { totalAmount: { gte: 100.00 } } }</p>
<p>      { data: { customerName: { contains: "Corp" } } }</p>
<p>    ]</p>
<p>  }) {</p>
<p>    nodes { ... }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>OR</h3>

<pre><code class="language-graphql">{
<p>  orders(where: {</p>
<p>    or: [</p>
<p>      { data: { status: { eq: "Completed" } } }</p>
<p>      { data: { status: { eq: "Shipped" } } }</p>
<p>    ]</p>
<p>  }) {</p>
<p>    nodes { ... }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Complex Combinations</h3>

<pre><code class="language-graphql">{
<p>  orders(where: {</p>
<p>    and: [</p>
<p>      { data: { totalAmount: { gte: 100.00 } } }</p>
<p>      {</p>
<p>        or: [</p>
<p>          { data: { status: { eq: "Completed" } } }</p>
<p>          { data: { status: { eq: "Shipped" } } }</p>
<p>        ]</p>
<p>      }</p>
<p>    ]</p>
<p>  }) {</p>
<p>    nodes { ... }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Filtering on System Fields</h2>

<p>Filter on <code>PerspectiveRow</code> system fields:</p>

<pre><code class="language-graphql"># By ID
<p>{</p>
<p>  orders(where: { id: { eq: "550e8400-e29b-41d4-a716-446655440000" } }) {</p>
<p>    nodes { ... }</p>
<p>  }</p>
<p>}</p>

<h1>By version</h1>
<p>{</p>
<p>  orders(where: { version: { gte: 2 } }) {</p>
<p>    nodes { ... }</p>
<p>  }</p>
<p>}</p>

<h1>By creation date</h1>
<p>{</p>
<p>  orders(where: { createdAt: { gte: "2024-01-01T00:00:00Z" } }) {</p>
<p>    nodes { ... }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Filtering on Metadata</h2>

<p>When metadata is exposed (scope includes <code>Metadata</code>):</p>

<pre><code class="language-graphql">{
<p>  orders(where: {</p>
<p>    metadata: {</p>
<p>      eventType: { eq: "OrderCreated" }</p>
<p>    }</p>
<p>  }) {</p>
<p>    nodes {</p>
<p>      metadata {</p>
<p>        eventType</p>
<p>        correlationId</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Filtering on Scope</h2>

<p>When scope is exposed (scope includes <code>Scope</code>):</p>

<pre><code class="language-graphql">{
<p>  adminOrders(where: {</p>
<p>    scope: {</p>
<p>      tenantId: { eq: "tenant-123" }</p>
<p>    }</p>
<p>  }) {</p>
<p>    nodes {</p>
<p>      scope {</p>
<p>        tenantId</p>
<p>        userId</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Filtering with Variables</h2>

<p>Use GraphQL variables for dynamic filtering:</p>

<pre><code class="language-graphql">query GetOrders($status: String!, $minAmount: Decimal!) {
<p>  orders(where: {</p>
<p>    and: [</p>
<p>      { data: { status: { eq: $status } } }</p>
<p>      { data: { totalAmount: { gte: $minAmount } } }</p>
<p>    ]</p>
<p>  }) {</p>
<p>    nodes {</p>
<p>      data {</p>
<p>        customerName</p>
<p>        status</p>
<p>        totalAmount</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<p>Variables:</p>
<pre><code class="language-json">{
<p>  "status": "Completed",</p>
<p>  "minAmount": 100.00</p>
<p>}</p>
<p></code></pre></p>

<h2>Performance Considerations</h2>

<ul><li><strong>Index your filter columns</strong> - Ensure database indexes exist for commonly filtered fields</li>
<li><strong>Avoid wide OR clauses</strong> - Multiple OR conditions can prevent index usage</li>
<li><strong>Use paging</strong> - Always combine filtering with paging for large datasets</li>
<li><strong>Project only needed fields</strong> - GraphQL projection optimizes the SQL query</li>
</ul>
<h2>Next Steps</h2>

<ul><li><a href="sorting.md">Sorting</a> - Sort operations</li>
<li><a href="scoping.md">Scoping</a> - Automatic tenant filtering</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-graphql-index" class="doc-section">
  <h3>index</h3>
  <p class="doc-path"><code>v1.0.0/graphql/index</code></p>
  <div class="doc-content">
<h1>GraphQL Integration</h1>

<p>Whizbang provides seamless HotChocolate GraphQL integration for Lenses, enabling powerful filtering, sorting, paging, and projection capabilities with full AOT compatibility.</p>

<h2>Overview</h2>

<p>The <code>Whizbang.Transports.HotChocolate</code> package integrates Whizbang Lenses with <a href="https://chillicream.com/docs/hotchocolate">HotChocolate</a>, providing:</p>

<ul><li><strong>Automatic Query Generation</strong> - Source generators create type-safe GraphQL queries from <code>[GraphQLLens]</code> attributes</li>
<li><strong>Full Data Operations</strong> - <code>[UseFiltering]</code>, <code>[UseSorting]</code>, <code>[UsePaging]</code>, <code>[UseProjection]</code> support</li>
<li><strong>Scope-Aware Queries</strong> - Multi-tenancy and security filtering via middleware</li>
<li><strong>AOT Compatible</strong> - Zero reflection, source-generated at compile time</li>
</ul>
<h2>Quick Start</h2>

<h3>1. Install the Package</h3>

<pre><code class="language-bash">dotnet add package Whizbang.Transports.HotChocolate
<p></code></pre></p>

<h3>2. Define Your Lens</h3>

<pre><code class="language-csharp">[GraphQLLens(QueryName = "orders")]
<p>public interface IOrderLens : ILensQuery<OrderReadModel> { }</p>
<p></code></pre></p>

<h3>3. Configure Services</h3>

<pre><code class="language-csharp">// Program.cs
<p>builder.Services.AddGraphQLServer()</p>
<p>    .AddWhizbangLenses()</p>
<p>    .AddQueryType<Query>();</p>

<p>// Add scope middleware for multi-tenancy</p>
<p>builder.Services.AddWhizbangScope();</p>

<p>var app = builder.Build();</p>
<p>app.UseWhizbangScope();</p>
<p>app.MapGraphQL();</p>
<p></code></pre></p>

<h3>4. Query Your Data</h3>

<pre><code class="language-graphql">{
<p>  orders(</p>
<p>    where: { data: { status: { eq: "Completed" } } }</p>
<p>    order: { data: { createdAt: DESC } }</p>
<p>    first: 10</p>
<p>  ) {</p>
<p>    nodes {</p>
<p>      id</p>
<p>      data {</p>
<p>        customerName</p>
<p>        status</p>
<p>        totalAmount</p>
<p>      }</p>
<p>      metadata {</p>
<p>        eventType</p>
<p>        timestamp</p>
<p>      }</p>
<p>    }</p>
<p>    pageInfo {</p>
<p>      hasNextPage</p>
<p>      endCursor</p>
<p>    }</p>
<p>    totalCount</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Documentation</h2>

<p>| Topic | Description |</p>
<p>|-------|-------------|</p>
<p>| <a href="setup.md">Setup</a> | Installation and configuration |</p>
<p>| <a href="lens-integration.md">Lens Integration</a> | Using <code>[GraphQLLens]</code> attribute |</p>
<p>| <a href="filtering.md">Filtering</a> | Query filtering examples |</p>
<p>| <a href="sorting.md">Sorting</a> | Sort operations |</p>
<p>| <a href="scoping.md">Scoping</a> | Multi-tenancy and security |</p>

<h2>Architecture</h2>

<pre><code class="language-">┌─────────────────────────────────────────────────────────────┐
<p>│                    GraphQL Request                          │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>                              │</p>
<p>                              ▼</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<p>│              WhizbangScopeMiddleware                        │</p>
<p>│  - Extracts TenantId, UserId from claims/headers            │</p>
<p>│  - Sets IScopeContext for request                           │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>                              │</p>
<p>                              ▼</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<p>│                 HotChocolate Execution                      │</p>
<p>│  - [UseFiltering] → WhizbangFilterConvention                │</p>
<p>│  - [UseSorting]   → WhizbangSortConvention                  │</p>
<p>│  - [UsePaging]    → Relay-style pagination                  │</p>
<p>│  - [UseProjection]→ Efficient field selection               │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>                              │</p>
<p>                              ▼</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<p>│                   ILensQuery<TModel>                        │</p>
<p>│  - Scope-filtered IQueryable                                │</p>
<p>│  - PerspectiveRow<TModel> with Data, Metadata, Scope        │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<h2>Key Types</h2>

<p>| Type | Purpose |</p>
<p>|------|---------|</p>
<p>| <code>GraphQLLensAttribute</code> | Marks lens interfaces for GraphQL exposure |</p>
<p>| <code>GraphQLLensScope</code> | Controls which fields are exposed (Data, Metadata, Scope, SystemFields) |</p>
<p>| <code>WhizbangScopeMiddleware</code> | Extracts scope from HTTP context |</p>
<p>| <code>WhizbangScopeOptions</code> | Configures claim/header mappings |</p>
<p>| <code>PerspectiveRow<T></code> | Wrapper with Data, Metadata, Scope, and system fields |</p>

<h2>Related Documentation</h2>

<ul><li><a href="/docs/v1.0.0/core-concepts/lenses">Lenses Overview</a></li>
<li><a href="/docs/v1.0.0/core-concepts/security">Security & Scoping</a></li>
<li><a href="https://chillicream.com/docs/hotchocolate">HotChocolate Documentation</a></li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-graphql-lens-integration" class="doc-section">
  <h3>lens integration</h3>
  <p class="doc-path"><code>v1.0.0/graphql/lens-integration</code></p>
  <div class="doc-content">
<h1>Lens Integration</h1>

<p>The <code>[GraphQLLens]</code> attribute marks lens interfaces for GraphQL exposure, enabling automatic query generation with configurable filtering, sorting, and paging.</p>

<h2>Basic Usage</h2>

<pre><code class="language-csharp">[GraphQLLens(QueryName = "orders")]
<p>public interface IOrderLens : ILensQuery<OrderReadModel> { }</p>
<p></code></pre></p>

<p>This generates a GraphQL query field named <code>orders</code> with full data operations support.</p>

<h2>Attribute Properties</h2>

<p>| Property | Type | Default | Description |</p>
<p>|----------|------|---------|-------------|</p>
<p>| <code>QueryName</code> | <code>string</code> | Interface name | GraphQL field name |</p>
<p>| <code>Scope</code> | <code>GraphQLLensScope</code> | <code>Default</code> | Which fields to expose |</p>
<p>| <code>EnableFiltering</code> | <code>bool</code> | <code>true</code> | Enable <code>where</code> argument |</p>
<p>| <code>EnableSorting</code> | <code>bool</code> | <code>true</code> | Enable <code>order</code> argument |</p>
<p>| <code>EnablePaging</code> | <code>bool</code> | <code>true</code> | Enable Relay-style paging |</p>
<p>| <code>EnableProjection</code> | <code>bool</code> | <code>true</code> | Enable field selection optimization |</p>
<p>| <code>DefaultPageSize</code> | <code>int</code> | <code>10</code> | Default items per page |</p>
<p>| <code>MaxPageSize</code> | <code>int</code> | <code>100</code> | Maximum items per page |</p>

<h2>GraphQLLensScope</h2>

<p>Control which parts of <code>PerspectiveRow<T></code> are exposed:</p>

<pre><code class="language-csharp">[Flags]
<p>public enum GraphQLLensScope {</p>
<p>    Default = 0,           // Use system default</p>
<p>    Data = 1 << 0,         // TModel properties</p>
<p>    Metadata = 1 << 1,     // EventType, CorrelationId, Timestamp</p>
<p>    Scope = 1 << 2,        // TenantId, UserId, OrganizationId</p>
<p>    SystemFields = 1 << 3, // Id, Version, CreatedAt, UpdatedAt</p>

<p>    // Presets</p>
<p>    DataOnly = Data,</p>
<p>    NoData = Metadata | Scope | SystemFields,</p>
<p>    All = Data | Metadata | Scope | SystemFields</p>
<p>}</p>
<p></code></pre></p>

<h2>Configuration Examples</h2>

<h3>Data Only (Default)</h3>

<p>Expose only the business data:</p>

<pre><code class="language-csharp">[GraphQLLens(QueryName = "products", Scope = GraphQLLensScope.DataOnly)]
<p>public interface IProductLens : ILensQuery<ProductReadModel> { }</p>
<p></code></pre></p>

<pre><code class="language-graphql">{
<p>  products {</p>
<p>    nodes {</p>
<p>      data {</p>
<p>        name</p>
<p>        price</p>
<p>        category</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>With Metadata</h3>

<p>Include event sourcing metadata:</p>

<pre><code class="language-csharp">[GraphQLLens(
<p>    QueryName = "auditLog",</p>
<p>    Scope = GraphQLLensScope.Data | GraphQLLensScope.Metadata | GraphQLLensScope.SystemFields)]</p>
<p>public interface IAuditLens : ILensQuery<AuditReadModel> { }</p>
<p></code></pre></p>

<pre><code class="language-graphql">{
<p>  auditLog {</p>
<p>    nodes {</p>
<p>      id</p>
<p>      version</p>
<p>      data {</p>
<p>        action</p>
<p>        description</p>
<p>      }</p>
<p>      metadata {</p>
<p>        eventType</p>
<p>        correlationId</p>
<p>        timestamp</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Full Row (Admin View)</h3>

<p>Expose everything including scope data:</p>

<pre><code class="language-csharp">[GraphQLLens(QueryName = "adminOrders", Scope = GraphQLLensScope.All)]
<p>public interface IAdminOrderLens : ILensQuery<OrderReadModel> { }</p>
<p></code></pre></p>

<pre><code class="language-graphql">{
<p>  adminOrders {</p>
<p>    nodes {</p>
<p>      id</p>
<p>      version</p>
<p>      createdAt</p>
<p>      updatedAt</p>
<p>      data {</p>
<p>        customerName</p>
<p>        status</p>
<p>      }</p>
<p>      metadata {</p>
<p>        eventType</p>
<p>        correlationId</p>
<p>      }</p>
<p>      scope {</p>
<p>        tenantId</p>
<p>        userId</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Filter-Only (No Paging)</h3>

<p>Disable paging for simple lists:</p>

<pre><code class="language-csharp">[GraphQLLens(
<p>    QueryName = "statuses",</p>
<p>    EnablePaging = false,</p>
<p>    EnableSorting = false)]</p>
<p>public interface IStatusLens : ILensQuery<StatusReadModel> { }</p>
<p></code></pre></p>

<pre><code class="language-graphql">{
<p>  statuses(where: { data: { isActive: { eq: true } } }) {</p>
<p>    id</p>
<p>    data {</p>
<p>      name</p>
<p>      isActive</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Custom Page Sizes</h3>

<p>Configure paging limits:</p>

<pre><code class="language-csharp">[GraphQLLens(
<p>    QueryName = "transactions",</p>
<p>    DefaultPageSize = 50,</p>
<p>    MaxPageSize = 500)]</p>
<p>public interface ITransactionLens : ILensQuery<TransactionReadModel> { }</p>
<p></code></pre></p>

<h2>Generated Schema</h2>

<p>For a lens like:</p>

<pre><code class="language-csharp">[GraphQLLens(QueryName = "orders")]
<p>public interface IOrderLens : ILensQuery<OrderReadModel> { }</p>

<p>public record OrderReadModel {</p>
<p>    public string CustomerName { get; init; }</p>
<p>    public string Status { get; init; }</p>
<p>    public decimal TotalAmount { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<p>The generated GraphQL schema includes:</p>

<pre><code class="language-graphql">type Query {
<p>  orders(</p>
<p>    where: OrderFilterInput</p>
<p>    order: [OrderSortInput!]</p>
<p>    first: Int</p>
<p>    after: String</p>
<p>    last: Int</p>
<p>    before: String</p>
<p>  ): OrdersConnection</p>
<p>}</p>

<p>type OrdersConnection {</p>
<p>  nodes: [Order!]</p>
<p>  edges: [OrderEdge!]</p>
<p>  pageInfo: PageInfo!</p>
<p>  totalCount: Int!</p>
<p>}</p>

<p>type Order {</p>
<p>  id: UUID!</p>
<p>  version: Int!</p>
<p>  data: OrderData!</p>
<p>  metadata: PerspectiveMetadata</p>
<p>  scope: PerspectiveScope</p>
<p>  createdAt: DateTime!</p>
<p>  updatedAt: DateTime!</p>
<p>}</p>

<p>type OrderData {</p>
<p>  customerName: String!</p>
<p>  status: String!</p>
<p>  totalAmount: Decimal!</p>
<p>}</p>

<p>input OrderFilterInput {</p>
<p>  and: [OrderFilterInput!]</p>
<p>  or: [OrderFilterInput!]</p>
<p>  data: OrderDataFilterInput</p>
<p>  id: UuidOperationFilterInput</p>
<p>  version: IntOperationFilterInput</p>
<p>}</p>
<p></code></pre></p>

<h2>Multiple Lenses for Same Model</h2>

<p>You can create multiple lenses for the same model with different configurations:</p>

<pre><code class="language-csharp">// Public API - data only
<p>[GraphQLLens(QueryName = "orders", Scope = GraphQLLensScope.DataOnly)]</p>
<p>public interface IOrderLens : ILensQuery<OrderReadModel> { }</p>

<p>// Admin API - full access</p>
<p>[GraphQLLens(QueryName = "adminOrders", Scope = GraphQLLensScope.All)]</p>
<p>public interface IAdminOrderLens : ILensQuery<OrderReadModel> { }</p>

<p>// Audit API - metadata focus</p>
<p>[GraphQLLens(</p>
<p>    QueryName = "orderAudit",</p>
<p>    Scope = GraphQLLensScope.Metadata | GraphQLLensScope.SystemFields,</p>
<p>    EnableFiltering = false)]</p>
<p>public interface IOrderAuditLens : ILensQuery<OrderReadModel> { }</p>
<p></code></pre></p>

<h2>Next Steps</h2>

<ul><li><a href="filtering.md">Filtering</a> - Query filtering syntax</li>
<li><a href="sorting.md">Sorting</a> - Sort operations</li>
<li><a href="scoping.md">Scoping</a> - Multi-tenancy filtering</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-graphql-scoping" class="doc-section">
  <h3>scoping</h3>
  <p class="doc-path"><code>v1.0.0/graphql/scoping</code></p>
  <div class="doc-content">
<h1>GraphQL Scoping</h1>

<p>Whizbang's scope middleware provides automatic multi-tenancy and security filtering for GraphQL queries, ensuring users only see data they're authorized to access.</p>

<h2>Overview</h2>

<p>The <code>WhizbangScopeMiddleware</code> extracts scope information from HTTP requests (JWT claims and headers) and makes it available to lens queries for automatic filtering.</p>

<pre><code class="language-">HTTP Request
<p>    │</p>
<p>    ├── JWT Claims (tenant_id, sub, groups, ...)</p>
<p>    ├── Headers (X-Tenant-Id, X-User-Id, ...)</p>
<p>    │</p>
<p>    ▼</p>
<p>WhizbangScopeMiddleware</p>
<p>    │</p>
<p>    ├── Extracts scope values</p>
<p>    ├── Creates IScopeContext</p>
<p>    │</p>
<p>    ▼</p>
<p>IScopeContextAccessor.Current</p>
<p>    │</p>
<p>    ▼</p>
<p>Lens Query (automatic filtering)</p>
<p></code></pre></p>

<h2>Setup</h2>

<h3>1. Register Services</h3>

<pre><code class="language-csharp">builder.Services.AddWhizbangScope();
<p></code></pre></p>

<h3>2. Add Middleware</h3>

<pre><code class="language-csharp">app.UseAuthentication();
<p>app.UseWhizbangScope();  // After auth</p>
<p>app.MapGraphQL();</p>
<p></code></pre></p>

<h2>Configuration</h2>

<h3>Default Claim/Header Mappings</h3>

<p>| Scope Value | Claim Type | Header Name |</p>
<p>|-------------|-----------|-------------|</p>
<p>| TenantId | <code>tenant_id</code> | <code>X-Tenant-Id</code> |</p>
<p>| UserId | <code>ClaimTypes.NameIdentifier</code> | <code>X-User-Id</code> |</p>
<p>| OrganizationId | <code>org_id</code> | <code>X-Organization-Id</code> |</p>
<p>| CustomerId | <code>customer_id</code> | <code>X-Customer-Id</code> |</p>
<p>| Roles | <code>ClaimTypes.Role</code> | - |</p>
<p>| Groups | <code>groups</code> | - |</p>

<h3>Custom Configuration</h3>

<pre><code class="language-csharp">builder.Services.AddWhizbangScope(options => {
<p>    // Custom claim types</p>
<p>    options.TenantIdClaimType = "https://myapp.com/tenant_id";</p>
<p>    options.UserIdClaimType = "sub";</p>
<p>    options.GroupsClaimType = "https://myapp.com/groups";</p>

<p>    // Custom header names</p>
<p>    options.TenantIdHeaderName = "X-My-Tenant";</p>

<p>    // Extension mappings</p>
<p>    options.ExtensionClaimMappings["region"] = "Region";</p>
<p>    options.ExtensionClaimMappings["department"] = "Department";</p>
<p>});</p>
<p></code></pre></p>

<h2>How Scoping Works</h2>

<h3>1. Scope Extraction</h3>

<p>The middleware extracts scope from the request:</p>

<pre><code class="language-csharp">// JWT claims take priority over headers
<p>var tenantId = context.User?.FindFirst("tenant_id")?.Value</p>
<p>    ?? context.Request.Headers["X-Tenant-Id"];</p>
<p></code></pre></p>

<h3>2. Context Population</h3>

<p>The scope context is populated with:</p>

<pre><code class="language-csharp">scopeContextAccessor.Current = new RequestScopeContext {
<p>    Scope = new PerspectiveScope {</p>
<p>        TenantId = "tenant-123",</p>
<p>        UserId = "user-456",</p>
<p>        OrganizationId = "org-789"</p>
<p>    },</p>
<p>    Roles = ["Admin", "User"],</p>
<p>    SecurityPrincipals = [</p>
<p>        SecurityPrincipalId.User("user-456"),</p>
<p>        SecurityPrincipalId.Group("sales-team")</p>
<p>    ],</p>
<p>    Claims = { ... }</p>
<p>};</p>
<p></code></pre></p>

<h3>3. Lens Filtering</h3>

<p>Your lens implementation uses the scope context:</p>

<pre><code class="language-csharp">public class ScopedOrderLens : IOrderLens {
<p>    private readonly IScopeContextAccessor _scopeContextAccessor;</p>
<p>    private readonly DbContext _db;</p>

<p>    public IQueryable<PerspectiveRow<OrderReadModel>> Query {</p>
<p>        get {</p>
<p>            var context = _scopeContextAccessor.Current;</p>
<p>            var query = _db.Orders.AsQueryable();</p>

<p>            // Filter by tenant</p>
<p>            if (!string.IsNullOrEmpty(context?.Scope.TenantId)) {</p>
<p>                query = query.Where(o => o.Scope.TenantId == context.Scope.TenantId);</p>
<p>            }</p>

<p>            // Filter by allowed principals (array overlap)</p>
<p>            if (context?.SecurityPrincipals.Count > 0) {</p>
<p>                query = query.Where(o =></p>
<p>                    o.Scope.AllowedPrincipals == null ||</p>
<p>                    o.Scope.AllowedPrincipals.Any(p =></p>
<p>                        context.SecurityPrincipals.Contains(p)));</p>
<p>            }</p>

<p>            return query;</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Security Principal Filtering</h2>

<h3>Row-Level Security</h3>

<p>Each <code>PerspectiveRow</code> can have <code>AllowedPrincipals</code>:</p>

<pre><code class="language-csharp">var order = new PerspectiveRow<OrderReadModel> {
<p>    Data = orderData,</p>
<p>    Scope = new PerspectiveScope {</p>
<p>        TenantId = "tenant-123",</p>
<p>        AllowedPrincipals = [</p>
<p>            SecurityPrincipalId.User("user-456"),</p>
<p>            SecurityPrincipalId.Group("sales-team")</p>
<p>        ]</p>
<p>    }</p>
<p>};</p>
<p></code></pre></p>

<h3>Query Filtering</h3>

<p>The lens filters using "array overlap":</p>

<pre><code class="language-sql">-- PostgreSQL example
<p>WHERE scope->'AllowedPrincipals' ?| ARRAY['user:user-456', 'group:sales-team']</p>
<p></code></pre></p>

<h2>Accessing Scope in Resolvers</h2>

<h3>Via IScopeContextAccessor</h3>

<pre><code class="language-csharp">public class Query {
<p>    public CurrentUser GetCurrentUser([Service] IScopeContextAccessor accessor) {</p>
<p>        var context = accessor.Current;</p>
<p>        return new CurrentUser {</p>
<p>            UserId = context?.Scope.UserId,</p>
<p>            TenantId = context?.Scope.TenantId,</p>
<p>            Roles = context?.Roles.ToList() ?? []</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Exposing Current Scope</h3>

<pre><code class="language-graphql">type Query {
<p>  currentScope: ScopeInfo!</p>
<p>  orders(...): OrdersConnection</p>
<p>}</p>

<p>type ScopeInfo {</p>
<p>  tenantId: String</p>
<p>  userId: String</p>
<p>  organizationId: String</p>
<p>  roles: [String!]!</p>
<p>}</p>
<p></code></pre></p>

<h2>Multi-Tenancy Patterns</h2>

<h3>Tenant-Per-Row</h3>

<p>Each row has a <code>TenantId</code> in its scope:</p>

<pre><code class="language-csharp">[GraphQLLens(QueryName = "orders")]
<p>public interface IOrderLens : ILensQuery<OrderReadModel> { }</p>

<p>// Lens filters by TenantId from context</p>
<p></code></pre></p>

<h3>Tenant-Per-Database</h3>

<p>Different databases per tenant (configured at startup):</p>

<pre><code class="language-csharp">builder.Services.AddScoped<IOrderLens>(sp => {
<p>    var context = sp.GetRequiredService<IScopeContextAccessor>().Current;</p>
<p>    var tenantId = context?.Scope.TenantId ?? "default";</p>
<p>    var connectionString = GetTenantConnectionString(tenantId);</p>
<p>    return new EFCoreOrderLens(connectionString);</p>
<p>});</p>
<p></code></pre></p>

<h2>Permission Checks</h2>

<h3>In Resolvers</h3>

<pre><code class="language-csharp">public class Query {
<p>    public async Task<Order?> GetOrder(</p>
<p>        Guid id,</p>
<p>        [Service] IOrderLens lens,</p>
<p>        [Service] IScopeContextAccessor accessor) {</p>

<p>        var context = accessor.Current;</p>

<p>        // Check permission</p>
<p>        if (!context?.HasPermission(Permission.Read("orders")) ?? true) {</p>
<p>            throw new UnauthorizedAccessException();</p>
<p>        }</p>

<p>        return await lens.GetByIdAsync(id);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>With Attributes</h3>

<pre><code class="language-csharp">[RequirePermission("orders:read")]
<p>public IQueryable<PerspectiveRow<OrderReadModel>> GetOrders(</p>
<p>    [Service] IOrderLens lens) {</p>
<p>    return lens.Query;</p>
<p>}</p>
<p></code></pre></p>

<h2>Testing Scoped Queries</h2>

<pre><code class="language-csharp">[Test]
<p>public async Task Query_FiltersByTenantAsync() {</p>
<p>    // Arrange</p>
<p>    var scopeAccessor = new TestScopeContextAccessor();</p>
<p>    scopeAccessor.Current = new TestScopeContext {</p>
<p>        Scope = new PerspectiveScope { TenantId = "tenant-a" }</p>
<p>    };</p>

<p>    var lens = new ScopedOrderLens(scopeAccessor, db);</p>

<p>    // Add test data</p>
<p>    db.Orders.Add(CreateOrder("tenant-a"));</p>
<p>    db.Orders.Add(CreateOrder("tenant-b"));</p>
<p>    await db.SaveChangesAsync();</p>

<p>    // Act</p>
<p>    var results = await lens.Query.ToListAsync();</p>

<p>    // Assert</p>
<p>    Assert.That(results).AllSatisfy(r =></p>
<p>        Assert.That(r.Scope.TenantId).IsEqualTo("tenant-a"));</p>
<p>}</p>
<p></code></pre></p>

<h2>Best Practices</h2>

<ul><li><strong>Always filter by scope</strong> - Never bypass scope filtering, even for admin queries</li>
<li><strong>Use row-level security</strong> - Combine tenant filtering with principal filtering</li>
<li><strong>Validate scope values</strong> - Don't trust scope values for authorization decisions alone</li>
<li><strong>Log scope context</strong> - Include scope in audit logs for troubleshooting</li>
<li><strong>Test with multiple tenants</strong> - Ensure queries don't leak data across tenants</li>
</ul>
<h2>Related Documentation</h2>

<ul><li><a href="setup.md">Setup</a> - Initial configuration</li>
<li><a href="filtering.md">Filtering</a> - Query filtering</li>
<li><a href="/docs/v1.0.0/core-concepts/security">Security</a> - Security principals and permissions</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-graphql-setup" class="doc-section">
  <h3>setup</h3>
  <p class="doc-path"><code>v1.0.0/graphql/setup</code></p>
  <div class="doc-content">
<h1>GraphQL Setup</h1>

<p>This guide covers installation and configuration of Whizbang's HotChocolate GraphQL integration.</p>

<h2>Installation</h2>

<pre><code class="language-bash">dotnet add package Whizbang.Transports.HotChocolate
<p></code></pre></p>

<h2>Basic Configuration</h2>

<h3>Minimal Setup</h3>

<pre><code class="language-csharp">// Program.cs
<p>var builder = WebApplication.CreateBuilder(args);</p>

<p>builder.Services</p>
<p>    .AddGraphQLServer()</p>
<p>    .AddWhizbangLenses()</p>
<p>    .AddQueryType<Query>();</p>

<p>var app = builder.Build();</p>
<p>app.MapGraphQL();</p>
<p>app.Run();</p>
<p></code></pre></p>

<h3>With Scope Middleware</h3>

<p>For multi-tenancy and security filtering:</p>

<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);

<p>// Add services</p>
<p>builder.Services.AddWhizbangScope();</p>
<p>builder.Services</p>
<p>    .AddGraphQLServer()</p>
<p>    .AddWhizbangLenses()</p>
<p>    .AddQueryType<Query>();</p>

<p>var app = builder.Build();</p>

<p>// Middleware order matters</p>
<p>app.UseAuthentication();</p>
<p>app.UseWhizbangScope();  // After auth, before GraphQL</p>
<p>app.MapGraphQL();</p>

<p>app.Run();</p>
<p></code></pre></p>

<h2>Configuration Options</h2>

<h3>WhizbangGraphQLOptions</h3>

<p>Configure default behavior for all lenses:</p>

<pre><code class="language-csharp">builder.Services
<p>    .AddGraphQLServer()</p>
<p>    .AddWhizbangLenses(options => {</p>
<p>        options.DefaultScope = GraphQLLensScope.Data | GraphQLLensScope.SystemFields;</p>
<p>        options.DefaultPageSize = 25;</p>
<p>        options.MaxPageSize = 200;</p>
<p>    });</p>
<p></code></pre></p>

<p>| Option | Default | Description |</p>
<p>|--------|---------|-------------|</p>
<p>| <code>DefaultScope</code> | <code>DataOnly</code> | Fields exposed by default |</p>
<p>| <code>DefaultPageSize</code> | <code>10</code> | Default page size for paging |</p>
<p>| <code>MaxPageSize</code> | <code>100</code> | Maximum allowed page size |</p>

<h3>WhizbangScopeOptions</h3>

<p>Configure scope extraction from HTTP context:</p>

<pre><code class="language-csharp">builder.Services.AddWhizbangScope(options => {
<p>    // Claim types</p>
<p>    options.TenantIdClaimType = "tenant_id";</p>
<p>    options.UserIdClaimType = ClaimTypes.NameIdentifier;</p>
<p>    options.OrganizationIdClaimType = "org_id";</p>
<p>    options.CustomerIdClaimType = "customer_id";</p>

<p>    // Header names (fallback if claim not present)</p>
<p>    options.TenantIdHeaderName = "X-Tenant-Id";</p>
<p>    options.UserIdHeaderName = "X-User-Id";</p>

<p>    // Custom extensions</p>
<p>    options.ExtensionClaimMappings["region"] = "Region";</p>
<p>    options.ExtensionHeaderMappings["X-Region"] = "Region";</p>
<p>});</p>
<p></code></pre></p>

<p>| Option | Default | Description |</p>
<p>|--------|---------|-------------|</p>
<p>| <code>TenantIdClaimType</code> | <code>"tenant_id"</code> | JWT claim for tenant ID |</p>
<p>| <code>TenantIdHeaderName</code> | <code>"X-Tenant-Id"</code> | HTTP header for tenant ID |</p>
<p>| <code>UserIdClaimType</code> | <code>ClaimTypes.NameIdentifier</code> | JWT claim for user ID |</p>
<p>| <code>RolesClaimType</code> | <code>ClaimTypes.Role</code> | JWT claim for roles |</p>
<p>| <code>GroupsClaimType</code> | <code>"groups"</code> | JWT claim for group memberships |</p>

<h2>Query Type Setup</h2>

<p>Define your query type with lens resolvers:</p>

<pre><code class="language-csharp">public class Query {
<p>    [UsePaging(DefaultPageSize = 10, MaxPageSize = 100, IncludeTotalCount = true)]</p>
<p>    [UseProjection]</p>
<p>    [UseFiltering]</p>
<p>    [UseSorting]</p>
<p>    public IQueryable<PerspectiveRow<OrderReadModel>> GetOrders(</p>
<p>        [Service] IOrderLens lens) {</p>
<p>        return lens.Query;</p>
<p>    }</p>

<p>    [UsePaging]</p>
<p>    [UseFiltering]</p>
<p>    [UseSorting]</p>
<p>    public IQueryable<PerspectiveRow<ProductReadModel>> GetProducts(</p>
<p>        [Service] IProductLens lens) {</p>
<p>        return lens.Query;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Service Registration</h2>

<p>Register your lens implementations:</p>

<pre><code class="language-csharp">// If using EF Core
<p>builder.Services.AddScoped<IOrderLens, EFCoreOrderLens>();</p>
<p>builder.Services.AddScoped<IProductLens, EFCoreProductLens>();</p>

<p>// Or use the generated registration from source generators</p>
<p>builder.Services.AddWhizbangLensQueries();</p>
<p></code></pre></p>

<h2>What Gets Registered</h2>

<code>AddWhizbangLenses()</code> registers:

<ul><li><code>WhizbangFilterConvention</code> - Custom filtering for <code>PerspectiveRow<T></code></li>
<li><code>WhizbangSortConvention</code> - Custom sorting for nested data</li>
<li>Default projection convention</li>
<li><code>WhizbangGraphQLOptions</code> singleton</li>
</ul>
<code>AddWhizbangScope()</code> registers:

<ul><li><code>IScopeContextAccessor</code> - AsyncLocal-based scope access</li>
<li><code>WhizbangScopeOptions</code> singleton (if configured)</li>
</ul>
<h2>Next Steps</h2>

<ul><li><a href="lens-integration.md">Lens Integration</a> - Configure <code>[GraphQLLens]</code> attributes</li>
<li><a href="filtering.md">Filtering</a> - Query filtering examples</li>
<li><a href="scoping.md">Scoping</a> - Multi-tenancy configuration</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-graphql-sorting" class="doc-section">
  <h3>sorting</h3>
  <p class="doc-path"><code>v1.0.0/graphql/sorting</code></p>
  <div class="doc-content">
<h1>GraphQL Sorting</h1>

<p>Whizbang's HotChocolate integration provides flexible sorting capabilities for <code>PerspectiveRow<T></code> data.</p>

<h2>Basic Sorting</h2>

<p>Sort results using the <code>order</code> argument:</p>

<pre><code class="language-graphql">{
<p>  orders(order: { data: { customerName: ASC } }) {</p>
<p>    nodes {</p>
<p>      data {</p>
<p>        customerName</p>
<p>        totalAmount</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Sort Directions</h2>

<ul><li><code>ASC</code> - Ascending (A-Z, 0-9, oldest first)</li>
<li><code>DESC</code> - Descending (Z-A, 9-0, newest first)</li>
</ul>
<pre><code class="language-graphql"># Ascending
<p>order: { data: { createdAt: ASC } }</p>

<h1>Descending</h1>
<p>order: { data: { createdAt: DESC } }</p>
<p></code></pre></p>

<h2>Sorting on Data Properties</h2>

<p>Sort by any property in your read model:</p>

<pre><code class="language-graphql"># By string
<p>{</p>
<p>  products(order: { data: { name: ASC } }) {</p>
<p>    nodes { ... }</p>
<p>  }</p>
<p>}</p>

<h1>By number</h1>
<p>{</p>
<p>  products(order: { data: { price: DESC } }) {</p>
<p>    nodes { ... }</p>
<p>  }</p>
<p>}</p>

<h1>By date</h1>
<p>{</p>
<p>  orders(order: { data: { orderDate: DESC } }) {</p>
<p>    nodes { ... }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Multi-Column Sorting</h2>

<p>Sort by multiple columns using an array:</p>

<pre><code class="language-graphql">{
<p>  orders(order: [</p>
<p>    { data: { status: ASC } }</p>
<p>    { data: { totalAmount: DESC } }</p>
<p>  ]) {</p>
<p>    nodes {</p>
<p>      data {</p>
<p>        status</p>
<p>        totalAmount</p>
<p>        customerName</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<p>This sorts by status ascending first, then by total amount descending within each status.</p>

<h2>Sorting on System Fields</h2>

<p>Sort by <code>PerspectiveRow</code> system fields:</p>

<pre><code class="language-graphql"># By ID
<p>{</p>
<p>  orders(order: { id: ASC }) {</p>
<p>    nodes { ... }</p>
<p>  }</p>
<p>}</p>

<h1>By version (for optimistic concurrency)</h1>
<p>{</p>
<p>  orders(order: { version: DESC }) {</p>
<p>    nodes { ... }</p>
<p>  }</p>
<p>}</p>

<h1>By creation date</h1>
<p>{</p>
<p>  orders(order: { createdAt: DESC }) {</p>
<p>    nodes { ... }</p>
<p>  }</p>
<p>}</p>

<h1>By last update</h1>
<p>{</p>
<p>  orders(order: { updatedAt: DESC }) {</p>
<p>    nodes { ... }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Sorting on Metadata</h2>

<p>When metadata is exposed:</p>

<pre><code class="language-graphql">{
<p>  orders(order: { metadata: { timestamp: DESC } }) {</p>
<p>    nodes {</p>
<p>      metadata {</p>
<p>        eventType</p>
<p>        timestamp</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Combining Sort and Filter</h2>

<p>Sort and filter work together:</p>

<pre><code class="language-graphql">{
<p>  orders(</p>
<p>    where: { data: { status: { eq: "Completed" } } }</p>
<p>    order: [</p>
<p>      { data: { totalAmount: DESC } }</p>
<p>      { createdAt: DESC }</p>
<p>    ]</p>
<p>  ) {</p>
<p>    nodes {</p>
<p>      data {</p>
<p>        customerName</p>
<p>        totalAmount</p>
<p>        status</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Sorting with Paging</h2>

<p>Always combine sorting with paging for consistent results:</p>

<pre><code class="language-graphql">{
<p>  orders(</p>
<p>    order: { createdAt: DESC }</p>
<p>    first: 10</p>
<p>    after: "cursor..."</p>
<p>  ) {</p>
<p>    nodes {</p>
<p>      data {</p>
<p>        customerName</p>
<p>      }</p>
<p>    }</p>
<p>    pageInfo {</p>
<p>      hasNextPage</p>
<p>      endCursor</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Sort with Variables</h2>

<p>Use GraphQL variables for dynamic sorting:</p>

<pre><code class="language-graphql">query GetProducts($sortField: ProductSortInput!) {
<p>  products(order: [$sortField]) {</p>
<p>    nodes {</p>
<p>      data {</p>
<p>        name</p>
<p>        price</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Default Sort Order</h2>

<p>If no <code>order</code> is specified:</p>
<ul><li>With paging: Results are ordered by <code>id</code> for consistent pagination</li>
<li>Without paging: Database default order (typically insertion order)</li>
</ul>
<strong>Best Practice</strong>: Always specify an explicit sort order for predictable results.

<h2>Performance Considerations</h2>

<ul><li><strong>Index sort columns</strong> - Ensure indexes exist for frequently sorted fields</li>
<li><strong>Limit multi-column sorts</strong> - Each additional sort column may reduce index efficiency</li>
<li><strong>Sort + Filter alignment</strong> - Best performance when sort and filter use the same indexed columns</li>
<li><strong>Consider composite indexes</strong> - For common sort+filter combinations</li>
</ul>
<h2>Example: Dashboard Query</h2>

<p>A typical dashboard query combining filter, sort, and paging:</p>

<pre><code class="language-graphql">query RecentOrders($tenantId: String!, $status: String) {
<p>  orders(</p>
<p>    where: {</p>
<p>      and: [</p>
<p>        { scope: { tenantId: { eq: $tenantId } } }</p>
<p>        { data: { status: { eq: $status } } }</p>
<p>      ]</p>
<p>    }</p>
<p>    order: [</p>
<p>      { data: { priority: DESC } }</p>
<p>      { createdAt: DESC }</p>
<p>    ]</p>
<p>    first: 20</p>
<p>  ) {</p>
<p>    nodes {</p>
<p>      id</p>
<p>      data {</p>
<p>        customerName</p>
<p>        status</p>
<p>        priority</p>
<p>        totalAmount</p>
<p>      }</p>
<p>      createdAt</p>
<p>    }</p>
<p>    pageInfo {</p>
<p>      hasNextPage</p>
<p>      endCursor</p>
<p>    }</p>
<p>    totalCount</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Next Steps</h2>

<ul><li><a href="scoping.md">Scoping</a> - Multi-tenancy and security filtering</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Guides</h2>
<article id="v1-0-0-guides-implementing-multi-tenancy" class="doc-section">
  <h3>implementing multi tenancy</h3>
  <p class="doc-path"><code>v1.0.0/guides/implementing-multi-tenancy</code></p>
  <div class="doc-content">
<h1>Implementing Multi-Tenancy</h1>

<p>This guide walks through implementing multi-tenancy in a Whizbang application, from basic tenant isolation to advanced group-based sharing.</p>

<h2>Prerequisites</h2>

<ul><li>Whizbang.Core package installed</li>
<li>Basic understanding of perspectives and lenses</li>
<li>Familiarity with dependency injection</li>
</ul>
<h2>Step 1: Configure Security Options</h2>

<p>First, configure the security system with roles and permission extraction.</p>

<pre><code class="language-csharp">// Program.cs
<p>builder.Services.AddSingleton(new SecurityOptions()</p>
<p>  // Define roles with permissions</p>
<p>  .DefineRole("Admin", b => b</p>
<p>    .HasAllPermissions("*"))</p>
<p>  .DefineRole("Manager", b => b</p>
<p>    .HasAllPermissions("orders")</p>
<p>    .HasAllPermissions("customers")</p>
<p>    .HasReadPermission("reports"))</p>
<p>  .DefineRole("User", b => b</p>
<p>    .HasReadPermission("orders")</p>
<p>    .HasReadPermission("products"))</p>

<p>  // Extract from JWT claims</p>
<p>  .ExtractPermissionsFromClaim("permissions")</p>
<p>  .ExtractRolesFromClaim("roles")</p>
<p>  .ExtractSecurityPrincipalsFromClaim("groups"));</p>
<p></code></pre></p>

<h2>Step 2: Register Core Services</h2>

<p>Register the security and scoping services.</p>

<pre><code class="language-csharp">// Core services
<p>builder.Services.AddSingleton<IScopeContextAccessor, ScopeContextAccessor>();</p>
<p>builder.Services.AddSingleton<ISystemEventEmitter, SystemEventEmitter>();</p>
<p>builder.Services.AddSingleton<LensOptions>();</p>

<p>// Scoped lens factory</p>
<p>builder.Services.AddScoped<IScopedLensFactory, ScopedLensFactory>();</p>

<p>// Your lenses</p>
<p>builder.Services.AddScoped<IOrderLens, OrderLens>();</p>
<p>builder.Services.AddScoped<ICustomerLens, CustomerLens>();</p>
<p></code></pre></p>

<h2>Step 3: Create Scope Context Middleware</h2>

<p>Create middleware to populate the scope context from the authenticated user.</p>

<pre><code class="language-csharp">public class ScopeContextMiddleware {
<p>  private readonly RequestDelegate _next;</p>
<p>  private readonly SecurityOptions _securityOptions;</p>

<p>  public ScopeContextMiddleware(RequestDelegate next, SecurityOptions options) {</p>
<p>    _next = next;</p>
<p>    _securityOptions = options;</p>
<p>  }</p>

<p>  public async Task InvokeAsync(</p>
<p>      HttpContext httpContext,</p>
<p>      IScopeContextAccessor accessor) {</p>

<p>    if (httpContext.User.Identity?.IsAuthenticated == true) {</p>
<p>      var claims = httpContext.User.Claims</p>
<p>        .ToDictionary(c => c.Type, c => c.Value);</p>

<p>      // Extract using configured extractors</p>
<p>      var permissions = _securityOptions.Extractors</p>
<p>        .SelectMany(e => e.ExtractPermissions(claims))</p>
<p>        .ToHashSet();</p>
<p>      var roles = _securityOptions.Extractors</p>
<p>        .SelectMany(e => e.ExtractRoles(claims))</p>
<p>        .ToHashSet();</p>
<p>      var principals = _securityOptions.Extractors</p>
<p>        .SelectMany(e => e.ExtractSecurityPrincipals(claims))</p>
<p>        .ToHashSet();</p>

<p>      // Add user as principal</p>
<p>      var userId = claims.GetValueOrDefault("sub");</p>
<p>      if (userId != null) {</p>
<p>        principals.Add(SecurityPrincipalId.User(userId));</p>
<p>      }</p>

<p>      accessor.Current = new ScopeContext {</p>
<p>        Scope = new PerspectiveScope {</p>
<p>          TenantId = claims.GetValueOrDefault("tenant"),</p>
<p>          UserId = userId</p>
<p>        },</p>
<p>        Roles = roles,</p>
<p>        Permissions = permissions,</p>
<p>        SecurityPrincipals = principals,</p>
<p>        Claims = claims</p>
<p>      };</p>
<p>    }</p>

<p>    await _next(httpContext);</p>
<p>  }</p>
<p>}</p>

<p>// Register in Program.cs</p>
<p>app.UseAuthentication();</p>
<p>app.UseMiddleware<ScopeContextMiddleware>();</p>
<p>app.UseAuthorization();</p>
<p></code></pre></p>

<h2>Step 4: Implement Filterable Lenses</h2>

<p>Create lenses that implement <code>IFilterableLens</code> to receive scope filters.</p>

<pre><code class="language-csharp">public interface IOrderLens : ILensQuery, IFilterableLens {
<p>  Task<List<Order>> GetAllAsync();</p>
<p>  Task<Order?> GetByIdAsync(Guid id);</p>
<p>}</p>

<p>public class OrderLens : IOrderLens {</p>
<p>  private readonly DbContext _context;</p>
<p>  private ScopeFilterInfo _filterInfo;</p>

<p>  public OrderLens(DbContext context) {</p>
<p>    _context = context;</p>
<p>  }</p>

<p>  public void ApplyFilter(ScopeFilterInfo filterInfo) {</p>
<p>    _filterInfo = filterInfo;</p>
<p>  }</p>

<p>  public async Task<List<Order>> GetAllAsync() {</p>
<p>    var query = _context.Set<PerspectiveRow<Order>>().AsQueryable();</p>

<p>    // Apply scope filters</p>
<p>    if (_filterInfo.Filters.HasFlag(ScopeFilter.Tenant)) {</p>
<p>      query = query.Where(r => r.Scope.TenantId == _filterInfo.TenantId);</p>
<p>    }</p>

<p>    if (_filterInfo.UseOrLogicForUserAndPrincipal) {</p>
<p>      // User OR Principal</p>
<p>      query = query.Where(r =></p>
<p>        r.Scope.UserId == _filterInfo.UserId ||</p>
<p>        r.Scope.AllowedPrincipals!.Any(p =></p>
<p>          _filterInfo.SecurityPrincipals.Contains(p)));</p>
<p>    } else {</p>
<p>      if (_filterInfo.Filters.HasFlag(ScopeFilter.User)) {</p>
<p>        query = query.Where(r => r.Scope.UserId == _filterInfo.UserId);</p>
<p>      }</p>
<p>      if (_filterInfo.Filters.HasFlag(ScopeFilter.Principal)) {</p>
<p>        query = query.Where(r =></p>
<p>          r.Scope.AllowedPrincipals!.Any(p =></p>
<p>            _filterInfo.SecurityPrincipals.Contains(p)));</p>
<p>      }</p>
<p>    }</p>

<p>    return await query.Select(r => r.Data).ToListAsync();</p>
<p>  }</p>

<p>  public async Task<Order?> GetByIdAsync(Guid id) {</p>
<p>    // Similar filtering logic...</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Step 5: Use in Controllers</h2>

<p>Use the scoped lens factory in your controllers.</p>

<pre><code class="language-csharp">[ApiController]
<p>[Route("api/orders")]</p>
<p>public class OrdersController : ControllerBase {</p>
<p>  private readonly IScopedLensFactory _lensFactory;</p>

<p>  public OrdersController(IScopedLensFactory lensFactory) {</p>
<p>    _lensFactory = lensFactory;</p>
<p>  }</p>

<p>  [HttpGet]</p>
<p>  public async Task<IActionResult> GetOrders() {</p>
<p>    // Gets only orders for current tenant</p>
<p>    var lens = _lensFactory.GetTenantLens<IOrderLens>();</p>
<p>    var orders = await lens.GetAllAsync();</p>
<p>    return Ok(orders);</p>
<p>  }</p>

<p>  [HttpGet("my")]</p>
<p>  public async Task<IActionResult> GetMyOrders() {</p>
<p>    // Gets only current user's orders</p>
<p>    var lens = _lensFactory.GetUserLens<IOrderLens>();</p>
<p>    var orders = await lens.GetAllAsync();</p>
<p>    return Ok(orders);</p>
<p>  }</p>

<p>  [HttpGet("shared")]</p>
<p>  public async Task<IActionResult> GetSharedOrders() {</p>
<p>    // Gets orders shared with user's groups</p>
<p>    var lens = _lensFactory.GetPrincipalLens<IOrderLens>();</p>
<p>    var orders = await lens.GetAllAsync();</p>
<p>    return Ok(orders);</p>
<p>  }</p>

<p>  [HttpGet("all-accessible")]</p>
<p>  public async Task<IActionResult> GetAllAccessibleOrders() {</p>
<p>    // Gets my orders + shared with me</p>
<p>    var lens = _lensFactory.GetMyOrSharedLens<IOrderLens>();</p>
<p>    var orders = await lens.GetAllAsync();</p>
<p>    return Ok(orders);</p>
<p>  }</p>

<p>  [HttpDelete("{id}")]</p>
<p>  public async Task<IActionResult> DeleteOrder(Guid id) {</p>
<p>    // Require delete permission</p>
<p>    var lens = _lensFactory.GetLens<IOrderLens>(</p>
<p>      ScopeFilter.Tenant,</p>
<p>      Permission.Delete("orders"));</p>

<p>    // Will throw AccessDeniedException if not authorized</p>
<p>    // ...</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Step 6: Store Data with Scope</h2>

<p>When creating perspective rows, set the appropriate scope.</p>

<pre><code class="language-csharp">public class OrderPerspective : IPerspectiveFor<Order, OrderCreatedEvent> {
<p>  private readonly IPerspectiveStore<Order> _store;</p>
<p>  private readonly IScopeContextAccessor _accessor;</p>

<p>  public async Task Update(OrderCreatedEvent @event, CancellationToken ct) {</p>
<p>    var context = _accessor.Current!;</p>
<p>    var order = Apply(new Order(), @event);</p>

<p>    await _store.UpsertAsync(</p>
<p>      @event.OrderId,</p>
<p>      order,</p>
<p>      new PerspectiveScope {</p>
<p>        TenantId = context.Scope.TenantId,</p>
<p>        UserId = context.Scope.UserId,</p>
<p>        // Optional: Allow sharing with user's groups</p>
<p>        AllowedPrincipals = context.SecurityPrincipals.ToList()</p>
<p>      },</p>
<p>      ct);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Step 7: Handle Access Denied</h2>

<p>Handle <code>AccessDeniedException</code> appropriately.</p>

<pre><code class="language-csharp">public class SecurityExceptionMiddleware {
<p>  private readonly RequestDelegate _next;</p>
<p>  private readonly ILogger<SecurityExceptionMiddleware> _logger;</p>

<p>  public async Task InvokeAsync(HttpContext context) {</p>
<p>    try {</p>
<p>      await _next(context);</p>
<p>    } catch (AccessDeniedException ex) {</p>
<p>      _logger.LogWarning(</p>
<p>        "Access denied: {Resource} requires {Permission}. Reason: {Reason}",</p>
<p>        ex.ResourceType,</p>
<p>        ex.RequiredPermission,</p>
<p>        ex.Reason);</p>

<p>      context.Response.StatusCode = 403;</p>
<p>      await context.Response.WriteAsJsonAsync(new {</p>
<p>        error = "Access denied",</p>
<p>        resource = ex.ResourceType,</p>
<p>        requiredPermission = ex.RequiredPermission.Value</p>
<p>      });</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Advanced: Organization Hierarchy</h2>

<p>For organization-based access within a tenant:</p>

<pre><code class="language-csharp">// Store with organization scope
<p>await _store.UpsertAsync(id, data, new PerspectiveScope {</p>
<p>  TenantId = "tenant-123",</p>
<p>  OrganizationId = "org-sales",</p>
<p>  AllowedPrincipals = new[] {</p>
<p>    SecurityPrincipalId.Group("org:sales"),</p>
<p>    SecurityPrincipalId.Group("org:management")</p>
<p>  }</p>
<p>});</p>

<p>// Query organization's data</p>
<p>var lens = _lensFactory.GetOrganizationLens<IReportLens>();</p>
<p></code></pre></p>

<h2>Advanced: Department-Based Extensions</h2>

<p>Use extensions for custom scope dimensions:</p>

<pre><code class="language-csharp">// Store with custom extensions
<p>await _store.UpsertAsync(id, data, new PerspectiveScope {</p>
<p>  TenantId = "tenant-123",</p>
<p>  Extensions = new Dictionary<string, string?> {</p>
<p>    ["department"] = "engineering",</p>
<p>    ["costCenter"] = "CC-1234",</p>
<p>    ["project"] = "alpha"</p>
<p>  }</p>
<p>});</p>

<p>// Access in queries</p>
<p>var department = row.Scope["department"];</p>
<p></code></pre></p>

<h2>Testing</h2>

<p>Test multi-tenancy with explicit context setup:</p>

<pre><code class="language-csharp">[Test]
<p>public async Task GetOrders_ReturnsOnlyTenantOrders() {</p>
<p>  // Arrange</p>
<p>  var accessor = new ScopeContextAccessor();</p>
<p>  accessor.Current = new ScopeContext {</p>
<p>    Scope = new PerspectiveScope { TenantId = "tenant-A" },</p>
<p>    Roles = new HashSet<string>(),</p>
<p>    Permissions = new HashSet<Permission> { Permission.Read("orders") },</p>
<p>    SecurityPrincipals = new HashSet<SecurityPrincipalId>(),</p>
<p>    Claims = new Dictionary<string, string>()</p>
<p>  };</p>

<p>  var factory = new ScopedLensFactory(provider, accessor, options, emitter);</p>

<p>  // Act</p>
<p>  var lens = factory.GetTenantLens<IOrderLens>();</p>
<p>  var orders = await lens.GetAllAsync();</p>

<p>  // Assert</p>
<p>  await Assert.That(orders.All(o => o.TenantId == "tenant-A")).IsTrue();</p>
<p>}</p>
<p></code></pre></p>

<h2>Related Documentation</h2>

<ul><li><a href="../core-concepts/security.md">Security</a> - Permission and role system</li>
<li><a href="../core-concepts/scoping.md">Scoping</a> - Scope filters and composition</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Infrastructure</h2>
<article id="v1-0-0-infrastructure-aspire-integration" class="doc-section">
  <h3>.NET Aspire Integration</h3>
  <p class="doc-path"><code>v1.0.0/infrastructure/aspire-integration</code></p>
  <p class="doc-description"><em>Cloud-native orchestration for Whizbang applications with .NET Aspire - automatic infrastructure provisioning and service discovery</em></p>
  <div class="doc-content">

<h1>.NET Aspire Integration</h1>

<strong>.NET Aspire</strong> is Microsoft's cloud-native application stack for building distributed applications with batteries-included infrastructure. Whizbang integrates seamlessly with Aspire to provide automatic service discovery, infrastructure provisioning, and local development environments.

<h2>Why Aspire + Whizbang?</h2>

<strong>Aspire solves infrastructure complexity</strong> for Whizbang applications:

<p>| Challenge | Without Aspire | With Aspire |</p>
<p>|-----------|---------------|-------------|</p>
<p>| <strong>Service Bus Setup</strong> | Manual topic/subscription creation | Automatic provisioning from AppHost |</p>
<p>| <strong>Connection Strings</strong> | Copy-paste from Azure Portal | Auto-injected via configuration |</p>
<p>| <strong>Local Development</strong> | Install/configure Service Bus locally | Built-in emulator with zero config |</p>
<p>| <strong>Service Discovery</strong> | Manual endpoint configuration | Automatic service-to-service discovery |</p>
<p>| <strong>Health Checks</strong> | Manual endpoint setup | Built-in dashboards with live monitoring |</p>
<p>| <strong>Observability</strong> | Configure OpenTelemetry manually | Auto-wired distributed tracing |</p>

<strong>Whizbang + Aspire Benefits</strong>:
<ul><li>✅ <strong>Zero Manual Infrastructure</strong> - Topics, subscriptions, filters provisioned automatically</li>
<li>✅ <strong>Emulator Support</strong> - Local Service Bus emulator for dev/test</li>
<li>✅ <strong>Configuration as Code</strong> - AppHost defines infrastructure declaratively</li>
<li>✅ <strong>Multi-Service Orchestration</strong> - Run distributed systems locally with <code>dotnet run</code></li>
<li>✅ <strong>Production Parity</strong> - Same code runs locally (emulator) and in Azure</li>
</ul>
<hr>

<h2>Architecture</h2>

<h3>Aspire AppHost Pattern</h3>

<pre><code class="language-">┌────────────────────────────────────────────────────────┐
<p>│  AppHost (Program.cs)                                  │</p>
<p>│                                                         │</p>
<p>│  ┌──────────────────────────────────────────────────┐ │</p>
<p>│  │  Azure Service Bus Resource                      │ │</p>
<p>│  │  ├─ Topic: "whizbang.events"                     │ │</p>
<p>│  │  │  ├─ Subscription: "inventory-service"         │ │</p>
<p>│  │  │  │  └─ Filter: Destination = "inventory"      │ │</p>
<p>│  │  │  ├─ Subscription: "notification-service"      │ │</p>
<p>│  │  │  │  └─ Filter: Destination = "notifications"  │ │</p>
<p>│  │  │  └─ Subscription: "analytics-service"         │ │</p>
<p>│  │  │     └─ Filter: Destination = "analytics"      │ │</p>
<p>│  └──────────────────────────────────────────────────┘ │</p>
<p>│                                                         │</p>
<p>│  ┌──────────────────────────────────────────────────┐ │</p>
<p>│  │  Service Projects (with references)              │ │</p>
<p>│  │  ├─ Inventory Service → inventory-service sub    │ │</p>
<p>│  │  ├─ Notification Service → notification-service  │ │</p>
<p>│  │  └─ Analytics Service → analytics-service sub    │ │</p>
<p>│  └──────────────────────────────────────────────────┘ │</p>
<p>└────────────────────────────────────────────────────────┘</p>
<p>         │</p>
<p>         │ dotnet run (AppHost)</p>
<p>         ▼</p>
<p>┌────────────────────────────────────────────────────────┐</p>
<p>│  Aspire Runtime                                        │</p>
<p>│                                                         │</p>
<p>│  - Starts Service Bus emulator (or connects to Azure) │</p>
<p>│  - Provisions topics and subscriptions via Bicep/API  │</p>
<p>│  - Injects connection strings into services           │</p>
<p>│  - Starts all service projects                        │</p>
<p>│  - Exposes dashboard at http://localhost:15888        │</p>
<p>└────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<hr>

<h2>Setup</h2>

<h3>1. Create Aspire AppHost Project</h3>

<pre><code class="language-bash"># Create solution structure
<p>dotnet new sln -n MyDistributedApp</p>
<p>dotnet new aspire-apphost -n MyDistributedApp.AppHost</p>
<p>dotnet sln add MyDistributedApp.AppHost</p>

<h1>Add service projects</h1>
<p>dotnet new webapi -n InventoryService</p>
<p>dotnet new webapi -n NotificationService</p>
<p>dotnet sln add InventoryService NotificationService</p>
<p></code></pre></p>

<h3>2. Add Whizbang NuGet Packages</h3>

<strong>AppHost Project</strong>:
<pre><code class="language-bash">cd MyDistributedApp.AppHost
<p>dotnet add package Whizbang.Hosting.Azure.ServiceBus</p>
<p></code></pre></p>

<strong>Service Projects</strong>:
<pre><code class="language-bash">cd ../InventoryService
<p>dotnet add package Whizbang</p>
<p>dotnet add package Whizbang.Transports.AzureServiceBus</p>
<p></code></pre></p>

<h3>3. Configure AppHost</h3>

<strong>AppHost/Program.cs</strong>:
<pre><code class="language-csharp">using Whizbang.Hosting.Azure.ServiceBus;

<p>var builder = DistributedApplication.CreateBuilder(args);</p>

<p>// Add Service Bus resource (emulator for local dev)</p>
<p>var serviceBus = builder.AddAzureServiceBus("messaging")</p>
<p>  .RunAsEmulator();  // Local development</p>
<p>  // .PublishAsAzureServiceBusNamespace();  // Production deployment</p>

<p>// Create topic for all events</p>
<p>var topic = serviceBus.AddTopic("whizbang-events");</p>

<p>// Add subscriptions with Whizbang correlation filters</p>
<p>var inventorySub = topic.AddSubscription("inventory-service")</p>
<p>  .WithDestinationFilter("inventory");  // ⭐ Whizbang extension method</p>

<p>var notificationSub = topic.AddSubscription("notification-service")</p>
<p>  .WithDestinationFilter("notifications");</p>

<p>var analyticsSub = topic.AddSubscription("analytics-service")</p>
<p>  .WithDestinationFilter("analytics");</p>

<p>// Add service projects with Service Bus references</p>
<p>var inventoryService = builder.AddProject<Projects.InventoryService>("inventory-service")</p>
<p>  .WithReference(serviceBus)</p>
<p>  .WithReference(inventorySub);  // Grants read access to subscription</p>

<p>var notificationService = builder.AddProject<Projects.NotificationService>("notification-service")</p>
<p>  .WithReference(serviceBus)</p>
<p>  .WithReference(notificationSub);</p>

<p>var analyticsService = builder.AddProject<Projects.AnalyticsService>("analytics-service")</p>
<p>  .WithReference(serviceBus)</p>
<p>  .WithReference(analyticsSub);</p>

<p>builder.Build().Run();</p>
<p></code></pre></p>

<strong>What <code>.WithDestinationFilter()</code> Does</strong>:
<ul><li>Provisions Azure Service Bus <strong>Correlation Filter</strong> on the subscription</li>
<li>Filters messages based on <code>ApplicationProperties["Destination"]</code> value</li>
<li>Enables multi-tenant and multi-service routing patterns</li>
<li>Works in both emulator and production</li>
</ul>
<hr>

<h2>Service Configuration</h2>

<h3>1. Add Aspire Service Defaults</h3>

<strong>InventoryService/Program.cs</strong>:
<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);

<p>// Add Aspire service defaults (health checks, telemetry, service discovery)</p>
<p>builder.AddServiceDefaults();  // ⭐ Essential for Aspire integration</p>

<p>// Get Service Bus connection string injected by Aspire</p>
<p>var connectionString = builder.Configuration.GetConnectionString("messaging")</p>
<p>  ?? throw new InvalidOperationException("Service Bus connection not found");</p>

<p>// Register Whizbang transport</p>
<p>builder.Services.AddAzureServiceBusTransport(connectionString);</p>

<p>// Register receptors, perspectives, etc.</p>
<p>builder.Services.AddWhizbang();</p>

<p>var app = builder.Build();</p>
<p>app.MapDefaultEndpoints();  // Health checks, metrics</p>

<p>app.Run();</p>
<p></code></pre></p>

<strong>How It Works</strong>:
<ul><li>Aspire injects <code>ConnectionStrings:messaging</code> into app configuration</li>
<li>Service reads connection string and registers transport</li>
<li>Transport auto-detects emulator vs. production connection</li>
<li>Aspire dashboard shows service health and telemetry</li>
</ul>
<h3>2. Verify Aspire Integration</h3>

<pre><code class="language-bash"># Run AppHost
<p>cd MyDistributedApp.AppHost</p>
<p>dotnet run</p>

<h1>Aspire dashboard opens at http://localhost:15888</h1>
<h1>View:</h1>
<h1>- Resources (Service Bus, services)</h1>
<h1>- Service health status</h1>
<h1>- Distributed traces</h1>
<h1>- Logs (structured and correlated)</h1>
<p></code></pre></p>

<hr>

<h2>Correlation Filters</h2>

<h3>WithDestinationFilter Extension</h3>

<strong>Purpose</strong>: Route messages to specific services based on <code>Destination</code> property.

<strong>Implementation</strong>:
<pre><code class="language-csharp">public static IResourceBuilder<AzureServiceBusSubscriptionResource> WithDestinationFilter(
<p>  this IResourceBuilder<AzureServiceBusSubscriptionResource> subscription,</p>
<p>  string destination</p>
<p>) {</p>
<p>  return subscription.WithProperties(sub => {</p>
<p>    sub.Rules.Add(new AzureServiceBusRule("DestinationFilter") {</p>
<p>      CorrelationFilter = new() {</p>
<p>        Properties = { ["Destination"] = destination }</p>
<p>      }</p>
<p>    });</p>
<p>  });</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage Pattern</strong>:
<pre><code class="language-csharp">// AppHost - provision filters
<p>var inventorySub = topic.AddSubscription("inventory-service")</p>
<p>  .WithDestinationFilter("inventory");  // Only messages with Destination = "inventory"</p>

<p>// Publisher - set Destination property</p>
<p>var destination = new TransportDestination(</p>
<p>  Address: "whizbang-events",</p>
<p>  RoutingKey: "inventory-service",</p>
<p>  Metadata: new Dictionary<string, JsonElement> {</p>
<p>    ["Destination"] = JsonSerializer.SerializeToElement("inventory")  // ⭐ Filter value</p>
<p>  }</p>
<p>);</p>

<p>await transport.PublishAsync(envelope, destination);</p>
<p></code></pre></p>

<strong>Result</strong>: Only messages with <code>Destination = "inventory"</code> routed to <code>inventory-service</code> subscription.

<hr>

<h2>Emulator vs Production</h2>

<h3>Development (Emulator)</h3>

<pre><code class="language-csharp">var serviceBus = builder.AddAzureServiceBus("messaging")
<p>  .RunAsEmulator();  // Starts container with Service Bus emulator</p>
<p></code></pre></p>

<strong>Characteristics</strong>:
<ul><li>Runs in Docker container</li>
<li>Accessed via <code>localhost:5672</code> (AMQP)</li>
<li>No Admin API (port 443 not supported)</li>
<li>Filters provisioned by Aspire at startup</li>
<li>Zero Azure credentials required</li>
</ul>
<strong>Connection String</strong>:
<pre><code class="language-">Endpoint=sb://localhost;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=SAS_KEY_VALUE;UseDevelopmentEmulator=true
<p></code></pre></p>

<h3>Production (Azure)</h3>

<pre><code class="language-csharp">var serviceBus = builder.AddAzureServiceBus("messaging")
<p>  .PublishAsAzureServiceBusNamespace();  // Generates Bicep for Azure deployment</p>
<p></code></pre></p>

<strong>Characteristics</strong>:
<ul><li>Provisions Azure Service Bus Namespace</li>
<li>Generates Bicep infrastructure-as-code</li>
<li>Uses Azure identity for authentication</li>
<li>Full Admin API support for filter management</li>
</ul>
<strong>Connection String</strong> (injected by Azure):
<pre><code class="language-">Endpoint=sb://my-namespace.servicebus.windows.net/;...
<p></code></pre></p>

<hr>

<h2>Configuration Generation</h2>

<h3>AspireConfigurationGenerator</h3>

<strong>Purpose</strong>: Generate C# code for AppHost based on service requirements.

<strong>Use Case</strong>: Services define their messaging requirements programmatically, generator creates AppHost config.

<strong>Example</strong>:
<pre><code class="language-csharp">using Whizbang.Core.Transports.AzureServiceBus;

<p>// Service defines requirements</p>
<p>var requirements = new[] {</p>
<p>  new TopicRequirement("whizbang-events", "inventory-service"),</p>
<p>  new TopicRequirement("whizbang-events", "notification-service"),</p>
<p>  new TopicRequirement("order-events", "shipping-service")</p>
<p>};</p>

<p>// Generate AppHost code</p>
<p>var code = AspireConfigurationGenerator.GenerateAppHostCode(</p>
<p>  requirements,</p>
<p>  serviceName: "OrderService"</p>
<p>);</p>

<p>Console.WriteLine(code);</p>
<p></code></pre></p>

<strong>Generated Output</strong>:
<pre><code class="language-csharp">// === Whizbang Service Bus Configuration ===
<p>// Service Bus topics for OrderService service</p>

<p>var orderEventsTopic = serviceBus.AddServiceBusTopic("order-events");</p>
<p>orderEventsTopic.AddServiceBusSubscription("shipping-service");</p>

<p>var whizbangEventsTopic = serviceBus.AddServiceBusTopic("whizbang-events");</p>
<p>whizbangEventsTopic.AddServiceBusSubscription("inventory-service");</p>
<p>whizbangEventsTopic.AddServiceBusSubscription("notification-service");</p>

<p>// ==========================================</p>
<p></code></pre></p>

<strong>Use Case</strong>: Copy-paste into AppHost to provision topics/subscriptions.

<hr>

<h2>Readiness Checks</h2>

<h3>ServiceBusReadinessCheck</h3>

<strong>Purpose</strong>: Verify Service Bus connectivity before accepting traffic.

<strong>Pattern</strong>:
<pre><code class="language-csharp">using Whizbang.Hosting.Azure.ServiceBus;

<p>builder.Services.AddSingleton<ITransportReadinessCheck, ServiceBusReadinessCheck>();</p>
<p></code></pre></p>

<strong>How It Works</strong>:
<pre><code class="language-csharp">public async Task<bool> IsReadyAsync(CancellationToken ct) {
<p>  // 1. Check if transport initialized</p>
<p>  if (!_transport.IsInitialized) {</p>
<p>    return false;</p>
<p>  }</p>

<p>  // 2. Check cache (30-second TTL)</p>
<p>  if (_lastSuccessfulCheck.HasValue &&</p>
<p>      DateTimeOffset.UtcNow - _lastSuccessfulCheck.Value < _cacheDuration) {</p>
<p>    return true;  // Cached result</p>
<p>  }</p>

<p>  // 3. Verify ServiceBusClient is open</p>
<p>  if (_client.IsClosed) {</p>
<p>    return false;</p>
<p>  }</p>

<p>  // 4. Cache successful check</p>
<p>  _lastSuccessfulCheck = DateTimeOffset.UtcNow;</p>
<p>  return true;</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>Prevents accepting requests before Service Bus connection is ready</li>
<li>Cached checks avoid excessive health check overhead</li>
<li>Integrates with Aspire dashboard for real-time status</li>
</ul>
<hr>

<h2>Multi-Service Patterns</h2>

<h3>Fan-Out Events</h3>

<pre><code class="language-csharp">// AppHost - multiple services subscribe to same topic
<p>var topic = serviceBus.AddTopic("order-events");</p>

<p>topic.AddSubscription("inventory-service")</p>
<p>  .WithDestinationFilter("inventory");</p>

<p>topic.AddSubscription("notification-service")</p>
<p>  .WithDestinationFilter("notifications");</p>

<p>topic.AddSubscription("analytics-service")</p>
<p>  .WithDestinationFilter("analytics");</p>

<p>topic.AddSubscription("audit-service")</p>
<p>  .WithDestinationFilter("audit");</p>

<p>// Publisher - send to multiple destinations</p>
<p>await transport.PublishAsync(envelope, new TransportDestination("order-events", Metadata: CreateDestination("inventory")));</p>
<p>await transport.PublishAsync(envelope, new TransportDestination("order-events", Metadata: CreateDestination("notifications")));</p>
<p>await transport.PublishAsync(envelope, new TransportDestination("order-events", Metadata: CreateDestination("audit")));</p>
<p></code></pre></p>

<strong>Result</strong>: Single event published to multiple services via correlation filters.

<h3>Service-to-Service Communication</h3>

<pre><code class="language-csharp">// AppHost - inventory service references notification service
<p>var notificationService = builder.AddProject<Projects.NotificationService>("notification-service")</p>
<p>  .WithReference(serviceBus);</p>

<p>var inventoryService = builder.AddProject<Projects.InventoryService>("inventory-service")</p>
<p>  .WithReference(serviceBus)</p>
<p>  .WithReference(notificationService);  // Service discovery</p>

<p>// InventoryService - call NotificationService</p>
<p>var notificationEndpoint = builder.Configuration["services:notification-service:https:0"];</p>
<p>var httpClient = new HttpClient { BaseAddress = new Uri(notificationEndpoint) };</p>

<p>await httpClient.PostAsync("/notify", content);  // Service-to-service HTTP</p>
<p></code></pre></p>

<strong>Aspire provides</strong>:
<ul><li>Automatic service endpoint discovery</li>
<li>Load balancing across instances</li>
<li>Health-based routing</li>
</ul>
<hr>

<h2>Dashboard and Observability</h2>

<h3>Aspire Dashboard</h3>

<p>Run AppHost and open <strong>http://localhost:15888</strong>.</p>

<strong>Features</strong>:
<ul><li><strong>Resources Tab</strong>: View Service Bus, services, dependencies</li>
<li><strong>Console Logs Tab</strong>: Structured logs with correlation IDs</li>
<li><strong>Traces Tab</strong>: Distributed tracing across services</li>
<li><strong>Metrics Tab</strong>: Service health, request rates, latencies</li>
</ul>
<h3>Whizbang Integration</h3>

<strong>Automatic Tracing</strong>:
<ul><li>All <code>IDispatcher.SendAsync</code> calls create spans</li>
<li>Transport <code>PublishAsync</code> and <code>SubscribeAsync</code> tracked</li>
<li>Correlation IDs propagated across services</li>
</ul>
<strong>Example Trace</strong>:
<pre><code class="language-">OrderService.DispatcherInvokeReceptor (50ms)
<p>  ├─ OrderReceptor.HandleAsync (45ms)</p>
<p>  │  ├─ Database.Insert (10ms)</p>
<p>  │  └─ Transport.PublishAsync (5ms)</p>
<p>  │</p>
<p>  └─ InventoryService.ReceiveMessage (20ms)</p>
<p>     └─ InventoryReceptor.HandleAsync (18ms)</p>
<p>        └─ Database.Update (15ms)</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Use <code>.WithDestinationFilter()</code></strong> for multi-service routing</li>
<li>✅ <strong>Run emulator for local development</strong> (zero Azure costs)</li>
<li>✅ <strong>Add <code>.AddServiceDefaults()</code></strong> to all service projects</li>
<li>✅ <strong>Reference subscriptions</strong> via <code>.WithReference()</code> (grants access)</li>
<li>✅ <strong>Use <code>PublishAsAzureServiceBusNamespace()</code></strong> for production Bicep generation</li>
<li>✅ <strong>Monitor Aspire dashboard</strong> during development</li>
<li>✅ <strong>Test locally with emulator</strong> before deploying to Azure</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Hardcode connection strings (use Aspire configuration)</li>
<li>❌ Skip <code>.AddServiceDefaults()</code> (breaks health checks and telemetry)</li>
<li>❌ Create topics/subscriptions manually (let Aspire provision)</li>
<li>❌ Use Admin API with emulator (not supported)</li>
<li>❌ Ignore readiness checks (services may accept traffic before ready)</li>
<li>❌ Deploy to production without testing emulator first</li>
</ul>
<hr>

<h2>Troubleshooting</h2>

<h3>Problem: "Connection string 'messaging' not found"</h3>

<strong>Symptoms</strong>: Service fails to start with missing connection string error.

<strong>Cause</strong>: Service not referenced in AppHost or missing <code>.WithReference(serviceBus)</code>.

<strong>Solution</strong>:
<pre><code class="language-csharp">// AppHost - add reference to Service Bus
<p>var inventoryService = builder.AddProject<Projects.InventoryService>("inventory-service")</p>
<p>  .WithReference(serviceBus);  // ⭐ Required for connection string injection</p>

<p>// Service - verify configuration key</p>
<p>var connectionString = builder.Configuration.GetConnectionString("messaging");</p>
<p>// Key must match resource name in AppHost ("messaging")</p>
<p></code></pre></p>

<h3>Problem: Messages Not Filtered Correctly</h3>

<strong>Symptoms</strong>: Subscriber receives all messages, not just filtered ones.

<strong>Causes</strong>:
<ul><li>Filter not provisioned (missing <code>.WithDestinationFilter()</code>)</li>
<li>Publisher not setting <code>Destination</code> property</li>
<li>Filter value mismatch</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-csharp">// AppHost - verify filter provisioning
<p>var inventorySub = topic.AddSubscription("inventory-service")</p>
<p>  .WithDestinationFilter("inventory");  // Filter value: "inventory"</p>

<p>// Publisher - set matching Destination property</p>
<p>var metadata = new Dictionary<string, JsonElement> {</p>
<p>  ["Destination"] = JsonSerializer.SerializeToElement("inventory")  // Must match filter</p>
<p>};</p>

<p>var destination = new TransportDestination("whizbang-events", "inventory-service", metadata);</p>
<p>await transport.PublishAsync(envelope, destination);</p>

<p>// Verify in Azure Portal:</p>
<p>// Service Bus Namespace → Topics → whizbang-events → Subscriptions → inventory-service → Rules</p>
<p>// Expected: DestinationFilter with Destination = "inventory"</p>
<p></code></pre></p>

<h3>Problem: Emulator Fails to Start</h3>

<strong>Symptoms</strong>: AppHost throws error starting Service Bus emulator.

<strong>Causes</strong>:
<ul><li>Docker not running</li>
<li>Port 5672 already in use</li>
<li>Emulator image not pulled</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-bash"># Verify Docker is running
<p>docker ps</p>

<h1>Pull Service Bus emulator image</h1>
<p>docker pull mcr.microsoft.com/azure-messaging/servicebus-emulator:latest</p>

<h1>Check port availability</h1>
<p>lsof -i :5672  # Should be empty</p>

<h1>Run AppHost again</h1>
<p>dotnet run</p>
<p></code></pre></p>

<h3>Problem: Service Not Appearing in Dashboard</h3>

<strong>Symptoms</strong>: Aspire dashboard shows Service Bus but not service projects.

<strong>Cause</strong>: Missing <code>.AddServiceDefaults()</code> in service <code>Program.cs</code>.

<strong>Solution</strong>:
<pre><code class="language-csharp">// Service Program.cs - add service defaults
<p>var builder = WebApplication.CreateBuilder(args);</p>
<p>builder.AddServiceDefaults();  // ⭐ Required for dashboard integration</p>

<p>var app = builder.Build();</p>
<p>app.MapDefaultEndpoints();  // Exposes health/metrics endpoints</p>
<p>app.Run();</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Transports</strong>:
<ul><li><a href="../transports/azure-service-bus.md">Azure Service Bus Transport</a> - Service Bus integration details</li>
</ul>
<strong>Infrastructure</strong>:
<ul><li><a href="health-checks.md">Health Checks</a> - Application health monitoring</li>
<li><a href="policies.md">Policies</a> - Policy-based routing</li>
</ul>
<strong>Messaging</strong>:
<ul><li><a href="../messaging/outbox-pattern.md">Outbox Pattern</a> - Reliable event publishing</li>
<li><a href="../messaging/inbox-pattern.md">Inbox Pattern</a> - Exactly-once processing</li>
</ul>
<strong>External Resources</strong>:
<ul><li><a href="https://learn.microsoft.com/en-us/dotnet/aspire/">.NET Aspire Documentation</a></li>
<li><a href="https://learn.microsoft.com/en-us/azure/service-bus-messaging/overview-emulator">Azure Service Bus Emulator</a></li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-infrastructure-health-checks" class="doc-section">
  <h3>Health Checks</h3>
  <p class="doc-path"><code>v1.0.0/infrastructure/health-checks</code></p>
  <p class="doc-description"><em>Application health monitoring with built-in health checks for transports, databases, and custom components</em></p>
  <div class="doc-content">

<h1>Health Checks</h1>

<strong>Health checks</strong> provide real-time monitoring of application health and dependency availability. Whizbang includes built-in health checks for transports, databases, and infrastructure components with seamless integration into .NET Aspire dashboards and Kubernetes readiness probes.

<h2>Why Health Checks?</h2>

<strong>Health checks prevent cascading failures</strong> in distributed systems:

<p>| Use Case | Description | Benefit |</p>
<p>|----------|-------------|---------|</p>
<p>| <strong>Kubernetes Readiness</strong> | Prevent routing traffic to unhealthy instances | Zero-downtime deployments |</p>
<p>| <strong>Load Balancer Health</strong> | Remove unhealthy instances from pool | High availability |</p>
<p>| <strong>Circuit Breakers</strong> | Detect downstream failures early | Fault isolation |</p>
<p>| <strong>Aspire Dashboard</strong> | Real-time health visualization | Faster troubleshooting |</p>
<p>| <strong>Startup Validation</strong> | Verify dependencies before accepting traffic | Fail-fast on misconfiguration |</p>
<p>| <strong>Monitoring Alerts</strong> | Trigger alerts when dependencies fail | Proactive incident response |</p>

<strong>Whizbang Health Checks</strong>:
<ul><li>✅ <strong>Transport Connectivity</strong> - Azure Service Bus, In-Memory</li>
<li>✅ <strong>Database Connectivity</strong> - PostgreSQL, SQL Server</li>
<li>✅ <strong>Custom Checks</strong> - Extensible <code>IHealthCheck</code> pattern</li>
<li>✅ <strong>Caching</strong> - Avoid excessive health check overhead</li>
<li>✅ <strong>Aspire Integration</strong> - Auto-wired dashboard monitoring</li>
</ul>
<hr>

<h2>Architecture</h2>

<h3>Health Check Flow</h3>

<pre><code class="language-">┌────────────────────────────────────────────────────────┐
<p>│  Health Check Endpoint: /health                        │</p>
<p>│  (Kubernetes readiness, load balancer, monitoring)     │</p>
<p>└────────────────┬───────────────────────────────────────┘</p>
<p>                 │</p>
<p>                 │ HTTP GET /health</p>
<p>                 ▼</p>
<p>┌────────────────────────────────────────────────────────┐</p>
<p>│  Microsoft.Extensions.Diagnostics.HealthChecks         │</p>
<p>│  (Built into ASP.NET Core)                             │</p>
<p>│                                                         │</p>
<p>│  Executes all registered health checks in parallel:    │</p>
<p>│  ├─ AzureServiceBusHealthCheck                         │</p>
<p>│  ├─ PostgresHealthCheck                                │</p>
<p>│  ├─ CustomHealthCheck                                  │</p>
<p>│  └─ ...                                                 │</p>
<p>└────────────────┬───────────────────────────────────────┘</p>
<p>                 │</p>
<p>                 │ Aggregate results</p>
<p>                 ▼</p>
<p>┌────────────────────────────────────────────────────────┐</p>
<p>│  Health Check Response                                 │</p>
<p>│                                                         │</p>
<p>│  {                                                      │</p>
<p>│    "status": "Healthy",           // or Degraded, Unhealthy</p>
<p>│    "results": {                                         │</p>
<p>│      "azure_servicebus": {                              │</p>
<p>│        "status": "Healthy",                             │</p>
<p>│        "description": "Transport is available"          │</p>
<p>│      },                                                 │</p>
<p>│      "postgres": {                                      │</p>
<p>│        "status": "Healthy",                             │</p>
<p>│        "description": "Database is accessible"          │</p>
<p>│      }                                                  │</p>
<p>│    }                                                    │</p>
<p>│  }                                                      │</p>
<p>└────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<hr>

<h2>Built-In Health Checks</h2>

<h3>1. Azure Service Bus Health Check</h3>

<strong>Purpose</strong>: Verify transport is available and connected.

<strong>Usage</strong>:
<pre><code class="language-csharp">using Whizbang.Transports.AzureServiceBus;

<p>builder.Services.AddAzureServiceBusTransport(connectionString);</p>
<p>builder.Services.AddAzureServiceBusHealthChecks();  // ⭐ Register health check</p>

<p>// Expose health endpoint</p>
<p>app.MapHealthChecks("/health");</p>
<p></code></pre></p>

<strong>Implementation</strong>:
<pre><code class="language-csharp">public class AzureServiceBusHealthCheck(ITransport transport) : IHealthCheck {
<p>  public Task<HealthCheckResult> CheckHealthAsync(</p>
<p>    HealthCheckContext context,</p>
<p>    CancellationToken cancellationToken</p>
<p>  ) {</p>
<p>    // Verify transport is Azure Service Bus</p>
<p>    if (transport is not AzureServiceBusTransport) {</p>
<p>      return Task.FromResult(</p>
<p>        HealthCheckResult.Degraded("Transport is not Azure Service Bus")</p>
<p>      );</p>
<p>    }</p>

<p>    // Transport is instantiated and not disposed</p>
<p>    return Task.FromResult(</p>
<p>      HealthCheckResult.Healthy("Azure Service Bus transport is available")</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Status Levels</strong>:
<ul><li><strong>Healthy</strong>: Transport instantiated and available</li>
<li><strong>Degraded</strong>: Wrong transport type registered</li>
<li><strong>Unhealthy</strong>: Transport disposed or unavailable</li>
</ul>
<h3>2. PostgreSQL Health Check</h3>

<strong>Purpose</strong>: Verify database connectivity and query execution.

<strong>Usage</strong>:
<pre><code class="language-csharp">using Whizbang.Data.Dapper.Postgres;

<p>builder.Services.AddPostgresConnection(connectionString);</p>
<p>builder.Services.AddPostgresHealthChecks();  // ⭐ Register health check</p>

<p>app.MapHealthChecks("/health");</p>
<p></code></pre></p>

<strong>Implementation</strong>:
<pre><code class="language-csharp">public class PostgresHealthCheck(IDbConnectionFactory connectionFactory) : IHealthCheck {
<p>  public async Task<HealthCheckResult> CheckHealthAsync(</p>
<p>    HealthCheckContext context,</p>
<p>    CancellationToken cancellationToken</p>
<p>  ) {</p>
<p>    try {</p>
<p>      using var connection = await connectionFactory.CreateConnectionAsync(cancellationToken);</p>

<p>      // Execute simple query to verify database is accessible</p>
<p>      _ = await connection.ExecuteScalarAsync("SELECT 1");</p>

<p>      return HealthCheckResult.Healthy("PostgreSQL database is accessible");</p>
<p>    } catch (Exception ex) {</p>
<p>      return HealthCheckResult.Unhealthy("PostgreSQL database is not accessible", ex);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>What It Checks</strong>:
<ul><li>✅ Connection factory can create connections</li>
<li>✅ Database accepts queries</li>
<li>✅ Network connectivity to database</li>
</ul>
<strong>Status Levels</strong>:
<ul><li><strong>Healthy</strong>: Database accessible and responsive</li>
<li><strong>Unhealthy</strong>: Connection failed or query timed out</li>
</ul>
<h3>3. Service Bus Readiness Check</h3>

<strong>Purpose</strong>: Cached transport readiness check with initialization verification.

<strong>Usage</strong>:
<pre><code class="language-csharp">using Whizbang.Hosting.Azure.ServiceBus;

<p>builder.Services.AddSingleton<ITransportReadinessCheck, ServiceBusReadinessCheck>();</p>

<p>// Use in startup validation</p>
<p>var readinessCheck = app.Services.GetRequiredService<ITransportReadinessCheck>();</p>
<p>if (!await readinessCheck.IsReadyAsync()) {</p>
<p>  throw new InvalidOperationException("Service Bus is not ready");</p>
<p>}</p>
<p></code></pre></p>

<strong>Implementation</strong>:
<pre><code class="language-csharp">public class ServiceBusReadinessCheck : ITransportReadinessCheck {
<p>  private DateTimeOffset? _lastSuccessfulCheck;</p>
<p>  private readonly TimeSpan _cacheDuration = TimeSpan.FromSeconds(30);</p>

<p>  public async Task<bool> IsReadyAsync(CancellationToken cancellationToken) {</p>
<p>    // 1. Check if transport initialized</p>
<p>    if (!_transport.IsInitialized) {</p>
<p>      return false;</p>
<p>    }</p>

<p>    // 2. Check cache (30-second TTL)</p>
<p>    if (_lastSuccessfulCheck.HasValue &&</p>
<p>        DateTimeOffset.UtcNow - _lastSuccessfulCheck.Value < _cacheDuration) {</p>
<p>      return true;  // Cached result</p>
<p>    }</p>

<p>    // 3. Verify ServiceBusClient is open</p>
<p>    if (_client.IsClosed) {</p>
<p>      return false;</p>
<p>    }</p>

<p>    // 4. Cache successful check</p>
<p>    _lastSuccessfulCheck = DateTimeOffset.UtcNow;</p>
<p>    return true;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>30-second cache reduces health check overhead</li>
<li>Verifies transport initialization (not just registration)</li>
<li>Thread-safe with double-checked locking</li>
</ul>
<hr>

<h2>Registration Patterns</h2>

<h3>Basic Registration</h3>

<pre><code class="language-csharp">builder.Services.AddHealthChecks()
<p>  .AddCheck<AzureServiceBusHealthCheck>("azure_servicebus")</p>
<p>  .AddCheck<PostgresHealthCheck>("postgres");</p>

<p>app.MapHealthChecks("/health");</p>
<p></code></pre></p>

<strong>Endpoint Output</strong>:
<pre><code class="language-json">{
<p>  "status": "Healthy",</p>
<p>  "results": {</p>
<p>    "azure_servicebus": {</p>
<p>      "status": "Healthy",</p>
<p>      "description": "Azure Service Bus transport is available"</p>
<p>    },</p>
<p>    "postgres": {</p>
<p>      "status": "Healthy",</p>
<p>      "description": "PostgreSQL database is accessible"</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Detailed Health Checks</h3>

<pre><code class="language-csharp">builder.Services.AddHealthChecks()
<p>  .AddCheck<AzureServiceBusHealthCheck>(</p>
<p>    name: "azure_servicebus",</p>
<p>    failureStatus: HealthStatus.Degraded,  // Degraded instead of Unhealthy</p>
<p>    tags: ["ready", "live"]  // Kubernetes readiness and liveness</p>
<p>  )</p>
<p>  .AddCheck<PostgresHealthCheck>(</p>
<p>    name: "postgres",</p>
<p>    failureStatus: HealthStatus.Unhealthy,</p>
<p>    tags: ["ready"]  // Required for readiness, not liveness</p>
<p>  );</p>

<p>// Readiness endpoint (includes postgres)</p>
<p>app.MapHealthChecks("/health/ready", new HealthCheckOptions {</p>
<p>  Predicate = check => check.Tags.Contains("ready")</p>
<p>});</p>

<p>// Liveness endpoint (excludes postgres)</p>
<p>app.MapHealthChecks("/health/live", new HealthCheckOptions {</p>
<p>  Predicate = check => check.Tags.Contains("live")</p>
<p>});</p>
<p></code></pre></p>

<strong>Kubernetes Usage</strong>:
<pre><code class="language-yaml"># deployment.yaml
<p>livenessProbe:</p>
<p>  httpGet:</p>
<p>    path: /health/live</p>
<p>    port: 8080</p>
<p>  initialDelaySeconds: 10</p>
<p>  periodSeconds: 10</p>

<p>readinessProbe:</p>
<p>  httpGet:</p>
<p>    path: /health/ready</p>
<p>    port: 8080</p>
<p>  initialDelaySeconds: 5</p>
<p>  periodSeconds: 5</p>
<p></code></pre></p>

<hr>

<h2>Custom Health Checks</h2>

<h3>Implementing IHealthCheck</h3>

<pre><code class="language-csharp">using Microsoft.Extensions.Diagnostics.HealthChecks;

<p>public class RedisHealthCheck : IHealthCheck {</p>
<p>  private readonly IConnectionMultiplexer _redis;</p>

<p>  public RedisHealthCheck(IConnectionMultiplexer redis) {</p>
<p>    _redis = redis;</p>
<p>  }</p>

<p>  public async Task<HealthCheckResult> CheckHealthAsync(</p>
<p>    HealthCheckContext context,</p>
<p>    CancellationToken cancellationToken = default</p>
<p>  ) {</p>
<p>    try {</p>
<p>      // Check Redis connectivity</p>
<p>      var db = _redis.GetDatabase();</p>
<p>      await db.PingAsync();</p>

<p>      // Check specific keys if needed</p>
<p>      var keyExists = await db.KeyExistsAsync("health-check-key");</p>

<p>      var data = new Dictionary<string, object> {</p>
<p>        { "connected", true },</p>
<p>        { "endpoints", _redis.GetEndPoints().Length }</p>
<p>      };</p>

<p>      return HealthCheckResult.Healthy(</p>
<p>        "Redis is accessible",</p>
<p>        data: data</p>
<p>      );</p>
<p>    } catch (Exception ex) {</p>
<p>      return HealthCheckResult.Unhealthy(</p>
<p>        "Redis is not accessible",</p>
<p>        exception: ex</p>
<p>      );</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Registration</strong>:
<pre><code class="language-csharp">builder.Services.AddSingleton<IConnectionMultiplexer>(/<em> Redis connection </em>/);
<p>builder.Services.AddHealthChecks()</p>
<p>  .AddCheck<RedisHealthCheck>("redis");</p>
<p></code></pre></p>

<h3>Timeout and Failure Handling</h3>

<pre><code class="language-csharp">public class ExternalApiHealthCheck : IHealthCheck {
<p>  private readonly HttpClient _httpClient;</p>
<p>  private readonly TimeSpan _timeout = TimeSpan.FromSeconds(5);</p>

<p>  public async Task<HealthCheckResult> CheckHealthAsync(</p>
<p>    HealthCheckContext context,</p>
<p>    CancellationToken cancellationToken</p>
<p>  ) {</p>
<p>    using var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);</p>
<p>    cts.CancelAfter(_timeout);</p>

<p>    try {</p>
<p>      var response = await _httpClient.GetAsync("/health", cts.Token);</p>

<p>      if (response.IsSuccessStatusCode) {</p>
<p>        return HealthCheckResult.Healthy("External API is responsive");</p>
<p>      }</p>

<p>      return HealthCheckResult.Degraded(</p>
<p>        $"External API returned {response.StatusCode}"</p>
<p>      );</p>
<p>    } catch (OperationCanceledException) {</p>
<p>      return HealthCheckResult.Degraded("External API timed out after 5 seconds");</p>
<p>    } catch (Exception ex) {</p>
<p>      return HealthCheckResult.Unhealthy("External API is not accessible", ex);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Aspire Dashboard Integration</h2>

<h3>Automatic Health Monitoring</h3>

<p>When using .NET Aspire, health checks are automatically wired to the dashboard:</p>

<pre><code class="language-csharp">// Service Program.cs
<p>builder.AddServiceDefaults();  // ⭐ Enables Aspire integration</p>

<p>builder.Services.AddHealthChecks()</p>
<p>  .AddCheck<AzureServiceBusHealthCheck>("azure_servicebus")</p>
<p>  .AddCheck<PostgresHealthCheck>("postgres");</p>

<p>var app = builder.Build();</p>
<p>app.MapDefaultEndpoints();  // ⭐ Exposes /health endpoint</p>

<p>app.Run();</p>
<p></code></pre></p>

<strong>Aspire Dashboard</strong> (http://localhost:15888):
<ul><li><strong>Resources Tab</strong>: Shows service health status (🟢 Healthy, 🟡 Degraded, 🔴 Unhealthy)</li>
<li><strong>Health History</strong>: Track health over time</li>
<li><strong>Failure Alerts</strong>: Visual indicators for unhealthy services</li>
</ul>
<hr>

<h2>Advanced Patterns</h2>

<h3>Startup Health Check</h3>

<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);

<p>// Register services and health checks</p>
<p>builder.Services.AddAzureServiceBusTransport(connectionString);</p>
<p>builder.Services.AddHealthChecks()</p>
<p>  .AddCheck<AzureServiceBusHealthCheck>("azure_servicebus");</p>

<p>var app = builder.Build();</p>

<p>// Validate health BEFORE accepting traffic</p>
<p>var healthCheckService = app.Services.GetRequiredService<HealthCheckService>();</p>
<p>var healthReport = await healthCheckService.CheckHealthAsync();</p>

<p>if (healthReport.Status != HealthStatus.Healthy) {</p>
<p>  Console.WriteLine("❌ Application is not healthy - failing startup");</p>
<p>  Console.WriteLine($"Status: {healthReport.Status}");</p>

<p>  foreach (var (key, entry) in healthReport.Entries) {</p>
<p>    if (entry.Status != HealthStatus.Healthy) {</p>
<p>      Console.WriteLine($"  - {key}: {entry.Status} - {entry.Description}");</p>
<p>    }</p>
<p>  }</p>

<p>  Environment.Exit(1);  // Fail fast</p>
<p>}</p>

<p>Console.WriteLine("✅ All health checks passed - starting application");</p>
<p>app.Run();</p>
<p></code></pre></p>

<strong>Benefit</strong>: Prevent application from starting if dependencies are unavailable.

<h3>Cached Health Checks</h3>

<pre><code class="language-csharp">public class CachedDatabaseHealthCheck : IHealthCheck {
<p>  private readonly IDbConnectionFactory _connectionFactory;</p>
<p>  private DateTimeOffset? _lastCheck;</p>
<p>  private HealthCheckResult? _cachedResult;</p>
<p>  private readonly TimeSpan _cacheDuration = TimeSpan.FromMinutes(1);</p>
<p>  private readonly SemaphoreSlim _lock = new(1, 1);</p>

<p>  public async Task<HealthCheckResult> CheckHealthAsync(</p>
<p>    HealthCheckContext context,</p>
<p>    CancellationToken cancellationToken</p>
<p>  ) {</p>
<p>    // Return cached result if available and fresh</p>
<p>    if (_cachedResult != null &&</p>
<p>        _lastCheck.HasValue &&</p>
<p>        DateTimeOffset.UtcNow - _lastCheck.Value < _cacheDuration) {</p>
<p>      return _cachedResult;</p>
<p>    }</p>

<p>    await _lock.WaitAsync(cancellationToken);</p>
<p>    try {</p>
<p>      // Double-check cache after acquiring lock</p>
<p>      if (_cachedResult != null &&</p>
<p>          _lastCheck.HasValue &&</p>
<p>          DateTimeOffset.UtcNow - _lastCheck.Value < _cacheDuration) {</p>
<p>        return _cachedResult;</p>
<p>      }</p>

<p>      // Perform actual health check</p>
<p>      using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);</p>
<p>      _ = await connection.ExecuteScalarAsync("SELECT 1");</p>

<p>      _cachedResult = HealthCheckResult.Healthy("Database is accessible");</p>
<p>      _lastCheck = DateTimeOffset.UtcNow;</p>

<p>      return _cachedResult;</p>
<p>    } catch (Exception ex) {</p>
<p>      _cachedResult = HealthCheckResult.Unhealthy("Database is not accessible", ex);</p>
<p>      _lastCheck = DateTimeOffset.UtcNow;</p>
<p>      return _cachedResult;</p>
<p>    } finally {</p>
<p>      _lock.Release();</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Use Case</strong>: Reduce database load from frequent health checks (Kubernetes polls every 5-10 seconds).

<h3>Composite Health Checks</h3>

<pre><code class="language-csharp">public class ApplicationHealthCheck : IHealthCheck {
<p>  private readonly IHealthCheck[] _checks;</p>

<p>  public ApplicationHealthCheck(</p>
<p>    AzureServiceBusHealthCheck transportCheck,</p>
<p>    PostgresHealthCheck databaseCheck,</p>
<p>    RedisHealthCheck cacheCheck</p>
<p>  ) {</p>
<p>    _checks = new IHealthCheck[] { transportCheck, databaseCheck, cacheCheck };</p>
<p>  }</p>

<p>  public async Task<HealthCheckResult> CheckHealthAsync(</p>
<p>    HealthCheckContext context,</p>
<p>    CancellationToken cancellationToken</p>
<p>  ) {</p>
<p>    var tasks = _checks.Select(check =></p>
<p>      check.CheckHealthAsync(context, cancellationToken)</p>
<p>    );</p>

<p>    var results = await Task.WhenAll(tasks);</p>

<p>    var unhealthyResults = results.Where(r => r.Status == HealthStatus.Unhealthy).ToList();</p>
<p>    var degradedResults = results.Where(r => r.Status == HealthStatus.Degraded).ToList();</p>

<p>    if (unhealthyResults.Any()) {</p>
<p>      return HealthCheckResult.Unhealthy(</p>
<p>        $"{unhealthyResults.Count} component(s) unhealthy"</p>
<p>      );</p>
<p>    }</p>

<p>    if (degradedResults.Any()) {</p>
<p>      return HealthCheckResult.Degraded(</p>
<p>        $"{degradedResults.Count} component(s) degraded"</p>
<p>      );</p>
<p>    }</p>

<p>    return HealthCheckResult.Healthy("All components healthy");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Register health checks for all dependencies</strong> (database, cache, transport)</li>
<li>✅ <strong>Use tags for readiness vs liveness</strong> (readiness includes dependencies, liveness doesn't)</li>
<li>✅ <strong>Cache expensive checks</strong> (database queries, external API calls)</li>
<li>✅ <strong>Use timeouts</strong> to prevent health checks from blocking</li>
<li>✅ <strong>Validate health on startup</strong> (fail fast if misconfigured)</li>
<li>✅ <strong>Monitor health in Aspire dashboard</strong> during development</li>
<li>✅ <strong>Return detailed status</strong> (Healthy, Degraded, Unhealthy with descriptions)</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Perform expensive operations in health checks (use caching)</li>
<li>❌ Include authentication in liveness checks (should always succeed if app is running)</li>
<li>❌ Ignore health check failures in logs (investigate and fix)</li>
<li>❌ Use default <code>/healthz</code> endpoint (configure specific paths like <code>/health/ready</code>)</li>
<li>❌ Skip health checks for "optional" dependencies (mark as Degraded instead)</li>
<li>❌ Block application startup on non-critical dependencies</li>
</ul>
<hr>

<h2>Troubleshooting</h2>

<h3>Problem: Health Check Always Returns Unhealthy</h3>

<strong>Symptoms</strong>: Health endpoint returns 503 Service Unavailable.

<strong>Causes</strong>:
<ul><li>Dependency actually unavailable (database down, Service Bus unreachable)</li>
<li>Health check timeout too short</li>
<li>Caching not working (re-checking every request)</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-csharp">// 1. Check logs for actual failure reason
<p>var healthReport = await healthCheckService.CheckHealthAsync();</p>
<p>foreach (var (key, entry) in healthReport.Entries) {</p>
<p>  logger.LogError("Health check {Name}: {Status} - {Description} - {Exception}",</p>
<p>    key, entry.Status, entry.Description, entry.Exception);</p>
<p>}</p>

<p>// 2. Increase timeout</p>
<p>builder.Services.AddHealthChecks()</p>
<p>  .AddCheck<PostgresHealthCheck>("postgres", timeout: TimeSpan.FromSeconds(30));</p>

<p>// 3. Verify caching logic</p>
<p>if (_lastCheck.HasValue) {</p>
<p>  var age = DateTimeOffset.UtcNow - _lastCheck.Value;</p>
<p>  logger.LogDebug("Cache age: {Age}, Duration: {Duration}", age, _cacheDuration);</p>
<p>}</p>
<p></code></pre></p>

<h3>Problem: Kubernetes Keeps Restarting Pod</h3>

<strong>Symptoms</strong>: Pod repeatedly restarted with "Liveness probe failed" in events.

<strong>Cause</strong>: Liveness check includes database or external dependencies (shouldn't).

<strong>Solution</strong>:
<pre><code class="language-csharp">// Liveness should only check app is running (no external dependencies)
<p>builder.Services.AddHealthChecks()</p>
<p>  .AddCheck("self", () => HealthCheckResult.Healthy("App is running"), tags: ["live"])</p>
<p>  .AddCheck<PostgresHealthCheck>("postgres", tags: ["ready"]);  // Readiness only</p>

<p>// Separate endpoints</p>
<p>app.MapHealthChecks("/health/live", new HealthCheckOptions {</p>
<p>  Predicate = check => check.Tags.Contains("live")</p>
<p>});</p>

<p>app.MapHealthChecks("/health/ready", new HealthCheckOptions {</p>
<p>  Predicate = check => check.Tags.Contains("ready")</p>
<p>});</p>
<p></code></pre></p>

<h3>Problem: Health Checks Cause Database Overload</h3>

<strong>Symptoms</strong>: Database CPU spikes from health check queries.

<strong>Cause</strong>: Kubernetes polling every 5 seconds across 100 pods = 20 queries/second.

<strong>Solution</strong>:
<pre><code class="language-csharp">// Add caching to reduce database load
<p>public class CachedPostgresHealthCheck : PostgresHealthCheck {</p>
<p>  private DateTimeOffset? _lastCheck;</p>
<p>  private HealthCheckResult? _cachedResult;</p>
<p>  private readonly TimeSpan _cacheDuration = TimeSpan.FromSeconds(30);  // ⭐ Cache for 30 seconds</p>

<p>  public override async Task<HealthCheckResult> CheckHealthAsync(...) {</p>
<p>    if (_cachedResult != null &&</p>
<p>        _lastCheck.HasValue &&</p>
<p>        DateTimeOffset.UtcNow - _lastCheck.Value < _cacheDuration) {</p>
<p>      return _cachedResult;  // Return cached result</p>
<p>    }</p>

<p>    _cachedResult = await base.CheckHealthAsync(context, cancellationToken);</p>
<p>    _lastCheck = DateTimeOffset.UtcNow;</p>
<p>    return _cachedResult;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Infrastructure</strong>:
<ul><li><a href="aspire-integration.md">Aspire Integration</a> - .NET Aspire orchestration and dashboard</li>
<li><a href="policies.md">Policies</a> - Policy-based routing and decisions</li>
</ul>
<strong>Transports</strong>:
<ul><li><a href="../transports/azure-service-bus.md">Azure Service Bus Transport</a> - Transport health checks</li>
</ul>
<strong>Data Access</strong>:
<ul><li><a href="../data/dapper-postgres.md">Dapper + PostgreSQL</a> - Database health checks</li>
</ul>
<strong>External Resources</strong>:
<ul><li><a href="https://learn.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks">ASP.NET Core Health Checks</a></li>
<li><a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">Kubernetes Liveness and Readiness Probes</a></li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-infrastructure-policies" class="doc-section">
  <h3>Policy-Based Routing</h3>
  <p class="doc-path"><code>v1.0.0/infrastructure/policies</code></p>
  <p class="doc-description"><em>Dynamic message routing and configuration via predicate-based policies - multi-tenancy, environment-based routing, and execution strategies</em></p>
  <div class="doc-content">

<h1>Policy-Based Routing</h1>

<strong>Policy-based routing</strong> enables dynamic message configuration based on runtime conditions. Policies evaluate message context (type, aggregate ID, tenant, environment) and return routing configuration (topics, execution strategies, partitioning) without hardcoding business logic into handlers.

<h2>Why Policies?</h2>

<strong>Policies decouple routing decisions from business logic</strong>:

<p>| Without Policies | With Policies | Benefit |</p>
<p>|------------------|---------------|---------|</p>
<p>| <strong>Hardcoded Routes</strong> | Dynamic predicates | Flexible configuration |</p>
<p>| <strong>If/Else Chains</strong> | First-match evaluation | Clean code |</p>
<p>| <strong>Per-Handler Config</strong> | Centralized policy engine | Single source of truth |</p>
<p>| <strong>No Audit Trail</strong> | PolicyDecisionTrail | Full observability |</p>
<p>| <strong>Multi-Tenant Logic Scattered</strong> | Tenant-based policies | Centralized multi-tenancy |</p>

<strong>Use Cases</strong>:
<ul><li>✅ <strong>Multi-Tenancy</strong> - Route messages to tenant-specific topics/databases</li>
<li>✅ <strong>Environment-Based Routing</strong> - Different config for dev/staging/prod</li>
<li>✅ <strong>Aggregate-Based Partitioning</strong> - Route by OrderId, CustomerId, etc.</li>
<li>✅ <strong>Execution Strategies</strong> - Serial vs parallel based on message type</li>
<li>✅ <strong>Feature Flags</strong> - Enable/disable routing based on tags/metadata</li>
</ul>
<hr>

<h2>Architecture</h2>

<h3>Policy Evaluation Flow</h3>

<pre><code class="language-">┌────────────────────────────────────────────────────────┐
<p>│  Message Processing                                    │</p>
<p>│                                                         │</p>
<p>│  1. Rent PolicyContext from pool                       │</p>
<p>│     context = PolicyContextPool.Rent(message, ...)     │</p>
<p>│                                                         │</p>
<p>│  2. Evaluate policies                                  │</p>
<p>│     config = await policyEngine.MatchAsync(context)    │</p>
<p>│                                                         │</p>
<p>│  3. Use configuration                                  │</p>
<p>│     - Topic routing                                    │</p>
<p>│     - Execution strategy                               │</p>
<p>│     - Partitioning                                     │</p>
<p>│     - Concurrency                                      │</p>
<p>└────────────────────────────────────────────────────────┘</p>

<p>PolicyEngine Evaluation:</p>

<p>┌────────────────────────────────────────────────────────┐</p>
<p>│  PolicyEngine.MatchAsync(context)                      │</p>
<p>│                                                         │</p>
<p>│  Policies evaluated in order (first match wins):       │</p>
<p>│  ├─ Policy 1: TenantRouting                            │</p>
<p>│  │  ├─ Predicate: context.GetMetadata("tenantId") == "tenant-a"</p>
<p>│  │  ├─ Matched: ✅                                     │</p>
<p>│  │  └─ Configuration: Topic = "tenant-a-events"        │</p>
<p>│  │                                                      │</p>
<p>│  │  ⭐ RETURN (first match - skip remaining policies)  │</p>
<p>│  │                                                      │</p>
<p>│  ├─ Policy 2: EnvironmentRouting (skipped)             │</p>
<p>│  └─ Policy 3: DefaultRouting (skipped)                 │</p>
<p>└────────────────────────────────────────────────────────┘</p>

<p>PolicyDecisionTrail (Observability):</p>

<p>┌────────────────────────────────────────────────────────┐</p>
<p>│  context.Trail.Decisions                               │</p>
<p>│                                                         │</p>
<p>│  [0] PolicyName: "TenantRouting"                       │</p>
<p>│      Rule: "tenantId == tenant-a"                      │</p>
<p>│      Matched: ✅                                       │</p>
<p>│      Configuration: { Topic: "tenant-a-events" }       │</p>
<p>│      Reason: "Tenant-based routing matched"            │</p>
<p>│      Timestamp: 2024-12-12T10:30:45Z                   │</p>
<p>│                                                         │</p>
<p>│  [1] PolicyName: "EnvironmentRouting"                  │</p>
<p>│      Rule: "environment == production"                 │</p>
<p>│      Matched: ❌                                       │</p>
<p>│      Reason: "Environment is development"              │</p>
<p>│      Timestamp: 2024-12-12T10:30:45Z                   │</p>
<p>└────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<hr>

<h2>Core Components</h2>

<h3>1. PolicyEngine</h3>

<strong>Purpose</strong>: Evaluates policies in order, returns first match.

<strong>Registration</strong>:
<pre><code class="language-csharp">builder.Services.AddSingleton<IPolicyEngine, PolicyEngine>();
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">var policyEngine = new PolicyEngine();

<p>// Add policies (evaluated in order)</p>
<p>policyEngine.AddPolicy(</p>
<p>  name: "TenantRouting",</p>
<p>  predicate: context =></p>
<p>    context.GetMetadata("tenantId")?.ToString() == "tenant-a",</p>
<p>  configure: config =></p>
<p>    config.PublishToServiceBus("tenant-a-events")</p>
<p>);</p>

<p>policyEngine.AddPolicy(</p>
<p>  name: "DefaultRouting",</p>
<p>  predicate: context => true,  // Always matches (fallback)</p>
<p>  configure: config =></p>
<p>    config.PublishToServiceBus("default-events")</p>
<p>);</p>

<p>// Evaluate policies</p>
<p>var config = await policyEngine.MatchAsync(context);</p>
<p></code></pre></p>

<strong>Evaluation Rules</strong>:
<ul><li>Policies evaluated in registration order</li>
<li>First matched policy returns configuration</li>
<li>Subsequent policies skipped</li>
<li>If no policies match, returns <code>null</code></li>
</ul>
<h3>2. PolicyContext</h3>

<strong>Purpose</strong>: Universal context with message, envelope, services, environment.

<strong>Properties</strong>:
<pre><code class="language-csharp">public class PolicyContext {
<p>  public object Message { get; }              // The message being processed</p>
<p>  public Type MessageType { get; }            // Runtime type of message</p>
<p>  public IMessageEnvelope? Envelope { get; }  // Envelope with metadata</p>
<p>  public IServiceProvider? Services { get; }  // DI container</p>
<p>  public string Environment { get; }          // "development", "production", etc.</p>
<p>  public DateTimeOffset ExecutionTime { get; } // When processing started</p>
<p>  public PolicyDecisionTrail Trail { get; }   // Decision audit trail</p>
<p>}</p>
<p></code></pre></p>

<strong>Helper Methods</strong>:
<pre><code class="language-csharp">// Service resolution
<p>var repository = context.GetService<IOrderRepository>();</p>

<p>// Metadata access</p>
<p>var tenantId = context.GetMetadata("tenantId");</p>
<p>var hasHighPriority = context.HasTag("high-priority");</p>
<p>var isUrgent = context.HasFlag(MessageFlags.Urgent);</p>

<p>// Aggregate matching</p>
<p>bool isOrderMessage = context.MatchesAggregate<Order>();</p>

<p>// Aggregate ID extraction (zero reflection)</p>
<p>var orderId = context.GetAggregateId();  // Requires [AggregateId] attribute</p>
<p></code></pre></p>

<strong>Pooling</strong>:
<pre><code class="language-csharp">// Rent from pool
<p>var context = PolicyContextPool.Rent(message, envelope, services, "production");</p>

<p>try {</p>
<p>  var config = await policyEngine.MatchAsync(context);</p>
<p>  // Use config...</p>
<p>} finally {</p>
<p>  // Always return to pool</p>
<p>  PolicyContextPool.Return(context);</p>
<p>}</p>
<p></code></pre></p>

<h3>3. PolicyDecisionTrail</h3>

<strong>Purpose</strong>: Records all policy decisions for debugging and time-travel.

<strong>Usage</strong>:
<pre><code class="language-csharp">// Automatic recording by PolicyEngine
<p>context.Trail.RecordDecision(</p>
<p>  policyName: "TenantRouting",</p>
<p>  rule: "tenantId == tenant-a",</p>
<p>  matched: true,</p>
<p>  configuration: config,</p>
<p>  reason: "Tenant-based routing matched"</p>
<p>);</p>

<p>// Query trail</p>
<p>var matchedPolicies = context.Trail.GetMatchedRules();</p>
<p>var unmatchedPolicies = context.Trail.GetUnmatchedRules();</p>

<p>foreach (var decision in context.Trail.Decisions) {</p>
<p>  Console.WriteLine($"{decision.PolicyName}: {decision.Matched} - {decision.Reason}");</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li><strong>Debugging</strong>: See why specific configuration was applied</li>
<li><strong>Auditing</strong>: Track policy decisions over time</li>
<li><strong>Time-Travel</strong>: Replay message processing with decision history</li>
</ul>
<h3>4. PolicyConfiguration</h3>

<strong>Purpose</strong>: Routing and execution configuration returned by matched policy.

<strong>Properties</strong>:
<pre><code class="language-csharp">public class PolicyConfiguration {
<p>  // Publishing (outbound)</p>
<p>  public List<PublishTarget> PublishTargets { get; }</p>

<p>  // Subscribing (inbound)</p>
<p>  public List<SubscriptionTarget> SubscriptionTargets { get; }</p>

<p>  // Stream configuration</p>
<p>  public string? Topic { get; }</p>
<p>  public string? StreamKey { get; }</p>

<p>  // Execution strategy</p>
<p>  public Type? ExecutionStrategyType { get; }</p>
<p>  public Type? PartitionRouterType { get; }</p>
<p>  public int? PartitionCount { get; }</p>
<p>  public int? MaxConcurrency { get; }</p>

<p>  // Persistence size limits</p>
<p>  public int? MaxDataSizeBytes { get; }</p>
<p>  public bool SuppressSizeWarnings { get; }</p>
<p>  public bool ThrowOnSizeExceeded { get; }</p>
<p>}</p>
<p></code></pre></p>

<strong>Fluent API</strong>:
<pre><code class="language-csharp">configure: config => config
<p>  .PublishToServiceBus("order-events")</p>
<p>  .UseStreamKey("order-{aggregateId}")</p>
<p>  .UseExecutionStrategy<SerialExecutor>()</p>
<p>  .UsePartitionRouter<HashPartitionRouter>()</p>
<p>  .WithPartitions(count: 100)</p>
<p>  .WithConcurrency(maxConcurrency: 10)</p>
<p>  .WithPersistenceSize(maxDataSizeBytes: 7000, throwOnExceeded: true)</p>
<p></code></pre></p>

<hr>

<h2>Common Policies</h2>

<h3>1. Multi-Tenant Routing</h3>

<pre><code class="language-csharp">policyEngine.AddPolicy(
<p>  name: "TenantARouting",</p>
<p>  predicate: context =></p>
<p>    context.GetMetadata("tenantId")?.ToString() == "tenant-a",</p>
<p>  configure: config => config</p>
<p>    .PublishToServiceBus("tenant-a-events")</p>
<p>    .UseStreamKey("tenant-a-{aggregateId}")</p>
<p>);</p>

<p>policyEngine.AddPolicy(</p>
<p>  name: "TenantBRouting",</p>
<p>  predicate: context =></p>
<p>    context.GetMetadata("tenantId")?.ToString() == "tenant-b",</p>
<p>  configure: config => config</p>
<p>    .PublishToServiceBus("tenant-b-events")</p>
<p>    .UseStreamKey("tenant-b-{aggregateId}")</p>
<p>);</p>

<p>// Fallback for unknown tenants</p>
<p>policyEngine.AddPolicy(</p>
<p>  name: "DefaultTenantRouting",</p>
<p>  predicate: context => true,</p>
<p>  configure: config => config</p>
<p>    .PublishToServiceBus("default-events")</p>
<p>);</p>
<p></code></pre></p>

<h3>2. Environment-Based Routing</h3>

<pre><code class="language-csharp">policyEngine.AddPolicy(
<p>  name: "ProductionRouting",</p>
<p>  predicate: context => context.Environment == "production",</p>
<p>  configure: config => config</p>
<p>    .PublishToServiceBus("prod-events")</p>
<p>    .WithConcurrency(maxConcurrency: 50)</p>
<p>);</p>

<p>policyEngine.AddPolicy(</p>
<p>  name: "StagingRouting",</p>
<p>  predicate: context => context.Environment == "staging",</p>
<p>  configure: config => config</p>
<p>    .PublishToServiceBus("staging-events")</p>
<p>    .WithConcurrency(maxConcurrency: 10)</p>
<p>);</p>

<p>policyEngine.AddPolicy(</p>
<p>  name: "DevelopmentRouting",</p>
<p>  predicate: context => context.Environment == "development",</p>
<p>  configure: config => config</p>
<p>    .PublishToServiceBus("dev-events")</p>
<p>    .WithConcurrency(maxConcurrency: 1)  // Serial processing in dev</p>
<p>);</p>
<p></code></pre></p>

<h3>3. Aggregate-Based Partitioning</h3>

<pre><code class="language-csharp">policyEngine.AddPolicy(
<p>  name: "OrderPartitioning",</p>
<p>  predicate: context => context.MatchesAggregate<Order>(),</p>
<p>  configure: config => config</p>
<p>    .UseStreamKey("order-{aggregateId}")</p>
<p>    .UsePartitionRouter<HashPartitionRouter>()</p>
<p>    .WithPartitions(count: 100)</p>
<p>);</p>

<p>policyEngine.AddPolicy(</p>
<p>  name: "CustomerPartitioning",</p>
<p>  predicate: context => context.MatchesAggregate<Customer>(),</p>
<p>  configure: config => config</p>
<p>    .UseStreamKey("customer-{aggregateId}")</p>
<p>    .UsePartitionRouter<HashPartitionRouter>()</p>
<p>    .WithPartitions(count: 50)</p>
<p>);</p>
<p></code></pre></p>

<h3>4. Message Type-Based Execution</h3>

<pre><code class="language-csharp">policyEngine.AddPolicy(
<p>  name: "BulkImportExecutionStrategy",</p>
<p>  predicate: context => context.MessageType.Name.Contains("BulkImport"),</p>
<p>  configure: config => config</p>
<p>    .UseExecutionStrategy<ParallelExecutor>()</p>
<p>    .WithConcurrency(maxConcurrency: 100)</p>
<p>);</p>

<p>policyEngine.AddPolicy(</p>
<p>  name: "OrderExecutionStrategy",</p>
<p>  predicate: context => context.MessageType.Name.Contains("Order"),</p>
<p>  configure: config => config</p>
<p>    .UseExecutionStrategy<SerialExecutor>()  // Strict ordering for orders</p>
<p>);</p>
<p></code></pre></p>

<h3>5. Tag-Based Routing</h3>

<pre><code class="language-csharp">policyEngine.AddPolicy(
<p>  name: "HighPriorityRouting",</p>
<p>  predicate: context => context.HasTag("high-priority"),</p>
<p>  configure: config => config</p>
<p>    .PublishToServiceBus("priority-events")</p>
<p>    .WithConcurrency(maxConcurrency: 100)</p>
<p>);</p>

<p>policyEngine.AddPolicy(</p>
<p>  name: "ArchivalRouting",</p>
<p>  predicate: context => context.HasTag("archival"),</p>
<p>  configure: config => config</p>
<p>    .PublishToServiceBus("archive-events")</p>
<p>    .WithConcurrency(maxConcurrency: 1)  // Low priority</p>
<p>);</p>
<p></code></pre></p>

<hr>

<h2>Advanced Patterns</h2>

<h3>Composite Policies</h3>

<pre><code class="language-csharp">policyEngine.AddPolicy(
<p>  name: "HighValueOrderRouting",</p>
<p>  predicate: context => {</p>
<p>    // Complex predicate with multiple conditions</p>
<p>    bool isOrder = context.MatchesAggregate<Order>();</p>
<p>    bool isHighValue = context.GetMetadata("totalAmount") is decimal amount && amount > 10000;</p>
<p>    bool isProduction = context.Environment == "production";</p>

<p>    return isOrder && isHighValue && isProduction;</p>
<p>  },</p>
<p>  configure: config => config</p>
<p>    .PublishToServiceBus("high-value-orders")</p>
<p>    .UseExecutionStrategy<SerialExecutor>()</p>
<p>    .WithConcurrency(maxConcurrency: 1)</p>
<p>);</p>
<p></code></pre></p>

<h3>Service-Injected Policies</h3>

<pre><code class="language-csharp">policyEngine.AddPolicy(
<p>  name: "FeatureFlagRouting",</p>
<p>  predicate: context => {</p>
<p>    // Resolve service from context</p>
<p>    var featureFlags = context.GetService<IFeatureFlagService>();</p>

<p>    // Check feature flag</p>
<p>    return featureFlags.IsEnabled("new-event-routing");</p>
<p>  },</p>
<p>  configure: config => config</p>
<p>    .PublishToServiceBus("new-events-topic")</p>
<p>);</p>
<p></code></pre></p>

<h3>Time-Based Policies</h3>

<pre><code class="language-csharp">policyEngine.AddPolicy(
<p>  name: "PeakHoursRouting",</p>
<p>  predicate: context => {</p>
<p>    var hour = context.ExecutionTime.Hour;</p>
<p>    bool isPeakHours = hour >= 9 && hour <= 17;  // 9 AM - 5 PM</p>

<p>    return isPeakHours;</p>
<p>  },</p>
<p>  configure: config => config</p>
<p>    .WithConcurrency(maxConcurrency: 100)  // High concurrency during peak</p>
<p>);</p>

<p>policyEngine.AddPolicy(</p>
<p>  name: "OffHoursRouting",</p>
<p>  predicate: context => true,  // Fallback</p>
<p>  configure: config => config</p>
<p>    .WithConcurrency(maxConcurrency: 10)  // Lower concurrency off-peak</p>
<p>);</p>
<p></code></pre></p>

<hr>

<h2>Testing Policies</h2>

<h3>Unit Testing Predicates</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task TenantARouting_WithTenantA_MatchesAsync() {</p>
<p>  // Arrange</p>
<p>  var context = new PolicyContext(</p>
<p>    message: new CreateOrder(),</p>
<p>    envelope: CreateEnvelope(metadata: new Dictionary<string, object> {</p>
<p>      ["tenantId"] = "tenant-a"</p>
<p>    }),</p>
<p>    services: null,</p>
<p>    environment: "production"</p>
<p>  );</p>

<p>  var policyEngine = new PolicyEngine();</p>
<p>  policyEngine.AddPolicy(</p>
<p>    name: "TenantARouting",</p>
<p>    predicate: ctx => ctx.GetMetadata("tenantId")?.ToString() == "tenant-a",</p>
<p>    configure: config => config.PublishToServiceBus("tenant-a-events")</p>
<p>  );</p>

<p>  // Act</p>
<p>  var result = await policyEngine.MatchAsync(context);</p>

<p>  // Assert</p>
<p>  await Assert.That(result).IsNotNull();</p>
<p>  await Assert.That(result!.PublishTargets).HasCount().EqualTo(1);</p>
<p>  await Assert.That(result.PublishTargets[0].Destination).IsEqualTo("tenant-a-events");</p>
<p>}</p>
<p></code></pre></p>

<h3>Testing Policy Order</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task PolicyEngine_FirstMatchWins_SkipsSubsequentPoliciesAsync() {</p>
<p>  // Arrange</p>
<p>  var context = new PolicyContext(new CreateOrder(), null, null, "production");</p>

<p>  var policyEngine = new PolicyEngine();</p>

<p>  policyEngine.AddPolicy("FirstPolicy",</p>
<p>    predicate: ctx => true,  // Always matches</p>
<p>    configure: config => config.PublishToServiceBus("first-topic")</p>
<p>  );</p>

<p>  policyEngine.AddPolicy("SecondPolicy",</p>
<p>    predicate: ctx => true,  // Would match, but skipped</p>
<p>    configure: config => config.PublishToServiceBus("second-topic")</p>
<p>  );</p>

<p>  // Act</p>
<p>  var result = await policyEngine.MatchAsync(context);</p>

<p>  // Assert</p>
<p>  await Assert.That(result!.PublishTargets[0].Destination).IsEqualTo("first-topic");</p>

<p>  // Verify decision trail</p>
<p>  var matched = context.Trail.GetMatchedRules().ToList();</p>
<p>  await Assert.That(matched).HasCount().EqualTo(1);</p>
<p>  await Assert.That(matched[0].PolicyName).IsEqualTo("FirstPolicy");</p>
<p>}</p>
<p></code></pre></p>

<h3>Testing PolicyDecisionTrail</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task PolicyEngine_RecordsDecisionTrail_ForAllPoliciesAsync() {</p>
<p>  // Arrange</p>
<p>  var context = new PolicyContext(new CreateOrder(), null, null, "production");</p>

<p>  var policyEngine = new PolicyEngine();</p>
<p>  policyEngine.AddPolicy("Policy1", ctx => false, config => { });</p>
<p>  policyEngine.AddPolicy("Policy2", ctx => true, config => { });</p>

<p>  // Act</p>
<p>  await policyEngine.MatchAsync(context);</p>

<p>  // Assert</p>
<p>  var decisions = context.Trail.Decisions.ToList();</p>
<p>  await Assert.That(decisions).HasCount().EqualTo(2);</p>

<p>  // First policy did not match</p>
<p>  await Assert.That(decisions[0].PolicyName).IsEqualTo("Policy1");</p>
<p>  await Assert.That(decisions[0].Matched).IsFalse();</p>

<p>  // Second policy matched</p>
<p>  await Assert.That(decisions[1].PolicyName).IsEqualTo("Policy2");</p>
<p>  await Assert.That(decisions[1].Matched).IsTrue();</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Register policies in order of specificity</strong> (most specific first, fallback last)</li>
<li>✅ <strong>Use descriptive policy names</strong> for clarity in decision trails</li>
<li>✅ <strong>Return contexts to pool</strong> after policy evaluation</li>
<li>✅ <strong>Test policies with various inputs</strong> (unit test predicates)</li>
<li>✅ <strong>Use service injection</strong> for complex predicates (feature flags, config)</li>
<li>✅ <strong>Add fallback policy</strong> with <code>predicate: ctx => true</code> at end</li>
<li>✅ <strong>Monitor PolicyDecisionTrail</strong> in logs for debugging</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Perform expensive operations in predicates (database queries, API calls)</li>
<li>❌ Mutate context in predicates (side effects)</li>
<li>❌ Throw exceptions in predicates (they're caught and logged as failures)</li>
<li>❌ Skip returning contexts to pool (memory leak)</li>
<li>❌ Hardcode business logic in predicates (use services instead)</li>
<li>❌ Use policies for non-routing concerns (keep focused on configuration)</li>
</ul>
<hr>

<h2>Troubleshooting</h2>

<h3>Problem: No Policy Matches, Null Configuration</h3>

<strong>Symptoms</strong>: <code>MatchAsync()</code> returns <code>null</code>, no configuration applied.

<strong>Cause</strong>: No policies registered or all predicates return <code>false</code>.

<strong>Solution</strong>:
<pre><code class="language-csharp">// Add fallback policy
<p>policyEngine.AddPolicy(</p>
<p>  name: "DefaultPolicy",</p>
<p>  predicate: context => true,  // Always matches (last resort)</p>
<p>  configure: config => config</p>
<p>    .PublishToServiceBus("default-events")</p>
<p>);</p>

<p>// Verify policies registered</p>
<p>var config = await policyEngine.MatchAsync(context);</p>
<p>if (config is null) {</p>
<p>  logger.LogWarning("No policy matched for message {MessageType}", context.MessageType.Name);</p>

<p>  // Check decision trail</p>
<p>  foreach (var decision in context.Trail.Decisions) {</p>
<p>    logger.LogDebug("Policy {PolicyName}: {Matched} - {Reason}",</p>
<p>      decision.PolicyName, decision.Matched, decision.Reason);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Problem: Wrong Policy Matched</h3>

<strong>Symptoms</strong>: Unexpected configuration returned.

<strong>Cause</strong>: Policy order incorrect (fallback registered before specific policies).

<strong>Solution</strong>:
<pre><code class="language-csharp">// ❌ WRONG: Fallback first (always matches)
<p>policyEngine.AddPolicy("Fallback", ctx => true, config => config.PublishToServiceBus("default"));</p>
<p>policyEngine.AddPolicy("Specific", ctx => ctx.HasTag("high-priority"), config => config.PublishToServiceBus("priority"));</p>

<p>// ✅ CORRECT: Specific first, fallback last</p>
<p>policyEngine.AddPolicy("Specific", ctx => ctx.HasTag("high-priority"), config => config.PublishToServiceBus("priority"));</p>
<p>policyEngine.AddPolicy("Fallback", ctx => true, config => config.PublishToServiceBus("default"));</p>
<p></code></pre></p>

<h3>Problem: Predicate Throws Exception</h3>

<strong>Symptoms</strong>: Policy skipped with error in decision trail.

<strong>Cause</strong>: Exception thrown in predicate.

<strong>Solution</strong>:
<pre><code class="language-csharp">// Predicate exception is caught and logged
<p>policyEngine.AddPolicy(</p>
<p>  name: "FaultyPolicy",</p>
<p>  predicate: context => {</p>
<p>    var metadata = context.GetMetadata("value");</p>
<p>    return (int)metadata! > 100;  // NullReferenceException if missing</p>
<p>  },</p>
<p>  configure: config => { }</p>
<p>);</p>

<p>// Decision trail shows failure</p>
<p>// PolicyName: "FaultyPolicy"</p>
<p>// Matched: false</p>
<p>// Reason: "Evaluation failed: Object reference not set to an instance of an object"</p>

<p>// FIX: Null-safe predicate</p>
<p>policyEngine.AddPolicy(</p>
<p>  name: "SafePolicy",</p>
<p>  predicate: context => {</p>
<p>    var metadata = context.GetMetadata("value");</p>
<p>    return metadata is int value && value > 100;  // ✅ Null-safe</p>
<p>  },</p>
<p>  configure: config => { }</p>
<p>);</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Infrastructure</strong>:
<ul><li><a href="pooling.md">Object Pooling</a> - PolicyContext pooling for performance</li>
<li><a href="aspire-integration.md">Aspire Integration</a> - Service configuration injection</li>
</ul>
<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/message-context.md">Message Context</a> - MessageId, CorrelationId, CausationId</li>
<li><a href="../core-concepts/observability.md">Observability</a> - Distributed tracing with hops</li>
</ul>
<strong>Source Generators</strong>:
<ul><li><a href="../source-generators/aggregate-ids.md">Aggregate IDs</a> - Zero-reflection aggregate ID extraction</li>
</ul>
<strong>Advanced</strong>:
<ul><li><a href="../advanced/multi-tenancy.md">Multi-Tenancy</a> - Tenant isolation patterns</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-infrastructure-pooling" class="doc-section">
  <h3>Object Pooling</h3>
  <p class="doc-path"><code>v1.0.0/infrastructure/pooling</code></p>
  <p class="doc-description"><em>Zero-allocation object pooling for high-performance message processing - reduce heap pressure and GC overhead</em></p>
  <div class="doc-content">

<h1>Object Pooling</h1>

<strong>Object pooling</strong> reduces heap allocations by reusing objects instead of creating new ones. Whizbang uses pooling for frequently-allocated objects like <code>PolicyContext</code> to minimize garbage collection pressure and improve throughput in high-performance scenarios.

<h2>Why Object Pooling?</h2>

<strong>Pooling reduces GC overhead</strong> for frequently-created objects:

<p>| Without Pooling | With Pooling | Improvement |</p>
<p>|-----------------|--------------|-------------|</p>
<p>| <strong>1M PolicyContext</strong> created | 1,024 PolicyContext created (max pool size) | ~999x fewer allocations |</p>
<p>| <strong>Gen 0 GC</strong>: Every 5,000 messages | <strong>Gen 0 GC</strong>: Every 500,000 messages | ~100x less frequent |</p>
<p>| <strong>Heap Pressure</strong>: 160MB | <strong>Heap Pressure</strong>: ~1.6MB | ~100x reduction |</p>
<p>| <strong>Throughput</strong>: 50K msg/sec | <strong>Throughput</strong>: 150K msg/sec | <strong>3x faster</strong> |</p>

<strong>When to Use Pooling</strong>:
<ul><li>✅ <strong>High-Throughput Scenarios</strong> - Processing 10K+ messages/second</li>
<li>✅ <strong>Frequently-Allocated Objects</strong> - Created and discarded per message</li>
<li>✅ <strong>Short-Lived Objects</strong> - Used briefly then returned to pool</li>
<li>✅ <strong>Fixed-Size Objects</strong> - Predictable memory usage</li>
</ul>
<strong>Whizbang Pooled Objects</strong>:
<ul><li><code>PolicyContext</code> - Message processing context (100-200 bytes)</li>
<li><code>ExecutionState</code> - Execution pipeline state (50-100 bytes)</li>
</ul>
<hr>

<h2>Architecture</h2>

<h3>PolicyContextPool Design</h3>

<pre><code class="language-">┌────────────────────────────────────────────────────────┐
<p>│  PolicyContextPool (Static)                            │</p>
<p>│                                                         │</p>
<p>│  ┌──────────────────────────────────────────────────┐ │</p>
<p>│  │  ConcurrentBag<PolicyContext>                    │ │</p>
<p>│  │  (Thread-safe, lock-free pool)                   │ │</p>
<p>│  │                                                   │ │</p>
<p>│  │  [Context1] [Context2] [Context3] ... [Context1024]  │</p>
<p>│  │                                                   │ │</p>
<p>│  │  Max Size: 1024 (overflow discarded)             │ │</p>
<p>│  └──────────────────────────────────────────────────┘ │</p>
<p>└────────────────────────────────────────────────────────┘</p>

<p>Message Processing Lifecycle:</p>

<ul><li>Rent from Pool</li>
</ul><p>   ↓</p>
<p>   context = PolicyContextPool.Rent(message, envelope, services, environment);</p>
<p>   ↓</p>
<ul><li>Initialize with Message</li>
</ul><p>   ↓</p>
<p>   context.Initialize(message, envelope, services, environment);</p>
<p>   ↓</p>
<ul><li>Use Context in Processing</li>
</ul><p>   ↓</p>
<p>   var config = await policyEngine.MatchAsync(context);</p>
<p>   await HandleMessageAsync(message, context);</p>
<p>   ↓</p>
<ul><li>Return to Pool</li>
</ul><p>   ↓</p>
<p>   PolicyContextPool.Return(context);</p>
<p>   ↓</p>
<p>   context.Reset() → clears references</p>
<p>   ↓</p>
<p>   Added to pool (if not full) or GC'd (if full)</p>
<p></code></pre></p>

<hr>

<h2>PolicyContextPool</h2>

<h3>Implementation</h3>

<pre><code class="language-csharp">using Whizbang.Core.Pooling;

<p>public static class PolicyContextPool {</p>
<p>  private static readonly ConcurrentBag<PolicyContext> _pool = [];</p>
<p>  private static int _poolSize = 0;</p>
<p>  private const int MaxPoolSize = 1024;</p>

<p>  /// <summary></p>
<p>  /// Rents a PolicyContext from the pool and initializes it.</p>
<p>  /// If pool is empty, creates a new instance.</p>
<p>  /// </summary></p>
<p>  public static PolicyContext Rent(</p>
<p>    object message,</p>
<p>    IMessageEnvelope? envelope,</p>
<p>    IServiceProvider? services,</p>
<p>    string environment</p>
<p>  ) {</p>
<p>    if (_pool.TryTake(out var context)) {</p>
<p>      Interlocked.Decrement(ref _poolSize);</p>
<p>    } else {</p>
<p>      context = new PolicyContext();</p>
<p>    }</p>

<p>    context.Initialize(message, envelope, services, environment);</p>
<p>    return context;</p>
<p>  }</p>

<p>  /// <summary></p>
<p>  /// Returns a PolicyContext to the pool after resetting it.</p>
<p>  /// If pool is full, context is discarded and GC'd.</p>
<p>  /// </summary></p>
<p>  public static void Return(PolicyContext? context) {</p>
<p>    if (context is null) {</p>
<p>      return;</p>
<p>    }</p>

<p>    // Reset to clear references (prevent memory leaks)</p>
<p>    context.Reset();</p>

<p>    // Only add back if pool not full</p>
<p>    if (_poolSize < MaxPoolSize) {</p>
<p>      _pool.Add(context);</p>
<p>      Interlocked.Increment(ref _poolSize);</p>
<p>    }</p>
<p>    // If full, let context be GC'd</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Features</strong>:
<ul><li><strong>Thread-Safe</strong>: <code>ConcurrentBag</code> provides lock-free concurrency</li>
<li><strong>Max Size Limit</strong>: Prevents unbounded growth (1,024 contexts = ~100KB max)</li>
<li><strong>Overflow Handling</strong>: Discards contexts when full (GC collects them)</li>
<li><strong>Reset Before Return</strong>: Clears references to prevent memory leaks</li>
</ul>
<hr>

<h2>Usage Patterns</h2>

<h3>Basic Rent/Return</h3>

<pre><code class="language-csharp">using Whizbang.Core.Pooling;
<p>using Whizbang.Core.Policies;</p>

<p>public class MessageHandler {</p>
<p>  private readonly IPolicyEngine _policyEngine;</p>
<p>  private readonly IServiceProvider _services;</p>

<p>  public async Task HandleAsync(</p>
<p>    object message,</p>
<p>    IMessageEnvelope envelope,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    // Rent context from pool</p>
<p>    var context = PolicyContextPool.Rent(</p>
<p>      message,</p>
<p>      envelope,</p>
<p>      _services,</p>
<p>      environment: "production"</p>
<p>    );</p>

<p>    try {</p>
<p>      // Use context for policy evaluation</p>
<p>      var config = await _policyEngine.MatchAsync(context);</p>

<p>      // Process message with context</p>
<p>      await ProcessMessageAsync(message, config, context, ct);</p>
<p>    } finally {</p>
<p>      // ALWAYS return to pool (even on exception)</p>
<p>      PolicyContextPool.Return(context);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Critical</strong>: Always return contexts in <code>finally</code> block to prevent pool depletion.

<h3>Automatic Return with Using</h3>

<pre><code class="language-csharp">// Helper class for IDisposable pattern
<p>public class PooledPolicyContext : IDisposable {</p>
<p>  public PolicyContext Context { get; }</p>

<p>  public PooledPolicyContext(</p>
<p>    object message,</p>
<p>    IMessageEnvelope? envelope,</p>
<p>    IServiceProvider? services,</p>
<p>    string environment</p>
<p>  ) {</p>
<p>    Context = PolicyContextPool.Rent(message, envelope, services, environment);</p>
<p>  }</p>

<p>  public void Dispose() {</p>
<p>    PolicyContextPool.Return(Context);</p>
<p>  }</p>
<p>}</p>

<p>// Usage</p>
<p>using var pooled = new PooledPolicyContext(message, envelope, services, "production");</p>
<p>var config = await policyEngine.MatchAsync(pooled.Context);</p>
<p>// Automatic return when 'using' block exits</p>
<p></code></pre></p>

<h3>Async Method Pattern</h3>

<pre><code class="language-csharp">public async Task ProcessMessageAsync(
<p>  CreateOrder command,</p>
<p>  IMessageEnvelope envelope,</p>
<p>  CancellationToken ct</p>
<p>) {</p>
<p>  var context = PolicyContextPool.Rent(command, envelope, _services, "production");</p>

<p>  try {</p>
<p>    // Async policy evaluation</p>
<p>    var config = await _policyEngine.MatchAsync(context);</p>

<p>    // Async message processing</p>
<p>    await _receptor.HandleAsync(command, ct);</p>

<p>    // Async event publishing</p>
<p>    var @event = new OrderCreated(command.OrderId);</p>
<p>    await PublishEventAsync(@event, config, ct);</p>
<p>  } finally {</p>
<p>    // Return even if async operation cancelled</p>
<p>    PolicyContextPool.Return(context);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>PolicyContext Lifecycle</h2>

<h3>1. Rent (Create or Reuse)</h3>

<pre><code class="language-csharp">var context = PolicyContextPool.Rent(message, envelope, services, "production");
<p></code></pre></p>

<strong>What Happens</strong>:
<ul><li>Pool checked for available context</li>
<li>If found → reused (zero allocation)</li>
<li>If empty → new context created (rare)</li>
<li>Context initialized with message data</li>
</ul>
<h3>2. Initialize</h3>

<pre><code class="language-csharp">context.Initialize(message, envelope, services, environment);
<p></code></pre></p>

<strong>What's Set</strong>:
<ul><li><code>Message</code> = message object</li>
<li><code>MessageType</code> = message.GetType()</li>
<li><code>Envelope</code> = envelope with metadata</li>
<li><code>Services</code> = DI container</li>
<li><code>Environment</code> = "production"</li>
<li><code>ExecutionTime</code> = DateTimeOffset.UtcNow</li>
<li><code>Trail</code> = new PolicyDecisionTrail()</li>
</ul>
<h3>3. Use</h3>

<pre><code class="language-csharp">var config = await policyEngine.MatchAsync(context);
<p>var aggregateId = context.GetAggregateId();</p>
<p>var service = context.GetService<IOrderRepository>();</p>
<p></code></pre></p>

<strong>Available Operations</strong>:
<ul><li>Policy evaluation</li>
<li>Aggregate ID extraction (zero reflection)</li>
<li>Service resolution</li>
<li>Metadata access</li>
<li>Tag/flag checking</li>
</ul>
<h3>4. Reset</h3>

<pre><code class="language-csharp">context.Reset();
<p></code></pre></p>

<strong>What's Cleared</strong>:
<ul><li><code>Message</code> = null (release reference)</li>
<li><code>MessageType</code> = null</li>
<li><code>Envelope</code> = null (prevent memory leak)</li>
<li><code>Services</code> = null</li>
<li><code>Environment</code> = "development" (default)</li>
<li><code>Trail</code> = new PolicyDecisionTrail() (clear decisions)</li>
</ul>
<strong>Why Reset?</strong> Prevents holding references to disposed objects (memory leaks).

<h3>5. Return</h3>

<pre><code class="language-csharp">PolicyContextPool.Return(context);
<p></code></pre></p>

<strong>What Happens</strong>:
<ul><li>Context reset (step 4)</li>
<li>If pool < 1,024 → added to pool</li>
<li>If pool >= 1,024 → discarded, GC'd</li>
</ul>
<hr>

<h2>Performance Characteristics</h2>

<h3>Allocation Benchmarks</h3>

<p>| Scenario | Without Pooling | With Pooling | Improvement |</p>
<p>|----------|----------------|--------------|-------------|</p>
<p>| <strong>1M Messages</strong> | 160MB allocated | ~160KB allocated | <strong>1000x reduction</strong> |</p>
<p>| <strong>Gen 0 Collections</strong> | ~200 | ~2 | <strong>100x fewer</strong> |</p>
<p>| <strong>Gen 1 Collections</strong> | ~20 | ~0 | <strong>Eliminated</strong> |</p>
<p>| <strong>Gen 2 Collections</strong> | ~2 | ~0 | <strong>Eliminated</strong> |</p>
<p>| <strong>Throughput</strong> | 50K msg/sec | 150K msg/sec | <strong>3x faster</strong> |</p>

<h3>Latency Impact</h3>

<p>| Operation | Without Pooling | With Pooling | Improvement |</p>
<p>|-----------|----------------|--------------|-------------|</p>
<p>| <strong>Context Creation</strong> | ~500ns (alloc + init) | ~50ns (reuse) | <strong>10x faster</strong> |</p>
<p>| <strong>GC Pause</strong> | ~10-50ms | ~1-5ms | <strong>10x shorter</strong> |</p>
<p>| <strong>99th Percentile</strong> | ~15ms | ~2ms | <strong>7.5x better</strong> |</p>

<h3>Memory Usage</h3>

<pre><code class="language-">Pool Size: 1,024 contexts
<p>Context Size: ~160 bytes</p>
<p>Total Pool Memory: ~160KB (negligible)</p>

<p>Peak Pool Memory: 1,024 × 160 bytes = ~160KB</p>
<p>Heap Savings: 1M × 160 bytes - 160KB = 159.84MB saved</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Always return in finally block</strong> - Prevents pool depletion</li>
<li>✅ <strong>Use pooling for high-throughput scenarios</strong> - 10K+ msg/sec</li>
<li>✅ <strong>Reset before return</strong> - Prevent memory leaks</li>
<li>✅ <strong>Monitor pool size</strong> - Track <code>_poolSize</code> in metrics</li>
<li>✅ <strong>Use IDisposable wrapper</strong> for automatic return</li>
<li>✅ <strong>Profile before optimizing</strong> - Measure allocations first</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Hold context references after return (use-after-return bug)</li>
<li>❌ Return context twice (double-free bug)</li>
<li>❌ Skip returning contexts (pool depletion)</li>
<li>❌ Pool large objects (> 1KB) - GC is fine for large objects</li>
<li>❌ Use pooling for infrequent operations (< 100 msg/sec)</li>
<li>❌ Forget to reset before return (memory leaks)</li>
</ul>
<hr>

<h2>Advanced Patterns</h2>

<h3>Custom Pool Size</h3>

<pre><code class="language-csharp">// For very high throughput (100K+ msg/sec), increase max size
<p>private const int MaxPoolSize = 4096;  // 4x default</p>

<p>// For memory-constrained environments, decrease</p>
<p>private const int MaxPoolSize = 256;  // 1/4 default</p>
<p></code></pre></p>

<strong>Guideline</strong>: Set <code>MaxPoolSize</code> to 2x concurrent message processing capacity.

<h3>Pool Monitoring</h3>

<pre><code class="language-csharp">public static class PolicyContextPool {
<p>  // Metrics for monitoring</p>
<p>  private static long _totalRented = 0;</p>
<p>  private static long _totalReturned = 0;</p>
<p>  private static long _totalAllocated = 0;  // Rent when pool empty</p>

<p>  public static PolicyContext Rent(...) {</p>
<p>    Interlocked.Increment(ref _totalRented);</p>

<p>    if (_pool.TryTake(out var context)) {</p>
<p>      // Reused from pool</p>
<p>    } else {</p>
<p>      // Pool empty - allocate new</p>
<p>      Interlocked.Increment(ref _totalAllocated);</p>
<p>      context = new PolicyContext();</p>
<p>    }</p>

<p>    // ...</p>
<p>  }</p>

<p>  public static void Return(PolicyContext? context) {</p>
<p>    if (context is null) return;</p>
<p>    Interlocked.Increment(ref _totalReturned);</p>
<p>    // ...</p>
<p>  }</p>

<p>  // Metrics endpoints</p>
<p>  public static int GetPoolSize() => _poolSize;</p>
<p>  public static long GetTotalRented() => _totalRented;</p>
<p>  public static long GetTotalReturned() => _totalReturned;</p>
<p>  public static long GetTotalAllocated() => _totalAllocated;</p>
<p>  public static double GetHitRate() =></p>
<p>    _totalRented > 0 ? (double)(_totalRented - _totalAllocated) / _totalRented : 0;</p>
<p>}</p>
<p></code></pre></p>

<strong>Monitoring</strong>:
<ul><li><strong>Pool Size</strong>: Should stabilize near max concurrent processing</li>
<li><strong>Hit Rate</strong>: Should be > 99% (reusing from pool)</li>
<li><strong>Allocations</strong>: Should plateau after warmup</li>
</ul>
<h3>Pre-Warming Pool</h3>

<pre><code class="language-csharp">// Warm pool on application startup
<p>public static class PolicyContextPool {</p>
<p>  public static void WarmPool(int targetSize = MaxPoolSize) {</p>
<p>    for (int i = 0; i < targetSize; i++) {</p>
<p>      var context = new PolicyContext();</p>
<p>      context.Reset();</p>
<p>      _pool.Add(context);</p>
<p>      Interlocked.Increment(ref _poolSize);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>

<p>// Usage in Startup</p>
<p>public class Program {</p>
<p>  public static void Main(string[] args) {</p>
<p>    // Warm pool before accepting traffic</p>
<p>    PolicyContextPool.WarmPool(targetSize: 1024);</p>

<p>    var app = WebApplication.Create(args);</p>
<p>    app.Run();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefit</strong>: Eliminates allocations during first 1,024 messages (faster startup).

<hr>

<h2>Troubleshooting</h2>

<h3>Problem: Pool Never Reuses Contexts</h3>

<strong>Symptoms</strong>: <code>GetHitRate()</code> returns 0%, all messages allocate new contexts.

<strong>Causes</strong>:
<ul><li>Contexts not returned to pool</li>
<li>Returned contexts not added (pool full on every return)</li>
<li>Pool cleared between rent/return</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-csharp">// 1. Verify return in finally
<p>try {</p>
<p>  var context = PolicyContextPool.Rent(...);</p>
<p>  // Use context</p>
<p>} finally {</p>
<p>  PolicyContextPool.Return(context);  // ⭐ Must execute</p>
<p>}</p>

<p>// 2. Check pool size metrics</p>
<p>var poolSize = PolicyContextPool.GetPoolSize();</p>
<p>var returned = PolicyContextPool.GetTotalReturned();</p>
<p>var rented = PolicyContextPool.GetTotalRented();</p>

<p>Console.WriteLine($"Pool Size: {poolSize}, Returned: {returned}, Rented: {rented}");</p>

<p>// Expected: returned ≈ rented, poolSize > 0</p>
<p></code></pre></p>

<h3>Problem: Memory Leak Despite Pooling</h3>

<strong>Symptoms</strong>: Heap grows over time even with pooling.

<strong>Cause</strong>: Context references not cleared in <code>Reset()</code>.

<strong>Solution</strong>:
<pre><code class="language-csharp">// Verify Reset() clears ALL references
<p>internal void Reset() {</p>
<p>  Message = null!;          // ⭐ Clear</p>
<p>  MessageType = null!;      // ⭐ Clear</p>
<p>  Envelope = null;          // ⭐ Clear (prevent leak)</p>
<p>  Services = null;          // ⭐ Clear (prevent leak)</p>
<p>  Environment = "development";</p>
<p>  Trail = new PolicyDecisionTrail();  // New instance</p>
<p>}</p>

<p>// Verify no lingering references</p>
<p>context.Reset();</p>
<p>Assert.That(context.Envelope).IsNull();</p>
<p>Assert.That(context.Services).IsNull();</p>
<p></code></pre></p>

<h3>Problem: Pool Depletion Under Load</h3>

<strong>Symptoms</strong>: <code>GetPoolSize()</code> drops to 0 under high load, allocations spike.

<strong>Causes</strong>:
<ul><li>Contexts not returned (leaked)</li>
<li>Max pool size too small</li>
<li>Concurrent processing exceeds pool capacity</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-csharp">// 1. Audit return paths
<p>public async Task HandleAsync(message) {</p>
<p>  var context = PolicyContextPool.Rent(...);</p>
<p>  try {</p>
<p>    await ProcessAsync(message, context);</p>
<p>  } catch {</p>
<p>    // Exception path - still return</p>
<p>    throw;</p>
<p>  } finally {</p>
<p>    PolicyContextPool.Return(context);  // ⭐ All paths return</p>
<p>  }</p>
<p>}</p>

<p>// 2. Increase max pool size</p>
<p>private const int MaxPoolSize = 4096;  // 4x concurrent capacity</p>

<p>// 3. Monitor concurrent usage</p>
<p>var concurrentMessages = GetConcurrentMessageCount();</p>
<p>var poolSize = PolicyContextPool.GetPoolSize();</p>

<p>if (concurrentMessages > poolSize) {</p>
<p>  // Pool too small - increase MaxPoolSize</p>
<p>  Console.WriteLine($"WARNING: Pool depleted - {concurrentMessages} concurrent > {poolSize} pool size");</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Infrastructure</strong>:
<ul><li><a href="policies.md">Policies</a> - PolicyContext usage in policy evaluation</li>
<li><a href="health-checks.md">Health Checks</a> - Monitoring pool health</li>
</ul>
<strong>Performance</strong>:
<ul><li><a href="../advanced/performance-tuning.md">Performance Tuning</a> - GC optimization strategies</li>
</ul>
<strong>External Resources</strong>:
<ul><li><a href="https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/">.NET Memory Management</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.objectpool.objectpool-1">ObjectPool<T></a></li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Lenses</h2>
<article id="v1-0-0-lenses-raw-sql" class="doc-section">
  <h3>raw sql</h3>
  <p class="doc-path"><code>v1.0.0/lenses/raw-sql</code></p>
  <div class="doc-content">
<h1>Raw SQL and Connection Access</h1>

<p>For advanced scenarios where LINQ extensions are insufficient, Whizbang provides escape hatches for raw SQL execution and direct database connection access.</p>

<h2>When to Use Raw SQL</h2>

<ul><li>Complex queries not expressible in LINQ</li>
<li>Stored procedure execution</li>
<li>Database-specific features (PostgreSQL-specific functions, etc.)</li>
<li>Bulk operations via native drivers (e.g., Npgsql binary import)</li>
<li>Materialized view refresh</li>
</ul>
<strong>Prefer LINQ when possible.</strong> Raw SQL bypasses EF Core's change tracking and may be harder to maintain.

<h2>ExecuteSqlAsync</h2>

<p>Execute parameterized SQL queries with typed results:</p>

<pre><code class="language-csharp">var category = "electronics";
<p>var limit = 10;</p>

<p>var products = await lensQuery.ExecuteSqlAsync<Product, ProductSummary>(</p>
<p>    $"SELECT id, name, price FROM products WHERE category = {category} LIMIT {limit}");</p>
<p></code></pre></p>

<h3>SQL Injection Protection</h3>

<p>The <code>FormattableString</code> parameter ensures parameters are properly escaped:</p>

<pre><code class="language-csharp">// SAFE: Parameters are extracted and passed separately
<p>var results = await lensQuery.ExecuteSqlAsync<Order, OrderSummary>(</p>
<p>    $"SELECT id, total FROM orders WHERE status = {status}");</p>

<p>// The {status} becomes a SQL parameter (@p0), NOT string concatenation</p>
<p>// Generated SQL: SELECT id, total FROM orders WHERE status = @p0</p>
<p></code></pre></p>

<h2>Direct Connection Access</h2>

<h3>GetConnection (Synchronous)</h3>

<p>Get the underlying connection without opening:</p>

<pre><code class="language-csharp">var connection = lensQuery.GetConnection<Order>();

<p>// Use for synchronous operations</p>
<p>using var command = connection.CreateCommand();</p>
<p>command.CommandText = "SELECT version()";</p>
<p>var version = command.ExecuteScalar();</p>
<p></code></pre></p>

<h3>GetConnectionAsync (Asynchronous)</h3>

<p>Get the connection and ensure it's open:</p>

<pre><code class="language-csharp">await using var connection = await lensQuery.GetConnectionAsync<Order>();

<p>await using var command = connection.CreateCommand();</p>
<p>command.CommandText = "CALL refresh_materialized_view('product_stats')";</p>
<p>await command.ExecuteNonQueryAsync();</p>
<p></code></pre></p>

<h2>Use Cases</h2>

<h3>Stored Procedures</h3>

<pre><code class="language-csharp">await using var connection = await lensQuery.GetConnectionAsync<Product>();
<p>await using var command = connection.CreateCommand();</p>
<p>command.CommandText = "CALL update_inventory(@product_id, @quantity)";</p>
<p>command.Parameters.Add(new NpgsqlParameter("product_id", productId));</p>
<p>command.Parameters.Add(new NpgsqlParameter("quantity", quantity));</p>
<p>await command.ExecuteNonQueryAsync();</p>
<p></code></pre></p>

<h3>Bulk Import (Npgsql Binary COPY)</h3>

<pre><code class="language-csharp">await using var connection = await lensQuery.GetConnectionAsync<Product>();

<p>await using var writer = await ((NpgsqlConnection)connection)</p>
<p>    .BeginBinaryImportAsync("COPY products (id, name, price) FROM STDIN (FORMAT BINARY)");</p>

<p>foreach (var product in products) {</p>
<p>  await writer.StartRowAsync();</p>
<p>  await writer.WriteAsync(product.Id, NpgsqlDbType.Uuid);</p>
<p>  await writer.WriteAsync(product.Name, NpgsqlDbType.Text);</p>
<p>  await writer.WriteAsync(product.Price, NpgsqlDbType.Numeric);</p>
<p>}</p>

<p>await writer.CompleteAsync();</p>
<p></code></pre></p>

<h3>Materialized View Refresh</h3>

<pre><code class="language-csharp">await using var connection = await lensQuery.GetConnectionAsync<Analytics>();
<p>await using var command = connection.CreateCommand();</p>
<p>command.CommandText = "REFRESH MATERIALIZED VIEW CONCURRENTLY sales_summary";</p>
<p>await command.ExecuteNonQueryAsync();</p>
<p></code></pre></p>

<h3>Database-Specific Functions</h3>

<pre><code class="language-csharp">// PostgreSQL full-text search
<p>var searchResults = await lensQuery.ExecuteSqlAsync<Document, SearchResult>(</p>
<p>    $@"SELECT id, title, ts_rank(search_vector, query) AS rank</p>
<p>       FROM documents, plainto_tsquery('english', {searchTerm}) query</p>
<p>       WHERE search_vector @@ query</p>
<p>       ORDER BY rank DESC</p>
<p>       LIMIT 20");</p>
<p></code></pre></p>

<h2>Important Notes</h2>

<ul><li><strong>Connection Lifecycle</strong>: The returned connection is managed by EF Core. Do NOT dispose it manually when using <code>GetConnection</code>.</li>
</ul>
<ul><li><strong>Transaction Scope</strong>: Operations on the returned connection participate in the current EF Core transaction (if any).</li>
</ul>
<ul><li><strong>AOT Compatibility</strong>: These methods are AOT-compatible when using Npgsql's source-generated JSON serialization.</li>
</ul>
<ul><li><strong>Type Safety</strong>: <code>ExecuteSqlAsync<TModel, TResult></code> requires <code>TResult</code> to be a class with properties matching the SQL projection.</li>
</ul>
<h2>See Also</h2>

<ul><li><a href="/docs/lenses/overview">Lens Queries</a></li>
<li><a href="/docs/data/postgres">PostgreSQL Extensions</a></li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-lenses-vector-search" class="doc-section">
  <h3>vector search</h3>
  <p class="doc-path"><code>v1.0.0/lenses/vector-search</code></p>
  <div class="doc-content">
<h1>Vector Similarity Search</h1>

<p>Whizbang supports pgvector similarity queries for semantic search, embeddings, and AI/ML workloads.</p>

<h2>Turnkey Setup {#turnkey-setup}</h2>

<p>Whizbang provides a <strong>turnkey experience</strong> for pgvector. When your perspective models use <code>[VectorField]</code> attributes, the source generator automatically creates an <code>Add{YourDbContext}()</code> extension method that handles all pgvector configuration:</p>

<pre><code class="language-csharp">// Single call configures everything:
<p>// - NpgsqlDataSource with UseVector()</p>
<p>// - DbContext with UseVector()</p>
<p>// - HasPostgresExtension("vector") in OnModelCreating</p>
<p>builder.Services.AddMyAppDbContext(connectionString);</p>
<p></code></pre></p>

<h3>What Gets Configured Automatically</h3>

<p>When Whizbang detects <code>[VectorField]</code> attributes in your perspective models, the generated code:</p>

<ul><li><strong>Creates the pgvector extension</strong> - Generates <code>modelBuilder.HasPostgresExtension("vector")</code> in <code>ConfigureWhizbang()</code></li>
<li><strong>Configures NpgsqlDataSource</strong> - Calls <code>dataSourceBuilder.UseVector()</code> for Npgsql type mapping</li>
<li><strong>Configures EF Core</strong> - Calls <code>npgsqlOptions.UseVector()</code> for EF Core query translation</li>
<li><strong>Maps vector columns</strong> - Generates proper <code>HasColumnType("vector({dimensions})")</code> configuration</li>
</ul>
<h3>Customization</h3>

<p>If you need to configure the data source (e.g., for JSON options), pass a callback:</p>

<pre><code class="language-csharp">builder.Services.AddMyAppDbContext(connectionString, dataSourceBuilder => {
<p>  dataSourceBuilder.ConfigureJsonOptions(jsonOptions);</p>
<p>  dataSourceBuilder.EnableDynamicJson();</p>
<p>});</p>
<p></code></pre></p>

<p>Or configure DbContext options:</p>

<pre><code class="language-csharp">builder.Services.AddMyAppDbContext(connectionString, configureDbContext: options => {
<p>  options.EnableSensitiveDataLogging();</p>
<p>});</p>
<p></code></pre></p>

<h2>Prerequisites</h2>

<p>When using <code>[VectorField]</code> attributes on your perspective models, you must add both pgvector packages:</p>

<pre><code class="language-xml"><ItemGroup>
<p>  <!-- Base package for NpgsqlDataSourceBuilder.UseVector() --></p>
<p>  <PackageReference Include="Pgvector" Version="0.3.0" /></p>

<p>  <!-- EF Core integration for type mapping and queries --></p>
<p>  <PackageReference Include="Pgvector.EntityFrameworkCore" Version="0.3.0" /></p>
<p></ItemGroup></p>
<p></code></pre></p>

<p>If you forget these packages, compiler diagnostics will guide you:</p>

<ul><li><strong><a href="/docs/v0.1.0/diagnostics/whiz070">WHIZ070</a></strong> - Missing <code>Pgvector.EntityFrameworkCore</code> package</li>
<li><strong><a href="/docs/v0.1.0/diagnostics/whiz071">WHIZ071</a></strong> - Missing <code>Pgvector</code> package</li>
</ul>
<h2>Defining Vector Fields</h2>

<p>Add <code>[VectorField]</code> to properties in your perspective model:</p>

<pre><code class="language-csharp">public class DocumentModel {
<p>  public Guid Id { get; init; }</p>
<p>  public string Title { get; init; } = "";</p>
<p>  public string Content { get; init; } = "";</p>

<p>  [VectorField(1536)]  // OpenAI ada-002 dimensions</p>
<p>  public float[]? ContentEmbedding { get; init; }</p>

<p>  [VectorField(1536)]  // For comparison operations</p>
<p>  public float[]? SummaryEmbedding { get; init; }</p>
<p>}</p>

<p>public class UserPreferenceModel {</p>
<p>  public Guid UserId { get; init; }</p>

<p>  [VectorField(1536)]</p>
<p>  public float[]? PreferenceEmbedding { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<p>The generator creates pgvector shadow properties with appropriate indexes.</p>

<h2>Usage Patterns</h2>

<p>All methods use <strong>strongly-typed lambda selectors</strong> for compile-time safety.</p>

<h3>Pattern 1: App-Side Vector (Search Query)</h3>

<p>Use when the search vector comes from your application (e.g., embedding a user's search query):</p>

<pre><code class="language-csharp">// Get embedding from your embedding service (OpenAI, etc.)
<p>var searchEmbedding = await embeddingService.EmbedAsync(userSearchQuery);</p>

<p>// Find documents similar to the search query</p>
<p>var results = await documentLens.Query</p>
<p>    .OrderByCosineDistance(m => m.ContentEmbedding, searchEmbedding)</p>
<p>    .Take(10)</p>
<p>    .ToListAsync();</p>
<p></code></pre></p>

<strong>SQL Generated:</strong>
<pre><code class="language-sql">SELECT * FROM documents
<p>ORDER BY content_embedding <=> @p0 ASC</p>
<p>LIMIT 10</p>
<p></code></pre></p>

<h3>Pattern 2: Same-Table Column Comparison</h3>

<p>Use when comparing two vector columns on the same row (100% SQL, no vector data round-trip):</p>

<pre><code class="language-csharp">// Find documents where content differs significantly from summary
<p>// (potential quality issue - summary doesn't match content)</p>
<p>var mismatchedDocs = await documentLens.Query</p>
<p>    .Where(m => m.ContentEmbedding != null && m.SummaryEmbedding != null)</p>
<p>    .OrderByCosineDistance(m => m.ContentEmbedding, m => m.SummaryEmbedding)</p>
<p>    .ThenByDescending(m => m.Data.CreatedAt)  // Most different first, then newest</p>
<p>    .Take(20)</p>
<p>    .ToListAsync();</p>

<p>// Find documents where content and summary are similar (well-summarized)</p>
<p>var wellSummarized = await documentLens.Query</p>
<p>    .WithinCosineDistance(m => m.ContentEmbedding, m => m.SummaryEmbedding, threshold: 0.2)</p>
<p>    .ToListAsync();</p>
<p></code></pre></p>

<strong>SQL Generated:</strong>
<pre><code class="language-sql">-- No vector data sent to/from C# - all computed in PostgreSQL!
<p>SELECT * FROM documents</p>
<p>WHERE content_embedding IS NOT NULL AND summary_embedding IS NOT NULL</p>
<p>ORDER BY content_embedding <=> summary_embedding ASC</p>
<p>LIMIT 20</p>
<p></code></pre></p>

<h3>Pattern 3: Cross-Table Comparison (Joins)</h3>

<p>Use when comparing vectors from different tables:</p>

<pre><code class="language-csharp">// Find documents that match a user's preferences
<p>var userId = currentUserId;</p>

<p>var recommendations = await documentLens.Query</p>
<p>    .SelectMany(</p>
<p>        doc => userPreferenceLens.Query.Where(up => up.Data.UserId == userId),</p>
<p>        (doc, pref) => new { Document = doc, Preference = pref })</p>
<p>    .OrderByCosineDistance(</p>
<p>        x => x.Document.Data.ContentEmbedding,    // From documents table</p>
<p>        x => x.Preference.Data.PreferenceEmbedding)  // From user_preferences table</p>
<p>    .Select(x => x.Document)</p>
<p>    .Take(10)</p>
<p>    .ToListAsync();</p>
<p></code></pre></p>

<strong>SQL Generated:</strong>
<pre><code class="language-sql">SELECT d.* FROM documents d
<p>JOIN user_preferences up ON up.user_id = @userId</p>
<p>ORDER BY d.content_embedding <=> up.preference_embedding ASC</p>
<p>LIMIT 10</p>
<p></code></pre></p>

<h3>Pattern 4: Filtering by Distance Threshold</h3>

<p>Use when you only want results within a certain similarity range:</p>

<pre><code class="language-csharp">var searchEmbedding = await embeddingService.EmbedAsync(userQuery);

<p>// Only return documents with cosine distance < 0.3 (very similar)</p>
<p>var closeMatches = await documentLens.Query</p>
<p>    .WithinCosineDistance(m => m.ContentEmbedding, searchEmbedding, threshold: 0.3)</p>
<p>    .OrderByCosineDistance(m => m.ContentEmbedding, searchEmbedding)</p>
<p>    .ToListAsync();</p>
<p></code></pre></p>

<strong>SQL Generated:</strong>
<pre><code class="language-sql">SELECT * FROM documents
<p>WHERE content_embedding <=> @p0 < 0.3</p>
<p>ORDER BY content_embedding <=> @p0 ASC</p>
<p></code></pre></p>

<h3>Pattern 5: Combined Filter + Sort + Project</h3>

<p>Use when you need distance/similarity scores in your results:</p>

<p>:::updated</p>
<strong>Important</strong>: <code>WithCosineDistance</code> must be used as the <strong>final projection</strong> before <code>ToListAsync()</code>.
<p>You cannot chain <code>.OrderBy(r => r.Distance)</code> or <code>.Where(r => r.Distance < x)</code> after it - use</p>
<code>OrderByCosineDistance</code> and <code>WithinCosineDistance</code> for SQL-side operations first.
<p>:::</p>

<pre><code class="language-csharp">var searchEmbedding = await embeddingService.EmbedAsync(userQuery);

<p>// Filter -> Sort -> Project with scores</p>
<p>var results = await documentLens.Query</p>
<p>    .WithinCosineDistance(m => m.ContentEmbedding, searchEmbedding, threshold: 0.5)</p>
<p>    .OrderByCosineDistance(m => m.ContentEmbedding, searchEmbedding)</p>
<p>    .WithCosineDistance(m => m.ContentEmbedding, searchEmbedding)</p>
<p>    .Take(10)</p>
<p>    .ToListAsync();</p>

<p>foreach (var result in results) {</p>
<p>  Console.WriteLine($"{result.Row.Data.Title}: {result.Similarity:P0} match");</p>
<p>  // Output: "My Document: 95% match"</p>
<p>}</p>
<p></code></pre></p>

<p>Returns <code>VectorSearchResult<TModel></code> with:</p>
<ul><li><code>Row</code> - The perspective row</li>
<li><code>Distance</code> - Cosine distance (0 = identical, 2 = opposite)</li>
<li><code>Similarity</code> - Similarity score (1 = identical, -1 = opposite)</li>
</ul>
<h2>Query Extension Reference</h2>

<h3>Ordering Methods</h3>

<p>| Method | PostgreSQL Operator | Use Case |</p>
<p>|--------|---------------------|----------|</p>
<p>| <code>OrderByCosineDistance</code> | <code><=></code> | Semantic similarity (normalized vectors) |</p>
<p>| <code>OrderByL2Distance</code> | <code><-></code> | Euclidean distance (spatial data) |</p>
<p>| <code>OrderByInnerProductDistance</code> | <code><#></code> | Dot product (normalized vectors) |</p>

<h3>Filtering Methods</h3>

<p>| Method | PostgreSQL | Use Case |</p>
<p>|--------|------------|----------|</p>
<p>| <code>WithinCosineDistance</code> | <code><=> < threshold</code> | Filter by cosine similarity |</p>
<p>| <code>WithinL2Distance</code> | <code><-> < threshold</code> | Filter by Euclidean distance |</p>

<h3>Projection Methods</h3>

<p>| Method | Returns | Use Case |</p>
<p>|--------|---------|----------|</p>
<p>| <code>WithCosineDistance</code> | <code>VectorSearchResult<T></code> | Get distance/similarity scores |</p>

<h2>Distance Calculators</h2>

<p>For testing or manual calculations, use the static helper methods:</p>

<pre><code class="language-csharp">double cosine = VectorSearchExtensions.CalculateCosineDistance(vectorA, vectorB);
<p>double l2 = VectorSearchExtensions.CalculateL2Distance(vectorA, vectorB);</p>
<p>double innerProduct = VectorSearchExtensions.CalculateInnerProductDistance(vectorA, vectorB);</p>
<p></code></pre></p>

<h2>Complete Example: Semantic Search with Ranking</h2>

<pre><code class="language-csharp">public class SearchService {
<p>  private readonly ILensQueryFactory<DocumentModel> _documentLens;</p>
<p>  private readonly IEmbeddingService _embeddingService;</p>

<p>  public async Task<List<SearchResult>> SearchAsync(string query, int limit = 10) {</p>
<p>    // 1. Embed the user's search query</p>
<p>    var queryEmbedding = await _embeddingService.EmbedAsync(query);</p>

<p>    // 2. Find similar documents with scores</p>
<p>    var results = await _documentLens.Query</p>
<p>        .WithinCosineDistance(m => m.ContentEmbedding, queryEmbedding, threshold: 0.5)</p>
<p>        .OrderByCosineDistance(m => m.ContentEmbedding, queryEmbedding)</p>
<p>        .WithCosineDistance(m => m.ContentEmbedding, queryEmbedding)</p>
<p>        .Take(limit)</p>
<p>        .ToListAsync();</p>

<p>    // 3. Map to search results</p>
<p>    return results.Select(r => new SearchResult {</p>
<p>      Id = r.Row.Data.Id,</p>
<p>      Title = r.Row.Data.Title,</p>
<p>      Snippet = r.Row.Data.Content[..200],</p>
<p>      RelevanceScore = r.Similarity</p>
<p>    }).ToList();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Manual Configuration {#manual-configuration}</h2>

<p>If you prefer manual configuration over the turnkey approach, you can set up pgvector yourself:</p>

<pre><code class="language-csharp">// 1. Create data source with UseVector()
<p>var dataSourceBuilder = new NpgsqlDataSourceBuilder(connectionString);</p>
<p>dataSourceBuilder.UseVector();</p>
<p>var dataSource = dataSourceBuilder.Build();</p>
<p>builder.Services.AddSingleton(dataSource);</p>

<p>// 2. Add DbContext with UseVector()</p>
<p>builder.Services.AddDbContext<MyAppDbContext>(options => {</p>
<p>  options.UseNpgsql(dataSource, npgsqlOptions => {</p>
<p>    npgsqlOptions.UseVector();</p>
<p>  });</p>
<p>});</p>

<p>// 3. Configure Whizbang normally</p>
<p>builder.Services</p>
<p>  .AddWhizbang()</p>
<p>  .WithEFCore<MyAppDbContext>()</p>
<p>  .WithDriver.Postgres;</p>
<p></code></pre></p>

<p>Note: The generated <code>ConfigureWhizbang()</code> method automatically includes <code>HasPostgresExtension("vector")</code> when <code>[VectorField]</code> attributes are detected, so you don't need to add that manually.</p>

<h2>See Also</h2>

<ul><li><a href="/docs/perspectives/overview">Perspective Models</a></li>
<li><a href="/api/VectorFieldAttribute">VectorFieldAttribute Reference</a></li>
<li><a href="/docs/v0.1.0/diagnostics/whiz070">WHIZ070: Missing Pgvector.EntityFrameworkCore</a></li>
<li><a href="/docs/v0.1.0/diagnostics/whiz071">WHIZ071: Missing Pgvector Package</a></li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Messaging</h2>
<article id="v1-0-0-messaging-commands-events" class="doc-section">
  <h3>commands events</h3>
  <p class="doc-path"><code>v1.0.0/messaging/commands-events</code></p>
  <div class="doc-content">
<h1>Commands and Events</h1>

<p>Commands and Events are the core message types in Whizbang, representing intent (commands) and facts (events) in your domain.</p>

<h2>Overview</h2>

<p>Whizbang uses marker interfaces to distinguish between different message types:</p>

<ul><li><strong>Commands</strong>: Represent intent or requests for action (e.g., <code>CreateOrder</code>, <code>CancelOrder</code>)</li>
<li><strong>Events</strong>: Represent facts or things that have happened (e.g., <code>OrderCreated</code>, <code>OrderCancelled</code>)</li>
</ul>
<p>Both commands and events are wrapped in <a href="message-envelopes.md">Message Envelopes</a> for routing, tracing, and metadata.</p>

<h2>ICommand Interface</h2>

<p>Commands express <strong>intent</strong> - a request to perform an action in the system.</p>

<h3>Characteristics</h3>

<ul><li><strong>Imperative naming</strong>: <code>CreateOrder</code>, <code>UpdateInventory</code>, <code>ProcessPayment</code></li>
<li><strong>Single handler</strong>: Typically processed by exactly one receptor</li>
<li><strong>Can fail</strong>: Commands can be rejected due to business rules or validation</li>
<li><strong>Idempotent</strong>: Should be safe to retry</li>
<li><strong>Authorization</strong>: May require permissions or policies</li>
</ul>
<h3>Definition</h3>

<pre><code class="language-csharp">/// <summary>
<p>/// Marker interface for command messages</p>
<p>/// </summary></p>
<p>/// <docs>messaging/commands-events</docs></p>
<p>public interface ICommand {</p>
<p>  // Marker interface - no members</p>
<p>}</p>
<p></code></pre></p>

<h3>Example Commands</h3>

<pre><code class="language-csharp">public record CreateOrder : ICommand {
<p>  public required string CustomerId { get; init; }</p>
<p>  public required OrderItem[] Items { get; init; }</p>
<p>  public string? CouponCode { get; init; }</p>
<p>}</p>

<p>public record CancelOrder : ICommand {</p>
<p>  public required Guid OrderId { get; init; }</p>
<p>  public required string Reason { get; init; }</p>
<p>}</p>

<p>public record UpdateInventory : ICommand {</p>
<p>  public required string ProductId { get; init; }</p>
<p>  public required int QuantityChange { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h3>Naming Conventions</h3>

<strong>Commands use imperative verbs</strong>:
<ul><li>✅ <code>CreateOrder</code>, <code>UpdateProfile</code>, <code>ProcessPayment</code></li>
<li>❌ <code>OrderCreation</code>, <code>ProfileUpdate</code>, <code>PaymentProcessing</code></li>
</ul>
<strong>Commands are specific</strong>:
<ul><li>✅ <code>ApproveOrder</code>, <code>RejectOrder</code>, <code>CancelOrder</code></li>
<li>❌ <code>ModifyOrder</code>, <code>ChangeOrder</code>, <code>UpdateOrder</code> (too generic)</li>
</ul>
<h2>IEvent Interface</h2>

<p>Events represent <strong>facts</strong> - things that have already happened in the system.</p>

<h3>Characteristics</h3>

<ul><li><strong>Past tense naming</strong>: <code>OrderCreated</code>, <code>PaymentProcessed</code>, <code>InventoryUpdated</code></li>
<li><strong>Multiple handlers</strong>: Can be processed by many receptors and perspectives</li>
<li><strong>Cannot fail</strong>: Events are facts - you can't "reject" something that already happened</li>
<li><strong>Immutable</strong>: Events should never be modified after creation</li>
<li><strong>Source of truth</strong>: Events drive perspectives (read models) and analytics</li>
</ul>
<h3>Definition</h3>

<pre><code class="language-csharp">/// <summary>
<p>/// Marker interface for event messages</p>
<p>/// </summary></p>
<p>/// <docs>messaging/commands-events</docs></p>
<p>public interface IEvent {</p>
<p>  // Marker interface - no members</p>
<p>}</p>
<p></code></pre></p>

<h3>Example Events</h3>

<pre><code class="language-csharp">public record OrderCreated : IEvent {
<p>  public required Guid OrderId { get; init; }</p>
<p>  public required string CustomerId { get; init; }</p>
<p>  public required OrderItem[] Items { get; init; }</p>
<p>  public required decimal TotalAmount { get; init; }</p>
<p>  public required DateTimeOffset CreatedAt { get; init; }</p>
<p>}</p>

<p>public record OrderCancelled : IEvent {</p>
<p>  public required Guid OrderId { get; init; }</p>
<p>  public required string Reason { get; init; }</p>
<p>  public required DateTimeOffset CancelledAt { get; init; }</p>
<p>}</p>

<p>public record InventoryUpdated : IEvent {</p>
<p>  public required string ProductId { get; init; }</p>
<p>  public required int OldQuantity { get; init; }</p>
<p>  public required int NewQuantity { get; init; }</p>
<p>  public required DateTimeOffset UpdatedAt { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h3>Naming Conventions</h3>

<strong>Events use past tense</strong>:
<ul><li>✅ <code>OrderCreated</code>, <code>PaymentProcessed</code>, <code>InventoryReserved</code></li>
<li>❌ <code>CreateOrder</code>, <code>ProcessPayment</code>, <code>ReserveInventory</code></li>
</ul>
<strong>Events capture state changes</strong>:
<ul><li>✅ <code>ProductPriceChanged</code> (includes old and new price)</li>
<li>✅ <code>OrderStatusChanged</code> (includes old and new status)</li>
<li>❌ <code>ProductUpdated</code> (too generic, doesn't capture what changed)</li>
</ul>
<h2>Command → Event Flow</h2>

<p>Commands trigger business logic that results in events:</p>

<pre><code class="language-csharp">// Command: Request to create an order
<p>public record CreateOrder : ICommand {</p>
<p>  public required string CustomerId { get; init; }</p>
<p>  public required OrderItem[] Items { get; init; }</p>
<p>}</p>

<p>// Event: Order was created successfully</p>
<p>public record OrderCreated : IEvent {</p>
<p>  public required Guid OrderId { get; init; }</p>
<p>  public required string CustomerId { get; init; }</p>
<p>  public required OrderItem[] Items { get; init; }</p>
<p>  public required decimal TotalAmount { get; init; }</p>
<p>  public required DateTimeOffset CreatedAt { get; init; }</p>
<p>}</p>

<p>// Receptor: Handles command, produces event</p>
<p>public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>  public async Task<OrderCreated> HandleAsync(</p>
<p>    CreateOrder command,</p>
<p>    IMessageContext context,</p>
<p>    CancellationToken cancellationToken = default</p>
<p>  ) {</p>
<p>    // Validate business rules</p>
<p>    if (command.Items.Length == 0) {</p>
<p>      throw new InvalidOperationException("Order must contain at least one item");</p>
<p>    }</p>

<p>    // Create order</p>
<p>    var orderId = Guid.CreateVersion7();</p>
<p>    var totalAmount = command.Items.Sum(i => i.Price * i.Quantity);</p>

<p>    // Return event (fact)</p>
<p>    return new OrderCreated {</p>
<p>      OrderId = orderId,</p>
<p>      CustomerId = command.CustomerId,</p>
<p>      Items = command.Items,</p>
<p>      TotalAmount = totalAmount,</p>
<p>      CreatedAt = DateTimeOffset.UtcNow</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Message Envelopes</h2>

<p>Both commands and events are wrapped in <code>MessageEnvelope<T></code> for routing and tracing:</p>

<pre><code class="language-csharp">// Dispatch a command
<p>var createOrder = new CreateOrder {</p>
<p>  CustomerId = "cust-123",</p>
<p>  Items = [</p>
<p>    new OrderItem { ProductId = "prod-456", Quantity = 2, Price = 29.99m }</p>
<p>  ]</p>
<p>};</p>

<p>var result = await dispatcher.DispatchAsync<CreateOrder, OrderCreated>(createOrder);</p>

<p>// The envelope provides:</p>
<p>// - MessageId (UUIDv7)</p>
<p>// - CorrelationId (for distributed tracing)</p>
<p>// - CausationId (parent message)</p>
<p>// - Hops (routing and metadata)</p>
<p>// - SecurityContext (user, tenant)</p>
<p>// - PolicyDecisionTrail (authorization audit)</p>
<p></code></pre></p>

<p>See <a href="message-envelopes.md">Message Envelopes</a> for details.</p>

<h2>Event Sourcing</h2>

<p>Events are the source of truth in event-sourced systems:</p>

<pre><code class="language-csharp">// Event store tracks all events for an aggregate
<p>public class Order {</p>
<p>  public Guid Id { get; private set; }</p>
<p>  public List<IEvent> Events { get; } = new();</p>

<p>  public void Apply(OrderCreated e) {</p>
<p>    Id = e.OrderId;</p>
<p>    // ... update state</p>
<p>  }</p>

<p>  public void Apply(OrderCancelled e) {</p>
<p>    // ... update state</p>
<p>  }</p>

<p>  // Rebuild state from events</p>
<p>  public static Order FromEvents(IEnumerable<IEvent> events) {</p>
<p>    var order = new Order();</p>
<p>    foreach (var e in events) {</p>
<p>      order.Apply((dynamic)e);</p>
<p>    }</p>
<p>    return order;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<p>See <a href="../data/event-store.md">Event Store</a> for details.</p>

<h2>Perspectives (Read Models)</h2>

<p>Events drive perspectives - read models optimized for queries:</p>

<pre><code class="language-csharp">// Perspective: Order summary read model
<p>public class OrderSummaryPerspective : IPerspectiveOf<OrderSummary> {</p>
<p>  public async Task<OrderSummary> ProjectAsync(</p>
<p>    IEvent @event,</p>
<p>    OrderSummary? current,</p>
<p>    CancellationToken cancellationToken = default</p>
<p>  ) {</p>
<p>    return @event switch {</p>
<p>      OrderCreated e => new OrderSummary {</p>
<p>        OrderId = e.OrderId,</p>
<p>        CustomerId = e.CustomerId,</p>
<p>        TotalAmount = e.TotalAmount,</p>
<p>        Status = "Created",</p>
<p>        CreatedAt = e.CreatedAt</p>
<p>      },</p>
<p>      OrderCancelled e => current with {</p>
<p>        Status = "Cancelled",</p>
<p>        CancelledAt = e.CancelledAt</p>
<p>      },</p>
<p>      _ => current ?? throw new InvalidOperationException("Unknown event type")</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<p>See <a href="../core-concepts/perspectives.md">Perspectives</a> for details.</p>

<h2>Best Practices</h2>

<h3>Command Design</h3>

<strong>1. Use value objects for type safety</strong>:
<pre><code class="language-csharp">// ✅ GOOD: Type-safe value objects
<p>public record CreateOrder : ICommand {</p>
<p>  public required CustomerId CustomerId { get; init; }</p>
<p>  public required OrderItem[] Items { get; init; }</p>
<p>}</p>

<p>// ❌ BAD: Primitive obsession</p>
<p>public record CreateOrder : ICommand {</p>
<p>  public required string CustomerId { get; init; }  // What format? Validated?</p>
<p>  public required object[] Items { get; init; }      // What type?</p>
<p>}</p>
<p></code></pre></p>

<strong>2. Make commands self-contained</strong>:
<pre><code class="language-csharp">// ✅ GOOD: Everything needed to process the command
<p>public record CreateOrder : ICommand {</p>
<p>  public required string CustomerId { get; init; }</p>
<p>  public required OrderItem[] Items { get; init; }</p>
<p>  public required Address ShippingAddress { get; init; }</p>
<p>  public string? CouponCode { get; init; }</p>
<p>}</p>

<p>// ❌ BAD: Requires external lookups</p>
<p>public record CreateOrder : ICommand {</p>
<p>  public required string CustomerId { get; init; }</p>
<p>  // Missing: Items, shipping address - where do these come from?</p>
<p>}</p>
<p></code></pre></p>

<strong>3. Use records for immutability</strong>:
<pre><code class="language-csharp">// ✅ GOOD: Immutable record with init-only properties
<p>public record CreateOrder : ICommand {</p>
<p>  public required string CustomerId { get; init; }</p>
<p>  public required OrderItem[] Items { get; init; }</p>
<p>}</p>

<p>// ❌ BAD: Mutable class with setters</p>
<p>public class CreateOrder : ICommand {</p>
<p>  public string CustomerId { get; set; }  // Can be modified after creation!</p>
<p>  public OrderItem[] Items { get; set; }</p>
<p>}</p>
<p></code></pre></p>

<h3>Event Design</h3>

<strong>1. Capture all relevant state</strong>:
<pre><code class="language-csharp">// ✅ GOOD: Complete snapshot of what changed
<p>public record ProductPriceChanged : IEvent {</p>
<p>  public required string ProductId { get; init; }</p>
<p>  public required decimal OldPrice { get; init; }</p>
<p>  public required decimal NewPrice { get; init; }</p>
<p>  public required DateTimeOffset ChangedAt { get; init; }</p>
<p>  public required string ChangedBy { get; init; }</p>
<p>}</p>

<p>// ❌ BAD: Incomplete - can't reconstruct history</p>
<p>public record ProductPriceChanged : IEvent {</p>
<p>  public required string ProductId { get; init; }</p>
<p>  public required decimal NewPrice { get; init; }</p>
<p>  // Missing: old price, timestamp, who made the change</p>
<p>}</p>
<p></code></pre></p>

<strong>2. Make events immutable and serializable</strong>:
<pre><code class="language-csharp">// ✅ GOOD: All properties init-only, no methods
<p>public record OrderCreated : IEvent {</p>
<p>  public required Guid OrderId { get; init; }</p>
<p>  public required string CustomerId { get; init; }</p>
<p>  public required OrderItem[] Items { get; init; }</p>
<p>}</p>

<p>// ❌ BAD: Mutable properties, non-serializable state</p>
<p>public record OrderCreated : IEvent {</p>
<p>  public Guid OrderId { get; set; }  // Mutable!</p>
<p>  public Func<decimal> CalculateTotal { get; set; }  // Non-serializable!</p>
<p>}</p>
<p></code></pre></p>

<strong>3. Use UUIDv7 for time-ordered IDs</strong>:
<pre><code class="language-csharp">// ✅ GOOD: UUIDv7 for database-friendly, time-ordered IDs
<p>public record OrderCreated : IEvent {</p>
<p>  public required Guid OrderId { get; init; }  // Generated via Guid.CreateVersion7()</p>
<p>  public required DateTimeOffset CreatedAt { get; init; }</p>
<p>}</p>

<p>// ❌ BAD: Random GUIDs cause index fragmentation</p>
<p>public record OrderCreated : IEvent {</p>
<p>  public required Guid OrderId { get; init; }  // Guid.NewGuid() - random!</p>
<p>}</p>
<p></code></pre></p>

<h2>Related Topics</h2>

<ul><li><a href="message-envelopes.md">Message Envelopes</a> - How commands and events are wrapped for routing</li>
<li><a href="../core-concepts/receptors.md">Receptors</a> - How commands are handled</li>
<li><a href="../core-concepts/perspectives.md">Perspectives</a> - How events drive read models</li>
<li><a href="../data/event-store.md">Event Store</a> - How events are persisted</li>
<li><a href="inbox-pattern.md">Inbox Pattern</a> - Guaranteed message delivery</li>
<li><a href="outbox-pattern.md">Outbox Pattern</a> - Transactional message publishing</li>
</ul>
<h2>Summary</h2>

<ul><li><strong>Commands</strong> = Intent (imperative verbs, can fail, single handler)</li>
<li><strong>Events</strong> = Facts (past tense, cannot fail, multiple handlers)</li>
<li>Both wrapped in <strong>MessageEnvelope</strong> for routing and tracing</li>
<li>Commands handled by <strong>Receptors</strong> which produce events</li>
<li>Events drive <strong>Perspectives</strong> (read models) and analytics</li>
<li>Use <strong>records</strong> for immutability</li>
<li>Use <strong>value objects</strong> for type safety</li>
<li>Use <strong>UUIDv7</strong> for time-ordered IDs</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-messaging-failure-handling" class="doc-section">
  <h3>failure handling</h3>
  <p class="doc-path"><code>v1.0.0/messaging/failure-handling</code></p>
  <div class="doc-content">
<h1>Failure Handling</h1>

<h2>Overview</h2>

<p>Whizbang implements sophisticated failure handling mechanisms including exponential backoff retry scheduling, stream-based failure cascades, and poison message detection. This document details how failures are tracked, scheduled for retry, and how they impact stream processing.</p>

<h2>Core Concepts</h2>

<h3>Message Processing Status</h3>

<p>Messages track their processing state using bitwise flags in the <code>status</code> column:</p>

<pre><code class="language-csharp">[Flags]
<p>public enum MessageProcessingStatus {</p>
<p>    Stored = 1,         // Bit 0: Message stored in database</p>
<p>    EventStored = 2,    // Bit 1: Event persisted to event store</p>
<p>    Published = 4,      // Bit 2: Message published to transport</p>
<p>    Failed = 32768      // Bit 15: Processing failed</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Properties</strong>:
<ul><li><strong>Bitwise Flags</strong>: Multiple states can coexist (e.g., <code>Stored | Failed = 32769</code>)</li>
<li><strong>Status Progression</strong>: <code>Stored → EventStored → Published</code> (outbox)</li>
<li><strong>Failure Overlay</strong>: <code>Failed</code> flag added via bitwise OR when message fails</li>
<li><strong>Partial Completion</strong>: <code>CompletedStatus</code> tracks what was accomplished before failure</li>
</ul>
<h3>Failure Classification</h3>

<pre><code class="language-csharp">public enum MessageFailureReason {
<p>    Unknown = 99,                    // Default (not classified)</p>
<p>    TransportUnavailable = 1,        // Network/transport issues</p>
<p>    HandlerException = 2,            // Handler threw exception</p>
<p>    ValidationFailure = 3,           // Message validation failed</p>
<p>    TimeoutExceeded = 4,             // Processing timeout</p>
<p>    SerializationError = 5,          // Cannot deserialize message</p>
<p>    DependencyFailure = 6,           // External dependency unavailable</p>
<p>    PoisonMessage = 7                // Exceeded retry limit</p>
<p>}</p>
<p></code></pre></p>

<strong>Purpose</strong>:
<ul><li>Enable typed filtering (e.g., "retry only TransportUnavailable failures")</li>
<li>Support different retry strategies per failure type</li>
<li>Metrics and monitoring (failure classification dashboards)</li>
</ul>
<h3>Retry Scheduling</h3>

<strong>Exponential Backoff Formula</strong>:
<pre><code class="language-">scheduled_for = now + (base_interval * 2^attempts)

<p>Base interval: 30 seconds</p>
<p>Attempts:</p>
<ul><li>0: First attempt (no backoff)</li>
<li>1: 30s * 2^1 = 1 minute</li>
<li>2: 30s * 2^2 = 2 minutes</li>
<li>3: 30s * 2^3 = 4 minutes</li>
<li>4: 30s * 2^4 = 8 minutes</li>
<li>5: 30s * 2^5 = 16 minutes</li>
<li>...</li>
</ul><p></code></pre></p>

<h2>Failure Processing Flow {#failure-flow}</h2>

<h3>Basic Failure and Retry</h3>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant I as Instance</p>
<p>    participant DB as PostgreSQL</p>
<p>    participant H as Handler/Transport</p>

<p>    I->>DB: ProcessWorkBatchAsync()</p>
<p>    DB-->>I: WorkBatch: [M1]</p>

<p>    I->>H: Process M1</p>
<p>    H-->>I: ❌ Exception: Network timeout</p>

<p>    I->>DB: ProcessWorkBatchAsync(<br/>failures: [M1: error="Network timeout"])</p>
<p>    DB->>DB: UPDATE wh_outbox<br/>SET status = status | Failed (32768),<br/>error = "Network timeout",<br/>attempts = attempts + 1,<br/>scheduled_for = now + (30s * 2^attempts),<br/>instance_id = NULL,<br/>lease_expiry = NULL<br/>WHERE message_id = M1</p>
<p>    Note over DB: M1: attempts=1<br/>scheduled_for = now + 1 min<br/>Status: Stored | Failed (32769)</p>

<p>    Note over I: Wait 1 minute...</p>

<p>    I->>DB: ProcessWorkBatchAsync()</p>
<p>    DB->>DB: Find claimable messages:<br/>WHERE scheduled_for <= now</p>
<p>    DB-->>I: WorkBatch: [M1] (retry)</p>

<p>    I->>H: Process M1 (retry)</p>
<p>    H-->>I: ✅ Success</p>

<p>    I->>DB: ProcessWorkBatchAsync(<br/>completions: [M1: Published])</p>
<p>    DB->>DB: UPDATE status = status | Published,<br/>DELETE (outbox done when published)</p>
<p>    Note over DB: ✅ M1 processed successfully<br/>after retry</p>
<p></code></pre></p>

<h3>Retry Schedule Timeline</h3>

<pre><code class="language-">Time →
<p>0s              60s             120s            180s            240s</p>
<p>│               │               │               │               │</p>
<p>M1 ━━━━━━━━━┃ Fail (attempts=0)</p>
<p>           │</p>
<p>           ├→ scheduled_for = now + 30s * 2^1 = now + 1 min</p>
<p>           │</p>
<p>           ├──── Cannot claim (scheduled_for > now)</p>
<p>           │</p>
<p>           │               Retry #1</p>
<p>           │               ┃ Fail (attempts=1)</p>
<p>           │               │</p>
<p>           │               ├→ scheduled_for = now + 30s * 2^2 = now + 2 min</p>
<p>           │               │</p>
<p>           │               ├──── Cannot claim</p>
<p>           │               │</p>
<p>           │               │                               Retry #2</p>
<p>           │               │                               ┃ Success</p>
<p>           │               │                               │</p>
<p>           │               │                               └→ Published</p>
<p></code></pre></p>

<h2>Stream-Based Failure Cascades {#failure-cascade}</h2>

<h3>Problem: Blocking Entire Stream</h3>

<p>When message M1 in stream S fails, what happens to messages M2, M3, M4 that come after it?</p>

<strong>Options</strong>:
<ul><li><strong>Block all</strong>: M2, M3, M4 stuck until M1 succeeds (could wait forever)</li>
<li><strong>Continue</strong>: Process M2, M3, M4 anyway (violates stream ordering)</li>
<li><strong>Cascade release</strong>: Allow releasing M2, M3, M4 to unblock stream</li>
</ul>
<strong>Whizbang's Approach</strong>: Cascade release with explicit control

<h3>Status=0 Release Pattern</h3>

<strong>Mechanism</strong>: Completing a message with <code>Status = 0</code> clears its lease without changing status flags, allowing it to be reprocessed.

<pre><code class="language-csharp">// Release messages M2, M3 (let them be retried)
<p>await coordinator.ProcessWorkBatchAsync(</p>
<p>    // ...</p>
<p>    outboxCompletions: [</p>
<p>        new MessageCompletion { MessageId = message2Id, Status = 0 },  // Release</p>
<p>        new MessageCompletion { MessageId = message3Id, Status = 0 }   // Release</p>
<p>    ],</p>
<p>    outboxFailures: [</p>
<p>        new MessageFailure {</p>
<p>            MessageId = message1Id,</p>
<p>            CompletedStatus = MessageProcessingStatus.Stored,</p>
<p>            Error = "Processing failed"</p>
<p>        }</p>
<p>    ]</p>
<p>);</p>
<p></code></pre></p>

<strong>Effect</strong>:
<ul><li>M1: Marked as failed, scheduled for retry</li>
<li>M2, M3: Leases cleared (<code>instance_id = NULL</code>, <code>lease_expiry = NULL</code>)</li>
<li>M2, M3: Status unchanged (still <code>Stored</code>)</li>
<li>M2, M3: Can be reclaimed by any instance</li>
</ul>
<h3>Cascade Release Sequence Diagram</h3>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant I as Instance</p>
<p>    participant DB as PostgreSQL</p>

<p>    Note over DB: Stream S has messages M1, M2, M3<br/>(all claimed by Instance)</p>

<p>    I->>I: Process M1 → ❌ Fails</p>
<p>    I->>I: Cannot process M2, M3<br/>(depend on M1 success)</p>

<p>    I->>DB: ProcessWorkBatchAsync(<br/>failures: [M1],<br/>completions: [M2: Status=0, M3: Status=0])</p>

<p>    DB->>DB: UPDATE wh_outbox<br/>SET status = status | Failed,<br/>scheduled_for = now + 1 min,<br/>instance_id = NULL, lease_expiry = NULL<br/>WHERE message_id = M1</p>

<p>    DB->>DB: UPDATE wh_outbox<br/>SET instance_id = NULL,<br/>lease_expiry = NULL<br/>WHERE message_id IN (M2, M3)<br/>-- Status unchanged (Status | 0 = Status)</p>

<p>    Note over DB: M1: Failed, scheduled for retry<br/>M2, M3: Released, can be reclaimed</p>

<p>    Note over I: Later (next ProcessWorkBatch call)</p>

<p>    I->>DB: ProcessWorkBatchAsync()</p>
<p>    DB->>DB: Find claimable messages:<br/>M1: scheduled_for > now (blocked)<br/>M2: No earlier messages with active lease ✅<br/>M3: M2 earlier, but no lease ✅</p>
<p>    DB-->>I: WorkBatch: [M2, M3]</p>

<p>    I->>I: Process M2, M3 successfully</p>
<p>    I->>DB: ProcessWorkBatchAsync(<br/>completions: [M2: Published, M3: Published])</p>
<p>    Note over DB: ✅ M2, M3 completed<br/>M1 still scheduled for retry</p>
<p></code></pre></p>

<h3>Cascade Decision Matrix</h3>

<p>| M1 State | M2 Lease Cleared? | M2 Claimable? | Ordering Impact |</p>
<p>|---|---|---|---|</p>
<p>| Failed, scheduled | No | ❌ Blocked | M2 waits for M1 retry |</p>
<p>| Failed, scheduled | Yes (Status=0) | ✅ Can claim | Stream continues without M1 |</p>
<p>| Failed, not scheduled | Yes | ✅ Can claim | Stream continues (M1 poisoned?) |</p>
<p>| Processing (active lease) | N/A | ❌ Blocked | Normal stream ordering |</p>
<p>| Completed | N/A | ✅ Can claim | Normal progression |</p>

<h3>Use Cases for Cascade Release</h3>

<strong>1. Independent Events</strong>:
<pre><code class="language-">M1: CustomerCreated (fails due to validation)
<p>M2: CustomerAddressUpdated (can proceed without M1)</p>
<p>M3: CustomerEmailUpdated (can proceed without M1)</p>

<p>→ Release M2, M3 to continue processing</p>
<p></code></pre></p>

<strong>2. Retry Later Strategy</strong>:
<pre><code class="language-">M1: SendEmail (fails due to SMTP unavailable)
<p>M2: LogEmailSent (depends on M1)</p>
<p>M3: UpdateCustomerPreferences (independent)</p>

<p>→ Release M3, keep M2 blocked</p>
<p></code></pre></p>

<strong>3. Poison Message Handling</strong>:
<pre><code class="language-">M1: ProcessLargeFile (exceeds memory, always fails)
<p>M2, M3, M4: Other events (independent)</p>

<p>→ Mark M1 as poison (manual intervention)</p>
<p>→ Release M2, M3, M4 to continue stream</p>
<p></code></pre></p>

<h2>Poison Message Detection {#poison-messages}</h2>

<h3>What is a Poison Message?</h3>

<strong>Definition</strong>: A message that repeatedly fails processing and cannot succeed, blocking the queue.

<strong>Characteristics</strong>:
<ul><li>High retry count (e.g., <code>attempts > 10</code>)</li>
<li>Consistent failure reason (e.g., SerializationError)</li>
<li>Blocks stream processing</li>
<li>Requires manual intervention</li>
</ul>
<h3>Detection Criteria</h3>

<pre><code class="language-sql">-- Find potential poison messages
<p>SELECT message_id, destination, event_type, attempts, error,</p>
<p>       scheduled_for, created_at</p>
<p>FROM wh_outbox</p>
<p>WHERE attempts >= 10  -- High retry count</p>
<p>  AND (status & 32768) = 32768  -- Failed flag set</p>
<p>  AND scheduled_for IS NOT NULL  -- Still scheduled for retry</p>
<p>ORDER BY attempts DESC, created_at ASC;</p>
<p></code></pre></p>

<h3>Handling Strategies</h3>

<strong>1. Dead Letter Queue</strong> (recommended):
<pre><code class="language-csharp">// Move to dead letter queue after N attempts
<p>if (message.Attempts >= 10) {</p>
<p>    await MoveToDeadLetterQueueAsync(message);</p>

<p>    // Complete with Status=0 to prevent re-claiming</p>
<p>    await coordinator.ProcessWorkBatchAsync(</p>
<p>        outboxCompletions: [</p>
<p>            new MessageCompletion { MessageId = message.MessageId, Status = 0 }</p>
<p>        ]</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<strong>2. Manual Intervention</strong>:
<ul><li>Set <code>scheduled_for = NULL</code> (prevents retry)</li>
<li>Set custom <code>FailureReason = PoisonMessage</code></li>
<li>Alert operations team</li>
<li>Release downstream messages (Status=0)</li>
</ul>
<strong>3. Circuit Breaker</strong>:
<ul><li>Detect repeated failures of same type</li>
<li>Temporarily stop processing that message type</li>
<li>Alert and investigate root cause</li>
</ul>
<h2>Partial Completion Tracking {#partial-completion}</h2>

<h3>CompletedStatus Field</h3>

<p>When a message fails, it may have completed some steps before failing. The <code>CompletedStatus</code> field tracks what was accomplished.</p>

<pre><code class="language-csharp">public record MessageFailure {
<p>    public required Guid MessageId { get; init; }</p>
<p>    public required MessageProcessingStatus CompletedStatus { get; init; }</p>
<p>    public required string Error { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<strong>Example</strong>:
<pre><code class="language-csharp">// Message M1: Store to DB ✅, Store to Event Store ✅, Publish to Transport ❌
<p>await coordinator.ProcessWorkBatchAsync(</p>
<p>    outboxFailures: [</p>
<p>        new MessageFailure {</p>
<p>            MessageId = message1Id,</p>
<p>            CompletedStatus = MessageProcessingStatus.Stored | MessageProcessingStatus.EventStored,</p>
<p>            Error = "Transport unavailable"</p>
<p>        }</p>
<p>    ]</p>
<p>);</p>

<p>// Result:</p>
<p>// status = (Stored | EventStored) | (Stored | EventStored) | Failed</p>
<p>//        = Stored | EventStored | Failed</p>
<p></code></pre></p>

<h3>SQL Update Logic</h3>

<pre><code class="language-sql">UPDATE wh_outbox
<p>SET status = (status | v_failure.status_flags | 32768),  -- Add completed flags + Failed flag</p>
<p>    error = v_failure.error_message,</p>
<p>    attempts = attempts + 1,</p>
<p>    scheduled_for = now + (INTERVAL '30 seconds' * POWER(2, attempts + 1))</p>
<p>WHERE message_id = v_failure.msg_id;</p>
<p></code></pre></p>

<strong>Rationale</strong>:
<ul><li>Avoid re-executing already completed steps on retry</li>
<li>Idempotency: Bitwise OR ensures flags only add, never remove</li>
<li>Resume from failure point</li>
</ul>
<h2>Failure Metrics and Monitoring</h2>

<h3>Key Metrics to Track</h3>

<strong>1. Retry Count Distribution</strong>:
<pre><code class="language-sql">SELECT attempts, COUNT(*) as message_count
<p>FROM wh_outbox</p>
<p>WHERE (status & 32768) = 32768  -- Failed messages</p>
<p>GROUP BY attempts</p>
<p>ORDER BY attempts;</p>
<p></code></pre></p>

<strong>2. Failure Reasons</strong>:
<pre><code class="language-sql">SELECT failure_reason, COUNT(*) as count
<p>FROM wh_outbox</p>
<p>WHERE (status & 32768) = 32768</p>
<p>GROUP BY failure_reason</p>
<p>ORDER BY count DESC;</p>
<p></code></pre></p>

<strong>3. Scheduled Retry Backlog</strong>:
<pre><code class="language-sql">SELECT COUNT(*) as scheduled_count,
<p>       MIN(scheduled_for) as next_retry,</p>
<p>       MAX(scheduled_for) as latest_retry</p>
<p>FROM wh_outbox</p>
<p>WHERE scheduled_for IS NOT NULL</p>
<p>  AND scheduled_for > NOW();</p>
<p></code></pre></p>

<strong>4. Poison Message Candidates</strong>:
<pre><code class="language-sql">SELECT COUNT(*) as poison_candidates
<p>FROM wh_outbox</p>
<p>WHERE attempts >= 10</p>
<p>  AND (status & 32768) = 32768;</p>
<p></code></pre></p>

<h2>Configuration and Tuning</h2>

<h3>Retry Configuration</h3>

<strong>Base Interval</strong> (default: 30 seconds):
<ul><li>Shorter: Faster retries, higher load</li>
<li>Longer: Slower recovery, lower load</li>
<li>Recommended: 30-60 seconds</li>
</ul>
<strong>Max Attempts</strong> (application-defined):
<ul><li>Low (5-10): Quick poison message detection</li>
<li>High (20+): Aggressive retry (long outages)</li>
<li>Recommended: 10 attempts</li>
</ul>
<strong>Backoff Cap</strong> (optional):
<pre><code class="language-csharp">// Cap exponential backoff at 1 hour
<p>var backoffSeconds = Math.Min(</p>
<p>    30 * Math.Pow(2, attempts),</p>
<p>    3600  // 1 hour max</p>
<p>);</p>
<p></code></pre></p>

<h3>Stream Ordering vs. Availability</h3>

<strong>Trade-off</strong>:
<ul><li><strong>Strict Ordering</strong>: Block stream on failure (wait for M1 to succeed)</li>
<li><strong>High Availability</strong>: Release downstream messages (allow M2, M3 to proceed)</li>
</ul>
<strong>Decision Matrix</strong>:

<p>| Scenario | Strategy | Rationale |</p>
<p>|---|---|---|</p>
<p>| Financial transactions | Strict ordering | Cannot process M2 without M1 |</p>
<p>| Audit logs | Strict ordering | Preserve temporal order |</p>
<p>| Notifications | High availability | Independent messages, release OK |</p>
<p>| Analytics events | High availability | Eventually consistent, release OK |</p>

<h2>Troubleshooting</h2>

<h3>Problem: Message Stuck in Retry Loop</h3>

<strong>Symptoms</strong>:
<ul><li>Message has high <code>attempts</code> count</li>
<li><code>scheduled_for</code> keeps advancing</li>
<li>Never succeeds</li>
</ul>
<strong>Diagnostic Steps</strong>:
<ul><li>Check error message:</li>
</ul><p>   <pre><code class="language-sql">   SELECT message_id, attempts, error, scheduled_for</p>
<p>   FROM wh_outbox</p>
<p>   WHERE message_id = '<stuck_message_id>';</p>
<p>   </code></pre></p>

<ul><li>Check failure reason classification:</li>
</ul><p>   <pre><code class="language-sql">   SELECT failure_reason FROM wh_outbox WHERE message_id = '<stuck_message_id>';</p>
<p>   </code></pre></p>

<ul><li>Inspect message data:</li>
</ul><p>   <pre><code class="language-sql">   SELECT event_data FROM wh_outbox WHERE message_id = '<stuck_message_id>';</p>
<p>   </code></pre></p>

<strong>Common Causes</strong>:
<ul><li>Malformed message (SerializationError)</li>
<li>Validation failure (will never pass)</li>
<li>External dependency permanently unavailable</li>
<li>Message too large (always exceeds limits)</li>
</ul>
<strong>Solutions</strong>:
<ul><li>Move to dead letter queue</li>
<li>Fix underlying issue and reset <code>attempts = 0</code></li>
<li>Release downstream messages (Status=0 cascade)</li>
</ul>
<h3>Problem: Stream Completely Blocked</h3>

<strong>Symptoms</strong>:
<ul><li>No messages in stream are processing</li>
<li>All messages have <code>scheduled_for</code> in future</li>
<li>Backlog growing</li>
</ul>
<strong>Diagnostic Steps</strong>:
<ul><li>Find blocking message:</li>
</ul><p>   <pre><code class="language-sql">   SELECT message_id, created_at, attempts, scheduled_for</p>
<p>   FROM wh_outbox</p>
<p>   WHERE stream_id = '<blocked_stream_id>'</p>
<p>   ORDER BY created_at ASC</p>
<p>   LIMIT 1;</p>
<p>   </code></pre></p>

<ul><li>Check if it's a poison message:</li>
</ul><p>   <pre><code class="language-sql">   SELECT attempts FROM wh_outbox WHERE message_id = '<blocking_message_id>';</p>
<p>   </code></pre></p>

<strong>Solutions</strong>:
<ul><li>Release blocking message to dead letter queue</li>
<li>Reset <code>scheduled_for = NOW()</code> to trigger immediate retry</li>
<li>Cascade release downstream messages (Status=0)</li>
</ul>
<h2>Related Documentation</h2>

<ul><li><a href="work-coordination.md">Work Coordination</a> - Overview and architecture</li>
<li><a href="multi-instance-coordination.md">Multi-Instance Coordination</a> - Cross-instance scenarios</li>
<li><a href="idempotency-patterns.md">Idempotency Patterns</a> - Deduplication strategies</li>
<li><a href="outbox-pattern.md">Outbox Pattern</a> - Transactional outbox implementation</li>
<li><a href="inbox-pattern.md">Inbox Pattern</a> - Deduplication and handler invocation</li>
</ul>
<h2>Implementation</h2>

<h3>PostgreSQL Function</h3>

<p>See: <code>014_CreateProcessWorkBatchFunction.sql</code></p>

<strong>Key Sections</strong>:
<ul><li>Lines 158-195: Failure processing with exponential backoff</li>
<li>Lines 728-738 (outbox), 770-780 (inbox): Scheduled retry blocking via NOT EXISTS</li>
</ul>
<h3>C# Records</h3>

<p>See: <code>Whizbang.Core/Messaging/MessageFailure.cs</code></p>

<pre><code class="language-csharp">public record MessageFailure {
<p>    public required Guid MessageId { get; init; }</p>
<p>    public required MessageProcessingStatus CompletedStatus { get; init; }</p>
<p>    public required string Error { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h3>Integration Tests</h3>

<p>See: <code>Whizbang.Data.EFCore.Postgres.Tests/EFCoreWorkCoordinatorTests.cs</code></p>

<strong>Test Cases</strong>:
<ul><li><code>ProcessWorkBatch_FailsOutboxMessages_MarksAsFailedWithErrorAsync</code> - Basic failure</li>
<li><code>ProcessWorkBatch_StreamBasedFailureCascade_ReleasesLaterMessagesInSameStreamAsync</code> - Cascade release</li>
<li><code>ProcessWorkBatch_ScheduledRetry_BlocksLaterMessagesInStreamAsync</code> - Scheduled retry blocking</li>
<li><code>ProcessWorkBatch_ScheduledRetryExpires_UnblocksStreamAsync</code> - Time-based unblocking</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-messaging-idempotency-patterns" class="doc-section">
  <h3>idempotency patterns</h3>
  <p class="doc-path"><code>v1.0.0/messaging/idempotency-patterns</code></p>
  <div class="doc-content">
<h1>Idempotency Patterns</h1>

<h2>Overview</h2>

<p>Idempotency ensures that processing the same message multiple times produces the same result as processing it once. Whizbang implements different idempotency strategies for inbox and outbox based on their roles in the system architecture.</p>

<h2>Core Concepts</h2>

<h3>What is Idempotency?</h3>

<strong>Definition</strong>: An operation is idempotent if performing it multiple times has the same effect as performing it once.

<strong>Why It Matters</strong>:
<ul><li>Message brokers often provide at-least-once delivery (duplicates possible)</li>
<li>Network retries can cause duplicate message sends</li>
<li>Distributed systems need to handle duplicate messages gracefully</li>
</ul>
<strong>Example</strong>:
<ul><li>✅ Idempotent: <code>SET balance = 100</code> (same result whether executed 1x or 10x)</li>
<li>❌ Not Idempotent: <code>SET balance = balance + 10</code> (different result each execution)</li>
</ul>
<h3>Inbox vs. Outbox Strategies</h3>

<p>| Aspect | Inbox | Outbox |</p>
<p>|---|---|---|</p>
<p>| <strong>Deduplication</strong> | Permanent table (wh_message_deduplication) | Transactional boundary responsibility |</p>
<p>| <strong>Guarantee</strong> | Exactly-once processing | At-least-once delivery |</p>
<p>| <strong>Responsibility</strong> | Whizbang framework | Application code |</p>
<p>| <strong>Rationale</strong> | Prevents duplicate external events | Part of application transaction |</p>

<h2>Inbox Idempotency {#inbox-idempotency}</h2>

<h3>Strategy: Permanent Deduplication Table</h3>

<strong>Mechanism</strong>: The <code>wh_message_deduplication</code> table permanently tracks all inbox message IDs ever seen. Duplicate messages are rejected via <code>ON CONFLICT DO NOTHING</code>.

<h3>Database Schema</h3>

<pre><code class="language-sql">CREATE TABLE wh_message_deduplication (
<p>  message_id UUID PRIMARY KEY,</p>
<p>  first_seen_at TIMESTAMPTZ NOT NULL</p>
<p>);</p>

<p>-- Index for cleanup queries (if ever implemented)</p>
<p>CREATE INDEX idx_message_dedup_first_seen</p>
<p>  ON wh_message_deduplication(first_seen_at);</p>
<p></code></pre></p>

<strong>Characteristics</strong>:
<ul><li><strong>Permanent</strong>: Never deleted (grows over time)</li>
<li><strong>Primary Key</strong>: message_id ensures uniqueness</li>
<li><strong>First Seen</strong>: Tracks when message was first encountered</li>
<li><strong>Cleanup</strong>: Optional (could expire old entries if needed)</li>
</ul>
<h3>Processing Flow</h3>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant T as Transport<br/>(External)</p>
<p>    participant App as Application</p>
<p>    participant WC as WorkCoordinator</p>
<p>    participant DB as PostgreSQL</p>

<p>    T->>App: Deliver message M1<br/>(messageId: abc-123)</p>
<p>    App->>WC: ProcessWorkBatchAsync(<br/>newInboxMessages: [M1])</p>
<p>    WC->>DB: process_work_batch()</p>

<p>    DB->>DB: INSERT INTO wh_message_deduplication<br/>(message_id='abc-123', first_seen_at=now)<br/>ON CONFLICT (message_id) DO NOTHING<br/>RETURNING message_id</p>
<p>    Note over DB: ✅ INSERT succeeds<br/>Returns 'abc-123'</p>

<p>    DB->>DB: v_new_inbox_ids := ['abc-123']</p>
<p>    DB->>DB: INSERT INTO wh_inbox<br/>WHERE message_id IN (v_new_inbox_ids)</p>
<p>    Note over DB: Message stored in inbox</p>

<p>    DB-->>WC: WorkBatch: [M1]</p>
<p>    WC-->>App: WorkBatch: [M1]</p>

<p>    App->>App: Process M1</p>

<p>    Note over T: Network issue causes<br/>duplicate delivery</p>

<p>    T->>App: Deliver message M1 AGAIN<br/>(same messageId: abc-123)</p>
<p>    App->>WC: ProcessWorkBatchAsync(<br/>newInboxMessages: [M1])</p>
<p>    WC->>DB: process_work_batch()</p>

<p>    DB->>DB: INSERT INTO wh_message_deduplication<br/>(message_id='abc-123', first_seen_at=now)<br/>ON CONFLICT (message_id) DO NOTHING<br/>RETURNING message_id</p>
<p>    Note over DB: ❌ ON CONFLICT<br/>Returns nothing (DO NOTHING)</p>

<p>    DB->>DB: v_new_inbox_ids := [] (empty)</p>
<p>    DB->>DB: Skip INSERT INTO wh_inbox<br/>(no new message IDs)</p>

<p>    DB-->>WC: WorkBatch: [] (empty)</p>
<p>    WC-->>App: WorkBatch: [] (empty)</p>

<p>    Note over App: ✅ Duplicate prevented<br/>Exactly-once processing</p>
<p></code></pre></p>

<h3>Implementation Details</h3>

<strong>PostgreSQL Function</strong> (lines 348-404 in <code>014_CreateProcessWorkBatchFunction.sql</code>):

<pre><code class="language-sql">-- Store new inbox messages (with partition assignment and deduplication)
<p>IF jsonb_array_length(p_new_inbox_messages) > 0 THEN</p>
<p>  -- First, record all message IDs in permanent deduplication table</p>
<p>  -- Only messages that are actually new will be returned</p>
<p>  WITH new_msgs AS (</p>
<p>    INSERT INTO wh_message_deduplication (message_id, first_seen_at)</p>
<p>    SELECT (elem->>'MessageId')::UUID, v_now</p>
<p>    FROM jsonb_array_elements(p_new_inbox_messages) as elem</p>
<p>    ON CONFLICT (message_id) DO NOTHING  -- ← Deduplication happens here</p>
<p>    RETURNING message_id</p>
<p>  )</p>
<p>  SELECT array_agg(message_id) INTO v_new_inbox_ids FROM new_msgs;</p>

<p>  -- Handle NULL case (no new messages, all were duplicates)</p>
<p>  v_new_inbox_ids := COALESCE(v_new_inbox_ids, '{}');</p>

<p>  -- Now insert only the truly new messages into inbox</p>
<p>  FOR v_new_msg IN</p>
<p>    SELECT ...</p>
<p>    FROM jsonb_array_elements(p_new_inbox_messages) as elem</p>
<p>    WHERE (elem->>'MessageId')::UUID = ANY(v_new_inbox_ids)  -- ← Only new IDs</p>
<p>  LOOP</p>
<p>    -- Insert into inbox...</p>
<p>  END LOOP;</p>
<p>END IF;</p>
<p></code></pre></p>

<h3>Testing</h3>

<strong>Test Case</strong>: <code>ProcessWorkBatch_DuplicateInboxMessage_DeduplicationPreventsAsync</code>

<strong>Scenario</strong>:
<ul><li>Insert inbox message M1 with <code>message_id = abc-123</code></li>
<li>Attempt to insert same message again with same <code>message_id</code></li>
<li>Verify second insert is rejected</li>
<li>Verify only one record in <code>wh_inbox</code></li>
</ul>
<h3>Limitations and Trade-offs</h3>

<strong>Advantages</strong>:
<ul><li>✅ <strong>Simple</strong>: No complex logic, database constraint handles it</li>
<li>✅ <strong>Reliable</strong>: Primary key constraint is atomic and foolproof</li>
<li>✅ <strong>Exactly-once</strong>: Guaranteed single processing per message ID</li>
</ul>
<strong>Disadvantages</strong>:
<ul><li>❌ <strong>Storage Growth</strong>: Table grows indefinitely (one row per unique message ID)</li>
<li>❌ <strong>Performance</strong>: Index size grows over time (mitigated by UUIDs and btree)</li>
<li>❌ <strong>No Expiration</strong>: Old messages never removed (could implement cleanup)</li>
</ul>
<strong>Mitigation Strategies</strong>:
<ul><li>Use UUIDv7 for time-ordered IDs (better index performance)</li>
<li>Partition table by first_seen_at (if cleanup needed)</li>
<li>Monitor table size and implement retention policy if needed</li>
</ul>
<h2>Outbox Idempotency {#outbox-idempotency}</h2>

<h3>Strategy: Transactional Boundary Responsibility</h3>

<strong>Mechanism</strong>: Outbox does NOT use a deduplication table. Duplicate prevention is the application's responsibility within its transaction boundary.

<h3>Why No Deduplication?</h3>

<strong>Rationale</strong>:
<ul><li><strong>Transactional Outbox Pattern</strong>: Outbox is part of the application's database transaction</li>
<li><strong>Application Control</strong>: Application decides what messages to send</li>
<li><strong>Idempotent Commands</strong>: Application should use idempotent command IDs</li>
<li><strong>Whizbang's Role</strong>: Ensure at-least-once delivery (once in outbox → delivered to transport)</li>
</ul>
<h3>Transactional Outbox Pattern</h3>

<pre><code class="language-mermaid">graph TD
<p>    A[HTTP Request:<br/>Create Order] -->|BEGIN TRANSACTION| B[Application Logic]</p>
<p>    B --> C[INSERT INTO orders<br/>id=123, status='Created']</p>
<p>    C --> D{Check if order<br/>already exists?}</p>
<p>    D -->|Exists| E[Do Nothing<br/>Idempotent]</p>
<p>    D -->|New| F[INSERT INTO wh_outbox<br/>OrderCreated event]</p>
<p>    F --> G[COMMIT TRANSACTION]</p>
<p>    E --> G</p>

<p>    G --> H[Background Worker:<br/>ProcessWorkBatchAsync]</p>
<p>    H --> I[Publish to Transport]</p>
<p>    I --> J[Mark as Published,<br/>DELETE from wh_outbox]</p>

<p>    style C fill:#e1ffe1</p>
<p>    style D fill:#ffe1e1</p>
<p>    style F fill:#ffe1e1</p>
<p>    style G fill:#e1f5ff</p>

<p>    Note1[Application ensures idempotency<br/>via unique constraints, checks, etc.]</p>
<p>    Note2[Whizbang ensures at-least-once delivery<br/>from outbox to transport]</p>
<p></code></pre></p>

<h3>Example: Idempotent Command Handler</h3>

<pre><code class="language-csharp">public async Task<Result> HandleCreateOrderAsync(CreateOrderCommand command) {
<p>    // Start application transaction</p>
<p>    using var transaction = await _dbContext.Database.BeginTransactionAsync();</p>

<p>    // Check if order already exists (idempotency check)</p>
<p>    var existingOrder = await _dbContext.Orders</p>
<p>        .FirstOrDefaultAsync(o => o.Id == command.OrderId);</p>

<p>    if (existingOrder != null) {</p>
<p>        // Already processed - do nothing (idempotent)</p>
<p>        await transaction.CommitAsync();</p>
<p>        return Result.Success();</p>
<p>    }</p>

<p>    // Create new order</p>
<p>    var order = new Order {</p>
<p>        Id = command.OrderId,  // Deterministic ID (from command)</p>
<p>        CustomerId = command.CustomerId,</p>
<p>        Status = OrderStatus.Created</p>
<p>    };</p>

<p>    _dbContext.Orders.Add(order);</p>

<p>    // Publish OrderCreated event to outbox</p>
<p>    var orderCreatedEvent = new OrderCreatedEvent {</p>
<p>        OrderId = order.Id,</p>
<p>        CustomerId = order.CustomerId</p>
<p>    };</p>

<p>    await _dispatcher.PublishAsync(orderCreatedEvent);  // → Outbox</p>

<p>    // Commit application transaction (atomic)</p>
<p>    await _dbContext.SaveChangesAsync();</p>
<p>    await transaction.CommitAsync();</p>

<p>    return Result.Success();</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li>Command has deterministic ID (<code>command.OrderId</code>)</li>
<li>Application checks for existing order before processing</li>
<li>If order exists, do nothing (idempotent)</li>
<li>Outbox insert happens within same transaction</li>
<li>If transaction fails, both order AND outbox inserts roll back</li>
</ul>
<h3>No Deduplication Table Needed</h3>

<strong>Why?</strong>:
<ul><li>If the same command is executed twice:</li>
</ul><p>  - First execution: Creates order + outbox entry → COMMIT</p>
<p>  - Second execution: Finds existing order → Do nothing → COMMIT (no outbox entry)</p>
<ul><li>Outbox only has one entry (from first execution)</li>
<li>If application logic fails to check for duplicates, that's an application bug, not a framework responsibility</li>
</ul>
<h3>Outbox Processing Flow</h3>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant App as Application</p>
<p>    participant DB as PostgreSQL<br/>(Application DB)</p>
<p>    participant WC as WorkCoordinator</p>
<p>    participant T as Transport</p>

<p>    App->>DB: BEGIN TRANSACTION</p>
<p>    App->>DB: INSERT INTO orders (id=123, ...)</p>
<p>    App->>DB: INSERT INTO wh_outbox<br/>(message_id=uuid, event='OrderCreated')</p>
<p>    App->>DB: COMMIT TRANSACTION</p>

<p>    Note over DB: Outbox entry persisted<br/>atomically with order</p>

<p>    WC->>DB: ProcessWorkBatchAsync()</p>
<p>    DB-->>WC: WorkBatch: [OrderCreated event]</p>

<p>    WC->>T: Publish OrderCreated to transport</p>
<p>    T-->>WC: Ack</p>

<p>    WC->>DB: ProcessWorkBatchAsync(<br/>completions: [OrderCreated: Published])</p>
<p>    DB->>DB: DELETE FROM wh_outbox<br/>WHERE message_id = ...</p>

<p>    Note over DB: ✅ Message delivered exactly once<br/>Outbox entry removed</p>
<p></code></pre></p>

<h3>Testing</h3>

<strong>Test Case</strong>: <code>ProcessWorkBatch_OutboxNoDuplication_TransactionalBoundaryAsync</code>

<strong>Scenario</strong>:
<ul><li>Application transaction creates order + outbox entry</li>
<li>Same command executed again (simulating duplicate request)</li>
<li>Verify application logic prevents duplicate order</li>
<li>Verify only ONE outbox entry created</li>
</ul>
<h2>Comparison Matrix</h2>

<p>| Aspect | Inbox Deduplication | Outbox Transactional |</p>
<p>|---|---|---|</p>
<p>| <strong>Mechanism</strong> | Permanent deduplication table | Application transaction control |</p>
<p>| <strong>Guarantee</strong> | Exactly-once processing | At-least-once delivery |</p>
<p>| <strong>Responsibility</strong> | Whizbang framework | Application code |</p>
<p>| <strong>Storage</strong> | One row per unique message ID (permanent) | No deduplication table |</p>
<p>| <strong>Performance</strong> | Index lookup on every message | No overhead |</p>
<p>| <strong>Complexity</strong> | Simple (database constraint) | Requires application design |</p>
<p>| <strong>Use Case</strong> | External events (from transports) | Internal events (from application) |</p>

<h2>Best Practices</h2>

<h3>Inbox Best Practices</h3>

<strong>1. Use Deterministic Message IDs</strong>:
<pre><code class="language-csharp">// ✅ Good: Deterministic ID based on event content
<p>var messageId = Uuid7.FromName(</p>
<p>    namespaceId: Uuid7.NamespaceOID,</p>
<p>    name: $"OrderCreated-{orderId}"</p>
<p>);</p>

<p>// ❌ Bad: Random ID (loses idempotency)</p>
<p>var messageId = Uuid7.NewUuid7();  // Different every time</p>
<p></code></pre></p>

<strong>2. Include Correlation/Causation IDs</strong>:
<ul><li>Even with deduplication, include correlation and causation IDs</li>
<li>Enables tracing and debugging</li>
<li>Helps identify duplicate sources</li>
</ul>
<strong>3. Monitor Deduplication Table Size</strong>:
<pre><code class="language-sql">SELECT COUNT(*) FROM wh_message_deduplication;
<p>SELECT pg_total_relation_size('wh_message_deduplication');</p>
<p></code></pre></p>

<strong>4. Consider Retention Policy</strong> (optional):
<pre><code class="language-sql">-- Delete deduplication records older than 90 days (if needed)
<p>DELETE FROM wh_message_deduplication</p>
<p>WHERE first_seen_at < NOW() - INTERVAL '90 days';</p>
<p></code></pre></p>

<h3>Outbox Best Practices</h3>

<strong>1. Use Deterministic Command IDs</strong>:
<pre><code class="language-csharp">public class CreateOrderCommand {
<p>    public Guid OrderId { get; init; }  // Deterministic, from client</p>
<p>    // ... other properties</p>
<p>}</p>

<p>// Client generates ID</p>
<p>var command = new CreateOrderCommand {</p>
<p>    OrderId = Uuid7.NewUuid7(),  // Generated once, by client</p>
<p>    // ...</p>
<p>};</p>

<p>// Retry with same ID</p>
<p>await httpClient.PostAsync("/orders", command);  // Same OrderId</p>
<p></code></pre></p>

<strong>2. Implement Idempotency Checks</strong>:
<pre><code class="language-csharp">// Always check if entity already exists
<p>var existing = await _dbContext.Orders</p>
<p>    .FirstOrDefaultAsync(o => o.Id == command.OrderId);</p>

<p>if (existing != null) {</p>
<p>    return Result.Success();  // Already processed</p>
<p>}</p>
<p></code></pre></p>

<strong>3. Use Unique Constraints</strong>:
<pre><code class="language-csharp">modelBuilder.Entity<Order>(entity => {
<p>    entity.HasKey(e => e.Id);</p>

<p>    // Additional unique constraints for idempotency</p>
<p>    entity.HasIndex(e => new { e.CustomerId, e.OrderNumber })</p>
<p>          .IsUnique();  // Prevent duplicate order numbers</p>
<p>});</p>
<p></code></pre></p>

<strong>4. Transaction Scope</strong>:
<pre><code class="language-csharp">// Ensure outbox is in same transaction as business logic
<p>using var transaction = await _dbContext.Database.BeginTransactionAsync();</p>

<p>// Business logic</p>
<p>// ...</p>

<p>// Outbox (same transaction)</p>
<p>await _dispatcher.PublishAsync(evt);</p>

<p>await _dbContext.SaveChangesAsync();</p>
<p>await transaction.CommitAsync();  // Atomic</p>
<p></code></pre></p>

<h2>Troubleshooting</h2>

<h3>Inbox: Duplicate Messages Still Processing</h3>

<strong>Symptoms</strong>:
<ul><li>Same message processed multiple times</li>
<li>Duplicate handler invocations</li>
<li>Data inconsistencies</li>
</ul>
<strong>Diagnostic Steps</strong>:
<ul><li>Check if message IDs are actually unique:</li>
</ul><p>   <pre><code class="language-sql">   SELECT message_id, COUNT(*)</p>
<p>   FROM wh_message_deduplication</p>
<p>   GROUP BY message_id</p>
<p>   HAVING COUNT(*) > 1;</p>
<p>   </code></pre></p>

<ul><li>Verify deduplication table exists and has primary key:</li>
</ul><p>   <pre><code class="language-sql">   \d wh_message_deduplication</p>
<p>   </code></pre></p>

<ul><li>Check if messages have NULL message_id:</li>
</ul><p>   <pre><code class="language-sql">   SELECT * FROM wh_inbox WHERE message_id IS NULL;</p>
<p>   </code></pre></p>

<strong>Common Causes</strong>:
<ul><li>Message IDs not set (NULL)</li>
<li>Non-deterministic message ID generation</li>
<li>Deduplication table missing or corrupted</li>
<li>Multiple databases (each has separate deduplication table)</li>
</ul>
<h3>Outbox: Duplicate Events Published</h3>

<strong>Symptoms</strong>:
<ul><li>Same event published multiple times to transport</li>
<li>Downstream systems receive duplicates</li>
</ul>
<strong>Diagnostic Steps</strong>:
<ul><li>Check if outbox has duplicate entries:</li>
</ul><p>   <pre><code class="language-sql">   SELECT destination, event_type, event_data::TEXT,</p>
<p>          COUNT(*)</p>
<p>   FROM wh_outbox</p>
<p>   GROUP BY destination, event_type, event_data::TEXT</p>
<p>   HAVING COUNT(*) > 1;</p>
<p>   </code></pre></p>

<ul><li>Verify application transaction scope:</li>
</ul><p>   - Is outbox insert in same transaction as business logic?</p>
<p>   - Are there multiple code paths creating the same event?</p>

<strong>Common Causes</strong>:
<ul><li>Application logic executes multiple times (no idempotency check)</li>
<li>Outbox insert outside application transaction</li>
<li>Retry logic without idempotency checks</li>
<li>Multiple application instances with separate databases</li>
</ul>
<h2>Related Documentation</h2>

<ul><li><a href="work-coordination.md">Work Coordination</a> - Overview and architecture</li>
<li><a href="multi-instance-coordination.md">Multi-Instance Coordination</a> - Cross-instance scenarios</li>
<li><a href="failure-handling.md">Failure Handling</a> - Retry scheduling and cascades</li>
<li><a href="outbox-pattern.md">Outbox Pattern</a> - Transactional outbox implementation</li>
<li><a href="inbox-pattern.md">Inbox Pattern</a> - Deduplication and handler invocation</li>
</ul>
<h2>Implementation</h2>

<h3>PostgreSQL Function</h3>

<p>See: <code>014_CreateProcessWorkBatchFunction.sql</code></p>

<strong>Key Sections</strong>:
<ul><li>Lines 348-404: Inbox deduplication with wh_message_deduplication table</li>
<li>Lines 299-344: Outbox storage (no deduplication table)</li>
</ul>
<h3>C# Coordinator</h3>

<p>See: <code>Whizbang.Data.EFCore.Postgres/EFCoreWorkCoordinator.cs</code></p>

<strong>Method</strong>: <code>ProcessWorkBatchAsync</code>

<strong>Responsibilities</strong>:
<ul><li>Serialize new inbox/outbox messages to JSON</li>
<li>Call PostgreSQL <code>process_work_batch</code> function</li>
<li>Return work batch with messages (duplicates already filtered by DB)</li>
</ul>
<h3>Integration Tests</h3>

<p>See: <code>Whizbang.Data.EFCore.Postgres.Tests/EFCoreWorkCoordinatorTests.cs</code></p>

<strong>Test Cases</strong>:
<ul><li><code>ProcessWorkBatch_DuplicateInboxMessage_DeduplicationPreventsAsync</code> - Inbox idempotency</li>
<li><code>ProcessWorkBatch_OutboxNoDuplication_TransactionalBoundaryAsync</code> - Outbox responsibility</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-messaging-inbox-pattern" class="doc-section">
  <h3>Inbox Pattern</h3>
  <p class="doc-path"><code>v1.0.0/messaging/inbox-pattern</code></p>
  <p class="doc-description"><em>Achieve exactly-once message processing with the Inbox Pattern - automatic deduplication and idempotent message handling</em></p>
  <div class="doc-content">

<h1>Inbox Pattern</h1>

<p>The <strong>Inbox Pattern</strong> ensures exactly-once message processing by storing incoming messages in a database table ("inbox") before processing. If a duplicate message arrives, it's detected and ignored.</p>

<h2>Problem: Duplicate Messages</h2>

<strong>The Challenge</strong>: Message brokers provide <strong>at-least-once delivery</strong>, meaning messages may be delivered multiple times.

<h3>Sources of Duplicates</h3>

<ul><li><strong>Outbox retry</strong>: Publisher retries after partial failure</li>
<li><strong>Network timeout</strong>: Ack not received, broker resends</li>
<li><strong>Consumer restart</strong>: Message in-flight when consumer crashes</li>
<li><strong>Broker failover</strong>: Message replayed after broker failover</li>
</ul>
<h3>Naive Approach (BROKEN)</h3>

<pre><code class="language-csharp">public async Task ProcessMessageAsync(OrderCreated @event, CancellationToken ct) {
<p>    // ❌ No duplicate detection - processes every message!</p>

<p>    await _db.ExecuteAsync(</p>
<p>        "UPDATE inventory SET reserved = reserved + @Quantity WHERE product_id = @ProductId",</p>
<p>        new { @event.ProductId, @event.Quantity }</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<strong>What goes wrong with duplicates?</strong>
<ul><li>❌ Inventory reserved twice (incorrect stock levels)</li>
<li>❌ Payment charged twice (angry customers!)</li>
<li>❌ Email sent twice (spam)</li>
</ul>
<hr>

<h2>Solution: Inbox Pattern</h2>

<strong>The Fix</strong>: Check inbox before processing, store message ID after processing.

<pre><code class="language-">┌─────────────────────────────────────────────────┐
<p>│ 1. Message arrives from Azure Service Bus      │</p>
<p>└─────────────────┬───────────────────────────────┘</p>
<p>                  ↓</p>
<p>┌─────────────────────────────────────────────────┐</p>
<p>│ 2. Check inbox for duplicate                    │</p>
<p>│    SELECT * FROM wh_inbox WHERE message_id = ?  │</p>
<p>│                                                 │</p>
<p>│    If found: SKIP (already processed!)         │  ← Exactly-once!</p>
<p>│    If not found: Continue...                    │</p>
<p>└─────────────────┬───────────────────────────────┘</p>
<p>                  ↓</p>
<p>┌─────────────────────────────────────────────────┐</p>
<p>│ 3. Process message (business logic)             │</p>
<p>└─────────────────┬───────────────────────────────┘</p>
<p>                  ↓</p>
<p>┌─────────────────────────────────────────────────┐</p>
<p>│ 4. Store message ID in inbox (atomic!)          │</p>
<p>│    INSERT INTO wh_inbox (message_id, ...)       │</p>
<p>└─────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ <strong>Exactly-once processing</strong>: Duplicates detected and skipped</li>
<li>✅ <strong>Idempotent</strong>: Safe to replay messages</li>
<li>✅ <strong>Automatic</strong>: Framework handles deduplication</li>
<li>✅ <strong>Auditability</strong>: Complete record of processed messages</li>
</ul>
<hr>

<h2>Whizbang Implementation</h2>

<h3>Database Schema</h3>

<pre><code class="language-sql">CREATE TABLE wh_inbox (
<p>    message_id UUID PRIMARY KEY,</p>
<p>    correlation_id UUID NOT NULL,</p>
<p>    causation_id UUID NULL,</p>
<p>    message_type VARCHAR(500) NOT NULL,</p>
<p>    payload JSONB NOT NULL,</p>
<p>    source_topic VARCHAR(255) NOT NULL,</p>

<p>    -- Metadata</p>
<p>    metadata JSONB NULL,</p>

<p>    -- Lease-based coordination</p>
<p>    instance_id UUID NULL,</p>
<p>    lease_expiry TIMESTAMPTZ NULL,</p>

<p>    -- Status tracking</p>
<p>    status VARCHAR(50) NOT NULL DEFAULT 'Received',</p>
<p>    attempts INT NOT NULL DEFAULT 0,</p>
<p>    last_error TEXT NULL,</p>

<p>    -- Timestamps</p>
<p>    received_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),</p>
<p>    processed_at TIMESTAMPTZ NULL,</p>
<p>    completed_at TIMESTAMPTZ NULL,</p>

<p>    -- Indexes</p>
<p>    CONSTRAINT chk_inbox_status CHECK (status IN ('Received', 'Processing', 'Completed', 'Failed'))</p>
<p>);</p>

<p>CREATE INDEX idx_inbox_status ON wh_inbox(status, partition_number);</p>
<p>CREATE INDEX idx_inbox_correlation ON wh_inbox(correlation_id);</p>
<p>CREATE UNIQUE INDEX idx_inbox_message_id ON wh_inbox(message_id);  -- Enforces exactly-once!</p>
<p></code></pre></p>

<strong>Key Fields</strong>:
<ul><li><strong>message_id</strong>: Unique message identifier (primary key, enforces uniqueness)</li>
<li><strong>status</strong>: Received → Processing → Completed | Failed</li>
<li><strong>instance_id</strong>: Which worker is processing this message</li>
<li><strong>lease_expiry</strong>: When the lease expires</li>
</ul>
<strong>Critical</strong>: <code>UNIQUE INDEX</code> on <code>message_id</code> prevents duplicate processing!

<hr>

<h2>Detecting Duplicates</h2>

<h3>Check Before Processing</h3>

<pre><code class="language-csharp">public async Task<bool> IsMessageProcessedAsync(
<p>    Guid messageId,</p>
<p>    CancellationToken ct = default) {</p>

<p>    await using var conn = _db.CreateConnection();</p>

<p>    var existing = await conn.QuerySingleOrDefaultAsync<InboxRow>(</p>
<p>        "SELECT * FROM wh_inbox WHERE message_id = @MessageId",</p>
<p>        new { MessageId = messageId },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    return existing is not null && existing.Status == "Completed";</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">if (await IsMessageProcessedAsync(message.MessageId, ct)) {
<p>    _logger.LogWarning("Duplicate message {MessageId} detected, skipping", message.MessageId);</p>
<p>    return;  // Skip processing!</p>
<p>}</p>
<p></code></pre></p>

<h3>Atomic Insert with Duplicate Check</h3>

<pre><code class="language-csharp">try {
<p>    await conn.ExecuteAsync(</p>
<p>        """</p>
<p>        INSERT INTO wh_inbox (message_id, correlation_id, message_type, payload, source_topic, status, received_at)</p>
<p>        VALUES (@MessageId, @CorrelationId, @MessageType, @Payload, @SourceTopic, 'Received', NOW())</p>
<p>        """,</p>
<p>        new {</p>
<p>            MessageId = message.MessageId,</p>
<p>            CorrelationId = message.CorrelationId,</p>
<p>            MessageType = message.GetType().FullName,</p>
<p>            Payload = JsonSerializer.Serialize(message),</p>
<p>            SourceTopic = "orders"</p>
<p>        },</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>} catch (Npgsql.PostgresException ex) when (ex.SqlState == "23505") {  // Unique violation</p>
<p>    _logger.LogWarning("Duplicate message {MessageId} detected (unique constraint)", message.MessageId);</p>
<p>    return;  // Skip processing!</p>
<p>}</p>
<p></code></pre></p>

<strong>Pattern</strong>: Let database enforce uniqueness via unique constraint.

<hr>

<h2>Complete Processing Example</h2>

<h3>InventoryWorker</h3>

<pre><code class="language-csharp">public class InventoryWorker : BackgroundService {
<p>    private readonly IWorkCoordinator _coordinator;</p>
<p>    private readonly IMessageTransport _transport;</p>
<p>    private readonly IDispatcher _dispatcher;</p>

<p>    protected override async Task ExecuteAsync(CancellationToken ct) {</p>
<p>        var instanceId = Guid.NewGuid();</p>

<p>        // Subscribe to topic</p>
<p>        await _transport.SubscribeAsync("orders", async (msg, ct) => {</p>
<p>            try {</p>
<p>                // 1. Check for duplicate (via inbox)</p>
<p>                var isDuplicate = await _coordinator.IsMessageInInboxAsync(msg.MessageId, ct);</p>

<p>                if (isDuplicate) {</p>
<p>                    _logger.LogWarning(</p>
<p>                        "Duplicate message {MessageId} detected, skipping",</p>
<p>                        msg.MessageId</p>
<p>                    );</p>
<p>                    return;  // Skip!</p>
<p>                }</p>

<p>                // 2. Store in inbox (atomic - prevents concurrent processing)</p>
<p>                await _coordinator.ProcessWorkBatchAsync(</p>
<p>                    instanceId: instanceId,</p>
<p>                    serviceName: "InventoryWorker",</p>
<p>                    hostName: Environment.MachineName,</p>
<p>                    processId: Environment.ProcessId,</p>
<p>                    metadata: null,</p>
<p>                    outboxCompletions: [],</p>
<p>                    outboxFailures: [],</p>
<p>                    inboxCompletions: [],</p>
<p>                    inboxFailures: [],</p>
<p>                    receptorCompletions: [],</p>
<p>                    receptorFailures: [],</p>
<p>                    perspectiveCompletions: [],</p>
<p>                    perspectiveFailures: [],</p>
<p>                    newOutboxMessages: [],</p>
<p>                    newInboxMessages: [</p>
<p>                        new InboxMessage(</p>
<p>                            MessageId: msg.MessageId,</p>
<p>                            CorrelationId: msg.CorrelationId,</p>
<p>                            CausationId: msg.CausationId,</p>
<p>                            MessageType: msg.MessageType,</p>
<p>                            Payload: msg.Payload,</p>
<p>                            SourceTopic: "orders"</p>
<p>                        )</p>
<p>                    ],</p>
<p>                    renewOutboxLeaseIds: [],</p>
<p>                    renewInboxLeaseIds: [],</p>
<p>                    ct: ct</p>
<p>                );</p>

<p>                // 3. Process message (business logic)</p>
<p>                var orderCreated = JsonSerializer.Deserialize<OrderCreated>(msg.Payload);</p>

<p>                if (orderCreated is null) {</p>
<p>                    throw new InvalidOperationException("Failed to deserialize OrderCreated");</p>
<p>                }</p>

<p>                await ProcessOrderCreatedAsync(orderCreated, ct);</p>

<p>                // 4. Mark as completed</p>
<p>                await _coordinator.ProcessWorkBatchAsync(</p>
<p>                    instanceId: instanceId,</p>
<p>                    serviceName: "InventoryWorker",</p>
<p>                    hostName: Environment.MachineName,</p>
<p>                    processId: Environment.ProcessId,</p>
<p>                    metadata: null,</p>
<p>                    outboxCompletions: [],</p>
<p>                    outboxFailures: [],</p>
<p>                    inboxCompletions: [</p>
<p>                        new MessageCompletion(</p>
<p>                            MessageId: msg.MessageId,</p>
<p>                            Status: MessageProcessingStatus.Completed</p>
<p>                        )</p>
<p>                    ],</p>
<p>                    inboxFailures: [],</p>
<p>                    receptorCompletions: [],</p>
<p>                    receptorFailures: [],</p>
<p>                    perspectiveCompletions: [],</p>
<p>                    perspectiveFailures: [],</p>
<p>                    newOutboxMessages: [],</p>
<p>                    newInboxMessages: [],</p>
<p>                    renewOutboxLeaseIds: [],</p>
<p>                    renewInboxLeaseIds: [],</p>
<p>                    ct: ct</p>
<p>                );</p>

<p>                _logger.LogInformation(</p>
<p>                    "Successfully processed message {MessageId}",</p>
<p>                    msg.MessageId</p>
<p>                );</p>

<p>            } catch (Exception ex) {</p>
<p>                _logger.LogError(</p>
<p>                    ex,</p>
<p>                    "Failed to process message {MessageId}",</p>
<p>                    msg.MessageId</p>
<p>                );</p>

<p>                // Mark as failed</p>
<p>                await _coordinator.ProcessWorkBatchAsync(</p>
<p>                    instanceId: instanceId,</p>
<p>                    serviceName: "InventoryWorker",</p>
<p>                    hostName: Environment.MachineName,</p>
<p>                    processId: Environment.ProcessId,</p>
<p>                    metadata: null,</p>
<p>                    outboxCompletions: [],</p>
<p>                    outboxFailures: [],</p>
<p>                    inboxCompletions: [],</p>
<p>                    inboxFailures: [</p>
<p>                        new MessageFailure(</p>
<p>                            MessageId: msg.MessageId,</p>
<p>                            Status: MessageProcessingStatus.Failed,</p>
<p>                            Error: ex.Message,</p>
<p>                            StackTrace: ex.StackTrace</p>
<p>                        )</p>
<p>                    ],</p>
<p>                    receptorCompletions: [],</p>
<p>                    receptorFailures: [],</p>
<p>                    perspectiveCompletions: [],</p>
<p>                    perspectiveFailures: [],</p>
<p>                    newOutboxMessages: [],</p>
<p>                    newInboxMessages: [],</p>
<p>                    renewOutboxLeaseIds: [],</p>
<p>                    renewInboxLeaseIds: [],</p>
<p>                    ct: ct</p>
<p>                );</p>
<p>            }</p>
<p>        }, ct);</p>

<p>        // Keep running</p>
<p>        await Task.Delay(Timeout.Infinite, ct);</p>
<p>    }</p>

<p>    private async Task ProcessOrderCreatedAsync(OrderCreated @event, CancellationToken ct) {</p>
<p>        // Business logic: Reserve inventory</p>

<p>        foreach (var item in @event.Items) {</p>
<p>            var available = await _db.QuerySingleAsync<int>(</p>
<p>                "SELECT available FROM inventory WHERE product_id = @ProductId",</p>
<p>                new { ProductId = item.ProductId },</p>
<p>                ct</p>
<p>            );</p>

<p>            if (available < item.Quantity) {</p>
<p>                throw new InsufficientInventoryException(</p>
<p>                    $"Product {item.ProductId} has only {available} units available, requested {item.Quantity}"</p>
<p>                );</p>
<p>            }</p>

<p>            await _db.ExecuteAsync(</p>
<p>                "UPDATE inventory SET reserved = reserved + @Quantity WHERE product_id = @ProductId",</p>
<p>                new { ProductId = item.ProductId, Quantity = item.Quantity },</p>
<p>                ct</p>
<p>            );</p>
<p>        }</p>

<p>        _logger.LogInformation(</p>
<p>            "Reserved inventory for order {OrderId}",</p>
<p>            @event.OrderId</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Flow</strong>:
<ul><li>Check inbox for duplicate → Skip if found</li>
<li>Insert into inbox (atomic) → Prevents concurrent processing</li>
<li>Process message (business logic)</li>
<li>Mark as completed → Won't process again</li>
</ul>
<hr>

<h2>Lease-Based Processing</h2>

<p>Like the Outbox Pattern, Inbox uses <strong>leases</strong> for coordinating work across multiple workers.</p>

<h3>Claiming Messages</h3>

<pre><code class="language-sql">-- Claim inbox messages for processing
<p>UPDATE wh_inbox</p>
<p>SET</p>
<p>    instance_id = @InstanceId,</p>
<p>    lease_expiry = NOW() + INTERVAL '5 minutes',</p>
<p>    status = 'Processing'</p>
<p>WHERE message_id IN (</p>
<p>    SELECT message_id</p>
<p>    FROM wh_inbox</p>
<p>    WHERE</p>
<p>        status = 'Received'</p>
<p>        AND (instance_id IS NULL OR lease_expiry < NOW())</p>
<p>        AND partition_number IN (SELECT * FROM assigned_partitions)</p>
<p>    ORDER BY received_at</p>
<p>    LIMIT 100</p>
<p>)</p>
<p>RETURNING *;</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ Multiple workers can process different messages</li>
<li>✅ Crashed workers release leases automatically (via expiry)</li>
<li>✅ Work distributed evenly (partition-based)</li>
</ul>
<hr>

<h2>Exactly-Once Semantics</h2>

<h3>How Inbox Ensures Exactly-Once</h3>

<pre><code class="language-">Message arrives with MessageId: msg-123

<p>┌──────────────────────────────────────────┐</p>
<p>│ Attempt 1 (Worker A)                     │</p>
<p>│                                          │</p>
<p>│ 1. Check inbox for msg-123: NOT FOUND   │</p>
<p>│ 2. Insert into inbox: SUCCESS           │  ← First to insert!</p>
<p>│ 3. Process message: SUCCESS              │</p>
<p>│ 4. Mark completed: SUCCESS               │</p>
<p>└──────────────────────────────────────────┘</p>

<p>Duplicate arrives with MessageId: msg-123 (network retry)</p>

<p>┌──────────────────────────────────────────┐</p>
<p>│ Attempt 2 (Worker B)                     │</p>
<p>│                                          │</p>
<p>│ 1. Check inbox for msg-123: FOUND!      │  ← Duplicate detected!</p>
<p>│ 2. SKIP processing                       │</p>
<p>└──────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Key</strong>: <code>UNIQUE INDEX</code> on <code>message_id</code> prevents duplicate inserts.

<h3>Race Condition Handling</h3>

<pre><code class="language-">Two workers receive same message simultaneously:

<p>Worker A                     Worker B</p>
<p>  ↓                           ↓</p>
<p>INSERT msg-123 → SUCCESS     INSERT msg-123 → DUPLICATE KEY ERROR!</p>
<p>  ↓                           ↓</p>
<p>Process message              Skip (unique constraint violation)</p>
<p>  ↓</p>
<p>Mark completed</p>
<p></code></pre></p>

<strong>Database guarantees exactly-once</strong> via unique constraint!

<hr>

<h2>Idempotency</h2>

<p>Even with inbox, <strong>business logic should be idempotent</strong> as a defense-in-depth strategy.</p>

<h3>Idempotent Update</h3>

<pre><code class="language-csharp">// ✅ Idempotent - safe to run multiple times
<p>await _db.ExecuteAsync(</p>
<p>    "UPDATE orders SET status = 'Shipped', shipped_at = @ShippedAt WHERE order_id = @OrderId AND status = 'Created'",</p>
<p>    new { @event.OrderId, @event.ShippedAt }</p>
<p>);</p>
<p></code></pre></p>

<strong>Key</strong>: <code>WHERE status = 'Created'</code> ensures update only happens once (already shipped orders are skipped).

<h3>Non-Idempotent Update (Avoid!)</h3>

<pre><code class="language-csharp">// ❌ Not idempotent - running twice doubles inventory!
<p>await _db.ExecuteAsync(</p>
<p>    "UPDATE inventory SET reserved = reserved + @Quantity WHERE product_id = @ProductId",</p>
<p>    new { @event.ProductId, @event.Quantity }</p>
<p>);</p>
<p></code></pre></p>

<strong>Fix</strong>: Use inbox to prevent this, OR make logic idempotent:

<pre><code class="language-csharp">// ✅ Idempotent - check if already reserved
<p>var alreadyReserved = await _db.QuerySingleAsync<bool>(</p>
<p>    "SELECT EXISTS(SELECT 1 FROM inventory_reservations WHERE order_id = @OrderId AND product_id = @ProductId)",</p>
<p>    new { @event.OrderId, @event.ProductId }</p>
<p>);</p>

<p>if (!alreadyReserved) {</p>
<p>    await _db.ExecuteAsync(</p>
<p>        "UPDATE inventory SET reserved = reserved + @Quantity WHERE product_id = @ProductId",</p>
<p>        new { @event.ProductId, @event.Quantity }</p>
<p>    );</p>

<p>    await _db.ExecuteAsync(</p>
<p>        "INSERT INTO inventory_reservations (order_id, product_id, quantity) VALUES (@OrderId, @ProductId, @Quantity)",</p>
<p>        new { @event.OrderId, @event.ProductId, @event.Quantity }</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Retry & Failure Handling</h2>

<h3>Retry Logic</h3>

<pre><code class="language-csharp">// Failed messages: increment attempts, update status
<p>foreach (var failure in inboxFailures) {</p>
<p>    await conn.ExecuteAsync(</p>
<p>        """</p>
<p>        UPDATE wh_inbox</p>
<p>        SET</p>
<p>            attempts = attempts + 1,</p>
<p>            status = CASE</p>
<p>                WHEN attempts + 1 >= 5 THEN 'Failed'  -- Max 5 attempts</p>
<p>                ELSE 'Received'  -- Retry</p>
<p>            END,</p>
<p>            last_error = @Error,</p>
<p>            instance_id = NULL,</p>
<p>            lease_expiry = NULL</p>
<p>        WHERE message_id = @MessageId</p>
<p>        """,</p>
<p>        new { failure.MessageId, failure.Error }</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<strong>Retry Strategy</strong>:
<ul><li>Attempt 1-4: Retry (status = Received, available for next poll)</li>
<li>Attempt 5+: Give up (status = Failed, needs manual intervention)</li>
</ul>
<h3>Dead Letter Queue</h3>

<pre><code class="language-csharp">public async Task ReprocessFailedMessagesAsync(CancellationToken ct = default) {
<p>    var failedMessages = await _db.QueryAsync<InboxRow>(</p>
<p>        """</p>
<p>        SELECT * FROM wh_inbox</p>
<p>        WHERE status = 'Failed'</p>
<p>        ORDER BY received_at</p>
<p>        LIMIT 100</p>
<p>        """,</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    foreach (var msg in failedMessages) {</p>
<p>        // Manual retry or move to dead letter queue</p>
<p>        _logger.LogWarning(</p>
<p>            "Failed message {MessageId} after {Attempts} attempts: {Error}",</p>
<p>            msg.MessageId, msg.Attempts, msg.LastError</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Check inbox before processing</strong> (detect duplicates)</li>
<li>✅ <strong>Insert into inbox atomically</strong> (prevents concurrent processing)</li>
<li>✅ <strong>Use unique constraint</strong> on message_id (enforces exactly-once)</li>
<li>✅ <strong>Make business logic idempotent</strong> (defense-in-depth)</li>
<li>✅ <strong>Log all processing</strong> (correlation ID, message type)</li>
<li>✅ <strong>Monitor failed messages</strong> (alerts when attempts >= 5)</li>
<li>✅ <strong>Clean up old messages</strong> (archive Completed after 30 days)</li>
<li>✅ <strong>Use leases</strong> (enables parallel processing)</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Skip duplicate detection (leads to duplicate processing)</li>
<li>❌ Process before inserting into inbox (race condition)</li>
<li>❌ Ignore failed messages (silent data loss)</li>
<li>❌ Assume messages arrive in order (they don't!)</li>
<li>❌ Store large payloads in inbox (use size limits)</li>
<li>❌ Process same message concurrently (use leases)</li>
<li>❌ Skip monitoring (blind to failures)</li>
</ul>
<hr>

<h2>Monitoring & Observability</h2>

<h3>Key Metrics</h3>

<pre><code class="language-csharp">public class InboxMetrics {
<p>    public int ReceivedCount { get; set; }     // Messages waiting to be processed</p>
<p>    public int ProcessingCount { get; set; }   // Messages currently being processed</p>
<p>    public int CompletedCount { get; set; }    // Messages successfully processed</p>
<p>    public int FailedCount { get; set; }       // Messages that failed max retries</p>
<p>    public double OldestMessageAge { get; set; }  // Age of oldest Received message (seconds)</p>
<p>}</p>

<p>public async Task<InboxMetrics> GetMetricsAsync(CancellationToken ct = default) {</p>
<p>    await using var conn = _db.CreateConnection();</p>

<p>    return await conn.QuerySingleAsync<InboxMetrics>(</p>
<p>        """</p>
<p>        SELECT</p>
<p>            COUNT(*) FILTER (WHERE status = 'Received') AS ReceivedCount,</p>
<p>            COUNT(*) FILTER (WHERE status = 'Processing') AS ProcessingCount,</p>
<p>            COUNT(*) FILTER (WHERE status = 'Completed') AS CompletedCount,</p>
<p>            COUNT(*) FILTER (WHERE status = 'Failed') AS FailedCount,</p>
<p>            EXTRACT(EPOCH FROM (NOW() - MIN(received_at) FILTER (WHERE status = 'Received'))) AS OldestMessageAge</p>
<p>        FROM wh_inbox</p>
<p>        """,</p>
<p>        cancellationToken: ct</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<h3>Alerts</h3>

<strong>Critical Alerts</strong>:
<ul><li>🚨 <code>OldestMessageAge > 600</code> (message stuck for 10+ minutes)</li>
<li>🚨 <code>FailedCount > 0</code> (messages gave up after max retries)</li>
<li>🚨 <code>ReceivedCount > 10000</code> (inbox backlog growing)</li>
</ul>
<strong>Warning Alerts</strong>:
<ul><li>⚠️ <code>OldestMessageAge > 60</code> (message not processed within 1 minute)</li>
<li>⚠️ <code>ProcessingCount > 1000</code> (many messages being processed)</li>
</ul>
<hr>

<h2>Testing</h2>

<h3>Unit Tests</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task ProcessMessage_Duplicate_SkipsProcessingAsync() {</p>
<p>    // Arrange</p>
<p>    var messageId = Guid.CreateVersion7();</p>

<p>    // First processing</p>
<p>    await _coordinator.ProcessWorkBatchAsync(</p>
<p>        /<em> ... </em>/,</p>
<p>        newInboxMessages: [new InboxMessage(MessageId: messageId, /<em> ... </em>/)],</p>
<p>        /<em> ... </em>/</p>
<p>    );</p>

<p>    await _coordinator.ProcessWorkBatchAsync(</p>
<p>        /<em> ... </em>/,</p>
<p>        inboxCompletions: [new MessageCompletion(MessageId: messageId, Status: MessageProcessingStatus.Completed)],</p>
<p>        /<em> ... </em>/</p>
<p>    );</p>

<p>    // Act - attempt duplicate</p>
<p>    var isDuplicate = await _coordinator.IsMessageInInboxAsync(messageId);</p>

<p>    // Assert</p>
<p>    await Assert.That(isDuplicate).IsTrue();</p>
<p>}</p>
<p></code></pre></p>

<h3>Integration Tests</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task InventoryWorker_DuplicateMessage_ProcessesOnceAsync() {</p>
<p>    // Arrange</p>
<p>    var message = new OrderCreated(/<em> ... </em>/);</p>
<p>    var messageId = message.MessageId;</p>

<p>    // Act - publish same message twice</p>
<p>    await _transport.PublishAsync("orders", message);</p>
<p>    await Task.Delay(1000);  // Let worker process</p>

<p>    await _transport.PublishAsync("orders", message);  // Duplicate!</p>
<p>    await Task.Delay(1000);  // Let worker process</p>

<p>    // Assert - inventory reserved only once</p>
<p>    var reserved = await _db.QuerySingleAsync<int>(</p>
<p>        "SELECT reserved FROM inventory WHERE product_id = @ProductId",</p>
<p>        new { ProductId = message.Items[0].ProductId }</p>
<p>    );</p>

<p>    await Assert.That(reserved).IsEqualTo(message.Items[0].Quantity);  // Not doubled!</p>

<p>    // Assert - inbox has one completed entry</p>
<p>    var inboxCount = await _db.ExecuteScalarAsync<int>(</p>
<p>        "SELECT COUNT(*) FROM wh_inbox WHERE message_id = @MessageId",</p>
<p>        new { MessageId = messageId }</p>
<p>    );</p>

<p>    await Assert.That(inboxCount).IsEqualTo(1);</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/dispatcher.md">Dispatcher</a> - Message routing</li>
<li><a href="../core-concepts/receptors.md">Receptors</a> - Message handlers</li>
</ul>
<strong>Messaging Patterns</strong>:
<ul><li><a href="outbox-pattern.md">Outbox Pattern</a> - Reliable event publishing</li>
<li><a href="work-coordinator.md">Work Coordination</a> - IWorkCoordinator deep dive</li>
<li><a href="message-envelopes.md">Message Envelopes</a> - Hop-based observability</li>
</ul>
<strong>Examples</strong>:
<ul><li><a href="../examples/ecommerce/inventory-worker.md">ECommerce: Inventory Worker</a> - Real-world inbox usage</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-messaging-message-envelopes" class="doc-section">
  <h3>Message Envelopes Deep Dive</h3>
  <p class="doc-path"><code>v1.0.0/messaging/message-envelopes</code></p>
  <p class="doc-description"><em>Deep dive into Message Envelopes - hop-based distributed tracing across Outbox, Inbox, and message transports</em></p>
  <div class="doc-content">

<h1>Message Envelopes Deep Dive</h1>

<p>This guide explores how <strong>MessageEnvelope</strong> enables hop-based distributed tracing across Outbox, Inbox, and message transports like Azure Service Bus.</p>

<p>See <a href="../core-concepts/observability.md">Observability & Message Hops</a> for architectural overview. This document focuses on <strong>practical messaging scenarios</strong>.</p>

<hr>

<h2>Envelope Flow Across Services</h2>

<h3>Complete Journey</h3>

<pre><code class="language-">Service A (OrderService)
<p>  ├─> CreateOrder command arrives</p>
<p>  ├─> Envelope created with Current hop</p>
<p>  ├─> Receptor processes, creates OrderCreated event</p>
<p>  ├─> Event stored in Outbox with inherited hops</p>
<p>  ├─> Background worker publishes to Azure Service Bus</p>
<p>  └─> Envelope serialized with all hops</p>

<p>      ↓ Azure Service Bus</p>

<p>Service B (InventoryWorker)</p>
<p>  ├─> Message arrives from Azure Service Bus</p>
<p>  ├─> Envelope deserialized (hops restored!)</p>
<p>  ├─> Stored in Inbox with all original hops</p>
<p>  ├─> Receptor processes, adds new Current hop</p>
<p>  ├─> InventoryReserved event created</p>
<p>  └─> Published to Azure Service Bus with accumulated hops</p>

<p>      ↓ Azure Service Bus</p>

<p>Service C (PaymentWorker)</p>
<p>  ├─> Message arrives with hops from A + B</p>
<p>  └─> Complete trace from HTTP request → Payment!</p>
<p></code></pre></p>

<strong>Key Insight</strong>: Hops <strong>accumulate</strong> across services, providing end-to-end trace.

<hr>

<h2>Outbox Integration</h2>

<h3>Storing Envelope in Outbox</h3>

<pre><code class="language-csharp">public async ValueTask<OrderCreated> HandleAsync(
<p>    CreateOrder message,</p>
<p>    CancellationToken ct = default) {</p>

<p>    // Create event</p>
<p>    var @event = new OrderCreated(/<em> ... </em>/);</p>

<p>    // Create envelope with hops</p>
<p>    var envelope = MessageEnvelope.Create(</p>
<p>        messageId: MessageId.New(),</p>
<p>        correlationId: message.CorrelationId,</p>
<p>        causationId: CausationId.From(message.MessageId),</p>
<p>        payload: @event,</p>
<p>        currentHop: new MessageHop {</p>
<p>            Type = MessageHopType.Current,</p>
<p>            Topic = "orders",</p>
<p>            StreamKey: message.CustomerId.ToString(),</p>
<p>            SecurityContext = GetSecurityContext(),</p>
<p>            Metadata = new Dictionary<string, string> {</p>
<p>                ["ServiceName"] = "OrderService",</p>
<p>                ["ReceptorName"] = nameof(CreateOrderReceptor)</p>
<p>            },</p>
<p>            Timestamp = DateTimeOffset.UtcNow</p>
<p>        },</p>
<p>        causationHops: message.Envelope.Hops  // Inherit parent hops!</p>
<p>    );</p>

<p>    // Store in outbox (serialize envelope)</p>
<p>    await _coordinator.ProcessWorkBatchAsync(</p>
<p>        /<em> ... </em>/,</p>
<p>        newOutboxMessages: [</p>
<p>            new OutboxMessage(</p>
<p>                MessageId: envelope.MessageId.Value,</p>
<p>                CorrelationId: envelope.CorrelationId.Value,</p>
<p>                CausationId: envelope.CausationId?.Value,</p>
<p>                MessageType: typeof(OrderCreated).FullName!,</p>
<p>                Payload: JsonSerializer.Serialize(envelope),  // ← Full envelope!</p>
<p>                Topic: "orders",</p>
<p>                StreamKey: message.CustomerId.ToString(),</p>
<p>                PartitionKey: message.CustomerId.ToString()</p>
<p>            )</p>
<p>        ],</p>
<p>        /<em> ... </em>/</p>
<p>    );</p>

<p>    return @event;</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li>Envelope includes <strong>all hops</strong> (current + causation)</li>
<li>Serialized as JSON in <code>Payload</code> field</li>
<li>Hops <strong>persist</strong> in database for auditability</li>
</ul>
<hr>

<h2>Publishing with Hops</h2>

<h3>Azure Service Bus Integration</h3>

<pre><code class="language-csharp">public class AzureServiceBusTransport : IMessageTransport {
<p>    public async Task PublishAsync(</p>
<p>        string topic,</p>
<p>        MessageEnvelope envelope,</p>
<p>        CancellationToken ct = default) {</p>

<p>        // Serialize envelope (includes all hops)</p>
<p>        var json = JsonSerializer.Serialize(envelope, _jsonOptions);</p>

<p>        var message = new ServiceBusMessage(json) {</p>
<p>            MessageId = envelope.MessageId.Value.ToString(),</p>
<p>            CorrelationId = envelope.CorrelationId.Value.ToString(),</p>
<p>            Subject = envelope.Payload.GetType().Name,</p>

<p>            // Add custom properties for routing</p>
<p>            ApplicationProperties = {</p>
<p>                ["MessageType"] = envelope.Payload.GetType().FullName,</p>
<p>                ["CausationId"] = envelope.CausationId?.Value.ToString() ?? "",</p>
<p>                ["HopCount"] = envelope.Hops.Count,  // For monitoring</p>
<p>                ["OriginatingService"] = envelope.Hops.FirstOrDefault()?.Metadata?["ServiceName"] ?? "Unknown"</p>
<p>            }</p>
<p>        };</p>

<p>        var sender = _client.CreateSender(topic);</p>
<p>        await sender.SendMessageAsync(message, ct);</p>

<p>        _logger.LogInformation(</p>
<p>            "Published message {MessageId} to topic {Topic} with {HopCount} hops",</p>
<p>            envelope.MessageId, topic, envelope.Hops.Count</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Result</strong>: Envelope with <strong>all hops</strong> transmitted to Azure Service Bus!

<hr>

<h2>Receiving with Hops</h2>

<h3>Inbox Deduplication + Hop Restoration</h3>

<pre><code class="language-csharp">public async Task SubscribeAsync(
<p>    string topic,</p>
<p>    Func<MessageEnvelope, CancellationToken, Task> handler,</p>
<p>    CancellationToken ct = default) {</p>

<p>    var processor = _client.CreateProcessor(topic, new ServiceBusProcessorOptions());</p>

<p>    processor.ProcessMessageAsync += async args => {</p>
<p>        try {</p>
<p>            // 1. Deserialize envelope (hops restored!)</p>
<p>            var envelope = JsonSerializer.Deserialize<MessageEnvelope>(</p>
<p>                args.Message.Body.ToString(),</p>
<p>                _jsonOptions</p>
<p>            );</p>

<p>            if (envelope is null) {</p>
<p>                _logger.LogError("Failed to deserialize envelope");</p>
<p>                await args.CompleteMessageAsync(args.Message, ct);</p>
<p>                return;</p>
<p>            }</p>

<p>            _logger.LogInformation(</p>
<p>                "Received message {MessageId} with {HopCount} hops, CorrelationId {CorrelationId}",</p>
<p>                envelope.MessageId, envelope.Hops.Count, envelope.CorrelationId</p>
<p>            );</p>

<p>            // 2. Check inbox for duplicate</p>
<p>            var isDuplicate = await _coordinator.IsMessageInInboxAsync(</p>
<p>                envelope.MessageId.Value,</p>
<p>                ct</p>
<p>            );</p>

<p>            if (isDuplicate) {</p>
<p>                _logger.LogWarning(</p>
<p>                    "Duplicate message {MessageId} detected, skipping",</p>
<p>                    envelope.MessageId</p>
<p>                );</p>
<p>                await args.CompleteMessageAsync(args.Message, ct);</p>
<p>                return;</p>
<p>            }</p>

<p>            // 3. Store in inbox</p>
<p>            await _coordinator.ProcessWorkBatchAsync(</p>
<p>                /<em> ... </em>/,</p>
<p>                newInboxMessages: [</p>
<p>                    new InboxMessage(</p>
<p>                        MessageId: envelope.MessageId.Value,</p>
<p>                        CorrelationId: envelope.CorrelationId.Value,</p>
<p>                        CausationId: envelope.CausationId?.Value,</p>
<p>                        MessageType: envelope.Payload.GetType().FullName!,</p>
<p>                        Payload: JsonSerializer.Serialize(envelope),  // Store full envelope</p>
<p>                        SourceTopic: topic</p>
<p>                    )</p>
<p>                ],</p>
<p>                /<em> ... </em>/</p>
<p>            );</p>

<p>            // 4. Process message (handler receives envelope with hops!)</p>
<p>            await handler(envelope, ct);</p>

<p>            // 5. Complete message</p>
<p>            await args.CompleteMessageAsync(args.Message, ct);</p>

<p>        } catch (Exception ex) {</p>
<p>            _logger.LogError(ex, "Error processing message");</p>
<p>            await args.AbandonMessageAsync(args.Message);</p>
<p>        }</p>
<p>    };</p>

<p>    await processor.StartProcessingAsync(ct);</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li>Envelope <strong>deserialized</strong> with all hops intact</li>
<li>Hops stored in inbox for auditability</li>
<li>Handler receives <strong>full envelope</strong> (not just payload)</li>
</ul>
<hr>

<h2>Adding Hops in Workers</h2>

<h3>InventoryWorker Example</h3>

<pre><code class="language-csharp">public async Task ProcessOrderCreatedAsync(
<p>    MessageEnvelope envelope,</p>
<p>    CancellationToken ct = default) {</p>

<p>    var orderCreated = (OrderCreated)envelope.Payload;</p>

<p>    // Business logic: Reserve inventory</p>
<p>    await ReserveInventoryAsync(orderCreated, ct);</p>

<p>    // Create InventoryReserved event</p>
<p>    var inventoryReserved = new InventoryReserved(</p>
<p>        OrderId: orderCreated.OrderId,</p>
<p>        Reservations: /<em> ... </em>/,</p>
<p>        ReservedAt: DateTimeOffset.UtcNow</p>
<p>    );</p>

<p>    // Create envelope with NEW hop</p>
<p>    var newEnvelope = MessageEnvelope.Create(</p>
<p>        messageId: MessageId.New(),</p>
<p>        correlationId: envelope.CorrelationId,  // Inherit</p>
<p>        causationId: CausationId.From(envelope.MessageId),  // Parent</p>
<p>        payload: inventoryReserved,</p>
<p>        currentHop: new MessageHop {</p>
<p>            Type = MessageHopType.Current,</p>
<p>            Topic = "inventory",</p>
<p>            StreamKey: orderCreated.OrderId.ToString(),</p>
<p>            SecurityContext = envelope.Hops.FirstOrDefault()?.SecurityContext,  // Inherit security</p>
<p>            Metadata = new Dictionary<string, string> {</p>
<p>                ["ServiceName"] = "InventoryWorker",</p>
<p>                ["ReceptorName"] = "ReserveInventoryReceptor",</p>
<p>                ["OriginalOrderId"] = orderCreated.OrderId.ToString()</p>
<p>            },</p>
<p>            Timestamp = DateTimeOffset.UtcNow</p>
<p>        },</p>
<p>        causationHops: envelope.Hops  // ← INHERIT ALL PARENT HOPS!</p>
<p>    );</p>

<p>    // Store in outbox for publishing</p>
<p>    await _coordinator.ProcessWorkBatchAsync(</p>
<p>        /<em> ... </em>/,</p>
<p>        newOutboxMessages: [</p>
<p>            new OutboxMessage(</p>
<p>                MessageId: newEnvelope.MessageId.Value,</p>
<p>                CorrelationId: newEnvelope.CorrelationId.Value,</p>
<p>                CausationId: newEnvelope.CausationId?.Value,</p>
<p>                MessageType: typeof(InventoryReserved).FullName!,</p>
<p>                Payload: JsonSerializer.Serialize(newEnvelope),</p>
<p>                Topic: "inventory",</p>
<p>                StreamKey: orderCreated.OrderId.ToString(),</p>
<p>                PartitionKey: orderCreated.OrderId.ToString()</p>
<p>            )</p>
<p>        ],</p>
<p>        /<em> ... </em>/</p>
<p>    );</p>

<p>    _logger.LogInformation(</p>
<p>        "Published InventoryReserved event with {HopCount} hops (inherited {InheritedHops})",</p>
<p>        newEnvelope.Hops.Count,</p>
<p>        newEnvelope.Hops.Count(h => h.Type == MessageHopType.Causation)</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<strong>Result</strong>: <code>InventoryReserved</code> envelope contains:
<ul><li>Current hop (InventoryWorker)</li>
<li>All causation hops from <code>OrderCreated</code> (OrderService, API Gateway, etc.)</li>
</ul>
<hr>

<h2>Querying Hops Across Services</h2>

<h3>Find Complete Workflow</h3>

<pre><code class="language-sql">-- Find all messages in a workflow (all services)
<p>SELECT</p>
<p>    o.message_id,</p>
<p>    o.message_type,</p>
<p>    o.topic,</p>
<p>    o.created_at,</p>
<p>    (o.payload::JSONB)->'Hops' AS hops</p>
<p>FROM wh_outbox o</p>
<p>WHERE (o.payload::JSONB)->>'CorrelationId' = 'corr-abc'</p>
<p>ORDER BY o.created_at;</p>
<p></code></pre></p>

<strong>Example output</strong>:
<pre><code class="language-">message_id | message_type       | topic     | created_at          | hops
<p>-----------|--------------------|-----------|---------------------|------</p>
<p>msg-001    | OrderCreated       | orders    | 2024-12-12 10:00:00 | [API Gateway]</p>
<p>msg-002    | InventoryReserved  | inventory | 2024-12-12 10:00:01 | [API Gateway, OrderService]</p>
<p>msg-003    | PaymentProcessed   | payment   | 2024-12-12 10:00:02 | [API Gateway, OrderService, InventoryWorker]</p>
<p></code></pre></p>

<h3>Visualize Hop Accumulation</h3>

<pre><code class="language-csharp">public void PrintHopAccumulation(Guid correlationId) {
<p>    var messages = GetMessagesByCorrelation(correlationId);</p>

<p>    foreach (var msg in messages) {</p>
<p>        Console.WriteLine($"{msg.MessageType} ({msg.Timestamp}):");</p>

<p>        for (int i = 0; i < msg.Envelope.Hops.Count; i++) {</p>
<p>            var hop = msg.Envelope.Hops[i];</p>
<p>            var prefix = new string(' ', i * 2);</p>
<p>            var type = hop.Type == MessageHopType.Current ? "CURRENT" : "CAUSATION";</p>

<p>            Console.WriteLine($"{prefix}├─ {type}: {hop.Metadata?["ServiceName"]}");</p>
<p>        }</p>

<p>        Console.WriteLine();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Output</strong>:
<pre><code class="language-">OrderCreated (2024-12-12 10:00:00):
<p>├─ CURRENT: OrderService</p>

<p>InventoryReserved (2024-12-12 10:00:01):</p>
<p>├─ CAUSATION: OrderService</p>
<p>  ├─ CURRENT: InventoryWorker</p>

<p>PaymentProcessed (2024-12-12 10:00:02):</p>
<p>├─ CAUSATION: OrderService</p>
<p>  ├─ CAUSATION: InventoryWorker</p>
<p>    ├─ CURRENT: PaymentWorker</p>
<p></code></pre></p>

<hr>

<h2>Security Context Propagation</h2>

<h3>Extracting Security from Hops</h3>

<pre><code class="language-csharp">public async Task<InventoryReserved> HandleAsync(
<p>    MessageEnvelope envelope,</p>
<p>    CancellationToken ct = default) {</p>

<p>    // Extract security context from first hop (originating service)</p>
<p>    var securityContext = envelope.Hops</p>
<p>        .FirstOrDefault(h => h.SecurityContext is not null)?</p>
<p>        .SecurityContext;</p>

<p>    if (securityContext?.UserId is null) {</p>
<p>        throw new UnauthorizedAccessException("No user context in hops");</p>
<p>    }</p>

<p>    // Validate tenant isolation</p>
<p>    if (securityContext.TenantId != expectedTenantId) {</p>
<p>        throw new ForbiddenException("Tenant mismatch");</p>
<p>    }</p>

<p>    // Business logic with security context</p>
<p>    await ReserveInventoryAsync(orderCreated, securityContext, ct);</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefit</strong>: Security context flows <strong>automatically</strong> via hops!

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Inherit causation hops</strong> when creating new messages</li>
<li>✅ <strong>Add current hop</strong> with service name, timestamp, metadata</li>
<li>✅ <strong>Propagate security context</strong> via hops</li>
<li>✅ <strong>Store envelopes</strong> in outbox/inbox (full auditability)</li>
<li>✅ <strong>Query by CorrelationId</strong> for end-to-end traces</li>
<li>✅ <strong>Monitor hop count</strong> (alert if > 10 hops indicates circular dependency)</li>
<li>✅ <strong>Include debug info</strong> (CallerMemberName, FilePath, LineNumber)</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Discard causation hops (breaks tracing)</li>
<li>❌ Modify inherited hops (immutable!)</li>
<li>❌ Skip adding current hop (incomplete trace)</li>
<li>❌ Store sensitive data in metadata (use SecurityContext)</li>
<li>❌ Ignore hop count limits (circular dependencies)</li>
<li>❌ Forget to log hop information</li>
</ul>
<hr>

<h2>Troubleshooting</h2>

<h3>Problem: Missing Hops</h3>

<strong>Symptom</strong>: Messages arrive with fewer hops than expected.

<strong>Causes</strong>:
<ul><li>Worker not inheriting causation hops</li>
<li>Envelope not serialized/deserialized correctly</li>
<li>Hops not stored in outbox</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-csharp">// Verify hops are inherited
<p>var newEnvelope = MessageEnvelope.Create(</p>
<p>    /<em> ... </em>/,</p>
<p>    causationHops: parentEnvelope.Hops  // ← REQUIRED!</p>
<p>);</p>

<p>// Verify serialization</p>
<p>var json = JsonSerializer.Serialize(envelope);</p>
<p>var deserialized = JsonSerializer.Deserialize<MessageEnvelope>(json);</p>
<p>Debug.Assert(deserialized.Hops.Count == envelope.Hops.Count);</p>
<p></code></pre></p>

<h3>Problem: Circular Dependencies</h3>

<strong>Symptom</strong>: Hop count grows indefinitely.

<strong>Causes</strong>:
<ul><li>Service A publishes event that triggers Service B</li>
<li>Service B publishes event that triggers Service A</li>
<li>Loop repeats forever</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-csharp">// Detect circular dependency via hop count
<p>if (envelope.Hops.Count > 10) {</p>
<p>    _logger.LogError(</p>
<p>        "Circular dependency detected! {HopCount} hops for {CorrelationId}",</p>
<p>        envelope.Hops.Count, envelope.CorrelationId</p>
<p>    );</p>

<p>    // Break the loop</p>
<p>    return;</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Performance Considerations</h2>

<h3>Hop Size</h3>

<strong>Typical hop</strong>: ~500 bytes (JSON)

<strong>10 hops</strong>: ~5KB total envelope size

<strong>Recommendation</strong>: Limit hops to 10-20 max to prevent payload bloat.

<h3>Serialization Performance</h3>

<pre><code class="language-csharp">// ✅ Efficient: Use JsonTypeInfo for AOT
<p>var json = JsonSerializer.Serialize(</p>
<p>    envelope,</p>
<p>    _jsonOptions.GetTypeInfo(typeof(MessageEnvelope))</p>
<p>);</p>

<p>// ❌ Slow: Reflection-based serialization</p>
<p>var json = JsonSerializer.Serialize(envelope);  // Not AOT-compatible</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/observability.md">Observability & Message Hops</a> - Architecture overview</li>
<li><a href="../core-concepts/message-context.md">Message Context</a> - MessageId, CorrelationId, CausationId</li>
</ul>
<strong>Messaging Patterns</strong>:
<ul><li><a href="outbox-pattern.md">Outbox Pattern</a> - Reliable publishing with hops</li>
<li><a href="inbox-pattern.md">Inbox Pattern</a> - Exactly-once processing with hops</li>
<li><a href="work-coordinator.md">Work Coordinator</a> - Atomic batch processing</li>
</ul>
<strong>Transports</strong>:
<ul><li><a href="../transports/azure-service-bus.md">Azure Service Bus</a> - ASB integration with hops</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-messaging-multi-instance-coordination" class="doc-section">
  <h3>multi instance coordination</h3>
  <p class="doc-path"><code>v1.0.0/messaging/multi-instance-coordination</code></p>
  <div class="doc-content">
<h1>Multi-Instance Coordination</h1>

<h2>Overview</h2>

<p>Multi-instance coordination ensures reliable, ordered message processing across multiple service instances. This document details the coordination mechanisms, decision points, and timing guarantees that enable distributed message processing.</p>

<h2>Core Coordination Mechanisms</h2>

<h3>1. Cross-Instance Stream Ordering {#cross-instance-stream-ordering}</h3>

<strong>Rule</strong>: When Instance A holds message M1 from stream S, Instance B cannot claim later messages (M2, M3, M4) from the same stream until Instance A completes or releases M1.

<strong>Why This Matters</strong>: Prevents out-of-order processing when messages from the same stream are distributed across multiple instances via partition assignment.

<h4>Sequence Diagram</h4>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant I1 as Instance 1</p>
<p>    participant DB as PostgreSQL</p>
<p>    participant I2 as Instance 2</p>

<p>    Note over DB: Stream S has messages M1, M2, M3, M4<br/>(temporal order by created_at)</p>

<p>    I1->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: Calculate partition ownership<br/>(partition % 2)</p>
<p>    DB->>DB: M1, M2 assigned to partition 0<br/>M3, M4 assigned to partition 5</p>
<p>    DB->>DB: Instance 1 owns partition 0<br/>Instance 2 owns partition 5</p>
<p>    DB-->>I1: Returns M1, M2</p>
<p>    Note over I1: I1 now holds lease on M1, M2<br/>lease_expiry = now + 5 min</p>

<p>    I2->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: Check partition ownership</p>
<p>    DB->>DB: Find M3, M4 in partition 5 (owned by I2)</p>
<p>    DB->>DB: NOT EXISTS check:<br/>SELECT 1 FROM wh_outbox earlier<br/>WHERE earlier.stream_id = M3.stream_id<br/>AND earlier.created_at < M3.created_at<br/>AND earlier.instance_id IS NOT NULL<br/>AND earlier.lease_expiry > now</p>
<p>    Note over DB: ❌ M3, M4 BLOCKED<br/>Earlier messages M1, M2 held by I1<br/>(active lease)</p>
<p>    DB-->>I2: Returns [] (empty)</p>

<p>    Note over I2: I2 cannot process M3, M4<br/>until I1 completes/releases M1, M2</p>

<p>    I1->>DB: ProcessWorkBatch(<br/>completions: [M1: Published, M2: Published])</p>
<p>    DB->>DB: Mark M1, M2 as Published</p>
<p>    DB->>DB: Delete M1, M2 (done)</p>

<p>    I2->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: NOT EXISTS check passes<br/>(no earlier messages with active leases)</p>
<p>    DB-->>I2: Returns M3, M4</p>
<p>    Note over I2: ✅ Stream ordering preserved<br/>M1, M2 completed before M3, M4 claimed</p>
<p></code></pre></p>

<strong>Decision Matrix</strong>:

<p>| Earlier Message State | Later Messages Claimable? | Reason |</p>
<p>|---|---|---|</p>
<p>| No lease (<code>instance_id = NULL</code>) | ✅ Yes | Message not claimed |</p>
<p>| Expired lease (<code>lease_expiry < now</code>) | ✅ Yes | Message orphaned |</p>
<p>| Active lease (other instance) | ❌ No | Stream ordering protection |</p>
<p>| Completed/deleted | ✅ Yes | Message finished |</p>
<p>| Scheduled for retry | ❌ No | See <a href="#scheduled-retry-blocking">Scheduled Retry Blocking</a> |</p>

<h3>2. Stale Instance Cleanup {#stale-instance-cleanup}</h3>

<strong>Rule</strong>: Instances that stop heartbeating for longer than the stale threshold (default: 10 minutes) are automatically removed, releasing their messages.

<h4>Sequence Diagram</h4>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant I1 as Instance 1</p>
<p>    participant DB as PostgreSQL</p>
<p>    participant I2 as Instance 2</p>

<p>    I1->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: UPDATE wh_service_instances<br/>SET last_heartbeat_at = now<br/>WHERE instance_id = I1</p>
<p>    DB-->>I1: WorkBatch</p>

<p>    Note over I1: Instance 1 crashes<br/>(application stopped)</p>

<p>    Note over DB: Time passes...<br/>10+ minutes (stale threshold)</p>

<p>    I2->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: DELETE FROM wh_service_instances<br/>WHERE last_heartbeat_at < now - INTERVAL '10 minutes'<br/>AND instance_id != I2</p>
<p>    DB->>DB: Release I1's messages:<br/>UPDATE wh_outbox SET instance_id=NULL, lease_expiry=NULL<br/>WHERE instance_id = I1</p>
<p>    DB->>DB: Count active instances:<br/>1 (only I2)</p>
<p>    DB->>DB: Recalculate hash distribution<br/>(all streams now owned by I2)</p>
<p>    DB->>DB: Claim orphaned messages<br/>using hash-based ownership</p>
<p>    DB-->>I2: WorkBatch (includes I1's former work)</p>

<p>    Note over I2: ✅ Instance 1 cleaned up<br/>Messages reassigned via hash<br/>Work processing continues</p>
<p></code></pre></p>

<strong>Timing Diagram</strong>:

<pre><code class="language-">Time →
<p>0s         300s        600s        610s        620s</p>
<p>│          │           │           │           │</p>
<p>I1 ━━━━━━━━━━━━━━━━━━━━┃ Crash</p>
<p>                       │</p>
<p>                       ├──── Heartbeat valid (10 min window)</p>
<p>                       │</p>
<p>                       │                       I2 calls ProcessWorkBatch</p>
<p>                       │                       │</p>
<p>                       ├─ Stale threshold ────→│</p>
<p>                       │                       │</p>
<p>                       │                       ├→ I1 deleted (CASCADE)</p>
<p>                       │                       ├→ Partitions released</p>
<p>                       │                       └→ I2 claims partitions</p>
<p></code></pre></p>

<strong>Decision Matrix</strong>:

<p>| Heartbeat Age | Instance State | Messages | Action |</p>
<p>|---|---|---|---|</p>
<p>| < 10 minutes | Active | Retained | Normal operation |</p>
<p>| > 10 minutes (same instance) | Active | Retained | Self-exception (don't delete self) |</p>
<p>| > 10 minutes (other instance) | Stale | Released | DELETE instance, release messages (instance_id=NULL) |</p>

<h3>3. New Instance Joining {#new-instance-joining}</h3>

<strong>Rule</strong>: When a new instance joins, hash distribution changes automatically. Existing messages retain their <code>instance_id</code>, while new messages follow the new hash distribution.

<h4>Sequence Diagram</h4>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant I1 as Instance 1<br/>(Active)</p>
<p>    participant DB as PostgreSQL</p>
<p>    participant I2 as Instance 2<br/>(New)</p>

<p>    Note over I1: Instance 1 processing all streams<br/>(alone, active_instance_count=1)</p>

<p>    I1->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: Heartbeat update</p>
<p>    DB-->>I1: WorkBatch (all streams)</p>

<p>    Note over I2: New Instance 2 starts</p>

<p>    I2->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: INSERT INTO wh_service_instances<br/>(I2, ServiceName, Host, PID, now)</p>
<p>    DB->>DB: Count active instances:<br/>SELECT COUNT(*) FROM wh_service_instances<br/>WHERE last_heartbeat_at >= stale_cutoff</p>
<p>    Note over DB: Result: 2 active instances</p>

<p>    DB->>DB: Hash redistribution automatic:<br/>hashtext(stream_id) % 2 determines owner<br/>~50% of streams switch to I2</p>

<p>    I2->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: Check orphaned messages<br/>with matching hash</p>
<p>    Note over DB: Existing messages keep instance_id=I1<br/>(no stealing from active instance)</p>
<p>    DB-->>I2: [] (no work yet)</p>

<p>    Note over DB: New messages arrive</p>

<p>    I1->>DB: ProcessWorkBatch(newOutboxMessages)</p>
<p>    DB->>DB: Assign instance_id based on hash:<br/>Some to I1, some to I2</p>
<p>    DB-->>I1: Messages assigned to I1</p>

<p>    I2->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: Claim messages with instance_id=I2</p>
<p>    DB-->>I2: Messages assigned to I2</p>

<p>    Note over I1,I2: Both instances process their assigned streams<br/>Hash distribution automatically balances load</p>
<p></code></pre></p>

<strong>Stream Distribution Example</strong>:

<p>| Stream ID Hash | Before (count=1) | After (count=2) | New Owner |</p>
<p>|---|---|---|---|</p>
<p>| hashtext(s1) % n | 0 (I1) | 0 (I1) | No change |</p>
<p>| hashtext(s2) % n | 0 (I1) | 1 (I2) | Redistributed |</p>
<p>| hashtext(s3) % n | 0 (I1) | 0 (I1) | No change |</p>
<p>| hashtext(s4) % n | 0 (I1) | 1 (I2) | Redistributed |</p>
<p>| ... | ... | ... | ... |</p>

<h3>4. Scheduled Retry Blocking {#scheduled-retry-blocking}</h3>

<strong>Rule</strong>: When message M1 fails and is scheduled for retry (e.g., <code>scheduled_for = now + 5 minutes</code>), all later messages in the same stream are blocked until the scheduled time passes.

<h4>Sequence Diagram</h4>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant I1 as Instance 1</p>
<p>    participant DB as PostgreSQL</p>

<p>    Note over DB: Stream S has messages M1, M2, M3<br/>(temporal order by created_at)</p>

<p>    I1->>DB: ProcessWorkBatch()</p>
<p>    DB-->>I1: M1, M2, M3</p>

<p>    I1->>I1: Process M1 → Fails</p>
<p>    I1->>DB: ProcessWorkBatch(<br/>failures: [M1: error="Network timeout"]<br/>completions: [M2: Status=0, M3: Status=0])</p>
<p>    DB->>DB: UPDATE wh_outbox<br/>SET status = status | Failed,<br/>scheduled_for = now + INTERVAL '1 minute',<br/>instance_id = NULL, lease_expiry = NULL<br/>WHERE message_id = M1</p>
<p>    DB->>DB: Release M2, M3 leases<br/>(instance_id = NULL, lease_expiry = NULL)</p>
<p>    Note over DB: M1: scheduled_for = now + 1 min<br/>M2, M3: leases cleared</p>

<p>    I1->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: Find claimable messages in owned partitions</p>
<p>    DB->>DB: Check M2:<br/>NOT EXISTS (<br/>  SELECT 1 FROM wh_outbox earlier<br/>  WHERE earlier.stream_id = M2.stream_id<br/>  AND earlier.created_at < M2.created_at<br/>  AND earlier.scheduled_for > now<br/>)</p>
<p>    Note over DB: ❌ M2 BLOCKED<br/>M1 scheduled_for = now + 1 min > now<br/>(M1 is earlier in stream)</p>
<p>    DB->>DB: Check M3: Same result (blocked)</p>
<p>    DB-->>I1: Returns [] (empty)</p>

<p>    Note over I1: Cannot process M2, M3<br/>until M1's scheduled time arrives</p>

<p>    Note over DB: Time passes (1+ minute)</p>

<p>    I1->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: Check M1:<br/>scheduled_for <= now? ✅ Yes<br/>NOT EXISTS check passes</p>
<p>    DB->>DB: Check M2, M3:<br/>NOT EXISTS check passes<br/>(M1.scheduled_for <= now)</p>
<p>    DB-->>I1: Returns M1, M2, M3</p>

<p>    Note over I1: ✅ All messages now claimable<br/>Retry M1 + process M2, M3</p>
<p></code></pre></p>

<strong>Timing Diagram</strong>:

<pre><code class="language-">Time →
<p>0s              60s             120s</p>
<p>│               │               │</p>
<p>M1 ━━━━━━━━━┃ Fail</p>
<p>           │</p>
<p>           ├→ scheduled_for = now + 60s</p>
<p>           │</p>
<p>M2, M3     ├→ Leases cleared (Status=0)</p>
<p>blocked    │</p>
<p>           │</p>
<p>           ├──── M2, M3 cannot be claimed</p>
<p>           │</p>
<p>           │               ProcessWorkBatch</p>
<p>           │               │</p>
<p>           └─ Scheduled ──→│</p>
<p>                           │</p>
<p>                           ├→ M1 claimable (scheduled_for <= now)</p>
<p>                           └→ M2, M3 claimable (no blocking)</p>
<p></code></pre></p>

<strong>Decision Matrix</strong>:

<p>| Earlier Message State | scheduled_for | Later Messages Claimable? | Reason |</p>
<p>|---|---|---|---|</p>
<p>| Failed | now + 5 min (future) | ❌ No | Scheduled retry blocks stream |</p>
<p>| Failed | now - 1 min (past) | ✅ Yes | Scheduled time passed |</p>
<p>| Failed | NULL | ✅ Yes | No schedule (poison message?) |</p>
<p>| Processing | N/A | ❌ No | Active lease blocks |</p>
<p>| Completed | N/A | ✅ Yes | Message done |</p>

<h3>5. Message Reassignment After Instance Failure {#message-reassignment}</h3>

<strong>Rule</strong>: When an instance goes stale and its messages are released, they become claimable by any instance whose hash matches the stream.

<strong>Note</strong>: This section describes the same concept as <a href="#stale-instance-cleanup">Stale Instance Cleanup</a> but focuses on message-level reassignment rather than instance-level cleanup. See also <a href="#instance-joining-hash-redistribution">Instance Joining - Hash Redistribution</a> for how new instances claim messages.

<h3>6. Lease Expiry and Orphaned Work {#lease-expiry}</h3>

<strong>Rule</strong>: Messages with expired leases (<code>lease_expiry < now</code>) can be claimed by any instance, enabling automatic recovery from instance failures.

<h4>Sequence Diagram</h4>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant I1 as Instance 1<br/>(Crashes)</p>
<p>    participant DB as PostgreSQL</p>
<p>    participant I2 as Instance 2</p>

<p>    I1->>DB: ProcessWorkBatch()</p>
<p>    DB-->>I1: M1, M2 (lease_expiry = now + 5 min)</p>

<p>    Note over I1: Instance 1 crashes mid-processing<br/>(still heartbeating, lease still valid)</p>

<p>    Note over DB: Time passes (5+ minutes)<br/>Lease expires</p>

<p>    I2->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: Find orphaned work:<br/>SELECT * FROM wh_outbox<br/>WHERE (hashtext(stream_id::TEXT) % active_count) =<br/>(hashtext(I2_id::TEXT) % active_count)<br/>AND (instance_id IS NULL<br/>     OR lease_expiry IS NULL<br/>     OR lease_expiry < now)</p>
<p>    DB->>DB: UPDATE wh_outbox<br/>SET instance_id = I2,<br/>lease_expiry = now + 5 min<br/>WHERE message_id IN (M1, M2)</p>
<p>    DB-->>I2: WorkBatch: M1, M2 (reclaimed)</p>

<p>    Note over I2: ✅ Orphaned work recovered<br/>Processing continues</p>
<p></code></pre></p>

<strong>Lease State Machine</strong>:

<pre><code class="language-">No Lease                Active Lease              Expired Lease
<p>(instance_id = NULL) →  (lease_expiry > now)  →  (lease_expiry < now)</p>
<p>                        ↓                         ↓</p>
<p>                        Processing                Orphaned (reclaimable)</p>
<p>                        ↓</p>
<p>                        Completed/Failed</p>
<p>                        (lease cleared)</p>
<p></code></pre></p>

<h3>7. Idempotency - Inbox Deduplication {#idempotency-inbox}</h3>

<strong>Rule</strong>: The <code>wh_message_deduplication</code> table permanently tracks all inbox message IDs. Duplicate messages are rejected via <code>ON CONFLICT DO NOTHING</code>.

<h4>Sequence Diagram</h4>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant T as Transport<br/>(Azure Service Bus)</p>
<p>    participant I1 as Instance 1</p>
<p>    participant DB as PostgreSQL</p>

<p>    T->>I1: Deliver message M1 (messageId: abc-123)</p>
<p>    I1->>DB: ProcessWorkBatch(<br/>newInboxMessages: [M1])</p>
<p>    DB->>DB: INSERT INTO wh_message_deduplication<br/>(message_id='abc-123', first_seen_at=now)<br/>ON CONFLICT (message_id) DO NOTHING<br/>RETURNING message_id</p>
<p>    Note over DB: ✅ Returns 'abc-123'<br/>(first time seeing this message)</p>
<p>    DB->>DB: INSERT INTO wh_inbox (message_id='abc-123', ...)</p>
<p>    DB-->>I1: WorkBatch: [M1]</p>

<p>    Note over T: Network blip causes duplicate delivery</p>

<p>    T->>I1: Deliver message M1 again (messageId: abc-123)</p>
<p>    I1->>DB: ProcessWorkBatch(<br/>newInboxMessages: [M1])</p>
<p>    DB->>DB: INSERT INTO wh_message_deduplication<br/>(message_id='abc-123', first_seen_at=now)<br/>ON CONFLICT (message_id) DO NOTHING<br/>RETURNING message_id</p>
<p>    Note over DB: ❌ Returns nothing<br/>(conflict on message_id, DO NOTHING)</p>
<p>    DB->>DB: v_new_inbox_ids = [] (empty array)</p>
<p>    DB->>DB: Skip INSERT INTO wh_inbox<br/>(message not in v_new_inbox_ids)</p>
<p>    DB-->>I1: WorkBatch: [] (empty, duplicate rejected)</p>

<p>    Note over I1: ✅ Duplicate prevented<br/>Exactly-once processing guaranteed</p>
<p></code></pre></p>

<strong>Deduplication Table</strong>:

<pre><code class="language-sql">CREATE TABLE wh_message_deduplication (
<p>  message_id UUID PRIMARY KEY,  -- Idempotency key</p>
<p>  first_seen_at TIMESTAMPTZ NOT NULL</p>
<p>);</p>

<p>-- Permanent record (never deleted)</p>
<p>-- Enables exactly-once inbox processing</p>
<p></code></pre></p>

<h3>8. Idempotency - Outbox Transactional Boundary {#idempotency-outbox}</h3>

<strong>Rule</strong>: Outbox does NOT use the deduplication table. Duplicate prevention is the caller's responsibility (transactional outbox pattern).

<h4>Diagram</h4>

<pre><code class="language-mermaid">graph TD
<p>    A[Application Transaction] -->|BEGIN| B[Business Logic]</p>
<p>    B --> C[INSERT INTO application_table]</p>
<p>    C --> D[INSERT INTO wh_outbox]</p>
<p>    D -->|COMMIT| E[Transaction Committed]</p>

<p>    E --> F[Background Worker: ProcessWorkBatch]</p>
<p>    F --> G[Publish to Transport]</p>
<p>    G --> H[Mark as Published, DELETE from wh_outbox]</p>

<p>    style A fill:#e1f5ff</p>
<p>    style D fill:#ffe1e1</p>
<p>    style E fill:#e1ffe1</p>

<p>    Note1[Outbox is part of application transaction]</p>
<p>    Note2[If transaction fails, outbox INSERT rolls back]</p>
<p>    Note3[No deduplication table needed]</p>
<p></code></pre></p>

<strong>Why No Deduplication?</strong>:
<ul><li>Outbox is part of the application's transaction boundary</li>
<li>If the same message is inserted twice, it's because the application logic called it twice</li>
<li>The application should handle deduplication (e.g., idempotent commands, unique constraints)</li>
<li>Whizbang's responsibility: Ensure at-least-once delivery (once in outbox → delivered to transport)</li>
</ul>
<h3>9. Virtual Partition Assignment (Hash-Based) {#virtual-partition-assignment}</h3>

<strong>Rule</strong>: Instance ownership is calculated algorithmically using consistent hashing on UUIDs. No partition assignments table is needed.

<strong>Formula</strong>: <code>(hashtext(stream_id::TEXT) % active_instance_count) = (hashtext(instance_id::TEXT) % active_instance_count)</code>

<h4>Sequence Diagram</h4>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant I1 as Instance 1<br/>(ID: aaa...111)</p>
<p>    participant DB as PostgreSQL</p>
<p>    participant I2 as Instance 2<br/>(ID: bbb...222)</p>

<p>    Note over DB: Stream S1 (stream_id: ccc...333)<br/>Messages M1, M2 created</p>

<p>    I1->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: Count active instances: 2</p>
<p>    DB->>DB: Hash stream_id: hashtext('ccc...333') % 2 = 0</p>
<p>    DB->>DB: Hash instance I1: hashtext('aaa...111') % 2 = 0</p>
<p>    DB->>DB: ✅ Match! (0 = 0)</p>
<p>    DB->>DB: Claim M1, M2 for I1</p>
<p>    DB-->>I1: M1, M2 (instance_id=I1, lease_expiry=now+5min)</p>

<p>    Note over I1: I1 processes M1, M2</p>

<p>    I2->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: Hash stream_id: hashtext('ccc...333') % 2 = 0</p>
<p>    DB->>DB: Hash instance I2: hashtext('bbb...222') % 2 = 1</p>
<p>    DB->>DB: ❌ No match (0 ≠ 1)</p>
<p>    DB->>DB: Cannot claim - wrong instance per hash</p>
<p>    DB-->>I2: [] (empty)</p>

<p>    Note over I2: I2 cannot claim Stream S1 messages<br/>Hash ownership belongs to I1</p>
<p></code></pre></p>

<strong>Key Properties</strong>:
<ul><li><strong>Self-contained</strong>: Depends only on UUID values, not database state</li>
<li><strong>Deterministic</strong>: Same UUIDs always produce same result</li>
<li><strong>No table lookups</strong>: Pure computation (fast)</li>
<li><strong>Automatic rebalancing</strong>: Adding instance changes modulo distribution</li>
</ul>
<h3>10. Instance Transition - Stream Splitting Across Instances {#instance-transition-stream-split}</h3>

<strong>Rule</strong>: When instances join/leave, hash distribution changes. Messages created before the change remain on original instance (via <code>instance_id</code> assignment), while new messages follow new hash distribution.

<strong>Critical Guarantee</strong>: Earlier messages MUST complete on original instance before later messages can be claimed on new instance.

<h4>Sequence Diagram</h4>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant I1 as Instance 1</p>
<p>    participant DB as PostgreSQL</p>
<p>    participant I2 as Instance 2<br/>(New)</p>

<p>    Note over DB: Stream S, active_instance_count = 1<br/>hashtext(stream_id) % 1 = 0<br/>hashtext(I1_id) % 1 = 0<br/>✅ I1 owns all streams</p>

<p>    I1->>DB: ProcessWorkBatch(newOutboxMessages: [M1, M2])</p>
<p>    DB->>DB: Store M1 (created_at=10s, instance_id=I1)</p>
<p>    DB->>DB: Store M2 (created_at=20s, instance_id=I1)</p>
<p>    DB-->>I1: M1, M2</p>

<p>    I1->>I1: Processing M1, M2...</p>

<p>    Note over I2: Instance 2 starts</p>

<p>    I2->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: Register I2, active_instance_count = 2</p>
<p>    Note over DB: Hash distribution changes!<br/>hashtext(stream_id) % 2 = 0<br/>hashtext(I1_id) % 2 = 0 ✅<br/>hashtext(I2_id) % 2 = 1 ❌<br/>Stream S still owned by I1</p>

<p>    I1->>DB: ProcessWorkBatch(newOutboxMessages: [M3])</p>
<p>    DB->>DB: Store M3 (created_at=30s)<br/>Hash: hashtext(stream_id) % 2 = 0<br/>Instance hash: hashtext(I1_id) % 2 = 0<br/>✅ Match - assign to I1</p>
<p>    DB->>DB: instance_id = I1 (preserves assignment)</p>
<p>    DB-->>I1: M3</p>

<p>    Note over DB: Time passes, hash changes<br/>(simulating redistribution)</p>

<p>    I1->>DB: ProcessWorkBatch(newOutboxMessages: [M4])</p>
<p>    DB->>DB: Store M4 (created_at=40s)<br/>Hash: hashtext(stream_id_v2) % 2 = 1<br/>Instance hash: hashtext(I2_id) % 2 = 1<br/>✅ Match - assign to I2</p>
<p>    DB->>DB: instance_id = I2 (new assignment)</p>
<p>    DB-->>I1: []</p>

<p>    I2->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: Check M4 claimability</p>
<p>    DB->>DB: NOT EXISTS check:<br/>Are there earlier messages (M1, M2, M3)<br/>still processing?</p>
<p>    Note over DB: M1, M2, M3 still held by I1<br/>(instance_id=I1, lease_expiry>now)</p>
<p>    DB->>DB: ❌ M4 BLOCKED<br/>Earlier messages M1-M3 on I1</p>
<p>    DB-->>I2: [] (empty)</p>

<p>    Note over I2: I2 cannot claim M4<br/>until I1 completes M1-M3</p>

<p>    I1->>DB: ProcessWorkBatch(<br/>completions: [M1: Published, M2: Published, M3: Published])</p>
<p>    DB->>DB: Delete M1, M2, M3 (completed)</p>

<p>    I2->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: NOT EXISTS check passes<br/>(no earlier messages with active leases)</p>
<p>    DB-->>I2: M4</p>

<p>    Note over I2: ✅ Stream ordering preserved<br/>M1-M3 completed on I1<br/>BEFORE M4 claimed by I2</p>
<p></code></pre></p>

<strong>Decision Matrix</strong>:

<p>| Earlier Messages | Later Message | Can Claim? | Reason |</p>
<p>|---|---|---|---|</p>
<p>| M1-M3 on I1 (processing) | M4 on I2 (new hash) | ❌ No | NOT EXISTS blocks |</p>
<p>| M1-M3 completed/deleted | M4 on I2 (new hash) | ✅ Yes | No blocking messages |</p>
<p>| M1-M3 on I1 (lease expired) | M4 on I2 (new hash) | ❌ No | Must reclaim M1-M3 first |</p>
<p>| M1-M3 on I1 (scheduled retry) | M4 on I2 (new hash) | ❌ No | Scheduled blocks stream |</p>

<strong>Key Guarantees</strong>:
<ul><li><strong>Time-ordered processing</strong>: M1 → M2 → M3 → M4 (by <code>created_at</code>)</li>
<li><strong>Cross-instance coordination</strong>: I1 must finish before I2 can start</li>
<li><strong>Single-processing</strong>: Each message claimed exactly once (within lease)</li>
<li><strong>Assignment preservation</strong>: <code>instance_id</code> prevents mid-processing theft</li>
</ul>
<h3>11. Instance Joining - Hash Redistribution {#instance-joining-hash-redistribution}</h3>

<strong>Rule</strong>: When new instance joins, <code>active_instance_count</code> increases, changing hash modulo distribution. Existing messages retain original <code>instance_id</code>, new messages follow new distribution.

<h4>Sequence Diagram</h4>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant I1 as Instance 1<br/>(Alone)</p>
<p>    participant DB as PostgreSQL</p>
<p>    participant I2 as Instance 2<br/>(Joins)</p>

<p>    Note over DB: Stream S1: hashtext(s1) % 1 = 0<br/>Stream S2: hashtext(s2) % 1 = 0<br/>Both owned by I1 (only instance)</p>

<p>    I1->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: active_instance_count = 1</p>
<p>    DB->>DB: All streams map to I1 (modulo 1)</p>
<p>    DB-->>I1: Messages from S1, S2</p>

<p>    Note over I2: Instance 2 starts</p>

<p>    I2->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: Register I2</p>
<p>    DB->>DB: active_instance_count = 2</p>
<p>    Note over DB: Hash redistribution!<br/>hashtext(s1) % 2 = 0 → I1<br/>hashtext(s2) % 2 = 1 → I2</p>

<p>    I2->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: Find orphaned/new messages</p>
<p>    DB->>DB: Check Stream S1 messages:<br/>hashtext(s1) % 2 = 0<br/>hashtext(I2_id) % 2 = 1<br/>❌ No match - cannot claim</p>
<p>    DB->>DB: Check Stream S2 messages:<br/>hashtext(s2) % 2 = 1<br/>hashtext(I2_id) % 2 = 1<br/>✅ Match - can claim!</p>
<p>    DB->>DB: But existing S2 messages have instance_id=I1<br/>(assigned before I2 joined)<br/>❌ Cannot steal (I1 active)</p>
<p>    DB-->>I2: [] (no work yet)</p>

<p>    Note over DB: New message arrives for Stream S2</p>

<p>    I1->>DB: ProcessWorkBatch(newInboxMessages: [M_S2_new])</p>
<p>    DB->>DB: Store M_S2_new<br/>Hash: hashtext(s2) % 2 = 1<br/>Instance hash: hashtext(I2_id) % 2 = 1<br/>✅ Assign to I2 (new distribution)</p>
<p>    DB->>DB: instance_id = I2</p>

<p>    I2->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: Find messages with instance_id=I2<br/>OR orphaned with matching hash</p>
<p>    DB-->>I2: M_S2_new (newly assigned)</p>

<p>    Note over I1,I2: I1 continues processing old S2 messages<br/>I2 processes new S2 messages<br/>Stream ordering preserved via NOT EXISTS</p>
<p></code></pre></p>

<strong>Distribution Changes</strong>:

<p>| Stream | Hash Value | Before (count=1) | After (count=2) | New Owner |</p>
<p>|---|---|---|---|---|</p>
<p>| S1 | <code>hashtext(s1) % n</code> | 0 (I1) | 0 (I1) | No change |</p>
<p>| S2 | <code>hashtext(s2) % n</code> | 0 (I1) | 1 (I2) | Redistributed |</p>
<p>| S3 | <code>hashtext(s3) % n</code> | 0 (I1) | 0 (I1) | No change |</p>
<p>| S4 | <code>hashtext(s4) % n</code> | 0 (I1) | 1 (I2) | Redistributed |</p>

<strong>Key Points</strong>:
<ul><li>~50% of streams redistribute when instance count doubles</li>
<li>Existing messages keep original <code>instance_id</code> (no stealing)</li>
<li>New messages follow new hash distribution</li>
<li>NOT EXISTS ensures ordering across transition</li>
</ul>
<h2>Testing Scenarios</h2>

<p>Each coordination mechanism has corresponding integration tests that validate the behavior under various conditions:</p>

<h3>Instance Lifecycle Tests</h3>
<ul><li><strong>Stale instance cleanup</strong> - <code>ProcessWorkBatch_StaleInstance_CleanedUpAndPartitionsReleasedAsync</code></li>
<li><strong>Lease expiry recovery</strong> - <code>ProcessWorkBatch_InstanceCrashes_MessagesReclaimedAfterLeaseExpiryAsync</code></li>
<li><strong>Active instance counting</strong> - <code>ProcessWorkBatch_MultipleActiveInstances_AllCountedInDistributionAsync</code></li>
</ul>
<h3>Partition Stability Tests</h3>
<ul><li><strong>New instance joining</strong> - <code>ProcessWorkBatch_NewInstanceJoins_DoesNotStealActivePartitionsAsync</code></li>
<li><strong>Partition reassignment rules</strong> - <code>ProcessWorkBatch_PartitionReassignment_OnlyFromStaleInstancesAsync</code></li>
<li><strong>Lease-based ownership</strong> - <code>ProcessWorkBatch_ActiveLease_PreventsCrossInstanceStealingAsync</code></li>
</ul>
<h3>Stream Ordering Tests</h3>
<ul><li><strong>Cross-instance blocking</strong> - <code>ProcessWorkBatch_CrossInstanceStreamOrdering_PreventsClaimingWhenEarlierMessagesHeldAsync</code></li>
<li><strong>Scheduled retry blocking</strong> - <code>ProcessWorkBatch_ScheduledRetry_BlocksLaterMessagesInStreamAsync</code></li>
<li><strong>Scheduled retry expiry</strong> - <code>ProcessWorkBatch_ScheduledRetryExpires_UnblocksStreamAsync</code></li>
</ul>
<h3>Idempotency Tests</h3>
<ul><li><strong>Inbox deduplication</strong> - <code>ProcessWorkBatch_DuplicateInboxMessage_DeduplicationPreventsAsync</code></li>
<li><strong>Outbox transactional</strong> - <code>ProcessWorkBatch_OutboxNoDuplication_TransactionalBoundaryAsync</code></li>
</ul>
<h2>Configuration Guidelines</h2>

<h3>Lease Duration</h3>

<p>Choose based on maximum expected processing time:</p>

<p>| Processing Time | Recommended Lease | Rationale |</p>
<p>|---|---|---|</p>
<p>| < 30 seconds | 2 minutes | Quick recovery, minimal orphaning risk |</p>
<p>| 30s - 2 minutes | 5 minutes (default) | Balanced recovery and stability |</p>
<p>| 2 - 5 minutes | 10 minutes | Long-running tasks, prioritize stability |</p>
<p>| > 5 minutes | Use lease renewal | Extend lease for long-running operations |</p>

<h3>Stale Threshold</h3>

<p>Set to accommodate temporary network issues:</p>

<p>| Environment | Recommended Threshold | Rationale |</p>
<p>|---|---|---|</p>
<p>| Development/Testing | 10 seconds | Fast feedback, quick recovery |</p>
<p>| Production (stable network) | 10 minutes (default) | Handles brief network issues |</p>
<p>| Production (unreliable network) | 20 minutes | Prevents false stale detection |</p>

<strong>Rule of Thumb</strong>: Stale threshold should be ≥ 2x lease duration

<h3>Partition Count</h3>

<p>Higher counts enable finer-grained distribution:</p>

<p>| Instance Count | Recommended Partitions | Distribution Granularity |</p>
<p>|---|---|---|</p>
<p>| 1-5 instances | 1,000 | 200-1000 partitions per instance |</p>
<p>| 5-20 instances | 10,000 (default) | 500-2000 partitions per instance |</p>
<p>| 20-100 instances | 50,000 | 500-2500 partitions per instance |</p>
<p>| 100+ instances | 100,000 | 1000+ partitions per instance |</p>

<h2>Troubleshooting Guide</h2>

<h3>Problem: Messages Stuck (Not Being Claimed)</h3>

<strong>Diagnostic Steps</strong>:

<ul><li><strong>Check instance heartbeat</strong>:</li>
</ul><p>   <pre><code class="language-sql">   SELECT instance_id, last_heartbeat_at,</p>
<p>          now() - last_heartbeat_at AS age</p>
<p>   FROM wh_service_instances;</p>
<p>   </code></pre></p>

<ul><li><strong>Check hash-based ownership</strong>:</li>
</ul><p>   <pre><code class="language-sql">   -- Verify which instance should own this stream</p>
<p>   SELECT</p>
<p>     (abs(hashtext('<stream_id>'::TEXT)) % <partition_count>) AS partition_number,</p>
<p>     (abs(hashtext('<stream_id>'::TEXT)) % <active_instance_count>) AS expected_instance_index;</p>
<p>   -- Compare with actual instance assignment on message</p>
<p>   </code></pre></p>

<ul><li><strong>Check stream ordering</strong>:</li>
</ul><p>   <pre><code class="language-sql">   SELECT message_id, created_at, instance_id, lease_expiry,</p>
<p>          scheduled_for, status</p>
<p>   FROM wh_outbox</p>
<p>   WHERE stream_id = <stream_id></p>
<p>   ORDER BY created_at;</p>
<p>   </code></pre></p>

<ul><li><strong>Check lease status</strong>:</li>
</ul><p>   <pre><code class="language-sql">   SELECT message_id, instance_id,</p>
<p>          lease_expiry,</p>
<p>          lease_expiry < now() AS is_expired</p>
<p>   FROM wh_outbox</p>
<p>   WHERE message_id = <stuck_message_id>;</p>
<p>   </code></pre></p>

<strong>Common Causes</strong>:
<ul><li>Earlier message in stream has active lease (other instance)</li>
<li>Earlier message in stream is scheduled for future retry</li>
<li>Message not in partition owned by any active instance</li>
<li>All instances stopped heartbeating (all stale)</li>
</ul>
<h3>Problem: Out-of-Order Processing</h3>

<strong>Diagnostic Steps</strong>:

<ul><li><strong>Verify stream IDs are set correctly</strong>:</li>
</ul><p>   <pre><code class="language-sql">   SELECT message_id, stream_id, created_at</p>
<p>   FROM wh_outbox</p>
<p>   ORDER BY stream_id, created_at;</p>
<p>   </code></pre></p>

<ul><li><strong>Check for lease bypass (should not happen)</strong>:</li>
</ul><p>   <pre><code class="language-sql">   -- Find messages processed out of order</p>
<p>   SELECT later.message_id AS later_msg,</p>
<p>          later.processed_at AS later_processed,</p>
<p>          earlier.message_id AS earlier_msg,</p>
<p>          earlier.processed_at AS earlier_processed</p>
<p>   FROM wh_outbox later</p>
<p>   JOIN wh_outbox earlier</p>
<p>     ON later.stream_id = earlier.stream_id</p>
<p>     AND later.created_at > earlier.created_at</p>
<p>   WHERE later.processed_at < earlier.processed_at;</p>
<p>   </code></pre></p>

<strong>Common Causes</strong>:
<ul><li>Stream IDs not set (NULL) → no ordering constraint</li>
<li>Temporal order incorrect (created_at not sequential)</li>
<li>Bug in NOT EXISTS logic (report if found!)</li>
</ul>
<h2>Related Documentation</h2>

<ul><li><a href="work-coordination.md">Work Coordination</a> - Overview and architecture</li>
<li><a href="idempotency-patterns.md">Idempotency Patterns</a> - Deduplication strategies</li>
<li><a href="failure-handling.md">Failure Handling</a> - Retry scheduling and cascades</li>
<li><a href="outbox-pattern.md">Outbox Pattern</a> - Transactional outbox implementation</li>
<li><a href="inbox-pattern.md">Inbox Pattern</a> - Deduplication and handler invocation</li>
</ul>
<h2>Implementation</h2>

<h3>PostgreSQL Function (Core Logic)</h3>

<p>See: <code>014_CreateProcessWorkBatchFunction.sql</code></p>

<strong>Key Sections</strong>:
<ul><li>Lines 114-128: Instance heartbeat and stale cleanup</li>
<li>Lines 130-149: Dynamic partition calculation</li>
<li>Lines 151-154: Partition heartbeat update</li>
<li>Lines 406-484: Partition claiming with modulo distribution</li>
<li>Lines 614-788: Orphaned work claiming with stream ordering protection</li>
</ul>
<h3>C# Coordinator</h3>

<p>See: <code>Whizbang.Data.EFCore.Postgres/EFCoreWorkCoordinator.cs</code></p>

<strong>Responsibilities</strong>:
<ul><li>Serialize work batch parameters to JSON</li>
<li>Call PostgreSQL <code>process_work_batch</code> function</li>
<li>Deserialize returned work batch</li>
<li>Map database columns to C# types</li>
</ul>
<h3>Integration Tests</h3>

<p>See: <code>Whizbang.Data.EFCore.Postgres.Tests/EFCoreWorkCoordinatorTests.cs</code></p>

<strong>Test Categories</strong>:
<ul><li>Instance lifecycle (heartbeat, stale cleanup)</li>
<li>Partition stability (scaling, reassignment)</li>
<li>Stream ordering (cross-instance, scheduled retry)</li>
<li>Idempotency (inbox deduplication, outbox transactional)</li>
<li>Failure recovery (lease expiry, orphaned work)</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-messaging-outbox-pattern" class="doc-section">
  <h3>Outbox Pattern</h3>
  <p class="doc-path"><code>v1.0.0/messaging/outbox-pattern</code></p>
  <p class="doc-description"><em>Implement reliable cross-service event publishing with the Outbox Pattern - guaranteed delivery without distributed transactions</em></p>
  <div class="doc-content">

<h1>Outbox Pattern</h1>

<p>The <strong>Outbox Pattern</strong> ensures reliable event publishing in distributed systems by storing events in a database table ("outbox") as part of the same transaction that modifies business data. A background worker then publishes events from the outbox to the message transport.</p>

<h2>Problem: Dual Writes</h2>

<strong>The Challenge</strong>: How do you atomically update a database AND publish an event to a message broker?

<h3>Naive Approach (BROKEN)</h3>

<pre><code class="language-csharp">public async Task<OrderCreated> HandleAsync(CreateOrder message, CancellationToken ct) {
<p>    // 1. Update database</p>
<p>    await _db.ExecuteAsync(</p>
<p>        "INSERT INTO orders (order_id, customer_id, total) VALUES (@OrderId, @CustomerId, @Total)",</p>
<p>        new { OrderId = orderId, message.CustomerId, Total = total }</p>
<p>    );</p>

<p>    // 2. Publish event to Azure Service Bus</p>
<p>    await _transport.PublishAsync(orderCreatedEvent);  // ❌ NOT ATOMIC!</p>

<p>    return orderCreatedEvent;</p>
<p>}</p>
<p></code></pre></p>

<strong>What can go wrong?</strong>
<ul><li>❌ Database commit succeeds, but publish fails → Event lost!</li>
<li>❌ Publish succeeds, but database commit fails → Duplicate event!</li>
<li>❌ Process crashes between the two operations → Inconsistent state!</li>
</ul>
<strong>Root Cause</strong>: You cannot have a distributed transaction across database and message broker.

<hr>

<h2>Solution: Outbox Pattern</h2>

<strong>The Fix</strong>: Store the event in the database (same transaction), then publish it later.

<pre><code class="language-">┌─────────────────────────────────────────────────┐
<p>│ Database Transaction                            │</p>
<p>│                                                 │</p>
<p>│ 1. INSERT INTO orders (...) VALUES (...)       │</p>
<p>│ 2. INSERT INTO wh_outbox (...) VALUES (...)    │  ← Event stored atomically!</p>
<p>│                                                 │</p>
<p>└─────────────────────────────────────────────────┘</p>
<p>                    ↓</p>
<p>┌─────────────────────────────────────────────────┐</p>
<p>│ Background Worker (polls outbox)                │</p>
<p>│                                                 │</p>
<p>│ 3. SELECT * FROM wh_outbox WHERE status = ...  │</p>
<p>│ 4. Publish to Azure Service Bus                │</p>
<p>│ 5. UPDATE wh_outbox SET status = 'Published'   │</p>
<p>│                                                 │</p>
<p>└─────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ <strong>Atomicity</strong>: Event stored in same transaction as business data</li>
<li>✅ <strong>Guaranteed delivery</strong>: Event will be published eventually</li>
<li>✅ <strong>No data loss</strong>: If publish fails, event remains in outbox for retry</li>
<li>✅ <strong>Idempotency</strong>: Can safely retry publishing</li>
</ul>
<hr>

<h2>Whizbang Implementation</h2>

<h3>Database Schema</h3>

<pre><code class="language-sql">CREATE TABLE wh_outbox (
<p>    message_id UUID PRIMARY KEY,</p>
<p>    correlation_id UUID NOT NULL,</p>
<p>    causation_id UUID NULL,</p>
<p>    message_type VARCHAR(500) NOT NULL,</p>
<p>    payload JSONB NOT NULL,</p>
<p>    topic VARCHAR(255) NOT NULL,</p>
<p>    stream_key VARCHAR(255) NULL,</p>
<p>    partition_number INT NOT NULL,</p>

<p>    -- Metadata</p>
<p>    metadata JSONB NULL,</p>

<p>    -- Lease-based coordination</p>
<p>    instance_id UUID NULL,</p>
<p>    lease_expiry TIMESTAMPTZ NULL,</p>

<p>    -- Status tracking</p>
<p>    status VARCHAR(50) NOT NULL DEFAULT 'Stored',</p>
<p>    attempts INT NOT NULL DEFAULT 0,</p>
<p>    last_error TEXT NULL,</p>

<p>    -- Timestamps</p>
<p>    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),</p>
<p>    published_at TIMESTAMPTZ NULL,</p>

<p>    -- Indexes for efficient querying</p>
<p>    CONSTRAINT chk_outbox_status CHECK (status IN ('Stored', 'Published', 'Failed'))</p>
<p>);</p>

<p>CREATE INDEX idx_outbox_status ON wh_outbox(status, partition_number);</p>
<p>CREATE INDEX idx_outbox_lease ON wh_outbox(instance_id, lease_expiry);</p>
<p>CREATE INDEX idx_outbox_correlation ON wh_outbox(correlation_id);</p>
<p></code></pre></p>

<strong>Key Fields</strong>:
<ul><li><strong>message_id</strong>: Unique identifier (UUIDv7)</li>
<li><strong>status</strong>: Stored → Published | Failed</li>
<li><strong>instance_id</strong>: Which worker claimed this message (lease-based coordination)</li>
<li><strong>lease_expiry</strong>: When the lease expires (prevents stuck messages)</li>
<li><strong>partition_number</strong>: Consistent hashing for work distribution</li>
</ul>
<h3>IWorkCoordinator Interface</h3>

<pre><code class="language-csharp">public interface IWorkCoordinator {
<p>    Task<WorkBatch> ProcessWorkBatchAsync(</p>
<p>        Guid instanceId,</p>
<p>        string serviceName,</p>
<p>        string hostName,</p>
<p>        int processId,</p>
<p>        Dictionary<string, JsonElement>? metadata,</p>

<p>        // Completions and failures</p>
<p>        MessageCompletion[] outboxCompletions,</p>
<p>        MessageFailure[] outboxFailures,</p>
<p>        MessageCompletion[] inboxCompletions,</p>
<p>        MessageFailure[] inboxFailures,</p>

<p>        // Event store tracking</p>
<p>        ReceptorProcessingCompletion[] receptorCompletions,</p>
<p>        ReceptorProcessingFailure[] receptorFailures,</p>
<p>        PerspectiveCheckpointCompletion[] perspectiveCompletions,</p>
<p>        PerspectiveCheckpointFailure[] perspectiveFailures,</p>

<p>        // New work to store</p>
<p>        OutboxMessage[] newOutboxMessages,</p>
<p>        InboxMessage[] newInboxMessages,</p>

<p>        // Lease renewals</p>
<p>        Guid[] renewOutboxLeaseIds,</p>
<p>        Guid[] renewInboxLeaseIds,</p>

<p>        // Configuration</p>
<p>        WorkBatchFlags flags = WorkBatchFlags.None,</p>
<p>        int partitionCount = 10000,</p>
<p>        int maxPartitionsPerInstance = 100,</p>
<p>        int leaseSeconds = 300,</p>
<p>        int staleThresholdSeconds = 600,</p>

<p>        CancellationToken cancellationToken = default</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Method</strong>: <code>ProcessWorkBatchAsync</code> handles <strong>atomic operations</strong>:
<ul><li>Delete completed messages</li>
<li>Update failed messages</li>
<li>Insert new outbox messages</li>
<li>Claim new work (via leasing)</li>
</ul>
<hr>

<h2>Storing Events in Outbox</h2>

<h3>Example: CreateOrderReceptor</h3>

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>    private readonly IWorkCoordinator _coordinator;</p>
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        // Business logic</p>
<p>        var orderId = Guid.CreateVersion7();</p>
<p>        var total = message.Items.Sum(i => i.Quantity * i.UnitPrice);</p>

<p>        var @event = new OrderCreated(</p>
<p>            OrderId: orderId,</p>
<p>            CustomerId: message.CustomerId,</p>
<p>            Items: message.Items,</p>
<p>            Total: total,</p>
<p>            CreatedAt: DateTimeOffset.UtcNow</p>
<p>        );</p>

<p>        // Store event in outbox (atomic with business data)</p>
<p>        await using var conn = _db.CreateConnection();</p>
<p>        await using var transaction = await conn.BeginTransactionAsync(ct);</p>

<p>        try {</p>
<p>            // 1. Insert business data</p>
<p>            await conn.ExecuteAsync(</p>
<p>                "INSERT INTO orders (order_id, customer_id, total, status, created_at) VALUES (@OrderId, @CustomerId, @Total, @Status, @CreatedAt)",</p>
<p>                new {</p>
<p>                    OrderId = orderId,</p>
<p>                    message.CustomerId,</p>
<p>                    Total = total,</p>
<p>                    Status = "Created",</p>
<p>                    CreatedAt = @event.CreatedAt</p>
<p>                },</p>
<p>                transaction: transaction,</p>
<p>                cancellationToken: ct</p>
<p>            );</p>

<p>            // 2. Insert event into outbox (same transaction!)</p>
<p>            await _coordinator.ProcessWorkBatchAsync(</p>
<p>                instanceId: Guid.NewGuid(),</p>
<p>                serviceName: "OrderService",</p>
<p>                hostName: Environment.MachineName,</p>
<p>                processId: Environment.ProcessId,</p>
<p>                metadata: null,</p>
<p>                outboxCompletions: [],</p>
<p>                outboxFailures: [],</p>
<p>                inboxCompletions: [],</p>
<p>                inboxFailures: [],</p>
<p>                receptorCompletions: [],</p>
<p>                receptorFailures: [],</p>
<p>                perspectiveCompletions: [],</p>
<p>                perspectiveFailures: [],</p>
<p>                newOutboxMessages: [</p>
<p>                    new OutboxMessage(</p>
<p>                        MessageId: Guid.CreateVersion7(),</p>
<p>                        CorrelationId: message.CorrelationId.Value,</p>
<p>                        CausationId: message.MessageId.Value,</p>
<p>                        MessageType: typeof(OrderCreated).FullName!,</p>
<p>                        Payload: JsonSerializer.Serialize(@event, _jsonOptions),</p>
<p>                        Topic: "orders",</p>
<p>                        StreamKey: message.CustomerId.ToString(),</p>
<p>                        PartitionKey: message.CustomerId.ToString()</p>
<p>                    )</p>
<p>                ],</p>
<p>                newInboxMessages: [],</p>
<p>                renewOutboxLeaseIds: [],</p>
<p>                renewInboxLeaseIds: [],</p>
<p>                ct: ct</p>
<p>            );</p>

<p>            await transaction.CommitAsync(ct);</p>

<p>        } catch {</p>
<p>            await transaction.RollbackAsync(ct);</p>
<p>            throw;</p>
<p>        }</p>

<p>        return @event;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Points</strong>:
<ul><li>✅ Business data and outbox insert in <strong>same transaction</strong></li>
<li>✅ If transaction fails, <strong>nothing</strong> is committed (atomicity)</li>
<li>✅ Event is stored even if network to message broker is down</li>
</ul>
<hr>

<h2>Publishing from Outbox</h2>

<h3>WorkCoordinatorPublisher Worker</h3>

<pre><code class="language-csharp">public class WorkCoordinatorPublisherWorker : BackgroundService {
<p>    private readonly IWorkCoordinator _coordinator;</p>
<p>    private readonly IMessageTransport _transport;</p>
<p>    private readonly IConfiguration _config;</p>
<p>    private readonly ILogger<WorkCoordinatorPublisherWorker> _logger;</p>

<p>    protected override async Task ExecuteAsync(CancellationToken ct) {</p>
<p>        var instanceId = Guid.NewGuid();</p>
<p>        var pollingInterval = _config.GetValue<int>("WorkCoordinatorPublisher:PollingIntervalMilliseconds", 1000);</p>

<p>        _logger.LogInformation(</p>
<p>            "WorkCoordinatorPublisher starting with instance ID {InstanceId}",</p>
<p>            instanceId</p>
<p>        );</p>

<p>        while (!ct.IsCancellationRequested) {</p>
<p>            try {</p>
<p>                // 1. Claim work from outbox</p>
<p>                var batch = await _coordinator.ProcessWorkBatchAsync(</p>
<p>                    instanceId: instanceId,</p>
<p>                    serviceName: "OrderService",</p>
<p>                    hostName: Environment.MachineName,</p>
<p>                    processId: Environment.ProcessId,</p>
<p>                    metadata: null,</p>
<p>                    outboxCompletions: [],</p>
<p>                    outboxFailures: [],</p>
<p>                    inboxCompletions: [],</p>
<p>                    inboxFailures: [],</p>
<p>                    receptorCompletions: [],</p>
<p>                    receptorFailures: [],</p>
<p>                    perspectiveCompletions: [],</p>
<p>                    perspectiveFailures: [],</p>
<p>                    newOutboxMessages: [],</p>
<p>                    newInboxMessages: [],</p>
<p>                    renewOutboxLeaseIds: [],</p>
<p>                    renewInboxLeaseIds: [],</p>
<p>                    ct: ct</p>
<p>                );</p>

<p>                // 2. Publish claimed messages</p>
<p>                var completions = new List<MessageCompletion>();</p>
<p>                var failures = new List<MessageFailure>();</p>

<p>                foreach (var msg in batch.ClaimedOutboxMessages) {</p>
<p>                    try {</p>
<p>                        await _transport.PublishAsync(</p>
<p>                            topic: msg.Topic,</p>
<p>                            messageId: msg.MessageId,</p>
<p>                            correlationId: msg.CorrelationId,</p>
<p>                            causationId: msg.CausationId,</p>
<p>                            messageType: msg.MessageType,</p>
<p>                            payload: msg.Payload,</p>
<p>                            ct: ct</p>
<p>                        );</p>

<p>                        completions.Add(new MessageCompletion(</p>
<p>                            MessageId: msg.MessageId,</p>
<p>                            Status: MessageProcessingStatus.Published</p>
<p>                        ));</p>

<p>                        _logger.LogInformation(</p>
<p>                            "Published message {MessageId} of type {MessageType} to topic {Topic}",</p>
<p>                            msg.MessageId, msg.MessageType, msg.Topic</p>
<p>                        );</p>

<p>                    } catch (Exception ex) {</p>
<p>                        _logger.LogError(</p>
<p>                            ex,</p>
<p>                            "Failed to publish message {MessageId} of type {MessageType}",</p>
<p>                            msg.MessageId, msg.MessageType</p>
<p>                        );</p>

<p>                        failures.Add(new MessageFailure(</p>
<p>                            MessageId: msg.MessageId,</p>
<p>                            Status: MessageProcessingStatus.Failed,</p>
<p>                            Error: ex.Message,</p>
<p>                            StackTrace: ex.StackTrace</p>
<p>                        ));</p>
<p>                    }</p>
<p>                }</p>

<p>                // 3. Report completions/failures back to coordinator</p>
<p>                if (completions.Count > 0 || failures.Count > 0) {</p>
<p>                    await _coordinator.ProcessWorkBatchAsync(</p>
<p>                        instanceId: instanceId,</p>
<p>                        serviceName: "OrderService",</p>
<p>                        hostName: Environment.MachineName,</p>
<p>                        processId: Environment.ProcessId,</p>
<p>                        metadata: null,</p>
<p>                        outboxCompletions: completions.ToArray(),</p>
<p>                        outboxFailures: failures.ToArray(),</p>
<p>                        inboxCompletions: [],</p>
<p>                        inboxFailures: [],</p>
<p>                        receptorCompletions: [],</p>
<p>                        receptorFailures: [],</p>
<p>                        perspectiveCompletions: [],</p>
<p>                        perspectiveFailures: [],</p>
<p>                        newOutboxMessages: [],</p>
<p>                        newInboxMessages: [],</p>
<p>                        renewOutboxLeaseIds: [],</p>
<p>                        renewInboxLeaseIds: [],</p>
<p>                        ct: ct</p>
<p>                    );</p>
<p>                }</p>

<p>            } catch (Exception ex) {</p>
<p>                _logger.LogError(ex, "Error in WorkCoordinatorPublisher");</p>
<p>            }</p>

<p>            await Task.Delay(pollingInterval, ct);</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Workflow</strong>:
<ul><li><strong>Claim work</strong>: Get messages from outbox (with lease)</li>
<li><strong>Publish</strong>: Send to Azure Service Bus</li>
<li><strong>Report</strong>: Mark as Published (success) or Failed (error)</li>
<li><strong>Retry</strong>: Failed messages remain in outbox for retry</li>
</ul>
<hr>

<h2>Lease-Based Coordination</h2>

<h3>How Leasing Works</h3>

<pre><code class="language-sql">-- Claim messages for this instance
<p>UPDATE wh_outbox</p>
<p>SET</p>
<p>    instance_id = @InstanceId,</p>
<p>    lease_expiry = NOW() + INTERVAL '5 minutes'</p>
<p>WHERE message_id IN (</p>
<p>    SELECT message_id</p>
<p>    FROM wh_outbox</p>
<p>    WHERE</p>
<p>        status = 'Stored'</p>
<p>        AND (instance_id IS NULL OR lease_expiry < NOW())  -- Available or lease expired</p>
<p>        AND partition_number IN (SELECT * FROM assigned_partitions)</p>
<p>    ORDER BY created_at</p>
<p>    LIMIT 100</p>
<p>)</p>
<p>RETURNING *;</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ <strong>Parallel processing</strong>: Multiple workers can process different partitions</li>
<li>✅ <strong>Fault tolerance</strong>: If worker crashes, lease expires and message is reclaimed</li>
<li>✅ <strong>Load balancing</strong>: Work distributed via consistent hashing (partition_number)</li>
</ul>
<h3>Configuration</h3>

<pre><code class="language-json">{
<p>  "WorkCoordinatorPublisher": {</p>
<p>    "PollingIntervalMilliseconds": 1000,</p>
<p>    "LeaseSeconds": 300,</p>
<p>    "StaleThresholdSeconds": 600,</p>
<p>    "PartitionCount": 10000,</p>
<p>    "MaxPartitionsPerInstance": 100</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Parameters</strong>:
<ul><li><code>PollingIntervalMilliseconds</code>: How often to check for new work (1000ms = 1 second)</li>
<li><code>LeaseSeconds</code>: How long a lease lasts (300s = 5 minutes)</li>
<li><code>StaleThresholdSeconds</code>: When to consider a lease stale (600s = 10 minutes)</li>
<li><code>PartitionCount</code>: Total partitions for consistent hashing (10,000)</li>
<li><code>MaxPartitionsPerInstance</code>: Max partitions per worker (100)</li>
</ul>
<hr>

<h2>Guaranteed Delivery</h2>

<h3>At-Least-Once Semantics</h3>

<p>The Outbox Pattern provides <strong>at-least-once delivery</strong>:</p>
<ul><li>✅ Event is <strong>guaranteed</strong> to be published (eventually)</li>
<li>⚠️ Event <strong>may</strong> be published multiple times (rare, but possible)</li>
</ul>
<strong>Why duplicates?</strong>
<pre><code class="language-">1. Worker publishes message to Azure Service Bus (success)
<ul><li>Worker tries to mark message as Published in database (fails due to network blip)</li>
<li>Lease expires</li>
<li>Different worker claims message</li>
<li>Worker publishes message again (duplicate!)</li>
</ul><p></code></pre></p>

<strong>Solution</strong>: Use Inbox Pattern on receiving side to detect duplicates.

<h3>Retry Strategy</h3>

<pre><code class="language-csharp">public async Task ProcessWorkBatchAsync(...) {
<p>    // Failed messages: increment attempt count, update status</p>
<p>    foreach (var failure in outboxFailures) {</p>
<p>        await conn.ExecuteAsync(</p>
<p>            """</p>
<p>            UPDATE wh_outbox</p>
<p>            SET</p>
<p>                attempts = attempts + 1,</p>
<p>                status = CASE</p>
<p>                    WHEN attempts + 1 >= 5 THEN 'Failed'  -- Max 5 attempts</p>
<p>                    ELSE 'Stored'  -- Retry</p>
<p>                END,</p>
<p>                last_error = @Error,</p>
<p>                instance_id = NULL,  -- Release lease</p>
<p>                lease_expiry = NULL</p>
<p>            WHERE message_id = @MessageId</p>
<p>            """,</p>
<p>            new { failure.MessageId, failure.Error }</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Retry Logic</strong>:
<ul><li>Attempt 1-4: Retry (status = Stored)</li>
<li>Attempt 5+: Give up (status = Failed)</li>
</ul>
<strong>Monitoring</strong>:
<pre><code class="language-sql">-- Find messages with multiple failures
<p>SELECT message_id, message_type, attempts, last_error, created_at</p>
<p>FROM wh_outbox</p>
<p>WHERE status = 'Failed'</p>
<p>ORDER BY created_at DESC;</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ Store events in <strong>same transaction</strong> as business data</li>
<li>✅ Use <strong>UUIDv7</strong> for MessageId (time-ordered, avoids index fragmentation)</li>
<li>✅ Set <strong>reasonable lease duration</strong> (5 minutes default)</li>
<li>✅ <strong>Monitor failed messages</strong> (alerts when attempts >= 5)</li>
<li>✅ Use <strong>consistent hashing</strong> (partition_number) for work distribution</li>
<li>✅ <strong>Log all publishes</strong> (correlation ID, message type, topic)</li>
<li>✅ <strong>Implement retry logic</strong> (exponential backoff, max attempts)</li>
<li>✅ <strong>Clean up old messages</strong> (archive Published messages after 30 days)</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Publish directly to transport without outbox (breaks atomicity)</li>
<li>❌ Use database locks instead of leases (doesn't scale)</li>
<li>❌ Ignore failed messages (silent data loss)</li>
<li>❌ Set lease duration too short (thrashing)</li>
<li>❌ Set lease duration too long (slow recovery from crashes)</li>
<li>❌ Store large payloads in outbox (use payload size limits)</li>
<li>❌ Skip monitoring (blind to failures)</li>
</ul>
<hr>

<h2>Monitoring & Observability</h2>

<h3>Key Metrics</h3>

<pre><code class="language-csharp">public class OutboxMetrics {
<p>    public int StoredCount { get; set; }      // Messages waiting to be published</p>
<p>    public int PublishedCount { get; set; }   // Messages successfully published</p>
<p>    public int FailedCount { get; set; }      // Messages that failed max retries</p>
<p>    public double OldestMessageAge { get; set; }  // Age of oldest Stored message (seconds)</p>
<p>    public int ActiveLeases { get; set; }     // Number of active leases</p>
<p>}</p>

<p>public async Task<OutboxMetrics> GetMetricsAsync(CancellationToken ct = default) {</p>
<p>    await using var conn = _db.CreateConnection();</p>

<p>    var metrics = await conn.QuerySingleAsync<OutboxMetrics>(</p>
<p>        """</p>
<p>        SELECT</p>
<p>            COUNT(*) FILTER (WHERE status = 'Stored') AS StoredCount,</p>
<p>            COUNT(*) FILTER (WHERE status = 'Published') AS PublishedCount,</p>
<p>            COUNT(*) FILTER (WHERE status = 'Failed') AS FailedCount,</p>
<p>            EXTRACT(EPOCH FROM (NOW() - MIN(created_at) FILTER (WHERE status = 'Stored'))) AS OldestMessageAge,</p>
<p>            COUNT(*) FILTER (WHERE instance_id IS NOT NULL AND lease_expiry > NOW()) AS ActiveLeases</p>
<p>        FROM wh_outbox</p>
<p>        """,</p>
<p>        cancellationToken: ct</p>
<p>    );</p>

<p>    return metrics;</p>
<p>}</p>
<p></code></pre></p>

<h3>Alerts</h3>

<strong>Critical Alerts</strong>:
<ul><li>🚨 <code>OldestMessageAge > 600</code> (message stuck for 10+ minutes)</li>
<li>🚨 <code>FailedCount > 0</code> (messages gave up after max retries)</li>
<li>🚨 <code>StoredCount > 10000</code> (outbox backlog growing)</li>
</ul>
<strong>Warning Alerts</strong>:
<ul><li>⚠️ <code>OldestMessageAge > 60</code> (message not published within 1 minute)</li>
<li>⚠️ <code>StoredCount > 1000</code> (outbox filling up)</li>
</ul>
<hr>

<h2>Testing</h2>

<h3>Unit Tests</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task ProcessWorkBatchAsync_NewOutboxMessage_StoresInDatabaseAsync() {</p>
<p>    // Arrange</p>
<p>    var coordinator = CreateWorkCoordinator();</p>

<p>    var outboxMsg = new OutboxMessage(</p>
<p>        MessageId: Guid.CreateVersion7(),</p>
<p>        CorrelationId: Guid.CreateVersion7(),</p>
<p>        CausationId: Guid.CreateVersion7(),</p>
<p>        MessageType: "OrderCreated",</p>
<p>        Payload: "{\"orderId\":\"123\"}",</p>
<p>        Topic: "orders",</p>
<p>        StreamKey: "customer-456",</p>
<p>        PartitionKey: "customer-456"</p>
<p>    );</p>

<p>    // Act</p>
<p>    await coordinator.ProcessWorkBatchAsync(</p>
<p>        instanceId: Guid.NewGuid(),</p>
<p>        serviceName: "OrderService",</p>
<p>        hostName: "localhost",</p>
<p>        processId: 1234,</p>
<p>        metadata: null,</p>
<p>        outboxCompletions: [],</p>
<p>        outboxFailures: [],</p>
<p>        inboxCompletions: [],</p>
<p>        inboxFailures: [],</p>
<p>        receptorCompletions: [],</p>
<p>        receptorFailures: [],</p>
<p>        perspectiveCompletions: [],</p>
<p>        perspectiveFailures: [],</p>
<p>        newOutboxMessages: [outboxMsg],</p>
<p>        newInboxMessages: [],</p>
<p>        renewOutboxLeaseIds: [],</p>
<p>        renewInboxLeaseIds: [],</p>
<p>        ct: CancellationToken.None</p>
<p>    );</p>

<p>    // Assert</p>
<p>    var stored = await _db.QuerySingleOrDefaultAsync<OutboxRow>(</p>
<p>        "SELECT * FROM wh_outbox WHERE message_id = @MessageId",</p>
<p>        new { outboxMsg.MessageId }</p>
<p>    );</p>

<p>    await Assert.That(stored).IsNotNull();</p>
<p>    await Assert.That(stored!.Status).IsEqualTo("Stored");</p>
<p>    await Assert.That(stored.MessageType).IsEqualTo("OrderCreated");</p>
<p>}</p>
<p></code></pre></p>

<h3>Integration Tests</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task WorkCoordinatorPublisher_PublishesFromOutboxAsync() {</p>
<p>    // Arrange</p>
<p>    var mockTransport = CreateMockTransport();</p>
<p>    var worker = new WorkCoordinatorPublisherWorker(_coordinator, mockTransport, _config, _logger);</p>

<p>    // Seed outbox with message</p>
<p>    await SeedOutboxAsync(new OutboxMessage(/<em> ... </em>/));</p>

<p>    // Act</p>
<p>    await worker.StartAsync(CancellationToken.None);</p>
<p>    await Task.Delay(2000);  // Let worker poll</p>
<p>    await worker.StopAsync(CancellationToken.None);</p>

<p>    // Assert</p>
<p>    await Assert.That(mockTransport.PublishedMessages).HasCount().EqualTo(1);</p>

<p>    var published = await _db.QuerySingleOrDefaultAsync<OutboxRow>(</p>
<p>        "SELECT * FROM wh_outbox WHERE message_id = @MessageId",</p>
<p>        new { MessageId = outboxMsg.MessageId }</p>
<p>    );</p>

<p>    await Assert.That(published!.Status).IsEqualTo("Published");</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/dispatcher.md">Dispatcher</a> - How to publish events</li>
<li><a href="../core-concepts/receptors.md">Receptors</a> - Message handlers</li>
</ul>
<strong>Messaging Patterns</strong>:
<ul><li><a href="inbox-pattern.md">Inbox Pattern</a> - Exactly-once message processing</li>
<li><a href="work-coordinator.md">Work Coordination</a> - IWorkCoordinator deep dive</li>
<li><a href="message-envelopes.md">Message Envelopes</a> - Hop-based observability</li>
</ul>
<strong>Examples</strong>:
<ul><li><a href="../examples/ecommerce/order-service.md">ECommerce: Order Service</a> - Real-world outbox usage</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-messaging-topic-filters" class="doc-section">
  <h3>topic filters</h3>
  <p class="doc-path"><code>v1.0.0/messaging/topic-filters</code></p>
  <div class="doc-content">
<h1>Topic Filters</h1>

<p>Topic Filters provide type-safe, compile-time routing configuration for commands in message-based architectures. They enable declarative topic assignment using attributes with support for both string literals and strongly-typed enums.</p>

<h2>Overview</h2>

<p>Topic filters allow you to declare which topics or queues your commands should be routed to without writing imperative routing code. The filter strings are extracted at compile time via source generation, enabling zero-reflection AOT-compatible routing.</p>

<h3>Characteristics</h3>

<ul><li><strong>Declarative</strong>: Define routing via attributes on command types</li>
<li><strong>Type-safe</strong>: Use enums with <code>[Description]</code> attributes for centralized topic definitions</li>
<li><strong>Compile-time</strong>: Filter extraction via Roslyn source generators (zero reflection)</li>
<li><strong>Multiple filters</strong>: Support multiple topics per command via <code>AllowMultiple = true</code></li>
<li><strong>Inheritance support</strong>: Derive custom attributes from <code>TopicFilterAttribute</code></li>
<li><strong>AOT compatible</strong>: Generated code works with Native AOT compilation</li>
</ul>
<h2>TopicFilterAttribute</h2>

<h3>String-Based Filters</h3>

<p>Use string literals for simple, ad-hoc topic assignment:</p>

<pre><code class="language-csharp">using Whizbang.Core;

<p>namespace MyApp.Commands;</p>

<p>[TopicFilter("orders.create")]</p>
<p>public record CreateOrderCommand : ICommand {</p>
<p>  public required string CustomerId { get; init; }</p>
<p>  public required OrderItem[] Items { get; init; }</p>
<p>}</p>

<p>[TopicFilter("payments.process")]</p>
<p>public record ProcessPaymentCommand : ICommand {</p>
<p>  public required Guid OrderId { get; init; }</p>
<p>  public required decimal Amount { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h3>Enum-Based Filters</h3>

<p>For centralized, type-safe topic definitions, use enums with <code>[Description]</code> attributes:</p>

<pre><code class="language-csharp">using System.ComponentModel;
<p>using Whizbang.Core;</p>

<p>namespace MyApp.Commands;</p>

<p>// Centralized topic definitions</p>
<p>public enum ServiceBusTopics {</p>
<p>  [Description("orders.created")]</p>
<p>  OrdersCreated,</p>

<p>  [Description("orders.cancelled")]</p>
<p>  OrdersCancelled,</p>

<p>  [Description("payments.processed")]</p>
<p>  PaymentsProcessed</p>
<p>}</p>

<p>// Type-safe topic assignment</p>
<p>[TopicFilter<ServiceBusTopics>(ServiceBusTopics.OrdersCreated)]</p>
<p>public record CreateOrderCommand : ICommand {</p>
<p>  public required string CustomerId { get; init; }</p>
<p>  public required OrderItem[] Items { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<strong>How it works</strong>:
<ul><li>Generator extracts <code>[Description]</code> attribute value at compile time ("orders.created")</li>
<li>Falls back to enum symbol name if no <code>[Description]</code> ("OrdersCreated")</li>
<li>No reflection or runtime lookup - 100% AOT compatible</li>
</ul>
<h3>Multiple Filters</h3>

<p>Commands can have multiple topic filters for fan-out scenarios:</p>

<pre><code class="language-csharp">// Publish to both primary and backup queues
<p>[TopicFilter("orders.primary")]</p>
<p>[TopicFilter("orders.backup")]</p>
<p>public record CreateOrderCommand : ICommand {</p>
<p>  public required string CustomerId { get; init; }</p>
<p>  public required OrderItem[] Items { get; init; }</p>
<p>}</p>

<p>// Publish to multiple event streams</p>
<p>[TopicFilter<ServiceBusTopics>(ServiceBusTopics.OrdersCreated)]</p>
<p>[TopicFilter<ServiceBusTopics>(ServiceBusTopics.Analytics)]</p>
<p>public record CreateOrderCommand : ICommand {</p>
<p>  // ...</p>
<p>}</p>
<p></code></pre></p>

<h2>Generated Registry</h2>

<p>The <code>TopicFilterGenerator</code> source generator creates an AOT-compatible registry:</p>

<pre><code class="language-csharp">// Generated code (example)
<p>namespace MyApp.Generated;</p>

<p>public static class TopicFilterRegistry {</p>
<p>  public static string[] GetTopicFilters<TCommand>() where TCommand : ICommand {</p>
<p>    if (typeof(TCommand) == typeof(global::MyApp.Commands.CreateOrderCommand)) {</p>
<p>      return new[] { "orders.created" };</p>
<p>    }</p>
<p>    if (typeof(TCommand) == typeof(global::MyApp.Commands.ProcessPaymentCommand)) {</p>
<p>      return new[] { "payments.processed" };</p>
<p>    }</p>
<p>    return Array.Empty<string>();</p>
<p>  }</p>

<p>  public static IReadOnlyDictionary<string, string[]> GetAllFilters() {</p>
<p>    return new Dictionary<string, string[]> {</p>
<p>      { "CreateOrderCommand", new[] { "orders.created" } },</p>
<p>      { "ProcessPaymentCommand", new[] { "payments.processed" } }</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Usage</h3>

<p>Query topic filters at runtime for routing decisions:</p>

<pre><code class="language-csharp">// Get filters for a specific command type
<p>var filters = TopicFilterRegistry.GetTopicFilters<CreateOrderCommand>();</p>
<p>// Returns: ["orders.created"]</p>

<p>// Get all filters (for diagnostics/tooling)</p>
<p>var allFilters = TopicFilterRegistry.GetAllFilters();</p>
<p>// Returns: Dictionary<string, string[]> of all command → filter mappings</p>
<p></code></pre></p>

<h2>Custom Derived Attributes</h2>

<p>Create domain-specific attributes by inheriting from <code>TopicFilterAttribute</code>:</p>

<pre><code class="language-csharp">using System.ComponentModel;
<p>using Whizbang.Core;</p>

<p>// RabbitMQ-specific topics</p>
<p>public enum RabbitMqTopics {</p>
<p>  [Description("orders.exchange")]</p>
<p>  OrdersExchange,</p>

<p>  [Description("payments.exchange")]</p>
<p>  PaymentsExchange</p>
<p>}</p>

<p>// Custom attribute for RabbitMQ</p>
<p>[AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]</p>
<p>public class RabbitMqTopicAttribute : TopicFilterAttribute<RabbitMqTopics> {</p>
<p>  public RabbitMqTopicAttribute(RabbitMqTopics topic) : base(topic) { }</p>
<p>}</p>

<p>// Usage: Domain-specific attribute with same functionality</p>
<p>[RabbitMqTopic(RabbitMqTopics.OrdersExchange)]</p>
<p>public record CreateOrderCommand : ICommand {</p>
<p>  // ...</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>Clear intent (attribute name indicates transport type)</li>
<li>Centralized configuration per transport</li>
<li>Type safety with transport-specific enums</li>
<li>Generator automatically recognizes derived attributes</li>
</ul>
<h2>Best Practices</h2>

<h3>1. Use Enums for Centralized Configuration</h3>

<pre><code class="language-csharp">// ✅ GOOD: Centralized, type-safe, refactor-friendly
<p>public enum Topics {</p>
<p>  [Description("orders.created")]</p>
<p>  OrdersCreated,</p>

<p>  [Description("orders.cancelled")]</p>
<p>  OrdersCancelled</p>
<p>}</p>

<p>[TopicFilter<Topics>(Topics.OrdersCreated)]</p>
<p>public record CreateOrderCommand : ICommand { }</p>

<p>// ❌ BAD: Scattered string literals, typo-prone</p>
<p>[TopicFilter("orders.created")]  // What if you typo this?</p>
<p>public record CreateOrderCommand : ICommand { }</p>

<p>[TopicFilter("orders.creted")]   // Typo! Runtime failure</p>
<p>public record ProcessOrderCommand : ICommand { }</p>
<p></code></pre></p>

<h3>2. Use Description Attributes for Production Values</h3>

<pre><code class="language-csharp">// ✅ GOOD: Description defines actual topic name
<p>public enum Topics {</p>
<p>  [Description("prod.orders.v2.created")]  // Production topic name</p>
<p>  OrdersCreated,  // Clean, readable symbol name</p>
<p>}</p>

<p>// ❌ BAD: Enum symbol must match topic (verbose, constrained)</p>
<p>public enum Topics {</p>
<p>  prod_orders_v2_created  // Forced to match topic syntax</p>
<p>}</p>
<p></code></pre></p>

<h3>3. Group Topics by Domain or Transport</h3>

<pre><code class="language-csharp">// ✅ GOOD: Organized by domain
<p>public enum OrderTopics {</p>
<p>  [Description("orders.created")]</p>
<p>  Created,</p>

<p>  [Description("orders.updated")]</p>
<p>  Updated</p>
<p>}</p>

<p>public enum PaymentTopics {</p>
<p>  [Description("payments.processed")]</p>
<p>  Processed,</p>

<p>  [Description("payments.refunded")]</p>
<p>  Refunded</p>
<p>}</p>

<p>// ❌ BAD: Single flat enum for all topics</p>
<p>public enum AllTopics {</p>
<p>  OrdersCreated,</p>
<p>  OrdersUpdated,</p>
<p>  PaymentsProcessed,</p>
<p>  PaymentsRefunded,</p>
<p>  InventoryUpdated,</p>
<p>  // ... 100 more topics</p>
<p>}</p>
<p></code></pre></p>

<h3>4. Use Multiple Filters for Fan-Out</h3>

<pre><code class="language-csharp">// ✅ GOOD: Multiple filters for legitimate fan-out
<p>[TopicFilter<Topics>(Topics.OrdersCreated)]</p>
<p>[TopicFilter<Topics>(Topics.AnalyticsStream)]</p>
<p>public record CreateOrderCommand : ICommand { }</p>

<p>// ❌ BAD: Multiple filters for unrelated concerns (code smell)</p>
<p>[TopicFilter("orders.created")]</p>
<p>[TopicFilter("payments.pending")]  // Should be separate command</p>
<p>[TopicFilter("inventory.reserve")]  // Should be separate command</p>
<p>public record CreateOrderCommand : ICommand { }</p>
<p></code></pre></p>

<h3>5. Validate Topics at Startup</h3>

<pre><code class="language-csharp">// ✅ GOOD: Validate all topics exist in your message broker
<p>public static void ValidateTopics(IServiceProvider services) {</p>
<p>  var allFilters = TopicFilterRegistry.GetAllFilters();</p>
<p>  var transport = services.GetRequiredService<ITransport>();</p>

<p>  foreach (var (command, topics) in allFilters) {</p>
<p>    foreach (var topic in topics) {</p>
<p>      if (!transport.TopicExists(topic)) {</p>
<p>        throw new InvalidOperationException(</p>
<p>          $"Command '{command}' references non-existent topic '{topic}'"</p>
<p>        );</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Integration with Transports</h2>

<p>Topic filters integrate with Whizbang's transport abstraction:</p>

<pre><code class="language-csharp">// Query filters when publishing commands
<p>public async Task PublishCommandAsync<TCommand>(TCommand command)</p>
<p>    where TCommand : ICommand {</p>

<p>  var topics = TopicFilterRegistry.GetTopicFilters<TCommand>();</p>

<p>  if (topics.Length == 0) {</p>
<p>    throw new InvalidOperationException(</p>
<p>      $"Command '{typeof(TCommand).Name}' has no topic filters"</p>
<p>    );</p>
<p>  }</p>

<p>  foreach (var topic in topics) {</p>
<p>    var destination = new TransportDestination {</p>
<p>      Topic = topic,</p>
<p>      // ... other routing metadata</p>
<p>    };</p>

<p>    await _transport.PublishAsync(command, destination);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<p>See <a href="../infrastructure/transports.md">Transports</a> for details on transport integration.</p>

<h2>Diagnostics</h2>

<p>The <code>TopicFilterGenerator</code> reports diagnostics during compilation:</p>

<h3>WHIZ022: Topic Filter Discovered (Info)</h3>

<pre><code class="language-">Info WHIZ022: Found topic filter 'orders.created' on command 'CreateOrderCommand'
<p></code></pre></p>

<p>Generated for every discovered topic filter. Useful for verifying generation.</p>

<h3>WHIZ023: Enum Filter No Description (Info)</h3>

<pre><code class="language-">Info WHIZ023: Enum value 'Topics.OrdersCreated' has no [Description] attribute. Using enum symbol name 'OrdersCreated' as filter.
<p></code></pre></p>

<p>Warns when an enum value lacks a <code>[Description]</code> attribute. The symbol name is used as fallback.</p>

<h3>WHIZ025: TopicFilter On Non-Command (Warning)</h3>

<pre><code class="language-">Warning WHIZ025: [TopicFilter] on type 'MyClass' which does not implement ICommand. Filter will be ignored.
<p></code></pre></p>

<p>Indicates you've placed <code>[TopicFilter]</code> on a type that doesn't implement <code>ICommand</code>.</p>

<h3>WHIZ026: No Topic Filters Found (Info)</h3>

<pre><code class="language-">Info WHIZ026: No [TopicFilter] attributes were found in the compilation. TopicFilterRegistry will not be generated.
<p></code></pre></p>

<p>Reports when no topic filters are found in the assembly.</p>

<h2>Example: Multi-Transport Scenario</h2>

<p>Using custom attributes for different transports:</p>

<pre><code class="language-csharp">// Azure Service Bus topics
<p>public enum ServiceBusTopics {</p>
<p>  [Description("prod-orders-v2")]</p>
<p>  Orders,</p>

<p>  [Description("prod-payments-v2")]</p>
<p>  Payments</p>
<p>}</p>

<p>[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]</p>
<p>public class ServiceBusTopicAttribute : TopicFilterAttribute<ServiceBusTopics> {</p>
<p>  public ServiceBusTopicAttribute(ServiceBusTopics topic) : base(topic) { }</p>
<p>}</p>

<p>// RabbitMQ exchanges</p>
<p>public enum RabbitMqExchanges {</p>
<p>  [Description("orders.exchange")]</p>
<p>  OrdersExchange,</p>

<p>  [Description("payments.exchange")]</p>
<p>  PaymentsExchange</p>
<p>}</p>

<p>[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]</p>
<p>public class RabbitMqExchangeAttribute : TopicFilterAttribute<RabbitMqExchanges> {</p>
<p>  public RabbitMqExchangeAttribute(RabbitMqExchanges exchange) : base(exchange) { }</p>
<p>}</p>

<p>// Command with both transport configurations</p>
<p>[ServiceBusTopic(ServiceBusTopics.Orders)]</p>
<p>[RabbitMqExchange(RabbitMqExchanges.OrdersExchange)]</p>
<p>public record CreateOrderCommand : ICommand {</p>
<p>  public required string CustomerId { get; init; }</p>
<p>  public required OrderItem[] Items { get; init; }</p>
<p>}</p>

<p>// Runtime routing logic can query both</p>
<p>var allFilters = TopicFilterRegistry.GetTopicFilters<CreateOrderCommand>();</p>
<p>// Returns: ["prod-orders-v2", "orders.exchange"]</p>
<p></code></pre></p>

<h2>Related Topics</h2>

<ul><li><a href="../source-generators/topic-filter-discovery.md">Source Generators</a> - How TopicFilterGenerator works</li>
<li><a href="commands-events.md">Commands and Events</a> - Core message types</li>
<li><a href="../infrastructure/transports.md">Transports</a> - Message transport abstraction</li>
<li><a href="message-envelopes.md">Message Envelopes</a> - Message routing and metadata</li>
</ul>
<h2>Summary</h2>

<ul><li><strong>Topic Filters</strong> provide declarative, compile-time routing configuration for commands</li>
<li><strong>String-based filters</strong> for simple scenarios, <strong>enum-based</strong> for type safety and centralization</li>
<li><strong>Multiple filters</strong> supported via <code>AllowMultiple = true</code></li>
<li><strong>Custom attributes</strong> for domain-specific or transport-specific configuration</li>
<li><strong>Source generation</strong> ensures zero-reflection, AOT-compatible code</li>
<li><strong>GetTopicFilters()</strong> queries filters at runtime for routing decisions</li>
<li><strong>Diagnostics</strong> (WHIZ022-WHIZ026) provide visibility during compilation</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-messaging-work-coordination" class="doc-section">
  <h3>work coordination</h3>
  <p class="doc-path"><code>v1.0.0/messaging/work-coordination</code></p>
  <div class="doc-content">
<h1>Work Coordination</h1>

<h2>Overview</h2>

<p>Work coordination is the foundation of Whizbang's distributed message processing architecture. It ensures reliable, ordered, and efficient message processing across multiple service instances through lease-based coordination, partition-based distribution, and stream ordering guarantees.</p>

<h2>Core Concepts</h2>

<h3>Lease-Based Coordination</h3>

<p>Messages are claimed using time-limited leases to prevent duplicate processing and enable automatic recovery from instance failures.</p>

<strong>Key Properties:</strong>
<ul><li><strong>Lease Duration</strong>: Configurable time window (default: 5 minutes) during which an instance has exclusive rights to process a message</li>
<li><strong>Lease Expiry</strong>: UTC timestamp when the lease expires</li>
<li><strong>Orphaned Work Recovery</strong>: Messages with expired leases can be reclaimed by any active instance</li>
<li><strong>Atomic Claiming</strong>: Lease acquisition happens atomically in the database via the <code>process_work_batch</code> function</li>
</ul>
<h3>Virtual Partition Distribution</h3>

<p>Work is distributed across instances using consistent hashing on UUIDv7 identifiers - <strong>no partition assignments table required</strong>.</p>

<strong>How It Works:</strong>
<ul><li>Each message's <code>stream_id</code> is hashed to determine its partition number (0-9999 by default)</li>
<li>Instance ownership calculated algorithmically: <code>hashtext(stream_id::TEXT) % active_instance_count = hashtext(instance_id::TEXT) % active_instance_count</code></li>
<li>Each message stores <code>instance_id</code> when claimed to preserve assignment</li>
<li>No <code>wh_partition_assignments</code> table - purely algorithmic</li>
</ul>
<strong>Benefits:</strong>
<ul><li><strong>Fair Distribution</strong>: Work evenly distributed via consistent hashing</li>
<li><strong>Sticky Assignment</strong>: Same stream always maps to same instance (until rebalancing)</li>
<li><strong>Automatic Rebalancing</strong>: Adding/removing instances triggers hash redistribution</li>
<li><strong>Self-Contained</strong>: No external state - assignment based on UUID properties</li>
<li><strong>Fault Tolerance</strong>: Failed instances release messages via lease expiry</li>
</ul>
<h3>Stream Ordering Guarantees</h3>

<p>Messages within the same stream are processed in strict temporal order, even across multiple instances.</p>

<strong>Ordering Rules:</strong>
<ul><li>Messages in the same stream must be processed in <code>created_at</code> (outbox) or <code>received_at</code> (inbox) order</li>
<li>If Instance A holds message M1 from stream S, Instance B cannot claim later messages M2, M3, M4 from stream S</li>
<li>Scheduled retries block all later messages in the same stream until the scheduled time passes</li>
<li>This guarantee holds across instance failures, scaling events, and partition reassignments</li>
</ul>
<h2>Architecture Components</h2>

<h3>Database Tables</h3>

<strong><code>wh_service_instances</code></strong> - Active instance registry
<ul><li>Tracks all service instances with heartbeat timestamps</li>
<li>Used to determine active instance count for virtual partition distribution</li>
<li>Stale instances (no heartbeat > threshold) are automatically removed</li>
</ul>
<strong><code>wh_outbox</code></strong> - Outbound message queue
<ul><li>Messages awaiting publication to external transports</li>
<li>Includes partition number, lease information, and processing status</li>
<li>Done when <code>Published</code> flag is set</li>
</ul>
<strong><code>wh_inbox</code></strong> - Inbound message queue
<ul><li>Messages awaiting handler invocation</li>
<li>Includes deduplication tracking via <code>wh_message_deduplication</code></li>
<li>Done when <code>EventStored</code> flag is set</li>
</ul>
<strong><code>wh_message_deduplication</code></strong> - Inbox deduplication
<ul><li>Permanent record of all inbox message IDs seen</li>
<li>Prevents duplicate processing of the same message</li>
<li>Outbox does not use this table (transactional boundary responsibility)</li>
</ul>
<h3>PostgreSQL Function</h3>

<strong><code>process_work_batch</code></strong> - Atomic work coordination
<ul><li>Single PostgreSQL function handling all coordination operations</li>
<li>Minimizes database round-trips and ensures atomicity</li>
<li>Returns claimable work in a single result set</li>
</ul>
<strong>Operations Performed:</strong>
<ul><li>Register/update instance with heartbeat</li>
<li>Clean up stale instances (expired heartbeats)</li>
<li>Mark completed/failed messages (outbox and inbox)</li>
<li>Update receptor processing and perspective checkpoints</li>
<li>Store new messages (with partition assignment)</li>
<li>Claim orphaned work (expired leases)</li>
<li>Renew leases for buffered messages</li>
<li>Return claimable work (respecting stream ordering)</li>
</ul>
<strong>Parameters:</strong>
<ul><li>Instance identification (ID, service name, host, process ID)</li>
<li>Completion/failure tracking (outbox, inbox, receptors, perspectives)</li>
<li>New messages to store</li>
<li>Lease renewal IDs</li>
<li>Configuration (lease seconds, stale threshold, partition count)</li>
</ul>
<h2>Processing Flow</h2>

<h3>Normal Operation</h3>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant App as Application</p>
<p>    participant WC as WorkCoordinator</p>
<p>    participant DB as PostgreSQL</p>
<p>    participant T as Transport</p>

<p>    App->>WC: ProcessWorkBatchAsync()</p>
<p>    WC->>DB: process_work_batch()</p>
<p>    DB->>DB: Update heartbeat</p>
<p>    DB->>DB: Claim orphaned work</p>
<p>    DB->>DB: Apply modulo distribution</p>
<p>    DB->>DB: Check stream ordering</p>
<p>    DB-->>WC: WorkBatch (claimable messages)</p>
<p>    WC-->>App: WorkBatch</p>

<p>    App->>App: Process messages</p>
<p>    App->>T: Publish to transport</p>
<p>    T-->>App: Ack</p>

<p>    App->>WC: ProcessWorkBatchAsync(completions)</p>
<p>    WC->>DB: process_work_batch(completions)</p>
<p>    DB->>DB: Mark as Published/EventStored</p>
<p>    DB->>DB: Delete completed messages</p>
<p>    DB-->>WC: WorkBatch (new work)</p>
<p>    WC-->>App: WorkBatch</p>
<p></code></pre></p>

<h3>Failure Recovery</h3>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant I1 as Instance 1</p>
<p>    participant DB as PostgreSQL</p>
<p>    participant I2 as Instance 2</p>

<p>    I1->>DB: ProcessWorkBatch()</p>
<p>    DB-->>I1: M1, M2 (lease_expiry = now + 5min)</p>

<p>    Note over I1: Instance 1 crashes<br/>(no heartbeat)</p>

<p>    Note over DB: Time passes...<br/>lease_expiry < now</p>

<p>    I2->>DB: ProcessWorkBatch()</p>
<p>    DB->>DB: Find orphaned work<br/>(lease_expiry < now)</p>
<p>    DB-->>I2: M1, M2 (reclaimed)</p>

<p>    Note over I2: ✅ Processing continues<br/>No messages lost</p>
<p></code></pre></p>

<h2>Key Features</h2>

<h3>Atomic Operations</h3>

<p>All coordination operations happen in a single database transaction:</p>
<ul><li>Heartbeat updates</li>
<li>Message completions</li>
<li>Message failures</li>
<li>New message storage</li>
<li>Lease claims</li>
<li>Work return</li>
</ul>
<p>This ensures consistency even under high concurrency and instance failures.</p>

<h3>Stale Instance Detection</h3>

<p>Instances that stop heartbeating are automatically detected and cleaned up:</p>
<ul><li><strong>Stale Threshold</strong>: Default 10 minutes (configurable)</li>
<li><strong>Heartbeat Update</strong>: Every <code>ProcessWorkBatch</code> call updates <code>last_heartbeat_at</code></li>
<li><strong>Cleanup</strong>: Stale instances deleted, their partitions released (CASCADE)</li>
</ul>
<h3>Partition Stability</h3>

<p>Partition ownership is stable across instance scaling:</p>
<ul><li><strong>New Instances</strong>: Claim only unassigned partitions or partitions from stale instances</li>
<li><strong>Active Instances</strong>: Partitions are NOT reassigned from active instances</li>
<li><strong>Modulo Distribution</strong>: Ensures fair work distribution as instances join/leave</li>
</ul>
<h3>Idempotency</h3>

<strong>Inbox</strong>: Permanent deduplication via <code>wh_message_deduplication</code> table
<ul><li>Duplicate messages are rejected via <code>ON CONFLICT DO NOTHING</code></li>
<li>Ensures exactly-once processing guarantee</li>
</ul>
<strong>Outbox</strong>: Transactional boundary responsibility
<ul><li>No deduplication table (duplicate prevention is the caller's responsibility)</li>
<li>Outbox is part of the application's transaction boundary</li>
</ul>
<h2>Configuration Options</h2>

<h3>Lease Configuration</h3>

<pre><code class="language-csharp">await coordinator.ProcessWorkBatchAsync(
<p>    instanceId,</p>
<p>    serviceName,</p>
<p>    hostName,</p>
<p>    processId,</p>
<p>    metadata,</p>
<p>    // ... other parameters</p>
<p>    leaseSeconds: 300,  // 5 minutes (default)</p>
<p>    staleThresholdSeconds: 600  // 10 minutes (default)</p>
<p>);</p>
<p></code></pre></p>

<h3>Partition Configuration</h3>

<pre><code class="language-csharp">await coordinator.ProcessWorkBatchAsync(
<p>    // ... other parameters</p>
<p>    partitionCount: 10000,  // Total partitions (default)</p>
<p>    maxPartitionsPerInstance: null  // NULL = unlimited, or set explicit limit</p>
<p>);</p>
<p></code></pre></p>

<h3>Testing Configuration</h3>

<p>For fast tests, use short lease and stale times:</p>

<pre><code class="language-csharp">await coordinator.ProcessWorkBatchAsync(
<p>    // ... other parameters</p>
<p>    leaseSeconds: 2,  // 2 seconds for fast tests</p>
<p>    staleThresholdSeconds: 10  // 10 seconds for fast tests</p>
<p>);</p>
<p></code></pre></p>

<h2>Performance Characteristics</h2>

<h3>Single Database Call</h3>

<p>All coordination operations happen in one <code>process_work_batch</code> call:</p>
<ul><li>Minimizes network round-trips</li>
<li>Reduces database connection overhead</li>
<li>Ensures atomic consistency</li>
</ul>
<h3>Efficient Querying</h3>

<p>The function uses optimized queries:</p>
<ul><li>Index-based partition lookups</li>
<li>Efficient NOT EXISTS checks for stream ordering</li>
<li>Batch operations for completions/failures</li>
</ul>
<h3>Scalability</h3>

<p>Horizontal scaling through partition distribution:</p>
<ul><li>Add instances → automatic partition redistribution</li>
<li>Remove instances → automatic partition reassignment</li>
<li>No manual coordination required</li>
</ul>
<h2>Related Documentation</h2>

<ul><li><a href="multi-instance-coordination.md">Multi-Instance Coordination</a> - Detailed scenarios and sequence diagrams</li>
<li><a href="idempotency-patterns.md">Idempotency Patterns</a> - Deduplication strategies</li>
<li><a href="failure-handling.md">Failure Handling</a> - Retry scheduling and failure cascades</li>
<li><a href="outbox-pattern.md">Outbox Pattern</a> - Transactional outbox implementation</li>
<li><a href="inbox-pattern.md">Inbox Pattern</a> - Deduplication and handler invocation</li>
</ul>
<h2>Implementation</h2>

<h3>C# Interface</h3>

<pre><code class="language-csharp">public interface IWorkCoordinator<TDbContext> where TDbContext : DbContext {
<p>    Task<WorkBatch> ProcessWorkBatchAsync(</p>
<p>        Guid instanceId,</p>
<p>        string serviceName,</p>
<p>        string hostName,</p>
<p>        int processId,</p>
<p>        Dictionary<string, JsonElement>? metadata,</p>

<p>        MessageCompletion[] outboxCompletions,</p>
<p>        MessageFailure[] outboxFailures,</p>
<p>        MessageCompletion[] inboxCompletions,</p>
<p>        MessageFailure[] inboxFailures,</p>

<p>        ReceptorProcessingCompletion[] receptorCompletions,</p>
<p>        ReceptorProcessingFailure[] receptorFailures,</p>
<p>        PerspectiveCheckpointCompletion[] perspectiveCompletions,</p>
<p>        PerspectiveCheckpointFailure[] perspectiveFailures,</p>

<p>        OutboxMessage[] newOutboxMessages,</p>
<p>        InboxMessage[] newInboxMessages,</p>

<p>        Guid[] renewOutboxLeaseIds,</p>
<p>        Guid[] renewInboxLeaseIds,</p>

<p>        WorkBatchFlags flags = WorkBatchFlags.None,</p>
<p>        int partitionCount = 10000,</p>
<p>        int? maxPartitionsPerInstance = null,</p>
<p>        int leaseSeconds = 300,</p>
<p>        int staleThresholdSeconds = 600,</p>
<p>        CancellationToken cancellationToken = default</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<h3>PostgreSQL Implementation</h3>

<p>See: <code>014_CreateProcessWorkBatchFunction.sql</code></p>

<p>The PostgreSQL function is the authoritative implementation of all coordination logic.</p>

<h2>Testing</h2>

<p>Comprehensive integration tests validate all coordination scenarios:</p>
<ul><li>Instance lifecycle (heartbeat, stale cleanup)</li>
<li>Partition stability (scaling, reassignment)</li>
<li>Stream ordering (cross-instance, scheduled retry)</li>
<li>Idempotency (inbox deduplication, outbox transactional)</li>
<li>Failure recovery (lease expiry, orphaned work)</li>
</ul>
<p>See: <code>Whizbang.Data.EFCore.Postgres.Tests/EFCoreWorkCoordinatorTests.cs</code></p>

<h2>Best Practices</h2>

<h3>Heartbeat Frequency</h3>

<p>Call <code>ProcessWorkBatchAsync</code> frequently to maintain heartbeat:</p>
<ul><li>Recommended: Every 30-60 seconds minimum</li>
<li>Ensures instances are not marked as stale</li>
<li>Enables quick partition reassignment on failures</li>
</ul>
<h3>Lease Duration</h3>

<p>Choose lease duration based on maximum processing time:</p>
<ul><li>Too short: Messages become orphaned during normal processing</li>
<li>Too long: Delayed recovery from instance failures</li>
<li>Recommended: 5 minutes (covers most processing scenarios)</li>
</ul>
<h3>Stale Threshold</h3>

<p>Set stale threshold to allow for temporary network issues:</p>
<ul><li>Should be significantly longer than lease duration</li>
<li>Recommended: 2x lease duration minimum (10 minutes for 5-minute leases)</li>
</ul>
<h3>Partition Count</h3>

<p>Higher partition counts enable finer-grained distribution:</p>
<ul><li>Default: 10,000 partitions (works well for most scenarios)</li>
<li>More partitions = more even distribution across instances</li>
<li>Trade-off: More partition assignments to track</li>
</ul>
<h2>Troubleshooting</h2>

<h3>Messages Not Being Claimed</h3>

<strong>Check:</strong>
<ul><li>Instance is heartbeating (calls <code>ProcessWorkBatchAsync</code> regularly)</li>
<li>Partition ownership (is instance assigned the message's partition?)</li>
<li>Stream ordering (is an earlier message blocking this message?)</li>
<li>Lease status (is message already claimed by another instance?)</li>
</ul>
<h3>Stale Instance Not Cleaned Up</h3>

<strong>Check:</strong>
<ul><li>Last heartbeat timestamp (<code>wh_service_instances.last_heartbeat_at</code>)</li>
<li>Stale threshold configuration (default: 10 minutes)</li>
<li>System time synchronization across instances</li>
</ul>
<h3>Partition Not Reassigning</h3>

<strong>Check:</strong>
<ul><li>Instance is actually stale (heartbeat > threshold)</li>
<li>Partition ownership (<code>wh_partition_assignments</code>)</li>
<li>Active instance count (should redistribute partitions)</li>
</ul>
<h3>Out-of-Order Processing</h3>

<strong>Check:</strong>
<ul><li>Stream ID is set correctly on all messages</li>
<li>Temporal order (created_at/received_at timestamps)</li>
<li>Cross-instance lease coordination (NOT EXISTS logic)</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-messaging-work-coordinator" class="doc-section">
  <h3>Work Coordinator</h3>
  <p class="doc-path"><code>v1.0.0/messaging/work-coordinator</code></p>
  <p class="doc-description"><em>Master the Work Coordinator - atomic batch processing for Outbox, Inbox, and event store tracking with lease-based coordination</em></p>
  <div class="doc-content">

<h1>Work Coordinator</h1>

<p>The <strong>Work Coordinator</strong> (<code>IWorkCoordinator</code>) is Whizbang's atomic batch processing engine. It handles Outbox, Inbox, and event store tracking in a single database transaction with lease-based coordination for distributed work.</p>

<h2>Overview</h2>

<p>The Work Coordinator solves a critical problem: <strong>How do you atomically coordinate multiple operations</strong> (mark messages complete, store new events, claim work) across distributed workers?</p>

<h3>What It Coordinates</h3>

<pre><code class="language-">┌─────────────────────────────────────────────────────┐
<p>│ Single Atomic Database Transaction                  │</p>
<p>│                                                     │</p>
<p>│ 1. Delete completed outbox messages                │</p>
<p>│ 2. Update failed outbox messages (retry counts)    │</p>
<p>│ 3. Insert new outbox messages                      │</p>
<p>│ 4. Delete completed inbox messages                 │</p>
<p>│ 5. Update failed inbox messages                    │</p>
<p>│ 6. Insert new inbox messages                       │</p>
<p>│ 7. Update receptor processing records              │</p>
<p>│ 8. Update perspective checkpoint records           │</p>
<p>│ 9. Claim new outbox/inbox work (via leasing)       │</p>
<p>│ 10. Return claimed work to caller                   │</p>
<p>│                                                     │</p>
<p>└─────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Key Insight</strong>: All operations <strong>succeed together or fail together</strong> (atomicity via database transaction).

<hr>

<h2>IWorkCoordinator Interface</h2>

<pre><code class="language-csharp">public interface IWorkCoordinator {
<p>    Task<WorkBatch> ProcessWorkBatchAsync(</p>
<p>        // Instance info</p>
<p>        Guid instanceId,</p>
<p>        string serviceName,</p>
<p>        string hostName,</p>
<p>        int processId,</p>
<p>        Dictionary<string, JsonElement>? metadata,</p>

<p>        // Outbox completions and failures</p>
<p>        MessageCompletion[] outboxCompletions,</p>
<p>        MessageFailure[] outboxFailures,</p>

<p>        // Inbox completions and failures</p>
<p>        MessageCompletion[] inboxCompletions,</p>
<p>        MessageFailure[] inboxFailures,</p>

<p>        // Event store tracking - Receptors</p>
<p>        ReceptorProcessingCompletion[] receptorCompletions,</p>
<p>        ReceptorProcessingFailure[] receptorFailures,</p>

<p>        // Event store tracking - Perspectives</p>
<p>        PerspectiveCheckpointCompletion[] perspectiveCompletions,</p>
<p>        PerspectiveCheckpointFailure[] perspectiveFailures,</p>

<p>        // New work to store</p>
<p>        OutboxMessage[] newOutboxMessages,</p>
<p>        InboxMessage[] newInboxMessages,</p>

<p>        // Lease renewals</p>
<p>        Guid[] renewOutboxLeaseIds,</p>
<p>        Guid[] renewInboxLeaseIds,</p>

<p>        // Configuration</p>
<p>        WorkBatchFlags flags = WorkBatchFlags.None,</p>
<p>        int partitionCount = 10000,</p>
<p>        int maxPartitionsPerInstance = 100,</p>
<p>        int leaseSeconds = 300,</p>
<p>        int staleThresholdSeconds = 600,</p>

<p>        CancellationToken cancellationToken = default</p>
<p>    );</p>
<p>}</p>
<p></code></pre></p>

<strong>Returns</strong>:
<pre><code class="language-csharp">public record WorkBatch(
<p>    OutboxMessage[] ClaimedOutboxMessages,</p>
<p>    InboxMessage[] ClaimedInboxMessages,</p>
<p>    int[] AssignedPartitions</p>
<p>);</p>
<p></code></pre></p>

<hr>

<h2>Core Concepts</h2>

<h3>Atomic Batch Processing</h3>

<strong>Pattern</strong>: Submit <strong>all changes</strong> in one call, get <strong>all results</strong> atomically.

<pre><code class="language-csharp">// Example: Order created, publish event, claim new work
<p>var batch = await _coordinator.ProcessWorkBatchAsync(</p>
<p>    instanceId: workerInstanceId,</p>
<p>    serviceName: "OrderService",</p>
<p>    hostName: Environment.MachineName,</p>
<p>    processId: Environment.ProcessId,</p>
<p>    metadata: null,</p>

<p>    // No completions/failures this time</p>
<p>    outboxCompletions: [],</p>
<p>    outboxFailures: [],</p>
<p>    inboxCompletions: [],</p>
<p>    inboxFailures: [],</p>

<p>    // Event store tracking</p>
<p>    receptorCompletions: [],</p>
<p>    receptorFailures: [],</p>
<p>    perspectiveCompletions: [],</p>
<p>    perspectiveFailures: [],</p>

<p>    // Store new OrderCreated event in outbox</p>
<p>    newOutboxMessages: [</p>
<p>        new OutboxMessage(</p>
<p>            MessageId: Guid.CreateVersion7(),</p>
<p>            CorrelationId: correlationId,</p>
<p>            CausationId: causationId,</p>
<p>            MessageType: "OrderCreated",</p>
<p>            Payload: JsonSerializer.Serialize(orderCreated),</p>
<p>            Topic: "orders",</p>
<p>            StreamKey: customerId.ToString(),</p>
<p>            PartitionKey: customerId.ToString()</p>
<p>        )</p>
<p>    ],</p>
<p>    newInboxMessages: [],</p>

<p>    // No renewals</p>
<p>    renewOutboxLeaseIds: [],</p>
<p>    renewInboxLeaseIds: [],</p>

<p>    ct: cancellationToken</p>
<p>);</p>

<p>// batch.ClaimedOutboxMessages = newly claimed work ready to publish</p>
<p></code></pre></p>

<strong>Result</strong>:
<ul><li>OrderCreated event stored in outbox</li>
<li>New outbox messages claimed for this worker</li>
<li><strong>All atomic</strong> - if database commit fails, nothing happens</li>
</ul>
<h3>Lease-Based Coordination</h3>

<strong>Problem</strong>: How do multiple workers process messages without conflicts?

<strong>Solution</strong>: <strong>Leasing</strong> - workers "claim" messages for a time period.

<pre><code class="language-sql">-- Worker A claims messages
<p>UPDATE wh_outbox</p>
<p>SET</p>
<p>    instance_id = 'worker-a',</p>
<p>    lease_expiry = NOW() + INTERVAL '5 minutes'</p>
<p>WHERE message_id IN (...)</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ <strong>Prevents duplicate processing</strong>: Only one worker holds lease</li>
<li>✅ <strong>Fault tolerance</strong>: Lease expires if worker crashes</li>
<li>✅ <strong>Scalability</strong>: Multiple workers process different partitions</li>
</ul>
<h3>Partition-Based Distribution</h3>

<strong>Problem</strong>: How do you distribute work evenly across workers?

<strong>Solution</strong>: <strong>Consistent hashing</strong> via <code>partition_number</code>.

<pre><code class="language-csharp">// Each message gets a partition number (0-9999)
<p>var partitionNumber = Math.Abs(customerId.GetHashCode()) % 10000;</p>

<p>// Worker A might handle partitions 0-999</p>
<p>// Worker B might handle partitions 1000-1999</p>
<p>// Worker C might handle partitions 2000-2999</p>
<p>// etc.</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ <strong>Even distribution</strong>: Hash function spreads messages evenly</li>
<li>✅ <strong>Deterministic</strong>: Same customer always maps to same partition</li>
<li>✅ <strong>Scalable</strong>: Add more workers, redistribute partitions</li>
</ul>
<hr>

<h2>Parameters Explained</h2>

<h3>Instance Information</h3>

<pre><code class="language-csharp">Guid instanceId,          // Unique ID for this worker instance
<p>string serviceName,       // Name of service ("OrderService")</p>
<p>string hostName,          // Machine name (Environment.MachineName)</p>
<p>int processId,            // Process ID (Environment.ProcessId)</p>
<p>Dictionary<string, JsonElement>? metadata,  // Optional metadata</p>
<p></code></pre></p>

<strong>Usage</strong>: Identifies which worker is processing messages (for observability and debugging).

<h3>Message Completions</h3>

<pre><code class="language-csharp">MessageCompletion[] outboxCompletions,
<p>MessageCompletion[] inboxCompletions,</p>

<p>public record MessageCompletion(</p>
<p>    Guid MessageId,</p>
<p>    MessageProcessingStatus Status</p>
<p>);</p>

<p>public enum MessageProcessingStatus {</p>
<p>    Stored = 1,</p>
<p>    Published = 2,</p>
<p>    Completed = 4,</p>
<p>    Failed = 8</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>: Mark messages as successfully processed (delete from outbox/inbox).

<h3>Message Failures</h3>

<pre><code class="language-csharp">MessageFailure[] outboxFailures,
<p>MessageFailure[] inboxFailures,</p>

<p>public record MessageFailure(</p>
<p>    Guid MessageId,</p>
<p>    MessageProcessingStatus Status,</p>
<p>    string Error,</p>
<p>    string? StackTrace = null</p>
<p>);</p>
<p></code></pre></p>

<strong>Usage</strong>: Mark messages as failed (increment retry count, update error).

<h3>Event Store Tracking - Receptors</h3>

<pre><code class="language-csharp">ReceptorProcessingCompletion[] receptorCompletions,
<p>ReceptorProcessingFailure[] receptorFailures,</p>

<p>public record ReceptorProcessingCompletion(</p>
<p>    Guid EventId,</p>
<p>    string ReceptorName,</p>
<p>    ReceptorProcessingStatus Status</p>
<p>);</p>

<p>public record ReceptorProcessingFailure(</p>
<p>    Guid EventId,</p>
<p>    string ReceptorName,</p>
<p>    ReceptorProcessingStatus Status,</p>
<p>    string Error</p>
<p>);</p>
<p></code></pre></p>

<strong>Purpose</strong>: Track which <strong>receptors</strong> have processed which <strong>events</strong> (log-style, many receptors per event).

<strong>Use Cases</strong>:
<ul><li>Side effects (sending emails, notifications)</li>
<li>Read model updates (non-ordered)</li>
<li>Analytics/metrics collection</li>
</ul>
<h3>Event Store Tracking - Perspectives</h3>

<pre><code class="language-csharp">PerspectiveCheckpointCompletion[] perspectiveCompletions,
<p>PerspectiveCheckpointFailure[] perspectiveFailures,</p>

<p>public record PerspectiveCheckpointCompletion(</p>
<p>    Guid StreamId,</p>
<p>    string PerspectiveName,</p>
<p>    Guid LastEventId,</p>
<p>    PerspectiveProcessingStatus Status</p>
<p>);</p>

<p>public record PerspectiveCheckpointFailure(</p>
<p>    Guid StreamId,</p>
<p>    string PerspectiveName,</p>
<p>    Guid LastEventId,</p>
<p>    PerspectiveProcessingStatus Status,</p>
<p>    string Error</p>
<p>);</p>
<p></code></pre></p>

<strong>Purpose</strong>: Track <strong>checkpoints</strong> for perspectives processing event streams (one checkpoint per stream/perspective pair).

<strong>Use Cases</strong>:
<ul><li>Read model projections (ordered events per stream)</li>
<li>Temporal queries (state as of specific event)</li>
<li>Rebuilding projections from event history</li>
</ul>
<strong>Key Difference from Receptors</strong>:
<ul><li><strong>Receptors</strong>: Many receptors can process same event independently</li>
<li><strong>Perspectives</strong>: One checkpoint per (stream_id, perspective_name) pair for ordered processing</li>
</ul>
<h3>New Messages</h3>

<pre><code class="language-csharp">OutboxMessage[] newOutboxMessages,
<p>InboxMessage[] newInboxMessages,</p>

<p>public record OutboxMessage(</p>
<p>    Guid MessageId,</p>
<p>    Guid CorrelationId,</p>
<p>    Guid CausationId,</p>
<p>    string MessageType,</p>
<p>    string Payload,  // JSON</p>
<p>    string Topic,</p>
<p>    string StreamKey,</p>
<p>    string PartitionKey</p>
<p>);</p>

<p>public record InboxMessage(</p>
<p>    Guid MessageId,</p>
<p>    Guid CorrelationId,</p>
<p>    Guid? CausationId,</p>
<p>    string MessageType,</p>
<p>    string Payload,  // JSON</p>
<p>    string SourceTopic</p>
<p>);</p>
<p></code></pre></p>

<strong>Usage</strong>: Store new events in outbox (for publishing) or inbox (for deduplication).

<h3>Lease Renewals</h3>

<pre><code class="language-csharp">Guid[] renewOutboxLeaseIds,
<p>Guid[] renewInboxLeaseIds,</p>
<p></code></pre></p>

<strong>Usage</strong>: Extend leases on messages being processed (prevents timeout during long operations).

<h3>Configuration</h3>

<pre><code class="language-csharp">WorkBatchFlags flags = WorkBatchFlags.None,
<p>int partitionCount = 10000,</p>
<p>int maxPartitionsPerInstance = 100,</p>
<p>int leaseSeconds = 300,</p>
<p>int staleThresholdSeconds = 600,</p>
<p></code></pre></p>

<strong>Flags</strong>:
<ul><li><code>None</code>: Normal operation</li>
<li><code>SkipClaim</code>: Don't claim new work (only process completions/failures)</li>
</ul>
<strong>Parameters</strong>:
<ul><li><code>partitionCount</code>: Total partitions (10,000 recommended)</li>
<li><code>maxPartitionsPerInstance</code>: Max partitions per worker (100 recommended)</li>
<li><code>leaseSeconds</code>: Lease duration (300s = 5 minutes)</li>
<li><code>staleThresholdSeconds</code>: Stale lease threshold (600s = 10 minutes)</li>
</ul>
<hr>

<h2>Common Usage Patterns</h2>

<h3>Pattern 1: Store Event in Outbox</h3>

<pre><code class="language-csharp">// Receptor creates event, stores in outbox
<p>await _coordinator.ProcessWorkBatchAsync(</p>
<p>    instanceId: instanceId,</p>
<p>    serviceName: "OrderService",</p>
<p>    hostName: Environment.MachineName,</p>
<p>    processId: Environment.ProcessId,</p>
<p>    metadata: null,</p>
<p>    outboxCompletions: [],</p>
<p>    outboxFailures: [],</p>
<p>    inboxCompletions: [],</p>
<p>    inboxFailures: [],</p>
<p>    receptorCompletions: [],</p>
<p>    receptorFailures: [],</p>
<p>    perspectiveCompletions: [],</p>
<p>    perspectiveFailures: [],</p>
<p>    newOutboxMessages: [</p>
<p>        new OutboxMessage(</p>
<p>            MessageId: Guid.CreateVersion7(),</p>
<p>            CorrelationId: command.CorrelationId.Value,</p>
<p>            CausationId: command.MessageId.Value,</p>
<p>            MessageType: typeof(OrderCreated).FullName!,</p>
<p>            Payload: JsonSerializer.Serialize(orderCreated),</p>
<p>            Topic: "orders",</p>
<p>            StreamKey: customerId.ToString(),</p>
<p>            PartitionKey: customerId.ToString()</p>
<p>        )</p>
<p>    ],</p>
<p>    newInboxMessages: [],</p>
<p>    renewOutboxLeaseIds: [],</p>
<p>    renewInboxLeaseIds: [],</p>
<p>    ct: ct</p>
<p>);</p>
<p></code></pre></p>

<h3>Pattern 2: Claim and Publish Outbox Messages</h3>

<pre><code class="language-csharp">// Background worker claims work
<p>var batch = await _coordinator.ProcessWorkBatchAsync(</p>
<p>    instanceId: workerInstanceId,</p>
<p>    serviceName: "OrderService",</p>
<p>    hostName: Environment.MachineName,</p>
<p>    processId: Environment.ProcessId,</p>
<p>    metadata: null,</p>
<p>    outboxCompletions: [],</p>
<p>    outboxFailures: [],</p>
<p>    inboxCompletions: [],</p>
<p>    inboxFailures: [],</p>
<p>    receptorCompletions: [],</p>
<p>    receptorFailures: [],</p>
<p>    perspectiveCompletions: [],</p>
<p>    perspectiveFailures: [],</p>
<p>    newOutboxMessages: [],</p>
<p>    newInboxMessages: [],</p>
<p>    renewOutboxLeaseIds: [],</p>
<p>    renewInboxLeaseIds: [],</p>
<p>    ct: ct</p>
<p>);</p>

<p>// Publish claimed messages</p>
<p>foreach (var msg in batch.ClaimedOutboxMessages) {</p>
<p>    await _transport.PublishAsync(msg.Topic, msg.MessageId, msg.Payload, ct);</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern 3: Report Completions After Publishing</h3>

<pre><code class="language-csharp">var completions = new List<MessageCompletion>();

<p>foreach (var msg in batch.ClaimedOutboxMessages) {</p>
<p>    try {</p>
<p>        await _transport.PublishAsync(msg.Topic, msg.MessageId, msg.Payload, ct);</p>

<p>        completions.Add(new MessageCompletion(</p>
<p>            MessageId: msg.MessageId,</p>
<p>            Status: MessageProcessingStatus.Published</p>
<p>        ));</p>

<p>    } catch (Exception ex) {</p>
<p>        failures.Add(new MessageFailure(</p>
<p>            MessageId: msg.MessageId,</p>
<p>            Status: MessageProcessingStatus.Failed,</p>
<p>            Error: ex.Message,</p>
<p>            StackTrace: ex.StackTrace</p>
<p>        ));</p>
<p>    }</p>
<p>}</p>

<p>// Report back to coordinator</p>
<p>await _coordinator.ProcessWorkBatchAsync(</p>
<p>    instanceId: workerInstanceId,</p>
<p>    serviceName: "OrderService",</p>
<p>    hostName: Environment.MachineName,</p>
<p>    processId: Environment.ProcessId,</p>
<p>    metadata: null,</p>
<p>    outboxCompletions: completions.ToArray(),</p>
<p>    outboxFailures: failures.ToArray(),</p>
<p>    /<em> ... </em>/,</p>
<p>    ct: ct</p>
<p>);</p>
<p></code></pre></p>

<h3>Pattern 4: Store in Inbox (Deduplication)</h3>

<pre><code class="language-csharp">// Worker receives message from Azure Service Bus
<p>try {</p>
<p>    // Store in inbox (atomic - prevents duplicate processing)</p>
<p>    await _coordinator.ProcessWorkBatchAsync(</p>
<p>        instanceId: workerInstanceId,</p>
<p>        serviceName: "InventoryWorker",</p>
<p>        hostName: Environment.MachineName,</p>
<p>        processId: Environment.ProcessId,</p>
<p>        metadata: null,</p>
<p>        outboxCompletions: [],</p>
<p>        outboxFailures: [],</p>
<p>        inboxCompletions: [],</p>
<p>        inboxFailures: [],</p>
<p>        receptorCompletions: [],</p>
<p>        receptorFailures: [],</p>
<p>        perspectiveCompletions: [],</p>
<p>        perspectiveFailures: [],</p>
<p>        newOutboxMessages: [],</p>
<p>        newInboxMessages: [</p>
<p>            new InboxMessage(</p>
<p>                MessageId: message.MessageId,</p>
<p>                CorrelationId: message.CorrelationId,</p>
<p>                CausationId: message.CausationId,</p>
<p>                MessageType: message.MessageType,</p>
<p>                Payload: message.Payload,</p>
<p>                SourceTopic: "orders"</p>
<p>            )</p>
<p>        ],</p>
<p>        renewOutboxLeaseIds: [],</p>
<p>        renewInboxLeaseIds: [],</p>
<p>        ct: ct</p>
<p>    );</p>

<p>} catch (Npgsql.PostgresException ex) when (ex.SqlState == "23505") {</p>
<p>    // Unique constraint violation = duplicate message</p>
<p>    _logger.LogWarning("Duplicate message {MessageId} detected", message.MessageId);</p>
<p>    return;  // Skip processing</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>PostgreSQL Implementation</h2>

<p>The Work Coordinator is implemented as a <strong>PostgreSQL stored procedure</strong> for optimal performance.</p>

<h3>Stored Procedure: <code>process_work_batch</code></h3>

<pre><code class="language-sql">CREATE OR REPLACE FUNCTION process_work_batch(
<p>    p_instance_id UUID,</p>
<p>    p_service_name VARCHAR(255),</p>
<p>    p_host_name VARCHAR(255),</p>
<p>    p_process_id INT,</p>
<p>    p_metadata JSONB,</p>

<p>    -- Completions and failures (JSON arrays)</p>
<p>    p_outbox_completions JSONB,</p>
<p>    p_outbox_failures JSONB,</p>
<p>    p_inbox_completions JSONB,</p>
<p>    p_inbox_failures JSONB,</p>

<p>    -- Event store tracking</p>
<p>    p_receptor_completions JSONB,</p>
<p>    p_receptor_failures JSONB,</p>
<p>    p_perspective_completions JSONB,</p>
<p>    p_perspective_failures JSONB,</p>

<p>    -- New messages</p>
<p>    p_new_outbox_messages JSONB,</p>
<p>    p_new_inbox_messages JSONB,</p>

<p>    -- Lease renewals</p>
<p>    p_renew_outbox_lease_ids JSONB,</p>
<p>    p_renew_inbox_lease_ids JSONB,</p>

<p>    -- Configuration</p>
<p>    p_partition_count INT DEFAULT 10000,</p>
<p>    p_max_partitions_per_instance INT DEFAULT 100,</p>
<p>    p_lease_seconds INT DEFAULT 300,</p>
<p>    p_stale_threshold_seconds INT DEFAULT 600</p>
<p>)</p>
<p>RETURNS TABLE (</p>
<p>    claimed_outbox_messages JSONB,</p>
<p>    claimed_inbox_messages JSONB,</p>
<p>    assigned_partitions JSONB</p>
<p>)</p>
<p>LANGUAGE plpgsql</p>
<p>AS $$</p>
<p>BEGIN</p>
<p>    -- 1. Delete completed outbox messages</p>
<p>    DELETE FROM wh_outbox</p>
<p>    WHERE message_id IN (</p>
<p>        SELECT (value->>'MessageId')::UUID</p>
<p>        FROM jsonb_array_elements(p_outbox_completions)</p>
<p>    );</p>

<p>    -- 2. Update failed outbox messages</p>
<p>    -- (increment attempts, update error, release lease)</p>

<p>    -- 3. Insert new outbox messages</p>
<p>    -- (with partition_number for consistent hashing)</p>

<p>    -- 4. Delete completed inbox messages</p>
<p>    -- 5. Update failed inbox messages</p>
<p>    -- 6. Insert new inbox messages</p>

<p>    -- 7. Update receptor processing records</p>
<p>    -- 8. Update perspective checkpoint records</p>

<p>    -- 9. Claim new outbox work (with leasing)</p>
<p>    -- 10. Claim new inbox work (with leasing)</p>

<p>    -- Return claimed work</p>
<p>    RETURN QUERY SELECT ...;</p>
<p>END;</p>
<p>$$;</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ <strong>Single database roundtrip</strong>: All operations in one call</li>
<li>✅ <strong>Atomic</strong>: Transaction semantics guarantee consistency</li>
<li>✅ <strong>Performance</strong>: Stored procedure is compiled, optimized by PostgreSQL</li>
</ul>
<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Use single transaction</strong>: All operations atomic</li>
<li>✅ <strong>Report completions promptly</strong>: Don't let leases expire</li>
<li>✅ <strong>Monitor stale leases</strong>: Alert when lease_expiry is old</li>
<li>✅ <strong>Use consistent hashing</strong>: Partition-based work distribution</li>
<li>✅ <strong>Log all operations</strong>: InstanceId, ServiceName, timestamps</li>
<li>✅ <strong>Handle failures gracefully</strong>: Increment retry counts, log errors</li>
<li>✅ <strong>Clean up old data</strong>: Archive completed messages periodically</li>
<li>✅ <strong>Configure lease duration</strong>: Balance fault tolerance vs recovery time</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Skip reporting completions (leads to duplicate work)</li>
<li>❌ Ignore failures (silent data loss)</li>
<li>❌ Use locks instead of leases (doesn't scale)</li>
<li>❌ Set lease duration too short (thrashing)</li>
<li>❌ Set lease duration too long (slow recovery from crashes)</li>
<li>❌ Process outside coordinator (breaks atomicity)</li>
<li>❌ Skip monitoring (blind to failures)</li>
</ul>
<hr>

<h2>Monitoring & Observability</h2>

<h3>Key Metrics</h3>

<pre><code class="language-csharp">public class WorkCoordinatorMetrics {
<p>    public int OutboxStoredCount { get; set; }</p>
<p>    public int OutboxPublishedCount { get; set; }</p>
<p>    public int OutboxFailedCount { get; set; }</p>
<p>    public int InboxReceivedCount { get; set; }</p>
<p>    public int InboxCompletedCount { get; set; }</p>
<p>    public int InboxFailedCount { get; set; }</p>
<p>    public int ActiveLeases { get; set; }</p>
<p>    public int StaleLeases { get; set; }</p>
<p>}</p>
<p></code></pre></p>

<h3>Alerts</h3>

<strong>Critical</strong>:
<ul><li>🚨 <code>StaleLeases > 0</code> (workers crashed or stuck)</li>
<li>🚨 <code>OutboxFailedCount > 0</code> or <code>InboxFailedCount > 0</code> (messages gave up)</li>
</ul>
<strong>Warning</strong>:
<ul><li>⚠️ <code>OutboxStoredCount > 10000</code> (backlog growing)</li>
<li>⚠️ <code>ActiveLeases > workers * maxPartitionsPerInstance</code> (too many leases)</li>
</ul>
<hr>

<h2>Further Reading</h2>

<strong>Architecture</strong>:
<ul><li><a href="../architecture/message-lifecycle.md">Message Lifecycle & Architecture</a> - <strong>Complete flow with sequence diagrams</strong> showing Commands, Events, Receptors, Perspectives, and all integration points</li>
</ul>
<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/dispatcher.md">Dispatcher</a> - Message routing</li>
<li><a href="../core-concepts/receptors.md">Receptors</a> - Message handlers and business logic</li>
<li><a href="../core-concepts/perspectives.md">Perspectives</a> - Event listeners for read models</li>
</ul>
<strong>Messaging Patterns</strong>:
<ul><li><a href="outbox-pattern.md">Outbox Pattern</a> - Reliable event publishing</li>
<li><a href="inbox-pattern.md">Inbox Pattern</a> - Exactly-once processing</li>
<li><a href="message-envelopes.md">Message Envelopes</a> - Hop-based observability</li>
</ul>
<strong>Data Access</strong>:
<ul><li><a href="../data/event-store.md">Event Store</a> - Event storage and replay</li>
</ul>
<strong>Workers</strong>:
<ul><li><a href="../workers/perspective-worker.md">Perspective Worker</a> - Uses work coordinator for checkpoint-based processing</li>
<li><a href="../workers/execution-lifecycle.md">Execution Lifecycle</a> - Startup/shutdown coordination</li>
<li><a href="../workers/database-readiness.md">Database Readiness</a> - Dependency coordination</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2025-12-21</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Migration Guide</h2>
<article id="v1-0-0-migration-guide-01-concept-mapping" class="doc-section">
  <h3>Concept Mapping</h3>
  <p class="doc-path"><code>v1.0.0/migration-guide/01-concept-mapping</code></p>
  <p class="doc-description"><em>How Marten/Wolverine concepts translate to Whizbang equivalents</em></p>
  <div class="doc-content">

<h1>Concept Mapping: Marten/Wolverine → Whizbang</h1>

<p>This guide maps concepts from the Marten/Wolverine ("Critter Stack") to their Whizbang equivalents.</p>

<h2>Core Concept Mapping Table</h2>

<p>| Marten/Wolverine | Whizbang | Key Differences |</p>
<p>|------------------|----------|-----------------|</p>
<p>| <code>IDocumentStore</code> | <code>IEventStore</code> | Stream-based, generic <code>AppendAsync<TMessage>()</code> |</p>
<p>| <code>IDocumentSession</code> | Injected via DI | No session concept; use <code>IEventStore</code> directly |</p>
<p>| <code>session.Events.Append()</code> | <code>eventStore.AppendAsync<T>(streamId, envelope)</code> | Explicit stream ID, <code>MessageEnvelope</code> wrapper |</p>
<p>| <code>IHandle<TMessage></code> | <code>IReceptor<TMessage, TResult></code> | Returns typed result, source-generator discovered |</p>
<p>| <code>IHandle<TMessage></code> (void) | <code>IReceptor<TMessage></code> | Void receptor for side-effect-only handlers |</p>
<p>| <code>[WolverineHandler]</code> | <em>No attribute needed</em> | Source generator discovers <code>IReceptor</code> implementations |</p>
<p>| <code>SingleStreamProjection<T></code> | <code>IPerspectiveFor<TModel, TEvent...></code> | Pure function <code>Apply()</code>, variadic for multiple events |</p>
<p>| <code>MultiStreamProjection<T></code> | <code>IGlobalPerspectiveFor<TModel></code> | Global perspectives for cross-stream aggregation |</p>
<p>| Async projections (daemon) | <code>PerspectiveWorker</code> | Background worker with checkpointing |</p>
<p>| <code>UseDurableOutbox()</code> | Built-in outbox via <code>IWorkCoordinator</code> | Database-backed with configurable strategies |</p>
<p>| <code>IMessageBus</code> | <code>IDispatcher</code> | Three patterns: <code>SendAsync</code>, <code>LocalInvokeAsync</code>, <code>PublishAsync</code> |</p>
<p>| <code>AddMarten()</code> | <code>services.AddWhizbang()</code> | Fluent builder pattern |</p>
<p>| <code>UseWolverine()</code> | Implicit via source generators | Receptors auto-discovered at compile time |</p>

<h2>Handler/Receptor Mapping</h2>

<h3>Wolverine Handler Patterns</h3>

<pre><code class="language-csharp">// Wolverine: Attribute-based discovery
<p>[WolverineHandler]</p>
<p>public class OrderHandler {</p>
<p>    // Sync handler</p>
<p>    public OrderCreated Handle(CreateOrder command) {</p>
<p>        return new OrderCreated(command.OrderId);</p>
<p>    }</p>

<p>    // Async handler</p>
<p>    public async Task<OrderShipped> HandleAsync(ShipOrder command) {</p>
<p>        return new OrderShipped(command.OrderId);</p>
<p>    }</p>

<p>    // Cascading via tuple return</p>
<p>    public (OrderCreated, SendEmail) Handle(CreateOrderWithNotification command) {</p>
<p>        return (</p>
<p>            new OrderCreated(command.OrderId),</p>
<p>            new SendEmail(command.CustomerEmail)</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Whizbang Receptor Equivalents</h3>

<pre><code class="language-csharp">// Whizbang: Interface-based discovery (no attributes)
<p>public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    public ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken ct = default) {</p>
<p>        return ValueTask.FromResult(new OrderCreated(message.OrderId));</p>
<p>    }</p>
<p>}</p>

<p>public class ShipOrderReceptor : IReceptor<ShipOrder, OrderShipped> {</p>
<p>    public async ValueTask<OrderShipped> HandleAsync(</p>
<p>        ShipOrder message,</p>
<p>        CancellationToken ct = default) {</p>
<p>        // Async operations here</p>
<p>        return new OrderShipped(message.OrderId);</p>
<p>    }</p>
<p>}</p>

<p>// Cascading: Use dispatcher to publish additional messages</p>
<p>public class CreateOrderWithNotificationReceptor : IReceptor<CreateOrderWithNotification, OrderCreated> {</p>
<p>    private readonly IDispatcher _dispatcher;</p>

<p>    public CreateOrderWithNotificationReceptor(IDispatcher dispatcher) {</p>
<p>        _dispatcher = dispatcher;</p>
<p>    }</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrderWithNotification message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        var result = new OrderCreated(message.OrderId);</p>
<p>        await _dispatcher.PublishAsync(new SendEmail(message.CustomerEmail), ct);</p>
<p>        return result;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Projection/Perspective Mapping</h2>

<h3>Marten Single-Stream Projection</h3>

<pre><code class="language-csharp">// Marten: Can mutate, can have side effects
<p>public class OrderSummaryProjection : SingleStreamProjection<OrderSummary> {</p>
<p>    public OrderSummary Create(OrderCreated @event) {</p>
<p>        return new OrderSummary {</p>
<p>            Id = @event.OrderId,</p>
<p>            Status = OrderStatus.Created,</p>
<p>            Total = @event.Total</p>
<p>        };</p>
<p>    }</p>

<p>    public void Apply(OrderShipped @event, OrderSummary model) {</p>
<p>        model.Status = OrderStatus.Shipped;  // Mutation!</p>
<p>        model.ShippedAt = @event.Timestamp;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Whizbang Perspective Equivalent</h3>

<pre><code class="language-csharp">// Whizbang: Pure functions, returns new model
<p>public class OrderSummaryPerspective :</p>
<p>    IPerspectiveFor<OrderSummary, OrderCreated, OrderShipped> {</p>

<p>    public OrderSummary Apply(OrderSummary current, OrderCreated @event) {</p>
<p>        return new OrderSummary {</p>
<p>            Id = @event.OrderId,</p>
<p>            Status = OrderStatus.Created,</p>
<p>            Total = @event.Total</p>
<p>        };</p>
<p>    }</p>

<p>    public OrderSummary Apply(OrderSummary current, OrderShipped @event) {</p>
<p>        return current with {</p>
<p>            Status = OrderStatus.Shipped,</p>
<p>            ShippedAt = @event.Timestamp</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Event Store Mapping</h2>

<h3>Marten Event Store</h3>

<pre><code class="language-csharp">// Marten: Session-based
<p>public class OrderService {</p>
<p>    private readonly IDocumentStore _store;</p>

<p>    public async Task CreateOrderAsync(CreateOrder command) {</p>
<p>        await using var session = _store.LightweightSession();</p>

<p>        var @event = new OrderCreated(command.OrderId, command.Items);</p>
<p>        session.Events.Append(command.OrderId, @event);</p>

<p>        await session.SaveChangesAsync();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Whizbang Event Store</h3>

<pre><code class="language-csharp">// Whizbang: Direct injection, explicit envelope
<p>public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    private readonly IEventStore _eventStore;</p>

<p>    public CreateOrderReceptor(IEventStore eventStore) {</p>
<p>        _eventStore = eventStore;</p>
<p>    }</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        var @event = new OrderCreated(message.OrderId, message.Items);</p>

<p>        var envelope = new MessageEnvelope<OrderCreated> {</p>
<p>            MessageId = MessageId.From(Guid.CreateVersion7()),</p>
<p>            Payload = @event</p>
<p>        };</p>

<p>        await _eventStore.AppendAsync(message.OrderId, envelope, ct);</p>
<p>        return @event;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Transport Mapping</h2>

<p>| Wolverine Transport | Whizbang Transport | Package |</p>
<p>|---------------------|--------------------|---------|</p>
<p>| <code>Wolverine.RabbitMQ</code> | <code>Whizbang.Transports.RabbitMQ</code> | <code>AddRabbitMQTransport()</code> |</p>
<p>| <code>Wolverine.AzureServiceBus</code> | <code>Whizbang.Transports.AzureServiceBus</code> | <code>AddAzureServiceBusTransport()</code> |</p>
<p>| <code>Wolverine.Kafka</code> | <em>Not yet available</em> | Planned |</p>

<h2>Dispatch Pattern Mapping</h2>

<h3>Wolverine Message Bus</h3>

<pre><code class="language-csharp">// Wolverine: Single pattern
<p>await _bus.SendAsync(command);</p>
<p>await _bus.PublishAsync(@event);</p>
<p>await _bus.InvokeAsync<OrderCreated>(command);</p>
<p></code></pre></p>

<h3>Whizbang Dispatcher</h3>

<pre><code class="language-csharp">// Whizbang: Three distinct patterns
<p>// 1. SendAsync - Command with delivery receipt (can go over wire)</p>
<p>var receipt = await _dispatcher.SendAsync(command);</p>

<p>// 2. LocalInvokeAsync - In-process RPC (< 20ns, zero allocation)</p>
<p>var result = await _dispatcher.LocalInvokeAsync<CreateOrder, OrderCreated>(command);</p>

<p>// 3. PublishAsync - Event broadcasting (fire-and-forget)</p>
<p>await _dispatcher.PublishAsync(@event);</p>
<p></code></pre></p>

<h2>Key Differences Summary</h2>

<ul><li><strong>Discovery</strong>: Wolverine uses attributes; Whizbang uses interfaces (source-generated)</li>
<li><strong>Projections</strong>: Marten allows mutation; Whizbang requires pure functions</li>
<li><strong>Sessions</strong>: Marten uses document sessions; Whizbang uses direct event store</li>
<li><strong>Dispatch</strong>: Wolverine has unified bus; Whizbang has three specialized patterns</li>
<li><strong>AOT</strong>: Wolverine has partial support; Whizbang is AOT-native</li>
</ul>
<hr>

<em>Next: <a href="02-project-setup.md">Project Setup</a></em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-migration-guide-02-project-setup" class="doc-section">
  <h3>Project Setup</h3>
  <p class="doc-path"><code>v1.0.0/migration-guide/02-project-setup</code></p>
  <p class="doc-description"><em>NuGet packages and initial configuration for migrating to Whizbang</em></p>
  <div class="doc-content">

<h1>Project Setup for Migration</h1>

<p>This guide covers the NuGet package changes and initial configuration needed when migrating from Marten/Wolverine to Whizbang.</p>

<h2>Package Changes</h2>

<h3>Remove Marten/Wolverine Packages</h3>

<p>Remove these packages from your <code>.csproj</code> files:</p>

<pre><code class="language-xml"><!-- REMOVE THESE -->
<p><PackageReference Include="Marten" Version="x.x.x" /></p>
<p><PackageReference Include="Marten.AspNetCore" Version="x.x.x" /></p>
<p><PackageReference Include="Marten.Events.Projections" Version="x.x.x" /></p>
<p><PackageReference Include="Wolverine" Version="x.x.x" /></p>
<p><PackageReference Include="Wolverine.Marten" Version="x.x.x" /></p>
<p><PackageReference Include="WolverineFx.RabbitMQ" Version="x.x.x" /></p>
<p><PackageReference Include="WolverineFx.AzureServiceBus" Version="x.x.x" /></p>
<p><PackageReference Include="WolverineFx.Kafka" Version="x.x.x" /></p>
<p></code></pre></p>

<h3>Add Whizbang Packages</h3>

<p>Add the Whizbang packages from NuGet.org:</p>

<pre><code class="language-xml"><ItemGroup>
<p>  <!-- Core Whizbang --></p>
<p>  <PackageReference Include="Whizbang.Core" Version="0.1.0" /></p>
<p>  <PackageReference Include="Whizbang.Generators" Version="0.1.0"</p>
<p>                    OutputItemType="Analyzer"</p>
<p>                    ReferenceOutputAssembly="false" /></p>

<p>  <!-- Data Layer (choose based on your preference) --></p>
<p>  <!-- Option A: EF Core (recommended for complex queries) --></p>
<p>  <PackageReference Include="Whizbang.Data.EFCore.Postgres" Version="0.1.0" /></p>

<p>  <!-- Option B: Dapper (recommended for performance) --></p>
<p>  <PackageReference Include="Whizbang.Data.Dapper.Postgres" Version="0.1.0" /></p>

<p>  <!-- Transports (include both for environment switching) --></p>
<p>  <PackageReference Include="Whizbang.Transports.RabbitMQ" Version="0.1.0" /></p>
<p>  <PackageReference Include="Whizbang.Transports.AzureServiceBus" Version="0.1.0" /></p>

<p>  <!-- Testing (for test projects) --></p>
<p>  <PackageReference Include="Whizbang.Testing" Version="0.1.0" /></p>
<p></ItemGroup></p>
<p></code></pre></p>

<h2>Configuration Changes</h2>

<h3>Program.cs Migration</h3>

<strong>Before (Marten/Wolverine)</strong>:

<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);

<p>// Marten configuration</p>
<p>builder.Services.AddMarten(opts => {</p>
<p>    opts.Connection(builder.Configuration.GetConnectionString("postgres")!);</p>
<p>    opts.Events.TenancyStyle = TenancyStyle.Conjoined;</p>
<p>    opts.Events.AppendMode = EventAppendMode.Quick;</p>
<p>})</p>
<p>.IntegrateWithWolverine()</p>
<p>.AddAsyncDaemon(DaemonMode.HotCold);</p>

<p>// Wolverine configuration</p>
<p>builder.Host.UseWolverine(opts => {</p>
<p>    opts.UseRabbitMq(builder.Configuration.GetConnectionString("rabbitmq")!)</p>
<p>        .UseConventionalRouting()</p>
<p>        .UseDurableOutbox();</p>
<p>});</p>

<p>var app = builder.Build();</p>
<p></code></pre></p>

<strong>After (Whizbang)</strong>:

<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);

<p>// Whizbang configuration</p>
<p>builder.Services.AddWhizbang(options => {</p>
<p>    // Database configuration</p>
<p>    options.UsePostgres(builder.Configuration.GetConnectionString("postgres")!);</p>

<p>    // Or for EF Core:</p>
<p>    // options.UseEFCore<AppDbContext>();</p>
<p>});</p>

<p>// Transport configuration (environment-based switching)</p>
<p>var useRabbitMQ = builder.Configuration.GetValue<bool>("UseRabbitMQ");</p>

<p>if (useRabbitMQ) {</p>
<p>    // Local development with Aspire</p>
<p>    builder.Services.AddRabbitMQTransport(</p>
<p>        builder.Configuration.GetConnectionString("rabbitmq")!,</p>
<p>        options => {</p>
<p>            options.DefaultExchange = "whizbang.events";</p>
<p>        });</p>
<p>} else {</p>
<p>    // Production with Azure Service Bus</p>
<p>    builder.Services.AddAzureServiceBusTransport(</p>
<p>        builder.Configuration.GetConnectionString("servicebus")!,</p>
<p>        options => {</p>
<p>            options.DefaultTopicName = "whizbang-events";</p>
<p>        });</p>
<p>}</p>

<p>var app = builder.Build();</p>
<p></code></pre></p>

<h3>AppSettings Configuration</h3>

<strong>appsettings.Development.json</strong> (for local Aspire development):

<pre><code class="language-json">{
<p>  "UseRabbitMQ": true,</p>
<p>  "ConnectionStrings": {</p>
<p>    "postgres": "Host=localhost;Database=myapp;Username=postgres;Password=postgres",</p>
<p>    "rabbitmq": "amqp://guest:guest@localhost:5672"</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>appsettings.Production.json</strong> (for Azure deployment):

<pre><code class="language-json">{
<p>  "UseRabbitMQ": false,</p>
<p>  "ConnectionStrings": {</p>
<p>    "postgres": "Host=myapp.postgres.database.azure.com;Database=myapp;...",</p>
<p>    "servicebus": "Endpoint=sb://myapp.servicebus.windows.net/;..."</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Database Schema</h2>

<h3>Initialize Whizbang Schema</h3>

<p>Whizbang uses a different database schema than Marten. Initialize it on startup:</p>

<pre><code class="language-csharp">var app = builder.Build();

<p>// Initialize Whizbang schema</p>
<p>using (var scope = app.Services.CreateScope()) {</p>
<p>    var schemaInitializer = scope.ServiceProvider.GetRequiredService<ISchemaInitializer>();</p>
<p>    await schemaInitializer.InitializeAsync();</p>
<p>}</p>

<p>app.Run();</p>
<p></code></pre></p>

<h3>Schema Comparison</h3>

<p>| Marten Table | Whizbang Table | Notes |</p>
<p>|--------------|----------------|-------|</p>
<p>| <code>mt_events</code> | <code>whizbang.events</code> | Event storage |</p>
<p>| <code>mt_streams</code> | <code>whizbang.streams</code> | Stream metadata |</p>
<p>| <code>mt_doc_<em></code> | <code>whizbang.perspectives_</em></code> | Read model storage |</p>
<p>| <code>mt_event_progression</code> | <code>whizbang.checkpoints</code> | Projection progress |</p>
<p>| <code>wolverine_incoming_envelopes</code> | <code>whizbang.inbox</code> | Inbox messages |</p>
<p>| <code>wolverine_outgoing_envelopes</code> | <code>whizbang.outbox</code> | Outbox messages |</p>

<h2>Namespace Changes</h2>

<p>Update your using statements:</p>

<pre><code class="language-csharp">// Remove
<p>using Marten;</p>
<p>using Marten.Events;</p>
<p>using Marten.Events.Projections;</p>
<p>using Wolverine;</p>
<p>using Wolverine.Attributes;</p>

<p>// Add</p>
<p>using Whizbang.Core;</p>
<p>using Whizbang.Core.Messaging;</p>
<p>using Whizbang.Core.Perspectives;</p>
<p></code></pre></p>

<h2>Dependency Injection Changes</h2>

<h3>Service Registration</h3>

<strong>Before</strong>:

<pre><code class="language-csharp">// Marten session injection
<p>public class OrderService {</p>
<p>    private readonly IDocumentSession _session;</p>

<p>    public OrderService(IDocumentSession session) {</p>
<p>        _session = session;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>After</strong>:

<pre><code class="language-csharp">// Whizbang direct injection
<p>public class OrderService {</p>
<p>    private readonly IEventStore _eventStore;</p>
<p>    private readonly IDispatcher _dispatcher;</p>

<p>    public OrderService(IEventStore eventStore, IDispatcher dispatcher) {</p>
<p>        _eventStore = eventStore;</p>
<p>        _dispatcher = dispatcher;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Verification Steps</h2>

<p>After updating packages and configuration:</p>

<ul><li><strong>Build the solution</strong>:</li>
</ul><p>   <pre><code class="language-bash">   dotnet build</p>
<p>   </code></pre></p>

<ul><li><strong>Check for source generator output</strong>:</li>
</ul><p>   Look for generated files in <code>obj/Debug/net10.0/generated/</code></p>

<ul><li><strong>Run database migration</strong>:</li>
</ul><p>   <pre><code class="language-bash">   dotnet run -- schema init</p>
<p>   </code></pre></p>

<ul><li><strong>Run tests</strong>:</li>
</ul><p>   <pre><code class="language-bash">   dotnet test</p>
<p>   </code></pre></p>

<h2>Common Issues</h2>

<h3>Missing Receptors</h3>

<p>If handlers aren't being discovered:</p>
<ul><li>Ensure <code>Whizbang.Generators</code> is referenced with <code>OutputItemType="Analyzer"</code></li>
<li>Verify classes implement <code>IReceptor<TMessage></code> or <code>IReceptor<TMessage, TResult></code></li>
<li>Check that receptor classes are <code>public</code></li>
</ul>
<h3>Database Connection</h3>

<p>If database operations fail:</p>
<ul><li>Verify connection string format for Whizbang (same as Npgsql)</li>
<li>Ensure schema initialization ran successfully</li>
<li>Check that PostgreSQL extensions are installed (if using custom types)</li>
</ul>
<hr>

<em>Previous: <a href="01-concept-mapping.md">Concept Mapping</a> | Next: <a href="03-handler-migration.md">Handler Migration</a></em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-migration-guide-03-handler-migration" class="doc-section">
  <h3>Handler Migration</h3>
  <p class="doc-path"><code>v1.0.0/migration-guide/03-handler-migration</code></p>
  <p class="doc-description"><em>Converting Wolverine handlers to Whizbang Receptors</em></p>
  <div class="doc-content">

<h1>Handler Migration: Wolverine → Whizbang Receptors</h1>

<p>This guide covers converting Wolverine message handlers to Whizbang Receptors.</p>

<h2>Key Differences</h2>

<p>| Aspect | Wolverine Handler | Whizbang Receptor |</p>
<p>|--------|-------------------|-------------------|</p>
<p>| Discovery | <code>[WolverineHandler]</code> attribute | <code>IReceptor<T></code> interface |</p>
<p>| Return type | Method return type | Generic type parameter |</p>
<p>| Method name | <code>Handle</code> or <code>HandleAsync</code> | <code>HandleAsync</code> (always) |</p>
<p>| Async | Optional <code>Task<T></code> | Always <code>ValueTask<T></code> |</p>
<p>| Void handlers | Return <code>void</code> or <code>Task</code> | <code>IReceptor<TMessage></code> |</p>

<h2>Basic Handler Migration</h2>

<h3>Synchronous Handler</h3>

<strong>Wolverine</strong>:

<pre><code class="language-csharp">[WolverineHandler]
<p>public class OrderHandler {</p>
<p>    public OrderCreated Handle(CreateOrder command) {</p>
<p>        // Business logic</p>
<p>        return new OrderCreated(Guid.CreateVersion7());</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang</strong>:

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>    public ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken cancellationToken = default) {</p>
<p>        // Business logic</p>
<p>        return ValueTask.FromResult(new OrderCreated(Guid.CreateVersion7()));</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Asynchronous Handler</h3>

<strong>Wolverine</strong>:

<pre><code class="language-csharp">[WolverineHandler]
<p>public class OrderHandler {</p>
<p>    private readonly IOrderRepository _repository;</p>

<p>    public async Task<OrderCreated> HandleAsync(CreateOrder command) {</p>
<p>        var order = await _repository.CreateAsync(command);</p>
<p>        return new OrderCreated(order.Id);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang</strong>:

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>    private readonly IOrderRepository _repository;</p>

<p>    public CreateOrderReceptor(IOrderRepository repository) {</p>
<p>        _repository = repository;</p>
<p>    }</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken cancellationToken = default) {</p>
<p>        var order = await _repository.CreateAsync(message, cancellationToken);</p>
<p>        return new OrderCreated(order.Id);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Void Handler (Side Effects Only)</h3>

<strong>Wolverine</strong>:

<pre><code class="language-csharp">[WolverineHandler]
<p>public class NotificationHandler {</p>
<p>    public async Task Handle(SendEmail command, IEmailService emailService) {</p>
<p>        await emailService.SendAsync(command.To, command.Subject, command.Body);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang</strong>:

<pre><code class="language-csharp">public class SendEmailReceptor : IReceptor<SendEmail> {
<p>    private readonly IEmailService _emailService;</p>

<p>    public SendEmailReceptor(IEmailService emailService) {</p>
<p>        _emailService = emailService;</p>
<p>    }</p>

<p>    public async ValueTask HandleAsync(</p>
<p>        SendEmail message,</p>
<p>        CancellationToken cancellationToken = default) {</p>
<p>        await _emailService.SendAsync(</p>
<p>            message.To,</p>
<p>            message.Subject,</p>
<p>            message.Body,</p>
<p>            cancellationToken);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Advanced Patterns</h2>

<h3>Cascading Messages (Tuple Returns)</h3>

<strong>Wolverine</strong>:

<pre><code class="language-csharp">[WolverineHandler]
<p>public class OrderHandler {</p>
<p>    public (OrderCreated, SendOrderConfirmation) Handle(CreateOrder command) {</p>
<p>        var orderId = Guid.CreateVersion7();</p>
<p>        return (</p>
<p>            new OrderCreated(orderId),</p>
<p>            new SendOrderConfirmation(command.CustomerEmail, orderId)</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang</strong> (use dispatcher for cascading):

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>    private readonly IDispatcher _dispatcher;</p>

<p>    public CreateOrderReceptor(IDispatcher dispatcher) {</p>
<p>        _dispatcher = dispatcher;</p>
<p>    }</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken cancellationToken = default) {</p>

<p>        var orderId = Guid.CreateVersion7();</p>
<p>        var orderCreated = new OrderCreated(orderId);</p>

<p>        // Publish cascading message</p>
<p>        await _dispatcher.PublishAsync(</p>
<p>            new SendOrderConfirmation(message.CustomerEmail, orderId),</p>
<p>            cancellationToken);</p>

<p>        return orderCreated;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Handler with Event Store</h3>

<strong>Wolverine</strong> (with Marten):

<pre><code class="language-csharp">[WolverineHandler]
<p>public class OrderHandler {</p>
<p>    public async Task<OrderCreated> HandleAsync(</p>
<p>        CreateOrder command,</p>
<p>        IDocumentSession session) {</p>

<p>        var @event = new OrderCreated(Guid.CreateVersion7());</p>
<p>        session.Events.Append(command.OrderId, @event);</p>
<p>        await session.SaveChangesAsync();</p>
<p>        return @event;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang</strong>:

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>    private readonly IEventStore _eventStore;</p>

<p>    public CreateOrderReceptor(IEventStore eventStore) {</p>
<p>        _eventStore = eventStore;</p>
<p>    }</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken cancellationToken = default) {</p>

<p>        var streamId = Guid.CreateVersion7();</p>
<p>        var @event = new OrderCreated(streamId);</p>

<p>        var envelope = new MessageEnvelope<OrderCreated> {</p>
<p>            MessageId = MessageId.From(Guid.CreateVersion7()),</p>
<p>            Payload = @event</p>
<p>        };</p>

<p>        await _eventStore.AppendAsync(streamId, envelope, cancellationToken);</p>
<p>        return @event;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Multiple Handlers → Multiple Receptors</h3>

<strong>Wolverine</strong> (one class, multiple handlers):

<pre><code class="language-csharp">[WolverineHandler]
<p>public class OrderHandlers {</p>
<p>    public OrderCreated Handle(CreateOrder command) { ... }</p>
<p>    public OrderShipped Handle(ShipOrder command) { ... }</p>
<p>    public OrderCancelled Handle(CancelOrder command) { ... }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang</strong> (one receptor per message):

<pre><code class="language-csharp">// Separate classes for each message type
<p>public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    public ValueTask<OrderCreated> HandleAsync(CreateOrder message, CancellationToken ct) { ... }</p>
<p>}</p>

<p>public class ShipOrderReceptor : IReceptor<ShipOrder, OrderShipped> {</p>
<p>    public ValueTask<OrderShipped> HandleAsync(ShipOrder message, CancellationToken ct) { ... }</p>
<p>}</p>

<p>public class CancelOrderReceptor : IReceptor<CancelOrder, OrderCancelled> {</p>
<p>    public ValueTask<OrderCancelled> HandleAsync(CancelOrder message, CancellationToken ct) { ... }</p>
<p>}</p>
<p></code></pre></p>

<h2>Dependency Injection</h2>

<h3>Wolverine Method Injection</h3>

<strong>Wolverine</strong> (dependencies injected per method):

<pre><code class="language-csharp">[WolverineHandler]
<p>public class OrderHandler {</p>
<p>    public async Task<OrderCreated> HandleAsync(</p>
<p>        CreateOrder command,</p>
<p>        IOrderRepository repository,  // Method injection</p>
<p>        ILogger<OrderHandler> logger) {</p>

<p>        logger.LogInformation("Creating order");</p>
<p>        var order = await repository.CreateAsync(command);</p>
<p>        return new OrderCreated(order.Id);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Whizbang Constructor Injection</h3>

<strong>Whizbang</strong> (standard DI via constructor):

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>    private readonly IOrderRepository _repository;</p>
<p>    private readonly ILogger<CreateOrderReceptor> _logger;</p>

<p>    public CreateOrderReceptor(</p>
<p>        IOrderRepository repository,</p>
<p>        ILogger<CreateOrderReceptor> logger) {</p>
<p>        _repository = repository;</p>
<p>        _logger = logger;</p>
<p>    }</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken cancellationToken = default) {</p>

<p>        _logger.LogInformation("Creating order");</p>
<p>        var order = await _repository.CreateAsync(message, cancellationToken);</p>
<p>        return new OrderCreated(order.Id);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Naming Conventions</h2>

<p>| Wolverine | Whizbang |</p>
<p>|-----------|----------|</p>
<p>| <code>OrderHandler</code> | <code>CreateOrderReceptor</code>, <code>ShipOrderReceptor</code> |</p>
<p>| <code>Handle</code> | <code>HandleAsync</code> |</p>
<p>| <code>HandleAsync</code> | <code>HandleAsync</code> |</p>
<p>| Multiple handlers in one class | One receptor per message type |</p>

<h2>Migration Checklist</h2>

<ul><li>[ ] Remove <code>[WolverineHandler]</code> attribute</li>
<li>[ ] Implement <code>IReceptor<TMessage, TResult></code> or <code>IReceptor<TMessage></code></li>
<li>[ ] Rename method to <code>HandleAsync</code></li>
<li>[ ] Change return type to <code>ValueTask<TResult></code> or <code>ValueTask</code></li>
<li>[ ] Add <code>CancellationToken</code> parameter</li>
<li>[ ] Convert method injection to constructor injection</li>
<li>[ ] Split multi-handler classes into separate receptors</li>
<li>[ ] Update namespace usings</li>
</ul>
<h2>Automated Migration</h2>

<p>The <code>whizbang-migrate</code> tool can automate handler migration:</p>

<pre><code class="language-bash"># Analyze handlers
<p>whizbang migrate analyze --project ./MyApp.sln --filter handlers</p>

<h1>Preview transformations</h1>
<p>whizbang migrate plan --project ./MyApp.sln --filter handlers</p>

<h1>Apply with review</h1>
<p>whizbang migrate apply --mode guided --filter handlers</p>
<p></code></pre></p>

<hr>

<em>Previous: <a href="02-project-setup.md">Project Setup</a> | Next: <a href="04-projection-migration.md">Projection Migration</a></em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-migration-guide-04-projection-migration" class="doc-section">
  <h3>Projection Migration</h3>
  <p class="doc-path"><code>v1.0.0/migration-guide/04-projection-migration</code></p>
  <p class="doc-description"><em>Converting Marten projections to Whizbang Perspectives</em></p>
  <div class="doc-content">

<h1>Projection Migration: Marten → Whizbang Perspectives</h1>

<p>This guide covers converting Marten projections to Whizbang Perspectives.</p>

<h2>Key Differences</h2>

<p>| Aspect | Marten Projection | Whizbang Perspective |</p>
<p>|--------|-------------------|----------------------|</p>
<p>| Execution | Can be async | Synchronous (pure functions) |</p>
<p>| Mutation | Can mutate model | Must return new model |</p>
<p>| Side effects | Allowed | Not allowed |</p>
<p>| Multiple events | Separate <code>Apply</code> methods | Variadic interface |</p>
<p>| State | Can access external state | Only event + current model |</p>

<h2>Why Pure Functions?</h2>

<p>Whizbang Perspectives are <strong>pure functions</strong> by design:</p>

<ul><li><strong>Deterministic</strong>: Same input always produces same output</li>
<li><strong>Testable</strong>: No mocks needed, just input → output</li>
<li><strong>Replayable</strong>: Can rebuild from any point in time</li>
<li><strong>Time-travel debugging</strong>: Easy to debug historical state</li>
<li><strong>AOT-compatible</strong>: No reflection needed</li>
</ul>
<h2>Single-Stream Projection Migration</h2>

<h3>Marten Single-Stream</h3>

<pre><code class="language-csharp">// Marten: Can mutate, can have side effects
<p>public class OrderSummaryProjection : SingleStreamProjection<OrderSummary> {</p>
<p>    public OrderSummary Create(OrderCreated @event) {</p>
<p>        return new OrderSummary {</p>
<p>            Id = @event.OrderId,</p>
<p>            CustomerId = @event.CustomerId,</p>
<p>            Status = OrderStatus.Created,</p>
<p>            Total = @event.Items.Sum(i => i.Price * i.Quantity),</p>
<p>            CreatedAt = @event.Timestamp</p>
<p>        };</p>
<p>    }</p>

<p>    public void Apply(OrderItemAdded @event, OrderSummary model) {</p>
<p>        model.Total += @event.Price * @event.Quantity;</p>
<p>        model.ItemCount++;</p>
<p>    }</p>

<p>    public void Apply(OrderShipped @event, OrderSummary model) {</p>
<p>        model.Status = OrderStatus.Shipped;</p>
<p>        model.ShippedAt = @event.Timestamp;</p>
<p>    }</p>

<p>    public void Apply(OrderCancelled @event, OrderSummary model) {</p>
<p>        model.Status = OrderStatus.Cancelled;</p>
<p>        model.CancelledAt = @event.Timestamp;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Whizbang Perspective</h3>

<pre><code class="language-csharp">// Whizbang: Pure functions, returns new model
<p>public class OrderSummaryPerspective :</p>
<p>    IPerspectiveFor<OrderSummary, OrderCreated, OrderItemAdded, OrderShipped, OrderCancelled> {</p>

<p>    public OrderSummary Apply(OrderSummary current, OrderCreated @event) {</p>
<p>        return new OrderSummary {</p>
<p>            Id = @event.OrderId,</p>
<p>            CustomerId = @event.CustomerId,</p>
<p>            Status = OrderStatus.Created,</p>
<p>            Total = @event.Items.Sum(i => i.Price * i.Quantity),</p>
<p>            ItemCount = @event.Items.Count,</p>
<p>            CreatedAt = @event.Timestamp</p>
<p>        };</p>
<p>    }</p>

<p>    public OrderSummary Apply(OrderSummary current, OrderItemAdded @event) {</p>
<p>        return current with {</p>
<p>            Total = current.Total + (@event.Price * @event.Quantity),</p>
<p>            ItemCount = current.ItemCount + 1</p>
<p>        };</p>
<p>    }</p>

<p>    public OrderSummary Apply(OrderSummary current, OrderShipped @event) {</p>
<p>        return current with {</p>
<p>            Status = OrderStatus.Shipped,</p>
<p>            ShippedAt = @event.Timestamp</p>
<p>        };</p>
<p>    }</p>

<p>    public OrderSummary Apply(OrderSummary current, OrderCancelled @event) {</p>
<p>        return current with {</p>
<p>            Status = OrderStatus.Cancelled,</p>
<p>            CancelledAt = @event.Timestamp</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Multi-Stream Projection Migration</h2>

<h3>Marten Multi-Stream</h3>

<pre><code class="language-csharp">// Marten: Aggregates across streams
<p>public class CustomerOrderStatsProjection :</p>
<p>    MultiStreamProjection<CustomerOrderStats, Guid> {</p>

<p>    public CustomerOrderStatsProjection() {</p>
<p>        Identity<OrderCreated>(e => e.CustomerId);</p>
<p>        Identity<OrderCompleted>(e => e.CustomerId);</p>
<p>    }</p>

<p>    public CustomerOrderStats Create(OrderCreated @event) {</p>
<p>        return new CustomerOrderStats {</p>
<p>            CustomerId = @event.CustomerId,</p>
<p>            TotalOrders = 1,</p>
<p>            TotalSpent = @event.Total</p>
<p>        };</p>
<p>    }</p>

<p>    public void Apply(OrderCreated @event, CustomerOrderStats model) {</p>
<p>        model.TotalOrders++;</p>
<p>        model.TotalSpent += @event.Total;</p>
<p>    }</p>

<p>    public void Apply(OrderCompleted @event, CustomerOrderStats model) {</p>
<p>        model.CompletedOrders++;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Whizbang Global Perspective</h3>

<pre><code class="language-csharp">// Whizbang: Global perspective with partition key
<p>public class CustomerOrderStatsPerspective :</p>
<p>    IGlobalPerspectiveFor<CustomerOrderStats, Guid, OrderCreated, OrderCompleted> {</p>

<p>    public Guid GetPartitionKey(OrderCreated @event) => @event.CustomerId;</p>
<p>    public Guid GetPartitionKey(OrderCompleted @event) => @event.CustomerId;</p>

<p>    public CustomerOrderStats Apply(CustomerOrderStats current, OrderCreated @event) {</p>
<p>        if (current == null) {</p>
<p>            return new CustomerOrderStats {</p>
<p>                CustomerId = @event.CustomerId,</p>
<p>                TotalOrders = 1,</p>
<p>                TotalSpent = @event.Total</p>
<p>            };</p>
<p>        }</p>

<p>        return current with {</p>
<p>            TotalOrders = current.TotalOrders + 1,</p>
<p>            TotalSpent = current.TotalSpent + @event.Total</p>
<p>        };</p>
<p>    }</p>

<p>    public CustomerOrderStats Apply(CustomerOrderStats current, OrderCompleted @event) {</p>
<p>        return current with {</p>
<p>            CompletedOrders = current.CompletedOrders + 1</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Converting Mutation to Immutable</h2>

<h3>Pattern: Mutation → <code>with</code> Expression</h3>

<strong>Marten (mutation)</strong>:

<pre><code class="language-csharp">public void Apply(OrderUpdated @event, OrderSummary model) {
<p>    model.Title = @event.Title;</p>
<p>    model.Total = @event.Total;</p>
<p>    model.UpdatedAt = @event.Timestamp;</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang (immutable)</strong>:

<pre><code class="language-csharp">public OrderSummary Apply(OrderSummary current, OrderUpdated @event) {
<p>    return current with {</p>
<p>        Title = @event.Title,</p>
<p>        Total = @event.Total,</p>
<p>        UpdatedAt = @event.Timestamp</p>
<p>    };</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern: Conditional Logic</h3>

<strong>Marten (conditional mutation)</strong>:

<pre><code class="language-csharp">public void Apply(PaymentReceived @event, OrderSummary model) {
<p>    model.PaidAmount += @event.Amount;</p>
<p>    if (model.PaidAmount >= model.Total) {</p>
<p>        model.Status = OrderStatus.Paid;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang (conditional immutable)</strong>:

<pre><code class="language-csharp">public OrderSummary Apply(OrderSummary current, PaymentReceived @event) {
<p>    var newPaidAmount = current.PaidAmount + @event.Amount;</p>
<p>    var newStatus = newPaidAmount >= current.Total</p>
<p>        ? OrderStatus.Paid</p>
<p>        : current.Status;</p>

<p>    return current with {</p>
<p>        PaidAmount = newPaidAmount,</p>
<p>        Status = newStatus</p>
<p>    };</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern: Collection Updates</h3>

<strong>Marten (list mutation)</strong>:

<pre><code class="language-csharp">public void Apply(ItemAdded @event, ShoppingCart model) {
<p>    model.Items.Add(new CartItem(@event.ProductId, @event.Quantity));</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang (immutable collection)</strong>:

<pre><code class="language-csharp">public ShoppingCart Apply(ShoppingCart current, ItemAdded @event) {
<p>    var newItems = current.Items</p>
<p>        .Append(new CartItem(@event.ProductId, @event.Quantity))</p>
<p>        .ToList();</p>

<p>    return current with { Items = newItems };</p>
<p>}</p>
<p></code></pre></p>

<h2>Model Definition Changes</h2>

<h3>Use Records for Immutability</h3>

<strong>Before (class with mutable properties)</strong>:

<pre><code class="language-csharp">public class OrderSummary {
<p>    public Guid Id { get; set; }</p>
<p>    public OrderStatus Status { get; set; }</p>
<p>    public decimal Total { get; set; }</p>
<p>}</p>
<p></code></pre></p>

<strong>After (record with init properties)</strong>:

<pre><code class="language-csharp">public sealed record OrderSummary {
<p>    public required Guid Id { get; init; }</p>
<p>    public OrderStatus Status { get; init; }</p>
<p>    public decimal Total { get; init; }</p>
<p>    public int ItemCount { get; init; }</p>
<p>    public DateTimeOffset CreatedAt { get; init; }</p>
<p>    public DateTimeOffset? ShippedAt { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h2>Async Operations</h2>

<h3>Marten Async Projections</h3>

<pre><code class="language-csharp">// Marten: Can do async work in projections
<p>public async Task Apply(OrderCreated @event, OrderSummary model, IQuerySession session) {</p>
<p>    var customer = await session.LoadAsync<Customer>(@event.CustomerId);</p>
<p>    model.CustomerName = customer?.Name;</p>
<p>}</p>
<p></code></pre></p>

<h3>Whizbang: Move Async to Receptor</h3>

<p>Perspectives must be pure. Move async logic to receptors:</p>

<pre><code class="language-csharp">// Receptor enriches event before storing
<p>public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    private readonly ICustomerService _customers;</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(CreateOrder message, CancellationToken ct) {</p>
<p>        var customer = await _customers.GetAsync(message.CustomerId, ct);</p>

<p>        return new OrderCreated(</p>
<p>            message.OrderId,</p>
<p>            message.CustomerId,</p>
<p>            CustomerName: customer.Name,  // Enrich at write time</p>
<p>            message.Items</p>
<p>        );</p>
<p>    }</p>
<p>}</p>

<p>// Perspective is pure (no async)</p>
<p>public class OrderSummaryPerspective : IPerspectiveFor<OrderSummary, OrderCreated> {</p>
<p>    public OrderSummary Apply(OrderSummary current, OrderCreated @event) {</p>
<p>        return new OrderSummary {</p>
<p>            Id = @event.OrderId,</p>
<p>            CustomerName = @event.CustomerName  // Already enriched</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Registration Changes</h2>

<h3>Marten Projection Registration</h3>

<pre><code class="language-csharp">services.AddMarten(opts => {
<p>    opts.Projections.Add<OrderSummaryProjection>(ProjectionLifecycle.Async);</p>
<p>    opts.Projections.Add<CustomerOrderStatsProjection>(ProjectionLifecycle.Inline);</p>
<p>});</p>
<p></code></pre></p>

<h3>Whizbang Perspective Registration</h3>

<pre><code class="language-csharp">services.AddWhizbang(options => {
<p>    // Perspectives are auto-discovered via source generators</p>
<p>    // Explicit registration if needed:</p>
<p>    options.AddPerspective<OrderSummaryPerspective>();</p>
<p>    options.AddPerspective<CustomerOrderStatsPerspective>();</p>
<p>});</p>
<p></code></pre></p>

<h2>Testing Perspectives</h2>

<p>Perspectives are easy to test because they're pure functions:</p>

<pre><code class="language-csharp">[Test]
<p>public void Apply_OrderCreated_CreatesNewSummaryAsync() {</p>
<p>    // Arrange</p>
<p>    var perspective = new OrderSummaryPerspective();</p>
<p>    var @event = new OrderCreated(</p>
<p>        Guid.CreateVersion7(),</p>
<p>        CustomerId: Guid.CreateVersion7(),</p>
<p>        Items: new[] { new OrderItem("SKU1", 2, 29.99m) }</p>
<p>    );</p>

<p>    // Act</p>
<p>    var result = perspective.Apply(null!, @event);</p>

<p>    // Assert</p>
<p>    await Assert.That(result.Status).IsEqualTo(OrderStatus.Created);</p>
<p>    await Assert.That(result.Total).IsEqualTo(59.98m);</p>
<p>}</p>

<p>[Test]</p>
<p>public void Apply_OrderShipped_UpdatesStatusAsync() {</p>
<p>    // Arrange</p>
<p>    var perspective = new OrderSummaryPerspective();</p>
<p>    var current = new OrderSummary {</p>
<p>        Id = Guid.CreateVersion7(),</p>
<p>        Status = OrderStatus.Created</p>
<p>    };</p>
<p>    var @event = new OrderShipped(current.Id, DateTimeOffset.UtcNow);</p>

<p>    // Act</p>
<p>    var result = perspective.Apply(current, @event);</p>

<p>    // Assert</p>
<p>    await Assert.That(result.Status).IsEqualTo(OrderStatus.Shipped);</p>
<p>    await Assert.That(result.ShippedAt).IsNotNull();</p>
<p>}</p>
<p></code></pre></p>

<h2>Migration Checklist</h2>

<ul><li>[ ] Replace <code>SingleStreamProjection<T></code> with <code>IPerspectiveFor<T, TEvent...></code></li>
<li>[ ] Replace <code>MultiStreamProjection<T, TKey></code> with <code>IGlobalPerspectiveFor<T, TKey, TEvent...></code></li>
<li>[ ] Convert mutation (<code>model.X = y</code>) to immutable (<code>current with { X = y }</code>)</li>
<li>[ ] Move async operations to receptors</li>
<li>[ ] Use <code>sealed record</code> for model types</li>
<li>[ ] Add variadic event types to interface</li>
<li>[ ] Implement <code>GetPartitionKey</code> for global perspectives</li>
<li>[ ] Update tests to pure function assertions</li>
</ul>
<hr>

<em>Previous: <a href="03-handler-migration.md">Handler Migration</a> | Next: <a href="05-event-store-migration.md">Event Store Migration</a></em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-migration-guide-05-event-store-migration" class="doc-section">
  <h3>Event Store Migration</h3>
  <p class="doc-path"><code>v1.0.0/migration-guide/05-event-store-migration</code></p>
  <p class="doc-description"><em>Migrating from Marten's event store to Whizbang's IEventStore</em></p>
  <div class="doc-content">

<h1>Event Store Migration: Marten → Whizbang</h1>

<p>This guide covers migrating from Marten's document store and event sourcing to Whizbang's <code>IEventStore</code>.</p>

<h2>Key Differences</h2>

<p>| Aspect | Marten | Whizbang |</p>
<p>|--------|--------|----------|</p>
<p>| Session | <code>IDocumentSession</code> | Direct <code>IEventStore</code> injection |</p>
<p>| Append | <code>session.Events.Append()</code> | <code>eventStore.AppendAsync<T>()</code> |</p>
<p>| Save | <code>session.SaveChangesAsync()</code> | Implicit (per-append) |</p>
<p>| Stream ID | Inferred or explicit | Always explicit |</p>
<p>| Envelope | Automatic | <code>MessageEnvelope<T></code> |</p>
<p>| Versioning | <code>ExpectedVersion</code> | Sequence-based |</p>

<h2>Basic Event Store Operations</h2>

<h3>Appending Events</h3>

<strong>Marten</strong>:

<pre><code class="language-csharp">public class OrderService {
<p>    private readonly IDocumentStore _store;</p>

<p>    public async Task CreateOrderAsync(CreateOrderCommand cmd) {</p>
<p>        await using var session = _store.LightweightSession();</p>

<p>        var orderId = Guid.NewGuid();</p>
<p>        var @event = new OrderCreated(orderId, cmd.CustomerId, cmd.Items);</p>

<p>        session.Events.Append(orderId, @event);</p>
<p>        await session.SaveChangesAsync();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang</strong>:

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>    private readonly IEventStore _eventStore;</p>

<p>    public CreateOrderReceptor(IEventStore eventStore) {</p>
<p>        _eventStore = eventStore;</p>
<p>    }</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        var streamId = Guid.CreateVersion7();</p>
<p>        var @event = new OrderCreated(streamId, message.CustomerId, message.Items);</p>

<p>        var envelope = new MessageEnvelope<OrderCreated> {</p>
<p>            MessageId = MessageId.From(Guid.CreateVersion7()),</p>
<p>            Payload = @event,</p>
<p>            Hops = new List<MessageHop> {</p>
<p>                MessageHop.Create(CorrelationId.From(Guid.CreateVersion7()))</p>
<p>            }</p>
<p>        };</p>

<p>        await _eventStore.AppendAsync(streamId, envelope, ct);</p>
<p>        return @event;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Reading Events</h3>

<strong>Marten</strong>:

<pre><code class="language-csharp">public async Task<Order> RehydrateOrderAsync(Guid orderId) {
<p>    await using var session = _store.QuerySession();</p>

<p>    var events = await session.Events</p>
<p>        .FetchStreamAsync(orderId);</p>

<p>    var order = new Order();</p>
<p>    foreach (var @event in events) {</p>
<p>        order.Apply(@event.Data);</p>
<p>    }</p>
<p>    return order;</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang</strong>:

<pre><code class="language-csharp">public async Task<Order> RehydrateOrderAsync(Guid orderId, CancellationToken ct) {
<p>    var events = await _eventStore.ReadAsync<IOrderEvent>(</p>
<p>        orderId,</p>
<p>        fromSequence: 0,</p>
<p>        ct);</p>

<p>    var order = new Order();</p>
<p>    await foreach (var envelope in events) {</p>
<p>        order.Apply(envelope.Payload);</p>
<p>    }</p>
<p>    return order;</p>
<p>}</p>
<p></code></pre></p>

<h3>Multiple Events in One Append</h3>

<strong>Marten</strong>:

<pre><code class="language-csharp">await using var session = _store.LightweightSession();

<p>session.Events.Append(orderId,</p>
<p>    new OrderCreated(orderId),</p>
<p>    new OrderItemAdded(orderId, item1),</p>
<p>    new OrderItemAdded(orderId, item2)</p>
<p>);</p>

<p>await session.SaveChangesAsync();</p>
<p></code></pre></p>

<strong>Whizbang</strong>:

<pre><code class="language-csharp">// Append multiple events individually
<p>var events = new IOrderEvent[] {</p>
<p>    new OrderCreated(orderId),</p>
<p>    new OrderItemAdded(orderId, item1),</p>
<p>    new OrderItemAdded(orderId, item2)</p>
<p>};</p>

<p>foreach (var @event in events) {</p>
<p>    var envelope = CreateEnvelope(@event);</p>
<p>    await _eventStore.AppendAsync(orderId, envelope, ct);</p>
<p>}</p>

<p>// Or use batch append if available</p>
<p>await _eventStore.AppendManyAsync(orderId, envelopes, ct);</p>
<p></code></pre></p>

<h2>Stream Management</h2>

<h3>Starting a Stream</h3>

<strong>Marten</strong> (implicit stream creation):

<pre><code class="language-csharp">// Marten creates stream automatically
<p>session.Events.Append(newStreamId, firstEvent);</p>
<p></code></pre></p>

<strong>Whizbang</strong> (explicit stream):

<pre><code class="language-csharp">// Whizbang creates stream on first append
<p>var streamId = Guid.CreateVersion7();  // Use UUIDv7 for time-ordering</p>
<p>var envelope = CreateEnvelope(firstEvent);</p>
<p>await _eventStore.AppendAsync(streamId, envelope, ct);</p>
<p></code></pre></p>

<h3>Checking Stream Existence</h3>

<strong>Marten</strong>:

<pre><code class="language-csharp">var state = await session.Events.FetchStreamStateAsync(streamId);
<p>var exists = state != null;</p>
<p></code></pre></p>

<strong>Whizbang</strong>:

<pre><code class="language-csharp">var events = await _eventStore.ReadAsync<IEvent>(streamId, fromSequence: 0, ct);
<p>var exists = await events.AnyAsync(ct);</p>
<p></code></pre></p>

<h2>Concurrency Control</h2>

<h3>Marten Expected Version</h3>

<pre><code class="language-csharp">// Marten: Optimistic concurrency via expected version
<p>session.Events.Append(orderId, expectedVersion: 5, newEvent);</p>
<p>await session.SaveChangesAsync();  // Throws if version != 5</p>
<p></code></pre></p>

<h3>Whizbang Sequence-Based</h3>

<pre><code class="language-csharp">// Whizbang: Sequence-based concurrency
<p>// Events have monotonic sequence numbers per stream</p>
<p>// Concurrency handled at append time</p>

<p>var envelope = new MessageEnvelope<OrderUpdated> {</p>
<p>    MessageId = MessageId.From(Guid.CreateVersion7()),</p>
<p>    Payload = @event,</p>
<p>    // Sequence is assigned automatically</p>
<p>};</p>

<p>await _eventStore.AppendAsync(streamId, envelope, ct);</p>
<p>// Throws ConcurrencyException if sequence conflict</p>
<p></code></pre></p>

<h2>Session Patterns</h2>

<h3>Marten Unit of Work</h3>

<pre><code class="language-csharp">// Marten: Batch multiple operations
<p>await using var session = _store.LightweightSession();</p>

<p>session.Events.Append(order1Id, event1);</p>
<p>session.Events.Append(order2Id, event2);</p>
<p>session.Store(document);</p>

<p>await session.SaveChangesAsync();  // All-or-nothing</p>
<p></code></pre></p>

<h3>Whizbang Transactional</h3>

<pre><code class="language-csharp">// Whizbang: Use EF Core transaction or explicit transaction
<p>await using var transaction = await _dbContext.Database.BeginTransactionAsync(ct);</p>

<p>try {</p>
<p>    await _eventStore.AppendAsync(order1Id, envelope1, ct);</p>
<p>    await _eventStore.AppendAsync(order2Id, envelope2, ct);</p>
<p>    await _dbContext.SaveChangesAsync(ct);</p>

<p>    await transaction.CommitAsync(ct);</p>
<p>} catch {</p>
<p>    await transaction.RollbackAsync(ct);</p>
<p>    throw;</p>
<p>}</p>
<p></code></pre></p>

<h2>Query Patterns</h2>

<h3>Marten Query Session</h3>

<pre><code class="language-csharp">// Marten: Query events directly
<p>await using var session = _store.QuerySession();</p>

<p>var recentOrders = await session.Events</p>
<p>    .QueryRawEventDataOnly<OrderCreated>()</p>
<p>    .Where(e => e.Timestamp > cutoff)</p>
<p>    .ToListAsync();</p>
<p></code></pre></p>

<h3>Whizbang Event Queries</h3>

<pre><code class="language-csharp">// Whizbang: Query via event store
<p>var events = await _eventStore.GetEventsBetweenAsync<OrderCreated>(</p>
<p>    fromPosition: lastCheckpoint,</p>
<p>    toPosition: currentPosition,</p>
<p>    ct);</p>

<p>await foreach (var envelope in events) {</p>
<p>    // Process event</p>
<p>}</p>
<p></code></pre></p>

<h2>MessageEnvelope Creation Helper</h2>

<p>Create a helper method for consistent envelope creation:</p>

<pre><code class="language-csharp">public static class EnvelopeFactory {
<p>    public static MessageEnvelope<T> Create<T>(</p>
<p>        T payload,</p>
<p>        CorrelationId? correlationId = null,</p>
<p>        CausationId? causationId = null) where T : IEvent {</p>

<p>        return new MessageEnvelope<T> {</p>
<p>            MessageId = MessageId.From(Guid.CreateVersion7()),</p>
<p>            Payload = payload,</p>
<p>            Hops = new List<MessageHop> {</p>
<p>                MessageHop.Create(</p>
<p>                    correlationId ?? CorrelationId.From(Guid.CreateVersion7()),</p>
<p>                    causationId)</p>
<p>            }</p>
<p>        };</p>
<p>    }</p>
<p>}</p>

<p>// Usage</p>
<p>var envelope = EnvelopeFactory.Create(orderCreatedEvent);</p>
<p>await _eventStore.AppendAsync(streamId, envelope, ct);</p>
<p></code></pre></p>

<h2>Migration Checklist</h2>

<ul><li>[ ] Replace <code>IDocumentStore</code> with <code>IEventStore</code></li>
<li>[ ] Replace <code>IDocumentSession</code> with direct <code>IEventStore</code> injection</li>
<li>[ ] Replace <code>session.Events.Append()</code> with <code>eventStore.AppendAsync<T>()</code></li>
<li>[ ] Create <code>MessageEnvelope<T></code> for each event</li>
<li>[ ] Use <code>Guid.CreateVersion7()</code> for new stream IDs</li>
<li>[ ] Remove <code>session.SaveChangesAsync()</code> (Whizbang auto-commits)</li>
<li>[ ] Update concurrency handling to sequence-based</li>
<li>[ ] Update event queries to use <code>IEventStore</code> methods</li>
</ul>
<hr>

<em>Previous: <a href="04-projection-migration.md">Projection Migration</a> | Next: <a href="06-transport-configuration.md">Transport Configuration</a></em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-migration-guide-06-transport-configuration" class="doc-section">
  <h3>Transport Configuration</h3>
  <p class="doc-path"><code>v1.0.0/migration-guide/06-transport-configuration</code></p>
  <p class="doc-description"><em>Configuring RabbitMQ and Azure Service Bus transports for Whizbang</em></p>
  <div class="doc-content">

<h1>Transport Configuration</h1>

<p>This guide covers configuring message transports in Whizbang, including environment-based switching between RabbitMQ (local development) and Azure Service Bus (production).</p>

<h2>Transport Options</h2>

<p>| Transport | Package | Use Case |</p>
<p>|-----------|---------|----------|</p>
<p>| RabbitMQ | <code>Whizbang.Transports.RabbitMQ</code> | Local development, Aspire |</p>
<p>| Azure Service Bus | <code>Whizbang.Transports.AzureServiceBus</code> | Production, Azure deployment |</p>
<p>| In-Memory | Built-in | Unit testing |</p>

<h2>Environment-Based Transport Switching</h2>

<h3>Recommended Pattern: Runtime Configuration</h3>

<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);

<p>// Core Whizbang setup</p>
<p>builder.Services.AddWhizbang(options => {</p>
<p>    options.UsePostgres(builder.Configuration.GetConnectionString("postgres")!);</p>
<p>});</p>

<p>// Transport switching based on configuration</p>
<p>var useRabbitMQ = builder.Configuration.GetValue<bool>("UseRabbitMQ");</p>

<p>if (useRabbitMQ) {</p>
<p>    // Local development with Aspire/RabbitMQ</p>
<p>    builder.Services.AddRabbitMQTransport(</p>
<p>        builder.Configuration.GetConnectionString("rabbitmq")!,</p>
<p>        options => {</p>
<p>            options.DefaultExchange = "whizbang.events";</p>
<p>            options.MaxChannels = 10;</p>
<p>            options.PrefetchCount = 16;</p>
<p>        });</p>

<p>    builder.Services.AddRabbitMQHealthChecks();</p>
<p>} else {</p>
<p>    // Production with Azure Service Bus</p>
<p>    builder.Services.AddAzureServiceBusTransport(</p>
<p>        builder.Configuration.GetConnectionString("servicebus")!,</p>
<p>        options => {</p>
<p>            options.DefaultTopicName = "whizbang-events";</p>
<p>            options.MaxConcurrentCalls = 16;</p>
<p>            options.AutoComplete = false;</p>
<p>        });</p>

<p>    builder.Services.AddAzureServiceBusHealthChecks();</p>
<p>}</p>
<p></code></pre></p>

<h3>Configuration Files</h3>

<strong>appsettings.Development.json</strong>:

<pre><code class="language-json">{
<p>  "UseRabbitMQ": true,</p>
<p>  "ConnectionStrings": {</p>
<p>    "postgres": "Host=localhost;Database=myapp;Username=postgres;Password=postgres",</p>
<p>    "rabbitmq": "amqp://guest:guest@localhost:5672"</p>
<p>  },</p>
<p>  "RabbitMQ": {</p>
<p>    "Exchange": "whizbang.events",</p>
<p>    "MaxChannels": 10,</p>
<p>    "PrefetchCount": 16</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>appsettings.Production.json</strong>:

<pre><code class="language-json">{
<p>  "UseRabbitMQ": false,</p>
<p>  "ConnectionStrings": {</p>
<p>    "postgres": "Host=myapp.postgres.database.azure.com;Database=myapp;...",</p>
<p>    "servicebus": "Endpoint=sb://myapp.servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=..."</p>
<p>  },</p>
<p>  "AzureServiceBus": {</p>
<p>    "TopicName": "whizbang-events",</p>
<p>    "MaxConcurrentCalls": 16</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>RabbitMQ Configuration</h2>

<h3>Basic Setup</h3>

<pre><code class="language-csharp">builder.Services.AddRabbitMQTransport(
<p>    builder.Configuration.GetConnectionString("rabbitmq")!);</p>
<p></code></pre></p>

<h3>Advanced Configuration</h3>

<pre><code class="language-csharp">builder.Services.AddRabbitMQTransport(
<p>    builder.Configuration.GetConnectionString("rabbitmq")!,</p>
<p>    options => {</p>
<p>        // Exchange configuration</p>
<p>        options.DefaultExchange = "whizbang.events";</p>
<p>        options.ExchangeType = ExchangeType.Topic;</p>
<p>        options.Durable = true;</p>

<p>        // Connection pooling</p>
<p>        options.MaxChannels = 10;</p>

<p>        // Consumer configuration</p>
<p>        options.PrefetchCount = 16;</p>
<p>        options.AutoAck = false;</p>

<p>        // Retry configuration</p>
<p>        options.RetryPolicy = RetryPolicy.Exponential(</p>
<p>            maxRetries: 5,</p>
<p>            initialDelay: TimeSpan.FromSeconds(1),</p>
<p>            maxDelay: TimeSpan.FromMinutes(1)</p>
<p>        );</p>

<p>        // Dead letter queue</p>
<p>        options.DeadLetterExchange = "whizbang.dlx";</p>
<p>    });</p>

<p>// Add health checks</p>
<p>builder.Services.AddHealthChecks()</p>
<p>    .AddRabbitMQ(name: "rabbitmq");</p>
<p></code></pre></p>

<h3>Aspire Integration</h3>

<pre><code class="language-csharp">// In AppHost project
<p>var rabbitmq = builder.AddRabbitMQ("rabbitmq")</p>
<p>    .WithManagementPlugin();</p>

<p>var api = builder.AddProject<Projects.MyApp_API>("api")</p>
<p>    .WithReference(rabbitmq);</p>
<p></code></pre></p>

<pre><code class="language-csharp">// In API project
<p>builder.AddRabbitMQClient("rabbitmq");</p>
<p>builder.Services.AddRabbitMQTransport(options => {</p>
<p>    // Connection string resolved via Aspire</p>
<p>});</p>
<p></code></pre></p>

<h2>Azure Service Bus Configuration</h2>

<h3>Basic Setup</h3>

<pre><code class="language-csharp">builder.Services.AddAzureServiceBusTransport(
<p>    builder.Configuration.GetConnectionString("servicebus")!);</p>
<p></code></pre></p>

<h3>Advanced Configuration</h3>

<pre><code class="language-csharp">builder.Services.AddAzureServiceBusTransport(
<p>    builder.Configuration.GetConnectionString("servicebus")!,</p>
<p>    options => {</p>
<p>        // Topic configuration</p>
<p>        options.DefaultTopicName = "whizbang-events";</p>

<p>        // Subscription configuration</p>
<p>        options.SubscriptionName = "order-service";</p>
<p>        options.MaxConcurrentCalls = 16;</p>
<p>        options.AutoComplete = false;</p>

<p>        // Session handling (for ordered processing)</p>
<p>        options.RequiresSession = false;</p>

<p>        // Retry configuration</p>
<p>        options.MaxDeliveryCount = 10;</p>
<p>        options.RetryOptions = new ServiceBusRetryOptions {</p>
<p>            MaxRetries = 5,</p>
<p>            Delay = TimeSpan.FromSeconds(1),</p>
<p>            MaxDelay = TimeSpan.FromMinutes(1),</p>
<p>            Mode = ServiceBusRetryMode.Exponential</p>
<p>        };</p>

<p>        // Dead letter configuration</p>
<p>        options.DeadLetterOnMessageExpiration = true;</p>
<p>    });</p>

<p>// Add health checks</p>
<p>builder.Services.AddHealthChecks()</p>
<p>    .AddAzureServiceBusTopic(</p>
<p>        builder.Configuration.GetConnectionString("servicebus")!,</p>
<p>        "whizbang-events",</p>
<p>        name: "servicebus");</p>
<p></code></pre></p>

<h3>Managed Identity Authentication</h3>

<pre><code class="language-csharp">builder.Services.AddAzureServiceBusTransport(options => {
<p>    options.FullyQualifiedNamespace = "myapp.servicebus.windows.net";</p>
<p>    options.Credential = new DefaultAzureCredential();</p>
<p>    options.DefaultTopicName = "whizbang-events";</p>
<p>});</p>
<p></code></pre></p>

<h2>Migrating from Wolverine Transports</h2>

<h3>Wolverine RabbitMQ</h3>

<pre><code class="language-csharp">// Wolverine
<p>builder.Host.UseWolverine(opts => {</p>
<p>    opts.UseRabbitMq("amqp://guest:guest@localhost:5672")</p>
<p>        .UseConventionalRouting()</p>
<p>        .UseDurableOutbox();</p>
<p>});</p>
<p></code></pre></p>

<pre><code class="language-csharp">// Whizbang
<p>builder.Services.AddRabbitMQTransport(</p>
<p>    "amqp://guest:guest@localhost:5672",</p>
<p>    options => {</p>
<p>        // Outbox is built-in to Whizbang Core</p>
<p>        options.DefaultExchange = "whizbang.events";</p>
<p>    });</p>
<p></code></pre></p>

<h3>Wolverine Azure Service Bus</h3>

<pre><code class="language-csharp">// Wolverine
<p>builder.Host.UseWolverine(opts => {</p>
<p>    opts.UseAzureServiceBus(connectionString)</p>
<p>        .UseTopicsAndSubscriptions()</p>
<p>        .UseDurableOutbox();</p>
<p>});</p>
<p></code></pre></p>

<pre><code class="language-csharp">// Whizbang
<p>builder.Services.AddAzureServiceBusTransport(</p>
<p>    connectionString,</p>
<p>    options => {</p>
<p>        options.DefaultTopicName = "whizbang-events";</p>
<p>    });</p>
<p></code></pre></p>

<h2>Message Routing</h2>

<h3>Topic-Based Routing</h3>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.ConfigureRouting(routing => {</p>
<p>        // Route by message type</p>
<p>        routing.Route<OrderCreated>().ToTopic("orders");</p>
<p>        routing.Route<PaymentProcessed>().ToTopic("payments");</p>

<p>        // Route by convention</p>
<p>        routing.RouteByConvention(msg => msg.GetType().Namespace!.Split('.').Last());</p>
<p>    });</p>
<p>});</p>
<p></code></pre></p>

<h3>Subscription Configuration</h3>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.ConfigureSubscriptions(subs => {</p>
<p>        // Subscribe to specific topics</p>
<p>        subs.Subscribe<OrderCreated>("orders");</p>
<p>        subs.Subscribe<PaymentProcessed>("payments");</p>

<p>        // Subscribe with filter</p>
<p>        subs.Subscribe<OrderCreated>("orders")</p>
<p>            .WithFilter("Total > 1000");</p>
<p>    });</p>
<p>});</p>
<p></code></pre></p>

<h2>Testing Configuration</h2>

<h3>In-Memory Transport for Tests</h3>

<pre><code class="language-csharp">public class TestFixture {
<p>    public ServiceProvider BuildTestServices() {</p>
<p>        var services = new ServiceCollection();</p>

<p>        services.AddWhizbang(options => {</p>
<p>            options.UseInMemoryEventStore();</p>
<p>        });</p>

<p>        // Use in-memory transport for testing</p>
<p>        services.AddInMemoryTransport();</p>

<p>        return services.BuildServiceProvider();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Integration Test with TestContainers</h3>

<pre><code class="language-csharp">public class IntegrationTestFixture : IAsyncLifetime {
<p>    private RabbitMqContainer _rabbitMq = null!;</p>

<p>    public async Task InitializeAsync() {</p>
<p>        _rabbitMq = new RabbitMqBuilder()</p>
<p>            .WithImage("rabbitmq:3-management")</p>
<p>            .Build();</p>

<p>        await _rabbitMq.StartAsync();</p>
<p>    }</p>

<p>    public ServiceProvider BuildServices() {</p>
<p>        var services = new ServiceCollection();</p>

<p>        services.AddRabbitMQTransport(_rabbitMq.GetConnectionString());</p>

<p>        return services.BuildServiceProvider();</p>
<p>    }</p>

<p>    public async Task DisposeAsync() {</p>
<p>        await _rabbitMq.DisposeAsync();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Migration Checklist</h2>

<ul><li>[ ] Add <code>Whizbang.Transports.RabbitMQ</code> and/or <code>Whizbang.Transports.AzureServiceBus</code> packages</li>
<li>[ ] Configure environment-based transport switching</li>
<li>[ ] Set up <code>appsettings.Development.json</code> for RabbitMQ</li>
<li>[ ] Set up <code>appsettings.Production.json</code> for Azure Service Bus</li>
<li>[ ] Configure health checks for transport</li>
<li>[ ] Update Aspire integration (if using)</li>
<li>[ ] Configure message routing</li>
<li>[ ] Update integration tests to use in-memory transport</li>
</ul>
<hr>

<em>Previous: <a href="05-event-store-migration.md">Event Store Migration</a> | Next: <a href="07-outbox-migration.md">Outbox Migration</a></em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-migration-guide-07-outbox-migration" class="doc-section">
  <h3>Outbox Migration</h3>
  <p class="doc-path"><code>v1.0.0/migration-guide/07-outbox-migration</code></p>
  <p class="doc-description"><em>Migrating from Wolverine's durable outbox to Whizbang's built-in outbox pattern</em></p>
  <div class="doc-content">

<h1>Outbox Migration: Wolverine → Whizbang</h1>

<p>This guide covers migrating from Wolverine's durable outbox pattern to Whizbang's built-in outbox implementation.</p>

<h2>Understanding the Outbox Pattern</h2>

<p>The outbox pattern ensures reliable message delivery by:</p>

<ul><li>Writing events to a database table (outbox) in the same transaction as business data</li>
<li>A background worker reads from the outbox and publishes to the message broker</li>
<li>On successful publish, marks the outbox entry as completed</li>
</ul>
<p>This guarantees <strong>at-least-once delivery</strong> even if the message broker is temporarily unavailable.</p>

<h2>Key Differences</h2>

<p>| Aspect | Wolverine | Whizbang |</p>
<p>|--------|-----------|----------|</p>
<p>| Configuration | <code>UseDurableOutbox()</code> | Built-in, always enabled |</p>
<p>| Outbox table | <code>wolverine_outgoing_envelopes</code> | <code>whizbang.outbox</code> |</p>
<p>| Inbox table | <code>wolverine_incoming_envelopes</code> | <code>whizbang.inbox</code> |</p>
<p>| Background worker | Wolverine daemon | <code>WorkCoordinatorPublisherWorker</code> |</p>
<p>| Retry policy | Configurable | Configurable via <code>IWorkCoordinatorStrategy</code> |</p>

<h2>Wolverine Outbox Configuration</h2>

<pre><code class="language-csharp">// Wolverine: Explicit outbox configuration
<p>builder.Host.UseWolverine(opts => {</p>
<p>    opts.UseRabbitMq(connectionString)</p>
<p>        .UseConventionalRouting()</p>
<p>        .UseDurableOutbox();  // Enable outbox</p>

<p>    opts.Policies.UseDurableLocalQueues();</p>
<p>    opts.Policies.UseDurableInbox();</p>

<p>    // Configure retry</p>
<p>    opts.Handlers.OnAnyException()</p>
<p>        .RetryWithCooldown(TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5))</p>
<p>        .Then.Requeue();</p>
<p>});</p>
<p></code></pre></p>

<h2>Whizbang Outbox Configuration</h2>

<p>Whizbang's outbox is <strong>built-in and always enabled</strong>. Configure the work coordinator for your needs:</p>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.UsePostgres(connectionString);</p>
<p>});</p>

<p>// Configure work coordinator strategy</p>
<p>builder.Services.AddSingleton<IWorkCoordinatorStrategy>(</p>
<p>    new IntervalWorkCoordinatorStrategy(</p>
<p>        pollInterval: TimeSpan.FromMilliseconds(100),</p>
<p>        batchSize: 100,</p>
<p>        maxRetries: 5,</p>
<p>        retryDelay: TimeSpan.FromSeconds(1)));</p>

<p>// Add the background worker</p>
<p>builder.Services.AddHostedService<WorkCoordinatorPublisherWorker>();</p>
<p></code></pre></p>

<h2>Outbox Flow Comparison</h2>

<h3>Wolverine Flow</h3>

<pre><code class="language-csharp">// Wolverine: Messages queued to outbox automatically
<p>[WolverineHandler]</p>
<p>public async Task<OrderCreated> Handle(</p>
<p>    CreateOrder command,</p>
<p>    IDocumentSession session,</p>
<p>    IMessageContext context) {</p>

<p>    var @event = new OrderCreated(command.OrderId);</p>

<p>    // Append event (transactional)</p>
<p>    session.Events.Append(command.OrderId, @event);</p>

<p>    // Queue message to outbox (same transaction)</p>
<p>    await context.PublishAsync(new NotifyCustomer(command.CustomerEmail));</p>

<p>    await session.SaveChangesAsync();  // Commits both</p>
<p>    return @event;</p>
<p>}</p>
<p></code></pre></p>

<h3>Whizbang Flow</h3>

<pre><code class="language-csharp">// Whizbang: Outbox is implicit via dispatcher
<p>public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    private readonly IEventStore _eventStore;</p>
<p>    private readonly IDispatcher _dispatcher;</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        var @event = new OrderCreated(message.OrderId);</p>

<p>        // Append event to event store</p>
<p>        var envelope = EnvelopeFactory.Create(@event);</p>
<p>        await _eventStore.AppendAsync(message.OrderId, envelope, ct);</p>

<p>        // Publish goes through outbox automatically</p>
<p>        await _dispatcher.PublishAsync(</p>
<p>            new NotifyCustomer(message.CustomerEmail),</p>
<p>            ct);</p>

<p>        return @event;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Inbox Pattern (Idempotency)</h2>

<h3>Wolverine Inbox</h3>

<pre><code class="language-csharp">// Wolverine: Inbox for idempotent processing
<p>opts.Policies.UseDurableInbox();</p>

<p>// Messages are tracked by ID in wolverine_incoming_envelopes</p>
<p>// Duplicate messages are automatically rejected</p>
<p></code></pre></p>

<h3>Whizbang Inbox</h3>

<pre><code class="language-csharp">// Whizbang: Built-in inbox deduplication
<p>builder.Services.AddWhizbang(options => {</p>
<p>    options.EnableInboxDeduplication(</p>
<p>        retentionPeriod: TimeSpan.FromDays(7),</p>
<p>        cleanupInterval: TimeSpan.FromHours(1));</p>
<p>});</p>

<p>// Messages with same MessageId are automatically deduplicated</p>
<p>// via whizbang.inbox table</p>
<p></code></pre></p>

<h2>Work Coordinator Strategies</h2>

<h3>Interval Strategy (Default)</h3>

<p>Polls the outbox at regular intervals:</p>

<pre><code class="language-csharp">builder.Services.AddSingleton<IWorkCoordinatorStrategy>(
<p>    new IntervalWorkCoordinatorStrategy(</p>
<p>        pollInterval: TimeSpan.FromMilliseconds(100)));</p>
<p></code></pre></p>

<h3>Notification Strategy</h3>

<p>Uses database notifications for immediate processing:</p>

<pre><code class="language-csharp">builder.Services.AddSingleton<IWorkCoordinatorStrategy>(
<p>    new NotificationWorkCoordinatorStrategy(</p>
<p>        connectionString,</p>
<p>        channelName: "outbox_notify"));</p>
<p></code></pre></p>

<h3>Hybrid Strategy</h3>

<p>Combines notification with interval fallback:</p>

<pre><code class="language-csharp">builder.Services.AddSingleton<IWorkCoordinatorStrategy>(
<p>    new HybridWorkCoordinatorStrategy(</p>
<p>        notificationChannel: "outbox_notify",</p>
<p>        fallbackInterval: TimeSpan.FromSeconds(5)));</p>
<p></code></pre></p>

<h2>Error Handling</h2>

<h3>Wolverine Error Policies</h3>

<pre><code class="language-csharp">opts.Handlers.OnAnyException()
<p>    .RetryWithCooldown(</p>
<p>        TimeSpan.FromSeconds(1),</p>
<p>        TimeSpan.FromSeconds(5),</p>
<p>        TimeSpan.FromSeconds(30))</p>
<p>    .Then.MoveToErrorQueue();</p>
<p></code></pre></p>

<h3>Whizbang Retry Configuration</h3>

<pre><code class="language-csharp">builder.Services.AddSingleton<IWorkCoordinatorStrategy>(
<p>    new IntervalWorkCoordinatorStrategy(</p>
<p>        pollInterval: TimeSpan.FromMilliseconds(100),</p>
<p>        batchSize: 100,</p>
<p>        maxRetries: 5,</p>
<p>        retryDelays: new[] {</p>
<p>            TimeSpan.FromSeconds(1),</p>
<p>            TimeSpan.FromSeconds(5),</p>
<p>            TimeSpan.FromSeconds(30)</p>
<p>        },</p>
<p>        onMaxRetriesExceeded: OutboxAction.MoveToDeadLetter));</p>
<p></code></pre></p>

<h2>Dead Letter Queue</h2>

<h3>Wolverine Dead Letter</h3>

<pre><code class="language-csharp">// Wolverine moves failed messages to error queue
<p>// Access via IMessageStore.Inbox.DeadLetterEnvelopes</p>
<p></code></pre></p>

<h3>Whizbang Dead Letter</h3>

<pre><code class="language-csharp">// Failed messages moved to whizbang.dead_letters table
<p>// Query via:</p>
<p>var deadLetters = await _dbContext.DeadLetters</p>
<p>    .Where(d => d.CreatedAt > cutoff)</p>
<p>    .ToListAsync();</p>

<p>// Replay dead letter</p>
<p>await _workCoordinator.ReplayDeadLetterAsync(deadLetterId, ct);</p>
<p></code></pre></p>

<h2>Database Schema</h2>

<h3>Wolverine Tables</h3>

<pre><code class="language-sql">-- Wolverine outbox tables
<p>CREATE TABLE wolverine_outgoing_envelopes (...);</p>
<p>CREATE TABLE wolverine_incoming_envelopes (...);</p>
<p></code></pre></p>

<h3>Whizbang Tables</h3>

<pre><code class="language-sql">-- Whizbang outbox tables
<p>CREATE TABLE whizbang.outbox (</p>
<p>    id uuid PRIMARY KEY,</p>
<p>    message_type text NOT NULL,</p>
<p>    payload jsonb NOT NULL,</p>
<p>    created_at timestamptz NOT NULL,</p>
<p>    scheduled_at timestamptz,</p>
<p>    attempts int DEFAULT 0,</p>
<p>    last_error text,</p>
<p>    completed_at timestamptz</p>
<p>);</p>

<p>CREATE TABLE whizbang.inbox (</p>
<p>    message_id uuid PRIMARY KEY,</p>
<p>    received_at timestamptz NOT NULL</p>
<p>);</p>

<p>CREATE TABLE whizbang.dead_letters (</p>
<p>    id uuid PRIMARY KEY,</p>
<p>    original_id uuid NOT NULL,</p>
<p>    message_type text NOT NULL,</p>
<p>    payload jsonb NOT NULL,</p>
<p>    error text NOT NULL,</p>
<p>    created_at timestamptz NOT NULL</p>
<p>);</p>
<p></code></pre></p>

<h2>Transactional Consistency</h2>

<h3>Ensuring Atomicity</h3>

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>    private readonly IEventStore _eventStore;</p>
<p>    private readonly IOutbox _outbox;</p>
<p>    private readonly AppDbContext _dbContext;</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        // All operations in same transaction</p>
<p>        await using var transaction = await _dbContext.Database</p>
<p>            .BeginTransactionAsync(ct);</p>

<p>        try {</p>
<p>            // 1. Append event</p>
<p>            var @event = new OrderCreated(message.OrderId);</p>
<p>            await _eventStore.AppendAsync(message.OrderId,</p>
<p>                EnvelopeFactory.Create(@event), ct);</p>

<p>            // 2. Write to outbox (same transaction)</p>
<p>            await _outbox.EnqueueAsync(</p>
<p>                new NotifyCustomer(message.CustomerEmail),</p>
<p>                ct);</p>

<p>            // 3. Commit together</p>
<p>            await transaction.CommitAsync(ct);</p>

<p>            return @event;</p>
<p>        } catch {</p>
<p>            await transaction.RollbackAsync(ct);</p>
<p>            throw;</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Migration Checklist</h2>

<ul><li>[ ] Remove <code>UseDurableOutbox()</code> configuration</li>
<li>[ ] Remove <code>UseDurableInbox()</code> configuration</li>
<li>[ ] Configure <code>IWorkCoordinatorStrategy</code></li>
<li>[ ] Add <code>WorkCoordinatorPublisherWorker</code> hosted service</li>
<li>[ ] Update retry policies to Whizbang format</li>
<li>[ ] Initialize Whizbang schema (includes outbox tables)</li>
<li>[ ] Update dead letter handling</li>
<li>[ ] Test transactional consistency</li>
</ul>
<hr>

<em>Previous: <a href="06-transport-configuration.md">Transport Configuration</a> | Next: <a href="08-testing-migration.md">Testing Migration</a></em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-migration-guide-08-testing-migration" class="doc-section">
  <h3>Testing Migration</h3>
  <p class="doc-path"><code>v1.0.0/migration-guide/08-testing-migration</code></p>
  <p class="doc-description"><em>Updating test infrastructure when migrating to Whizbang</em></p>
  <div class="doc-content">

<h1>Testing Migration</h1>

<p>This guide covers updating your test infrastructure when migrating from Marten/Wolverine to Whizbang.</p>

<h2>Testing Framework</h2>

<p>Whizbang recommends <strong>TUnit</strong> with <strong>Rocks</strong> for AOT-compatible testing:</p>

<p>| Component | Marten/Wolverine Stack | Whizbang Stack |</p>
<p>|-----------|------------------------|----------------|</p>
<p>| Test Framework | xUnit/NUnit | TUnit 1.2.11+ |</p>
<p>| Mocking | Moq/NSubstitute | Rocks 9.3.0+ |</p>
<p>| Data Generation | AutoFixture | Bogus |</p>
<p>| Assertions | FluentAssertions | TUnit.Assertions |</p>

<h2>Package Changes</h2>

<h3>Remove</h3>

<pre><code class="language-xml"><PackageReference Include="xunit" />
<p><PackageReference Include="xunit.runner.visualstudio" /></p>
<p><PackageReference Include="Moq" /></p>
<p><PackageReference Include="FluentAssertions" /></p>
<p></code></pre></p>

<h3>Add</h3>

<pre><code class="language-xml"><PackageReference Include="TUnit" Version="1.2.11" />
<p><PackageReference Include="TUnit.Assertions" Version="1.2.11" /></p>
<p><PackageReference Include="Rocks" Version="9.3.0" /></p>
<p><PackageReference Include="Bogus" Version="35.6.1" /></p>
<p><PackageReference Include="Whizbang.Testing" Version="0.1.0" /></p>
<p></code></pre></p>

<h2>Unit Test Migration</h2>

<h3>Handler/Receptor Tests</h3>

<strong>xUnit + Moq (before)</strong>:

<pre><code class="language-csharp">public class OrderHandlerTests {
<p>    [Fact]</p>
<p>    public async Task Handle_ValidOrder_ReturnsOrderCreated() {</p>
<p>        // Arrange</p>
<p>        var mockRepo = new Mock<IOrderRepository>();</p>
<p>        mockRepo.Setup(r => r.CreateAsync(It.IsAny<CreateOrder>()))</p>
<p>            .ReturnsAsync(new Order { Id = Guid.NewGuid() });</p>

<p>        var handler = new OrderHandler(mockRepo.Object);</p>
<p>        var command = new CreateOrder { CustomerId = Guid.NewGuid() };</p>

<p>        // Act</p>
<p>        var result = await handler.HandleAsync(command);</p>

<p>        // Assert</p>
<p>        result.Should().NotBeNull();</p>
<p>        result.OrderId.Should().NotBeEmpty();</p>
<p>        mockRepo.Verify(r => r.CreateAsync(command), Times.Once);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>TUnit + Rocks (after)</strong>:

<pre><code class="language-csharp">public class CreateOrderReceptorTests {
<p>    [Test]</p>
<p>    public async Task HandleAsync_ValidOrder_ReturnsOrderCreatedAsync() {</p>
<p>        // Arrange</p>
<p>        var orderId = Guid.CreateVersion7();</p>
<p>        var expectations = Rock.Create<IOrderRepository>();</p>
<p>        expectations.Methods()</p>
<p>            .CreateAsync(Arg.Any<CreateOrder>(), Arg.Any<CancellationToken>())</p>
<p>            .Returns(new Order { Id = orderId });</p>

<p>        var repository = expectations.Instance();</p>
<p>        var receptor = new CreateOrderReceptor(repository);</p>
<p>        var command = new CreateOrder { CustomerId = Guid.CreateVersion7() };</p>

<p>        // Act</p>
<p>        var result = await receptor.HandleAsync(command);</p>

<p>        // Assert</p>
<p>        await Assert.That(result).IsNotNull();</p>
<p>        await Assert.That(result.OrderId).IsEqualTo(orderId);</p>
<p>        expectations.Verify();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Perspective Tests</h3>

<p>Perspectives are pure functions - no mocks needed!</p>

<strong>TUnit (Whizbang perspective test)</strong>:

<pre><code class="language-csharp">public class OrderSummaryPerspectiveTests {
<p>    [Test]</p>
<p>    public async Task Apply_OrderCreated_CreatesNewSummaryAsync() {</p>
<p>        // Arrange</p>
<p>        var perspective = new OrderSummaryPerspective();</p>
<p>        var @event = new OrderCreated(</p>
<p>            OrderId: Guid.CreateVersion7(),</p>
<p>            CustomerId: Guid.CreateVersion7(),</p>
<p>            Items: new[] { new OrderItem("SKU1", 2, 29.99m) },</p>
<p>            Timestamp: DateTimeOffset.UtcNow</p>
<p>        );</p>

<p>        // Act</p>
<p>        var result = perspective.Apply(null!, @event);</p>

<p>        // Assert</p>
<p>        await Assert.That(result.Id).IsEqualTo(@event.OrderId);</p>
<p>        await Assert.That(result.Status).IsEqualTo(OrderStatus.Created);</p>
<p>        await Assert.That(result.Total).IsEqualTo(59.98m);</p>
<p>    }</p>

<p>    [Test]</p>
<p>    public async Task Apply_OrderShipped_UpdatesStatusAsync() {</p>
<p>        // Arrange</p>
<p>        var perspective = new OrderSummaryPerspective();</p>
<p>        var current = new OrderSummary {</p>
<p>            Id = Guid.CreateVersion7(),</p>
<p>            Status = OrderStatus.Created,</p>
<p>            Total = 100m</p>
<p>        };</p>
<p>        var @event = new OrderShipped(current.Id, DateTimeOffset.UtcNow);</p>

<p>        // Act</p>
<p>        var result = perspective.Apply(current, @event);</p>

<p>        // Assert</p>
<p>        await Assert.That(result.Status).IsEqualTo(OrderStatus.Shipped);</p>
<p>        await Assert.That(result.ShippedAt).IsNotNull();</p>
<p>        // Verify immutability - original unchanged</p>
<p>        await Assert.That(current.Status).IsEqualTo(OrderStatus.Created);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Integration Test Migration</h2>

<h3>Marten Test Harness</h3>

<strong>Before (Marten)</strong>:

<pre><code class="language-csharp">public class OrderIntegrationTests : IAsyncLifetime {
<p>    private IDocumentStore _store = null!;</p>

<p>    public async Task InitializeAsync() {</p>
<p>        _store = DocumentStore.For(opts => {</p>
<p>            opts.Connection("Host=localhost;Database=test;...");</p>
<p>            opts.AutoCreateSchemaObjects = AutoCreate.All;</p>
<p>        });</p>
<p>    }</p>

<p>    [Fact]</p>
<p>    public async Task CreateOrder_PersistsEvent() {</p>
<p>        await using var session = _store.LightweightSession();</p>

<p>        var orderId = Guid.NewGuid();</p>
<p>        session.Events.Append(orderId, new OrderCreated(orderId));</p>
<p>        await session.SaveChangesAsync();</p>

<p>        var events = await session.Events.FetchStreamAsync(orderId);</p>
<p>        events.Should().ContainSingle();</p>
<p>    }</p>

<p>    public async Task DisposeAsync() {</p>
<p>        _store.Dispose();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Whizbang Test Harness</h3>

<strong>After (Whizbang)</strong>:

<pre><code class="language-csharp">public class OrderIntegrationTests : IAsyncLifetime {
<p>    private ServiceProvider _provider = null!;</p>
<p>    private IEventStore _eventStore = null!;</p>

<p>    public async Task InitializeAsync() {</p>
<p>        var services = new ServiceCollection();</p>

<p>        services.AddWhizbang(options => {</p>
<p>            options.UseInMemoryEventStore();  // In-memory for tests</p>
<p>        });</p>

<p>        _provider = services.BuildServiceProvider();</p>
<p>        _eventStore = _provider.GetRequiredService<IEventStore>();</p>
<p>    }</p>

<p>    [Test]</p>
<p>    public async Task CreateOrder_PersistsEventAsync() {</p>
<p>        // Arrange</p>
<p>        var orderId = Guid.CreateVersion7();</p>
<p>        var @event = new OrderCreated(orderId);</p>
<p>        var envelope = EnvelopeFactory.Create(@event);</p>

<p>        // Act</p>
<p>        await _eventStore.AppendAsync(orderId, envelope);</p>

<p>        // Assert</p>
<p>        var events = await _eventStore.ReadAsync<OrderCreated>(orderId, 0)</p>
<p>            .ToListAsync();</p>
<p>        await Assert.That(events).HasCount().EqualTo(1);</p>
<p>    }</p>

<p>    public async Task DisposeAsync() {</p>
<p>        await _provider.DisposeAsync();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>TestContainers for PostgreSQL</h3>

<pre><code class="language-csharp">public class PostgresIntegrationTests : IAsyncLifetime {
<p>    private PostgreSqlContainer _postgres = null!;</p>
<p>    private ServiceProvider _provider = null!;</p>

<p>    public async Task InitializeAsync() {</p>
<p>        _postgres = new PostgreSqlBuilder()</p>
<p>            .WithImage("postgres:16")</p>
<p>            .Build();</p>

<p>        await _postgres.StartAsync();</p>

<p>        var services = new ServiceCollection();</p>
<p>        services.AddWhizbang(options => {</p>
<p>            options.UsePostgres(_postgres.GetConnectionString());</p>
<p>        });</p>

<p>        _provider = services.BuildServiceProvider();</p>

<p>        // Initialize schema</p>
<p>        var initializer = _provider.GetRequiredService<ISchemaInitializer>();</p>
<p>        await initializer.InitializeAsync();</p>
<p>    }</p>

<p>    [Test]</p>
<p>    public async Task EventStore_WithRealPostgres_WorksAsync() {</p>
<p>        var eventStore = _provider.GetRequiredService<IEventStore>();</p>
<p>        var streamId = Guid.CreateVersion7();</p>

<p>        await eventStore.AppendAsync(streamId,</p>
<p>            EnvelopeFactory.Create(new OrderCreated(streamId)));</p>

<p>        var events = await eventStore.ReadAsync<OrderCreated>(streamId, 0)</p>
<p>            .ToListAsync();</p>

<p>        await Assert.That(events).HasCount().EqualTo(1);</p>
<p>    }</p>

<p>    public async Task DisposeAsync() {</p>
<p>        await _provider.DisposeAsync();</p>
<p>        await _postgres.DisposeAsync();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Test Data Generation</h2>

<h3>Bogus Faker for Test Data</h3>

<pre><code class="language-csharp">public class OrderFaker : Faker<CreateOrder> {
<p>    public OrderFaker() {</p>
<p>        RuleFor(o => o.CustomerId, f => Guid.CreateVersion7());</p>
<p>        RuleFor(o => o.Items, f => new OrderItemFaker().Generate(f.Random.Int(1, 5)));</p>
<p>        RuleFor(o => o.ShippingAddress, f => new AddressFaker().Generate());</p>
<p>    }</p>
<p>}</p>

<p>public class OrderItemFaker : Faker<OrderItem> {</p>
<p>    public OrderItemFaker() {</p>
<p>        RuleFor(i => i.ProductId, f => Guid.CreateVersion7());</p>
<p>        RuleFor(i => i.Quantity, f => f.Random.Int(1, 10));</p>
<p>        RuleFor(i => i.Price, f => f.Finance.Amount(1, 1000));</p>
<p>    }</p>
<p>}</p>

<p>// Usage in tests</p>
<p>[Test]</p>
<p>public async Task HandleAsync_ValidOrder_ProcessesCorrectlyAsync() {</p>
<p>    var faker = new OrderFaker();</p>
<p>    var command = faker.Generate();</p>

<p>    var result = await _receptor.HandleAsync(command);</p>

<p>    await Assert.That(result.OrderId).IsNotEqualTo(Guid.Empty);</p>
<p>}</p>
<p></code></pre></p>

<h2>Async Test Patterns</h2>

<h3>TUnit Async Assertions</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task Receptor_ThrowsOnInvalidInput_Async() {</p>
<p>    var receptor = new CreateOrderReceptor(_eventStore);</p>
<p>    var invalidCommand = new CreateOrder { Items = Array.Empty<OrderItem>() };</p>

<p>    await Assert.That(async () => await receptor.HandleAsync(invalidCommand))</p>
<p>        .ThrowsAsync<InvalidOperationException>()</p>
<p>        .WithMessage("Order must have at least one item");</p>
<p>}</p>

<p>[Test]</p>
<p>public async Task EventStore_ReturnsEventsInOrder_Async() {</p>
<p>    var streamId = Guid.CreateVersion7();</p>

<p>    await _eventStore.AppendAsync(streamId, EnvelopeFactory.Create(new Event1()));</p>
<p>    await _eventStore.AppendAsync(streamId, EnvelopeFactory.Create(new Event2()));</p>
<p>    await _eventStore.AppendAsync(streamId, EnvelopeFactory.Create(new Event3()));</p>

<p>    var events = await _eventStore.ReadAsync<IEvent>(streamId, 0).ToListAsync();</p>

<p>    await Assert.That(events).HasCount().EqualTo(3);</p>
<p>    await Assert.That(events[0].Payload).IsTypeOf<Event1>();</p>
<p>    await Assert.That(events[1].Payload).IsTypeOf<Event2>();</p>
<p>    await Assert.That(events[2].Payload).IsTypeOf<Event3>();</p>
<p>}</p>
<p></code></pre></p>

<h2>Test Naming Convention</h2>

<p>All async test methods must end with <code>Async</code>:</p>

<pre><code class="language-csharp">// ✅ CORRECT
<p>[Test]</p>
<p>public async Task HandleAsync_ValidInput_ReturnsExpectedResultAsync() { }</p>

<p>// ❌ WRONG</p>
<p>[Test]</p>
<p>public async Task HandleAsync_ValidInput_ReturnsExpectedResult() { }</p>
<p></code></pre></p>

<h2>Running Tests</h2>

<pre><code class="language-bash"># Run all tests
<p>dotnet test</p>

<h1>Run with parallel execution</h1>
<p>dotnet test --max-parallel-test-modules 8</p>

<h1>Run specific test file</h1>
<p>cd tests/MyApp.Tests</p>
<p>dotnet run -- --treenode-filter "/MyApp.Tests/<em>/OrderReceptorTests/</em>"</p>

<h1>Run with coverage</h1>
<p>dotnet run -- --coverage --coverage-output-format cobertura</p>
<p></code></pre></p>

<h2>Migration Checklist</h2>

<ul><li>[ ] Replace xUnit/NUnit with TUnit</li>
<li>[ ] Replace Moq/NSubstitute with Rocks</li>
<li>[ ] Replace FluentAssertions with TUnit.Assertions</li>
<li>[ ] Add <code>Async</code> suffix to all async test methods</li>
<li>[ ] Update assertion syntax to <code>await Assert.That(...)</code></li>
<li>[ ] Update mock syntax to Rocks patterns</li>
<li>[ ] Add Whizbang.Testing package</li>
<li>[ ] Configure in-memory event store for unit tests</li>
<li>[ ] Set up TestContainers for integration tests</li>
<li>[ ] Update CI pipeline for TUnit</li>
</ul>
<hr>

<em>Previous: <a href="07-outbox-migration.md">Outbox Migration</a> | Next: <a href="appendix-checklist.md">Migration Checklist</a></em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-migration-guide-readme" class="doc-section">
  <h3>Migration Guide Overview</h3>
  <p class="doc-path"><code>v1.0.0/migration-guide/README</code></p>
  <p class="doc-description"><em>Overview of migrating from Marten/Wolverine and other frameworks to Whizbang</em></p>
  <div class="doc-content">

<h1>Migration Guide Overview</h1>

<p>This guide helps you migrate from <strong>Marten/Wolverine</strong> (the "Critter Stack") and other CQRS/event-sourcing frameworks to Whizbang.</p>

<h2>Why Migrate to Whizbang?</h2>

<p>| Feature | Marten/Wolverine | Whizbang |</p>
<p>|---------|------------------|----------|</p>
<p>| <strong>Reflection</strong> | Runtime reflection | Zero reflection (source generators) |</p>
<p>| <strong>AOT Support</strong> | Partial | Full Native AOT from day one |</p>
<p>| <strong>Database Support</strong> | PostgreSQL only | PostgreSQL, SQLite, extensible |</p>
<p>| <strong>Multi-Tenancy</strong> | Manual | First-class support |</p>
<p>| <strong>Projections</strong> | Async (side effects allowed) | Pure functions (deterministic) |</p>
<p>| <strong>Dashboard</strong> | Not included | Integrated (planned) |</p>

<h2>Migration Paths</h2>

<h3>From Marten/Wolverine</h3>

<p>The most common migration path. Covers:</p>

<ul><li><strong><a href="01-concept-mapping.md">Concept Mapping</a></strong> - Understand how Marten/Wolverine concepts translate to Whizbang</li>
<li><strong><a href="02-project-setup.md">Project Setup</a></strong> - NuGet packages and initial configuration</li>
<li><strong><a href="03-handler-migration.md">Handler Migration</a></strong> - Convert Wolverine handlers to Whizbang Receptors</li>
<li><strong><a href="04-projection-migration.md">Projection Migration</a></strong> - Convert Marten projections to Whizbang Perspectives</li>
<li><strong><a href="05-event-store-migration.md">Event Store Migration</a></strong> - Adapt event store patterns</li>
<li><strong><a href="06-transport-configuration.md">Transport Configuration</a></strong> - Configure RabbitMQ/Azure Service Bus</li>
<li><strong><a href="07-outbox-migration.md">Outbox Migration</a></strong> - Migrate durable outbox patterns</li>
<li><strong><a href="08-testing-migration.md">Testing Migration</a></strong> - Update test infrastructure</li>
</ul>
<h3>Migration Checklist</h3>

<p>See the <strong><a href="appendix-checklist.md">Migration Checklist</a></strong> for a complete step-by-step checklist.</p>

<h2>Automated Migration Tool</h2>

<p>Whizbang provides a CLI migration tool to automate common transformations:</p>

<pre><code class="language-bash"># Install the migration tool
<p>dotnet tool install -g whizbang-migrate</p>

<h1>Analyze your project</h1>
<p>whizbang migrate analyze --project ./MyApp.sln</p>

<h1>Create a migration plan</h1>
<p>whizbang migrate plan --project ./MyApp.sln --output migration-plan.json</p>

<h1>Apply migrations (guided mode with human review)</h1>
<p>whizbang migrate apply --mode guided</p>

<h1>Apply migrations (full automation)</h1>
<p>whizbang migrate apply --mode auto</p>
<p></code></pre></p>

<p>The tool uses <strong>git worktrees</strong> for safe, isolated migrations with automatic rollback on failure.</p>

<p>See the <a href="../tools/whizbang-migrate.md">Migration Tool Documentation</a> for details.</p>

<h2>Key Architectural Differences</h2>

<h3>Zero Reflection</h3>

<p>Whizbang uses Roslyn source generators for all discovery:</p>

<pre><code class="language-csharp">// Wolverine - Runtime discovery via attributes
<p>[WolverineHandler]</p>
<p>public class OrderHandler {</p>
<p>    public OrderCreated Handle(CreateOrder cmd) { ... }</p>
<p>}</p>

<p>// Whizbang - Compile-time discovery via interface</p>
<p>public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    public ValueTask<OrderCreated> HandleAsync(CreateOrder message, CancellationToken ct) { ... }</p>
<p>}</p>
<p></code></pre></p>

<h3>Pure Function Perspectives</h3>

<p>Marten projections can have side effects. Whizbang Perspectives are <strong>pure functions</strong>:</p>

<pre><code class="language-csharp">// Marten - Mutation allowed
<p>public void Apply(OrderSummary model, OrderCreated @event) {</p>
<p>    model.Total += @event.Total;  // Mutates model</p>
<p>}</p>

<p>// Whizbang - Pure function, returns new model</p>
<p>public OrderSummary Apply(OrderSummary current, OrderCreated @event) {</p>
<p>    return current with { Total = current.Total + @event.Total };  // Returns new</p>
<p>}</p>
<p></code></pre></p>

<h3>Three Dispatch Patterns</h3>

<p>Whizbang's <code>IDispatcher</code> provides three distinct patterns:</p>

<p>| Pattern | Use Case | Wire Support |</p>
<p>|---------|----------|--------------|</p>
<p>| <code>SendAsync</code> | Command dispatch with delivery receipt | Yes |</p>
<p>| <code>LocalInvokeAsync</code> | In-process RPC (< 20ns, zero allocation) | No |</p>
<p>| <code>PublishAsync</code> | Event broadcasting (fire-and-forget) | Yes |</p>

<h2>Getting Help</h2>

<ul><li><strong><a href="appendix-troubleshooting.md">Troubleshooting</a></strong> - Common migration issues</li>
<li><strong><a href="https://github.com/whizbang-lib/whizbang/issues">GitHub Issues</a></strong> - Report problems</li>
<li><strong><a href="https://github.com/whizbang-lib/whizbang/discussions">Discussions</a></strong> - Ask questions</li>
</ul>
<hr>

<em>Last Updated: 2026-01-19 | Whizbang v1.0.0</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-migration-guide-appendix-checklist" class="doc-section">
  <h3>Migration Checklist</h3>
  <p class="doc-path"><code>v1.0.0/migration-guide/appendix-checklist</code></p>
  <p class="doc-description"><em>Complete checklist for migrating from Marten/Wolverine to Whizbang</em></p>
  <div class="doc-content">

<h1>Migration Checklist</h1>

<p>Use this checklist to track your migration progress from Marten/Wolverine to Whizbang.</p>

<h2>Phase 1: Project Setup</h2>

<h3>Package Changes</h3>

<ul><li>[ ] Remove Marten packages:</li>
</ul><p>  - [ ] <code>Marten</code></p>
<p>  - [ ] <code>Marten.AspNetCore</code></p>
<p>  - [ ] <code>Marten.Events.Projections</code></p>

<ul><li>[ ] Remove Wolverine packages:</li>
</ul><p>  - [ ] <code>Wolverine</code></p>
<p>  - [ ] <code>Wolverine.Marten</code></p>
<p>  - [ ] <code>WolverineFx.RabbitMQ</code></p>
<p>  - [ ] <code>WolverineFx.AzureServiceBus</code></p>
<p>  - [ ] <code>WolverineFx.Kafka</code></p>

<ul><li>[ ] Add Whizbang packages:</li>
</ul><p>  - [ ] <code>Whizbang.Core</code></p>
<p>  - [ ] <code>Whizbang.Generators</code> (as Analyzer)</p>
<p>  - [ ] <code>Whizbang.Data.EFCore.Postgres</code> or <code>Whizbang.Data.Dapper.Postgres</code></p>
<p>  - [ ] <code>Whizbang.Transports.RabbitMQ</code></p>
<p>  - [ ] <code>Whizbang.Transports.AzureServiceBus</code></p>
<p>  - [ ] <code>Whizbang.Testing</code> (test projects)</p>

<h3>Configuration</h3>

<ul><li>[ ] Update <code>Program.cs</code>:</li>
</ul><p>  - [ ] Replace <code>AddMarten()</code> with <code>AddWhizbang()</code></p>
<p>  - [ ] Remove <code>UseWolverine()</code></p>
<p>  - [ ] Configure transport (RabbitMQ/Azure Service Bus)</p>
<p>  - [ ] Add work coordinator</p>

<ul><li>[ ] Update configuration files:</li>
</ul><p>  - [ ] <code>appsettings.Development.json</code> (RabbitMQ)</p>
<p>  - [ ] <code>appsettings.Production.json</code> (Azure Service Bus)</p>
<p>  - [ ] Add <code>UseRabbitMQ</code> toggle</p>

<ul><li>[ ] Initialize database schema:</li>
</ul><p>  - [ ] Add schema initialization on startup</p>
<p>  - [ ] Verify Whizbang tables created</p>

<hr>

<h2>Phase 2: Handler Migration</h2>

<h3>Convert Wolverine Handlers to Receptors</h3>

<p>For each handler:</p>

<ul><li>[ ] Remove <code>[WolverineHandler]</code> attribute</li>
<li>[ ] Implement <code>IReceptor<TMessage, TResult></code> or <code>IReceptor<TMessage></code></li>
<li>[ ] Rename method to <code>HandleAsync</code></li>
<li>[ ] Change return type to <code>ValueTask<TResult></code> or <code>ValueTask</code></li>
<li>[ ] Add <code>CancellationToken</code> parameter</li>
<li>[ ] Convert method injection to constructor injection</li>
<li>[ ] Split multi-handler classes into separate receptors</li>
<li>[ ] Update namespace usings</li>
</ul>
<h3>Handler Checklist Template</h3>

<p>| Handler | Status | Receptor Name | Notes |</p>
<p>|---------|--------|---------------|-------|</p>
<p>| <code>OrderHandler.Handle(CreateOrder)</code> | ☐ | <code>CreateOrderReceptor</code> | |</p>
<p>| <code>OrderHandler.Handle(ShipOrder)</code> | ☐ | <code>ShipOrderReceptor</code> | |</p>
<p>| <code>NotificationHandler.Handle(SendEmail)</code> | ☐ | <code>SendEmailReceptor</code> | Void receptor |</p>

<hr>

<h2>Phase 3: Projection Migration</h2>

<h3>Convert Marten Projections to Perspectives</h3>

<p>For each projection:</p>

<ul><li>[ ] Replace <code>SingleStreamProjection<T></code> with <code>IPerspectiveFor<T, TEvent...></code></li>
<li>[ ] Replace <code>MultiStreamProjection<T, TKey></code> with <code>IGlobalPerspectiveFor<...></code></li>
<li>[ ] Convert mutation to immutable (<code>model.X = y</code> → <code>current with { X = y }</code>)</li>
<li>[ ] Move async operations to receptors</li>
<li>[ ] Use <code>sealed record</code> for model types</li>
<li>[ ] Add variadic event types to interface</li>
<li>[ ] Implement <code>GetPartitionKey</code> for global perspectives</li>
</ul>
<h3>Projection Checklist Template</h3>

<p>| Projection | Status | Perspective Name | Events |</p>
<p>|------------|--------|------------------|--------|</p>
<p>| <code>OrderSummaryProjection</code> | ☐ | <code>OrderSummaryPerspective</code> | Created, Shipped, Cancelled |</p>
<p>| <code>CustomerStatsProjection</code> | ☐ | <code>CustomerStatsPerspective</code> | OrderCreated, OrderCompleted |</p>

<hr>

<h2>Phase 4: Event Store Migration</h2>

<h3>Update Event Store Usage</h3>

<ul><li>[ ] Replace <code>IDocumentStore</code> with <code>IEventStore</code></li>
<li>[ ] Replace <code>IDocumentSession</code> with direct <code>IEventStore</code> injection</li>
<li>[ ] Replace <code>session.Events.Append()</code> with <code>eventStore.AppendAsync<T>()</code></li>
<li>[ ] Create <code>MessageEnvelope<T></code> for each event</li>
<li>[ ] Use <code>Guid.CreateVersion7()</code> for new stream IDs</li>
<li>[ ] Remove <code>session.SaveChangesAsync()</code> calls</li>
<li>[ ] Update concurrency handling to sequence-based</li>
<li>[ ] Update event queries to use <code>IEventStore</code> methods</li>
</ul>
<hr>

<h2>Phase 5: Messaging Migration</h2>

<h3>Transport Configuration</h3>

<ul><li>[ ] Configure RabbitMQ for local development</li>
<li>[ ] Configure Azure Service Bus for production</li>
<li>[ ] Set up environment-based switching</li>
<li>[ ] Add health checks for transport</li>
<li>[ ] Update Aspire integration (if using)</li>
</ul>
<h3>Outbox/Inbox</h3>

<ul><li>[ ] Remove <code>UseDurableOutbox()</code> configuration</li>
<li>[ ] Remove <code>UseDurableInbox()</code> configuration</li>
<li>[ ] Configure <code>IWorkCoordinatorStrategy</code></li>
<li>[ ] Add <code>WorkCoordinatorPublisherWorker</code> hosted service</li>
<li>[ ] Update retry policies</li>
</ul>
<hr>

<h2>Phase 6: Testing Migration</h2>

<h3>Test Framework</h3>

<ul><li>[ ] Replace xUnit/NUnit with TUnit</li>
<li>[ ] Replace Moq/NSubstitute with Rocks</li>
<li>[ ] Replace FluentAssertions with TUnit.Assertions</li>
<li>[ ] Add <code>Async</code> suffix to all async test methods</li>
</ul>
<h3>Test Updates</h3>

<ul><li>[ ] Update assertion syntax to <code>await Assert.That(...)</code></li>
<li>[ ] Update mock syntax to Rocks patterns</li>
<li>[ ] Add Whizbang.Testing package</li>
<li>[ ] Configure in-memory event store for unit tests</li>
<li>[ ] Set up TestContainers for integration tests</li>
</ul>
<h3>Test Coverage</h3>

<ul><li>[ ] Update receptor tests</li>
<li>[ ] Create perspective tests (pure function tests)</li>
<li>[ ] Update integration tests</li>
<li>[ ] Update CI pipeline</li>
</ul>
<hr>

<h2>Phase 7: Verification</h2>

<h3>Build Verification</h3>

<ul><li>[ ] Solution builds without errors</li>
<li>[ ] No Marten/Wolverine namespace warnings</li>
<li>[ ] Source generators produce expected output</li>
<li>[ ] <code>dotnet format</code> passes</li>
</ul>
<h3>Runtime Verification</h3>

<ul><li>[ ] Application starts successfully</li>
<li>[ ] Database schema initialized</li>
<li>[ ] Receptors discovered (check logs)</li>
<li>[ ] Perspectives registered</li>
<li>[ ] Transport connected</li>
</ul>
<h3>Functional Verification</h3>

<ul><li>[ ] Events persist to database</li>
<li>[ ] Perspectives update correctly</li>
<li>[ ] Messages published to transport</li>
<li>[ ] Outbox processes messages</li>
<li>[ ] Inbox deduplicates messages</li>
</ul>
<h3>Test Verification</h3>

<ul><li>[ ] All unit tests pass</li>
<li>[ ] All integration tests pass</li>
<li>[ ] Test coverage maintained or improved</li>
</ul>
<hr>

<h2>Phase 8: Cleanup</h2>

<h3>Code Cleanup</h3>

<ul><li>[ ] Remove unused Marten/Wolverine files</li>
<li>[ ] Remove old configuration classes</li>
<li>[ ] Update XML documentation</li>
<li>[ ] Run <code>dotnet format</code></li>
</ul>
<h3>Documentation</h3>

<ul><li>[ ] Update README</li>
<li>[ ] Update architecture diagrams</li>
<li>[ ] Update deployment documentation</li>
<li>[ ] Update onboarding guides</li>
</ul>
<h3>Deployment</h3>

<ul><li>[ ] Update CI/CD pipeline</li>
<li>[ ] Update environment variables</li>
<li>[ ] Update secrets management</li>
<li>[ ] Plan production rollout</li>
</ul>
<hr>

<h2>Quick Reference</h2>

<h3>Namespace Changes</h3>

<pre><code class="language-csharp">// Remove
<p>using Marten;</p>
<p>using Marten.Events;</p>
<p>using Marten.Events.Projections;</p>
<p>using Wolverine;</p>
<p>using Wolverine.Attributes;</p>

<p>// Add</p>
<p>using Whizbang.Core;</p>
<p>using Whizbang.Core.Messaging;</p>
<p>using Whizbang.Core.Perspectives;</p>
<p></code></pre></p>

<h3>Key Pattern Changes</h3>

<p>| Before | After |</p>
<p>|--------|-------|</p>
<p>| <code>IDocumentStore</code> | <code>IEventStore</code> |</p>
<p>| <code>IDocumentSession</code> | Direct injection |</p>
<p>| <code>[WolverineHandler]</code> | <code>IReceptor<T></code> interface |</p>
<p>| <code>SingleStreamProjection<T></code> | <code>IPerspectiveFor<T, TEvent...></code> |</p>
<p>| <code>session.Events.Append()</code> | <code>eventStore.AppendAsync<T>()</code> |</p>
<p>| <code>model.X = y</code> | <code>current with { X = y }</code> |</p>

<hr>

<h2>Automated Migration Tool</h2>

<p>Use <code>whizbang-migrate</code> to automate common transformations:</p>

<pre><code class="language-bash"># Install
<p>dotnet tool install -g whizbang-migrate</p>

<h1>Analyze</h1>
<p>whizbang migrate analyze --project ./MyApp.sln</p>

<h1>Plan</h1>
<p>whizbang migrate plan --project ./MyApp.sln</p>

<h1>Apply (guided)</h1>
<p>whizbang migrate apply --mode guided</p>

<h1>Check status</h1>
<p>whizbang migrate status</p>
<p></code></pre></p>

<hr>

<em>Need help? See <a href="appendix-troubleshooting.md">Troubleshooting</a> or open an issue on GitHub.</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Perspectives</h2>
<article id="v1-0-0-perspectives-registry" class="doc-section">
  <h3>registry</h3>
  <p class="doc-path"><code>v1.0.0/perspectives/registry</code></p>
  <div class="doc-content">
<h1>Perspective Registry</h1>

<p>The perspective registry is a system table that tracks the mapping between your C# perspective types and their corresponding database tables. It enables automatic schema management, drift detection, and safe table renaming across deployments.</p>

<h2>Overview</h2>

<p>When Whizbang creates perspective tables, it registers metadata about each perspective in the <code>wh_perspective_registry</code> table. This enables:</p>

<p>| Feature | Description |</p>
<p>|---------|-------------|</p>
<p>| <strong>CLR Type Tracking</strong> | Maps fully-qualified C# type names to table names |</p>
<p>| <strong>Schema Hashing</strong> | SHA-256 hash of table schema for drift detection |</p>
<p>| <strong>Auto-Rename</strong> | Automatically renames tables when perspective names change |</p>
<p>| <strong>Multi-Service</strong> | Tracks which service owns each perspective |</p>

<h2>How It Works</h2>

<h3>Registration Flow</h3>

<pre><code class="language-">┌─────────────────────┐
<p>│  Source Generator   │</p>
<p>│  (compile time)     │</p>
<p>├─────────────────────┤</p>
<p>│ Generates metadata: │</p>
<p>│ - CLR type name     │</p>
<p>│ - Table name        │</p>
<p>│ - Schema JSON       │</p>
<p>│ - Schema hash       │</p>
<p>└─────────┬───────────┘</p>
<p>          │</p>
<p>          ▼</p>
<p>┌─────────────────────┐</p>
<p>│  Application Start  │</p>
<p>│  (runtime)          │</p>
<p>├─────────────────────┤</p>
<p>│ Calls reconcile_    │</p>
<p>│ perspective_        │</p>
<p>│ registry()          │</p>
<p>└─────────┬───────────┘</p>
<p>          │</p>
<p>          ▼</p>
<p>┌─────────────────────┐</p>
<p>│  Database           │</p>
<p>├─────────────────────┤</p>
<p>│ - Inserts new types │</p>
<p>│ - Detects renames   │</p>
<p>│ - Detects drift     │</p>
<p>└─────────────────────┘</p>
<p></code></pre></p>

<h3>Registry Table Schema</h3>

<pre><code class="language-sql">CREATE TABLE wh_perspective_registry (
<p>  id UUID PRIMARY KEY,</p>
<p>  clr_type_name VARCHAR(500) NOT NULL,    -- "MyApp.OrderProjection, MyApp"</p>
<p>  table_name VARCHAR(255) NOT NULL,        -- "wh_per_order"</p>
<p>  schema_json JSONB NOT NULL,              -- Full column/index definition</p>
<p>  schema_hash VARCHAR(64) NOT NULL,        -- SHA-256 of canonical schema</p>
<p>  service_name VARCHAR(255) NOT NULL,      -- "MyApp.Api"</p>
<p>  created_at TIMESTAMPTZ NOT NULL,</p>
<p>  updated_at TIMESTAMPTZ NOT NULL,</p>
<p>  UNIQUE(clr_type_name, service_name)</p>
<p>);</p>
<p></code></pre></p>

<h2>Reconciliation Actions</h2>

<p>When your application starts, the reconciliation function compares registered perspectives against the database and returns actions taken:</p>

<p>| Action | When It Occurs |</p>
<p>|--------|----------------|</p>
<p>| <code>inserted</code> | New perspective type registered for the first time |</p>
<p>| <code>updated</code> | Existing type refreshed (timestamps updated) |</p>
<p>| <code>renamed</code> | Table name changed - executes <code>ALTER TABLE RENAME</code> |</p>
<p>| <code>drift_detected</code> | Schema hash differs from previous deployment |</p>

<h3>Example Output</h3>

<pre><code class="language-csharp">// Startup logs show reconciliation results
<p>[INF] Perspective registry reconciliation complete:</p>
<p>[INF]   - inserted: MyApp.NewOrderProjection -> wh_per_new_order</p>
<p>[INF]   - renamed: MyApp.CustomerDto -> wh_per_customer (was: wh_per_customer_dto)</p>
<p>[INF]   - drift_detected: MyApp.ProductView (schema changed)</p>
<p></code></pre></p>

<h2>Schema Drift Detection</h2>

<p>Schema drift occurs when your C# perspective class changes but the database table wasn't updated. The registry detects this by comparing schema hashes.</p>

<h3>What Causes Drift</h3>

<ul><li>Adding or removing properties from your perspective model</li>
<li>Changing property types (e.g., <code>int</code> to <code>long</code>)</li>
<li>Adding new indexes via attributes</li>
<li>Removing physical fields</li>
</ul>
<h3>Handling Drift</h3>

<p>When drift is detected, Whizbang logs a warning. You can then:</p>

<ul><li><strong>Run migrations</strong> to update the table schema</li>
<li><strong>Recreate the table</strong> if the changes are breaking</li>
<li><strong>Ignore</strong> if the changes are backward-compatible</li>
</ul>
<pre><code class="language-csharp">// Configure drift handling behavior
<p>services.AddWhizbang(options => {</p>
<p>  options.Perspectives.OnSchemaDrift = SchemaDriftBehavior.LogWarning;</p>
<p>  // Other options: ThrowException, AutoMigrate (future)</p>
<p>});</p>
<p></code></pre></p>

<h2>Automatic Table Renaming</h2>

<p>When you rename a perspective class or change its table name, the registry automatically handles the rename:</p>

<h3>Before</h3>

<pre><code class="language-csharp">[Perspective("customer_dto")]  // Old name
<p>public class CustomerDto : IPerspectiveFor<CustomerData, CustomerCreatedEvent> {</p>
<p>  // ...</p>
<p>}</p>
<p></code></pre></p>

<h3>After</h3>

<pre><code class="language-csharp">[Perspective("customer")]  // New name (or rely on suffix stripping)
<p>public class CustomerDto : IPerspectiveFor<CustomerData, CustomerCreatedEvent> {</p>
<p>  // ...</p>
<p>}</p>
<p></code></pre></p>

<h3>What Happens</h3>

<ul><li>Application starts and calls <code>reconcile_perspective_registry()</code></li>
<li>Registry finds existing entry for <code>MyApp.CustomerDto</code></li>
<li>Detects table name changed from <code>wh_per_customer_dto</code> to <code>wh_per_customer</code></li>
<li>Executes: <code>ALTER TABLE wh_per_customer_dto RENAME TO wh_per_customer</code></li>
<li>Updates registry with new table name</li>
</ul>
<p>This happens automatically - no manual migration required.</p>

<h2>Multi-Service Scenarios</h2>

<p>In microservice architectures, multiple services may define perspectives. The registry tracks which service owns each perspective via the <code>service_name</code> column.</p>

<pre><code class="language-csharp">// Service A: OrderService
<p>public class OrderProjection : IPerspectiveFor<OrderData, OrderCreatedEvent> { }</p>
<p>// Registered as: OrderService.OrderProjection, wh_per_order, "OrderService"</p>

<p>// Service B: AnalyticsService</p>
<p>public class OrderProjection : IPerspectiveFor<OrderAnalytics, OrderCreatedEvent> { }</p>
<p>// Registered as: AnalyticsService.OrderProjection, wh_per_order, "AnalyticsService"</p>
<p></code></pre></p>

<p>The unique constraint <code>(clr_type_name, service_name)</code> allows the same type name in different services.</p>

<h2>Schema JSON Format</h2>

<p>The registry stores the full schema definition as JSON for debugging and migration tooling:</p>

<pre><code class="language-json">{
<p>  "columns": [</p>
<p>    {"name": "id", "type": "uuid", "nullable": false, "isPrimaryKey": true},</p>
<p>    {"name": "data", "type": "jsonb", "nullable": false},</p>
<p>    {"name": "customer_id", "type": "uuid", "nullable": true, "isPhysicalField": true}</p>
<p>  ],</p>
<p>  "indexes": [</p>
<p>    {"name": "idx_customer_customer_id", "columns": ["customer_id"], "type": "btree"}</p>
<p>  ]</p>
<p>}</p>
<p></code></pre></p>

<h3>Schema Hash Algorithm</h3>

<p>The schema hash is computed using:</p>

<ul><li>Serialize schema to <strong>canonical JSON</strong> (sorted keys, no whitespace, lowercase types)</li>
<li>Encode as UTF-8 bytes</li>
<li>Compute SHA-256 hash</li>
<li>Output as 64-character lowercase hex string</li>
</ul>
<p>This ensures consistent hashes across deployments regardless of serialization order.</p>

<h2>Querying the Registry</h2>

<p>You can query the registry directly for debugging:</p>

<pre><code class="language-sql">-- All perspectives for a service
<p>SELECT clr_type_name, table_name, schema_hash, updated_at</p>
<p>FROM wh_perspective_registry</p>
<p>WHERE service_name = 'MyApp.Api'</p>
<p>ORDER BY table_name;</p>

<p>-- Find perspectives with schema drift (compare with application metadata)</p>
<p>SELECT clr_type_name, table_name, schema_hash</p>
<p>FROM wh_perspective_registry</p>
<p>WHERE schema_hash != 'expected_hash_from_app';</p>

<p>-- Recently updated perspectives</p>
<p>SELECT clr_type_name, table_name, updated_at</p>
<p>FROM wh_perspective_registry</p>
<p>WHERE updated_at > NOW() - INTERVAL '1 hour';</p>
<p></code></pre></p>

<h2>Configuration</h2>

<p>The registry is automatically created as part of the Whizbang infrastructure schema. No additional configuration is required.</p>

<pre><code class="language-csharp">// Registry is included in standard initialization
<p>await dbContext.EnsureWhizbangDatabaseInitializedAsync();</p>
<p></code></pre></p>

<h2>See Also</h2>

<ul><li><a href="/docs/v1.0.0/perspectives/table-naming">Table Naming</a> - Configure table name generation</li>
<li><a href="/docs/v1.0.0/data/schema-migration">Schema Migration</a> - Database schema management</li>
<li><a href="/docs/v1.0.0/perspectives/temporal">Temporal Perspectives</a> - Append-only perspective pattern</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-perspectives-table-naming" class="doc-section">
  <h3>table naming</h3>
  <p class="doc-path"><code>v1.0.0/perspectives/table-naming</code></p>
  <div class="doc-content">
<h1>Perspective Table Naming</h1>

<p>Whizbang automatically generates database table names for your perspectives using configurable naming conventions. By default, common suffixes like <code>Projection</code>, <code>Model</code>, and <code>Dto</code> are stripped to create cleaner, shorter table names.</p>

<h2>Default Behavior</h2>

<p>When you define a perspective, Whizbang converts the class name to snake_case and adds the <code>wh_per_</code> prefix:</p>

<p>| C# Class Name | Default Table Name |</p>
<p>|--------------|-------------------|</p>
<p>| <code>OrderProjection</code> | <code>wh_per_order</code> |</p>
<p>| <code>CustomerDto</code> | <code>wh_per_customer</code> |</p>
<p>| <code>ProductReadModel</code> | <code>wh_per_product</code> |</p>
<p>| <code>ActivityView</code> | <code>wh_per_activity</code> |</p>
<p>| <code>InventoryModel</code> | <code>wh_per_inventory</code> |</p>

<h3>Why Strip Suffixes?</h3>

<p>Suffixes like <code>Projection</code>, <code>Model</code>, <code>Dto</code>, and <code>View</code> describe what the class <em>is</em> in your codebase, but add no value in the database. Stripping them results in:</p>

<ul><li><strong>Shorter table names</strong>: Easier to work with in SQL queries</li>
<li><strong>Cleaner schema</strong>: <code>wh_per_order</code> is clearer than <code>wh_per_order_projection</code></li>
<li><strong>Consistent naming</strong>: Different teams may use <code>Dto</code> vs <code>Model</code> vs <code>View</code> - all become the same</li>
</ul>
<h2>Configuring Suffix Stripping</h2>

<h3>MSBuild Properties</h3>

<p>Configure suffix stripping in your project file:</p>

<pre><code class="language-xml"><PropertyGroup>
<p>  <!-- Enable/disable suffix stripping (default: true) --></p>
<p>  <WhizbangStripTableNameSuffixes>true</WhizbangStripTableNameSuffixes></p>

<p>  <!-- Suffixes to strip (default list shown) --></p>
<p>  <WhizbangTableNameSuffixesToStrip>Model,Projection,ReadModel,Dto,View</WhizbangTableNameSuffixesToStrip></p>
<p></PropertyGroup></p>
<p></code></pre></p>

<h3>Disabling Suffix Stripping</h3>

<p>To keep the full class name in table names:</p>

<pre><code class="language-xml"><PropertyGroup>
<p>  <WhizbangStripTableNameSuffixes>false</WhizbangStripTableNameSuffixes></p>
<p></PropertyGroup></p>
<p></code></pre></p>

<p>With stripping disabled:</p>

<p>| C# Class Name | Table Name |</p>
<p>|--------------|------------|</p>
<p>| <code>OrderProjection</code> | <code>wh_per_order_projection</code> |</p>
<p>| <code>CustomerDto</code> | <code>wh_per_customer_dto</code> |</p>

<h3>Custom Suffixes</h3>

<p>Add or modify the suffixes to strip:</p>

<pre><code class="language-xml"><PropertyGroup>
<p>  <!-- Add custom suffixes --></p>
<p>  <WhizbangTableNameSuffixesToStrip>Model,Projection,ReadModel,Dto,View,ViewModel,State</WhizbangTableNameSuffixesToStrip></p>
<p></PropertyGroup></p>
<p></code></pre></p>

<h2>Explicit Table Names</h2>

<p>Override the generated name using the <code>[Perspective]</code> attribute:</p>

<pre><code class="language-csharp">// Explicit table name - ignores all conventions
<p>[Perspective("custom_orders")]</p>
<p>public class OrderProjection : IPerspectiveFor<OrderData, OrderCreatedEvent> {</p>
<p>  // Table: wh_per_custom_orders</p>
<p>}</p>
<p></code></pre></p>

<p>This is useful when:</p>
<ul><li>You need a specific table name for compatibility</li>
<li>The generated name would be ambiguous</li>
<li>You're renaming a perspective and want to preserve the old table name</li>
</ul>
<h2>Naming Convention Details</h2>

<h3>Conversion Rules</h3>

<ul><li><strong>PascalCase to snake_case</strong>: <code>OrderDetails</code> → <code>order_details</code></li>
<li><strong>Acronyms preserved</strong>: <code>APIResponse</code> → <code>api_response</code></li>
<li><strong>Numbers preserved</strong>: <code>Order2024</code> → <code>order2024</code></li>
<li><strong>Suffix stripping</strong>: <code>OrderProjection</code> → <code>order</code> (suffix removed before conversion)</li>
</ul>
<h3>Examples</h3>

<p>| Class Name | Suffix Stripped | Snake Case | Final Table |</p>
<p>|------------|----------------|------------|-------------|</p>
<p>| <code>OrderProjection</code> | <code>Order</code> | <code>order</code> | <code>wh_per_order</code> |</p>
<p>| <code>CustomerAccountDto</code> | <code>CustomerAccount</code> | <code>customer_account</code> | <code>wh_per_customer_account</code> |</p>
<p>| <code>ProductInventoryModel</code> | <code>ProductInventory</code> | <code>product_inventory</code> | <code>wh_per_product_inventory</code> |</p>
<p>| <code>APIUsageView</code> | <code>APIUsage</code> | <code>api_usage</code> | <code>wh_per_api_usage</code> |</p>
<p>| <code>Order2024Projection</code> | <code>Order2024</code> | <code>order2024</code> | <code>wh_per_order2024</code> |</p>

<h3>Edge Cases</h3>

<p>| Class Name | Notes | Table Name |</p>
<p>|------------|-------|------------|</p>
<p>| <code>Model</code> | Only suffix, no stripping | <code>wh_per_model</code> |</p>
<p>| <code>OrderModelProjection</code> | Only last suffix stripped | <code>wh_per_order_model</code> |</p>
<p>| <code>Dto</code> | Only suffix, no stripping | <code>wh_per_dto</code> |</p>

<h2>Table Name Conflicts</h2>

<p>If two perspectives would generate the same table name, you'll get a compile-time error:</p>

<pre><code class="language-csharp">// Both would generate wh_per_order
<p>public class OrderProjection : IPerspectiveFor<OrderData, OrderCreatedEvent> { }</p>
<p>public class OrderDto : IPerspectiveFor<OrderSummary, OrderCreatedEvent> { }</p>
<p>// Error: WB1001 - Duplicate perspective table name 'wh_per_order'</p>
<p></code></pre></p>

<p>Resolve by using explicit names:</p>

<pre><code class="language-csharp">[Perspective("order_details")]
<p>public class OrderProjection : IPerspectiveFor<OrderData, OrderCreatedEvent> { }</p>

<p>[Perspective("order_summary")]</p>
<p>public class OrderDto : IPerspectiveFor<OrderSummary, OrderCreatedEvent> { }</p>
<p></code></pre></p>

<h2>Renaming Perspectives</h2>

<p>When you rename a perspective class, the <a href="/docs/v1.0.0/perspectives/registry">perspective registry</a> automatically handles the table rename:</p>

<h3>Before</h3>

<pre><code class="language-csharp">public class CustomerDataProjection : IPerspectiveFor<CustomerData, CustomerEvent> { }
<p>// Table: wh_per_customer_data</p>
<p></code></pre></p>

<h3>After</h3>

<pre><code class="language-csharp">public class CustomerProjection : IPerspectiveFor<CustomerData, CustomerEvent> { }
<p>// Table: wh_per_customer</p>
<p></code></pre></p>

<p>On next application start:</p>
<ul><li>Registry detects table name changed</li>
<li>Executes <code>ALTER TABLE wh_per_customer_data RENAME TO wh_per_customer</code></li>
<li>Data preserved, no migration needed</li>
</ul>
<h2>Prefix Configuration</h2>

<p>The <code>wh_per_</code> prefix is part of Whizbang's schema configuration:</p>

<pre><code class="language-csharp">services.AddWhizbang(options => {
<p>  options.Schema.InfrastructurePrefix = "wh_";    // Default</p>
<p>  options.Schema.PerspectivePrefix = "wh_per_";   // Default</p>
<p>});</p>
<p></code></pre></p>

<p>Changing prefixes affects all table names:</p>

<p>| Prefix | Table Name |</p>
<p>|--------|------------|</p>
<p>| <code>wh_per_</code> (default) | <code>wh_per_order</code> |</p>
<p>| <code>app_view_</code> | <code>app_view_order</code> |</p>
<p>| <code>proj_</code> | <code>proj_order</code> |</p>

<h2>Best Practices</h2>

<ul><li><strong>Use descriptive class names</strong>: <code>OrderSummaryProjection</code> is better than <code>OrderProj</code></li>
<li><strong>Let suffix stripping work</strong>: Don't manually abbreviate names</li>
<li><strong>Use explicit names sparingly</strong>: Only when conventions don't fit</li>
<li><strong>Be consistent</strong>: Pick one suffix convention (<code>Projection</code>, <code>Dto</code>, etc.) for your team</li>
<li><strong>Document custom names</strong>: If using <code>[Perspective("...")]</code>, explain why</li>
</ul>
<h2>See Also</h2>

<ul><li><a href="/docs/v1.0.0/perspectives/registry">Perspective Registry</a> - Automatic table tracking and renaming</li>
<li><a href="/docs/v1.0.0/data/schema-migration">Schema Migration</a> - Database schema management</li>
<li><a href="/docs/v1.0.0/perspectives/temporal">Temporal Perspectives</a> - Append-only perspective pattern</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-perspectives-temporal" class="doc-section">
  <h3>temporal</h3>
  <p class="doc-path"><code>v1.0.0/perspectives/temporal</code></p>
  <div class="doc-content">
<h1>Temporal Perspectives</h1>

<p>Temporal perspectives create append-only logs where each event creates a NEW row rather than updating existing rows. This pattern is ideal for activity feeds, audit logs, and full history tracking.</p>

<h2>Overview</h2>

<p>| Pattern | Interface | Storage | Use Case |</p>
<p>|---------|-----------|---------|----------|</p>
<p>| Standard | <code>IPerspectiveFor</code> | UPSERT (one row per stream) | Current state views |</p>
<p>| Temporal | <code>ITemporalPerspectiveFor</code> | INSERT (new row per event) | Activity feeds, audit logs |</p>

<h2>Defining a Temporal Perspective</h2>

<pre><code class="language-csharp">public class ActivityPerspective :
<p>    ITemporalPerspectiveFor<ActivityEntry, OrderCreatedEvent, OrderUpdatedEvent> {</p>

<p>  public ActivityEntry? Transform(OrderCreatedEvent @event) {</p>
<p>    return new ActivityEntry {</p>
<p>      SubjectId = @event.OrderId,</p>
<p>      Action = "created",</p>
<p>      Description = $"Order created for ${@event.TotalAmount}"</p>
<p>    };</p>
<p>  }</p>

<p>  public ActivityEntry? Transform(OrderUpdatedEvent @event) {</p>
<p>    return new ActivityEntry {</p>
<p>      SubjectId = @event.OrderId,</p>
<p>      Action = "updated",</p>
<p>      Description = $"Order status changed to {@event.NewStatus}"</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Key Differences from IPerspectiveFor</h3>

<ul><li><strong>Transform vs Apply</strong>: <code>Transform(event)</code> instead of <code>Apply(currentData, event)</code></li>
<li><strong>No current state</strong>: Transform only receives the event, not existing data</li>
<li><strong>Nullable return</strong>: Return <code>null</code> to skip an event (no entry created)</li>
<li><strong>Always INSERT</strong>: Never updates existing rows</li>
</ul>
<h2>Temporal Row Structure</h2>

<p>Each temporal row includes:</p>

<pre><code class="language-csharp">public class TemporalPerspectiveRow<TModel> {
<p>  public Guid Id { get; }           // UUIDv7 for time-ordering</p>
<p>  public Guid StreamId { get; }     // Aggregate ID</p>
<p>  public Guid EventId { get; }      // Source event ID</p>
<p>  public TModel Data { get; }       // Transformed entry</p>
<p>  public PerspectiveMetadata Metadata { get; }</p>
<p>  public PerspectiveScope Scope { get; }</p>

<p>  // Temporal tracking (SQL Server patterns)</p>
<p>  public TemporalActionType ActionType { get; }  // Insert/Update/Delete</p>
<p>  public DateTime PeriodStart { get; }           // When recorded (system time)</p>
<p>  public DateTime PeriodEnd { get; }             // When superseded</p>
<p>  public DateTimeOffset ValidTime { get; }       // Business time from event</p>
<p>}</p>
<p></code></pre></p>

<h2>Querying Temporal Data</h2>

<h3>All History</h3>

<pre><code class="language-csharp">var allHistory = await temporalLens
<p>    .TemporalAll()</p>
<p>    .Where(r => r.StreamId == orderId)</p>
<p>    .OrderBy(r => r.PeriodStart)</p>
<p>    .ToListAsync();</p>
<p></code></pre></p>

<h3>Latest Per Stream</h3>

<pre><code class="language-csharp">var latestStates = await temporalLens
<p>    .LatestPerStream()</p>
<p>    .ToListAsync();</p>
<p></code></pre></p>

<h3>Point-in-Time Query (As Of)</h3>

<pre><code class="language-csharp">var stateLastWeek = await temporalLens
<p>    .TemporalAsOf(DateTimeOffset.UtcNow.AddDays(-7))</p>
<p>    .ToListAsync();</p>
<p></code></pre></p>

<h3>Time Range Queries</h3>

<pre><code class="language-csharp">// Rows active during a range
<p>var activeRows = await temporalLens</p>
<p>    .TemporalFromTo(startTime, endTime)</p>
<p>    .ToListAsync();</p>

<p>// Rows fully contained in a range</p>
<p>var containedRows = await temporalLens</p>
<p>    .TemporalContainedIn(startTime, endTime)</p>
<p>    .ToListAsync();</p>
<p></code></pre></p>

<h3>Convenience Methods</h3>

<pre><code class="language-csharp">// Recent activity for a stream
<p>var orderActivity = await temporalLens</p>
<p>    .RecentActivityForStream(orderId, limit: 20)</p>
<p>    .ToListAsync();</p>

<p>// Recent activity for a user</p>
<p>var userActivity = await temporalLens</p>
<p>    .RecentActivityForUser(userId, limit: 50)</p>
<p>    .ToListAsync();</p>
<p></code></pre></p>

<h2>Action Types</h2>

<p>The <code>TemporalActionType</code> enum tracks what happened:</p>

<pre><code class="language-csharp">public enum TemporalActionType {
<p>  Insert,   // New entity created</p>
<p>  Update,   // Entity modified</p>
<p>  Delete    // Entity removed/soft-deleted</p>
<p>}</p>
<p></code></pre></p>

<h2>Filtering Events</h2>

<p>Return <code>null</code> from Transform to skip events:</p>

<pre><code class="language-csharp">public ActivityEntry? Transform(OrderCreatedEvent @event) {
<p>  // Only log high-value orders</p>
<p>  if (@event.TotalAmount < 100) {</p>
<p>    return null;  // Skip this event</p>
<p>  }</p>

<p>  return new ActivityEntry { ... };</p>
<p>}</p>
<p></code></pre></p>

<h2>Bi-Temporal Support</h2>

<p>Temporal perspectives support both system time and business time:</p>

<ul><li><strong>PeriodStart/PeriodEnd</strong>: When the database recorded the change (system time)</li>
<li><strong>ValidTime</strong>: When the event occurred in business terms</li>
</ul>
<p>This enables queries like "what did we know about this order on January 15th?"</p>

<h2>See Also</h2>

<ul><li><a href="/docs/perspectives/overview">Standard Perspectives</a></li>
<li><a href="/api/ITemporalLensQuery">ITemporalLensQuery Reference</a></li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Source Generators</h2>
<article id="v1-0-0-source-generators-aggregate-ids" class="doc-section">
  <h3>Aggregate IDs</h3>
  <p class="doc-path"><code>v1.0.0/source-generators/aggregate-ids</code></p>
  <p class="doc-description"><em>Zero-reflection aggregate ID extraction for PolicyContext - compile-time discovery of [AggregateId] marked properties</em></p>
  <div class="doc-content">

<h1>Aggregate IDs</h1>

<p>The <strong>AggregateIdGenerator</strong> discovers properties marked with <code>[AggregateId]</code> at compile-time and generates zero-reflection extractor methods. This enables <code>PolicyContext</code> to extract aggregate IDs from messages for distributed tracing, tenant isolation, and policy decisions without runtime reflection.</p>

<h2>Why Aggregate IDs?</h2>

<strong>Aggregate IDs</strong> are the primary identifiers for domain entities (Orders, Customers, Products). Whizbang uses them for:

<p>| Use Case | Description | Example |</p>
<p>|----------|-------------|---------|</p>
<p>| <strong>Distributed Tracing</strong> | Group all events for an aggregate | All events for Order #123 |</p>
<p>| <strong>Tenant Isolation</strong> | Route messages to correct tenant database | Customer #456 → Tenant A database |</p>
<p>| <strong>Policy Decisions</strong> | Make routing decisions based on ID | High-value orders → Priority queue |</p>
<p>| <strong>Stream Keys</strong> | Organize events in Event Store | Stream: <code>Order-abc123</code> |</p>
<p>| <strong>Partitioning</strong> | Distribute work across instances | Order #789 → Instance 2 |</p>

<strong>Problem</strong>: Extracting IDs at runtime requires <strong>reflection</strong> (slow, not AOT-compatible).

<strong>Solution</strong>: Generator discovers IDs at compile-time, generates <strong>zero-reflection extractors</strong>.

<hr>

<h2>How It Works</h2>

<h3>1. Mark Properties with [AggregateId]</h3>

<pre><code class="language-csharp">using Whizbang.Core;

<p>// Command</p>
<p>public record CreateOrder(</p>
<p>    [property: AggregateId] Guid OrderId,  // ← Marked as aggregate ID</p>
<p>    Guid CustomerId,</p>
<p>    OrderItem[] Items</p>
<p>) : ICommand;</p>

<p>// Event</p>
<p>public record OrderCreated(</p>
<p>    [property: AggregateId] Guid OrderId,  // ← Marked as aggregate ID</p>
<p>    Guid CustomerId,</p>
<p>    decimal Total,</p>
<p>    DateTimeOffset CreatedAt</p>
<p>) : IEvent;</p>
<p></code></pre></p>

<strong>Convention</strong>: One <code>[AggregateId]</code> per message type (typically the primary entity ID).

<hr>

<h3>2. Compile-Time Discovery</h3>

<pre><code class="language-">┌──────────────────────────────────────────────────┐
<p>│  AggregateIdGenerator (Roslyn)                  │</p>
<p>│                                                  │</p>
<p>│  1. Scan syntax tree for records/classes        │</p>
<p>│  2. Check properties for [AggregateId] attribute│</p>
<p>│  3. Extract: Message type, Property name        │</p>
<p>│  4. Validate: Must be Guid or Guid?             │</p>
<p>└─────────────────┬────────────────────────────────┘</p>
<p>                  │</p>
<p>                  ▼</p>
<p>┌──────────────────────────────────────────────────┐</p>
<p>│  Generated: AggregateIdExtractors.g.cs           │</p>
<p>│                                                  │</p>
<p>│  - Static extractor methods (zero reflection)   │</p>
<p>│  - Type-safe property access                    │</p>
<p>│  - AOT-compatible                                │</p>
<p>└──────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<hr>

<h3>3. Generated Code</h3>

<strong>AggregateIdExtractors.g.cs</strong>:
<pre><code class="language-csharp">// <auto-generated/>
<p>using System;</p>

<p>namespace MyApp.Generated;</p>

<p>public static class AggregateIdExtractors {</p>
<p>    /// <summary></p>
<p>    /// Extracts aggregate ID from a message (zero reflection, AOT-compatible).</p>
<p>    /// Generated for 3 message types with [AggregateId] attributes.</p>
<p>    /// </summary></p>
<p>    public static Guid? ExtractAggregateId(object message, Type messageType) {</p>
<p>        // CreateOrder</p>
<p>        if (messageType == typeof(global::MyApp.Commands.CreateOrder)) {</p>
<p>            return ((global::MyApp.Commands.CreateOrder)message).OrderId;</p>
<p>        }</p>

<p>        // OrderCreated</p>
<p>        if (messageType == typeof(global::MyApp.Events.OrderCreated)) {</p>
<p>            return ((global::MyApp.Events.OrderCreated)message).OrderId;</p>
<p>        }</p>

<p>        // ShipOrder</p>
<p>        if (messageType == typeof(global::MyApp.Commands.ShipOrder)) {</p>
<p>            return ((global::MyApp.Commands.ShipOrder)message).OrderId;</p>
<p>        }</p>

<p>        return null;  // No [AggregateId] found</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Features</strong>:
<ul><li><strong>Zero Reflection</strong>: Direct type checks and casts</li>
<li><strong>Type Safe</strong>: Compile-time property access</li>
<li><strong>AOT Compatible</strong>: No <code>MakeGenericType</code> or <code>GetProperty</code> calls</li>
<li><strong>Fast</strong>: < 10ns per extraction (vs ~1,000ns with reflection)</li>
</ul>
<hr>

<h2>Usage in PolicyContext</h2>

<h3>PolicyContext Integration</h3>

<pre><code class="language-csharp">using Whizbang.Core.Policies;

<p>public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    private readonly IPolicyEngine _policies;</p>

<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        // PolicyContext automatically extracts OrderId via generated extractor</p>
<p>        var context = new PolicyContext {</p>
<p>            Message = message,</p>
<p>            MessageType = typeof(CreateOrder),</p>
<p>            AggregateId = AggregateIdExtractors.ExtractAggregateId(message, typeof(CreateOrder)),  // ← Generated method</p>
<p>            UserId = GetCurrentUserId(),</p>
<p>            TenantId = GetCurrentTenantId()</p>
<p>        };</p>

<p>        // Policy decisions based on aggregate ID</p>
<p>        var decision = await _policies.EvaluateAsync("OrderRouting", context, ct);</p>

<p>        // Route based on aggregate ID</p>
<p>        if (decision.IsAllowed) {</p>
<p>            // Process order...</p>
<p>        }</p>

<p>        return new OrderCreated(/<em> ... </em>/);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Automatic Extraction</strong> (via MessageEnvelope):
<pre><code class="language-csharp">// MessageEnvelope automatically extracts aggregate ID
<p>var envelope = MessageEnvelope.Create(</p>
<p>    messageId: MessageId.New(),</p>
<p>    correlationId: CorrelationId.New(),</p>
<p>    causationId: null,</p>
<p>    payload: message,</p>
<p>    currentHop: new MessageHop {</p>
<p>        // Aggregate ID extracted automatically via generator</p>
<p>        StreamKey: AggregateIdExtractors.ExtractAggregateId(message, message.GetType())?.ToString()</p>
<p>    }</p>
<p>);</p>
<p></code></pre></p>

<hr>

<h2>Patterns</h2>

<h3>Pattern 1: Simple Aggregate ID</h3>

<pre><code class="language-csharp">public record CreateOrder(
<p>    [property: AggregateId] Guid OrderId,  // ← Primary entity ID</p>
<p>    Guid CustomerId,</p>
<p>    OrderItem[] Items</p>
<p>) : ICommand;</p>
<p></code></pre></p>

<strong>Generated</strong>:
<pre><code class="language-csharp">if (messageType == typeof(CreateOrder)) {
<p>    return ((CreateOrder)message).OrderId;</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h3>Pattern 2: Nullable Aggregate ID</h3>

<pre><code class="language-csharp">public record GetOrders(
<p>    [property: AggregateId] Guid? OrderId,  // ← Nullable (optional filter)</p>
<p>    Guid CustomerId</p>
<p>) : ICommand;</p>
<p></code></pre></p>

<strong>Generated</strong>:
<pre><code class="language-csharp">if (messageType == typeof(GetOrders)) {
<p>    return ((GetOrders)message).OrderId;  // Returns Guid? (nullable)</p>
<p>}</p>
<p></code></pre></p>

<strong>Use Case</strong>: Query commands where aggregate ID is optional.

<hr>

<h3>Pattern 3: Inherited Aggregate ID</h3>

<pre><code class="language-csharp">// Base class
<p>public abstract record OrderCommand {</p>
<p>    [AggregateId]</p>
<p>    public Guid OrderId { get; init; }</p>
<p>}</p>

<p>// Derived commands inherit [AggregateId]</p>
<p>public record ShipOrder(Guid OrderId, string TrackingNumber) : OrderCommand, ICommand;</p>
<p>public record CancelOrder(Guid OrderId, string Reason) : OrderCommand, ICommand;</p>
<p></code></pre></p>

<strong>Generated</strong> (one extractor per type):
<pre><code class="language-csharp">if (messageType == typeof(ShipOrder)) {
<p>    return ((ShipOrder)message).OrderId;  // Inherited property</p>
<p>}</p>

<p>if (messageType == typeof(CancelOrder)) {</p>
<p>    return ((CancelOrder)message).OrderId;  // Inherited property</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Diagnostics</h2>

<h3>WHIZ004: Aggregate ID Property Discovered</h3>

<strong>Severity</strong>: Info

<strong>Message</strong>: <code>Found [AggregateId] on property '{0}.{1}'</code>

<strong>Example</strong>:
<pre><code class="language-">info WHIZ004: Found [AggregateId] on property 'CreateOrder.OrderId'
<p>info WHIZ004: Found [AggregateId] on property 'OrderCreated.OrderId'</p>
<p></code></pre></p>

<hr>

<h3>WHIZ005: Multiple [AggregateId] Attributes</h3>

<strong>Severity</strong>: Warning

<strong>Message</strong>: <code>Type '{0}' has multiple [AggregateId] attributes. Using first: '{1}'</code>

<strong>Example</strong>:
<pre><code class="language-">warning WHIZ005: Type 'CreateOrder' has multiple [AggregateId] attributes. Using first: 'OrderId'
<p></code></pre></p>

<strong>Cause</strong>:
<pre><code class="language-csharp">public record CreateOrder(
<p>    [property: AggregateId] Guid OrderId,  // ← First (used)</p>
<p>    [property: AggregateId] Guid CustomerId  // ← Second (ignored)</p>
<p>) : ICommand;</p>
<p></code></pre></p>

<strong>Fix</strong>: Only mark <strong>one property</strong> per message type.

<hr>

<h3>WHIZ006: Invalid Property Type</h3>

<strong>Severity</strong>: Error

<strong>Message</strong>: <code>Property '{0}.{1}' has [AggregateId] but is not Guid or Guid?</code>

<strong>Example</strong>:
<pre><code class="language-">error WHIZ006: Property 'CreateOrder.OrderId' has [AggregateId] but is not Guid or Guid?
<p></code></pre></p>

<strong>Cause</strong>:
<pre><code class="language-csharp">public record CreateOrder(
<p>    [property: AggregateId] string OrderId,  // ❌ String, not Guid</p>
<p>    Guid CustomerId</p>
<p>) : ICommand;</p>
<p></code></pre></p>

<strong>Fix</strong>: Use <code>Guid</code> or <code>Guid?</code>:
<pre><code class="language-csharp">public record CreateOrder(
<p>    [property: AggregateId] Guid OrderId,  // ✅ Guid</p>
<p>    Guid CustomerId</p>
<p>) : ICommand;</p>
<p></code></pre></p>

<hr>

<h2>Performance</h2>

<h3>Benchmark: Extraction Speed</h3>

<p>| Method | Overhead | Notes |</p>
<p>|--------|----------|-------|</p>
<p>| <strong>Generated Extractor</strong> | ~8ns | Direct cast + property access |</p>
<p>| <strong>Reflection</strong> | ~1,000ns | <code>GetProperty()</code> + <code>GetValue()</code> |</p>

<strong>125x faster</strong> than reflection!

<pre><code class="language-csharp">// ✅ Generated (fast)
<p>var id = AggregateIdExtractors.ExtractAggregateId(message, typeof(CreateOrder));</p>

<p>// ❌ Reflection (slow)</p>
<p>var property = typeof(CreateOrder).GetProperty("OrderId");</p>
<p>var id = (Guid?)property?.GetValue(message);</p>
<p></code></pre></p>

<h3>Zero Allocations</h3>

<p>Generated code produces <strong>zero allocations</strong>:</p>

<pre><code class="language-csharp">// Generated code (no boxing/unboxing, no reflection overhead)
<p>if (messageType == typeof(CreateOrder)) {</p>
<p>    return ((CreateOrder)message).OrderId;  // Direct property access</p>
<p>}</p>
<p></code></pre></p>

<strong>Benchmark</strong>:
<pre><code class="language-">Memory Diagnostics:
<p>  Gen 0: 0</p>
<p>  Gen 1: 0</p>
<p>  Gen 2: 0</p>
<p>  Allocated: 0 bytes</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Mark primary entity ID</strong> with <code>[AggregateId]</code></li>
<li>✅ <strong>Use Guid or Guid?</strong> for ID properties</li>
<li>✅ <strong>Use UUIDv7</strong> for time-ordered IDs (<code>Guid.CreateVersion7()</code>)</li>
<li>✅ <strong>One [AggregateId] per message</strong> (typically the main entity)</li>
<li>✅ <strong>Consistent naming</strong> (OrderId, CustomerId, ProductId)</li>
<li>✅ <strong>Apply to both commands and events</strong> for traceability</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Mark multiple properties (only first is used)</li>
<li>❌ Use non-Guid types (must be Guid or Guid?)</li>
<li>❌ Skip [AggregateId] on primary entities (breaks tracing)</li>
<li>❌ Use random GUIDs (use UUIDv7 for time-ordering)</li>
</ul>
<hr>

<h2>Troubleshooting</h2>

<h3>Problem: Extractor Returns Null</h3>

<strong>Symptoms</strong>: <code>ExtractAggregateId()</code> returns <code>null</code> for message.

<strong>Causes</strong>:
<ul><li>Property not marked with <code>[AggregateId]</code></li>
<li>Wrong message type passed</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-csharp">// ✅ Mark property
<p>public record CreateOrder(</p>
<p>    [property: AggregateId] Guid OrderId,  // Add attribute</p>
<p>    Guid CustomerId</p>
<p>) : ICommand;</p>

<p>// ✅ Pass correct type</p>
<p>var id = AggregateIdExtractors.ExtractAggregateId(message, message.GetType());</p>
<p></code></pre></p>

<h3>Problem: Property Ignored</h3>

<strong>Symptoms</strong>: Warning WHIZ005, second property not used.

<strong>Cause</strong>: Multiple <code>[AggregateId]</code> attributes on same type.

<strong>Solution</strong>: Remove duplicate:
<pre><code class="language-csharp">// ❌ Multiple attributes
<p>public record CreateOrder(</p>
<p>    [property: AggregateId] Guid OrderId,</p>
<p>    [property: AggregateId] Guid CustomerId  // ← Remove this</p>
<p>) : ICommand;</p>

<p>// ✅ Single attribute</p>
<p>public record CreateOrder(</p>
<p>    [property: AggregateId] Guid OrderId,</p>
<p>    Guid CustomerId</p>
<p>) : ICommand;</p>
<p></code></pre></p>

<hr>

<h2>Integration with Event Store</h2>

<h3>Stream Key Generation</h3>

<p>Aggregate IDs are used to generate <strong>Event Store stream keys</strong>:</p>

<pre><code class="language-csharp">// Event Store automatically uses aggregate ID for stream key
<p>var streamKey = AggregateIdExtractors.ExtractAggregateId(@event, @event.GetType())?.ToString();</p>

<p>// Stream: "Order-abc123-def456-..."</p>
<p>// All events for Order #abc123 in same stream</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li><strong>Consistent Ordering</strong>: Events for same aggregate always ordered</li>
<li><strong>Rebuild Capability</strong>: Replay events for specific aggregate</li>
<li><strong>Query Efficiency</strong>: Read all events for aggregate in one query</li>
</ul>
<hr>

<h2>Further Reading</h2>

<strong>Source Generators</strong>:
<ul><li><a href="receptor-discovery.md">Receptor Discovery</a> - Compile-time receptor discovery</li>
<li><a href="perspective-discovery.md">Perspective Discovery</a> - Compile-time perspective discovery</li>
<li><a href="message-registry.md">Message Registry</a> - VSCode extension integration</li>
<li><a href="json-contexts.md">JSON Contexts</a> - AOT-compatible JSON serialization</li>
</ul>
<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/message-context.md">Message Context</a> - MessageId, CorrelationId, CausationId</li>
<li><a href="../core-concepts/observability.md">Observability</a> - Distributed tracing with hops</li>
</ul>
<strong>Data Access</strong>:
<ul><li><a href="../data/event-store.md">Event Store</a> - Event sourcing and stream storage</li>
</ul>
<strong>Infrastructure</strong>:
<ul><li><a href="../infrastructure/policies.md">Policies</a> - Policy-based routing and decisions</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-source-generators-json-contexts" class="doc-section">
  <h3>JSON Contexts</h3>
  <p class="doc-path"><code>v1.0.0/source-generators/json-contexts</code></p>
  <p class="doc-description"><em>AOT-compatible JSON serialization with compile-time JsonSerializerContext generation - zero reflection for Native AOT</em></p>
  <div class="doc-content">

<h1>JSON Contexts</h1>

<p>The <strong>MessageJsonContextGenerator</strong> discovers all message types (<code>ICommand</code>, <code>IEvent</code>) at compile-time and generates a <code>JsonSerializerContext</code> with <code>JsonTypeInfo</code> for <strong>AOT-compatible JSON serialization</strong>. This enables Native AOT deployments with zero reflection overhead.</p>

<h2>Why JSON Source Generation?</h2>

<strong>Problem</strong>: Traditional <code>JsonSerializer</code> uses <strong>reflection</strong> at runtime:

<pre><code class="language-csharp">// ❌ Reflection-based (not AOT-compatible)
<p>var json = JsonSerializer.Serialize(message);  // Scans type at runtime!</p>
<p>var deserialized = JsonSerializer.Deserialize<CreateOrder>(json);  // Reflection!</p>
<p></code></pre></p>

<strong>Issues with Reflection</strong>:
<ul><li>❌ <strong>Not AOT Compatible</strong>: Native AOT trims reflection metadata</li>
<li>❌ <strong>Slow First Call</strong>: ~50-100ms to scan type and build metadata</li>
<li>❌ <strong>Runtime Overhead</strong>: Type analysis on every new type</li>
<li>❌ <strong>Large Binary Size</strong>: Includes all reflection infrastructure</li>
</ul>
<strong>Solution</strong>: <strong>Source-Generated JsonSerializerContext</strong>:

<pre><code class="language-csharp">// ✅ AOT-compatible (compile-time metadata)
<p>var options = new JsonSerializerOptions {</p>
<p>    TypeInfoResolver = new WhizbangJsonContext()  // Generated at compile-time</p>
<p>};</p>

<p>var json = JsonSerializer.Serialize(message, options);  // Zero reflection!</p>
<p>var deserialized = JsonSerializer.Deserialize<CreateOrder>(json, options);</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ <strong>AOT Compatible</strong>: No reflection, full Native AOT support</li>
<li>✅ <strong>Fast</strong>: Zero runtime type analysis (~100x faster first call)</li>
<li>✅ <strong>Small Binary</strong>: No reflection infrastructure needed</li>
<li>✅ <strong>Explicit</strong>: All serialized types visible at compile-time</li>
</ul>
<hr>

<h2>How It Works</h2>

<h3>1. Compile-Time Discovery</h3>

<pre><code class="language-">┌──────────────────────────────────────────────────┐
<p>│  MessageJsonContextGenerator (Roslyn)            │</p>
<p>│                                                  │</p>
<p>│  Discovers:                                      │</p>
<p>│  1. Messages (ICommand, IEvent)                 │</p>
<p>│  2. Nested types (OrderItem in List<OrderItem>) │</p>
<p>│  3. Collection types (List<T>)                  │</p>
<p>│  4. WhizbangId types (MessageId, ProductId)     │</p>
<p>└─────────────────┬────────────────────────────────┘</p>
<p>                  │</p>
<p>                  ▼</p>
<p>┌──────────────────────────────────────────────────┐</p>
<p>│  Generated Files                                 │</p>
<p>│                                                  │</p>
<p>│  1. MessageJsonContext.g.cs                      │</p>
<p>│     └─ JsonTypeInfo for all discovered types    │</p>
<p>│                                                  │</p>
<p>│  2. WhizbangJsonContext.g.cs (facade)            │</p>
<p>│     └─ Public API for JsonSerializerOptions     │</p>
<p>└──────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<hr>

<h3>2. Generated Code</h3>

<strong>WhizbangJsonContext.g.cs</strong> (facade):
<pre><code class="language-csharp">using System.Text.Json;
<p>using System.Text.Json.Serialization;</p>

<p>namespace MyApp.Generated;</p>

<p>/// <summary></p>
<p>/// Generated JSON context for WhizBang message serialization (AOT-compatible).</p>
<p>/// Discovered 5 message types, 3 nested types, 2 collection types.</p>
<p>/// </summary></p>
<p>[JsonSerializable(typeof(CreateOrder))]</p>
<p>[JsonSerializable(typeof(OrderCreated))]</p>
<p>[JsonSerializable(typeof(ShipOrder))]</p>
<p>[JsonSerializable(typeof(OrderShipped))]</p>
<p>[JsonSerializable(typeof(CancelOrder))]</p>
<p>public partial class WhizbangJsonContext : JsonSerializerContext {</p>
<p>    /// <summary></p>
<p>    /// Creates JsonSerializerOptions with WhizbangJsonContext.</p>
<p>    /// </summary></p>
<p>    public static JsonSerializerOptions CreateOptions() {</p>
<p>        var options = new JsonSerializerOptions {</p>
<p>            TypeInfoResolver = new WhizbangJsonContext(),</p>
<p>            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,</p>
<p>            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull</p>
<p>        };</p>

<p>        // Register WhizbangId converters (AOT-compatible)</p>
<p>        options.Converters.Add(new ProductIdJsonConverter());</p>
<p>        options.Converters.Add(new OrderIdJsonConverter());</p>

<p>        return options;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>MessageJsonContext.g.cs</strong> (implementation):
<pre><code class="language-csharp">using System;
<p>using System.Text.Json;</p>
<p>using System.Text.Json.Serialization;</p>
<p>using System.Text.Json.Serialization.Metadata;</p>

<p>namespace MyApp.Generated;</p>

<p>internal partial class MessageJsonContext : JsonSerializerContext {</p>
<p>    // Generated JsonTypeInfo for CreateOrder</p>
<p>    private JsonTypeInfo<CreateOrder> Create_CreateOrder(JsonSerializerOptions options) {</p>
<p>        var properties = new JsonPropertyInfo[3];</p>

<p>        properties[0] = JsonMetadataServices.CreatePropertyInfo<Guid>(</p>
<p>            options,</p>
<p>            propertyName: "OrderId",</p>
<p>            getter: static obj => ((CreateOrder)obj).OrderId,</p>
<p>            setter: null  // Init-only property</p>
<p>        );</p>

<p>        properties[1] = JsonMetadataServices.CreatePropertyInfo<Guid>(</p>
<p>            options,</p>
<p>            propertyName: "CustomerId",</p>
<p>            getter: static obj => ((CreateOrder)obj).CustomerId,</p>
<p>            setter: null</p>
<p>        );</p>

<p>        properties[2] = JsonMetadataServices.CreatePropertyInfo<List<OrderItem>>(</p>
<p>            options,</p>
<p>            propertyName: "Items",</p>
<p>            getter: static obj => ((CreateOrder)obj).Items,</p>
<p>            setter: null</p>
<p>        );</p>

<p>        // Constructor parameters for record with primary constructor</p>
<p>        var ctorParams = new JsonParameterInfoValues[3];</p>
<p>        ctorParams[0] = new JsonParameterInfoValues { Name = "OrderId", ParameterType = typeof(Guid) };</p>
<p>        ctorParams[1] = new JsonParameterInfoValues { Name = "CustomerId", ParameterType = typeof(Guid) };</p>
<p>        ctorParams[2] = new JsonParameterInfoValues { Name = "Items", ParameterType = typeof(List<OrderItem>) };</p>

<p>        var objectInfo = new JsonObjectInfoValues<CreateOrder> {</p>
<p>            ObjectWithParameterizedConstructorCreator = static args => new CreateOrder(</p>
<p>                (Guid)args[0],</p>
<p>                (Guid)args[1],</p>
<p>                (List<OrderItem>)args[2]</p>
<p>            ),</p>
<p>            PropertyMetadataInitializer = _ => properties,</p>
<p>            ConstructorParameterMetadataInitializer = () => ctorParams</p>
<p>        };</p>

<p>        var jsonTypeInfo = JsonMetadataServices.CreateObjectInfo(options, objectInfo);</p>
<p>        jsonTypeInfo.OriginatingResolver = this;</p>
<p>        return jsonTypeInfo;</p>
<p>    }</p>

<p>    // Type resolver - matches type to JsonTypeInfo</p>
<p>    public override JsonTypeInfo? GetTypeInfo(Type type) {</p>
<p>        if (type == typeof(CreateOrder)) {</p>
<p>            return Create_CreateOrder(Options);</p>
<p>        }</p>

<p>        if (type == typeof(OrderCreated)) {</p>
<p>            return Create_OrderCreated(Options);</p>
<p>        }</p>

<p>        // ... more types</p>

<p>        return null;  // Not handled by this context</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Discovery Patterns</h2>

<h3>Pattern 1: Command/Event Discovery</h3>

<pre><code class="language-csharp">// Commands and events are auto-discovered
<p>public record CreateOrder(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    List<OrderItem> Items</p>
<p>) : ICommand;  // ← Discovered</p>

<p>public record OrderCreated(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    decimal Total,</p>
<p>    DateTimeOffset CreatedAt</p>
<p>) : IEvent;  // ← Discovered</p>
<p></code></pre></p>

<strong>Result</strong>: <code>JsonTypeInfo<CreateOrder></code> and <code>JsonTypeInfo<OrderCreated></code> generated.

<hr>

<h3>Pattern 2: Nested Type Discovery</h3>

<pre><code class="language-csharp">// Command uses OrderItem (nested type)
<p>public record CreateOrder(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    List<OrderItem> Items  // ← OrderItem discovered automatically</p>
<p>) : ICommand;</p>

<p>// Nested type (not ICommand or IEvent)</p>
<p>public record OrderItem(</p>
<p>    Guid ProductId,</p>
<p>    int Quantity,</p>
<p>    decimal UnitPrice</p>
<p>);</p>
<p></code></pre></p>

<strong>Result</strong>: <code>JsonTypeInfo<OrderItem></code> also generated (needed for <code>List<OrderItem></code>).

<hr>

<h3>Pattern 3: Collection Type Discovery</h3>

<pre><code class="language-csharp">// List<T> types discovered from properties
<p>public record CreateOrder(</p>
<p>    Guid OrderId,</p>
<p>    List<OrderItem> Items  // ← List<OrderItem> discovered</p>
<p>) : ICommand;</p>
<p></code></pre></p>

<strong>Result</strong>: <code>JsonTypeInfo<List<OrderItem>></code> generated for AOT compatibility.

<hr>

<h3>Pattern 4: WhizbangId Converter Discovery</h3>

<pre><code class="language-csharp">// Generator infers converters for *Id types
<p>public record CreateOrder(</p>
<p>    ProductId ProductId,  // ← Infers ProductIdJsonConverter</p>
<p>    CustomerId CustomerId  // ← Infers CustomerIdJsonConverter</p>
<p>) : ICommand;</p>
<p></code></pre></p>

<strong>Result</strong>: Converters automatically registered in <code>CreateOptions()</code>:
<pre><code class="language-csharp">options.Converters.Add(new ProductIdJsonConverter());
<p>options.Converters.Add(new CustomerIdJsonConverter());</p>
<p></code></pre></p>

<hr>

<h2>Usage</h2>

<h3>Basic Serialization</h3>

<pre><code class="language-csharp">using MyApp.Generated;

<p>// Create options with generated context</p>
<p>var options = WhizbangJsonContext.CreateOptions();</p>

<p>// Serialize (AOT-compatible, zero reflection)</p>
<p>var command = new CreateOrder(orderId, customerId, items);</p>
<p>var json = JsonSerializer.Serialize(command, options);</p>

<p>// Deserialize (AOT-compatible)</p>
<p>var deserialized = JsonSerializer.Deserialize<CreateOrder>(json, options);</p>
<p></code></pre></p>

<hr>

<h3>Dependency Injection</h3>

<pre><code class="language-csharp">// Program.cs
<p>using MyApp.Generated;</p>

<p>var builder = WebApplication.CreateBuilder(args);</p>

<p>// Register JsonSerializerOptions with generated context</p>
<p>builder.Services.AddSingleton(WhizbangJsonContext.CreateOptions());</p>

<p>// Or configure JsonOptions for ASP.NET Core</p>
<p>builder.Services.Configure<JsonOptions>(options => {</p>
<p>    options.JsonSerializerOptions.TypeInfoResolver = new WhizbangJsonContext();</p>
<p>    options.JsonSerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;</p>
<p>});</p>
<p></code></pre></p>

<hr>

<h3>Outbox/Inbox Serialization</h3>

<pre><code class="language-csharp">public class OutboxPublisher {
<p>    private readonly JsonSerializerOptions _jsonOptions;</p>

<p>    public OutboxPublisher() {</p>
<p>        _jsonOptions = WhizbangJsonContext.CreateOptions();</p>
<p>    }</p>

<p>    public async Task PublishAsync(object message, CancellationToken ct = default) {</p>
<p>        // Serialize with AOT-compatible context</p>
<p>        var json = JsonSerializer.Serialize(message, _jsonOptions);</p>

<p>        await _db.ExecuteAsync(</p>
<p>            "INSERT INTO wh_outbox (message_id, payload, ...) VALUES (@MessageId, @Payload::jsonb, ...)",</p>
<p>            new { MessageId = Guid.NewGuid(), Payload = json },</p>
<p>            cancellationToken: ct</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Performance</h2>

<h3>Benchmark: First Serialization</h3>

<p>| Method | Overhead | Notes |</p>
<p>|--------|----------|-------|</p>
<p>| <strong>Generated Context</strong> | ~5ms | Compile-time metadata |</p>
<p>| <strong>Reflection</strong> | ~100ms | Runtime type analysis |</p>

<strong>20x faster</strong> on first call!

<h3>Subsequent Calls</h3>

<p>| Method | Overhead | Notes |</p>
<p>|--------|----------|-------|</p>
<p>| <strong>Generated Context</strong> | ~100ns | Direct property access |</p>
<p>| <strong>Reflection</strong> | ~150ns | Cached reflection metadata |</p>

<strong>1.5x faster</strong> on subsequent calls (minimal difference after warm-up).

<hr>

<h2>Native AOT Compatibility</h2>

<h3>Publish Native AOT</h3>

<pre><code class="language-xml"><!-- MyApp.csproj -->
<p><PropertyGroup></p>
<p>  <PublishAot>true</PublishAot></p>
<p></PropertyGroup></p>
<p></code></pre></p>

<strong>Build</strong>:
<pre><code class="language-bash">dotnet publish -c Release

<h1>Output:</h1>
<p>Generating native code...</p>
<p>  MyApp.dll -> MyApp.exe (Native AOT)</p>
<p>  Binary size: 12.5 MB (includes JSON context)</p>
<p>  Startup time: < 10ms</p>
<p></code></pre></p>

<strong>Verification</strong>:
<pre><code class="language-bash"># Check binary doesn't use reflection
<p>nm MyApp.exe | grep -i "reflection"</p>
<h1>No results = success!</h1>
<p></code></pre></p>

<hr>

<h2>Diagnostics</h2>

<h3>WHIZ099: Generator Running</h3>

<strong>Severity</strong>: Info

<strong>Message</strong>: <code>MessageJsonContextGenerator invoked for assembly '{0}' with {1} message type(s)</code>

<strong>Example</strong>:
<pre><code class="language-">info WHIZ099: MessageJsonContextGenerator invoked for assembly 'MyApp' with 5 message type(s)
<p></code></pre></p>

<hr>

<h3>WHIZ007: JSON Serializable Type Discovered</h3>

<strong>Severity</strong>: Info

<strong>Message</strong>: <code>Found JSON-serializable type '{0}' ({1})</code>

<strong>Example</strong>:
<pre><code class="language-">info WHIZ007: Found JSON-serializable type 'CreateOrder' (command)
<p>info WHIZ007: Found JSON-serializable type 'OrderItem' (nested type)</p>
<p>info WHIZ007: Found JSON-serializable type 'List<OrderItem>' (collection type)</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Use WhizbangJsonContext.CreateOptions()</strong> for all JSON serialization</li>
<li>✅ <strong>Mark all messages as public</strong> (generator only processes public types)</li>
<li>✅ <strong>Use records with primary constructors</strong> for best JSON support</li>
<li>✅ <strong>Test Native AOT</strong> deployment early (catches issues sooner)</li>
<li>✅ <strong>Include nested types</strong> in same assembly as messages</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Use reflection-based JsonSerializer (defeats AOT)</li>
<li>❌ Mark messages as internal (won't be discovered)</li>
<li>❌ Use complex custom converters (may not be AOT-compatible)</li>
<li>❌ Serialize types from other assemblies without their context</li>
<li>❌ Skip testing with <code>PublishAot=true</code></li>
</ul>
<hr>

<h2>Troubleshooting</h2>

<h3>Problem: Type Not Serializable in Native AOT</h3>

<strong>Symptoms</strong>: Serialization throws <code>NotSupportedException</code> in AOT build.

<strong>Cause</strong>: Type not included in generated context.

<strong>Solution</strong>:
<ul><li>Verify type is public</li>
<li>Verify type implements <code>ICommand</code> or <code>IEvent</code></li>
<li>Rebuild project to regenerate context</li>
</ul>
<pre><code class="language-csharp">// ❌ Internal type (not discovered)
<p>internal record CreateOrder(...) : ICommand;</p>

<p>// ✅ Public type (discovered)</p>
<p>public record CreateOrder(...) : ICommand;</p>
<p></code></pre></p>

<h3>Problem: Nested Type Not Found</h3>

<strong>Symptoms</strong>: <code>List<OrderItem></code> fails to serialize.

<strong>Cause</strong>: <code>OrderItem</code> not public or in different assembly.

<strong>Solution</strong>: Make nested types public in same assembly:
<pre><code class="language-csharp">// ✅ Public nested type
<p>public record OrderItem(Guid ProductId, int Quantity);</p>
<p></code></pre></p>

<h3>Problem: WhizbangId Converter Not Registered</h3>

<strong>Symptoms</strong>: <code>ProductId</code> serializes as <code>{}</code> instead of GUID value.

<strong>Cause</strong>: Converter not auto-discovered (name doesn't match convention).

<strong>Solution</strong>: Ensure converter follows naming convention:
<pre><code class="language-csharp">// Type: ProductId
<p>// Converter: ProductIdJsonConverter (must match!)</p>
<p>public class ProductIdJsonConverter : JsonConverter<ProductId> {</p>
<p>    // Implementation...</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Source Generators</strong>:
<ul><li><a href="receptor-discovery.md">Receptor Discovery</a> - Compile-time receptor discovery</li>
<li><a href="perspective-discovery.md">Perspective Discovery</a> - Compile-time perspective discovery</li>
<li><a href="message-registry.md">Message Registry</a> - VSCode extension integration</li>
<li><a href="aggregate-ids.md">Aggregate IDs</a> - UUIDv7 generation for identity value objects</li>
</ul>
<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/message-context.md">Message Context</a> - MessageId, CorrelationId, CausationId</li>
</ul>
<strong>Messaging</strong>:
<ul><li><a href="../messaging/outbox-pattern.md">Outbox Pattern</a> - Reliable event publishing</li>
<li><a href="../messaging/inbox-pattern.md">Inbox Pattern</a> - Exactly-once processing</li>
</ul>
<strong>Advanced</strong>:
<ul><li><a href="../advanced/native-aot.md">Native AOT Deployment</a> - Full AOT deployment guide</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-source-generators-message-registry" class="doc-section">
  <h3>Message Registry</h3>
  <p class="doc-path"><code>v1.0.0/source-generators/message-registry</code></p>
  <p class="doc-description"><em>VSCode extension integration via compile-time message registry - navigate from messages to handlers with IDE tooling</em></p>
  <div class="doc-content">

<h1>Message Registry</h1>

<p>The <strong>MessageRegistryGenerator</strong> discovers all messages, dispatchers, receptors, and perspectives at compile-time and generates a JSON registry file for the <strong>Whizbang VSCode Extension</strong>. This enables rich IDE features like CodeLens annotations, hover tooltips, and "Go to Handler" navigation.</p>

<h2>VSCode Extension Integration</h2>

<h3>IDE Features Enabled</h3>

<p>| Feature | Description | Example |</p>
<p>|---------|-------------|---------|</p>
<p>| <strong>CodeLens</strong> | Inline annotations showing handler counts | <code>CreateOrder</code> → 3 dispatchers, 1 receptor |</p>
<p>| <strong>Hover Tooltip</strong> | Rich markdown with handler locations | Mouse over message → see all handlers |</p>
<p>| <strong>Go to Handler</strong> | Navigate from message to implementation | Click CodeLens → jump to receptor |</p>
<p>| <strong>Find References</strong> | List all dispatchers for a message | Right-click → Find dispatchers |</p>

<strong>Visual Example</strong>:
<pre><code class="language-csharp">// In your code editor:
<p>public record CreateOrder(Guid CustomerId, OrderItem[] Items) : ICommand;</p>
<p>             ↑↑↑↑↑↑↑↑↑↑↑</p>
<p>             [3 dispatchers] [1 receptor] [0 perspectives]  ← CodeLens</p>

<p>// Click [1 receptor] → Jump to OrderReceptor.HandleAsync()</p>
<p></code></pre></p>

<hr>

<h2>How It Works</h2>

<h3>1. Compile-Time Discovery</h3>

<pre><code class="language-">┌──────────────────────────────────────────────────┐
<p>│  MessageRegistryGenerator (Roslyn)              │</p>
<p>│                                                  │</p>
<p>│  Discovers 4 types of constructs:               │</p>
<p>│                                                  │</p>
<p>│  1. Messages (ICommand, IEvent)                 │</p>
<p>│  2. Dispatchers (SendAsync, PublishAsync calls) │</p>
<p>│  3. Receptors (IReceptor implementations)       │</p>
<p>│  4. Perspectives (IPerspectiveOf implementations)│</p>
<p>└─────────────────┬────────────────────────────────┘</p>
<p>                  │</p>
<p>                  ▼</p>
<p>┌──────────────────────────────────────────────────┐</p>
<p>│  Generated: MessageRegistry.g.cs                 │</p>
<p>│                                                  │</p>
<p>│  Contains:                                       │</p>
<p>│  - Embedded JSON with message-to-handler mapping│</p>
<p>│  - File paths and line numbers for navigation   │</p>
<p>│  - Message type metadata (command vs event)     │</p>
<p>└─────────────────┬────────────────────────────────┘</p>
<p>                  │</p>
<p>                  ▼</p>
<p>┌──────────────────────────────────────────────────┐</p>
<p>│  Build Process: Copy to .whizbang/               │</p>
<p>│                                                  │</p>
<p>│  message-registry.json                           │</p>
<p>│  └─ Used by VSCode extension for tooling        │</p>
<p>└──────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<h3>2. Generated File</h3>

<strong>MessageRegistry.g.cs</strong> (simplified):
<pre><code class="language-csharp">// <auto-generated/>
<p>// This file is generated by MessageRegistryGenerator</p>
<p>// DO NOT EDIT - Changes will be overwritten</p>

<p>namespace MyApp.Generated;</p>

<p>internal static class MessageRegistry {</p>
<p>    public static string Json = @"{</p>
<p>  ""messages"": [</p>
<p>    {</p>
<p>      ""type"": ""MyApp.Commands.CreateOrder"",</p>
<p>      ""isCommand"": true,</p>
<p>      ""isEvent"": false,</p>
<p>      ""filePath"": ""src/Commands/CreateOrder.cs"",</p>
<p>      ""lineNumber"": 5,</p>
<p>      ""dispatchers"": [</p>
<p>        {</p>
<p>          ""className"": ""MyApp.Controllers.OrderController"",</p>
<p>          ""methodName"": ""CreateAsync"",</p>
<p>          ""filePath"": ""src/Controllers/OrderController.cs"",</p>
<p>          ""lineNumber"": 42</p>
<p>        },</p>
<p>        {</p>
<p>          ""className"": ""MyApp.Sagas.OrderSaga"",</p>
<p>          ""methodName"": ""ProcessAsync"",</p>
<p>          ""filePath"": ""src/Sagas/OrderSaga.cs"",</p>
<p>          ""lineNumber"": 18</p>
<p>        }</p>
<p>      ],</p>
<p>      ""receptors"": [</p>
<p>        {</p>
<p>          ""className"": ""MyApp.Receptors.OrderReceptor"",</p>
<p>          ""methodName"": ""HandleAsync"",</p>
<p>          ""filePath"": ""src/Receptors/OrderReceptor.cs"",</p>
<p>          ""lineNumber"": 12</p>
<p>        }</p>
<p>      ],</p>
<p>      ""perspectives"": []</p>
<p>    },</p>
<p>    {</p>
<p>      ""type"": ""MyApp.Events.OrderCreated"",</p>
<p>      ""isCommand"": false,</p>
<p>      ""isEvent"": true,</p>
<p>      ""filePath"": ""src/Events/OrderCreated.cs"",</p>
<p>      ""lineNumber"": 3,</p>
<p>      ""dispatchers"": [</p>
<p>        {</p>
<p>          ""className"": ""MyApp.Receptors.OrderReceptor"",</p>
<p>          ""methodName"": ""HandleAsync"",</p>
<p>          ""filePath"": ""src/Receptors/OrderReceptor.cs"",</p>
<p>          ""lineNumber"": 25</p>
<p>        }</p>
<p>      ],</p>
<p>      ""receptors"": [],</p>
<p>      ""perspectives"": [</p>
<p>        {</p>
<p>          ""className"": ""MyApp.Perspectives.OrderSummaryPerspective"",</p>
<p>          ""filePath"": ""src/Perspectives/OrderSummaryPerspective.cs"",</p>
<p>          ""lineNumber"": 8</p>
<p>        },</p>
<p>        {</p>
<p>          ""className"": ""MyApp.Perspectives.CustomerStatisticsPerspective"",</p>
<p>          ""filePath"": ""src/Perspectives/CustomerStatisticsPerspective.cs"",</p>
<p>          ""lineNumber"": 15</p>
<p>        }</p>
<p>      ]</p>
<p>    }</p>
<p>  ]</p>
<p>}";</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Information</strong>:
<ul><li>Message type (fully qualified name)</li>
<li>Message kind (command vs event)</li>
<li>Definition location (file path + line number)</li>
<li>All dispatchers calling this message</li>
<li>All receptors handling this message</li>
<li>All perspectives listening to this event</li>
</ul>
<hr>

<h2>Discovery Patterns</h2>

<h3>Pattern 1: Message Discovery</h3>

<p>Discovers <strong>ICommand</strong> and <strong>IEvent</strong> implementations:</p>

<pre><code class="language-csharp">// Command
<p>public record CreateOrder(</p>
<p>    Guid CustomerId,</p>
<p>    OrderItem[] Items</p>
<p>) : ICommand;  // ← Discovered</p>

<p>// Event</p>
<p>public record OrderCreated(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    decimal Total,</p>
<p>    DateTimeOffset CreatedAt</p>
<p>) : IEvent;  // ← Discovered</p>
<p></code></pre></p>

<strong>Generator finds</strong>:
<ul><li>Type name: <code>MyApp.Commands.CreateOrder</code></li>
<li>File: <code>src/Commands/CreateOrder.cs</code></li>
<li>Line: 5</li>
<li>IsCommand: <code>true</code></li>
<li>IsEvent: <code>false</code></li>
</ul>
<hr>

<h3>Pattern 2: Dispatcher Discovery</h3>

<p>Discovers <strong>SendAsync</strong> and <strong>PublishAsync</strong> call sites:</p>

<pre><code class="language-csharp">public class OrderController : ControllerBase {
<p>    private readonly IDispatcher _dispatcher;</p>

<p>    public async Task<IActionResult> CreateAsync(CreateOrderRequest request) {</p>
<p>        var command = new CreateOrder(request.CustomerId, request.Items);</p>

<p>        // ← Dispatcher call discovered</p>
<p>        var @event = await _dispatcher.SendAsync(command);</p>

<p>        return Ok(@event);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Generator finds</strong>:
<ul><li>Message type: <code>CreateOrder</code></li>
<li>Class: <code>OrderController</code></li>
<li>Method: <code>CreateAsync</code></li>
<li>File: <code>src/Controllers/OrderController.cs</code></li>
<li>Line: 42</li>
</ul>
<strong>Also discovers PublishAsync</strong>:
<pre><code class="language-csharp">// Inside OrderReceptor
<p>var @event = new OrderCreated(/<em> ... </em>/);</p>
<p>await _dispatcher.PublishAsync(@event);  // ← Discovered</p>
<p></code></pre></p>

<hr>

<h3>Pattern 3: Receptor Discovery</h3>

<p>Discovers <strong>IReceptor<TMessage, TResponse></strong> implementations:</p>

<pre><code class="language-csharp">public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>    public async ValueTask<OrderCreated> HandleAsync(  // ← Method discovered</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        // Business logic...</p>
<p>        return new OrderCreated(/<em> ... </em>/);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Generator finds</strong>:
<ul><li>Message type: <code>CreateOrder</code></li>
<li>Class: <code>OrderReceptor</code></li>
<li>Method: <code>HandleAsync</code></li>
<li>File: <code>src/Receptors/OrderReceptor.cs</code></li>
<li>Line: 12 (HandleAsync method location)</li>
</ul>
<hr>

<h3>Pattern 4: Perspective Discovery</h3>

<p>Discovers <strong>IPerspectiveOf<TEvent></strong> implementations:</p>

<pre><code class="language-csharp">public class OrderSummaryPerspective :
<p>    IPerspectiveOf<OrderCreated>,  // ← Discovered</p>
<p>    IPerspectiveOf<OrderShipped>,  // ← Discovered</p>
<p>    IPerspectiveOf<OrderCancelled> {  // ← Discovered</p>

<p>    public async Task UpdateAsync(OrderCreated @event, CancellationToken ct) {</p>
<p>        // Update order_summaries table</p>
<p>    }</p>

<p>    public async Task UpdateAsync(OrderShipped @event, CancellationToken ct) {</p>
<p>        // Update order_summaries table</p>
<p>    }</p>

<p>    public async Task UpdateAsync(OrderCancelled @event, CancellationToken ct) {</p>
<p>        // Update order_summaries table</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Generator finds</strong>:
<ul><li>Event types: <code>OrderCreated</code>, <code>OrderShipped</code>, <code>OrderCancelled</code></li>
<li>Class: <code>OrderSummaryPerspective</code></li>
<li>File: <code>src/Perspectives/OrderSummaryPerspective.cs</code></li>
<li>Line: 8 (class declaration)</li>
</ul>
<strong>Result</strong>: One perspective, three event type mappings.

<hr>

<h2>JSON Structure</h2>

<h3>Complete Example</h3>

<pre><code class="language-json">{
<p>  "messages": [</p>
<p>    {</p>
<p>      "type": "MyApp.Commands.CreateOrder",</p>
<p>      "isCommand": true,</p>
<p>      "isEvent": false,</p>
<p>      "filePath": "src/Commands/CreateOrder.cs",</p>
<p>      "lineNumber": 5,</p>
<p>      "dispatchers": [</p>
<p>        {</p>
<p>          "className": "MyApp.Controllers.OrderController",</p>
<p>          "methodName": "CreateAsync",</p>
<p>          "filePath": "src/Controllers/OrderController.cs",</p>
<p>          "lineNumber": 42</p>
<p>        }</p>
<p>      ],</p>
<p>      "receptors": [</p>
<p>        {</p>
<p>          "className": "MyApp.Receptors.OrderReceptor",</p>
<p>          "methodName": "HandleAsync",</p>
<p>          "filePath": "src/Receptors/OrderReceptor.cs",</p>
<p>          "lineNumber": 12</p>
<p>        }</p>
<p>      ],</p>
<p>      "perspectives": []</p>
<p>    },</p>
<p>    {</p>
<p>      "type": "MyApp.Events.OrderCreated",</p>
<p>      "isCommand": false,</p>
<p>      "isEvent": true,</p>
<p>      "filePath": "src/Events/OrderCreated.cs",</p>
<p>      "lineNumber": 3,</p>
<p>      "dispatchers": [</p>
<p>        {</p>
<p>          "className": "MyApp.Receptors.OrderReceptor",</p>
<p>          "methodName": "HandleAsync",</p>
<p>          "filePath": "src/Receptors/OrderReceptor.cs",</p>
<p>          "lineNumber": 25</p>
<p>        }</p>
<p>      ],</p>
<p>      "receptors": [],</p>
<p>      "perspectives": [</p>
<p>        {</p>
<p>          "className": "MyApp.Perspectives.OrderSummaryPerspective",</p>
<p>          "filePath": "src/Perspectives/OrderSummaryPerspective.cs",</p>
<p>          "lineNumber": 8</p>
<p>        }</p>
<p>      ]</p>
<p>    }</p>
<p>  ]</p>
<p>}</p>
<p></code></pre></p>

<h3>Field Descriptions</h3>

<p>| Field | Type | Description |</p>
<p>|-------|------|-------------|</p>
<p>| <code>type</code> | string | Fully qualified message type name |</p>
<p>| <code>isCommand</code> | boolean | True if implements ICommand |</p>
<p>| <code>isEvent</code> | boolean | True if implements IEvent |</p>
<p>| <code>filePath</code> | string | Relative path from workspace root |</p>
<p>| <code>lineNumber</code> | number | Line number (1-based) |</p>
<p>| <code>dispatchers</code> | array | All SendAsync/PublishAsync calls |</p>
<p>| <code>receptors</code> | array | All IReceptor implementations |</p>
<p>| <code>perspectives</code> | array | All IPerspectiveOf implementations |</p>

<hr>

<h2>VSCode Extension Usage</h2>

<h3>Installing the Extension</h3>

<pre><code class="language-bash"># From VSCode Extensions panel:
<h1>Search: "Whizbang"</h1>
<h1>Install: Whizbang Message Flow Visualizer</h1>

<h1>Or from command line:</h1>
<p>code --install-extension whizbang.whizbang-vscode</p>
<p></code></pre></p>

<h3>Extension Features</h3>

<h4>1. CodeLens Annotations</h4>

<p>Inline annotations above message types:</p>

<pre><code class="language-csharp">// [3 dispatchers] [1 receptor] [0 perspectives]
<p>public record CreateOrder(Guid CustomerId, OrderItem[] Items) : ICommand;</p>
<p></code></pre></p>

<strong>Click counts</strong> to navigate:
<ul><li><code>[3 dispatchers]</code> → List of dispatcher locations</li>
<li><code>[1 receptor]</code> → Jump to receptor HandleAsync</li>
<li><code>[0 perspectives]</code> → No perspectives for this command</li>
</ul>
<h4>2. Hover Tooltips</h4>

<p>Rich markdown tooltips on hover:</p>

<pre><code class="language-">CreateOrder

<p>Type: Command</p>
<p>Handlers: 1 receptor</p>

<p>Dispatchers (3):</p>
<p>  • OrderController.CreateAsync (Controllers/OrderController.cs:42)</p>
<p>  • OrderSaga.ProcessAsync (Sagas/OrderSaga.cs:18)</p>
<p>  • OrderScheduler.ScheduleAsync (Schedulers/OrderScheduler.cs:105)</p>

<p>Receptors (1):</p>
<p>  • OrderReceptor.HandleAsync (Receptors/OrderReceptor.cs:12)</p>
<p>    Returns: OrderCreated</p>
<p></code></pre></p>

<h4>3. Go to Handler Command</h4>

<p>Right-click message → <strong>"Go to Whizbang Handler"</strong>:</p>

<pre><code class="language-">Jump to:
<p>  • OrderReceptor.HandleAsync (Receptors/OrderReceptor.cs:12)</p>
<p></code></pre></p>

<h4>4. Message Flow Visualization</h4>

<p>Command palette → <strong>"Whizbang: Show Message Flow"</strong>:</p>

<pre><code class="language-">CreateOrder
<p>  ├─ Dispatcher: OrderController.CreateAsync</p>
<p>  │   └─ Receptor: OrderReceptor.HandleAsync</p>
<p>  │       └─ Publishes: OrderCreated</p>
<p>  │           ├─ Perspective: OrderSummaryPerspective</p>
<p>  │           └─ Perspective: CustomerStatisticsPerspective</p>
<p>  └─ Dispatcher: OrderSaga.ProcessAsync</p>
<p>      └─ (Remote via Outbox)</p>
<p></code></pre></p>

<hr>

<h2>Build Integration</h2>

<h3>MSBuild Target</h3>

<p>Generator runs automatically during build. Optional: Copy JSON to <code>.whizbang/</code> folder for extension:</p>

<pre><code class="language-xml"><!-- MyApp.csproj -->
<p><Target Name="CopyMessageRegistry" AfterTargets="Build"></p>
<p>  <ItemGroup></p>
<p>    <MessageRegistryFiles Include="$(IntermediateOutputPath)generated/<em></em>/*MessageRegistry.g.cs" /></p>
<p>  </ItemGroup></p>

<p>  <!-- Extract JSON from generated C# file and write to .whizbang/message-registry.json --></p>
<p>  <Exec Command="dotnet run --project tools/extract-message-registry.csproj" /></p>
<p></Target></p>
<p></code></pre></p>

<h3>Extract JSON Script</h3>

<pre><code class="language-csharp">// tools/extract-message-registry/Program.cs
<p>using System.Text.RegularExpressions;</p>

<p>var generatedFile = args[0];  // Path to MessageRegistry.g.cs</p>
<p>var outputFile = ".whizbang/message-registry.json";</p>

<p>var content = File.ReadAllText(generatedFile);</p>

<p>// Extract JSON from embedded string</p>
<p>var match = Regex.Match(content, @"public static string Json = @""(.+?)"";", RegexOptions.Singleline);</p>
<p>if (match.Success) {</p>
<p>    var json = match.Groups[1].Value.Replace("\"\"", "\"");  // Unescape</p>
<p>    Directory.CreateDirectory(".whizbang");</p>
<p>    File.WriteAllText(outputFile, json);</p>
<p>    Console.WriteLine($"Wrote message registry to {outputFile}");</p>
<p>}</p>
<p></code></pre></p>

<strong>Run after build</strong>:
<pre><code class="language-bash">dotnet build
<h1>Writes .whizbang/message-registry.json</h1>
<p></code></pre></p>

<hr>

<h2>Generator Performance</h2>

<h3>Multi-Pipeline Architecture</h3>

<p>Generator uses <strong>4 independent pipelines</strong> for optimal caching:</p>

<pre><code class="language-csharp">// Pipeline 1: Messages
<p>var messageTypes = context.SyntaxProvider.CreateSyntaxProvider(</p>
<p>    predicate: static (node, _) => node is RecordDeclarationSyntax { BaseList.Types.Count: > 0 },</p>
<p>    transform: static (ctx, ct) => ExtractMessageType(ctx, ct)</p>
<p>);</p>

<p>// Pipeline 2: Dispatchers</p>
<p>var dispatchers = context.SyntaxProvider.CreateSyntaxProvider(</p>
<p>    predicate: static (node, _) => node is InvocationExpressionSyntax { ... },</p>
<p>    transform: static (ctx, ct) => ExtractDispatcher(ctx, ct)</p>
<p>);</p>

<p>// Pipeline 3: Receptors</p>
<p>var receptors = context.SyntaxProvider.CreateSyntaxProvider(</p>
<p>    predicate: static (node, _) => node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 },</p>
<p>    transform: static (ctx, ct) => ExtractReceptor(ctx, ct)</p>
<p>);</p>

<p>// Pipeline 4: Perspectives</p>
<p>var perspectives = context.SyntaxProvider.CreateSyntaxProvider(</p>
<p>    predicate: static (node, _) => node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 },</p>
<p>    transform: static (ctx, ct) => ExtractPerspective(ctx, ct)</p>
<p>);</p>

<p>// Combine at the end</p>
<p>var allData = messageTypes.Collect()</p>
<p>    .Combine(dispatchers.Collect())</p>
<p>    .Combine(receptors.Collect())</p>
<p>    .Combine(perspectives.Collect());</p>
<p></code></pre></p>

<strong>Why 4 pipelines?</strong>
<ul><li><strong>Independent caching</strong>: Changing a dispatcher doesn't invalidate message cache</li>
<li><strong>Optimized predicates</strong>: Each pipeline filters for its specific construct</li>
<li><strong>Parallel execution</strong>: Roslyn runs pipelines concurrently</li>
</ul>
<h3>Performance Characteristics</h3>

<pre><code class="language-">First compilation (100 messages, 200 handlers):
<p>├─ Message discovery: 30ms</p>
<p>├─ Dispatcher discovery: 40ms</p>
<p>├─ Receptor discovery: 20ms</p>
<p>├─ Perspective discovery: 15ms</p>
<p>├─ JSON generation: 5ms</p>
<p>└─ Total: 110ms</p>

<p>Incremental compilation (change 1 receptor):</p>
<p>├─ Message cache: 0ms (unchanged)</p>
<p>├─ Dispatcher cache: 0ms (unchanged)</p>
<p>├─ Receptor discovery: 20ms (changed)</p>
<p>├─ Perspective cache: 0ms (unchanged)</p>
<p>├─ JSON generation: 5ms</p>
<p>└─ Total: 25ms (85ms saved!)</p>
<p></code></pre></p>

<hr>

<h2>Cross-Assembly Messages</h2>

<p>Generator handles messages <strong>from referenced assemblies</strong>:</p>

<pre><code class="language-csharp">// In Whizbang.Core (referenced assembly)
<p>public interface ICommand { }</p>

<p>// In MyApp (your project)</p>
<p>public record CreateOrder(Guid CustomerId) : ICommand;  // ← Discovered</p>

<p>// Also in MyApp</p>
<p>public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    // ← Receptor discovered, links to CreateOrder</p>
<p>}</p>
<p></code></pre></p>

<strong>Result</strong>: CreateOrder appears in registry even though <code>ICommand</code> is external.

<strong>External Messages</strong>:
<pre><code class="language-csharp">// In SharedMessages (referenced assembly)
<p>public record CustomerCreated(Guid CustomerId) : IEvent;</p>

<p>// In MyApp</p>
<p>public class CustomerStatsPerspective : IPerspectiveOf<CustomerCreated> {</p>
<p>    // ← Perspective discovered, links to CustomerCreated</p>
<p>}</p>
<p></code></pre></p>

<strong>JSON output</strong>:
<pre><code class="language-json">{
<p>  "type": "SharedMessages.CustomerCreated",</p>
<p>  "isCommand": false,</p>
<p>  "isEvent": true,</p>
<p>  "filePath": "",  // Empty - not defined in this project</p>
<p>  "lineNumber": 0,</p>
<p>  "dispatchers": [],</p>
<p>  "receptors": [],</p>
<p>  "perspectives": [</p>
<p>    {</p>
<p>      "className": "MyApp.Perspectives.CustomerStatsPerspective",</p>
<p>      "filePath": "src/Perspectives/CustomerStatsPerspective.cs",</p>
<p>      "lineNumber": 8</p>
<p>    }</p>
<p>  ]</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefit</strong>: Complete message flow visualization across assemblies.

<hr>

<h2>Debugging</h2>

<h3>View Generated File</h3>

<pre><code class="language-">obj/Debug/net10.0/generated/Whizbang.Generators/MessageRegistryGenerator/
<p>└── MessageRegistry.g.cs</p>
<p></code></pre></p>

<p>Or configured output:</p>
<pre><code class="language-xml"><PropertyGroup>
<p>  <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles></p>
<p>  <CompilerGeneratedFilesOutputPath>.whizbang-generated</CompilerGeneratedFilesOutputPath></p>
<p></PropertyGroup></p>
<p></code></pre></p>

<h3>Validate JSON</h3>

<pre><code class="language-bash"># Extract JSON from generated file
<p>dotnet run --project tools/extract-message-registry.csproj</p>

<h1>Validate JSON</h1>
<p>cat .whizbang/message-registry.json | jq .</p>

<h1>Output:</h1>
<p>{</p>
<p>  "messages": [</p>
<p>    {</p>
<p>      "type": "MyApp.Commands.CreateOrder",</p>
<p>      "isCommand": true,</p>
<p>      ...</p>
<p>    }</p>
<p>  ]</p>
<p>}</p>
<p></code></pre></p>

<h3>VSCode Extension Logs</h3>

<p>View extension logs:</p>
<ul><li><strong>View</strong> → <strong>Output</strong></li>
<li>Select <strong>"Whizbang"</strong> from dropdown</li>
<li>See message registry loading and parsing</li>
</ul>
<pre><code class="language-">[Whizbang] Loading message registry from .whizbang/message-registry.json
<p>[Whizbang] Found 15 messages</p>
<p>[Whizbang] Registered 42 CodeLens providers</p>
<p>[Whizbang] Registry loaded successfully</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Use ICommand and IEvent</strong> markers for all messages</li>
<li>✅ <strong>Keep messages in dedicated folders</strong> (Commands/, Events/)</li>
<li>✅ <strong>Use descriptive names</strong> (CreateOrder, not Order1)</li>
<li>✅ <strong>Commit .whizbang/message-registry.json</strong> to source control (helps team)</li>
<li>✅ <strong>Rebuild after adding new messages</strong> (F5 in VSCode to reload extension)</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Modify MessageRegistry.g.cs manually (regenerated on build)</li>
<li>❌ Use abstract message types (can't be instantiated)</li>
<li>❌ Mix commands and events (implement one interface only)</li>
<li>❌ Delete .whizbang/ folder (VSCode extension needs it)</li>
</ul>
<hr>

<h2>Troubleshooting</h2>

<h3>Problem: CodeLens Not Showing</h3>

<strong>Symptoms</strong>: No <code>[X dispatchers]</code> annotations above messages.

<strong>Causes</strong>:
<ul><li>Extension not installed</li>
<li>Message registry not generated</li>
<li>Extension not loaded</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-bash"># 1. Verify extension installed
<p>code --list-extensions | grep whizbang</p>

<h1>2. Rebuild project (generates registry)</h1>
<p>dotnet build</p>

<h1>3. Check .whizbang/message-registry.json exists</h1>
<p>ls -la .whizbang/</p>

<h1>4. Reload VSCode window</h1>
<p>Ctrl+Shift+P → "Developer: Reload Window"</p>
<p></code></pre></p>

<h3>Problem: Wrong Handler Count</h3>

<strong>Symptoms</strong>: CodeLens shows <code>[1 receptor]</code> but you have 2 receptors.

<strong>Causes</strong>:
<ul><li>Stale message-registry.json</li>
<li>Receptor not discovered (missing IReceptor interface)</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-bash"># Clean and rebuild
<p>dotnet clean && dotnet build</p>

<h1>Check generated file</h1>
<p>cat .whizbang/message-registry.json | jq '.messages[] | select(.type == "MyApp.Commands.CreateOrder")'</p>

<h1>Verify receptor implements interface correctly</h1>
<p>public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    // Must have HandleAsync method</p>
<p>}</p>
<p></code></pre></p>

<h3>Problem: External Messages Not Found</h3>

<strong>Symptoms</strong>: Messages from referenced assemblies don't appear in registry.

<strong>Causes</strong>:
<ul><li>Message not used in any dispatcher/receptor/perspective</li>
<li>Assembly reference missing</li>
</ul>
<strong>Solution</strong>: Generator only includes messages that are actually <strong>used</strong> in the project. If you want external messages in registry, add at least one handler:

<pre><code class="language-csharp">// Add a perspective for external event
<p>public class ExternalEventPerspective : IPerspectiveOf<SharedMessages.CustomerCreated> {</p>
<p>    public async Task UpdateAsync(CustomerCreated @event, CancellationToken ct) {</p>
<p>        // Now CustomerCreated appears in registry!</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Source Generators</strong>:
<ul><li><a href="receptor-discovery.md">Receptor Discovery</a> - Compile-time receptor discovery</li>
<li><a href="perspective-discovery.md">Perspective Discovery</a> - Compile-time perspective discovery</li>
<li><a href="aggregate-ids.md">Aggregate IDs</a> - UUIDv7 generation for identity value objects</li>
<li><a href="json-contexts.md">JSON Contexts</a> - AOT-compatible JSON serialization</li>
</ul>
<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/dispatcher.md">Dispatcher</a> - Message routing patterns</li>
<li><a href="../core-concepts/receptors.md">Receptors</a> - Message handlers</li>
<li><a href="../core-concepts/perspectives.md">Perspectives</a> - Event-driven read models</li>
</ul>
<strong>Tools</strong>:
<ul><li><a href="../tools/vscode-extension.md">VSCode Extension</a> - IDE integration features</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-source-generators-perspective-discovery" class="doc-section">
  <h3>Perspective Discovery</h3>
  <p class="doc-path"><code>v1.0.0/source-generators/perspective-discovery</code></p>
  <p class="doc-description"><em>Compile-time perspective discovery for event-driven read models - zero reflection registration and Event Store integration</em></p>
  <div class="doc-content">

<h1>Perspective Discovery</h1>

<p>The <strong>PerspectiveDiscoveryGenerator</strong> discovers all <code>IPerspectiveOf<TEvent></code> implementations at compile-time and generates zero-reflection DI registration code. Perspectives are event-driven read models that update denormalized views in response to domain events.</p>

<h2>Perspectives vs Receptors</h2>

<p>| Aspect | Perspectives | Receptors |</p>
<p>|--------|-------------|----------|</p>
<p>| <strong>Purpose</strong> | Update read models | Handle commands/queries |</p>
<p>| <strong>Trigger</strong> | Domain events | Commands/queries |</p>
<p>| <strong>Return</strong> | void (async Task) | Typed response |</p>
<p>| <strong>Pattern</strong> | Event-driven denormalization | Command/query handling |</p>
<p>| <strong>Invocation</strong> | Via Event Store coordinator | Via Dispatcher |</p>
<p>| <strong>Use Case</strong> | Build query-optimized views | Implement business logic |</p>

<strong>Whizbang Pattern</strong>: Commands → Receptors → Events → Perspectives → Read Models

<hr>

<h2>Event-Driven Read Models</h2>

<h3>Traditional Approach (Direct Updates)</h3>

<pre><code class="language-csharp">// ❌ Tight coupling between command and query models
<p>public class OrderService {</p>
<p>    public async Task<OrderCreated> CreateOrderAsync(CreateOrder command) {</p>
<p>        // 1. Update write model</p>
<p>        var order = new Order(command.CustomerId, command.Items);</p>
<p>        await _context.Orders.AddAsync(order);</p>

<p>        // 2. Update read model (tightly coupled!)</p>
<p>        var summary = new OrderSummary {</p>
<p>            OrderId = order.Id,</p>
<p>            CustomerId = order.CustomerId,</p>
<p>            Total = order.Total,</p>
<p>            Status = "Created"</p>
<p>        };</p>
<p>        await _context.OrderSummaries.AddAsync(summary);</p>

<p>        await _context.SaveChangesAsync();</p>

<p>        return new OrderCreated(/<em> ... </em>/);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Whizbang Approach (Event-Driven)</h3>

<pre><code class="language-csharp">// ✅ Decoupled: Command handler publishes event, perspective updates read model
<p>public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    public async ValueTask<OrderCreated> HandleAsync(CreateOrder message, CancellationToken ct) {</p>
<p>        // 1. Business logic (write model)</p>
<p>        var order = new Order(message.CustomerId, message.Items);</p>

<p>        // 2. Return event (no direct coupling to read model!)</p>
<p>        return new OrderCreated(</p>
<p>            OrderId: order.Id,</p>
<p>            CustomerId: message.CustomerId,</p>
<p>            Total: order.Total,</p>
<p>            CreatedAt: DateTimeOffset.UtcNow</p>
<p>        );</p>
<p>    }</p>
<p>}</p>

<p>// ✅ Perspective updates read model independently</p>
<p>public class OrderSummaryPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>        await using var conn = _db.CreateConnection();</p>

<p>        await conn.ExecuteAsync(</p>
<p>            """</p>
<p>            INSERT INTO order_summaries (order_id, customer_id, total, status, created_at)</p>
<p>            VALUES (@OrderId, @CustomerId, @Total, 'Created', @CreatedAt)</p>
<p>            """,</p>
<p>            @event,</p>
<p>            cancellationToken: ct</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ <strong>Decoupling</strong>: Command handler doesn't know about read models</li>
<li>✅ <strong>Multiple Perspectives</strong>: Many read models from same event</li>
<li>✅ <strong>Independent Evolution</strong>: Change read models without touching commands</li>
<li>✅ <strong>Rebuild Capability</strong>: Replay events to rebuild read models</li>
</ul>
<hr>

<h2>How It Works</h2>

<h3>1. Compile-Time Discovery</h3>

<pre><code class="language-">┌──────────────────────────────────────────────────┐
<p>│  Your Code                                       │</p>
<p>│                                                  │</p>
<p>│  public class OrderSummaryPerspective           │</p>
<p>│      : IPerspectiveOf<OrderCreated> {           │</p>
<p>│    public async Task UpdateAsync(               │</p>
<p>│        OrderCreated @event,                     │</p>
<p>│        CancellationToken ct) { ... }            │</p>
<p>│  }                                               │</p>
<p>└─────────────────┬────────────────────────────────┘</p>
<p>                  │</p>
<p>                  ▼</p>
<p>┌──────────────────────────────────────────────────┐</p>
<p>│  PerspectiveDiscoveryGenerator (Roslyn)         │</p>
<p>│                                                  │</p>
<p>│  1. Scan syntax tree for classes                │</p>
<p>│  2. Filter classes with base types              │</p>
<p>│  3. Check for IPerspectiveOf<TEvent>            │</p>
<p>│  4. Extract: Class, Event types (can be many!)  │</p>
<p>└─────────────────┬────────────────────────────────┘</p>
<p>                  │</p>
<p>                  ▼</p>
<p>┌──────────────────────────────────────────────────┐</p>
<p>│  Generated Code                                  │</p>
<p>│                                                  │</p>
<p>│  PerspectiveRegistrations.g.cs                  │</p>
<p>│  └─ services.AddScoped<IPerspectiveOf<...>>()  │</p>
<p>└──────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<h3>2. Generated File</h3>

<strong>PerspectiveRegistrations.g.cs</strong>:
<pre><code class="language-csharp">using Microsoft.Extensions.DependencyInjection;
<p>using Whizbang.Core;</p>

<p>namespace MyApp.Generated;</p>

<p>public static class PerspectiveRegistrations {</p>
<p>    /// <summary></p>
<p>    /// Registers all discovered perspectives (5 perspective classes, 8 event handlers).</p>
<p>    /// Generated at compile-time by PerspectiveDiscoveryGenerator.</p>
<p>    /// </summary></p>
<p>    public static IServiceCollection AddWhizbangPerspectives(</p>
<p>        this IServiceCollection services) {</p>

<p>        // OrderSummaryPerspective handles 3 events</p>
<p>        services.AddScoped<IPerspectiveOf<OrderCreated>, OrderSummaryPerspective>();</p>
<p>        services.AddScoped<IPerspectiveOf<OrderShipped>, OrderSummaryPerspective>();</p>
<p>        services.AddScoped<IPerspectiveOf<OrderCancelled>, OrderSummaryPerspective>();</p>

<p>        // CustomerStatisticsPerspective handles 2 events</p>
<p>        services.AddScoped<IPerspectiveOf<OrderCreated>, CustomerStatisticsPerspective>();</p>
<p>        services.AddScoped<IPerspectiveOf<OrderShipped>, CustomerStatisticsPerspective>();</p>

<p>        // InventoryPerspective handles 3 events</p>
<p>        services.AddScoped<IPerspectiveOf<OrderCreated>, InventoryPerspective>();</p>
<p>        services.AddScoped<IPerspectiveOf<OrderShipped>, InventoryPerspective>();</p>
<p>        services.AddScoped<IPerspectiveOf<OrderCancelled>, InventoryPerspective>();</p>

<p>        return services;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Observations</strong>:
<ul><li>One perspective class can handle <strong>multiple events</strong> (e.g., OrderSummaryPerspective handles 3 events)</li>
<li>Multiple perspectives can handle the <strong>same event</strong> (e.g., OrderCreated handled by 3 perspectives)</li>
<li>Registered as <strong>Scoped</strong> (new instance per request/worker batch)</li>
</ul>
<hr>

<h2>Using Generated Registration</h2>

<h3>Registration in Program.cs</h3>

<pre><code class="language-csharp">// Program.cs
<p>using MyApp.Generated;</p>

<p>var builder = WebApplication.CreateBuilder(args);</p>

<p>// Register perspectives (generated method)</p>
<p>builder.Services.AddWhizbangPerspectives();</p>

<p>// Register Event Store coordinator (triggers perspectives)</p>
<p>builder.Services.AddWhizbangEventStore(/<em> config </em>/);</p>

<p>var app = builder.Build();</p>
<p>app.Run();</p>
<p></code></pre></p>

<strong>That's it!</strong> No manual registration, no reflection, no assembly scanning.

<hr>

<h2>Perspective Patterns</h2>

<h3>Pattern 1: Single Event Handler</h3>

<pre><code class="language-csharp">public class OrderSummaryPerspective : IPerspectiveOf<OrderCreated> {
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>        await using var conn = _db.CreateConnection();</p>

<p>        await conn.ExecuteAsync(</p>
<p>            """</p>
<p>            INSERT INTO order_summaries (</p>
<p>                order_id, customer_id, total, status, created_at</p>
<p>            ) VALUES (</p>
<p>                @OrderId, @CustomerId, @Total, 'Created', @CreatedAt</p>
<p>            )</p>
<p>            """,</p>
<p>            @event,</p>
<p>            cancellationToken: ct</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Generated registration</strong> (1 event):
<pre><code class="language-csharp">services.AddScoped<IPerspectiveOf<OrderCreated>, OrderSummaryPerspective>();
<p></code></pre></p>

<hr>

<h3>Pattern 2: Multiple Event Handlers</h3>

<pre><code class="language-csharp">public class OrderSummaryPerspective :
<p>    IPerspectiveOf<OrderCreated>,</p>
<p>    IPerspectiveOf<OrderShipped>,</p>
<p>    IPerspectiveOf<OrderCancelled> {</p>

<p>    private readonly IDbConnectionFactory _db;</p>

<p>    // Handle OrderCreated</p>
<p>    public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>        await using var conn = _db.CreateConnection();</p>
<p>        await conn.ExecuteAsync(</p>
<p>            "INSERT INTO order_summaries (...) VALUES (...)",</p>
<p>            @event,</p>
<p>            cancellationToken: ct</p>
<p>        );</p>
<p>    }</p>

<p>    // Handle OrderShipped</p>
<p>    public async Task UpdateAsync(OrderShipped @event, CancellationToken ct = default) {</p>
<p>        await using var conn = _db.CreateConnection();</p>
<p>        await conn.ExecuteAsync(</p>
<p>            "UPDATE order_summaries SET status = 'Shipped', shipped_at = @ShippedAt WHERE order_id = @OrderId",</p>
<p>            @event,</p>
<p>            cancellationToken: ct</p>
<p>        );</p>
<p>    }</p>

<p>    // Handle OrderCancelled</p>
<p>    public async Task UpdateAsync(OrderCancelled @event, CancellationToken ct = default) {</p>
<p>        await using var conn = _db.CreateConnection();</p>
<p>        await conn.ExecuteAsync(</p>
<p>            "UPDATE order_summaries SET status = 'Cancelled', cancelled_at = @CancelledAt WHERE order_id = @OrderId",</p>
<p>            @event,</p>
<p>            cancellationToken: ct</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Generated registration</strong> (3 events):
<pre><code class="language-csharp">services.AddScoped<IPerspectiveOf<OrderCreated>, OrderSummaryPerspective>();
<p>services.AddScoped<IPerspectiveOf<OrderShipped>, OrderSummaryPerspective>();</p>
<p>services.AddScoped<IPerspectiveOf<OrderCancelled>, OrderSummaryPerspective>();</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>Single perspective class for related updates</li>
<li>Maintains cohesion (all order summary logic in one place)</li>
<li>Generator handles multiple interface implementations automatically</li>
</ul>
<hr>

<h3>Pattern 3: Aggregated Statistics</h3>

<pre><code class="language-csharp">public class CustomerStatisticsPerspective :
<p>    IPerspectiveOf<OrderCreated>,</p>
<p>    IPerspectiveOf<OrderShipped> {</p>

<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public async Task UpdateAsync(OrderCreated @event, CancellationToken ct = default) {</p>
<p>        await using var conn = _db.CreateConnection();</p>

<p>        // Increment order count and total spent</p>
<p>        await conn.ExecuteAsync(</p>
<p>            """</p>
<p>            INSERT INTO customer_statistics (customer_id, total_orders, total_spent, last_order_at)</p>
<p>            VALUES (@CustomerId, 1, @Total, @CreatedAt)</p>
<p>            ON CONFLICT (customer_id) DO UPDATE SET</p>
<p>                total_orders = customer_statistics.total_orders + 1,</p>
<p>                total_spent = customer_statistics.total_spent + @Total,</p>
<p>                last_order_at = @CreatedAt</p>
<p>            """,</p>
<p>            new { @event.CustomerId, @event.Total, @event.CreatedAt },</p>
<p>            cancellationToken: ct</p>
<p>        );</p>
<p>    }</p>

<p>    public async Task UpdateAsync(OrderShipped @event, CancellationToken ct = default) {</p>
<p>        await using var conn = _db.CreateConnection();</p>

<p>        // Update last shipped date</p>
<p>        await conn.ExecuteAsync(</p>
<p>            """</p>
<p>            UPDATE customer_statistics</p>
<p>            SET last_shipped_at = @ShippedAt</p>
<p>            WHERE customer_id = @CustomerId</p>
<p>            """,</p>
<p>            new { @event.CustomerId, @event.ShippedAt },</p>
<p>            cancellationToken: ct</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Use Case</strong>: Pre-compute aggregations for analytics dashboards.

<hr>

<h2>Event Store Integration</h2>

<h3>Perspective Invocation Flow</h3>

<pre><code class="language-">1. Receptor handles command, returns event
<p>   └─> OrderCreated event</p>

<ul><li>Event published to Event Store</li>
</ul><p>   └─> Stored in wh_events table</p>

<ul><li>Event Store Coordinator processes event</li>
</ul><p>   └─> Resolves IPerspectiveOf<OrderCreated> implementations</p>

<ul><li>Perspectives invoked (parallel)</li>
</ul><p>   ├─> OrderSummaryPerspective.UpdateAsync(OrderCreated)</p>
<p>   ├─> CustomerStatisticsPerspective.UpdateAsync(OrderCreated)</p>
<p>   └─> InventoryPerspective.UpdateAsync(OrderCreated)</p>

<ul><li>Checkpoints updated</li>
</ul><p>   └─> wh_perspective_checkpoints table</p>
<p></code></pre></p>

<h3>Checkpoint-Based Processing</h3>

<p>Each perspective tracks <strong>last processed event</strong> per stream:</p>

<pre><code class="language-sql">-- wh_perspective_checkpoints table
<p>CREATE TABLE wh_perspective_checkpoints (</p>
<p>    stream_id UUID NOT NULL,</p>
<p>    perspective_name VARCHAR(200) NOT NULL,</p>
<p>    last_event_id UUID NOT NULL,</p>
<p>    last_sequence_number BIGINT NOT NULL,</p>
<p>    status VARCHAR(50) NOT NULL,</p>
<p>    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),</p>

<p>    PRIMARY KEY (stream_id, perspective_name)</p>
<p>);</p>
<p></code></pre></p>

<strong>Example</strong>:
<pre><code class="language-">stream_id                           | perspective_name           | last_event_id | last_sequence_number
<p>------------------------------------|----------------------------|---------------|---------------------</p>
<p>order-abc-123                       | OrderSummaryPerspective    | event-001     | 5</p>
<p>order-abc-123                       | CustomerStatistics         | event-001     | 5</p>
<p>order-abc-123                       | InventoryPerspective       | event-001     | 5</p>
<p></code></pre></p>

<strong>Benefit</strong>: Can rebuild perspectives from any checkpoint (time-travel!).

<hr>

<h2>Rebuilding Perspectives</h2>

<h3>Full Rebuild</h3>

<pre><code class="language-csharp">public class PerspectiveRebuilder {
<p>    private readonly IEventStore _eventStore;</p>
<p>    private readonly IServiceProvider _services;</p>

<p>    public async Task RebuildAllPerspectivesAsync(CancellationToken ct = default) {</p>
<p>        // 1. Truncate all perspective tables</p>
<p>        await TruncatePerspectiveTables();</p>

<p>        // 2. Reset checkpoints</p>
<p>        await ResetCheckpoints();</p>

<p>        // 3. Read all events from Event Store</p>
<p>        var events = await _eventStore.ReadAllEventsAsync(fromSequence: 0);</p>

<p>        // 4. Resolve all perspectives</p>
<p>        var perspectives = GetAllPerspectives();</p>

<p>        // 5. Replay events through perspectives</p>
<p>        foreach (var @event in events) {</p>
<p>            foreach (var perspective in perspectives) {</p>
<p>                if (CanHandle(perspective, @event)) {</p>
<p>                    await perspective.UpdateAsync(@event, ct);</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
<p>    }</p>

<p>    private IEnumerable<IPerspectiveOf<object>> GetAllPerspectives() {</p>
<p>        // Generator registers all perspectives, we can resolve them here</p>
<p>        return _services.GetServices<IPerspectiveOf<OrderCreated>>()</p>
<p>            .Concat(_services.GetServices<IPerspectiveOf<OrderShipped>>())</p>
<p>            .Concat(_services.GetServices<IPerspectiveOf<OrderCancelled>>())</p>
<p>            .Cast<IPerspectiveOf<object>>();</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Use Cases</strong>:
<ul><li>Add new perspective to existing system</li>
<li>Fix bug in perspective logic</li>
<li>Schema migration (add new columns)</li>
<li>Analytics: "What would customer stats look like without refunds?"</li>
</ul>
<hr>

<h2>Generator Performance</h2>

<h3>Incremental Caching</h3>

<p>Like ReceptorDiscoveryGenerator, uses <strong>value-based caching</strong>:</p>

<pre><code class="language-csharp">internal sealed record PerspectiveInfo(
<p>    string ClassName,</p>
<p>    string[] EventTypes  // Arrays support value equality in records!</p>
<p>);</p>
<p></code></pre></p>

<strong>Performance</strong>:
<pre><code class="language-">First compilation:
<p>├─ Scan syntax tree: 50ms</p>
<p>├─ Extract perspective info: 20ms</p>
<p>├─ Generate registration file: 5ms</p>
<p>└─ Total: 75ms</p>

<p>Subsequent compilation (no changes):</p>
<p>├─ Check cache: 1ms (inputs unchanged)</p>
<p>├─ Skip generation: 0ms</p>
<p>└─ Total: 1ms (74ms saved!)</p>
<p></code></pre></p>

<h3>Syntactic Filtering</h3>

<pre><code class="language-csharp">// Fast syntactic check (no semantic model access)
<p>predicate: static (node, _) => node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 },</p>

<p>// Only runs on ~5% of nodes (those with base types)</p>
<p>transform: static (ctx, ct) => ExtractPerspectiveInfo(ctx, ct)</p>
<p></code></pre></p>

<strong>Result</strong>: 100x faster than analyzing every node!

<hr>

<h2>Debugging Generated Code</h2>

<h3>View Generated File</h3>

<p>Generated file written to:</p>
<pre><code class="language-">obj/Debug/net10.0/generated/Whizbang.Generators/PerspectiveDiscoveryGenerator/
<p>└── PerspectiveRegistrations.g.cs</p>
<p></code></pre></p>

<p>Or configured output:</p>
<pre><code class="language-xml"><PropertyGroup>
<p>  <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles></p>
<p>  <CompilerGeneratedFilesOutputPath>.whizbang-generated</CompilerGeneratedFilesOutputPath></p>
<p></PropertyGroup></p>
<p></code></pre></p>

<h3>Build Diagnostics</h3>

<p>Generator reports discoveries:</p>

<pre><code class="language-">Build started...
<p>info WHIZ003: Found perspective 'OrderSummaryPerspective' handling OrderCreated, OrderShipped, OrderCancelled</p>
<p>info WHIZ003: Found perspective 'CustomerStatisticsPerspective' handling OrderCreated, OrderShipped</p>
<p>info WHIZ003: Found perspective 'InventoryPerspective' handling OrderCreated, OrderShipped, OrderCancelled</p>
<p>Build succeeded.</p>
<p>    3 perspectives discovered (8 event handlers)</p>
<p></code></pre></p>

<hr>

<h2>Diagnostics</h2>

<h3>WHIZ003: Perspective Discovered</h3>

<strong>Severity</strong>: Info

<strong>Message</strong>: <code>Found perspective '{0}' handling {1}</code>

<strong>Example</strong>:
<pre><code class="language-">info WHIZ003: Found perspective 'OrderSummaryPerspective' handling OrderCreated, OrderShipped, OrderCancelled
<p></code></pre></p>

<strong>When</strong>: Reported for each discovered perspective during compilation.

<strong>Args</strong>:
<ul><li><code>{0}</code>: Perspective class name (e.g., OrderSummaryPerspective)</li>
<li><code>{1}</code>: Comma-separated event types (e.g., OrderCreated, OrderShipped, OrderCancelled)</li>
</ul>
<hr>

<h2>Multiple Perspectives Per Event</h2>

<strong>One event, many read models</strong>:

<pre><code class="language-csharp">// Event
<p>public record OrderCreated(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    decimal Total,</p>
<p>    DateTimeOffset CreatedAt</p>
<p>);</p>

<p>// Perspective 1: Order summary view</p>
<p>public class OrderSummaryPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>    public async Task UpdateAsync(OrderCreated @event, CancellationToken ct) {</p>
<p>        // Update order_summaries table</p>
<p>    }</p>
<p>}</p>

<p>// Perspective 2: Customer statistics</p>
<p>public class CustomerStatisticsPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>    public async Task UpdateAsync(OrderCreated @event, CancellationToken ct) {</p>
<p>        // Update customer_statistics table (aggregate)</p>
<p>    }</p>
<p>}</p>

<p>// Perspective 3: Inventory reservation</p>
<p>public class InventoryPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>    public async Task UpdateAsync(OrderCreated @event, CancellationToken ct) {</p>
<p>        // Update inventory table (decrement available)</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Generator registers all three</strong>:
<pre><code class="language-csharp">services.AddScoped<IPerspectiveOf<OrderCreated>, OrderSummaryPerspective>();
<p>services.AddScoped<IPerspectiveOf<OrderCreated>, CustomerStatisticsPerspective>();</p>
<p>services.AddScoped<IPerspectiveOf<OrderCreated>, InventoryPerspective>();</p>
<p></code></pre></p>

<strong>Event Store Coordinator invokes all in parallel</strong> (or configurable sequential).

<hr>

<h2>AOT Compatibility</h2>

<h3>Zero Reflection Guarantee</h3>

<p>Generated registration uses <strong>no reflection</strong>:</p>

<pre><code class="language-csharp">// ✅ Direct type registration (AOT-compatible)
<p>services.AddScoped<IPerspectiveOf<OrderCreated>, OrderSummaryPerspective>();</p>

<p>// ❌ Reflection-based registration (incompatible with AOT)</p>
<p>var perspectiveType = typeof(IPerspectiveOf<>).MakeGenericType(eventType);</p>
<p>var implementationType = assembly.GetTypes().First(t => t.IsAssignableTo(perspectiveType));</p>
<p>services.AddScoped(perspectiveType, implementationType);</p>
<p></code></pre></p>

<h3>Native AOT Verification</h3>

<pre><code class="language-xml"><PropertyGroup>
<p>  <PublishAot>true</PublishAot></p>
<p></PropertyGroup></p>
<p></code></pre></p>

<strong>Build output</strong>:
<pre><code class="language-">dotnet publish -c Release
<p>...</p>
<p>Generating native code</p>
<p>  MyApp.dll -> MyApp.exe (Native AOT)</p>
<p>  Startup time: < 10ms</p>
<p>  Perspectives registered: 5 classes, 8 event handlers</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Implement IPerspectiveOf<TEvent></strong> for each event your read model needs</li>
<li>✅ <strong>Group related updates</strong> in one perspective class (e.g., OrderSummaryPerspective)</li>
<li>✅ <strong>Use UPSERT</strong> for idempotency (ON CONFLICT DO UPDATE)</li>
<li>✅ <strong>Keep perspectives simple</strong> (no complex business logic)</li>
<li>✅ <strong>Use Dapper</strong> for high-performance reads/writes</li>
<li>✅ <strong>Design for rebuild</strong> (assume events can be replayed)</li>
<li>✅ <strong>Call AddWhizbangPerspectives()</strong> in Program.cs</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Put business logic in perspectives (belong in receptors)</li>
<li>❌ Query other services in perspectives (use denormalized data from event)</li>
<li>❌ Forget idempotency (events can be replayed!)</li>
<li>❌ Use EF Core for perspectives (Dapper is 20x faster)</li>
<li>❌ Manually register perspectives (generator handles this)</li>
<li>❌ Modify generated files (will be overwritten)</li>
</ul>
<hr>

<h2>Troubleshooting</h2>

<h3>Problem: Perspective Not Invoked</h3>

<strong>Symptoms</strong>: Event published but perspective's <code>UpdateAsync</code> never called.

<strong>Causes</strong>:
<ul><li>Perspective not implementing <code>IPerspectiveOf<TEvent></code> correctly</li>
<li>Missing <code>AddWhizbangPerspectives()</code> call</li>
<li>Event type mismatch (spelling, namespace)</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-csharp">// ✅ Correct interface implementation
<p>public class OrderSummaryPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>    public async Task UpdateAsync(OrderCreated @event, CancellationToken ct) {</p>
<p>        // Implementation</p>
<p>    }</p>
<p>}</p>

<p>// Program.cs</p>
<p>builder.Services.AddWhizbangPerspectives();  // Required!</p>
<p></code></pre></p>

<h3>Problem: Duplicate Perspective Updates</h3>

<strong>Symptoms</strong>: Same event processed multiple times by perspective.

<strong>Causes</strong>:
<ul><li>Missing checkpoint tracking</li>
<li>Event Store replaying events without checking checkpoints</li>
</ul>
<strong>Solution</strong>: Use <code>IWorkCoordinator.ProcessWorkBatchAsync</code> with perspective checkpoint tracking:

<pre><code class="language-csharp">await _coordinator.ProcessWorkBatchAsync(
<p>    /<em> ... </em>/,</p>
<p>    perspectiveCompletions: new[] {</p>
<p>        new PerspectiveCheckpointCompletion {</p>
<p>            StreamId = @event.StreamId,</p>
<p>            PerspectiveName = nameof(OrderSummaryPerspective),</p>
<p>            LastEventId = @event.EventId,</p>
<p>            Status = PerspectiveProcessingStatus.UpToDate</p>
<p>        }</p>
<p>    },</p>
<p>    /<em> ... </em>/</p>
<p>);</p>
<p></code></pre></p>

<h3>Problem: Generator Doesn't Find Perspectives</h3>

<strong>Symptoms</strong>: <code>PerspectiveRegistrations.g.cs</code> not generated or empty.

<strong>Causes</strong>:
<ul><li>No perspectives in project</li>
<li>Perspectives are abstract classes (can't be instantiated)</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-csharp">// ✅ Concrete class
<p>public class OrderSummaryPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>    // Implementation</p>
<p>}</p>

<p>// ❌ Abstract class (skipped by generator)</p>
<p>public abstract class BasePerspective : IPerspectiveOf<OrderCreated> {</p>
<p>    // Abstract classes can't be instantiated</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Source Generators</strong>:
<ul><li><a href="receptor-discovery.md">Receptor Discovery</a> - Compile-time receptor discovery</li>
<li><a href="message-registry.md">Message Registry</a> - VSCode extension integration</li>
<li><a href="aggregate-ids.md">Aggregate IDs</a> - UUIDv7 generation for identity value objects</li>
<li><a href="json-contexts.md">JSON Contexts</a> - AOT-compatible JSON serialization</li>
</ul>
<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/perspectives.md">Perspectives</a> - Event-driven read models</li>
<li><a href="../core-concepts/lenses.md">Lenses</a> - Query-optimized repositories</li>
</ul>
<strong>Data Access</strong>:
<ul><li><a href="../data/perspectives-storage.md">Perspectives Storage</a> - Read model schema design</li>
<li><a href="../data/event-store.md">Event Store</a> - Event sourcing and replay</li>
</ul>
<strong>Messaging</strong>:
<ul><li><a href="../messaging/work-coordinator.md">Work Coordinator</a> - Atomic batch processing</li>
</ul>
<strong>Workers</strong>:
<ul><li><a href="../workers/perspective-worker.md">Perspective Worker</a> - Checkpoint processing lifecycle and runtime behavior</li>
<li><a href="../workers/execution-lifecycle.md">Execution Lifecycle</a> - Startup/shutdown coordination</li>
<li><a href="../workers/database-readiness.md">Database Readiness</a> - Dependency coordination</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2025-12-21</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-source-generators-receptor-discovery" class="doc-section">
  <h3>Receptor Discovery</h3>
  <p class="doc-path"><code>v1.0.0/source-generators/receptor-discovery</code></p>
  <p class="doc-description"><em>Compile-time receptor discovery with Roslyn source generators - zero reflection, AOT-compatible message routing</em></p>
  <div class="doc-content">

<h1>Receptor Discovery</h1>

<p>The <strong>ReceptorDiscoveryGenerator</strong> discovers all <code>IReceptor<TMessage, TResponse></code> implementations at compile-time and generates zero-reflection message routing code. This enables AOT compatibility and optimal runtime performance.</p>

<h2>Zero Reflection Philosophy</h2>

<p>Traditional frameworks discover handlers at runtime using <strong>reflection</strong>:</p>

<pre><code class="language-csharp">// ❌ Reflection-based (incompatible with AOT, slow startup)
<p>foreach (var type in assembly.GetTypes()) {</p>
<p>    if (type.IsAssignableTo(typeof(IReceptor<,>))) {</p>
<p>        services.AddScoped(type.GetInterfaces()[0], type);  // Runtime discovery</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<p>Whizbang uses <strong>Roslyn source generators</strong> for compile-time discovery:</p>

<pre><code class="language-csharp">// ✅ Zero reflection (AOT-compatible, instant startup)
<p>services.AddScoped<IReceptor<CreateOrder, OrderCreated>, OrderReceptor>();</p>
<p>services.AddScoped<IReceptor<ShipOrder, OrderShipped>, ShipOrderReceptor>();</p>
<p>// Generated at compile-time!</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ <strong>AOT Compatible</strong>: No runtime reflection or assembly scanning</li>
<li>✅ <strong>Fast Startup</strong>: No discovery overhead (< 1ms registration)</li>
<li>✅ <strong>Type Safe</strong>: Compile-time validation of all receptors</li>
<li>✅ <strong>Optimal Performance</strong>: Direct dispatch without dictionary lookups (~20ns overhead)</li>
</ul>
<hr>

<h2>How It Works</h2>

<h3>1. Compile-Time Discovery</h3>

<pre><code class="language-">┌──────────────────────────────────────────────────┐
<p>│  Your Code                                       │</p>
<p>│                                                  │</p>
<p>│  public class OrderReceptor                     │</p>
<p>│      : IReceptor<CreateOrder, OrderCreated> {   │</p>
<p>│    // Implementation...                          │</p>
<p>│  }                                               │</p>
<p>└─────────────────┬────────────────────────────────┘</p>
<p>                  │</p>
<p>                  ▼</p>
<p>┌──────────────────────────────────────────────────┐</p>
<p>│  ReceptorDiscoveryGenerator (Roslyn)            │</p>
<p>│                                                  │</p>
<p>│  1. Scan syntax tree for classes                │</p>
<p>│  2. Filter classes with base types              │</p>
<p>│  3. Check for IReceptor<TMessage, TResponse>    │</p>
<p>│  4. Extract: Class, Message, Response types     │</p>
<p>└─────────────────┬────────────────────────────────┘</p>
<p>                  │</p>
<p>                  ▼</p>
<p>┌──────────────────────────────────────────────────┐</p>
<p>│  Generated Code (3 files)                       │</p>
<p>│                                                  │</p>
<p>│  1. DispatcherRegistrations.g.cs                │</p>
<p>│     └─ services.AddScoped<IReceptor<...>, ...>()│</p>
<p>│                                                  │</p>
<p>│  2. Dispatcher.g.cs                             │</p>
<p>│     └─ Type-safe routing logic                  │</p>
<p>│                                                  │</p>
<p>│  3. ReceptorDiscoveryDiagnostics.g.cs           │</p>
<p>│     └─ Startup diagnostics                      │</p>
<p>└──────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<h3>2. Generated Files</h3>

<strong>DispatcherRegistrations.g.cs</strong> (DI Registration):
<pre><code class="language-csharp">using Microsoft.Extensions.DependencyInjection;
<p>using Whizbang.Core;</p>

<p>namespace MyApp.Generated;</p>

<p>public static class DispatcherRegistrations {</p>
<p>    public static IServiceCollection AddWhizbangDispatchers(</p>
<p>        this IServiceCollection services) {</p>

<p>        // Generated receptor registrations (3 found)</p>
<p>        services.AddScoped<IReceptor<CreateOrder, OrderCreated>, OrderReceptor>();</p>
<p>        services.AddScoped<IReceptor<ShipOrder, OrderShipped>, ShipOrderReceptor>();</p>
<p>        services.AddScoped<IReceptor<CancelOrder, OrderCancelled>, CancelOrderReceptor>();</p>

<p>        // Register generated dispatcher</p>
<p>        services.AddScoped<IDispatcher, GeneratedDispatcher>();</p>

<p>        return services;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Dispatcher.g.cs</strong> (Type-Safe Routing):
<pre><code class="language-csharp">using System;
<p>using System.Threading;</p>
<p>using System.Threading.Tasks;</p>
<p>using Microsoft.Extensions.DependencyInjection;</p>
<p>using Whizbang.Core;</p>

<p>namespace MyApp.Generated;</p>

<p>public class GeneratedDispatcher : Dispatcher {</p>
<p>    public GeneratedDispatcher(IServiceProvider services) : base(services) { }</p>

<p>    protected override ReceptorInvoker<TResult>? GetReceptorInvoker<TResult>(</p>
<p>        object message,</p>
<p>        Type messageType) {</p>

<p>        // Generated routing (zero reflection, zero allocations)</p>
<p>        if (messageType == typeof(CreateOrder)) {</p>
<p>            var receptor = _serviceProvider.GetRequiredService<IReceptor<CreateOrder, OrderCreated>>();</p>
<p>            return async msg => (TResult)(object)await receptor.HandleAsync((CreateOrder)msg);</p>
<p>        }</p>

<p>        if (messageType == typeof(ShipOrder)) {</p>
<p>            var receptor = _serviceProvider.GetRequiredService<IReceptor<ShipOrder, OrderShipped>>();</p>
<p>            return async msg => (TResult)(object)await receptor.HandleAsync((ShipOrder)msg);</p>
<p>        }</p>

<p>        if (messageType == typeof(CancelOrder)) {</p>
<p>            var receptor = _serviceProvider.GetRequiredService<IReceptor<CancelOrder, OrderCancelled>>();</p>
<p>            return async msg => (TResult)(object)await receptor.HandleAsync((CancelOrder)msg);</p>
<p>        }</p>

<p>        return null;  // No receptor found</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>ReceptorDiscoveryDiagnostics.g.cs</strong> (Startup Info):
<pre><code class="language-csharp">using System.Text;
<p>using Whizbang.Core.Diagnostics;</p>

<p>namespace MyApp.Generated;</p>

<p>[WhizbangDiagnosticCollector]</p>
<p>internal static class ReceptorDiscoveryDiagnostics {</p>
<p>    public static void Register() {</p>
<p>        WhizbangDiagnostics.RegisterDiagnostic("Receptor Discovery", () => {</p>
<p>            var message = new StringBuilder();</p>
<p>            message.AppendLine("Discovered 3 receptors at compile-time:");</p>
<p>            message.AppendLine();</p>

<p>            message.AppendLine("  1. OrderReceptor: CreateOrder → OrderCreated");</p>
<p>            message.AppendLine("  2. ShipOrderReceptor: ShipOrder → OrderShipped");</p>
<p>            message.AppendLine("  3. CancelOrderReceptor: CancelOrder → OrderCancelled");</p>

<p>            return message.ToString();</p>
<p>        });</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Using Generated Registration</h2>

<h3>Registration in Program.cs</h3>

<pre><code class="language-csharp">// Program.cs
<p>using MyApp.Generated;  // Generated namespace</p>

<p>var builder = WebApplication.CreateBuilder(args);</p>

<p>// Register Whizbang dispatchers (generated method)</p>
<p>builder.Services.AddWhizbangDispatchers();</p>

<p>var app = builder.Build();</p>
<p>app.Run();</p>
<p></code></pre></p>

<strong>That's it!</strong> No manual registration, no reflection, no assembly scanning.

<hr>

<h2>Receptor Patterns</h2>

<h3>Pattern 1: Command → Event</h3>

<pre><code class="language-csharp">public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> {
<p>    public async ValueTask<OrderCreated> HandleAsync(</p>
<p>        CreateOrder message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        // Business logic</p>
<p>        var order = new Order(message.CustomerId, message.Items);</p>

<p>        // Return event</p>
<p>        return new OrderCreated(</p>
<p>            OrderId: order.Id,</p>
<p>            CustomerId: order.CustomerId,</p>
<p>            Total: order.Total,</p>
<p>            CreatedAt: DateTimeOffset.UtcNow</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Generated routing</strong>:
<pre><code class="language-csharp">if (messageType == typeof(CreateOrder)) {
<p>    var receptor = _serviceProvider.GetRequiredService<IReceptor<CreateOrder, OrderCreated>>();</p>
<p>    return async msg => (TResult)(object)await receptor.HandleAsync((CreateOrder)msg);</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern 2: Query → Result</h3>

<pre><code class="language-csharp">public class GetOrderReceptor : IReceptor<GetOrder, OrderSummary> {
<p>    private readonly IDbConnectionFactory _db;</p>

<p>    public async ValueTask<OrderSummary> HandleAsync(</p>
<p>        GetOrder query,</p>
<p>        CancellationToken ct = default) {</p>

<p>        await using var conn = _db.CreateConnection();</p>

<p>        return await conn.QuerySingleOrDefaultAsync<OrderSummary>(</p>
<p>            "SELECT * FROM order_summaries WHERE order_id = @OrderId",</p>
<p>            new { query.OrderId },</p>
<p>            cancellationToken: ct</p>
<p>        ) ?? throw new NotFoundException($"Order {query.OrderId} not found");</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern 3: Void Receptor (No Response)</h3>

<pre><code class="language-csharp">public class SendEmailReceptor : IReceptor<SendEmail> {  // No response type
<p>    private readonly IEmailService _email;</p>

<p>    public async ValueTask HandleAsync(</p>
<p>        SendEmail message,</p>
<p>        CancellationToken ct = default) {</p>

<p>        await _email.SendAsync(</p>
<p>            to: message.To,</p>
<p>            subject: message.Subject,</p>
<p>            body: message.Body,</p>
<p>            ct: ct</p>
<p>        );</p>

<p>        // No return value</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Generated routing</strong> (void pattern):
<pre><code class="language-csharp">if (messageType == typeof(SendEmail)) {
<p>    var receptor = _serviceProvider.GetRequiredService<IReceptor<SendEmail>>();</p>
<p>    await receptor.HandleAsync((SendEmail)msg);</p>
<p>    return default;  // Void receptor</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Generator Performance</h2>

<h3>Incremental Compilation</h3>

<p>Roslyn incremental generators use <strong>value-based caching</strong> to skip work when inputs haven't changed:</p>

<pre><code class="language-">First compilation:
<p>├─ Scan syntax tree: 50ms</p>
<p>├─ Extract receptor info: 20ms</p>
<p>├─ Generate 3 files: 10ms</p>
<p>└─ Total: 80ms</p>

<p>Subsequent compilation (no changes):</p>
<p>├─ Check cache: 1ms (inputs unchanged)</p>
<p>├─ Skip generation: 0ms</p>
<p>└─ Total: 1ms (79ms saved!)</p>

<p>Compilation after receptor change:</p>
<p>├─ Check cache: 1ms (CreateOrder receptor changed)</p>
<p>├─ Scan syntax tree: 50ms</p>
<p>├─ Extract receptor info: 20ms</p>
<p>├─ Generate 3 files: 10ms</p>
<p>└─ Total: 81ms (only re-runs affected pipeline)</p>
<p></code></pre></p>

<strong>Key Insight</strong>: Generator only re-runs when receptors actually change, not on every compilation.

<h3>Syntactic Filtering</h3>

<p>Generator uses <strong>syntactic predicates</strong> to filter 95%+ of nodes before expensive semantic analysis:</p>

<pre><code class="language-csharp">// Fast syntactic check (no semantic model access)
<p>predicate: static (node, _) => node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 },</p>

<p>// Only runs on ~5% of nodes (those with base types)</p>
<p>transform: static (ctx, ct) => ExtractReceptorInfo(ctx, ct)</p>
<p></code></pre></p>

<strong>Performance</strong>:
<ul><li>Without predicate: ~10,000ms on 10,000 types (analyzes everything)</li>
<li>With predicate: ~50-100ms on 10,000 types (analyzes only 500 classes with base types)</li>
</ul>
<strong>100x faster</strong> with proper filtering!

<hr>

<h2>Debugging Generated Code</h2>

<h3>View Generated Files</h3>

<p>Generated files are written to:</p>
<pre><code class="language-">obj/Debug/net10.0/generated/Whizbang.Generators/ReceptorDiscoveryGenerator/
<p>├── DispatcherRegistrations.g.cs</p>
<p>├── Dispatcher.g.cs</p>
<p>└── ReceptorDiscoveryDiagnostics.g.cs</p>
<p></code></pre></p>

<p>Or optionally configured output folder:</p>
<pre><code class="language-xml"><PropertyGroup>
<p>  <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles></p>
<p>  <CompilerGeneratedFilesOutputPath>.whizbang-generated</CompilerGeneratedFilesOutputPath></p>
<p></PropertyGroup></p>
<p></code></pre></p>

<h3>Build Diagnostics</h3>

<p>Generator reports discoveries during build:</p>

<pre><code class="language-">Build started...
<p>info WHIZ001: Found receptor 'OrderReceptor' handling CreateOrder → OrderCreated</p>
<p>info WHIZ001: Found receptor 'ShipOrderReceptor' handling ShipOrder → OrderShipped</p>
<p>info WHIZ001: Found receptor 'CancelOrderReceptor' handling CancelOrder → OrderCancelled</p>
<p>Build succeeded.</p>
<p>    3 receptors discovered</p>
<p></code></pre></p>

<h3>Startup Diagnostics</h3>

<p>View discovered receptors at application startup:</p>

<pre><code class="language-csharp">// Enable diagnostics
<p>WhizbangDiagnostics.EnableLogging = true;</p>

<p>var app = builder.Build();</p>

<p>// View diagnostics before running</p>
<p>var diagnostics = WhizbangDiagnostics.GetAllDiagnostics();</p>
<p>foreach (var (category, messageFn) in diagnostics) {</p>
<p>    Console.WriteLine($"[{category}]");</p>
<p>    Console.WriteLine(messageFn());</p>
<p>    Console.WriteLine();</p>
<p>}</p>

<p>app.Run();</p>
<p></code></pre></p>

<strong>Output</strong>:
<pre><code class="language-">[Receptor Discovery]
<p>Discovered 3 receptors at compile-time:</p>

<p>  1. OrderReceptor: CreateOrder → OrderCreated</p>
<p>  2. ShipOrderReceptor: ShipOrder → OrderShipped</p>
<p>  3. CancelOrderReceptor: CancelOrder → OrderCancelled</p>
<p></code></pre></p>

<hr>

<h2>Diagnostics</h2>

<h3>WHIZ001: Receptor Discovered</h3>

<strong>Severity</strong>: Info

<strong>Message</strong>: <code>Found receptor '{0}' handling {1} → {2}</code>

<strong>Example</strong>:
<pre><code class="language-">info WHIZ001: Found receptor 'OrderReceptor' handling CreateOrder → OrderCreated
<p></code></pre></p>

<strong>When</strong>: Reported for each discovered receptor during compilation.

<hr>

<h3>WHIZ002: No Receptors Found</h3>

<strong>Severity</strong>: Warning

<strong>Message</strong>: <code>No IReceptor implementations were found in the compilation</code>

<strong>Example</strong>:
<pre><code class="language-">warning WHIZ002: No IReceptor implementations were found in the compilation
<p></code></pre></p>

<strong>When</strong>: No receptors discovered (may indicate missing implementations or namespace issues).

<strong>Fix</strong>:
<ul><li>Ensure receptors implement <code>IReceptor<TMessage, TResponse></code></li>
<li>Verify <code>using Whizbang.Core;</code> is present</li>
<li>Check that receptors are in the same project or referenced project</li>
</ul>
<hr>

<h2>Multiple Receptors Per Message</h2>

<strong>One message, multiple destinations</strong>:

<pre><code class="language-csharp">// Local receptor (in-process)
<p>public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    public async ValueTask<OrderCreated> HandleAsync(CreateOrder message, CancellationToken ct) {</p>
<p>        // Create order locally</p>
<p>        return new OrderCreated(/<em> ... </em>/);</p>
<p>    }</p>
<p>}</p>

<p>// Remote receptor (via outbox)</p>
<p>public class NotifyInventoryReceptor : IReceptor<CreateOrder, InventoryNotified> {</p>
<p>    public async ValueTask<InventoryNotified> HandleAsync(CreateOrder message, CancellationToken ct) {</p>
<p>        // Send to inventory service via outbox</p>
<p>        return new InventoryNotified(/<em> ... </em>/);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Generator handles both</strong>:
<pre><code class="language-csharp">// SendAsync: Routes to first receptor
<p>if (messageType == typeof(CreateOrder)) {</p>
<p>    var receptor = _serviceProvider.GetRequiredService<IReceptor<CreateOrder, OrderCreated>>();</p>
<p>    return async msg => await receptor.HandleAsync((CreateOrder)msg);</p>
<p>}</p>

<p>// PublishAsync: Routes to all receptors</p>
<p>if (messageType == typeof(CreateOrder)) {</p>
<p>    var receptors = _serviceProvider.GetServices<IReceptor<CreateOrder, *>>();</p>
<p>    foreach (var receptor in receptors) {</p>
<p>        await receptor.HandleAsync((CreateOrder)msg);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>AOT Compatibility</h2>

<h3>Zero Reflection Guarantee</h3>

<p>Generated code uses <strong>no reflection</strong>:</p>

<pre><code class="language-csharp">// ✅ Direct type checks (AOT-compatible)
<p>if (messageType == typeof(CreateOrder)) {</p>
<p>    var receptor = _serviceProvider.GetRequiredService<IReceptor<CreateOrder, OrderCreated>>();</p>
<p>    return async msg => await receptor.HandleAsync((CreateOrder)msg);</p>
<p>}</p>

<p>// ❌ Reflection-based routing (incompatible with AOT)</p>
<p>var receptorType = typeof(IReceptor<,>).MakeGenericType(messageType, responseType);</p>
<p>var receptor = _serviceProvider.GetService(receptorType);</p>
<p>var method = receptorType.GetMethod("HandleAsync");</p>
<p>return method.Invoke(receptor, new[] { message });</p>
<p></code></pre></p>

<h3>Native AOT Verification</h3>

<pre><code class="language-xml"><!-- Enable Native AOT -->
<p><PropertyGroup></p>
<p>  <PublishAot>true</PublishAot></p>
<p></PropertyGroup></p>
<p></code></pre></p>

<strong>Build output</strong>:
<pre><code class="language-">dotnet publish -c Release
<p>...</p>
<p>Generating native code</p>
<p>  MyApp.dll -> MyApp.exe (Native AOT)</p>
<p>  Binary size: 8.2 MB</p>
<p>  Startup time: < 10ms</p>
<p></code></pre></p>

<strong>Whizbang dispatcher adds < 1KB to native binary size!</strong>

<hr>

<h2>Performance Characteristics</h2>

<h3>Dispatch Overhead</h3>

<p>| Method | Overhead | Notes |</p>
<p>|--------|----------|-------|</p>
<p>| <strong>LocalInvokeAsync</strong> | < 20ns | Direct method call via delegate |</p>
<p>| <strong>SendAsync</strong> | ~100ns | Includes outbox storage if no local receptor |</p>
<p>| <strong>PublishAsync</strong> | ~50ns per receptor | Parallel invocation |</p>

<strong>Benchmark</strong>:
<pre><code class="language-csharp">[Benchmark]
<p>public async Task LocalInvokeAsync_CreateOrder() {</p>
<p>    var result = await _dispatcher.LocalInvokeAsync<CreateOrder, OrderCreated>(</p>
<p>        new CreateOrder(/<em> ... </em>/)</p>
<p>    );</p>
<p>}</p>
<p>// Result: ~18ns per dispatch (3.5M operations/second)</p>
<p></code></pre></p>

<h3>Zero Allocations</h3>

<p>Generated routing uses <strong>object pooling</strong> to avoid allocations:</p>

<pre><code class="language-csharp">// Generated code (simplified)
<p>protected override ReceptorInvoker<TResult>? GetReceptorInvoker<TResult>(</p>
<p>    object message,</p>
<p>    Type messageType) {</p>

<p>    // Cached delegate (zero allocations after first call)</p>
<p>    if (messageType == typeof(CreateOrder)) {</p>
<p>        return _cachedOrderReceptorInvoker ??= CreateInvoker();</p>
<p>    }</p>

<p>    return null;</p>
<p>}</p>
<p></code></pre></p>

<strong>Benchmark</strong>:
<pre><code class="language-">Memory Diagnostics:
<p>  Gen 0: 0</p>
<p>  Gen 1: 0</p>
<p>  Gen 2: 0</p>
<p>  Allocated: 0 bytes</p>
<p></code></pre></p>

<hr>

<h2>Generator Internals</h2>

<h3>Value Type Records for Caching</h3>

<pre><code class="language-csharp">internal sealed record ReceptorInfo(
<p>    string ClassName,</p>
<p>    string MessageType,</p>
<p>    string ResponseType</p>
<p>);</p>
<p></code></pre></p>

<strong>Why sealed record?</strong>
<ul><li><strong>Value equality</strong>: Incremental caching relies on structural comparison</li>
<li><strong>Immutable</strong>: No risk of cache invalidation from mutation</li>
<li><strong>Performance</strong>: Compiler optimizes sealed types</li>
</ul>
<strong>Comparison</strong>:
<pre><code class="language-csharp">// With record (value equality)
<p>var cached = new ReceptorInfo("OrderReceptor", "CreateOrder", "OrderCreated");</p>
<p>var current = new ReceptorInfo("OrderReceptor", "CreateOrder", "OrderCreated");</p>
<p>cached == current;  // ✅ true (fields match, generator skips re-generation)</p>

<p>// With class (reference equality)</p>
<p>var cached = new ReceptorInfo { ClassName = "OrderReceptor", ... };</p>
<p>var current = new ReceptorInfo { ClassName = "OrderReceptor", ... };</p>
<p>cached == current;  // ❌ false (different references, generator always re-runs)</p>
<p></code></pre></p>

<strong>Impact</strong>: Record caching saves 50-200ms per incremental build.

<h3>Template-Based Generation</h3>

<p>Generator uses <strong>real C# templates</strong> with IDE support:</p>

<pre><code class="language-csharp">// Templates/DispatcherTemplate.cs
<p>namespace Whizbang.Core.Generated;</p>

<p>public class GeneratedDispatcher : Dispatcher {</p>
<p>    protected override ReceptorInvoker<TResult>? GetReceptorInvoker<TResult>(</p>
<p>        object message,</p>
<p>        Type messageType) {</p>

<p>        #region SEND_ROUTING</p>
<p>        // Generator replaces this region with routing code</p>
<p>        #endregion</p>

<p>        return null;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>Full IntelliSense and syntax highlighting</li>
<li>Compile-time validation via placeholder types</li>
<li>Easy to update and maintain</li>
<li>No string concatenation nightmares</li>
</ul>
<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Implement IReceptor<TMessage, TResponse></strong> for all message handlers</li>
<li>✅ <strong>Use descriptive receptor names</strong> (e.g., <code>CreateOrderReceptor</code>, not <code>Receptor1</code>)</li>
<li>✅ <strong>Keep receptors small</strong> (single responsibility)</li>
<li>✅ <strong>Use dependency injection</strong> for services</li>
<li>✅ <strong>Return events</strong> from commands (enables perspectives)</li>
<li>✅ <strong>Call AddWhizbangDispatchers()</strong> in Program.cs</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Manually register receptors (generator handles this)</li>
<li>❌ Use reflection to discover receptors (defeats AOT compatibility)</li>
<li>❌ Create receptors in other assemblies without referencing Whizbang.Generators</li>
<li>❌ Modify generated files (will be overwritten)</li>
<li>❌ Skip CancellationToken parameter (required for graceful shutdown)</li>
</ul>
<hr>

<h2>Troubleshooting</h2>

<h3>Problem: Generator Doesn't Run</h3>

<strong>Symptoms</strong>: No generated files in <code>obj/</code> directory.

<strong>Causes</strong>:
<ul><li>Whizbang.Generators not referenced</li>
<li>Generator disabled in project file</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-xml"><ItemGroup>
<p>  <PackageReference Include="Whizbang.Generators" OutputItemType="Analyzer" /></p>
<p></ItemGroup></p>
<p></code></pre></p>

<h3>Problem: No Receptors Found (WHIZ002)</h3>

<strong>Symptoms</strong>: <code>warning WHIZ002: No IReceptor implementations were found</code>

<strong>Causes</strong>:
<ul><li>Receptors not implementing correct interface</li>
<li>Namespace import missing</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-csharp">using Whizbang.Core;  // Required!

<p>public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>    // Implementation...</p>
<p>}</p>
<p></code></pre></p>

<h3>Problem: Type Not Found in Generated Code</h3>

<strong>Symptoms</strong>: Compilation error in generated <code>Dispatcher.g.cs</code>.

<strong>Causes</strong>:
<ul><li>Message type not public</li>
<li>Message type in different assembly not referenced</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-csharp">// ✅ Public message types
<p>public record CreateOrder(Guid CustomerId, OrderItem[] Items);</p>

<p>// ❌ Internal message types</p>
<p>internal record CreateOrder(Guid CustomerId, OrderItem[] Items);</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Source Generators</strong>:
<ul><li><a href="perspective-discovery.md">Perspective Discovery</a> - Discovering IPerspectiveOf implementations</li>
<li><a href="message-registry.md">Message Registry</a> - VSCode extension integration</li>
<li><a href="aggregate-ids.md">Aggregate IDs</a> - UUIDv7 generation for identity value objects</li>
<li><a href="json-contexts.md">JSON Contexts</a> - AOT-compatible JSON serialization</li>
</ul>
<strong>Core Concepts</strong>:
<ul><li><a href="../core-concepts/receptors.md">Receptors</a> - Message handler pattern</li>
<li><a href="../core-concepts/dispatcher.md">Dispatcher</a> - Message routing patterns</li>
</ul>
<strong>Advanced</strong>:
<ul><li><a href="../advanced/local-invoke.md">Performance: Local Invoke</a> - Sub-20ns dispatch</li>
<li><a href="../advanced/receptor-testing.md">Testing: Receptor Testing</a> - Unit testing receptors</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-source-generators-topic-filter-discovery" class="doc-section">
  <h3>Topic Filter Discovery</h3>
  <p class="doc-path"><code>v1.0.0/source-generators/topic-filter-discovery</code></p>
  <p class="doc-description"><em>Compile-time topic filter discovery with Roslyn source generators - type-safe, zero-reflection message routing configuration</em></p>
  <div class="doc-content">

<h1>Topic Filter Discovery</h1>

<p>The <strong>TopicFilterGenerator</strong> discovers all <code>ICommand</code> implementations decorated with <code>[TopicFilter]</code> attributes at compile-time and generates an AOT-compatible topic filter registry. This enables zero-reflection routing configuration with support for both string literals and strongly-typed enums.</p>

<h2>Zero Reflection Philosophy</h2>

<p>Traditional message routing frameworks configure topics at runtime using <strong>reflection</strong> or <strong>configuration files</strong>:</p>

<pre><code class="language-csharp">// ❌ Reflection-based (incompatible with AOT, error-prone)
<p>var topicAttr = command.GetType()</p>
<p>    .GetCustomAttribute<TopicFilterAttribute>();</p>
<p>var topic = topicAttr?.Filter;  // Runtime reflection</p>

<p>// ❌ Configuration-based (disconnected from code, no type safety)</p>
<p>// appsettings.json</p>
<p>{</p>
<p>  "CommandTopics": {</p>
<p>    "CreateOrderCommand": "orders.created"  // Typos not caught at compile time</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<p>Whizbang uses <strong>Roslyn source generators</strong> for compile-time topic extraction:</p>

<pre><code class="language-csharp">// ✅ Zero reflection (AOT-compatible, compile-time validation)
<p>var topics = TopicFilterRegistry.GetTopicFilters<CreateOrderCommand>();</p>
<p>// Returns: ["orders.created"]</p>
<p>// Generated at compile-time!</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ <strong>AOT Compatible</strong>: No runtime reflection or attribute scanning</li>
<li>✅ <strong>Type Safe</strong>: Enum-based topics with compile-time validation</li>
<li>✅ <strong>Fast Lookup</strong>: Direct type checks (~5ns overhead)</li>
<li>✅ <strong>Centralized</strong>: All topic mappings in one generated registry</li>
<li>✅ <strong>Description Support</strong>: Extracts <code>[Description]</code> attributes from enums</li>
</ul>
<hr>

<h2>How It Works</h2>

<h3>1. Compile-Time Discovery</h3>

<pre><code class="language-">┌──────────────────────────────────────────────────┐
<p>│  Your Code                                       │</p>
<p>│                                                  │</p>
<p>│  [TopicFilter("orders.created")]                │</p>
<p>│  public record CreateOrderCommand : ICommand {  │</p>
<p>│    // ...                                        │</p>
<p>│  }                                               │</p>
<p>└─────────────────┬────────────────────────────────┘</p>
<p>                  │</p>
<p>                  ▼</p>
<p>┌──────────────────────────────────────────────────┐</p>
<p>│  TopicFilterGenerator (Roslyn)                  │</p>
<p>│                                                  │</p>
<p>│  1. Scan syntax tree for classes/records        │</p>
<p>│  2. Filter types with attributes                │</p>
<p>│  3. Check for ICommand implementation           │</p>
<p>│  4. Extract TopicFilter attribute values        │</p>
<p>│  5. Extract enum Description attributes         │</p>
<p>└─────────────────┬────────────────────────────────┘</p>
<p>                  │</p>
<p>                  ▼</p>
<p>┌──────────────────────────────────────────────────┐</p>
<p>│  Generated Code                                  │</p>
<p>│                                                  │</p>
<p>│  TopicFilterRegistry.g.cs                       │</p>
<p>│  └─ GetTopicFilters<TCommand>()                 │</p>
<p>│  └─ GetAllFilters()                             │</p>
<p>└──────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<h3>2. String-Based Filter Extraction</h3>

<pre><code class="language-csharp">// Input: Attribute on command
<p>[TopicFilter("orders.created")]</p>
<p>public record CreateOrderCommand : ICommand { }</p>

<p>// Generator extracts string literal directly</p>
<p>// Output: Registry entry</p>
<p>if (typeof(TCommand) == typeof(global::MyApp.Commands.CreateOrderCommand)) {</p>
<p>  return new[] { "orders.created" };</p>
<p>}</p>
<p></code></pre></p>

<h3>3. Enum-Based Filter Extraction</h3>

<pre><code class="language-csharp">// Input: Enum with Description attribute
<p>public enum ServiceBusTopics {</p>
<p>  [Description("orders.created")]</p>
<p>  OrdersCreated</p>
<p>}</p>

<p>[TopicFilter<ServiceBusTopics>(ServiceBusTopics.OrdersCreated)]</p>
<p>public record CreateOrderCommand : ICommand { }</p>

<p>// Generator:</p>
<p>// 1. Gets enum value (ServiceBusTopics.OrdersCreated)</p>
<p>// 2. Finds enum field by ConstantValue</p>
<p>// 3. Extracts [Description] attribute ("orders.created")</p>
<p>// 4. Falls back to symbol name if no Description ("OrdersCreated")</p>

<p>// Output: Registry entry</p>
<p>if (typeof(TCommand) == typeof(global::MyApp.Commands.CreateOrderCommand)) {</p>
<p>  return new[] { "orders.created" };  // From Description attribute</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Generated File</h2>

<strong>TopicFilterRegistry.g.cs</strong>:

<pre><code class="language-csharp">// <auto-generated/>
<p>// Generated by TopicFilterGenerator at 2024-12-14 15:00:00 UTC</p>
<p>// DO NOT EDIT - Changes will be overwritten</p>
<p>#nullable enable</p>

<p>namespace MyApp.Generated;</p>

<p>using System;</p>
<p>using System.Collections.Generic;</p>
<p>using Whizbang.Core;</p>

<p>/// <summary></p>
<p>/// Auto-generated registry for topic filter lookups.</p>
<p>/// Generated from 3 topic filter(s) across 2 command(s).</p>
<p>/// </summary></p>
<p>public static class TopicFilterRegistry {</p>
<p>  /// <summary></p>
<p>  /// Gets all topic filters for the specified command type.</p>
<p>  /// Returns empty array if command has no topic filters.</p>
<p>  /// </summary></p>
<p>  /// <typeparam name="TCommand">The command type to look up</typeparam></p>
<p>  /// <returns>Array of topic filter strings</returns></p>
<p>  public static string[] GetTopicFilters<TCommand>() where TCommand : ICommand {</p>
<p>    if (typeof(TCommand) == typeof(global::MyApp.Commands.CreateOrderCommand)) {</p>
<p>      return new[] { "orders.created", "analytics.orders" };</p>
<p>    }</p>
<p>    if (typeof(TCommand) == typeof(global::MyApp.Commands.ProcessPaymentCommand)) {</p>
<p>      return new[] { "payments.processed" };</p>
<p>    }</p>
<p>    return Array.Empty<string>();</p>
<p>  }</p>

<p>  /// <summary></p>
<p>  /// Gets all topic filters for all commands (for diagnostics and tooling).</p>
<p>  /// </summary></p>
<p>  /// <returns>Dictionary mapping command names to their topic filters</returns></p>
<p>  public static IReadOnlyDictionary<string, string[]> GetAllFilters() {</p>
<p>    return new Dictionary<string, string[]> {</p>
<p>      { "CreateOrderCommand", new[] { "orders.created", "analytics.orders" } },</p>
<p>      { "ProcessPaymentCommand", new[] { "payments.processed" } }</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Using Generated Registry</h2>

<h3>Basic Lookup</h3>

<pre><code class="language-csharp">using MyApp.Generated;

<p>// Get topic filters for a specific command</p>
<p>var topics = TopicFilterRegistry.GetTopicFilters<CreateOrderCommand>();</p>
<p>// Returns: ["orders.created", "analytics.orders"]</p>

<p>// Use in routing logic</p>
<p>foreach (var topic in topics) {</p>
<p>  await _transport.PublishAsync(command, new TransportDestination {</p>
<p>    Topic = topic,</p>
<p>    // ... other routing metadata</p>
<p>  });</p>
<p>}</p>
<p></code></pre></p>

<h3>Startup Validation</h3>

<pre><code class="language-csharp">// Validate all topics exist in message broker at startup
<p>public static void ValidateTopics(IServiceProvider services) {</p>
<p>  var allFilters = TopicFilterRegistry.GetAllFilters();</p>
<p>  var transport = services.GetRequiredService<ITransport>();</p>

<p>  foreach (var (command, topics) in allFilters) {</p>
<p>    foreach (var topic in topics) {</p>
<p>      if (!transport.TopicExists(topic)) {</p>
<p>        throw new InvalidOperationException(</p>
<p>          $"Command '{command}' references non-existent topic '{topic}'"</p>
<p>        );</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Diagnostics and Tooling</h3>

<pre><code class="language-csharp">// List all command → topic mappings
<p>var allFilters = TopicFilterRegistry.GetAllFilters();</p>

<p>foreach (var (command, topics) in allFilters) {</p>
<p>  Console.WriteLine($"{command}:");</p>
<p>  foreach (var topic in topics) {</p>
<p>    Console.WriteLine($"  → {topic}");</p>
<p>  }</p>
<p>}</p>

<p>// Output:</p>
<p>// CreateOrderCommand:</p>
<p>//   → orders.created</p>
<p>//   → analytics.orders</p>
<p>// ProcessPaymentCommand:</p>
<p>//   → payments.processed</p>
<p></code></pre></p>

<hr>

<h2>Generator Internals</h2>

<h3>Value Type Record for Caching</h3>

<pre><code class="language-csharp">internal sealed record TopicFilterInfo(
<p>  string CommandType,</p>
<p>  string Filter</p>
<p>);</p>
<p></code></pre></p>

<strong>Why sealed record?</strong>
<ul><li><strong>Value equality</strong>: Incremental caching relies on structural comparison</li>
<li><strong>Immutable</strong>: No risk of cache invalidation from mutation</li>
<li><strong>Performance</strong>: Compiler optimizes sealed types</li>
</ul>
<strong>Impact</strong>: Record caching saves 50-200ms per incremental build.

<h3>Syntactic Filtering</h3>

<p>Generator uses <strong>syntactic predicates</strong> to filter 95%+ of nodes before expensive semantic analysis:</p>

<pre><code class="language-csharp">// Fast syntactic check (no semantic model access)
<p>predicate: static (node, _) =></p>
<p>  (node is ClassDeclarationSyntax or RecordDeclarationSyntax) &&</p>
<p>  ((TypeDeclarationSyntax)node).AttributeLists.Count > 0,</p>

<p>// Only runs on types with attributes (~5% of nodes)</p>
<p>transform: static (ctx, ct) => ExtractTopicFilters(ctx, ct)</p>
<p></code></pre></p>

<strong>Performance</strong>:
<ul><li>Without predicate: ~10,000ms on 10,000 types (analyzes everything)</li>
<li>With predicate: ~50-100ms on 10,000 types (analyzes only attributed types)</li>
</ul>
<strong>100x faster</strong> with proper filtering!

<h3>Attribute Inheritance Detection</h3>

<p>Generator recognizes derived attributes:</p>

<pre><code class="language-csharp">// Check if attribute is TopicFilterAttribute or derived from it
<p>var currentClass = attr.AttributeClass;</p>
<p>while (currentClass is not null) {</p>
<p>  var fullName = currentClass.ToDisplayString();</p>
<p>  if (fullName == TOPIC_FILTER_ATTRIBUTE ||</p>
<p>      fullName.StartsWith(TOPIC_FILTER_ATTRIBUTE + "<")) {</p>
<p>    return true;  // Recognize both base and generic versions</p>
<p>  }</p>
<p>  currentClass = currentClass.BaseType;</p>
<p>}</p>
<p></code></pre></p>

<strong>Supports</strong>:
<ul><li><code>TopicFilterAttribute</code> (base, string parameter)</li>
<li><code>TopicFilterAttribute<TEnum></code> (generic, enum parameter)</li>
<li>Any derived custom attributes</li>
</ul>
<h3>Enum Description Extraction</h3>

<pre><code class="language-csharp">// Get enum value from attribute constructor argument
<p>var enumValue = firstArg.Value;  // Numeric value (0, 1, 2...)</p>

<p>// Find enum field by matching ConstantValue (not symbol name!)</p>
<p>var enumField = enumType.GetMembers()</p>
<p>  .OfType<IFieldSymbol>()</p>
<p>  .FirstOrDefault(f => f.HasConstantValue && Equals(f.ConstantValue, enumValue));</p>

<p>// Extract Description attribute</p>
<p>var descriptionAttr = enumField.GetAttributes()</p>
<p>  .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DESCRIPTION_ATTRIBUTE);</p>

<p>if (descriptionAttr is not null && descriptionAttr.ConstructorArguments.Length > 0) {</p>
<p>  return descriptionAttr.ConstructorArguments[0].Value?.ToString();  // "orders.created"</p>
<p>}</p>

<p>// Fallback to enum symbol name</p>
<p>return enumField.Name;  // "OrdersCreated"</p>
<p></code></pre></p>

<strong>Key Insight</strong>: Match enum fields by <code>ConstantValue</code>, not by name, since <code>ToString()</code> on numeric values returns "0", "1", etc.

<hr>

<h2>Generator Performance</h2>

<h3>Incremental Compilation</h3>

<p>Roslyn incremental generators use <strong>value-based caching</strong> to skip work when inputs haven't changed:</p>

<pre><code class="language-">First compilation:
<p>├─ Scan syntax tree: 30ms</p>
<p>├─ Extract topic filters: 15ms</p>
<p>├─ Generate registry: 5ms</p>
<p>└─ Total: 50ms</p>

<p>Subsequent compilation (no changes):</p>
<p>├─ Check cache: 1ms (inputs unchanged)</p>
<p>├─ Skip generation: 0ms</p>
<p>└─ Total: 1ms (49ms saved!)</p>

<p>Compilation after topic filter change:</p>
<p>├─ Check cache: 1ms (CreateOrder filter changed)</p>
<p>├─ Scan syntax tree: 30ms</p>
<p>├─ Extract topic filters: 15ms</p>
<p>├─ Generate registry: 5ms</p>
<p>└─ Total: 51ms (only re-runs affected pipeline)</p>
<p></code></pre></p>

<h3>Lookup Performance</h3>

<p>| Method | Overhead | Notes |</p>
<p>|--------|----------|-------|</p>
<p>| <strong>GetTopicFilters<T>()</strong> | ~5ns | Direct type check |</p>
<p>| <strong>GetAllFilters()</strong> | ~10ns | Dictionary access |</p>

<strong>Benchmark</strong>:
<pre><code class="language-csharp">[Benchmark]
<p>public string[] GetTopicFilters_CreateOrder() {</p>
<p>  return TopicFilterRegistry.GetTopicFilters<CreateOrderCommand>();</p>
<p>}</p>
<p>// Result: ~5ns per lookup (200M operations/second)</p>
<p></code></pre></p>

<hr>

<h2>Debugging Generated Code</h2>

<h3>View Generated Files</h3>

<p>Generated file is written to:</p>
<pre><code class="language-">obj/Debug/net10.0/generated/Whizbang.Generators/TopicFilterGenerator/
<p>└── TopicFilterRegistry.g.cs</p>
<p></code></pre></p>

<p>Or optionally configured output folder:</p>
<pre><code class="language-xml"><PropertyGroup>
<p>  <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles></p>
<p>  <CompilerGeneratedFilesOutputPath>.whizbang-generated</CompilerGeneratedFilesOutputPath></p>
<p></PropertyGroup></p>
<p></code></pre></p>

<h3>Build Diagnostics</h3>

<p>Generator reports discoveries during build:</p>

<pre><code class="language-">Build started...
<p>info WHIZ022: Found topic filter 'orders.created' on command 'CreateOrderCommand'</p>
<p>info WHIZ022: Found topic filter 'analytics.orders' on command 'CreateOrderCommand'</p>
<p>info WHIZ022: Found topic filter 'payments.processed' on command 'ProcessPaymentCommand'</p>
<p>Build succeeded.</p>
<p>    3 topic filters discovered across 2 commands</p>
<p></code></pre></p>

<hr>

<h2>Diagnostics</h2>

<h3>WHIZ022: Topic Filter Discovered</h3>

<strong>Severity</strong>: Info

<strong>Message</strong>: <code>Found topic filter '{1}' on command '{0}'</code>

<strong>Example</strong>:
<pre><code class="language-">info WHIZ022: Found topic filter 'orders.created' on command 'CreateOrderCommand'
<p></code></pre></p>

<strong>When</strong>: Reported for each discovered topic filter during compilation.

<hr>

<h3>WHIZ023: Enum Filter No Description</h3>

<strong>Severity</strong>: Info

<strong>Message</strong>: <code>Enum value '{0}.{1}' has no [Description] attribute. Using enum symbol name '{1}' as filter.</code>

<strong>Example</strong>:
<pre><code class="language-">info WHIZ023: Enum value 'Topics.OrdersCreated' has no [Description] attribute. Using enum symbol name 'OrdersCreated' as filter.
<p></code></pre></p>

<strong>When</strong>: An enum-based topic filter lacks a <code>[Description]</code> attribute. The enum symbol name is used as fallback.

<strong>Fix</strong> (if Description is desired):
<pre><code class="language-csharp">public enum Topics {
<p>  [Description("orders.created")]  // Add this!</p>
<p>  OrdersCreated</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h3>WHIZ025: TopicFilter On Non-Command</h3>

<strong>Severity</strong>: Warning

<strong>Message</strong>: <code>[TopicFilter] on type '{0}' which does not implement ICommand. Filter will be ignored.</code>

<strong>Example</strong>:
<pre><code class="language-">warning WHIZ025: [TopicFilter] on type 'MyClass' which does not implement ICommand. Filter will be ignored.
<p></code></pre></p>

<strong>When</strong>: <code>[TopicFilter]</code> is placed on a type that doesn't implement <code>ICommand</code>.

<strong>Fix</strong>:
<pre><code class="language-csharp">// ✅ CORRECT: Implement ICommand
<p>[TopicFilter("orders.created")]</p>
<p>public record CreateOrderCommand : ICommand { }</p>

<p>// ❌ WRONG: Missing ICommand</p>
<p>[TopicFilter("orders.created")]</p>
<p>public record MyClass { }  // No ICommand!</p>
<p></code></pre></p>

<hr>

<h3>WHIZ026: No Topic Filters Found</h3>

<strong>Severity</strong>: Info

<strong>Message</strong>: <code>No [TopicFilter] attributes were found in the compilation. TopicFilterRegistry will not be generated.</code>

<strong>Example</strong>:
<pre><code class="language-">info WHIZ026: No [TopicFilter] attributes were found in the compilation. TopicFilterRegistry will not be generated.
<p></code></pre></p>

<strong>When</strong>: No commands with <code>[TopicFilter]</code> attributes are found in the assembly. This is informational only.

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Use enums for centralized topic definitions</strong></li>
<li>✅ <strong>Add [Description] attributes to enum values</strong> for production topic names</li>
<li>✅ <strong>Group topics by domain or transport</strong> (OrderTopics, PaymentTopics, etc.)</li>
<li>✅ <strong>Validate topics at startup</strong> against message broker</li>
<li>✅ <strong>Use multiple filters for legitimate fan-out</strong> scenarios</li>
<li>✅ <strong>Create custom derived attributes</strong> for transport-specific configuration</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Use string literals for repeated topics (centralize via enums)</li>
<li>❌ Place <code>[TopicFilter]</code> on non-<code>ICommand</code> types</li>
<li>❌ Create flat enums with 100+ topics (group by domain)</li>
<li>❌ Skip Description attributes on production enums</li>
<li>❌ Modify generated TopicFilterRegistry.g.cs (will be overwritten)</li>
<li>❌ Forget to validate topics exist in message broker at startup</li>
</ul>
<hr>

<h2>Troubleshooting</h2>

<h3>Problem: Generator Doesn't Run</h3>

<strong>Symptoms</strong>: No <code>TopicFilterRegistry.g.cs</code> in <code>obj/</code> directory.

<strong>Causes</strong>:
<ul><li>Whizbang.Generators not referenced</li>
<li>Generator disabled in project file</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-xml"><ItemGroup>
<p>  <PackageReference Include="Whizbang.Generators" OutputItemType="Analyzer" /></p>
<p></ItemGroup></p>
<p></code></pre></p>

<hr>

<h3>Problem: No Topic Filters Found (WHIZ026)</h3>

<strong>Symptoms</strong>: <code>info WHIZ026: No [TopicFilter] attributes were found</code>

<strong>Causes</strong>:
<ul><li>Forgot to add <code>[TopicFilter]</code> attributes to commands</li>
<li>Namespace import missing</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-csharp">using Whizbang.Core;  // Required!

<p>[TopicFilter("orders.created")]</p>
<p>public record CreateOrderCommand : ICommand {</p>
<p>  // Implementation...</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h3>Problem: Enum Symbol Name Instead of Description</h3>

<strong>Symptoms</strong>: <code>GetTopicFilters<T>()</code> returns "OrdersCreated" instead of "orders.created"

<strong>Causes</strong>: Forgot to add <code>[Description]</code> attribute to enum value.

<strong>Solution</strong>:
<pre><code class="language-csharp">using System.ComponentModel;  // Required for [Description]

<p>public enum Topics {</p>
<p>  [Description("orders.created")]  // Add this!</p>
<p>  OrdersCreated</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h3>Problem: TopicFilter Attribute Not Found</h3>

<strong>Symptoms</strong>: Compilation error: <code>'TopicFilterAttribute' could not be found</code>

<strong>Causes</strong>: Missing <code>using Whizbang.Core;</code> directive.

<strong>Solution</strong>:
<pre><code class="language-csharp">using Whizbang.Core;  // Required!

<p>[TopicFilter("orders.created")]</p>
<p>public record CreateOrderCommand : ICommand { }</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Source Generators</strong>:
<ul><li><a href="receptor-discovery.md">Receptor Discovery</a> - Discovering IReceptor implementations</li>
<li><a href="perspective-discovery.md">Perspective Discovery</a> - Discovering IPerspectiveOf implementations</li>
<li><a href="message-registry.md">Message Registry</a> - VSCode extension integration</li>
<li><a href="json-contexts.md">JSON Contexts</a> - AOT-compatible JSON serialization</li>
</ul>
<strong>Messaging</strong>:
<ul><li><a href="../messaging/topic-filters.md">Topic Filters</a> - User guide for topic filters</li>
<li><a href="../messaging/commands-events.md">Commands and Events</a> - Core message types</li>
<li><a href="../infrastructure/transports.md">Transports</a> - Message transport abstraction</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-14</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Testing</h2>
<article id="v1-0-0-testing-lifecycle-synchronization" class="doc-section">
  <h3>Lifecycle Synchronization</h3>
  <p class="doc-path"><code>v1.0.0/testing/lifecycle-synchronization</code></p>
  <p class="doc-description"><em>Deterministic test synchronization using lifecycle receptors - eliminate race conditions in integration tests with PostPerspectiveInline stage</em></p>
  <div class="doc-content">

<h1>Lifecycle Synchronization</h1>

<p>Integration tests must wait for <strong>asynchronous perspective processing</strong> to complete before asserting on perspective data. <strong>Polling-based approaches have race conditions</strong>. Lifecycle synchronization provides <strong>deterministic completion detection</strong> using the <code>PostPerspectiveInline</code> lifecycle stage.</p>

<h2>The Race Condition Problem</h2>

<h3>Why Polling Fails</h3>

<p>Traditional polling approach checks if database queues are empty:</p>

<pre><code class="language-csharp">// ❌ RACE CONDITION!
<p>public async Task WaitForEventProcessingAsync() {</p>
<p>  for (var i = 0; i < 100; i++) {</p>
<p>    var hasPendingWork = await _dbContext.WorkItems.AnyAsync();</p>
<p>    if (!hasPendingWork) {</p>
<p>      return;  // Queue empty = done?</p>
<p>    }</p>
<p>    await Task.Delay(100);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>The Problem</strong>:
<pre><code class="language-mermaid">sequenceDiagram
<p>    participant Test</p>
<p>    participant Queue as Work Queue</p>
<p>    participant Bus as Service Bus</p>
<p>    participant Perspective</p>

<p>    Test->>Queue: Dispatch command</p>
<p>    Queue-->>Test: Command saved</p>
<p>    Queue->>Bus: Publish to transport</p>
<p>    Note right of Queue: Queue is now EMPTY</p>

<p>    Test->>Queue: Check queue (polling)</p>
<p>    Queue-->>Test: Empty! ✓</p>
<p>    Note right of Test: Test proceeds...</p>

<p>    Bus->>Perspective: Message in-flight...</p>
<p>    Note right of Test: ❌ Assertion FAILS!</p>
<p>    Perspective->>Perspective: Apply event</p>
<p>    Note right of Perspective: Too late!</p>
<p></code></pre></p>

<strong>The queue is empty while message is in-flight through Service Bus!</strong>

<h3>Test Failures</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task CreateProduct_UpdatesProductCatalog_FailsRandomlyAsync() {</p>
<p>  // Arrange</p>
<p>  var command = new CreateProductCommand("Widget", 9.99m);</p>

<p>  // Act</p>
<p>  await _dispatcher.SendAsync(command);</p>
<p>  await WaitForEventProcessingAsync();  // ❌ Returns too early!</p>

<p>  // Assert</p>
<p>  var product = await _productLens.GetByIdAsync(command.ProductId);</p>
<p>  Assert.That(product).IsNotNull();  // ❌ FAILS randomly!</p>
<p>}</p>
<p></code></pre></p>

<strong>Failure Rate</strong>: 20-40% depending on system load and Service Bus latency.

<hr>

<h2>The Solution: <code>PostPerspectiveInline</code></h2>

<h3>Lifecycle Stage Guarantee</h3>

<p>The <strong><code>PostPerspectiveInline</code> lifecycle stage</strong> fires:</p>
<ul><li>✅ <strong>After</strong> perspective <code>RunAsync()</code> completes</li>
<li>✅ <strong>After</strong> database writes are committed</li>
<li>✅ <strong>Before</strong> checkpoint is reported to coordinator</li>
<li>✅ <strong>Blocks</strong> checkpoint reporting until receptors complete</li>
</ul>
<strong>Timing Diagram</strong>:
<pre><code class="language-mermaid">sequenceDiagram
<p>    participant Test</p>
<p>    participant Dispatcher</p>
<p>    participant Bus as Service Bus</p>
<p>    participant Worker as Perspective Worker</p>
<p>    participant Perspective</p>
<p>    participant Receptor as Lifecycle Receptor</p>
<p>    participant Test2 as Test (Resumed)</p>

<p>    Test->>Dispatcher: SendAsync(command)</p>
<p>    Dispatcher->>Bus: Publish event</p>
<p>    Test->>Test: await completionSource.Task ⏸️</p>

<p>    Bus->>Worker: Receive message</p>
<p>    Worker->>Perspective: RunAsync()</p>
<p>    Perspective->>Perspective: Apply events</p>
<p>    Perspective->>Perspective: SaveChangesAsync() ✓</p>

<p>    Note right of Worker: PostPerspectiveInline fires here</p>
<p>    Worker->>Receptor: HandleAsync(event)</p>
<p>    Receptor->>Test2: completionSource.SetResult(true)</p>

<p>    Test2->>Test2: Task completes!</p>
<p>    Test2->>Test2: Assert perspective data ✓</p>
<p></code></pre></p>

<strong>Key Guarantee</strong>: When <code>PostPerspectiveInline</code> fires, <strong>database writes are committed</strong> - safe to query!

<hr>

<h2>Basic Test Pattern</h2>

<h3>Step 1: Create Completion Receptor</h3>

<pre><code class="language-csharp">using Whizbang.Core;
<p>using Whizbang.Core.Messaging;</p>

<p>[FireAt(LifecycleStage.PostPerspectiveInline)]</p>
<p>public sealed class PerspectiveCompletionReceptor<TEvent> : IReceptor<TEvent></p>
<p>  where TEvent : IEvent {</p>

<p>  private readonly TaskCompletionSource<bool> _completionSource;</p>
<p>  private readonly string? _perspectiveName;</p>
<p>  private readonly ILifecycleContext? _context;</p>

<p>  public PerspectiveCompletionReceptor(</p>
<p>      TaskCompletionSource<bool> completionSource,</p>
<p>      string? perspectiveName = null,</p>
<p>      ILifecycleContext? context = null) {</p>

<p>    _completionSource = completionSource;</p>
<p>    _perspectiveName = perspectiveName;</p>
<p>    _context = context;</p>
<p>  }</p>

<p>  public ValueTask HandleAsync(TEvent message, CancellationToken ct) {</p>
<p>    // Filter by perspective if specified</p>
<p>    if (_context is not null && _perspectiveName is not null) {</p>
<p>      if (_context.PerspectiveName != _perspectiveName) {</p>
<p>        return ValueTask.CompletedTask;  // Not our perspective</p>
<p>      }</p>
<p>    }</p>

<p>    // Signal test to proceed</p>
<p>    _completionSource.TrySetResult(true);</p>
<p>    return ValueTask.CompletedTask;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Step 2: Register at Runtime</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task CreateProduct_UpdatesProductCatalog_DeterministicallyAsync() {</p>
<p>  // Arrange</p>
<p>  var completionSource = new TaskCompletionSource<bool>();</p>
<p>  var receptor = new PerspectiveCompletionReceptor<ProductCreatedEvent>(</p>
<p>    completionSource,</p>
<p>    perspectiveName: "ProductCatalog"  // Optional: filter by perspective</p>
<p>  );</p>

<p>  var registry = _host.Services.GetRequiredService<ILifecycleReceptorRegistry>();</p>
<p>  registry.Register<ProductCreatedEvent>(receptor, LifecycleStage.PostPerspectiveInline);</p>

<p>  try {</p>
<p>    var command = new CreateProductCommand("Widget", 9.99m);</p>

<p>    // Act</p>
<p>    await _dispatcher.SendAsync(command);</p>

<p>    // Wait for perspective processing to complete (deterministic!)</p>
<p>    await completionSource.Task.WaitAsync(TimeSpan.FromSeconds(15));</p>

<p>    // Assert - perspective data is guaranteed to be saved</p>
<p>    var product = await _productLens.GetByIdAsync(command.ProductId);</p>
<p>    Assert.That(product).IsNotNull();</p>
<p>    Assert.That(product!.Name).IsEqualTo("Widget");</p>
<p>    Assert.That(product.Price).IsEqualTo(9.99m);</p>

<p>  } finally {</p>
<p>    // Always unregister</p>
<p>    registry.Unregister<ProductCreatedEvent>(receptor, LifecycleStage.PostPerspectiveInline);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Success Rate</strong>: 100% - no more race conditions!

<hr>

<h2>Helper Method Pattern</h2>

<h3>Extension Method</h3>

<p>Create a reusable helper method in your test fixtures:</p>

<pre><code class="language-csharp">// File: tests/ECommerce.Integration.Tests/Fixtures/LifecycleReceptorTestExtensions.cs
<p>using Microsoft.Extensions.DependencyInjection;</p>
<p>using Microsoft.Extensions.Hosting;</p>
<p>using Whizbang.Core;</p>
<p>using Whizbang.Core.Messaging;</p>

<p>public static class LifecycleReceptorTestExtensions {</p>

<p>  /// <summary></p>
<p>  /// Waits for perspective processing to complete for a specific event type.</p>
<p>  /// Uses PostPerspectiveInline lifecycle stage for deterministic synchronization.</p>
<p>  /// </summary></p>
<p>  public static async Task WaitForPerspectiveCompletionAsync<TEvent>(</p>
<p>      this IHost host,</p>
<p>      string? perspectiveName = null,</p>
<p>      int timeoutMilliseconds = 15000)</p>
<p>      where TEvent : IEvent {</p>

<p>    ArgumentNullException.ThrowIfNull(host);</p>

<p>    var completionSource = new TaskCompletionSource<bool>();</p>
<p>    var receptor = new PerspectiveCompletionReceptor<TEvent>(completionSource, perspectiveName);</p>
<p>    var registry = host.Services.GetRequiredService<ILifecycleReceptorRegistry>();</p>

<p>    registry.Register<TEvent>(receptor, LifecycleStage.PostPerspectiveInline);</p>

<p>    try {</p>
<p>      await completionSource.Task.WaitAsync(TimeSpan.FromMilliseconds(timeoutMilliseconds));</p>
<p>    } finally {</p>
<p>      registry.Unregister<TEvent>(receptor, LifecycleStage.PostPerspectiveInline);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Simplified Test Usage</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task CreateProduct_UpdatesProductCatalog_SimpleAsync() {</p>
<p>  // Arrange</p>
<p>  var command = new CreateProductCommand("Widget", 9.99m);</p>

<p>  // Act</p>
<p>  await _dispatcher.SendAsync(command);</p>

<p>  // Wait for perspective completion (one line!)</p>
<p>  await _host.WaitForPerspectiveCompletionAsync<ProductCreatedEvent>(</p>
<p>    perspectiveName: "ProductCatalog",</p>
<p>    timeoutMilliseconds: 15000</p>
<p>  );</p>

<p>  // Assert</p>
<p>  var product = await _productLens.GetByIdAsync(command.ProductId);</p>
<p>  Assert.That(product).IsNotNull();</p>
<p>  Assert.That(product!.Name).IsEqualTo("Widget");</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ One-line synchronization</li>
<li>✅ Automatic registration/cleanup</li>
<li>✅ Consistent timeout handling</li>
<li>✅ Reusable across all tests</li>
</ul>
<hr>

<h2>Advanced Patterns</h2>

<h3>Pattern 1: Multiple Event Types</h3>

<p>Wait for multiple different events (e.g., command triggers multiple perspectives):</p>

<pre><code class="language-csharp">public static async Task WaitForMultiplePerspectiveCompletionsAsync(
<p>    this IHost host,</p>
<p>    Type[] eventTypes,</p>
<p>    string? perspectiveName = null,</p>
<p>    int timeoutMilliseconds = 15000) {</p>

<p>  ArgumentNullException.ThrowIfNull(host);</p>
<p>  ArgumentNullException.ThrowIfNull(eventTypes);</p>

<p>  if (eventTypes.Length == 0) {</p>
<p>    return;</p>
<p>  }</p>

<p>  var completionSources = eventTypes.Select(_ => new TaskCompletionSource<bool>()).ToArray();</p>
<p>  var receptors = new List<object>();</p>
<p>  var registry = host.Services.GetRequiredService<ILifecycleReceptorRegistry>();</p>

<p>  try {</p>
<p>    // Register receptors for each event type</p>
<p>    for (var i = 0; i < eventTypes.Length; i++) {</p>
<p>      var eventType = eventTypes[i];</p>
<p>      var completionSource = completionSources[i];</p>

<p>      // Create receptor using reflection (dynamic event type)</p>
<p>      var receptorType = typeof(PerspectiveCompletionReceptor<>).MakeGenericType(eventType);</p>
<p>      var receptor = Activator.CreateInstance(receptorType, completionSource, perspectiveName, null)</p>
<p>        ?? throw new InvalidOperationException($"Failed to create receptor for {eventType.Name}");</p>

<p>      receptors.Add(receptor);</p>

<p>      // Register using reflection</p>
<p>      var registerMethod = typeof(ILifecycleReceptorRegistry)</p>
<p>        .GetMethod(nameof(ILifecycleReceptorRegistry.Register))!</p>
<p>        .MakeGenericMethod(eventType);</p>
<p>      registerMethod.Invoke(registry, new[] { receptor, LifecycleStage.PostPerspectiveInline });</p>
<p>    }</p>

<p>    // Wait for ALL completions</p>
<p>    await Task.WhenAll(completionSources.Select(cs => cs.Task))</p>
<p>      .WaitAsync(TimeSpan.FromMilliseconds(timeoutMilliseconds));</p>

<p>  } finally {</p>
<p>    // Unregister all receptors</p>
<p>    for (var i = 0; i < eventTypes.Length; i++) {</p>
<p>      var eventType = eventTypes[i];</p>
<p>      var receptor = receptors[i];</p>

<p>      var unregisterMethod = typeof(ILifecycleReceptorRegistry)</p>
<p>        .GetMethod(nameof(ILifecycleReceptorRegistry.Unregister))!</p>
<p>        .MakeGenericMethod(eventType);</p>
<p>      unregisterMethod.Invoke(registry, new[] { receptor, LifecycleStage.PostPerspectiveInline });</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:
<pre><code class="language-csharp">[Test]
<p>public async Task UpdateInventory_UpdatesMultiplePerspectives_DeterministicallyAsync() {</p>
<p>  // Arrange</p>
<p>  var command = new UpdateInventoryCommand(productId: _productId, quantity: 100);</p>

<p>  // Act</p>
<p>  await _dispatcher.SendAsync(command);</p>

<p>  // Wait for BOTH events to be processed</p>
<p>  await _host.WaitForMultiplePerspectiveCompletionsAsync(</p>
<p>    new[] { typeof(InventoryUpdatedEvent), typeof(ProductModifiedEvent) },</p>
<p>    timeoutMilliseconds: 20000</p>
<p>  );</p>

<p>  // Assert - both perspectives updated</p>
<p>  var inventory = await _inventoryLens.GetByProductIdAsync(_productId);</p>
<p>  var product = await _productLens.GetByIdAsync(_productId);</p>

<p>  Assert.That(inventory!.Quantity).IsEqualTo(100);</p>
<p>  Assert.That(product!.LastModified).IsNotNull();</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern 2: Perspective-Specific Filtering</h3>

<p>Wait for a specific perspective to complete (useful when multiple perspectives process same event):</p>

<pre><code class="language-csharp">[Test]
<p>public async Task CreateProduct_UpdatesOnlyProductCatalog_NotInventoryAsync() {</p>
<p>  // Arrange</p>
<p>  var command = new CreateProductCommand("Widget", 9.99m);</p>

<p>  // Act</p>
<p>  await _dispatcher.SendAsync(command);</p>

<p>  // Wait for ProductCatalog perspective specifically</p>
<p>  await _host.WaitForPerspectiveCompletionAsync<ProductCreatedEvent>(</p>
<p>    perspectiveName: "ProductCatalog"  // Only this perspective</p>
<p>  );</p>

<p>  // Assert - ProductCatalog updated</p>
<p>  var product = await _productLens.GetByIdAsync(command.ProductId);</p>
<p>  Assert.That(product).IsNotNull();</p>

<p>  // But Inventory perspective NOT updated yet (different event)</p>
<p>  var inventory = await _inventoryLens.GetByProductIdAsync(command.ProductId);</p>
<p>  Assert.That(inventory).IsNull();  // Expected!</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern 3: Timeout Handling</h3>

<p>Handle timeouts gracefully with diagnostic information:</p>

<pre><code class="language-csharp">[Test]
<p>public async Task SlowPerspective_TimesOut_WithDiagnosticsAsync() {</p>
<p>  // Arrange</p>
<p>  var command = new CreateProductCommand("Widget", 9.99m);</p>

<p>  // Act & Assert</p>
<p>  await _dispatcher.SendAsync(command);</p>

<p>  try {</p>
<p>    await _host.WaitForPerspectiveCompletionAsync<ProductCreatedEvent>(</p>
<p>      timeoutMilliseconds: 1000  // Short timeout for demonstration</p>
<p>    );</p>

<p>    Assert.Fail("Expected TimeoutException");</p>

<p>  } catch (TimeoutException ex) {</p>
<p>    // Gather diagnostics</p>
<p>    var pendingWork = await _dbContext.WorkItems.CountAsync();</p>
<p>    var lastCheckpoint = await _dbContext.PerspectiveCheckpoints</p>
<p>      .Where(p => p.PerspectiveName == "ProductCatalog")</p>
<p>      .FirstOrDefaultAsync();</p>

<p>    Assert.Fail(</p>
<p>      $"Perspective processing timed out. " +</p>
<p>      $"Pending work items: {pendingWork}, " +</p>
<p>      $"Last checkpoint: {lastCheckpoint?.LastProcessedEventId}");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern 4: Any-Of-Multiple Events</h3>

<p>Wait for <strong>any one</strong> of multiple events (first to complete):</p>

<pre><code class="language-csharp">[Test]
<p>public async Task Command_TriggersOneOfSeveralEvents_FlexiblyAsync() {</p>
<p>  // Arrange</p>
<p>  var command = new ProcessOrderCommand(orderId: _orderId);</p>

<p>  // Create completion sources for each possible event</p>
<p>  var orderCompletedSource = new TaskCompletionSource<bool>();</p>
<p>  var orderFailedSource = new TaskCompletionSource<bool>();</p>

<p>  var registry = _host.Services.GetRequiredService<ILifecycleReceptorRegistry>();</p>

<p>  var completedReceptor = new PerspectiveCompletionReceptor<OrderCompletedEvent>(orderCompletedSource);</p>
<p>  var failedReceptor = new PerspectiveCompletionReceptor<OrderFailedEvent>(orderFailedSource);</p>

<p>  registry.Register<OrderCompletedEvent>(completedReceptor, LifecycleStage.PostPerspectiveInline);</p>
<p>  registry.Register<OrderFailedEvent>(failedReceptor, LifecycleStage.PostPerspectiveInline);</p>

<p>  try {</p>
<p>    // Act</p>
<p>    await _dispatcher.SendAsync(command);</p>

<p>    // Wait for EITHER event (first to complete)</p>
<p>    var completedTask = await Task.WhenAny(</p>
<p>      orderCompletedSource.Task,</p>
<p>      orderFailedSource.Task</p>
<p>    ).WaitAsync(TimeSpan.FromSeconds(15));</p>

<p>    // Assert based on which event fired</p>
<p>    if (completedTask == orderCompletedSource.Task) {</p>
<p>      var order = await _orderLens.GetByIdAsync(_orderId);</p>
<p>      Assert.That(order!.Status).IsEqualTo(OrderStatus.Completed);</p>
<p>    } else {</p>
<p>      var order = await _orderLens.GetByIdAsync(_orderId);</p>
<p>      Assert.That(order!.Status).IsEqualTo(OrderStatus.Failed);</p>
<p>    }</p>

<p>  } finally {</p>
<p>    registry.Unregister<OrderCompletedEvent>(completedReceptor, LifecycleStage.PostPerspectiveInline);</p>
<p>    registry.Unregister<OrderFailedEvent>(failedReceptor, LifecycleStage.PostPerspectiveInline);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Integration Test Fixture Pattern</h2>

<h3>Base Fixture Setup</h3>

<pre><code class="language-csharp">public class ServiceBusIntegrationFixture : IAsyncDisposable {
<p>  protected IHost _inventoryHost = null!;</p>
<p>  protected IHost _bffHost = null!;</p>
<p>  protected IDispatcher _dispatcher = null!;</p>

<p>  [Before(Test)]</p>
<p>  public async Task SetupAsync() {</p>
<p>    // Start hosts</p>
<p>    _inventoryHost = await InventoryHostBuilder.BuildAsync();</p>
<p>    _bffHost = await BffHostBuilder.BuildAsync();</p>

<p>    await _inventoryHost.StartAsync();</p>
<p>    await _bffHost.StartAsync();</p>

<p>    _dispatcher = _bffHost.Services.GetRequiredService<IDispatcher>();</p>
<p>  }</p>

<p>  [After(Test)]</p>
<p>  public async Task CleanupAsync() {</p>
<p>    await _inventoryHost.StopAsync();</p>
<p>    await _bffHost.StopAsync();</p>
<p>    await DisposeAsync();</p>
<p>  }</p>

<p>  // Helper method available to all tests</p>
<p>  protected Task WaitForPerspectiveAsync<TEvent>(</p>
<p>      string? perspectiveName = null,</p>
<p>      int timeoutMs = 15000)</p>
<p>      where TEvent : IEvent {</p>

<p>    return _inventoryHost.WaitForPerspectiveCompletionAsync<TEvent>(</p>
<p>      perspectiveName,</p>
<p>      timeoutMs</p>
<p>    );</p>
<p>  }</p>

<p>  public async ValueTask DisposeAsync() {</p>
<p>    if (_inventoryHost is not null) await _inventoryHost.DisposeAsync();</p>
<p>    if (_bffHost is not null) await _bffHost.DisposeAsync();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Test Class Usage</h3>

<pre><code class="language-csharp">public class CreateProductWorkflowTests : ServiceBusIntegrationFixture {

<p>  [Test]</p>
<p>  public async Task CreateProduct_FlowsFromBffToInventory_DeterministicallyAsync() {</p>
<p>    // Arrange</p>
<p>    var command = new CreateProductCommand("Widget", 9.99m);</p>

<p>    // Act</p>
<p>    await _dispatcher.SendAsync(command);</p>

<p>    // Wait for perspective (uses helper from base fixture)</p>
<p>    await WaitForPerspectiveAsync<ProductCreatedEvent>(</p>
<p>      perspectiveName: "ProductCatalog"</p>
<p>    );</p>

<p>    // Assert</p>
<p>    var inventoryDbContext = _inventoryHost.Services</p>
<p>      .GetRequiredService<InventoryDbContext>();</p>

<p>    var product = await inventoryDbContext.Products</p>
<p>      .FirstOrDefaultAsync(p => p.Id == command.ProductId);</p>

<p>    Assert.That(product).IsNotNull();</p>
<p>    Assert.That(product!.Name).IsEqualTo("Widget");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Troubleshooting</h2>

<h3>Problem: TimeoutException</h3>

<strong>Symptoms</strong>: Test times out waiting for perspective completion.

<strong>Possible Causes</strong>:
<ul><li><strong>Perspective not running</strong> - Check that perspective worker is started</li>
<li><strong>Different event type</strong> - Verify you're waiting for correct event</li>
<li><strong>Perspective name mismatch</strong> - Check perspective name filter</li>
<li><strong>Message routing issue</strong> - Event not reaching perspective</li>
</ul>
<strong>Debugging</strong>:
<pre><code class="language-csharp">// Check pending work items
<p>var pendingWork = await _dbContext.WorkItems.ToListAsync();</p>
<p>Console.WriteLine($"Pending work: {pendingWork.Count}");</p>

<p>// Check perspective checkpoints</p>
<p>var checkpoint = await _dbContext.PerspectiveCheckpoints</p>
<p>  .FirstOrDefaultAsync(p => p.PerspectiveName == "ProductCatalog");</p>
<p>Console.WriteLine($"Last checkpoint: {checkpoint?.LastProcessedEventId}");</p>

<p>// Check if event was published</p>
<p>var events = await _dbContext.Events</p>
<p>  .Where(e => e.EventType == "ProductCreatedEvent")</p>
<p>  .ToListAsync();</p>
<p>Console.WriteLine($"ProductCreatedEvent count: {events.Count}");</p>
<p></code></pre></p>

<h3>Problem: Test Passes But Assertions Fail</h3>

<strong>Symptoms</strong>: WaitForPerspectiveCompletionAsync returns, but data not in database.

<strong>Possible Causes</strong>:
<ul><li><strong>Wrong perspective</strong> - Waiting for perspective that doesn't update target data</li>
<li><strong>Multiple perspectives</strong> - Need to wait for multiple perspectives</li>
<li><strong>Async stage instead of Inline</strong> - Use <code>PostPerspectiveInline</code>, not <code>PostPerspectiveAsync</code></li>
</ul>
<strong>Fix</strong>:
<pre><code class="language-csharp">// ❌ WRONG: PostPerspectiveAsync (non-blocking, no guarantee)
<p>[FireAt(LifecycleStage.PostPerspectiveAsync)]</p>
<p>public class CompletionReceptor : IReceptor<ProductCreatedEvent> { }</p>

<p>// ✅ CORRECT: PostPerspectiveInline (blocking, guarantees persistence)</p>
<p>[FireAt(LifecycleStage.PostPerspectiveInline)]</p>
<p>public class CompletionReceptor : IReceptor<ProductCreatedEvent> { }</p>
<p></code></pre></p>

<h3>Problem: Receptor Not Firing</h3>

<strong>Symptoms</strong>: WaitForPerspectiveCompletionAsync times out, receptor never called.

<strong>Possible Causes</strong>:
<ul><li><strong>Not registered</strong> - Forgot to call <code>registry.Register()</code></li>
<li><strong>Wrong event type</strong> - Generic type mismatch</li>
<li><strong>Wrong stage</strong> - Using different stage than <code>PostPerspectiveInline</code></li>
<li><strong>Perspective name filter excludes event</strong> - Check filter logic</li>
</ul>
<strong>Debugging</strong>:
<pre><code class="language-csharp">// Add logging to receptor
<p>public ValueTask HandleAsync(ProductCreatedEvent evt, CancellationToken ct) {</p>
<p>  Console.WriteLine($"RECEPTOR FIRED: {evt.GetType().Name}");</p>
<p>  Console.WriteLine($"Perspective: {_context?.PerspectiveName}");</p>
<p>  Console.WriteLine($"Stream: {_context?.StreamId}");</p>

<p>  _completionSource.TrySetResult(true);</p>
<p>  return ValueTask.CompletedTask;</p>
<p>}</p>
<p></code></pre></p>

<h3>Problem: Registry Not Found</h3>

<strong>Symptoms</strong>: <code>GetRequiredService<ILifecycleReceptorRegistry>()</code> throws exception.

<strong>Fix</strong>: Register in DI container:
<pre><code class="language-csharp">// In Startup.cs or Program.cs
<p>services</p>
<p>  .AddWhizbang()  // Automatically registers ILifecycleReceptorRegistry</p>
<p>  .WithEFCore<MyDbContext>()</p>
<p>  .WithDriver.Postgres;</p>
<p></code></pre></p>

<hr>

<h2>Performance Considerations</h2>

<h3>Lifecycle Receptor Overhead</h3>

<strong>Inline receptors add < 1ms per event</strong>:
<ul><li>Registration: One-time cost (< 0.1ms)</li>
<li>Invocation: Pattern matching + delegate call (< 0.5ms)</li>
<li>Completion signal: <code>TaskCompletionSource.SetResult()</code> (< 0.1ms)</li>
</ul>
<strong>For tests with 1000+ events</strong>:
<ul><li>Traditional polling: 100ms * 100 iterations = ~10 seconds</li>
<li>Lifecycle sync: 1ms * 1000 events = ~1 second</li>
</ul>
<strong>Lifecycle synchronization is 10x faster than polling!</strong>

<h3>Timeout Recommendations</h3>

<pre><code class="language-csharp">// Local development (fast)
<p>timeoutMilliseconds: 5000   // 5 seconds</p>

<p>// CI/CD pipeline (slower)</p>
<p>timeoutMilliseconds: 15000  // 15 seconds</p>

<p>// Slow integration tests (Azure Service Bus)</p>
<p>timeoutMilliseconds: 30000  // 30 seconds</p>
<p></code></pre></p>

<hr>

<h2>Migration Guide</h2>

<h3>Before: Polling-Based Tests</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task OldTest_UsesPollingSyncAsync() {</p>
<p>  // Arrange</p>
<p>  var command = new CreateProductCommand("Widget", 9.99m);</p>

<p>  // Act</p>
<p>  await _dispatcher.SendAsync(command);</p>

<p>  // ❌ OLD: Polling (race condition!)</p>
<p>  await WaitForEventProcessingAsync();</p>

<p>  // Assert</p>
<p>  var product = await _productLens.GetByIdAsync(command.ProductId);</p>
<p>  Assert.That(product).IsNotNull();</p>
<p>}</p>

<p>private async Task WaitForEventProcessingAsync() {</p>
<p>  for (var i = 0; i < 100; i++) {</p>
<p>    var hasPendingWork = await _dbContext.WorkItems.AnyAsync();</p>
<p>    if (!hasPendingWork) return;</p>
<p>    await Task.Delay(100);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>After: Lifecycle Synchronization</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task NewTest_UsesLifecycleSyncAsync() {</p>
<p>  // Arrange</p>
<p>  var command = new CreateProductCommand("Widget", 9.99m);</p>

<p>  // Act</p>
<p>  await _dispatcher.SendAsync(command);</p>

<p>  // ✅ NEW: Deterministic lifecycle synchronization</p>
<p>  await _host.WaitForPerspectiveCompletionAsync<ProductCreatedEvent>(</p>
<p>    perspectiveName: "ProductCatalog"</p>
<p>  );</p>

<p>  // Assert</p>
<p>  var product = await _productLens.GetByIdAsync(command.ProductId);</p>
<p>  Assert.That(product).IsNotNull();</p>
<p>}</p>
<p></code></pre></p>

<strong>Migration Steps</strong>:
<ul><li>Add <code>PerspectiveCompletionReceptor<TEvent></code> to test project</li>
<li>Add <code>WaitForPerspectiveCompletionAsync<TEvent>()</code> extension method</li>
<li>Replace <code>WaitForEventProcessingAsync()</code> calls with lifecycle sync</li>
<li>Remove polling helper methods</li>
<li>Run tests 100 times to verify 100% reliability</li>
</ul>
<hr>

<h2>Related Topics</h2>

<ul><li><a href="../core-concepts/lifecycle-stages.md">Lifecycle Stages</a> - All 18 stages with timing guarantees</li>
<li><a href="../core-concepts/lifecycle-receptors.md">Lifecycle Receptors</a> - API reference for [FireAt] attribute</li>
<li><a href="integration-testing.md">Integration Testing</a> - Complete integration test patterns</li>
<li><a href="../workers/perspective-worker.md">PerspectiveWorker</a> - Perspective processing architecture</li>
</ul>
<hr>

<h2>Summary</h2>

<ul><li><strong>Problem</strong>: Polling has race conditions (in-flight messages not visible in queue)</li>
<li><strong>Solution</strong>: <code>PostPerspectiveInline</code> lifecycle stage guarantees persistence</li>
<li><strong>Pattern</strong>: Register <code>PerspectiveCompletionReceptor<TEvent></code> at runtime</li>
<li><strong>Helper</strong>: <code>WaitForPerspectiveCompletionAsync<TEvent>()</code> extension method</li>
<li><strong>Benefits</strong>: 100% test reliability, 10x faster than polling</li>
<li><strong>Advanced</strong>: Multiple events, perspective filtering, any-of patterns</li>
<li><strong>Migration</strong>: Replace polling with lifecycle sync in existing tests</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Transports</h2>
<article id="v1-0-0-transports-azure-service-bus" class="doc-section">
  <h3>Azure Service Bus Transport</h3>
  <p class="doc-path"><code>v1.0.0/transports/azure-service-bus</code></p>
  <p class="doc-description"><em>Reliable cross-service messaging with Azure Service Bus topics and subscriptions - AOT-compatible with correlation filters</em></p>
  <div class="doc-content">

<h1>Azure Service Bus Transport</h1>

<p>The <strong>Azure Service Bus transport</strong> provides reliable, ordered message delivery across services using Azure Service Bus topics and subscriptions. This enables pub/sub patterns with correlation-based routing for multi-tenant and distributed architectures.</p>

<h2>Why Azure Service Bus?</h2>

<strong>Azure Service Bus</strong> offers enterprise-grade messaging with:

<p>| Feature | Description | Benefit |</p>
<p>|---------|-------------|---------|</p>
<p>| <strong>Topics & Subscriptions</strong> | Publish once, multiple subscribers | True pub/sub pattern |</p>
<p>| <strong>Correlation Filters</strong> | Route messages by properties | Multi-tenant isolation |</p>
<p>| <strong>At-Least-Once Delivery</strong> | Guaranteed message delivery | Reliability |</p>
<p>| <strong>Message Ordering</strong> | FIFO within sessions | Consistency |</p>
<p>| <strong>Dead Letter Queue</strong> | Automatic failure handling | Observability |</p>
<p>| <strong>Lock Renewal</strong> | Automatic lock extension | Long-running handlers |</p>

<strong>Whizbang Integration</strong>:
<ul><li>✅ <strong>AOT-Compatible</strong> - Uses <code>JsonContextRegistry</code> for serialization</li>
<li>✅ <strong>Aspire Integration</strong> - First-class support for .NET Aspire orchestration</li>
<li>✅ <strong>Correlation Filters</strong> - Automatic routing based on message properties</li>
<li>✅ <strong>Emulator Support</strong> - Works with Aspire Service Bus emulator</li>
<li>✅ <strong>Observability</strong> - OpenTelemetry tracing for all operations</li>
</ul>
<hr>

<h2>Architecture</h2>

<h3>Topic/Subscription Pattern</h3>

<pre><code class="language-">┌────────────────────────────────────────────────────────┐
<p>│  Azure Service Bus Namespace                           │</p>
<p>│                                                         │</p>
<p>│  ┌────────────────────────────────────────────────┐   │</p>
<p>│  │  Topic: "whizbang.events"                      │   │</p>
<p>│  │                                                 │   │</p>
<p>│  │  ┌──────────────────────────────────────────┐ │   │</p>
<p>│  │  │  Subscription: "inventory-service"       │ │   │</p>
<p>│  │  │  Filter: Destination = "inventory"       │ │   │</p>
<p>│  │  │  → Inventory Service                     │ │   │</p>
<p>│  │  └──────────────────────────────────────────┘ │   │</p>
<p>│  │                                                 │   │</p>
<p>│  │  ┌──────────────────────────────────────────┐ │   │</p>
<p>│  │  │  Subscription: "notification-service"    │ │   │</p>
<p>│  │  │  Filter: Destination = "notifications"   │ │   │</p>
<p>│  │  │  → Notification Service                  │ │   │</p>
<p>│  │  └──────────────────────────────────────────┘ │   │</p>
<p>│  │                                                 │   │</p>
<p>│  │  ┌──────────────────────────────────────────┐ │   │</p>
<p>│  │  │  Subscription: "analytics-service"       │ │   │</p>
<p>│  │  │  Filter: Destination = "analytics"       │ │   │</p>
<p>│  │  │  → Analytics Service                     │ │   │</p>
<p>│  │  └──────────────────────────────────────────┘ │   │</p>
<p>│  └────────────────────────────────────────────────┘   │</p>
<p>└────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<h3>Message Flow</h3>

<pre><code class="language-">Publisher (Order Service)
<p>  │</p>
<p>  │ 1. PublishAsync(envelope, destination)</p>
<p>  │    Destination: "inventory"</p>
<p>  ▼</p>
<p>┌─────────────────────────────────────┐</p>
<p>│  AzureServiceBusTransport           │</p>
<p>│                                     │</p>
<p>│  - Serialize MessageEnvelope        │</p>
<p>│  - Set ApplicationProperties:       │</p>
<p>│    • MessageId                      │</p>
<p>│    • CorrelationId                  │</p>
<p>│    • CausationId                    │</p>
<p>│    • Destination = "inventory"      │</p>
<p>└─────────────────────────────────────┘</p>
<p>  │</p>
<p>  │ 2. SendMessageAsync()</p>
<p>  ▼</p>
<p>┌─────────────────────────────────────┐</p>
<p>│  Azure Service Bus Topic            │</p>
<p>│  "whizbang.events"                  │</p>
<p>└─────────────────────────────────────┘</p>
<p>  │</p>
<p>  │ 3. Correlation Filter</p>
<p>  │    WHERE Destination = "inventory"</p>
<p>  ▼</p>
<p>┌─────────────────────────────────────┐</p>
<p>│  Subscription: "inventory-service"  │</p>
<p>│  (Only messages with matching       │</p>
<p>│   Destination property)             │</p>
<p>└─────────────────────────────────────┘</p>
<p>  │</p>
<p>  │ 4. ProcessMessageAsync()</p>
<p>  ▼</p>
<p>┌─────────────────────────────────────┐</p>
<p>│  Inventory Service Subscriber       │</p>
<p>│                                     │</p>
<p>│  - Deserialize MessageEnvelope      │</p>
<p>│  - Extract metadata (IDs, hops)     │</p>
<p>│  - Invoke handler                   │</p>
<p>│  - Complete or Abandon message      │</p>
<p>└─────────────────────────────────────┘</p>
<p></code></pre></p>

<hr>

<h2>Configuration</h2>

<h3>1. Add NuGet Package</h3>

<pre><code class="language-bash">dotnet add package Whizbang.Transports.AzureServiceBus
<p></code></pre></p>

<h3>2. Register Transport (Standard .NET)</h3>

<pre><code class="language-csharp">using Whizbang.Transports.AzureServiceBus;

<p>var builder = WebApplication.CreateBuilder(args);</p>

<p>// Register Azure Service Bus transport</p>
<p>builder.Services.AddAzureServiceBusTransport(</p>
<p>  connectionString: "Endpoint=sb://...",</p>
<p>  configureOptions: options => {</p>
<p>    options.MaxConcurrentCalls = 20;              // Default: 10</p>
<p>    options.MaxAutoLockRenewalDuration = TimeSpan.FromMinutes(5);</p>
<p>    options.MaxDeliveryAttempts = 10;             // Default: 10</p>
<p>    options.DefaultSubscriptionName = "default";  // Default: "default"</p>
<p>  }</p>
<p>);</p>

<p>// Optional: Add health checks</p>
<p>builder.Services.AddAzureServiceBusHealthChecks();</p>

<p>var app = builder.Build();</p>
<p>app.Run();</p>
<p></code></pre></p>

<h3>3. Register Transport (.NET Aspire)</h3>

<strong>.NET Aspire App Host</strong> (<code>AppHost/Program.cs</code>):

<pre><code class="language-csharp">var builder = DistributedApplication.CreateBuilder(args);

<p>// Add Azure Service Bus resource (or emulator)</p>
<p>var serviceBus = builder.AddAzureServiceBus("messaging")</p>
<p>  .RunAsEmulator();  // Or .PublishAsAzureServiceBusNamespace() for production</p>

<p>// Add topic with subscriptions</p>
<p>var topic = serviceBus.AddTopic("whizbang-events");</p>

<p>// Inventory service subscription with correlation filter</p>
<p>var inventorySub = topic.AddSubscription("inventory-service")</p>
<p>  .WithDestinationFilter("inventory");  // Whizbang extension method</p>

<p>var notificationSub = topic.AddSubscription("notification-service")</p>
<p>  .WithDestinationFilter("notifications");</p>

<p>// Add service projects with references</p>
<p>var inventoryService = builder.AddProject<Projects.InventoryService>("inventory-service")</p>
<p>  .WithReference(serviceBus)</p>
<p>  .WithReference(inventorySub);  // Grants access to subscription</p>

<p>var notificationService = builder.AddProject<Projects.NotificationService>("notification-service")</p>
<p>  .WithReference(serviceBus)</p>
<p>  .WithReference(notificationSub);</p>
<p></code></pre></p>

<strong>Service Project</strong> (<code>InventoryService/Program.cs</code>):

<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);

<p>// Aspire adds Service Bus connection string via environment variables</p>
<p>builder.AddServiceDefaults();  // Includes Service Bus integration</p>

<p>// Register Azure Service Bus transport</p>
<p>// Connection string injected by Aspire</p>
<p>var connectionString = builder.Configuration.GetConnectionString("messaging")</p>
<p>  ?? throw new InvalidOperationException("Service Bus connection string not found");</p>

<p>builder.Services.AddAzureServiceBusTransport(connectionString);</p>

<p>var app = builder.Build();</p>
<p>app.Run();</p>
<p></code></pre></p>

<h3>Configuration Options</h3>

<p>| Property | Default | Description |</p>
<p>|----------|---------|-------------|</p>
<p>| <code>MaxConcurrentCalls</code> | 10 | Maximum concurrent message processing calls |</p>
<p>| <code>MaxAutoLockRenewalDuration</code> | 5 minutes | Maximum duration for automatic lock renewal |</p>
<p>| <code>MaxDeliveryAttempts</code> | 10 | Retry limit before dead-lettering |</p>
<p>| <code>DefaultSubscriptionName</code> | "default" | Fallback subscription name if not specified |</p>

<h3>Connection Retry Options {#connection-retry}</h3>

<p>The transport includes built-in connection retry with exponential backoff for handling transient connection failures:</p>

<p>| Property | Default | Description |</p>
<p>|----------|---------|-------------|</p>
<p>| <code>InitialRetryAttempts</code> | 5 | Initial retry attempts with warning logs |</p>
<p>| <code>InitialRetryDelay</code> | 1 second | Delay before first retry |</p>
<p>| <code>MaxRetryDelay</code> | 120 seconds | Maximum delay (caps exponential backoff) |</p>
<p>| <code>BackoffMultiplier</code> | 2.0 | Multiplier for exponential backoff |</p>
<p>| <code>RetryIndefinitely</code> | <code>true</code> | Continue retrying after initial attempts |</p>

<strong>Example Configuration</strong>:
<pre><code class="language-csharp">builder.Services.AddAzureServiceBusTransport(
<p>    connectionString: "Endpoint=sb://...",</p>
<p>    configureOptions: options => {</p>
<p>        // Connection retry settings</p>
<p>        options.InitialRetryAttempts = 10;              // More warnings for slow emulators</p>
<p>        options.InitialRetryDelay = TimeSpan.FromSeconds(2);</p>
<p>        options.MaxRetryDelay = TimeSpan.FromMinutes(2);</p>
<p>        options.BackoffMultiplier = 1.5;</p>
<p>        options.RetryIndefinitely = true;               // Keep trying until success</p>
<p>    }</p>
<p>);</p>
<p></code></pre></p>

<strong>Retry Behavior</strong> (with defaults):
<ul><li>Initial attempt → fails</li>
<li>Wait 1s → retry 1 (logged as warning)</li>
<li>Wait 2s → retry 2 (logged as warning)</li>
<li>Wait 4s → retry 3 (logged as warning)</li>
<li>Wait 8s → retry 4 (logged as warning)</li>
<li>Wait 16s → retry 5 (logged as warning)</li>
<li>Continue retrying indefinitely at intervals up to 120s (logged every 10 attempts)</li>
</ul>
<strong>Key Behaviors</strong>:
<ul><li><strong>Initial Phase</strong>: First 5 attempts log warnings for each failure</li>
<li><strong>Indefinite Phase</strong>: After initial attempts, continues retrying (logged less frequently)</li>
<li><strong>Capped Backoff</strong>: Delay never exceeds <code>MaxRetryDelay</code> (default 120s)</li>
<li><strong>Graceful Shutdown</strong>: Responds to cancellation token for clean shutdown</li>
</ul>
<strong>Use Cases</strong>:
<ul><li><strong>Emulator Startup</strong>: Azure Service Bus emulator may take 45-60 seconds to become ready</li>
<li><strong>Network Glitches</strong>: Temporary network issues during service startup</li>
<li><strong>Cold Start</strong>: Azure Service Bus may have cold start delays in serverless scenarios</li>
<li><strong>Infrastructure Outage</strong>: Service survives extended outages and reconnects automatically</li>
</ul>
<strong>Fail Fast</strong> (disable indefinite retry):
<pre><code class="language-csharp">options.RetryIndefinitely = false;  // Throws after InitialRetryAttempts
<p></code></pre></p>

<h3>Runtime Reconnection {#runtime-reconnection}</h3>

<p>Azure Service Bus SDK has built-in retry policies that handle transient failures during runtime. The SDK automatically:</p>

<ul><li><strong>Detects Transient Failures</strong>: Network issues, throttling, service unavailability</li>
<li><strong>Automatic Retries</strong>: Uses exponential backoff with configurable policies</li>
<li><strong>Connection Recovery</strong>: Re-establishes connections transparently</li>
</ul>
<strong>SDK Retry Policy</strong> (configured in ServiceBusClientOptions):
<p>The Azure SDK's built-in retry policy handles most runtime scenarios. Our connection retry is specifically for <strong>initial connection establishment</strong> when the service might not yet be available (e.g., emulator startup).</p>

<strong>No Manual Reconnection Needed</strong>: The Azure Service Bus SDK handles transient failures automatically. Your application code continues to work transparently after recovery

<h3>Domain Topic Auto-Provisioning {#domain-topic-provisioning}</h3>

<p>:::new</p>
<p>When a service declares domain ownership via <code>OwnDomains()</code>, Whizbang can automatically provision the corresponding topics at worker startup. This ensures the domain owner (publisher) creates infrastructure that subscribers will use.</p>
<p>:::</p>

<strong>Important</strong>: Topic provisioning requires a connection string with <strong>Manage</strong> permissions. In production environments, topics are often pre-provisioned via infrastructure-as-code, so this step is optional.

<strong>Enable Auto-Provisioning</strong>:
<pre><code class="language-csharp">// Requires separate call with Manage permissions
<p>services.AddAzureServiceBusTransport(connectionString);</p>
<p>services.AddAzureServiceBusProvisioner(adminConnectionString);</p>

<p>services.AddWhizbang()</p>
<p>    .WithRouting(routing => {</p>
<p>        routing.OwnDomains("myapp.users", "myapp.orders");</p>
<p>    })</p>
<p>    .AddTransportConsumer();</p>

<p>// At startup, these topics are automatically created:</p>
<p>// - myapp.users</p>
<p>// - myapp.orders</p>
<p></code></pre></p>

<strong>Provisioning Behavior</strong>:
<ul><li>Uses <code>ServiceBusAdministrationClient.CreateTopicIfNotExistsAsync()</code></li>
<li>Idempotent - safe to call from multiple service instances</li>
<li>Handles race conditions gracefully (ignores 409 Conflict)</li>
<li>Skips provisioning if <code>AddAzureServiceBusProvisioner</code> is not called</li>
</ul>
<strong>Why Separate Registration?</strong>

<p>The provisioner is registered separately from the transport because:</p>
<ul><li><strong>Different Permissions</strong>: Transport needs Send/Receive, provisioning needs Manage</li>
<li><strong>Production Patterns</strong>: Topics are typically pre-created via IaC (Terraform, Bicep, ARM)</li>
<li><strong>Security</strong>: Not all environments should have Manage permissions</li>
</ul>
<strong>Development vs Production</strong>:
<pre><code class="language-csharp">// Development: Auto-provision for convenience
<p>if (builder.Environment.IsDevelopment()) {</p>
<p>    services.AddAzureServiceBusProvisioner(connectionString);</p>
<p>}</p>

<p>// Production: Topics pre-provisioned via infrastructure-as-code</p>
<p>// No AddAzureServiceBusProvisioner call needed</p>
<p></code></pre></p>

<hr>

<h2>Usage Patterns</h2>

<h3>Publishing Messages</h3>

<pre><code class="language-csharp">using Whizbang.Core.Transports;

<p>public class OrderService {</p>
<p>  private readonly ITransport _transport;</p>

<p>  public OrderService(ITransport transport) {</p>
<p>    _transport = transport;</p>
<p>  }</p>

<p>  public async Task CreateOrderAsync(CreateOrder command) {</p>
<p>    // Process order...</p>
<p>    var @event = new OrderCreated(orderId, customerId, total, DateTimeOffset.UtcNow);</p>

<p>    // Create envelope</p>
<p>    var envelope = MessageEnvelope.Create(</p>
<p>      messageId: MessageId.New(),</p>
<p>      correlationId: CorrelationId.New(),</p>
<p>      causationId: null,</p>
<p>      payload: @event,</p>
<p>      currentHop: new MessageHop {</p>
<p>        StreamKey = orderId.ToString(),</p>
<p>        Timestamp = DateTimeOffset.UtcNow</p>
<p>      }</p>
<p>    );</p>

<p>    // Publish to multiple destinations</p>
<p>    var inventoryDest = new TransportDestination(</p>
<p>      Address: "whizbang-events",</p>
<p>      RoutingKey: "inventory-service",</p>
<p>      Metadata: new Dictionary<string, JsonElement> {</p>
<p>        ["Destination"] = JsonSerializer.SerializeToElement("inventory")</p>
<p>      }</p>
<p>    );</p>

<p>    var notificationDest = new TransportDestination(</p>
<p>      Address: "whizbang-events",</p>
<p>      RoutingKey: "notification-service",</p>
<p>      Metadata: new Dictionary<string, JsonElement> {</p>
<p>        ["Destination"] = JsonSerializer.SerializeToElement("notifications")</p>
<p>      }</p>
<p>    );</p>

<p>    await _transport.PublishAsync(envelope, inventoryDest);</p>
<p>    await _transport.PublishAsync(envelope, notificationDest);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Subscribing to Messages</h3>

<pre><code class="language-csharp">using Whizbang.Core.Transports;

<p>public class InventoryServiceWorker : BackgroundService {</p>
<p>  private readonly ITransport _transport;</p>
<p>  private readonly IDispatcher _dispatcher;</p>
<p>  private ISubscription? _subscription;</p>

<p>  public InventoryServiceWorker(ITransport transport, IDispatcher dispatcher) {</p>
<p>    _transport = transport;</p>
<p>    _dispatcher = dispatcher;</p>
<p>  }</p>

<p>  protected override async Task ExecuteAsync(CancellationToken stoppingToken) {</p>
<p>    // Initialize transport</p>
<p>    await _transport.InitializeAsync(stoppingToken);</p>

<p>    // Subscribe to messages</p>
<p>    var destination = new TransportDestination(</p>
<p>      Address: "whizbang-events",</p>
<p>      RoutingKey: "inventory-service",</p>
<p>      Metadata: new Dictionary<string, JsonElement> {</p>
<p>        ["DestinationFilter"] = JsonSerializer.SerializeToElement("inventory")</p>
<p>      }</p>
<p>    );</p>

<p>    _subscription = await _transport.SubscribeAsync(</p>
<p>      handler: async (envelope, ct) => {</p>
<p>        // Dispatch message to appropriate receptor</p>
<p>        await _dispatcher.LocalInvokeAsync(envelope.Payload, ct);</p>
<p>      },</p>
<p>      destination: destination,</p>
<p>      cancellationToken: stoppingToken</p>
<p>    );</p>

<p>    // Keep worker running</p>
<p>    await Task.Delay(Timeout.Infinite, stoppingToken);</p>
<p>  }</p>

<p>  public override async Task StopAsync(CancellationToken cancellationToken) {</p>
<p>    if (_subscription != null) {</p>
<p>      await _subscription.DisposeAsync();</p>
<p>    }</p>
<p>    await base.StopAsync(cancellationToken);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Correlation Filters (Production)</h3>

<strong>Without Aspire</strong> - Manual filter provisioning:

<pre><code class="language-csharp">// Destination metadata triggers automatic filter provisioning
<p>var destination = new TransportDestination(</p>
<p>  Address: "whizbang-events",</p>
<p>  RoutingKey: "inventory-service",</p>
<p>  Metadata: new Dictionary<string, JsonElement> {</p>
<p>    // DestinationFilter triggers ApplyCorrelationFilterAsync()</p>
<p>    ["DestinationFilter"] = JsonSerializer.SerializeToElement("inventory")</p>
<p>  }</p>
<p>);</p>

<p>// Transport automatically provisions CorrelationFilter:</p>
<p>// - Deletes $Default rule</p>
<p>// - Creates DestinationFilter rule with Destination = "inventory"</p>
<p>var subscription = await transport.SubscribeAsync(handler, destination);</p>
<p></code></pre></p>

<strong>With Aspire</strong> - Automatic filter provisioning:

<pre><code class="language-csharp">// Aspire handles filter provisioning in AppHost
<p>var subscription = topic.AddSubscription("inventory-service")</p>
<p>  .WithDestinationFilter("inventory");  // Provisioned by Aspire at startup</p>
<p></code></pre></p>

<hr>

<h2>Transport Capabilities</h2>

<p>The Azure Service Bus transport declares these capabilities:</p>

<pre><code class="language-csharp">TransportCapabilities.PublishSubscribe |   // ✅ Pub/sub via topics
<p>TransportCapabilities.Reliable |           // ✅ At-least-once delivery</p>
<p>TransportCapabilities.Ordered              // ✅ FIFO within sessions</p>
<p></code></pre></p>

<strong>Not Supported</strong>:
<ul><li>❌ <code>RequestResponse</code> - Use Inbox/Outbox with correlation IDs instead</li>
<li>❌ <code>ExactlyOnce</code> - Requires Inbox pattern for deduplication</li>
<li>❌ <code>Streaming</code> - Use pub/sub with multiple messages</li>
</ul>
<hr>

<h2>Serialization (AOT-Compatible)</h2>

<h3>JsonContextRegistry Integration</h3>

<p>Azure Service Bus transport uses <code>JsonContextRegistry</code> for AOT-compatible serialization:</p>

<pre><code class="language-csharp">// Publishing (serialize envelope)
<p>var envelopeType = envelope.GetType();</p>
<p>var typeInfo = _jsonOptions.GetTypeInfo(envelopeType)</p>
<p>  ?? throw new InvalidOperationException($"No JsonTypeInfo found for {envelopeType.Name}");</p>

<p>var json = JsonSerializer.Serialize(envelope, typeInfo);  // Zero reflection</p>

<p>// Message metadata stores envelope type</p>
<p>message.ApplicationProperties["EnvelopeType"] = envelopeType.AssemblyQualifiedName;</p>
<p></code></pre></p>

<strong>Subscribing (deserialize envelope)</strong>:

<pre><code class="language-csharp">// Get envelope type from metadata
<p>var envelopeTypeName = message.ApplicationProperties["EnvelopeType"] as string;</p>
<p>var envelopeType = Type.GetType(envelopeTypeName);</p>

<p>// Deserialize using JsonTypeInfo</p>
<p>var typeInfo = _jsonOptions.GetTypeInfo(envelopeType);</p>
<p>var envelope = JsonSerializer.Deserialize(json, typeInfo) as IMessageEnvelope;</p>
<p></code></pre></p>

<strong>Why AOT-compatible?</strong>
<ul><li><code>JsonContextRegistry</code> pre-generates <code>JsonTypeInfo</code> for all message types</li>
<li>No reflection at runtime - all serialization metadata compiled</li>
<li>Full Native AOT support</li>
</ul>
<hr>

<h2>Emulator Support</h2>

<h3>Aspire Service Bus Emulator</h3>

<p>Whizbang detects the emulator automatically:</p>

<pre><code class="language-csharp">// Detection logic
<p>_isEmulator = connectionString.Contains("localhost") ||</p>
<p>              connectionString.Contains("127.0.0.1");</p>
<p></code></pre></p>

<strong>Emulator Differences</strong>:

<p>| Feature | Production | Emulator |</p>
<p>|---------|-----------|----------|</p>
<p>| <strong>Admin API</strong> | ✅ Available (port 443) | ❌ Not supported |</p>
<p>| <strong>Connectivity Check</strong> | Via <code>GetNamespacePropertiesAsync()</code> | Skipped (client open check) |</p>
<p>| <strong>Filter Provisioning</strong> | Manual via Admin API | Aspire provisions at startup |</p>
<p>| <strong>Initialization</strong> | Full verification | Simplified verification |</p>

<strong>Example</strong>:

<pre><code class="language-csharp">// AppHost
<p>var serviceBus = builder.AddAzureServiceBus("messaging")</p>
<p>  .RunAsEmulator();  // Starts container with emulator</p>

<p>// Transport detects emulator and skips Admin API calls</p>
<p>var transport = new AzureServiceBusTransport(connectionString, jsonOptions);</p>
<p>await transport.InitializeAsync();  // Skips admin verification for emulator</p>
<p></code></pre></p>

<hr>

<h2>Retry and Error Handling</h2>

<h3>Automatic Retry with Abandon</h3>

<pre><code class="language-csharp">try {
<p>  // Invoke handler</p>
<p>  await handler(envelope, ct);</p>

<p>  // Complete on success</p>
<p>  await args.CompleteMessageAsync(message, ct);</p>
<p>} catch (Exception ex) {</p>
<p>  var deliveryCount = message.DeliveryCount;</p>

<p>  if (deliveryCount >= MaxDeliveryAttempts) {</p>
<p>    // Dead-letter after max attempts</p>
<p>    await args.DeadLetterMessageAsync(</p>
<p>      message,</p>
<p>      "MaxDeliveryAttemptsExceeded",</p>
<p>      ex.Message,</p>
<p>      ct</p>
<p>    );</p>
<p>  } else {</p>
<p>    // Abandon to retry (message returns to subscription)</p>
<p>    await args.AbandonMessageAsync(message, ct);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Retry Behavior</strong>:
<ul><li>Message abandoned → returns to subscription queue</li>
<li>Service Bus applies exponential backoff</li>
<li>After 10 attempts (default) → dead-lettered</li>
</ul>
<h3>Dead Letter Queue Monitoring</h3>

<pre><code class="language-csharp">// Monitor DLQ for failed messages
<p>var receiver = client.CreateReceiver(</p>
<p>  "whizbang-events",</p>
<p>  "inventory-service",</p>
<p>  new ServiceBusReceiverOptions {</p>
<p>    SubQueue = SubQueue.DeadLetter</p>
<p>  }</p>
<p>);</p>

<p>await foreach (var message in receiver.ReceiveMessagesAsync()) {</p>
<p>  // Analyze failure reason</p>
<p>  var reason = message.DeadLetterReason;</p>
<p>  var description = message.DeadLetterErrorDescription;</p>

<p>  // Log for investigation</p>
<p>  logger.LogError("DLQ: {Reason} - {Description}", reason, description);</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Lock Renewal</h2>

<h3>Automatic Lock Extension</h3>

<pre><code class="language-csharp">var processorOptions = new ServiceBusProcessorOptions {
<p>  MaxConcurrentCalls = 20,</p>
<p>  AutoCompleteMessages = false,  // Manual completion after handler succeeds</p>
<p>  MaxAutoLockRenewalDuration = TimeSpan.FromMinutes(5)  // Auto-renew lock for 5 min</p>
<p>};</p>
<p></code></pre></p>

<strong>How It Works</strong>:
<ul><li>Handler processes message (may take several minutes)</li>
<li>Service Bus client automatically renews lock every 30 seconds</li>
<li>Max renewal duration: 5 minutes (configurable)</li>
<li>If processing exceeds 5 min → lock expires → message abandoned</li>
</ul>
<strong>Best Practice</strong>: Set <code>MaxAutoLockRenewalDuration</code> to expected max processing time + buffer.

<hr>

<h2>Observability</h2>

<h3>OpenTelemetry Integration</h3>

<p>Azure Service Bus transport emits OpenTelemetry spans:</p>

<pre><code class="language-csharp">using var activity = WhizbangActivitySource.Transport.StartActivity("PublishAsync");

<p>activity?.SetTag("transport.type", "AzureServiceBus");</p>
<p>activity?.SetTag("transport.topic", topicName);</p>
<p>activity?.SetTag("transport.subscription", subscriptionName);</p>
<p>activity?.SetTag("transport.emulator", isEmulator);</p>
<p>activity?.SetTag("message.id", envelope.MessageId.Value);</p>
<p>activity?.SetTag("message.correlation_id", correlationId);</p>
<p></code></pre></p>

<strong>Trace Correlation</strong>:
<ul><li><code>MessageId</code> → Unique message identifier</li>
<li><code>CorrelationId</code> → Request correlation across services</li>
<li><code>CausationId</code> → Parent message that caused this message</li>
</ul>
<h3>Health Checks</h3>

<pre><code class="language-csharp">// Register health check
<p>builder.Services.AddAzureServiceBusHealthChecks();</p>

<p>// Health check endpoint</p>
<p>app.MapHealthChecks("/health");</p>
<p></code></pre></p>

<strong>Health Check Logic</strong>:
<pre><code class="language-csharp">public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken ct) {
<p>  if (!_transport.IsInitialized) {</p>
<p>    return HealthCheckResult.Unhealthy("Transport not initialized");</p>
<p>  }</p>

<p>  // Check if client is open</p>
<p>  if (_client.IsClosed) {</p>
<p>    return HealthCheckResult.Unhealthy("ServiceBusClient is closed");</p>
<p>  }</p>

<p>  return HealthCheckResult.Healthy("Azure Service Bus transport is healthy");</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Performance</h2>

<h3>Throughput Benchmarks</h3>

<p>| Metric | Value | Notes |</p>
<p>|--------|-------|-------|</p>
<p>| <strong>Publish Latency</strong> | ~10-50ms | Network + serialization |</p>
<p>| <strong>Subscribe Latency</strong> | ~20-100ms | Network + deserialization + handler |</p>
<p>| <strong>Max Throughput</strong> | ~10,000 msg/sec | Depends on namespace tier |</p>
<p>| <strong>Serialization</strong> | ~100ns | AOT-compiled JsonTypeInfo |</p>

<h3>Concurrency</h3>

<pre><code class="language-csharp">options.MaxConcurrentCalls = 20;  // Process 20 messages in parallel
<p></code></pre></p>

<strong>Guidelines</strong>:
<ul><li><strong>CPU-bound handlers</strong>: Set to CPU core count</li>
<li><strong>I/O-bound handlers</strong>: Set to 2-4x CPU core count</li>
<li><strong>High throughput</strong>: Increase to 50-100 (monitor memory)</li>
</ul>
<h3>Batching (Future)</h3>

<p>Service Bus supports batch sends (not yet implemented):</p>

<pre><code class="language-csharp">// TODO: Batch sending for higher throughput
<p>await sender.SendMessagesAsync(batch);  // Send multiple at once</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Use Correlation Filters</strong> for multi-tenant routing</li>
<li>✅ <strong>Set MaxAutoLockRenewalDuration</strong> to expected processing time + buffer</li>
<li>✅ <strong>Monitor Dead Letter Queue</strong> for failed messages</li>
<li>✅ <strong>Use Aspire for local development</strong> (emulator + automatic provisioning)</li>
<li>✅ <strong>Initialize transport during startup</strong> to fail fast if unreachable</li>
<li>✅ <strong>Complete messages manually</strong> after successful handling</li>
<li>✅ <strong>Use IDispatcher</strong> in subscription handlers for receptor routing</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Use for request/response patterns (not supported - use Inbox/Outbox)</li>
<li>❌ Forget to abandon messages on transient errors (breaks retry)</li>
<li>❌ Dead-letter messages on transient errors (use abandon instead)</li>
<li>❌ Hardcode connection strings (use configuration/Aspire)</li>
<li>❌ Skip emulator detection (breaks admin API calls)</li>
<li>❌ Set MaxConcurrentCalls too high (causes memory pressure)</li>
</ul>
<hr>

<h2>Troubleshooting</h2>

<h3>Problem: Messages Not Reaching Subscriber</h3>

<strong>Symptoms</strong>: Publisher succeeds, but subscriber never receives messages.

<strong>Causes</strong>:
<ul><li>Correlation filter misconfiguration</li>
<li>Subscription doesn't exist</li>
<li>Destination property mismatch</li>
</ul>
<strong>Solution</strong>:

<pre><code class="language-csharp">// Verify destination property matches filter
<p>var destination = new TransportDestination(</p>
<p>  Address: "whizbang-events",</p>
<p>  RoutingKey: "inventory-service",</p>
<p>  Metadata: new Dictionary<string, JsonElement> {</p>
<p>    ["Destination"] = JsonSerializer.SerializeToElement("inventory")  // Must match filter</p>
<p>  }</p>
<p>);</p>

<p>// Check filter in Azure Portal:</p>
<p>// Service Bus Namespace → Topics → whizbang-events → Subscriptions → inventory-service → Rules</p>
<p>// Expected: DestinationFilter with Destination = "inventory"</p>
<p></code></pre></p>

<h3>Problem: "No JsonTypeInfo found for envelope type"</h3>

<strong>Symptoms</strong>: Deserialization fails with missing <code>JsonTypeInfo</code> error.

<strong>Cause</strong>: Envelope type not registered in <code>JsonContextRegistry</code>.

<strong>Solution</strong>:

<pre><code class="language-csharp">// Ensure envelope type is registered
<p>// In library: MessageEnvelope<T> should auto-register via MessageJsonContextGenerator</p>

<p>// Verify registration</p>
<p>var jsonOptions = JsonContextRegistry.CreateCombinedOptions();</p>
<p>var typeInfo = jsonOptions.GetTypeInfo(typeof(MessageEnvelope<OrderCreated>));</p>
<p>if (typeInfo == null) {</p>
<p>  // Not registered - check generator output</p>
<p>}</p>
<p></code></pre></p>

<h3>Problem: Transport Initialization Fails</h3>

<strong>Symptoms</strong>: <code>InitializeAsync()</code> throws <code>InvalidOperationException</code>.

<strong>Causes</strong>:
<ul><li>Invalid connection string</li>
<li>Service Bus namespace unreachable</li>
<li>Admin client not available (production)</li>
</ul>
<strong>Solution</strong>:

<pre><code class="language-csharp">try {
<p>  await transport.InitializeAsync();</p>
<p>} catch (InvalidOperationException ex) {</p>
<p>  // Check connection string</p>
<p>  logger.LogError(ex, "Invalid connection string or Service Bus unreachable");</p>

<p>  // For emulator: Ensure Aspire AppHost is running</p>
<p>  // For production: Check network connectivity and connection string</p>
<p>}</p>
<p></code></pre></p>

<h3>Problem: Messages Dead-Lettered Immediately</h3>

<strong>Symptoms</strong>: All messages go to DLQ without processing.

<strong>Causes</strong>:
<ul><li>Handler throws exception</li>
<li>Missing envelope type metadata</li>
<li>Deserialization failure</li>
</ul>
<strong>Solution</strong>:

<pre><code class="language-csharp">// Check DLQ for failure reason
<p>var dlqReceiver = client.CreateReceiver(</p>
<p>  "whizbang-events",</p>
<p>  "inventory-service",</p>
<p>  new ServiceBusReceiverOptions { SubQueue = SubQueue.DeadLetter }</p>
<p>);</p>

<p>await foreach (var message in dlqReceiver.ReceiveMessagesAsync()) {</p>
<p>  logger.LogError(</p>
<p>    "DLQ: {Reason} - {Description}. MessageId={MessageId}",</p>
<p>    message.DeadLetterReason,</p>
<p>    message.DeadLetterErrorDescription,</p>
<p>    message.MessageId</p>
<p>  );</p>

<p>  // Common reasons:</p>
<p>  // - "MissingEnvelopeType" → Publisher didn't set ApplicationProperties["EnvelopeType"]</p>
<p>  // - "UnresolvableEnvelopeType" → Type not found (assembly not loaded)</p>
<p>  // - "DeserializationFailed" → JSON mismatch or missing JsonTypeInfo</p>
<p>  // - "MaxDeliveryAttemptsExceeded" → Handler keeps failing</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Transports</strong>:
<ul><li><a href="in-memory.md">In-Memory Transport</a> - Local testing and development</li>
</ul>
<strong>Messaging Patterns</strong>:
<ul><li><a href="../messaging/outbox-pattern.md">Outbox Pattern</a> - Reliable cross-service events</li>
<li><a href="../messaging/inbox-pattern.md">Inbox Pattern</a> - Exactly-once processing</li>
<li><a href="../messaging/work-coordination.md">Work Coordination</a> - Lease-based message processing</li>
</ul>
<strong>Source Generators</strong>:
<ul><li><a href="../source-generators/json-contexts.md">JSON Contexts</a> - AOT-compatible JSON serialization</li>
</ul>
<strong>Infrastructure</strong>:
<ul><li><a href="../infrastructure/aspire-integration.md">Aspire Integration</a> - .NET Aspire orchestration</li>
<li><a href="../infrastructure/health-checks.md">Health Checks</a> - Application health monitoring</li>
</ul>
<strong>Advanced</strong>:
<ul><li><a href="../extensibility/custom-transports.md">Custom Transports</a> - Implementing custom transports</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-transports-in-memory" class="doc-section">
  <h3>In-Memory Transport</h3>
  <p class="doc-path"><code>v1.0.0/transports/in-memory</code></p>
  <p class="doc-description"><em>Synchronous in-process message delivery for testing and single-process scenarios - zero external dependencies</em></p>
  <div class="doc-content">

<h1>In-Memory Transport</h1>

<p>The <strong>In-Memory transport</strong> provides synchronous, in-process message delivery without external dependencies. This transport is ideal for testing, development, and single-process applications where cross-process communication isn't needed.</p>

<h2>Why In-Memory Transport?</h2>

<strong>In-Memory</strong> offers simplicity and speed for local scenarios:

<p>| Feature | Description | Benefit |</p>
<p>|---------|-------------|---------|</p>
<p>| <strong>Zero Dependencies</strong> | No external infrastructure | Simple setup |</p>
<p>| <strong>Synchronous Delivery</strong> | Messages delivered immediately | Predictable testing |</p>
<p>| <strong>Thread-Safe</strong> | Concurrent publish/subscribe | Multi-threaded safety |</p>
<p>| <strong>Full Capabilities</strong> | Pub/sub + request/response | Complete feature set |</p>
<p>| <strong>Instant Initialization</strong> | No network checks | Fast startup |</p>
<p>| <strong>Subscription Lifecycle</strong> | Pause/resume/dispose | Fine-grained control |</p>

<strong>Use Cases</strong>:
<ul><li>✅ <strong>Unit Testing</strong> - Test receptors without external infrastructure</li>
<li>✅ <strong>Integration Testing</strong> - Test message flows in-process</li>
<li>✅ <strong>Single-Process Apps</strong> - Modular applications without distributed messaging</li>
<li>✅ <strong>Local Development</strong> - No need for Service Bus/RabbitMQ during development</li>
<li>✅ <strong>Prototyping</strong> - Quick experimentation with messaging patterns</li>
</ul>
<hr>

<h2>Architecture</h2>

<h3>Synchronous Delivery Model</h3>

<pre><code class="language-">┌─────────────────────────────────────────────────────────┐
<p>│  InProcessTransport                                     │</p>
<p>│                                                          │</p>
<p>│  ┌────────────────────────────────────────────────┐    │</p>
<p>│  │  Subscriptions Dictionary                      │    │</p>
<p>│  │                                                 │    │</p>
<p>│  │  "orders" → [Handler1, Handler2]               │    │</p>
<p>│  │  "payments" → [Handler3]                       │    │</p>
<p>│  │  "notifications" → [Handler4, Handler5]        │    │</p>
<p>│  └────────────────────────────────────────────────┘    │</p>
<p>└─────────────────────────────────────────────────────────┘</p>

<p>Publisher                                      Subscriber</p>
<p>  │                                                │</p>
<p>  │ 1. PublishAsync(envelope, destination)        │</p>
<p>  │    Destination: "orders"                       │</p>
<p>  ▼                                                │</p>
<p>┌──────────────────────────────────┐              │</p>
<p>│  Lookup subscriptions["orders"]  │              │</p>
<p>└──────────────────────────────────┘              │</p>
<p>  │                                                │</p>
<p>  │ 2. Foreach handler in subscriptions           │</p>
<p>  │    → Await handler(envelope)                  │</p>
<p>  ▼                                                ▼</p>
<p>┌──────────────────────────────────┐    ┌──────────────────┐</p>
<p>│  Handler1(envelope)              │───▶│  Process message │</p>
<p>└──────────────────────────────────┘    └──────────────────┘</p>
<p>  │                                                │</p>
<p>  │ 3. Sequential execution                       │</p>
<p>  ▼                                                │</p>
<p>┌──────────────────────────────────┐    ┌──────────────────┐</p>
<p>│  Handler2(envelope)              │───▶│  Process message │</p>
<p>└──────────────────────────────────┘    └──────────────────┘</p>
<p>  │</p>
<p>  │ 4. PublishAsync completes after ALL handlers</p>
<p>  ▼</p>
<p></code></pre></p>

<strong>Key Characteristics</strong>:
<ul><li><strong>Synchronous</strong>: <code>PublishAsync</code> awaits all handlers before returning</li>
<li><strong>Ordered</strong>: Handlers invoked in subscription order</li>
<li><strong>Thread-Safe</strong>: Uses <code>ConcurrentDictionary</code> and locking</li>
<li><strong>No Retry</strong>: Exceptions propagate to publisher</li>
</ul>
<hr>

<h2>Configuration</h2>

<h3>1. Register Transport (Built-In)</h3>

<pre><code class="language-csharp">using Whizbang.Core.Transports;

<p>var builder = WebApplication.CreateBuilder(args);</p>

<p>// In-memory transport is part of Whizbang.Core - no separate package needed</p>
<p>builder.Services.AddSingleton<ITransport, InProcessTransport>();</p>

<p>var app = builder.Build();</p>
<p>app.Run();</p>
<p></code></pre></p>

<strong>Note</strong>: No additional configuration needed - transport is ready immediately.

<h3>2. Initialization</h3>

<pre><code class="language-csharp">var transport = new InProcessTransport();
<p>await transport.InitializeAsync();  // Returns immediately (idempotent)</p>

<p>// IsInitialized is true immediately</p>
<p>Console.WriteLine(transport.IsInitialized);  // True</p>
<p></code></pre></p>

<hr>

<h2>Usage Patterns</h2>

<h3>Publish/Subscribe</h3>

<pre><code class="language-csharp">using Whizbang.Core.Transports;

<p>var transport = new InProcessTransport();</p>

<p>// Subscribe to messages</p>
<p>var subscription = await transport.SubscribeAsync(</p>
<p>  handler: async (envelope, ct) => {</p>
<p>    Console.WriteLine($"Received: {envelope.MessageId}");</p>
<p>    await ProcessMessageAsync(envelope);</p>
<p>  },</p>
<p>  destination: new TransportDestination("orders")</p>
<p>);</p>

<p>// Publish message</p>
<p>var envelope = MessageEnvelope.Create(</p>
<p>  messageId: MessageId.New(),</p>
<p>  correlationId: CorrelationId.New(),</p>
<p>  causationId: null,</p>
<p>  payload: new OrderCreated(orderId, customerId, total),</p>
<p>  currentHop: new MessageHop { Timestamp = DateTimeOffset.UtcNow }</p>
<p>);</p>

<p>await transport.PublishAsync(</p>
<p>  envelope,</p>
<p>  new TransportDestination("orders")</p>
<p>);</p>

<p>// Handler invoked synchronously before PublishAsync returns</p>
<p></code></pre></p>

<h3>Multiple Subscribers</h3>

<pre><code class="language-csharp">// Multiple subscribers receive the same message
<p>await transport.SubscribeAsync(</p>
<p>  handler: async (envelope, ct) => {</p>
<p>    // Update read model</p>
<p>    await _perspectiveStore.UpdateAsync(envelope.Payload);</p>
<p>  },</p>
<p>  destination: new TransportDestination("orders")</p>
<p>);</p>

<p>await transport.SubscribeAsync(</p>
<p>  handler: async (envelope, ct) => {</p>
<p>    // Send notification</p>
<p>    await _emailService.SendOrderConfirmationAsync(envelope.Payload);</p>
<p>  },</p>
<p>  destination: new TransportDestination("orders")</p>
<p>);</p>

<p>// Publish - both handlers invoked sequentially</p>
<p>await transport.PublishAsync(envelope, new TransportDestination("orders"));</p>
<p></code></pre></p>

<h3>Request/Response Pattern</h3>

<pre><code class="language-csharp">// Setup responder
<p>await transport.SubscribeAsync(</p>
<p>  handler: async (requestEnvelope, ct) => {</p>
<p>    // Process request</p>
<p>    var response = ProcessOrder(requestEnvelope.Payload);</p>

<p>    // Send response to response destination</p>
<p>    var responseEnvelope = MessageEnvelope.Create(</p>
<p>      messageId: MessageId.New(),</p>
<p>      correlationId: requestEnvelope.GetCorrelationId(),</p>
<p>      causationId: requestEnvelope.MessageId,</p>
<p>      payload: response,</p>
<p>      currentHop: new MessageHop { Timestamp = DateTimeOffset.UtcNow }</p>
<p>    );</p>

<p>    var responseDest = new TransportDestination($"response-{requestEnvelope.MessageId.Value}");</p>
<p>    await transport.PublishAsync(responseEnvelope, responseDest, ct);</p>
<p>  },</p>
<p>  destination: new TransportDestination("order-service")</p>
<p>);</p>

<p>// Send request and wait for response</p>
<p>var requestEnvelope = MessageEnvelope.Create(</p>
<p>  messageId: MessageId.New(),</p>
<p>  correlationId: CorrelationId.New(),</p>
<p>  causationId: null,</p>
<p>  payload: new CreateOrder(items),</p>
<p>  currentHop: new MessageHop { Timestamp = DateTimeOffset.UtcNow }</p>
<p>);</p>

<p>var responseEnvelope = await transport.SendAsync<CreateOrder, OrderCreated>(</p>
<p>  requestEnvelope,</p>
<p>  new TransportDestination("order-service")</p>
<p>);</p>

<p>Console.WriteLine($"Order created: {responseEnvelope.Payload}");</p>
<p></code></pre></p>

<strong>How SendAsync Works</strong>:
<ul><li>Creates temporary response destination: <code>response-{messageId}</code></li>
<li>Subscribes to response destination</li>
<li>Publishes request to target destination</li>
<li>Waits for response (via <code>TaskCompletionSource</code>)</li>
<li>Cleans up response subscription (in finally block)</li>
</ul>
<hr>

<h2>Subscription Lifecycle</h2>

<h3>Pause and Resume</h3>

<pre><code class="language-csharp">var subscription = await transport.SubscribeAsync(
<p>  handler: async (envelope, ct) => {</p>
<p>    await ProcessAsync(envelope);</p>
<p>  },</p>
<p>  destination: new TransportDestination("orders")</p>
<p>);</p>

<p>// Pause subscription - handler won't be invoked</p>
<p>await subscription.PauseAsync();</p>
<p>Console.WriteLine(subscription.IsActive);  // False</p>

<p>await transport.PublishAsync(envelope, destination);  // Handler NOT invoked</p>

<p>// Resume subscription</p>
<p>await subscription.ResumeAsync();</p>
<p>Console.WriteLine(subscription.IsActive);  // True</p>

<p>await transport.PublishAsync(envelope, destination);  // Handler invoked</p>
<p></code></pre></p>

<strong>Use Cases</strong>:
<ul><li>Temporarily stop processing during maintenance</li>
<li>Rate limiting or backpressure handling</li>
<li>Graceful shutdown (pause before disposing)</li>
</ul>
<h3>Dispose</h3>

<pre><code class="language-csharp">// Remove subscription entirely
<p>subscription.Dispose();</p>

<p>// Handler removed from transport</p>
<p>await transport.PublishAsync(envelope, destination);  // Handler NOT invoked</p>

<p>// Dispose is idempotent</p>
<p>subscription.Dispose();  // Safe to call multiple times</p>
<p></code></pre></p>

<hr>

<h2>Transport Capabilities</h2>

<p>The in-memory transport declares these capabilities:</p>

<pre><code class="language-csharp">TransportCapabilities.RequestResponse |   // ✅ SendAsync support
<p>TransportCapabilities.PublishSubscribe |  // ✅ PublishAsync/SubscribeAsync</p>
<p>TransportCapabilities.Ordered |           // ✅ Sequential handler execution</p>
<p>TransportCapabilities.Reliable            // ✅ Direct invocation (no network failures)</p>
<p></code></pre></p>

<strong>Not Supported</strong>:
<ul><li>❌ <code>ExactlyOnce</code> - Handlers invoked for each publish (no deduplication)</li>
<li>❌ <code>Streaming</code> - Not applicable to in-memory</li>
</ul>
<strong>Reliability Note</strong>: "Reliable" means messages won't be lost due to network failures, but exceptions in handlers propagate to publisher.

<hr>

<h2>Thread Safety</h2>

<h3>Concurrent Publishes</h3>

<pre><code class="language-csharp">var transport = new InProcessTransport();
<p>var destination = new TransportDestination("orders");</p>

<p>// Subscribe once</p>
<p>await transport.SubscribeAsync(</p>
<p>  handler: async (envelope, ct) => {</p>
<p>    await ProcessAsync(envelope);</p>
<p>  },</p>
<p>  destination: destination</p>
<p>);</p>

<p>// Publish concurrently from multiple threads</p>
<p>var tasks = Enumerable.Range(0, 100)</p>
<p>  .Select(i => {</p>
<p>    var envelope = CreateEnvelope($"order-{i}");</p>
<p>    return transport.PublishAsync(envelope, destination);</p>
<p>  })</p>
<p>  .ToArray();</p>

<p>await Task.WhenAll(tasks);  // Thread-safe - all handlers invoked</p>
<p></code></pre></p>

<h3>Concurrent Subscriptions</h3>

<pre><code class="language-csharp">// Subscribe concurrently from multiple threads
<p>var subscribeTasks = Enumerable.Range(0, 50)</p>
<p>  .Select(i => transport.SubscribeAsync(</p>
<p>    handler: async (envelope, ct) => {</p>
<p>      await ProcessAsync(envelope, handlerIndex: i);</p>
<p>    },</p>
<p>    destination: new TransportDestination("orders")</p>
<p>  ))</p>
<p>  .ToArray();</p>

<p>await Task.WhenAll(subscribeTasks);  // Thread-safe - all registered</p>

<p>// Publish message - all 50 handlers invoked</p>
<p>await transport.PublishAsync(envelope, new TransportDestination("orders"));</p>
<p></code></pre></p>

<strong>Implementation</strong>:
<ul><li><code>ConcurrentDictionary<string, List<...>></code> for subscriptions</li>
<li><code>lock</code> on subscription list during add/remove</li>
<li>Thread-safe iteration with <code>.ToArray()</code> snapshot</li>
</ul>
<hr>

<h2>Error Handling</h2>

<h3>Handler Exceptions</h3>

<pre><code class="language-csharp">await transport.SubscribeAsync(
<p>  handler: async (envelope, ct) => {</p>
<p>    throw new InvalidOperationException("Handler failed!");</p>
<p>  },</p>
<p>  destination: new TransportDestination("orders")</p>
<p>);</p>

<p>try {</p>
<p>  await transport.PublishAsync(envelope, destination);</p>
<p>} catch (InvalidOperationException ex) {</p>
<p>  // Exception propagates to publisher</p>
<p>  Console.WriteLine($"Handler failed: {ex.Message}");</p>
<p>}</p>
<p></code></pre></p>

<strong>Behavior</strong>:
<ul><li>Exception thrown in handler → exception propagates to <code>PublishAsync</code> caller</li>
<li>Subsequent handlers <strong>may not execute</strong> (depends on exception handling)</li>
<li><strong>No retry</strong> - caller must handle retry logic</li>
</ul>
<h3>Cancellation</h3>

<pre><code class="language-csharp">var cts = new CancellationTokenSource(TimeSpan.FromSeconds(5));

<p>try {</p>
<p>  await transport.SendAsync<CreateOrder, OrderCreated>(</p>
<p>    requestEnvelope,</p>
<p>    destination,</p>
<p>    cts.Token  // Timeout after 5 seconds</p>
<p>  );</p>
<p>} catch (OperationCanceledException) {</p>
<p>  Console.WriteLine("Request timed out - no response received");</p>
<p>}</p>
<p></code></pre></p>

<strong>SendAsync Cancellation</strong>:
<ul><li>Response subscription cleaned up (finally block)</li>
<li><code>TaskCompletionSource</code> cancelled</li>
<li>No orphaned subscriptions</li>
</ul>
<hr>

<h2>Performance</h2>

<h3>Benchmarks</h3>

<p>| Metric | Value | Notes |</p>
<p>|--------|-------|-------|</p>
<p>| <strong>PublishAsync Latency</strong> | ~1-5µs | Direct method call |</p>
<p>| <strong>SendAsync Latency</strong> | ~10-50µs | Includes subscription setup/teardown |</p>
<p>| <strong>Throughput</strong> | ~1M msg/sec | Limited by handler execution time |</p>
<p>| <strong>Memory</strong> | ~100 bytes/subscription | Minimal overhead |</p>

<h3>Comparison: In-Memory vs Azure Service Bus</h3>

<p>| Metric | In-Memory | Azure Service Bus |</p>
<p>|--------|-----------|-------------------|</p>
<p>| <strong>Latency</strong> | ~5µs | ~10-50ms (network) |</p>
<p>| <strong>Throughput</strong> | ~1M msg/sec | ~10K msg/sec |</p>
<p>| <strong>Cross-Process</strong> | ❌ Same process only | ✅ Distributed |</p>
<p>| <strong>Persistence</strong> | ❌ No | ✅ Durable queues |</p>
<p>| <strong>Retry</strong> | ❌ Manual | ✅ Automatic |</p>
<p>| <strong>Dead Letter</strong> | ❌ No | ✅ Yes |</p>
<p>| <strong>Setup Complexity</strong> | ✅ None | ⚠️ Infrastructure required |</p>

<strong>When to Use Each</strong>:

<p>| Scenario | Transport |</p>
<p>|----------|-----------|</p>
<p>| <strong>Unit/Integration Tests</strong> | In-Memory |</p>
<p>| <strong>Single-Process App</strong> | In-Memory |</p>
<p>| <strong>Distributed Services</strong> | Azure Service Bus |</p>
<p>| <strong>High Availability</strong> | Azure Service Bus |</p>
<p>| <strong>Local Development</strong> | In-Memory |</p>
<p>| <strong>Production Multi-Service</strong> | Azure Service Bus |</p>

<hr>

<h2>Testing Patterns</h2>

<h3>Unit Testing Receptors</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task OrderReceptor_CreateOrder_PublishesOrderCreatedAsync() {</p>
<p>  // Arrange</p>
<p>  var transport = new InProcessTransport();</p>
<p>  var receptor = new OrderReceptor(transport);</p>

<p>  IMessageEnvelope? publishedEvent = null;</p>
<p>  await transport.SubscribeAsync(</p>
<p>    handler: (envelope, ct) => {</p>
<p>      publishedEvent = envelope;</p>
<p>      return Task.CompletedTask;</p>
<p>    },</p>
<p>    destination: new TransportDestination("order-events")</p>
<p>  );</p>

<p>  var command = new CreateOrder(orderId, customerId, items);</p>

<p>  // Act</p>
<p>  var result = await receptor.HandleAsync(command);</p>

<p>  // Assert</p>
<p>  await Assert.That(publishedEvent).IsNotNull();</p>
<p>  await Assert.That(publishedEvent!.Payload).IsOfType<OrderCreated>();</p>
<p>}</p>
<p></code></pre></p>

<h3>Testing Message Flows</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task OrderFlow_CreateAndShip_FullMessageChainAsync() {</p>
<p>  // Arrange</p>
<p>  var transport = new InProcessTransport();</p>

<p>  // Setup receptors</p>
<p>  var orderReceptor = new OrderReceptor(transport);</p>
<p>  var inventoryReceptor = new InventoryReceptor(transport);</p>
<p>  var shippingReceptor = new ShippingReceptor(transport);</p>

<p>  // Subscribe to each stage</p>
<p>  await transport.SubscribeAsync(</p>
<p>    handler: (env, ct) => inventoryReceptor.HandleAsync(env.Payload as OrderCreated),</p>
<p>    destination: new TransportDestination("inventory")</p>
<p>  );</p>

<p>  await transport.SubscribeAsync(</p>
<p>    handler: (env, ct) => shippingReceptor.HandleAsync(env.Payload as InventoryReserved),</p>
<p>    destination: new TransportDestination("shipping")</p>
<p>  );</p>

<p>  // Act - Trigger flow</p>
<p>  var command = new CreateOrder(orderId, customerId, items);</p>
<p>  await orderReceptor.HandleAsync(command);</p>

<p>  // Assert - Verify all stages completed</p>
<p>  var order = await _orderRepository.GetAsync(orderId);</p>
<p>  await Assert.That(order.Status).IsEqualTo(OrderStatus.Shipped);</p>
<p>}</p>
<p></code></pre></p>

<h3>Testing with IDispatcher</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task MessageFlow_ViaDispatcher_RoutesToCorrectReceptorAsync() {</p>
<p>  // Arrange</p>
<p>  var serviceProvider = BuildServiceProvider();  // Includes receptors</p>
<p>  var dispatcher = serviceProvider.GetRequiredService<IDispatcher>();</p>
<p>  var transport = serviceProvider.GetRequiredService<ITransport>() as InProcessTransport;</p>

<p>  // Subscribe dispatcher to transport</p>
<p>  await transport!.SubscribeAsync(</p>
<p>    handler: async (envelope, ct) => {</p>
<p>      await dispatcher.LocalInvokeAsync(envelope.Payload, ct);</p>
<p>    },</p>
<p>    destination: new TransportDestination("messages")</p>
<p>  );</p>

<p>  // Act - Publish command</p>
<p>  var command = new CreateOrder(orderId, customerId, items);</p>
<p>  var envelope = MessageEnvelope.Create(</p>
<p>    MessageId.New(), CorrelationId.New(), null,</p>
<p>    command,</p>
<p>    new MessageHop { Timestamp = DateTimeOffset.UtcNow }</p>
<p>  );</p>

<p>  await transport.PublishAsync(envelope, new TransportDestination("messages"));</p>

<p>  // Assert - Receptor invoked via dispatcher</p>
<p>  var order = await _orderRepository.GetAsync(orderId);</p>
<p>  await Assert.That(order).IsNotNull();</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Use for unit and integration tests</strong> - Fastest, no infrastructure</li>
<li>✅ <strong>Dispose subscriptions</strong> when done - Prevent handler leaks</li>
<li>✅ <strong>Handle exceptions in handlers</strong> - Prevent propagation to publisher</li>
<li>✅ <strong>Use pause/resume for backpressure</strong> - Graceful flow control</li>
<li>✅ <strong>Test error paths</strong> - Verify exception handling</li>
<li>✅ <strong>Use for single-process apps</strong> - Simple modular architecture</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Use for production distributed systems (use Azure Service Bus)</li>
<li>❌ Rely on retry/dead-letter (not supported - handle manually)</li>
<li>❌ Forget to dispose subscriptions (causes memory leaks)</li>
<li>❌ Assume asynchronous delivery (handlers execute synchronously)</li>
<li>❌ Use for cross-process communication (in-memory only)</li>
<li>❌ Ignore handler exceptions (they propagate to publisher)</li>
</ul>
<hr>

<h2>Troubleshooting</h2>

<h3>Problem: Handler Not Invoked</h3>

<strong>Symptoms</strong>: Published messages don't trigger handler.

<strong>Causes</strong>:
<ul><li>Destination address mismatch</li>
<li>Subscription paused or disposed</li>
<li>Handler threw exception in previous call</li>
</ul>
<strong>Solution</strong>:

<pre><code class="language-csharp">// Verify destination addresses match EXACTLY
<p>var publishDest = new TransportDestination("orders");</p>
<p>var subscribeDest = new TransportDestination("orders");</p>

<p>// Verify subscription is active</p>
<p>var subscription = await transport.SubscribeAsync(handler, subscribeDest);</p>
<p>Console.WriteLine(subscription.IsActive);  // Should be true</p>

<p>// Check for paused subscription</p>
<p>await subscription.ResumeAsync();</p>
<p></code></pre></p>

<h3>Problem: SendAsync Hangs Forever</h3>

<strong>Symptoms</strong>: <code>SendAsync</code> never returns, no timeout.

<strong>Cause</strong>: No responder subscribed to request destination.

<strong>Solution</strong>:

<pre><code class="language-csharp">// Always use timeout with SendAsync
<p>var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));</p>

<p>try {</p>
<p>  var response = await transport.SendAsync<TRequest, TResponse>(</p>
<p>    requestEnvelope,</p>
<p>    destination,</p>
<p>    cts.Token  // ✅ Timeout after 30 seconds</p>
<p>  );</p>
<p>} catch (OperationCanceledException) {</p>
<p>  // No response received - handle timeout</p>
<p>  Console.WriteLine("Request timed out");</p>
<p>}</p>
<p></code></pre></p>

<h3>Problem: Memory Leak with Subscriptions</h3>

<strong>Symptoms</strong>: Memory usage grows over time.

<strong>Cause</strong>: Subscriptions not disposed when no longer needed.

<strong>Solution</strong>:

<pre><code class="language-csharp">// Always dispose subscriptions
<p>var subscription = await transport.SubscribeAsync(handler, destination);</p>

<p>try {</p>
<p>  // Use subscription...</p>
<p>} finally {</p>
<p>  subscription.Dispose();  // ✅ Cleanup</p>
<p>}</p>

<p>// Or use IAsyncDisposable</p>
<p>await using var subscription = await transport.SubscribeAsync(handler, destination);</p>
<p>// Auto-disposed when out of scope</p>
<p></code></pre></p>

<h3>Problem: Concurrent Handler Execution</h3>

<strong>Symptoms</strong>: Handlers execute in unpredictable order.

<strong>Cause</strong>: Multiple concurrent <code>PublishAsync</code> calls.

<strong>Clarification</strong>: This is <strong>expected behavior</strong> for concurrent publishes.

<pre><code class="language-csharp">// Concurrent publishes → concurrent handler execution
<p>await Task.WhenAll(</p>
<p>  transport.PublishAsync(envelope1, destination),  // Handler invoked</p>
<p>  transport.PublishAsync(envelope2, destination),  // Handler invoked concurrently</p>
<p>  transport.PublishAsync(envelope3, destination)   // Handler invoked concurrently</p>
<p>);</p>

<p>// Solution: If strict ordering required, publish sequentially</p>
<p>await transport.PublishAsync(envelope1, destination);  // Completes before next</p>
<p>await transport.PublishAsync(envelope2, destination);</p>
<p>await transport.PublishAsync(envelope3, destination);</p>
<p></code></pre></p>

<hr>

<h2>Advanced Patterns</h2>

<h3>Conditional Handler Execution</h3>

<pre><code class="language-csharp">await transport.SubscribeAsync(
<p>  handler: async (envelope, ct) => {</p>
<p>    // Skip processing based on metadata</p>
<p>    var hop = envelope.Hops.First();</p>
<p>    if (hop.ServiceInstance?.ServiceName == "InventoryService") {</p>
<p>      return;  // Skip messages from InventoryService</p>
<p>    }</p>

<p>    await ProcessAsync(envelope);</p>
<p>  },</p>
<p>  destination: new TransportDestination("orders")</p>
<p>);</p>
<p></code></pre></p>

<h3>Circuit Breaker Pattern</h3>

<pre><code class="language-csharp">int failureCount = 0;
<p>const int maxFailures = 3;</p>

<p>var subscription = await transport.SubscribeAsync(</p>
<p>  handler: async (envelope, ct) => {</p>
<p>    try {</p>
<p>      await ProcessAsync(envelope);</p>
<p>      failureCount = 0;  // Reset on success</p>
<p>    } catch (Exception ex) {</p>
<p>      failureCount++;</p>

<p>      if (failureCount >= maxFailures) {</p>
<p>        // Open circuit - pause subscription</p>
<p>        await subscription.PauseAsync();</p>
<p>        Console.WriteLine("Circuit opened - pausing subscription");</p>

<p>        // Schedule resume after cooldown</p>
<p>        _ = Task.Delay(TimeSpan.FromMinutes(1))</p>
<p>          .ContinueWith(async _ => {</p>
<p>            await subscription.ResumeAsync();</p>
<p>            failureCount = 0;</p>
<p>            Console.WriteLine("Circuit closed - resuming subscription");</p>
<p>          });</p>
<p>      }</p>

<p>      throw;  // Re-throw to propagate to publisher</p>
<p>    }</p>
<p>  },</p>
<p>  destination: new TransportDestination("orders")</p>
<p>);</p>
<p></code></pre></p>

<h3>Fan-Out Pattern</h3>

<pre><code class="language-csharp">// Single publisher, multiple subscribers (fan-out)
<p>var transport = new InProcessTransport();</p>
<p>var destination = new TransportDestination("order-created");</p>

<p>// Subscribe multiple services</p>
<p>await transport.SubscribeAsync(</p>
<p>  handler: async (env, ct) => await _inventoryService.ReserveStockAsync(env.Payload),</p>
<p>  destination: destination</p>
<p>);</p>

<p>await transport.SubscribeAsync(</p>
<p>  handler: async (env, ct) => await _notificationService.SendEmailAsync(env.Payload),</p>
<p>  destination: destination</p>
<p>);</p>

<p>await transport.SubscribeAsync(</p>
<p>  handler: async (env, ct) => await _analyticsService.TrackEventAsync(env.Payload),</p>
<p>  destination: destination</p>
<p>);</p>

<p>// Publish once - all three services invoked</p>
<p>await transport.PublishAsync(orderCreatedEnvelope, destination);</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Transports</strong>:
<ul><li><a href="azure-service-bus.md">Azure Service Bus Transport</a> - Distributed messaging for production</li>
</ul>
<strong>Messaging Patterns</strong>:
<ul><li><a href="../messaging/outbox-pattern.md">Outbox Pattern</a> - Reliable event publishing (not needed for in-memory)</li>
<li><a href="../messaging/inbox-pattern.md">Inbox Pattern</a> - Exactly-once processing (not needed for in-memory)</li>
</ul>
<strong>Testing</strong>:
<ul><li><a href="../advanced/testing-receptors.md">Testing Receptors</a> - Unit testing message handlers</li>
</ul>
<strong>Extensibility</strong>:
<ul><li><a href="../extensibility/custom-transports.md">Custom Transports</a> - Implementing custom transports</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-transports-rabbitmq" class="doc-section">
  <h3>RabbitMQ Transport</h3>
  <p class="doc-path"><code>v1.0.0/transports/rabbitmq</code></p>
  <p class="doc-description"><em>Distributed event-driven messaging with RabbitMQ topic exchanges - AOT-compatible with channel pooling and dead-letter queue support</em></p>
  <div class="doc-content">

<h1>RabbitMQ Transport</h1>

<p>The <strong>RabbitMQ transport</strong> provides reliable, distributed messaging using RabbitMQ topic exchanges with automatic dead-letter queue handling, connection pooling, and full AOT compatibility. This enables pub/sub patterns for event-driven architectures with flexible routing and retry semantics.</p>

<h2>Why RabbitMQ?</h2>

<strong>RabbitMQ</strong> is a battle-tested open-source message broker offering:

<p>| Feature | Description | Benefit |</p>
<p>|---------|-------------|---------|</p>
<p>| <strong>Topic Exchanges</strong> | Flexible routing patterns | Wildcard subscriptions (<code>product.*</code>) |</p>
<p>| <strong>At-Least-Once Delivery</strong> | Message acknowledgments | Reliability |</p>
<p>| <strong>Dead Letter Queues</strong> | Automatic failure handling | Observability & recovery |</p>
<p>| <strong>Lightweight</strong> | Runs on-premise or containers | Developer-friendly |</p>
<p>| <strong>Message TTL</strong> | Time-to-live support | Automatic cleanup |</p>
<p>| <strong>Prefetch Control</strong> | QoS flow control | Backpressure management |</p>

<strong>Whizbang Integration</strong>:
<ul><li>✅ <strong>AOT-Compatible</strong> - Uses <code>JsonContextRegistry</code> for source-generated JSON serialization</li>
<li>✅ <strong>Channel Pooling</strong> - Thread-safe operations via semaphore-based pooling</li>
<li>✅ <strong>TestContainers Support</strong> - First-class integration testing with Docker</li>
<li>✅ <strong>Dead-Letter Queues</strong> - Automatic DLX/DLQ creation and binding</li>
<li>✅ <strong>Pause/Resume</strong> - Subscription lifecycle management</li>
<li>✅ <strong>Correlation Tracing</strong> - MessageId, CorrelationId, CausationId propagation</li>
</ul>
<hr>

<h2>Architecture</h2>

<h3>Topic Exchange Pattern</h3>

<pre><code class="language-">┌────────────────────────────────────────────────────────┐
<p>│  RabbitMQ Broker                                       │</p>
<p>│                                                         │</p>
<p>│  ┌────────────────────────────────────────────────┐   │</p>
<p>│  │  Exchange: "products" (topic)                  │   │</p>
<p>│  │                                                 │   │</p>
<p>│  │  ┌──────────────────────────────────────────┐ │   │</p>
<p>│  │  │  Queue: "inventory-products-queue"       │ │   │</p>
<p>│  │  │  Binding: "product.*"                    │ │   │</p>
<p>│  │  │  → Inventory Service                     │ │   │</p>
<p>│  │  └──────────────────────────────────────────┘ │   │</p>
<p>│  │                                                 │   │</p>
<p>│  │  ┌──────────────────────────────────────────┐ │   │</p>
<p>│  │  │  Queue: "analytics-products-queue"       │ │   │</p>
<p>│  │  │  Binding: "product.created"              │ │   │</p>
<p>│  │  │  → Analytics Service                     │ │   │</p>
<p>│  │  └──────────────────────────────────────────┘ │   │</p>
<p>│  │                                                 │   │</p>
<p>│  │  ┌──────────────────────────────────────────┐ │   │</p>
<p>│  │  │  Queue: "notifications-queue"            │ │   │</p>
<p>│  │  │  Binding: "#" (all messages)             │ │   │</p>
<p>│  │  │  → Notification Service                  │ │   │</p>
<p>│  │  └──────────────────────────────────────────┘ │   │</p>
<p>│  └────────────────────────────────────────────────┘   │</p>
<p>│                                                         │</p>
<p>│  ┌────────────────────────────────────────────────┐   │</p>
<p>│  │  Dead Letter Exchange: "products.dlx" (fanout) │   │</p>
<p>│  │                                                 │   │</p>
<p>│  │  ┌──────────────────────────────────────────┐ │   │</p>
<p>│  │  │  Dead Letter Queue: "inventory-queue.dlq"│ │   │</p>
<p>│  │  └──────────────────────────────────────────┘ │   │</p>
<p>│  └────────────────────────────────────────────────┘   │</p>
<p>└────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<h3>Channel Pool Architecture</h3>

<p>RabbitMQ channels are <strong>not thread-safe</strong>, so Whizbang uses a channel pool for concurrent publishing:</p>

<pre><code class="language-">┌───────────────────────────────────────────┐
<p>│  RabbitMQChannelPool                      │</p>
<p>│                                           │</p>
<p>│  ┌─────────────────────────────────────┐ │</p>
<p>│  │  Available Channels (Semaphore)     │ │</p>
<p>│  │  Max: 10 (configurable)             │ │</p>
<p>│  │                                      │ │</p>
<p>│  │  ┌──────┐ ┌──────┐ ┌──────┐        │ │</p>
<p>│  │  │ CH 1 │ │ CH 2 │ │ CH 3 │  ...   │ │</p>
<p>│  │  └──────┘ └──────┘ └──────┘        │ │</p>
<p>│  └─────────────────────────────────────┘ │</p>
<p>└───────────────────────────────────────────┘</p>
<p>         ▲                  │</p>
<p>         │ Rent             │ Return</p>
<p>         │                  ▼</p>
<p>┌─────────────────────────────────────────┐</p>
<p>│  Publisher (TransportPublishStrategy)   │</p>
<p>│                                          │</p>
<p>│  using (var channel =                   │</p>
<p>│      await pool.RentChannelAsync()) {   │</p>
<p>│    // Publish message                   │</p>
<p>│    // Channel auto-returns on dispose   │</p>
<p>│  }                                       │</p>
<p>└─────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Subscriptions</strong> get dedicated channels (no pooling) for long-lived operations.

<h3>Message Flow</h3>

<h4>Publishing</h4>

<pre><code class="language-">Publisher (Order Service)
<p>  │</p>
<p>  │ 1. PublishAsync(envelope, destination)</p>
<p>  │    Destination.Address: "orders"</p>
<p>  │    Destination.RoutingKey: "order.created"</p>
<p>  ▼</p>
<p>┌─────────────────────────────────────┐</p>
<p>│  RabbitMQTransport                  │</p>
<p>│                                     │</p>
<p>│  - Rent channel from pool           │</p>
<p>│  - Declare exchange (idempotent)    │</p>
<p>│  - Serialize MessageEnvelope        │</p>
<p>│  - Set BasicProperties:             │</p>
<p>│    • MessageId                      │</p>
<p>│    • CorrelationId                  │</p>
<p>│    • EnvelopeType (for deser)       │</p>
<p>│  - BasicPublish(exchange, key)      │</p>
<p>│  - Return channel to pool           │</p>
<p>└─────────────────────────────────────┘</p>
<p>  │</p>
<p>  │ 2. BasicPublish()</p>
<p>  ▼</p>
<p>┌─────────────────────────────────────┐</p>
<p>│  RabbitMQ Exchange: "orders"        │</p>
<p>│  Type: topic                        │</p>
<p>└─────────────────────────────────────┘</p>
<p>  │</p>
<p>  │ 3. Route by pattern</p>
<p>  │    Routing Key: "order.created"</p>
<p>  ▼</p>
<p>┌─────────────────────────────────────┐</p>
<p>│  Queue: "fulfillment-orders-queue"  │</p>
<p>│  Binding: "order.*"                 │</p>
<p>└─────────────────────────────────────┘</p>
<p></code></pre></p>

<h4>Subscribing</h4>

<pre><code class="language-">Subscriber (Fulfillment Service)
<p>  │</p>
<p>  │ 1. SubscribeAsync(handler, destination)</p>
<p>  │    Destination.Address: "orders"</p>
<p>  │    Destination.RoutingKey: "fulfillment-orders-queue"</p>
<p>  ▼</p>
<p>┌─────────────────────────────────────┐</p>
<p>│  RabbitMQTransport                  │</p>
<p>│                                     │</p>
<p>│  - Create dedicated channel         │</p>
<p>│  - Set QoS prefetch (default: 10)  │</p>
<p>│  - Declare exchange                 │</p>
<p>│  - Declare queue with DLX           │</p>
<p>│  - Bind queue to exchange           │</p>
<p>│  - Create AsyncEventingBasicConsumer│</p>
<p>└─────────────────────────────────────┘</p>
<p>  │</p>
<p>  │ 2. Receive BasicDeliver event</p>
<p>  ▼</p>
<p>┌─────────────────────────────────────┐</p>
<p>│  Message Handler                    │</p>
<p>│                                     │</p>
<p>│  - Check subscription.IsActive      │</p>
<p>│  - Deserialize via EnvelopeType     │</p>
<p>│  - Invoke handler (Receptor)        │</p>
<p>│  - BasicAck on success              │</p>
<p>│  - BasicNack + requeue on failure   │</p>
<p>│  - BasicNack → DLQ after max retries│</p>
<p>└─────────────────────────────────────┘</p>
<p></code></pre></p>

<hr>

<h2>Installation</h2>

<h3>Package Reference</h3>

<strong>NuGet Package</strong>: <code>Whizbang.Transports.RabbitMQ</code> (when published)

<pre><code class="language-xml"><PackageReference Include="Whizbang.Transports.RabbitMQ" Version="0.1.0" />
<p></code></pre></p>

<h3>Dependencies</h3>

<pre><code class="language-xml"><ItemGroup>
<p>  <PackageReference Include="RabbitMQ.Client" Version="7.1.2" /></p>
<p>  <PackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="10.0.1" /></p>
<p>  <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks" Version="10.0.1" /></p>
<p></ItemGroup></p>
<p></code></pre></p>

<hr>

<h2>Running the Example Project</h2>

<p>The <strong>ECommerce sample</strong> demonstrates cross-service event distribution using <strong>Aspire orchestration</strong> with switchable transport providers. The same application code runs with either <strong>RabbitMQ</strong> or <strong>Azure Service Bus</strong> using compiler directives.</p>

<h3>Architecture Overview</h3>

<p>The sample includes:</p>
<ul><li><strong>OrderService.API</strong>: Handles order commands and workflows</li>
<li><strong>InventoryWorker</strong>: Manages inventory and publishes stock events</li>
<li><strong>PaymentWorker</strong>: Processes payment transactions</li>
<li><strong>ShippingWorker</strong>: Handles fulfillment and shipping</li>
<li><strong>NotificationWorker</strong>: Sends customer notifications</li>
<li><strong>BFF.API</strong>: Aggregates cross-service data via perspectives (GraphQL + REST)</li>
<li><strong>ECommerce.UI</strong>: Angular frontend (port 4200)</li>
</ul>
<strong>Cross-Service Event Flow</strong>:
<pre><code class="language-">OrderService → "orders" topic → [Payment, Shipping, Inventory, Notification, BFF]
<p>InventoryWorker → "products" topic → [BFF, InventoryWorker]</p>
<p>PaymentWorker → "payments" topic → [BFF]</p>
<p>ShippingWorker → "shipping" topic → [BFF]</p>
<p></code></pre></p>

<h3>Transport Provider Selection</h3>

<p>The ECommerce sample uses <strong>compiler directives</strong> to switch between transports at build time:</p>

<pre><code class="language-xml"><!-- Directory.Build.props -->
<p><DefineConstants Condition="'$(TransportProvider)' == ''">AZURESERVICEBUS</DefineConstants></p>
<p><DefineConstants Condition="'$(TransportProvider)' == 'RabbitMQ'">RABBITMQ</DefineConstants></p>
<p><DefineConstants Condition="'$(TransportProvider)' == 'AzureServiceBus'">AZURESERVICEBUS</DefineConstants></p>
<p></code></pre></p>

<strong>Default</strong>: Azure Service Bus
<strong>Switch to RabbitMQ</strong>: Add <code>/p:TransportProvider=RabbitMQ</code> to build/run commands

<h3>Prerequisites</h3>

<strong>Required Tools</strong>:
<ul><li><strong>.NET 10 SDK</strong> (or later)</li>
<li><strong>Docker Desktop</strong> (for emulators)</li>
<li><strong>Node.js 20+</strong> (for Angular UI)</li>
<li><strong>.NET Aspire Workload</strong>: <code>dotnet workload install aspire</code></li>
</ul>
<strong>Verify Installation</strong>:
<pre><code class="language-bash">dotnet --version  # Should be 10.0.1 or later
<p>docker --version  # Should be 20.10 or later</p>
<p>node --version    # Should be 20.0 or later</p>
<p>dotnet workload list | grep aspire  # Should show aspire workload</p>
<p></code></pre></p>

<hr>

<h3>Running with RabbitMQ</h3>

<strong>1. Build with RabbitMQ Transport</strong>:
<pre><code class="language-bash">cd samples/ECommerce

<h1>Build all projects with RabbitMQ transport</h1>
<p>dotnet build /p:TransportProvider=RabbitMQ</p>
<p></code></pre></p>

<strong>2. Start Aspire AppHost</strong>:
<pre><code class="language-bash">cd ECommerce.AppHost

<h1>Run with RabbitMQ (Aspire dashboard at https://localhost:17036)</h1>
<p>dotnet run /p:TransportProvider=RabbitMQ</p>
<p></code></pre></p>

<strong>What Aspire Does</strong>:
<ul><li>✅ Starts <strong>RabbitMQ container</strong> (port 5672, management UI at 15672)</li>
<li>✅ Starts <strong>PostgreSQL container</strong> (port 5432, pgAdmin at 5050)</li>
<li>✅ Creates <strong>exchanges</strong> (<code>orders</code>, <code>products</code>, <code>payments</code>, <code>shipping</code>, <code>inbox</code>)</li>
<li>✅ Creates <strong>queue bindings</strong> with routing patterns</li>
<li>✅ Initializes <strong>7 microservices</strong> with dependency injection</li>
<li>✅ Starts <strong>Angular UI</strong> at http://localhost:4200</li>
<li>✅ Provides <strong>Aspire Dashboard</strong> for observability</li>
</ul>
<strong>3. Access Services</strong>:
<pre><code class="language-bash"># Aspire Dashboard
<p>https://localhost:17036</p>

<h1>RabbitMQ Management UI (guest/guest)</h1>
<p>http://localhost:15672</p>

<h1>PostgreSQL pgAdmin (admin@admin.com/admin)</h1>
<p>http://localhost:5050</p>

<h1>Angular UI</h1>
<p>http://localhost:4200</p>

<h1>BFF Swagger UI</h1>
<p>http://localhost:<bff-port>/swagger</p>

<h1>BFF GraphQL Playground</h1>
<p>http://localhost:<bff-port>/graphql</p>
<p></code></pre></p>

<strong>4. View RabbitMQ Topology</strong>:
<ul><li>Navigate to <strong>Exchanges</strong> tab → See <code>orders</code>, <code>products</code>, <code>payments</code>, <code>shipping</code>, <code>inbox</code></li>
<li>Navigate to <strong>Queues</strong> tab → See all service queues with bindings</li>
<li>Navigate to <strong>Connections</strong> tab → See all microservice connections</li>
</ul>
<strong>5. Stop All Services</strong>:
<pre><code class="language-bash"># Ctrl+C in terminal running AppHost
<h1>Containers persist by default (ContainerLifetime.Persistent)</h1>

<h1>To clean up containers:</h1>
<p>docker stop rabbitmq postgres pgadmin</p>
<p>docker rm rabbitmq postgres pgadmin</p>
<p></code></pre></p>

<hr>

<h3>Running with Azure Service Bus Emulator</h3>

<strong>1. Build with Azure Service Bus Transport</strong>:
<pre><code class="language-bash">cd samples/ECommerce

<h1>Build with Azure Service Bus (default)</h1>
<p>dotnet build</p>

<h1>Or explicitly:</h1>
<p>dotnet build /p:TransportProvider=AzureServiceBus</p>
<p></code></pre></p>

<strong>2. Start Aspire AppHost</strong>:
<pre><code class="language-bash">cd ECommerce.AppHost

<h1>Run with Azure Service Bus (Aspire dashboard at https://localhost:17036)</h1>
<p>dotnet run</p>
<p></code></pre></p>

<strong>What Aspire Does</strong>:
<ul><li>✅ Starts <strong>Azure Service Bus Emulator</strong> (port 5672)</li>
<li>✅ Creates <strong>topics</strong> (<code>orders</code>, <code>products</code>, <code>payments</code>, <code>shipping</code>, <code>inbox</code>)</li>
<li>✅ Creates <strong>subscriptions</strong> with correlation filters</li>
<li>✅ Starts <strong>PostgreSQL container</strong> (port 5432, pgAdmin at 5050)</li>
<li>✅ Initializes <strong>7 microservices</strong> with dependency injection</li>
<li>✅ Starts <strong>Angular UI</strong> at http://localhost:4200</li>
<li>✅ Provides <strong>Aspire Dashboard</strong> for observability</li>
</ul>
<strong>3. Access Services</strong> (same as RabbitMQ except no Management UI):
<pre><code class="language-bash"># Aspire Dashboard
<p>https://localhost:17036</p>

<h1>PostgreSQL pgAdmin (admin@admin.com/admin)</h1>
<p>http://localhost:5050</p>

<h1>Angular UI</h1>
<p>http://localhost:4200</p>

<h1>BFF Swagger UI</h1>
<p>http://localhost:<bff-port>/swagger</p>

<h1>BFF GraphQL Playground</h1>
<p>http://localhost:<bff-port>/graphql</p>
<p></code></pre></p>

<strong>Note</strong>: Azure Service Bus Emulator has <strong>no management UI</strong>. Use Aspire Dashboard to monitor service health.

<hr>

<h3>Running Integration Tests</h3>

<p>The ECommerce sample includes <strong>dedicated integration test projects</strong> for each transport:</p>
<ul><li><code>ECommerce.Integration.Tests</code> → Azure Service Bus (48 lifecycle tests)</li>
<li><code>ECommerce.RabbitMQ.Integration.Tests</code> → RabbitMQ (48 lifecycle tests)</li>
</ul>
<strong>Why Separate Test Projects?</strong>:
<ul><li>Different fixtures for emulator management (shared vs per-test containers)</li>
<li>Different topic/exchange isolation strategies</li>
<li>Different cleanup and drain logic</li>
</ul>
<h4>RabbitMQ Integration Tests</h4>

<strong>1. Start RabbitMQ Container</strong>:
<pre><code class="language-bash">docker run -d \
<p>  --name rabbitmq \</p>
<p>  -p 5672:5672 \</p>
<p>  -p 15672:15672 \</p>
<p>  rabbitmq:4-management</p>
<p></code></pre></p>

<strong>2. Run Tests</strong>:
<pre><code class="language-bash">cd samples/ECommerce/tests/ECommerce.RabbitMQ.Integration.Tests

<h1>Run all 48 lifecycle tests (sequential execution)</h1>
<p>dotnet test</p>

<h1>Run specific test</h1>
<p>dotnet run -- --treenode-filter "/<em>/</em>/*/RestockInventory_FromZeroStock_IncreasesCorrectlyAsync"</p>
<p></code></pre></p>

<strong>Test Duration</strong>: ~1.5-2 minutes (48 tests, ~1-2s each)

<strong>What Tests Validate</strong>:
<ul><li>Cross-service event publication (InventoryWorker → RabbitMQ → BFF)</li>
<li>Topic exchange routing with test-specific exchanges</li>
<li>Dead letter queue handling (automatic DLX/DLQ creation)</li>
<li>Perspective materialization from cross-service events</li>
<li>Channel pool thread-safety under concurrent load</li>
<li>Subscription pause/resume lifecycle</li>
</ul>
<h4>Azure Service Bus Integration Tests</h4>

<strong>1. Start Service Bus Emulator</strong>:
<pre><code class="language-bash">docker run -d \
<p>  --name servicebus-emulator \</p>
<p>  -p 5672:5672 \</p>
<p>  -v $(pwd)/samples/ECommerce/tests/ECommerce.Integration.Tests/Config-Named.json:/ServiceBus_Emulator/ConfigFiles/Config.json \</p>
<p>  mcr.microsoft.com/azure-messaging/servicebus-emulator:latest</p>
<p></code></pre></p>

<strong>2. Run Tests</strong>:
<pre><code class="language-bash">cd samples/ECommerce/tests/ECommerce.Integration.Tests

<h1>Run all 48 lifecycle tests (sequential execution)</h1>
<p>dotnet test</p>

<h1>Run specific test</h1>
<p>dotnet run -- --treenode-filter "/<em>/</em>/*/SeedProducts_CreatesProducts_AndPerspectivesCompleteAsync"</p>
<p></code></pre></p>

<strong>Test Duration</strong>: ~2-2.5 minutes (emulator startup adds 45-60 seconds on first run)

<hr>

<h3>Key Differences Between Transports</h3>

<p>| Aspect | RabbitMQ | Azure Service Bus |</p>
<p>|--------|----------|-------------------|</p>
<p>| <strong>AppHost Setup</strong> | <code>AddRabbitMQ()</code> with exchanges/queues | <code>AddAzureServiceBus()</code> with topics/subscriptions |</p>
<p>| <strong>Topic Creation</strong> | Dynamic (created on first publish) | Static (pre-defined via Aspire or Config.json) |</p>
<p>| <strong>Management UI</strong> | ✅ Built-in (port 15672) | ❌ No UI (use Aspire Dashboard) |</p>
<p>| <strong>Routing</strong> | Wildcard patterns (<code>product.*</code>, <code>#</code>) | Subscription filters (CorrelationId, MessageId) |</p>
<p>| <strong>DLQ Handling</strong> | Automatic DLX/DLQ creation | Requires explicit subscription configuration |</p>
<p>| <strong>Startup Time</strong> | ~10 seconds | ~45-60 seconds (emulator initialization) |</p>
<p>| <strong>Test Isolation</strong> | Test-specific exchanges (<code>inventory-{testId}</code>) | Shared topics (<code>topic-00</code>, <code>topic-01</code>) |</p>

<hr>

<h3>Troubleshooting</h3>

<h4>AppHost won't start</h4>

<pre><code class="language-bash"># Ensure Aspire workload is installed
<p>dotnet workload install aspire</p>

<h1>Check Docker is running</h1>
<p>docker ps</p>

<h1>Rebuild all projects</h1>
<p>cd samples/ECommerce</p>
<p>dotnet clean</p>
<p>dotnet build /p:TransportProvider=RabbitMQ  # or AzureServiceBus</p>
<p></code></pre></p>

<h4>RabbitMQ container fails to start</h4>

<pre><code class="language-bash"># Check port conflicts
<p>lsof -i :5672</p>
<p>lsof -i :15672</p>

<h1>Remove existing container</h1>
<p>docker stop rabbitmq</p>
<p>docker rm rabbitmq</p>

<h1>Start fresh</h1>
<p>docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:4-management</p>
<p></code></pre></p>

<h4>Azure Service Bus Emulator not ready</h4>

<pre><code class="language-bash"># Check emulator logs
<p>docker logs servicebus-emulator</p>

<h1>Wait for "Emulator is ready" message (can take 60 seconds)</h1>
<p></code></pre></p>

<h4>Integration tests timeout</h4>

<pre><code class="language-bash"># Ensure emulator is running
<p>docker ps | grep rabbitmq  # or servicebus-emulator</p>

<h1>Check emulator logs</h1>
<p>docker logs rabbitmq</p>

<h1>Restart emulator if needed</h1>
<p>docker restart rabbitmq</p>
<p></code></pre></p>

<h4>Wrong transport used at runtime</h4>

<pre><code class="language-bash"># Verify build used correct transport
<p>cd samples/ECommerce</p>
<p>dotnet clean</p>
<p>dotnet build /p:TransportProvider=RabbitMQ  # or AzureServiceBus</p>

<h1>Check generated symbols in .whizbang-generated folder</h1>
<p>grep -r "RABBITMQ\|AZURESERVICEBUS" ECommerce.InventoryWorker/.whizbang-generated</p>
<p></code></pre></p>

<hr>

<h2>Configuration</h2>

<h3>Basic Setup</h3>

<pre><code class="language-csharp">using Whizbang.Transports.RabbitMQ;

<p>var builder = WebApplication.CreateBuilder(args);</p>

<p>// Register RabbitMQ transport</p>
<p>builder.Services.AddRabbitMQTransport(</p>
<p>    connectionString: "amqp://guest:guest@localhost:5672/",</p>
<p>    configureOptions: options => {</p>
<p>        options.MaxChannels = 20;                      // Channel pool size</p>
<p>        options.MaxDeliveryAttempts = 5;               // Retry limit before DLQ</p>
<p>        options.PrefetchCount = 10;                    // QoS prefetch count</p>
<p>        options.AutoDeclareDeadLetterExchange = true;  // Auto-create DLX/DLQ</p>
<p>    }</p>
<p>);</p>

<p>// Add health checks</p>
<p>builder.Services.AddRabbitMQHealthChecks();</p>

<p>var app = builder.Build();</p>

<p>// Health check endpoint</p>
<p>app.MapHealthChecks("/health");</p>

<p>app.Run();</p>
<p></code></pre></p>

<h3>Configuration Options</h3>

<p>| Property | Default | Description |</p>
<p>|----------|---------|-------------|</p>
<p>| <code>MaxChannels</code> | 10 | Maximum pooled channels for publishing |</p>
<p>| <code>MaxDeliveryAttempts</code> | 10 | Retry limit before dead-lettering |</p>
<p>| <code>DefaultQueueName</code> | <code>null</code> | Fallback queue name if not specified |</p>
<p>| <code>PrefetchCount</code> | 10 | QoS prefetch count per consumer |</p>
<p>| <code>AutoDeclareDeadLetterExchange</code> | <code>true</code> | Auto-create DLX and DLQ |</p>

<h3>Domain Topic Auto-Provisioning {#auto-provisioning}</h3>

<p>:::new</p>
<p>When you declare domain ownership via <code>OwnDomains()</code>, Whizbang automatically provisions topic exchanges at worker startup.</p>
<p>:::</p>

<p>The <code>RabbitMQInfrastructureProvisioner</code> is automatically registered and creates topic exchanges for owned domains:</p>

<pre><code class="language-csharp">services.AddWhizbang()
<p>    .WithRouting(routing => {</p>
<p>        routing.OwnDomains("myapp.users", "myapp.orders");</p>
<p>    })</p>
<p>    .AddTransportConsumer();</p>

<p>// At startup, these exchanges are auto-created:</p>
<p>// - myapp.users (type: topic, durable: true)</p>
<p>// - myapp.orders (type: topic, durable: true)</p>
<p></code></pre></p>

<strong>Key behaviors:</strong>
<ul><li>Exchange names are lowercased for consistency</li>
<li>Exchange declaration is idempotent (safe if already exists)</li>
<li>Provisioning happens before subscriptions are created</li>
<li>Multiple service instances can provision concurrently (race-safe)</li>
</ul>
<p>📖 See <a href="/core-concepts/routing#domain-topic-provisioning">Domain Topic Provisioning</a> for full details.</p>

<h3>Connection Retry Options {#connection-retry}</h3>

<p>The transport includes built-in connection retry with exponential backoff for handling transient connection failures:</p>

<p>| Property | Default | Description |</p>
<p>|----------|---------|-------------|</p>
<p>| <code>InitialRetryAttempts</code> | 5 | Initial retry attempts with warning logs |</p>
<p>| <code>InitialRetryDelay</code> | 1 second | Delay before first retry |</p>
<p>| <code>MaxRetryDelay</code> | 120 seconds | Maximum delay (caps exponential backoff) |</p>
<p>| <code>BackoffMultiplier</code> | 2.0 | Multiplier for exponential backoff |</p>
<p>| <code>RetryIndefinitely</code> | <code>true</code> | Continue retrying after initial attempts |</p>

<strong>Example Configuration</strong>:
<pre><code class="language-csharp">builder.Services.AddRabbitMQTransport(
<p>    connectionString: "amqp://guest:guest@localhost:5672/",</p>
<p>    configureOptions: options => {</p>
<p>        // Connection retry settings</p>
<p>        options.InitialRetryAttempts = 10;              // More warnings for slow containers</p>
<p>        options.InitialRetryDelay = TimeSpan.FromSeconds(2);</p>
<p>        options.MaxRetryDelay = TimeSpan.FromMinutes(2);</p>
<p>        options.BackoffMultiplier = 1.5;</p>
<p>        options.RetryIndefinitely = true;               // Keep trying until success</p>
<p>    }</p>
<p>);</p>
<p></code></pre></p>

<strong>Retry Behavior</strong> (with defaults):
<ul><li>Initial attempt → fails</li>
<li>Wait 1s → retry 1 (logged as warning)</li>
<li>Wait 2s → retry 2 (logged as warning)</li>
<li>Wait 4s → retry 3 (logged as warning)</li>
<li>Wait 8s → retry 4 (logged as warning)</li>
<li>Wait 16s → retry 5 (logged as warning)</li>
<li>Continue retrying indefinitely at intervals up to 120s (logged every 10 attempts)</li>
</ul>
<strong>Key Behaviors</strong>:
<ul><li><strong>Initial Phase</strong>: First 5 attempts log warnings for each failure</li>
<li><strong>Indefinite Phase</strong>: After initial attempts, continues retrying (logged less frequently)</li>
<li><strong>Capped Backoff</strong>: Delay never exceeds <code>MaxRetryDelay</code> (default 120s)</li>
<li><strong>Graceful Shutdown</strong>: Responds to cancellation token for clean shutdown</li>
</ul>
<strong>Use Cases</strong>:
<ul><li><strong>Container Startup</strong>: RabbitMQ container may take 10-30 seconds to become ready</li>
<li><strong>Network Glitches</strong>: Temporary network issues during service startup</li>
<li><strong>Cluster Failover</strong>: RabbitMQ cluster switching to different node</li>
<li><strong>Infrastructure Outage</strong>: Service survives extended outages and reconnects automatically</li>
</ul>
<strong>Fail Fast</strong> (disable indefinite retry):
<pre><code class="language-csharp">options.RetryIndefinitely = false;  // Throws after InitialRetryAttempts
<p></code></pre></p>

<h3>Runtime Reconnection {#runtime-reconnection}</h3>

<p>RabbitMQ transport uses the RabbitMQ client's built-in <strong>Automatic Recovery</strong> feature for runtime reconnection. When a connection is lost during operation:</p>

<ul><li><strong>Automatic Detection</strong>: Connection shutdown is detected immediately</li>
<li><strong>Automatic Recovery</strong>: Client attempts to reconnect automatically</li>
<li><strong>Channel Recovery</strong>: All channels and consumers are automatically re-established</li>
<li><strong>Topology Recovery</strong>: Exchanges, queues, and bindings are automatically re-declared</li>
</ul>
<strong>Connection State Monitoring</strong>:
<p>The transport logs connection state changes for observability:</p>
<ul><li><code>ConnectionShutdown</code> → Warning with reason code and message</li>
<li><code>RecoverySucceeded</code> → Information that connection recovered</li>
<li><code>ConnectionRecoveryError</code> → Error with exception details</li>
<li><code>ConnectionBlocked</code> → Warning when broker blocks the connection (resource alarm)</li>
<li><code>ConnectionUnblocked</code> → Information when normal operation resumes</li>
</ul>
<strong>Configuration</strong>:
<pre><code class="language-csharp">// NetworkRecoveryInterval is set to match InitialRetryDelay
<p>options.InitialRetryDelay = TimeSpan.FromSeconds(5);  // Recovery interval = 5s</p>
<p></code></pre></p>

<strong>No Manual Reconnection Needed</strong>: The RabbitMQ client handles all reconnection automatically. Your application code continues to work transparently after recovery

<h3>Connection String Format</h3>

<pre><code class="language-">amqp://username:password@hostname:port/virtualhost
<p>amqps://username:password@hostname:port/virtualhost  # TLS</p>
<p></code></pre></p>

<strong>Examples</strong>:
<ul><li>Local development: <code>amqp://guest:guest@localhost:5672/</code></li>
<li>Production: <code>amqps://prod-user:secret@rabbitmq.example.com:5671/production</code></li>
<li>Docker: <code>amqp://guest:guest@rabbitmq:5672/</code></li>
</ul>
<hr>

<h2>Usage</h2>

<h3>Publishing Messages</h3>

<pre><code class="language-csharp">public class ProductService {
<p>    private readonly ITransport _transport;</p>
<p>    private readonly ILogger<ProductService> _logger;</p>

<p>    public ProductService(ITransport transport, ILogger<ProductService> logger) {</p>
<p>        _transport = transport;</p>
<p>        _logger = logger;</p>
<p>    }</p>

<p>    public async Task CreateProductAsync(CreateProductCommand command) {</p>
<p>        // Create message envelope</p>
<p>        var envelope = new MessageEnvelope<ProductCreatedEvent> {</p>
<p>            MessageId = MessageId.New(),</p>
<p>            Payload = new ProductCreatedEvent {</p>
<p>                ProductId = command.ProductId,</p>
<p>                Name = command.Name,</p>
<p>                Price = command.Price,</p>
<p>                CreatedAt = DateTime.UtcNow</p>
<p>            }</p>
<p>        };</p>

<p>        // Publish to exchange with routing key</p>
<p>        var destination = new TransportDestination(</p>
<p>            Address: "products",                    // Exchange name</p>
<p>            RoutingKey: "product.created",          // Routing key</p>
<p>            Metadata: new Dictionary<string, JsonElement> {</p>
<p>                ["Priority"] = JsonSerializer.SerializeToElement(5)</p>
<p>            }</p>
<p>        );</p>

<p>        await _transport.PublishAsync(envelope, destination);</p>

<p>        _logger.LogInformation("Published ProductCreatedEvent for {ProductId}", command.ProductId);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Subscribing to Messages</h3>

<pre><code class="language-csharp">public class InventoryWorker : BackgroundService {
<p>    private readonly ITransport _transport;</p>
<p>    private readonly ILogger<InventoryWorker> _logger;</p>
<p>    private ISubscription? _subscription;</p>

<p>    public InventoryWorker(ITransport transport, ILogger<InventoryWorker> logger) {</p>
<p>        _transport = transport;</p>
<p>        _logger = logger;</p>
<p>    }</p>

<p>    protected override async Task ExecuteAsync(CancellationToken stoppingToken) {</p>
<p>        var destination = new TransportDestination(</p>
<p>            Address: "products",                           // Exchange name</p>
<p>            RoutingKey: "inventory-products-queue",        // Queue name</p>
<p>            Metadata: new Dictionary<string, JsonElement> {</p>
<p>                ["RoutingPattern"] = JsonSerializer.SerializeToElement("product.*")</p>
<p>            }</p>
<p>        );</p>

<p>        _subscription = await _transport.SubscribeAsync(</p>
<p>            handler: async (envelope, envelopeType, ct) => {</p>
<p>                _logger.LogInformation("Received message: {MessageId}", envelope.MessageId);</p>

<p>                if (envelope.Payload is ProductCreatedEvent evt) {</p>
<p>                    await HandleProductCreatedAsync(evt, ct);</p>
<p>                }</p>
<p>            },</p>
<p>            destination,</p>
<p>            stoppingToken</p>
<p>        );</p>

<p>        _logger.LogInformation("Subscribed to products exchange");</p>
<p>    }</p>

<p>    private async Task HandleProductCreatedAsync(ProductCreatedEvent evt, CancellationToken ct) {</p>
<p>        // Update inventory levels</p>
<p>        _logger.LogInformation("Handling ProductCreatedEvent for {ProductId}", evt.ProductId);</p>
<p>        // ... business logic</p>
<p>    }</p>

<p>    public override async Task StopAsync(CancellationToken ct) {</p>
<p>        if (_subscription != null) {</p>
<p>            await _subscription.DisposeAsync();</p>
<p>        }</p>
<p>        await base.StopAsync(ct);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Custom Routing Patterns</h3>

<pre><code class="language-csharp">// Subscribe to specific event types
<p>var destination = new TransportDestination(</p>
<p>    Address: "products",</p>
<p>    RoutingKey: "analytics-queue",</p>
<p>    Metadata: new Dictionary<string, JsonElement> {</p>
<p>        ["RoutingPattern"] = JsonSerializer.SerializeToElement("product.created")</p>
<p>    }</p>
<p>);</p>

<p>// Subscribe to all product events</p>
<p>var destination = new TransportDestination(</p>
<p>    Address: "products",</p>
<p>    RoutingKey: "audit-queue",</p>
<p>    Metadata: new Dictionary<string, JsonElement> {</p>
<p>        ["RoutingPattern"] = JsonSerializer.SerializeToElement("product.*")</p>
<p>    }</p>
<p>);</p>

<p>// Subscribe to all messages</p>
<p>var destination = new TransportDestination(</p>
<p>    Address: "products",</p>
<p>    RoutingKey: "logger-queue",</p>
<p>    Metadata: new Dictionary<string, JsonElement> {</p>
<p>        ["RoutingPattern"] = JsonSerializer.SerializeToElement("#")</p>
<p>    }</p>
<p>);</p>
<p></code></pre></p>

<h3>Pause and Resume Subscriptions</h3>

<pre><code class="language-csharp">public class OrderProcessor {
<p>    private ISubscription? _subscription;</p>

<p>    public async Task PauseProcessingAsync() {</p>
<p>        if (_subscription != null) {</p>
<p>            await _subscription.PauseAsync();</p>
<p>            // Messages will be nack'd with requeue while paused</p>
<p>        }</p>
<p>    }</p>

<p>    public async Task ResumeProcessingAsync() {</p>
<p>        if (_subscription != null) {</p>
<p>            await _subscription.ResumeAsync();</p>
<p>            // Message processing continues</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Dead Letter Queues</h2>

<h3>Automatic DLX/DLQ Setup</h3>

<p>When <code>AutoDeclareDeadLetterExchange = true</code> (default), the transport automatically creates:</p>

<ul><li><strong>Dead Letter Exchange</strong> (<code>{exchange}.dlx</code>): Fanout exchange for failed messages</li>
<li><strong>Dead Letter Queue</strong> (<code>{queue}.dlq</code>): Queue storing permanently failed messages</li>
<li><strong>DLX Binding</strong>: Main queue declares <code>x-dead-letter-exchange</code> argument</li>
</ul>
<h3>Message Retry Flow</h3>

<pre><code class="language-">┌─────────────────────┐
<p>│  Main Queue         │</p>
<p>│  "orders-queue"     │</p>
<p>│                     │</p>
<p>│  Delivery attempt 1 │</p>
<p>│  ────────────────►  │</p>
<p>│       Nack          │</p>
<p>│  ◄────────────────  │</p>
<p>│                     │</p>
<p>│  Delivery attempt 2 │</p>
<p>│  ────────────────►  │</p>
<p>│       Nack          │</p>
<p>│  ◄────────────────  │</p>
<p>│                     │</p>
<p>│  ...                │</p>
<p>│                     │</p>
<p>│  Attempt 10 (max)   │</p>
<p>│  ────────────────►  │</p>
<p>│       Nack          │</p>
<p>│  ◄──────────────┘   │</p>
<p>│                     │</p>
<p>│  x-dead-letter-     │</p>
<p>│  exchange set       │</p>
<p>└──────│──────────────┘</p>
<p>       │</p>
<p>       │ Message moved to DLX</p>
<p>       ▼</p>
<p>┌─────────────────────┐</p>
<p>│  Dead Letter        │</p>
<p>│  Exchange           │</p>
<p>│  "orders.dlx"       │</p>
<p>└──────│──────────────┘</p>
<p>       │</p>
<p>       │ Fanout routing</p>
<p>       ▼</p>
<p>┌─────────────────────┐</p>
<p>│  Dead Letter Queue  │</p>
<p>│  "orders-queue.dlq" │</p>
<p>│                     │</p>
<p>│  Permanently failed │</p>
<p>│  messages stored    │</p>
<p>└─────────────────────┘</p>
<p></code></pre></p>

<h3>Inspecting Failed Messages</h3>

<pre><code class="language-bash"># List messages in DLQ
<p>rabbitmqadmin get queue=orders-queue.dlq count=10</p>

<h1>Republish message from DLQ (manual intervention)</h1>
<p>rabbitmqadmin get queue=orders-queue.dlq requeue=true</p>
<p></code></pre></p>

<hr>

<h2>Health Checks</h2>

<h3>ASP.NET Core Health Checks</h3>

<pre><code class="language-csharp">using Whizbang.Transports.RabbitMQ;

<p>var builder = WebApplication.CreateBuilder(args);</p>

<p>builder.Services.AddRabbitMQTransport("amqp://localhost:5672/");</p>
<p>builder.Services.AddRabbitMQHealthChecks();</p>

<p>var app = builder.Build();</p>

<p>app.MapHealthChecks("/health");</p>

<p>app.Run();</p>
<p></code></pre></p>

<strong>Health Check Response</strong>:
<pre><code class="language-json">{
<p>  "status": "Healthy",</p>
<p>  "results": {</p>
<p>    "rabbitmq": {</p>
<p>      "status": "Healthy",</p>
<p>      "description": "RabbitMQ connection is open",</p>
<p>      "data": {}</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Custom Readiness Checks</h3>

<pre><code class="language-csharp">public class RabbitMQReadinessCheck : ITransportReadinessCheck {
<p>    private readonly IConnection _connection;</p>

<p>    public RabbitMQReadinessCheck(IConnection connection) {</p>
<p>        _connection = connection;</p>
<p>    }</p>

<p>    public ValueTask<bool> IsReadyAsync(CancellationToken ct = default) {</p>
<p>        return ValueTask.FromResult(_connection.IsOpen);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Testing</h2>

<h3>Unit Testing with Test Doubles</h3>

<pre><code class="language-csharp">using Whizbang.Transports.RabbitMQ;
<p>using Whizbang.Transports.RabbitMQ.Tests;</p>

<p>public class ProductServiceTests {</p>
<p>    [Test]</p>
<p>    public async Task CreateProductAsync_PublishesEvent() {</p>
<p>        // Arrange</p>
<p>        var fakeConnection = new FakeConnection();</p>
<p>        var fakeChannel = new FakeChannel();</p>
<p>        fakeConnection.CreateModelReturns = fakeChannel;</p>

<p>        var transport = new RabbitMQTransport(</p>
<p>            fakeConnection,</p>
<p>            new RabbitMQOptions(),</p>
<p>            NullLogger<RabbitMQTransport>.Instance</p>
<p>        );</p>

<p>        var service = new ProductService(transport, NullLogger<ProductService>.Instance);</p>

<p>        // Act</p>
<p>        await service.CreateProductAsync(new CreateProductCommand {</p>
<p>            ProductId = ProductId.From(Guid.NewGuid()),</p>
<p>            Name = "Test Product",</p>
<p>            Price = 10.00m</p>
<p>        });</p>

<p>        // Assert</p>
<p>        await Assert.That(fakeChannel.BasicPublishCallCount).IsEqualTo(1);</p>
<p>        await Assert.That(fakeChannel.LastExchange).IsEqualTo("products");</p>
<p>        await Assert.That(fakeChannel.LastRoutingKey).IsEqualTo("product.created");</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h3>Integration Testing with TestContainers</h3>

<pre><code class="language-csharp">using Testcontainers.RabbitMQ;

<p>[NotInParallel]  // RabbitMQ container isolation</p>
<p>public class RabbitMQIntegrationTests {</p>
<p>    private RabbitMqContainer? _container;</p>
<p>    private ITransport? _transport;</p>

<p>    [Before(Test)]</p>
<p>    public async Task SetupAsync() {</p>
<p>        // Start RabbitMQ container</p>
<p>        _container = new RabbitMqBuilder()</p>
<p>            .WithImage("rabbitmq:3.13-management-alpine")</p>
<p>            .WithPortBinding(5672, 5672)</p>
<p>            .WithPortBinding(15672, 15672)</p>
<p>            .Build();</p>

<p>        await _container.StartAsync();</p>

<p>        // Create transport</p>
<p>        var services = new ServiceCollection();</p>
<p>        services.AddRabbitMQTransport(_container.GetConnectionString());</p>
<p>        var provider = services.BuildServiceProvider();</p>

<p>        _transport = provider.GetRequiredService<ITransport>();</p>
<p>    }</p>

<p>    [Test]</p>
<p>    public async Task PublishAndSubscribe_MessageReceivedAsync() {</p>
<p>        // Arrange</p>
<p>        var receivedEvent = new TaskCompletionSource<ProductCreatedEvent>();</p>

<p>        var destination = new TransportDestination(</p>
<p>            Address: "test-products",</p>
<p>            RoutingKey: "test-queue"</p>
<p>        );</p>

<p>        // Subscribe</p>
<p>        await _transport!.SubscribeAsync(</p>
<p>            handler: (envelope, type, ct) => {</p>
<p>                if (envelope.Payload is ProductCreatedEvent evt) {</p>
<p>                    receivedEvent.SetResult(evt);</p>
<p>                }</p>
<p>                return ValueTask.CompletedTask;</p>
<p>            },</p>
<p>            destination,</p>
<p>            CancellationToken.None</p>
<p>        );</p>

<p>        // Act - Publish</p>
<p>        var expected = new ProductCreatedEvent {</p>
<p>            ProductId = ProductId.From(Guid.NewGuid()),</p>
<p>            Name = "Integration Test Product",</p>
<p>            Price = 99.99m</p>
<p>        };</p>

<p>        var envelope = new MessageEnvelope<ProductCreatedEvent> {</p>
<p>            MessageId = MessageId.New(),</p>
<p>            Payload = expected</p>
<p>        };</p>

<p>        await _transport.PublishAsync(envelope, destination);</p>

<p>        // Assert</p>
<p>        var received = await receivedEvent.Task.WaitAsync(TimeSpan.FromSeconds(5));</p>
<p>        await Assert.That(received.ProductId).IsEqualTo(expected.ProductId);</p>
<p>        await Assert.That(received.Name).IsEqualTo(expected.Name);</p>
<p>    }</p>

<p>    [After(Test)]</p>
<p>    public async Task TeardownAsync() {</p>
<p>        if (_transport != null) {</p>
<p>            await _transport.DisposeAsync();</p>
<p>        }</p>
<p>        if (_container != null) {</p>
<p>            await _container.StopAsync();</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>1. Channel Pool Sizing</h3>

<strong>Guideline</strong>: Set <code>MaxChannels</code> based on concurrent publishing threads.

<pre><code class="language-csharp">// Low throughput (< 10 msg/sec)
<p>options.MaxChannels = 10;  // Default</p>

<p>// Medium throughput (10-100 msg/sec)</p>
<p>options.MaxChannels = 20;</p>

<p>// High throughput (> 100 msg/sec)</p>
<p>options.MaxChannels = 50;</p>
<p></code></pre></p>

<strong>Why</strong>: Channels are lightweight, but excessive pooling wastes resources. Profile your workload.

<h3>2. Prefetch Count Tuning</h3>

<strong>Guideline</strong>: Set <code>PrefetchCount</code> based on message processing time.

<pre><code class="language-csharp">// Fast processing (< 100ms per message)
<p>options.PrefetchCount = 20;</p>

<p>// Medium processing (100ms - 1s)</p>
<p>options.PrefetchCount = 10;  // Default</p>

<p>// Slow processing (> 1s per message)</p>
<p>options.PrefetchCount = 1;</p>
<p></code></pre></p>

<strong>Why</strong>: Higher prefetch improves throughput but increases memory usage and delays redelivery on failure.

<h3>3. Retry Limits</h3>

<strong>Guideline</strong>: Set <code>MaxDeliveryAttempts</code> based on failure characteristics.

<pre><code class="language-csharp">// Transient failures (network glitches)
<p>options.MaxDeliveryAttempts = 3;</p>

<p>// Intermittent failures (external API timeouts)</p>
<p>options.MaxDeliveryAttempts = 5;</p>

<p>// Persistent failures (message format errors)</p>
<p>options.MaxDeliveryAttempts = 1;  // Fail fast to DLQ</p>
<p></code></pre></p>

<strong>Why</strong>: Excessive retries delay DLQ routing and waste resources.

<h3>4. Exchange and Queue Naming</h3>

<strong>Convention</strong>: Use hierarchical names for topic routing.

<pre><code class="language-csharp">// Good - hierarchical routing
<p>Address: "ecommerce.products"</p>
<p>RoutingKey: "product.created"</p>

<p>// Good - tenant isolation</p>
<p>Address: "tenant-123.orders"</p>
<p>RoutingKey: "order.*"</p>

<p>// Avoid - flat namespace</p>
<p>Address: "products"</p>
<p>RoutingKey: "created"</p>
<p></code></pre></p>

<h3>5. Dead Letter Queue Monitoring</h3>

<strong>Setup alerting</strong> for DLQ depth:

<pre><code class="language-bash"># Check DLQ message count
<p>rabbitmqadmin list queues name messages | grep dlq</p>

<h1>Set CloudWatch/Prometheus alert</h1>
<h1>If dlq_messages > threshold, investigate</h1>
<p></code></pre></p>

<strong>Why</strong>: Messages in DLQ indicate persistent failures requiring manual intervention.

<hr>

<h2>Capabilities</h2>

<p>The RabbitMQ transport supports the following <code>TransportCapabilities</code>:</p>

<p>| Capability | Supported | Notes |</p>
<p>|------------|-----------|-------|</p>
<p>| <strong>PublishSubscribe</strong> | ✅ Yes | Topic exchanges with wildcard routing |</p>
<p>| <strong>Reliable</strong> | ✅ Yes | At-least-once delivery with retries |</p>
<p>| <strong>Ordered</strong> | ❌ No | Not guaranteed with multiple consumers |</p>
<p>| <strong>RequestResponse</strong> | ❌ No | Not implemented in v1.0.0 |</p>
<p>| <strong>ExactlyOnce</strong> | ❌ No | Use inbox/outbox pattern (Whizbang.Core) |</p>

<strong>Ordering Considerations</strong>:
<ul><li>Single consumer per queue: Ordered within routing key</li>
<li>Multiple consumers: No ordering guarantee</li>
<li>Use partitioning or Azure Service Bus for strict ordering</li>
</ul>
<hr>

<h2>Troubleshooting</h2>

<h3>Connection Refused</h3>

<strong>Symptom</strong>: <code>BrokerUnreachableException: None of the specified endpoints were reachable</code>

<strong>Causes</strong>:
<ul><li>RabbitMQ server not running</li>
<li>Incorrect connection string</li>
<li>Firewall blocking port 5672</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-bash"># Check RabbitMQ is running
<p>docker ps | grep rabbitmq</p>

<h1>Verify connection</h1>
<p>telnet localhost 5672</p>

<h1>Check RabbitMQ logs</h1>
<p>docker logs <rabbitmq-container></p>
<p></code></pre></p>

<h3>Channel Pool Exhaustion</h3>

<strong>Symptom</strong>: <code>PublishAsync()</code> hangs or times out

<strong>Cause</strong>: All channels rented, none returned (likely exception in <code>using</code> block)

<strong>Solution</strong>:
<pre><code class="language-csharp">// Ensure channel returns on exception
<p>try {</p>
<p>    using (var channel = await pool.RentChannelAsync()) {</p>
<p>        await transport.PublishAsync(envelope, destination);</p>
<p>    }  // Channel auto-returns here</p>
<p>} catch (Exception ex) {</p>
<p>    _logger.LogError(ex, "Publish failed");</p>
<p>    throw;</p>
<p>}</p>
<p></code></pre></p>

<h3>Messages Not Routed</h3>

<strong>Symptom</strong>: Messages published but not received

<strong>Causes</strong>:
<ul><li>Exchange/queue binding mismatch</li>
<li>Incorrect routing key pattern</li>
<li>Queue not declared</li>
</ul>
<strong>Diagnosis</strong>:
<pre><code class="language-bash"># Check exchange exists
<p>rabbitmqadmin list exchanges name type</p>

<h1>Check queue bindings</h1>
<p>rabbitmqadmin list bindings source destination</p>

<h1>Inspect queue</h1>
<p>rabbitmqadmin list queues name messages</p>
<p></code></pre></p>

<h3>Dead Letter Loop</h3>

<strong>Symptom</strong>: Messages cycling between queue and DLQ

<strong>Cause</strong>: Handler always fails, message requeued from DLQ

<strong>Solution</strong>: Disable DLQ auto-requeue or fix handler logic.

<hr>

<h2>Performance Considerations</h2>

<h3>Throughput Characteristics</h3>

<strong>Baseline</strong> (local RabbitMQ, default settings):
<ul><li><strong>Publish</strong>: ~2,000-5,000 msg/sec</li>
<li><strong>Subscribe</strong>: ~1,000-3,000 msg/sec (depends on handler)</li>
</ul>
<strong>Tuning for High Throughput</strong>:
<ul><li>Increase <code>MaxChannels</code> (50-100)</li>
<li>Increase <code>PrefetchCount</code> (20-50)</li>
<li>Use multiple consumers</li>
<li>Disable unnecessary plugins (management UI)</li>
</ul>
<h3>Latency Characteristics</h3>

<strong>Typical Latencies</strong> (local RabbitMQ):
<ul><li><strong>Publish</strong>: 1-5 ms</li>
<li><strong>End-to-End</strong>: 10-50 ms (depends on handler)</li>
</ul>
<strong>Reducing Latency</strong>:
<ul><li>Reduce <code>PrefetchCount</code> (1-5)</li>
<li>Use faster serialization (System.Text.Json with source generation)</li>
<li>Optimize handler logic</li>
<li>Co-locate publisher and consumer</li>
</ul>
<hr>

<h2>Related Topics</h2>

<ul><li><a href="/components/transports">Transports Overview</a> - Compare transport implementations</li>
<li><a href="/transports/azure-service-bus">Azure Service Bus Transport</a> - Alternative transport with strict ordering</li>
<li><a href="/transports/in-memory">In-Memory Transport</a> - Testing and development</li>
<li><a href="/extensibility/custom-transports">Custom Transports</a> - Implement your own transport</li>
<li><a href="/core-concepts/lifecycle">Lifecycle Hooks</a> - Pre/post processing for messages</li>
<li><a href="/core-concepts/observability">Observability</a> - OpenTelemetry tracing</li>
</ul>
<hr>

<h2>Code References</h2>

<h3>Core Implementation</h3>
<ul><li><a href="https://github.com/whizbang-lib/whizbang/blob/main/src/Whizbang.Transports.RabbitMQ/RabbitMQTransport.cs"><code>RabbitMQTransport.cs</code></a> - Main transport implementation</li>
<li><a href="https://github.com/whizbang-lib/whizbang/blob/main/src/Whizbang.Transports.RabbitMQ/RabbitMQChannelPool.cs"><code>RabbitMQChannelPool.cs</code></a> - Thread-safe channel pooling</li>
<li><a href="https://github.com/whizbang-lib/whizbang/blob/main/src/Whizbang.Transports.RabbitMQ/RabbitMQOptions.cs"><code>RabbitMQOptions.cs</code></a> - Configuration options</li>
<li><a href="https://github.com/whizbang-lib/whizbang/blob/main/src/Whizbang.Transports.RabbitMQ/RabbitMQSubscription.cs"><code>RabbitMQSubscription.cs</code></a> - Subscription lifecycle</li>
</ul>
<h3>Tests</h3>
<ul><li><a href="https://github.com/whizbang-lib/whizbang/blob/main/tests/Whizbang.Transports.RabbitMQ.Tests/RabbitMQTransportTests.cs"><code>RabbitMQTransportTests.cs</code></a> - Unit tests</li>
<li><a href="https://github.com/whizbang-lib/whizbang/blob/main/tests/Whizbang.Transports.RabbitMQ.Tests/RabbitMQChannelPoolTests.cs"><code>RabbitMQChannelPoolTests.cs</code></a> - Channel pool tests</li>
<li><a href="https://github.com/whizbang-lib/whizbang/tree/main/samples/ECommerce/tests/ECommerce.RabbitMQ.Integration.Tests">Integration Tests</a> - TestContainers-based end-to-end tests</li>
</ul>
<hr>

<h2>Summary</h2>

<p>The RabbitMQ transport provides a robust, performant foundation for distributed event-driven architectures with:</p>

<p>✅ <strong>Reliable Delivery</strong> - At-least-once guarantees with automatic retries</p>
<p>✅ <strong>Flexible Routing</strong> - Topic exchanges with wildcard patterns</p>
<p>✅ <strong>AOT-Compatible</strong> - Source-generated JSON serialization</p>
<p>✅ <strong>Thread-Safe</strong> - Channel pooling for concurrent publishing</p>
<p>✅ <strong>Dead Letter Queues</strong> - Automatic failure handling and observability</p>
<p>✅ <strong>Production-Ready</strong> - Health checks, pause/resume, TestContainers integration</p>

<strong>Next Steps</strong>:
<ul><li><a href="#installation">Install and configure</a> the RabbitMQ transport</li>
<li>Review <a href="#usage">usage examples</a> for publishing and subscribing</li>
<li>Explore <a href="https://github.com/whizbang-lib/whizbang/tree/main/samples/ECommerce/tests/ECommerce.RabbitMQ.Integration.Tests">integration tests</a> for real-world patterns</li>
<li>Read <a href="#best-practices">best practices</a> for production deployments</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Tutorial</h2>
<article id="v1-0-0-tutorial-analytics-service" class="doc-section">
  <h3>Analytics Service</h3>
  <p class="doc-path"><code>v1.0.0/tutorial/analytics-service</code></p>
  <p class="doc-description"><em>Build the Analytics Worker - real-time analytics, time-series perspectives, and reporting dashboards</em></p>
  <div class="doc-content">

<h1>Analytics Service</h1>

<p>Build the <strong>Analytics Worker</strong> - a background service that subscribes to all domain events, aggregates metrics in real-time, and provides analytics dashboards.</p>

<p>:::note</p>
<p>This is <strong>Part 7</strong> of the ECommerce Tutorial. Complete <a href="customer-service.md">Customer Service</a> first.</p>
<p>:::</p>

<hr>

<h2>What You'll Build</h2>

<pre><code class="language-">┌──────────────────────────────────────────────────────────────┐
<p>│  Analytics Service Architecture                              │</p>
<p>│                                                               │</p>
<p>│  ┌─────────────┐                                             │</p>
<p>│  │Azure Service│  ALL domain events                          │</p>
<p>│  │     Bus     │  (OrderCreated, PaymentProcessed, etc.)     │</p>
<p>│  └──────┬──────┘                                             │</p>
<p>│         │                                                     │</p>
<p>│         ▼                                                     │</p>
<p>│  ┌────────────────────────────────────┐                      │</p>
<p>│  │  Time-Series Perspectives          │                      │</p>
<p>│  │  - DailySalesAnalyticsPerspective  │                      │</p>
<p>│  │  - HourlySalesAnalyticsPerspective │                      │</p>
<p>│  │  - ProductAnalyticsPerspective     │                      │</p>
<p>│  └──────────┬─────────────────────────┘                      │</p>
<p>│             │                                                 │</p>
<p>│             ▼                                                 │</p>
<p>│  ┌────────────────────────────────────┐                      │</p>
<p>│  │  PostgreSQL Time-Series Tables     │                      │</p>
<p>│  │  (Partitioned by date)             │                      │</p>
<p>│  └──────────┬─────────────────────────┘                      │</p>
<p>│             │                                                 │</p>
<p>│             ▼                                                 │</p>
<p>│  ┌────────────────────────────────────┐                      │</p>
<p>│  │  Analytics API (REST)              │                      │</p>
<p>│  │  GET /analytics/sales/daily        │                      │</p>
<p>│  │  GET /analytics/products/top       │                      │</p>
<p>│  └────────────────────────────────────┘                      │</p>
<p>└──────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Features</strong>:
<ul><li>✅ Real-time event aggregation</li>
<li>✅ Time-series perspectives (hourly, daily, monthly)</li>
<li>✅ Product performance analytics</li>
<li>✅ Customer cohort analysis</li>
<li>✅ Partitioned tables for performance</li>
<li>✅ Dashboard APIs</li>
</ul>
<hr>

<h2>Step 1: Database Schema (Time-Series Tables)</h2>

<h3>Daily Sales Analytics</h3>

<strong>ECommerce.AnalyticsWorker/Database/Migrations/001_CreateDailySalesAnalyticsTable.sql</strong>:

<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS daily_sales_analytics (
<p>  date DATE NOT NULL,</p>
<p>  total_orders BIGINT NOT NULL DEFAULT 0,</p>
<p>  total_revenue NUMERIC(12, 2) NOT NULL DEFAULT 0,</p>
<p>  total_items_sold BIGINT NOT NULL DEFAULT 0,</p>
<p>  avg_order_value NUMERIC(10, 2) NOT NULL DEFAULT 0,</p>
<p>  unique_customers BIGINT NOT NULL DEFAULT 0,</p>
<p>  created_at TIMESTAMP NOT NULL DEFAULT NOW(),</p>
<p>  updated_at TIMESTAMP NOT NULL DEFAULT NOW(),</p>
<p>  PRIMARY KEY (date)</p>
<p>) PARTITION BY RANGE (date);</p>

<p>-- Create partitions for current and next year</p>
<p>CREATE TABLE daily_sales_analytics_2024 PARTITION OF daily_sales_analytics</p>
<p>  FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');</p>

<p>CREATE TABLE daily_sales_analytics_2025 PARTITION OF daily_sales_analytics</p>
<p>  FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');</p>

<p>CREATE INDEX idx_daily_sales_date ON daily_sales_analytics(date DESC);</p>
<p></code></pre></p>

<h3>Hourly Sales Analytics</h3>

<strong>ECommerce.AnalyticsWorker/Database/Migrations/002_CreateHourlySalesAnalyticsTable.sql</strong>:

<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS hourly_sales_analytics (
<p>  hour TIMESTAMP NOT NULL,  -- Truncated to hour (e.g., 2024-12-12 10:00:00)</p>
<p>  total_orders BIGINT NOT NULL DEFAULT 0,</p>
<p>  total_revenue NUMERIC(12, 2) NOT NULL DEFAULT 0,</p>
<p>  created_at TIMESTAMP NOT NULL DEFAULT NOW(),</p>
<p>  updated_at TIMESTAMP NOT NULL DEFAULT NOW(),</p>
<p>  PRIMARY KEY (hour)</p>
<p>);</p>

<p>CREATE INDEX idx_hourly_sales_hour ON hourly_sales_analytics(hour DESC);</p>
<p></code></pre></p>

<h3>Product Analytics</h3>

<strong>ECommerce.AnalyticsWorker/Database/Migrations/003_CreateProductAnalyticsTable.sql</strong>:

<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS product_analytics (
<p>  product_id TEXT NOT NULL,</p>
<p>  date DATE NOT NULL,</p>
<p>  times_ordered BIGINT NOT NULL DEFAULT 0,</p>
<p>  units_sold BIGINT NOT NULL DEFAULT 0,</p>
<p>  total_revenue NUMERIC(12, 2) NOT NULL DEFAULT 0,</p>
<p>  created_at TIMESTAMP NOT NULL DEFAULT NOW(),</p>
<p>  updated_at TIMESTAMP NOT NULL DEFAULT NOW(),</p>
<p>  PRIMARY KEY (product_id, date)</p>
<p>) PARTITION BY RANGE (date);</p>

<p>-- Create partitions</p>
<p>CREATE TABLE product_analytics_2024 PARTITION OF product_analytics</p>
<p>  FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');</p>

<p>CREATE TABLE product_analytics_2025 PARTITION OF product_analytics</p>
<p>  FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');</p>

<p>CREATE INDEX idx_product_analytics_product_date ON product_analytics(product_id, date DESC);</p>
<p>CREATE INDEX idx_product_analytics_revenue ON product_analytics(total_revenue DESC);</p>
<p></code></pre></p>

<hr>

<h2>Step 2: Perspectives</h2>

<h3>Daily Sales Analytics Perspective</h3>

<strong>ECommerce.AnalyticsWorker/Perspectives/DailySalesAnalyticsPerspective.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;
<p>using ECommerce.Contracts.Events;</p>
<p>using Npgsql;</p>
<p>using Dapper;</p>

<p>namespace ECommerce.AnalyticsWorker.Perspectives;</p>

<p>public class DailySalesAnalyticsPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly ILogger<DailySalesAnalyticsPerspective> _logger;</p>

<p>  public DailySalesAnalyticsPerspective(</p>
<p>    NpgsqlConnection db,</p>
<p>    ILogger<DailySalesAnalyticsPerspective> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task HandleAsync(</p>
<p>    OrderCreated @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var date = @event.CreatedAt.Date;</p>

<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO daily_sales_analytics (</p>
<p>        date, total_orders, total_revenue, total_items_sold, avg_order_value, unique_customers, updated_at</p>
<p>      )</p>
<p>      VALUES (@Date, 1, @TotalAmount, @ItemCount, @TotalAmount, 1, NOW())</p>
<p>      ON CONFLICT (date) DO UPDATE SET</p>
<p>        total_orders = daily_sales_analytics.total_orders + 1,</p>
<p>        total_revenue = daily_sales_analytics.total_revenue + @TotalAmount,</p>
<p>        total_items_sold = daily_sales_analytics.total_items_sold + @ItemCount,</p>
<p>        avg_order_value = (daily_sales_analytics.total_revenue + @TotalAmount) / (daily_sales_analytics.total_orders + 1),</p>
<p>        updated_at = NOW()</p>
<p>      """,</p>
<p>      new {</p>
<p>        Date = date,</p>
<p>        TotalAmount = @event.TotalAmount,</p>
<p>        ItemCount = @event.Items.Sum(i => i.Quantity)</p>
<p>      }</p>
<p>    );</p>

<p>    _logger.LogInformation(</p>
<p>      "Daily sales analytics updated for {Date}: +${Amount}",</p>
<p>      date,</p>
<p>      @event.TotalAmount</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Hourly Sales Analytics Perspective</h3>

<strong>ECommerce.AnalyticsWorker/Perspectives/HourlySalesAnalyticsPerspective.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;
<p>using ECommerce.Contracts.Events;</p>
<p>using Npgsql;</p>
<p>using Dapper;</p>

<p>namespace ECommerce.AnalyticsWorker.Perspectives;</p>

<p>public class HourlySalesAnalyticsPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly ILogger<HourlySalesAnalyticsPerspective> _logger;</p>

<p>  public HourlySalesAnalyticsPerspective(</p>
<p>    NpgsqlConnection db,</p>
<p>    ILogger<HourlySalesAnalyticsPerspective> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task HandleAsync(</p>
<p>    OrderCreated @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    // Truncate to hour (e.g., 2024-12-12 10:00:00)</p>
<p>    var hour = new DateTime(</p>
<p>      @event.CreatedAt.Year,</p>
<p>      @event.CreatedAt.Month,</p>
<p>      @event.CreatedAt.Day,</p>
<p>      @event.CreatedAt.Hour,</p>
<p>      0,</p>
<p>      0</p>
<p>    );</p>

<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO hourly_sales_analytics (hour, total_orders, total_revenue, updated_at)</p>
<p>      VALUES (@Hour, 1, @TotalAmount, NOW())</p>
<p>      ON CONFLICT (hour) DO UPDATE SET</p>
<p>        total_orders = hourly_sales_analytics.total_orders + 1,</p>
<p>        total_revenue = hourly_sales_analytics.total_revenue + @TotalAmount,</p>
<p>        updated_at = NOW()</p>
<p>      """,</p>
<p>      new {</p>
<p>        Hour = hour,</p>
<p>        TotalAmount = @event.TotalAmount</p>
<p>      }</p>
<p>    );</p>

<p>    _logger.LogInformation(</p>
<p>      "Hourly sales analytics updated for {Hour}: +${Amount}",</p>
<p>      hour,</p>
<p>      @event.TotalAmount</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Product Analytics Perspective</h3>

<strong>ECommerce.AnalyticsWorker/Perspectives/ProductAnalyticsPerspective.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;
<p>using ECommerce.Contracts.Events;</p>
<p>using Npgsql;</p>
<p>using Dapper;</p>

<p>namespace ECommerce.AnalyticsWorker.Perspectives;</p>

<p>public class ProductAnalyticsPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly ILogger<ProductAnalyticsPerspective> _logger;</p>

<p>  public ProductAnalyticsPerspective(</p>
<p>    NpgsqlConnection db,</p>
<p>    ILogger<ProductAnalyticsPerspective> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task HandleAsync(</p>
<p>    OrderCreated @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var date = @event.CreatedAt.Date;</p>

<p>    // Update analytics for each product in the order</p>
<p>    foreach (var item in @event.Items) {</p>
<p>      await _db.ExecuteAsync(</p>
<p>        """</p>
<p>        INSERT INTO product_analytics (</p>
<p>          product_id, date, times_ordered, units_sold, total_revenue, updated_at</p>
<p>        )</p>
<p>        VALUES (@ProductId, @Date, 1, @Quantity, @LineTotal, NOW())</p>
<p>        ON CONFLICT (product_id, date) DO UPDATE SET</p>
<p>          times_ordered = product_analytics.times_ordered + 1,</p>
<p>          units_sold = product_analytics.units_sold + @Quantity,</p>
<p>          total_revenue = product_analytics.total_revenue + @LineTotal,</p>
<p>          updated_at = NOW()</p>
<p>        """,</p>
<p>        new {</p>
<p>          ProductId = item.ProductId,</p>
<p>          Date = date,</p>
<p>          Quantity = item.Quantity,</p>
<p>          LineTotal = item.LineTotal</p>
<p>        }</p>
<p>      );</p>

<p>      _logger.LogInformation(</p>
<p>        "Product analytics updated for {ProductId} on {Date}: +{Quantity} units, +${LineTotal}",</p>
<p>        item.ProductId,</p>
<p>        date,</p>
<p>        item.Quantity,</p>
<p>        item.LineTotal</p>
<p>      );</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Step 3: Analytics API</h2>

<h3>DTOs</h3>

<strong>ECommerce.AnalyticsWorker/Models/DailySalesDto.cs</strong>:

<pre><code class="language-csharp">namespace ECommerce.AnalyticsWorker.Models;

<p>public record DailySalesDto(</p>
<p>  DateTime Date,</p>
<p>  long TotalOrders,</p>
<p>  decimal TotalRevenue,</p>
<p>  long TotalItemsSold,</p>
<p>  decimal AvgOrderValue,</p>
<p>  long UniqueCustomers</p>
<p>);</p>
<p></code></pre></p>

<strong>ECommerce.AnalyticsWorker/Models/ProductPerformanceDto.cs</strong>:

<pre><code class="language-csharp">namespace ECommerce.AnalyticsWorker.Models;

<p>public record ProductPerformanceDto(</p>
<p>  string ProductId,</p>
<p>  long TimesOrdered,</p>
<p>  long UnitsSold,</p>
<p>  decimal TotalRevenue,</p>
<p>  decimal AvgRevenuePerOrder</p>
<p>);</p>
<p></code></pre></p>

<h3>Controllers</h3>

<strong>ECommerce.AnalyticsWorker/Controllers/AnalyticsController.cs</strong>:

<pre><code class="language-csharp">using Microsoft.AspNetCore.Mvc;
<p>using Npgsql;</p>
<p>using Dapper;</p>
<p>using ECommerce.AnalyticsWorker.Models;</p>

<p>namespace ECommerce.AnalyticsWorker.Controllers;</p>

<p>[ApiController]</p>
<p>[Route("api/[controller]")]</p>
<p>public class AnalyticsController : ControllerBase {</p>
<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly ILogger<AnalyticsController> _logger;</p>

<p>  public AnalyticsController(</p>
<p>    NpgsqlConnection db,</p>
<p>    ILogger<AnalyticsController> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  [HttpGet("sales/daily")]</p>
<p>  [ProducesResponseType(typeof(DailySalesDto[]), StatusCodes.Status200OK)]</p>
<p>  public async Task<IActionResult> GetDailySales(</p>
<p>    [FromQuery] DateTime? startDate = null,</p>
<p>    [FromQuery] DateTime? endDate = null</p>
<p>  ) {</p>
<p>    var start = startDate ?? DateTime.UtcNow.AddDays(-30).Date;</p>
<p>    var end = endDate ?? DateTime.UtcNow.Date;</p>

<p>    var sales = await _db.QueryAsync<DailySalesRow>(</p>
<p>      """</p>
<p>      SELECT date, total_orders, total_revenue, total_items_sold, avg_order_value, unique_customers</p>
<p>      FROM daily_sales_analytics</p>
<p>      WHERE date >= @StartDate AND date <= @EndDate</p>
<p>      ORDER BY date DESC</p>
<p>      """,</p>
<p>      new { StartDate = start, EndDate = end }</p>
<p>    );</p>

<p>    var dtos = sales.Select(s => new DailySalesDto(</p>
<p>      Date: s.Date,</p>
<p>      TotalOrders: s.TotalOrders,</p>
<p>      TotalRevenue: s.TotalRevenue,</p>
<p>      TotalItemsSold: s.TotalItemsSold,</p>
<p>      AvgOrderValue: s.AvgOrderValue,</p>
<p>      UniqueCustomers: s.UniqueCustomers</p>
<p>    )).ToArray();</p>

<p>    return Ok(dtos);</p>
<p>  }</p>

<p>  [HttpGet("sales/hourly")]</p>
<p>  [ProducesResponseType(typeof(HourlySalesDto[]), StatusCodes.Status200OK)]</p>
<p>  public async Task<IActionResult> GetHourlySales(</p>
<p>    [FromQuery] DateTime? date = null</p>
<p>  ) {</p>
<p>    var targetDate = date ?? DateTime.UtcNow.Date;</p>
<p>    var startHour = targetDate;</p>
<p>    var endHour = targetDate.AddDays(1);</p>

<p>    var sales = await _db.QueryAsync<HourlySalesRow>(</p>
<p>      """</p>
<p>      SELECT hour, total_orders, total_revenue</p>
<p>      FROM hourly_sales_analytics</p>
<p>      WHERE hour >= @StartHour AND hour < @EndHour</p>
<p>      ORDER BY hour ASC</p>
<p>      """,</p>
<p>      new { StartHour = startHour, EndHour = endHour }</p>
<p>    );</p>

<p>    var dtos = sales.Select(s => new HourlySalesDto(</p>
<p>      Hour: s.Hour,</p>
<p>      TotalOrders: s.TotalOrders,</p>
<p>      TotalRevenue: s.TotalRevenue</p>
<p>    )).ToArray();</p>

<p>    return Ok(dtos);</p>
<p>  }</p>

<p>  [HttpGet("products/top")]</p>
<p>  [ProducesResponseType(typeof(ProductPerformanceDto[]), StatusCodes.Status200OK)]</p>
<p>  public async Task<IActionResult> GetTopProducts(</p>
<p>    [FromQuery] DateTime? startDate = null,</p>
<p>    [FromQuery] DateTime? endDate = null,</p>
<p>    [FromQuery] int limit = 10</p>
<p>  ) {</p>
<p>    var start = startDate ?? DateTime.UtcNow.AddDays(-30).Date;</p>
<p>    var end = endDate ?? DateTime.UtcNow.Date;</p>

<p>    var products = await _db.QueryAsync<ProductAnalyticsRow>(</p>
<p>      """</p>
<p>      SELECT</p>
<p>        product_id,</p>
<p>        SUM(times_ordered) AS times_ordered,</p>
<p>        SUM(units_sold) AS units_sold,</p>
<p>        SUM(total_revenue) AS total_revenue</p>
<p>      FROM product_analytics</p>
<p>      WHERE date >= @StartDate AND date <= @EndDate</p>
<p>      GROUP BY product_id</p>
<p>      ORDER BY total_revenue DESC</p>
<p>      LIMIT @Limit</p>
<p>      """,</p>
<p>      new { StartDate = start, EndDate = end, Limit = limit }</p>
<p>    );</p>

<p>    var dtos = products.Select(p => new ProductPerformanceDto(</p>
<p>      ProductId: p.ProductId,</p>
<p>      TimesOrdered: p.TimesOrdered,</p>
<p>      UnitsSold: p.UnitsSold,</p>
<p>      TotalRevenue: p.TotalRevenue,</p>
<p>      AvgRevenuePerOrder: p.TimesOrdered > 0 ? p.TotalRevenue / p.TimesOrdered : 0</p>
<p>    )).ToArray();</p>

<p>    return Ok(dtos);</p>
<p>  }</p>
<p>}</p>

<p>public record DailySalesRow(</p>
<p>  DateTime Date,</p>
<p>  long TotalOrders,</p>
<p>  decimal TotalRevenue,</p>
<p>  long TotalItemsSold,</p>
<p>  decimal AvgOrderValue,</p>
<p>  long UniqueCustomers</p>
<p>);</p>

<p>public record HourlySalesDto(</p>
<p>  DateTime Hour,</p>
<p>  long TotalOrders,</p>
<p>  decimal TotalRevenue</p>
<p>);</p>

<p>public record HourlySalesRow(</p>
<p>  DateTime Hour,</p>
<p>  long TotalOrders,</p>
<p>  decimal TotalRevenue</p>
<p>);</p>

<p>public record ProductAnalyticsRow(</p>
<p>  string ProductId,</p>
<p>  long TimesOrdered,</p>
<p>  long UnitsSold,</p>
<p>  decimal TotalRevenue</p>
<p>);</p>
<p></code></pre></p>

<hr>

<h2>Step 4: Service Configuration</h2>

<strong>ECommerce.AnalyticsWorker/Program.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;
<p>using Whizbang.Data.Postgres;</p>
<p>using Whizbang.Transports.AzureServiceBus;</p>
<p>using Npgsql;</p>

<p>var builder = WebApplication.CreateBuilder(args);</p>

<p>// 1. Add Whizbang</p>
<p>builder.Services.AddWhizbang(options => {</p>
<p>  options.ServiceName = "AnalyticsWorker";</p>
<p>  options.EnableInbox = true;</p>
<p>});</p>

<p>// 2. Add PostgreSQL</p>
<p>builder.Services.AddScoped<NpgsqlConnection>(sp => {</p>
<p>  var connectionString = builder.Configuration.GetConnectionString("AnalyticsDb");</p>
<p>  return new NpgsqlConnection(connectionString);</p>
<p>});</p>

<p>// 3. Add Azure Service Bus</p>
<p>builder.AddAzureServiceBus("messaging");</p>

<p>// 4. Add controllers</p>
<p>builder.Services.AddControllers();</p>
<p>builder.Services.AddEndpointsApiExplorer();</p>
<p>builder.Services.AddSwaggerGen();</p>

<p>var app = builder.Build();</p>

<p>if (app.Environment.IsDevelopment()) {</p>
<p>  app.UseSwagger();</p>
<p>  app.UseSwaggerUI();</p>
<p>}</p>

<p>app.UseHttpsRedirection();</p>
<p>app.UseAuthorization();</p>
<p>app.MapControllers();</p>

<p>await app.MigrateDatabaseAsync();</p>
<p>app.Run();</p>
<p></code></pre></p>

<hr>

<h2>Step 5: Test Analytics</h2>

<h3>1. Create Orders (Generate Data)</h3>

<pre><code class="language-bash"># Create 10 orders
<p>for i in {1..10}; do</p>
<p>  curl -X POST http://localhost:5000/api/orders \</p>
<p>    -H "Content-Type: application/json" \</p>
<p>    -d '{ "customerId": "cust-'$i'", ... }'</p>
<p>  sleep 1</p>
<p>done</p>
<p></code></pre></p>

<h3>2. Query Daily Sales</h3>

<pre><code class="language-bash">curl "http://localhost:5002/api/analytics/sales/daily?startDate=2024-12-01&endDate=2024-12-31"
<p></code></pre></p>

<strong>Response</strong>:

<pre><code class="language-json">[
<p>  {</p>
<p>    "date": "2024-12-12",</p>
<p>    "totalOrders": 10,</p>
<p>    "totalRevenue": 399.80,</p>
<p>    "totalItemsSold": 20,</p>
<p>    "avgOrderValue": 39.98,</p>
<p>    "uniqueCustomers": 10</p>
<p>  }</p>
<p>]</p>
<p></code></pre></p>

<h3>3. Query Hourly Sales</h3>

<pre><code class="language-bash">curl "http://localhost:5002/api/analytics/sales/hourly?date=2024-12-12"
<p></code></pre></p>

<strong>Response</strong>:

<pre><code class="language-json">[
<p>  { "hour": "2024-12-12T10:00:00Z", "totalOrders": 3, "totalRevenue": 119.94 },</p>
<p>  { "hour": "2024-12-12T11:00:00Z", "totalOrders": 5, "totalRevenue": 199.90 },</p>
<p>  { "hour": "2024-12-12T12:00:00Z", "totalOrders": 2, "totalRevenue": 79.96 }</p>
<p>]</p>
<p></code></pre></p>

<h3>4. Query Top Products</h3>

<pre><code class="language-bash">curl "http://localhost:5002/api/analytics/products/top?limit=5"
<p></code></pre></p>

<strong>Response</strong>:

<pre><code class="language-json">[
<p>  {</p>
<p>    "productId": "prod-456",</p>
<p>    "timesOrdered": 8,</p>
<p>    "unitsSold": 16,</p>
<p>    "totalRevenue": 319.84,</p>
<p>    "avgRevenuePerOrder": 39.98</p>
<p>  },</p>
<p>  {</p>
<p>    "productId": "prod-789",</p>
<p>    "timesOrdered": 2,</p>
<p>    "unitsSold": 2,</p>
<p>    "totalRevenue": 99.98,</p>
<p>    "avgRevenuePerOrder": 49.99</p>
<p>  }</p>
<p>]</p>
<p></code></pre></p>

<hr>

<h2>Key Concepts</h2>

<h3>Time-Series Perspectives</h3>

<pre><code class="language-csharp">// Truncate timestamp to hour for hourly aggregation
<p>var hour = new DateTime(</p>
<p>  @event.CreatedAt.Year,</p>
<p>  @event.CreatedAt.Month,</p>
<p>  @event.CreatedAt.Day,</p>
<p>  @event.CreatedAt.Hour,</p>
<p>  0,</p>
<p>  0</p>
<p>);</p>

<p>// Upsert with aggregation</p>
<p>INSERT INTO hourly_sales_analytics (hour, total_orders, total_revenue)</p>
<p>VALUES (@Hour, 1, @TotalAmount)</p>
<p>ON CONFLICT (hour) DO UPDATE SET</p>
<p>  total_orders = hourly_sales_analytics.total_orders + 1,</p>
<p>  total_revenue = hourly_sales_analytics.total_revenue + @TotalAmount</p>
<p></code></pre></p>

<strong>Result</strong>: Real-time hourly metrics without batch processing.

<h3>Partitioned Tables</h3>

<pre><code class="language-sql">CREATE TABLE daily_sales_analytics (...)
<p>PARTITION BY RANGE (date);</p>

<p>-- Separate physical tables per year</p>
<p>CREATE TABLE daily_sales_analytics_2024 PARTITION OF daily_sales_analytics</p>
<p>  FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ <strong>Performance</strong>: Queries only scan relevant partitions</li>
<li>✅ <strong>Maintenance</strong>: Drop old partitions easily (e.g., GDPR retention)</li>
<li>✅ <strong>Scalability</strong>: Add future partitions dynamically</li>
</ul>
<hr>

<h2>Advanced: Materialized Views</h2>

<p>For complex aggregations, use materialized views:</p>

<strong>ECommerce.AnalyticsWorker/Database/Migrations/004_CreateMaterializedViews.sql</strong>:

<pre><code class="language-sql">CREATE MATERIALIZED VIEW monthly_sales_summary AS
<p>SELECT</p>
<p>  DATE_TRUNC('month', date) AS month,</p>
<p>  SUM(total_orders) AS total_orders,</p>
<p>  SUM(total_revenue) AS total_revenue,</p>
<p>  AVG(avg_order_value) AS avg_order_value</p>
<p>FROM daily_sales_analytics</p>
<p>GROUP BY DATE_TRUNC('month', date)</p>
<p>ORDER BY month DESC;</p>

<p>CREATE UNIQUE INDEX idx_monthly_sales_month ON monthly_sales_summary(month);</p>

<p>-- Refresh monthly (can be automated via background job)</p>
<p>REFRESH MATERIALIZED VIEW CONCURRENTLY monthly_sales_summary;</p>
<p></code></pre></p>

<hr>

<h2>Testing</h2>

<h3>Unit Test - Daily Sales Perspective</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task DailySalesPerspective_OrderCreated_UpdatesDailySalesAsync() {</p>
<p>  // Arrange</p>
<p>  var db = new MockNpgsqlConnection();</p>
<p>  var perspective = new DailySalesAnalyticsPerspective(db, mockLogger);</p>
<p>  var @event = new OrderCreated(</p>
<p>    OrderId: "order-123",</p>
<p>    CustomerId: "cust-456",</p>
<p>    Items: [new OrderItem("prod-789", 2, 19.99m, 39.98m)],</p>
<p>    TotalAmount: 39.98m,</p>
<p>    CreatedAt: new DateTime(2024, 12, 12, 10, 30, 0)</p>
<p>    // ... other fields</p>
<p>  );</p>

<p>  // Act</p>
<p>  await perspective.HandleAsync(@event);</p>

<p>  // Assert</p>
<p>  var sales = db.GetDailySales(new DateTime(2024, 12, 12));</p>
<p>  await Assert.That(sales.TotalOrders).IsEqualTo(1);</p>
<p>  await Assert.That(sales.TotalRevenue).IsEqualTo(39.98m);</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Next Steps</h2>

<p>Continue to <strong><a href="testing-strategy.md">Testing Strategy</a></strong> to:</p>
<ul><li>Write unit tests for receptors and perspectives</li>
<li>Implement integration tests for event flows</li>
<li>Create end-to-end tests for full order lifecycle</li>
<li>Set up test fixtures and mocks</li>
</ul>
<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>Time-Series Perspectives</strong> - Real-time aggregation with hour/day truncation</p>
<p>✅ <strong>Partitioned Tables</strong> - Performance optimization for large datasets</p>
<p>✅ <strong>Event Aggregation</strong> - Single perspective handles all analytics</p>
<p>✅ <strong>Dashboard APIs</strong> - REST endpoints for frontend dashboards</p>
<p>✅ <strong>Materialized Views</strong> - Pre-computed complex aggregations</p>

<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-tutorial-customer-service" class="doc-section">
  <h3>Customer Service (BFF)</h3>
  <p class="doc-path"><code>v1.0.0/tutorial/customer-service</code></p>
  <p class="doc-description"><em>Build the Customer Service BFF - perspectives, read models, CQRS query side, and GraphQL API</em></p>
  <div class="doc-content">

<h1>Customer Service (BFF)</h1>

<p>Build the <strong>Customer Service</strong> - a Backend for Frontend (BFF) API that provides denormalized read models via <strong>Perspectives</strong>, demonstrating the query side of CQRS.</p>

<p>:::note</p>
<p>This is <strong>Part 6</strong> of the ECommerce Tutorial. Complete <a href="shipping-service.md">Shipping Service</a> first.</p>
<p>:::</p>

<hr>

<h2>What You'll Build</h2>

<pre><code class="language-">┌──────────────────────────────────────────────────────────────┐
<p>│  Customer Service Architecture (BFF)                         │</p>
<p>│                                                               │</p>
<p>│  ┌─────────────┐                                             │</p>
<p>│  │Azure Service│  OrderCreated, PaymentProcessed, etc.       │</p>
<p>│  │     Bus     │──────────────────────────┐                  │</p>
<p>│  └─────────────┘                          │                  │</p>
<p>│                                            ▼                  │</p>
<p>│                          ┌────────────────────────────┐      │</p>
<p>│                          │  Perspectives (Event       │      │</p>
<p>│                          │  Handlers for Read Models) │      │</p>
<p>│                          │  - OrderSummaryPerspective │      │</p>
<p>│                          │  - CustomerActivityPersp.  │      │</p>
<p>│                          └──────────┬─────────────────┘      │</p>
<p>│                                     │                         │</p>
<p>│                                     ▼                         │</p>
<p>│                          ┌────────────────────────┐          │</p>
<p>│                          │  PostgreSQL Read Models│          │</p>
<p>│                          │  (Denormalized Views)  │          │</p>
<p>│                          └──────────┬─────────────┘          │</p>
<p>│                                     │                         │</p>
<p>│                                     ▼                         │</p>
<p>│  ┌──────────────┐        ┌────────────────────────┐          │</p>
<p>│  │  HTTP Client │───────▶│  HTTP API (REST)       │          │</p>
<p>│  │  (Frontend)  │        │  GET /customers/{id}   │          │</p>
<p>│  └──────────────┘        │  GET /orders/{id}      │          │</p>
<p>│                          └────────────────────────┘          │</p>
<p>└──────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Features</strong>:
<ul><li>✅ Perspectives (event-driven read models)</li>
<li>✅ Denormalized views (fast queries)</li>
<li>✅ CQRS query side</li>
<li>✅ BFF pattern (tailored to frontend needs)</li>
<li>✅ REST API with rich DTOs</li>
<li>✅ Event sourcing with time-travel queries</li>
</ul>
<hr>

<h2>Step 1: Database Schema (Read Models)</h2>

<h3>Order Summary View</h3>

<strong>ECommerce.CustomerService.API/Database/Migrations/001_CreateOrderSummaryTable.sql</strong>:

<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS order_summary (
<p>  order_id TEXT PRIMARY KEY,</p>
<p>  customer_id TEXT NOT NULL,</p>
<p>  total_amount NUMERIC(10, 2) NOT NULL,</p>
<p>  status TEXT NOT NULL,  -- 'Pending', 'PaymentProcessed', 'Shipped', 'Delivered', 'Cancelled'</p>
<p>  item_count INTEGER NOT NULL,</p>
<p>  shipping_address JSONB NOT NULL,</p>
<p>  created_at TIMESTAMP NOT NULL,</p>
<p>  payment_id TEXT,</p>
<p>  payment_status TEXT,</p>
<p>  payment_processed_at TIMESTAMP,</p>
<p>  shipment_id TEXT,</p>
<p>  tracking_number TEXT,</p>
<p>  estimated_delivery TIMESTAMP,</p>
<p>  actual_delivery TIMESTAMP,</p>
<p>  updated_at TIMESTAMP NOT NULL DEFAULT NOW()</p>
<p>);</p>

<p>CREATE INDEX idx_order_summary_customer_id ON order_summary(customer_id);</p>
<p>CREATE INDEX idx_order_summary_status ON order_summary(status);</p>
<p>CREATE INDEX idx_order_summary_created_at ON order_summary(created_at DESC);</p>
<p></code></pre></p>

<h3>Customer Activity View</h3>

<strong>ECommerce.CustomerService.API/Database/Migrations/002_CreateCustomerActivityTable.sql</strong>:

<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS customer_activity (
<p>  customer_id TEXT PRIMARY KEY,</p>
<p>  total_orders INTEGER NOT NULL DEFAULT 0,</p>
<p>  total_spent NUMERIC(10, 2) NOT NULL DEFAULT 0,</p>
<p>  last_order_id TEXT,</p>
<p>  last_order_at TIMESTAMP,</p>
<p>  first_order_at TIMESTAMP,</p>
<p>  updated_at TIMESTAMP NOT NULL DEFAULT NOW()</p>
<p>);</p>

<p>CREATE INDEX idx_customer_activity_total_spent ON customer_activity(total_spent DESC);</p>
<p>CREATE INDEX idx_customer_activity_last_order_at ON customer_activity(last_order_at DESC);</p>
<p></code></pre></p>

<hr>

<h2>Step 2: Perspectives</h2>

<h3>Order Summary Perspective</h3>

<strong>ECommerce.CustomerService.API/Perspectives/OrderSummaryPerspective.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;
<p>using ECommerce.Contracts.Events;</p>
<p>using Npgsql;</p>
<p>using Dapper;</p>

<p>namespace ECommerce.CustomerService.API.Perspectives;</p>

<p>public class OrderSummaryPerspective :</p>
<p>  IPerspectiveOf<OrderCreated>,</p>
<p>  IPerspectiveOf<PaymentProcessed>,</p>
<p>  IPerspectiveOf<ShipmentCreated> {</p>

<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly ILogger<OrderSummaryPerspective> _logger;</p>

<p>  public OrderSummaryPerspective(</p>
<p>    NpgsqlConnection db,</p>
<p>    ILogger<OrderSummaryPerspective> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  // Handle OrderCreated event</p>
<p>  public async Task HandleAsync(</p>
<p>    OrderCreated @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO order_summary (</p>
<p>        order_id, customer_id, total_amount, status, item_count, shipping_address, created_at, updated_at</p>
<p>      )</p>
<p>      VALUES (@OrderId, @CustomerId, @TotalAmount, @Status, @ItemCount, @ShippingAddress::jsonb, @CreatedAt, NOW())</p>
<p>      ON CONFLICT (order_id) DO UPDATE SET</p>
<p>        updated_at = NOW()</p>
<p>      """,</p>
<p>      new {</p>
<p>        OrderId = @event.OrderId,</p>
<p>        CustomerId = @event.CustomerId,</p>
<p>        TotalAmount = @event.TotalAmount,</p>
<p>        Status = "Pending",</p>
<p>        ItemCount = @event.Items.Length,</p>
<p>        ShippingAddress = System.Text.Json.JsonSerializer.Serialize(@event.ShippingAddress),</p>
<p>        CreatedAt = @event.CreatedAt</p>
<p>      }</p>
<p>    );</p>

<p>    _logger.LogInformation(</p>
<p>      "Order summary created for order {OrderId}",</p>
<p>      @event.OrderId</p>
<p>    );</p>
<p>  }</p>

<p>  // Handle PaymentProcessed event</p>
<p>  public async Task HandleAsync(</p>
<p>    PaymentProcessed @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      UPDATE order_summary</p>
<p>      SET</p>
<p>        status = 'PaymentProcessed',</p>
<p>        payment_id = @PaymentId,</p>
<p>        payment_status = @PaymentStatus,</p>
<p>        payment_processed_at = @ProcessedAt,</p>
<p>        updated_at = NOW()</p>
<p>      WHERE order_id = @OrderId</p>
<p>      """,</p>
<p>      new {</p>
<p>        OrderId = @event.OrderId,</p>
<p>        PaymentId = @event.PaymentId,</p>
<p>        PaymentStatus = @event.Status.ToString(),</p>
<p>        ProcessedAt = @event.ProcessedAt</p>
<p>      }</p>
<p>    );</p>

<p>    _logger.LogInformation(</p>
<p>      "Order summary updated with payment for order {OrderId}",</p>
<p>      @event.OrderId</p>
<p>    );</p>
<p>  }</p>

<p>  // Handle ShipmentCreated event</p>
<p>  public async Task HandleAsync(</p>
<p>    ShipmentCreated @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      UPDATE order_summary</p>
<p>      SET</p>
<p>        status = 'Shipped',</p>
<p>        shipment_id = @ShipmentId,</p>
<p>        tracking_number = @TrackingNumber,</p>
<p>        estimated_delivery = @EstimatedDelivery,</p>
<p>        updated_at = NOW()</p>
<p>      WHERE order_id = @OrderId</p>
<p>      """,</p>
<p>      new {</p>
<p>        OrderId = @event.OrderId,</p>
<p>        ShipmentId = @event.ShipmentId,</p>
<p>        TrackingNumber = @event.TrackingNumber,</p>
<p>        EstimatedDelivery = @event.EstimatedDelivery</p>
<p>      }</p>
<p>    );</p>

<p>    _logger.LogInformation(</p>
<p>      "Order summary updated with shipment for order {OrderId}",</p>
<p>      @event.OrderId</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key pattern</strong>: <strong>Single perspective handles multiple events</strong> to build a denormalized view.

<h3>Customer Activity Perspective</h3>

<strong>ECommerce.CustomerService.API/Perspectives/CustomerActivityPerspective.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;
<p>using ECommerce.Contracts.Events;</p>
<p>using Npgsql;</p>
<p>using Dapper;</p>

<p>namespace ECommerce.CustomerService.API.Perspectives;</p>

<p>public class CustomerActivityPerspective : IPerspectiveOf<OrderCreated> {</p>
<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly ILogger<CustomerActivityPerspective> _logger;</p>

<p>  public CustomerActivityPerspective(</p>
<p>    NpgsqlConnection db,</p>
<p>    ILogger<CustomerActivityPerspective> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task HandleAsync(</p>
<p>    OrderCreated @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO customer_activity (</p>
<p>        customer_id, total_orders, total_spent, last_order_id, last_order_at, first_order_at, updated_at</p>
<p>      )</p>
<p>      VALUES (@CustomerId, 1, @TotalAmount, @OrderId, @CreatedAt, @CreatedAt, NOW())</p>
<p>      ON CONFLICT (customer_id) DO UPDATE SET</p>
<p>        total_orders = customer_activity.total_orders + 1,</p>
<p>        total_spent = customer_activity.total_spent + @TotalAmount,</p>
<p>        last_order_id = @OrderId,</p>
<p>        last_order_at = @CreatedAt,</p>
<p>        updated_at = NOW()</p>
<p>      """,</p>
<p>      new {</p>
<p>        CustomerId = @event.CustomerId,</p>
<p>        TotalAmount = @event.TotalAmount,</p>
<p>        OrderId = @event.OrderId,</p>
<p>        CreatedAt = @event.CreatedAt</p>
<p>      }</p>
<p>    );</p>

<p>    _logger.LogInformation(</p>
<p>      "Customer activity updated for customer {CustomerId}",</p>
<p>      @event.CustomerId</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Step 3: HTTP API</h2>

<h3>DTOs</h3>

<strong>ECommerce.CustomerService.API/Models/OrderSummaryDto.cs</strong>:

<pre><code class="language-csharp">namespace ECommerce.CustomerService.API.Models;

<p>public record OrderSummaryDto(</p>
<p>  string OrderId,</p>
<p>  string CustomerId,</p>
<p>  decimal TotalAmount,</p>
<p>  string Status,</p>
<p>  int ItemCount,</p>
<p>  ShippingAddressDto ShippingAddress,</p>
<p>  DateTime CreatedAt,</p>
<p>  PaymentInfoDto? PaymentInfo,</p>
<p>  ShipmentInfoDto? ShipmentInfo</p>
<p>);</p>

<p>public record ShippingAddressDto(</p>
<p>  string Street,</p>
<p>  string City,</p>
<p>  string State,</p>
<p>  string ZipCode,</p>
<p>  string Country</p>
<p>);</p>

<p>public record PaymentInfoDto(</p>
<p>  string PaymentId,</p>
<p>  string Status,</p>
<p>  DateTime ProcessedAt</p>
<p>);</p>

<p>public record ShipmentInfoDto(</p>
<p>  string ShipmentId,</p>
<p>  string TrackingNumber,</p>
<p>  DateTime EstimatedDelivery,</p>
<p>  DateTime? ActualDelivery</p>
<p>);</p>
<p></code></pre></p>

<strong>ECommerce.CustomerService.API/Models/CustomerActivityDto.cs</strong>:

<pre><code class="language-csharp">namespace ECommerce.CustomerService.API.Models;

<p>public record CustomerActivityDto(</p>
<p>  string CustomerId,</p>
<p>  int TotalOrders,</p>
<p>  decimal TotalSpent,</p>
<p>  string? LastOrderId,</p>
<p>  DateTime? LastOrderAt,</p>
<p>  DateTime? FirstOrderAt</p>
<p>);</p>
<p></code></pre></p>

<h3>Controllers</h3>

<strong>ECommerce.CustomerService.API/Controllers/CustomersController.cs</strong>:

<pre><code class="language-csharp">using Microsoft.AspNetCore.Mvc;
<p>using Npgsql;</p>
<p>using Dapper;</p>
<p>using ECommerce.CustomerService.API.Models;</p>

<p>namespace ECommerce.CustomerService.API.Controllers;</p>

<p>[ApiController]</p>
<p>[Route("api/[controller]")]</p>
<p>public class CustomersController : ControllerBase {</p>
<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly ILogger<CustomersController> _logger;</p>

<p>  public CustomersController(</p>
<p>    NpgsqlConnection db,</p>
<p>    ILogger<CustomersController> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  [HttpGet("{customerId}")]</p>
<p>  [ProducesResponseType(typeof(CustomerActivityDto), StatusCodes.Status200OK)]</p>
<p>  [ProducesResponseType(StatusCodes.Status404NotFound)]</p>
<p>  public async Task<IActionResult> GetCustomer(string customerId) {</p>
<p>    var customer = await _db.QuerySingleOrDefaultAsync<CustomerActivityRow>(</p>
<p>      """</p>
<p>      SELECT customer_id, total_orders, total_spent, last_order_id, last_order_at, first_order_at</p>
<p>      FROM customer_activity</p>
<p>      WHERE customer_id = @CustomerId</p>
<p>      """,</p>
<p>      new { CustomerId = customerId }</p>
<p>    );</p>

<p>    if (customer == null) {</p>
<p>      return NotFound();</p>
<p>    }</p>

<p>    return Ok(new CustomerActivityDto(</p>
<p>      CustomerId: customer.CustomerId,</p>
<p>      TotalOrders: customer.TotalOrders,</p>
<p>      TotalSpent: customer.TotalSpent,</p>
<p>      LastOrderId: customer.LastOrderId,</p>
<p>      LastOrderAt: customer.LastOrderAt,</p>
<p>      FirstOrderAt: customer.FirstOrderAt</p>
<p>    ));</p>
<p>  }</p>

<p>  [HttpGet("{customerId}/orders")]</p>
<p>  [ProducesResponseType(typeof(OrderSummaryDto[]), StatusCodes.Status200OK)]</p>
<p>  public async Task<IActionResult> GetCustomerOrders(string customerId) {</p>
<p>    var orders = await _db.QueryAsync<OrderSummaryRow>(</p>
<p>      """</p>
<p>      SELECT</p>
<p>        order_id, customer_id, total_amount, status, item_count, shipping_address,</p>
<p>        created_at, payment_id, payment_status, payment_processed_at,</p>
<p>        shipment_id, tracking_number, estimated_delivery, actual_delivery</p>
<p>      FROM order_summary</p>
<p>      WHERE customer_id = @CustomerId</p>
<p>      ORDER BY created_at DESC</p>
<p>      """,</p>
<p>      new { CustomerId = customerId }</p>
<p>    );</p>

<p>    var dtos = orders.Select(o => new OrderSummaryDto(</p>
<p>      OrderId: o.OrderId,</p>
<p>      CustomerId: o.CustomerId,</p>
<p>      TotalAmount: o.TotalAmount,</p>
<p>      Status: o.Status,</p>
<p>      ItemCount: o.ItemCount,</p>
<p>      ShippingAddress: System.Text.Json.JsonSerializer.Deserialize<ShippingAddressDto>(o.ShippingAddress)!,</p>
<p>      CreatedAt: o.CreatedAt,</p>
<p>      PaymentInfo: o.PaymentId != null ? new PaymentInfoDto(</p>
<p>        PaymentId: o.PaymentId,</p>
<p>        Status: o.PaymentStatus!,</p>
<p>        ProcessedAt: o.PaymentProcessedAt!.Value</p>
<p>      ) : null,</p>
<p>      ShipmentInfo: o.ShipmentId != null ? new ShipmentInfoDto(</p>
<p>        ShipmentId: o.ShipmentId,</p>
<p>        TrackingNumber: o.TrackingNumber!,</p>
<p>        EstimatedDelivery: o.EstimatedDelivery!.Value,</p>
<p>        ActualDelivery: o.ActualDelivery</p>
<p>      ) : null</p>
<p>    )).ToArray();</p>

<p>    return Ok(dtos);</p>
<p>  }</p>
<p>}</p>

<p>public record CustomerActivityRow(</p>
<p>  string CustomerId,</p>
<p>  int TotalOrders,</p>
<p>  decimal TotalSpent,</p>
<p>  string? LastOrderId,</p>
<p>  DateTime? LastOrderAt,</p>
<p>  DateTime? FirstOrderAt</p>
<p>);</p>

<p>public record OrderSummaryRow(</p>
<p>  string OrderId,</p>
<p>  string CustomerId,</p>
<p>  decimal TotalAmount,</p>
<p>  string Status,</p>
<p>  int ItemCount,</p>
<p>  string ShippingAddress,  // JSONB</p>
<p>  DateTime CreatedAt,</p>
<p>  string? PaymentId,</p>
<p>  string? PaymentStatus,</p>
<p>  DateTime? PaymentProcessedAt,</p>
<p>  string? ShipmentId,</p>
<p>  string? TrackingNumber,</p>
<p>  DateTime? EstimatedDelivery,</p>
<p>  DateTime? ActualDelivery</p>
<p>);</p>
<p></code></pre></p>

<strong>ECommerce.CustomerService.API/Controllers/OrdersController.cs</strong>:

<pre><code class="language-csharp">using Microsoft.AspNetCore.Mvc;
<p>using Npgsql;</p>
<p>using Dapper;</p>
<p>using ECommerce.CustomerService.API.Models;</p>

<p>namespace ECommerce.CustomerService.API.Controllers;</p>

<p>[ApiController]</p>
<p>[Route("api/[controller]")]</p>
<p>public class OrdersController : ControllerBase {</p>
<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly ILogger<OrdersController> _logger;</p>

<p>  public OrdersController(</p>
<p>    NpgsqlConnection db,</p>
<p>    ILogger<OrdersController> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  [HttpGet("{orderId}")]</p>
<p>  [ProducesResponseType(typeof(OrderSummaryDto), StatusCodes.Status200OK)]</p>
<p>  [ProducesResponseType(StatusCodes.Status404NotFound)]</p>
<p>  public async Task<IActionResult> GetOrder(string orderId) {</p>
<p>    var order = await _db.QuerySingleOrDefaultAsync<OrderSummaryRow>(</p>
<p>      """</p>
<p>      SELECT</p>
<p>        order_id, customer_id, total_amount, status, item_count, shipping_address,</p>
<p>        created_at, payment_id, payment_status, payment_processed_at,</p>
<p>        shipment_id, tracking_number, estimated_delivery, actual_delivery</p>
<p>      FROM order_summary</p>
<p>      WHERE order_id = @OrderId</p>
<p>      """,</p>
<p>      new { OrderId = orderId }</p>
<p>    );</p>

<p>    if (order == null) {</p>
<p>      return NotFound();</p>
<p>    }</p>

<p>    return Ok(new OrderSummaryDto(</p>
<p>      OrderId: order.OrderId,</p>
<p>      CustomerId: order.CustomerId,</p>
<p>      TotalAmount: order.TotalAmount,</p>
<p>      Status: order.Status,</p>
<p>      ItemCount: order.ItemCount,</p>
<p>      ShippingAddress: System.Text.Json.JsonSerializer.Deserialize<ShippingAddressDto>(order.ShippingAddress)!,</p>
<p>      CreatedAt: order.CreatedAt,</p>
<p>      PaymentInfo: order.PaymentId != null ? new PaymentInfoDto(</p>
<p>        PaymentId: order.PaymentId,</p>
<p>        Status: order.PaymentStatus!,</p>
<p>        ProcessedAt: order.PaymentProcessedAt!.Value</p>
<p>      ) : null,</p>
<p>      ShipmentInfo: order.ShipmentId != null ? new ShipmentInfoDto(</p>
<p>        ShipmentId: order.ShipmentId,</p>
<p>        TrackingNumber: order.TrackingNumber!,</p>
<p>        EstimatedDelivery: order.EstimatedDelivery!.Value,</p>
<p>        ActualDelivery: order.ActualDelivery</p>
<p>      ) : null</p>
<p>    ));</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Step 4: Service Configuration</h2>

<strong>ECommerce.CustomerService.API/Program.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;
<p>using Whizbang.Data.Postgres;</p>
<p>using Whizbang.Transports.AzureServiceBus;</p>
<p>using Npgsql;</p>

<p>var builder = WebApplication.CreateBuilder(args);</p>

<p>// 1. Add Whizbang</p>
<p>builder.Services.AddWhizbang(options => {</p>
<p>  options.ServiceName = "CustomerService";</p>
<p>  options.EnableInbox = true;</p>
<p>});</p>

<p>// 2. Add PostgreSQL</p>
<p>builder.Services.AddScoped<NpgsqlConnection>(sp => {</p>
<p>  var connectionString = builder.Configuration.GetConnectionString("CustomerDb");</p>
<p>  return new NpgsqlConnection(connectionString);</p>
<p>});</p>

<p>// 3. Add Azure Service Bus</p>
<p>builder.AddAzureServiceBus("messaging");</p>

<p>// 4. Add Aspire service defaults</p>
<p>builder.AddServiceDefaults();</p>

<p>// 5. Add controllers</p>
<p>builder.Services.AddControllers();</p>
<p>builder.Services.AddEndpointsApiExplorer();</p>
<p>builder.Services.AddSwaggerGen();</p>

<p>var app = builder.Build();</p>

<p>if (app.Environment.IsDevelopment()) {</p>
<p>  app.UseSwagger();</p>
<p>  app.UseSwaggerUI();</p>
<p>}</p>

<p>app.UseHttpsRedirection();</p>
<p>app.UseAuthorization();</p>
<p>app.MapControllers();</p>

<p>await app.MigrateDatabaseAsync();</p>
<p>app.Run();</p>
<p></code></pre></p>

<hr>

<h2>Step 5: Test BFF API</h2>

<h3>1. Create Order (Full Flow)</h3>

<pre><code class="language-bash">curl -X POST http://localhost:5000/api/orders \
<p>  -H "Content-Type: application/json" \</p>
<p>  -d '{ ... }'</p>
<p></code></pre></p>

<p>Wait for events to propagate through system (~10 seconds).</p>

<h3>2. Query Customer Activity</h3>

<pre><code class="language-bash">curl http://localhost:5001/api/customers/cust-123
<p></code></pre></p>

<strong>Response</strong>:

<pre><code class="language-json">{
<p>  "customerId": "cust-123",</p>
<p>  "totalOrders": 1,</p>
<p>  "totalSpent": 39.98,</p>
<p>  "lastOrderId": "order-abc123",</p>
<p>  "lastOrderAt": "2024-12-12T10:30:00Z",</p>
<p>  "firstOrderAt": "2024-12-12T10:30:00Z"</p>
<p>}</p>
<p></code></pre></p>

<h3>3. Query Customer Orders</h3>

<pre><code class="language-bash">curl http://localhost:5001/api/customers/cust-123/orders
<p></code></pre></p>

<strong>Response</strong>:

<pre><code class="language-json">[
<p>  {</p>
<p>    "orderId": "order-abc123",</p>
<p>    "customerId": "cust-123",</p>
<p>    "totalAmount": 39.98,</p>
<p>    "status": "Shipped",</p>
<p>    "itemCount": 1,</p>
<p>    "shippingAddress": {</p>
<p>      "street": "123 Main St",</p>
<p>      "city": "Springfield",</p>
<p>      "state": "IL",</p>
<p>      "zipCode": "62701",</p>
<p>      "country": "USA"</p>
<p>    },</p>
<p>    "createdAt": "2024-12-12T10:30:00Z",</p>
<p>    "paymentInfo": {</p>
<p>      "paymentId": "pay-xyz789",</p>
<p>      "status": "Captured",</p>
<p>      "processedAt": "2024-12-12T10:31:00Z"</p>
<p>    },</p>
<p>    "shipmentInfo": {</p>
<p>      "shipmentId": "ship-def456",</p>
<p>      "trackingNumber": "123456789012",</p>
<p>      "estimatedDelivery": "2024-12-15T12:00:00Z",</p>
<p>      "actualDelivery": null</p>
<p>    }</p>
<p>  }</p>
<p>]</p>
<p></code></pre></p>

<h3>4. Query Single Order</h3>

<pre><code class="language-bash">curl http://localhost:5001/api/orders/order-abc123
<p></code></pre></p>

<strong>Response</strong>: Same as above (single order).

<hr>

<h2>Key Concepts</h2>

<h3>CQRS (Command Query Responsibility Segregation)</h3>

<pre><code class="language-">┌─────────────────────────────────────────────────────────┐
<p>│  CQRS Pattern                                            │</p>
<p>│                                                          │</p>
<p>│  WRITE SIDE (Commands)                                  │</p>
<p>│  ┌──────────────────────────────────┐                   │</p>
<p>│  │  Order Service                   │                   │</p>
<p>│  │  - CreateOrder command           │                   │</p>
<p>│  │  - Publishes OrderCreated event  │                   │</p>
<p>│  └──────────────┬───────────────────┘                   │</p>
<p>│                 │                                        │</p>
<p>│                 ▼                                        │</p>
<p>│  ┌──────────────────────────────────┐                   │</p>
<p>│  │  Azure Service Bus (Events)      │                   │</p>
<p>│  └──────────────┬───────────────────┘                   │</p>
<p>│                 │                                        │</p>
<p>│                 ▼                                        │</p>
<p>│  READ SIDE (Queries)                                    │</p>
<p>│  ┌──────────────────────────────────┐                   │</p>
<p>│  │  Customer Service                │                   │</p>
<p>│  │  - OrderSummaryPerspective       │                   │</p>
<p>│  │  - Denormalized order_summary    │                   │</p>
<p>│  │  - Fast queries (no joins!)      │                   │</p>
<p>│  └──────────────────────────────────┘                   │</p>
<p>└─────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ <strong>Write optimization</strong>: Order Service optimized for writes (ACID, validation)</li>
<li>✅ <strong>Read optimization</strong>: Customer Service optimized for reads (denormalized, indexed)</li>
<li>✅ <strong>Independent scaling</strong>: Scale read replicas independently</li>
<li>✅ <strong>Eventual consistency</strong>: Acceptable for most read queries</li>
</ul>
<h3>Event-Driven Read Models</h3>

<pre><code class="language-csharp">// Single perspective updates from multiple events
<p>public class OrderSummaryPerspective :</p>
<p>  IPerspectiveOf<OrderCreated>,       // Sets initial state</p>
<p>  IPerspectiveOf<PaymentProcessed>,   // Updates payment info</p>
<p>  IPerspectiveOf<ShipmentCreated> {   // Updates shipment info</p>

<p>  public async Task HandleAsync(OrderCreated @event) {</p>
<p>    // INSERT initial order summary</p>
<p>  }</p>

<p>  public async Task HandleAsync(PaymentProcessed @event) {</p>
<p>    // UPDATE with payment details</p>
<p>  }</p>

<p>  public async Task HandleAsync(ShipmentCreated @event) {</p>
<p>    // UPDATE with shipment details</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Result</strong>: Single <code>order_summary</code> row with data from 3 different events.

<h3>BFF (Backend for Frontend)</h3>

<pre><code class="language-">┌─────────────────────────────────────────────────────────┐
<p>│  BFF Pattern                                             │</p>
<p>│                                                          │</p>
<p>│  ┌──────────────┐                                       │</p>
<p>│  │  Web Client  │───────┐                               │</p>
<p>│  └──────────────┘       │                               │</p>
<p>│                         ▼                               │</p>
<p>│  ┌──────────────┐   ┌──────────────────┐               │</p>
<p>│  │Mobile Client │───▶│ Customer Service │               │</p>
<p>│  └──────────────┘   │      (BFF)       │               │</p>
<p>│                     │  - Tailored DTOs │               │</p>
<p>│                     │  - Aggregated data│               │</p>
<p>│                     │  - Client-specific│               │</p>
<p>│                     └──────────────────┘               │</p>
<p>└─────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Key characteristics</strong>:
<ul><li>✅ <strong>Client-specific</strong>: DTOs shaped for frontend needs</li>
<li>✅ <strong>Aggregation</strong>: Combines data from multiple events</li>
<li>✅ <strong>Denormalization</strong>: Pre-joins data for performance</li>
<li>✅ <strong>Versioning</strong>: API versions per client type</li>
</ul>
<hr>

<h2>Testing</h2>

<h3>Unit Test - Perspective</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task OrderSummaryPerspective_OrderCreated_CreatesOrderSummaryAsync() {</p>
<p>  // Arrange</p>
<p>  var db = new MockNpgsqlConnection();</p>
<p>  var perspective = new OrderSummaryPerspective(db, mockLogger);</p>
<p>  var @event = new OrderCreated(...);</p>

<p>  // Act</p>
<p>  await perspective.HandleAsync(@event);</p>

<p>  // Assert</p>
<p>  var summary = db.GetOrderSummary(@event.OrderId);</p>
<p>  await Assert.That(summary).IsNotNull();</p>
<p>  await Assert.That(summary.Status).IsEqualTo("Pending");</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Next Steps</h2>

<p>Continue to <strong><a href="analytics-service.md">Analytics Service</a></strong> to:</p>
<ul><li>Build real-time analytics dashboards</li>
<li>Aggregate events across all services</li>
<li>Implement time-series perspectives</li>
<li>Create daily/monthly reports</li>
</ul>
<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>CQRS</strong> - Separate write (commands) and read (queries) models</p>
<p>✅ <strong>Perspectives</strong> - Event-driven read model updates</p>
<p>✅ <strong>Denormalization</strong> - Pre-join data for fast queries</p>
<p>✅ <strong>BFF Pattern</strong> - Tailor API to frontend needs</p>
<p>✅ <strong>Eventual Consistency</strong> - Acceptable for most read queries</p>

<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-tutorial-deployment" class="doc-section">
  <h3>Deployment</h3>
  <p class="doc-path"><code>v1.0.0/tutorial/deployment</code></p>
  <p class="doc-description"><em>Deploy to production - Azure Kubernetes Service, CI/CD pipelines, monitoring, and scaling</em></p>
  <div class="doc-content">

<h1>Deployment</h1>

<p>Deploy the <strong>ECommerce system</strong> to production using Azure Kubernetes Service (AKS), implement CI/CD pipelines, configure monitoring, and enable auto-scaling.</p>

<p>:::note</p>
<p>This is <strong>Part 9</strong> (Final) of the ECommerce Tutorial. Complete <a href="testing-strategy.md">Testing Strategy</a> first.</p>
<p>:::</p>

<hr>

<h2>Deployment Architecture</h2>

<pre><code class="language-">┌──────────────────────────────────────────────────────────────┐
<p>│  Azure Kubernetes Service (AKS)                              │</p>
<p>│                                                               │</p>
<p>│  ┌─────────────────────────────────────────────────────┐    │</p>
<p>│  │  Ingress Controller (nginx)                         │    │</p>
<p>│  │  - SSL/TLS Termination                              │    │</p>
<p>│  │  - Load Balancing                                   │    │</p>
<p>│  └────────────┬─────────────────────────────────────────┘   │</p>
<p>│               │                                               │</p>
<p>│  ┌────────────▼────────┐  ┌──────────────────┐              │</p>
<p>│  │  Order Service      │  │ Customer Service │              │</p>
<p>│  │  (3 replicas)       │  │  (2 replicas)    │              │</p>
<p>│  └─────────────────────┘  └──────────────────┘              │</p>
<p>│                                                               │</p>
<p>│  ┌─────────────────────┐  ┌──────────────────┐              │</p>
<p>│  │ Inventory Worker    │  │  Payment Worker  │              │</p>
<p>│  │  (2 replicas)       │  │  (2 replicas)    │              │</p>
<p>│  └─────────────────────┘  └──────────────────┘              │</p>
<p>│                                                               │</p>
<p>│  ┌─────────────────────┐  ┌──────────────────┐              │</p>
<p>│  │Notification Worker  │  │ Shipping Worker  │              │</p>
<p>│  │  (2 replicas)       │  │  (2 replicas)    │              │</p>
<p>│  └─────────────────────┘  └──────────────────┘              │</p>
<p>│                                                               │</p>
<p>│  ┌──────────────────────────────────────────────────────┐   │</p>
<p>│  │  Analytics Worker (1 replica)                        │   │</p>
<p>│  └──────────────────────────────────────────────────────┘   │</p>
<p>└──────────────────────────────────────────────────────────────┘</p>

<p>┌──────────────────────────────────────────────────────────────┐</p>
<p>│  Azure Managed Services                                      │</p>
<p>│                                                               │</p>
<p>│  ┌──────────────────┐  ┌──────────────────┐  ┌────────────┐│</p>
<p>│  │ Azure Service    │  │ Azure Database   │  │ Azure      ││</p>
<p>│  │ Bus (Premium)    │  │ for PostgreSQL   │  │ Monitor    ││</p>
<p>│  └──────────────────┘  └──────────────────┘  └────────────┘│</p>
<p>└──────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<hr>

<h2>Step 1: Dockerfiles</h2>

<h3>Order Service Dockerfile</h3>

<strong>ECommerce.OrderService.API/Dockerfile</strong>:

<pre><code class="language-dockerfile"># Build stage
<p>FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build</p>
<p>WORKDIR /src</p>

<h1>Copy solution and project files</h1>
<p>COPY ECommerce.sln .</p>
<p>COPY ECommerce.OrderService.API/ECommerce.OrderService.API.csproj ECommerce.OrderService.API/</p>
<p>COPY ECommerce.Contracts/ECommerce.Contracts.csproj ECommerce.Contracts/</p>

<h1>Restore dependencies</h1>
<p>RUN dotnet restore ECommerce.OrderService.API/ECommerce.OrderService.API.csproj</p>

<h1>Copy source code</h1>
<p>COPY . .</p>

<h1>Build and publish</h1>
<p>WORKDIR /src/ECommerce.OrderService.API</p>
<p>RUN dotnet publish -c Release -o /app/publish \</p>
<p>  --no-restore \</p>
<p>  /p:UseAppHost=false</p>

<h1>Runtime stage</h1>
<p>FROM mcr.microsoft.com/dotnet/aspnet:10.0 AS runtime</p>
<p>WORKDIR /app</p>

<h1>Copy published files</h1>
<p>COPY --from=build /app/publish .</p>

<h1>Create non-root user</h1>
<p>RUN adduser --disabled-password --gecos "" appuser && chown -R appuser /app</p>
<p>USER appuser</p>

<h1>Health check</h1>
<p>HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \</p>
<p>  CMD curl -f http://localhost:8080/health || exit 1</p>

<h1>Expose port</h1>
<p>EXPOSE 8080</p>

<p>ENTRYPOINT ["dotnet", "ECommerce.OrderService.API.dll"]</p>
<p></code></pre></p>

<h3>Worker Service Dockerfile</h3>

<strong>ECommerce.InventoryWorker/Dockerfile</strong>:

<pre><code class="language-dockerfile">FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
<p>WORKDIR /src</p>

<p>COPY ECommerce.sln .</p>
<p>COPY ECommerce.InventoryWorker/ECommerce.InventoryWorker.csproj ECommerce.InventoryWorker/</p>
<p>COPY ECommerce.Contracts/ECommerce.Contracts.csproj ECommerce.Contracts/</p>

<p>RUN dotnet restore ECommerce.InventoryWorker/ECommerce.InventoryWorker.csproj</p>

<p>COPY . .</p>
<p>WORKDIR /src/ECommerce.InventoryWorker</p>
<p>RUN dotnet publish -c Release -o /app/publish \</p>
<p>  --no-restore \</p>
<p>  /p:UseAppHost=false</p>

<p>FROM mcr.microsoft.com/dotnet/runtime:10.0 AS runtime</p>
<p>WORKDIR /app</p>
<p>COPY --from=build /app/publish .</p>

<p>RUN adduser --disabled-password --gecos "" appuser && chown -R appuser /app</p>
<p>USER appuser</p>

<p>ENTRYPOINT ["dotnet", "ECommerce.InventoryWorker.dll"]</p>
<p></code></pre></p>

<hr>

<h2>Step 2: Kubernetes Manifests</h2>

<h3>Order Service Deployment</h3>

<strong>k8s/order-service/deployment.yaml</strong>:

<pre><code class="language-yaml">apiVersion: apps/v1
<p>kind: Deployment</p>
<p>metadata:</p>
<p>  name: order-service</p>
<p>  namespace: ecommerce</p>
<p>  labels:</p>
<p>    app: order-service</p>
<p>spec:</p>
<p>  replicas: 3</p>
<p>  selector:</p>
<p>    matchLabels:</p>
<p>      app: order-service</p>
<p>  template:</p>
<p>    metadata:</p>
<p>      labels:</p>
<p>        app: order-service</p>
<p>    spec:</p>
<p>      containers:</p>
<p>      - name: order-service</p>
<p>        image: ecommerceacr.azurecr.io/order-service:latest</p>
<p>        ports:</p>
<p>        - containerPort: 8080</p>
<p>          name: http</p>
<p>        env:</p>
<p>        - name: ASPNETCORE_ENVIRONMENT</p>
<p>          value: "Production"</p>
<p>        - name: ConnectionStrings__OrdersDb</p>
<p>          valueFrom:</p>
<p>            secretKeyRef:</p>
<p>              name: database-secrets</p>
<p>              key: orders-db-connection-string</p>
<p>        - name: Whizbang__ServiceBus__ConnectionString</p>
<p>          valueFrom:</p>
<p>            secretKeyRef:</p>
<p>              name: servicebus-secrets</p>
<p>              key: connection-string</p>
<p>        resources:</p>
<p>          requests:</p>
<p>            memory: "256Mi"</p>
<p>            cpu: "250m"</p>
<p>          limits:</p>
<p>            memory: "512Mi"</p>
<p>            cpu: "500m"</p>
<p>        livenessProbe:</p>
<p>          httpGet:</p>
<p>            path: /health</p>
<p>            port: 8080</p>
<p>          initialDelaySeconds: 30</p>
<p>          periodSeconds: 10</p>
<p>        readinessProbe:</p>
<p>          httpGet:</p>
<p>            path: /health/ready</p>
<p>            port: 8080</p>
<p>          initialDelaySeconds: 10</p>
<p>          periodSeconds: 5</p>
<hr>
<p>apiVersion: v1</p>
<p>kind: Service</p>
<p>metadata:</p>
<p>  name: order-service</p>
<p>  namespace: ecommerce</p>
<p>spec:</p>
<p>  selector:</p>
<p>    app: order-service</p>
<p>  ports:</p>
<p>  - port: 80</p>
<p>    targetPort: 8080</p>
<p>    name: http</p>
<p>  type: ClusterIP</p>
<p></code></pre></p>

<h3>Horizontal Pod Autoscaler</h3>

<strong>k8s/order-service/hpa.yaml</strong>:

<pre><code class="language-yaml">apiVersion: autoscaling/v2
<p>kind: HorizontalPodAutoscaler</p>
<p>metadata:</p>
<p>  name: order-service-hpa</p>
<p>  namespace: ecommerce</p>
<p>spec:</p>
<p>  scaleTargetRef:</p>
<p>    apiVersion: apps/v1</p>
<p>    kind: Deployment</p>
<p>    name: order-service</p>
<p>  minReplicas: 3</p>
<p>  maxReplicas: 10</p>
<p>  metrics:</p>
<p>  - type: Resource</p>
<p>    resource:</p>
<p>      name: cpu</p>
<p>      target:</p>
<p>        type: Utilization</p>
<p>        averageUtilization: 70</p>
<p>  - type: Resource</p>
<p>    resource:</p>
<p>      name: memory</p>
<p>      target:</p>
<p>        type: Utilization</p>
<p>        averageUtilization: 80</p>
<p>  behavior:</p>
<p>    scaleUp:</p>
<p>      stabilizationWindowSeconds: 60</p>
<p>      policies:</p>
<p>      - type: Percent</p>
<p>        value: 50</p>
<p>        periodSeconds: 60</p>
<p>    scaleDown:</p>
<p>      stabilizationWindowSeconds: 300</p>
<p>      policies:</p>
<p>      - type: Percent</p>
<p>        value: 10</p>
<p>        periodSeconds: 60</p>
<p></code></pre></p>

<h3>Ingress</h3>

<strong>k8s/ingress.yaml</strong>:

<pre><code class="language-yaml">apiVersion: networking.k8s.io/v1
<p>kind: Ingress</p>
<p>metadata:</p>
<p>  name: ecommerce-ingress</p>
<p>  namespace: ecommerce</p>
<p>  annotations:</p>
<p>    cert-manager.io/cluster-issuer: letsencrypt-prod</p>
<p>    nginx.ingress.kubernetes.io/ssl-redirect: "true"</p>
<p>    nginx.ingress.kubernetes.io/rate-limit: "100"</p>
<p>spec:</p>
<p>  ingressClassName: nginx</p>
<p>  tls:</p>
<p>  - hosts:</p>
<p>    - api.ecommerce.example.com</p>
<p>    secretName: ecommerce-tls</p>
<p>  rules:</p>
<p>  - host: api.ecommerce.example.com</p>
<p>    http:</p>
<p>      paths:</p>
<p>      - path: /api/orders</p>
<p>        pathType: Prefix</p>
<p>        backend:</p>
<p>          service:</p>
<p>            name: order-service</p>
<p>            port:</p>
<p>              number: 80</p>
<p>      - path: /api/customers</p>
<p>        pathType: Prefix</p>
<p>        backend:</p>
<p>          service:</p>
<p>            name: customer-service</p>
<p>            port:</p>
<p>              number: 80</p>
<p>      - path: /api/analytics</p>
<p>        pathType: Prefix</p>
<p>        backend:</p>
<p>          service:</p>
<p>            name: analytics-service</p>
<p>            port:</p>
<p>              number: 80</p>
<p></code></pre></p>

<hr>

<h2>Step 3: Azure Infrastructure (Bicep)</h2>

<strong>infra/main.bicep</strong>:

<pre><code class="language-bicep">param location string = 'eastus'
<p>param environment string = 'production'</p>

<p>// Azure Kubernetes Service</p>
<p>resource aks 'Microsoft.ContainerService/managedClusters@2024-01-01' = {</p>
<p>  name: 'ecommerce-aks-${environment}'</p>
<p>  location: location</p>
<p>  identity: {</p>
<p>    type: 'SystemAssigned'</p>
<p>  }</p>
<p>  properties: {</p>
<p>    kubernetesVersion: '1.28'</p>
<p>    dnsPrefix: 'ecommerce-${environment}'</p>
<p>    agentPoolProfiles: [</p>
<p>      {</p>
<p>        name: 'nodepool1'</p>
<p>        count: 3</p>
<p>        vmSize: 'Standard_D4s_v3'</p>
<p>        mode: 'System'</p>
<p>        enableAutoScaling: true</p>
<p>        minCount: 3</p>
<p>        maxCount: 10</p>
<p>        osDiskSizeGB: 128</p>
<p>        osType: 'Linux'</p>
<p>      }</p>
<p>    ]</p>
<p>    networkProfile: {</p>
<p>      networkPlugin: 'azure'</p>
<p>      loadBalancerSku: 'standard'</p>
<p>      serviceCidr: '10.0.0.0/16'</p>
<p>      dnsServiceIP: '10.0.0.10'</p>
<p>    }</p>
<p>    addonProfiles: {</p>
<p>      azurePolicy: {</p>
<p>        enabled: true</p>
<p>      }</p>
<p>      omsagent: {</p>
<p>        enabled: true</p>
<p>        config: {</p>
<p>          logAnalyticsWorkspaceResourceID: logAnalytics.id</p>
<p>        }</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>

<p>// Azure Database for PostgreSQL</p>
<p>resource postgres 'Microsoft.DBforPostgreSQL/flexibleServers@2023-03-01-preview' = {</p>
<p>  name: 'ecommerce-postgres-${environment}'</p>
<p>  location: location</p>
<p>  sku: {</p>
<p>    name: 'Standard_D4s_v3'</p>
<p>    tier: 'GeneralPurpose'</p>
<p>  }</p>
<p>  properties: {</p>
<p>    version: '16'</p>
<p>    administratorLogin: 'pgadmin'</p>
<p>    administratorLoginPassword: '<secure-password>'</p>
<p>    storage: {</p>
<p>      storageSizeGB: 128</p>
<p>    }</p>
<p>    backup: {</p>
<p>      backupRetentionDays: 7</p>
<p>      geoRedundantBackup: 'Enabled'</p>
<p>    }</p>
<p>    highAvailability: {</p>
<p>      mode: 'ZoneRedundant'</p>
<p>    }</p>
<p>  }</p>
<p>}</p>

<p>// Azure Service Bus</p>
<p>resource serviceBus 'Microsoft.ServiceBus/namespaces@2023-01-01-preview' = {</p>
<p>  name: 'ecommerce-servicebus-${environment}'</p>
<p>  location: location</p>
<p>  sku: {</p>
<p>    name: 'Premium'</p>
<p>    tier: 'Premium'</p>
<p>    capacity: 1</p>
<p>  }</p>
<p>  properties: {</p>
<p>    zoneRedundant: true</p>
<p>  }</p>
<p>}</p>

<p>// Azure Container Registry</p>
<p>resource acr 'Microsoft.ContainerRegistry/registries@2023-07-01' = {</p>
<p>  name: 'ecommerceacr${environment}'</p>
<p>  location: location</p>
<p>  sku: {</p>
<p>    name: 'Premium'</p>
<p>  }</p>
<p>  properties: {</p>
<p>    adminUserEnabled: false</p>
<p>    publicNetworkAccess: 'Enabled'</p>
<p>  }</p>
<p>}</p>

<p>// Log Analytics Workspace</p>
<p>resource logAnalytics 'Microsoft.OperationalInsights/workspaces@2022-10-01' = {</p>
<p>  name: 'ecommerce-logs-${environment}'</p>
<p>  location: location</p>
<p>  properties: {</p>
<p>    sku: {</p>
<p>      name: 'PerGB2018'</p>
<p>    }</p>
<p>    retentionInDays: 30</p>
<p>  }</p>
<p>}</p>

<p>// Application Insights</p>
<p>resource appInsights 'Microsoft.Insights/components@2020-02-02' = {</p>
<p>  name: 'ecommerce-appinsights-${environment}'</p>
<p>  location: location</p>
<p>  kind: 'web'</p>
<p>  properties: {</p>
<p>    Application_Type: 'web'</p>
<p>    WorkspaceResourceId: logAnalytics.id</p>
<p>  }</p>
<p>}</p>

<p>output aksName string = aks.name</p>
<p>output acrLoginServer string = acr.properties.loginServer</p>
<p>output postgresHost string = postgres.properties.fullyQualifiedDomainName</p>
<p>output serviceBusNamespace string = serviceBus.name</p>
<p></code></pre></p>

<strong>Deploy infrastructure</strong>:

<pre><code class="language-bash">az deployment group create \
<p>  --resource-group ecommerce-rg \</p>
<p>  --template-file infra/main.bicep \</p>
<p>  --parameters environment=production</p>
<p></code></pre></p>

<hr>

<h2>Step 4: CI/CD Pipeline (GitHub Actions)</h2>

<strong>.github/workflows/deploy.yaml</strong>:

<pre><code class="language-yaml">name: Build and Deploy

<p>on:</p>
<p>  push:</p>
<p>    branches: [main]</p>
<p>  pull_request:</p>
<p>    branches: [main]</p>

<p>env:</p>
<p>  AZURE_RESOURCE_GROUP: ecommerce-rg</p>
<p>  AKS_CLUSTER_NAME: ecommerce-aks-production</p>
<p>  ACR_NAME: ecommerceacrproduction</p>

<p>jobs:</p>
<p>  test:</p>
<p>    runs-on: ubuntu-latest</p>
<p>    steps:</p>
<p>    - uses: actions/checkout@v4</p>

<p>    - name: Setup .NET 10</p>
<p>      uses: actions/setup-dotnet@v4</p>
<p>      with:</p>
<p>        dotnet-version: '10.0.x'</p>

<p>    - name: Restore dependencies</p>
<p>      run: dotnet restore</p>

<p>    - name: Build</p>
<p>      run: dotnet build --no-restore</p>

<p>    - name: Run unit tests</p>
<p>      run: dotnet test --no-build --verbosity normal --logger trx</p>

<p>    - name: Run integration tests</p>
<p>      run: |</p>
<p>        docker-compose -f docker-compose.test.yml up -d</p>
<p>        dotnet test tests/ECommerce.IntegrationTests --no-build</p>
<p>        docker-compose -f docker-compose.test.yml down</p>

<p>  build-and-push:</p>
<p>    needs: test</p>
<p>    runs-on: ubuntu-latest</p>
<p>    if: github.ref == 'refs/heads/main'</p>
<p>    strategy:</p>
<p>      matrix:</p>
<p>        service:</p>
<p>        - order-service</p>
<p>        - inventory-worker</p>
<p>        - payment-worker</p>
<p>        - notification-worker</p>
<p>        - shipping-worker</p>
<p>        - customer-service</p>
<p>        - analytics-worker</p>
<p>    steps:</p>
<p>    - uses: actions/checkout@v4</p>

<p>    - name: Login to Azure Container Registry</p>
<p>      uses: azure/docker-login@v1</p>
<p>      with:</p>
<p>        login-server: ${{ env.ACR_NAME }}.azurecr.io</p>
<p>        username: ${{ secrets.ACR_USERNAME }}</p>
<p>        password: ${{ secrets.ACR_PASSWORD }}</p>

<p>    - name: Build and push Docker image</p>
<p>      run: |</p>
<p>        docker build -t ${{ env.ACR_NAME }}.azurecr.io/${{ matrix.service }}:${{ github.sha }} \</p>
<p>          -f ECommerce.${{ matrix.service }}/Dockerfile .</p>
<p>        docker push ${{ env.ACR_NAME }}.azurecr.io/${{ matrix.service }}:${{ github.sha }}</p>

<p>  deploy:</p>
<p>    needs: build-and-push</p>
<p>    runs-on: ubuntu-latest</p>
<p>    if: github.ref == 'refs/heads/main'</p>
<p>    steps:</p>
<p>    - uses: actions/checkout@v4</p>

<p>    - name: Azure Login</p>
<p>      uses: azure/login@v1</p>
<p>      with:</p>
<p>        creds: ${{ secrets.AZURE_CREDENTIALS }}</p>

<p>    - name: Get AKS credentials</p>
<p>      run: |</p>
<p>        az aks get-credentials \</p>
<p>          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \</p>
<p>          --name ${{ env.AKS_CLUSTER_NAME }}</p>

<p>    - name: Update Kubernetes manifests</p>
<p>      run: |</p>
<p>        sed -i "s|:latest|:${{ github.sha }}|g" k8s/<em></em>/*.yaml</p>

<p>    - name: Deploy to AKS</p>
<p>      run: |</p>
<p>        kubectl apply -f k8s/namespace.yaml</p>
<p>        kubectl apply -f k8s/secrets/ --namespace ecommerce</p>
<p>        kubectl apply -f k8s/ --recursive --namespace ecommerce</p>

<p>    - name: Wait for rollout</p>
<p>      run: |</p>
<p>        kubectl rollout status deployment/order-service --namespace ecommerce --timeout=10m</p>
<p>        kubectl rollout status deployment/inventory-worker --namespace ecommerce --timeout=10m</p>
<p></code></pre></p>

<hr>

<h2>Step 5: Monitoring and Observability</h2>

<h3>Application Insights Integration</h3>

<strong>Program.cs</strong>:

<pre><code class="language-csharp">builder.Services.AddApplicationInsightsTelemetry(options => {
<p>  options.ConnectionString = builder.Configuration["ApplicationInsights:ConnectionString"];</p>
<p>});</p>

<p>builder.Services.AddOpenTelemetryMetrics(metrics => {</p>
<p>  metrics</p>
<p>    .AddAspNetCoreInstrumentation()</p>
<p>    .AddHttpClientInstrumentation()</p>
<p>    .AddRuntimeInstrumentation();</p>
<p>});</p>

<p>builder.Services.AddOpenTelemetryTracing(tracing => {</p>
<p>  tracing</p>
<p>    .AddAspNetCoreInstrumentation()</p>
<p>    .AddHttpClientInstrumentation()</p>
<p>    .AddNpgsql()</p>
<p>    .AddAzureServiceBusInstrumentation();</p>
<p>});</p>
<p></code></pre></p>

<h3>Prometheus Metrics</h3>

<strong>k8s/monitoring/prometheus.yaml</strong>:

<pre><code class="language-yaml">apiVersion: v1
<p>kind: ServiceMonitor</p>
<p>metadata:</p>
<p>  name: ecommerce-services</p>
<p>  namespace: ecommerce</p>
<p>spec:</p>
<p>  selector:</p>
<p>    matchLabels:</p>
<p>      app: order-service</p>
<p>  endpoints:</p>
<p>  - port: http</p>
<p>    path: /metrics</p>
<p>    interval: 30s</p>
<p></code></pre></p>

<h3>Custom Metrics</h3>

<strong>Receptors/CreateOrderReceptor.cs</strong>:

<pre><code class="language-csharp">private readonly Meter _meter = new("ECommerce.OrderService");
<p>private readonly Counter<long> _ordersCreated;</p>

<p>public CreateOrderReceptor(...) {</p>
<p>  _ordersCreated = _meter.CreateCounter<long>(</p>
<p>    "orders_created_total",</p>
<p>    description: "Total number of orders created"</p>
<p>  );</p>
<p>}</p>

<p>public async Task<OrderCreated> HandleAsync(CreateOrder command, CancellationToken ct) {</p>
<p>  // ... process order</p>

<p>  _ordersCreated.Add(1, new TagList {</p>
<p>    { "customer_id", command.CustomerId },</p>
<p>    { "item_count", command.Items.Length }</p>
<p>  });</p>

<p>  return @event;</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Step 6: Database Migrations</h2>

<h3>Migration Job</h3>

<strong>k8s/jobs/migrate-orders-db.yaml</strong>:

<pre><code class="language-yaml">apiVersion: batch/v1
<p>kind: Job</p>
<p>metadata:</p>
<p>  name: migrate-orders-db</p>
<p>  namespace: ecommerce</p>
<p>spec:</p>
<p>  template:</p>
<p>    spec:</p>
<p>      containers:</p>
<p>      - name: migrate</p>
<p>        image: ecommerceacr.azurecr.io/order-service:latest</p>
<p>        command: ["dotnet", "ECommerce.OrderService.API.dll", "migrate"]</p>
<p>        env:</p>
<p>        - name: ConnectionStrings__OrdersDb</p>
<p>          valueFrom:</p>
<p>            secretKeyRef:</p>
<p>              name: database-secrets</p>
<p>              key: orders-db-connection-string</p>
<p>      restartPolicy: OnFailure</p>
<p>  backoffLimit: 3</p>
<p></code></pre></p>

<strong>Run migration before deployment</strong>:

<pre><code class="language-bash">kubectl apply -f k8s/jobs/migrate-orders-db.yaml
<p>kubectl wait --for=condition=complete job/migrate-orders-db --timeout=5m</p>
<p></code></pre></p>

<hr>

<h2>Step 7: Blue-Green Deployment</h2>

<strong>k8s/order-service/deployment-blue.yaml</strong>:

<pre><code class="language-yaml">apiVersion: apps/v1
<p>kind: Deployment</p>
<p>metadata:</p>
<p>  name: order-service-blue</p>
<p>  namespace: ecommerce</p>
<p>  labels:</p>
<p>    app: order-service</p>
<p>    version: blue</p>
<p>spec:</p>
<p>  replicas: 3</p>
<p>  selector:</p>
<p>    matchLabels:</p>
<p>      app: order-service</p>
<p>      version: blue</p>
<p>  template:</p>
<p>    metadata:</p>
<p>      labels:</p>
<p>        app: order-service</p>
<p>        version: blue</p>
<p>    spec:</p>
<p>      containers:</p>
<p>      - name: order-service</p>
<p>        image: ecommerceacr.azurecr.io/order-service:v1.0.0</p>
<p>        # ...</p>
<p></code></pre></p>

<strong>k8s/order-service/service-switch.yaml</strong>:

<pre><code class="language-yaml">apiVersion: v1
<p>kind: Service</p>
<p>metadata:</p>
<p>  name: order-service</p>
<p>  namespace: ecommerce</p>
<p>spec:</p>
<p>  selector:</p>
<p>    app: order-service</p>
<p>    version: blue  # Switch to "green" for rollover</p>
<p>  ports:</p>
<p>  - port: 80</p>
<p>    targetPort: 8080</p>
<p></code></pre></p>

<strong>Deployment process</strong>:

<pre><code class="language-bash"># Deploy green version
<p>kubectl apply -f k8s/order-service/deployment-green.yaml</p>

<h1>Wait for readiness</h1>
<p>kubectl wait --for=condition=available deployment/order-service-green --timeout=5m</p>

<h1>Switch traffic to green</h1>
<p>kubectl patch service order-service -p '{"spec":{"selector":{"version":"green"}}}'</p>

<h1>Monitor for errors (5 minutes)</h1>
<h1>If successful, delete blue</h1>
<p>kubectl delete deployment order-service-blue</p>
<p></code></pre></p>

<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>Kubernetes Deployment</strong> - AKS with auto-scaling and health checks</p>
<p>✅ <strong>CI/CD Pipeline</strong> - GitHub Actions for automated testing and deployment</p>
<p>✅ <strong>Infrastructure as Code</strong> - Bicep for Azure resources</p>
<p>✅ <strong>Monitoring</strong> - Application Insights and Prometheus metrics</p>
<p>✅ <strong>Blue-Green Deployment</strong> - Zero-downtime deployments</p>
<p>✅ <strong>Database Migrations</strong> - Automated with Kubernetes jobs</p>

<hr>

<h2>Production Checklist</h2>

<p>Before going live:</p>

<ul><li>[ ] SSL/TLS certificates configured (cert-manager + Let's Encrypt)</li>
<li>[ ] Secrets stored in Azure Key Vault (not ConfigMaps)</li>
<li>[ ] Database backups configured (7-day retention)</li>
<li>[ ] Log aggregation configured (Azure Monitor)</li>
<li>[ ] Alerts configured for critical errors</li>
<li>[ ] Auto-scaling tested under load</li>
<li>[ ] Disaster recovery plan documented</li>
<li>[ ] Security scanning in CI/CD pipeline</li>
<li>[ ] Rate limiting configured on Ingress</li>
<li>[ ] DDoS protection enabled</li>
</ul>
<hr>

<h2>Congratulations!</h2>

<p>You've completed the <strong>ECommerce Tutorial</strong> and built a production-ready, event-driven microservices system with Whizbang! 🎉</p>

<strong>What you've learned</strong>:
<ul><li>Event-driven architecture with CQRS</li>
<li>Distributed transactions with sagas</li>
<li>Read models with perspectives</li>
<li>Testing strategies (unit, integration, e2e)</li>
<li>Production deployment on Kubernetes</li>
</ul>
<strong>Next steps</strong>:
<ul><li>Explore <a href="../advanced-topics/">Advanced Topics</a> for performance tuning and scaling</li>
<li>Check out <a href="../customization-examples/">Customization Examples</a> for real-world patterns</li>
<li>Join the community and share your Whizbang projects!</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-tutorial-inventory-service" class="doc-section">
  <h3>Inventory Service</h3>
  <p class="doc-path"><code>v1.0.0/tutorial/inventory-service</code></p>
  <p class="doc-description"><em>Build the Inventory Worker - event subscription, stock reservations, compensation, and perspectives</em></p>
  <div class="doc-content">

<h1>Inventory Service</h1>

<p>Build the <strong>Inventory Worker</strong> - a background service that subscribes to <code>OrderCreated</code> events, reserves inventory, publishes <code>InventoryReserved</code> events, and maintains read models via perspectives.</p>

<p>:::note</p>
<p>This is <strong>Part 2</strong> of the ECommerce Tutorial. Complete <a href="order-management.md">Order Management</a> first.</p>
<p>:::</p>

<hr>

<h2>What You'll Build</h2>

<pre><code class="language-">┌─────────────────────────────────────────────────────────────┐
<p>│  Inventory Service Architecture                             │</p>
<p>│                                                              │</p>
<p>│  ┌─────────────┐                                            │</p>
<p>│  │Azure Service│  OrderCreated event                        │</p>
<p>│  │     Bus     │──────────────────────┐                     │</p>
<p>│  └─────────────┘                      │                     │</p>
<p>│                                        ▼                     │</p>
<p>│                          ┌────────────────────────┐         │</p>
<p>│                          │  Inbox Pattern         │         │</p>
<p>│                          │  (Exactly-Once)        │         │</p>
<p>│                          └──────────┬─────────────┘         │</p>
<p>│                                     │                        │</p>
<p>│                                     ▼                        │</p>
<p>│                          ┌────────────────────────┐         │</p>
<p>│                          │ ReserveInventoryReceptor│        │</p>
<p>│                          │  - Check stock         │         │</p>
<p>│                          │  - Reserve units       │         │</p>
<p>│                          │  - Publish event       │         │</p>
<p>│                          └──────────┬─────────────┘         │</p>
<p>│                                     │                        │</p>
<p>│                      ┌──────────────┼──────────────┐        │</p>
<p>│                      │              │              │        │</p>
<p>│                      ▼              ▼              ▼        │</p>
<p>│                 ┌─────────┐   ┌─────────┐   ┌──────────┐   │</p>
<p>│                 │Postgres │   │ Outbox  │   │Perspective│  │</p>
<p>│                 │Inventory│   │ Table   │   │  (Read    │  │</p>
<p>│                 │  Table  │   │         │   │  Model)   │  │</p>
<p>│                 └─────────┘   └─────────┘   └──────────┘   │</p>
<p>│                                     │                        │</p>
<p>│                                     ▼                        │</p>
<p>│                          ┌────────────────────────┐         │</p>
<p>│                          │ Azure Service Bus      │         │</p>
<p>│                          │ InventoryReserved      │         │</p>
<p>│                          └────────────────────────┘         │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Features</strong>:
<ul><li>✅ Event subscription (OrderCreated)</li>
<li>✅ Inbox pattern (exactly-once processing)</li>
<li>✅ Inventory reservation logic</li>
<li>✅ Compensation (stock release on failure)</li>
<li>✅ Perspective read model (InventorySummary)</li>
<li>✅ Work coordination via PostgreSQL</li>
</ul>
<hr>

<h2>Step 1: Define Events</h2>

<h3>InventoryReserved Event</h3>

<strong>ECommerce.Contracts/Events/InventoryReserved.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;

<p>namespace ECommerce.Contracts.Events;</p>

<p>public record InventoryReserved(</p>
<p>  string OrderId,</p>
<p>  string ProductId,</p>
<p>  int QuantityReserved,</p>
<p>  int RemainingStock,</p>
<p>  DateTime ReservedAt</p>
<p>) : IEvent;</p>
<p></code></pre></p>

<h3>InventoryInsufficient Event (Compensation)</h3>

<strong>ECommerce.Contracts/Events/InventoryInsufficient.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;

<p>namespace ECommerce.Contracts.Events;</p>

<p>public record InventoryInsufficient(</p>
<p>  string OrderId,</p>
<p>  string ProductId,</p>
<p>  int RequestedQuantity,</p>
<p>  int AvailableStock,</p>
<p>  DateTime CheckedAt</p>
<p>) : IEvent;</p>
<p></code></pre></p>

<strong>Why two events?</strong>
<ul><li>Success path: <code>InventoryReserved</code> triggers payment processing</li>
<li>Failure path: <code>InventoryInsufficient</code> triggers order cancellation (compensation)</li>
</ul>
<hr>

<h2>Step 2: Database Schema</h2>

<h3>Inventory Table</h3>

<strong>ECommerce.InventoryWorker/Database/Migrations/001_CreateInventoryTable.sql</strong>:

<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS inventory (
<p>  product_id TEXT PRIMARY KEY,</p>
<p>  available_stock INTEGER NOT NULL CHECK (available_stock >= 0),</p>
<p>  reserved_stock INTEGER NOT NULL DEFAULT 0 CHECK (reserved_stock >= 0),</p>
<p>  total_stock INTEGER GENERATED ALWAYS AS (available_stock + reserved_stock) STORED,</p>
<p>  last_updated TIMESTAMP NOT NULL DEFAULT NOW(),</p>
<p>  version INTEGER NOT NULL DEFAULT 1  -- Optimistic concurrency</p>
<p>);</p>

<p>CREATE INDEX idx_inventory_product_id ON inventory(product_id);</p>

<p>-- Seed data for demo</p>
<p>INSERT INTO inventory (product_id, available_stock, reserved_stock)</p>
<p>VALUES</p>
<p>  ('prod-456', 100, 0),</p>
<p>  ('prod-789', 50, 0)</p>
<p>ON CONFLICT (product_id) DO NOTHING;</p>
<p></code></pre></p>

<h3>Reservations Table</h3>

<strong>ECommerce.InventoryWorker/Database/Migrations/002_CreateReservationsTable.sql</strong>:

<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS inventory_reservations (
<p>  reservation_id TEXT PRIMARY KEY,</p>
<p>  order_id TEXT NOT NULL,</p>
<p>  product_id TEXT NOT NULL REFERENCES inventory(product_id),</p>
<p>  quantity_reserved INTEGER NOT NULL,</p>
<p>  status TEXT NOT NULL,  -- 'Reserved', 'Released', 'Committed'</p>
<p>  created_at TIMESTAMP NOT NULL DEFAULT NOW(),</p>
<p>  expires_at TIMESTAMP NOT NULL  -- Auto-release after N minutes</p>
<p>);</p>

<p>CREATE INDEX idx_reservations_order_id ON inventory_reservations(order_id);</p>
<p>CREATE INDEX idx_reservations_product_id ON inventory_reservations(product_id);</p>
<p>CREATE INDEX idx_reservations_expires_at ON inventory_reservations(expires_at)</p>
<p>  WHERE status = 'Reserved';</p>
<p></code></pre></p>

<h3>Inbox Table</h3>

<strong>ECommerce.InventoryWorker/Database/Migrations/003_CreateInboxTable.sql</strong>:

<pre><code class="language-sql">-- Whizbang inbox pattern for exactly-once processing
<p>CREATE TABLE IF NOT EXISTS inbox (</p>
<p>  message_id UUID PRIMARY KEY,</p>
<p>  message_type TEXT NOT NULL,</p>
<p>  message_body JSONB NOT NULL,</p>
<p>  received_at TIMESTAMP NOT NULL DEFAULT NOW(),</p>
<p>  processed_at TIMESTAMP,</p>
<p>  retry_count INTEGER NOT NULL DEFAULT 0,</p>
<p>  next_retry_at TIMESTAMP,</p>
<p>  error_message TEXT</p>
<p>);</p>

<p>CREATE INDEX idx_inbox_unprocessed ON inbox(received_at)</p>
<p>  WHERE processed_at IS NULL;</p>
<p></code></pre></p>

<hr>

<h2>Step 3: Implement Receptor</h2>

<strong>ECommerce.InventoryWorker/Receptors/ReserveInventoryReceptor.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;
<p>using ECommerce.Contracts.Events;</p>
<p>using Npgsql;</p>
<p>using Dapper;</p>

<p>namespace ECommerce.InventoryWorker.Receptors;</p>

<p>public class ReserveInventoryReceptor : IReceptor<OrderCreated, InventoryReserved> {</p>
<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly IMessageContext _context;</p>
<p>  private readonly ILogger<ReserveInventoryReceptor> _logger;</p>

<p>  public ReserveInventoryReceptor(</p>
<p>    NpgsqlConnection db,</p>
<p>    IMessageContext context,</p>
<p>    ILogger<ReserveInventoryReceptor> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _context = context;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task<InventoryReserved> HandleAsync(</p>
<p>    OrderCreated @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    await using var tx = await _db.BeginTransactionAsync(ct);</p>

<p>    try {</p>
<p>      // Process each item in the order</p>
<p>      foreach (var item in @event.Items) {</p>
<p>        // 1. Check available stock</p>
<p>        var inventory = await _db.QuerySingleOrDefaultAsync<InventoryRow>(</p>
<p>          """</p>
<p>          SELECT product_id, available_stock, reserved_stock, version</p>
<p>          FROM inventory</p>
<p>          WHERE product_id = @ProductId</p>
<p>          FOR UPDATE  -- Row-level lock for concurrency</p>
<p>          """,</p>
<p>          new { ProductId = item.ProductId },</p>
<p>          transaction: tx</p>
<p>        );</p>

<p>        if (inventory == null) {</p>
<p>          throw new InvalidOperationException($"Product {item.ProductId} not found");</p>
<p>        }</p>

<p>        // 2. Check if sufficient stock</p>
<p>        if (inventory.AvailableStock < item.Quantity) {</p>
<p>          // Publish InventoryInsufficient event (compensation)</p>
<p>          var insufficientEvent = new InventoryInsufficient(</p>
<p>            OrderId: @event.OrderId,</p>
<p>            ProductId: item.ProductId,</p>
<p>            RequestedQuantity: item.Quantity,</p>
<p>            AvailableStock: inventory.AvailableStock,</p>
<p>            CheckedAt: DateTime.UtcNow</p>
<p>          );</p>

<p>          // Insert into outbox for publishing</p>
<p>          await PublishEventAsync(insufficientEvent, tx, ct);</p>

<p>          _logger.LogWarning(</p>
<p>            "Insufficient inventory for order {OrderId}, product {ProductId}: requested {Requested}, available {Available}",</p>
<p>            @event.OrderId,</p>
<p>            item.ProductId,</p>
<p>            item.Quantity,</p>
<p>            inventory.AvailableStock</p>
<p>          );</p>

<p>          throw new InsufficientInventoryException(</p>
<p>            item.ProductId,</p>
<p>            item.Quantity,</p>
<p>            inventory.AvailableStock</p>
<p>          );</p>
<p>        }</p>

<p>        // 3. Reserve stock (optimistic concurrency via version)</p>
<p>        var rowsAffected = await _db.ExecuteAsync(</p>
<p>          """</p>
<p>          UPDATE inventory</p>
<p>          SET</p>
<p>            available_stock = available_stock - @Quantity,</p>
<p>            reserved_stock = reserved_stock + @Quantity,</p>
<p>            last_updated = NOW(),</p>
<p>            version = version + 1</p>
<p>          WHERE product_id = @ProductId AND version = @Version</p>
<p>          """,</p>
<p>          new {</p>
<p>            ProductId = item.ProductId,</p>
<p>            Quantity = item.Quantity,</p>
<p>            Version = inventory.Version</p>
<p>          },</p>
<p>          transaction: tx</p>
<p>        );</p>

<p>        if (rowsAffected == 0) {</p>
<p>          // Optimistic concurrency violation - retry</p>
<p>          throw new ConcurrencyException($"Inventory updated concurrently for product {item.ProductId}");</p>
<p>        }</p>

<p>        // 4. Create reservation record</p>
<p>        await _db.ExecuteAsync(</p>
<p>          """</p>
<p>          INSERT INTO inventory_reservations (</p>
<p>            reservation_id, order_id, product_id, quantity_reserved, status, created_at, expires_at</p>
<p>          )</p>
<p>          VALUES (@ReservationId, @OrderId, @ProductId, @Quantity, @Status, NOW(), NOW() + INTERVAL '15 minutes')</p>
<p>          """,</p>
<p>          new {</p>
<p>            ReservationId = Guid.NewGuid().ToString("N"),</p>
<p>            OrderId = @event.OrderId,</p>
<p>            ProductId = item.ProductId,</p>
<p>            Quantity = item.Quantity,</p>
<p>            Status = "Reserved"</p>
<p>          },</p>
<p>          transaction: tx</p>
<p>        );</p>

<p>        // 5. Publish InventoryReserved event</p>
<p>        var reservedEvent = new InventoryReserved(</p>
<p>          OrderId: @event.OrderId,</p>
<p>          ProductId: item.ProductId,</p>
<p>          QuantityReserved: item.Quantity,</p>
<p>          RemainingStock: inventory.AvailableStock - item.Quantity,</p>
<p>          ReservedAt: DateTime.UtcNow</p>
<p>        );</p>

<p>        await PublishEventAsync(reservedEvent, tx, ct);</p>

<p>        _logger.LogInformation(</p>
<p>          "Reserved {Quantity} units of product {ProductId} for order {OrderId}, remaining stock: {RemainingStock}",</p>
<p>          item.Quantity,</p>
<p>          item.ProductId,</p>
<p>          @event.OrderId,</p>
<p>          inventory.AvailableStock - item.Quantity</p>
<p>        );</p>
<p>      }</p>

<p>      await tx.CommitAsync(ct);</p>

<p>      // Return first item's event (simplification for demo)</p>
<p>      return new InventoryReserved(</p>
<p>        OrderId: @event.OrderId,</p>
<p>        ProductId: @event.Items[0].ProductId,</p>
<p>        QuantityReserved: @event.Items[0].Quantity,</p>
<p>        RemainingStock: 0,</p>
<p>        ReservedAt: DateTime.UtcNow</p>
<p>      );</p>
<p>    } catch {</p>
<p>      await tx.RollbackAsync(ct);</p>
<p>      throw;</p>
<p>    }</p>
<p>  }</p>

<p>  private async Task PublishEventAsync<TEvent>(</p>
<p>    TEvent @event,</p>
<p>    NpgsqlTransaction tx,</p>
<p>    CancellationToken ct</p>
<p>  ) where TEvent : IEvent {</p>
<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO outbox (message_id, message_type, message_body, created_at)</p>
<p>      VALUES (@MessageId, @MessageType, @MessageBody::jsonb, NOW())</p>
<p>      """,</p>
<p>      new {</p>
<p>        MessageId = Guid.NewGuid(),</p>
<p>        MessageType = typeof(TEvent).FullName,</p>
<p>        MessageBody = System.Text.Json.JsonSerializer.Serialize(@event)</p>
<p>      },</p>
<p>      transaction: tx</p>
<p>    );</p>
<p>  }</p>
<p>}</p>

<p>public record InventoryRow(</p>
<p>  string ProductId,</p>
<p>  int AvailableStock,</p>
<p>  int ReservedStock,</p>
<p>  int Version</p>
<p>);</p>

<p>public class InsufficientInventoryException : Exception {</p>
<p>  public InsufficientInventoryException(</p>
<p>    string productId,</p>
<p>    int requested,</p>
<p>    int available</p>
<p>  ) : base($"Insufficient inventory for {productId}: requested {requested}, available {available}") { }</p>
<p>}</p>

<p>public class ConcurrencyException : Exception {</p>
<p>  public ConcurrencyException(string message) : base(message) { }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key patterns</strong>:
<ul><li>✅ <strong>Row-Level Locking</strong>: <code>FOR UPDATE</code> prevents concurrent stock deductions</li>
<li>✅ <strong>Optimistic Concurrency</strong>: <code>version</code> column detects concurrent updates</li>
<li>✅ <strong>Compensation</strong>: <code>InventoryInsufficient</code> event published on failure</li>
<li>✅ <strong>Transactional</strong>: All operations (stock update + reservation + outbox) in one transaction</li>
</ul>
<hr>

<h2>Step 4: Perspective (Read Model)</h2>

<strong>ECommerce.InventoryWorker/Perspectives/InventorySummaryPerspective.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;
<p>using ECommerce.Contracts.Events;</p>
<p>using Npgsql;</p>
<p>using Dapper;</p>

<p>namespace ECommerce.InventoryWorker.Perspectives;</p>

<p>public class InventorySummaryPerspective :</p>
<p>  IPerspectiveOf<InventoryReserved>,</p>
<p>  IPerspectiveOf<InventoryInsufficient> {</p>

<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly ILogger<InventorySummaryPerspective> _logger;</p>

<p>  public InventorySummaryPerspective(</p>
<p>    NpgsqlConnection db,</p>
<p>    ILogger<InventorySummaryPerspective> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  // Handle InventoryReserved events</p>
<p>  public async Task HandleAsync(</p>
<p>    InventoryReserved @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO inventory_summary (</p>
<p>        product_id,</p>
<p>        total_reservations,</p>
<p>        total_reserved_quantity,</p>
<p>        last_reservation_at</p>
<p>      )</p>
<p>      VALUES (@ProductId, 1, @Quantity, @ReservedAt)</p>
<p>      ON CONFLICT (product_id) DO UPDATE SET</p>
<p>        total_reservations = inventory_summary.total_reservations + 1,</p>
<p>        total_reserved_quantity = inventory_summary.total_reserved_quantity + @Quantity,</p>
<p>        last_reservation_at = @ReservedAt</p>
<p>      """,</p>
<p>      new {</p>
<p>        ProductId = @event.ProductId,</p>
<p>        Quantity = @event.QuantityReserved,</p>
<p>        ReservedAt = @event.ReservedAt</p>
<p>      }</p>
<p>    );</p>

<p>    _logger.LogInformation(</p>
<p>      "Updated inventory summary for product {ProductId}",</p>
<p>      @event.ProductId</p>
<p>    );</p>
<p>  }</p>

<p>  // Handle InventoryInsufficient events</p>
<p>  public async Task HandleAsync(</p>
<p>    InventoryInsufficient @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO inventory_summary (</p>
<p>        product_id,</p>
<p>        total_insufficient_count,</p>
<p>        last_insufficient_at</p>
<p>      )</p>
<p>      VALUES (@ProductId, 1, @CheckedAt)</p>
<p>      ON CONFLICT (product_id) DO UPDATE SET</p>
<p>        total_insufficient_count = inventory_summary.total_insufficient_count + 1,</p>
<p>        last_insufficient_at = @CheckedAt</p>
<p>      """,</p>
<p>      new {</p>
<p>        ProductId = @event.ProductId,</p>
<p>        CheckedAt = @event.CheckedAt</p>
<p>      }</p>
<p>    );</p>

<p>    _logger.LogWarning(</p>
<p>      "Recorded insufficient inventory for product {ProductId}",</p>
<p>      @event.ProductId</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Perspective schema</strong>:

<strong>ECommerce.InventoryWorker/Database/Migrations/004_CreateInventorySummaryTable.sql</strong>:

<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS inventory_summary (
<p>  product_id TEXT PRIMARY KEY,</p>
<p>  total_reservations BIGINT NOT NULL DEFAULT 0,</p>
<p>  total_reserved_quantity BIGINT NOT NULL DEFAULT 0,</p>
<p>  total_insufficient_count BIGINT NOT NULL DEFAULT 0,</p>
<p>  last_reservation_at TIMESTAMP,</p>
<p>  last_insufficient_at TIMESTAMP</p>
<p>);</p>

<p>CREATE INDEX idx_inventory_summary_last_reservation ON inventory_summary(last_reservation_at DESC);</p>
<p></code></pre></p>

<strong>Why perspectives?</strong>
<ul><li>✅ <strong>Denormalized Read Models</strong>: Fast queries without joins</li>
<li>✅ <strong>Event-Driven Updates</strong>: Automatically updated from events</li>
<li>✅ <strong>CQRS</strong>: Separate read (perspective) from write (receptor) models</li>
</ul>
<hr>

<h2>Step 5: Worker Configuration</h2>

<strong>ECommerce.InventoryWorker/Worker.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;

<p>namespace ECommerce.InventoryWorker;</p>

<p>public class Worker : BackgroundService {</p>
<p>  private readonly IWorkCoordinator _coordinator;</p>
<p>  private readonly IDispatcher _dispatcher;</p>
<p>  private readonly ILogger<Worker> _logger;</p>

<p>  public Worker(</p>
<p>    IWorkCoordinator coordinator,</p>
<p>    IDispatcher dispatcher,</p>
<p>    ILogger<Worker> logger</p>
<p>  ) {</p>
<p>    _coordinator = coordinator;</p>
<p>    _dispatcher = dispatcher;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  protected override async Task ExecuteAsync(CancellationToken stoppingToken) {</p>
<p>    _logger.LogInformation("Inventory Worker started");</p>

<p>    while (!stoppingToken.IsCancellationRequested) {</p>
<p>      try {</p>
<p>        // 1. Claim work batch from inbox</p>
<p>        var workBatch = await _coordinator.ProcessWorkBatchAsync(</p>
<p>          instanceId: Guid.NewGuid(),</p>
<p>          serviceName: "InventoryWorker",</p>
<p>          hostName: Environment.MachineName,</p>
<p>          processId: Environment.ProcessId,</p>
<p>          metadata: null,</p>
<p>          outboxCompletions: [],</p>
<p>          outboxFailures: [],</p>
<p>          inboxCompletions: [],</p>
<p>          inboxFailures: [],</p>
<p>          receptorCompletions: [],</p>
<p>          receptorFailures: [],</p>
<p>          perspectiveCompletions: [],</p>
<p>          perspectiveFailures: [],</p>
<p>          newOutboxMessages: [],</p>
<p>          newInboxMessages: [],</p>
<p>          renewOutboxLeaseIds: [],</p>
<p>          renewInboxLeaseIds: [],</p>
<p>          cancellationToken: stoppingToken</p>
<p>        );</p>

<p>        // 2. Process each inbox message</p>
<p>        foreach (var inboxMessage in workBatch.ClaimedInboxMessages) {</p>
<p>          var @event = DeserializeEvent(inboxMessage);</p>
<p>          if (@event is OrderCreated orderCreated) {</p>
<p>            await _dispatcher.DispatchAsync(orderCreated, stoppingToken);</p>
<p>          }</p>
<p>        }</p>

<p>        // 3. Poll every 5 seconds</p>
<p>        await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);</p>
<p>      } catch (Exception ex) when (ex is not OperationCanceledException) {</p>
<p>        _logger.LogError(ex, "Error in worker loop");</p>
<p>        await Task.Delay(TimeSpan.FromSeconds(10), stoppingToken);</p>
<p>      }</p>
<p>    }</p>

<p>    _logger.LogInformation("Inventory Worker stopped");</p>
<p>  }</p>

<p>  private IEvent DeserializeEvent(InboxMessage message) {</p>
<p>    // Simplified deserialization (use JsonContextRegistry in production)</p>
<p>    return System.Text.Json.JsonSerializer.Deserialize<OrderCreated>(</p>
<p>      message.MessageBody.GetRawText()</p>
<p>    )!;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Program.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;
<p>using Whizbang.Data.Postgres;</p>
<p>using Whizbang.Transports.AzureServiceBus;</p>
<p>using Npgsql;</p>
<p>using ECommerce.InventoryWorker;</p>

<p>var builder = Host.CreateApplicationBuilder(args);</p>

<p>// 1. Add Whizbang</p>
<p>builder.Services.AddWhizbang(options => {</p>
<p>  options.ServiceName = "InventoryWorker";</p>
<p>  options.EnableInbox = true;</p>
<p>  options.EnableOutbox = true;</p>
<p>});</p>

<p>// 2. Add PostgreSQL</p>
<p>builder.Services.AddScoped<NpgsqlConnection>(sp => {</p>
<p>  var connectionString = builder.Configuration.GetConnectionString("InventoryDb");</p>
<p>  return new NpgsqlConnection(connectionString);</p>
<p>});</p>

<p>// 3. Add Azure Service Bus</p>
<p>builder.AddAzureServiceBus("messaging");</p>

<p>// 4. Add Worker</p>
<p>builder.Services.AddHostedService<Worker>();</p>

<p>var host = builder.Build();</p>

<p>// Run migrations</p>
<p>await host.MigrateDatabaseAsync();</p>

<p>await host.RunAsync();</p>
<p></code></pre></p>

<hr>

<h2>Step 6: Aspire Integration</h2>

<strong>Update ECommerce.AppHost/Program.cs</strong>:

<pre><code class="language-csharp">var builder = DistributedApplication.CreateBuilder(args);

<p>// 1. PostgreSQL</p>
<p>var postgres = builder.AddPostgres("postgres").WithPgAdmin();</p>
<p>var ordersDb = postgres.AddDatabase("orders-db");</p>
<p>var inventoryDb = postgres.AddDatabase("inventory-db");  // NEW</p>

<p>// 2. Azure Service Bus</p>
<p>var serviceBus = builder.AddAzureServiceBus("messaging").RunAsEmulator();</p>

<p>// 3. Order Service</p>
<p>var orderService = builder.AddProject<Projects.ECommerce_OrderService_API>("order-service")</p>
<p>  .WithReference(ordersDb)</p>
<p>  .WithReference(serviceBus);</p>

<p>// 4. Inventory Worker (NEW)</p>
<p>var inventoryWorker = builder.AddProject<Projects.ECommerce_InventoryWorker>("inventory-worker")</p>
<p>  .WithReference(inventoryDb)</p>
<p>  .WithReference(serviceBus);</p>

<p>builder.Build().Run();</p>
<p></code></pre></p>

<strong>appsettings.json</strong>:

<pre><code class="language-json">{
<p>  "Logging": {</p>
<p>    "LogLevel": {</p>
<p>      "Default": "Information",</p>
<p>      "Whizbang": "Debug"</p>
<p>    }</p>
<p>  },</p>
<p>  "ConnectionStrings": {</p>
<p>    "InventoryDb": "Host=localhost;Database=inventory;Username=postgres;Password=postgres"</p>
<p>  },</p>
<p>  "Whizbang": {</p>
<p>    "ServiceName": "InventoryWorker",</p>
<p>    "Inbox": {</p>
<p>      "Enabled": true,</p>
<p>      "BatchSize": 100,</p>
<p>      "PollingInterval": "00:00:05"</p>
<p>    },</p>
<p>    "Outbox": {</p>
<p>      "Enabled": true,</p>
<p>      "BatchSize": 100,</p>
<p>      "PollingInterval": "00:00:05"</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Step 7: Test the Flow</h2>

<h3>1. Start Aspire</h3>

<pre><code class="language-bash">cd ECommerce.AppHost
<p>dotnet run</p>
<p></code></pre></p>

<h3>2. Create Order (Triggers Inventory Reservation)</h3>

<pre><code class="language-bash">curl -X POST http://localhost:5000/api/orders \
<p>  -H "Content-Type: application/json" \</p>
<p>  -d '{</p>
<p>    "customerId": "cust-123",</p>
<p>    "items": [</p>
<p>      { "productId": "prod-456", "quantity": 2, "unitPrice": 19.99 }</p>
<p>    ],</p>
<p>    "shippingAddress": {</p>
<p>      "street": "123 Main St",</p>
<p>      "city": "Springfield",</p>
<p>      "state": "IL",</p>
<p>      "zipCode": "62701",</p>
<p>      "country": "USA"</p>
<p>    }</p>
<p>  }'</p>
<p></code></pre></p>

<h3>3. Observe Event Flow</h3>

<p>Check Aspire Dashboard:</p>
<ul><li><strong>Order Service</strong>: <code>OrderCreated</code> event published to Service Bus</li>
<li><strong>Service Bus</strong>: Event routed to <code>OrderCreated</code> topic</li>
<li><strong>Inventory Worker</strong>: Receives event from inbox</li>
<li><strong>Inventory Worker</strong>: Processes event via <code>ReserveInventoryReceptor</code></li>
<li><strong>Service Bus</strong>: <code>InventoryReserved</code> event published</li>
</ul>
<h3>4. Verify Database</h3>

<pre><code class="language-sql">-- Check inventory (stock should be reduced)
<p>SELECT * FROM inventory WHERE product_id = 'prod-456';</p>

<p>-- Check reservations</p>
<p>SELECT * FROM inventory_reservations WHERE product_id = 'prod-456';</p>

<p>-- Check perspective (read model)</p>
<p>SELECT * FROM inventory_summary WHERE product_id = 'prod-456';</p>
<p></code></pre></p>

<strong>Expected</strong>:
<ul><li><code>inventory.available_stock</code> decreased by 2</li>
<li><code>inventory.reserved_stock</code> increased by 2</li>
<li>New row in <code>inventory_reservations</code></li>
<li><code>inventory_summary.total_reservations</code> incremented</li>
</ul>
<hr>

<h2>Key Concepts</h2>

<h3>Inbox Pattern (Exactly-Once Processing)</h3>

<pre><code class="language-">┌─────────────────────────────────────────────────────┐
<p>│  Inbox Pattern - Exactly-Once Processing            │</p>
<p>│                                                      │</p>
<p>│  ┌──────────────────────────────────┐               │</p>
<p>│  │  Azure Service Bus               │               │</p>
<p>│  │  - Message delivered to worker   │               │</p>
<p>│  └──────────────┬───────────────────┘               │</p>
<p>│                 │                                    │</p>
<p>│                 ▼                                    │</p>
<p>│  ┌──────────────────────────────────┐               │</p>
<p>│  │  PostgreSQL Transaction          │               │</p>
<p>│  │                                   │               │</p>
<p>│  │  1. INSERT INTO inbox (msg_id)   │ ← Dedupe!    │</p>
<p>│  │  2. Process message (receptor)   │               │</p>
<p>│  │  3. UPDATE inbox SET processed   │               │</p>
<p>│  │                                   │               │</p>
<p>│  │  COMMIT;                          │               │</p>
<p>│  └──────────────────────────────────┘               │</p>
<p>│                                                      │</p>
<p>│  If duplicate message arrives:                      │</p>
<p>│  - INSERT fails (unique constraint on msg_id)       │</p>
<p>│  - Message skipped (already processed)              │</p>
<p>└─────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ <strong>Exactly-Once</strong>: Duplicate messages automatically skipped</li>
<li>✅ <strong>Idempotent</strong>: Safe to retry failed messages</li>
<li>✅ <strong>Transactional</strong>: Processing + inbox update atomic</li>
</ul>
<h3>Compensation (Saga Pattern)</h3>

<pre><code class="language-">Success Flow:
<p>OrderCreated → InventoryReserved → PaymentProcessed → ShipmentCreated</p>

<p>Failure Flow (Insufficient Inventory):</p>
<p>OrderCreated → InventoryInsufficient → CancelOrder (compensation)</p>

<p>Failure Flow (Payment Failed):</p>
<p>OrderCreated → InventoryReserved → PaymentFailed → ReleaseInventory (compensation)</p>
<p></code></pre></p>

<strong>Compensation handler</strong>:

<strong>ECommerce.InventoryWorker/Receptors/ReleaseInventoryReceptor.cs</strong>:

<pre><code class="language-csharp">public class ReleaseInventoryReceptor : IReceptor<PaymentFailed, InventoryReleased> {
<p>  public async Task<InventoryReleased> HandleAsync(</p>
<p>    PaymentFailed @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    await using var tx = await _db.BeginTransactionAsync(ct);</p>

<p>    // 1. Find reservations for this order</p>
<p>    var reservations = await _db.QueryAsync<ReservationRow>(</p>
<p>      """</p>
<p>      SELECT reservation_id, product_id, quantity_reserved</p>
<p>      FROM inventory_reservations</p>
<p>      WHERE order_id = @OrderId AND status = 'Reserved'</p>
<p>      FOR UPDATE</p>
<p>      """,</p>
<p>      new { OrderId = @event.OrderId },</p>
<p>      transaction: tx</p>
<p>    );</p>

<p>    foreach (var reservation in reservations) {</p>
<p>      // 2. Return stock to available</p>
<p>      await _db.ExecuteAsync(</p>
<p>        """</p>
<p>        UPDATE inventory</p>
<p>        SET</p>
<p>          available_stock = available_stock + @Quantity,</p>
<p>          reserved_stock = reserved_stock - @Quantity</p>
<p>        WHERE product_id = @ProductId</p>
<p>        """,</p>
<p>        new { reservation.ProductId, reservation.QuantityReserved },</p>
<p>        transaction: tx</p>
<p>      );</p>

<p>      // 3. Mark reservation as released</p>
<p>      await _db.ExecuteAsync(</p>
<p>        """</p>
<p>        UPDATE inventory_reservations</p>
<p>        SET status = 'Released'</p>
<p>        WHERE reservation_id = @ReservationId</p>
<p>        """,</p>
<p>        new { reservation.ReservationId },</p>
<p>        transaction: tx</p>
<p>      );</p>
<p>    }</p>

<p>    await tx.CommitAsync(ct);</p>

<p>    return new InventoryReleased(@event.OrderId, DateTime.UtcNow);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Testing</h2>

<h3>Unit Test - Sufficient Stock</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task ReserveInventory_SufficientStock_ReservesAndPublishesEventAsync() {</p>
<p>  // Arrange</p>
<p>  var db = new MockNpgsqlConnection();</p>
<p>  db.SeedInventory("prod-456", availableStock: 100, reservedStock: 0);</p>

<p>  var receptor = new ReserveInventoryReceptor(db, mockContext, mockLogger);</p>
<p>  var @event = new OrderCreated(</p>
<p>    OrderId: "order-123",</p>
<p>    CustomerId: "cust-456",</p>
<p>    Items: [new OrderItem("prod-456", 2, 19.99m, 39.98m)],</p>
<p>    // ... other fields</p>
<p>  );</p>

<p>  // Act</p>
<p>  var result = await receptor.HandleAsync(@event);</p>

<p>  // Assert</p>
<p>  await Assert.That(result.QuantityReserved).IsEqualTo(2);</p>
<p>  await Assert.That(result.RemainingStock).IsEqualTo(98);</p>

<p>  var inventory = db.GetInventory("prod-456");</p>
<p>  await Assert.That(inventory.AvailableStock).IsEqualTo(98);</p>
<p>  await Assert.That(inventory.ReservedStock).IsEqualTo(2);</p>
<p>}</p>
<p></code></pre></p>

<h3>Unit Test - Insufficient Stock</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task ReserveInventory_InsufficientStock_ThrowsExceptionAsync() {</p>
<p>  // Arrange</p>
<p>  var db = new MockNpgsqlConnection();</p>
<p>  db.SeedInventory("prod-456", availableStock: 1, reservedStock: 0);</p>

<p>  var receptor = new ReserveInventoryReceptor(db, mockContext, mockLogger);</p>
<p>  var @event = new OrderCreated(</p>
<p>    OrderId: "order-123",</p>
<p>    CustomerId: "cust-456",</p>
<p>    Items: [new OrderItem("prod-456", 2, 19.99m, 39.98m)],</p>
<p>    // ... other fields</p>
<p>  );</p>

<p>  // Act & Assert</p>
<p>  await Assert.That(async () => await receptor.HandleAsync(@event))</p>
<p>    .Throws<InsufficientInventoryException>();</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Next Steps</h2>

<p>Continue to <strong><a href="payment-processing.md">Payment Processing</a></strong> to:</p>
<ul><li>Subscribe to <code>InventoryReserved</code> events</li>
<li>Implement payment gateway integration</li>
<li>Publish <code>PaymentProcessed</code> events</li>
<li>Handle payment failures (compensation)</li>
</ul>
<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>Inbox Pattern</strong> - Exactly-once event processing with database deduplication</p>
<p>✅ <strong>Row-Level Locking</strong> - <code>FOR UPDATE</code> prevents race conditions</p>
<p>✅ <strong>Optimistic Concurrency</strong> - <code>version</code> column detects concurrent updates</p>
<p>✅ <strong>Compensation</strong> - <code>InventoryInsufficient</code> event triggers order cancellation</p>
<p>✅ <strong>Perspectives</strong> - Denormalized read models for fast queries</p>
<p>✅ <strong>Saga Pattern</strong> - Distributed transactions with compensating actions</p>

<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-tutorial-notification-service" class="doc-section">
  <h3>Notification Service</h3>
  <p class="doc-path"><code>v1.0.0/tutorial/notification-service</code></p>
  <p class="doc-description"><em>Build the Notification Worker - email/SMS notifications, template rendering, and delivery tracking</em></p>
  <div class="doc-content">

<h1>Notification Service</h1>

<p>Build the <strong>Notification Worker</strong> - a background service that subscribes to multiple events (<code>OrderCreated</code>, <code>PaymentProcessed</code>, <code>ShipmentCreated</code>) and sends notifications via email/SMS.</p>

<p>:::note</p>
<p>This is <strong>Part 4</strong> of the ECommerce Tutorial. Complete <a href="payment-processing.md">Payment Processing</a> first.</p>
<p>:::</p>

<hr>

<h2>What You'll Build</h2>

<pre><code class="language-">┌─────────────────────────────────────────────────────────────┐
<p>│  Notification Service Architecture                          │</p>
<p>│                                                              │</p>
<p>│  ┌─────────────┐                                            │</p>
<p>│  │Azure Service│  OrderCreated, PaymentProcessed, etc.      │</p>
<p>│  │     Bus     │──────────────────────────┐                 │</p>
<p>│  └─────────────┘                          │                 │</p>
<p>│                                            ▼                 │</p>
<p>│                          ┌────────────────────────────┐     │</p>
<p>│                          │  Multiple Event Receptors  │     │</p>
<p>│                          │  - OrderConfirmationReceptor│    │</p>
<p>│                          │  - PaymentReceiptReceptor  │     │</p>
<p>│                          │  - ShipmentNotificationReceptor│ │</p>
<p>│                          └──────────┬─────────────────┘     │</p>
<p>│                                     │                        │</p>
<p>│                      ┌──────────────┼──────────────┐        │</p>
<p>│                      │              │              │        │</p>
<p>│                      ▼              ▼              ▼        │</p>
<p>│                 ┌─────────┐   ┌─────────┐   ┌──────────┐   │</p>
<p>│                 │Template │   │  Email  │   │Postgres  │   │</p>
<p>│                 │ Engine  │   │Provider │   │ Tracking │   │</p>
<p>│                 │(Scriban)│   │(SendGrid│   │  Table   │   │</p>
<p>│                 └─────────┘   │/Twilio) │   └──────────┘   │</p>
<p>│                               └─────────┘                    │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Features</strong>:
<ul><li>✅ Multi-event subscriptions</li>
<li>✅ Email notifications (SendGrid)</li>
<li>✅ SMS notifications (Twilio)</li>
<li>✅ Template rendering (Scriban)</li>
<li>✅ Delivery tracking</li>
<li>✅ Retry logic for failed sends</li>
</ul>
<hr>

<h2>Step 1: Notification Providers</h2>

<h3>Email Provider (SendGrid)</h3>

<strong>ECommerce.NotificationWorker/Services/IEmailProvider.cs</strong>:

<pre><code class="language-csharp">namespace ECommerce.NotificationWorker.Services;

<p>public interface IEmailProvider {</p>
<p>  Task<EmailResult> SendEmailAsync(</p>
<p>    string to,</p>
<p>    string subject,</p>
<p>    string htmlBody,</p>
<p>    string? textBody = null,</p>
<p>    CancellationToken ct = default</p>
<p>  );</p>
<p>}</p>

<p>public record EmailResult(</p>
<p>  bool Success,</p>
<p>  string? MessageId,</p>
<p>  string? ErrorMessage</p>
<p>);</p>
<p></code></pre></p>

<strong>ECommerce.NotificationWorker/Services/SendGridEmailProvider.cs</strong>:

<pre><code class="language-csharp">using SendGrid;
<p>using SendGrid.Helpers.Mail;</p>

<p>namespace ECommerce.NotificationWorker.Services;</p>

<p>public class SendGridEmailProvider : IEmailProvider {</p>
<p>  private readonly SendGridClient _client;</p>
<p>  private readonly string _fromEmail;</p>
<p>  private readonly string _fromName;</p>
<p>  private readonly ILogger<SendGridEmailProvider> _logger;</p>

<p>  public SendGridEmailProvider(</p>
<p>    IConfiguration configuration,</p>
<p>    ILogger<SendGridEmailProvider> logger</p>
<p>  ) {</p>
<p>    var apiKey = configuration["SendGrid:ApiKey"]</p>
<p>      ?? throw new InvalidOperationException("SendGrid:ApiKey not configured");</p>

<p>    _client = new SendGridClient(apiKey);</p>
<p>    _fromEmail = configuration["SendGrid:FromEmail"] ?? "noreply@ecommerce.example.com";</p>
<p>    _fromName = configuration["SendGrid:FromName"] ?? "ECommerce Platform";</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task<EmailResult> SendEmailAsync(</p>
<p>    string to,</p>
<p>    string subject,</p>
<p>    string htmlBody,</p>
<p>    string? textBody = null,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    try {</p>
<p>      var from = new EmailAddress(_fromEmail, _fromName);</p>
<p>      var toAddress = new EmailAddress(to);</p>
<p>      var msg = MailHelper.CreateSingleEmail(</p>
<p>        from,</p>
<p>        toAddress,</p>
<p>        subject,</p>
<p>        textBody ?? htmlBody,</p>
<p>        htmlBody</p>
<p>      );</p>

<p>      var response = await _client.SendEmailAsync(msg, ct);</p>

<p>      if (response.IsSuccessStatusCode) {</p>
<p>        var messageId = response.Headers.GetValues("X-Message-Id").FirstOrDefault();</p>
<p>        _logger.LogInformation(</p>
<p>          "Email sent to {To}, subject: {Subject}, messageId: {MessageId}",</p>
<p>          to,</p>
<p>          subject,</p>
<p>          messageId</p>
<p>        );</p>

<p>        return new EmailResult(</p>
<p>          Success: true,</p>
<p>          MessageId: messageId,</p>
<p>          ErrorMessage: null</p>
<p>        );</p>
<p>      } else {</p>
<p>        var errorBody = await response.Body.ReadAsStringAsync();</p>
<p>        _logger.LogError(</p>
<p>          "Email send failed to {To}: {StatusCode} - {Error}",</p>
<p>          to,</p>
<p>          response.StatusCode,</p>
<p>          errorBody</p>
<p>        );</p>

<p>        return new EmailResult(</p>
<p>          Success: false,</p>
<p>          MessageId: null,</p>
<p>          ErrorMessage: $"{response.StatusCode}: {errorBody}"</p>
<p>        );</p>
<p>      }</p>
<p>    } catch (Exception ex) {</p>
<p>      _logger.LogError(ex, "Email send exception for {To}", to);</p>
<p>      return new EmailResult(</p>
<p>        Success: false,</p>
<p>        MessageId: null,</p>
<p>        ErrorMessage: ex.Message</p>
<p>      );</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>SMS Provider (Twilio)</h3>

<strong>ECommerce.NotificationWorker/Services/ISmsProvider.cs</strong>:

<pre><code class="language-csharp">namespace ECommerce.NotificationWorker.Services;

<p>public interface ISmsProvider {</p>
<p>  Task<SmsResult> SendSmsAsync(</p>
<p>    string to,</p>
<p>    string message,</p>
<p>    CancellationToken ct = default</p>
<p>  );</p>
<p>}</p>

<p>public record SmsResult(</p>
<p>  bool Success,</p>
<p>  string? MessageSid,</p>
<p>  string? ErrorMessage</p>
<p>);</p>
<p></code></pre></p>

<strong>ECommerce.NotificationWorker/Services/TwilioSmsProvider.cs</strong>:

<pre><code class="language-csharp">using Twilio;
<p>using Twilio.Rest.Api.V2010.Account;</p>
<p>using Twilio.Types;</p>

<p>namespace ECommerce.NotificationWorker.Services;</p>

<p>public class TwilioSmsProvider : ISmsProvider {</p>
<p>  private readonly string _fromNumber;</p>
<p>  private readonly ILogger<TwilioSmsProvider> _logger;</p>

<p>  public TwilioSmsProvider(</p>
<p>    IConfiguration configuration,</p>
<p>    ILogger<TwilioSmsProvider> logger</p>
<p>  ) {</p>
<p>    var accountSid = configuration["Twilio:AccountSid"]</p>
<p>      ?? throw new InvalidOperationException("Twilio:AccountSid not configured");</p>
<p>    var authToken = configuration["Twilio:AuthToken"]</p>
<p>      ?? throw new InvalidOperationException("Twilio:AuthToken not configured");</p>

<p>    _fromNumber = configuration["Twilio:FromNumber"] ?? "+15551234567";</p>

<p>    TwilioClient.Init(accountSid, authToken);</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task<SmsResult> SendSmsAsync(</p>
<p>    string to,</p>
<p>    string message,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    try {</p>
<p>      var smsMessage = await MessageResource.CreateAsync(</p>
<p>        to: new PhoneNumber(to),</p>
<p>        from: new PhoneNumber(_fromNumber),</p>
<p>        body: message</p>
<p>      );</p>

<p>      if (smsMessage.Status == MessageResource.StatusEnum.Queued ||</p>
<p>          smsMessage.Status == MessageResource.StatusEnum.Sent) {</p>
<p>        _logger.LogInformation(</p>
<p>          "SMS sent to {To}, sid: {Sid}",</p>
<p>          to,</p>
<p>          smsMessage.Sid</p>
<p>        );</p>

<p>        return new SmsResult(</p>
<p>          Success: true,</p>
<p>          MessageSid: smsMessage.Sid,</p>
<p>          ErrorMessage: null</p>
<p>        );</p>
<p>      } else {</p>
<p>        _logger.LogError(</p>
<p>          "SMS send failed to {To}: {Status} - {ErrorMessage}",</p>
<p>          to,</p>
<p>          smsMessage.Status,</p>
<p>          smsMessage.ErrorMessage</p>
<p>        );</p>

<p>        return new SmsResult(</p>
<p>          Success: false,</p>
<p>          MessageSid: null,</p>
<p>          ErrorMessage: smsMessage.ErrorMessage</p>
<p>        );</p>
<p>      }</p>
<p>    } catch (Exception ex) {</p>
<p>      _logger.LogError(ex, "SMS send exception for {To}", to);</p>
<p>      return new SmsResult(</p>
<p>        Success: false,</p>
<p>        MessageSid: null,</p>
<p>        ErrorMessage: ex.Message</p>
<p>      );</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Step 2: Template Engine</h2>

<strong>ECommerce.NotificationWorker/Services/ITemplateRenderer.cs</strong>:

<pre><code class="language-csharp">namespace ECommerce.NotificationWorker.Services;

<p>public interface ITemplateRenderer {</p>
<p>  Task<string> RenderAsync<TModel>(</p>
<p>    string templateName,</p>
<p>    TModel model,</p>
<p>    CancellationToken ct = default</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<strong>ECommerce.NotificationWorker/Services/ScribanTemplateRenderer.cs</strong>:

<pre><code class="language-csharp">using Scriban;
<p>using Scriban.Runtime;</p>

<p>namespace ECommerce.NotificationWorker.Services;</p>

<p>public class ScribanTemplateRenderer : ITemplateRenderer {</p>
<p>  private readonly string _templateDirectory;</p>
<p>  private readonly Dictionary<string, Template> _cache = new();</p>
<p>  private readonly ILogger<ScribanTemplateRenderer> _logger;</p>

<p>  public ScribanTemplateRenderer(</p>
<p>    IConfiguration configuration,</p>
<p>    ILogger<ScribanTemplateRenderer> logger</p>
<p>  ) {</p>
<p>    _templateDirectory = configuration["Templates:Directory"] ?? "Templates";</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task<string> RenderAsync<TModel>(</p>
<p>    string templateName,</p>
<p>    TModel model,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var template = await GetTemplateAsync(templateName, ct);</p>

<p>    var scriptObject = new ScriptObject();</p>
<p>    scriptObject.Import(model, renamer: member => member.Name);</p>

<p>    var context = new TemplateContext();</p>
<p>    context.PushGlobal(scriptObject);</p>

<p>    return await template.RenderAsync(context);</p>
<p>  }</p>

<p>  private async Task<Template> GetTemplateAsync(string templateName, CancellationToken ct) {</p>
<p>    if (_cache.TryGetValue(templateName, out var cachedTemplate)) {</p>
<p>      return cachedTemplate;</p>
<p>    }</p>

<p>    var templatePath = Path.Combine(_templateDirectory, $"{templateName}.liquid");</p>
<p>    if (!File.Exists(templatePath)) {</p>
<p>      throw new FileNotFoundException($"Template not found: {templatePath}");</p>
<p>    }</p>

<p>    var templateContent = await File.ReadAllTextAsync(templatePath, ct);</p>
<p>    var template = Template.Parse(templateContent);</p>

<p>    if (template.HasErrors) {</p>
<p>      var errors = string.Join(", ", template.Messages);</p>
<p>      throw new InvalidOperationException($"Template parse errors: {errors}");</p>
<p>    }</p>

<p>    _cache[templateName] = template;</p>
<p>    return template;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Templates/order-confirmation.liquid</strong>:

<pre><code class="language-liquid"><!DOCTYPE html>
<html>
<head>
<p>  <style></p>
<p>    body { font-family: Arial, sans-serif; }</p>
<p>    .header { background-color: #4CAF50; color: white; padding: 20px; }</p>
<p>    .content { padding: 20px; }</p>
<p>    .order-items { border-collapse: collapse; width: 100%; }</p>
<p>    .order-items th, .order-items td { border: 1px solid #ddd; padding: 8px; }</p>
<p>    .total { font-weight: bold; font-size: 1.2em; }</p>
<p>  </style></p>
<p></head></p>
<body>
<p>  <div class="header"></p>
<p>    <h1>Order Confirmation</h1></p>
<p>  </div></p>
<p>  <div class="content"></p>
<p>    <p>Hi {{ customer_name }},</p></p>
<p>    <p>Thank you for your order! Your order <strong>#{{ order_id }}</strong> has been received and is being processed.</p></p>

<p>    <h2>Order Details</h2></p>
<p>    <table class="order-items"></p>
<p>      <thead></p>
<p>        <tr></p>
<p>          <th>Product</th></p>
<p>          <th>Quantity</th></p>
<p>          <th>Unit Price</th></p>
<p>          <th>Total</th></p>
<p>        </tr></p>
<p>      </thead></p>
<p>      <tbody></p>
<p>        {{ for item in items }}</p>
<p>        <tr></p>
<p>          <td>{{ item.product_id }}</td></p>
<p>          <td>{{ item.quantity }}</td></p>
<p>          <td>${{ item.unit_price }}</td></p>
<p>          <td>${{ item.line_total }}</td></p>
<p>        </tr></p>
<p>        {{ end }}</p>
<p>      </tbody></p>
<p>    </table></p>

<p>    <p class="total">Total: ${{ total_amount }}</p></p>

<p>    <h2>Shipping Address</h2></p>
<p>    
<p>      {{ shipping_address.street }}<br></p>
<p>      {{ shipping_address.city }}, {{ shipping_address.state }} {{ shipping_address.zip_code }}<br></p>
<p>      {{ shipping_address.country }}</p>
<p>    </p></p>

<p>    <p>We'll send you another email when your order ships.</p></p>
<p>    <p>Thanks,<br>The ECommerce Team</p></p>
<p>  </div></p>
<p></body></p>
<p></html></p>
<p></code></pre></p>

<hr>

<h2>Step 3: Database Schema</h2>

<strong>ECommerce.NotificationWorker/Database/Migrations/001_CreateNotificationsTable.sql</strong>:

<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS notifications (
<p>  notification_id TEXT PRIMARY KEY,</p>
<p>  order_id TEXT NOT NULL,</p>
<p>  notification_type TEXT NOT NULL,  -- 'OrderConfirmation', 'PaymentReceipt', 'ShipmentNotification'</p>
<p>  channel TEXT NOT NULL,  -- 'Email', 'SMS'</p>
<p>  recipient TEXT NOT NULL,</p>
<p>  subject TEXT,</p>
<p>  message TEXT NOT NULL,</p>
<p>  status TEXT NOT NULL,  -- 'Sent', 'Failed', 'Pending'</p>
<p>  provider_message_id TEXT,</p>
<p>  error_message TEXT,</p>
<p>  sent_at TIMESTAMP,</p>
<p>  created_at TIMESTAMP NOT NULL DEFAULT NOW()</p>
<p>);</p>

<p>CREATE INDEX idx_notifications_order_id ON notifications(order_id);</p>
<p>CREATE INDEX idx_notifications_status ON notifications(status);</p>
<p>CREATE INDEX idx_notifications_created_at ON notifications(created_at DESC);</p>
<p></code></pre></p>

<hr>

<h2>Step 4: Implement Receptors</h2>

<h3>Order Confirmation Receptor</h3>

<strong>ECommerce.NotificationWorker/Receptors/OrderConfirmationReceptor.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;
<p>using ECommerce.Contracts.Events;</p>
<p>using ECommerce.NotificationWorker.Services;</p>
<p>using Npgsql;</p>
<p>using Dapper;</p>

<p>namespace ECommerce.NotificationWorker.Receptors;</p>

<p>public class OrderConfirmationReceptor : IReceptor<OrderCreated, NotificationSent> {</p>
<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly IEmailProvider _emailProvider;</p>
<p>  private readonly ITemplateRenderer _templateRenderer;</p>
<p>  private readonly ILogger<OrderConfirmationReceptor> _logger;</p>

<p>  public OrderConfirmationReceptor(</p>
<p>    NpgsqlConnection db,</p>
<p>    IEmailProvider emailProvider,</p>
<p>    ITemplateRenderer templateRenderer,</p>
<p>    ILogger<OrderConfirmationReceptor> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _emailProvider = emailProvider;</p>
<p>    _templateRenderer = templateRenderer;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task<NotificationSent> HandleAsync(</p>
<p>    OrderCreated @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var notificationId = Guid.NewGuid().ToString("N");</p>

<p>    try {</p>
<p>      // 1. Get customer email (in production, query customer service)</p>
<p>      var customerEmail = $"{@event.CustomerId}@example.com";  // Demo</p>

<p>      // 2. Render email template</p>
<p>      var htmlBody = await _templateRenderer.RenderAsync(</p>
<p>        "order-confirmation",</p>
<p>        new {</p>
<p>          customer_name = @event.CustomerId,</p>
<p>          order_id = @event.OrderId,</p>
<p>          items = @event.Items.Select(i => new {</p>
<p>            product_id = i.ProductId,</p>
<p>            quantity = i.Quantity,</p>
<p>            unit_price = i.UnitPrice,</p>
<p>            line_total = i.LineTotal</p>
<p>          }),</p>
<p>          total_amount = @event.TotalAmount,</p>
<p>          shipping_address = new {</p>
<p>            street = @event.ShippingAddress.Street,</p>
<p>            city = @event.ShippingAddress.City,</p>
<p>            state = @event.ShippingAddress.State,</p>
<p>            zip_code = @event.ShippingAddress.ZipCode,</p>
<p>            country = @event.ShippingAddress.Country</p>
<p>          }</p>
<p>        },</p>
<p>        ct</p>
<p>      );</p>

<p>      // 3. Send email</p>
<p>      var result = await _emailProvider.SendEmailAsync(</p>
<p>        to: customerEmail,</p>
<p>        subject: $"Order Confirmation - #{@event.OrderId}",</p>
<p>        htmlBody: htmlBody,</p>
<p>        ct: ct</p>
<p>      );</p>

<p>      // 4. Track notification</p>
<p>      await _db.ExecuteAsync(</p>
<p>        """</p>
<p>        INSERT INTO notifications (</p>
<p>          notification_id, order_id, notification_type, channel, recipient, subject, message,</p>
<p>          status, provider_message_id, error_message, sent_at, created_at</p>
<p>        )</p>
<p>        VALUES (</p>
<p>          @NotificationId, @OrderId, @NotificationType, @Channel, @Recipient, @Subject, @Message,</p>
<p>          @Status, @ProviderMessageId, @ErrorMessage, @SentAt, NOW()</p>
<p>        )</p>
<p>        """,</p>
<p>        new {</p>
<p>          NotificationId = notificationId,</p>
<p>          OrderId = @event.OrderId,</p>
<p>          NotificationType = "OrderConfirmation",</p>
<p>          Channel = "Email",</p>
<p>          Recipient = customerEmail,</p>
<p>          Subject = $"Order Confirmation - #{@event.OrderId}",</p>
<p>          Message = htmlBody,</p>
<p>          Status = result.Success ? "Sent" : "Failed",</p>
<p>          ProviderMessageId = result.MessageId,</p>
<p>          ErrorMessage = result.ErrorMessage,</p>
<p>          SentAt = result.Success ? DateTime.UtcNow : (DateTime?)null</p>
<p>        }</p>
<p>      );</p>

<p>      if (result.Success) {</p>
<p>        _logger.LogInformation(</p>
<p>          "Order confirmation sent for order {OrderId} to {Email}",</p>
<p>          @event.OrderId,</p>
<p>          customerEmail</p>
<p>        );</p>

<p>        return new NotificationSent(</p>
<p>          NotificationId: notificationId,</p>
<p>          OrderId: @event.OrderId,</p>
<p>          NotificationType: "OrderConfirmation",</p>
<p>          Channel: "Email",</p>
<p>          SentAt: DateTime.UtcNow</p>
<p>        );</p>
<p>      } else {</p>
<p>        throw new NotificationFailedException(</p>
<p>          notificationId,</p>
<p>          "OrderConfirmation",</p>
<p>          result.ErrorMessage ?? "Email send failed"</p>
<p>        );</p>
<p>      }</p>
<p>    } catch (Exception ex) when (ex is not NotificationFailedException) {</p>
<p>      _logger.LogError(ex, "Failed to send order confirmation for order {OrderId}", @event.OrderId);</p>
<p>      throw new NotificationFailedException(notificationId, "OrderConfirmation", ex.Message);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>

<p>public record NotificationSent(</p>
<p>  string NotificationId,</p>
<p>  string OrderId,</p>
<p>  string NotificationType,</p>
<p>  string Channel,</p>
<p>  DateTime SentAt</p>
<p>) : IEvent;</p>

<p>public class NotificationFailedException : Exception {</p>
<p>  public NotificationFailedException(string notificationId, string type, string message)</p>
<p>    : base($"Notification {notificationId} ({type}) failed: {message}") { }</p>
<p>}</p>
<p></code></pre></p>

<h3>Payment Receipt Receptor</h3>

<strong>ECommerce.NotificationWorker/Receptors/PaymentReceiptReceptor.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;
<p>using ECommerce.Contracts.Events;</p>
<p>using ECommerce.NotificationWorker.Services;</p>
<p>using Npgsql;</p>
<p>using Dapper;</p>

<p>namespace ECommerce.NotificationWorker.Receptors;</p>

<p>public class PaymentReceiptReceptor : IReceptor<PaymentProcessed, NotificationSent> {</p>
<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly IEmailProvider _emailProvider;</p>
<p>  private readonly ITemplateRenderer _templateRenderer;</p>
<p>  private readonly ILogger<PaymentReceiptReceptor> _logger;</p>

<p>  public PaymentReceiptReceptor(</p>
<p>    NpgsqlConnection db,</p>
<p>    IEmailProvider emailProvider,</p>
<p>    ITemplateRenderer templateRenderer,</p>
<p>    ILogger<PaymentReceiptReceptor> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _emailProvider = emailProvider;</p>
<p>    _templateRenderer = templateRenderer;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task<NotificationSent> HandleAsync(</p>
<p>    PaymentProcessed @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var notificationId = Guid.NewGuid().ToString("N");</p>

<p>    // Similar implementation to OrderConfirmationReceptor</p>
<p>    // Render "payment-receipt" template and send email</p>

<p>    // For brevity, omitted - follows same pattern as OrderConfirmation</p>

<p>    return new NotificationSent(</p>
<p>      NotificationId: notificationId,</p>
<p>      OrderId: @event.OrderId,</p>
<p>      NotificationType: "PaymentReceipt",</p>
<p>      Channel: "Email",</p>
<p>      SentAt: DateTime.UtcNow</p>
<p>    );</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Shipment Notification Receptor (SMS)</h3>

<strong>ECommerce.NotificationWorker/Receptors/ShipmentNotificationReceptor.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;
<p>using ECommerce.Contracts.Events;</p>
<p>using ECommerce.NotificationWorker.Services;</p>
<p>using Npgsql;</p>
<p>using Dapper;</p>

<p>namespace ECommerce.NotificationWorker.Receptors;</p>

<p>public class ShipmentNotificationReceptor : IReceptor<ShipmentCreated, NotificationSent> {</p>
<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly ISmsProvider _smsProvider;</p>
<p>  private readonly ILogger<ShipmentNotificationReceptor> _logger;</p>

<p>  public ShipmentNotificationReceptor(</p>
<p>    NpgsqlConnection db,</p>
<p>    ISmsProvider smsProvider,</p>
<p>    ILogger<ShipmentNotificationReceptor> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _smsProvider = smsProvider;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task<NotificationSent> HandleAsync(</p>
<p>    ShipmentCreated @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var notificationId = Guid.NewGuid().ToString("N");</p>

<p>    try {</p>
<p>      // 1. Get customer phone (in production, query customer service)</p>
<p>      var customerPhone = "+15551234567";  // Demo</p>

<p>      // 2. Build SMS message</p>
<p>      var message = $"Your order #{@event.OrderId} has shipped! " +</p>
<p>                    $"Tracking: {@event.TrackingNumber}. " +</p>
<p>                    $"Estimated delivery: {@event.EstimatedDelivery:MM/dd/yyyy}";</p>

<p>      // 3. Send SMS</p>
<p>      var result = await _smsProvider.SendSmsAsync(</p>
<p>        to: customerPhone,</p>
<p>        message: message,</p>
<p>        ct: ct</p>
<p>      );</p>

<p>      // 4. Track notification</p>
<p>      await _db.ExecuteAsync(</p>
<p>        """</p>
<p>        INSERT INTO notifications (</p>
<p>          notification_id, order_id, notification_type, channel, recipient, message,</p>
<p>          status, provider_message_id, error_message, sent_at, created_at</p>
<p>        )</p>
<p>        VALUES (</p>
<p>          @NotificationId, @OrderId, @NotificationType, @Channel, @Recipient, @Message,</p>
<p>          @Status, @ProviderMessageId, @ErrorMessage, @SentAt, NOW()</p>
<p>        )</p>
<p>        """,</p>
<p>        new {</p>
<p>          NotificationId = notificationId,</p>
<p>          OrderId = @event.OrderId,</p>
<p>          NotificationType = "ShipmentNotification",</p>
<p>          Channel = "SMS",</p>
<p>          Recipient = customerPhone,</p>
<p>          Message = message,</p>
<p>          Status = result.Success ? "Sent" : "Failed",</p>
<p>          ProviderMessageId = result.MessageSid,</p>
<p>          ErrorMessage = result.ErrorMessage,</p>
<p>          SentAt = result.Success ? DateTime.UtcNow : (DateTime?)null</p>
<p>        }</p>
<p>      );</p>

<p>      if (result.Success) {</p>
<p>        _logger.LogInformation(</p>
<p>          "Shipment notification sent for order {OrderId} to {Phone}",</p>
<p>          @event.OrderId,</p>
<p>          customerPhone</p>
<p>        );</p>

<p>        return new NotificationSent(</p>
<p>          NotificationId: notificationId,</p>
<p>          OrderId: @event.OrderId,</p>
<p>          NotificationType: "ShipmentNotification",</p>
<p>          Channel: "SMS",</p>
<p>          SentAt: DateTime.UtcNow</p>
<p>        );</p>
<p>      } else {</p>
<p>        throw new NotificationFailedException(</p>
<p>          notificationId,</p>
<p>          "ShipmentNotification",</p>
<p>          result.ErrorMessage ?? "SMS send failed"</p>
<p>        );</p>
<p>      }</p>
<p>    } catch (Exception ex) when (ex is not NotificationFailedException) {</p>
<p>      _logger.LogError(ex, "Failed to send shipment notification for order {OrderId}", @event.OrderId);</p>
<p>      throw new NotificationFailedException(notificationId, "ShipmentNotification", ex.Message);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Step 5: Service Configuration</h2>

<strong>ECommerce.NotificationWorker/Program.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;
<p>using Whizbang.Data.Postgres;</p>
<p>using Whizbang.Transports.AzureServiceBus;</p>
<p>using Npgsql;</p>
<p>using ECommerce.NotificationWorker.Services;</p>

<p>var builder = Host.CreateApplicationBuilder(args);</p>

<p>// 1. Add Whizbang</p>
<p>builder.Services.AddWhizbang(options => {</p>
<p>  options.ServiceName = "NotificationWorker";</p>
<p>  options.EnableInbox = true;</p>
<p>});</p>

<p>// 2. Add PostgreSQL</p>
<p>builder.Services.AddScoped<NpgsqlConnection>(sp => {</p>
<p>  var connectionString = builder.Configuration.GetConnectionString("NotificationDb");</p>
<p>  return new NpgsqlConnection(connectionString);</p>
<p>});</p>

<p>// 3. Add Azure Service Bus</p>
<p>builder.AddAzureServiceBus("messaging");</p>

<p>// 4. Add notification providers</p>
<p>builder.Services.AddSingleton<IEmailProvider, SendGridEmailProvider>();</p>
<p>builder.Services.AddSingleton<ISmsProvider, TwilioSmsProvider>();</p>
<p>builder.Services.AddSingleton<ITemplateRenderer, ScribanTemplateRenderer>();</p>

<p>// 5. Add Worker</p>
<p>builder.Services.AddHostedService<Worker>();</p>

<p>var host = builder.Build();</p>
<p>await host.MigrateDatabaseAsync();</p>
<p>await host.RunAsync();</p>
<p></code></pre></p>

<strong>appsettings.json</strong>:

<pre><code class="language-json">{
<p>  "Logging": {</p>
<p>    "LogLevel": {</p>
<p>      "Default": "Information",</p>
<p>      "Whizbang": "Debug"</p>
<p>    }</p>
<p>  },</p>
<p>  "ConnectionStrings": {</p>
<p>    "NotificationDb": "Host=localhost;Database=notification;Username=postgres;Password=postgres"</p>
<p>  },</p>
<p>  "SendGrid": {</p>
<p>    "ApiKey": "SG.xxx",</p>
<p>    "FromEmail": "noreply@ecommerce.example.com",</p>
<p>    "FromName": "ECommerce Platform"</p>
<p>  },</p>
<p>  "Twilio": {</p>
<p>    "AccountSid": "ACxxx",</p>
<p>    "AuthToken": "xxx",</p>
<p>    "FromNumber": "+15551234567"</p>
<p>  },</p>
<p>  "Templates": {</p>
<p>    "Directory": "Templates"</p>
<p>  },</p>
<p>  "Whizbang": {</p>
<p>    "ServiceName": "NotificationWorker",</p>
<p>    "Inbox": {</p>
<p>      "Enabled": true,</p>
<p>      "BatchSize": 100,</p>
<p>      "PollingInterval": "00:00:05"</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Step 6: Test Notifications</h2>

<h3>1. Update Aspire</h3>

<strong>ECommerce.AppHost/Program.cs</strong>:

<pre><code class="language-csharp">var notificationDb = postgres.AddDatabase("notification-db");

<p>var notificationWorker = builder.AddProject<Projects.ECommerce_NotificationWorker>("notification-worker")</p>
<p>  .WithReference(notificationDb)</p>
<p>  .WithReference(serviceBus);</p>
<p></code></pre></p>

<h3>2. Create Order</h3>

<pre><code class="language-bash">curl -X POST http://localhost:5000/api/orders \
<p>  -H "Content-Type: application/json" \</p>
<p>  -d '{ ... }'</p>
<p></code></pre></p>

<h3>3. Check Email (SendGrid Dashboard)</h3>

<p>Navigate to SendGrid dashboard → Activity Feed → Search for recipient email</p>

<h3>4. Verify Database</h3>

<pre><code class="language-sql">SELECT * FROM notifications WHERE order_id = '<order-id>';
<p></code></pre></p>

<strong>Expected</strong>:
<ul><li>Row for <code>OrderConfirmation</code> (Email) with <code>status = 'Sent'</code></li>
<li>Row for <code>PaymentReceipt</code> (Email) with <code>status = 'Sent'</code></li>
<li>Row for <code>ShipmentNotification</code> (SMS) with <code>status = 'Sent'</code></li>
</ul>
<hr>

<h2>Key Concepts</h2>

<h3>Multi-Event Subscriptions</h3>

<pre><code class="language-csharp">// Single service subscribes to multiple events
<p>public class OrderConfirmationReceptor : IReceptor<OrderCreated, NotificationSent> { }</p>
<p>public class PaymentReceiptReceptor : IReceptor<PaymentProcessed, NotificationSent> { }</p>
<p>public class ShipmentNotificationReceptor : IReceptor<ShipmentCreated, NotificationSent> { }</p>
<p></code></pre></p>

<strong>Azure Service Bus</strong>:
<ul><li>OrderCreated → <code>order-confirmation-subscription</code></li>
<li>PaymentProcessed → <code>payment-receipt-subscription</code></li>
<li>ShipmentCreated → <code>shipment-notification-subscription</code></li>
</ul>
<h3>Template Rendering</h3>

<pre><code class="language-liquid">{{ for item in items }}
<p>  <tr></p>
<p>    <td>{{ item.product_id }}</td></p>
<p>    <td>{{ item.quantity }}</td></p>
<p>    <td>${{ item.unit_price }}</td></p>
<p>  </tr></p>
<p>{{ end }}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ <strong>Separation of Concerns</strong>: Business logic separate from presentation</li>
<li>✅ <strong>Non-Technical Editing</strong>: Marketing can update templates</li>
<li>✅ <strong>Testability</strong>: Unit test template rendering independently</li>
</ul>
<hr>

<h2>Testing</h2>

<h3>Unit Test - Email Rendering</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task OrderConfirmation_RendersTemplateCorrectlyAsync() {</p>
<p>  // Arrange</p>
<p>  var renderer = new ScribanTemplateRenderer(mockConfig, mockLogger);</p>
<p>  var model = new {</p>
<p>    customer_name = "John Doe",</p>
<p>    order_id = "order-123",</p>
<p>    items = new[] {</p>
<p>      new { product_id = "prod-456", quantity = 2, unit_price = 19.99m, line_total = 39.98m }</p>
<p>    },</p>
<p>    total_amount = 39.98m,</p>
<p>    shipping_address = new { street = "123 Main", city = "Springfield", state = "IL", zip_code = "62701", country = "USA" }</p>
<p>  };</p>

<p>  // Act</p>
<p>  var html = await renderer.RenderAsync("order-confirmation", model);</p>

<p>  // Assert</p>
<p>  await Assert.That(html).Contains("Order Confirmation");</p>
<p>  await Assert.That(html).Contains("order-123");</p>
<p>  await Assert.That(html).Contains("$39.98");</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Next Steps</h2>

<p>Continue to <strong><a href="shipping-service.md">Shipping Service</a></strong> to:</p>
<ul><li>Subscribe to <code>PaymentProcessed</code> events</li>
<li>Create shipments via carrier API</li>
<li>Publish <code>ShipmentCreated</code> events</li>
<li>Track shipment status</li>
</ul>
<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>Multi-Event Subscriptions</strong> - Single service handles multiple event types</p>
<p>✅ <strong>Template Rendering</strong> - Scriban for maintainable email templates</p>
<p>✅ <strong>Provider Abstraction</strong> - Swap email/SMS providers easily</p>
<p>✅ <strong>Delivery Tracking</strong> - Store notification history for auditing</p>
<p>✅ <strong>Graceful Failures</strong> - Log errors, don't block order processing</p>

<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-tutorial-order-management" class="doc-section">
  <h3>Order Management Service</h3>
  <p class="doc-path"><code>v1.0.0/tutorial/order-management</code></p>
  <p class="doc-description"><em>Build the Order Service - HTTP API, command handling, event publishing, and PostgreSQL persistence</em></p>
  <div class="doc-content">

<h1>Order Management Service</h1>

<p>Build the <strong>Order Service</strong> - an HTTP API that accepts order creation requests, validates them, persists to PostgreSQL, and publishes events to Azure Service Bus.</p>

<p>:::note</p>
<p>This is <strong>Part 1</strong> of the ECommerce Tutorial. Start with <a href="tutorial-overview.md">Tutorial Overview</a> if you haven't already.</p>
<p>:::</p>

<hr>

<h2>What You'll Build</h2>

<pre><code class="language-">┌─────────────────────────────────────────────────────────┐
<p>│  Order Service Architecture                             │</p>
<p>│                                                          │</p>
<p>│  ┌──────────────┐                                       │</p>
<p>│  │    HTTP      │                                       │</p>
<p>│  │  Controller  │  POST /orders                         │</p>
<p>│  └──────┬───────┘                                       │</p>
<p>│         │                                                │</p>
<p>│         ▼                                                │</p>
<p>│  ┌──────────────┐  CreateOrder command                  │</p>
<p>│  │  Dispatcher  │─────────────────────────┐             │</p>
<p>│  └──────────────┘                         │             │</p>
<p>│                                            ▼             │</p>
<p>│                                 ┌─────────────────────┐ │</p>
<p>│                                 │ CreateOrderReceptor │ │</p>
<p>│                                 │  - Validate order   │ │</p>
<p>│                                 │  - Save to DB       │ │</p>
<p>│                                 │  - Publish event    │ │</p>
<p>│                                 └─────────┬───────────┘ │</p>
<p>│                                           │             │</p>
<p>│                              ┌────────────┼───────────┐ │</p>
<p>│                              │            │           │ │</p>
<p>│                              ▼            ▼           ▼ │</p>
<p>│                         ┌────────┐  ┌─────────┐  ┌─────┐</p>
<p>│                         │Postgres│  │ Outbox  │  │ ASB │</p>
<p>│                         │ Orders │  │ Table   │  │ Bus │</p>
<p>│                         └────────┘  └─────────┘  └─────┘</p>
<p>└─────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Features</strong>:
<ul><li>✅ HTTP API endpoint for order creation</li>
<li>✅ Command handling with validation</li>
<li>✅ PostgreSQL persistence with outbox pattern</li>
<li>✅ Event publishing to Azure Service Bus</li>
<li>✅ Message context (correlation, causation, tracing)</li>
<li>✅ .NET Aspire orchestration</li>
</ul>
<hr>

<h2>Step 1: Define Messages</h2>

<h3>Commands</h3>

<strong>ECommerce.Contracts/Commands/CreateOrder.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;

<p>namespace ECommerce.Contracts.Commands;</p>

<p>public record CreateOrder(</p>
<p>  string CustomerId,</p>
<p>  OrderItem[] Items,</p>
<p>  Address ShippingAddress</p>
<p>) : ICommand<OrderCreated>;</p>

<p>public record OrderItem(</p>
<p>  string ProductId,</p>
<p>  int Quantity,</p>
<p>  decimal UnitPrice</p>
<p>);</p>

<p>public record Address(</p>
<p>  string Street,</p>
<p>  string City,</p>
<p>  string State,</p>
<p>  string ZipCode,</p>
<p>  string Country</p>
<p>);</p>
<p></code></pre></p>

<h3>Events</h3>

<strong>ECommerce.Contracts/Events/OrderCreated.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;

<p>namespace ECommerce.Contracts.Events;</p>

<p>public record OrderCreated(</p>
<p>  string OrderId,</p>
<p>  string CustomerId,</p>
<p>  OrderItem[] Items,</p>
<p>  Address ShippingAddress,</p>
<p>  decimal TotalAmount,</p>
<p>  DateTime CreatedAt</p>
<p>) : IEvent;</p>

<p>public record OrderItem(</p>
<p>  string ProductId,</p>
<p>  int Quantity,</p>
<p>  decimal UnitPrice,</p>
<p>  decimal LineTotal</p>
<p>);</p>

<p>public record Address(</p>
<p>  string Street,</p>
<p>  string City,</p>
<p>  string State,</p>
<p>  string ZipCode,</p>
<p>  string Country</p>
<p>);</p>
<p></code></pre></p>

<strong>Why separate records?</strong>
<ul><li>Commands and events have different lifecycles</li>
<li>Event includes calculated fields (<code>OrderId</code>, <code>TotalAmount</code>, <code>LineTotal</code>)</li>
<li>Event is immutable history, command is intent</li>
</ul>
<hr>

<h2>Step 2: Database Schema</h2>

<h3>Orders Table</h3>

<strong>ECommerce.OrderService.API/Database/Migrations/001_CreateOrdersTable.sql</strong>:

<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS orders (
<p>  order_id TEXT PRIMARY KEY,</p>
<p>  customer_id TEXT NOT NULL,</p>
<p>  total_amount NUMERIC(10, 2) NOT NULL,</p>
<p>  status TEXT NOT NULL,</p>
<p>  shipping_address JSONB NOT NULL,</p>
<p>  created_at TIMESTAMP NOT NULL DEFAULT NOW(),</p>
<p>  updated_at TIMESTAMP NOT NULL DEFAULT NOW()</p>
<p>);</p>

<p>CREATE INDEX idx_orders_customer_id ON orders(customer_id);</p>
<p>CREATE INDEX idx_orders_created_at ON orders(created_at DESC);</p>
<p></code></pre></p>

<h3>Order Items Table</h3>

<strong>ECommerce.OrderService.API/Database/Migrations/002_CreateOrderItemsTable.sql</strong>:

<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS order_items (
<p>  order_item_id TEXT PRIMARY KEY,</p>
<p>  order_id TEXT NOT NULL REFERENCES orders(order_id) ON DELETE CASCADE,</p>
<p>  product_id TEXT NOT NULL,</p>
<p>  quantity INTEGER NOT NULL,</p>
<p>  unit_price NUMERIC(10, 2) NOT NULL,</p>
<p>  line_total NUMERIC(10, 2) NOT NULL,</p>
<p>  created_at TIMESTAMP NOT NULL DEFAULT NOW()</p>
<p>);</p>

<p>CREATE INDEX idx_order_items_order_id ON order_items(order_id);</p>
<p>CREATE INDEX idx_order_items_product_id ON order_items(product_id);</p>
<p></code></pre></p>

<h3>Outbox Table</h3>

<strong>ECommerce.OrderService.API/Database/Migrations/003_CreateOutboxTable.sql</strong>:

<pre><code class="language-sql">-- Whizbang outbox pattern for reliable event publishing
<p>CREATE TABLE IF NOT EXISTS outbox (</p>
<p>  message_id UUID PRIMARY KEY,</p>
<p>  message_type TEXT NOT NULL,</p>
<p>  message_body JSONB NOT NULL,</p>
<p>  created_at TIMESTAMP NOT NULL DEFAULT NOW(),</p>
<p>  processed_at TIMESTAMP,</p>
<p>  retry_count INTEGER NOT NULL DEFAULT 0,</p>
<p>  next_retry_at TIMESTAMP,</p>
<p>  error_message TEXT</p>
<p>);</p>

<p>CREATE INDEX idx_outbox_unprocessed ON outbox(created_at)</p>
<p>  WHERE processed_at IS NULL;</p>
<p></code></pre></p>

<hr>

<h2>Step 3: Implement Receptor</h2>

<strong>ECommerce.OrderService.API/Receptors/CreateOrderReceptor.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;
<p>using ECommerce.Contracts.Commands;</p>
<p>using ECommerce.Contracts.Events;</p>
<p>using Npgsql;</p>
<p>using Dapper;</p>

<p>namespace ECommerce.OrderService.API.Receptors;</p>

<p>public class CreateOrderReceptor : IReceptor<CreateOrder, OrderCreated> {</p>
<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly IMessageContext _context;</p>
<p>  private readonly ILogger<CreateOrderReceptor> _logger;</p>

<p>  public CreateOrderReceptor(</p>
<p>    NpgsqlConnection db,</p>
<p>    IMessageContext context,</p>
<p>    ILogger<CreateOrderReceptor> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _context = context;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task<OrderCreated> HandleAsync(</p>
<p>    CreateOrder command,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    // 1. Validate</p>
<p>    if (command.Items.Length == 0) {</p>
<p>      throw new ValidationException("Order must have at least one item");</p>
<p>    }</p>

<p>    // 2. Calculate totals</p>
<p>    var orderId = Guid.NewGuid().ToString("N");</p>
<p>    var totalAmount = command.Items.Sum(i => i.Quantity * i.UnitPrice);</p>
<p>    var createdAt = DateTime.UtcNow;</p>

<p>    // 3. Save order (with outbox pattern)</p>
<p>    await using var tx = await _db.BeginTransactionAsync(ct);</p>

<p>    try {</p>
<p>      // Insert order</p>
<p>      await _db.ExecuteAsync(</p>
<p>        """</p>
<p>        INSERT INTO orders (order_id, customer_id, total_amount, status, shipping_address, created_at, updated_at)</p>
<p>        VALUES (@OrderId, @CustomerId, @TotalAmount, @Status, @ShippingAddress::jsonb, @CreatedAt, @CreatedAt)</p>
<p>        """,</p>
<p>        new {</p>
<p>          OrderId = orderId,</p>
<p>          CustomerId = command.CustomerId,</p>
<p>          TotalAmount = totalAmount,</p>
<p>          Status = "Pending",</p>
<p>          ShippingAddress = System.Text.Json.JsonSerializer.Serialize(command.ShippingAddress),</p>
<p>          CreatedAt = createdAt</p>
<p>        },</p>
<p>        transaction: tx</p>
<p>      );</p>

<p>      // Insert order items</p>
<p>      foreach (var item in command.Items) {</p>
<p>        var lineTotal = item.Quantity * item.UnitPrice;</p>
<p>        await _db.ExecuteAsync(</p>
<p>          """</p>
<p>          INSERT INTO order_items (order_item_id, order_id, product_id, quantity, unit_price, line_total, created_at)</p>
<p>          VALUES (@OrderItemId, @OrderId, @ProductId, @Quantity, @UnitPrice, @LineTotal, @CreatedAt)</p>
<p>          """,</p>
<p>          new {</p>
<p>            OrderItemId = Guid.NewGuid().ToString("N"),</p>
<p>            OrderId = orderId,</p>
<p>            ProductId = item.ProductId,</p>
<p>            Quantity = item.Quantity,</p>
<p>            UnitPrice = item.UnitPrice,</p>
<p>            LineTotal = lineTotal,</p>
<p>            CreatedAt = createdAt</p>
<p>          },</p>
<p>          transaction: tx</p>
<p>        );</p>
<p>      }</p>

<p>      // 4. Create event</p>
<p>      var @event = new OrderCreated(</p>
<p>        OrderId: orderId,</p>
<p>        CustomerId: command.CustomerId,</p>
<p>        Items: command.Items.Select(i => new Contracts.Events.OrderItem(</p>
<p>          ProductId: i.ProductId,</p>
<p>          Quantity: i.Quantity,</p>
<p>          UnitPrice: i.UnitPrice,</p>
<p>          LineTotal: i.Quantity * i.UnitPrice</p>
<p>        )).ToArray(),</p>
<p>        ShippingAddress: new Contracts.Events.Address(</p>
<p>          Street: command.ShippingAddress.Street,</p>
<p>          City: command.ShippingAddress.City,</p>
<p>          State: command.ShippingAddress.State,</p>
<p>          ZipCode: command.ShippingAddress.ZipCode,</p>
<p>          Country: command.ShippingAddress.Country</p>
<p>        ),</p>
<p>        TotalAmount: totalAmount,</p>
<p>        CreatedAt: createdAt</p>
<p>      );</p>

<p>      // 5. Insert into outbox (same transaction)</p>
<p>      await _db.ExecuteAsync(</p>
<p>        """</p>
<p>        INSERT INTO outbox (message_id, message_type, message_body, created_at)</p>
<p>        VALUES (@MessageId, @MessageType, @MessageBody::jsonb, @CreatedAt)</p>
<p>        """,</p>
<p>        new {</p>
<p>          MessageId = _context.MessageId,</p>
<p>          MessageType = typeof(OrderCreated).FullName,</p>
<p>          MessageBody = System.Text.Json.JsonSerializer.Serialize(@event),</p>
<p>          CreatedAt = createdAt</p>
<p>        },</p>
<p>        transaction: tx</p>
<p>      );</p>

<p>      await tx.CommitAsync(ct);</p>

<p>      _logger.LogInformation(</p>
<p>        "Order {OrderId} created for customer {CustomerId} with {ItemCount} items, total ${TotalAmount}",</p>
<p>        orderId,</p>
<p>        command.CustomerId,</p>
<p>        command.Items.Length,</p>
<p>        totalAmount</p>
<p>      );</p>

<p>      return @event;</p>
<p>    } catch {</p>
<p>      await tx.RollbackAsync(ct);</p>
<p>      throw;</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key patterns</strong>:
<ul><li>✅ <strong>Outbox Pattern</strong>: Event inserted in same transaction as order</li>
<li>✅ <strong>Validation</strong>: Business rules enforced before persistence</li>
<li>✅ <strong>Message Context</strong>: <code>_context.MessageId</code> for correlation</li>
<li>✅ <strong>Transactional</strong>: All-or-nothing via PostgreSQL transaction</li>
</ul>
<hr>

<h2>Step 4: HTTP API</h2>

<strong>ECommerce.OrderService.API/Controllers/OrdersController.cs</strong>:

<pre><code class="language-csharp">using Microsoft.AspNetCore.Mvc;
<p>using Whizbang.Core;</p>
<p>using ECommerce.Contracts.Commands;</p>

<p>namespace ECommerce.OrderService.API.Controllers;</p>

<p>[ApiController]</p>
<p>[Route("api/[controller]")]</p>
<p>public class OrdersController : ControllerBase {</p>
<p>  private readonly IDispatcher _dispatcher;</p>
<p>  private readonly ILogger<OrdersController> _logger;</p>

<p>  public OrdersController(</p>
<p>    IDispatcher dispatcher,</p>
<p>    ILogger<OrdersController> logger</p>
<p>  ) {</p>
<p>    _dispatcher = dispatcher;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  [HttpPost]</p>
<p>  [ProducesResponseType(StatusCodes.Status201Created)]</p>
<p>  [ProducesResponseType(StatusCodes.Status400BadRequest)]</p>
<p>  public async Task<IActionResult> CreateOrder(</p>
<p>    [FromBody] CreateOrder command,</p>
<p>    CancellationToken ct</p>
<p>  ) {</p>
<p>    try {</p>
<p>      var result = await _dispatcher.DispatchAsync(command, ct);</p>

<p>      return CreatedAtAction(</p>
<p>        nameof(GetOrder),</p>
<p>        new { orderId = result.OrderId },</p>
<p>        result</p>
<p>      );</p>
<p>    } catch (ValidationException ex) {</p>
<p>      return BadRequest(new { error = ex.Message });</p>
<p>    }</p>
<p>  }</p>

<p>  [HttpGet("{orderId}")]</p>
<p>  [ProducesResponseType(StatusCodes.Status200OK)]</p>
<p>  [ProducesResponseType(StatusCodes.Status404NotFound)]</p>
<p>  public async Task<IActionResult> GetOrder(string orderId) {</p>
<p>    // TODO: Implement query (Part 4 - Customer Service)</p>
<p>    return NotFound();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Step 5: Service Configuration</h2>

<strong>ECommerce.OrderService.API/Program.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;
<p>using Whizbang.Data.Postgres;</p>
<p>using Whizbang.Transports.AzureServiceBus;</p>
<p>using Whizbang.Hosting.Azure.ServiceBus;</p>
<p>using Npgsql;</p>

<p>var builder = WebApplication.CreateBuilder(args);</p>

<p>// 1. Add Whizbang</p>
<p>builder.Services.AddWhizbang(options => {</p>
<p>  options.ServiceName = "OrderService";</p>
<p>  options.EnableOutbox = true;</p>
<p>  options.EnableInbox = true;</p>
<p>});</p>

<p>// 2. Add PostgreSQL</p>
<p>builder.Services.AddScoped<NpgsqlConnection>(sp => {</p>
<p>  var connectionString = builder.Configuration.GetConnectionString("OrdersDb");</p>
<p>  return new NpgsqlConnection(connectionString);</p>
<p>});</p>

<p>// 3. Add Azure Service Bus</p>
<p>builder.AddAzureServiceBus("messaging");</p>

<p>// 4. Add Aspire service defaults</p>
<p>builder.AddServiceDefaults();</p>

<p>// 5. Add controllers</p>
<p>builder.Services.AddControllers();</p>
<p>builder.Services.AddEndpointsApiExplorer();</p>
<p>builder.Services.AddSwaggerGen();</p>

<p>var app = builder.Build();</p>

<p>// Configure HTTP pipeline</p>
<p>if (app.Environment.IsDevelopment()) {</p>
<p>  app.UseSwagger();</p>
<p>  app.UseSwaggerUI();</p>
<p>}</p>

<p>app.UseHttpsRedirection();</p>
<p>app.UseAuthorization();</p>
<p>app.MapControllers();</p>

<p>// Run database migrations</p>
<p>await app.MigrateDatabaseAsync();</p>

<p>app.Run();</p>
<p></code></pre></p>

<strong>Database migration helper</strong>:

<strong>ECommerce.OrderService.API/Extensions/MigrationExtensions.cs</strong>:

<pre><code class="language-csharp">using Npgsql;
<p>using Dapper;</p>

<p>namespace ECommerce.OrderService.API.Extensions;</p>

<p>public static class MigrationExtensions {</p>
<p>  public static async Task MigrateDatabaseAsync(this WebApplication app) {</p>
<p>    using var scope = app.Services.CreateScope();</p>
<p>    var db = scope.ServiceProvider.GetRequiredService<NpgsqlConnection>();</p>
<p>    var logger = scope.ServiceProvider.GetRequiredService<ILogger<Program>>();</p>

<p>    var migrationFiles = Directory.GetFiles(</p>
<p>      Path.Combine(AppContext.BaseDirectory, "Database/Migrations"),</p>
<p>      "*.sql"</p>
<p>    ).OrderBy(f => f);</p>

<p>    foreach (var file in migrationFiles) {</p>
<p>      var sql = await File.ReadAllTextAsync(file);</p>
<p>      await db.ExecuteAsync(sql);</p>
<p>      logger.LogInformation("Applied migration: {File}", Path.GetFileName(file));</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Step 6: Aspire Orchestration</h2>

<strong>ECommerce.AppHost/Program.cs</strong>:

<pre><code class="language-csharp">var builder = DistributedApplication.CreateBuilder(args);

<p>// 1. Add PostgreSQL</p>
<p>var postgres = builder.AddPostgres("postgres")</p>
<p>  .WithPgAdmin();</p>

<p>var ordersDb = postgres.AddDatabase("orders-db");</p>

<p>// 2. Add Azure Service Bus (emulator for local dev)</p>
<p>var serviceBus = builder.AddAzureServiceBus("messaging")</p>
<p>  .RunAsEmulator();</p>

<p>// 3. Add Order Service</p>
<p>var orderService = builder.AddProject<Projects.ECommerce_OrderService_API>("order-service")</p>
<p>  .WithReference(ordersDb)</p>
<p>  .WithReference(serviceBus);</p>

<p>builder.Build().Run();</p>
<p></code></pre></p>

<strong>appsettings.json</strong>:

<pre><code class="language-json">{
<p>  "Logging": {</p>
<p>    "LogLevel": {</p>
<p>      "Default": "Information",</p>
<p>      "Microsoft.AspNetCore": "Warning",</p>
<p>      "Whizbang": "Debug"</p>
<p>    }</p>
<p>  },</p>
<p>  "AllowedHosts": "*",</p>
<p>  "ConnectionStrings": {</p>
<p>    "OrdersDb": "Host=localhost;Database=orders;Username=postgres;Password=postgres"</p>
<p>  },</p>
<p>  "Whizbang": {</p>
<p>    "ServiceName": "OrderService",</p>
<p>    "Outbox": {</p>
<p>      "Enabled": true,</p>
<p>      "BatchSize": 100,</p>
<p>      "PollingInterval": "00:00:05"</p>
<p>    },</p>
<p>    "Inbox": {</p>
<p>      "Enabled": true,</p>
<p>      "BatchSize": 100</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Step 7: Test the Flow</h2>

<h3>1. Start Aspire</h3>

<pre><code class="language-bash">cd ECommerce.AppHost
<p>dotnet run</p>
<p></code></pre></p>

<p>Open Aspire Dashboard: <code>http://localhost:15000</code></p>

<h3>2. Create Order</h3>

<pre><code class="language-bash">curl -X POST http://localhost:5000/api/orders \
<p>  -H "Content-Type: application/json" \</p>
<p>  -d '{</p>
<p>    "customerId": "cust-123",</p>
<p>    "items": [</p>
<p>      {</p>
<p>        "productId": "prod-456",</p>
<p>        "quantity": 2,</p>
<p>        "unitPrice": 19.99</p>
<p>      },</p>
<p>      {</p>
<p>        "productId": "prod-789",</p>
<p>        "quantity": 1,</p>
<p>        "unitPrice": 49.99</p>
<p>      }</p>
<p>    ],</p>
<p>    "shippingAddress": {</p>
<p>      "street": "123 Main St",</p>
<p>      "city": "Springfield",</p>
<p>      "state": "IL",</p>
<p>      "zipCode": "62701",</p>
<p>      "country": "USA"</p>
<p>    }</p>
<p>  }'</p>
<p></code></pre></p>

<strong>Expected response</strong>:

<pre><code class="language-json">{
<p>  "orderId": "a1b2c3d4e5f6",</p>
<p>  "customerId": "cust-123",</p>
<p>  "items": [</p>
<p>    {</p>
<p>      "productId": "prod-456",</p>
<p>      "quantity": 2,</p>
<p>      "unitPrice": 19.99,</p>
<p>      "lineTotal": 39.98</p>
<p>    },</p>
<p>    {</p>
<p>      "productId": "prod-789",</p>
<p>      "quantity": 1,</p>
<p>      "unitPrice": 49.99,</p>
<p>      "lineTotal": 49.99</p>
<p>    }</p>
<p>  ],</p>
<p>  "shippingAddress": {</p>
<p>    "street": "123 Main St",</p>
<p>    "city": "Springfield",</p>
<p>    "state": "IL",</p>
<p>    "zipCode": "62701",</p>
<p>    "country": "USA"</p>
<p>  },</p>
<p>  "totalAmount": 89.97,</p>
<p>  "createdAt": "2024-12-12T10:30:00Z"</p>
<p>}</p>
<p></code></pre></p>

<h3>3. Verify Database</h3>

<pre><code class="language-sql">-- Connect to PostgreSQL
<p>psql -h localhost -U postgres -d orders</p>

<p>-- Check order</p>
<p>SELECT * FROM orders;</p>

<p>-- Check items</p>
<p>SELECT * FROM order_items;</p>

<p>-- Check outbox (event pending)</p>
<p>SELECT message_id, message_type, created_at, processed_at</p>
<p>FROM outbox;</p>
<p></code></pre></p>

<h3>4. Verify Event Publishing</h3>

<p>Check Aspire Dashboard:</p>
<ul><li><strong>Order Service</strong>: HTTP request logged</li>
<li><strong>Service Bus</strong>: OrderCreated event published</li>
<li><strong>Outbox Worker</strong>: Picked up event from outbox table</li>
</ul>
<hr>

<h2>Key Concepts</h2>

<h3>Outbox Pattern</h3>

<pre><code class="language-">┌─────────────────────────────────────────────────────┐
<p>│  Transactional Outbox Pattern                       │</p>
<p>│                                                      │</p>
<p>│  ┌──────────────────────────────────┐               │</p>
<p>│  │  PostgreSQL Transaction          │               │</p>
<p>│  │                                   │               │</p>
<p>│  │  1. INSERT INTO orders (...)     │               │</p>
<p>│  │  2. INSERT INTO order_items (...) │               │</p>
<p>│  │  3. INSERT INTO outbox (...)     │ ← Same TX!   │</p>
<p>│  │                                   │               │</p>
<p>│  │  COMMIT;                          │               │</p>
<p>│  └──────────────┬───────────────────┘               │</p>
<p>│                 │                                    │</p>
<p>│                 ▼                                    │</p>
<p>│  ┌──────────────────────────────────┐               │</p>
<p>│  │  Background Worker (Whizbang)    │               │</p>
<p>│  │                                   │               │</p>
<p>│  │  - SELECT * FROM outbox WHERE    │               │</p>
<p>│  │    processed_at IS NULL          │               │</p>
<p>│  │  - Publish to Azure Service Bus  │               │</p>
<p>│  │  - UPDATE outbox SET             │               │</p>
<p>│  │    processed_at = NOW()          │               │</p>
<p>│  └──────────────────────────────────┘               │</p>
<p>└─────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ <strong>Atomic</strong>: Order + event in single transaction</li>
<li>✅ <strong>Reliable</strong>: Event guaranteed published (eventually)</li>
<li>✅ <strong>Consistent</strong>: No partial state (order saved but event lost)</li>
</ul>
<h3>Message Context</h3>

<pre><code class="language-csharp">public interface IMessageContext {
<p>  Guid MessageId { get; }           // Unique ID for this message</p>
<p>  Guid? CorrelationId { get; }      // Business transaction ID</p>
<p>  Guid? CausationId { get; }        // ID of message that caused this one</p>
<p>  string? UserId { get; }           // User who initiated request</p>
<p>  IDictionary<string, string> Metadata { get; } // Custom metadata</p>
<p>}</p>
<p></code></pre></p>

<strong>Flow example</strong>:

<pre><code class="language-">HTTP Request
<p>  CorrelationId: req-123</p>
<p>  MessageId: msg-001</p>

<p>CreateOrder Command</p>
<p>  CorrelationId: req-123 (same)</p>
<p>  CausationId: msg-001</p>
<p>  MessageId: msg-002</p>

<p>OrderCreated Event</p>
<p>  CorrelationId: req-123 (same)</p>
<p>  CausationId: msg-002</p>
<p>  MessageId: msg-003</p>
<p></code></pre></p>

<p>This enables <strong>distributed tracing</strong> across services.</p>

<hr>

<h2>Testing</h2>

<h3>Unit Test</h3>

<strong>ECommerce.OrderService.Tests/CreateOrderReceptorTests.cs</strong>:

<pre><code class="language-csharp">using TUnit.Core;
<p>using TUnit.Assertions;</p>
<p>using ECommerce.OrderService.API.Receptors;</p>
<p>using ECommerce.Contracts.Commands;</p>

<p>namespace ECommerce.OrderService.Tests;</p>

<p>public class CreateOrderReceptorTests {</p>
<p>  [Test]</p>
<p>  public async Task HandleAsync_ValidOrder_ReturnsOrderCreatedEvent() {</p>
<p>    // Arrange</p>
<p>    var db = new MockNpgsqlConnection();</p>
<p>    var context = new MockMessageContext();</p>
<p>    var logger = new MockLogger<CreateOrderReceptor>();</p>
<p>    var receptor = new CreateOrderReceptor(db, context, logger);</p>

<p>    var command = new CreateOrder(</p>
<p>      CustomerId: "cust-123",</p>
<p>      Items: [</p>
<p>        new OrderItem("prod-456", 2, 19.99m)</p>
<p>      ],</p>
<p>      ShippingAddress: new Address("123 Main", "Springfield", "IL", "62701", "USA")</p>
<p>    );</p>

<p>    // Act</p>
<p>    var result = await receptor.HandleAsync(command);</p>

<p>    // Assert</p>
<p>    await Assert.That(result.CustomerId).IsEqualTo("cust-123");</p>
<p>    await Assert.That(result.TotalAmount).IsEqualTo(39.98m);</p>
<p>    await Assert.That(result.Items).HasCount().EqualTo(1);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Integration Test</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task CreateOrder_EndToEnd_PublishesEvent() {</p>
<p>  // Arrange</p>
<p>  var factory = new WebApplicationFactory<Program>();</p>
<p>  var client = factory.CreateClient();</p>

<p>  var command = new {</p>
<p>    customerId = "cust-123",</p>
<p>    items = new[] {</p>
<p>      new { productId = "prod-456", quantity = 2, unitPrice = 19.99 }</p>
<p>    },</p>
<p>    shippingAddress = new {</p>
<p>      street = "123 Main",</p>
<p>      city = "Springfield",</p>
<p>      state = "IL",</p>
<p>      zipCode = "62701",</p>
<p>      country = "USA"</p>
<p>    }</p>
<p>  };</p>

<p>  // Act</p>
<p>  var response = await client.PostAsJsonAsync("/api/orders", command);</p>

<p>  // Assert</p>
<p>  await Assert.That(response.StatusCode).IsEqualTo(HttpStatusCode.Created);</p>

<p>  var result = await response.Content.ReadFromJsonAsync<OrderCreated>();</p>
<p>  await Assert.That(result!.TotalAmount).IsEqualTo(39.98m);</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Common Issues</h2>

<h3>Issue 1: "Outbox table not found"</h3>

<strong>Cause</strong>: Migration not run
<strong>Fix</strong>:
<pre><code class="language-bash"># Ensure migrations executed on startup
<p>dotnet run --project ECommerce.OrderService.API</p>
<p></code></pre></p>

<h3>Issue 2: "Event not published"</h3>

<strong>Cause</strong>: Outbox worker not running
<strong>Fix</strong>: Check Aspire dashboard for worker logs. Verify Service Bus connection.

<h3>Issue 3: "Transaction deadlock"</h3>

<strong>Cause</strong>: Long-running transaction
<strong>Fix</strong>: Keep receptor logic fast. Move heavy processing to event handlers.

<hr>

<h2>Next Steps</h2>

<p>Continue to <strong><a href="inventory-service.md">Inventory Service</a></strong> to:</p>
<ul><li>Subscribe to <code>OrderCreated</code> events</li>
<li>Implement inventory reservation</li>
<li>Publish <code>InventoryReserved</code> events</li>
<li>Handle compensation (stock release)</li>
</ul>
<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>Outbox Pattern</strong> - Atomic event publishing with database transactions</p>
<p>✅ <strong>Command/Event Separation</strong> - Clear intent (command) vs. fact (event)</p>
<p>✅ <strong>Message Context</strong> - Distributed tracing with correlation IDs</p>
<p>✅ <strong>Validation</strong> - Business rules enforced in receptors</p>
<p>✅ <strong>.NET Aspire</strong> - Local orchestration with PostgreSQL + Service Bus emulators</p>

<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-tutorial-payment-processing" class="doc-section">
  <h3>Payment Processing Service</h3>
  <p class="doc-path"><code>v1.0.0/tutorial/payment-processing</code></p>
  <p class="doc-description"><em>Build the Payment Worker - payment gateway integration, distributed transactions, and compensation</em></p>
  <div class="doc-content">

<h1>Payment Processing Service</h1>

<p>Build the <strong>Payment Worker</strong> - a background service that subscribes to <code>InventoryReserved</code> events, processes payments via external gateway, and handles failures with compensation.</p>

<p>:::note</p>
<p>This is <strong>Part 3</strong> of the ECommerce Tutorial. Complete <a href="inventory-service.md">Inventory Service</a> first.</p>
<p>:::</p>

<hr>

<h2>What You'll Build</h2>

<pre><code class="language-">┌─────────────────────────────────────────────────────────────┐
<p>│  Payment Service Architecture                               │</p>
<p>│                                                              │</p>
<p>│  ┌─────────────┐                                            │</p>
<p>│  │Azure Service│  InventoryReserved event                   │</p>
<p>│  │     Bus     │──────────────────────┐                     │</p>
<p>│  └─────────────┘                      │                     │</p>
<p>│                                        ▼                     │</p>
<p>│                          ┌────────────────────────┐         │</p>
<p>│                          │  Inbox Pattern         │         │</p>
<p>│                          └──────────┬─────────────┘         │</p>
<p>│                                     │                        │</p>
<p>│                                     ▼                        │</p>
<p>│                          ┌────────────────────────┐         │</p>
<p>│                          │ ProcessPaymentReceptor │         │</p>
<p>│                          │  - Call gateway API    │         │</p>
<p>│                          │  - Retry logic         │         │</p>
<p>│                          │  - Store transaction   │         │</p>
<p>│                          └──────────┬─────────────┘         │</p>
<p>│                                     │                        │</p>
<p>│                      ┌──────────────┼──────────────┐        │</p>
<p>│                      │              │              │        │</p>
<p>│                      ▼              ▼              ▼        │</p>
<p>│                 ┌─────────┐   ┌─────────┐   ┌──────────┐   │</p>
<p>│                 │Postgres │   │ Outbox  │   │ Payment  │   │</p>
<p>│                 │Payments │   │ Table   │   │ Gateway  │   │</p>
<p>│                 │  Table  │   │         │   │   API    │   │</p>
<p>│                 └─────────┘   └─────────┘   └──────────┘   │</p>
<p>│                                     │                        │</p>
<p>│                      ┌──────────────┼──────────────┐        │</p>
<p>│                      │              │              │        │</p>
<p>│                      ▼              ▼              ▼        │</p>
<p>│              ┌──────────────┐  ┌──────────────┐  ┌────────┐│</p>
<p>│              │PaymentProcessed│ │PaymentFailed │ │Outbox  ││</p>
<p>│              │     Event      │ │    Event     │ │Worker  ││</p>
<p>│              └──────────────┘  └──────────────┘  └────────┘│</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Features</strong>:
<ul><li>✅ Payment gateway integration (Stripe example)</li>
<li>✅ Retry logic with exponential backoff</li>
<li>✅ Idempotency (payment deduplication)</li>
<li>✅ Distributed transaction coordination</li>
<li>✅ Compensation (refunds on failure)</li>
<li>✅ Circuit breaker pattern</li>
</ul>
<hr>

<h2>Step 1: Define Events</h2>

<h3>PaymentProcessed Event</h3>

<strong>ECommerce.Contracts/Events/PaymentProcessed.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;

<p>namespace ECommerce.Contracts.Events;</p>

<p>public record PaymentProcessed(</p>
<p>  string OrderId,</p>
<p>  string PaymentId,</p>
<p>  string TransactionId,</p>
<p>  decimal Amount,</p>
<p>  string PaymentMethod,</p>
<p>  PaymentStatus Status,</p>
<p>  DateTime ProcessedAt</p>
<p>) : IEvent;</p>

<p>public enum PaymentStatus {</p>
<p>  Authorized,</p>
<p>  Captured,</p>
<p>  Failed,</p>
<p>  Refunded</p>
<p>}</p>
<p></code></pre></p>

<h3>PaymentFailed Event (Compensation)</h3>

<strong>ECommerce.Contracts/Events/PaymentFailed.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;

<p>namespace ECommerce.Contracts.Events;</p>

<p>public record PaymentFailed(</p>
<p>  string OrderId,</p>
<p>  string PaymentId,</p>
<p>  string Reason,</p>
<p>  string ErrorCode,</p>
<p>  DateTime FailedAt</p>
<p>) : IEvent;</p>
<p></code></pre></p>

<hr>

<h2>Step 2: Database Schema</h2>

<h3>Payments Table</h3>

<strong>ECommerce.PaymentWorker/Database/Migrations/001_CreatePaymentsTable.sql</strong>:

<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS payments (
<p>  payment_id TEXT PRIMARY KEY,</p>
<p>  order_id TEXT NOT NULL UNIQUE,  -- One payment per order</p>
<p>  transaction_id TEXT,  -- External gateway transaction ID</p>
<p>  amount NUMERIC(10, 2) NOT NULL,</p>
<p>  payment_method TEXT NOT NULL,</p>
<p>  status TEXT NOT NULL,</p>
<p>  gateway_response JSONB,</p>
<p>  created_at TIMESTAMP NOT NULL DEFAULT NOW(),</p>
<p>  updated_at TIMESTAMP NOT NULL DEFAULT NOW()</p>
<p>);</p>

<p>CREATE INDEX idx_payments_order_id ON payments(order_id);</p>
<p>CREATE INDEX idx_payments_transaction_id ON payments(transaction_id);</p>
<p>CREATE INDEX idx_payments_status ON payments(status);</p>
<p></code></pre></p>

<hr>

<h2>Step 3: Payment Gateway Abstraction</h2>

<strong>ECommerce.PaymentWorker/Services/IPaymentGateway.cs</strong>:

<pre><code class="language-csharp">namespace ECommerce.PaymentWorker.Services;

<p>public interface IPaymentGateway {</p>
<p>  Task<PaymentResult> ChargeAsync(</p>
<p>    string idempotencyKey,</p>
<p>    decimal amount,</p>
<p>    string currency,</p>
<p>    string paymentMethod,</p>
<p>    CancellationToken ct = default</p>
<p>  );</p>

<p>  Task<RefundResult> RefundAsync(</p>
<p>    string transactionId,</p>
<p>    decimal amount,</p>
<p>    CancellationToken ct = default</p>
<p>  );</p>
<p>}</p>

<p>public record PaymentResult(</p>
<p>  bool Success,</p>
<p>  string? TransactionId,</p>
<p>  string? ErrorCode,</p>
<p>  string? ErrorMessage</p>
<p>);</p>

<p>public record RefundResult(</p>
<p>  bool Success,</p>
<p>  string? RefundId,</p>
<p>  string? ErrorMessage</p>
<p>);</p>
<p></code></pre></p>

<h3>Stripe Implementation</h3>

<strong>ECommerce.PaymentWorker/Services/StripePaymentGateway.cs</strong>:

<pre><code class="language-csharp">using Stripe;

<p>namespace ECommerce.PaymentWorker.Services;</p>

<p>public class StripePaymentGateway : IPaymentGateway {</p>
<p>  private readonly PaymentIntentService _paymentIntentService;</p>
<p>  private readonly RefundService _refundService;</p>
<p>  private readonly ILogger<StripePaymentGateway> _logger;</p>

<p>  public StripePaymentGateway(</p>
<p>    PaymentIntentService paymentIntentService,</p>
<p>    RefundService refundService,</p>
<p>    ILogger<StripePaymentGateway> logger</p>
<p>  ) {</p>
<p>    _paymentIntentService = paymentIntentService;</p>
<p>    _refundService = refundService;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task<PaymentResult> ChargeAsync(</p>
<p>    string idempotencyKey,</p>
<p>    decimal amount,</p>
<p>    string currency,</p>
<p>    string paymentMethod,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    try {</p>
<p>      var options = new PaymentIntentCreateOptions {</p>
<p>        Amount = (long)(amount * 100), // Stripe uses cents</p>
<p>        Currency = currency.ToLowerInvariant(),</p>
<p>        PaymentMethod = paymentMethod,</p>
<p>        Confirm = true,</p>
<p>        AutomaticPaymentMethods = new PaymentIntentAutomaticPaymentMethodsOptions {</p>
<p>          Enabled = true,</p>
<p>          AllowRedirects = "never"</p>
<p>        }</p>
<p>      };</p>

<p>      var requestOptions = new RequestOptions {</p>
<p>        IdempotencyKey = idempotencyKey  // Prevents duplicate charges</p>
<p>      };</p>

<p>      var intent = await _paymentIntentService.CreateAsync(</p>
<p>        options,</p>
<p>        requestOptions,</p>
<p>        ct</p>
<p>      );</p>

<p>      if (intent.Status == "succeeded") {</p>
<p>        return new PaymentResult(</p>
<p>          Success: true,</p>
<p>          TransactionId: intent.Id,</p>
<p>          ErrorCode: null,</p>
<p>          ErrorMessage: null</p>
<p>        );</p>
<p>      } else {</p>
<p>        return new PaymentResult(</p>
<p>          Success: false,</p>
<p>          TransactionId: intent.Id,</p>
<p>          ErrorCode: intent.Status,</p>
<p>          ErrorMessage: $"Payment intent status: {intent.Status}"</p>
<p>        );</p>
<p>      }</p>
<p>    } catch (StripeException ex) {</p>
<p>      _logger.LogError(ex, "Stripe payment failed: {ErrorCode}", ex.StripeError?.Code);</p>

<p>      return new PaymentResult(</p>
<p>        Success: false,</p>
<p>        TransactionId: null,</p>
<p>        ErrorCode: ex.StripeError?.Code ?? "unknown",</p>
<p>        ErrorMessage: ex.Message</p>
<p>      );</p>
<p>    }</p>
<p>  }</p>

<p>  public async Task<RefundResult> RefundAsync(</p>
<p>    string transactionId,</p>
<p>    decimal amount,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    try {</p>
<p>      var options = new RefundCreateOptions {</p>
<p>        PaymentIntent = transactionId,</p>
<p>        Amount = (long)(amount * 100)</p>
<p>      };</p>

<p>      var refund = await _refundService.CreateAsync(options, cancellationToken: ct);</p>

<p>      return new RefundResult(</p>
<p>        Success: refund.Status == "succeeded",</p>
<p>        RefundId: refund.Id,</p>
<p>        ErrorMessage: refund.Status == "failed" ? refund.FailureReason : null</p>
<p>      );</p>
<p>    } catch (StripeException ex) {</p>
<p>      _logger.LogError(ex, "Stripe refund failed: {ErrorCode}", ex.StripeError?.Code);</p>

<p>      return new RefundResult(</p>
<p>        Success: false,</p>
<p>        RefundId: null,</p>
<p>        ErrorMessage: ex.Message</p>
<p>      );</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Step 4: Implement Receptor</h2>

<strong>ECommerce.PaymentWorker/Receptors/ProcessPaymentReceptor.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;
<p>using ECommerce.Contracts.Events;</p>
<p>using ECommerce.PaymentWorker.Services;</p>
<p>using Npgsql;</p>
<p>using Dapper;</p>
<p>using Polly;</p>
<p>using Polly.CircuitBreaker;</p>

<p>namespace ECommerce.PaymentWorker.Receptors;</p>

<p>public class ProcessPaymentReceptor : IReceptor<InventoryReserved, PaymentProcessed> {</p>
<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly IPaymentGateway _gateway;</p>
<p>  private readonly IMessageContext _context;</p>
<p>  private readonly ILogger<ProcessPaymentReceptor> _logger;</p>

<p>  // Retry policy: 3 attempts with exponential backoff</p>
<p>  private static readonly AsyncPolicy<PaymentResult> RetryPolicy = Policy</p>
<p>    .Handle<HttpRequestException>()</p>
<p>    .Or<TaskCanceledException>()</p>
<p>    .OrResult<PaymentResult>(r => !r.Success && r.ErrorCode == "network_error")</p>
<p>    .WaitAndRetryAsync(</p>
<p>      retryCount: 3,</p>
<p>      sleepDurationProvider: attempt => TimeSpan.FromSeconds(Math.Pow(2, attempt)),</p>
<p>      onRetry: (outcome, timespan, retryCount, context) => {</p>
<p>        Console.WriteLine($"Payment retry {retryCount} after {timespan}");</p>
<p>      }</p>
<p>    );</p>

<p>  // Circuit breaker: Open after 5 consecutive failures, half-open after 30s</p>
<p>  private static readonly AsyncCircuitBreakerPolicy CircuitBreakerPolicy = Policy</p>
<p>    .Handle<HttpRequestException>()</p>
<p>    .CircuitBreakerAsync(</p>
<p>      exceptionsAllowedBeforeBreaking: 5,</p>
<p>      durationOfBreak: TimeSpan.FromSeconds(30),</p>
<p>      onBreak: (ex, duration) => {</p>
<p>        Console.WriteLine($"Circuit breaker opened for {duration}");</p>
<p>      },</p>
<p>      onReset: () => {</p>
<p>        Console.WriteLine("Circuit breaker reset");</p>
<p>      }</p>
<p>    );</p>

<p>  public ProcessPaymentReceptor(</p>
<p>    NpgsqlConnection db,</p>
<p>    IPaymentGateway gateway,</p>
<p>    IMessageContext context,</p>
<p>    ILogger<ProcessPaymentReceptor> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _gateway = gateway;</p>
<p>    _context = context;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task<PaymentProcessed> HandleAsync(</p>
<p>    InventoryReserved @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    await using var tx = await _db.BeginTransactionAsync(ct);</p>

<p>    try {</p>
<p>      // 1. Check if payment already exists (idempotency)</p>
<p>      var existingPayment = await _db.QuerySingleOrDefaultAsync<PaymentRow>(</p>
<p>        """</p>
<p>        SELECT payment_id, order_id, transaction_id, amount, status</p>
<p>        FROM payments</p>
<p>        WHERE order_id = @OrderId</p>
<p>        """,</p>
<p>        new { OrderId = @event.OrderId },</p>
<p>        transaction: tx</p>
<p>      );</p>

<p>      if (existingPayment != null) {</p>
<p>        _logger.LogInformation(</p>
<p>          "Payment already exists for order {OrderId}, skipping",</p>
<p>          @event.OrderId</p>
<p>        );</p>

<p>        return new PaymentProcessed(</p>
<p>          OrderId: existingPayment.OrderId,</p>
<p>          PaymentId: existingPayment.PaymentId,</p>
<p>          TransactionId: existingPayment.TransactionId!,</p>
<p>          Amount: existingPayment.Amount,</p>
<p>          PaymentMethod: "card",</p>
<p>          Status: PaymentStatus.Captured,</p>
<p>          ProcessedAt: DateTime.UtcNow</p>
<p>        );</p>
<p>      }</p>

<p>      // 2. Get order details (to determine amount)</p>
<p>      var order = await GetOrderAsync(@event.OrderId, ct);</p>
<p>      if (order == null) {</p>
<p>        throw new InvalidOperationException($"Order {event.OrderId} not found");</p>
<p>      }</p>

<p>      // 3. Call payment gateway with retry + circuit breaker</p>
<p>      var paymentId = Guid.NewGuid().ToString("N");</p>
<p>      var idempotencyKey = $"order-{@event.OrderId}-payment-{paymentId}";</p>

<p>      var result = await CircuitBreakerPolicy.ExecuteAsync(() =></p>
<p>        RetryPolicy.ExecuteAsync(() =></p>
<p>          _gateway.ChargeAsync(</p>
<p>            idempotencyKey: idempotencyKey,</p>
<p>            amount: order.TotalAmount,</p>
<p>            currency: "usd",</p>
<p>            paymentMethod: "pm_card_visa",  // Demo: Use test payment method</p>
<p>            ct: ct</p>
<p>          )</p>
<p>        )</p>
<p>      );</p>

<p>      // 4. Store payment record</p>
<p>      if (result.Success) {</p>
<p>        await _db.ExecuteAsync(</p>
<p>          """</p>
<p>          INSERT INTO payments (</p>
<p>            payment_id, order_id, transaction_id, amount, payment_method, status, gateway_response, created_at, updated_at</p>
<p>          )</p>
<p>          VALUES (@PaymentId, @OrderId, @TransactionId, @Amount, @PaymentMethod, @Status, @GatewayResponse::jsonb, NOW(), NOW())</p>
<p>          """,</p>
<p>          new {</p>
<p>            PaymentId = paymentId,</p>
<p>            OrderId = @event.OrderId,</p>
<p>            TransactionId = result.TransactionId,</p>
<p>            Amount = order.TotalAmount,</p>
<p>            PaymentMethod = "card",</p>
<p>            Status = "Captured",</p>
<p>            GatewayResponse = System.Text.Json.JsonSerializer.Serialize(result)</p>
<p>          },</p>
<p>          transaction: tx</p>
<p>        );</p>

<p>        // 5. Publish PaymentProcessed event</p>
<p>        var processedEvent = new PaymentProcessed(</p>
<p>          OrderId: @event.OrderId,</p>
<p>          PaymentId: paymentId,</p>
<p>          TransactionId: result.TransactionId!,</p>
<p>          Amount: order.TotalAmount,</p>
<p>          PaymentMethod: "card",</p>
<p>          Status: PaymentStatus.Captured,</p>
<p>          ProcessedAt: DateTime.UtcNow</p>
<p>        );</p>

<p>        await PublishEventAsync(processedEvent, tx, ct);</p>

<p>        await tx.CommitAsync(ct);</p>

<p>        _logger.LogInformation(</p>
<p>          "Payment processed for order {OrderId}, transaction {TransactionId}, amount ${Amount}",</p>
<p>          @event.OrderId,</p>
<p>          result.TransactionId,</p>
<p>          order.TotalAmount</p>
<p>        );</p>

<p>        return processedEvent;</p>
<p>      } else {</p>
<p>        // 6. Payment failed - store failure and publish PaymentFailed event</p>
<p>        await _db.ExecuteAsync(</p>
<p>          """</p>
<p>          INSERT INTO payments (</p>
<p>            payment_id, order_id, amount, payment_method, status, gateway_response, created_at, updated_at</p>
<p>          )</p>
<p>          VALUES (@PaymentId, @OrderId, @Amount, @PaymentMethod, @Status, @GatewayResponse::jsonb, NOW(), NOW())</p>
<p>          """,</p>
<p>          new {</p>
<p>            PaymentId = paymentId,</p>
<p>            OrderId = @event.OrderId,</p>
<p>            Amount = order.TotalAmount,</p>
<p>            PaymentMethod = "card",</p>
<p>            Status = "Failed",</p>
<p>            GatewayResponse = System.Text.Json.JsonSerializer.Serialize(result)</p>
<p>          },</p>
<p>          transaction: tx</p>
<p>        );</p>

<p>        var failedEvent = new PaymentFailed(</p>
<p>          OrderId: @event.OrderId,</p>
<p>          PaymentId: paymentId,</p>
<p>          Reason: result.ErrorMessage ?? "Unknown error",</p>
<p>          ErrorCode: result.ErrorCode ?? "unknown",</p>
<p>          FailedAt: DateTime.UtcNow</p>
<p>        );</p>

<p>        await PublishEventAsync(failedEvent, tx, ct);</p>

<p>        await tx.CommitAsync(ct);</p>

<p>        _logger.LogError(</p>
<p>          "Payment failed for order {OrderId}: {ErrorCode} - {ErrorMessage}",</p>
<p>          @event.OrderId,</p>
<p>          result.ErrorCode,</p>
<p>          result.ErrorMessage</p>
<p>        );</p>

<p>        throw new PaymentFailedException(</p>
<p>          @event.OrderId,</p>
<p>          result.ErrorCode ?? "unknown",</p>
<p>          result.ErrorMessage ?? "Unknown error"</p>
<p>        );</p>
<p>      }</p>
<p>    } catch {</p>
<p>      await tx.RollbackAsync(ct);</p>
<p>      throw;</p>
<p>    }</p>
<p>  }</p>

<p>  private async Task<OrderRow?> GetOrderAsync(string orderId, CancellationToken ct) {</p>
<p>    // Query Order Service database (cross-service query for demo)</p>
<p>    // In production, use event-carried state transfer or query API</p>
<p>    return await _db.QuerySingleOrDefaultAsync<OrderRow>(</p>
<p>      """</p>
<p>      SELECT order_id, total_amount</p>
<p>      FROM orders</p>
<p>      WHERE order_id = @OrderId</p>
<p>      """,</p>
<p>      new { OrderId = orderId }</p>
<p>    );</p>
<p>  }</p>

<p>  private async Task PublishEventAsync<TEvent>(</p>
<p>    TEvent @event,</p>
<p>    NpgsqlTransaction tx,</p>
<p>    CancellationToken ct</p>
<p>  ) where TEvent : IEvent {</p>
<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO outbox (message_id, message_type, message_body, created_at)</p>
<p>      VALUES (@MessageId, @MessageType, @MessageBody::jsonb, NOW())</p>
<p>      """,</p>
<p>      new {</p>
<p>        MessageId = Guid.NewGuid(),</p>
<p>        MessageType = typeof(TEvent).FullName,</p>
<p>        MessageBody = System.Text.Json.JsonSerializer.Serialize(@event)</p>
<p>      },</p>
<p>      transaction: tx</p>
<p>    );</p>
<p>  }</p>
<p>}</p>

<p>public record PaymentRow(</p>
<p>  string PaymentId,</p>
<p>  string OrderId,</p>
<p>  string? TransactionId,</p>
<p>  decimal Amount,</p>
<p>  string Status</p>
<p>);</p>

<p>public record OrderRow(</p>
<p>  string OrderId,</p>
<p>  decimal TotalAmount</p>
<p>);</p>

<p>public class PaymentFailedException : Exception {</p>
<p>  public PaymentFailedException(string orderId, string errorCode, string message)</p>
<p>    : base($"Payment failed for order {orderId}: {errorCode} - {message}") { }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key patterns</strong>:
<ul><li>✅ <strong>Idempotency</strong>: Check existing payment before charging</li>
<li>✅ <strong>Retry Logic</strong>: Polly retry policy with exponential backoff</li>
<li>✅ <strong>Circuit Breaker</strong>: Polly circuit breaker to prevent cascading failures</li>
<li>✅ <strong>Compensation</strong>: Publish <code>PaymentFailed</code> event to trigger inventory release</li>
</ul>
<hr>

<h2>Step 5: Compensation Receptor</h2>

<strong>ECommerce.PaymentWorker/Receptors/RefundPaymentReceptor.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;
<p>using ECommerce.Contracts.Events;</p>
<p>using ECommerce.PaymentWorker.Services;</p>
<p>using Npgsql;</p>
<p>using Dapper;</p>

<p>namespace ECommerce.PaymentWorker.Receptors;</p>

<p>public class RefundPaymentReceptor : IReceptor<OrderCancelled, PaymentRefunded> {</p>
<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly IPaymentGateway _gateway;</p>
<p>  private readonly ILogger<RefundPaymentReceptor> _logger;</p>

<p>  public RefundPaymentReceptor(</p>
<p>    NpgsqlConnection db,</p>
<p>    IPaymentGateway gateway,</p>
<p>    ILogger<RefundPaymentReceptor> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _gateway = gateway;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task<PaymentRefunded> HandleAsync(</p>
<p>    OrderCancelled @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    await using var tx = await _db.BeginTransactionAsync(ct);</p>

<p>    try {</p>
<p>      // 1. Find payment for this order</p>
<p>      var payment = await _db.QuerySingleOrDefaultAsync<PaymentRow>(</p>
<p>        """</p>
<p>        SELECT payment_id, order_id, transaction_id, amount, status</p>
<p>        FROM payments</p>
<p>        WHERE order_id = @OrderId AND status = 'Captured'</p>
<p>        """,</p>
<p>        new { OrderId = @event.OrderId },</p>
<p>        transaction: tx</p>
<p>      );</p>

<p>      if (payment == null) {</p>
<p>        _logger.LogWarning(</p>
<p>          "No captured payment found for order {OrderId}, skipping refund",</p>
<p>          @event.OrderId</p>
<p>        );</p>
<p>        throw new InvalidOperationException($"No payment to refund for order {event.OrderId}");</p>
<p>      }</p>

<p>      // 2. Call payment gateway for refund</p>
<p>      var result = await _gateway.RefundAsync(</p>
<p>        transactionId: payment.TransactionId!,</p>
<p>        amount: payment.Amount,</p>
<p>        ct: ct</p>
<p>      );</p>

<p>      if (result.Success) {</p>
<p>        // 3. Update payment status</p>
<p>        await _db.ExecuteAsync(</p>
<p>          """</p>
<p>          UPDATE payments</p>
<p>          SET status = 'Refunded', updated_at = NOW()</p>
<p>          WHERE payment_id = @PaymentId</p>
<p>          """,</p>
<p>          new { PaymentId = payment.PaymentId },</p>
<p>          transaction: tx</p>
<p>        );</p>

<p>        // 4. Publish PaymentRefunded event</p>
<p>        var refundedEvent = new PaymentRefunded(</p>
<p>          OrderId: @event.OrderId,</p>
<p>          PaymentId: payment.PaymentId,</p>
<p>          RefundId: result.RefundId!,</p>
<p>          Amount: payment.Amount,</p>
<p>          RefundedAt: DateTime.UtcNow</p>
<p>        );</p>

<p>        await PublishEventAsync(refundedEvent, tx, ct);</p>

<p>        await tx.CommitAsync(ct);</p>

<p>        _logger.LogInformation(</p>
<p>          "Payment refunded for order {OrderId}, refund {RefundId}, amount ${Amount}",</p>
<p>          @event.OrderId,</p>
<p>          result.RefundId,</p>
<p>          payment.Amount</p>
<p>        );</p>

<p>        return refundedEvent;</p>
<p>      } else {</p>
<p>        throw new RefundFailedException(</p>
<p>          @event.OrderId,</p>
<p>          result.ErrorMessage ?? "Refund failed"</p>
<p>        );</p>
<p>      }</p>
<p>    } catch {</p>
<p>      await tx.RollbackAsync(ct);</p>
<p>      throw;</p>
<p>    }</p>
<p>  }</p>

<p>  private async Task PublishEventAsync<TEvent>(</p>
<p>    TEvent @event,</p>
<p>    NpgsqlTransaction tx,</p>
<p>    CancellationToken ct</p>
<p>  ) where TEvent : IEvent {</p>
<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO outbox (message_id, message_type, message_body, created_at)</p>
<p>      VALUES (@MessageId, @MessageType, @MessageBody::jsonb, NOW())</p>
<p>      """,</p>
<p>      new {</p>
<p>        MessageId = Guid.NewGuid(),</p>
<p>        MessageType = typeof(TEvent).FullName,</p>
<p>        MessageBody = System.Text.Json.JsonSerializer.Serialize(@event)</p>
<p>      },</p>
<p>      transaction: tx</p>
<p>    );</p>
<p>  }</p>
<p>}</p>

<p>public record PaymentRefunded(</p>
<p>  string OrderId,</p>
<p>  string PaymentId,</p>
<p>  string RefundId,</p>
<p>  decimal Amount,</p>
<p>  DateTime RefundedAt</p>
<p>) : IEvent;</p>

<p>public class RefundFailedException : Exception {</p>
<p>  public RefundFailedException(string orderId, string message)</p>
<p>    : base($"Refund failed for order {orderId}: {message}") { }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Step 6: Service Configuration</h2>

<strong>ECommerce.PaymentWorker/Program.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;
<p>using Whizbang.Data.Postgres;</p>
<p>using Whizbang.Transports.AzureServiceBus;</p>
<p>using Npgsql;</p>
<p>using Stripe;</p>
<p>using ECommerce.PaymentWorker.Services;</p>

<p>var builder = Host.CreateApplicationBuilder(args);</p>

<p>// 1. Add Whizbang</p>
<p>builder.Services.AddWhizbang(options => {</p>
<p>  options.ServiceName = "PaymentWorker";</p>
<p>  options.EnableInbox = true;</p>
<p>  options.EnableOutbox = true;</p>
<p>});</p>

<p>// 2. Add PostgreSQL</p>
<p>builder.Services.AddScoped<NpgsqlConnection>(sp => {</p>
<p>  var connectionString = builder.Configuration.GetConnectionString("PaymentDb");</p>
<p>  return new NpgsqlConnection(connectionString);</p>
<p>});</p>

<p>// 3. Add Azure Service Bus</p>
<p>builder.AddAzureServiceBus("messaging");</p>

<p>// 4. Configure Stripe</p>
<p>StripeConfiguration.ApiKey = builder.Configuration["Stripe:SecretKey"];</p>
<p>builder.Services.AddSingleton<PaymentIntentService>();</p>
<p>builder.Services.AddSingleton<RefundService>();</p>
<p>builder.Services.AddScoped<IPaymentGateway, StripePaymentGateway>();</p>

<p>// 5. Add Worker</p>
<p>builder.Services.AddHostedService<Worker>();</p>

<p>var host = builder.Build();</p>

<p>await host.MigrateDatabaseAsync();</p>
<p>await host.RunAsync();</p>
<p></code></pre></p>

<strong>appsettings.json</strong>:

<pre><code class="language-json">{
<p>  "Logging": {</p>
<p>    "LogLevel": {</p>
<p>      "Default": "Information",</p>
<p>      "Whizbang": "Debug"</p>
<p>    }</p>
<p>  },</p>
<p>  "ConnectionStrings": {</p>
<p>    "PaymentDb": "Host=localhost;Database=payment;Username=postgres;Password=postgres"</p>
<p>  },</p>
<p>  "Stripe": {</p>
<p>    "SecretKey": "sk_test_...",</p>
<p>    "PublishableKey": "pk_test_..."</p>
<p>  },</p>
<p>  "Whizbang": {</p>
<p>    "ServiceName": "PaymentWorker",</p>
<p>    "Inbox": {</p>
<p>      "Enabled": true,</p>
<p>      "BatchSize": 50,</p>
<p>      "PollingInterval": "00:00:05"</p>
<p>    },</p>
<p>    "Outbox": {</p>
<p>      "Enabled": true,</p>
<p>      "BatchSize": 50,</p>
<p>      "PollingInterval": "00:00:05"</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Step 7: Test the Flow</h2>

<h3>1. Update Aspire Configuration</h3>

<strong>ECommerce.AppHost/Program.cs</strong>:

<pre><code class="language-csharp">var paymentDb = postgres.AddDatabase("payment-db");

<p>var paymentWorker = builder.AddProject<Projects.ECommerce_PaymentWorker>("payment-worker")</p>
<p>  .WithReference(paymentDb)</p>
<p>  .WithReference(serviceBus);</p>
<p></code></pre></p>

<h3>2. Create Order (Full Flow)</h3>

<pre><code class="language-bash">curl -X POST http://localhost:5000/api/orders \
<p>  -H "Content-Type: application/json" \</p>
<p>  -d '{</p>
<p>    "customerId": "cust-123",</p>
<p>    "items": [</p>
<p>      { "productId": "prod-456", "quantity": 2, "unitPrice": 19.99 }</p>
<p>    ],</p>
<p>    "shippingAddress": {</p>
<p>      "street": "123 Main St",</p>
<p>      "city": "Springfield",</p>
<p>      "state": "IL",</p>
<p>      "zipCode": "62701",</p>
<p>      "country": "USA"</p>
<p>    }</p>
<p>  }'</p>
<p></code></pre></p>

<h3>3. Observe Distributed Transaction</h3>

<p>Aspire Dashboard shows:</p>
<ul><li><strong>Order Service</strong>: <code>OrderCreated</code> event published</li>
<li><strong>Inventory Worker</strong>: <code>InventoryReserved</code> event published</li>
<li><strong>Payment Worker</strong>: Payment processed via Stripe</li>
<li><strong>Payment Worker</strong>: <code>PaymentProcessed</code> event published</li>
</ul>
<h3>4. Verify Payment</h3>

<pre><code class="language-sql">SELECT * FROM payments WHERE order_id = '<order-id>';
<p></code></pre></p>

<strong>Expected</strong>:
<ul><li><code>status = 'Captured'</code></li>
<li><code>transaction_id = 'pi_...'</code> (Stripe payment intent ID)</li>
<li><code>gateway_response</code> contains full Stripe response</li>
</ul>
<hr>

<h2>Key Concepts</h2>

<h3>Saga Pattern - Distributed Transactions</h3>

<pre><code class="language-">┌─────────────────────────────────────────────────────────┐
<p>│  Saga: Order Processing (Happy Path)                    │</p>
<p>│                                                          │</p>
<p>│  1. CreateOrder → OrderCreated                          │</p>
<p>│       ↓                                                  │</p>
<p>│  2. OrderCreated → ReserveInventory → InventoryReserved │</p>
<p>│       ↓                                                  │</p>
<p>│  3. InventoryReserved → ProcessPayment → PaymentProcessed│</p>
<p>│       ↓                                                  │</p>
<p>│  4. PaymentProcessed → CreateShipment → ShipmentCreated │</p>
<p>│       ↓                                                  │</p>
<p>│  5. ShipmentCreated → SendNotification → NotificationSent│</p>
<p>└─────────────────────────────────────────────────────────┘</p>

<p>┌─────────────────────────────────────────────────────────┐</p>
<p>│  Saga: Payment Failure (Compensation)                   │</p>
<p>│                                                          │</p>
<p>│  1. CreateOrder → OrderCreated                          │</p>
<p>│       ↓                                                  │</p>
<p>│  2. OrderCreated → ReserveInventory → InventoryReserved │</p>
<p>│       ↓                                                  │</p>
<p>│  3. InventoryReserved → ProcessPayment → PaymentFailed  │</p>
<p>│       ↓                                                  │</p>
<p>│  4. PaymentFailed → ReleaseInventory → InventoryReleased│</p>
<p>│       ↓                                                  │</p>
<p>│  5. InventoryReleased → CancelOrder → OrderCancelled    │</p>
<p>└─────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Compensating transactions</strong>:
<ul><li><code>PaymentFailed</code> → <code>ReleaseInventory</code> (return stock to available)</li>
<li><code>OrderCancelled</code> → <code>RefundPayment</code> (refund customer)</li>
</ul>
<h3>Retry Logic with Polly</h3>

<pre><code class="language-csharp">// Exponential backoff: 2s, 4s, 8s
<p>Policy</p>
<p>  .Handle<HttpRequestException>()</p>
<p>  .WaitAndRetryAsync(</p>
<p>    retryCount: 3,</p>
<p>    sleepDurationProvider: attempt => TimeSpan.FromSeconds(Math.Pow(2, attempt))</p>
<p>  );</p>
<p></code></pre></p>

<strong>When to retry</strong>:
<ul><li>✅ Network errors (transient)</li>
<li>✅ Gateway timeouts (transient)</li>
<li>❌ Invalid card (permanent)</li>
<li>❌ Insufficient funds (permanent)</li>
</ul>
<h3>Circuit Breaker</h3>

<pre><code class="language-csharp">// Open circuit after 5 failures, half-open after 30s
<p>Policy</p>
<p>  .Handle<HttpRequestException>()</p>
<p>  .CircuitBreakerAsync(</p>
<p>    exceptionsAllowedBeforeBreaking: 5,</p>
<p>    durationOfBreak: TimeSpan.FromSeconds(30)</p>
<p>  );</p>
<p></code></pre></p>

<strong>States</strong>:
<ul><li><strong>Closed</strong>: Normal operation</li>
<li><strong>Open</strong>: Gateway unavailable, fail fast</li>
<li><strong>Half-Open</strong>: Test if gateway recovered</li>
</ul>
<hr>

<h2>Testing</h2>

<h3>Unit Test - Successful Payment</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task ProcessPayment_ValidCard_ChargesAndPublishesEventAsync() {</p>
<p>  // Arrange</p>
<p>  var mockGateway = new MockPaymentGateway();</p>
<p>  mockGateway.SetupSuccessfulCharge("pi_123456");</p>

<p>  var receptor = new ProcessPaymentReceptor(mockDb, mockGateway, mockContext, mockLogger);</p>
<p>  var @event = new InventoryReserved(</p>
<p>    OrderId: "order-123",</p>
<p>    ProductId: "prod-456",</p>
<p>    QuantityReserved: 2,</p>
<p>    RemainingStock: 98,</p>
<p>    ReservedAt: DateTime.UtcNow</p>
<p>  );</p>

<p>  // Act</p>
<p>  var result = await receptor.HandleAsync(@event);</p>

<p>  // Assert</p>
<p>  await Assert.That(result.Status).IsEqualTo(PaymentStatus.Captured);</p>
<p>  await Assert.That(result.TransactionId).IsEqualTo("pi_123456");</p>
<p>}</p>
<p></code></pre></p>

<h3>Unit Test - Payment Failure</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task ProcessPayment_InvalidCard_PublishesPaymentFailedEventAsync() {</p>
<p>  // Arrange</p>
<p>  var mockGateway = new MockPaymentGateway();</p>
<p>  mockGateway.SetupFailedCharge("card_declined", "Your card was declined");</p>

<p>  var receptor = new ProcessPaymentReceptor(mockDb, mockGateway, mockContext, mockLogger);</p>
<p>  var @event = new InventoryReserved(...);</p>

<p>  // Act & Assert</p>
<p>  await Assert.That(async () => await receptor.HandleAsync(@event))</p>
<p>    .Throws<PaymentFailedException>();</p>

<p>  // Verify PaymentFailed event was published</p>
<p>  var outboxEvent = mockDb.GetOutboxEvents().Single();</p>
<p>  await Assert.That(outboxEvent.MessageType).Contains("PaymentFailed");</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Next Steps</h2>

<p>Continue to <strong><a href="notification-service.md">Notification Service</a></strong> to:</p>
<ul><li>Subscribe to <code>PaymentProcessed</code> events</li>
<li>Send order confirmation emails</li>
<li>Integrate with email/SMS providers</li>
<li>Handle notification failures gracefully</li>
</ul>
<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>Idempotency</strong> - Prevent duplicate charges with idempotency keys</p>
<p>✅ <strong>Retry Logic</strong> - Exponential backoff for transient failures</p>
<p>✅ <strong>Circuit Breaker</strong> - Fail fast when gateway is down</p>
<p>✅ <strong>Saga Pattern</strong> - Distributed transactions with compensation</p>
<p>✅ <strong>Gateway Abstraction</strong> - Swap payment providers easily</p>
<p>✅ <strong>Compensation</strong> - Refunds and inventory release on failure</p>

<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-tutorial-shipping-service" class="doc-section">
  <h3>Shipping Service</h3>
  <p class="doc-path"><code>v1.0.0/tutorial/shipping-service</code></p>
  <p class="doc-description"><em>Build the Shipping Worker - carrier API integration, shipment creation, tracking, and status updates</em></p>
  <div class="doc-content">

<h1>Shipping Service</h1>

<p>Build the <strong>Shipping Worker</strong> - a background service that subscribes to <code>PaymentProcessed</code> events, creates shipments via carrier APIs (FedEx/UPS/USPS), and publishes tracking information.</p>

<p>:::note</p>
<p>This is <strong>Part 5</strong> of the ECommerce Tutorial. Complete <a href="notification-service.md">Notification Service</a> first.</p>
<p>:::</p>

<hr>

<h2>What You'll Build</h2>

<pre><code class="language-">┌─────────────────────────────────────────────────────────────┐
<p>│  Shipping Service Architecture                              │</p>
<p>│                                                              │</p>
<p>│  ┌─────────────┐                                            │</p>
<p>│  │Azure Service│  PaymentProcessed event                    │</p>
<p>│  │     Bus     │──────────────────────┐                     │</p>
<p>│  └─────────────┘                      │                     │</p>
<p>│                                        ▼                     │</p>
<p>│                          ┌────────────────────────┐         │</p>
<p>│                          │CreateShipmentReceptor  │         │</p>
<p>│                          │  - Get order details   │         │</p>
<p>│                          │  - Call carrier API    │         │</p>
<p>│                          │  - Store tracking info │         │</p>
<p>│                          └──────────┬─────────────┘         │</p>
<p>│                                     │                        │</p>
<p>│                      ┌──────────────┼──────────────┐        │</p>
<p>│                      │              │              │        │</p>
<p>│                      ▼              ▼              ▼        │</p>
<p>│                 ┌─────────┐   ┌─────────┐   ┌──────────┐   │</p>
<p>│                 │Postgres │   │ Outbox  │   │ Carrier  │   │</p>
<p>│                 │Shipments│   │ Table   │   │   API    │   │</p>
<p>│                 │  Table  │   │         │   │(FedEx)   │   │</p>
<p>│                 └─────────┘   └─────────┘   └──────────┘   │</p>
<p>│                                     │                        │</p>
<p>│                                     ▼                        │</p>
<p>│                          ┌────────────────────────┐         │</p>
<p>│                          │ Azure Service Bus      │         │</p>
<p>│                          │ ShipmentCreated        │         │</p>
<p>│                          └────────────────────────┘         │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<strong>Features</strong>:
<ul><li>✅ Carrier API integration (FedEx example)</li>
<li>✅ Shipment creation with tracking</li>
<li>✅ Address validation</li>
<li>✅ Rate shopping (cheapest/fastest)</li>
<li>✅ Webhook integration for status updates</li>
<li>✅ Label generation (PDF)</li>
</ul>
<hr>

<h2>Step 1: Define Events</h2>

<h3>ShipmentCreated Event</h3>

<strong>ECommerce.Contracts/Events/ShipmentCreated.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;

<p>namespace ECommerce.Contracts.Events;</p>

<p>public record ShipmentCreated(</p>
<p>  string ShipmentId,</p>
<p>  string OrderId,</p>
<p>  string Carrier,</p>
<p>  string TrackingNumber,</p>
<p>  string LabelUrl,</p>
<p>  decimal ShippingCost,</p>
<p>  DateTime EstimatedDelivery,</p>
<p>  DateTime CreatedAt</p>
<p>) : IEvent;</p>
<p></code></pre></p>

<hr>

<h2>Step 2: Carrier API Abstraction</h2>

<strong>ECommerce.ShippingWorker/Services/ICarrierService.cs</strong>:

<pre><code class="language-csharp">namespace ECommerce.ShippingWorker.Services;

<p>public interface ICarrierService {</p>
<p>  Task<ShipmentResult> CreateShipmentAsync(</p>
<p>    ShipmentRequest request,</p>
<p>    CancellationToken ct = default</p>
<p>  );</p>

<p>  Task<TrackingResult> GetTrackingAsync(</p>
<p>    string trackingNumber,</p>
<p>    CancellationToken ct = default</p>
<p>  );</p>
<p>}</p>

<p>public record ShipmentRequest(</p>
<p>  string OrderId,</p>
<p>  Address From,</p>
<p>  Address To,</p>
<p>  Package Package,</p>
<p>  ShipmentOptions Options</p>
<p>);</p>

<p>public record Address(</p>
<p>  string Name,</p>
<p>  string Street,</p>
<p>  string City,</p>
<p>  string State,</p>
<p>  string ZipCode,</p>
<p>  string Country,</p>
<p>  string? Phone = null</p>
<p>);</p>

<p>public record Package(</p>
<p>  decimal WeightPounds,</p>
<p>  int LengthInches,</p>
<p>  int WidthInches,</p>
<p>  int HeightInches</p>
<p>);</p>

<p>public record ShipmentOptions(</p>
<p>  string ServiceLevel,  // "Standard", "Express", "Overnight"</p>
<p>  bool SignatureRequired = false,</p>
<p>  bool SaturdayDelivery = false</p>
<p>);</p>

<p>public record ShipmentResult(</p>
<p>  bool Success,</p>
<p>  string? ShipmentId,</p>
<p>  string? TrackingNumber,</p>
<p>  string? LabelUrl,</p>
<p>  decimal? ShippingCost,</p>
<p>  DateTime? EstimatedDelivery,</p>
<p>  string? ErrorMessage</p>
<p>);</p>

<p>public record TrackingResult(</p>
<p>  string TrackingNumber,</p>
<p>  string Status,</p>
<p>  DateTime? EstimatedDelivery,</p>
<p>  TrackingEvent[] Events</p>
<p>);</p>

<p>public record TrackingEvent(</p>
<p>  string Status,</p>
<p>  string Location,</p>
<p>  DateTime Timestamp</p>
<p>);</p>
<p></code></pre></p>

<hr>

<h2>Step 3: FedEx Implementation</h2>

<strong>ECommerce.ShippingWorker/Services/FedExCarrierService.cs</strong>:

<pre><code class="language-csharp">using System.Net.Http.Json;

<p>namespace ECommerce.ShippingWorker.Services;</p>

<p>public class FedExCarrierService : ICarrierService {</p>
<p>  private readonly HttpClient _httpClient;</p>
<p>  private readonly string _accountNumber;</p>
<p>  private readonly string _meterNumber;</p>
<p>  private readonly ILogger<FedExCarrierService> _logger;</p>

<p>  public FedExCarrierService(</p>
<p>    HttpClient httpClient,</p>
<p>    IConfiguration configuration,</p>
<p>    ILogger<FedExCarrierService> logger</p>
<p>  ) {</p>
<p>    _httpClient = httpClient;</p>
<p>    _accountNumber = configuration["FedEx:AccountNumber"]</p>
<p>      ?? throw new InvalidOperationException("FedEx:AccountNumber not configured");</p>
<p>    _meterNumber = configuration["FedEx:MeterNumber"]</p>
<p>      ?? throw new InvalidOperationException("FedEx:MeterNumber not configured");</p>
<p>    _logger = logger;</p>

<p>    _httpClient.BaseAddress = new Uri(configuration["FedEx:ApiUrl"] ?? "https://apis-sandbox.fedex.com");</p>
<p>  }</p>

<p>  public async Task<ShipmentResult> CreateShipmentAsync(</p>
<p>    ShipmentRequest request,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    try {</p>
<p>      // 1. Get OAuth token</p>
<p>      var token = await GetOAuthTokenAsync(ct);</p>

<p>      // 2. Build shipment request</p>
<p>      var fedexRequest = new {</p>
<p>        accountNumber = new {</p>
<p>          value = _accountNumber</p>
<p>        },</p>
<p>        requestedShipment = new {</p>
<p>          shipper = new {</p>
<p>            contact = new {</p>
<p>              personName = request.From.Name,</p>
<p>              phoneNumber = request.From.Phone ?? "5551234567"</p>
<p>            },</p>
<p>            address = new {</p>
<p>              streetLines = new[] { request.From.Street },</p>
<p>              city = request.From.City,</p>
<p>              stateOrProvinceCode = request.From.State,</p>
<p>              postalCode = request.From.ZipCode,</p>
<p>              countryCode = request.From.Country</p>
<p>            }</p>
<p>          },</p>
<p>          recipients = new[] {</p>
<p>            new {</p>
<p>              contact = new {</p>
<p>                personName = request.To.Name,</p>
<p>                phoneNumber = request.To.Phone ?? "5551234567"</p>
<p>              },</p>
<p>              address = new {</p>
<p>                streetLines = new[] { request.To.Street },</p>
<p>                city = request.To.City,</p>
<p>                stateOrProvinceCode = request.To.State,</p>
<p>                postalCode = request.To.ZipCode,</p>
<p>                countryCode = request.To.Country</p>
<p>              }</p>
<p>            }</p>
<p>          },</p>
<p>          pickupType = "USE_SCHEDULED_PICKUP",</p>
<p>          serviceType = MapServiceLevel(request.Options.ServiceLevel),</p>
<p>          packagingType = "YOUR_PACKAGING",</p>
<p>          shippingChargesPayment = new {</p>
<p>            paymentType = "SENDER"</p>
<p>          },</p>
<p>          labelSpecification = new {</p>
<p>            labelFormatType = "COMMON2D",</p>
<p>            imageType = "PDF",</p>
<p>            labelStockType = "PAPER_4X6"</p>
<p>          },</p>
<p>          requestedPackageLineItems = new[] {</p>
<p>            new {</p>
<p>              weight = new {</p>
<p>                units = "LB",</p>
<p>                value = request.Package.WeightPounds</p>
<p>              },</p>
<p>              dimensions = new {</p>
<p>                length = request.Package.LengthInches,</p>
<p>                width = request.Package.WidthInches,</p>
<p>                height = request.Package.HeightInches,</p>
<p>                units = "IN"</p>
<p>              }</p>
<p>            }</p>
<p>          }</p>
<p>        }</p>
<p>      };</p>

<p>      // 3. Call FedEx API</p>
<p>      var httpRequest = new HttpRequestMessage(HttpMethod.Post, "/ship/v1/shipments");</p>
<p>      httpRequest.Headers.Add("Authorization", $"Bearer {token}");</p>
<p>      httpRequest.Headers.Add("X-locale", "en_US");</p>
<p>      httpRequest.Content = JsonContent.Create(fedexRequest);</p>

<p>      var response = await _httpClient.SendAsync(httpRequest, ct);</p>
<p>      var responseContent = await response.Content.ReadAsStringAsync(ct);</p>

<p>      if (response.IsSuccessStatusCode) {</p>
<p>        var fedexResponse = System.Text.Json.JsonSerializer.Deserialize<FedExShipmentResponse>(responseContent);</p>

<p>        var trackingNumber = fedexResponse?.output?.transactionShipments?[0]?.masterTrackingNumber;</p>
<p>        var labelUrl = fedexResponse?.output?.transactionShipments?[0]?.pieceResponses?[0]?.packageDocuments?[0]?.url;</p>
<p>        var shippingCost = fedexResponse?.output?.transactionShipments?[0]?.shipmentDocuments?[0]?.netCharge;</p>

<p>        _logger.LogInformation(</p>
<p>          "FedEx shipment created for order {OrderId}, tracking: {TrackingNumber}",</p>
<p>          request.OrderId,</p>
<p>          trackingNumber</p>
<p>        );</p>

<p>        return new ShipmentResult(</p>
<p>          Success: true,</p>
<p>          ShipmentId: trackingNumber,</p>
<p>          TrackingNumber: trackingNumber,</p>
<p>          LabelUrl: labelUrl,</p>
<p>          ShippingCost: shippingCost ?? 0,</p>
<p>          EstimatedDelivery: DateTime.UtcNow.AddDays(3),  // Simplified</p>
<p>          ErrorMessage: null</p>
<p>        );</p>
<p>      } else {</p>
<p>        _logger.LogError(</p>
<p>          "FedEx shipment failed for order {OrderId}: {StatusCode} - {Response}",</p>
<p>          request.OrderId,</p>
<p>          response.StatusCode,</p>
<p>          responseContent</p>
<p>        );</p>

<p>        return new ShipmentResult(</p>
<p>          Success: false,</p>
<p>          ShipmentId: null,</p>
<p>          TrackingNumber: null,</p>
<p>          LabelUrl: null,</p>
<p>          ShippingCost: null,</p>
<p>          EstimatedDelivery: null,</p>
<p>          ErrorMessage: $"FedEx API error: {response.StatusCode}"</p>
<p>        );</p>
<p>      }</p>
<p>    } catch (Exception ex) {</p>
<p>      _logger.LogError(ex, "FedEx shipment exception for order {OrderId}", request.OrderId);</p>

<p>      return new ShipmentResult(</p>
<p>        Success: false,</p>
<p>        ShipmentId: null,</p>
<p>        TrackingNumber: null,</p>
<p>        LabelUrl: null,</p>
<p>        ShippingCost: null,</p>
<p>        EstimatedDelivery: null,</p>
<p>        ErrorMessage: ex.Message</p>
<p>      );</p>
<p>    }</p>
<p>  }</p>

<p>  public async Task<TrackingResult> GetTrackingAsync(</p>
<p>    string trackingNumber,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    // Similar implementation for tracking API</p>
<p>    // For brevity, omitted</p>

<p>    return new TrackingResult(</p>
<p>      TrackingNumber: trackingNumber,</p>
<p>      Status: "In Transit",</p>
<p>      EstimatedDelivery: DateTime.UtcNow.AddDays(2),</p>
<p>      Events: [</p>
<p>        new TrackingEvent("Picked Up", "Memphis, TN", DateTime.UtcNow.AddDays(-1)),</p>
<p>        new TrackingEvent("In Transit", "Indianapolis, IN", DateTime.UtcNow.AddHours(-6))</p>
<p>      ]</p>
<p>    );</p>
<p>  }</p>

<p>  private async Task<string> GetOAuthTokenAsync(CancellationToken ct) {</p>
<p>    // FedEx OAuth token exchange</p>
<p>    // Simplified for demo</p>
<p>    return "fake-oauth-token";</p>
<p>  }</p>

<p>  private string MapServiceLevel(string serviceLevel) {</p>
<p>    return serviceLevel switch {</p>
<p>      "Standard" => "FEDEX_GROUND",</p>
<p>      "Express" => "FEDEX_2_DAY",</p>
<p>      "Overnight" => "FEDEX_PRIORITY_OVERNIGHT",</p>
<p>      _ => "FEDEX_GROUND"</p>
<p>    };</p>
<p>  }</p>
<p>}</p>

<p>// FedEx API response models (simplified)</p>
<p>public record FedExShipmentResponse(</p>
<p>  FedExOutput? output</p>
<p>);</p>

<p>public record FedExOutput(</p>
<p>  FedExTransactionShipment[]? transactionShipments</p>
<p>);</p>

<p>public record FedExTransactionShipment(</p>
<p>  string? masterTrackingNumber,</p>
<p>  FedExPieceResponse[]? pieceResponses,</p>
<p>  FedExShipmentDocument[]? shipmentDocuments</p>
<p>);</p>

<p>public record FedExPieceResponse(</p>
<p>  FedExPackageDocument[]? packageDocuments</p>
<p>);</p>

<p>public record FedExPackageDocument(</p>
<p>  string? url</p>
<p>);</p>

<p>public record FedExShipmentDocument(</p>
<p>  decimal? netCharge</p>
<p>);</p>
<p></code></pre></p>

<hr>

<h2>Step 4: Database Schema</h2>

<strong>ECommerce.ShippingWorker/Database/Migrations/001_CreateShipmentsTable.sql</strong>:

<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS shipments (
<p>  shipment_id TEXT PRIMARY KEY,</p>
<p>  order_id TEXT NOT NULL UNIQUE,</p>
<p>  carrier TEXT NOT NULL,</p>
<p>  tracking_number TEXT NOT NULL UNIQUE,</p>
<p>  label_url TEXT NOT NULL,</p>
<p>  shipping_cost NUMERIC(10, 2) NOT NULL,</p>
<p>  estimated_delivery TIMESTAMP NOT NULL,</p>
<p>  actual_delivery TIMESTAMP,</p>
<p>  status TEXT NOT NULL,  -- 'Created', 'InTransit', 'Delivered', 'Exception'</p>
<p>  created_at TIMESTAMP NOT NULL DEFAULT NOW(),</p>
<p>  updated_at TIMESTAMP NOT NULL DEFAULT NOW()</p>
<p>);</p>

<p>CREATE INDEX idx_shipments_order_id ON shipments(order_id);</p>
<p>CREATE INDEX idx_shipments_tracking_number ON shipments(tracking_number);</p>
<p>CREATE INDEX idx_shipments_status ON shipments(status);</p>
<p></code></pre></p>

<strong>ECommerce.ShippingWorker/Database/Migrations/002_CreateTrackingEventsTable.sql</strong>:

<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS tracking_events (
<p>  event_id TEXT PRIMARY KEY,</p>
<p>  shipment_id TEXT NOT NULL REFERENCES shipments(shipment_id),</p>
<p>  status TEXT NOT NULL,</p>
<p>  location TEXT NOT NULL,</p>
<p>  timestamp TIMESTAMP NOT NULL,</p>
<p>  created_at TIMESTAMP NOT NULL DEFAULT NOW()</p>
<p>);</p>

<p>CREATE INDEX idx_tracking_events_shipment_id ON tracking_events(shipment_id);</p>
<p>CREATE INDEX idx_tracking_events_timestamp ON tracking_events(timestamp DESC);</p>
<p></code></pre></p>

<hr>

<h2>Step 5: Implement Receptor</h2>

<strong>ECommerce.ShippingWorker/Receptors/CreateShipmentReceptor.cs</strong>:

<pre><code class="language-csharp">using Whizbang.Core;
<p>using ECommerce.Contracts.Events;</p>
<p>using ECommerce.ShippingWorker.Services;</p>
<p>using Npgsql;</p>
<p>using Dapper;</p>

<p>namespace ECommerce.ShippingWorker.Receptors;</p>

<p>public class CreateShipmentReceptor : IReceptor<PaymentProcessed, ShipmentCreated> {</p>
<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly ICarrierService _carrierService;</p>
<p>  private readonly IMessageContext _context;</p>
<p>  private readonly ILogger<CreateShipmentReceptor> _logger;</p>

<p>  public CreateShipmentReceptor(</p>
<p>    NpgsqlConnection db,</p>
<p>    ICarrierService carrierService,</p>
<p>    IMessageContext context,</p>
<p>    ILogger<CreateShipmentReceptor> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _carrierService = carrierService;</p>
<p>    _context = context;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task<ShipmentCreated> HandleAsync(</p>
<p>    PaymentProcessed @event,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    await using var tx = await _db.BeginTransactionAsync(ct);</p>

<p>    try {</p>
<p>      // 1. Check if shipment already exists (idempotency)</p>
<p>      var existingShipment = await _db.QuerySingleOrDefaultAsync<ShipmentRow>(</p>
<p>        """</p>
<p>        SELECT shipment_id, order_id, carrier, tracking_number, label_url, shipping_cost, estimated_delivery</p>
<p>        FROM shipments</p>
<p>        WHERE order_id = @OrderId</p>
<p>        """,</p>
<p>        new { OrderId = @event.OrderId },</p>
<p>        transaction: tx</p>
<p>      );</p>

<p>      if (existingShipment != null) {</p>
<p>        _logger.LogInformation(</p>
<p>          "Shipment already exists for order {OrderId}, skipping",</p>
<p>          @event.OrderId</p>
<p>        );</p>

<p>        return new ShipmentCreated(</p>
<p>          ShipmentId: existingShipment.ShipmentId,</p>
<p>          OrderId: existingShipment.OrderId,</p>
<p>          Carrier: existingShipment.Carrier,</p>
<p>          TrackingNumber: existingShipment.TrackingNumber,</p>
<p>          LabelUrl: existingShipment.LabelUrl,</p>
<p>          ShippingCost: existingShipment.ShippingCost,</p>
<p>          EstimatedDelivery: existingShipment.EstimatedDelivery,</p>
<p>          CreatedAt: DateTime.UtcNow</p>
<p>        );</p>
<p>      }</p>

<p>      // 2. Get order details (from Order Service DB - cross-service query for demo)</p>
<p>      var order = await GetOrderAsync(@event.OrderId, ct);</p>
<p>      if (order == null) {</p>
<p>        throw new InvalidOperationException($"Order {event.OrderId} not found");</p>
<p>      }</p>

<p>      // 3. Build shipment request</p>
<p>      var shipmentRequest = new ShipmentRequest(</p>
<p>        OrderId: @event.OrderId,</p>
<p>        From: new Address(</p>
<p>          Name: "ECommerce Warehouse",</p>
<p>          Street: "1000 Warehouse Blvd",</p>
<p>          City: "Memphis",</p>
<p>          State: "TN",</p>
<p>          ZipCode: "38101",</p>
<p>          Country: "US",</p>
<p>          Phone: "9015551234"</p>
<p>        ),</p>
<p>        To: new Address(</p>
<p>          Name: order.CustomerName,</p>
<p>          Street: order.ShippingAddress.Street,</p>
<p>          City: order.ShippingAddress.City,</p>
<p>          State: order.ShippingAddress.State,</p>
<p>          ZipCode: order.ShippingAddress.ZipCode,</p>
<p>          Country: order.ShippingAddress.Country</p>
<p>        ),</p>
<p>        Package: new Package(</p>
<p>          WeightPounds: 5.0m,  // Demo: Hard-coded weight</p>
<p>          LengthInches: 12,</p>
<p>          WidthInches: 10,</p>
<p>          HeightInches: 8</p>
<p>        ),</p>
<p>        Options: new ShipmentOptions(</p>
<p>          ServiceLevel: "Standard"</p>
<p>        )</p>
<p>      );</p>

<p>      // 4. Call carrier API</p>
<p>      var result = await _carrierService.CreateShipmentAsync(shipmentRequest, ct);</p>

<p>      if (result.Success) {</p>
<p>        var shipmentId = Guid.NewGuid().ToString("N");</p>

<p>        // 5. Store shipment</p>
<p>        await _db.ExecuteAsync(</p>
<p>          """</p>
<p>          INSERT INTO shipments (</p>
<p>            shipment_id, order_id, carrier, tracking_number, label_url, shipping_cost, estimated_delivery, status, created_at, updated_at</p>
<p>          )</p>
<p>          VALUES (@ShipmentId, @OrderId, @Carrier, @TrackingNumber, @LabelUrl, @ShippingCost, @EstimatedDelivery, @Status, NOW(), NOW())</p>
<p>          """,</p>
<p>          new {</p>
<p>            ShipmentId = shipmentId,</p>
<p>            OrderId = @event.OrderId,</p>
<p>            Carrier = "FedEx",</p>
<p>            TrackingNumber = result.TrackingNumber,</p>
<p>            LabelUrl = result.LabelUrl,</p>
<p>            ShippingCost = result.ShippingCost,</p>
<p>            EstimatedDelivery = result.EstimatedDelivery,</p>
<p>            Status = "Created"</p>
<p>          },</p>
<p>          transaction: tx</p>
<p>        );</p>

<p>        // 6. Publish ShipmentCreated event</p>
<p>        var shipmentCreatedEvent = new ShipmentCreated(</p>
<p>          ShipmentId: shipmentId,</p>
<p>          OrderId: @event.OrderId,</p>
<p>          Carrier: "FedEx",</p>
<p>          TrackingNumber: result.TrackingNumber!,</p>
<p>          LabelUrl: result.LabelUrl!,</p>
<p>          ShippingCost: result.ShippingCost!.Value,</p>
<p>          EstimatedDelivery: result.EstimatedDelivery!.Value,</p>
<p>          CreatedAt: DateTime.UtcNow</p>
<p>        );</p>

<p>        await PublishEventAsync(shipmentCreatedEvent, tx, ct);</p>

<p>        await tx.CommitAsync(ct);</p>

<p>        _logger.LogInformation(</p>
<p>          "Shipment created for order {OrderId}, tracking: {TrackingNumber}, cost: ${ShippingCost}",</p>
<p>          @event.OrderId,</p>
<p>          result.TrackingNumber,</p>
<p>          result.ShippingCost</p>
<p>        );</p>

<p>        return shipmentCreatedEvent;</p>
<p>      } else {</p>
<p>        throw new ShipmentCreationFailedException(</p>
<p>          @event.OrderId,</p>
<p>          result.ErrorMessage ?? "Shipment creation failed"</p>
<p>        );</p>
<p>      }</p>
<p>    } catch {</p>
<p>      await tx.RollbackAsync(ct);</p>
<p>      throw;</p>
<p>    }</p>
<p>  }</p>

<p>  private async Task<OrderRow?> GetOrderAsync(string orderId, CancellationToken ct) {</p>
<p>    // Cross-service query (demo only - use event-carried state transfer in production)</p>
<p>    return await _db.QuerySingleOrDefaultAsync<OrderRow>(</p>
<p>      """</p>
<p>      SELECT</p>
<p>        o.order_id,</p>
<p>        o.customer_id AS customer_name,</p>
<p>        o.shipping_address</p>
<p>      FROM orders o</p>
<p>      WHERE o.order_id = @OrderId</p>
<p>      """,</p>
<p>      new { OrderId = orderId }</p>
<p>    );</p>
<p>  }</p>

<p>  private async Task PublishEventAsync<TEvent>(</p>
<p>    TEvent @event,</p>
<p>    NpgsqlTransaction tx,</p>
<p>    CancellationToken ct</p>
<p>  ) where TEvent : IEvent {</p>
<p>    await _db.ExecuteAsync(</p>
<p>      """</p>
<p>      INSERT INTO outbox (message_id, message_type, message_body, created_at)</p>
<p>      VALUES (@MessageId, @MessageType, @MessageBody::jsonb, NOW())</p>
<p>      """,</p>
<p>      new {</p>
<p>        MessageId = Guid.NewGuid(),</p>
<p>        MessageType = typeof(TEvent).FullName,</p>
<p>        MessageBody = System.Text.Json.JsonSerializer.Serialize(@event)</p>
<p>      },</p>
<p>      transaction: tx</p>
<p>    );</p>
<p>  }</p>
<p>}</p>

<p>public record ShipmentRow(</p>
<p>  string ShipmentId,</p>
<p>  string OrderId,</p>
<p>  string Carrier,</p>
<p>  string TrackingNumber,</p>
<p>  string LabelUrl,</p>
<p>  decimal ShippingCost,</p>
<p>  DateTime EstimatedDelivery</p>
<p>);</p>

<p>public record OrderRow(</p>
<p>  string OrderId,</p>
<p>  string CustomerName,</p>
<p>  ShippingAddress ShippingAddress</p>
<p>);</p>

<p>public record ShippingAddress(</p>
<p>  string Street,</p>
<p>  string City,</p>
<p>  string State,</p>
<p>  string ZipCode,</p>
<p>  string Country</p>
<p>);</p>

<p>public class ShipmentCreationFailedException : Exception {</p>
<p>  public ShipmentCreationFailedException(string orderId, string message)</p>
<p>    : base($"Shipment creation failed for order {orderId}: {message}") { }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Step 6: Tracking Updates (Webhook)</h2>

<strong>ECommerce.ShippingWorker/Controllers/WebhooksController.cs</strong>:

<pre><code class="language-csharp">using Microsoft.AspNetCore.Mvc;
<p>using Npgsql;</p>
<p>using Dapper;</p>

<p>namespace ECommerce.ShippingWorker.Controllers;</p>

<p>[ApiController]</p>
<p>[Route("api/webhooks")]</p>
<p>public class WebhooksController : ControllerBase {</p>
<p>  private readonly NpgsqlConnection _db;</p>
<p>  private readonly ILogger<WebhooksController> _logger;</p>

<p>  public WebhooksController(</p>
<p>    NpgsqlConnection db,</p>
<p>    ILogger<WebhooksController> logger</p>
<p>  ) {</p>
<p>    _db = db;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  [HttpPost("fedex/tracking")]</p>
<p>  public async Task<IActionResult> FedExTrackingUpdate([FromBody] FedExTrackingWebhook webhook) {</p>
<p>    try {</p>
<p>      var trackingNumber = webhook.TrackingNumber;</p>
<p>      var status = webhook.Status;</p>
<p>      var location = webhook.Location;</p>
<p>      var timestamp = webhook.Timestamp;</p>

<p>      // 1. Find shipment</p>
<p>      var shipment = await _db.QuerySingleOrDefaultAsync<ShipmentRow>(</p>
<p>        """</p>
<p>        SELECT shipment_id, order_id, tracking_number</p>
<p>        FROM shipments</p>
<p>        WHERE tracking_number = @TrackingNumber</p>
<p>        """,</p>
<p>        new { TrackingNumber = trackingNumber }</p>
<p>      );</p>

<p>      if (shipment == null) {</p>
<p>        _logger.LogWarning("Shipment not found for tracking {TrackingNumber}", trackingNumber);</p>
<p>        return NotFound();</p>
<p>      }</p>

<p>      // 2. Insert tracking event</p>
<p>      await _db.ExecuteAsync(</p>
<p>        """</p>
<p>        INSERT INTO tracking_events (event_id, shipment_id, status, location, timestamp, created_at)</p>
<p>        VALUES (@EventId, @ShipmentId, @Status, @Location, @Timestamp, NOW())</p>
<p>        """,</p>
<p>        new {</p>
<p>          EventId = Guid.NewGuid().ToString("N"),</p>
<p>          ShipmentId = shipment.ShipmentId,</p>
<p>          Status = status,</p>
<p>          Location = location,</p>
<p>          Timestamp = timestamp</p>
<p>        }</p>
<p>      );</p>

<p>      // 3. Update shipment status</p>
<p>      if (status == "Delivered") {</p>
<p>        await _db.ExecuteAsync(</p>
<p>          """</p>
<p>          UPDATE shipments</p>
<p>          SET status = 'Delivered', actual_delivery = @Timestamp, updated_at = NOW()</p>
<p>          WHERE shipment_id = @ShipmentId</p>
<p>          """,</p>
<p>          new { ShipmentId = shipment.ShipmentId, Timestamp = timestamp }</p>
<p>        );</p>
<p>      }</p>

<p>      _logger.LogInformation(</p>
<p>        "Tracking update for {TrackingNumber}: {Status} at {Location}",</p>
<p>        trackingNumber,</p>
<p>        status,</p>
<p>        location</p>
<p>      );</p>

<p>      return Ok();</p>
<p>    } catch (Exception ex) {</p>
<p>      _logger.LogError(ex, "Failed to process FedEx tracking webhook");</p>
<p>      return StatusCode(500);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>

<p>public record FedExTrackingWebhook(</p>
<p>  string TrackingNumber,</p>
<p>  string Status,</p>
<p>  string Location,</p>
<p>  DateTime Timestamp</p>
<p>);</p>
<p></code></pre></p>

<hr>

<h2>Step 7: Test Shipping Flow</h2>

<h3>1. Create Order (Full End-to-End)</h3>

<pre><code class="language-bash">curl -X POST http://localhost:5000/api/orders \
<p>  -H "Content-Type: application/json" \</p>
<p>  -d '{ ... }'</p>
<p></code></pre></p>

<h3>2. Observe Event Flow</h3>

<p>Aspire Dashboard:</p>
<ul><li><strong>Order Service</strong>: OrderCreated</li>
<li><strong>Inventory Worker</strong>: InventoryReserved</li>
<li><strong>Payment Worker</strong>: PaymentProcessed</li>
<li><strong>Shipping Worker</strong>: ShipmentCreated (THIS STEP)</li>
<li><strong>Notification Worker</strong>: ShipmentNotification (SMS)</li>
</ul>
<h3>3. Verify Shipment</h3>

<pre><code class="language-sql">SELECT * FROM shipments WHERE order_id = '<order-id>';
<p></code></pre></p>

<strong>Expected</strong>:
<ul><li><code>tracking_number = '123456789012'</code></li>
<li><code>carrier = 'FedEx'</code></li>
<li><code>status = 'Created'</code></li>
<li><code>label_url</code> contains PDF URL</li>
</ul>
<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>Carrier API Abstraction</strong> - Swap carriers easily (FedEx, UPS, USPS)</p>
<p>✅ <strong>Idempotency</strong> - Prevent duplicate shipments</p>
<p>✅ <strong>Webhook Integration</strong> - Real-time tracking updates</p>
<p>✅ <strong>Label Generation</strong> - PDF shipping labels</p>
<p>✅ <strong>Event-Driven</strong> - ShipmentCreated triggers notifications</p>

<hr>

<h2>Next Steps</h2>

<p>Continue to <strong><a href="customer-service.md">Customer Service</a></strong> to:</p>
<ul><li>Build BFF (Backend for Frontend) API</li>
<li>Implement perspectives for read models</li>
<li>Query order summaries</li>
<li>Aggregate data from multiple services</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-tutorial-testing-strategy" class="doc-section">
  <h3>Testing Strategy</h3>
  <p class="doc-path"><code>v1.0.0/tutorial/testing-strategy</code></p>
  <p class="doc-description"><em>Comprehensive testing strategy - unit tests, integration tests, e2e tests, mocks, and fixtures</em></p>
  <div class="doc-content">

<h1>Testing Strategy</h1>

<p>Build a <strong>comprehensive testing strategy</strong> for the ECommerce system covering unit tests, integration tests, end-to-end tests, test fixtures, and mocking patterns.</p>

<p>:::note</p>
<p>This is <strong>Part 8</strong> of the ECommerce Tutorial. Complete <a href="analytics-service.md">Analytics Service</a> first.</p>
<p>:::</p>

<hr>

<h2>Testing Pyramid</h2>

<pre><code class="language-">┌─────────────────────────────────────────────────────────┐
<p>│  Testing Pyramid                                         │</p>
<p>│                                                          │</p>
<p>│              ┌────────────────┐                          │</p>
<p>│              │  E2E Tests     │ ← 10% (Slow, Expensive)  │</p>
<p>│              │  Full system   │                          │</p>
<p>│              └────────────────┘                          │</p>
<p>│         ┌───────────────────────┐                        │</p>
<p>│         │  Integration Tests    │ ← 30% (Medium)        │</p>
<p>│         │  Service + DB + Bus   │                        │</p>
<p>│         └───────────────────────┘                        │</p>
<p>│    ┌───────────────────────────────┐                     │</p>
<p>│    │      Unit Tests               │ ← 60% (Fast, Cheap) │</p>
<p>│    │  Receptors, Perspectives,     │                     │</p>
<p>│    │  Business Logic               │                     │</p>
<p>│    └───────────────────────────────┘                     │</p>
<p>└─────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<hr>

<h2>Unit Tests</h2>

<h3>Testing Receptors</h3>

<strong>ECommerce.OrderService.Tests/CreateOrderReceptorTests.cs</strong>:

<pre><code class="language-csharp">using TUnit.Core;
<p>using TUnit.Assertions;</p>
<p>using ECommerce.OrderService.API.Receptors;</p>
<p>using ECommerce.Contracts.Commands;</p>
<p>using ECommerce.Contracts.Events;</p>
<p>using Npgsql;</p>
<p>using Moq;</p>

<p>namespace ECommerce.OrderService.Tests;</p>

<p>[TestFixture]</p>
<p>public class CreateOrderReceptorTests {</p>
<p>  [Test]</p>
<p>  public async Task HandleAsync_ValidOrder_CreatesOrderAndPublishesEventAsync() {</p>
<p>    // Arrange</p>
<p>    var mockDb = new Mock<NpgsqlConnection>();</p>
<p>    var mockContext = new Mock<IMessageContext>();</p>
<p>    var mockLogger = new Mock<ILogger<CreateOrderReceptor>>();</p>

<p>    // Setup message context</p>
<p>    mockContext.Setup(c => c.MessageId).Returns(Guid.NewGuid());</p>
<p>    mockContext.Setup(c => c.CorrelationId).Returns(Guid.NewGuid());</p>

<p>    var receptor = new CreateOrderReceptor(</p>
<p>      mockDb.Object,</p>
<p>      mockContext.Object,</p>
<p>      mockLogger.Object</p>
<p>    );</p>

<p>    var command = new CreateOrder(</p>
<p>      CustomerId: "cust-123",</p>
<p>      Items: [</p>
<p>        new OrderItem("prod-456", 2, 19.99m)</p>
<p>      ],</p>
<p>      ShippingAddress: new Address(</p>
<p>        Street: "123 Main St",</p>
<p>        City: "Springfield",</p>
<p>        State: "IL",</p>
<p>        ZipCode: "62701",</p>
<p>        Country: "USA"</p>
<p>      )</p>
<p>    );</p>

<p>    // Act</p>
<p>    var result = await receptor.HandleAsync(command);</p>

<p>    // Assert</p>
<p>    await Assert.That(result).IsNotNull();</p>
<p>    await Assert.That(result.CustomerId).IsEqualTo("cust-123");</p>
<p>    await Assert.That(result.TotalAmount).IsEqualTo(39.98m);</p>
<p>    await Assert.That(result.Items).HasCount().EqualTo(1);</p>
<p>    await Assert.That(result.Items[0].LineTotal).IsEqualTo(39.98m);</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task HandleAsync_EmptyItems_ThrowsValidationExceptionAsync() {</p>
<p>    // Arrange</p>
<p>    var mockDb = new Mock<NpgsqlConnection>();</p>
<p>    var mockContext = new Mock<IMessageContext>();</p>
<p>    var mockLogger = new Mock<ILogger<CreateOrderReceptor>>();</p>

<p>    var receptor = new CreateOrderReceptor(</p>
<p>      mockDb.Object,</p>
<p>      mockContext.Object,</p>
<p>      mockLogger.Object</p>
<p>    );</p>

<p>    var command = new CreateOrder(</p>
<p>      CustomerId: "cust-123",</p>
<p>      Items: [],  // Empty items</p>
<p>      ShippingAddress: new Address("123 Main", "Springfield", "IL", "62701", "USA")</p>
<p>    );</p>

<p>    // Act & Assert</p>
<p>    await Assert.That(async () => await receptor.HandleAsync(command))</p>
<p>      .Throws<ValidationException>()</p>
<p>      .WithMessage().Contains("at least one item");</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task HandleAsync_DuplicateOrder_ReturnsExistingOrderAsync() {</p>
<p>    // Arrange</p>
<p>    var mockDb = new Mock<NpgsqlConnection>();</p>
<p>    // Setup to return existing order</p>
<p>    mockDb.Setup(db => db.QuerySingleOrDefaultAsync<OrderRow>(</p>
<p>      It.IsAny<string>(),</p>
<p>      It.IsAny<object>(),</p>
<p>      It.IsAny<NpgsqlTransaction>()</p>
<p>    )).ReturnsAsync(new OrderRow(</p>
<p>      OrderId: "order-existing",</p>
<p>      CustomerId: "cust-123",</p>
<p>      TotalAmount: 39.98m</p>
<p>    ));</p>

<p>    var receptor = new CreateOrderReceptor(mockDb.Object, mockContext.Object, mockLogger.Object);</p>
<p>    var command = new CreateOrder(...);</p>

<p>    // Act</p>
<p>    var result = await receptor.HandleAsync(command);</p>

<p>    // Assert</p>
<p>    await Assert.That(result.OrderId).IsEqualTo("order-existing");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Testing Perspectives</h3>

<strong>ECommerce.CustomerService.Tests/OrderSummaryPerspectiveTests.cs</strong>:

<pre><code class="language-csharp">using TUnit.Core;
<p>using TUnit.Assertions;</p>
<p>using ECommerce.CustomerService.API.Perspectives;</p>
<p>using ECommerce.Contracts.Events;</p>
<p>using Npgsql;</p>
<p>using Dapper;</p>
<p>using Moq;</p>

<p>namespace ECommerce.CustomerService.Tests;</p>

<p>[TestFixture]</p>
<p>public class OrderSummaryPerspectiveTests {</p>
<p>  [Test]</p>
<p>  public async Task HandleAsync_OrderCreated_InsertsOrderSummaryAsync() {</p>
<p>    // Arrange</p>
<p>    var mockDb = new Mock<NpgsqlConnection>();</p>
<p>    var mockLogger = new Mock<ILogger<OrderSummaryPerspective>>();</p>

<p>    var perspective = new OrderSummaryPerspective(</p>
<p>      mockDb.Object,</p>
<p>      mockLogger.Object</p>
<p>    );</p>

<p>    var @event = new OrderCreated(</p>
<p>      OrderId: "order-123",</p>
<p>      CustomerId: "cust-456",</p>
<p>      Items: [</p>
<p>        new OrderItem("prod-789", 2, 19.99m, 39.98m)</p>
<p>      ],</p>
<p>      ShippingAddress: new Address("123 Main", "Springfield", "IL", "62701", "USA"),</p>
<p>      TotalAmount: 39.98m,</p>
<p>      CreatedAt: DateTime.UtcNow</p>
<p>    );</p>

<p>    // Act</p>
<p>    await perspective.HandleAsync(@event);</p>

<p>    // Assert</p>
<p>    mockDb.Verify(db => db.ExecuteAsync(</p>
<p>      It.Is<string>(sql => sql.Contains("INSERT INTO order_summary")),</p>
<p>      It.Is<object>(param =></p>
<p>        ((dynamic)param).OrderId == "order-123" &&</p>
<p>        ((dynamic)param).TotalAmount == 39.98m</p>
<p>      ),</p>
<p>      It.IsAny<NpgsqlTransaction>(),</p>
<p>      It.IsAny<int>(),</p>
<p>      It.IsAny<CommandType>()</p>
<p>    ), Times.Once);</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task HandleAsync_PaymentProcessed_UpdatesOrderSummaryAsync() {</p>
<p>    // Arrange</p>
<p>    var mockDb = new Mock<NpgsqlConnection>();</p>
<p>    var mockLogger = new Mock<ILogger<OrderSummaryPerspective>>();</p>

<p>    var perspective = new OrderSummaryPerspective(</p>
<p>      mockDb.Object,</p>
<p>      mockLogger.Object</p>
<p>    );</p>

<p>    var @event = new PaymentProcessed(</p>
<p>      OrderId: "order-123",</p>
<p>      PaymentId: "pay-456",</p>
<p>      TransactionId: "txn-789",</p>
<p>      Amount: 39.98m,</p>
<p>      PaymentMethod: "card",</p>
<p>      Status: PaymentStatus.Captured,</p>
<p>      ProcessedAt: DateTime.UtcNow</p>
<p>    );</p>

<p>    // Act</p>
<p>    await perspective.HandleAsync(@event);</p>

<p>    // Assert</p>
<p>    mockDb.Verify(db => db.ExecuteAsync(</p>
<p>      It.Is<string>(sql => sql.Contains("UPDATE order_summary")),</p>
<p>      It.Is<object>(param =></p>
<p>        ((dynamic)param).OrderId == "order-123" &&</p>
<p>        ((dynamic)param).PaymentId == "pay-456"</p>
<p>      ),</p>
<p>      It.IsAny<NpgsqlTransaction>(),</p>
<p>      It.IsAny<int>(),</p>
<p>      It.IsAny<CommandType>()</p>
<p>    ), Times.Once);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Integration Tests</h2>

<h3>Testing with Test Database</h3>

<strong>ECommerce.OrderService.IntegrationTests/CreateOrderIntegrationTests.cs</strong>:

<pre><code class="language-csharp">using TUnit.Core;
<p>using TUnit.Assertions;</p>
<p>using Microsoft.AspNetCore.Mvc.Testing;</p>
<p>using ECommerce.OrderService.API;</p>
<p>using ECommerce.Contracts.Commands;</p>
<p>using System.Net.Http.Json;</p>

<p>namespace ECommerce.OrderService.IntegrationTests;</p>

<p>[TestFixture]</p>
<p>public class CreateOrderIntegrationTests : IAsyncDisposable {</p>
<p>  private WebApplicationFactory<Program> _factory;</p>
<p>  private HttpClient _client;</p>

<p>  [Before(Test)]</p>
<p>  public async Task SetupAsync() {</p>
<p>    _factory = new WebApplicationFactory<Program>()</p>
<p>      .WithWebHostBuilder(builder => {</p>
<p>        builder.ConfigureServices(services => {</p>
<p>          // Override connection string to use test database</p>
<p>          services.Configure<ConnectionStrings>(options => {</p>
<p>            options.OrdersDb = "Host=localhost;Database=orders_test;Username=postgres;Password=postgres";</p>
<p>          });</p>
<p>        });</p>
<p>      });</p>

<p>    _client = _factory.CreateClient();</p>

<p>    // Clean database before each test</p>
<p>    await CleanDatabaseAsync();</p>
<p>  }</p>

<p>  [After(Test)]</p>
<p>  public async Task TeardownAsync() {</p>
<p>    await CleanDatabaseAsync();</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task POST_CreateOrder_ReturnsCreatedStatusAsync() {</p>
<p>    // Arrange</p>
<p>    var command = new {</p>
<p>      customerId = "cust-123",</p>
<p>      items = new[] {</p>
<p>        new { productId = "prod-456", quantity = 2, unitPrice = 19.99 }</p>
<p>      },</p>
<p>      shippingAddress = new {</p>
<p>        street = "123 Main St",</p>
<p>        city = "Springfield",</p>
<p>        state = "IL",</p>
<p>        zipCode = "62701",</p>
<p>        country = "USA"</p>
<p>      }</p>
<p>    };</p>

<p>    // Act</p>
<p>    var response = await _client.PostAsJsonAsync("/api/orders", command);</p>

<p>    // Assert</p>
<p>    await Assert.That(response.StatusCode).IsEqualTo(HttpStatusCode.Created);</p>

<p>    var result = await response.Content.ReadFromJsonAsync<OrderCreated>();</p>
<p>    await Assert.That(result).IsNotNull();</p>
<p>    await Assert.That(result!.CustomerId).IsEqualTo("cust-123");</p>
<p>    await Assert.That(result.TotalAmount).IsEqualTo(39.98m);</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task POST_CreateOrder_SavesOrderToDatabase_AndPublishesToOutboxAsync() {</p>
<p>    // Arrange</p>
<p>    var command = new { ... };</p>

<p>    // Act</p>
<p>    var response = await _client.PostAsJsonAsync("/api/orders", command);</p>
<p>    var result = await response.Content.ReadFromJsonAsync<OrderCreated>();</p>

<p>    // Assert - Query database directly</p>
<p>    using var connection = new NpgsqlConnection("Host=localhost;Database=orders_test;...");</p>
<p>    await connection.OpenAsync();</p>

<p>    // Check order exists</p>
<p>    var order = await connection.QuerySingleOrDefaultAsync<OrderRow>(</p>
<p>      "SELECT * FROM orders WHERE order_id = @OrderId",</p>
<p>      new { OrderId = result!.OrderId }</p>
<p>    );</p>
<p>    await Assert.That(order).IsNotNull();</p>

<p>    // Check outbox entry exists</p>
<p>    var outboxMessage = await connection.QuerySingleOrDefaultAsync<OutboxRow>(</p>
<p>      "SELECT * FROM outbox WHERE message_type = @MessageType",</p>
<p>      new { MessageType = typeof(OrderCreated).FullName }</p>
<p>    );</p>
<p>    await Assert.That(outboxMessage).IsNotNull();</p>
<p>  }</p>

<p>  private async Task CleanDatabaseAsync() {</p>
<p>    using var connection = new NpgsqlConnection("Host=localhost;Database=orders_test;...");</p>
<p>    await connection.OpenAsync();</p>
<p>    await connection.ExecuteAsync("TRUNCATE TABLE orders, order_items, outbox CASCADE");</p>
<p>  }</p>

<p>  public async ValueTask DisposeAsync() {</p>
<p>    await _client.DisposeAsync();</p>
<p>    await _factory.DisposeAsync();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Testing Event Flow</h3>

<strong>ECommerce.IntegrationTests/OrderToPaymentFlowTests.cs</strong>:

<pre><code class="language-csharp">using TUnit.Core;
<p>using TUnit.Assertions;</p>
<p>using Whizbang.Testing;</p>

<p>namespace ECommerce.IntegrationTests;</p>

<p>[TestFixture]</p>
<p>public class OrderToPaymentFlowTests {</p>
<p>  private TestHarness _harness;</p>

<p>  [Before(Test)]</p>
<p>  public async Task SetupAsync() {</p>
<p>    _harness = new TestHarness()</p>
<p>      .AddService<OrderService>()</p>
<p>      .AddService<InventoryWorker>()</p>
<p>      .AddService<PaymentWorker>()</p>
<p>      .UseInMemoryServiceBus();</p>

<p>    await _harness.StartAsync();</p>
<p>  }</p>

<p>  [After(Test)]</p>
<p>  public async Task TeardownAsync() {</p>
<p>    await _harness.StopAsync();</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task CreateOrder_WithSufficientInventory_ProcessesPaymentAsync() {</p>
<p>    // Arrange</p>
<p>    var command = new CreateOrder(...);</p>

<p>    // Act</p>
<p>    var orderCreatedEvent = await _harness.SendCommandAsync<CreateOrder, OrderCreated>(command);</p>

<p>    // Wait for event propagation</p>
<p>    await _harness.WaitForEventAsync<InventoryReserved>(</p>
<p>      e => e.OrderId == orderCreatedEvent.OrderId,</p>
<p>      timeout: TimeSpan.FromSeconds(10)</p>
<p>    );</p>

<p>    await _harness.WaitForEventAsync<PaymentProcessed>(</p>
<p>      e => e.OrderId == orderCreatedEvent.OrderId,</p>
<p>      timeout: TimeSpan.FromSeconds(10)</p>
<p>    );</p>

<p>    // Assert</p>
<p>    var events = _harness.GetPublishedEvents();</p>
<p>    await Assert.That(events).HasCount().EqualTo(3);  // OrderCreated, InventoryReserved, PaymentProcessed</p>

<p>    var paymentEvent = events.OfType<PaymentProcessed>().Single();</p>
<p>    await Assert.That(paymentEvent.Status).IsEqualTo(PaymentStatus.Captured);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>End-to-End Tests</h2>

<strong>ECommerce.E2ETests/FullOrderLifecycleTests.cs</strong>:

<pre><code class="language-csharp">using TUnit.Core;
<p>using TUnit.Assertions;</p>
<p>using Testcontainers.PostgreSql;</p>
<p>using Testcontainers.AzuriteServiceBus;</p>

<p>namespace ECommerce.E2ETests;</p>

<p>[TestFixture]</p>
<p>public class FullOrderLifecycleTests : IAsyncDisposable {</p>
<p>  private PostgreSqlContainer _postgresContainer;</p>
<p>  private AzuriteServiceBusContainer _serviceBusContainer;</p>
<p>  private HttpClient _orderServiceClient;</p>
<p>  private HttpClient _customerServiceClient;</p>

<p>  [Before(Test)]</p>
<p>  public async Task SetupAsync() {</p>
<p>    // Start containers</p>
<p>    _postgresContainer = new PostgreSqlBuilder()</p>
<p>      .WithImage("postgres:16")</p>
<p>      .Build();</p>

<p>    _serviceBusContainer = new AzuriteServiceBusBuilder()</p>
<p>      .WithImage("mcr.microsoft.com/azure-messaging/servicebus-emulator")</p>
<p>      .Build();</p>

<p>    await _postgresContainer.StartAsync();</p>
<p>    await _serviceBusContainer.StartAsync();</p>

<p>    // Start services with container connection strings</p>
<p>    _orderServiceClient = await StartServiceAsync<OrderService>(</p>
<p>      connectionString: _postgresContainer.GetConnectionString(),</p>
<p>      serviceBusConnectionString: _serviceBusContainer.GetConnectionString()</p>
<p>    );</p>

<p>    _customerServiceClient = await StartServiceAsync<CustomerService>(</p>
<p>      connectionString: _postgresContainer.GetConnectionString(),</p>
<p>      serviceBusConnectionString: _serviceBusContainer.GetConnectionString()</p>
<p>    );</p>

<p>    // Other services...</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task CreateOrder_FullLifecycle_CompletesSuccessfullyAsync() {</p>
<p>    // Arrange</p>
<p>    var command = new {</p>
<p>      customerId = "cust-123",</p>
<p>      items = new[] {</p>
<p>        new { productId = "prod-456", quantity = 2, unitPrice = 19.99 }</p>
<p>      },</p>
<p>      shippingAddress = new {</p>
<p>        street = "123 Main St",</p>
<p>        city = "Springfield",</p>
<p>        state = "IL",</p>
<p>        zipCode = "62701",</p>
<p>        country = "USA"</p>
<p>      }</p>
<p>    };</p>

<p>    // Act</p>
<p>    var createResponse = await _orderServiceClient.PostAsJsonAsync("/api/orders", command);</p>
<p>    var orderCreated = await createResponse.Content.ReadFromJsonAsync<OrderCreated>();</p>

<p>    // Wait for processing (eventually consistent)</p>
<p>    await Task.Delay(TimeSpan.FromSeconds(15));</p>

<p>    // Query order summary from Customer Service (read model)</p>
<p>    var orderSummary = await _customerServiceClient.GetFromJsonAsync<OrderSummaryDto>(</p>
<p>      $"/api/orders/{orderCreated!.OrderId}"</p>
<p>    );</p>

<p>    // Assert</p>
<p>    await Assert.That(orderSummary).IsNotNull();</p>
<p>    await Assert.That(orderSummary!.Status).IsEqualTo("Shipped");</p>
<p>    await Assert.That(orderSummary.PaymentInfo).IsNotNull();</p>
<p>    await Assert.That(orderSummary.PaymentInfo!.Status).IsEqualTo("Captured");</p>
<p>    await Assert.That(orderSummary.ShipmentInfo).IsNotNull();</p>
<p>    await Assert.That(orderSummary.ShipmentInfo!.TrackingNumber).IsNotNull();</p>
<p>  }</p>

<p>  public async ValueTask DisposeAsync() {</p>
<p>    await _postgresContainer.StopAsync();</p>
<p>    await _serviceBusContainer.StopAsync();</p>
<p>    await _postgresContainer.DisposeAsync();</p>
<p>    await _serviceBusContainer.DisposeAsync();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Test Fixtures</h2>

<strong>ECommerce.Testing/Fixtures/OrderFixture.cs</strong>:

<pre><code class="language-csharp">using Bogus;
<p>using ECommerce.Contracts.Commands;</p>
<p>using ECommerce.Contracts.Events;</p>

<p>namespace ECommerce.Testing.Fixtures;</p>

<p>public static class OrderFixture {</p>
<p>  private static readonly Faker<CreateOrder> CreateOrderFaker = new Faker<CreateOrder>()</p>
<p>    .CustomInstantiator(f => new CreateOrder(</p>
<p>      CustomerId: f.Random.AlphaNumeric(10),</p>
<p>      Items: Enumerable.Range(0, f.Random.Int(1, 5))</p>
<p>        .Select(_ => new OrderItem(</p>
<p>          ProductId: f.Commerce.Product(),</p>
<p>          Quantity: f.Random.Int(1, 10),</p>
<p>          UnitPrice: f.Finance.Amount(5, 100)</p>
<p>        ))</p>
<p>        .ToArray(),</p>
<p>      ShippingAddress: new Address(</p>
<p>        Street: f.Address.StreetAddress(),</p>
<p>        City: f.Address.City(),</p>
<p>        State: f.Address.StateAbbr(),</p>
<p>        ZipCode: f.Address.ZipCode(),</p>
<p>        Country: "USA"</p>
<p>      )</p>
<p>    ));</p>

<p>  public static CreateOrder GenerateCreateOrderCommand() {</p>
<p>    return CreateOrderFaker.Generate();</p>
<p>  }</p>

<p>  public static CreateOrder[] GenerateCreateOrderCommands(int count) {</p>
<p>    return CreateOrderFaker.Generate(count).ToArray();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Usage</strong>:

<pre><code class="language-csharp">[Test]
<p>public async Task SomeTest_WithRandomData_WorksCorrectlyAsync() {</p>
<p>  // Arrange</p>
<p>  var command = OrderFixture.GenerateCreateOrderCommand();</p>

<p>  // Act</p>
<p>  var result = await receptor.HandleAsync(command);</p>

<p>  // Assert</p>
<p>  await Assert.That(result).IsNotNull();</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Mocking External Services</h2>

<strong>ECommerce.Testing/Mocks/MockPaymentGateway.cs</strong>:

<pre><code class="language-csharp">using ECommerce.PaymentWorker.Services;

<p>namespace ECommerce.Testing.Mocks;</p>

<p>public class MockPaymentGateway : IPaymentGateway {</p>
<p>  private readonly List<PaymentResult> _results = [];</p>

<p>  public void SetupSuccessfulCharge(string transactionId) {</p>
<p>    _results.Add(new PaymentResult(</p>
<p>      Success: true,</p>
<p>      TransactionId: transactionId,</p>
<p>      ErrorCode: null,</p>
<p>      ErrorMessage: null</p>
<p>    ));</p>
<p>  }</p>

<p>  public void SetupFailedCharge(string errorCode, string errorMessage) {</p>
<p>    _results.Add(new PaymentResult(</p>
<p>      Success: false,</p>
<p>      TransactionId: null,</p>
<p>      ErrorCode: errorCode,</p>
<p>      ErrorMessage: errorMessage</p>
<p>    ));</p>
<p>  }</p>

<p>  public Task<PaymentResult> ChargeAsync(</p>
<p>    string idempotencyKey,</p>
<p>    decimal amount,</p>
<p>    string currency,</p>
<p>    string paymentMethod,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    if (_results.Count == 0) {</p>
<p>      throw new InvalidOperationException("No payment results configured");</p>
<p>    }</p>

<p>    var result = _results[0];</p>
<p>    _results.RemoveAt(0);</p>
<p>    return Task.FromResult(result);</p>
<p>  }</p>

<p>  public Task<RefundResult> RefundAsync(</p>
<p>    string transactionId,</p>
<p>    decimal amount,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    return Task.FromResult(new RefundResult(</p>
<p>      Success: true,</p>
<p>      RefundId: Guid.NewGuid().ToString("N"),</p>
<p>      ErrorMessage: null</p>
<p>    ));</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Test Coverage</h2>

<h3>Running Tests with Coverage</h3>

<pre><code class="language-bash">cd ECommerce.OrderService.Tests
<p>dotnet run -- --coverage --coverage-output-format cobertura --coverage-output coverage.xml</p>
<p></code></pre></p>

<h3>Coverage Targets</h3>

<p>| Component | Target | Rationale |</p>
<p>|-----------|--------|-----------|</p>
<p>| <strong>Receptors</strong> | 90%+ | Core business logic |</p>
<p>| <strong>Perspectives</strong> | 80%+ | Event handling logic |</p>
<p>| <strong>Controllers</strong> | 70%+ | HTTP API endpoints |</p>
<p>| <strong>Services</strong> | 80%+ | Infrastructure code |</p>

<hr>

<h2>Key Takeaways</h2>

<p>✅ <strong>Testing Pyramid</strong> - 60% unit, 30% integration, 10% e2e</p>
<p>✅ <strong>Test Fixtures</strong> - Bogus for test data generation</p>
<p>✅ <strong>Mock External Services</strong> - Isolate unit tests from dependencies</p>
<p>✅ <strong>Integration Tests</strong> - Test with real database and message bus</p>
<p>✅ <strong>E2E Tests</strong> - Testcontainers for full environment simulation</p>
<p>✅ <strong>Test Coverage</strong> - 80%+ for core business logic</p>

<hr>

<h2>Next Steps</h2>

<p>Continue to <strong><a href="deployment.md">Deployment</a></strong> to:</p>
<ul><li>Deploy to Azure Kubernetes Service (AKS)</li>
<li>Configure CI/CD pipelines</li>
<li>Set up monitoring and alerting</li>
<li>Implement blue-green deployments</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-tutorial-tutorial-overview" class="doc-section">
  <h3>ECommerce Tutorial Overview</h3>
  <p class="doc-path"><code>v1.0.0/tutorial/tutorial-overview</code></p>
  <p class="doc-description"><em>Build a complete e-commerce system with Whizbang - microservices, event sourcing, CQRS, and distributed messaging</em></p>
  <div class="doc-content">

<h1>ECommerce Tutorial Overview</h1>

<p>Build a <strong>complete e-commerce system</strong> using Whizbang to learn all framework features through a realistic, production-ready example.</p>

<h2>What You'll Build</h2>

<p>A distributed e-commerce platform with 7 microservices:</p>

<pre><code class="language-">┌─────────────────────────────────────────────────────────────┐
<p>│  ECommerce Platform Architecture                            │</p>
<p>│                                                              │</p>
<p>│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │</p>
<p>│  │   Order      │  │  Inventory   │  │   Payment    │     │</p>
<p>│  │   Service    │  │   Service    │  │   Service    │     │</p>
<p>│  │  (Commands)  │  │  (Commands)  │  │  (Commands)  │     │</p>
<p>│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘     │</p>
<p>│         │                  │                  │             │</p>
<p>│         └──────────────────┼──────────────────┘             │</p>
<p>│                            │                                │</p>
<p>│                  ┌─────────▼─────────┐                      │</p>
<p>│                  │  Azure Service    │                      │</p>
<p>│                  │      Bus          │                      │</p>
<p>│                  │   (Event Hub)     │                      │</p>
<p>│                  └─────────┬─────────┘                      │</p>
<p>│                            │                                │</p>
<p>│         ┌──────────────────┼──────────────────┐             │</p>
<p>│         │                  │                  │             │</p>
<p>│  ┌──────▼───────┐  ┌──────▼───────┐  ┌──────▼───────┐     │</p>
<p>│  │Notification  │  │   Shipping   │  │  Analytics   │     │</p>
<p>│  │   Service    │  │   Service    │  │   Service    │     │</p>
<p>│  │  (Events)    │  │  (Events)    │  │(Perspectives)│     │</p>
<p>│  └──────────────┘  └──────────────┘  └──────────────┘     │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<h3>Services</h3>

<p>| Service | Type | Purpose |</p>
<p>|---------|------|---------|</p>
<p>| <strong>Order Service</strong> | Command API | Order management, CRUD operations |</p>
<p>| <strong>Inventory Service</strong> | Command Worker | Stock tracking, reservations |</p>
<p>| <strong>Payment Service</strong> | Command Worker | Payment processing, transactions |</p>
<p>| <strong>Notification Service</strong> | Event Worker | Email/SMS notifications |</p>
<p>| <strong>Shipping Service</strong> | Event Worker | Shipment creation, tracking |</p>
<p>| <strong>Customer Service</strong> | Query API | Customer read models (BFF) |</p>
<p>| <strong>Analytics Service</strong> | Event Worker | Real-time analytics, reporting |</p>

<h2>What You'll Learn</h2>

<h3>Core Features</h3>
<ul><li>✅ <strong>Commands & Events</strong> - Request/response + pub/sub patterns</li>
<li>✅ <strong>Receptors</strong> - Message handlers with business logic</li>
<li>✅ <strong>Perspectives</strong> - Event-driven read models (CQRS)</li>
<li>✅ <strong>Dispatcher</strong> - Zero-reflection message routing</li>
<li>✅ <strong>Message Context</strong> - Correlation, causation, tracing</li>
</ul>
<h3>Messaging Patterns</h3>
<ul><li>✅ <strong>Outbox Pattern</strong> - Reliable cross-service events</li>
<li>✅ <strong>Inbox Pattern</strong> - Exactly-once message processing</li>
<li>✅ <strong>Work Coordination</strong> - Lease-based distributed processing</li>
<li>✅ <strong>Event Envelopes</strong> - Hop-based observability</li>
</ul>
<h3>Data Access</h3>
<ul><li>✅ <strong>Dapper + PostgreSQL</strong> - High-performance queries</li>
<li>✅ <strong>EF Core 10</strong> - Full-featured ORM</li>
<li>✅ <strong>Event Store</strong> - Event sourcing with time-travel</li>
<li>✅ <strong>Perspectives Storage</strong> - Read model schemas</li>
</ul>
<h3>Infrastructure</h3>
<ul><li>✅ <strong>.NET Aspire</strong> - Local orchestration with emulators</li>
<li>✅ <strong>Azure Service Bus</strong> - Production messaging</li>
<li>✅ <strong>Health Checks</strong> - Kubernetes readiness/liveness</li>
<li>✅ <strong>Policy-Based Routing</strong> - Multi-tenant, environment-aware</li>
</ul>
<h3>Advanced Topics</h3>
<ul><li>✅ <strong>Source Generators</strong> - Zero-reflection discovery</li>
<li>✅ <strong>AOT Compatibility</strong> - Native AOT deployment</li>
<li>✅ <strong>Testing</strong> - Unit, integration, e2e tests</li>
<li>✅ <strong>Deployment</strong> - Docker, Kubernetes, Azure</li>
</ul>
<h2>Prerequisites</h2>

<ul><li><strong>.NET 10.0 RC2+</strong> SDK</li>
<li><strong>Docker Desktop</strong> (for PostgreSQL, Azurite, Service Bus emulator)</li>
<li><strong>Visual Studio 2024</strong> or <strong>VS Code</strong> with C# DevKit</li>
<li><strong>Azure CLI</strong> (for production deployment)</li>
<li><strong>Basic C# knowledge</strong> (records, async/await, dependency injection)</li>
</ul>
<h2>Tutorial Structure</h2>

<h3>Part 1: Foundation (Order & Inventory)</h3>
<ul><li><strong><a href="tutorial-overview.md">Tutorial Overview</a></strong> ← You are here</li>
<li><strong><a href="order-management.md">Order Management</a></strong> - Create orders, command handling</li>
<li><strong><a href="inventory-service.md">Inventory Service</a></strong> - Stock reservations, event publishing</li>
</ul>
<h3>Part 2: Distributed Processing (Payment & Notifications)</h3>
<ul><li><strong><a href="payment-processing.md">Payment Processing</a></strong> - Payment gateway integration</li>
<li><strong><a href="notification-service.md">Notification Service</a></strong> - Email/SMS via events</li>
</ul>
<h3>Part 3: Logistics & Analytics (Shipping & Reporting)</h3>
<ul><li><strong><a href="shipping-service.md">Shipping Service</a></strong> - Shipment creation, tracking</li>
<li><strong><a href="analytics-service.md">Analytics Service</a></strong> - Real-time dashboards</li>
</ul>
<h3>Part 4: Customer Experience (Read Models)</h3>
<ul><li><strong><a href="customer-service.md">Customer Service</a></strong> - BFF pattern, perspectives</li>
</ul>
<h3>Part 5: Production Readiness</h3>
<ul><li><strong><a href="testing-strategy.md">Testing Strategy</a></strong> - Unit, integration, e2e tests</li>
<li><strong><a href="deployment.md">Deployment</a></strong> - Docker, Kubernetes, Azure</li>
</ul>
<h2>Project Setup</h2>

<h3>1. Create Solution</h3>

<pre><code class="language-bash">mkdir ECommerce
<p>cd ECommerce</p>

<p>dotnet new sln -n ECommerce</p>
<p></code></pre></p>

<h3>2. Add Projects</h3>

<pre><code class="language-bash"># Order Service (HTTP API)
<p>dotnet new webapi -n ECommerce.OrderService.API</p>
<p>dotnet sln add ECommerce.OrderService.API</p>

<h1>Inventory Service (Background Worker)</h1>
<p>dotnet new worker -n ECommerce.InventoryWorker</p>
<p>dotnet sln add ECommerce.InventoryWorker</p>

<h1>Payment Service (Background Worker)</h1>
<p>dotnet new worker -n ECommerce.PaymentWorker</p>
<p>dotnet sln add ECommerce.PaymentWorker</p>

<h1>Notification Service (Background Worker)</h1>
<p>dotnet new worker -n ECommerce.NotificationWorker</p>
<p>dotnet sln add ECommerce.NotificationWorker</p>

<h1>Shipping Service (Background Worker)</h1>
<p>dotnet new worker -n ECommerce.ShippingWorker</p>
<p>dotnet sln add ECommerce.ShippingWorker</p>

<h1>Customer Service (HTTP API - BFF)</h1>
<p>dotnet new webapi -n ECommerce.CustomerService.API</p>
<p>dotnet sln add ECommerce.CustomerService.API</p>

<h1>Analytics Service (Background Worker)</h1>
<p>dotnet new worker -n ECommerce.AnalyticsWorker</p>
<p>dotnet sln add ECommerce.AnalyticsWorker</p>

<h1>Shared Contracts</h1>
<p>dotnet new classlib -n ECommerce.Contracts</p>
<p>dotnet sln add ECommerce.Contracts</p>

<h1>Aspire App Host (Orchestration)</h1>
<p>dotnet new aspire-apphost -n ECommerce.AppHost</p>
<p>dotnet sln add ECommerce.AppHost</p>
<p></code></pre></p>

<h3>3. Add Whizbang Packages</h3>

<pre><code class="language-bash"># All projects
<p>dotnet add ECommerce.OrderService.API package Whizbang.Core</p>
<p>dotnet add ECommerce.InventoryWorker package Whizbang.Core</p>
<p>dotnet add ECommerce.PaymentWorker package Whizbang.Core</p>
<p>dotnet add ECommerce.NotificationWorker package Whizbang.Core</p>
<p>dotnet add ECommerce.ShippingWorker package Whizbang.Core</p>
<p>dotnet add ECommerce.CustomerService.API package Whizbang.Core</p>
<p>dotnet add ECommerce.AnalyticsWorker package Whizbang.Core</p>

<h1>Projects with Azure Service Bus</h1>
<p>dotnet add ECommerce.OrderService.API package Whizbang.Transports.AzureServiceBus</p>
<p>dotnet add ECommerce.InventoryWorker package Whizbang.Transports.AzureServiceBus</p>
<p>dotnet add ECommerce.PaymentWorker package Whizbang.Transports.AzureServiceBus</p>
<p>dotnet add ECommerce.NotificationWorker package Whizbang.Transports.AzureServiceBus</p>
<p>dotnet add ECommerce.ShippingWorker package Whizbang.Transports.AzureServiceBus</p>
<p>dotnet add ECommerce.AnalyticsWorker package Whizbang.Transports.AzureServiceBus</p>

<h1>Projects with PostgreSQL</h1>
<p>dotnet add ECommerce.OrderService.API package Whizbang.Data.Postgres</p>
<p>dotnet add ECommerce.InventoryWorker package Whizbang.Data.Postgres</p>
<p>dotnet add ECommerce.CustomerService.API package Whizbang.Data.Postgres</p>
<p>dotnet add ECommerce.AnalyticsWorker package Whizbang.Data.Postgres</p>

<h1>Aspire integration</h1>
<p>dotnet add ECommerce.OrderService.API package Whizbang.Hosting.Azure.ServiceBus</p>
<p>dotnet add ECommerce.AppHost package Aspire.Hosting.Azure.ServiceBus</p>
<p></code></pre></p>

<h3>4. Project Structure</h3>

<pre><code class="language-">ECommerce/
<p>├── ECommerce.sln</p>
<p>├── ECommerce.AppHost/             # .NET Aspire orchestration</p>
<p>├── ECommerce.Contracts/           # Shared messages</p>
<p>│   ├── Commands/</p>
<p>│   │   ├── CreateOrder.cs</p>
<p>│   │   ├── ReserveInventory.cs</p>
<p>│   │   └── ProcessPayment.cs</p>
<p>│   └── Events/</p>
<p>│       ├── OrderCreated.cs</p>
<p>│       ├── InventoryReserved.cs</p>
<p>│       └── PaymentProcessed.cs</p>
<p>├── ECommerce.OrderService.API/    # Order management</p>
<p>│   ├── Receptors/</p>
<p>│   │   ├── CreateOrderReceptor.cs</p>
<p>│   │   └── CancelOrderReceptor.cs</p>
<p>│   └── Controllers/</p>
<p>│       └── OrdersController.cs</p>
<p>├── ECommerce.InventoryWorker/     # Inventory management</p>
<p>│   ├── Receptors/</p>
<p>│   │   └── ReserveInventoryReceptor.cs</p>
<p>│   └── Perspectives/</p>
<p>│       └── InventorySummaryPerspective.cs</p>
<p>├── ECommerce.PaymentWorker/       # Payment processing</p>
<p>│   └── Receptors/</p>
<p>│       └── ProcessPaymentReceptor.cs</p>
<p>├── ECommerce.NotificationWorker/  # Notifications</p>
<p>│   └── Receptors/</p>
<p>│       └── SendNotificationReceptor.cs</p>
<p>├── ECommerce.ShippingWorker/      # Shipping</p>
<p>│   └── Receptors/</p>
<p>│       └── CreateShipmentReceptor.cs</p>
<p>├── ECommerce.CustomerService.API/ # Customer BFF</p>
<p>│   ├── Perspectives/</p>
<p>│   │   ├── OrderSummaryPerspective.cs</p>
<p>│   │   └── CustomerActivityPerspective.cs</p>
<p>│   └── Controllers/</p>
<p>│       └── CustomersController.cs</p>
<p>└── ECommerce.AnalyticsWorker/     # Analytics</p>
<p>    └── Perspectives/</p>
<p>        └── DailySalesAnalyticsPerspective.cs</p>
<p></code></pre></p>

<h2>Key Concepts Demonstrated</h2>

<h3>Event-Driven Architecture</h3>

<pre><code class="language-csharp">// Command: Create Order (synchronous)
<p>CreateOrder command → CreateOrderReceptor → OrderCreated event</p>

<p>// Event: Order Created (asynchronous pub/sub)</p>
<p>OrderCreated event → Published to Azure Service Bus</p>
<p>  ├─ InventoryWorker → ReserveInventory</p>
<p>  ├─ NotificationWorker → SendOrderConfirmation</p>
<p>  └─ AnalyticsWorker → UpdateDailySales (perspective)</p>
<p></code></pre></p>

<h3>CQRS (Command Query Responsibility Segregation)</h3>

<strong>Write Side</strong>:
<ul><li>Order Service receives <code>CreateOrder</code> command</li>
<li>CreateOrderReceptor handles command</li>
<li>Publishes <code>OrderCreated</code> event to event bus</li>
</ul>
<strong>Read Side</strong>:
<ul><li>Customer Service subscribes to <code>OrderCreated</code> events</li>
<li>OrderSummaryPerspective updates read model</li>
<li>CustomersController queries read model (fast!)</li>
</ul>
<h3>Saga Pattern (Distributed Transactions)</h3>

<pre><code class="language-">1. CreateOrder → OrderCreated
<ul><li>OrderCreated → ReserveInventory → InventoryReserved</li>
<li>InventoryReserved → ProcessPayment → PaymentProcessed</li>
<li>PaymentProcessed → CreateShipment → ShipmentCreated</li>
<li>ShipmentCreated → SendShippingNotification → NotificationSent</li>
</ul>
<p>Compensation (if payment fails):</p>
<ul><li>PaymentFailed → ReleaseInventory → InventoryReleased</li>
</ul><p></code></pre></p>

<h2>Development Workflow</h2>

<h3>1. Run Locally (Aspire)</h3>

<pre><code class="language-bash">cd ECommerce.AppHost
<p>dotnet run</p>
<p></code></pre></p>

<p>Open Aspire Dashboard: <code>http://localhost:15000</code></p>

<h3>2. Create Order via API</h3>

<pre><code class="language-bash">curl -X POST http://localhost:5000/orders \
<p>  -H "Content-Type: application/json" \</p>
<p>  -d '{</p>
<p>    "customerId": "cust-123",</p>
<p>    "items": [</p>
<p>      { "productId": "prod-456", "quantity": 2, "unitPrice": 19.99 }</p>
<p>    ]</p>
<p>  }'</p>
<p></code></pre></p>

<h3>3. Observe Event Flow</h3>

<p>Check Aspire Dashboard:</p>
<ul><li>Order Service: HTTP request logged</li>
<li>Service Bus: OrderCreated event published</li>
<li>Inventory Worker: InventoryReserved event published</li>
<li>Payment Worker: PaymentProcessed event published</li>
<li>Notification Worker: Email sent</li>
</ul>
<h3>4. Query Read Model</h3>

<pre><code class="language-bash">curl http://localhost:5001/customers/cust-123/orders
<p></code></pre></p>

<p>Returns denormalized order summary from read model (fast!).</p>

<h2>Next Steps</h2>

<p>Continue to <strong><a href="order-management.md">Order Management</a></strong> to start building the Order Service.</p>

<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2024-12-12</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Workers</h2>
<article id="v1-0-0-workers-database-readiness" class="doc-section">
  <h3>Database Readiness</h3>
  <p class="doc-path"><code>v1.0.0/workers/database-readiness</code></p>
  <p class="doc-description"><em>Database dependency coordination - IDatabaseReadinessCheck pattern, startup coordination, retry logic, and caching strategies</em></p>
  <div class="doc-content">

<h1>Database Readiness</h1>

<p>The <strong>IDatabaseReadinessCheck</strong> pattern provides a standard way for workers to coordinate with database availability during startup and runtime. It distinguishes between "database not ready yet" (expected during startup) and "database connection failed" (unexpected runtime error).</p>

<h2>Overview</h2>

<h3>Why Database Readiness Checks?</h3>

<strong>Without readiness checks</strong>:
<pre><code class="language-csharp">// ❌ Worker starts immediately, database might not be ready
<p>protected override async Task ExecuteAsync(CancellationToken ct) {</p>
<p>  while (!ct.IsCancellationRequested) {</p>
<p>    try {</p>
<p>      await _workCoordinator.ProcessWorkBatchAsync(...);</p>
<p>    } catch (Npgsql.NpgsqlException ex) {</p>
<p>      // Exception thrown - but is this:</p>
<p>      // - Startup (migrations not run yet)?</p>
<p>      // - Runtime failure (connection pool exhausted)?</p>
<p>      // - Server down (network issue)?</p>
<p>      // Can't distinguish - logs are confusing</p>
<p>      _logger.LogError(ex, "Failed to process work");</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>With readiness checks</strong>:
<pre><code class="language-csharp">// ✅ Worker coordinates with database availability
<p>protected override async Task ExecuteAsync(CancellationToken ct) {</p>
<p>  while (!ct.IsCancellationRequested) {</p>
<p>    var isDatabaseReady = await _databaseReadinessCheck.IsReadyAsync(ct);</p>
<p>    if (!isDatabaseReady) {</p>
<p>      // ✅ Clear signal: database not ready (expected during startup)</p>
<p>      _logger.LogInformation("Database not ready, skipping processing");</p>
<p>      await Task.Delay(_pollingInterval, ct);</p>
<p>      continue;</p>
<p>    }</p>

<p>    // ✅ Database is ready - safe to process work</p>
<p>    try {</p>
<p>      await _workCoordinator.ProcessWorkBatchAsync(...);</p>
<p>    } catch (Npgsql.NpgsqlException ex) {</p>
<p>      // ✅ Now we know this is a runtime failure (not startup)</p>
<p>      _logger.LogError(ex, "Database connection failed during processing");</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ <strong>Distinguish startup from runtime failures</strong></li>
<li>✅ <strong>Avoid exception noise</strong> during startup (clean logs)</li>
<li>✅ <strong>Graceful waiting</strong> (poll until ready, don't crash)</li>
<li>✅ <strong>Coordination</strong> (multiple workers wait for same signal)</li>
<li>✅ <strong>Observability</strong> (track consecutive "not ready" checks)</li>
</ul>
<hr>

<h2>IDatabaseReadinessCheck Interface</h2>

<strong>IDatabaseReadinessCheck.cs</strong>:
<pre><code class="language-csharp">/// <summary>
<p>/// Interface for checking whether the database is ready for work coordinator operations.</p>
<p>/// Implementations can check connectivity, schema availability, or other readiness criteria.</p>
<p>/// </summary></p>
<p>/// <remarks></p>
<p>/// This interface is used by workers to determine if database operations</p>
<p>/// should be attempted. When the database is not ready, work processing</p>
<p>/// is skipped and messages remain buffered in memory until the database becomes available.</p>
<p>///</p>
<p>/// Examples of readiness checks:</p>
<p>/// - PostgreSQL: Check if connection is available and required tables exist</p>
<p>/// - SQL Server: Check if database is accessible and schema is initialized</p>
<p>/// - Cassandra: Check if keyspace exists and is reachable</p>
<p>/// - MongoDB: Check if connection is established and collections exist</p>
<p>/// </remarks></p>
<p>/// <docs>workers/database-readiness</docs></p>
<p>public interface IDatabaseReadinessCheck {</p>
<p>  /// <summary></p>
<p>  /// Checks if the database is ready for work coordinator operations.</p>
<p>  /// </summary></p>
<p>  /// <param name="cancellationToken">Cancellation token to cancel the readiness check.</param></p>
<p>  /// <returns>True if the database is ready, false otherwise.</returns></p>
<p>  /// <remarks></p>
<p>  /// This method should be fast and lightweight. If the check requires network I/O,</p>
<p>  /// consider implementing caching or circuit breaker patterns to avoid excessive overhead.</p>
<p>  /// </remarks></p>
<p>  Task<bool> IsReadyAsync(CancellationToken cancellationToken = default);</p>
<p>}</p>
<p></code></pre></p>

<strong>Contract</strong>:
<ul><li>Returns <code>true</code> if database is ready for operations</li>
<li>Returns <code>false</code> if database is not ready (startup) or unavailable</li>
<li>Should be <strong>fast</strong> (lightweight check)</li>
<li>Should <strong>not throw</strong> exceptions (return <code>false</code> on error)</li>
<li>Can use <strong>caching</strong> to avoid repeated network calls</li>
</ul>
<hr>

<h2>PostgreSQL Implementation</h2>

<strong>PostgresDatabaseReadinessCheck.cs</strong>:
<pre><code class="language-csharp">public class PostgresDatabaseReadinessCheck : IDatabaseReadinessCheck {
<p>  private readonly IDbConnectionFactory _connectionFactory;</p>
<p>  private readonly ILogger<PostgresDatabaseReadinessCheck> _logger;</p>

<p>  private bool? _isReady;  // Cache result once ready</p>

<p>  public PostgresDatabaseReadinessCheck(</p>
<p>    IDbConnectionFactory connectionFactory,</p>
<p>    ILogger<PostgresDatabaseReadinessCheck> logger</p>
<p>  ) {</p>
<p>    _connectionFactory = connectionFactory;</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async Task<bool> IsReadyAsync(CancellationToken ct = default) {</p>
<p>    // Once ready, stay ready (no need to re-check)</p>
<p>    if (_isReady == true) {</p>
<p>      return true;</p>
<p>    }</p>

<p>    try {</p>
<p>      await using var connection = _connectionFactory.CreateConnection();</p>
<p>      await connection.OpenAsync(ct);</p>

<p>      // Check for required tables</p>
<p>      var requiredTables = new[] {</p>
<p>        "wh_outbox",</p>
<p>        "wh_inbox",</p>
<p>        "wh_events",</p>
<p>        "wh_perspective_checkpoints"</p>
<p>      };</p>

<p>      foreach (var tableName in requiredTables) {</p>
<p>        var tableExists = await connection.ExecuteScalarAsync<bool>(</p>
<p>          """</p>
<p>          SELECT EXISTS (</p>
<p>            SELECT 1 FROM information_schema.tables</p>
<p>            WHERE table_schema = 'public' AND table_name = @TableName</p>
<p>          )</p>
<p>          """,</p>
<p>          new { TableName = tableName },</p>
<p>          cancellationToken: ct</p>
<p>        );</p>

<p>        if (!tableExists) {</p>
<p>          _logger.LogDebug(</p>
<p>            "Database not ready: table '{TableName}' not found",</p>
<p>            tableName</p>
<p>          );</p>
<p>          _isReady = false;</p>
<p>          return false;</p>
<p>        }</p>
<p>      }</p>

<p>      // All tables exist - database is ready</p>
<p>      _logger.LogInformation("Database is ready");</p>
<p>      _isReady = true;</p>
<p>      return true;</p>

<p>    } catch (Npgsql.NpgsqlException ex) {</p>
<p>      _logger.LogDebug(</p>
<p>        "Database not ready: {Error}",</p>
<p>        ex.Message</p>
<p>      );</p>
<p>      _isReady = false;</p>
<p>      return false;</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Design Decisions</strong>:
<ul><li><strong>Cache <code>true</code> result</strong>: Once ready, always ready (no need to re-check)</li>
<li><strong>Don't cache <code>false</code> result</strong>: Database may become ready later (retry on next call)</li>
<li><strong>Check required tables</strong>: Ensures migrations have run</li>
<li><strong>Log at Debug level for <code>false</code></strong>: Avoid log noise during startup</li>
<li><strong>Log at Information level for <code>true</code></strong>: Important milestone</li>
<li><strong>Never throw</strong>: Return <code>false</code> on any error</li>
</ul>
<hr>

<h2>Integration with Workers</h2>

<h3>PerspectiveWorker Integration</h3>

<strong>PerspectiveWorker.cs:98-121</strong>:
<pre><code class="language-csharp">while (!stoppingToken.IsCancellationRequested) {
<p>  try {</p>
<p>    // Check database readiness before attempting work coordinator call</p>
<p>    var isDatabaseReady = await _databaseReadinessCheck.IsReadyAsync(stoppingToken);</p>
<p>    if (!isDatabaseReady) {</p>
<p>      // Database not ready - skip ProcessWorkBatchAsync</p>
<p>      Interlocked.Increment(ref _consecutiveDatabaseNotReadyChecks);</p>

<p>      _logger.LogInformation(</p>
<p>        "Database not ready, skipping perspective checkpoint processing (consecutive checks: {ConsecutiveCount})",</p>
<p>        _consecutiveDatabaseNotReadyChecks</p>
<p>      );</p>

<p>      // Warn if database has been continuously unavailable</p>
<p>      if (_consecutiveDatabaseNotReadyChecks > 10) {</p>
<p>        _logger.LogWarning(</p>
<p>          "Database not ready for {ConsecutiveCount} consecutive polling cycles. Perspective worker is paused.",</p>
<p>          _consecutiveDatabaseNotReadyChecks</p>
<p>        );</p>
<p>      }</p>

<p>      // Wait before retry</p>
<p>      await Task.Delay(_options.PollingIntervalMilliseconds, stoppingToken);</p>
<p>      continue;</p>
<p>    }</p>

<p>    // Database is ready - reset consecutive counter</p>
<p>    Interlocked.Exchange(ref _consecutiveDatabaseNotReadyChecks, 0);</p>

<p>    await ProcessWorkBatchAsync(stoppingToken);</p>
<p>  } catch (Exception ex) when (ex is not OperationCanceledException) {</p>
<p>    _logger.LogError(ex, "Error processing perspective checkpoints");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Workflow</strong>:
<ul><li><strong>Check readiness</strong> before attempting database operations</li>
<li><strong>If not ready</strong>:</li>
</ul><p>   - Increment consecutive "not ready" counter</p>
<p>   - Log at Information level (expected during startup)</p>
<p>   - Warn if threshold exceeded (10 consecutive checks)</p>
<p>   - Wait polling interval, then retry</p>
<ul><li><strong>If ready</strong>:</li>
</ul><p>   - Reset consecutive counter</p>
<p>   - Proceed with work processing</p>
<ul><li><strong>On exception</strong>:</li>
</ul><p>   - Now known to be runtime failure (not startup issue)</p>
<p>   - Log at Error level</p>

<h3>Startup Processing Integration</h3>

<strong>PerspectiveWorker.cs:82-94</strong>:
<pre><code class="language-csharp">// Process any pending perspective checkpoints IMMEDIATELY on startup (before first polling delay)
<p>try {</p>
<p>  _logger.LogDebug("Checking for pending perspective checkpoints on startup...");</p>
<p>  var isDatabaseReady = await _databaseReadinessCheck.IsReadyAsync(stoppingToken);</p>
<p>  if (isDatabaseReady) {</p>
<p>    await ProcessWorkBatchAsync(stoppingToken);</p>
<p>    _logger.LogDebug("Initial perspective checkpoint processing complete");</p>
<p>  } else {</p>
<p>    _logger.LogWarning("Database not ready on startup - skipping initial perspective checkpoint processing");</p>
<p>  }</p>
<p>} catch (Exception ex) when (ex is not OperationCanceledException) {</p>
<p>  _logger.LogError(ex, "Error processing initial perspective checkpoints on startup");</p>
<p>}</p>
<p></code></pre></p>

<strong>Why important</strong>:
<ul><li>Worker checks readiness <strong>before</strong> attempting immediate startup processing</li>
<li>If not ready, skip processing (don't crash worker)</li>
<li>Worker will retry on first polling cycle</li>
</ul>
<hr>

<h2>Caching Strategies</h2>

<h3>Strategy 1: Cache Once Ready (Recommended)</h3>

<strong>PostgreSQL Example</strong>:
<pre><code class="language-csharp">private bool? _isReady;

<p>public async Task<bool> IsReadyAsync(CancellationToken ct = default) {</p>
<p>  if (_isReady == true) {</p>
<p>    return true;  // ✅ Cache hit - skip check</p>
<p>  }</p>

<p>  // Check database connectivity and schema</p>
<p>  var ready = await CheckDatabaseAsync(ct);</p>

<p>  if (ready) {</p>
<p>    _isReady = true;  // ✅ Cache for future calls</p>
<p>  }</p>

<p>  return ready;</p>
<p>}</p>
<p></code></pre></p>

<strong>Rationale</strong>:
<ul><li>Once database is ready, it stays ready (during runtime)</li>
<li>Database doesn't "become not ready" during normal operation</li>
<li>Avoids repeated network calls after startup</li>
</ul>
<h3>Strategy 2: Time-Based Caching</h3>

<strong>Use Case</strong>: Periodic health checks for monitoring dashboards.

<pre><code class="language-csharp">private bool? _isReady;
<p>private DateTimeOffset? _lastCheck;</p>
<p>private static readonly TimeSpan CacheDuration = TimeSpan.FromMinutes(1);</p>

<p>public async Task<bool> IsReadyAsync(CancellationToken ct = default) {</p>
<p>  if (_isReady == true && _lastCheck.HasValue &&</p>
<p>      DateTimeOffset.UtcNow - _lastCheck.Value < CacheDuration) {</p>
<p>    return true;  // ✅ Cache hit within TTL</p>
<p>  }</p>

<p>  _lastCheck = DateTimeOffset.UtcNow;</p>
<p>  var ready = await CheckDatabaseAsync(ct);</p>
<p>  _isReady = ready;</p>

<p>  return ready;</p>
<p>}</p>
<p></code></pre></p>

<strong>Rationale</strong>:
<ul><li>Provides periodic "heartbeat" check</li>
<li>Detects database failures during runtime</li>
<li>Balances performance vs observability</li>
</ul>
<h3>Strategy 3: Circuit Breaker</h3>

<strong>Use Case</strong>: Avoid overwhelming unhealthy database with connection attempts.

<pre><code class="language-csharp">private CircuitBreakerState _state = CircuitBreakerState.Closed;
<p>private int _consecutiveFailures;</p>
<p>private DateTimeOffset? _circuitOpenedAt;</p>
<p>private static readonly TimeSpan CircuitResetTimeout = TimeSpan.FromSeconds(30);</p>

<p>public async Task<bool> IsReadyAsync(CancellationToken ct = default) {</p>
<p>  // If circuit is open, wait for reset timeout</p>
<p>  if (_state == CircuitBreakerState.Open) {</p>
<p>    if (DateTimeOffset.UtcNow - _circuitOpenedAt! < CircuitResetTimeout) {</p>
<p>      return false;  // ✅ Circuit open - don't attempt check</p>
<p>    }</p>

<p>    _state = CircuitBreakerState.HalfOpen;</p>
<p>  }</p>

<p>  try {</p>
<p>    var ready = await CheckDatabaseAsync(ct);</p>

<p>    if (ready) {</p>
<p>      // Success - close circuit</p>
<p>      _state = CircuitBreakerState.Closed;</p>
<p>      _consecutiveFailures = 0;</p>
<p>      return true;</p>
<p>    } else {</p>
<p>      // Not ready - increment failures</p>
<p>      _consecutiveFailures++;</p>

<p>      if (_consecutiveFailures >= 5) {</p>
<p>        // Open circuit after 5 consecutive failures</p>
<p>        _state = CircuitBreakerState.Open;</p>
<p>        _circuitOpenedAt = DateTimeOffset.UtcNow;</p>
<p>        _logger.LogWarning("Circuit breaker opened after {Count} consecutive failures", _consecutiveFailures);</p>
<p>      }</p>

<p>      return false;</p>
<p>    }</p>
<p>  } catch (Exception ex) {</p>
<p>    _logger.LogDebug("Database check failed: {Error}", ex.Message);</p>
<p>    _consecutiveFailures++;</p>

<p>    if (_consecutiveFailures >= 5) {</p>
<p>      _state = CircuitBreakerState.Open;</p>
<p>      _circuitOpenedAt = DateTimeOffset.UtcNow;</p>
<p>    }</p>

<p>    return false;</p>
<p>  }</p>
<p>}</p>

<p>enum CircuitBreakerState { Closed, Open, HalfOpen }</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>Prevents excessive connection attempts to unhealthy database</li>
<li>Automatic recovery after timeout</li>
<li>Reduces load on database during outages</li>
</ul>
<hr>

<h2>Configuration</h2>

<strong>Service Registration</strong>:
<pre><code class="language-csharp">// Program.cs
<p>builder.Services.AddSingleton<IDatabaseReadinessCheck, PostgresDatabaseReadinessCheck>();</p>
<p>builder.Services.AddHostedService<PerspectiveWorker>();</p>
<p></code></pre></p>

<strong>Options Pattern</strong> (optional):
<pre><code class="language-csharp">public class DatabaseReadinessOptions {
<p>  /// <summary></p>
<p>  /// Required tables that must exist for database to be considered ready.</p>
<p>  /// </summary></p>
<p>  public string[] RequiredTables { get; set; } = {</p>
<p>    "wh_outbox",</p>
<p>    "wh_inbox",</p>
<p>    "wh_events",</p>
<p>    "wh_perspective_checkpoints"</p>
<p>  };</p>

<p>  /// <summary></p>
<p>  /// Cache duration for readiness check results.</p>
<p>  /// Null = cache indefinitely once ready (default)</p>
<p>  /// </summary></p>
<p>  public TimeSpan? CacheDuration { get; set; } = null;</p>

<p>  /// <summary></p>
<p>  /// Circuit breaker threshold (number of consecutive failures before opening circuit).</p>
<p>  /// Null = no circuit breaker (default)</p>
<p>  /// </summary></p>
<p>  public int? CircuitBreakerThreshold { get; set; } = null;</p>
<p>}</p>
<p></code></pre></p>

<strong>Configuration Example</strong>:
<pre><code class="language-csharp">builder.Services.Configure<DatabaseReadinessOptions>(options => {
<p>  options.RequiredTables = new[] {</p>
<p>    "wh_outbox",</p>
<p>    "wh_inbox",</p>
<p>    "wh_events",</p>
<p>    "wh_perspective_checkpoints",</p>
<p>    "wh_service_instances"  // Additional table</p>
<p>  };</p>
<p>  options.CacheDuration = TimeSpan.FromMinutes(5);  // Re-check every 5 minutes</p>
<p>});</p>
<p></code></pre></p>

<hr>

<h2>Health Checks Integration</h2>

<strong>ASP.NET Core Health Checks</strong>:
<pre><code class="language-csharp">public class DatabaseReadinessHealthCheck : IHealthCheck {
<p>  private readonly IDatabaseReadinessCheck _readinessCheck;</p>

<p>  public DatabaseReadinessHealthCheck(IDatabaseReadinessCheck readinessCheck) {</p>
<p>    _readinessCheck = readinessCheck;</p>
<p>  }</p>

<p>  public async Task<HealthCheckResult> CheckHealthAsync(</p>
<p>    HealthCheckContext context,</p>
<p>    CancellationToken ct = default</p>
<p>  ) {</p>
<p>    var isReady = await _readinessCheck.IsReadyAsync(ct);</p>

<p>    return isReady</p>
<p>      ? HealthCheckResult.Healthy("Database is ready")</p>
<p>      : HealthCheckResult.Unhealthy("Database is not ready");</p>
<p>  }</p>
<p>}</p>

<p>// Program.cs</p>
<p>builder.Services.AddHealthChecks()</p>
<p>  .AddCheck<DatabaseReadinessHealthCheck>("database", tags: new[] { "ready" });</p>

<p>app.MapHealthChecks("/health/ready", new HealthCheckOptions {</p>
<p>  Predicate = check => check.Tags.Contains("ready")</p>
<p>});</p>
<p></code></pre></p>

<strong>Kubernetes Integration</strong>:
<pre><code class="language-yaml">apiVersion: v1
<p>kind: Pod</p>
<p>metadata:</p>
<p>  name: whizbang-worker</p>
<p>spec:</p>
<p>  containers:</p>
<p>  - name: worker</p>
<p>    image: whizbang:latest</p>
<p>    readinessProbe:</p>
<p>      httpGet:</p>
<p>        path: /health/ready</p>
<p>        port: 8080</p>
<p>      initialDelaySeconds: 5</p>
<p>      periodSeconds: 10</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>Container orchestrator knows when pod is ready</li>
<li>Traffic routing delayed until database is ready</li>
<li>Automatic pod restart if database becomes unavailable</li>
</ul>
<hr>

<h2>Observability</h2>

<h3>Metrics</h3>

<strong>Track readiness state</strong>:
<pre><code class="language-csharp">public class ObservableDatabaseReadinessCheck : IDatabaseReadinessCheck {
<p>  private readonly IDatabaseReadinessCheck _inner;</p>
<p>  private readonly IMetrics _metrics;</p>

<p>  public async Task<bool> IsReadyAsync(CancellationToken ct = default) {</p>
<p>    var sw = Stopwatch.StartNew();</p>
<p>    var ready = await _inner.IsReadyAsync(ct);</p>
<p>    sw.Stop();</p>

<p>    _metrics.RecordGauge("database.readiness", ready ? 1 : 0);</p>
<p>    _metrics.RecordHistogram("database.readiness.check_duration_ms", sw.ElapsedMilliseconds);</p>

<p>    return ready;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Metrics</strong>:
<ul><li><code>database.readiness</code> (gauge): 1 = ready, 0 = not ready</li>
<li><code>database.readiness.check_duration_ms</code> (histogram): Check latency</li>
<li><code>database.readiness.consecutive_failures</code> (counter): Track failure streaks</li>
</ul>
<h3>Logging</h3>

<strong>Log level guidance</strong>:
<pre><code class="language-csharp">// ✅ GOOD: Log levels match severity
<p>if (!isReady) {</p>
<p>  _logger.LogDebug("Database not ready: {Reason}", reason);  // Startup</p>
<p>} else {</p>
<p>  _logger.LogInformation("Database is ready");  // Milestone</p>
<p>}</p>

<p>if (consecutiveFailures > 10) {</p>
<p>  _logger.LogWarning("Database not ready for {Count} consecutive checks", consecutiveFailures);  // Alert</p>
<p>}</p>
<p></code></pre></p>

<strong>❌ BAD: Logging "not ready" at Error level</strong>:
<pre><code class="language-csharp">if (!isReady) {
<p>  _logger.LogError("Database not ready");  // ❌ Creates noise during startup</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Testing</h2>

<h3>Testing Readiness Check</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task IsReadyAsync_WithRunningDatabase_ReturnsTrueAsync() {</p>
<p>  // Arrange</p>
<p>  var dbCheck = new PostgresDatabaseReadinessCheck(_connectionFactory, _logger);</p>

<p>  // Act</p>
<p>  var isReady = await dbCheck.IsReadyAsync();</p>

<p>  // Assert</p>
<p>  await Assert.That(isReady).IsTrue();</p>
<p>}</p>

<p>[Test]</p>
<p>public async Task IsReadyAsync_WithMissingTables_ReturnsFalseAsync() {</p>
<p>  // Arrange</p>
<p>  var dbCheck = new PostgresDatabaseReadinessCheck(_emptyDbConnectionFactory, _logger);</p>

<p>  // Act</p>
<p>  var isReady = await dbCheck.IsReadyAsync();</p>

<p>  // Assert</p>
<p>  await Assert.That(isReady).IsFalse();</p>
<p>}</p>
<p></code></pre></p>

<h3>Testing Worker Integration</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task Worker_DatabaseNotReady_SkipsProcessingAsync() {</p>
<p>  // Arrange</p>
<p>  var mockDbCheck = new Mock<IDatabaseReadinessCheck>();</p>
<p>  mockDbCheck.Setup(x => x.IsReadyAsync(It.IsAny<CancellationToken>()))</p>
<p>    .ReturnsAsync(false);</p>

<p>  var worker = new PerspectiveWorker(</p>
<p>    _instanceProvider,</p>
<p>    _scopeFactory,</p>
<p>    _options,</p>
<p>    mockDbCheck.Object,</p>
<p>    _logger</p>
<p>  );</p>

<p>  // Act</p>
<p>  await worker.StartAsync();</p>
<p>  await Task.Delay(TimeSpan.FromSeconds(2));  // Let worker poll</p>
<p>  await worker.StopAsync();</p>

<p>  // Assert - ProcessWorkBatchAsync should NOT have been called</p>
<p>  await Assert.That(worker.ConsecutiveDatabaseNotReadyChecks).IsGreaterThan(0);</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Cache <code>true</code> result</strong> - Once ready, always ready (during runtime)</li>
<li>✅ <strong>Don't cache <code>false</code> result</strong> - Database may become ready later</li>
<li>✅ <strong>Check required tables</strong> - Ensures migrations have run</li>
<li>✅ <strong>Log at appropriate levels</strong> - Debug for <code>false</code>, Information for <code>true</code></li>
<li>✅ <strong>Never throw exceptions</strong> - Return <code>false</code> on error</li>
<li>✅ <strong>Use circuit breaker</strong> for high-frequency checks</li>
<li>✅ <strong>Track consecutive failures</strong> for alerting</li>
<li>✅ <strong>Integrate with health checks</strong> for Kubernetes readiness probes</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Throw exceptions from <code>IsReadyAsync()</code> (return <code>false</code> instead)</li>
<li>❌ Log "not ready" at Error level (creates noise during startup)</li>
<li>❌ Cache <code>false</code> result indefinitely (prevents recovery)</li>
<li>❌ Make expensive checks (lightweight only)</li>
<li>❌ Skip readiness checks (workers will crash on startup)</li>
<li>❌ Ignore consecutive failures (could indicate larger problem)</li>
</ul>
<hr>

<h2>Troubleshooting</h2>

<h3>Problem: Worker Keeps Reporting "Database Not Ready"</h3>

<strong>Symptoms</strong>: Logs show repeated "Database not ready" messages.

<strong>Causes</strong>:
<ul><li>Migrations haven't run yet</li>
<li>Required tables missing</li>
<li>Connection string incorrect</li>
<li>Database server not started</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-bash"># Check if database is accessible
<p>psql -h localhost -U postgres -d whizbang -c "SELECT 1;"</p>

<h1>Check if required tables exist</h1>
<p>psql -h localhost -U postgres -d whizbang -c "\dt wh_*"</p>

<h1>Run migrations</h1>
<p>dotnet ef database update</p>

<h1>Check logs for specific table missing</h1>
<p>grep "table '.*' not found" logs.txt</p>
<p></code></pre></p>

<h3>Problem: False Positive (Reports Ready When Not)</h3>

<strong>Symptoms</strong>: Worker starts, then crashes with database errors.

<strong>Causes</strong>:
<ul><li>Check only verifies connectivity, not schema</li>
<li>Caching bug (cache <code>false</code> as <code>true</code>)</li>
</ul>
<strong>Solution</strong>: Enhance check to verify table existence:
<pre><code class="language-csharp">public async Task<bool> IsReadyAsync(CancellationToken ct = default) {
<p>  // Don't just check connection - verify tables too</p>
<p>  var tableExists = await connection.ExecuteScalarAsync<bool>(</p>
<p>    "SELECT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'wh_outbox')",</p>
<p>    cancellationToken: ct</p>
<p>  );</p>

<p>  return tableExists;</p>
<p>}</p>
<p></code></pre></p>

<h3>Problem: Performance Impact</h3>

<strong>Symptoms</strong>: High database load from readiness checks.

<strong>Causes</strong>:
<ul><li>No caching (checking every poll)</li>
<li>Expensive query (complex schema check)</li>
</ul>
<strong>Solution</strong>: Implement caching and lightweight checks:
<pre><code class="language-csharp">private bool? _isReady;

<p>public async Task<bool> IsReadyAsync(CancellationToken ct = default) {</p>
<p>  if (_isReady == true) {</p>
<p>    return true;  // ✅ Skip check if already ready</p>
<p>  }</p>

<p>  // Lightweight check - just verify connection and one table</p>
<p>  var ready = await connection.ExecuteScalarAsync<bool>(</p>
<p>    "SELECT EXISTS (SELECT 1 FROM wh_outbox LIMIT 1)",</p>
<p>    cancellationToken: ct</p>
<p>  );</p>

<p>  if (ready) {</p>
<p>    _isReady = true;</p>
<p>  }</p>

<p>  return ready;</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Related Workers</strong>:
<ul><li><a href="perspective-worker.md">Perspective Worker</a> - Background checkpoint processing</li>
<li><a href="execution-lifecycle.md">Execution Lifecycle</a> - Startup/shutdown coordination</li>
</ul>
<strong>Infrastructure</strong>:
<ul><li><a href="../infrastructure/postgresql-setup.md">PostgreSQL Setup</a> - Database initialization</li>
<li><a href="../data/migrations.md">Migrations</a> - Schema management</li>
</ul>
<strong>Testing</strong>:
<ul><li><a href="../testing/integration.md">Integration Testing</a> - Testing database integration</li>
</ul>
<strong>Monitoring</strong>:
<ul><li><a href="../monitoring/health-checks.md">Health Checks</a> - Application health monitoring</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2025-12-21</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-workers-execution-lifecycle" class="doc-section">
  <h3>Execution Lifecycle</h3>
  <p class="doc-path"><code>v1.0.0/workers/execution-lifecycle</code></p>
  <p class="doc-description"><em>Application startup and shutdown coordination - IExecutionStrategy lifecycle hooks, graceful shutdown with work draining, and worker coordination</em></p>
  <div class="doc-content">

<h1>Execution Lifecycle</h1>

<p>The <strong>Execution Lifecycle</strong> defines how Whizbang coordinates application startup, normal operation, and graceful shutdown. It's built around the <code>IExecutionStrategy</code> interface which provides lifecycle hooks (<code>StartAsync</code>, <code>StopAsync</code>, <code>DrainAsync</code>) for controlled initialization and cleanup.</p>

<h2>Overview</h2>

<h3>Why Lifecycle Management Matters</h3>

<p>Without proper lifecycle coordination:</p>
<ul><li>❌ Workers start before database is ready → exceptions on startup</li>
<li>❌ Application shuts down mid-processing → data loss</li>
<li>❌ In-flight work abandoned → orphaned leases</li>
<li>❌ No graceful cleanup → resource leaks</li>
</ul>
<p>With <code>IExecutionStrategy</code> lifecycle:</p>
<ul><li>✅ Workers wait for dependencies (database ready) before starting</li>
<li>✅ Clean shutdown signal → no new work accepted</li>
<li>✅ Work draining → in-flight operations complete</li>
<li>✅ Graceful cleanup → resources released properly</li>
</ul>
<hr>

<h2>IExecutionStrategy Interface</h2>

<strong>IExecutionStrategy.cs</strong>:
<pre><code class="language-csharp">/// <summary>
<p>/// Defines a strategy for executing message handlers.</p>
<p>/// Implementations control ordering, concurrency, and lifecycle.</p>
<p>/// </summary></p>
<p>/// <docs>components/dispatcher</docs></p>
<p>/// <docs>workers/execution-lifecycle</docs></p>
<p>public interface IExecutionStrategy {</p>
<p>  /// <summary></p>
<p>  /// Name of the execution strategy (e.g., "Serial", "Parallel")</p>
<p>  /// </summary></p>
<p>  string Name { get; }</p>

<p>  /// <summary></p>
<p>  /// Executes a message handler with the given envelope and context.</p>
<p>  /// </summary></p>
<p>  ValueTask<TResult> ExecuteAsync<TResult>(</p>
<p>    IMessageEnvelope envelope,</p>
<p>    Func<IMessageEnvelope, PolicyContext, ValueTask<TResult>> handler,</p>
<p>    PolicyContext context,</p>
<p>    CancellationToken ct = default</p>
<p>  );</p>

<p>  /// <summary></p>
<p>  /// Starts the execution strategy (initializes any background workers/channels)</p>
<p>  /// </summary></p>
<p>  Task StartAsync(CancellationToken ct = default);</p>

<p>  /// <summary></p>
<p>  /// Stops the execution strategy (stops accepting new work)</p>
<p>  /// </summary></p>
<p>  Task StopAsync(CancellationToken ct = default);</p>

<p>  /// <summary></p>
<p>  /// Drains any pending work and waits for completion</p>
<p>  /// </summary></p>
<p>  Task DrainAsync(CancellationToken ct = default);</p>
<p>}</p>
<p></code></pre></p>

<strong>Three Lifecycle Phases</strong>:
<ul><li><strong>StartAsync</strong>: Initialize workers, channels, background tasks</li>
<li><strong>StopAsync</strong>: Stop accepting new work, signal shutdown</li>
<li><strong>DrainAsync</strong>: Wait for in-flight work to complete</li>
</ul>
<hr>

<h2>Startup Lifecycle Flow</h2>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant App as Application</p>
<p>    participant ES as IExecutionStrategy</p>
<p>    participant DRC as IDatabaseReadinessCheck</p>
<p>    participant PW as PerspectiveWorker</p>
<p>    participant WC as IWorkCoordinator</p>

<p>    rect rgb(240, 255, 240)</p>
<p>        Note over App,DRC: Phase 1: Initialization</p>
<p>        App->>App: Configure services</p>
<p>        App->>App: Build service provider</p>
<p>    end</p>

<p>    rect rgb(240, 248, 255)</p>
<p>        Note over App,ES: Phase 2: Start Execution Strategy</p>
<p>        App->>ES: StartAsync()</p>
<p>        Note over ES: Initialize channels,<br/>start background workers</p>
<p>        ES-->>App: Started</p>
<p>    end</p>

<p>    rect rgb(255, 250, 240)</p>
<p>        Note over PW,DRC: Phase 3: Worker Startup</p>
<p>        ES->>PW: StartExecuteAsync() (BackgroundService)</p>
<p>        PW->>DRC: IsReadyAsync()</p>

<p>        alt Database Ready</p>
<p>            DRC-->>PW: true</p>
<p>            PW->>WC: ProcessWorkBatchAsync() (immediate)</p>
<p>            Note over PW,WC: Process pending work<br/>on startup</p>
<p>            WC-->>PW: Work batch processed</p>
<p>        else Database Not Ready</p>
<p>            DRC-->>PW: false</p>
<p>            Note over PW: Wait and retry<br/>(database initializing)</p>
<p>        end</p>
<p>    end</p>

<p>    rect rgb(240, 255, 240)</p>
<p>        Note over PW,WC: Phase 4: Normal Operation</p>
<p>        loop Every PollingInterval</p>
<p>            PW->>DRC: IsReadyAsync()</p>
<p>            alt Ready</p>
<p>                DRC-->>PW: true</p>
<p>                PW->>WC: ProcessWorkBatchAsync()</p>
<p>                WC-->>PW: Work batch</p>
<p>            else Not Ready</p>
<p>                DRC-->>PW: false</p>
<p>                Note over PW: Skip polling cycle</p>
<p>            end</p>
<p>        end</p>
<p>    end</p>

<p>    rect rgb(255, 240, 240)</p>
<p>        Note over App,PW: Phase 5: Shutdown Signal</p>
<p>        App->>ES: StopAsync() (SIGTERM received)</p>
<p>        ES->>PW: StopAsync() (CancellationToken)</p>
<p>        Note over PW: Stop accepting<br/>new work</p>
<p>        PW->>PW: Complete current batch</p>
<p>    end</p>

<p>    rect rgb(255, 240, 255)</p>
<p>        Note over App,PW: Phase 6: Drain & Cleanup</p>
<p>        App->>ES: DrainAsync()</p>
<p>        ES->>PW: Await ExecuteAsync completion</p>
<p>        PW-->>ES: Work drained</p>
<p>        ES-->>App: All work complete</p>
<p>        Note over App: Exit gracefully</p>
<p>    end</p>
<p></code></pre></p>

<strong>Key Phases</strong>:
<ul><li><strong>Initialization</strong>: Configure services, build DI container</li>
<li><strong>Start Execution Strategy</strong>: Initialize execution infrastructure</li>
<li><strong>Worker Startup</strong>: Workers start, check database readiness, process pending work</li>
<li><strong>Normal Operation</strong>: Polling loop with database readiness checks</li>
<li><strong>Shutdown Signal</strong>: Stop accepting new work</li>
<li><strong>Drain & Cleanup</strong>: Wait for in-flight work, release resources</li>
</ul>
<hr>

<h2>StartAsync: Initialization</h2>

<strong>Purpose</strong>: Initialize execution strategy infrastructure before accepting work.

<h3>Execution Strategy Responsibilities</h3>

<strong>Example: SerialExecutionStrategy</strong>:
<pre><code class="language-csharp">public class SerialExecutionStrategy : IExecutionStrategy {
<p>  private Channel<WorkItem>? _channel;</p>
<p>  private Task? _worker;</p>

<p>  public async Task StartAsync(CancellationToken ct = default) {</p>
<p>    // 1. Create bounded channel for work items</p>
<p>    _channel = Channel.CreateBounded<WorkItem>(new BoundedChannelOptions(1000) {</p>
<p>      FullMode = BoundedChannelFullMode.Wait</p>
<p>    });</p>

<p>    // 2. Start background worker</p>
<p>    _worker = Task.Run(() => ProcessWorkItemsAsync(ct), ct);</p>

<p>    _logger.LogInformation("SerialExecutionStrategy started");</p>
<p>  }</p>

<p>  private async Task ProcessWorkItemsAsync(CancellationToken ct) {</p>
<p>    await foreach (var workItem in _channel.Reader.ReadAllAsync(ct)) {</p>
<p>      // Process work items serially</p>
<p>      await workItem.Handler(workItem.Envelope, workItem.Context, ct);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>What happens</strong>:
<ul><li>Create channels, queues, or other work coordination structures</li>
<li>Start background workers or task processors</li>
<li>Initialize connections (if needed)</li>
<li>Log startup completion</li>
</ul>
<h3>BackgroundService Integration</h3>

<strong>PerspectiveWorker (BackgroundService)</strong>:
<pre><code class="language-csharp">public class PerspectiveWorker : BackgroundService {
<p>  protected override async Task ExecuteAsync(CancellationToken stoppingToken) {</p>
<p>    _logger.LogInformation(</p>
<p>      "Perspective worker starting: Instance {InstanceId}",</p>
<p>      _instanceProvider.InstanceId</p>
<p>    );</p>

<p>    // IMMEDIATE processing on startup (before first poll delay)</p>
<p>    try {</p>
<p>      var isDatabaseReady = await _databaseReadinessCheck.IsReadyAsync(stoppingToken);</p>
<p>      if (isDatabaseReady) {</p>
<p>        await ProcessWorkBatchAsync(stoppingToken);</p>
<p>        _logger.LogDebug("Initial perspective checkpoint processing complete");</p>
<p>      } else {</p>
<p>        _logger.LogWarning("Database not ready on startup - skipping initial processing");</p>
<p>      }</p>
<p>    } catch (Exception ex) when (ex is not OperationCanceledException) {</p>
<p>      _logger.LogError(ex, "Error processing initial perspective checkpoints");</p>
<p>    }</p>

<p>    // Enter normal polling loop</p>
<p>    while (!stoppingToken.IsCancellationRequested) {</p>
<p>      // ... polling logic</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Best Practices</strong>:
<ul><li>✅ <strong>Check dependencies</strong> before starting work (database readiness)</li>
<li>✅ <strong>Process pending work immediately</strong> on startup (don't wait for first poll)</li>
<li>✅ <strong>Log startup events</strong> for observability</li>
<li>✅ <strong>Handle startup exceptions</strong> gracefully (don't crash worker)</li>
</ul>
<hr>

<h2>StopAsync: Shutdown Signal</h2>

<strong>Purpose</strong>: Stop accepting new work and signal workers to begin shutdown.

<h3>Execution Strategy Responsibilities</h3>

<strong>Example: SerialExecutionStrategy</strong>:
<pre><code class="language-csharp">public async Task StopAsync(CancellationToken ct = default) {
<p>  // 1. Stop accepting new work</p>
<p>  _channel?.Writer.Complete();</p>

<p>  _logger.LogInformation("SerialExecutionStrategy stopped accepting new work");</p>

<p>  // NOTE: Do NOT wait for work to complete here - that's DrainAsync's job</p>
<p>}</p>
<p></code></pre></p>

<strong>What happens</strong>:
<ul><li>Close channels (no new writes accepted)</li>
<li>Set internal flags (<code>_stopping = true</code>)</li>
<li>Signal background workers to stop after current work</li>
<li>Log shutdown initiated</li>
</ul>
<strong>DO NOT</strong>:
<ul><li>❌ Wait for work to complete (that's <code>DrainAsync</code>)</li>
<li>❌ Forcefully terminate workers (allow graceful completion)</li>
<li>❌ Throw exceptions (shutdown should always succeed)</li>
</ul>
<h3>BackgroundService Integration</h3>

<strong>PerspectiveWorker</strong>:
<pre><code class="language-csharp">protected override async Task ExecuteAsync(CancellationToken stoppingToken) {
<p>  while (!stoppingToken.IsCancellationRequested) {</p>
<p>    try {</p>
<p>      // ... process work batch</p>
<p>    } catch (OperationCanceledException) {</p>
<p>      // Graceful shutdown - exit loop</p>
<p>      _logger.LogInformation("Perspective worker stopping (cancellation requested)");</p>
<p>      break;</p>
<p>    }</p>
<p>  }</p>

<p>  _logger.LogInformation("Perspective worker stopped");</p>
<p>}</p>
<p></code></pre></p>

<strong>How BackgroundService works</strong>:
<ul><li><code>IHostApplicationLifetime.ApplicationStopping</code> event fires</li>
<li><code>BackgroundService.StopAsync()</code> called → sets <code>CancellationToken</code></li>
<li>Worker detects cancellation → completes current batch</li>
<li>Worker exits <code>ExecuteAsync()</code> loop</li>
<li><code>BackgroundService.StopAsync()</code> awaits <code>ExecuteAsync()</code> completion</li>
</ul>
<strong>Timeline Example</strong>:
<pre><code class="language-">t=0ms:    SIGTERM received (Ctrl+C or docker stop)
<p>t=5ms:    ApplicationStopping event fires</p>
<p>t=10ms:   BackgroundService.StopAsync() called</p>
<p>t=15ms:   CancellationToken set</p>
<p>t=100ms:  Worker detects cancellation</p>
<p>t=150ms:  Current batch completes</p>
<p>t=200ms:  Worker exits ExecuteAsync()</p>
<p>t=250ms:  StopAsync() returns</p>
<p></code></pre></p>

<hr>

<h2>DrainAsync: Work Completion</h2>

<strong>Purpose</strong>: Wait for all in-flight work to complete before final shutdown.

<h3>Execution Strategy Responsibilities</h3>

<strong>Example: SerialExecutionStrategy</strong>:
<pre><code class="language-csharp">public async Task DrainAsync(CancellationToken ct = default) {
<p>  // 1. Wait for background worker to complete</p>
<p>  if (_worker != null) {</p>
<p>    try {</p>
<p>      await _worker.WaitAsync(TimeSpan.FromSeconds(30), ct);</p>
<p>      _logger.LogInformation("SerialExecutionStrategy drained all work");</p>
<p>    } catch (TimeoutException) {</p>
<p>      _logger.LogWarning("Drain timeout - some work may not have completed");</p>
<p>    }</p>
<p>  }</p>

<p>  // 2. Cleanup resources</p>
<p>  _channel = null;</p>
<p>  _worker = null;</p>
<p>}</p>
<p></code></pre></p>

<strong>What happens</strong>:
<ul><li>Wait for background workers to complete (with timeout)</li>
<li>Await any pending task completion</li>
<li>Release resources (channels, connections)</li>
<li>Log drain completion</li>
</ul>
<strong>Timeout Handling</strong>:
<ul><li>Set reasonable timeout (e.g., 30 seconds)</li>
<li>Log warning if timeout exceeded</li>
<li>Allow shutdown to proceed (don't block forever)</li>
</ul>
<h3>Application Integration</h3>

<strong>ASP.NET Core Program.cs</strong>:
<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);

<p>// Configure services</p>
<p>builder.Services.AddScoped<IExecutionStrategy, SerialExecutionStrategy>();</p>
<p>builder.Services.AddHostedService<PerspectiveWorker>();</p>

<p>var app = builder.Build();</p>

<p>// Application startup</p>
<p>await app.StartAsync();</p>

<p>// Lifecycle: StartAsync called automatically by .NET host</p>
<p>// - IExecutionStrategy.StartAsync()</p>
<p>// - BackgroundService.StartExecuteAsync()</p>

<p>// Normal operation</p>
<p>// - Workers process events</p>
<p>// - Application serves requests</p>

<p>// Shutdown signal (SIGTERM, Ctrl+C, etc.)</p>
<p>var lifetime = app.Services.GetRequiredService<IHostApplicationLifetime>();</p>
<p>lifetime.ApplicationStopping.Register(() => {</p>
<p>  // IExecutionStrategy.StopAsync() called</p>
<p>  // BackgroundService.StopAsync() sets CancellationToken</p>
<p>});</p>

<p>await app.WaitForShutdownAsync();</p>

<p>// Lifecycle: DrainAsync called before final shutdown</p>
<p>// - IExecutionStrategy.DrainAsync()</p>
<p>// - BackgroundService awaits ExecuteAsync completion</p>

<p>await app.StopAsync();</p>
<p></code></pre></p>

<hr>

<h2>Database Readiness Coordination</h2>

<p>Workers use <code>IDatabaseReadinessCheck</code> to coordinate startup with database availability:</p>

<h3>Why Database Readiness Matters</h3>

<strong>Without readiness checks</strong>:
<pre><code class="language-csharp">// ❌ Worker starts before database is ready
<p>protected override async Task ExecuteAsync(CancellationToken ct) {</p>
<p>  while (!ct.IsCancellationRequested) {</p>
<p>    try {</p>
<p>      await _workCoordinator.ProcessWorkBatchAsync(...);  // EXCEPTION: database not ready</p>
<p>    } catch (Npgsql.NpgsqlException ex) {</p>
<p>      // Database connection failed - but why?</p>
<p>      // - Migrations not run yet?</p>
<p>      // - Connection pool not initialized?</p>
<p>      // - Database server not started?</p>
<p>      // Can't distinguish startup from runtime failures</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>With readiness checks</strong>:
<pre><code class="language-csharp">// ✅ Worker waits for database before processing
<p>protected override async Task ExecuteAsync(CancellationToken ct) {</p>
<p>  while (!ct.IsCancellationRequested) {</p>
<p>    var isDatabaseReady = await _databaseReadinessCheck.IsReadyAsync(ct);</p>
<p>    if (!isDatabaseReady) {</p>
<p>      _logger.LogInformation("Database not ready, skipping processing");</p>
<p>      await Task.Delay(_pollingInterval, ct);</p>
<p>      continue;  // Skip this cycle</p>
<p>    }</p>

<p>    // Database is ready - safe to process work</p>
<p>    await _workCoordinator.ProcessWorkBatchAsync(...);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ <strong>Distinguish startup from runtime failures</strong> (not ready vs connection failed)</li>
<li>✅ <strong>Avoid exception noise</strong> during startup (clean logs)</li>
<li>✅ <strong>Graceful waiting</strong> (poll until ready)</li>
<li>✅ <strong>Coordination</strong> (multiple workers wait for same signal)</li>
</ul>
<h3>Implementation Example</h3>

<strong>PostgresDatabaseReadinessCheck</strong>:
<pre><code class="language-csharp">public class PostgresDatabaseReadinessCheck : IDatabaseReadinessCheck {
<p>  private readonly IDbConnectionFactory _connectionFactory;</p>
<p>  private readonly ILogger<PostgresDatabaseReadinessCheck> _logger;</p>

<p>  private bool? _isReady;  // Cache result (avoid repeated checks)</p>

<p>  public async Task<bool> IsReadyAsync(CancellationToken ct = default) {</p>
<p>    if (_isReady == true) {</p>
<p>      return true;  // Already ready - skip check</p>
<p>    }</p>

<p>    try {</p>
<p>      await using var connection = _connectionFactory.CreateConnection();</p>
<p>      await connection.OpenAsync(ct);</p>

<p>      // Check for required tables</p>
<p>      var tableExists = await connection.ExecuteScalarAsync<bool>(</p>
<p>        """</p>
<p>        SELECT EXISTS (</p>
<p>          SELECT 1 FROM information_schema.tables</p>
<p>          WHERE table_name IN ('wh_outbox', 'wh_inbox', 'wh_events', 'wh_perspective_checkpoints')</p>
<p>        )</p>
<p>        """,</p>
<p>        cancellationToken: ct</p>
<p>      );</p>

<p>      _isReady = tableExists;</p>
<p>      return tableExists;</p>

<p>    } catch (Npgsql.NpgsqlException ex) {</p>
<p>      _logger.LogDebug("Database not ready: {Error}", ex.Message);</p>
<p>      _isReady = false;</p>
<p>      return false;</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Caching Strategy</strong>:
<ul><li>Cache <code>true</code> result (once ready, stays ready)</li>
<li>Re-check on <code>false</code> result (may become ready later)</li>
<li>No TTL expiry (database doesn't "become not ready" during runtime)</li>
</ul>
<p>See <a href="database-readiness.md">Database Readiness</a> for full details.</p>

<hr>

<h2>Graceful Shutdown Best Practices</h2>

<h3>DO ✅</h3>

<strong>1. Complete Current Batch</strong>:
<pre><code class="language-csharp">protected override async Task ExecuteAsync(CancellationToken ct) {
<p>  while (!ct.IsCancellationRequested) {</p>
<p>    var workBatch = await GetWorkBatchAsync(ct);</p>

<p>    foreach (var workItem in workBatch) {</p>
<p>      // ✅ Check cancellation BETWEEN items, not during</p>
<p>      if (ct.IsCancellationRequested) {</p>
<p>        _logger.LogInformation("Shutdown requested - completing current batch");</p>
<p>        break;</p>
<p>      }</p>

<p>      await ProcessWorkItemAsync(workItem, ct);</p>
<p>    }</p>

<p>    // Report results for completed items</p>
<p>    await ReportResults(ct);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>2. Set Reasonable Drain Timeout</strong>:
<pre><code class="language-csharp">public async Task DrainAsync(CancellationToken ct = default) {
<p>  var timeout = TimeSpan.FromSeconds(30);  // ✅ 30 seconds max</p>

<p>  try {</p>
<p>    await _worker.WaitAsync(timeout, ct);</p>
<p>  } catch (TimeoutException) {</p>
<p>    _logger.LogWarning("Drain timeout - forcing shutdown");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>3. Use Shutdown Token for New Work</strong>:
<pre><code class="language-csharp">public ValueTask<TResult> ExecuteAsync<TResult>(
<p>  IMessageEnvelope envelope,</p>
<p>  Func<IMessageEnvelope, PolicyContext, ValueTask<TResult>> handler,</p>
<p>  PolicyContext context,</p>
<p>  CancellationToken ct = default</p>
<p>) {</p>
<p>  if (_shutdownToken.IsCancellationRequested) {</p>
<p>    throw new InvalidOperationException("Execution strategy is shutting down");</p>
<p>  }</p>

<p>  // Accept new work only if not shutting down</p>
<p>  return _channel.Writer.WriteAsync(new WorkItem(...), ct);</p>
<p>}</p>
<p></code></pre></p>

<h3>DON'T ❌</h3>

<strong>1. Don't Abandon In-Flight Work</strong>:
<pre><code class="language-csharp">// ❌ BAD: Immediately exit on cancellation
<p>protected override async Task ExecuteAsync(CancellationToken ct) {</p>
<p>  while (!ct.IsCancellationRequested) {</p>
<p>    var workBatch = await GetWorkBatchAsync(ct);</p>

<p>    foreach (var workItem in workBatch) {</p>
<p>      if (ct.IsCancellationRequested) {</p>
<p>        return;  // ❌ Abandoned rest of batch!</p>
<p>      }</p>

<p>      await ProcessWorkItemAsync(workItem, ct);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>2. Don't Block Shutdown Indefinitely</strong>:
<pre><code class="language-csharp">// ❌ BAD: No timeout on drain
<p>public async Task DrainAsync(CancellationToken ct = default) {</p>
<p>  await _worker;  // ❌ Could wait forever if worker is stuck</p>
<p>}</p>
<p></code></pre></p>

<strong>3. Don't Throw on Shutdown</strong>:
<pre><code class="language-csharp">// ❌ BAD: Throwing exceptions during shutdown
<p>public async Task StopAsync(CancellationToken ct = default) {</p>
<p>  if (_worker == null) {</p>
<p>    throw new InvalidOperationException("Not started");  // ❌ Crashes shutdown</p>
<p>  }</p>

<p>  _channel.Writer.Complete();</p>
<p>}</p>

<p>// ✅ GOOD: Log and continue</p>
<p>public async Task StopAsync(CancellationToken ct = default) {</p>
<p>  if (_worker == null) {</p>
<p>    _logger.LogWarning("StopAsync called but worker was never started");</p>
<p>    return;  // ✅ Graceful</p>
<p>  }</p>

<p>  _channel.Writer.Complete();</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Observability</h2>

<h3>Logging Startup</h3>

<pre><code class="language-csharp">public async Task StartAsync(CancellationToken ct = default) {
<p>  _logger.LogInformation(</p>
<p>    "Starting {StrategyName} execution strategy",</p>
<p>    Name</p>
<p>  );</p>

<p>  // ... initialization</p>

<p>  _logger.LogInformation(</p>
<p>    "{StrategyName} started successfully",</p>
<p>    Name</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<h3>Logging Shutdown</h3>

<pre><code class="language-csharp">public async Task StopAsync(CancellationToken ct = default) {
<p>  _logger.LogInformation(</p>
<p>    "{StrategyName} stopping - no new work will be accepted",</p>
<p>    Name</p>
<p>  );</p>

<p>  _channel.Writer.Complete();</p>
<p>}</p>

<p>public async Task DrainAsync(CancellationToken ct = default) {</p>
<p>  _logger.LogInformation(</p>
<p>    "{StrategyName} draining - waiting for {PendingCount} pending work items",</p>
<p>    Name,</p>
<p>    _channel.Reader.Count</p>
<p>  );</p>

<p>  await _worker.WaitAsync(TimeSpan.FromSeconds(30), ct);</p>

<p>  _logger.LogInformation(</p>
<p>    "{StrategyName} drained successfully",</p>
<p>    Name</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<h3>Metrics</h3>

<strong>Track shutdown duration</strong>:
<pre><code class="language-csharp">private readonly Stopwatch _shutdownTimer = new();

<p>public async Task StopAsync(CancellationToken ct = default) {</p>
<p>  _shutdownTimer.Start();</p>
<p>  _channel.Writer.Complete();</p>
<p>}</p>

<p>public async Task DrainAsync(CancellationToken ct = default) {</p>
<p>  await _worker.WaitAsync(TimeSpan.FromSeconds(30), ct);</p>

<p>  _shutdownTimer.Stop();</p>
<p>  _logger.LogInformation(</p>
<p>    "Shutdown completed in {ElapsedMs}ms",</p>
<p>    _shutdownTimer.ElapsedMilliseconds</p>
<p>  );</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Testing Lifecycle</h2>

<h3>Testing StartAsync</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task StartAsync_ShouldBeIdempotentAsync() {</p>
<p>  // Arrange</p>
<p>  var strategy = new SerialExecutionStrategy();</p>

<p>  // Act</p>
<p>  await strategy.StartAsync();</p>
<p>  await strategy.StartAsync();  // Call twice</p>

<p>  // Assert - should not throw</p>
<p>  await Assert.That(strategy.Name).IsNotNull();</p>
<p>}</p>
<p></code></pre></p>

<h3>Testing StopAsync</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task StopAsync_ShouldPreventNewExecutionsAsync() {</p>
<p>  // Arrange</p>
<p>  var strategy = new SerialExecutionStrategy();</p>
<p>  await strategy.StartAsync();</p>

<p>  // Act</p>
<p>  await strategy.StopAsync();</p>

<p>  // Assert - new executions should throw</p>
<p>  await Assert.ThrowsAsync<InvalidOperationException>(async () => {</p>
<p>    await strategy.ExecuteAsync(envelope, handler, context);</p>
<p>  });</p>
<p>}</p>
<p></code></pre></p>

<h3>Testing DrainAsync</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task DrainAsync_ShouldWaitForPendingWorkAsync() {</p>
<p>  // Arrange</p>
<p>  var strategy = new SerialExecutionStrategy();</p>
<p>  await strategy.StartAsync();</p>

<p>  var workCompleted = false;</p>
<p>  var handler = async (envelope, context, ct) => {</p>
<p>    await Task.Delay(500, ct);  // Simulate 500ms work</p>
<p>    workCompleted = true;</p>
<p>    return new object();</p>
<p>  };</p>

<p>  // Queue work</p>
<p>  var workTask = strategy.ExecuteAsync(envelope, handler, context);</p>

<p>  // Act - drain immediately</p>
<p>  await strategy.StopAsync();</p>
<p>  await strategy.DrainAsync();</p>

<p>  // Assert - work should have completed</p>
<p>  await Assert.That(workCompleted).IsTrue();</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Common Patterns</h2>

<h3>Pattern 1: Initialization Dependencies</h3>

<strong>Problem</strong>: Worker needs database migrations before starting.

<strong>Solution</strong>:
<pre><code class="language-csharp">public class PerspectiveWorker : BackgroundService {
<p>  private readonly IDatabaseReadinessCheck _dbCheck;</p>

<p>  protected override async Task ExecuteAsync(CancellationToken ct) {</p>
<p>    // Wait for database readiness before starting</p>
<p>    while (!await _dbCheck.IsReadyAsync(ct)) {</p>
<p>      _logger.LogInformation("Waiting for database initialization...");</p>
<p>      await Task.Delay(TimeSpan.FromSeconds(5), ct);</p>
<p>    }</p>

<p>    _logger.LogInformation("Database ready - starting perspective processing");</p>

<p>    // Begin normal operation</p>
<p>    while (!ct.IsCancellationRequested) {</p>
<p>      await ProcessWorkBatchAsync(ct);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern 2: Multi-Phase Shutdown</h3>

<strong>Problem</strong>: Need to drain work from multiple channels.

<strong>Solution</strong>:
<pre><code class="language-csharp">public async Task DrainAsync(CancellationToken ct = default) {
<p>  // Phase 1: Drain primary work queue</p>
<p>  _primaryChannel.Writer.Complete();</p>
<p>  await _primaryWorker.WaitAsync(TimeSpan.FromSeconds(15), ct);</p>

<p>  // Phase 2: Drain secondary work queue (depends on primary)</p>
<p>  _secondaryChannel.Writer.Complete();</p>
<p>  await _secondaryWorker.WaitAsync(TimeSpan.FromSeconds(15), ct);</p>

<p>  _logger.LogInformation("All work drained");</p>
<p>}</p>
<p></code></pre></p>

<h3>Pattern 3: Startup Health Checks</h3>

<strong>Problem</strong>: Expose readiness to container orchestrator (Kubernetes).

<strong>Solution</strong>:
<pre><code class="language-csharp">// ASP.NET Core health checks
<p>builder.Services.AddHealthChecks()</p>
<p>  .AddCheck<DatabaseReadinessHealthCheck>("database")</p>
<p>  .AddCheck<ExecutionStrategyHealthCheck>("execution");</p>

<p>app.MapHealthChecks("/health/ready", new HealthCheckOptions {</p>
<p>  Predicate = check => check.Tags.Contains("ready")</p>
<p>});</p>
<p></code></pre></p>

<hr>

<h2>Troubleshooting</h2>

<h3>Problem: Worker Starts Before Database Ready</h3>

<strong>Symptoms</strong>: Exceptions on startup, "connection refused" errors.

<strong>Solution</strong>: Implement <code>IDatabaseReadinessCheck</code> and poll until ready:
<pre><code class="language-csharp">var isDatabaseReady = await _databaseReadinessCheck.IsReadyAsync(ct);
<p>if (!isDatabaseReady) {</p>
<p>  await Task.Delay(_pollingInterval, ct);</p>
<p>  continue;</p>
<p>}</p>
<p></code></pre></p>

<h3>Problem: Shutdown Hangs Indefinitely</h3>

<strong>Symptoms</strong>: Application doesn't exit after SIGTERM.

<strong>Causes</strong>:
<ul><li><code>DrainAsync()</code> has no timeout</li>
<li>Background worker stuck in infinite loop</li>
<li>Deadlock in work processing</li>
</ul>
<strong>Solution</strong>: Add timeout to drain:
<pre><code class="language-csharp">public async Task DrainAsync(CancellationToken ct = default) {
<p>  try {</p>
<p>    await _worker.WaitAsync(TimeSpan.FromSeconds(30), ct);</p>
<p>  } catch (TimeoutException) {</p>
<p>    _logger.LogWarning("Drain timeout - forcing shutdown");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Problem: Work Abandoned on Shutdown</h3>

<strong>Symptoms</strong>: In-flight work not completed, data loss.

<strong>Causes</strong>:
<ul><li>Worker exits immediately on cancellation</li>
<li><code>StopAsync()</code> kills worker instead of signaling</li>
<li><code>DrainAsync()</code> not awaited</li>
</ul>
<strong>Solution</strong>: Complete current batch before exiting:
<pre><code class="language-csharp">protected override async Task ExecuteAsync(CancellationToken ct) {
<p>  while (!ct.IsCancellationRequested) {</p>
<p>    var batch = await GetWorkBatchAsync(ct);</p>

<p>    foreach (var item in batch) {</p>
<p>      // Check cancellation BETWEEN items</p>
<p>      if (ct.IsCancellationRequested) {</p>
<p>        _logger.LogInformation("Completing current batch before shutdown");</p>
<p>        break;</p>
<p>      }</p>

<p>      await ProcessWorkItemAsync(item, ct);</p>
<p>    }</p>

<p>    // Report results for completed items</p>
<p>    await ReportResultsAsync(ct);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Further Reading</h2>

<strong>Related Workers</strong>:
<ul><li><a href="perspective-worker.md">Perspective Worker</a> - Concrete BackgroundService implementation</li>
<li><a href="database-readiness.md">Database Readiness</a> - Startup dependency coordination</li>
</ul>
<strong>Core Concepts</strong>:
<ul><li><a href="../components/dispatcher.md">Dispatcher</a> - Message routing and execution</li>
</ul>
<strong>Messaging</strong>:
<ul><li><a href="../messaging/work-coordinator.md">Work Coordinator</a> - Atomic batch processing</li>
<li><a href="../messaging/outbox-pattern.md">Outbox Pattern</a> - Reliable event publishing</li>
</ul>
<strong>Testing</strong>:
<ul><li><a href="../testing/foundation.md">Testing Guide</a> - Testing lifecycle hooks</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2025-12-21</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="v1-0-0-workers-perspective-worker" class="doc-section">
  <h3>Perspective Worker</h3>
  <p class="doc-path"><code>v1.0.0/workers/perspective-worker</code></p>
  <p class="doc-description"><em>Background worker for processing perspective checkpoints - automatic checkpoint creation, polling workflow, error tracking, and startup coordination</em></p>
  <div class="doc-content">

<h1>Perspective Worker</h1>

<p>The <strong>PerspectiveWorker</strong> is a background service (BackgroundService) that continuously processes perspective checkpoints by polling for new events, invoking perspective runners, and tracking progress. It implements a complete 4-phase checkpoint system with automatic creation, fuzzy type matching, checkpoint updates, and error tracking.</p>

<h2>Overview</h2>

<h3>What the Perspective Worker Does</h3>

<p>The PerspectiveWorker orchestrates the entire perspective checkpoint lifecycle:</p>

<ul><li><strong>Polls</strong> for perspective checkpoint work via <code>IWorkCoordinator</code></li>
<li><strong>Resolves</strong> appropriate <code>IPerspectiveRunner</code> for each checkpoint</li>
<li><strong>Invokes</strong> runners to process events since last checkpoint</li>
<li><strong>Tracks</strong> completions and failures</li>
<li><strong>Updates</strong> checkpoint records with latest event IDs and errors</li>
<li><strong>Coordinates</strong> with other instances via lease-based distribution</li>
</ul>
<strong>Key Insight</strong>: The PerspectiveWorker is the runtime engine that makes perspective checkpoints work. It transforms the compile-time perspective discovery (source generators) into a running system that processes events reliably.

<hr>

<h2>The 4-Phase Checkpoint System</h2>

<p>The PerspectiveWorker implements a complete checkpoint system built across four database migrations:</p>

<h3><strong>Phase 1: Auto-Creation on Event Arrival</strong> (Migration 004)</h3>

<p>When a new event arrives in the event store, perspective checkpoints are <strong>automatically created</strong> for all matching perspectives.</p>

<pre><code class="language-sql">-- Migration 004: Auto-create checkpoints when events arrive
<p>CREATE OR REPLACE FUNCTION auto_create_perspective_checkpoints()</p>
<p>RETURNS TRIGGER AS $$</p>
<p>BEGIN</p>
<p>  -- Find all perspectives that handle this event type (fuzzy matching)</p>
<p>  INSERT INTO wh_perspective_checkpoints (</p>
<p>    stream_id,</p>
<p>    perspective_name,</p>
<p>    last_event_id,</p>
<p>    status,</p>
<p>    created_at,</p>
<p>    updated_at</p>
<p>  )</p>
<p>  SELECT</p>
<p>    NEW.stream_id,</p>
<p>    pm.perspective_name,</p>
<p>    NEW.event_id,</p>
<p>    'Pending',  -- Ready for processing</p>
<p>    NOW(),</p>
<p>    NOW()</p>
<p>  FROM wh_perspective_mappings pm</p>
<p>  WHERE pm.event_type_pattern ~* ('^' || NEW.event_type || '$')  -- Fuzzy type match</p>
<p>  ON CONFLICT (stream_id, perspective_name) DO NOTHING;</p>

<p>  RETURN NEW;</p>
<p>END;</p>
<p>$$ LANGUAGE plpgsql;</p>
<p></code></pre></p>

<strong>What this means</strong>:
<ul><li>Event <code>OrderCreated</code> arrives → All perspectives handling <code>OrderCreated</code> get a checkpoint</li>
<li>Checkpoint status starts as <code>Pending</code> (ready to process)</li>
<li>If checkpoint already exists, skip (idempotent)</li>
</ul>
<h3><strong>Phase 2: Fuzzy Type Matching</strong> (Migration 004)</h3>

<p>Perspectives are matched to events using <strong>fuzzy type matching</strong> via <code>wh_perspective_mappings</code>:</p>

<pre><code class="language-sql">-- Perspective mappings table (populated by source generator registration)
<p>CREATE TABLE wh_perspective_mappings (</p>
<p>  perspective_name VARCHAR(200) NOT NULL,</p>
<p>  event_type_pattern VARCHAR(500) NOT NULL,  -- Regex pattern for matching</p>
<p>  PRIMARY KEY (perspective_name, event_type_pattern)</p>
<p>);</p>

<p>-- Example data:</p>
<p>-- perspective_name            | event_type_pattern</p>
<p>-- ----------------------------+-------------------</p>
<p>-- OrderSummaryPerspective     | .<em>OrderCreated.</em></p>
<p>-- CustomerStatsPerspective    | .<em>Order.</em></p>
<p>-- InventoryPerspective        | .<em>OrderCreated.</em></p>
<p></code></pre></p>

<strong>Why fuzzy matching?</strong>
<ul><li>Handles event type name variations (<code>OrderCreated</code> vs <code>MyApp.Events.OrderCreated</code>)</li>
<li>Supports namespace changes without re-registering perspectives</li>
<li>Flexible enough for generator-discovered perspectives</li>
</ul>
<h3><strong>Phase 3: Checkpoint Processing</strong> (Migration 005)</h3>

<p>The PerspectiveWorker <strong>polls</strong> for pending checkpoints and processes them:</p>

<pre><code class="language-sql">-- Migration 005: Claim checkpoint work for processing
<p>CREATE OR REPLACE FUNCTION claim_perspective_checkpoint_work(</p>
<p>  p_instance_id UUID,</p>
<p>  p_service_name VARCHAR(255),</p>
<p>  p_max_checkpoints INT DEFAULT 10</p>
<p>)</p>
<p>RETURNS TABLE (</p>
<p>  stream_id UUID,</p>
<p>  perspective_name VARCHAR(200),</p>
<p>  last_processed_event_id UUID,</p>
<p>  status SMALLINT</p>
<p>) AS $$</p>
<p>BEGIN</p>
<p>  -- Claim up to p_max_checkpoints pending checkpoints</p>
<p>  -- Uses lease-based coordination to prevent conflicts</p>
<p>  RETURN QUERY</p>
<p>  UPDATE wh_perspective_checkpoints</p>
<p>  SET</p>
<p>    instance_id = p_instance_id,</p>
<p>    service_name = p_service_name,</p>
<p>    lease_expiry = NOW() + INTERVAL '5 minutes',</p>
<p>    status = 'Processing'</p>
<p>  WHERE (stream_id, perspective_name) IN (</p>
<p>    SELECT stream_id, perspective_name</p>
<p>    FROM wh_perspective_checkpoints</p>
<p>    WHERE status = 'Pending'</p>
<p>       OR (status = 'Processing' AND lease_expiry < NOW())  -- Reclaim expired leases</p>
<p>    ORDER BY created_at</p>
<p>    LIMIT p_max_checkpoints</p>
<p>    FOR UPDATE SKIP LOCKED  -- Prevents conflicts between workers</p>
<p>  )</p>
<p>  RETURNING stream_id, perspective_name, last_event_id, status;</p>
<p>END;</p>
<p>$$ LANGUAGE plpgsql;</p>
<p></code></pre></p>

<strong>Workflow</strong>:
<ul><li>Worker polls via <code>IWorkCoordinator.ProcessWorkBatchAsync()</code></li>
<li>Work Coordinator calls <code>claim_perspective_checkpoint_work()</code></li>
<li>Worker receives checkpoints to process</li>
<li>Worker invokes <code>IPerspectiveRunner.RunAsync()</code> for each checkpoint</li>
<li>Runner processes events since <code>last_processed_event_id</code></li>
<li>Worker collects completions/failures</li>
</ul>
<h3><strong>Phase 4: Error Tracking</strong> (Migration 005a)</h3>

<p>When processing completes (success or failure), the checkpoint is <strong>updated</strong> with results:</p>

<pre><code class="language-sql">-- Migration 005a: Complete checkpoint work (with error tracking)
<p>CREATE OR REPLACE FUNCTION complete_perspective_checkpoint_work(</p>
<p>  p_stream_id UUID,</p>
<p>  p_perspective_name VARCHAR(200),</p>
<p>  p_last_event_id UUID,</p>
<p>  p_status SMALLINT,</p>
<p>  p_error_message TEXT DEFAULT NULL  -- NEW: Error tracking</p>
<p>)</p>
<p>RETURNS VOID AS $$</p>
<p>BEGIN</p>
<p>  UPDATE wh_perspective_checkpoints</p>
<p>  SET</p>
<p>    last_event_id = p_last_event_id,</p>
<p>    status = p_status,</p>
<p>    error = p_error_message,  -- NEW: Persisting error messages</p>
<p>    updated_at = NOW(),</p>
<p>    instance_id = NULL,  -- Release lease</p>
<p>    lease_expiry = NULL</p>
<p>  WHERE stream_id = p_stream_id</p>
<p>    AND perspective_name = p_perspective_name;</p>
<p>END;</p>
<p>$$ LANGUAGE plpgsql;</p>
<p></code></pre></p>

<strong>Error Handling</strong>:
<ul><li><strong>Success</strong>: Status = <code>Completed</code>, error = NULL</li>
<li><strong>Failure</strong>: Status = <code>Failed</code>, error = exception message</li>
<li>Failed checkpoints are <strong>retried</strong> on next poll (status = <code>Pending</code> again)</li>
<li>Error messages are <strong>persisted</strong> for debugging and observability</li>
</ul>
<hr>

<h2>Perspective Checkpoint Processing Flow</h2>

<pre><code class="language-mermaid">sequenceDiagram
<p>    participant ES as Event Store</p>
<p>    participant DB as wh_perspective_checkpoints</p>
<p>    participant WC as WorkCoordinator</p>
<p>    participant PW as PerspectiveWorker</p>
<p>    participant PR as IPerspectiveRunner</p>

<p>    Note over ES,DB: Phase 1: Auto-Create Checkpoints</p>
<p>    ES->>ES: New event arrives (OrderCreated)</p>
<p>    ES->>DB: Trigger: auto_create_perspective_checkpoints()</p>
<p>    Note over DB: stream_id, perspective_name,<br/>last_event_id, status=Pending</p>

<p>    Note over WC,PW: Phase 3: Poll & Process</p>
<p>    loop Every PollingIntervalMs (default 1s)</p>
<p>        PW->>WC: ProcessWorkBatchAsync()</p>
<p>        WC->>DB: claim_perspective_checkpoint_work()</p>
<p>        DB-->>WC: PerspectiveWork[] (claimed checkpoints)</p>
<p>        WC-->>PW: Claimed work batch</p>

<p>        alt Has Work</p>
<p>            loop For each checkpoint</p>
<p>                PW->>PR: RunAsync(streamId, perspectiveName, lastEventId)</p>
<p>                alt Processing Success</p>
<p>                    PR-->>PW: PerspectiveCheckpointCompletion</p>
<p>                    Note over PW: Collect completion</p>
<p>                else Processing Failure</p>
<p>                    PR-->>PW: Exception</p>
<p>                    Note over PW: Collect failure (with error message)</p>
<p>                end</p>
<p>            end</p>
<p>        end</p>

<p>        Note over PW,DB: Phase 4: Update Checkpoints</p>
<p>        PW->>WC: ProcessWorkBatchAsync(completions, failures)</p>
<p>        WC->>DB: complete_perspective_checkpoint_work()</p>
<p>        alt Success</p>
<p>            Note over DB: status=Completed,<br/>error=NULL</p>
<p>        else Failure</p>
<p>            Note over DB: status=Failed,<br/>error=exception.Message</p>
<p>        end</p>
<p>    end</p>

<p>    rect rgb(255, 240, 240)</p>
<p>        Note over PW,DB: Error Tracking (Phase 4)</p>
<p>        PW->>DB: Update with error message</p>
<p>        Note over DB: Checkpoint persists error<br/>for debugging/observability</p>
<p>    end</p>
<p></code></pre></p>

<strong>Key Phases</strong>:
<ul><li><strong>Phase 1</strong> (Auto-Create): Event arrives → checkpoints auto-created</li>
<li><strong>Phase 2</strong> (Fuzzy Match): Perspectives matched via regex patterns</li>
<li><strong>Phase 3</strong> (Process): Worker polls → claims → processes → collects results</li>
<li><strong>Phase 4</strong> (Track): Results persisted (completions or errors)</li>
</ul>
<hr>

<h2>Startup Processing</h2>

<p>The PerspectiveWorker processes pending checkpoints <strong>IMMEDIATELY</strong> on startup (before the first polling delay):</p>

<strong>PerspectiveWorker.cs:82-94</strong>:
<pre><code class="language-csharp">// Process any pending perspective checkpoints IMMEDIATELY on startup (before first polling delay)
<p>try {</p>
<p>  _logger.LogDebug("Checking for pending perspective checkpoints on startup...");</p>
<p>  var isDatabaseReady = await _databaseReadinessCheck.IsReadyAsync(stoppingToken);</p>
<p>  if (isDatabaseReady) {</p>
<p>    await ProcessWorkBatchAsync(stoppingToken);</p>
<p>    _logger.LogDebug("Initial perspective checkpoint processing complete");</p>
<p>  } else {</p>
<p>    _logger.LogWarning("Database not ready on startup - skipping initial perspective checkpoint processing");</p>
<p>  }</p>
<p>} catch (Exception ex) when (ex is not OperationCanceledException) {</p>
<p>  _logger.LogError(ex, "Error processing initial perspective checkpoints on startup");</p>
<p>}</p>
<p></code></pre></p>

<strong>Why important?</strong>
<ul><li>✅ <strong>Immediate Processing</strong>: No delay waiting for first poll interval</li>
<li>✅ <strong>Startup Responsiveness</strong>: Events processed as soon as worker starts</li>
<li>✅ <strong>Database Coordination</strong>: Waits for database readiness before processing</li>
<li>✅ <strong>Graceful Failure</strong>: Logs error but continues (doesn't crash worker)</li>
</ul>
<strong>Example Timeline</strong>:
<pre><code class="language-">t=0ms:    Worker starts
<p>t=5ms:    Check database readiness → Ready</p>
<p>t=10ms:   ProcessWorkBatchAsync() → 5 checkpoints claimed</p>
<p>t=500ms:  All 5 checkpoints processed</p>
<p>t=1000ms: First regular poll begins (PollingIntervalMs)</p>
<p></code></pre></p>

<hr>

<h2>Database Readiness Checks</h2>

<p>The PerspectiveWorker integrates with <code>IDatabaseReadinessCheck</code> to coordinate startup:</p>

<strong>PerspectiveWorker.cs:98-121</strong>:
<pre><code class="language-csharp">while (!stoppingToken.IsCancellationRequested) {
<p>  try {</p>
<p>    // Check database readiness before attempting work coordinator call</p>
<p>    var isDatabaseReady = await _databaseReadinessCheck.IsReadyAsync(stoppingToken);</p>
<p>    if (!isDatabaseReady) {</p>
<p>      // Database not ready - skip ProcessWorkBatchAsync</p>
<p>      Interlocked.Increment(ref _consecutiveDatabaseNotReadyChecks);</p>

<p>      _logger.LogInformation(</p>
<p>        "Database not ready, skipping perspective checkpoint processing (consecutive checks: {ConsecutiveCount})",</p>
<p>        _consecutiveDatabaseNotReadyChecks</p>
<p>      );</p>

<p>      // Warn if database has been continuously unavailable</p>
<p>      if (_consecutiveDatabaseNotReadyChecks > 10) {</p>
<p>        _logger.LogWarning(</p>
<p>          "Database not ready for {ConsecutiveCount} consecutive polling cycles. Perspective worker is paused.",</p>
<p>          _consecutiveDatabaseNotReadyChecks</p>
<p>        );</p>
<p>      }</p>

<p>      await Task.Delay(_options.PollingIntervalMilliseconds, stoppingToken);</p>
<p>      continue;</p>
<p>    }</p>

<p>    // Database is ready - reset consecutive counter</p>
<p>    Interlocked.Exchange(ref _consecutiveDatabaseNotReadyChecks, 0);</p>

<p>    await ProcessWorkBatchAsync(stoppingToken);</p>
<p>  } catch (Exception ex) when (ex is not OperationCanceledException) {</p>
<p>    _logger.LogError(ex, "Error processing perspective checkpoints");</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Pattern</strong>:
<ul><li>Check database readiness <strong>before</strong> attempting work coordination</li>
<li>If not ready, <strong>skip processing</strong> and wait</li>
<li>Track <strong>consecutive failures</strong> for observability</li>
<li><strong>Reset counter</strong> when database becomes ready</li>
</ul>
<strong>Use Cases</strong>:
<ul><li><strong>Startup</strong>: Database not yet initialized (migrations pending)</li>
<li><strong>Maintenance</strong>: Database temporarily unavailable (connection pool exhausted)</li>
<li><strong>Failure</strong>: Database down (network issue, server restart)</li>
</ul>
<p>See <a href="database-readiness.md">Database Readiness</a> for full details on <code>IDatabaseReadinessCheck</code> pattern.</p>

<hr>

<h2>Error Tracking & Retry</h2>

<p>The PerspectiveWorker implements comprehensive error tracking:</p>

<strong>PerspectiveWorker.cs:233-248</strong>:
<pre><code class="language-csharp">} catch (Exception ex) {
<p>  _logger.LogError(</p>
<p>    ex,</p>
<p>    "Error processing perspective checkpoint: {PerspectiveName} for stream {StreamId}",</p>
<p>    perspectiveWork.PerspectiveName,</p>
<p>    perspectiveWork.StreamId</p>
<p>  );</p>

<p>  _failures.Add(new PerspectiveCheckpointFailure {</p>
<p>    StreamId = perspectiveWork.StreamId,</p>
<p>    PerspectiveName = perspectiveWork.PerspectiveName,</p>
<p>    LastEventId = perspectiveWork.LastProcessedEventId ?? Guid.Empty,</p>
<p>    Status = PerspectiveProcessingStatus.Failed,</p>
<p>    Error = ex.Message  // Error message captured here</p>
<p>  });</p>
<p>}</p>
<p></code></pre></p>

<strong>Error Workflow</strong>:
<ul><li>Exception thrown during perspective processing</li>
<li>Error logged with full context (stream ID, perspective name)</li>
<li>Failure record created with <strong>error message</strong></li>
<li>Next poll: Worker reports failure to Work Coordinator</li>
<li>Work Coordinator persists error to <code>wh_perspective_checkpoints.error</code> column</li>
<li>Checkpoint status set to <code>Failed</code></li>
<li>Future poll: Checkpoint retried (status reset to <code>Pending</code>)</li>
</ul>
<strong>Example Error Record</strong>:
<pre><code class="language-sql">-- wh_perspective_checkpoints after failure
<p>stream_id                           | perspective_name           | status | error</p>
<p>------------------------------------|----------------------------|--------|------------------</p>
<p>order-abc-123                       | OrderSummaryPerspective    | Failed | Null reference exception: customerId</p>
<p></code></pre></p>

<strong>Retry Strategy</strong>:
<ul><li>Failed checkpoints are <strong>automatically retried</strong> on next poll</li>
<li>No manual intervention required</li>
<li>Error message persisted for debugging</li>
<li>Observability: Monitor <code>status='Failed'</code> count</li>
</ul>
<hr>

<h2>Lease-Based Coordination</h2>

<p>The PerspectiveWorker uses <strong>lease-based coordination</strong> to distribute work across multiple instances:</p>

<h3>How Leases Work</h3>

<strong>Claim</strong>:
<pre><code class="language-sql">-- Worker A claims checkpoint
<p>UPDATE wh_perspective_checkpoints</p>
<p>SET</p>
<p>    instance_id = 'worker-a-uuid',</p>
<p>    service_name = 'OrderService',</p>
<p>    lease_expiry = NOW() + INTERVAL '5 minutes',</p>
<p>    status = 'Processing'</p>
<p>WHERE (stream_id, perspective_name) = ('order-123', 'OrderSummaryPerspective')</p>
<p></code></pre></p>

<strong>Release</strong> (on completion):
<pre><code class="language-sql">-- Worker A completes and releases
<p>UPDATE wh_perspective_checkpoints</p>
<p>SET</p>
<p>    instance_id = NULL,</p>
<p>    lease_expiry = NULL,</p>
<p>    status = 'Completed',</p>
<p>    last_event_id = 'event-uuid-003'</p>
<p>WHERE (stream_id, perspective_name) = ('order-123', 'OrderSummaryPerspective')</p>
<p></code></pre></p>

<strong>Reclaim</strong> (on lease expiry):
<pre><code class="language-sql">-- Worker B reclaims expired lease (5 minutes passed)
<p>UPDATE wh_perspective_checkpoints</p>
<p>SET</p>
<p>    instance_id = 'worker-b-uuid',</p>
<p>    service_name = 'OrderService',</p>
<p>    lease_expiry = NOW() + INTERVAL '5 minutes',</p>
<p>    status = 'Processing'</p>
<p>WHERE (stream_id, perspective_name) = ('order-123', 'OrderSummaryPerspective')</p>
<p>  AND lease_expiry < NOW()  -- Lease expired</p>
<p></code></pre></p>

<strong>Benefits</strong>:
<ul><li>✅ <strong>Fault Tolerance</strong>: If worker crashes, lease expires and work is reclaimed</li>
<li>✅ <strong>Scalability</strong>: Multiple workers process different checkpoints simultaneously</li>
<li>✅ <strong>No Conflicts</strong>: <code>FOR UPDATE SKIP LOCKED</code> prevents duplicate processing</li>
<li>✅ <strong>Observability</strong>: <code>instance_id</code> tracks which worker is processing</li>
</ul>
<hr>

<h2>Configuration</h2>

<strong>PerspectiveWorkerOptions.cs</strong>:
<pre><code class="language-csharp">public class PerspectiveWorkerOptions {
<p>  /// <summary></p>
<p>  /// Milliseconds to wait between polling for perspective checkpoint work.</p>
<p>  /// Default: 1000 (1 second)</p>
<p>  /// </summary></p>
<p>  public int PollingIntervalMilliseconds { get; set; } = 1000;</p>

<p>  /// <summary></p>
<p>  /// Lease duration in seconds.</p>
<p>  /// Perspective checkpoints claimed will be locked for this duration.</p>
<p>  /// Default: 300 (5 minutes)</p>
<p>  /// </summary></p>
<p>  public int LeaseSeconds { get; set; } = 300;</p>

<p>  /// <summary></p>
<p>  /// Stale instance threshold in seconds.</p>
<p>  /// Instances that haven't sent a heartbeat for this duration will be removed.</p>
<p>  /// Default: 600 (10 minutes)</p>
<p>  /// </summary></p>
<p>  public int StaleThresholdSeconds { get; set; } = 600;</p>

<p>  /// <summary></p>
<p>  /// Keep completed checkpoints for debugging (default: false).</p>
<p>  /// When enabled, completed checkpoints are preserved instead of deleted.</p>
<p>  /// </summary></p>
<p>  public bool DebugMode { get; set; } = false;</p>

<p>  /// <summary></p>
<p>  /// Number of partitions for work distribution.</p>
<p>  /// Default: 10000</p>
<p>  /// </summary></p>
<p>  public int PartitionCount { get; set; } = 10_000;</p>

<p>  /// <summary></p>
<p>  /// Number of consecutive empty work polls required to trigger OnWorkProcessingIdle callback.</p>
<p>  /// Default: 2</p>
<p>  /// </summary></p>
<p>  public int IdleThresholdPolls { get; set; } = 2;</p>

<p>  /// <summary></p>
<p>  /// Number of events to process in a single batch before saving model + checkpoint.</p>
<p>  /// Higher values = fewer database writes but longer transactions.</p>
<p>  /// Lower values = more frequent saves but higher DB overhead.</p>
<p>  /// Default: 100</p>
<p>  /// </summary></p>
<p>  public int PerspectiveBatchSize { get; set; } = 100;</p>
<p>}</p>
<p></code></pre></p>

<strong>Configuration Example</strong>:
<pre><code class="language-csharp">// Program.cs
<p>builder.Services.Configure<PerspectiveWorkerOptions>(options => {</p>
<p>  options.PollingIntervalMilliseconds = 500;  // Poll every 500ms (more responsive)</p>
<p>  options.LeaseSeconds = 600;  // 10-minute leases (longer processing time)</p>
<p>  options.DebugMode = true;  // Keep completed checkpoints for debugging</p>
<p>  options.PerspectiveBatchSize = 50;  // Smaller batches for faster commits</p>
<p>});</p>
<p></code></pre></p>

<strong>Tuning Guidelines</strong>:
<ul><li><strong>Low Latency</strong>: <code>PollingIntervalMs = 100</code> (poll every 100ms)</li>
<li><strong>High Throughput</strong>: <code>PerspectiveBatchSize = 1000</code> (larger batches)</li>
<li><strong>Fault Tolerance</strong>: <code>LeaseSeconds = 60</code> (shorter leases, faster recovery)</li>
<li><strong>Long Processing</strong>: <code>LeaseSeconds = 1800</code> (30-minute leases for slow perspectives)</li>
</ul>
<hr>

<h2>Completion Strategy Pattern</h2>

<p>The PerspectiveWorker uses a <strong>completion strategy pattern</strong> to control when and how perspective checkpoint results are reported to the Work Coordinator. This provides flexibility for different environments (production vs testing) and processing patterns.</p>

<h3>Strategy Interface</h3>

<strong>IPerspectiveCompletionStrategy</strong>:
<pre><code class="language-csharp">public interface IPerspectiveCompletionStrategy {
<p>  /// <summary></p>
<p>  /// Reports a perspective checkpoint completion.</p>
<p>  /// </summary></p>
<p>  Task ReportCompletionAsync(</p>
<p>    PerspectiveCheckpointCompletion completion,</p>
<p>    IWorkCoordinator coordinator,</p>
<p>    CancellationToken cancellationToken);</p>

<p>  /// <summary></p>
<p>  /// Reports a perspective checkpoint failure.</p>
<p>  /// </summary></p>
<p>  Task ReportFailureAsync(</p>
<p>    PerspectiveCheckpointFailure failure,</p>
<p>    IWorkCoordinator coordinator,</p>
<p>    CancellationToken cancellationToken);</p>

<p>  /// <summary></p>
<p>  /// Gets pending completions that have been collected but not yet reported.</p>
<p>  /// </summary></p>
<p>  PerspectiveCheckpointCompletion[] GetPendingCompletions();</p>

<p>  /// <summary></p>
<p>  /// Gets pending failures that have been collected but not yet reported.</p>
<p>  /// </summary></p>
<p>  PerspectiveCheckpointFailure[] GetPendingFailures();</p>

<p>  /// <summary></p>
<p>  /// Clears all pending completions and failures.</p>
<p>  /// </summary></p>
<p>  void ClearPending();</p>
<p>}</p>
<p></code></pre></p>

<h3>Built-In Strategies</h3>

<h4>BatchedCompletionStrategy (Default)</h4>

<strong>Purpose</strong>: Collects completions in memory and reports them on the <strong>next poll cycle</strong>.

<strong>How it works</strong>:
<pre><code class="language-mermaid">sequenceDiagram
<p>    participant PW as PerspectiveWorker</p>
<p>    participant S as BatchedStrategy</p>
<p>    participant WC as WorkCoordinator</p>

<p>    Note over PW,WC: Cycle N: Process perspectives</p>
<p>    PW->>S: ReportCompletionAsync(completion1)</p>
<p>    Note over S: Store in memory</p>
<p>    PW->>S: ReportCompletionAsync(completion2)</p>
<p>    Note over S: Store in memory</p>

<p>    Note over PW,WC: Cycle N+1: Report results</p>
<p>    PW->>S: GetPendingCompletions()</p>
<p>    S-->>PW: [completion1, completion2]</p>
<p>    PW->>WC: ProcessWorkBatchAsync(completions=[1,2])</p>
<p>    WC-->>WC: Persist to database</p>
<p>    PW->>S: ClearPending()</p>
<p></code></pre></p>

<strong>When to use</strong>:
<ul><li>✅ <strong>Production environments</strong> - Minimizes database round-trips</li>
<li>✅ <strong>High throughput</strong> - Batches multiple completions per poll</li>
<li>✅ <strong>Normal latency tolerance</strong> - Completions appear after next poll cycle</li>
</ul>
<strong>Example</strong>:
<pre><code class="language-csharp">// Program.cs (production)
<p>builder.Services.AddHostedService<PerspectiveWorker>();  // Uses BatchedCompletionStrategy by default</p>
<p></code></pre></p>

<strong>Trade-offs</strong>:
<ul><li><strong>PRO</strong>: Fewer database calls (better performance)</li>
<li><strong>CON</strong>: Results delayed until next poll cycle (~1 second with default polling interval)</li>
</ul>
<h4>InstantCompletionStrategy</h4>

<strong>Purpose</strong>: Reports completions <strong>immediately</strong> via out-of-band coordinator methods.

<strong>How it works</strong>:
<pre><code class="language-mermaid">sequenceDiagram
<p>    participant PW as PerspectiveWorker</p>
<p>    participant S as InstantStrategy</p>
<p>    participant WC as WorkCoordinator</p>

<p>    Note over PW,WC: Process perspective</p>
<p>    PW->>S: ReportCompletionAsync(completion)</p>
<p>    S->>WC: ReportPerspectiveCompletionAsync(completion)</p>
<p>    WC-->>WC: Persist immediately (out-of-band)</p>
<p>    Note over S: Nothing stored in memory</p>

<p>    Note over PW,WC: Next cycle</p>
<p>    PW->>S: GetPendingCompletions()</p>
<p>    S-->>PW: [] (empty - nothing pending)</p>
<p></code></pre></p>

<strong>When to use</strong>:
<ul><li>✅ <strong>Test environments</strong> - Immediate consistency for assertions</li>
<li>✅ <strong>Low latency requirements</strong> - Results visible immediately</li>
<li>✅ <strong>Interactive scenarios</strong> - User-facing queries need instant data</li>
</ul>
<strong>Example</strong>:
<pre><code class="language-csharp">// Test fixture or low-latency service
<p>var strategy = new InstantCompletionStrategy();</p>
<p>var worker = new PerspectiveWorker(</p>
<p>  instanceProvider,</p>
<p>  scopeFactory,</p>
<p>  Options.Create(new PerspectiveWorkerOptions { PollingIntervalMilliseconds = 100 }),</p>
<p>  completionStrategy: strategy,  // ← Inject instant strategy</p>
<p>  databaseReadinessCheck,</p>
<p>  logger</p>
<p>);</p>
<p></code></pre></p>

<strong>Trade-offs</strong>:
<ul><li><strong>PRO</strong>: Zero delay - completions visible immediately</li>
<li><strong>CON</strong>: More database calls (one per completion)</li>
</ul>
<h3>Out-of-Band Reporting Methods</h3>

<p>The <code>InstantCompletionStrategy</code> uses lightweight out-of-band methods on <code>IWorkCoordinator</code>:</p>

<strong>ReportPerspectiveCompletionAsync</strong>:
<pre><code class="language-csharp">// Lightweight method that ONLY updates perspective checkpoint
<p>// Does NOT affect heartbeats, work claiming, or other coordination</p>
<p>await coordinator.ReportPerspectiveCompletionAsync(</p>
<p>  new PerspectiveCheckpointCompletion {</p>
<p>    StreamId = streamId,</p>
<p>    PerspectiveName = "OrderSummaryPerspective",</p>
<p>    LastEventId = lastEventId,</p>
<p>    Status = PerspectiveProcessingStatus.Completed</p>
<p>  },</p>
<p>  cancellationToken</p>
<p>);</p>

<p>// Calls SQL function directly:</p>
<p>// SELECT complete_perspective_checkpoint_work(</p>
<p>//   stream_id, perspective_name, last_event_id, status, error</p>
<p>// );</p>
<p></code></pre></p>

<strong>ReportPerspectiveFailureAsync</strong>:
<pre><code class="language-csharp">await coordinator.ReportPerspectiveFailureAsync(
<p>  new PerspectiveCheckpointFailure {</p>
<p>    StreamId = streamId,</p>
<p>    PerspectiveName = "OrderSummaryPerspective",</p>
<p>    LastEventId = lastEventId,</p>
<p>    Status = PerspectiveProcessingStatus.Failed,</p>
<p>    Error = ex.Message</p>
<p>  },</p>
<p>  cancellationToken</p>
<p>);</p>
<p></code></pre></p>

<strong>Key Difference from <code>ProcessWorkBatchAsync</code></strong>:
<ul><li><strong>Out-of-band methods</strong>: ONLY update perspective checkpoint (fast, focused)</li>
<li><strong>ProcessWorkBatchAsync</strong>: Updates checkpoints + heartbeats + claims work + renews leases (comprehensive, heavier)</li>
</ul>
<h3>Choosing a Strategy</h3>

<p>| Factor | BatchedCompletionStrategy | InstantCompletionStrategy |</p>
<p>|--------|---------------------------|---------------------------|</p>
<p>| <strong>Database Load</strong> | ✅ Low (batched) | ⚠️ Higher (per-completion) |</p>
<p>| <strong>Latency</strong> | ⚠️ Delayed (~1 poll cycle) | ✅ Immediate |</p>
<p>| <strong>Best For</strong> | Production | Tests, low-latency |</p>
<p>| <strong>Throughput</strong> | ✅ High | ⚠️ Lower |</p>
<p>| <strong>Simplicity</strong> | ✅ Default behavior | Requires injection |</p>

<strong>General Guidance</strong>:
<ul><li><strong>Production</strong>: Use <code>BatchedCompletionStrategy</code> (default) for best performance</li>
<li><strong>Tests</strong>: Use <code>InstantCompletionStrategy</code> for immediate consistency</li>
<li><strong>Low-Latency Services</strong>: Use <code>InstantCompletionStrategy</code> if sub-second visibility is required</li>
</ul>
<h3>Custom Strategies</h3>

<p>You can implement custom strategies for advanced scenarios:</p>

<pre><code class="language-csharp">public sealed class UnitOfWorkCompletionStrategy : IPerspectiveCompletionStrategy {
<p>  private readonly List<PerspectiveCheckpointCompletion> _completions = [];</p>
<p>  private readonly List<PerspectiveCheckpointFailure> _failures = [];</p>
<p>  private readonly int _batchSize;</p>

<p>  public UnitOfWorkCompletionStrategy(int batchSize = 10) {</p>
<p>    _batchSize = batchSize;</p>
<p>  }</p>

<p>  public async Task ReportCompletionAsync(</p>
<p>    PerspectiveCheckpointCompletion completion,</p>
<p>    IWorkCoordinator coordinator,</p>
<p>    CancellationToken cancellationToken) {</p>
<p>    _completions.Add(completion);</p>

<p>    // Flush when batch size reached</p>
<p>    if (_completions.Count >= _batchSize) {</p>
<p>      await FlushAsync(coordinator, cancellationToken);</p>
<p>    }</p>
<p>  }</p>

<p>  // ... implement FlushAsync, GetPendingCompletions, etc.</p>
<p>}</p>
<p></code></pre></p>

<strong>Use Cases</strong>:
<ul><li><strong>Time-based batching</strong>: Flush after N seconds</li>
<li><strong>Unit-of-work batching</strong>: Flush after logical group of work</li>
<li><strong>Adaptive batching</strong>: Adjust batch size based on load</li>
<li><strong>Custom persistence</strong>: Write to alternative storage (Redis, etc.)</li>
</ul>
<hr>

<h2>Integration with Work Coordinator</h2>

<p>The PerspectiveWorker calls <code>IWorkCoordinator.ProcessWorkBatchAsync()</code> on every poll:</p>

<strong>PerspectiveWorker.cs:161-184</strong>:
<pre><code class="language-csharp">var workBatch = await workCoordinator.ProcessWorkBatchAsync(
<p>  _instanceProvider.InstanceId,</p>
<p>  _instanceProvider.ServiceName,</p>
<p>  _instanceProvider.HostName,</p>
<p>  _instanceProvider.ProcessId,</p>
<p>  metadata: _options.InstanceMetadata,</p>
<p>  outboxCompletions: [],</p>
<p>  outboxFailures: [],</p>
<p>  inboxCompletions: [],</p>
<p>  inboxFailures: [],</p>
<p>  receptorCompletions: [],</p>
<p>  receptorFailures: [],</p>
<p>  perspectiveCompletions: perspectiveCompletions,  // ← Previous results</p>
<p>  perspectiveFailures: perspectiveFailures,        // ← Previous errors</p>
<p>  newOutboxMessages: [],</p>
<p>  newInboxMessages: [],</p>
<p>  renewOutboxLeaseIds: [],</p>
<p>  renewInboxLeaseIds: [],</p>
<p>  flags: _options.DebugMode ? WorkBatchFlags.DebugMode : WorkBatchFlags.None,</p>
<p>  partitionCount: _options.PartitionCount,</p>
<p>  leaseSeconds: _options.LeaseSeconds,</p>
<p>  staleThresholdSeconds: _options.StaleThresholdSeconds,</p>
<p>  cancellationToken: cancellationToken</p>
<p>);</p>
<p></code></pre></p>

<strong>What Happens</strong>:
<ul><li><strong>Report Results</strong>: Perspective completions/failures from previous poll</li>
<li><strong>Heartbeat</strong>: Update instance heartbeat (alive signal)</li>
<li><strong>Claim Work</strong>: Get new perspective checkpoints to process</li>
<li><strong>Return Batch</strong>: Work Coordinator returns <code>PerspectiveWork[]</code></li>
</ul>
<strong>Atomic Operations</strong>:
<ul><li>All operations happen in a <strong>single database transaction</strong></li>
<li>Completions are persisted <strong>atomically</strong> with new work claims</li>
<li>Prevents data loss even if worker crashes mid-poll</li>
</ul>
<p>See <a href="../messaging/work-coordinator.md">Work Coordinator</a> for full details on atomic batch processing.</p>

<hr>

<h2>Observability</h2>

<h3>Metrics</h3>

<strong>PerspectiveWorker.cs exposes</strong>:
<pre><code class="language-csharp">public int ConsecutiveDatabaseNotReadyChecks { get; }  // Database availability tracking
<p>public int ConsecutiveEmptyPolls { get; }              // Work availability tracking</p>
<p>public bool IsIdle { get; }                            // Worker state</p>
<p></code></pre></p>

<strong>Work Coordinator provides</strong>:
<pre><code class="language-csharp">workBatch.PerspectiveWork.Count  // Number of checkpoints claimed
<p>perspectiveCompletions.Length    // Number of checkpoints completed</p>
<p>perspectiveFailures.Length       // Number of checkpoints failed</p>
<p></code></pre></p>

<strong>Example Logging</strong>:
<pre><code class="language-csharp">_logger.LogInformation(
<p>  "Perspective batch: Claimed={Claimed}, completed={Completed}, failed={Failed}",</p>
<p>  workBatch.PerspectiveWork.Count,</p>
<p>  perspectiveCompletions.Length,</p>
<p>  perspectiveFailures.Length</p>
<p>);</p>
<p></code></pre></p>

<h3>Events</h3>

<strong>OnWorkProcessingStarted</strong>:
<ul><li>Fired when work appears after idle state</li>
<li>Indicates perspective processing has begun</li>
</ul>
<strong>OnWorkProcessingIdle</strong>:
<ul><li>Fired after N consecutive empty polls (default 2)</li>
<li>Indicates all checkpoints are caught up</li>
<li>Useful for integration tests (wait for idle before asserting)</li>
</ul>
<strong>Example Usage</strong>:
<pre><code class="language-csharp">var worker = serviceProvider.GetRequiredService<PerspectiveWorker>();

<p>worker.OnWorkProcessingIdle += () => {</p>
<p>  Console.WriteLine("All perspective checkpoints processed!");</p>
<p>};</p>
<p></code></pre></p>

<h3>Database Queries</h3>

<strong>Check checkpoint status</strong>:
<pre><code class="language-sql">SELECT
<p>  perspective_name,</p>
<p>  COUNT(*) FILTER (WHERE status = 'Pending') AS pending,</p>
<p>  COUNT(*) FILTER (WHERE status = 'Processing') AS processing,</p>
<p>  COUNT(*) FILTER (WHERE status = 'Completed') AS completed,</p>
<p>  COUNT(*) FILTER (WHERE status = 'Failed') AS failed</p>
<p>FROM wh_perspective_checkpoints</p>
<p>GROUP BY perspective_name;</p>
<p></code></pre></p>

<strong>Find failed checkpoints</strong>:
<pre><code class="language-sql">SELECT
<p>  stream_id,</p>
<p>  perspective_name,</p>
<p>  error,</p>
<p>  updated_at</p>
<p>FROM wh_perspective_checkpoints</p>
<p>WHERE status = 'Failed'</p>
<p>ORDER BY updated_at DESC;</p>
<p></code></pre></p>

<strong>Check worker health</strong>:
<pre><code class="language-sql">SELECT
<p>  instance_id,</p>
<p>  service_name,</p>
<p>  last_heartbeat,</p>
<p>  NOW() - last_heartbeat AS time_since_heartbeat</p>
<p>FROM wh_service_instances</p>
<p>WHERE service_name = 'PerspectiveWorker'</p>
<p>ORDER BY last_heartbeat DESC;</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO ✅</h3>

<ul><li>✅ <strong>Start worker immediately</strong> - Process pending checkpoints on startup</li>
<li>✅ <strong>Check database readiness</strong> - Coordinate with <code>IDatabaseReadinessCheck</code></li>
<li>✅ <strong>Track errors</strong> - Persist error messages for debugging</li>
<li>✅ <strong>Monitor failed checkpoints</strong> - Alert on <code>status='Failed'</code> count</li>
<li>✅ <strong>Use appropriate lease duration</strong> - Balance fault tolerance vs processing time</li>
<li>✅ <strong>Configure batch size</strong> - Tune <code>PerspectiveBatchSize</code> for your workload</li>
<li>✅ <strong>Log poll results</strong> - Track claimed/completed/failed counts</li>
<li>✅ <strong>Use DebugMode</strong> - Enable for troubleshooting in non-production</li>
</ul>
<h3>DON'T ❌</h3>

<ul><li>❌ Skip database readiness checks (worker will fail on startup)</li>
<li>❌ Set lease duration too short (thrashing, duplicate work)</li>
<li>❌ Set lease duration too long (slow recovery from crashes)</li>
<li>❌ Ignore failed checkpoints (silent data loss)</li>
<li>❌ Skip monitoring (blind to failures)</li>
<li>❌ Process checkpoints outside worker (breaks coordination)</li>
<li>❌ Manually modify checkpoint records (breaks consistency)</li>
</ul>
<hr>

<h2>Troubleshooting</h2>

<h3>Problem: Checkpoints Not Processing</h3>

<strong>Symptoms</strong>: <code>status='Pending'</code> checkpoints remain unprocessed.

<strong>Causes</strong>:
<ul><li>PerspectiveWorker not running</li>
<li>Database not ready (<code>IDatabaseReadinessCheck.IsReadyAsync() = false</code>)</li>
<li><code>IPerspectiveRunnerRegistry</code> not registered</li>
<li>No <code>IPerspectiveRunner</code> found for perspective name</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-csharp">// 1. Ensure worker is registered
<p>builder.Services.AddHostedService<PerspectiveWorker>();</p>

<p>// 2. Ensure database is ready</p>
<p>builder.Services.AddSingleton<IDatabaseReadinessCheck, PostgresDatabaseReadinessCheck>();</p>

<p>// 3. Ensure perspective runners are registered</p>
<p>builder.Services.AddPerspectiveRunners();  // Generated by source generator</p>

<p>// 4. Check logs for missing runners</p>
<p>// "No IPerspectiveRunner found for perspective {PerspectiveName}"</p>
<p></code></pre></p>

<h3>Problem: Duplicate Processing</h3>

<strong>Symptoms</strong>: Same checkpoint processed multiple times.

<strong>Causes</strong>:
<ul><li>Multiple workers without lease coordination</li>
<li>Lease duration too short</li>
<li>Clock skew between database and application servers</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-csharp">// Increase lease duration
<p>builder.Services.Configure<PerspectiveWorkerOptions>(options => {</p>
<p>  options.LeaseSeconds = 600;  // 10 minutes (longer)</p>
<p>});</p>

<p>// Ensure <code>FOR UPDATE SKIP LOCKED</code> is used (built into migration 005)</p>
<p>// Check database server time vs application server time</p>
<p>SELECT NOW();  -- Database time</p>
<p>Console.WriteLine(DateTimeOffset.UtcNow);  -- Application time</p>
<p></code></pre></p>

<h3>Problem: Failed Checkpoints Accumulating</h3>

<strong>Symptoms</strong>: Many checkpoints with <code>status='Failed'</code>.

<strong>Causes</strong>:
<ul><li>Perspective runner throwing exceptions</li>
<li>Invalid data in events</li>
<li>Database connection issues</li>
<li>Timeout during processing</li>
</ul>
<strong>Solution</strong>:
<pre><code class="language-sql">-- Find most common errors
<p>SELECT</p>
<p>  error,</p>
<p>  COUNT(*) AS count</p>
<p>FROM wh_perspective_checkpoints</p>
<p>WHERE status = 'Failed'</p>
<p>GROUP BY error</p>
<p>ORDER BY count DESC;</p>

<p>-- Fix underlying issue (e.g., null reference, invalid data)</p>
<p>-- Clear failed checkpoints to retry</p>
<p>UPDATE wh_perspective_checkpoints</p>
<p>SET status = 'Pending', error = NULL</p>
<p>WHERE status = 'Failed';</p>
<p></code></pre></p>

<h3>Problem: Only One Service Processing Work (Multi-Service Setup)</h3>

<p>:::new{type="fix" version="v0.1.1"}</p>
<strong>FIXED IN v0.1.1</strong>: This issue was resolved by ensuring all SQL migrations properly qualify <code>wh_active_streams</code> table references with the <code>__SCHEMA__</code> placeholder. Each service now has schema-qualified <code>wh_active_streams</code> tables (e.g., <code>inventory.wh_active_streams</code>, <code>bff.wh_active_streams</code>), allowing multiple services to independently process the same streams, matching Azure Service Bus behavior where each service has its own subscription.

<strong>Historical Context</strong>: Earlier versions had unqualified <code>wh_active_streams</code> references causing a "last writer wins" race condition where both services would update a shared table, leaving only the last writer with stream ownership.

<strong>Affected Migrations</strong>: 008_1 (table creation), 020 (store_outbox_messages), 021 (store_inbox_messages), 023 (cleanup_completed_streams), 024-026 (claim_orphaned_*), 027 (claim_orphaned_perspective_events).
<p>:::</p>

<strong>Symptoms</strong>: In a multi-service setup (e.g., InventoryWorker and BFF), only one service processes perspective work while the other remains idle. Perspective tables for the idle service remain empty.

<strong>Causes</strong>:
<ul><li><strong>Shared instance ID</strong> - Multiple services using the same <code>IServiceInstanceProvider.InstanceId</code></li>
<li>Work coordinator treats multiple services as a single instance</li>
<li>Only one service claims and processes work</li>
</ul>
<strong>Diagnostic Steps</strong>:
<pre><code class="language-csharp">// Enable diagnostic logging to check instance IDs
<p>builder.Logging.SetMinimumLevel(LogLevel.Debug);</p>

<p>// Check logs for instance ID collision</p>
<p>// Look for: "Perspective worker starting: Instance {InstanceId} ({ServiceName}@{HostName})"</p>
<p>// If multiple services show the same InstanceId, you have a collision</p>
<p></code></pre></p>

<strong>Solution</strong>:
<pre><code class="language-csharp">// WRONG: Shared instance ID (causes collision)
<p>private readonly Guid _sharedInstanceId = Guid.CreateVersion7();</p>
<p>builder.Services.AddSingleton<IServiceInstanceProvider>(sp =></p>
<p>  new TestServiceInstanceProvider(_sharedInstanceId, "InventoryWorker"));  // Same ID for both!</p>

<p>// CORRECT: Unique instance IDs per service</p>
<p>private readonly Guid _inventoryInstanceId = Guid.CreateVersion7();</p>
<p>private readonly Guid _bffInstanceId = Guid.CreateVersion7();</p>

<p>// InventoryWorker host</p>
<p>inventoryBuilder.Services.AddSingleton<IServiceInstanceProvider>(sp =></p>
<p>  new TestServiceInstanceProvider(_inventoryInstanceId, "InventoryWorker"));</p>

<p>// BFF host</p>
<p>bffBuilder.Services.AddSingleton<IServiceInstanceProvider>(sp =></p>
<p>  new TestServiceInstanceProvider(_bffInstanceId, "BFF.API"));</p>
<p></code></pre></p>

<strong>Verification</strong>:
<pre><code class="language-sql">-- Check that both services are active
<p>SELECT</p>
<p>  instance_id,</p>
<p>  service_name,</p>
<p>  last_heartbeat</p>
<p>FROM wh_service_instances</p>
<p>WHERE service_name IN ('InventoryWorker', 'BFF.API')</p>
<p>ORDER BY service_name;</p>

<p>-- Should show TWO distinct instance_id values (one per service)</p>
<p></code></pre></p>

<strong>Related</strong>: This issue commonly occurs in test fixtures where multiple services share a single test host. In production, each service typically runs in its own process with a unique instance ID.

<hr>

<h2>Further Reading</h2>

<strong>Related Workers</strong>:
<ul><li><a href="execution-lifecycle.md">Execution Lifecycle</a> - Startup/shutdown coordination</li>
<li><a href="database-readiness.md">Database Readiness</a> - Database dependency checks</li>
</ul>
<strong>Core Concepts</strong>:
<ul><li><a href="../components/perspectives.md">Perspectives</a> - What perspectives are</li>
<li><a href="../source-generators/perspective-discovery.md">Perspective Discovery</a> - Compile-time discovery</li>
</ul>
<strong>Messaging</strong>:
<ul><li><a href="../messaging/work-coordinator.md">Work Coordinator</a> - Atomic batch processing</li>
<li><a href="../messaging/outbox-pattern.md">Outbox Pattern</a> - Reliable event publishing</li>
</ul>
<strong>Data Access</strong>:
<ul><li><a href="../data/event-store.md">Event Store</a> - Event sourcing and replay</li>
<li><a href="../data/perspectives-storage.md">Perspectives Storage</a> - Read model schema design</li>
</ul>
<strong>Extensibility</strong>:
<ul><li><a href="../extensibility/custom-perspectives.md">Custom Perspectives</a> - Advanced perspective patterns</li>
</ul>
<hr>

<em>Version 1.0.0 - Foundation Release | Last Updated: 2025-12-21</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

</section>
</section>

<section id="guides"><h2>Guides</h2>
<section id="migrate-from-marten-wolverine"><h3>Migrate From Marten Wolverine</h3>
<article id="migrate-from-marten-wolverine-01-concept-mapping" class="doc-section">
  <h2>01 concept mapping</h2>
  <p class="doc-path"><code>migrate-from-marten-wolverine/01-concept-mapping</code></p>
  <div class="doc-content">
<h1>Migrate from Marten/Wolverine: Concept Mapping</h1>

<p>This document maps core concepts between Marten/Wolverine and Whizbang.</p>

<h2>Core Concept Translations</h2>

<p>| Marten/Wolverine | Whizbang | Key Differences |</p>
<p>|------------------|----------|-----------------|</p>
<p>| <code>IDocumentStore</code> | <code>IEventStore</code> | Stream-based, simple <code>AppendAsync(streamId, message, ct)</code> |</p>
<p>| <code>IHandle<TMessage></code> | <code>IReceptor<TMessage, TResult></code> | Returns typed result, source-generator discovered |</p>
<p>| <code>IHandle<TMessage></code> (sync logic) | <code>ISyncReceptor<TMessage, TResult></code> | For pure computation without async operations |</p>
<p>| <code>[WolverineHandler]</code> | <em>No attribute needed</em> | Source generator discovers <code>IReceptor</code>/<code>ISyncReceptor</code> |</p>
<p>| <code>SingleStreamProjection<T></code> | <code>IPerspectiveFor<TModel, TEvent...></code> | Pure function <code>Apply()</code>, multiple event types via variadic interface |</p>
<p>| <code>MultiStreamProjection<T></code> | <code>IGlobalPerspectiveFor<TModel></code> | Global perspectives for cross-stream aggregation |</p>
<p>| <code>UseDurableOutbox()</code> | Built-in outbox via <code>IWorkCoordinator</code> | Database-backed with configurable strategies |</p>
<p>| <code>IMessageBus.PublishAsync()</code> | <code>IDispatcher.PublishAsync()</code> | Fire-and-forget event broadcasting |</p>
<p>| <code>IMessageBus.SendAsync()</code> | <code>IDispatcher.SendAsync()</code> | Command dispatch with delivery receipt |</p>
<p>| <code>IMessageBus.InvokeAsync<T>()</code> | <code>IDispatcher.LocalInvokeAsync<T>()</code> | In-process RPC with typed result |</p>
<p>| <code>Guid.NewGuid()</code> / <code>Guid.CreateVersion7()</code> | <code>OrderId.New()</code> / <code>TrackedGuid.NewMedo()</code> | Strongly-typed IDs with UUIDv7 via Medo, no DI needed |</p>

<h2>Handler Migration</h2>

<h3>Wolverine Handler (Before)</h3>
<pre><code class="language-csharp">public class OrderHandler {
<p>  [WolverineHandler]</p>
<p>  public async Task Handle(CreateOrderCommand command, IDocumentSession session) {</p>
<p>    var order = new Order(command.CustomerId, command.Items);</p>
<p>    session.Store(order);</p>
<p>    await session.SaveChangesAsync();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Whizbang Receptor (After - Preferred: Tuple Return)</h3>
<pre><code class="language-csharp">public class CreateOrderReceptor
<p>    : ISyncReceptor<CreateOrderCommand, (OrderCreatedResult, OrderCreated)> {</p>

<p>  public (OrderCreatedResult, OrderCreated) Receive(CreateOrderCommand command) {</p>
<p>    var orderId = OrderId.New();  // UUIDv7 with sub-millisecond precision</p>
<p>    var @event = new OrderCreated(orderId, command.CustomerId, command.Items);</p>

<p>    // Return tuple - OrderCreated is AUTO-PUBLISHED to perspectives + outbox</p>
<p>    return (new OrderCreatedResult(orderId), @event);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<p>The framework automatically extracts and publishes any <code>IEvent</code> instances from the return value. This pattern:</p>
<ul><li><strong>Eliminates dispatcher dependency</strong> when only publishing events</li>
<li><strong>Makes side effects explicit</strong> in the return type</li>
<li><strong>Enables easier testing</strong> (assert return values, no mock setup needed)</li>
</ul>
<h2>Projection Migration</h2>

<h3>Marten Projection (Before)</h3>
<pre><code class="language-csharp">public class OrderProjection : SingleStreamProjection<OrderView> {
<p>  public OrderView Create(OrderCreated @event) {</p>
<p>    return new OrderView {</p>
<p>      Id = @event.OrderId,</p>
<p>      CustomerId = @event.CustomerId,</p>
<p>      Status = OrderStatus.Created</p>
<p>    };</p>
<p>  }</p>

<p>  public void Apply(OrderShipped @event, OrderView view) {</p>
<p>    view.Status = OrderStatus.Shipped;</p>
<p>    view.ShippedAt = @event.ShippedAt;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Whizbang Perspective (After)</h3>
<pre><code class="language-csharp">public class OrderPerspective : IPerspectiveFor<OrderView, OrderCreated, OrderShipped> {
<p>  // Creation event - nullable parameter, handles initial creation</p>
<p>  public OrderView Apply(OrderView? current, OrderCreated @event) {</p>
<p>    return new OrderView {</p>
<p>      Id = @event.OrderId,</p>
<p>      CustomerId = @event.CustomerId,</p>
<p>      Status = OrderStatus.Created</p>
<p>    };</p>
<p>  }</p>

<p>  // Update event - [MustExist] ensures model exists, non-nullable parameter</p>
<p>  [MustExist]</p>
<p>  public OrderView Apply(OrderView current, OrderShipped @event) {</p>
<p>    return current with {</p>
<p>      Status = OrderStatus.Shipped,</p>
<p>      ShippedAt = @event.ShippedAt</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<p>The <code>[MustExist]</code> attribute tells the generator to produce a null check before calling Apply:</p>
<pre><code class="language-csharp">// Generated code
<p>case OrderShipped typedEvent:</p>
<p>  if (currentModel == null)</p>
<p>    throw new InvalidOperationException(</p>
<p>      "OrderView must exist when applying OrderShipped in OrderPerspective");</p>
<p>  return perspective.Apply(currentModel, typedEvent);</p>
<p></code></pre></p>

<h2>Key Differences</h2>

<h3>1. Discovery Mechanism</h3>
<ul><li><strong>Wolverine</strong>: Uses attributes and runtime reflection</li>
<li><strong>Whizbang</strong>: Uses source generators for compile-time discovery (AOT-compatible)</li>
</ul>
<h3>2. Return Types</h3>
<ul><li><strong>Wolverine</strong>: Handlers return <code>void</code> or <code>Task</code></li>
<li><strong>Whizbang</strong>: Receptors return typed results via <code>IReceptor<TMessage, TResult></code></li>
</ul>
<h3>3. Projection Model</h3>
<ul><li><strong>Marten</strong>: Mutable projections with <code>Apply(event, view)</code> pattern</li>
<li><strong>Whizbang</strong>: Immutable perspectives with pure <code>Apply(current, event) => new</code> pattern</li>
</ul>
<h3>4. Event Store</h3>
<ul><li><strong>Marten</strong>: Document-centric with event sourcing bolted on</li>
<li><strong>Whizbang</strong>: Stream-first design with explicit stream IDs</li>
</ul>
<h3>5. Message Context</h3>
<ul><li><strong>Wolverine</strong>: <code>MessageContext</code> for accessing message metadata</li>
<li><strong>Whizbang</strong>: <code>MessageEnvelope<T></code> with <code>Hops</code> for distributed tracing (auto-created by Dispatcher)</li>
</ul>
<h2>Dispatcher Patterns</h2>

<p>Whizbang provides three distinct dispatch patterns via <code>IDispatcher</code>:</p>

<h3>PublishAsync - Fire-and-Forget</h3>
<pre><code class="language-csharp">// Broadcast event to all interested subscribers
<p>await _dispatcher.PublishAsync(new OrderCreated(orderId, customerId));</p>
<p></code></pre></p>

<h3>SendAsync - Command Dispatch</h3>
<pre><code class="language-csharp">// Send command to single handler, await delivery acknowledgment
<p>await _dispatcher.SendAsync(new ProcessPaymentCommand(orderId, amount));</p>
<p></code></pre></p>

<h3>LocalInvokeAsync - In-Process RPC</h3>
<pre><code class="language-csharp">// Invoke handler in-process and get typed result
<p>var result = await _dispatcher.LocalInvokeAsync<ProcessPaymentCommand, PaymentResult>(</p>
<p>    new ProcessPaymentCommand(orderId, amount));</p>
<p></code></pre></p>

<h2>Common ID Generation Migration Scenarios</h2>

<p>This section documents migration patterns for ID generation. Each scenario has a unique ID for traceability to automated migration tests.</p>

<hr>

<h3>Scenario G01: Guid.NewGuid() to Strongly-Typed ID</h3>

<strong>Marten/Wolverine Pattern (Before):</strong>

<pre><code class="language-csharp">public class OrderHandler : IHandle<CreateOrderCommand> {
<p>  private readonly IDocumentSession _session;</p>

<p>  public async Task Handle(CreateOrderCommand command, CancellationToken ct) {</p>
<p>    var orderId = Guid.NewGuid();</p>

<p>    _session.Events.StartStream<Order>(</p>
<p>        orderId,</p>
<p>        new OrderCreated(orderId, command.CustomerId, command.Items)</p>
<p>    );</p>

<p>    await _session.SaveChangesAsync(ct);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>

<pre><code class="language-csharp">public class CreateOrderReceptor
<p>    : ISyncReceptor<CreateOrderCommand, (OrderCreatedResult, OrderCreated)> {</p>

<p>    public (OrderCreatedResult, OrderCreated) Receive(CreateOrderCommand command) {</p>
<p>        // Strongly-typed ID with UUIDv7 generation</p>
<p>        var orderId = OrderId.New();</p>

<p>        return (</p>
<p>            new OrderCreatedResult(orderId),</p>
<p>            new OrderCreated(orderId, command.CustomerId, command.Items)</p>
<p>        );</p>
<p>    }</p>
<p>}</p>

<p>// Define strongly-typed ID using Vogen</p>
<p>[ValueObject<Guid>]</p>
<p>public partial struct OrderId {</p>
<p>    public static OrderId New() => From(TrackedGuid.NewMedo());</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>

<ul><li><code>Guid.NewGuid()</code> becomes <code>OrderId.New()</code> (strongly-typed)</li>
<li>Vogen generates compile-time value object with equality, serialization</li>
<li><code>TrackedGuid.NewMedo()</code> provides UUIDv7 with sub-millisecond precision</li>
<li>Type system prevents mixing up IDs (e.g., <code>OrderId</code> vs <code>CustomerId</code>)</li>
</ul>
<strong>CLI Transformation:</strong>

<ul><li>[x] Supported by <code>whizbang migrate apply</code></li>
<li>Suggests creating strongly-typed ID wrappers</li>
</ul>
<strong>Test Coverage:</strong>

<ul><li><code>TransformAsync_G01_GuidNewGuid_TransformsToIdProviderNewGuid</code></li>
</ul>
<hr>

<h3>Scenario G02: CombGuid to TrackedGuid.NewMedo()</h3>

<strong>Marten/Wolverine Pattern (Before):</strong>

<pre><code class="language-csharp">using Marten.Schema.Identity;

<p>public class StreamIdGenerator {</p>
<p>  public Guid GenerateStreamId() {</p>
<p>    // CombGuid generates sequential GUIDs for better database index performance</p>
<p>    return CombGuidIdGeneration.NewGuid();</p>
<p>  }</p>
<p>}</p>

<p>public class OrderHandler : IHandle<CreateOrderCommand> {</p>
<p>  private readonly StreamIdGenerator _idGenerator;</p>

<p>  public async Task Handle(CreateOrderCommand command, CancellationToken ct) {</p>
<p>    var orderId = _idGenerator.GenerateStreamId();</p>
<p>    // ...</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>

<pre><code class="language-csharp">public class CreateOrderReceptor
<p>    : ISyncReceptor<CreateOrderCommand, (OrderCreatedResult, OrderCreated)> {</p>

<p>    public (OrderCreatedResult, OrderCreated) Receive(CreateOrderCommand command) {</p>
<p>        // TrackedGuid.NewMedo() generates time-ordered UUIDv7</p>
<p>        // Equivalent to CombGuid but standardized and more precise</p>
<p>        var orderId = OrderId.New(); // Uses TrackedGuid.NewMedo() internally</p>

<p>        return (</p>
<p>            new OrderCreatedResult(orderId),</p>
<p>            new OrderCreated(orderId, command.CustomerId, command.Items)</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>

<ul><li><code>CombGuidIdGeneration.NewGuid()</code> → <code>TrackedGuid.NewMedo()</code></li>
<li>MEDO (monotonic, epoch-based, distributed, ordered) algorithm</li>
<li>Better precision than CombGuid (sub-millisecond vs millisecond)</li>
<li>Standardized UUIDv7 format per RFC 9562</li>
<li>No external dependency (built into Whizbang.Core)</li>
</ul>
<strong>CLI Transformation:</strong>

<ul><li>[x] Supported by <code>whizbang migrate apply</code></li>
<li>Direct replacement: <code>CombGuidIdGeneration.NewGuid()</code> → <code>TrackedGuid.NewMedo()</code></li>
</ul>
<strong>Test Coverage:</strong>

<ul><li><code>TransformAsync_G02_CombGuidIdGeneration_TransformsToTrackedGuid</code></li>
</ul>
<hr>

<h3>Scenario G03: Default StreamId Check Pattern</h3>

<strong>Marten/Wolverine Pattern (Before):</strong>

<pre><code class="language-csharp">public class OrderHandler : IHandle<CreateOrderCommand> {
<p>  public async Task Handle(CreateOrderCommand command, CancellationToken ct) {</p>
<p>    var @event = new OrderCreated(/<em> ... </em>/);</p>

<p>    // Pattern: Check if StreamId is default (not set), then generate</p>
<p>    if (@event.StreamId == default) {</p>
<p>      @event = @event with { StreamId = Guid.NewGuid() };</p>
<p>    }</p>

<p>        _session.Events.StartStream<Order>(@event.StreamId, @event);</p>
<p>        await _session.SaveChangesAsync(ct);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>

<pre><code class="language-csharp">public class CreateOrderReceptor
<p>    : ISyncReceptor<CreateOrderCommand, (OrderCreatedResult, OrderCreated)> {</p>

<p>    public (OrderCreatedResult, OrderCreated) Receive(CreateOrderCommand command) {</p>
<p>        // Always generate ID upfront - never rely on default checks</p>
<p>        var orderId = OrderId.New();</p>

<p>        var @event = new OrderCreated(orderId, command.CustomerId, command.Items);</p>

<p>        return (new OrderCreatedResult(orderId), @event);</p>
<p>    }</p>
<p>}</p>

<p>// Event record with required OrderId - compiler prevents default values</p>
<p>public sealed record OrderCreated(</p>
<p>    OrderId OrderId,  // Required, non-nullable</p>
<p>    CustomerId CustomerId,</p>
<p>    IReadOnlyList<OrderItem> Items</p>
<p>) : IEvent;</p>
<p></code></pre></p>

<strong>Key Differences:</strong>

<ul><li>No <code>default</code> checks needed - generate ID at creation time</li>
<li>Strongly-typed IDs prevent accidental <code>default(Guid)</code> usage</li>
<li>Record with required constructor parameters enforces initialization</li>
<li>Compiler catches missing ID at compile time, not runtime</li>
</ul>
<strong>CLI Transformation:</strong>

<ul><li>[x] Supported by <code>whizbang migrate apply</code></li>
<li>Warning: "Remove default StreamId checks - generate IDs at creation"</li>
</ul>
<strong>Test Coverage:</strong>

<ul><li><code>TransformAsync_G03_DefaultStreamIdCheck_RemovedWithWarning</code></li>
</ul>
<hr>

<h3>Scenario G04: Collision Retry Pattern</h3>

<strong>Marten/Wolverine Pattern (Before):</strong>

<pre><code class="language-csharp">public class OrderHandler : IHandle<CreateOrderCommand> {
<p>  private const int MaxRetryAttempts = 5;</p>
<p>  private readonly IDocumentSession _session;</p>

<p>  public async Task Handle(CreateOrderCommand command, CancellationToken ct) {</p>
<p>    for (var attempt = 0; attempt < MaxRetryAttempts; attempt++) {</p>
<p>      try {</p>
<p>        var orderId = Guid.NewGuid();</p>

<p>        _session.Events.StartStream<Order>(</p>
<p>            orderId,</p>
<p>            new OrderCreated(orderId, command.CustomerId, command.Items)</p>
<p>        );</p>
<p>        await _session.SaveChangesAsync(ct);</p>
<p>        return; // Success</p>
<p>      } catch (Exception ex) when (ex.Message.Contains("duplicate key")) {</p>
<p>        if (attempt == MaxRetryAttempts - 1) throw;</p>
<p>        // Retry with new ID on collision</p>
<p>      }</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>

<pre><code class="language-csharp">public class CreateOrderReceptor
<p>    : ISyncReceptor<CreateOrderCommand, (OrderCreatedResult, OrderCreated)> {</p>

<p>    public (OrderCreatedResult, OrderCreated) Receive(CreateOrderCommand command) {</p>
<p>        // TrackedGuid.NewMedo() is virtually collision-free</p>
<p>        // - Time-based component ensures temporal ordering</p>
<p>        // - 62 bits of randomness per millisecond</p>
<p>        // - Collision probability: ~1 in 4.6 quintillion per millisecond</p>
<p>        var orderId = OrderId.New();</p>

<p>        return (</p>
<p>            new OrderCreatedResult(orderId),</p>
<p>            new OrderCreated(orderId, command.CustomerId, command.Items)</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>

<ul><li>No retry logic needed with <code>TrackedGuid.NewMedo()</code></li>
<li>UUIDv7 combines timestamp + random for practical collision immunity</li>
<li>Simpler, more maintainable code</li>
<li>If retries are still needed (external reasons), use Polly policies at infrastructure level</li>
</ul>
<strong>CLI Transformation:</strong>

<ul><li>[x] Supported by <code>whizbang migrate apply</code></li>
<li>Warning: "Consider if GUID collision retry is still needed with TrackedGuid"</li>
</ul>
<strong>Test Coverage:</strong>

<ul><li><code>TransformAsync_G04_CollisionRetry_SimplifiedWithWarning</code></li>
</ul>
<hr>

<h2>Scenario Coverage Matrix: ID Generation</h2>

<p>| Scenario | Pattern | CLI Support | Test |</p>
<p>|----------|---------|-------------|------|</p>
<p>| G01 | Guid.NewGuid() | ✅ Full | ✅ |</p>
<p>| G02 | CombGuidIdGeneration | ✅ Full | ✅ |</p>
<p>| G03 | Default StreamId Check | ⚠️ Warning | ✅ |</p>
<p>| G04 | Collision Retry | ⚠️ Warning | ✅ |</p>

<hr>

<h2>Automated Migration</h2>

<p>The <code>whizbang migrate</code> CLI can automatically transform most patterns:</p>

<pre><code class="language-bash"># Analyze what needs migration
<p>whizbang migrate analyze --project ./src/MyService</p>

<h1>Apply transformations</h1>
<p>whizbang migrate apply --project ./src/MyService --guided</p>
<p></code></pre></p>

<p>The tool handles:</p>
<ul><li>Handler to Receptor transformation</li>
<li>Projection to Perspective transformation</li>
<li><code>IDocumentStore</code> to <code>IEventStore</code> transformation</li>
<li>Session removal (<code>LightweightSession</code>, <code>QuerySession</code>)</li>
<li><code>SaveChangesAsync</code> removal (each <code>AppendAsync</code> is atomic)</li>
<li><code>Guid.NewGuid()</code> / <code>Guid.CreateVersion7()</code> to <code>IWhizbangIdProvider.NewGuid()</code> (adds constructor injection)</li>
<li><code>[MustExist]</code> suggestions for Apply methods with non-nullable model parameter</li>
<li>DI registration updates</li>
<li>Using directive changes</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="migrate-from-marten-wolverine-02-project-setup" class="doc-section">
  <h2>02 project setup</h2>
  <p class="doc-path"><code>migrate-from-marten-wolverine/02-project-setup</code></p>
  <div class="doc-content">
<h1>Migrate from Marten/Wolverine: Project Setup</h1>

<p>This guide covers NuGet package installation and project configuration for migrating to Whizbang.</p>

<h2>NuGet Packages</h2>

<h3>Core Packages</h3>

<p>Add the following packages to your project:</p>

<pre><code class="language-xml"><ItemGroup>
<p>  <!-- Core framework --></p>
<p>  <PackageReference Include="Whizbang.Core" Version="0.1.0" /></p>

<p>  <!-- Source generators (required) --></p>
<p>  <PackageReference Include="Whizbang.Generators" Version="0.1.0" /></p>

<p>  <!-- PostgreSQL event store --></p>
<p>  <PackageReference Include="Whizbang.Data.EFCore.Postgres" Version="0.1.0" /></p>
<p></ItemGroup></p>
<p></code></pre></p>

<h3>Transport Packages</h3>

<p>Choose one or both transport packages based on your deployment environment:</p>

<pre><code class="language-xml"><ItemGroup>
<p>  <!-- For RabbitMQ (local development) --></p>
<p>  <PackageReference Include="Whizbang.Transports.RabbitMQ" Version="0.1.0" /></p>

<p>  <!-- For Azure Service Bus (production) --></p>
<p>  <PackageReference Include="Whizbang.Transports.AzureServiceBus" Version="0.1.0" /></p>
<p></ItemGroup></p>
<p></code></pre></p>

<h3>Testing Packages</h3>

<pre><code class="language-xml"><ItemGroup>
<p>  <PackageReference Include="Whizbang.Testing" Version="0.1.0" /></p>
<p></ItemGroup></p>
<p></code></pre></p>

<h2>Project Configuration</h2>

<h3>Enable Source Generators</h3>

<p>Ensure your project has the following settings in the <code>.csproj</code> file:</p>

<pre><code class="language-xml"><PropertyGroup>
<p>  <TargetFramework>net10.0</TargetFramework></p>
<p>  <Nullable>enable</Nullable></p>
<p>  <ImplicitUsings>enable</ImplicitUsings></p>

<p>  <!-- Required for source generators --></p>
<p>  <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles></p>
<p></PropertyGroup></p>
<p></code></pre></p>

<h3>Global Usings</h3>

<p>Create or update <code>GlobalUsings.cs</code>:</p>

<pre><code class="language-csharp">global using Whizbang.Core;
<p>global using Whizbang.Core.Messaging;</p>
<p>global using Whizbang.Core.Perspectives;</p>
<p>global using Whizbang.Core.Receptors;</p>
<p></code></pre></p>

<h2>Service Registration</h2>

<h3>Basic Setup</h3>

<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);

<p>// Add Whizbang core services</p>
<p>builder.Services.AddWhizbang(options => {</p>
<p>    options.UsePostgresEventStore(</p>
<p>        builder.Configuration.GetConnectionString("EventStore")!);</p>
<p>});</p>

<p>// Transport configuration (see 06-transport-configuration.md for details)</p>
<p>builder.Services.AddWhizbangTransport(builder.Configuration);</p>

<p>var app = builder.Build();</p>
<p>app.UseWhizbang();</p>
<p>app.Run();</p>
<p></code></pre></p>

<h3>Parallel Installation with Marten/Wolverine</h3>

<p>During migration, you can run both frameworks simultaneously:</p>

<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);

<p>// Existing Marten/Wolverine (keep during migration)</p>
<p>builder.Services.AddMarten(options => {</p>
<p>    options.Connection(builder.Configuration.GetConnectionString("Marten")!);</p>
<p>});</p>
<p>builder.Host.UseWolverine();</p>

<p>// New Whizbang (add alongside)</p>
<p>builder.Services.AddWhizbang(options => {</p>
<p>    options.UsePostgresEventStore(</p>
<p>        builder.Configuration.GetConnectionString("EventStore")!);</p>
<p>    options.SchemaName = "whizbang"; // Separate schema during migration</p>
<p>});</p>
<p></code></pre></p>

<h3>Schema Isolation</h3>

<p>During migration, use separate database schemas to avoid conflicts:</p>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.UsePostgresEventStore(connectionString);</p>
<p>    options.SchemaName = "whizbang"; // Keeps data separate from Marten</p>
<p>});</p>
<p></code></pre></p>

<h2>Directory Structure</h2>

<p>Recommended project structure after migration:</p>

<pre><code class="language-">src/MyService/
<p>├── Commands/</p>
<p>│   └── CreateOrderCommand.cs</p>
<p>├── Events/</p>
<p>│   └── OrderCreated.cs</p>
<p>├── Receptors/</p>
<p>│   └── CreateOrderReceptor.cs</p>
<p>├── Perspectives/</p>
<p>│   └── OrderPerspective.cs</p>
<p>├── Program.cs</p>
<p>└── GlobalUsings.cs</p>
<p></code></pre></p>

<h2>Removing Marten/Wolverine</h2>

<p>Once migration is complete and validated:</p>

<ul><li>Remove package references:</li>
</ul><pre><code class="language-xml"><!-- Remove these -->
<p><PackageReference Include="Marten" Version="*" /></p>
<p><PackageReference Include="WolverineFx" Version="*" /></p>
<p></code></pre></p>

<ul><li>Remove obsolete service registrations:</li>
</ul><pre><code class="language-csharp">// Remove these lines
<p>builder.Services.AddMarten(...);</p>
<p>builder.Host.UseWolverine();</p>
<p></code></pre></p>

<ul><li>Delete migrated handler classes</li>
<li>Run <code>dotnet clean && dotnet build</code> to verify</li>
</ul>
<h2>Next Steps</h2>

<ul><li><a href="./03-handler-migration.md">Handler Migration</a> - Convert Wolverine handlers to Receptors</li>
<li><a href="./04-projection-migration.md">Projection Migration</a> - Convert Marten projections to Perspectives</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="migrate-from-marten-wolverine-03-handler-migration" class="doc-section">
  <h2>03 handler migration</h2>
  <p class="doc-path"><code>migrate-from-marten-wolverine/03-handler-migration</code></p>
  <div class="doc-content">
<h1>Migrate from Marten/Wolverine: Handler Migration</h1>

<p>This guide covers migrating Wolverine handlers to Whizbang Receptors.</p>

<h2>Overview</h2>

<p>| Wolverine | Whizbang |</p>
<p>|-----------|----------|</p>
<p>| <code>IHandle<TMessage></code> | <code>IReceptor<TMessage, TResult></code> |</p>
<p>| <code>[WolverineHandler]</code> attribute | No attribute needed |</p>
<p>| Returns <code>void</code>/<code>Task</code> | Returns typed <code>TResult</code> |</p>
<p>| Runtime discovery | Compile-time source generation |</p>

<h2>Basic Handler Migration</h2>

<h3>Before: Wolverine Handler</h3>

<pre><code class="language-csharp">public class CreateOrderHandler : IHandle<CreateOrderCommand> {
<p>  private readonly IDocumentSession _session;</p>

<p>  public CreateOrderHandler(IDocumentSession session) {</p>
<p>    _session = session;</p>
<p>  }</p>

<p>  public async Task Handle(CreateOrderCommand command) {</p>
<p>    var order = new Order {</p>
<p>      Id = Guid.NewGuid(),</p>
<p>      CustomerId = command.CustomerId,</p>
<p>      Items = command.Items,</p>
<p>      Status = OrderStatus.Created</p>
<p>    };</p>

<p>    _session.Store(order);</p>
<p>    await _session.SaveChangesAsync();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>After: Whizbang Receptor (Preferred: Tuple Return)</h3>

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrderCommand, (OrderCreatedResult, OrderCreated)> {
<p>  public ValueTask<(OrderCreatedResult, OrderCreated)> HandleAsync(</p>
<p>    CreateOrderCommand command,</p>
<p>    CancellationToken ct) {</p>

<p>    var orderId = Guid.NewGuid();</p>
<p>    var @event = new OrderCreated(orderId, command.CustomerId, command.Items);</p>

<p>    // Return tuple - OrderCreated is AUTO-PUBLISHED to perspectives + outbox</p>
<p>    return ValueTask.FromResult((new OrderCreatedResult(orderId), @event));</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<p>:::tip[Auto-Cascade]</p>
<p>When a receptor returns a tuple or array containing <code>IEvent</code> instances, the framework automatically extracts and publishes them. This is the <strong>preferred pattern</strong> - no <code>IDispatcher</code> dependency needed for simple event publishing.</p>
<p>:::</p>

<p>:::note[Sync vs Async Receptors]</p>
<p>Handlers can be migrated to either <strong>async</strong> (<code>IReceptor<T, TResult></code>) or <strong>sync</strong> (<code>ISyncReceptor<T, TResult></code>) receptors. Use sync receptors when your handler performs pure computation without any <code>await</code> operations. See <a href="#synchronous-handlers-no-async-operations">Synchronous Handlers</a> section below for when to use each pattern and matching examples.</p>
<p>:::</p>

<h2>Key Migration Steps</h2>

<h3>1. Change Interface</h3>

<p>Replace <code>IHandle<TMessage></code> with <code>IReceptor<TMessage, TResult></code>:</p>

<pre><code class="language-csharp">// Before
<p>public class MyHandler : IHandle<MyCommand></p>

<p>// After</p>
<p>public class MyReceptor : IReceptor<MyCommand, MyResult></p>
<p></code></pre></p>

<h3>2. Update Method Signature</h3>

<p>Change from <code>Handle</code> to <code>HandleAsync</code> with return type:</p>

<pre><code class="language-csharp">// Before
<p>public async Task Handle(MyCommand command)</p>

<p>// After</p>
<p>public async ValueTask<MyResult> HandleAsync(MyCommand command, CancellationToken ct)</p>
<p></code></pre></p>

<h3>3. Replace IDocumentSession with IEventStore</h3>

<pre><code class="language-csharp">// Before
<p>private readonly IDocumentSession _session;</p>
<p>_session.Store(entity);</p>
<p>await _session.SaveChangesAsync();</p>

<p>// After</p>
<p>private readonly IEventStore _eventStore;</p>
<p>await _eventStore.AppendAsync(streamId, @event, ct);</p>
<p></code></pre></p>

<h3>4. Replace IMessageBus with IDispatcher</h3>

<pre><code class="language-csharp">// Before
<p>await _messageBus.PublishAsync(@event);</p>
<p>await _messageBus.SendAsync(command);</p>

<p>// After</p>
<p>await _dispatcher.PublishAsync(@event, ct);</p>
<p>await _dispatcher.SendAsync(command, ct);</p>
<p></code></pre></p>

<h3>5. Create Result Type</h3>

<p>Define a result type for the receptor:</p>

<pre><code class="language-csharp">public record OrderCreatedResult(Guid OrderId);
<p></code></pre></p>

<h2>Handlers with Dependencies</h2>

<h3>Before: Cascading Messages</h3>

<pre><code class="language-csharp">public class OrderHandler : IHandle<CreateOrderCommand> {
<p>  public async Task Handle(CreateOrderCommand command, IMessageBus bus) {</p>
<p>    var orderId = Guid.NewGuid();</p>
<p>    // ... create order logic</p>

<p>    // Cascade to payment processing</p>
<p>    await bus.SendAsync(new ProcessPaymentCommand(orderId, command.Amount));</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>After: Tuple Return with Auto-Cascade (Preferred)</h3>

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrderCommand, (OrderCreatedResult, OrderCreated)> {
<p>  public ValueTask<(OrderCreatedResult, OrderCreated)> HandleAsync(</p>
<p>    CreateOrderCommand command,</p>
<p>    CancellationToken ct) {</p>

<p>    var orderId = Guid.NewGuid();</p>
<p>    var @event = new OrderCreated(orderId, command.CustomerId, command.Amount);</p>

<p>    // Return tuple - OrderCreated is AUTO-PUBLISHED</p>
<p>    // A separate receptor listening for OrderCreated handles payment processing</p>
<p>    return ValueTask.FromResult((new OrderCreatedResult(orderId), @event));</p>
<p>  }</p>
<p>}</p>

<p>// Separate receptor handles payment when OrderCreated is published</p>
<p>public class PaymentReceptor : IReceptor<OrderCreated, Unit> {</p>
<p>  private readonly IPaymentService _paymentService;</p>

<p>  public PaymentReceptor(IPaymentService paymentService) {</p>
<p>    _paymentService = paymentService;</p>
<p>  }</p>

<p>  public async ValueTask<Unit> HandleAsync(OrderCreated @event, CancellationToken ct) {</p>
<p>    await _paymentService.ProcessPaymentAsync(@event.OrderId, @event.Amount, ct);</p>
<p>    return Unit.Value;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Event Handlers</h2>

<h3>Before: Event Handler</h3>

<pre><code class="language-csharp">public class OrderShippedHandler : IHandle<OrderShipped> {
<p>  private readonly IDocumentSession _session;</p>

<p>  public async Task Handle(OrderShipped @event) {</p>
<p>    var order = await _session.LoadAsync<Order>(@event.OrderId);</p>
<p>    order.Status = OrderStatus.Shipped;</p>
<p>    order.ShippedAt = @event.ShippedAt;</p>
<p>    await _session.SaveChangesAsync();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>After: Event Receptor</h3>

<p>For side effects (sending notifications, external API calls):</p>

<pre><code class="language-csharp">public class OrderShippedReceptor : IReceptor<OrderShipped, Unit> {
<p>  private readonly INotificationService _notifications;</p>

<p>  public OrderShippedReceptor(INotificationService notifications) {</p>
<p>    _notifications = notifications;</p>
<p>  }</p>

<p>  public async ValueTask<Unit> HandleAsync(OrderShipped @event, CancellationToken ct) {</p>
<p>    await _notifications.SendOrderShippedEmail(@event.OrderId, ct);</p>
<p>    return Unit.Value;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<p>For state updates, use Perspectives instead (see <a href="./04-projection-migration.md">Projection Migration</a>).</p>

<h2>Handlers Without Return Values</h2>

<p>For handlers that don't need to return data, use <code>Unit</code>:</p>

<pre><code class="language-csharp">public class LoggingReceptor : IReceptor<OrderCreated, Unit> {
<p>  private readonly ILogger<LoggingReceptor> _logger;</p>

<p>  public LoggingReceptor(ILogger<LoggingReceptor> logger) {</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public ValueTask<Unit> HandleAsync(OrderCreated @event, CancellationToken ct) {</p>
<p>    _logger.LogInformation("Order {OrderId} created", @event.OrderId);</p>
<p>    return ValueTask.FromResult(Unit.Value);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Synchronous Handlers (No Async Operations)</h2>

<p>:::new</p>
<p>For handlers that perform pure computation without any async operations, use <code>ISyncReceptor</code> to avoid <code>ValueTask.FromResult()</code> ceremony:</p>
<p>:::</p>

<h3>Before: Handler with No Async Operations</h3>

<pre><code class="language-csharp">public class CalculateTaxHandler : IHandle<CalculateTaxCommand> {
<p>  public Task Handle(CalculateTaxCommand command) {</p>
<p>    var tax = command.Amount * command.TaxRate;</p>
<p>    // No async operations - just computation</p>
<p>    return Task.CompletedTask;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>After: Sync Receptor (Clean Pattern)</h3>

<pre><code class="language-csharp">public class CalculateTaxReceptor : ISyncReceptor<CalculateTaxCommand, TaxResult> {
<p>  public TaxResult Handle(CalculateTaxCommand command) {</p>
<p>    var tax = command.Amount * command.TaxRate;</p>
<p>    return new TaxResult(tax);</p>
<p>    // No ValueTask.FromResult() needed!</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>When to Use ISyncReceptor</h3>

<p>| Use <code>ISyncReceptor</code> | Use <code>IReceptor</code> (async) |</p>
<p>|---------------------|-------------------------|</p>
<p>| Pure computation | Database access |</p>
<p>| In-memory transformations | External API calls |</p>
<p>| Validation logic | File I/O |</p>
<p>| ID generation | Message queue operations |</p>
<p>| Calculations | Any <code>await</code> operation |</p>

<h3>Sync Receptor with Events (Auto-Cascade Still Works)</h3>

<pre><code class="language-csharp">public class CreateOrderReceptor : ISyncReceptor<CreateOrder, (OrderResult, OrderCreated)> {
<p>  public (OrderResult, OrderCreated) Handle(CreateOrder message) {</p>
<p>    var orderId = Guid.CreateVersion7();</p>
<p>    var total = message.Items.Sum(i => i.Quantity * i.UnitPrice);</p>

<p>    return (</p>
<p>      new OrderResult(orderId),</p>
<p>      new OrderCreated(orderId, message.CustomerId, total, DateTimeOffset.UtcNow)</p>
<p>    );</p>
<p>    // OrderCreated is AUTO-PUBLISHED - same as async!</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Void Sync Receptor (Side Effects Only)</h3>

<pre><code class="language-csharp">public class LoggingReceptor : ISyncReceptor<OrderCreated> {
<p>  private readonly ILogger<LoggingReceptor> _logger;</p>

<p>  public LoggingReceptor(ILogger<LoggingReceptor> logger) {</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public void Handle(OrderCreated @event) {</p>
<p>    _logger.LogInformation("Order {OrderId} created", @event.OrderId);</p>
<p>    // No return value, no Unit type needed</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Middleware/Pipeline Behaviors</h2>

<h3>Before: Wolverine Middleware</h3>

<pre><code class="language-csharp">public class LoggingMiddleware {
<p>  public async Task Before(ILogger logger, Envelope envelope) {</p>
<p>    logger.LogInformation("Handling {MessageType}", envelope.Message?.GetType().Name);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>After: Whizbang Pipeline Behavior</h3>

<pre><code class="language-csharp">public class LoggingBehavior<TMessage, TResult> : IPipelineBehavior<TMessage, TResult>
<p>  where TMessage : notnull {</p>

<p>  private readonly ILogger<LoggingBehavior<TMessage, TResult>> _logger;</p>

<p>  public LoggingBehavior(ILogger<LoggingBehavior<TMessage, TResult>> logger) {</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public async ValueTask<TResult> HandleAsync(</p>
<p>    TMessage message,</p>
<p>    PipelineDelegate<TMessage, TResult> next,</p>
<p>    CancellationToken ct) {</p>

<p>    _logger.LogInformation("Handling {MessageType}", typeof(TMessage).Name);</p>
<p>    var result = await next(message, ct);</p>
<p>    _logger.LogInformation("Handled {MessageType}", typeof(TMessage).Name);</p>
<p>    return result;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<p>Register behaviors:</p>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.AddPipelineBehavior(typeof(LoggingBehavior<,>));</p>
<p>});</p>
<p></code></pre></p>

<h2>Common Migration Scenarios</h2>

<p>The following scenarios address patterns commonly found in Wolverine codebases.</p>

<h3>Scenario H01: IHandle Interface Implementation</h3>

<strong>Wolverine Pattern (Before):</strong>
<pre><code class="language-csharp">public class OrderInitializeHandler : IHandle<OrderInitializeCommand> {
<p>  private readonly IOrderService _service;</p>

<p>  public OrderInitializeHandler(IOrderService service) {</p>
<p>    _service = service;</p>
<p>  }</p>

<p>  public async Task Handle(OrderInitializeCommand message, CancellationToken ct) {</p>
<p>    await _service.InitializeAsync(message, ct);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>
<pre><code class="language-csharp">public class OrderInitializeReceptor(IOrderService service)
<p>    : IReceptor<OrderInitializeCommand, Unit> {</p>
<p>  public async ValueTask<Unit> HandleAsync(</p>
<p>      OrderInitializeCommand message,</p>
<p>      CancellationToken ct) {</p>
<p>    await service.InitializeAsync(message, ct);</p>
<p>    return Unit.Value;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>
<ul><li><code>IHandle<T></code> becomes <code>IReceptor<T, TResult></code> interface</li>
<li>No <code>[WolverineHandler]</code> attribute needed - source generator discovers receptors</li>
<li>Explicit return type (<code>Unit</code> for void operations)</li>
</ul>
<strong>CLI Transformation:</strong> <code>whizbang migrate apply</code> detects <code>IHandle<T></code> implementations and transforms to <code>IReceptor<T, TResult></code>.

<hr>

<h3>Scenario H02: Static Handler Methods</h3>

<strong>Wolverine Pattern (Before):</strong>
<pre><code class="language-csharp">public static class OrderHandlers {
<p>  public static async Task Handle(CreateOrderCommand msg, IOrderService service, CancellationToken ct) {</p>
<p>    await service.CreateAsync(msg, ct);</p>
<p>  }</p>

<p>  public static async Task Handle(UpdateOrderCommand msg, IOrderService service, CancellationToken ct) {</p>
<p>    await service.UpdateAsync(msg, ct);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>
<pre><code class="language-csharp">// Separate receptor classes - no static methods
<p>public class CreateOrderReceptor(IOrderService service)</p>
<p>    : IReceptor<CreateOrderCommand, OrderResult> {</p>
<p>  public async ValueTask<OrderResult> HandleAsync(CreateOrderCommand msg, CancellationToken ct) {</p>
<p>    return await service.CreateAsync(msg, ct);</p>
<p>  }</p>
<p>}</p>

<p>public class UpdateOrderReceptor(IOrderService service)</p>
<p>    : IReceptor<UpdateOrderCommand, OrderResult> {</p>
<p>  public async ValueTask<OrderResult> HandleAsync(UpdateOrderCommand msg, CancellationToken ct) {</p>
<p>    return await service.UpdateAsync(msg, ct);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>
<ul><li>Convert static methods to instance-based receptor classes</li>
<li>Each receptor is independently discoverable</li>
<li>Cleaner organization by message type</li>
<li>Dependencies injected via constructor</li>
</ul>
<strong>CLI Transformation:</strong> <code>whizbang migrate apply</code> extracts static handlers to separate receptor classes.

<hr>

<h3>Scenario H03: Handlers with Return Values</h3>

<strong>Wolverine Pattern (Before):</strong>
<pre><code class="language-csharp">public class StartActivityCommandHandler : IHandle<StartActivityCommand> {
<p>  private readonly IActivityService _service;</p>

<p>  public StartActivityCommandHandler(IActivityService service) {</p>
<p>    _service = service;</p>
<p>  }</p>

<p>  // Wolverine infers return from method signature</p>
<p>  public async Task<ActivityStartedEvent> Handle(StartActivityCommand message, CancellationToken ct) {</p>
<p>    return await _service.StartActivityAsync(message, ct);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>
<pre><code class="language-csharp">public class StartActivityReceptor(IActivityService service)
<p>    : IReceptor<StartActivityCommand, (ActivityResult, ActivityStartedEvent)> {</p>
<p>  public async ValueTask<(ActivityResult, ActivityStartedEvent)> HandleAsync(</p>
<p>      StartActivityCommand message,</p>
<p>      CancellationToken ct) {</p>
<p>    var @event = await service.StartActivityAsync(message, ct);</p>
<p>    return (new ActivityResult(@event.ActivityId), @event);</p>
<p>    // ActivityStartedEvent is AUTO-PUBLISHED</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>
<ul><li>RPC return is now a tuple containing both result and event</li>
<li>Event is automatically published when returned in tuple</li>
<li>Cleaner separation of response data vs domain events</li>
</ul>
<hr>

<h3>Scenario H04: In-Process Handler Invocation</h3>

<strong>Wolverine Pattern (Before):</strong>
<pre><code class="language-csharp">// Wolverine supports in-process invocation via IMessageBus
<p>public class ActivityOrchestrator {</p>
<p>  private readonly IMessageBus _bus;</p>

<p>  public async Task<ActivityResult> OrchestrateAsync(StartActivityCommand command, CancellationToken ct) {</p>
<p>    // InvokeAsync runs handler in-process</p>
<p>    return await _bus.InvokeAsync<ActivityResult>(command, ct);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>
<pre><code class="language-csharp">// Use LocalInvokeAsync directly - no wrapper needed
<p>public class ActivityOrchestrator(IDispatcher dispatcher)</p>
<p>    : IReceptor<StartActivityCommand, ActivityResult> {</p>
<p>  public async ValueTask<ActivityResult> HandleAsync(</p>
<p>      StartActivityCommand message,</p>
<p>      CancellationToken ct) {</p>
<p>    // LocalInvokeAsync provides in-process RPC semantics</p>
<p>    return await dispatcher.LocalInvokeAsync<StartActivityCommand, ActivityResult>(</p>
<p>        message, ct);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>
<ul><li>No <code>LocalMessage<T></code> wrapper needed</li>
<li><code>IDispatcher.LocalInvokeAsync<T>()</code> provides in-process execution</li>
<li>Type-safe with compile-time result type checking</li>
</ul>
<hr>

<h3>Scenario H05: Handler with Notification Service</h3>

<strong>Wolverine Pattern (Before):</strong>
<pre><code class="language-csharp">public class OrderHandler : IHandle<OrderCommand> {
<p>  private readonly IOrderService _service;</p>
<p>  private readonly INotificationService _notifications;</p>

<p>  public OrderHandler(IOrderService service, INotificationService notifications) {</p>
<p>    _service = service;</p>
<p>    _notifications = notifications;</p>
<p>  }</p>

<p>  public async Task Handle(OrderCommand msg, CancellationToken ct) {</p>
<p>    await _service.ProcessAsync(msg, ct);</p>
<p>    await _notifications.NotifyAsync(new OrderUpdatedNotification(msg.OrderId), ct);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>
<pre><code class="language-csharp">public class OrderReceptor(
<p>    IOrderService service,</p>
<p>    INotificationService notifications)</p>
<p>    : IReceptor<OrderCommand, (OrderResult, OrderUpdated)> {</p>

<p>  public async ValueTask<(OrderResult, OrderUpdated)> HandleAsync(</p>
<p>      OrderCommand msg,</p>
<p>      CancellationToken ct) {</p>
<p>    await service.ProcessAsync(msg, ct);</p>
<p>    await notifications.NotifyAsync(new OrderUpdatedNotification(msg.OrderId), ct);</p>

<p>    var @event = new OrderUpdated(msg.OrderId);</p>
<p>    return (new OrderResult(msg.OrderId), @event);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>
<ul><li>Same DI pattern for notification service</li>
<li>Event returned in tuple for auto-publishing</li>
<li>Notification service can be any implementation</li>
</ul>
<hr>

<h3>Scenario H06: Handler with Correlation Context</h3>

<strong>Wolverine Pattern (Before):</strong>
<pre><code class="language-csharp">public class OrderHandler : IHandle<CreateOrderCommand> {
<p>  private readonly IMessageContext _context;</p>

<p>  public OrderHandler(IMessageContext context) {</p>
<p>    _context = context;</p>
<p>  }</p>

<p>  public async Task Handle(CreateOrderCommand msg, CancellationToken ct) {</p>
<p>    var correlationId = _context.CorrelationId;</p>
<p>    // Use correlation for downstream calls</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>
<pre><code class="language-csharp">public class CreateOrderReceptor
<p>    : IReceptor<MessageEnvelope<CreateOrderCommand>, OrderResult> {</p>

<p>  public ValueTask<OrderResult> HandleAsync(</p>
<p>      MessageEnvelope<CreateOrderCommand> envelope,</p>
<p>      CancellationToken ct) {</p>
<p>    // Access correlation from envelope hops</p>
<p>    var correlationId = envelope.CurrentHop?.CorrelationId;</p>
<p>    var command = envelope.Payload;</p>

<p>    // Process with full message context available</p>
<p>    return ValueTask.FromResult(new OrderResult(command.OrderId));</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>
<ul><li>Wrap message type in <code>MessageEnvelope<T></code> to access context</li>
<li><code>Hops</code> property provides correlation, causation, and tracing info</li>
<li>No separate token provider needed - context flows with envelope</li>
</ul>
<hr>

<h3>Scenario H07: Handler with Telemetry/Tracing</h3>

<strong>Wolverine Pattern (Before):</strong>
<pre><code class="language-csharp">public class OrderHandler : IHandle<CreateOrderCommand> {
<p>  private readonly ActivitySource _activitySource;</p>

<p>  public OrderHandler(ActivitySource activitySource) {</p>
<p>    _activitySource = activitySource;</p>
<p>  }</p>

<p>  public async Task Handle(CreateOrderCommand msg, CancellationToken ct) {</p>
<p>    using var activity = _activitySource.StartActivity("CreateOrder");</p>
<p>    activity?.SetTag("orderId", msg.OrderId);</p>

<p>    // Process order</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>
<pre><code class="language-csharp">public class CreateOrderReceptor(ActivitySource activitySource)
<p>    : IReceptor<CreateOrderCommand, OrderResult> {</p>

<p>  public async ValueTask<OrderResult> HandleAsync(</p>
<p>      CreateOrderCommand msg,</p>
<p>      CancellationToken ct) {</p>
<p>    using var activity = activitySource.StartActivity("CreateOrder");</p>
<p>    activity?.SetTag("orderId", msg.OrderId);</p>

<p>    // Process order - same pattern works</p>
<p>    return new OrderResult(msg.OrderId);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>
<ul><li>Same <code>ActivitySource</code> pattern works in Whizbang</li>
<li>Consider using <code>ITraceStore</code> for persistent message tracing</li>
<li>Whizbang provides built-in observability via <code>MessageEnvelope.Hops</code></li>
</ul>
<p>:::tip[Built-in Tracing]</p>
<p>Whizbang automatically tracks message flow via <code>MessageEnvelope.Hops</code>. For custom spans, inject <code>ActivitySource</code> as shown above.</p>
<p>:::</p>

<hr>

<h2>Automated Migration</h2>

<p>Use the CLI tool to automate handler migration:</p>

<pre><code class="language-bash"># Preview changes
<p>whizbang migrate analyze --project ./src/MyService --type handlers</p>

<h1>Apply with review</h1>
<p>whizbang migrate apply --project ./src/MyService --type handlers --guided</p>
<p></code></pre></p>

<p>The tool will:</p>
<ul><li>Find all <code>IHandle<T></code> implementations</li>
<li>Generate corresponding <code>IReceptor<T, TResult></code> classes</li>
<li>Create result types</li>
<li>Update DI registrations</li>
<li>Preserve your business logic</li>
</ul>
<h2>Checklist</h2>

<ul><li>[ ] Replace <code>IHandle<T></code> with <code>IReceptor<T, TResult></code></li>
<li>[ ] Update method signature to <code>HandleAsync</code> with <code>CancellationToken</code></li>
<li>[ ] Create result types for each receptor</li>
<li>[ ] Replace <code>IDocumentSession</code> with <code>IEventStore</code></li>
<li>[ ] Replace <code>IMessageBus</code> with <code>IDispatcher</code></li>
<li>[ ] Convert middleware to pipeline behaviors</li>
<li>[ ] Remove <code>[WolverineHandler]</code> attributes (no longer needed)</li>
<li>[ ] Update using directives</li>
<li>[ ] Run tests to verify behavior</li>
</ul>
<h2>Next Steps</h2>

<ul><li><a href="./04-projection-migration.md">Projection Migration</a> - Convert Marten projections to Perspectives</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="migrate-from-marten-wolverine-04-projection-migration" class="doc-section">
  <h2>04 projection migration</h2>
  <p class="doc-path"><code>migrate-from-marten-wolverine/04-projection-migration</code></p>
  <div class="doc-content">
<h1>Migrate from Marten/Wolverine: Projection Migration</h1>

<p>This guide covers migrating Marten projections to Whizbang Perspectives.</p>

<h2>Overview</h2>

<p>| Marten | Whizbang |</p>
<p>|--------|----------|</p>
<p>| <code>SingleStreamProjection<T></code> | <code>IPerspectiveFor<TModel, TEvent...></code> |</p>
<p>| <code>MultiStreamProjection<T></code> | <code>IGlobalPerspectiveFor<TModel></code> |</p>
<p>| Mutable <code>Apply(event, view)</code> | Immutable <code>Apply(current, event) => new</code> |</p>
<p>| Runtime registration | Source-generated discovery |</p>

<h2>Single Stream Projection Migration</h2>

<h3>Before: Marten SingleStreamProjection</h3>

<pre><code class="language-csharp">public class OrderProjection : SingleStreamProjection<OrderView> {
<p>  public OrderView Create(OrderCreated @event) {</p>
<p>    return new OrderView {</p>
<p>      Id = @event.OrderId,</p>
<p>      CustomerId = @event.CustomerId,</p>
<p>      Items = @event.Items,</p>
<p>      Status = OrderStatus.Created,</p>
<p>      CreatedAt = @event.CreatedAt</p>
<p>    };</p>
<p>  }</p>

<p>  public void Apply(OrderShipped @event, OrderView view) {</p>
<p>    view.Status = OrderStatus.Shipped;</p>
<p>    view.ShippedAt = @event.ShippedAt;</p>
<p>  }</p>

<p>  public void Apply(OrderCancelled @event, OrderView view) {</p>
<p>    view.Status = OrderStatus.Cancelled;</p>
<p>    view.CancelledAt = @event.CancelledAt;</p>
<p>    view.CancellationReason = @event.Reason;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>After: Whizbang Perspective</h3>

<pre><code class="language-csharp">public class OrderPerspective
<p>  : IPerspectiveFor<OrderView, OrderCreated, OrderShipped, OrderCancelled> {</p>

<p>  public OrderView Apply(OrderView? current, OrderCreated @event) {</p>
<p>    return new OrderView {</p>
<p>      Id = @event.OrderId,</p>
<p>      CustomerId = @event.CustomerId,</p>
<p>      Items = @event.Items,</p>
<p>      Status = OrderStatus.Created,</p>
<p>      CreatedAt = @event.CreatedAt</p>
<p>    };</p>
<p>  }</p>

<p>  public OrderView Apply(OrderView? current, OrderShipped @event) {</p>
<p>    ArgumentNullException.ThrowIfNull(current, "Order must exist before shipping");</p>
<p>    return current with {</p>
<p>      Status = OrderStatus.Shipped,</p>
<p>      ShippedAt = @event.ShippedAt</p>
<p>    };</p>
<p>  }</p>

<p>  public OrderView Apply(OrderView? current, OrderCancelled @event) {</p>
<p>    ArgumentNullException.ThrowIfNull(current, "Order must exist before cancellation");</p>
<p>    return current with {</p>
<p>      Status = OrderStatus.Cancelled,</p>
<p>      CancelledAt = @event.CancelledAt,</p>
<p>      CancellationReason = @event.Reason</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Key Differences</h2>

<h3>1. Interface Declaration</h3>

<p>Marten uses inheritance; Whizbang uses a variadic interface listing all event types:</p>

<pre><code class="language-csharp">// Marten
<p>public class MyProjection : SingleStreamProjection<MyView></p>

<p>// Whizbang - list all event types</p>
<p>public class MyPerspective : IPerspectiveFor<MyView, Event1, Event2, Event3></p>
<p></code></pre></p>

<h3>2. Immutable Apply Pattern</h3>

<p>Marten mutates the existing view; Whizbang returns a new instance:</p>

<pre><code class="language-csharp">// Marten (mutable)
<p>public void Apply(OrderShipped @event, OrderView view) {</p>
<p>  view.Status = OrderStatus.Shipped;</p>
<p>}</p>

<p>// Whizbang (immutable)</p>
<p>public OrderView Apply(OrderView? current, OrderShipped @event) {</p>
<p>  return current with { Status = OrderStatus.Shipped };</p>
<p>}</p>
<p></code></pre></p>

<h3>3. Create vs Apply</h3>

<p>Marten has separate <code>Create</code> method; Whizbang uses <code>Apply</code> with nullable current:</p>

<pre><code class="language-csharp">// Marten
<p>public OrderView Create(OrderCreated @event) {</p>
<p>  return new OrderView { ... };</p>
<p>}</p>

<p>// Whizbang (current is null for first event)</p>
<p>public OrderView Apply(OrderView? current, OrderCreated @event) {</p>
<p>  // current is null - this is creation</p>
<p>  return new OrderView { ... };</p>
<p>}</p>
<p></code></pre></p>

<h2>Multi-Stream Projection Migration</h2>

<h3>Before: Marten MultiStreamProjection</h3>

<pre><code class="language-csharp">public class CustomerOrderSummaryProjection : MultiStreamProjection<CustomerOrderSummary, Guid> {
<p>  public CustomerOrderSummaryProjection() {</p>
<p>    Identity<OrderCreated>(e => e.CustomerId);</p>
<p>    Identity<OrderCompleted>(e => e.CustomerId);</p>
<p>  }</p>

<p>  public CustomerOrderSummary Create(OrderCreated @event) {</p>
<p>    return new CustomerOrderSummary {</p>
<p>      CustomerId = @event.CustomerId,</p>
<p>      TotalOrders = 1,</p>
<p>      TotalSpent = @event.Amount</p>
<p>    };</p>
<p>  }</p>

<p>  public void Apply(OrderCreated @event, CustomerOrderSummary summary) {</p>
<p>    summary.TotalOrders++;</p>
<p>    summary.TotalSpent += @event.Amount;</p>
<p>  }</p>

<p>  public void Apply(OrderCompleted @event, CustomerOrderSummary summary) {</p>
<p>    summary.CompletedOrders++;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>After: Whizbang Global Perspective</h3>

<pre><code class="language-csharp">public class CustomerOrderSummaryPerspective
<p>  : IGlobalPerspectiveFor<CustomerOrderSummary, OrderCreated, OrderCompleted> {</p>

<p>  public Guid GetPartitionKey(OrderCreated @event) => @event.CustomerId;</p>
<p>  public Guid GetPartitionKey(OrderCompleted @event) => @event.CustomerId;</p>

<p>  public CustomerOrderSummary Apply(CustomerOrderSummary? current, OrderCreated @event) {</p>
<p>    if (current is null) {</p>
<p>      return new CustomerOrderSummary {</p>
<p>        CustomerId = @event.CustomerId,</p>
<p>        TotalOrders = 1,</p>
<p>        TotalSpent = @event.Amount</p>
<p>      };</p>
<p>    }</p>

<p>    return current with {</p>
<p>      TotalOrders = current.TotalOrders + 1,</p>
<p>      TotalSpent = current.TotalSpent + @event.Amount</p>
<p>    };</p>
<p>  }</p>

<p>  public CustomerOrderSummary Apply(CustomerOrderSummary? current, OrderCompleted @event) {</p>
<p>    ArgumentNullException.ThrowIfNull(current);</p>
<p>    return current with {</p>
<p>      CompletedOrders = current.CompletedOrders + 1</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>View Model Requirements</h2>

<h3>Use Records for Immutability</h3>

<p>Whizbang perspectives work best with records:</p>

<pre><code class="language-csharp">// Recommended: record with 'with' expression support
<p>public record OrderView {</p>
<p>  public required Guid Id { get; init; }</p>
<p>  public required Guid CustomerId { get; init; }</p>
<p>  public required IReadOnlyList<OrderItem> Items { get; init; }</p>
<p>  public required OrderStatus Status { get; init; }</p>
<p>  public required DateTimeOffset CreatedAt { get; init; }</p>
<p>  public DateTimeOffset? ShippedAt { get; init; }</p>
<p>  public DateTimeOffset? CancelledAt { get; init; }</p>
<p>  public string? CancellationReason { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<h3>Migrating Mutable Classes</h3>

<p>If your existing view is a mutable class:</p>

<pre><code class="language-csharp">// Before: Mutable class
<p>public class OrderView {</p>
<p>  public Guid Id { get; set; }</p>
<p>  public OrderStatus Status { get; set; }</p>
<p>  // ...</p>
<p>}</p>

<p>// After: Convert to record</p>
<p>public record OrderView {</p>
<p>  public required Guid Id { get; init; }</p>
<p>  public required OrderStatus Status { get; init; }</p>
<p>  // ...</p>
<p>}</p>
<p></code></pre></p>

<h2>Perspective Purity Requirements</h2>

<p>:::warning[Critical]</p>
<p>Perspective Apply methods MUST be pure functions. This is enforced at compile-time.</p>
<p>:::</p>

<strong>CRITICAL</strong>: Perspective Apply methods MUST be pure functions:

<ul><li><strong>No async/await</strong> - Apply methods are synchronous</li>
<li><strong>No database calls</strong> - No DbContext, ILensQuery, or repository access</li>
<li><strong>No HTTP calls</strong> - No HttpClient or external API calls</li>
<li><strong>No side effects</strong> - No logging, no events, no external state mutation</li>
<li><strong>Deterministic</strong> - Same inputs always produce same outputs</li>
<li><strong>Use event timestamps</strong> - Not <code>DateTime.UtcNow</code> (use event's timestamp)</li>
</ul>
<h3>Why Purity Matters</h3>

<p>Perspectives may be replayed during:</p>
<ul><li>System recovery after failures</li>
<li>Rebuilding read models from event history</li>
<li>Testing with event replay</li>
</ul>
<p>Non-pure Apply methods would produce different results on replay, corrupting your read models.</p>

<h3>Compile-Time Enforcement</h3>

<p>Whizbang includes <code>PerspectivePurityAnalyzer</code> that emits errors for:</p>
<ul><li><strong>WHIZ100</strong>: Apply returns Task (must be sync)</li>
<li><strong>WHIZ101</strong>: Apply uses await keyword</li>
<li><strong>WHIZ102</strong>: Apply calls database I/O</li>
<li><strong>WHIZ103</strong>: Apply calls HTTP/network</li>
<li><strong>WHIZ104</strong>: Apply uses DateTime.UtcNow (warning)</li>
</ul>
<h3>Pure Service Injection</h3>

<p>If migrated code needs computation services in Apply methods, use <strong>class-level injection</strong> with Pure Services:</p>

<pre><code class="language-csharp">public class OrderPerspective : IPerspectiveFor<OrderView, OrderShipped> {
<p>  private readonly IExchangeRateService _exchangeRates; // Must be [PureService]</p>

<p>  public OrderPerspective(IExchangeRateService exchangeRates) {</p>
<p>    _exchangeRates = exchangeRates;</p>
<p>  }</p>

<p>  public OrderView Apply(OrderView? current, OrderShipped @event) {</p>
<p>    var rate = _exchangeRates.GetRate(@event.Currency, @event.ShippedAt);</p>
<p>    return current! with {</p>
<p>      Status = OrderStatus.Shipped,</p>
<p>      TotalInUsd = current.Total * rate</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<p>Services injected into Perspectives MUST be registered as <strong>Pure Services</strong>:</p>

<pre><code class="language-csharp">// Registration
<p>services.AddPureService<IExchangeRateService, ExchangeRateService>();</p>

<p>// Or with attribute on the service class</p>
<p>[PureService]</p>
<p>public class ExchangeRateService : IExchangeRateService {</p>
<p>  // Implementation must be pure!</p>
<p>}</p>
<p></code></pre></p>

<strong>Analyzer Behavior</strong>:
<ul><li><strong>WHIZ105</strong>: Warning when perspective injects non-<code>[PureService]</code> dependency</li>
<li>Developers can suppress warnings with <code>#pragma warning disable WHIZ105</code></li>
</ul>
<p>:::warning[Developer Scrutiny Required]</p>
<p>Pure services are a major area for careful review. Non-pure services injected into perspectives WILL break replay determinism. Only suppress WHIZ105 if you are 100% certain the service is truly pure.</p>
<p>:::</p>

<h2>Inline Projections</h2>

<p>For simple projections without a dedicated class:</p>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.AddInlinePerspective<OrderSummaryView>(cfg => {</p>
<p>        cfg.On<OrderCreated>((current, e) => new OrderSummaryView {</p>
<p>            Id = e.OrderId,</p>
<p>            Status = "Created"</p>
<p>        });</p>
<p>        cfg.On<OrderShipped>((current, e) => current! with {</p>
<p>            Status = "Shipped"</p>
<p>        });</p>
<p>    });</p>
<p>});</p>
<p></code></pre></p>

<h2>Registration</h2>

<p>Perspectives are discovered automatically by source generators. No manual registration required.</p>

<p>For explicit registration (optional):</p>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.AddPerspective<OrderPerspective>();</p>
<p>    options.AddGlobalPerspective<CustomerOrderSummaryPerspective>();</p>
<p>});</p>
<p></code></pre></p>

<h2>Common Migration Scenarios</h2>

<p>The following scenarios address patterns commonly found in Marten codebases.</p>

<h3>Scenario P01: SingleStreamProjection Base Class</h3>

<strong>Marten Pattern (Before):</strong>
<pre><code class="language-csharp">public class OrderProjection : SingleStreamProjection<Order> {
<p>  public Order Create(OrderCreatedEvent @event) {</p>
<p>    return new Order {</p>
<p>      Id = @event.StreamId,</p>
<p>      Title = @event.Title,</p>
<p>      Status = OrderStatus.Created</p>
<p>    };</p>
<p>  }</p>

<p>  public void Apply(OrderUpdatedEvent @event, Order model) {</p>
<p>    model.Title = @event.Title;</p>
<p>    model.Description = @event.Description;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>
<pre><code class="language-csharp">public class OrderPerspective
<p>    : IPerspectiveFor<Order, OrderCreatedEvent, OrderUpdatedEvent> {</p>

<p>  public Order Apply(Order? current, OrderCreatedEvent @event) {</p>
<p>    return new Order {</p>
<p>      Id = @event.StreamId,</p>
<p>      Title = @event.Title,</p>
<p>      Status = OrderStatus.Created</p>
<p>    };</p>
<p>  }</p>

<p>  public Order Apply(Order? current, OrderUpdatedEvent @event) {</p>
<p>    ArgumentNullException.ThrowIfNull(current);</p>
<p>    return current with {</p>
<p>      Title = @event.Title,</p>
<p>      Description = @event.Description</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>
<ul><li>No base class inheritance - implement interface directly</li>
<li>Source generator discovers perspectives automatically</li>
<li>Separate <code>Create</code> method merged into <code>Apply</code> with nullable <code>current</code></li>
</ul>
<strong>CLI Transformation:</strong> <code>whizbang migrate apply</code> detects <code>SingleStreamProjection<T></code> inheritance.

<hr>

<h3>Scenario P02: MultiStreamProjection Base Class</h3>

<strong>Marten Pattern (Before):</strong>
<pre><code class="language-csharp">public class CustomerProjection : MultiStreamProjection<Customer, Guid> {
<p>  public CustomerProjection() {</p>
<p>    Identity<IEvent>(e => e.StreamId);</p>
<p>  }</p>

<p>  public Customer Create(CustomerCreatedEvent @event) {</p>
<p>    return new Customer {</p>
<p>      Id = @event.StreamId,</p>
<p>      Name = @event.Name,</p>
<p>      Version = 1</p>
<p>    };</p>
<p>  }</p>

<p>  public void Apply(CustomerUpdatedEvent @event, Customer model) {</p>
<p>    model.Name = @event.Name;</p>
<p>    model.Version++;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>
<pre><code class="language-csharp">public class CustomerPerspective
<p>    : IGlobalPerspectiveFor<Customer, CustomerCreatedEvent, CustomerUpdatedEvent> {</p>

<p>  public Guid GetPartitionKey(CustomerCreatedEvent @event) => @event.StreamId;</p>
<p>  public Guid GetPartitionKey(CustomerUpdatedEvent @event) => @event.StreamId;</p>

<p>  public Customer Apply(Customer? current, CustomerCreatedEvent @event) {</p>
<p>    return new Customer {</p>
<p>      Id = @event.StreamId,</p>
<p>      Name = @event.Name,</p>
<p>      Version = 1</p>
<p>    };</p>
<p>  }</p>

<p>  public Customer Apply(Customer? current, CustomerUpdatedEvent @event) {</p>
<p>    ArgumentNullException.ThrowIfNull(current);</p>
<p>    return current with {</p>
<p>      Name = @event.Name,</p>
<p>      Version = current.Version + 1</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>
<ul><li>Constructor <code>Identity<T>()</code> becomes <code>GetPartitionKey()</code> methods</li>
<li>One <code>GetPartitionKey</code> method per event type</li>
<li>Same immutable <code>Apply</code> pattern as single-stream</li>
</ul>
<hr>

<h3>Scenario P03: Identity/Partition Key Extraction</h3>

<strong>Marten Pattern (Before):</strong>
<pre><code class="language-csharp">public class CustomerSummaryProjection : MultiStreamProjection<CustomerSummary, Guid> {
<p>  public CustomerSummaryProjection() {</p>
<p>    // Identity extraction in constructor</p>
<p>    Identity<OrderCreatedEvent>(e => e.CustomerId);</p>
<p>    Identity<OrderCompletedEvent>(e => e.CustomerId);</p>
<p>    Identity<OrderCancelledEvent>(e => e.CustomerId);</p>
<p>  }</p>
<p>  // ... Apply methods</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>
<pre><code class="language-csharp">public class CustomerSummaryPerspective
<p>    : IGlobalPerspectiveFor<CustomerSummary, OrderCreatedEvent, OrderCompletedEvent, OrderCancelledEvent> {</p>

<p>  // Explicit partition key methods - one per event type</p>
<p>  public Guid GetPartitionKey(OrderCreatedEvent @event) => @event.CustomerId;</p>
<p>  public Guid GetPartitionKey(OrderCompletedEvent @event) => @event.CustomerId;</p>
<p>  public Guid GetPartitionKey(OrderCancelledEvent @event) => @event.CustomerId;</p>

<p>  // ... Apply methods</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>
<ul><li>Constructor-based <code>Identity<T>()</code> becomes type-safe method overloads</li>
<li>Compile-time verification that all event types have partition key extraction</li>
<li>Clearer relationship between event and partition key</li>
</ul>
<hr>

<h3>Scenario P04: Nested Model + Projection Classes</h3>

<strong>Marten Pattern (Before):</strong>
<pre><code class="language-csharp">public static class TaskItemProjection {
<p>  // Nested model class</p>
<p>  public class Model {</p>
<p>    public Guid Id { get; set; }</p>
<p>    public string Title { get; set; } = "";</p>
<p>    public TaskStatus Status { get; set; }</p>
<p>    public List<TaskStep> Steps { get; set; } = new();</p>
<p>  }</p>

<p>  // Nested projection class</p>
<p>  public class Projection : SingleStreamProjection<Model> {</p>
<p>    public Model Create(TaskCreatedEvent @event) {</p>
<p>      return new Model {</p>
<p>        Id = @event.StreamId,</p>
<p>        Title = @event.Title,</p>
<p>        Status = TaskStatus.Pending</p>
<p>      };</p>
<p>    }</p>

<p>    public void Apply(TaskStepAddedEvent @event, Model model) {</p>
<p>      model.Steps.Add(new TaskStep { Id = @event.StepId, Name = @event.Name });</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>
<pre><code class="language-csharp">// Flat structure - separate record and perspective
<p>public record TaskItem {</p>
<p>  public required Guid Id { get; init; }</p>
<p>  public required string Title { get; init; }</p>
<p>  public required TaskStatus Status { get; init; }</p>
<p>  public required IReadOnlyList<TaskStep> Steps { get; init; }</p>
<p>}</p>

<p>public class TaskItemPerspective</p>
<p>    : IPerspectiveFor<TaskItem, TaskCreatedEvent, TaskStepAddedEvent> {</p>

<p>  public TaskItem Apply(TaskItem? current, TaskCreatedEvent @event) {</p>
<p>    return new TaskItem {</p>
<p>      Id = @event.StreamId,</p>
<p>      Title = @event.Title,</p>
<p>      Status = TaskStatus.Pending,</p>
<p>      Steps = []</p>
<p>    };</p>
<p>  }</p>

<p>  public TaskItem Apply(TaskItem? current, TaskStepAddedEvent @event) {</p>
<p>    ArgumentNullException.ThrowIfNull(current);</p>
<p>    return current with {</p>
<p>      Steps = [..current.Steps, new TaskStep { Id = @event.StepId, Name = @event.Name }]</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>
<ul><li>Flatten nested static classes into separate types</li>
<li>Model becomes a record at namespace level</li>
<li>Projection becomes a perspective at namespace level</li>
<li>Collection updates use spread syntax for immutability</li>
</ul>
<hr>

<h3>Scenario P05: Projection Model Interface</h3>

<strong>Marten Pattern (Before):</strong>
<pre><code class="language-csharp">// Some codebases use a marker interface for projection models
<p>public interface IProjectionModel {</p>
<p>  Guid Id { get; set; }</p>
<p>}</p>

<p>public class ActiveTenant : IProjectionModel {</p>
<p>  public Guid Id { get; set; }</p>
<p>  public string Name { get; set; } = "";</p>
<p>  public TenantStatus Status { get; set; }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>
<pre><code class="language-csharp">// No interface needed - just use a record
<p>public record ActiveTenant {</p>
<p>  public required Guid Id { get; init; }</p>
<p>  public required string Name { get; init; }</p>
<p>  public required TenantStatus Status { get; init; }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>
<ul><li>No marker interface required</li>
<li>Use <code>required</code> modifier for mandatory properties</li>
<li>Use <code>init</code> for immutability</li>
<li>Records provide <code>with</code> expression support automatically</li>
</ul>
<hr>

<h3>Scenario P06: Projection with Versioning</h3>

<strong>Marten Pattern (Before):</strong>
<pre><code class="language-csharp">public class Product {
<p>  public Guid Id { get; set; }</p>
<p>  public string Name { get; set; } = "";</p>
<p>  public int Version { get; set; }</p>
<p>  public DateTimeOffset LastModified { get; set; }</p>
<p>}</p>

<p>public class ProductProjection : SingleStreamProjection<Product> {</p>
<p>  public void Apply(ProductUpdatedEvent @event, Product model) {</p>
<p>    model.Name = @event.Name;</p>
<p>    model.Version++;  // Increment version on each update</p>
<p>    model.LastModified = DateTimeOffset.UtcNow;</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>
<pre><code class="language-csharp">public record Product {
<p>  public required Guid Id { get; init; }</p>
<p>  public required string Name { get; init; }</p>
<p>  public required int Version { get; init; }</p>
<p>  public required DateTimeOffset LastModified { get; init; }</p>
<p>}</p>

<p>public class ProductPerspective</p>
<p>    : IPerspectiveFor<Product, ProductCreatedEvent, ProductUpdatedEvent> {</p>

<p>  public Product Apply(Product? current, ProductUpdatedEvent @event) {</p>
<p>    ArgumentNullException.ThrowIfNull(current);</p>
<p>    return current with {</p>
<p>      Name = @event.Name,</p>
<p>      Version = current.Version + 1,  // Explicit increment</p>
<p>      LastModified = @event.UpdatedAt  // Use event timestamp, not UtcNow!</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>
<ul><li>Version increment is explicit in the <code>with</code> expression</li>
<li>Immutable pattern makes version history trackable</li>
<li>No side effects from <code>++</code> operator</li>
<li><strong>Use event timestamp</strong> instead of <code>DateTime.UtcNow</code> for deterministic replay</li>
</ul>
<hr>

<h3>Scenario P07: Cross-Service Duplicate Projections</h3>

<strong>Marten Pattern (Before):</strong>
<pre><code class="language-csharp">// In BffService
<p>public class TaskItemProjection : SingleStreamProjection<TaskItem> { ... }</p>

<p>// In JobService (duplicate!)</p>
<p>public class TaskItemProjection : SingleStreamProjection<TaskItem> { ... }</p>

<p>// In TaskService (another duplicate!)</p>
<p>public class TaskItemProjection : SingleStreamProjection<TaskItem> { ... }</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>
<pre><code class="language-csharp">// In shared Contracts assembly
<p>public record TaskItem {</p>
<p>  public required Guid Id { get; init; }</p>
<p>  public required string Title { get; init; }</p>
<p>  // ...</p>
<p>}</p>

<p>// Single perspective in one service (or shared library)</p>
<p>public class TaskItemPerspective</p>
<p>    : IPerspectiveFor<TaskItem, TaskCreatedEvent, TaskUpdatedEvent> {</p>
<p>  // Single source of truth</p>
<p>}</p>

<p>// Other services query via ILensQuery<TaskItem></p>
<p>public class TaskQueryReceptor(IScopedLensQuery<TaskItem> taskQuery)</p>
<p>    : IReceptor<GetTaskQuery, TaskItem?> {</p>

<p>  public async ValueTask<TaskItem?> HandleAsync(GetTaskQuery query, CancellationToken ct) {</p>
<p>    return await taskQuery.GetByIdAsync(query.TaskId, ct);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>
<ul><li>Single perspective definition (no duplication)</li>
<li>Other services use <code>ILensQuery<T></code> to query the projection</li>
<li>Model record shared via contracts assembly</li>
<li>Avoids synchronization issues from duplicate projections</li>
</ul>
<p>:::warning[Duplicate Projections]</p>
<p>Cross-service duplicate projections can lead to data inconsistency. Consolidate to a single source of truth and use <code>ILensQuery<T></code> for read access from other services.</p>
<p>:::</p>

<hr>

<h2>Automated Migration</h2>

<p>Use the CLI tool to automate projection migration:</p>

<pre><code class="language-bash"># Preview changes
<p>whizbang migrate analyze --project ./src/MyService --type projections</p>

<h1>Apply with review</h1>
<p>whizbang migrate apply --project ./src/MyService --type projections --guided</p>
<p></code></pre></p>

<p>The tool will:</p>
<ul><li>Find all <code>SingleStreamProjection<T></code> and <code>MultiStreamProjection<T></code> classes</li>
<li>Generate corresponding <code>IPerspectiveFor<T, ...></code> classes</li>
<li>Convert view classes to records</li>
<li>Transform mutable Apply methods to immutable returns</li>
</ul>
<h2>Checklist</h2>

<ul><li>[ ] Convert <code>SingleStreamProjection<T></code> to <code>IPerspectiveFor<T, TEvent...></code></li>
<li>[ ] Convert <code>MultiStreamProjection<T></code> to <code>IGlobalPerspectiveFor<T, TEvent...></code></li>
<li>[ ] Convert view classes to records with <code>init</code> properties</li>
<li>[ ] Change <code>Apply(event, view)</code> to <code>Apply(view?, event) => new</code></li>
<li>[ ] Replace <code>Create(event)</code> with <code>Apply(null, event)</code></li>
<li>[ ] Add <code>GetPartitionKey</code> methods for global perspectives</li>
<li>[ ] Handle nullable <code>current</code> parameter appropriately</li>
<li>[ ] Update using directives</li>
<li>[ ] Run tests to verify projections produce correct state</li>
</ul>
<h2>Next Steps</h2>

<ul><li><a href="./05-event-store-migration.md">Event Store Migration</a> - Migrate IDocumentStore to IEventStore</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="migrate-from-marten-wolverine-05-event-store-migration" class="doc-section">
  <h2>05 event store migration</h2>
  <p class="doc-path"><code>migrate-from-marten-wolverine/05-event-store-migration</code></p>
  <div class="doc-content">
<h1>Migrate from Marten/Wolverine: Event Store Migration</h1>

<p>This guide covers migrating from Marten's <code>IDocumentStore</code> to Whizbang's <code>IEventStore</code>.</p>

<h2>Overview</h2>

<p>| Marten | Whizbang |</p>
<p>|--------|----------|</p>
<p>| <code>IDocumentStore</code> | <code>IEventStore</code> |</p>
<p>| <code>IDocumentSession</code> | Direct <code>IEventStore</code> methods |</p>
<p>| <code>StartStream<T>()</code> | <code>AppendAsync()</code> with new stream ID |</p>
<p>| <code>Append()</code> + <code>SaveChangesAsync()</code> | Single <code>AppendAsync()</code> call |</p>
<p>| <code>FetchStreamAsync()</code> | <code>ReadAsync()</code> |</p>

<h2>Basic Operations</h2>

<h3>Creating a Stream</h3>

<h4>Before: Marten</h4>

<pre><code class="language-csharp">await using var session = _store.LightweightSession();
<p>var streamId = session.Events.StartStream<Order>(</p>
<p>    new OrderCreated(orderId, customerId, items)</p>
<p>).Id;</p>
<p>await session.SaveChangesAsync();</p>
<p></code></pre></p>

<h4>After: Whizbang</h4>

<pre><code class="language-csharp">var streamId = Guid.NewGuid();
<p>await _eventStore.AppendAsync(streamId, new OrderCreated(orderId, customerId, items), ct);</p>
<p></code></pre></p>

<h3>Appending Events</h3>

<h4>Before: Marten</h4>

<pre><code class="language-csharp">await using var session = _store.LightweightSession();
<p>session.Events.Append(streamId, new OrderShipped(streamId, DateTime.UtcNow));</p>
<p>await session.SaveChangesAsync();</p>
<p></code></pre></p>

<h4>After: Whizbang</h4>

<pre><code class="language-csharp">await _eventStore.AppendAsync(streamId, new OrderShipped(streamId, DateTimeOffset.UtcNow), ct);
<p></code></pre></p>

<h3>Reading Events</h3>

<h4>Before: Marten</h4>

<pre><code class="language-csharp">await using var session = _store.QuerySession();
<p>var events = await session.Events.FetchStreamAsync(streamId);</p>
<p></code></pre></p>

<h4>After: Whizbang</h4>

<pre><code class="language-csharp">var events = _eventStore.ReadAsync<IEvent>(streamId, fromSequence: 0, ct);
<p>await foreach (var envelope in events) {</p>
<p>    // envelope.Payload contains the event</p>
<p>    // envelope.Metadata contains correlation ID, timestamp, etc.</p>
<p>}</p>
<p></code></pre></p>

<h2>Working with Message Envelopes</h2>

<p>Whizbang wraps events in <code>MessageEnvelope<T></code> for metadata:</p>

<pre><code class="language-csharp">public class OrderService {
<p>  private readonly IEventStore _eventStore;</p>

<p>  public async Task CreateOrderAsync(CreateOrderCommand command, CancellationToken ct) {</p>
<p>    var orderId = Guid.NewGuid();</p>
<p>    var @event = new OrderCreated(orderId, command.CustomerId, command.Items);</p>

<p>    // Option 1: Simple append (envelope created automatically)</p>
<p>    await _eventStore.AppendAsync(orderId, @event, ct);</p>

<p>    // Option 2: Explicit envelope with custom metadata</p>
<p>    var envelope = new MessageEnvelope<OrderCreated> {</p>
<p>      MessageId = MessageId.New(),</p>
<p>      Payload = @event,</p>
<p>      CorrelationId = command.CorrelationId,</p>
<p>      Metadata = new Dictionary<string, string> {</p>
<p>        ["tenant_id"] = command.TenantId,</p>
<p>        ["user_id"] = command.UserId.ToString()</p>
<p>      }</p>
<p>    };</p>
<p>    await _eventStore.AppendAsync(orderId, envelope, ct);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Aggregate Rehydration</h2>

<h3>Before: Marten</h3>

<pre><code class="language-csharp">await using var session = _store.LightweightSession();
<p>var order = await session.Events.AggregateStreamAsync<Order>(streamId);</p>
<p></code></pre></p>

<h3>After: Whizbang</h3>

<pre><code class="language-csharp">// Option 1: Use perspective for read model
<p>var orderView = await _perspectiveReader.GetAsync<OrderView>(streamId, ct);</p>

<p>// Option 2: Manual rehydration</p>
<p>var order = new Order();</p>
<p>await foreach (var envelope in _eventStore.ReadAsync<IOrderEvent>(streamId, 0, ct)) {</p>
<p>    order.Apply(envelope.Payload);</p>
<p>}</p>
<p></code></pre></p>

<h2>Optimistic Concurrency</h2>

<h3>Before: Marten</h3>

<pre><code class="language-csharp">await using var session = _store.LightweightSession();
<p>session.Events.Append(streamId, expectedVersion, @event);</p>
<p>await session.SaveChangesAsync(); // Throws on version mismatch</p>
<p></code></pre></p>

<h3>After: Whizbang</h3>

<pre><code class="language-csharp">try {
<p>    await _eventStore.AppendAsync(streamId, @event, expectedSequence: 5, ct);</p>
<p>}</p>
<p>catch (ConcurrencyException ex) {</p>
<p>    // Handle version conflict</p>
<p>    _logger.LogWarning("Concurrency conflict on stream {StreamId}", streamId);</p>
<p>}</p>
<p></code></pre></p>

<h2>Batch Operations</h2>

<h3>Appending Multiple Events</h3>

<pre><code class="language-csharp">// Append multiple events to the same stream atomically
<p>var events = new object[] {</p>
<p>    new OrderCreated(orderId, customerId, items),</p>
<p>    new PaymentReceived(orderId, amount),</p>
<p>    new OrderConfirmed(orderId)</p>
<p>};</p>

<p>await _eventStore.AppendBatchAsync(streamId, events, ct);</p>
<p></code></pre></p>

<h3>Multi-Stream Transactions</h3>

<pre><code class="language-csharp">// For cross-stream consistency, use IWorkCoordinator
<p>await using var work = await _workCoordinator.BeginAsync(ct);</p>

<p>await _eventStore.AppendAsync(orderStreamId, new OrderCreated(...), ct);</p>
<p>await _eventStore.AppendAsync(inventoryStreamId, new InventoryReserved(...), ct);</p>

<p>await work.CommitAsync(ct);</p>
<p></code></pre></p>

<h2>Stream Metadata</h2>

<h3>Getting Stream Info</h3>

<pre><code class="language-csharp">var lastSequence = await _eventStore.GetLastSequenceAsync(streamId, ct);
<p>var exists = lastSequence > 0;</p>
<p></code></pre></p>

<h3>Checking Stream Existence</h3>

<pre><code class="language-csharp">var exists = await _eventStore.StreamExistsAsync(streamId, ct);
<p></code></pre></p>

<h2>Schema Migration</h2>

<h3>During Migration Period</h3>

<p>Run both stores in parallel with separate schemas:</p>

<pre><code class="language-csharp">builder.Services.AddMarten(options => {
<p>    options.Connection(connectionString);</p>
<p>    options.DatabaseSchemaName = "marten"; // Existing schema</p>
<p>});</p>

<p>builder.Services.AddWhizbang(options => {</p>
<p>    options.UsePostgresEventStore(connectionString);</p>
<p>    options.SchemaName = "whizbang"; // New schema</p>
<p>});</p>
<p></code></pre></p>

<h3>Dual-Write Pattern</h3>

<p>Write to both stores during migration:</p>

<pre><code class="language-csharp">public class DualWriteEventStore : IEventStore {
<p>  private readonly IDocumentSession _martenSession;</p>
<p>  private readonly IEventStore _whizbangStore;</p>

<p>  public async Task AppendAsync<T>(Guid streamId, T @event, CancellationToken ct) {</p>
<p>    // Write to Marten (existing)</p>
<p>    _martenSession.Events.Append(streamId, @event);</p>
<p>    await _martenSession.SaveChangesAsync(ct);</p>

<p>    // Write to Whizbang (new)</p>
<p>    await _whizbangStore.AppendAsync(streamId, @event, ct);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Data Migration Script</h3>

<p>For migrating existing events:</p>

<pre><code class="language-csharp">public class EventMigrationService {
<p>  private readonly IDocumentStore _martenStore;</p>
<p>  private readonly IEventStore _whizbangStore;</p>

<p>  public async Task MigrateStreamAsync(Guid streamId, CancellationToken ct) {</p>
<p>    await using var session = _martenStore.QuerySession();</p>
<p>    var martenEvents = await session.Events.FetchStreamAsync(streamId);</p>

<p>    foreach (var martenEvent in martenEvents) {</p>
<p>      var envelope = new MessageEnvelope<object> {</p>
<p>        MessageId = MessageId.New(),</p>
<p>        Payload = martenEvent.Data,</p>
<p>        Timestamp = martenEvent.Timestamp,</p>
<p>        Metadata = new Dictionary<string, string> {</p>
<p>          ["marten_sequence"] = martenEvent.Sequence.ToString(),</p>
<p>          ["migrated_at"] = DateTimeOffset.UtcNow.ToString("O")</p>
<p>        }</p>
<p>      };</p>

<p>      await _whizbangStore.AppendAsync(streamId, envelope, ct);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Common Migration Scenarios</h2>

<p>This section documents common migration patterns from Marten event store to Whizbang. Each scenario has a unique ID for traceability to automated migration tests.</p>

<hr>

<h3>Scenario E01: Start Stream with ID Generation</h3>

<strong>Marten Pattern (Before):</strong>

<pre><code class="language-csharp">public async Task<Guid> CreateOrderAsync(CreateOrderCommand command, CancellationToken ct) {
<p>    await using var session = _store.LightweightSession();</p>

<p>    var orderId = Guid.NewGuid();</p>
<p>    session.Events.StartStream<Order>(</p>
<p>        orderId,</p>
<p>        new OrderCreated(orderId, command.CustomerId, command.Items)</p>
<p>    );</p>

<p>    await session.SaveChangesAsync(ct);</p>
<p>    return orderId;</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>

<pre><code class="language-csharp">public async Task<OrderId> CreateOrderAsync(CreateOrderCommand command, CancellationToken ct) {
<p>    var orderId = OrderId.New();</p>

<p>    await _eventStore.AppendAsync(</p>
<p>        orderId.Value,</p>
<p>        new OrderCreated(orderId, command.CustomerId, command.Items),</p>
<p>        ct);</p>

<p>    return orderId;</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>

<ul><li>No session management (open, use, dispose)</li>
<li>Strongly-typed ID (<code>OrderId</code>) instead of raw <code>Guid</code></li>
<li>Single atomic <code>AppendAsync()</code> replaces <code>StartStream</code> + <code>SaveChangesAsync()</code></li>
<li>ID generation via <code>OrderId.New()</code> uses configured <code>IWhizbangIdProvider</code></li>
</ul>
<strong>CLI Transformation:</strong>

<ul><li>[x] Supported by <code>whizbang migrate apply</code></li>
<li>Converts <code>StartStream<T>()</code> + <code>SaveChangesAsync()</code> to <code>AppendAsync()</code></li>
</ul>
<strong>Test Coverage:</strong>

<ul><li><code>TransformAsync_E01_StartStreamWithGuid_TransformsToAppendAsync</code></li>
</ul>
<hr>

<h3>Scenario E02: Basic Append to Existing Stream</h3>

<strong>Marten Pattern (Before):</strong>

<pre><code class="language-csharp">public async Task ShipOrderAsync(Guid orderId, CancellationToken ct) {
<p>    await using var session = _store.LightweightSession();</p>

<p>    session.Events.Append(orderId, new OrderShipped(orderId, DateTime.UtcNow));</p>

<p>    await session.SaveChangesAsync(ct);</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>

<pre><code class="language-csharp">public async Task ShipOrderAsync(OrderId orderId, CancellationToken ct) {
<p>    await _eventStore.AppendAsync(</p>
<p>        orderId.Value,</p>
<p>        new OrderShipped(orderId, DateTimeOffset.UtcNow),</p>
<p>        ct);</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>

<ul><li>No session boilerplate</li>
<li><code>DateTimeOffset</code> preferred over <code>DateTime</code> for explicit timezone handling</li>
<li>Single <code>AppendAsync()</code> call (no separate <code>SaveChangesAsync()</code>)</li>
</ul>
<strong>CLI Transformation:</strong>

<ul><li>[x] Supported by <code>whizbang migrate apply</code></li>
<li>Detects <code>Append()</code> + <code>SaveChangesAsync()</code> pattern</li>
</ul>
<strong>Test Coverage:</strong>

<ul><li><code>TransformAsync_E02_AppendToStream_TransformsToAppendAsync</code></li>
</ul>
<hr>

<h3>Scenario E03: Exclusive Append with Locking</h3>

<strong>Marten Pattern (Before):</strong>

<pre><code class="language-csharp">public async Task ProcessExclusiveAsync(Guid streamId, IEvent @event, CancellationToken ct) {
<p>    await using var session = _store.LightweightSession();</p>

<p>    // AppendExclusive takes a lock on the stream</p>
<p>    session.Events.AppendExclusive(streamId, @event);</p>

<p>    await session.SaveChangesAsync(ct);</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>

<pre><code class="language-csharp">public async Task ProcessExclusiveAsync(StreamId streamId, IEvent @event, CancellationToken ct) {
<p>    // Whizbang uses optimistic concurrency by default</p>
<p>    // For exclusive access, use expected sequence or distributed lock</p>
<p>    var lastSequence = await _eventStore.GetLastSequenceAsync(streamId.Value, ct);</p>

<p>    await _eventStore.AppendAsync(</p>
<p>        streamId.Value,</p>
<p>        @event,</p>
<p>        expectedSequence: lastSequence,</p>
<p>        ct);</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>

<ul><li>No built-in <code>AppendExclusive()</code> - use optimistic concurrency</li>
<li>For true exclusive access, combine with distributed locking (Redis, PostgreSQL advisory locks)</li>
<li>Consider if exclusive access is actually needed</li>
</ul>
<strong>CLI Transformation:</strong>

<ul><li>[x] Supported by <code>whizbang migrate apply</code></li>
<li>Warning: "AppendExclusive requires review - consider optimistic concurrency or distributed locks"</li>
</ul>
<strong>Test Coverage:</strong>

<ul><li><code>TransformAsync_E03_AppendExclusive_TransformsWithWarning</code></li>
</ul>
<hr>

<h3>Scenario E04: Optimistic Concurrency Append</h3>

<strong>Marten Pattern (Before):</strong>

<pre><code class="language-csharp">public async Task UpdateWithVersionAsync(Guid streamId, int expectedVersion, IEvent @event, CancellationToken ct) {
<p>    await using var session = _store.LightweightSession();</p>

<p>    session.Events.AppendOptimistic(streamId, @event);</p>
<p>    // Or: session.Events.Append(streamId, expectedVersion, @event);</p>

<p>    await session.SaveChangesAsync(ct);</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>

<pre><code class="language-csharp">public async Task UpdateWithVersionAsync(StreamId streamId, long expectedSequence, IEvent @event, CancellationToken ct) {
<p>    await _eventStore.AppendAsync(</p>
<p>        streamId.Value,</p>
<p>        @event,</p>
<p>        expectedSequence: expectedSequence,</p>
<p>        ct);</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>

<ul><li><code>expectedSequence</code> parameter provides optimistic concurrency</li>
<li>Throws <code>ConcurrencyException</code> on version mismatch</li>
<li>Sequence is <code>long</code> (not <code>int</code>) for better range</li>
</ul>
<strong>CLI Transformation:</strong>

<ul><li>[x] Supported by <code>whizbang migrate apply</code></li>
<li>Converts <code>AppendOptimistic</code> to <code>AppendAsync</code> with <code>expectedSequence</code></li>
</ul>
<strong>Test Coverage:</strong>

<ul><li><code>TransformAsync_E04_AppendOptimistic_TransformsWithExpectedSequence</code></li>
</ul>
<hr>

<h3>Scenario E05: CombGuid ID Generation</h3>

<strong>Marten Pattern (Before):</strong>

<pre><code class="language-csharp">using Marten.Schema.Identity;

<p>public async Task<Guid> CreateWithCombGuidAsync(CreateCommand command, CancellationToken ct) {</p>
<p>    await using var session = _store.LightweightSession();</p>

<p>    // CombGuid generates sequential GUIDs for better index performance</p>
<p>    var streamId = CombGuidIdGeneration.NewGuid();</p>

<p>    session.Events.StartStream<MyAggregate>(streamId, new AggregateCreated(streamId));</p>
<p>    await session.SaveChangesAsync(ct);</p>

<p>    return streamId;</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>

<pre><code class="language-csharp">public async Task<MyAggregateId> CreateWithSequentialIdAsync(CreateCommand command, CancellationToken ct) {
<p>    // TrackedGuid.NewMedo() generates sequential GUIDs (MEDO algorithm)</p>
<p>    var streamId = MyAggregateId.New(); // Uses TrackedGuid.NewMedo() internally</p>

<p>    await _eventStore.AppendAsync(</p>
<p>        streamId.Value,</p>
<p>        new AggregateCreated(streamId),</p>
<p>        ct);</p>

<p>    return streamId;</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>

<ul><li><code>TrackedGuid.NewMedo()</code> replaces <code>CombGuidIdGeneration.NewGuid()</code></li>
<li>MEDO algorithm provides similar sequential GUID benefits</li>
<li>Strongly-typed IDs encapsulate the generation strategy</li>
</ul>
<strong>CLI Transformation:</strong>

<ul><li>[x] Supported by <code>whizbang migrate apply</code></li>
<li>Converts <code>CombGuidIdGeneration.NewGuid()</code> to <code>TrackedGuid.NewMedo()</code></li>
</ul>
<strong>Test Coverage:</strong>

<ul><li><code>TransformAsync_E05_CombGuidIdGeneration_TransformsToTrackedGuid</code></li>
</ul>
<hr>

<h3>Scenario E06: Stream ID Collision Retry</h3>

<strong>Marten Pattern (Before):</strong>

<pre><code class="language-csharp">public async Task<Guid> CreateWithRetryAsync(CreateCommand command, CancellationToken ct) {
<p>    const int maxAttempts = 5;</p>

<p>    for (var attempt = 0; attempt < maxAttempts; attempt++) {</p>
<p>        try {</p>
<p>            await using var session = _store.LightweightSession();</p>

<p>            var streamId = Guid.NewGuid();</p>
<p>            session.Events.StartStream<MyAggregate>(streamId, new AggregateCreated(streamId));</p>
<p>            await session.SaveChangesAsync(ct);</p>

<p>            return streamId;</p>
<p>        }</p>
<p>        catch (Exception ex) when (ex.Message.Contains("duplicate key")) {</p>
<p>            if (attempt == maxAttempts - 1) throw;</p>
<p>            // Retry with new ID</p>
<p>        }</p>
<p>    }</p>

<p>    throw new InvalidOperationException("Failed to create stream after max attempts");</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>

<pre><code class="language-csharp">public async Task<MyAggregateId> CreateWithRetryAsync(CreateCommand command, CancellationToken ct) {
<p>    // TrackedGuid provides virtually collision-free IDs</p>
<p>    // Built-in retry policies handle rare collisions</p>
<p>    var streamId = MyAggregateId.New();</p>

<p>    await _eventStore.AppendAsync(</p>
<p>        streamId.Value,</p>
<p>        new AggregateCreated(streamId),</p>
<p>        ct);</p>

<p>    return streamId;</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>

<ul><li><code>TrackedGuid.NewMedo()</code> is virtually collision-free (timestamp + random)</li>
<li>Retry logic typically unnecessary with proper ID generation</li>
<li>If needed, use Polly or similar for retry policies</li>
</ul>
<strong>CLI Transformation:</strong>

<ul><li>[x] Supported by <code>whizbang migrate apply</code></li>
<li>Warning: "Consider if retry logic is still needed with TrackedGuid"</li>
</ul>
<strong>Test Coverage:</strong>

<ul><li><code>TransformAsync_E06_CollisionRetry_SimplifiesToSingleAppend</code></li>
</ul>
<hr>

<h3>Scenario E07: SaveChangesAsync Removal (Strategy-Based)</h3>

<strong>Marten Pattern (Before):</strong>

<pre><code class="language-csharp">public async Task ComplexOperationAsync(Guid orderId, CancellationToken ct) {
<p>    await using var session = _store.LightweightSession();</p>

<p>    session.Events.Append(orderId, new OrderUpdated(orderId, "step1"));</p>
<p>    session.Events.Append(orderId, new OrderUpdated(orderId, "step2"));</p>
<p>    session.Events.Append(orderId, new OrderUpdated(orderId, "step3"));</p>

<p>    // All events committed atomically</p>
<p>    await session.SaveChangesAsync(ct);</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>

<pre><code class="language-csharp">public async Task ComplexOperationAsync(OrderId orderId, CancellationToken ct) {
<p>    // Use batch append for multiple events to same stream</p>
<p>    var events = new IEvent[] {</p>
<p>        new OrderUpdated(orderId, "step1"),</p>
<p>        new OrderUpdated(orderId, "step2"),</p>
<p>        new OrderUpdated(orderId, "step3")</p>
<p>    };</p>

<p>    await _eventStore.AppendBatchAsync(orderId.Value, events, ct);</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>

<ul><li>No <code>SaveChangesAsync()</code> - each <code>AppendAsync()</code> is atomic</li>
<li>Use <code>AppendBatchAsync()</code> for multiple events to maintain atomicity</li>
<li>No session state management needed</li>
</ul>
<p>:::note[Persistence Strategy]</p>
<p>Whether <code>SaveChangesAsync()</code> is needed depends on your <strong>persistence strategy</strong>. Different areas of an application may use different strategies:</p>

<p>| Strategy | Behavior | SaveChanges Needed? |</p>
<p>|----------|----------|---------------------|</p>
<p>| <strong>Immediate</strong> (default) | Each <code>AppendAsync()</code> commits immediately | No |</p>
<p>| <strong>Batched</strong> | Events buffered until <code>FlushAsync()</code> | Yes (<code>FlushAsync</code>) |</p>
<p>| <strong>Outbox</strong> | Events queued for reliable delivery | No (coordinator handles) |</p>

<p>Configure per-receptor with <code>[PersistenceStrategy]</code> attribute:</p>

<pre><code class="language-csharp">// Use default strategy (configured globally)
<p>public class OrderReceptor : IReceptor<CreateOrder, OrderCreated> { }</p>

<p>// Override with specific strategy</p>
<p>[PersistenceStrategy(PersistenceMode.Immediate)]</p>
<p>public class CriticalPaymentReceptor : IReceptor<ProcessPayment, PaymentProcessed> { }</p>

<p>// Use named custom strategy from appsettings.json</p>
<p>[PersistenceStrategy("high-throughput-batch")]</p>
<p>public class EventIngestionReceptor : IReceptor<IngestEvent, EventIngested> { }</p>
<p></code></pre></p>
<p>:::</p>

<strong>CLI Transformation:</strong>

<ul><li>[x] Supported by <code>whizbang migrate apply</code></li>
<li>Detects multiple <code>Append()</code> calls and suggests <code>AppendBatchAsync()</code></li>
<li>Generates <code>[PersistenceStrategy]</code> attribute based on wizard decisions</li>
</ul>
<strong>Test Coverage:</strong>

<ul><li><code>TransformAsync_E07_MultipleAppends_TransformsToAppendBatch</code></li>
</ul>
<hr>

<h3>Scenario E08: Batch Append Without Session</h3>

<strong>Marten Pattern (Before):</strong>

<pre><code class="language-csharp">public async Task BatchCreateAsync(IReadOnlyList<CreateItemCommand> commands, CancellationToken ct) {
<p>    await using var session = _store.LightweightSession();</p>

<p>    foreach (var command in commands) {</p>
<p>        var itemId = Guid.NewGuid();</p>
<p>        session.Events.StartStream<Item>(itemId, new ItemCreated(itemId, command.Name));</p>
<p>    }</p>

<p>    await session.SaveChangesAsync(ct);</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>

<pre><code class="language-csharp">public async Task BatchCreateAsync(IReadOnlyList<CreateItemCommand> commands, CancellationToken ct) {
<p>    // For cross-stream atomicity, use work coordinator</p>
<p>    await using var work = await _workCoordinator.BeginAsync(ct);</p>

<p>    foreach (var command in commands) {</p>
<p>        var itemId = ItemId.New();</p>
<p>        await _eventStore.AppendAsync(</p>
<p>            itemId.Value,</p>
<p>            new ItemCreated(itemId, command.Name),</p>
<p>            ct);</p>
<p>    }</p>

<p>    await work.CommitAsync(ct);</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>

<ul><li>Cross-stream transactions require <code>IWorkCoordinator</code></li>
<li>Single-stream batch uses <code>AppendBatchAsync()</code></li>
<li>Each stream is independent by default</li>
</ul>
<strong>CLI Transformation:</strong>

<ul><li>[x] Supported by <code>whizbang migrate apply</code></li>
<li>Detects multi-stream batch patterns and suggests <code>IWorkCoordinator</code></li>
</ul>
<strong>Test Coverage:</strong>

<ul><li><code>TransformAsync_E08_BatchAppend_TransformsWithWorkCoordinator</code></li>
</ul>
<hr>

<h3>Scenario E09: Tenant-Scoped Event Store</h3>

<strong>Marten Pattern (Before):</strong>

<pre><code class="language-csharp">public class TenantAwareService {
<p>    private readonly IDocumentStore _store;</p>
<p>    private readonly ITenantContext _tenantContext;</p>

<p>    public async Task CreateAsync(CreateCommand command, CancellationToken ct) {</p>
<p>        // Marten session scoped to tenant</p>
<p>        await using var session = _store.LightweightSession(_tenantContext.TenantId);</p>

<p>        var id = Guid.NewGuid();</p>
<p>        session.Events.StartStream<MyAggregate>(id, new Created(id));</p>
<p>        await session.SaveChangesAsync(ct);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang Pattern (After):</strong>

<pre><code class="language-csharp">public class TenantAwareService(IEventStore eventStore, ITenantContext tenantContext) {
<p>    public async Task CreateAsync(CreateCommand command, CancellationToken ct) {</p>
<p>        // Tenant context flows through scoped DI</p>
<p>        // IEventStore is already tenant-aware via DI scope</p>
<p>        var id = MyAggregateId.New();</p>

<p>        await eventStore.AppendAsync(</p>
<p>            id.Value,</p>
<p>            new Created(id),</p>
<p>            ct);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Key Differences:</strong>

<ul><li>Tenant context handled via scoped DI, not session parameter</li>
<li><code>IEventStore</code> resolves tenant from ambient context</li>
<li>No explicit tenant parameter in store operations</li>
</ul>
<strong>CLI Transformation:</strong>

<ul><li>[x] Supported by <code>whizbang migrate apply</code></li>
<li>Warning: "Ensure ITenantContext is registered as scoped service"</li>
</ul>
<strong>Test Coverage:</strong>

<ul><li><code>TransformAsync_E09_TenantScopedSession_TransformsToScopedEventStore</code></li>
</ul>
<hr>

<h2>Scenario Coverage Matrix</h2>

<p>| Scenario | Pattern | CLI Support | Test |</p>
<p>|----------|---------|-------------|------|</p>
<p>| E01 | StartStream with ID | ✅ Full | ✅ |</p>
<p>| E02 | Basic Append | ✅ Full | ✅ |</p>
<p>| E03 | AppendExclusive | ⚠️ Warning | ✅ |</p>
<p>| E04 | AppendOptimistic | ✅ Full | ✅ |</p>
<p>| E05 | CombGuid ID | ✅ Full | ✅ |</p>
<p>| E06 | Collision Retry | ⚠️ Warning | ✅ |</p>
<p>| E07 | SaveChangesAsync | ✅ Full | ✅ |</p>
<p>| E08 | Batch Append | ✅ Full | ✅ |</p>
<p>| E09 | Tenant-Scoped | ⚠️ Warning | ✅ |</p>

<hr>

<h2>Checklist</h2>

<ul><li>[ ] Replace <code>IDocumentStore</code> injection with <code>IEventStore</code></li>
<li>[ ] Replace <code>IDocumentSession</code> usage with direct <code>IEventStore</code> methods</li>
<li>[ ] Convert <code>StartStream<T>()</code> to <code>AppendAsync()</code> with new GUID</li>
<li>[ ] Convert <code>Append()</code> + <code>SaveChangesAsync()</code> to single <code>AppendAsync()</code></li>
<li>[ ] Convert <code>FetchStreamAsync()</code> to <code>ReadAsync()</code></li>
<li>[ ] Update optimistic concurrency checks</li>
<li>[ ] Plan data migration strategy (dual-write vs batch migration)</li>
<li>[ ] Configure separate schemas during migration period</li>
<li>[ ] Update tests to use Whizbang test fixtures</li>
</ul>
<h2>Next Steps</h2>

<ul><li><a href="./06-transport-configuration.md">Transport Configuration</a> - Configure messaging transports</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="migrate-from-marten-wolverine-06-transport-configuration" class="doc-section">
  <h2>06 transport configuration</h2>
  <p class="doc-path"><code>migrate-from-marten-wolverine/06-transport-configuration</code></p>
  <div class="doc-content">
<h1>Migrate from Marten/Wolverine: Transport Configuration</h1>

<p>This guide covers configuring message transports when migrating from Wolverine to Whizbang.</p>

<h2>Overview</h2>

<p>| Wolverine | Whizbang |</p>
<p>|-----------|----------|</p>
<p>| <code>UseRabbitMq()</code> | <code>AddRabbitMQTransport()</code> |</p>
<p>| <code>UseAzureServiceBus()</code> | <code>AddAzureServiceBusTransport()</code> |</p>
<p>| <code>ListenToRabbitQueue()</code> | <code>AddSubscription()</code> |</p>
<p>| <code>PublishToRabbitExchange()</code> | <code>AddPublication()</code> |</p>

<h2>Basic Configuration</h2>

<h3>RabbitMQ</h3>

<h4>Before: Wolverine</h4>

<pre><code class="language-csharp">builder.Host.UseWolverine(opts => {
<p>    opts.UseRabbitMq(rabbit => {</p>
<p>        rabbit.HostName = "localhost";</p>
<p>    })</p>
<p>    .AutoProvision();</p>

<p>    opts.ListenToRabbitQueue("orders");</p>
<p>    opts.PublishAllMessages().ToRabbitExchange("events");</p>
<p>});</p>
<p></code></pre></p>

<h4>After: Whizbang</h4>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.AddRabbitMQTransport(rabbit => {</p>
<p>        rabbit.ConnectionString = "amqp://guest:guest@localhost:5672";</p>
<p>        rabbit.AutoCreateTopology = true;</p>
<p>    });</p>

<p>    rabbit.AddSubscription<OrderCreated>("orders");</p>
<p>    rabbit.AddPublication<OrderCreated>("events");</p>
<p>});</p>
<p></code></pre></p>

<h3>Azure Service Bus</h3>

<h4>Before: Wolverine</h4>

<pre><code class="language-csharp">builder.Host.UseWolverine(opts => {
<p>    opts.UseAzureServiceBus(connectionString)</p>
<p>        .AutoProvision();</p>

<p>    opts.ListenToAzureServiceBusQueue("orders");</p>
<p>    opts.PublishAllMessages().ToAzureServiceBusTopic("events");</p>
<p>});</p>
<p></code></pre></p>

<h4>After: Whizbang</h4>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.AddAzureServiceBusTransport(asb => {</p>
<p>        asb.ConnectionString = connectionString;</p>
<p>        asb.AutoCreateTopology = true;</p>
<p>    });</p>

<p>    asb.AddSubscription<OrderCreated>("orders");</p>
<p>    asb.AddPublication<OrderCreated>("events", topicName: "events");</p>
<p>});</p>
<p></code></pre></p>

<h2>Runtime Transport Switching</h2>

<p>For environments using RabbitMQ locally and Azure Service Bus in production:</p>

<pre><code class="language-csharp">var useRabbitMQ = builder.Configuration.GetValue<bool>("UseRabbitMQ");

<p>builder.Services.AddWhizbang(options => {</p>
<p>    if (useRabbitMQ) {</p>
<p>        options.AddRabbitMQTransport(rabbit => {</p>
<p>            rabbit.ConnectionString = builder.Configuration</p>
<p>                .GetConnectionString("RabbitMQ")!;</p>
<p>        });</p>
<p>    }</p>
<p>    else {</p>
<p>        options.AddAzureServiceBusTransport(asb => {</p>
<p>            asb.ConnectionString = builder.Configuration</p>
<p>                .GetConnectionString("ServiceBus")!;</p>
<p>        });</p>
<p>    }</p>
<p>});</p>
<p></code></pre></p>

<h3>Configuration-Based Approach</h3>

<pre><code class="language-json">// appsettings.Development.json
<p>{</p>
<p>  "Transport": {</p>
<p>    "Type": "RabbitMQ",</p>
<p>    "ConnectionString": "amqp://guest:guest@localhost:5672"</p>
<p>  }</p>
<p>}</p>

<p>// appsettings.Production.json</p>
<p>{</p>
<p>  "Transport": {</p>
<p>    "Type": "AzureServiceBus",</p>
<p>    "ConnectionString": "Endpoint=sb://..."</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<pre><code class="language-csharp">var transportType = builder.Configuration["Transport:Type"];
<p>var connectionString = builder.Configuration["Transport:ConnectionString"];</p>

<p>builder.Services.AddWhizbang(options => {</p>
<p>    switch (transportType) {</p>
<p>        case "RabbitMQ":</p>
<p>            options.AddRabbitMQTransport(r => r.ConnectionString = connectionString);</p>
<p>            break;</p>
<p>        case "AzureServiceBus":</p>
<p>            options.AddAzureServiceBusTransport(a => a.ConnectionString = connectionString);</p>
<p>            break;</p>
<p>        default:</p>
<p>            options.AddInMemoryTransport(); // For testing</p>
<p>            break;</p>
<p>    }</p>
<p>});</p>
<p></code></pre></p>

<h2>Domain Ownership</h2>

<p>In microservice architectures, services <strong>own</strong> specific domains. Commands to owned domains route to that service's inbox, while events are published to domain-specific topics for any interested subscriber.</p>

<h3>Declaring Domain Ownership</h3>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    // Declare which domains this service owns</p>
<p>    options.Routing.OwnDomains("orders", "inventory");</p>
<p>});</p>
<p></code></pre></p>

<p>Domain ownership affects:</p>
<ul><li><strong>Inbound commands</strong>: Commands targeting owned domains route to this service</li>
<li><strong>Outbound events</strong>: Events are published to domain-specific topics</li>
</ul>
<h3>Configuration-Based Ownership</h3>

<pre><code class="language-json">// appsettings.json
<p>{</p>
<p>  "Whizbang": {</p>
<p>    "Routing": {</p>
<p>      "OwnedDomains": ["orders", "inventory"]</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    var domains = builder.Configuration</p>
<p>        .GetSection("Whizbang:Routing:OwnedDomains")</p>
<p>        .Get<string[]>() ?? [];</p>
<p>    options.Routing.OwnDomains(domains);</p>
<p>});</p>
<p></code></pre></p>

<h2>Inbox & Outbox Routing Strategies</h2>

<p>Whizbang separates <strong>inbox</strong> (receiving commands) and <strong>outbox</strong> (publishing events) routing strategies.</p>

<h3>Inbox Strategies</h3>

<p>The inbox strategy determines how this service receives commands.</p>

<h4>SharedTopicInboxStrategy (Default)</h4>

<p>All commands route to a single shared topic with broker-side filtering:</p>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.Routing.OwnDomains("orders", "inventory");</p>
<p>    options.Routing.Inbox.UseSharedTopic(); // Default: "whizbang.inbox"</p>
<p>    // Or with custom topic:</p>
<p>    options.Routing.Inbox.UseSharedTopic("commands.inbox");</p>
<p>});</p>
<p></code></pre></p>

<strong>How it works</strong>:
<ul><li>All services publish commands to <code>whizbang.inbox</code></li>
<li>Commands include a <code>Destination</code> property (domain name)</li>
<li>Broker filters messages: only commands where <code>Destination</code> matches owned domains are delivered</li>
<li><strong>Pros</strong>: Fewer topics, centralized command routing</li>
<li><strong>Cons</strong>: Requires broker-side filtering (ASB CorrelationFilter, RabbitMQ routing keys)</li>
</ul>
<h4>DomainTopicInboxStrategy</h4>

<p>Each domain has its own inbox topic:</p>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.Routing.OwnDomains("orders", "inventory");</p>
<p>    options.Routing.Inbox.UseDomainTopics(); // Default suffix: ".inbox"</p>
<p>    // Or with custom suffix:</p>
<p>    options.Routing.Inbox.UseDomainTopics(".in");</p>
<p>});</p>
<p></code></pre></p>

<strong>How it works</strong>:
<ul><li>Commands to <code>orders</code> domain → <code>orders.inbox</code> topic</li>
<li>Commands to <code>inventory</code> domain → <code>inventory.inbox</code> topic</li>
<li>Service subscribes to all owned domain inboxes</li>
<li><strong>Pros</strong>: Simple routing, no broker-side filtering needed</li>
<li><strong>Cons</strong>: More topics to manage</li>
</ul>
<h3>Outbox Strategies</h3>

<p>The outbox strategy determines how this service publishes events.</p>

<h4>DomainTopicOutboxStrategy (Default)</h4>

<p>Each domain publishes to its own topic:</p>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.Routing.OwnDomains("orders");</p>
<p>    options.Routing.Outbox.UseDomainTopics(); // Default</p>
<p>});</p>
<p></code></pre></p>

<strong>How it works</strong>:
<ul><li><code>OrderCreated</code> event → published to <code>orders</code> topic</li>
<li>Domain extracted from namespace or type name</li>
<li><strong>Pros</strong>: Clear domain separation, easy subscription filtering</li>
<li><strong>Cons</strong>: Subscribers must know which domains they need</li>
</ul>
<h4>SharedTopicOutboxStrategy</h4>

<p>All events publish to a single shared topic:</p>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.Routing.Outbox.UseSharedTopic(); // Default: "whizbang.events"</p>
<p>    // Or with custom topic:</p>
<p>    options.Routing.Outbox.UseSharedTopic("all.events");</p>
<p>});</p>
<p></code></pre></p>

<strong>How it works</strong>:
<ul><li>All events → <code>whizbang.events</code> topic</li>
<li>Domain included in message metadata</li>
<li><strong>Pros</strong>: Single topic for all events, simpler topology</li>
<li><strong>Cons</strong>: Requires metadata-based filtering for subscribers</li>
</ul>
<h3>Combined Configuration</h3>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.Routing</p>
<p>        .OwnDomains("orders", "inventory")</p>
<p>        .ConfigureInbox(inbox => inbox.UseSharedTopic())    // Recommended default</p>
<p>        .ConfigureOutbox(outbox => outbox.UseDomainTopics()); // Recommended default</p>
<p>});</p>
<p></code></pre></p>

<h3>Custom Routing Strategies</h3>

<p>Implement custom strategies for specialized routing:</p>

<pre><code class="language-csharp">public class TenantAwareInboxStrategy : IInboxRoutingStrategy {
<p>    public InboxSubscription GetSubscription(</p>
<p>        IReadOnlySet<string> ownedDomains,</p>
<p>        string serviceName,</p>
<p>        MessageKind kind) {</p>
<p>        // Custom logic: e.g., tenant-specific inbox</p>
<p>        return new InboxSubscription(</p>
<p>            Topic: $"{serviceName}.inbox",</p>
<p>            FilterExpression: string.Join(",", ownedDomains)</p>
<p>        );</p>
<p>    }</p>
<p>}</p>

<p>builder.Services.AddWhizbang(options => {</p>
<p>    options.Routing.Inbox.UseCustom(new TenantAwareInboxStrategy());</p>
<p>});</p>
<p></code></pre></p>

<h2>Message Routing</h2>

<h3>Queue/Topic Configuration</h3>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.ConfigureTransport(transport => {</p>
<p>        // Subscribe to specific message types</p>
<p>        transport.AddSubscription<CreateOrderCommand>("commands.orders");</p>
<p>        transport.AddSubscription<OrderCreated>("events.orders");</p>

<p>        // Publish specific message types</p>
<p>        transport.AddPublication<OrderCreated>("events");</p>
<p>        transport.AddPublication<OrderShipped>("events");</p>

<p>        // Publish all messages of a base type</p>
<p>        transport.AddPublication<IEvent>("events");</p>
<p>    });</p>
<p>});</p>
<p></code></pre></p>

<h3>Topic Routing Strategies</h3>

<p>Whizbang provides flexible topic routing strategies for dynamic message routing.</p>

<h4>NamespaceRoutingStrategy</h4>

<p>Routes messages to topics based on namespace patterns. Useful for projects with either hierarchical or flat namespace structures.</p>

<pre><code class="language-csharp">// Default behavior:
<p>// - MyApp.Orders.Events.OrderCreated → "orders"</p>
<p>// - MyApp.Contracts.Commands.CreateOrder → "order"</p>
<p>builder.Services.AddWhizbang(options => {</p>
<p>    options.TopicRouting.UseNamespaceRouting();</p>
<p>});</p>

<p>// Custom extraction logic</p>
<p>builder.Services.AddWhizbang(options => {</p>
<p>    options.TopicRouting.UseNamespaceRouting(type => {</p>
<p>        // Use [Topic] attribute if present, else default</p>
<p>        var attr = type.GetCustomAttribute<TopicAttribute>();</p>
<p>        return attr?.Name ?? NamespaceRoutingStrategy.DefaultTypeToTopic(type);</p>
<p>    });</p>
<p>});</p>
<p></code></pre></p>

<strong>How it works:</strong>

<p>| Namespace/Type | Extracted Topic |</p>
<p>|----------------|-----------------|</p>
<p>| <code>MyApp.Orders.Events.OrderCreated</code> | <code>orders</code> |</p>
<p>| <code>MyApp.Contracts.Commands.CreateOrder</code> | <code>order</code> |</p>
<p>| <code>MyApp.Contracts.Events.OrderCreated</code> | <code>order</code> |</p>
<p>| <code>MyApp.Contracts.Queries.GetOrderById</code> | <code>order</code> |</p>

<p>The strategy:</p>
<ul><li>Uses the second-to-last namespace segment for hierarchical namespaces</li>
<li>Skips generic segments (<code>contracts</code>, <code>commands</code>, <code>events</code>, <code>queries</code>, <code>messages</code>)</li>
<li>Falls back to extracting domain from type name (removes prefixes/suffixes)</li>
</ul>
<h4>CompositeTopicRoutingStrategy</h4>

<p>Chain multiple strategies together:</p>

<pre><code class="language-csharp">var composite = new CompositeTopicRoutingStrategy(
<p>    new NamespaceRoutingStrategy(),</p>
<p>    new PoolSuffixRoutingStrategy("01")</p>
<p>);</p>

<p>// orders → orders-01</p>
<p></code></pre></p>

<h3>Consumer Groups</h3>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.ConfigureTransport(transport => {</p>
<p>        // Competing consumers (only one instance handles each message)</p>
<p>        transport.AddSubscription<OrderCreated>("orders", options => {</p>
<p>            options.ConsumerGroup = "order-processor";</p>
<p>            options.ConcurrentConsumers = 5;</p>
<p>        });</p>

<p>        // Broadcast (all instances receive each message)</p>
<p>        transport.AddSubscription<CacheInvalidated>("cache", options => {</p>
<p>            options.Broadcast = true;</p>
<p>        });</p>
<p>    });</p>
<p>});</p>
<p></code></pre></p>

<h2>Dead Letter Handling</h2>

<h3>Configuration</h3>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.ConfigureTransport(transport => {</p>
<p>        transport.AddSubscription<OrderCreated>("orders", options => {</p>
<p>            options.MaxRetries = 3;</p>
<p>            options.RetryDelay = TimeSpan.FromSeconds(5);</p>
<p>            options.DeadLetterQueue = "orders-dlq";</p>
<p>        });</p>
<p>    });</p>
<p>});</p>
<p></code></pre></p>

<h3>Dead Letter Processing</h3>

<pre><code class="language-csharp">public class DeadLetterReceptor : IReceptor<DeadLetterMessage, Unit> {
<p>  private readonly ILogger<DeadLetterReceptor> _logger;</p>

<p>  public DeadLetterReceptor(ILogger<DeadLetterReceptor> logger) {</p>
<p>    _logger = logger;</p>
<p>  }</p>

<p>  public ValueTask<Unit> HandleAsync(DeadLetterMessage message, CancellationToken ct) {</p>
<p>    _logger.LogError(</p>
<p>        "Dead letter received: {MessageType}, Reason: {Reason}",</p>
<p>        message.OriginalType,</p>
<p>        message.FailureReason);</p>

<p>    // Handle dead letter (alert, store for manual review, etc.)</p>
<p>    return ValueTask.FromResult(Unit.Value);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Serialization</h2>

<h3>JSON Serialization (Default)</h3>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.ConfigureTransport(transport => {</p>
<p>        transport.UseJsonSerialization(json => {</p>
<p>            json.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;</p>
<p>            json.WriteIndented = false;</p>
<p>        });</p>
<p>    });</p>
<p>});</p>
<p></code></pre></p>

<h3>Custom Serialization</h3>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.ConfigureTransport(transport => {</p>
<p>        transport.UseSerializer<MyCustomSerializer>();</p>
<p>    });</p>
<p>});</p>
<p></code></pre></p>

<h2>Aspire Integration</h2>

<p>For .NET Aspire-based applications:</p>

<pre><code class="language-csharp">// In AppHost
<p>var rabbitmq = builder.AddRabbitMQ("messaging");</p>
<p>var serviceBus = builder.AddAzureServiceBus("messaging");</p>

<p>var orderService = builder.AddProject<Projects.OrderService>()</p>
<p>    .WithReference(rabbitmq); // or serviceBus</p>

<p>// In OrderService</p>
<p>builder.AddWhizbangWithAspire(); // Auto-configures from Aspire connection</p>
<p></code></pre></p>

<h2>Migration Strategy</h2>

<h3>Parallel Running</h3>

<p>Run both Wolverine and Whizbang simultaneously:</p>

<pre><code class="language-csharp">// Keep Wolverine temporarily
<p>builder.Host.UseWolverine(opts => {</p>
<p>    opts.UseRabbitMq().AutoProvision();</p>
<p>    opts.ListenToRabbitQueue("orders-wolverine");</p>
<p>});</p>

<p>// Add Whizbang on different queues</p>
<p>builder.Services.AddWhizbang(options => {</p>
<p>    options.AddRabbitMQTransport(r => r.ConnectionString = connectionString);</p>
<p>    options.ConfigureTransport(t => {</p>
<p>        t.AddSubscription<OrderCreated>("orders-whizbang");</p>
<p>    });</p>
<p>});</p>
<p></code></pre></p>

<h3>Gradual Queue Migration</h3>

<ul><li>Create new queues with <code>-v2</code> suffix</li>
<li>Configure Whizbang to consume from new queues</li>
<li>Update publishers to send to both old and new queues</li>
<li>Monitor and validate</li>
<li>Switch consumers to new queues only</li>
<li>Remove old queue configuration</li>
</ul>
<h2>Checklist</h2>

<ul><li>[ ] Identify all Wolverine transport configurations</li>
<li>[ ] Map queue/topic names between frameworks</li>
<li>[ ] Configure Whizbang transport (RabbitMQ or Azure Service Bus)</li>
<li>[ ] Set up message routing (subscriptions and publications)</li>
<li>[ ] Configure dead letter handling</li>
<li>[ ] Test with in-memory transport first</li>
<li>[ ] Plan parallel running strategy</li>
<li>[ ] Update connection strings in configuration</li>
<li>[ ] Verify message serialization compatibility</li>
</ul>
<h2>Next Steps</h2>

<ul><li><a href="./07-outbox-migration.md">Outbox Migration</a> - Migrate durable outbox patterns</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="migrate-from-marten-wolverine-07-outbox-migration" class="doc-section">
  <h2>07 outbox migration</h2>
  <p class="doc-path"><code>migrate-from-marten-wolverine/07-outbox-migration</code></p>
  <div class="doc-content">
<h1>Migrate from Marten/Wolverine: Outbox Migration</h1>

<p>This guide covers migrating from Wolverine's durable outbox to Whizbang's <code>IWorkCoordinator</code>.</p>

<h2>Overview</h2>

<p>| Wolverine | Whizbang |</p>
<p>|-----------|----------|</p>
<p>| <code>UseDurableOutbox()</code> | Built-in via <code>IWorkCoordinator</code> |</p>
<p>| <code>IMessageContext</code> | <code>IWorkCoordinator</code> |</p>
<p>| Message envelope persistence | Automatic with event store |</p>

<h2>Basic Outbox Usage</h2>

<h3>Before: Wolverine Durable Outbox</h3>

<pre><code class="language-csharp">public class OrderHandler : IHandle<CreateOrderCommand> {
<p>  public async Task Handle(CreateOrderCommand command, IMessageContext context) {</p>
<p>    var orderId = Guid.NewGuid();</p>
<p>    var @event = new OrderCreated(orderId, command.CustomerId);</p>

<p>    // Outbox ensures event is sent even if process crashes</p>
<p>    await context.SendAsync(new ProcessPaymentCommand(orderId));</p>
<p>    await context.PublishAsync(@event);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>After: Whizbang Work Coordinator</h3>

<pre><code class="language-csharp">public class CreateOrderReceptor : IReceptor<CreateOrderCommand, OrderCreatedResult> {
<p>  private readonly IEventStore _eventStore;</p>
<p>  private readonly IWorkCoordinator _workCoordinator;</p>
<p>  private readonly IDispatcher _dispatcher;</p>

<p>  public CreateOrderReceptor(</p>
<p>    IEventStore eventStore,</p>
<p>    IWorkCoordinator workCoordinator,</p>
<p>    IDispatcher dispatcher) {</p>
<p>    _eventStore = eventStore;</p>
<p>    _workCoordinator = workCoordinator;</p>
<p>    _dispatcher = dispatcher;</p>
<p>  }</p>

<p>  public async ValueTask<OrderCreatedResult> HandleAsync(</p>
<p>    CreateOrderCommand command,</p>
<p>    CancellationToken ct) {</p>

<p>    var orderId = Guid.NewGuid();</p>
<p>    var @event = new OrderCreated(orderId, command.CustomerId);</p>

<p>    // Begin coordinated work unit</p>
<p>    await using var work = await _workCoordinator.BeginAsync(ct);</p>

<p>    // Append event (persisted to outbox)</p>
<p>    await _eventStore.AppendAsync(orderId, @event, ct);</p>

<p>    // Schedule outgoing messages (persisted to outbox)</p>
<p>    await work.ScheduleAsync(new ProcessPaymentCommand(orderId));</p>
<p>    await work.ScheduleAsync(@event); // For publishing</p>

<p>    // Commit atomically - events and messages are sent together</p>
<p>    await work.CommitAsync(ct);</p>

<p>    return new OrderCreatedResult(orderId);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Work Coordinator Patterns</h2>

<h3>Transactional Consistency</h3>

<p>All operations within a work unit are atomic:</p>

<pre><code class="language-csharp">await using var work = await _workCoordinator.BeginAsync(ct);

<p>// These are all persisted together</p>
<p>await _eventStore.AppendAsync(orderStreamId, new OrderCreated(...), ct);</p>
<p>await _eventStore.AppendAsync(inventoryStreamId, new InventoryReserved(...), ct);</p>
<p>await work.ScheduleAsync(new NotifyCustomerCommand(...));</p>

<p>// If this fails, nothing is persisted</p>
<p>await work.CommitAsync(ct);</p>
<p></code></pre></p>

<h3>Automatic Retry</h3>

<p>Work coordinator handles transient failures:</p>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.ConfigureWorkCoordinator(wc => {</p>
<p>        wc.MaxRetries = 3;</p>
<p>        wc.RetryDelay = TimeSpan.FromSeconds(5);</p>
<p>        wc.ExponentialBackoff = true;</p>
<p>    });</p>
<p>});</p>
<p></code></pre></p>

<h3>Message Scheduling</h3>

<p>Schedule messages for future delivery:</p>

<pre><code class="language-csharp">await using var work = await _workCoordinator.BeginAsync(ct);

<p>// Send immediately after commit</p>
<p>await work.ScheduleAsync(new OrderConfirmation(orderId));</p>

<p>// Send after delay</p>
<p>await work.ScheduleAsync(</p>
<p>    new OrderReminderEmail(orderId),</p>
<p>    delay: TimeSpan.FromHours(24));</p>

<p>// Send at specific time</p>
<p>await work.ScheduleAsync(</p>
<p>    new OrderExpirationCheck(orderId),</p>
<p>    deliverAt: DateTimeOffset.UtcNow.AddDays(30));</p>

<p>await work.CommitAsync(ct);</p>
<p></code></pre></p>

<h2>Saga/Process Manager Migration</h2>

<h3>Before: Wolverine Saga</h3>

<pre><code class="language-csharp">public class OrderSaga : Saga {
<p>  public Guid OrderId { get; set; }</p>
<p>  public bool PaymentReceived { get; set; }</p>
<p>  public bool InventoryReserved { get; set; }</p>

<p>  public void Handle(OrderCreated @event) {</p>
<p>    OrderId = @event.OrderId;</p>
<p>  }</p>

<p>  public async Task Handle(PaymentReceived @event, IMessageContext context) {</p>
<p>    PaymentReceived = true;</p>
<p>    await CheckCompletion(context);</p>
<p>  }</p>

<p>  public async Task Handle(InventoryReserved @event, IMessageContext context) {</p>
<p>    InventoryReserved = true;</p>
<p>    await CheckCompletion(context);</p>
<p>  }</p>

<p>  private async Task CheckCompletion(IMessageContext context) {</p>
<p>    if (PaymentReceived && InventoryReserved) {</p>
<p>      await context.PublishAsync(new OrderCompleted(OrderId));</p>
<p>      MarkCompleted();</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>After: Whizbang Process Manager</h3>

<pre><code class="language-csharp">public record OrderProcessState {
<p>  public Guid OrderId { get; init; }</p>
<p>  public bool PaymentReceived { get; init; }</p>
<p>  public bool InventoryReserved { get; init; }</p>
<p>  public bool IsComplete => PaymentReceived && InventoryReserved;</p>
<p>}</p>

<p>public class OrderProcessPerspective</p>
<p>  : IPerspectiveFor<OrderProcessState, OrderCreated, PaymentReceived, InventoryReserved> {</p>

<p>  public OrderProcessState Apply(OrderProcessState? current, OrderCreated @event) {</p>
<p>    return new OrderProcessState { OrderId = @event.OrderId };</p>
<p>  }</p>

<p>  public OrderProcessState Apply(OrderProcessState? current, PaymentReceived @event) {</p>
<p>    return current! with { PaymentReceived = true };</p>
<p>  }</p>

<p>  public OrderProcessState Apply(OrderProcessState? current, InventoryReserved @event) {</p>
<p>    return current! with { InventoryReserved = true };</p>
<p>  }</p>
<p>}</p>

<p>public class OrderCompletionReceptor : IReceptor<PaymentReceived, Unit>,</p>
<p>                                        IReceptor<InventoryReserved, Unit> {</p>
<p>  private readonly IEventStore _eventStore;</p>
<p>  private readonly IWorkCoordinator _workCoordinator;</p>
<p>  private readonly IPerspectiveReader _perspectives;</p>

<p>  public async ValueTask<Unit> HandleAsync(PaymentReceived @event, CancellationToken ct) {</p>
<p>    await CheckAndCompleteAsync(@event.OrderId, ct);</p>
<p>    return Unit.Value;</p>
<p>  }</p>

<p>  public async ValueTask<Unit> HandleAsync(InventoryReserved @event, CancellationToken ct) {</p>
<p>    await CheckAndCompleteAsync(@event.OrderId, ct);</p>
<p>    return Unit.Value;</p>
<p>  }</p>

<p>  private async Task CheckAndCompleteAsync(Guid orderId, CancellationToken ct) {</p>
<p>    var state = await _perspectives.GetAsync<OrderProcessState>(orderId, ct);</p>

<p>    if (state?.IsComplete == true) {</p>
<p>      await using var work = await _workCoordinator.BeginAsync(ct);</p>
<p>      await _eventStore.AppendAsync(orderId, new OrderCompleted(orderId), ct);</p>
<p>      await work.CommitAsync(ct);</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Outbox Monitoring</h2>

<h3>Health Checks</h3>

<pre><code class="language-csharp">builder.Services.AddHealthChecks()
<p>    .AddWhizbangOutbox(); // Monitors outbox queue depth</p>

<p>// Access metrics</p>
<p>app.MapGet("/metrics/outbox", async (IOutboxMetrics metrics) => {</p>
<p>    return new {</p>
<p>        PendingMessages = await metrics.GetPendingCountAsync(),</p>
<p>        OldestMessage = await metrics.GetOldestMessageAgeAsync(),</p>
<p>        ProcessingRate = metrics.GetProcessingRate()</p>
<p>    };</p>
<p>});</p>
<p></code></pre></p>

<h3>Dashboard Integration</h3>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.ConfigureWorkCoordinator(wc => {</p>
<p>        wc.EnableDashboard = true; // Enables /whizbang/outbox endpoint</p>
<p>    });</p>
<p>});</p>
<p></code></pre></p>

<h2>Configuration Options</h2>

<pre><code class="language-csharp">builder.Services.AddWhizbang(options => {
<p>    options.ConfigureWorkCoordinator(wc => {</p>
<p>        // Retry configuration</p>
<p>        wc.MaxRetries = 5;</p>
<p>        wc.InitialRetryDelay = TimeSpan.FromSeconds(1);</p>
<p>        wc.MaxRetryDelay = TimeSpan.FromMinutes(5);</p>
<p>        wc.ExponentialBackoff = true;</p>

<p>        // Processing configuration</p>
<p>        wc.BatchSize = 100;</p>
<p>        wc.ProcessingInterval = TimeSpan.FromSeconds(1);</p>

<p>        // Cleanup configuration</p>
<p>        wc.RetentionPeriod = TimeSpan.FromDays(7);</p>
<p>        wc.CleanupInterval = TimeSpan.FromHours(1);</p>

<p>        // Concurrency</p>
<p>        wc.MaxConcurrentProcessing = 10;</p>
<p>    });</p>
<p>});</p>
<p></code></pre></p>

<h2>Database Schema</h2>

<p>The work coordinator uses these tables (auto-created):</p>

<pre><code class="language-sql">-- Outbox messages pending delivery
<p>CREATE TABLE whizbang.outbox_messages (</p>
<p>    id UUID PRIMARY KEY,</p>
<p>    message_type TEXT NOT NULL,</p>
<p>    payload JSONB NOT NULL,</p>
<p>    correlation_id TEXT,</p>
<p>    created_at TIMESTAMPTZ NOT NULL,</p>
<p>    scheduled_at TIMESTAMPTZ,</p>
<p>    attempts INT DEFAULT 0,</p>
<p>    last_attempt_at TIMESTAMPTZ,</p>
<p>    last_error TEXT</p>
<p>);</p>

<p>-- Successfully processed messages (for idempotency)</p>
<p>CREATE TABLE whizbang.processed_messages (</p>
<p>    message_id UUID PRIMARY KEY,</p>
<p>    processed_at TIMESTAMPTZ NOT NULL</p>
<p>);</p>
<p></code></pre></p>

<h2>Checklist</h2>

<ul><li>[ ] Replace <code>IMessageContext</code> with <code>IWorkCoordinator</code></li>
<li>[ ] Wrap related operations in <code>BeginAsync()</code>/<code>CommitAsync()</code></li>
<li>[ ] Convert saga state to perspective</li>
<li>[ ] Convert saga handlers to receptors</li>
<li>[ ] Configure retry and cleanup policies</li>
<li>[ ] Set up outbox monitoring</li>
<li>[ ] Test failure scenarios (process crash, network issues)</li>
<li>[ ] Verify message idempotency</li>
</ul>
<h2>Next Steps</h2>

<ul><li><a href="./08-testing-migration.md">Testing Migration</a> - Update testing patterns</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="migrate-from-marten-wolverine-08-testing-migration" class="doc-section">
  <h2>08 testing migration</h2>
  <p class="doc-path"><code>migrate-from-marten-wolverine/08-testing-migration</code></p>
  <div class="doc-content">
<h1>Migrate from Marten/Wolverine: Testing Migration</h1>

<p>This guide covers migrating tests from Marten/Wolverine testing patterns to Whizbang.</p>

<h2>Overview</h2>

<p>| Marten/Wolverine | Whizbang |</p>
<p>|------------------|----------|</p>
<p>| <code>DocumentStore.CreateCleanStore()</code> | <code>WhizbangTestFixture</code> |</p>
<p>| <code>WolverineOptions.Testing()</code> | <code>WhizbangTestContext</code> |</p>
<p>| <code>ITestOutputHelper</code> | Built-in test logging |</p>
<p>| Custom test hosts | <code>WhizbangTestHost</code> |</p>

<h2>Test Fixture Setup</h2>

<h3>Before: Marten/Wolverine</h3>

<pre><code class="language-csharp">public class OrderTests : IAsyncLifetime {
<p>  private IHost _host;</p>
<p>  private IDocumentStore _store;</p>

<p>  public async Task InitializeAsync() {</p>
<p>    _host = await Host.CreateDefaultBuilder()</p>
<p>      .UseWolverine(opts => {</p>
<p>        opts.Services.AddMarten(m => {</p>
<p>          m.Connection(TestConnectionString);</p>
<p>          m.AutoCreateSchemaObjects = AutoCreate.All;</p>
<p>        });</p>
<p>      })</p>
<p>      .StartAsync();</p>

<p>    _store = _host.Services.GetRequiredService<IDocumentStore>();</p>
<p>    await _store.Advanced.Clean.DeleteAllDocumentsAsync();</p>
<p>  }</p>

<p>  public async Task DisposeAsync() {</p>
<p>    await _host.StopAsync();</p>
<p>    _host.Dispose();</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>After: Whizbang</h3>

<pre><code class="language-csharp">public class OrderTests : WhizbangTestFixture {
<p>  public OrderTests(ITestOutputHelper output) : base(output) { }</p>

<p>  protected override void ConfigureServices(IServiceCollection services) {</p>
<p>    // Add test-specific services</p>
<p>    services.AddSingleton<IPaymentGateway, MockPaymentGateway>();</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task CreateOrder_AppendsEventToStore() {</p>
<p>    // Test implementation using TestContext</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Testing Receptors</h2>

<h3>Before: Wolverine Handler Test</h3>

<pre><code class="language-csharp">[Fact]
<p>public async Task CreateOrder_StoresOrderInDatabase() {</p>
<p>  // Arrange</p>
<p>  var handler = new CreateOrderHandler(_session);</p>
<p>  var command = new CreateOrderCommand(Guid.NewGuid(), [new Item("Product1", 2)]);</p>

<p>  // Act</p>
<p>  await handler.Handle(command);</p>

<p>  // Assert</p>
<p>  var order = await _session.Query<Order>()</p>
<p>    .SingleOrDefaultAsync(o => o.CustomerId == command.CustomerId);</p>
<p>  Assert.NotNull(order);</p>
<p>}</p>
<p></code></pre></p>

<h3>After: Whizbang Receptor Test</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task CreateOrder_AppendsEventToStoreAsync() {</p>
<p>  // Arrange</p>
<p>  var receptor = TestContext.GetService<CreateOrderReceptor>();</p>
<p>  var command = new CreateOrderCommand(Guid.NewGuid(), [new Item("Product1", 2)]);</p>

<p>  // Act</p>
<p>  var result = await receptor.HandleAsync(command, CancellationToken.None);</p>

<p>  // Assert</p>
<p>  var events = await TestContext.EventStore</p>
<p>    .ReadAsync<OrderCreated>(result.OrderId, 0)</p>
<p>    .ToListAsync();</p>

<p>  await Assert.That(events).HasCount().EqualTo(1);</p>
<p>  await Assert.That(events[0].Payload.CustomerId).IsEqualTo(command.CustomerId);</p>
<p>}</p>
<p></code></pre></p>

<h2>Testing Perspectives</h2>

<h3>Before: Marten Projection Test</h3>

<pre><code class="language-csharp">[Fact]
<p>public async Task OrderProjection_CreatesViewOnOrderCreated() {</p>
<p>  // Arrange</p>
<p>  var orderId = Guid.NewGuid();</p>
<p>  var @event = new OrderCreated(orderId, Guid.NewGuid(), []);</p>

<p>  // Act</p>
<p>  using var session = _store.LightweightSession();</p>
<p>  session.Events.StartStream<Order>(orderId, @event);</p>
<p>  await session.SaveChangesAsync();</p>

<p>  // Force projection to run</p>
<p>  await _store.WaitForNonStaleProjectionDataAsync(TimeSpan.FromSeconds(5));</p>

<p>  // Assert</p>
<p>  var view = await session.LoadAsync<OrderView>(orderId);</p>
<p>  Assert.NotNull(view);</p>
<p>  Assert.Equal(OrderStatus.Created, view.Status);</p>
<p>}</p>
<p></code></pre></p>

<h3>After: Whizbang Perspective Test</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task OrderPerspective_CreatesViewOnOrderCreatedAsync() {</p>
<p>  // Arrange</p>
<p>  var perspective = new OrderPerspective();</p>
<p>  var orderId = Guid.NewGuid();</p>
<p>  var @event = new OrderCreated(orderId, Guid.NewGuid(), []);</p>

<p>  // Act - perspectives are pure functions, easy to test</p>
<p>  var view = perspective.Apply(null, @event);</p>

<p>  // Assert</p>
<p>  await Assert.That(view.Id).IsEqualTo(orderId);</p>
<p>  await Assert.That(view.Status).IsEqualTo(OrderStatus.Created);</p>
<p>}</p>

<p>[Test]</p>
<p>public async Task OrderPerspective_IntegrationTestAsync() {</p>
<p>  // Full integration test with event store</p>
<p>  var orderId = Guid.NewGuid();</p>
<p>  var createEvent = new OrderCreated(orderId, Guid.NewGuid(), []);</p>
<p>  var shipEvent = new OrderShipped(orderId, DateTimeOffset.UtcNow);</p>

<p>  await TestContext.EventStore.AppendAsync(orderId, createEvent);</p>
<p>  await TestContext.EventStore.AppendAsync(orderId, shipEvent);</p>

<p>  // Get projected view</p>
<p>  var view = await TestContext.Perspectives.GetAsync<OrderView>(orderId);</p>

<p>  await Assert.That(view).IsNotNull();</p>
<p>  await Assert.That(view!.Status).IsEqualTo(OrderStatus.Shipped);</p>
<p>}</p>
<p></code></pre></p>

<h2>Testing Dispatchers</h2>

<h3>Before: Wolverine Message Testing</h3>

<pre><code class="language-csharp">[Fact]
<p>public async Task CreateOrder_PublishesOrderCreatedEvent() {</p>
<p>  // Arrange</p>
<p>  var recorder = new MessageRecorder();</p>
<p>  var handler = new CreateOrderHandler(_session, recorder);</p>

<p>  // Act</p>
<p>  await handler.Handle(new CreateOrderCommand(...));</p>

<p>  // Assert</p>
<p>  Assert.Single(recorder.Published.OfType<OrderCreated>());</p>
<p>}</p>
<p></code></pre></p>

<h3>After: Whizbang Dispatcher Testing</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task CreateOrder_PublishesOrderCreatedEventAsync() {</p>
<p>  // Arrange</p>
<p>  var receptor = TestContext.GetService<CreateOrderReceptor>();</p>

<p>  // Act</p>
<p>  await receptor.HandleAsync(new CreateOrderCommand(...), CancellationToken.None);</p>

<p>  // Assert - check dispatched messages</p>
<p>  var published = TestContext.Dispatcher.PublishedMessages;</p>
<p>  await Assert.That(published.OfType<OrderCreated>()).HasCount().EqualTo(1);</p>
<p>}</p>
<p></code></pre></p>

<h2>Test Doubles</h2>

<h3>Mock Event Store</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task Receptor_HandlesEventStoreFailureAsync() {</p>
<p>  // Arrange</p>
<p>  var mockEventStore = TestContext.GetMock<IEventStore>();</p>
<p>  mockEventStore.AppendAsync(Arg.Any<Guid>(), Arg.Any<object>(), Arg.Any<CancellationToken>())</p>
<p>    .ThrowsAsync(new EventStoreException("Connection failed"));</p>

<p>  var receptor = new CreateOrderReceptor(mockEventStore, TestContext.Dispatcher);</p>

<p>  // Act & Assert</p>
<p>  await Assert.ThrowsAsync<EventStoreException>(</p>
<p>    async () => await receptor.HandleAsync(new CreateOrderCommand(...), CancellationToken.None));</p>
<p>}</p>
<p></code></pre></p>

<h3>In-Memory Transport</h3>

<pre><code class="language-csharp">public class IntegrationTests : WhizbangTestFixture {
<p>  protected override void ConfigureTransport(ITransportConfiguration transport) {</p>
<p>    transport.UseInMemory(); // Messages processed synchronously</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task OrderCreated_TriggersPaymentProcessingAsync() {</p>
<p>    // Publish event</p>
<p>    await TestContext.Dispatcher.PublishAsync(new OrderCreated(...));</p>

<p>    // Verify downstream receptor was invoked</p>
<p>    var paymentCommands = TestContext.Dispatcher.SentMessages</p>
<p>      .OfType<ProcessPaymentCommand>();</p>

<p>    await Assert.That(paymentCommands).HasCount().EqualTo(1);</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Scenario Testing</h2>

<h3>Before: Wolverine Scenario</h3>

<pre><code class="language-csharp">[Fact]
<p>public async Task CompleteOrderWorkflow() {</p>
<p>  await using var host = await WolverineHost.For(opts => {</p>
<p>    opts.Services.AddMarten(...);</p>
<p>    opts.PublishAllMessages().Locally();</p>
<p>  });</p>

<p>  var bus = host.Services.GetRequiredService<IMessageBus>();</p>

<p>  // Execute scenario</p>
<p>  await bus.InvokeAsync(new CreateOrderCommand(...));</p>
<p>  await bus.InvokeAsync(new ProcessPaymentCommand(...));</p>

<p>  // Assert final state</p>
<p>  var session = host.Services.GetRequiredService<IDocumentSession>();</p>
<p>  var order = await session.LoadAsync<Order>(orderId);</p>
<p>  Assert.Equal(OrderStatus.Paid, order.Status);</p>
<p>}</p>
<p></code></pre></p>

<h3>After: Whizbang Scenario</h3>

<pre><code class="language-csharp">[Test]
<p>public async Task CompleteOrderWorkflowAsync() {</p>
<p>  // Create order</p>
<p>  var createResult = await TestContext.Dispatcher</p>
<p>    .LocalInvokeAsync<CreateOrderCommand, OrderCreatedResult>(</p>
<p>      new CreateOrderCommand(customerId, items));</p>

<p>  // Process payment</p>
<p>  await TestContext.Dispatcher</p>
<p>    .LocalInvokeAsync<ProcessPaymentCommand, PaymentResult>(</p>
<p>      new ProcessPaymentCommand(createResult.OrderId, 100m));</p>

<p>  // Assert final state</p>
<p>  var view = await TestContext.Perspectives.GetAsync<OrderView>(createResult.OrderId);</p>
<p>  await Assert.That(view!.Status).IsEqualTo(OrderStatus.Paid);</p>
<p>}</p>
<p></code></pre></p>

<h2>Test Data Builders</h2>

<h3>Fluent Test Data</h3>

<pre><code class="language-csharp">public static class TestData {
<p>  public static CreateOrderCommandBuilder CreateOrder() => new();</p>
<p>}</p>

<p>public class CreateOrderCommandBuilder {</p>
<p>  private Guid _customerId = Guid.NewGuid();</p>
<p>  private List<OrderItem> _items = [new("Default", 1, 10m)];</p>

<p>  public CreateOrderCommandBuilder WithCustomer(Guid customerId) {</p>
<p>    _customerId = customerId;</p>
<p>    return this;</p>
<p>  }</p>

<p>  public CreateOrderCommandBuilder WithItems(params OrderItem[] items) {</p>
<p>    _items = items.ToList();</p>
<p>    return this;</p>
<p>  }</p>

<p>  public CreateOrderCommand Build() => new(_customerId, _items);</p>
<p>}</p>

<p>// Usage in tests</p>
<p>[Test]</p>
<p>public async Task CreateOrder_WithMultipleItemsAsync() {</p>
<p>  var command = TestData.CreateOrder()</p>
<p>    .WithItems(</p>
<p>      new OrderItem("Product1", 2, 25m),</p>
<p>      new OrderItem("Product2", 1, 50m))</p>
<p>    .Build();</p>

<p>  var result = await receptor.HandleAsync(command, CancellationToken.None);</p>
<p>  // ...</p>
<p>}</p>
<p></code></pre></p>

<h2>Database Isolation</h2>

<h3>Per-Test Schema Isolation</h3>

<pre><code class="language-csharp">public class IsolatedTests : WhizbangTestFixture {
<p>  protected override void ConfigureDatabase(IDatabaseConfiguration db) {</p>
<p>    db.UseSchemaPerTest(); // Each test gets unique schema</p>
<p>    db.CleanupAfterTest = true;</p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task Test1Async() {</p>
<p>    // Uses schema: test_isolatedtests_test1async_<guid></p>
<p>  }</p>

<p>  [Test]</p>
<p>  public async Task Test2Async() {</p>
<p>    // Uses schema: test_isolatedtests_test2async_<guid></p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Shared Database with Cleanup</h3>

<pre><code class="language-csharp">public class SharedDatabaseTests : WhizbangTestFixture {
<p>  protected override void ConfigureDatabase(IDatabaseConfiguration db) {</p>
<p>    db.UseSharedDatabase();</p>
<p>    db.CleanupBeforeTest = true; // Clean slate for each test</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Checklist</h2>

<ul><li>[ ] Replace test host setup with <code>WhizbangTestFixture</code></li>
<li>[ ] Update handler tests to receptor tests</li>
<li>[ ] Convert projection tests to perspective tests</li>
<li>[ ] Replace <code>IMessageBus</code> assertions with <code>TestContext.Dispatcher</code></li>
<li>[ ] Use <code>InMemory</code> transport for integration tests</li>
<li>[ ] Create test data builders for complex commands/events</li>
<li>[ ] Configure database isolation strategy</li>
<li>[ ] Update mock patterns for new interfaces</li>
<li>[ ] Verify all async tests end with <code>Async</code> suffix</li>
</ul>
<h2>Next Steps</h2>

<ul><li><a href="./appendix-checklist.md">Migration Checklist</a> - Complete migration checklist</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="migrate-from-marten-wolverine-09-cli-wizard" class="doc-section">
  <h2>CLI Migration Wizard</h2>
  <p class="doc-path"><code>migrate-from-marten-wolverine/09-cli-wizard</code></p>
  <p class="doc-description"><em>Interactive wizard for migrating from Marten/Wolverine to Whizbang</em></p>
  <div class="doc-content">

<h1>CLI Migration Wizard</h1>

<p>The <code>whizbang migrate</code> command provides an interactive wizard for migrating from Marten/Wolverine to Whizbang. It guides you through each decision, tracks progress, and supports reverting changes.</p>

<h2>Quick Start</h2>

<pre><code class="language-bash"># Launch the wizard (auto-detects migration state)
<p>whizbang migrate</p>

<h1>Analyze codebase without making changes</h1>
<p>whizbang migrate analyze ./src</p>

<h1>Start interactive migration</h1>
<p>whizbang migrate apply ./src --interactive</p>

<h1>Resume from decision file</h1>
<p>whizbang migrate apply ./src --decision-file decisions.json</p>
<p></code></pre></p>

<h2>Main Menu</h2>

<p>When you run <code>whizbang migrate</code>, the wizard shows a context-aware menu based on your migration state.</p>

<h3>Fresh Start (No Migration in Progress)</h3>

<pre><code class="language-">┌─────────────────────────────────────────────────────────────────┐
<p>│  Whizbang Migration Wizard                                       │</p>
<p>├─────────────────────────────────────────────────────────────────┤</p>
<p>│                                                                  │</p>
<p>│  Migrate from Marten/Wolverine to Whizbang                       │</p>
<p>│                                                                  │</p>
<p>│  [1] Analyze codebase             ○ Scan for patterns            │</p>
<p>│  [2] Start new migration          ○ Interactive wizard           │</p>
<p>│  [3] Load existing decisions      ○ From decision file           │</p>
<p>│  [4] Help                         ○ Documentation                │</p>
<p>│                                                                  │</p>
<p>│  Select option [1-4]: _                                         │</p>
<p>└─────────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<h3>Migration in Progress</h3>

<pre><code class="language-">┌─────────────────────────────────────────────────────────────────┐
<p>│  Whizbang Migration Wizard                                       │</p>
<p>├─────────────────────────────────────────────────────────────────┤</p>
<p>│                                                                  │</p>
<p>│  Migration in progress detected!                                 │</p>
<p>│  Project: /src/MyProject                                         │</p>
<p>│  Started: 2026-01-18 14:30                                       │</p>
<p>│  Progress: 23/45 handlers, 0/12 projections                      │</p>
<p>│                                                                  │</p>
<p>│  What would you like to do?                                      │</p>
<p>│                                                                  │</p>
<p>│  [1] Continue migration           ▶ Resume where left            │</p>
<p>│  [2] Review/edit decisions        ○ Change choices               │</p>
<p>│  [3] Revert all changes           ○ Git reset + clean            │</p>
<p>│  [4] Start fresh                  ○ New migration                │</p>
<p>│  [5] View status                  ○ Detailed progress            │</p>
<p>│                                                                  │</p>
<p>│  Select option [1-5]: _                                         │</p>
<p>└─────────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<h2>Interactive Wizard Mode</h2>

<p>The interactive wizard walks you through each migration decision with code previews.</p>

<h3>Category Selection</h3>

<pre><code class="language-">┌─────────────────────────────────────────────────────────────────┐
<p>│  Categories to Review                                            │</p>
<p>├─────────────────────────────────────────────────────────────────┤</p>
<p>│                                                                  │</p>
<p>│  [1] Routing Configuration        ▶ Start                       │</p>
<p>│  [2] Handlers (45 files)          ○ Pending                     │</p>
<p>│  [3] Projections (23 files)       ○ Pending                     │</p>
<p>│  [4] Event Store Operations (67)  ○ Pending                     │</p>
<p>│  [5] ID Generation (34 locations) ○ Pending                     │</p>
<p>│  [6] DI Registration (12)         ○ Pending                     │</p>
<p>│                                                                  │</p>
<p>│  Select category [1-6]: _                                       │</p>
<p>└─────────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<h3>Domain Ownership Configuration</h3>

<p>The wizard detects domain patterns in your codebase and asks which domains this service owns:</p>

<pre><code class="language-">┌─────────────────────────────────────────────────────────────────┐
<p>│  Domain Ownership Configuration                                  │</p>
<p>├─────────────────────────────────────────────────────────────────┤</p>
<p>│                                                                  │</p>
<p>│  We detected these domain patterns in your codebase:            │</p>
<p>│                                                                  │</p>
<p>│  [x] orders (45 types, from namespace) (Recommended - most common)│</p>
<p>│  [ ] inventory (12 types, from namespace)                        │</p>
<p>│  [ ] shipping (8 types, from type names)                         │</p>
<p>│                                                                  │</p>
<p>├─────────────────────────────────────────────────────────────────┤</p>
<p>│                                                                  │</p>
<p>│  Which domains does THIS service own?                           │</p>
<p>│  (Commands to owned domains route to this service)              │</p>
<p>│                                                                  │</p>
<p>│  Enter domain numbers to toggle (e.g., "1,2"), or:              │</p>
<p>│    [A] Accept current selection                                 │</p>
<p>│    [N] None - I'll configure manually                           │</p>
<p>│    [C] Custom - Enter domain names                              │</p>
<p>│                                                                  │</p>
<p>└─────────────────────────────────────────────────────────────────┘</p>

<p>  Selection: _</p>
<p></code></pre></p>

<h3>Inbox Strategy Selection</h3>

<p>After domain ownership, configure how commands are routed to this service:</p>

<pre><code class="language-">┌─────────────────────────────────────────────────────────────────┐
<p>│  Inbox Routing Strategy                                          │</p>
<p>├─────────────────────────────────────────────────────────────────┤</p>
<p>│                                                                  │</p>
<p>│  How should commands be routed to this service?                 │</p>
<p>│                                                                  │</p>
<p>├─────────────────────────────────────────────────────────────────┤</p>
<p>│                                                                  │</p>
<p>│  [A] Shared Topic (Recommended)                                 │</p>
<p>│                                                                  │</p>
<p>│      All commands route to "whizbang.inbox" with broker-side    │</p>
<p>│      filtering. Fewer topics, relies on ASB/RabbitMQ filtering. │</p>
<p>│                                                                  │</p>
<p>│      Example: CreateOrder -> "whizbang.inbox" (filter: orders)  │</p>
<p>│                                                                  │</p>
<p>├─────────────────────────────────────────────────────────────────┤</p>
<p>│                                                                  │</p>
<p>│  [B] Domain Topics                                              │</p>
<p>│                                                                  │</p>
<p>│      Each domain has its own inbox topic.                       │</p>
<p>│      More topics, simpler routing logic.                        │</p>
<p>│                                                                  │</p>
<p>│      Example: CreateOrder -> "orders.inbox"                     │</p>
<p>│                                                                  │</p>
<p>├─────────────────────────────────────────────────────────────────┤</p>
<p>│                                                                  │</p>
<p>│  Select option [A/B]: _                                         │</p>
<p>│                                                                  │</p>
<p>└─────────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<h3>Decision Points</h3>

<p>For each pattern found, you'll see the original code and conversion options:</p>

<pre><code class="language-">┌─────────────────────────────────────────────────────────────────┐
<p>│  Handler Migration [3/45]                                        │</p>
<p>├─────────────────────────────────────────────────────────────────┤</p>
<p>│                                                                  │</p>
<p>│  File: OrderHandler.cs:15                                        │</p>
<p>│                                                                  │</p>
<p>│  BEFORE:                                                         │</p>
<p>│  ┌────────────────────────────────────────────────────────────┐ │</p>
<p>│  │ public class OrderHandler : IHandle<CreateOrder> {         │ │</p>
<p>│  │   public async Task Handle(CreateOrder cmd, ...) { }       │ │</p>
<p>│  │ }                                                           │ │</p>
<p>│  └────────────────────────────────────────────────────────────┘ │</p>
<p>│                                                                  │</p>
<p>│  CONVERSION OPTIONS:                                             │</p>
<p>│                                                                  │</p>
<p>│  [A] Convert to IReceptor<CreateOrder> (Recommended)            │</p>
<p>│      ┌──────────────────────────────────────────────────────┐   │</p>
<p>│      │ public class OrderReceptor : IReceptor<CreateOrder>  │   │</p>
<p>│      │ { ... }                                               │   │</p>
<p>│      └──────────────────────────────────────────────────────┘   │</p>
<p>│                                                                  │</p>
<p>│  [B] Skip - I'll handle this manually                           │</p>
<p>│  [C] Apply to all similar handlers                              │</p>
<p>│                                                                  │</p>
<p>│  Select option [A/B/C]: _                                       │</p>
<p>└─────────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<h2>Migration Warnings</h2>

<p>The analyzer detects patterns that may require manual attention. These warnings help identify custom infrastructure that wraps or extends Marten/Wolverine.</p>

<h3>Warning Types</h3>

<p>| Warning | Description |</p>
<p>|---------|-------------|</p>
<p>| <strong>Custom Base Class</strong> | Handler inherits from a non-standard base class (not <code>IHandle<T></code>) |</p>
<p>| <strong>Unknown Interface Parameter</strong> | Handler method has an interface parameter that isn't a known Wolverine/Marten type |</p>
<p>| <strong>Custom Context Parameter</strong> | Handler has a parameter with "Context" in its name that may wrap infrastructure |</p>
<p>| <strong>Nested Handler Class</strong> | Handler is nested inside another class (affects discoverability) |</p>

<h3>Known Types (No Warning)</h3>

<p>The analyzer recognizes these standard types and won't generate warnings:</p>

<strong>Wolverine Types:</strong>
<ul><li><code>IHandle<T></code>, <code>IHandle<T, TResult></code></li>
<li><code>IMessageBus</code>, <code>IMessageContext</code>, <code>MessageContext</code></li>
</ul>
<strong>Marten Types:</strong>
<ul><li><code>IDocumentSession</code>, <code>IQuerySession</code>, <code>IDocumentStore</code></li>
</ul>
<strong>Standard Types:</strong>
<ul><li><code>CancellationToken</code>, <code>ILogger</code>, <code>ILogger<T></code>, <code>IServiceProvider</code></li>
</ul>
<h3>Custom Base Class Decisions</h3>

<p>When a handler inherits from a custom base class, you decide how to handle it <strong>per type</strong> (not per instance):</p>

<pre><code class="language-">┌─────────────────────────────────────────────────────────────────┐
<p>│  Custom Base Class Detected                                      │</p>
<p>├─────────────────────────────────────────────────────────────────┤</p>
<p>│                                                                  │</p>
<p>│  Found: BaseMessageHandler<T>                                    │</p>
<p>│  Used by: 5 handlers                                             │</p>
<p>│                                                                  │</p>
<p>│  Files:                                                          │</p>
<p>│    • src/Handlers/CreateOrderHandler.cs:12                      │</p>
<p>│    • src/Handlers/UpdateOrderHandler.cs:15                      │</p>
<p>│    • src/Handlers/DeleteOrderHandler.cs:10                      │</p>
<p>│    • src/Handlers/ShipOrderHandler.cs:8                         │</p>
<p>│    • src/Handlers/CancelOrderHandler.cs:11                      │</p>
<p>│                                                                  │</p>
<p>│  This base class may contain Marten/Wolverine infrastructure.   │</p>
<p>│  How should handlers using this base class be migrated?         │</p>
<p>│                                                                  │</p>
<p>├─────────────────────────────────────────────────────────────────┤</p>
<p>│                                                                  │</p>
<p>│  [A] Remove Inheritance (Recommended)                           │</p>
<p>│      Migrated handlers implement IReceptor directly.            │</p>
<p>│      Base class functionality must be reimplemented.            │</p>
<p>│                                                                  │</p>
<p>│  [B] Keep Inheritance                                           │</p>
<p>│      Migrated handlers keep the base class AND add IReceptor.   │</p>
<p>│      You must manually adapt the base class to work with        │</p>
<p>│      Whizbang. A TODO comment will be added.                    │</p>
<p>│                                                                  │</p>
<p>│  [C] Skip All                                                   │</p>
<p>│      Don't migrate handlers using this base class.              │</p>
<p>│      They will be left unchanged with a warning.                │</p>
<p>│                                                                  │</p>
<p>│  Select option [A/B/C]: _                                       │</p>
<p>└─────────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<p>The decision applies to <strong>all handlers</strong> using that base class type.</p>

<h3>Unknown Interface Decisions</h3>

<p>When a handler method has unknown interface parameters, you decide how to handle each interface type:</p>

<pre><code class="language-">┌─────────────────────────────────────────────────────────────────┐
<p>│  Unknown Interface Parameter Detected                            │</p>
<p>├─────────────────────────────────────────────────────────────────┤</p>
<p>│                                                                  │</p>
<p>│  Found: IEventStoreContext                                       │</p>
<p>│  Used in: 8 handler methods                                      │</p>
<p>│                                                                  │</p>
<p>│  Example usage:                                                  │</p>
<p>│  ┌────────────────────────────────────────────────────────────┐ │</p>
<p>│  │ public Task Handle(CreateOrder cmd, IEventStoreContext ctx)│ │</p>
<p>│  │ {                                                          │ │</p>
<p>│  │   ctx.AppendEvent(new OrderCreated(...));                  │ │</p>
<p>│  │ }                                                          │ │</p>
<p>│  └────────────────────────────────────────────────────────────┘ │</p>
<p>│                                                                  │</p>
<p>│  This interface may wrap Marten/Wolverine infrastructure.       │</p>
<p>│  How should this parameter be handled?                          │</p>
<p>│                                                                  │</p>
<p>├─────────────────────────────────────────────────────────────────┤</p>
<p>│                                                                  │</p>
<p>│  [A] Map to Whizbang (Recommended if it wraps event store)     │</p>
<p>│      Replace with IEventStore parameter.                        │</p>
<p>│      Calls will be transformed to Whizbang equivalents.         │</p>
<p>│                                                                  │</p>
<p>│  [B] Keep and Inject                                            │</p>
<p>│      Keep the parameter, inject via DI.                         │</p>
<p>│      You must ensure IEventStoreContext is registered.          │</p>
<p>│                                                                  │</p>
<p>│  [C] Remove Parameter                                           │</p>
<p>│      Remove the parameter entirely.                             │</p>
<p>│      You must reimplement the functionality.                    │</p>
<p>│                                                                  │</p>
<p>│  [D] Skip All                                                   │</p>
<p>│      Don't migrate handlers using this interface.               │</p>
<p>│                                                                  │</p>
<p>│  Select option [A/B/C/D]: _                                     │</p>
<p>└─────────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<h3>Nested Handler Warning</h3>

<p>Handlers nested inside static classes are flagged for review:</p>

<pre><code class="language-">┌─────────────────────────────────────────────────────────────────┐
<p>│  ⚠ Nested Handler Class                                         │</p>
<p>├─────────────────────────────────────────────────────────────────┤</p>
<p>│                                                                  │</p>
<p>│  CreateOrderHandler is nested inside OrderHandlers              │</p>
<p>│  File: src/Handlers/OrderHandlers.cs:25                         │</p>
<p>│                                                                  │</p>
<p>│  ┌────────────────────────────────────────────────────────────┐ │</p>
<p>│  │ public static class OrderHandlers {                        │ │</p>
<p>│  │   public class CreateOrderHandler : IHandle<CreateOrder> { │ │</p>
<p>│  │     ...                                                    │ │</p>
<p>│  │   }                                                        │ │</p>
<p>│  │ }                                                          │ │</p>
<p>│  └────────────────────────────────────────────────────────────┘ │</p>
<p>│                                                                  │</p>
<p>│  Consider extracting to a top-level class for better            │</p>
<p>│  discoverability with Whizbang's source generators.             │</p>
<p>│                                                                  │</p>
<p>│  [A] Extract to top-level class (Recommended)                   │</p>
<p>│  [B] Keep nested (may require manual registration)              │</p>
<p>│                                                                  │</p>
<p>│  Select option [A/B]: _                                         │</p>
<p>└─────────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<h2>Decision Files</h2>

<p>Decision files store your migration choices and progress, allowing you to:</p>
<ul><li>Resume migrations later</li>
<li>Share decisions across team members</li>
<li>Edit decisions manually in a text editor</li>
<li>Replay migrations without prompts</li>
</ul>
<h3>Default Location</h3>

<pre><code class="language-">~/.whizbang/migrations/<project-name>/decisions.json
<p></code></pre></p>

<p>This location is <strong>outside your repository</strong>, making it safe from:</p>
<ul><li>Git worktree resets</li>
<li>Branch switches</li>
<li>Accidental commits</li>
</ul>
<h3>Custom Location</h3>

<pre><code class="language-bash"># Store in custom location
<p>whizbang migrate apply ./src --interactive --decision-file ~/myproject-decisions.json</p>

<h1>Replay saved decisions</h1>
<p>whizbang migrate apply ./src --decision-file ~/myproject-decisions.json</p>
<p></code></pre></p>

<h3>Decision File Format</h3>

<pre><code class="language-json">{
<p>  "version": "1.0",</p>
<p>  "project_path": "/src/MyProject",</p>
<p>  "generated_at": "2026-01-20T10:00:00Z",</p>
<p>  "state": {</p>
<p>    "status": "in_progress",</p>
<p>    "started_at": "2026-01-18T14:30:00Z",</p>
<p>    "git_commit_before": "abc123def456",</p>
<p>    "completed_categories": ["routing", "handlers"],</p>
<p>    "current_category": "projections",</p>
<p>    "current_item": 5</p>
<p>  },</p>
<p>  "decisions": {</p>
<p>    "routing": {</p>
<p>      "owned_domains": ["orders", "inventory"],</p>
<p>      "detected_domains": ["orders", "inventory", "shipping"],</p>
<p>      "inbox_strategy": "SharedTopic",</p>
<p>      "inbox_topic": null,</p>
<p>      "inbox_suffix": null,</p>
<p>      "outbox_strategy": "DomainTopics",</p>
<p>      "outbox_topic": null,</p>
<p>      "confirmed": true</p>
<p>    },</p>
<p>    "handlers": {</p>
<p>      "default": "Convert",</p>
<p>      "overrides": {</p>
<p>        "src/Handlers/LegacyHandler.cs": "Skip"</p>
<p>      }</p>
<p>    },</p>
<p>    "projections": {</p>
<p>      "default": "Convert",</p>
<p>      "single_stream": "IPerspectiveFor",</p>
<p>      "multi_stream": "IGlobalPerspectiveFor"</p>
<p>    },</p>
<p>    "event_store": {</p>
<p>      "append_exclusive": "ConvertWithWarning",</p>
<p>      "start_stream": "Convert",</p>
<p>      "save_changes": "Skip"</p>
<p>    },</p>
<p>    "id_generation": {</p>
<p>      "guid_new_guid": "Prompt",</p>
<p>      "comb_guid": "Convert"</p>
<p>    },</p>
<p>    "custom_base_classes": {</p>
<p>      "default_strategy": "Prompt",</p>
<p>      "base_class_strategies": {</p>
<p>        "BaseMessageHandler<T>": "RemoveInheritance",</p>
<p>        "BaseEventHandler": "KeepInheritance"</p>
<p>      },</p>
<p>      "confirmed": true</p>
<p>    },</p>
<p>    "unknown_interfaces": {</p>
<p>      "default_strategy": "Prompt",</p>
<p>      "interface_strategies": {</p>
<p>        "IEventStoreContext": "MapToWhizbang",</p>
<p>        "ICustomLogger": "KeepAndInject",</p>
<p>        "ILegacyService": "RemoveParameter"</p>
<p>      },</p>
<p>      "confirmed": true</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h3>Custom Base Class Strategies</h3>

<p>| Strategy | Description |</p>
<p>|----------|-------------|</p>
<p>| <code>Prompt</code> | Ask for each handler (default) |</p>
<p>| <code>RemoveInheritance</code> | Remove base class, implement IReceptor directly |</p>
<p>| <code>KeepInheritance</code> | Keep base class AND add IReceptor (requires manual base class adaptation) |</p>
<p>| <code>Skip</code> | Don't migrate handlers using this base class |</p>

<h3>Unknown Interface Strategies</h3>

<p>| Strategy | Description |</p>
<p>|----------|-------------|</p>
<p>| <code>Prompt</code> | Ask for each handler (default) |</p>
<p>| <code>MapToWhizbang</code> | Replace with Whizbang equivalent (e.g., <code>IEventStoreContext</code> → <code>IEventStore</code>) |</p>
<p>| <code>KeepAndInject</code> | Keep parameter, inject via DI |</p>
<p>| <code>RemoveParameter</code> | Remove the parameter entirely |</p>
<p>| <code>Skip</code> | Don't migrate handlers using this interface |</p>

<p>The <code>routing</code> section captures:</p>
<ul><li><strong>owned_domains</strong>: Domains this service owns (commands route here)</li>
<li><strong>detected_domains</strong>: All domains found in the codebase</li>
<li><strong>inbox_strategy</strong>: <code>SharedTopic</code> or <code>DomainTopics</code></li>
<li><strong>outbox_strategy</strong>: <code>DomainTopics</code> or <code>SharedTopic</code></li>
</ul>
<h3>Generate for Manual Editing</h3>

<pre><code class="language-bash"># Generate decision file with defaults for manual editing
<p>whizbang migrate apply ./src --generate-decisions myproject-decisions.json</p>
<p></code></pre></p>

<p>Edit the JSON file in your text editor, then replay:</p>

<pre><code class="language-bash">whizbang migrate apply ./src --decision-file myproject-decisions.json
<p></code></pre></p>

<h2>Revert Functionality</h2>

<p>If something goes wrong, you can revert all migration changes:</p>

<pre><code class="language-bash">whizbang migrate revert
<p></code></pre></p>

<p>This will:</p>
<ul><li>Reset to the git commit recorded before migration started</li>
<li>Clean any untracked files created during migration</li>
<li>Update the decision file status to "Reverted"</li>
</ul>
<h3>Revert Options</h3>

<pre><code class="language-">┌─────────────────────────────────────────────────────────────────┐
<p>│  Revert Migration                                                │</p>
<p>├─────────────────────────────────────────────────────────────────┤</p>
<p>│                                                                  │</p>
<p>│  This will revert all migration changes:                         │</p>
<p>│  • Git reset to commit: abc123 (before migration)               │</p>
<p>│  • Clean untracked files created during migration               │</p>
<p>│  • Keep decision file (can resume later)                        │</p>
<p>│                                                                  │</p>
<p>│  Warning: Uncommitted changes will be lost!                      │</p>
<p>│                                                                  │</p>
<p>│  [A] Revert and keep decision file (Recommended)                │</p>
<p>│  [B] Revert and delete decision file                            │</p>
<p>│  [C] Cancel                                                      │</p>
<p>│                                                                  │</p>
<p>│  Select option [A/B/C]: _                                       │</p>
<p>└─────────────────────────────────────────────────────────────────┘</p>
<p></code></pre></p>

<h2>Status Command</h2>

<p>View detailed migration status:</p>

<pre><code class="language-bash">whizbang migrate status
<p></code></pre></p>

<p>Output:</p>
<pre><code class="language-">Migration Status: In Progress
<p>Project: /src/MyProject</p>
<p>Started: 2026-01-18 14:30</p>

<p>Progress:</p>
<p>  [████████████░░░░░░░░] 60% (27/45)</p>

<p>Categories:</p>
<p>  ✓ Handlers (45/45)</p>
<p>  ▶ Projections (12/23) - current</p>
<p>  ○ Event Store (0/67)</p>
<p>  ○ ID Generation (0/34)</p>

<p>Decision file: ~/.whizbang/migrations/MyProject/decisions.json</p>
<p>Git commit (before): abc123def456</p>
<p></code></pre></p>

<h2>Command Reference</h2>

<p>| Command | Description |</p>
<p>|---------|-------------|</p>
<p>| <code>whizbang migrate</code> | Launch wizard menu |</p>
<p>| <code>whizbang migrate analyze <path></code> | Scan and report patterns |</p>
<p>| <code>whizbang migrate apply <path> --interactive</code> | Interactive wizard |</p>
<p>| <code>whizbang migrate apply <path> --decision-file <file></code> | Replay decisions |</p>
<p>| <code>whizbang migrate revert</code> | Revert changes |</p>
<p>| <code>whizbang migrate status</code> | Show progress |</p>

<h2>Workflow Examples</h2>

<h3>Team Migration</h3>

<pre><code class="language-bash"># Lead developer: Create decisions interactively
<p>whizbang migrate apply ./src --interactive --decision-file team-decisions.json</p>

<h1>Share team-decisions.json with team</h1>

<h1>Other developers: Apply same decisions</h1>
<p>whizbang migrate apply ./src --decision-file team-decisions.json</p>
<p></code></pre></p>

<h3>Incremental Migration</h3>

<pre><code class="language-bash"># Day 1: Migrate handlers
<p>whizbang migrate apply ./src --interactive</p>
<h1>Answer prompts for handlers only, exit</h1>

<h1>Day 2: Resume and migrate projections</h1>
<p>whizbang migrate</p>
<h1>Select "Continue migration"</h1>
<p></code></pre></p>

<h3>Safe Exploration</h3>

<pre><code class="language-bash"># Analyze without changes
<p>whizbang migrate analyze ./src</p>

<h1>Try interactive migration</h1>
<p>whizbang migrate apply ./src --interactive</p>

<h1>Something went wrong? Revert</h1>
<p>whizbang migrate revert</p>

<h1>Try again with different decisions</h1>
<p>whizbang migrate apply ./src --interactive</p>
<p></code></pre></p>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="migrate-from-marten-wolverine-readme" class="doc-section">
  <h2>README</h2>
  <p class="doc-path"><code>migrate-from-marten-wolverine/README</code></p>
  <div class="doc-content">
<h1>Migrate from Marten/Wolverine</h1>

<p>This guide provides step-by-step instructions for migrating applications from Marten/Wolverine to Whizbang.</p>

<h2>Overview</h2>

<p>Whizbang is a modern, AOT-compatible event-driven framework that provides:</p>
<ul><li>Zero-reflection architecture via source generators</li>
<li>Native AOT support from day one</li>
<li>Type-safe message routing with compile-time validation</li>
<li>Built-in observability and distributed tracing</li>
</ul>
<h2>Migration Approach</h2>

<p>We recommend a <strong>gradual migration</strong> strategy:</p>

<ul><li><strong>Add Whizbang packages</strong> alongside existing Marten/Wolverine</li>
<li><strong>Migrate handlers</strong> one at a time using the automated tooling</li>
<li><strong>Run in parallel</strong> to validate behavior</li>
<li><strong>Remove legacy dependencies</strong> once migration is complete</li>
</ul>
<h2>Quick Start</h2>

<pre><code class="language-bash"># Install the migration CLI tool
<p>dotnet tool install -g whizbang-migrate</p>

<h1>Analyze your project for migration scope</h1>
<p>whizbang migrate analyze --project ./src/MyService</p>

<h1>Create a migration plan</h1>
<p>whizbang migrate plan --project ./src/MyService --output migration-plan.json</p>

<h1>Apply migrations (interactive mode recommended for first run)</h1>
<p>whizbang migrate apply --project ./src/MyService --guided</p>
<p></code></pre></p>

<h2>Guide Contents</h2>

<ul><li><strong><a href="./01-concept-mapping.md">Concept Mapping</a></strong> - Core concept translations between frameworks</li>
<li><strong><a href="./02-project-setup.md">Project Setup</a></strong> - NuGet packages and configuration</li>
<li><strong><a href="./03-handler-migration.md">Handler Migration</a></strong> - Wolverine handlers to Receptors</li>
<li><strong><a href="./04-projection-migration.md">Projection Migration</a></strong> - Marten projections to Perspectives</li>
<li><strong><a href="./05-event-store-migration.md">Event Store Migration</a></strong> - IDocumentStore to IEventStore</li>
<li><strong><a href="./06-transport-configuration.md">Transport Configuration</a></strong> - RabbitMQ/Azure Service Bus</li>
<li><strong><a href="./07-outbox-migration.md">Outbox Migration</a></strong> - Durable outbox patterns</li>
<li><strong><a href="./08-testing-migration.md">Testing Migration</a></strong> - Testing strategy changes</li>
<li><strong><a href="./appendix-checklist.md">Migration Checklist</a></strong> - Complete checklist</li>
</ul>
<h2>Prerequisites</h2>

<ul><li>.NET 10.0 or later</li>
<li>Existing Marten/Wolverine application</li>
<li>PostgreSQL database (for event store)</li>
</ul>
<h2>CLI Tool Reference</h2>

<p>The <code>whizbang migrate</code> CLI provides automated migration assistance:</p>

<p>| Command | Description |</p>
<p>|---------|-------------|</p>
<p>| <code>analyze</code> | Scan project and report migration scope |</p>
<p>| <code>plan</code> | Generate migration plan without applying changes |</p>
<p>| <code>apply</code> | Apply migrations (supports <code>--guided</code> for interactive mode) |</p>
<p>| <code>rollback</code> | Revert to a previous checkpoint |</p>
<p>| <code>status</code> | Show current migration status |</p>

<p>See each section for detailed migration instructions.</p>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="migrate-from-marten-wolverine-appendix-checklist" class="doc-section">
  <h2>appendix checklist</h2>
  <p class="doc-path"><code>migrate-from-marten-wolverine/appendix-checklist</code></p>
  <div class="doc-content">
<h1>Migrate from Marten/Wolverine: Checklist</h1>

<p>Use this checklist to track your Marten/Wolverine to Whizbang migration progress.</p>

<h2>Pre-Migration</h2>

<ul><li>[ ] Review current Marten/Wolverine usage</li>
<li>[ ] Document all handlers, projections, and transports in use</li>
<li>[ ] Identify custom middleware and extensions</li>
<li>[ ] Create migration branch in version control</li>
<li>[ ] Set up parallel development environment</li>
<li>[ ] Run <code>whizbang migrate analyze</code> to assess scope</li>
</ul>
<h2>Project Setup</h2>

<ul><li>[ ] Add <code>Whizbang.Core</code> package</li>
<li>[ ] Add <code>Whizbang.Generators</code> package</li>
<li>[ ] Add <code>Whizbang.Data.EFCore.Postgres</code> package</li>
<li>[ ] Add transport package (RabbitMQ or Azure Service Bus)</li>
<li>[ ] Update <code>TargetFramework</code> to <code>net10.0</code></li>
<li>[ ] Add global usings for Whizbang namespaces</li>
<li>[ ] Configure separate schema (<code>options.SchemaName = "whizbang"</code>)</li>
<li>[ ] Verify project builds successfully</li>
</ul>
<h2>Handler Migration</h2>

<ul><li>[ ] List all <code>IHandle<T></code> implementations</li>
<li>[ ] Create result types for each handler</li>
<li>[ ] Convert handlers to <code>IReceptor<TMessage, TResult></code></li>
<li>[ ] Update method signatures (<code>Handle</code> to <code>HandleAsync</code>)</li>
<li>[ ] Replace <code>IDocumentSession</code> with <code>IEventStore</code></li>
<li>[ ] Replace <code>IMessageBus</code> with <code>IDispatcher</code></li>
<li>[ ] Update DI registrations</li>
<li>[ ] Remove <code>[WolverineHandler]</code> attributes</li>
<li>[ ] Verify all handlers have corresponding receptors</li>
</ul>
<h2>Projection Migration</h2>

<ul><li>[ ] List all <code>SingleStreamProjection<T></code> classes</li>
<li>[ ] List all <code>MultiStreamProjection<T></code> classes</li>
<li>[ ] Convert view classes to records</li>
<li>[ ] Convert projections to <code>IPerspectiveFor<T, TEvent...></code></li>
<li>[ ] Update <code>Apply</code> methods to return new instances</li>
<li>[ ] Replace <code>Create</code> methods with <code>Apply(null, event)</code></li>
<li>[ ] Add <code>GetPartitionKey</code> methods for global perspectives</li>
<li>[ ] Handle nullable <code>current</code> parameter</li>
<li>[ ] Verify perspective output matches projection output</li>
</ul>
<h2>Event Store Migration</h2>

<ul><li>[ ] Replace <code>IDocumentStore</code> with <code>IEventStore</code></li>
<li>[ ] Update stream creation patterns</li>
<li>[ ] Update event append patterns</li>
<li>[ ] Update event reading patterns</li>
<li>[ ] Configure optimistic concurrency if needed</li>
<li>[ ] Plan data migration strategy</li>
<li>[ ] Test event store operations</li>
</ul>
<h2>Transport Configuration</h2>

<ul><li>[ ] Identify current transport (RabbitMQ, Azure Service Bus)</li>
<li>[ ] Configure Whizbang transport</li>
<li>[ ] Map queue/topic names</li>
<li>[ ] Configure subscriptions</li>
<li>[ ] Configure publications</li>
<li>[ ] Set up dead letter handling</li>
<li>[ ] Configure retry policies</li>
<li>[ ] Test message flow end-to-end</li>
</ul>
<h2>Outbox Migration</h2>

<ul><li>[ ] Replace <code>IMessageContext</code> with <code>IWorkCoordinator</code></li>
<li>[ ] Wrap transactional operations in work units</li>
<li>[ ] Convert sagas to perspectives + receptors</li>
<li>[ ] Configure retry and cleanup policies</li>
<li>[ ] Set up outbox monitoring</li>
<li>[ ] Test failure recovery scenarios</li>
</ul>
<h2>Testing Migration</h2>

<ul><li>[ ] Update test fixtures to <code>WhizbangTestFixture</code></li>
<li>[ ] Convert handler tests to receptor tests</li>
<li>[ ] Convert projection tests to perspective tests</li>
<li>[ ] Update mock patterns</li>
<li>[ ] Configure test database isolation</li>
<li>[ ] Verify all tests pass</li>
</ul>
<h2>Parallel Running</h2>

<ul><li>[ ] Configure both frameworks simultaneously</li>
<li>[ ] Set up dual-write if needed</li>
<li>[ ] Monitor both systems</li>
<li>[ ] Compare outputs between old and new</li>
<li>[ ] Document any behavioral differences</li>
<li>[ ] Create rollback plan</li>
</ul>
<h2>Validation</h2>

<ul><li>[ ] All unit tests pass</li>
<li>[ ] All integration tests pass</li>
<li>[ ] Manual testing complete</li>
<li>[ ] Performance benchmarks acceptable</li>
<li>[ ] Error handling verified</li>
<li>[ ] Logging and monitoring functional</li>
<li>[ ] Documentation updated</li>
</ul>
<h2>Cleanup</h2>

<ul><li>[ ] Remove Marten package references</li>
<li>[ ] Remove Wolverine package references</li>
<li>[ ] Remove old handler classes</li>
<li>[ ] Remove old projection classes</li>
<li>[ ] Remove deprecated using statements</li>
<li>[ ] Remove parallel running configuration</li>
<li>[ ] Clean up temporary schemas</li>
<li>[ ] Archive or remove migration bridge code</li>
</ul>
<h2>Post-Migration</h2>

<ul><li>[ ] Monitor production deployment</li>
<li>[ ] Verify message processing rates</li>
<li>[ ] Check error rates and alerts</li>
<li>[ ] Update team documentation</li>
<li>[ ] Conduct knowledge transfer</li>
<li>[ ] Close migration tracking issues</li>
</ul>
<hr>

<h2>Quick Reference</h2>

<h3>CLI Commands</h3>

<pre><code class="language-bash"># Analyze migration scope
<p>whizbang migrate analyze --project ./src/MyService</p>

<h1>Generate migration plan</h1>
<p>whizbang migrate plan --project ./src/MyService --output plan.json</p>

<h1>Apply migrations interactively</h1>
<p>whizbang migrate apply --project ./src/MyService --guided</p>

<h1>Check migration status</h1>
<p>whizbang migrate status</p>

<h1>Rollback to checkpoint</h1>
<p>whizbang migrate rollback <checkpoint-id></p>
<p></code></pre></p>

<h3>Key Interface Mappings</h3>

<p>| Marten/Wolverine | Whizbang |</p>
<p>|------------------|----------|</p>
<p>| <code>IDocumentStore</code> | <code>IEventStore</code> |</p>
<p>| <code>IHandle<T></code> | <code>IReceptor<T, TResult></code> |</p>
<p>| <code>SingleStreamProjection<T></code> | <code>IPerspectiveFor<T, ...></code> |</p>
<p>| <code>MultiStreamProjection<T></code> | <code>IGlobalPerspectiveFor<T, ...></code> |</p>
<p>| <code>IMessageBus</code> | <code>IDispatcher</code> |</p>
<p>| <code>IMessageContext</code> | <code>IWorkCoordinator</code> |</p>

<h3>Package References</h3>

<pre><code class="language-xml"><ItemGroup>
<p>  <PackageReference Include="Whizbang.Core" Version="0.1.0" /></p>
<p>  <PackageReference Include="Whizbang.Generators" Version="0.1.0" /></p>
<p>  <PackageReference Include="Whizbang.Data.EFCore.Postgres" Version="0.1.0" /></p>
<p>  <PackageReference Include="Whizbang.Transports.RabbitMQ" Version="0.1.0" /></p>
<p>  <PackageReference Include="Whizbang.Transports.AzureServiceBus" Version="0.1.0" /></p>
<p></ItemGroup></p>
<p></code></pre></p>

<hr>

<h2>Getting Help</h2>

<ul><li><a href="./README.md">Migration Guide Index</a></li>
<li><a href="../v0.1.0/">Whizbang Documentation</a></li>
<li><a href="https://github.com/whizbang-lib/whizbang/issues">GitHub Issues</a></li>
<li><a href="https://discord.gg/whizbang">Discord Community</a></li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>
<section id="roadmap"><h3>Roadmap</h3>
<article id="roadmap-feature-evolution" class="doc-section">
  <h2>Feature Evolution Matrix</h2>
  <p class="doc-path"><code>roadmap/FEATURE-EVOLUTION</code></p>
  <p class="doc-description"><em>Track how each feature evolves across versions with clear progression indicators</em></p>
  <div class="doc-content">

<h1>Feature Evolution Matrix</h1>

<h2>Overview</h2>

<p>This matrix tracks how each Whizbang feature evolves across versions, showing clear progression from foundation to production-ready implementations.</p>

<h2>Legend</h2>

<ul><li>:::new <strong>New</strong> - Feature introduced in this version</li>
<li>:::updated <strong>Enhanced</strong> - Feature improved from previous version</li>
<li>:::updated{type="major"} <strong>Major Update</strong> - Significant enhancement</li>
<li>:::deprecated <strong>Deprecated</strong> - Feature being phased out</li>
<li>:::planned <strong>Planned</strong> - Coming in future version</li>
<li><code>-</code> No changes in this version</li>
</ul>
<h2>Core Components Evolution</h2>

<h3>Dispatcher</h3>
<p>| Version | Status | Key Features | Breaking Changes | Documentation |</p>
<p>|---------|--------|--------------|------------------|---------------|</p>
<p>| v0.1.0 | :::new <strong>New</strong> | • In-memory routing<br/>• Source-generated dispatch tables<br/>• Basic pipeline | - | <a href="../v0.1.0/components/dispatcher.md">View →</a> |</p>
<p>| v0.2.0 | :::updated <strong>Enhanced</strong> | • Parallel dispatch<br/>• Batch operations<br/>• Enhanced context | None | <a href="../v0.2.0/enhancements/dispatcher.md">View →</a> |</p>
<p>| v0.3.0 | :::updated <strong>Enhanced</strong> | • Event store integration<br/>• Replay support | None | <a href="../v0.3.0/features/dispatcher.md">View →</a> |</p>
<p>| v0.4.0 | :::updated <strong>Enhanced</strong> | • Database persistence<br/>• Transaction support | None | <a href="../v0.4.0/drivers/dispatcher.md">View →</a> |</p>
<p>| v0.5.0 | :::updated{type="major"} <strong>Major</strong> | • Distributed routing<br/>• Saga coordination | None | <a href="../v0.5.0/messaging/dispatcher.md">View →</a> |</p>

<h3>Receptors</h3>
<p>| Version | Status | Key Features | Breaking Changes | Documentation |</p>
<p>|---------|--------|--------------|------------------|---------------|</p>
<p>| v0.1.0 | :::new <strong>New</strong> | • Stateless receptors<br/>• Basic interface<br/>• Command handling | - | <a href="../v0.1.0/components/receptors.md">View →</a> |</p>
<p>| v0.2.0 | :::updated <strong>Enhanced</strong> | • Validation attributes<br/>• Parameter injection<br/>• Async support | None | <a href="../v0.2.0/enhancements/receptors.md">View →</a> |</p>
<p>| v0.3.0 | :::updated{type="major"} <strong>Major</strong> | • Stateful receptors<br/>• Event sourcing<br/>• State hydration | None | <a href="../v0.3.0/features/stateful-receptors.md">View →</a> |</p>
<p>| v0.4.0 | - | No changes | - | - |</p>
<p>| v0.5.0 | :::updated <strong>Enhanced</strong> | • Distributed execution<br/>• Remote receptors | None | <a href="../v0.5.0/messaging/receptors.md">View →</a> |</p>

<h3>Perspectives</h3>
<p>| Version | Status | Key Features | Breaking Changes | Documentation |</p>
<p>|---------|--------|--------------|------------------|---------------|</p>
<p>| v0.1.0 | :::new <strong>New</strong> | • Event handling<br/>• In-memory updates<br/>• Basic interface | - | <a href="../v0.1.0/components/perspectives.md">View →</a> |</p>
<p>| v0.2.0 | :::updated <strong>Enhanced</strong> | • Batch updates<br/>• Parallel execution<br/>• Error handling | None | <a href="../v0.2.0/enhancements/perspectives.md">View →</a> |</p>
<p>| v0.3.0 | :::updated{type="major"} <strong>Major</strong> | • Projection support<br/>• Rebuild capability<br/>• Checkpoints | None | <a href="../v0.3.0/features/projections.md">View →</a> |</p>
<p>| v0.4.0 | :::updated <strong>Enhanced</strong> | • Database backing<br/>• Optimized queries | None | <a href="../v0.4.0/drivers/perspectives.md">View →</a> |</p>
<p>| v0.5.0 | :::updated <strong>Enhanced</strong> | • Distributed perspectives<br/>• Partitioned processing | None | <a href="../v0.5.0/messaging/perspectives.md">View →</a> |</p>

<h3>Lenses</h3>
<p>| Version | Status | Key Features | Breaking Changes | Documentation |</p>
<p>|---------|--------|--------------|------------------|---------------|</p>
<p>| v0.1.0 | :::new <strong>New</strong> | • Query interface<br/>• Focus, View, Glimpse<br/>• In-memory queries | - | <a href="../v0.1.0/components/lenses.md">View →</a> |</p>
<p>| v0.2.0 | :::updated <strong>Enhanced</strong> | • Pagination<br/>• Async enumeration<br/>• Query optimization | None | <a href="../v0.2.0/enhancements/lenses.md">View →</a> |</p>
<p>| v0.3.0 | :::updated <strong>Enhanced</strong> | • Projection queries<br/>• Time-travel queries | None | <a href="../v0.3.0/features/lenses.md">View →</a> |</p>
<p>| v0.4.0 | :::updated{type="major"} <strong>Major</strong> | • SQL generation<br/>• Index usage<br/>• Query caching | None | <a href="../v0.4.0/drivers/lenses.md">View →</a> |</p>
<p>| v0.5.0 | :::updated <strong>Enhanced</strong> | • Distributed queries<br/>• Federated lenses | None | <a href="../v0.5.0/messaging/lenses.md">View →</a> |</p>

<h3>Policy Engine</h3>
<p>| Version | Status | Key Features | Breaking Changes | Documentation |</p>
<p>|---------|--------|--------------|------------------|---------------|</p>
<p>| v0.1.0 | :::new <strong>New</strong> | • Retry<br/>• Timeout<br/>• Cache<br/>• CircuitBreaker | - | <a href="../v0.1.0/components/policy-engine.md">View →</a> |</p>
<p>| v0.2.0 | :::updated <strong>Enhanced</strong> | • Bulkhead<br/>• Rate limiting<br/>• Policy composition | None | <a href="../v0.2.0/enhancements/policies.md">View →</a> |</p>
<p>| v0.3.0 | :::updated <strong>Enhanced</strong> | • Stateful policies<br/>• Policy persistence | None | <a href="../v0.3.0/features/policies.md">View →</a> |</p>
<p>| v0.4.0 | - | No changes | - | - |</p>
<p>| v0.5.0 | :::updated <strong>Enhanced</strong> | • Distributed policies<br/>• Policy synchronization | None | <a href="../v0.5.0/messaging/policies.md">View →</a> |</p>
<p>| v0.6.0 | :::planned <strong>Planned</strong> | • Authorization<br/>• Audit policies<br/>• Compliance policies | None | <a href="../future/v0.6.0-production.md">View →</a> |</p>

<h3>Ledger (Event Store)</h3>
<p>| Version | Status | Key Features | Breaking Changes | Documentation |</p>
<p>|---------|--------|--------------|------------------|---------------|</p>
<p>| v0.1.0 | :::new <strong>New</strong> | • Event store interface<br/>• In-memory storage<br/>• Basic streams | - | <a href="../v0.1.0/components/ledger.md">View →</a> |</p>
<p>| v0.2.0 | :::updated <strong>Enhanced</strong> | • Event metadata<br/>• Stream categories | None | <a href="../v0.2.0/enhancements/ledger.md">View →</a> |</p>
<p>| v0.3.0 | :::updated{type="major"} <strong>Major</strong> | • Snapshots<br/>• Projections<br/>• Event versioning | None | <a href="../v0.3.0/features/event-store.md">View →</a> |</p>
<p>| v0.4.0 | :::updated{type="major"} <strong>Major</strong> | • Database persistence<br/>• JSONB storage<br/>• Indexes | None | <a href="../v0.4.0/drivers/event-store.md">View →</a> |</p>
<p>| v0.5.0 | :::updated <strong>Enhanced</strong> | • Distributed streams<br/>• Partitioning | None | <a href="../v0.5.0/messaging/event-store.md">View →</a> |</p>

<h3>Drivers</h3>
<p>| Version | Status | Key Features | Breaking Changes | Documentation |</p>
<p>|---------|--------|--------------|------------------|---------------|</p>
<p>| v0.1.0 | :::new <strong>New</strong> | • Driver interface<br/>• In-memory driver | - | <a href="../v0.1.0/components/drivers.md">View →</a> |</p>
<p>| v0.2.0 | - | No changes | - | - |</p>
<p>| v0.3.0 | :::updated <strong>Enhanced</strong> | • Transaction support<br/>• Batch operations | None | <a href="../v0.3.0/features/drivers.md">View →</a> |</p>
<p>| v0.4.0 | :::updated{type="major"} <strong>Major</strong> | • PostgreSQL driver<br/>• SQL Server driver<br/>• SQLite driver | None | <a href="../v0.4.0/drivers/README.md">View →</a> |</p>
<p>| v0.5.0 | :::updated <strong>Enhanced</strong> | • Connection pooling<br/>• Failover support | None | <a href="../v0.5.0/messaging/drivers.md">View →</a> |</p>

<h3>Transports</h3>
<p>| Version | Status | Key Features | Breaking Changes | Documentation |</p>
<p>|---------|--------|--------------|------------------|---------------|</p>
<p>| v0.1.0 | :::new <strong>New</strong> | • Transport interface<br/>• In-memory transport | - | <a href="../v0.1.0/components/transports.md">View →</a> |</p>
<p>| v0.2.0 | - | No changes | - | - |</p>
<p>| v0.3.0 | - | No changes | - | - |</p>
<p>| v0.4.0 | :::updated <strong>Enhanced</strong> | • Outbox pattern prep | None | <a href="../v0.4.0/drivers/transports.md">View →</a> |</p>
<p>| v0.5.0 | :::updated{type="major"} <strong>Major</strong> | • Kafka transport<br/>• RabbitMQ transport<br/>• Azure Service Bus | None | <a href="../v0.5.0/messaging/README.md">View →</a> |</p>

<h2>Developer Experience Evolution</h2>

<h3>Source Generators</h3>
<p>| Version | Features | Performance Impact |</p>
<p>|---------|----------|-------------------|</p>
<p>| v0.1.0 | • Handler discovery<br/>• Routing tables<br/>• Service registration | < 1s for 1000 handlers |</p>
<p>| v0.2.0 | • Validation generation<br/>• Policy weaving | < 1.5s for 1000 handlers |</p>
<p>| v0.3.0 | • Serialization generation<br/>• State machines | < 2s for 1000 handlers |</p>
<p>| v0.4.0 | • SQL generation<br/>• Migration scripts | < 2.5s for 1000 handlers |</p>
<p>| v0.5.0 | • Message contracts<br/>• Saga orchestration | < 3s for 1000 handlers |</p>

<h3>IDE Tools</h3>
<p>| Version | Features | Enhancements |</p>
<p>|---------|----------|--------------|</p>
<p>| v0.1.0 | • CodeLens references<br/>• Basic navigation<br/>• Analyzer warnings | Foundation |</p>
<p>| v0.2.0 | • Enhanced traceability<br/>• Quick fixes<br/>• Refactoring support | +50% features |</p>
<p>| v0.3.0 | • Time-travel debugging<br/>• Event replay<br/>• State inspection | +30% features |</p>
<p>| v0.4.0 | • Query optimization hints<br/>• Index suggestions | +20% features |</p>
<p>| v0.5.0 | • Distributed tracing<br/>• Message flow viz | +40% features |</p>

<h3>Testing Support</h3>
<p>| Version | Features | Test Types |</p>
<p>|---------|----------|------------|</p>
<p>| v0.1.0 | • TUnit integration<br/>• Bogus scenarios<br/>• In-memory doubles | Unit, Integration |</p>
<p>| v0.2.0 | • Behavior specs<br/>• Property testing | + BDD, Property |</p>
<p>| v0.3.0 | • Event sourcing helpers<br/>• Time travel testing | + Event Testing |</p>
<p>| v0.4.0 | • Database testing<br/>• Migration testing | + Database |</p>
<p>| v0.5.0 | • Distributed testing<br/>• Chaos engineering | + Distributed |</p>

<h2>Migration Complexity</h2>

<h3>Version Upgrade Paths</h3>
<p>| From → To | Complexity | Breaking Changes | Migration Guide |</p>
<p>|-----------|------------|------------------|-----------------|</p>
<p>| v0.1.0 → v0.2.0 | ⭐ Easy | None | <a href="../v0.2.0/migration-guide.md">Guide →</a> |</p>
<p>| v0.2.0 → v0.3.0 | ⭐⭐ Moderate | None | <a href="../v0.3.0/migration-guide.md">Guide →</a> |</p>
<p>| v0.3.0 → v0.4.0 | ⭐⭐ Moderate | None | <a href="../v0.4.0/migration-guide.md">Guide →</a> |</p>
<p>| v0.4.0 → v0.5.0 | ⭐⭐⭐ Complex | None | <a href="../v0.5.0/migration-guide.md">Guide →</a> |</p>

<h2>Feature Adoption Timeline</h2>

<pre><code class="language-mermaid">gantt
<p>    title Feature Adoption Timeline</p>
<p>    dateFormat YYYY-MM</p>
<p>    section Foundation</p>
<p>    Core Components     :done, 2025-01, 2025-02</p>
<p>    Source Generators   :done, 2025-01, 2025-02</p>
<p>    IDE Tools          :done, 2025-01, 2025-02</p>
<p>    </p>
<p>    section Enhancement</p>
<p>    Validation         :active, 2025-03, 2025-04</p>
<p>    Policies           :active, 2025-03, 2025-04</p>
<p>    </p>
<p>    section Event Sourcing</p>
<p>    Stateful Receptors :2025-05, 2025-06</p>
<p>    Projections        :2025-05, 2025-06</p>
<p>    </p>
<p>    section Persistence</p>
<p>    Database Drivers   :2025-07, 2025-08</p>
<p>    Migrations         :2025-07, 2025-08</p>
<p>    </p>
<p>    section Distributed</p>
<p>    Message Transports :2025-09, 2025-10</p>
<p>    Sagas             :2025-09, 2025-10</p>
<p></code></pre></p>

<h2>Success Metrics by Version</h2>

<p>| Version | Adoption Target | Performance Target | Quality Target |</p>
<p>|---------|----------------|-------------------|----------------|</p>
<p>| v0.1.0 | 100+ developers | < 1ms operations | 100% test coverage |</p>
<p>| v0.2.0 | 500+ developers | < 1ms operations | 100% test coverage |</p>
<p>| v0.3.0 | 1,000+ developers | < 10ms operations | 95% test coverage |</p>
<p>| v0.4.0 | 5,000+ developers | < 10ms operations | 95% test coverage |</p>
<p>| v0.5.0 | 10,000+ developers | < 100ms operations | 90% test coverage |</p>

<h2>Navigation</h2>

<ul><li><a href="README.md">Back to Roadmap</a></li>
<li><a href="../v0.1.0/README.md">v0.1.0 Documentation</a></li>
<li><a href="success-metrics.md">Success Metrics</a></li>
<li><a href="SESSION-CONTEXT.md">Session Context</a></li></ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="roadmap-readme" class="doc-section">
  <h2>Whizbang Implementation Roadmap</h2>
  <p class="doc-path"><code>roadmap/README</code></p>
  <p class="doc-description"><em>Complete implementation roadmap for building the Whizbang .NET library from foundation to production</em></p>
  <div class="doc-content">

<h1>Whizbang Implementation Roadmap</h1>

<h2>Overview</h2>

<p>This roadmap outlines the complete implementation plan for Whizbang, a unified event-sourced data and messaging runtime for .NET. We follow a <strong>breadth-first approach</strong>, establishing thin implementations of ALL major components early, then iteratively enhancing each component.</p>

<h2>Core Principles</h2>

<ul><li><strong>Zero Reflection</strong>: Everything discovered and wired at compile time via source generators</li>
<li><strong>IDE-First Development</strong>: Developer tools and traceability from day one</li>
<li><strong>Test-Driven</strong>: Comprehensive testing with TUnit and Bogus from the start</li>
<li><strong>Progressive Enhancement</strong>: Start simple, enhance iteratively</li>
<li><strong>In-Memory First</strong>: All components start with in-memory implementations that become test doubles</li>
</ul>
<h2>Version Overview</h2>

<h3>🚀 <a href="../v0.1.0/README.md">v0.1.0 - Foundation</a></h3>
<strong>Status</strong>: Planning  
<strong>Goal</strong>: Minimal working implementation of EVERY major component
<ul><li>All core interfaces and abstractions</li>
<li>Source generators and analyzers</li>
<li>IDE tools with CodeLens-style references</li>
<li>Traceability and debugging foundation</li>
<li>Complete testing framework with TUnit and Bogus</li>
<li>In-memory implementations for all components</li>
</ul>
<h3>📈 <a href="../v0.2.0/README.md">v0.2.0 - Event-Driven Enhancement</a></h3>
<strong>Status</strong>: Planning  
<strong>Goal</strong>: Deepen event-driven capabilities
<ul><li>Enhanced receptors with validation</li>
<li>Rich event metadata and correlation</li>
<li>Multiple perspectives per event</li>
<li>Advanced lens query methods</li>
<li>Policy engine enhancements</li>
</ul>
<h3>💾 <a href="../v0.3.0/README.md">v0.3.0 - Event Sourcing</a></h3>
<strong>Status</strong>: Planning  
<strong>Goal</strong>: Add stateful capabilities
<ul><li>Stateful receptors</li>
<li>Traditional aggregates</li>
<li>Event store implementation</li>
<li>Projections and snapshots</li>
<li>Optimistic concurrency</li>
</ul>
<h3>🗄️ <a href="../v0.4.0/README.md">v0.4.0 - Real Persistence</a></h3>
<strong>Status</strong>: Planning  
<strong>Goal</strong>: Production-ready persistence
<ul><li>PostgreSQL driver with JSONB</li>
<li>SQL Server driver with JSON columns</li>
<li>SQLite driver for edge scenarios</li>
<li>Schema migrations</li>
<li>Multi-tenancy support</li>
</ul>
<h3>📡 <a href="../v0.5.0/README.md">v0.5.0 - Distributed Systems</a></h3>
<strong>Status</strong>: Planning  
<strong>Goal</strong>: Enable distributed messaging
<ul><li>Kafka transport</li>
<li>RabbitMQ transport</li>
<li>Outbox/Inbox patterns</li>
<li>Saga orchestration</li>
<li>Distributed tracing</li>
</ul>
<h3>🔮 <a href="../future/README.md">Future Versions</a></h3>
<ul><li><strong>v0.6.0</strong> - Production Hardening (Observability, Security, Compliance)</li>
<li><strong>v0.7.0</strong> - Performance & Scale (Zero allocation, AOT support)</li>
<li><strong>v0.8.0</strong> - Cloud Native (Kubernetes, Serverless)</li>
<li><strong>v0.9.0</strong> - Innovation (Effect system, AI integration)</li>
</ul>
<h2>Component Architecture</h2>

<h3>Core Components Present from v0.1.0</h3>

<p>| Component | Purpose | Starting Implementation |</p>
<p>|-----------|---------|------------------------|</p>
<p>| <strong>Dispatcher</strong> | Message routing and coordination | In-memory routing with generated mappings |</p>
<p>| <strong>Receptors</strong> | Command receivers and decision makers | Stateless with parameter injection |</p>
<p>| <strong>Perspectives</strong> | Event handlers and write models | In-memory state updates |</p>
<p>| <strong>Lenses</strong> | Query interfaces and read models | In-memory LINQ queries |</p>
<p>| <strong>Policy Engine</strong> | Cross-cutting concerns | Retry, Timeout, Cache, CircuitBreaker |</p>
<p>| <strong>Ledger</strong> | Event store abstraction | In-memory event streams |</p>
<p>| <strong>Drivers</strong> | Storage abstraction | In-memory storage |</p>
<p>| <strong>Transports</strong> | Message broker abstraction | In-memory pub/sub |</p>

<h3>Developer Experience from Day One</h3>

<p>| Feature | Purpose | Available From |</p>
<p>|---------|---------|----------------|</p>
<p>| <strong>Source Generators</strong> | Zero-reflection handler discovery | v0.1.0 |</p>
<p>| <strong>Analyzers</strong> | Compile-time validation | v0.1.0 |</p>
<p>| <strong>IDE Tools</strong> | CodeLens references, navigation | v0.1.0 |</p>
<p>| <strong>Traceability</strong> | Message flow visualization | v0.1.0 |</p>
<p>| <strong>Time-Travel Debugging</strong> | Step through message history | v0.1.0 |</p>
<p>| <strong>Test Framework</strong> | TUnit with Bogus scenarios | v0.1.0 |</p>

<h2>Success Metrics</h2>

<h3>Technical Goals</h3>
<ul><li>Zero reflection throughout the entire library</li>
<li>Sub-millisecond in-memory operations</li>
<li><10ms p99 for database operations</li>
<li><100ms p99 for distributed operations</li>
<li>100% backward compatibility within major versions</li>
</ul>
<h3>Quality Goals</h3>
<ul><li>100% test coverage of public APIs</li>
<li>All code examples compile and run</li>
<li>Complete documentation for every public API</li>
<li>Analyzers catch common mistakes at compile time</li>
</ul>
<h3>Developer Experience Goals</h3>
<ul><li>IntelliSense for all configuration options</li>
<li>One-click navigation between related components</li>
<li>Visual debugging of message flow</li>
<li>Comprehensive error messages with fixes</li>
</ul>
<h2>Getting Started</h2>

<ul><li><strong><a href="philosophy.md">Read the Philosophy</a></strong> - Understand our core principles</li>
<li><strong><a href="architecture.md">Review the Architecture</a></strong> - See how components fit together</li>
<li><strong><a href="../v0.1.0/README.md">Start with v0.1.0</a></strong> - Begin with the foundation</li>
<li><strong><a href="success-metrics.md">Check Success Metrics</a></strong> - Understand how we measure progress</li>
</ul>
<h2>Contributing</h2>

<p>This roadmap is a living document. Each version's documentation contains:</p>
<ul><li>Detailed specifications for each component</li>
<li>Code examples and patterns</li>
<li>Testing requirements</li>
<li>Migration guides from previous versions</li>
</ul>
<h2>Navigation</h2>

<h3>By Version</h3>
<ul><li><a href="../v0.1.0/README.md">v0.1.0 - Foundation</a></li>
<li><a href="../v0.2.0/README.md">v0.2.0 - Event-Driven</a></li>
<li><a href="../v0.3.0/README.md">v0.3.0 - Event Sourcing</a></li>
<li><a href="../v0.4.0/README.md">v0.4.0 - Persistence</a></li>
<li><a href="../v0.5.0/README.md">v0.5.0 - Distributed</a></li>
<li><a href="../future/README.md">Future Versions</a></li>
</ul>
<h3>By Topic</h3>
<ul><li><a href="philosophy.md">Core Philosophy</a></li>
<li><a href="architecture.md">Architecture Overview</a></li>
<li><a href="success-metrics.md">Success Metrics</a></li>
<li><a href="../v0.1.0/testing/README.md">Testing Strategy</a></li>
<li><a href="../v0.1.0/developer-experience/README.md">Developer Experience</a></li></ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="roadmap-session-context" class="doc-section">
  <h2>Session Context for Claude</h2>
  <p class="doc-path"><code>roadmap/SESSION-CONTEXT</code></p>
  <p class="doc-description"><em>Essential context for starting new Claude sessions on the Whizbang implementation</em></p>
  <div class="doc-content">

<h1>Session Context for Claude</h1>

<h2>Quick Start for New Sessions</h2>

<strong>Copy this to Claude when starting a new session:</strong>

<blockquote>I'm working on implementing the Whizbang .NET library. Please read the SESSION-CONTEXT.md file in src/assets/docs/roadmap/ for full context. We're building a zero-reflection, event-driven/event-sourced messaging runtime with source generators and comprehensive IDE support from day one.</blockquote>

<h2>Project Overview</h2>

<h3>What is Whizbang?</h3>
<p>Whizbang is a unified event-sourced data and messaging runtime for .NET that combines the best aspects of MediatR, Wolverine, MassTransit, and NServiceBus into a single, cohesive platform with progressive enhancement.</p>

<h3>Current Status</h3>
<ul><li><strong>Phase</strong>: Implementation planning and documentation</li>
<li><strong>Current Version</strong>: v0.1.0 (Foundation) - Planning</li>
<li><strong>Documentation</strong>: Located in <code>src/assets/docs/</code></li>
<li><strong>Old Docs</strong>: Previous versions prefixed with <code>old-</code> for reference</li>
</ul>
<h2>Core Implementation Principles</h2>

<h3>Non-Negotiable Rules</h3>
<ul><li><strong>ZERO REFLECTION</strong> - Everything via source generators, no exceptions</li>
<li><strong>IDE-First</strong> - CodeLens, traceability, and debugging from day one</li>
<li><strong>Test-Driven</strong> - TUnit + Bogus for all components</li>
<li><strong>Breadth-First</strong> - All components exist from v0.1.0, even if simple</li>
<li><strong>In-Memory First</strong> - All components start with in-memory implementations</li>
</ul>
<h3>Architecture Components (All in v0.1.0)</h3>
<ul><li><strong>Dispatcher</strong> - Message routing coordination</li>
<li><strong>Receptors</strong> - Command receivers (not handlers)</li>
<li><strong>Perspectives</strong> - Event handlers (not projections initially)</li>
<li><strong>Lenses</strong> - Read-only query interfaces</li>
<li><strong>Policy Engine</strong> - Cross-cutting concerns</li>
<li><strong>Ledger</strong> - Event store abstraction</li>
<li><strong>Drivers</strong> - Storage abstraction</li>
<li><strong>Transports</strong> - Message broker abstraction</li>
</ul>
<h3>Unique Terminology</h3>
<ul><li><strong>Receptors</strong> instead of Handlers (emphasizes decision-making)</li>
<li><strong>Perspectives</strong> instead of Projections (more general, handles all writes)</li>
<li><strong>Lenses</strong> for queries (composable, functional)</li>
<li><strong>Ledger</strong> instead of Event Store (cleaner abstraction)</li>
</ul>
<h2>Documentation Structure</h2>

<pre><code class="language-">src/assets/docs/
<p>├── roadmap/                    # Implementation roadmap</p>
<p>│   ├── README.md              # Main roadmap navigation</p>
<p>│   ├── philosophy.md          # Core principles</p>
<p>│   ├── architecture.md        # Component relationships</p>
<p>│   ├── success-metrics.md     # How we measure success</p>
<p>│   └── SESSION-CONTEXT.md     # This file</p>
<p>├── v0.1.0/                    # Foundation release (current focus)</p>
<p>│   ├── components/            # Component specifications</p>
<p>│   ├── developer-experience/  # IDE, source generators, debugging</p>
<p>│   ├── testing/              # Testing strategy</p>
<p>│   └── examples/             # Code examples</p>
<p>├── v0.2.0/ through v0.5.0/    # Future versions</p>
<p>├── future/                    # Long-term vision (v0.6.0+)</p>
<p>└── old-*/                     # Previous documentation for reference</p>
<p></code></pre></p>

<h2>Current Implementation Focus</h2>

<h3>v0.1.0 Goals</h3>
<ul><li>[ ] All 8 core components with interfaces</li>
<li>[ ] Source generators for zero-reflection discovery</li>
<li>[ ] IDE tools with CodeLens-style references</li>
<li>[ ] Traceability and time-travel debugging foundation</li>
<li>[ ] Complete testing framework (TUnit + Bogus)</li>
<li>[ ] In-memory implementations (become test doubles)</li>
</ul>
<h3>Key Files to Review</h3>
<ul><li><code>/roadmap/philosophy.md</code> - Core principles and anti-patterns</li>
<li><code>/roadmap/architecture.md</code> - Component relationships</li>
<li><code>/v0.1.0/README.md</code> - Current version details</li>
<li><code>/v0.1.0/components/dispatcher.md</code> - Example component spec</li>
</ul>
<h2>Development Patterns</h2>

<h3>Source Generator Pattern</h3>
<pre><code class="language-csharp">[WhizbangHandler]  // Source generator discovers this
<p>public class OrderReceptor : IReceptor<CreateOrder> {</p>
<p>    public OrderCreated Receive(CreateOrder cmd) { }</p>
<p>}</p>
<p></code></pre></p>

<h3>Policy Pattern</h3>
<pre><code class="language-csharp">[Retry(3)]
<p>[Timeout(5000)]</p>
<p>[Cache(300)]</p>
<p>public class PaymentReceptor : IReceptor<ProcessPayment> { }</p>
<p></code></pre></p>

<h3>Testing Pattern</h3>
<pre><code class="language-csharp">[Test]
<p>[MethodDataSource(nameof(OrderScenarios))]  // Bogus generates scenarios</p>
<p>public async Task CreateOrder_ShouldEmitOrderCreated(OrderScenario scenario) { }</p>
<p></code></pre></p>

<h2>Version Progression</h2>

<ul><li><strong>v0.1.0</strong> - Foundation (all components, in-memory)</li>
<li><strong>v0.2.0</strong> - Event-Driven Enhancement (validation, rich events)</li>
<li><strong>v0.3.0</strong> - Event Sourcing (stateful receptors, aggregates)</li>
<li><strong>v0.4.0</strong> - Real Persistence (PostgreSQL, SQL Server, SQLite)</li>
<li><strong>v0.5.0</strong> - Distributed Systems (Kafka, RabbitMQ, Sagas)</li>
<li><strong>v0.6.0+</strong> - Production, Performance, Cloud, Innovation</li>
</ul>
<h2>Common Tasks</h2>

<h3>Adding a New Component Spec</h3>
<ul><li>Create file in <code>/v0.1.0/components/[component].md</code></li>
<li>Include: Interface, In-Memory Implementation, Source Generation, Testing, IDE Integration</li>
<li>Update <code>/v0.1.0/components/README.md</code> navigation</li>
</ul>
<h3>Adding a New Version</h3>
<ul><li>Create folder <code>/v0.X.0/</code></li>
<li>Add <code>_folder.md</code> with metadata</li>
<li>Create <code>README.md</code> with version overview</li>
<li>Add <code>migration-guide.md</code> from previous version</li>
</ul>
<h3>Working on Specific Topics</h3>
<ul><li><strong>Components</strong>: Focus on <code>/v0.1.0/components/</code></li>
<li><strong>Testing</strong>: Focus on <code>/v0.1.0/testing/</code></li>
<li><strong>IDE Features</strong>: Focus on <code>/v0.1.0/developer-experience/</code></li>
<li><strong>Examples</strong>: Focus on <code>/v0.1.0/examples/</code></li>
</ul>
<h2>Key Decisions Made</h2>

<ul><li><strong>No Reflection Ever</strong> - Source generators from day one</li>
<li><strong>Breadth First</strong> - All components in v0.1.0</li>
<li><strong>TUnit over xUnit/NUnit</strong> - Modern, fast, better DX</li>
<li><strong>Bogus for Test Data</strong> - Realistic scenario generation</li>
<li><strong>In-Memory as Test Doubles</strong> - Not throwaway code</li>
<li><strong>Policies over Aspects</strong> - Explicit, composable, testable</li>
</ul>
<h2>Questions/Discussions in Progress</h2>

<ul><li>[ ] Exact IDE overlay visualization format</li>
<li>[ ] Specific OpenTelemetry integration points</li>
<li>[ ] Dashboard technology (Blazor vs React)</li>
<li>[ ] Package naming conventions</li>
<li>[ ] CI/CD pipeline structure</li>
</ul>
<h2>Working Conventions</h2>

<h3>Code Examples</h3>
<ul><li>Always show complete, compilable examples</li>
<li>Include using statements</li>
<li>Show both simple and advanced usage</li>
<li>Include testing examples</li>
</ul>
<h3>Documentation Style</h3>
<ul><li>Use clear headings and sections</li>
<li>Include code examples with syntax highlighting</li>
<li>Provide "why" not just "what"</li>
<li>Link between related documents</li>
</ul>
<h3>File Naming</h3>
<ul><li>Components: <code>[component-name].md</code></li>
<li>Guides: <code>[topic]-guide.md</code></li>
<li>Examples: <code>[scenario]-example.md</code></li>
<li>Always lowercase with hyphens</li>
</ul>
<h2>Concepts & Patterns Documentation</h2>

<h3>Pattern Documentation Standards</h3>

<p>All pattern files in <code>/src/assets/patterns/</code> follow this proven structure (based on successful Receptor Pattern template):</p>

<h4>Required Structure</h4>

<ul><li><strong>Front-matter</strong> - Standard metadata (title, category, order, description, tags)</li>
<li><strong>Title & Tagline</strong> - Pattern name with memorable quote  </li>
<li><strong>## Evolution</strong> (Early in document - key placement!)</li>
</ul><p>   - ### Pattern Roadmap</p>
<p>   - ### Version Timeline (Mermaid flowchart showing v0.1.0 → v0.5.0)</p>
<p>   - ### Capability Growth by Version</p>
<p>     - Code examples for each version with enhanced front-matter metadata</p>
<p>     - Progressive complexity from foundation to distributed</p>
<p>   - ### Evolution Benefits</p>
<p>   - ### Migration Path</p>
<p>   - ### Capability Matrix (Mermaid diagram showing evolution timeline)</p>
<ul><li><strong>## Pattern Overview</strong></li>
</ul><p>   - ### What is [Pattern]?</p>
<p>   - ### Key Characteristics  </p>
<p>   - <strong>Industry Pattern Comparisons</strong> (embedded, no separate header):</p>
<p>     - Traditional Pattern Name - <strong>Similarity:</strong> and <strong>Difference:</strong></p>
<p>     - Multiple comparisons showing how this pattern relates to existing approaches</p>
<p>   - ### When to Use [Pattern]</p>
<ul><li><strong>## Implementation</strong> - Technical details and core concepts</li>
<li><strong>## Code Examples</strong> - Progressive complexity with full metadata</li>
<li><strong>## When to Use This Pattern</strong> - Clear guidance and anti-patterns</li>
<li><strong>## Common Misconceptions</strong> - Address typical confusion points</li>
<li><strong>## Implementation Checklist</strong> - Practical step-by-step guidance</li>
<li><strong>## Example: [Specific Scenario]</strong> - Complete working implementation</li>
<li><strong>## Benefits</strong> - For developers and systems</li>
<li><strong>## Next Steps</strong> - Links to related patterns</li>
</ul>
<h4>Key Standards</h4>

<ul><li><strong>Evolution section placement</strong>: Position #3 (early), not late in document</li>
<li><strong>Industry comparisons</strong>: Use <strong>Similarity:</strong> and <strong>Difference:</strong> format (bold text renders automatically)</li>
<li><strong>Code examples</strong>: All must have enhanced front-matter with metadata including:</li>
</ul><p>  - title, description, framework, category, difficulty</p>
<p>  - tags, nugetPackages, filename, testFile, testMethod, usingStatements</p>
<ul><li><strong>Mermaid diagrams</strong>: Use consistent color schemes across all patterns</li>
<li><strong>Version progression</strong>: Always follows v0.1.0 → v0.2.0 → v0.3.0 → v0.4.0 → v0.5.0</li>
<li><strong>Cross-references</strong>: Use relative links between related patterns</li>
</ul>
<h4>Content Quality Requirements</h4>

<ul><li>All code examples must be complete and compilable</li>
<li>Progressive complexity from simple to distributed scenarios</li>
<li>Clear explanations of "why" not just "what"</li>
<li>Testable examples with accompanying test methods</li>
<li>Consistent terminology aligned with Whizbang's unique vocabulary</li>
</ul>
<h2>Session Handoff Notes</h2>

<strong>For next session, current priorities are:</strong>
<ul><li>Complete remaining v0.1.0 component specifications</li>
<li>Detail out testing foundation with TUnit/Bogus</li>
<li>Specify source generator implementation</li>
<li>Create developer experience documentation</li>
<li>Add concrete examples for each component</li>
</ul>
<strong>Recent work completed:</strong>
<ul><li>Renamed old version folders to <code>old-*</code></li>
<li>Created complete roadmap documentation structure</li>
<li>Established v0.1.0 through v0.5.0 version folders</li>
<li>Documented philosophy and architecture</li>
<li>Created success metrics framework</li>
</ul>
<h2>Quick Commands</h2>

<pre><code class="language-bash"># Navigate to docs
<p>cd /Users/philcarbone/src/whizbang-lib.github.io/src/assets/docs</p>

<h1>View structure</h1>
<p>ls -la roadmap/ v0.1.0/</p>

<h1>Find all component docs</h1>
<p>find . -name "<em>component</em>.md"</p>

<h1>Search for specific patterns</h1>
<p>grep -r "IReceptor" --include="*.md"</p>
<p></code></pre></p>

<h2>Contact/Questions</h2>

<ul><li>GitHub: https://github.com/whizbang-lib/whizbang</li>
<li>Discussions: Use GitHub Discussions for design questions</li>
<li>Documentation Site: This site (whizbang-lib.github.io)</li>
</ul>
<hr>

<strong>Remember</strong>: We're building the future of .NET messaging - zero reflection, exceptional DX, progressive enhancement!  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="roadmap-architecture" class="doc-section">
  <h2>Architecture Overview</h2>
  <p class="doc-path"><code>roadmap/architecture</code></p>
  <p class="doc-description"><em>High-level architecture and component relationships in Whizbang</em></p>
  <div class="doc-content">

<h1>Architecture Overview</h1>

<h2>Component Architecture</h2>

<pre><code class="language-mermaid">graph TB
<p>    subgraph "Message Flow"</p>
<p>        CMD[Command] --> DISP[Dispatcher]</p>
<p>        DISP --> REC[Receptor]</p>
<p>        REC --> EVT[Event]</p>
<p>        EVT --> DISP2[Dispatcher]</p>
<p>        DISP2 --> PERSP[Perspectives]</p>
<p>    end</p>
<p>    </p>
<p>    subgraph "Query Flow"</p>
<p>        QUERY[Query] --> LENS[Lens]</p>
<p>        LENS --> STORE[(Storage)]</p>
<p>    end</p>
<p>    </p>
<p>    subgraph "Cross-Cutting"</p>
<p>        POLICY[Policy Engine] -.->|Applies to| REC</p>
<p>        POLICY -.->|Applies to| PERSP</p>
<p>        TRACE[Traceability] -.->|Observes| DISP</p>
<p>        TRACE -.->|Observes| DISP2</p>
<p>    end</p>
<p>    </p>
<p>    PERSP --> STORE</p>
<p>    LEDGER[(Event Store)] --> STORE</p>
<p>    </p>
<p>    style CMD fill:#e1f5fe</p>
<p>    style EVT fill:#fff3e0</p>
<p>    style STORE fill:#f3e5f5</p>
<p>    style POLICY fill:#e8f5e9</p>
<p></code></pre></p>

<h2>Core Components</h2>

<h3>1. Dispatcher</h3>
<strong>The nervous system of Whizbang</strong>

<pre><code class="language-csharp">public interface IDispatcher {
<p>    // Commands go to exactly one receptor</p>
<p>    Task<TResult> Send<TResult>(ICommand<TResult> command);</p>
<p>    </p>
<p>    // Events go to all interested perspectives</p>
<p>    Task Publish<TEvent>(TEvent @event);</p>
<p>    </p>
<p>    // Queries go through lenses</p>
<p>    TLens GetLens<TLens>() where TLens : ILens;</p>
<p>}</p>
<p></code></pre></p>

<p>The Dispatcher:</p>
<ul><li>Routes messages based on compile-time generated tables</li>
<li>Manages execution pipeline</li>
<li>Applies policies</li>
<li>Tracks correlation and causation</li>
<li>Provides traceability hooks</li>
</ul>
<h3>2. Receptors</h3>
<strong>Command receivers and decision makers</strong>

<pre><code class="language-csharp">public interface IReceptor<TCommand> {
<p>    object Receive(TCommand command);</p>
<p>}</p>
<p></code></pre></p>

<p>Receptors:</p>
<ul><li>Receive commands from the dispatcher</li>
<li>Make decisions based on business rules</li>
<li>Emit events representing decisions</li>
<li>Can be stateless (Event-Driven) or stateful (Event-Sourced)</li>
<li>Never perform side effects directly</li>
</ul>
<h3>3. Perspectives</h3>
<strong>Event handlers that update views</strong>

<pre><code class="language-csharp">public interface IPerspectiveOf<TEvent> {
<p>    Task Update(TEvent @event);</p>
<p>}</p>
<p></code></pre></p>

<p>Perspectives:</p>
<ul><li>React to events from receptors</li>
<li>Update databases, caches, search indexes</li>
<li>Maintain different views of the same data</li>
<li>Execute all write operations</li>
<li>Can be synchronous or asynchronous</li>
</ul>
<h3>4. Lenses</h3>
<strong>Read-only query interfaces</strong>

<pre><code class="language-csharp">public interface ILens {
<p>    T Focus<T>(object id);                              // Single item</p>
<p>    IEnumerable<T> View<T>(Expression<Func<T, bool>> filter);  // Filtered set</p>
<p>    TSummary Glimpse<TSummary>(object id);             // Partial view</p>
<p>    bool Exists(object id);                            // Existence check</p>
<p>    IAsyncEnumerable<T> Scan<T>();                     // Full scan</p>
<p>}</p>
<p></code></pre></p>

<p>Lenses:</p>
<ul><li>Provide read-only access to data</li>
<li>Focus on specific query needs</li>
<li>Abstract storage mechanism</li>
<li>Support different view shapes</li>
<li>Enable query optimization</li>
</ul>
<h3>5. Policy Engine</h3>
<strong>Cross-cutting concerns as composable policies</strong>

<pre><code class="language-csharp">[Retry(3, BackoffStrategy.Exponential)]
<p>[Timeout(5000)]</p>
<p>[Cache(Duration = 300)]</p>
<p>[CircuitBreaker(0.5, 10)]</p>
<p>public class PaymentReceptor : IReceptor<ProcessPayment> { }</p>
<p></code></pre></p>

<p>Policies include:</p>
<ul><li><strong>Resilience</strong>: Retry, Circuit Breaker, Timeout, Fallback</li>
<li><strong>Performance</strong>: Cache, Batch, Throttle</li>
<li><strong>Security</strong>: Authorize, Audit, Encrypt</li>
<li><strong>Observability</strong>: Trace, Metric, Log</li>
</ul>
<h3>6. Ledger (Event Store)</h3>
<strong>The source of truth for events</strong>

<pre><code class="language-csharp">public interface ILedger {
<p>    // Append events to a stream</p>
<p>    Task<long> Append(string stream, IEnumerable<object> events, long? expectedVersion = null);</p>
<p>    </p>
<p>    // Load events from a stream</p>
<p>    IAsyncEnumerable<IEvent> Load(string stream, long from = 0);</p>
<p>    </p>
<p>    // Subscribe to events</p>
<p>    IDisposable Subscribe(string stream, Func<IEvent, Task> handler);</p>
<p>    </p>
<p>    // Snapshot support</p>
<p>    Task SaveSnapshot(string stream, object snapshot);</p>
<p>    Task<T?> LoadSnapshot<T>(string stream);</p>
<p>}</p>
<p></code></pre></p>

<h3>7. Drivers</h3>
<strong>Storage abstraction layer</strong>

<pre><code class="language-csharp">public interface IDriver {
<p>    // Execute queries</p>
<p>    Task<T> Query<T>(IQuery<T> query);</p>
<p>    </p>
<p>    // Execute commands</p>
<p>    Task Execute(ICommand command);</p>
<p>    </p>
<p>    // Transaction support</p>
<p>    Task<T> Transaction<T>(Func<ITransaction, Task<T>> action);</p>
<p>    </p>
<p>    // Migration support</p>
<p>    Task Migrate(IMigration migration);</p>
<p>}</p>
<p></code></pre></p>

<p>Drivers available:</p>
<ul><li><strong>InMemoryDriver</strong>: Development and testing</li>
<li><strong>PostgreSQLDriver</strong>: JSONB support</li>
<li><strong>SqlServerDriver</strong>: JSON columns</li>
<li><strong>SQLiteDriver</strong>: Edge scenarios</li>
<li><strong>Custom</strong>: Implement IDriver</li>
</ul>
<h3>8. Transports</h3>
<strong>Message broker abstraction</strong>

<pre><code class="language-csharp">public interface ITransport {
<p>    // Send messages</p>
<p>    Task Send<T>(string destination, T message);</p>
<p>    </p>
<p>    // Subscribe to messages</p>
<p>    IDisposable Subscribe<T>(string source, Func<T, Task> handler);</p>
<p>    </p>
<p>    // Request-Reply pattern</p>
<p>    Task<TResponse> Request<TRequest, TResponse>(string destination, TRequest request);</p>
<p>}</p>
<p></code></pre></p>

<p>Transports available:</p>
<ul><li><strong>InMemoryTransport</strong>: Development and testing</li>
<li><strong>KafkaTransport</strong>: High-throughput streaming</li>
<li><strong>RabbitMQTransport</strong>: Reliable messaging</li>
<li><strong>AzureServiceBusTransport</strong>: Cloud-native</li>
<li><strong>Custom</strong>: Implement ITransport</li>
</ul>
<h2>Message Flow Patterns</h2>

<h3>1. Command Flow (Event-Driven Mode)</h3>
<pre><code class="language-">Command → Dispatcher → Receptor → Event → Perspectives → Storage
<p>                          ↓</p>
<p>                        Lens ← Query</p>
<p></code></pre></p>

<h3>2. Command Flow (Event-Sourced Mode)</h3>
<pre><code class="language-">Command → Dispatcher → Receptor → Event → Ledger
<p>                                     ↓</p>
<p>                              Perspectives → Read Models</p>
<p>                                     ↓</p>
<p>                                   Lens ← Query</p>
<p></code></pre></p>

<h3>3. Query Flow</h3>
<pre><code class="language-">Query → Lens → Storage → Result
<p></code></pre></p>

<h3>4. Saga Flow</h3>
<pre><code class="language-">Event → Saga Coordinator → Command → Receptor
<p>          ↓                   ↓</p>
<p>      Saga State          New Event → Continue/Complete</p>
<p></code></pre></p>

<h2>Progressive Enhancement Path</h2>

<h3>Level 1: In-Process Event-Driven</h3>
<pre><code class="language-csharp">services.AddWhizbang()
<p>    .UseInMemory();  // Everything in-memory</p>
<p></code></pre></p>
<ul><li>Commands → Receptors → Events → Perspectives</li>
<li>All synchronous, in-process</li>
<li>Perfect for development</li>
</ul>
<h3>Level 2: Event-Sourced</h3>
<pre><code class="language-csharp">services.AddWhizbang()
<p>    .UseEventSourcing()</p>
<p>    .UseInMemory();  // In-memory event store</p>
<p></code></pre></p>
<ul><li>Add event store (Ledger)</li>
<li>Support stateful receptors</li>
<li>Enable projections</li>
</ul>
<h3>Level 3: Persistent</h3>
<pre><code class="language-csharp">services.AddWhizbang()
<p>    .UseEventSourcing()</p>
<p>    .UsePostgreSQL("connection-string");</p>
<p></code></pre></p>
<ul><li>Real database persistence</li>
<li>Production-ready storage</li>
<li>Schema migrations</li>
</ul>
<h3>Level 4: Distributed</h3>
<pre><code class="language-csharp">services.AddWhizbang()
<p>    .UseEventSourcing()</p>
<p>    .UsePostgreSQL("connection-string")</p>
<p>    .UseKafka("bootstrap-servers");</p>
<p></code></pre></p>
<ul><li>Distributed messaging</li>
<li>Microservices ready</li>
<li>Saga orchestration</li>
</ul>
<h2>Component Relationships</h2>

<h3>Compile-Time Relationships</h3>
<ul><li><strong>Source Generators</strong> discover and wire components</li>
<li><strong>Analyzers</strong> validate relationships</li>
<li><strong>Generated Code</strong> creates efficient dispatch tables</li>
</ul>
<h3>Runtime Relationships</h3>
<ul><li><strong>Dispatcher</strong> coordinates all message flow</li>
<li><strong>Policy Engine</strong> wraps component execution</li>
<li><strong>Traceability</strong> observes all operations</li>
<li><strong>Ledger</strong> persists all events</li>
</ul>
<h3>Testing Relationships</h3>
<ul><li><strong>In-Memory Implementations</strong> serve as test doubles</li>
<li><strong>Test Harness</strong> provides scenario execution</li>
<li><strong>Verification</strong> uses recorded interactions</li>
</ul>
<h2>Key Design Decisions</h2>

<h3>Why Receptors Instead of Handlers?</h3>
<ul><li>Receptors emphasize decision-making over handling</li>
<li>They're the same interface for stateless and stateful</li>
<li>They make the event-driven nature explicit</li>
<li>They separate concerns better than traditional handlers</li>
</ul>
<h3>Why Perspectives Instead of Projections?</h3>
<ul><li>Perspectives are more general than projections</li>
<li>They handle all write operations, not just read models</li>
<li>They can update multiple stores</li>
<li>They emphasize the "view" nature of the data</li>
</ul>
<h3>Why Lenses for Queries?</h3>
<ul><li>Lenses are composable</li>
<li>They're purely functional</li>
<li>They separate query concerns from storage</li>
<li>They enable query optimization</li>
</ul>
<h3>Why Policies Instead of Aspects?</h3>
<ul><li>Policies are more explicit</li>
<li>They're composable and configurable</li>
<li>They're testable in isolation</li>
<li>They avoid AOP magic</li>
</ul>
<h2>Extension Points</h2>

<h3>Custom Components</h3>
<ul><li>Implement <code>IReceptor<T></code> for custom command handling</li>
<li>Implement <code>IPerspectiveOf<T></code> for custom event handling</li>
<li>Implement <code>ILens</code> for custom queries</li>
<li>Implement <code>IPolicyOf<T></code> for custom policies</li>
</ul>
<h3>Custom Drivers</h3>
<ul><li>Implement <code>IDriver</code> for new databases</li>
<li>Implement <code>ITransport</code> for new message brokers</li>
<li>Implement <code>ILedger</code> for custom event stores</li>
</ul>
<h3>Source Generator Extensions</h3>
<ul><li>Add custom attributes for discovery</li>
<li>Generate specialized dispatch code</li>
<li>Create domain-specific optimizations</li>
</ul>
<h2>Performance Architecture</h2>

<h3>Compile-Time Optimizations</h3>
<ul><li>Generated dispatch tables (no reflection)</li>
<li>Inlined serialization code</li>
<li>Pre-compiled expressions</li>
<li>AOT-friendly code</li>
</ul>
<h3>Runtime Optimizations</h3>
<ul><li>Object pooling for messages</li>
<li>Zero-allocation patterns</li>
<li>Efficient async state machines</li>
<li>Minimal boxing/unboxing</li>
</ul>
<h3>Storage Optimizations</h3>
<ul><li>Batch operations</li>
<li>Prepared statements</li>
<li>Connection pooling</li>
<li>Query plan caching</li>
</ul>
<p>This architecture provides a solid foundation that scales from simple in-process messaging to complex distributed event-sourced systems, all while maintaining the same programming model.</p>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="roadmap-philosophy" class="doc-section">
  <h2>Implementation Philosophy</h2>
  <p class="doc-path"><code>roadmap/philosophy</code></p>
  <p class="doc-description"><em>Core principles and philosophy driving the Whizbang implementation</em></p>
  <div class="doc-content">

<h1>Implementation Philosophy</h1>

<h2>Core Principles</h2>

<h3>1. Zero Reflection - Compile-Time Everything</h3>

<strong>We never use reflection. Ever.</strong>

<ul><li>All handler discovery happens at compile time via source generators</li>
<li>All routing tables are generated during compilation</li>
<li>All serialization code is generated, not reflected</li>
<li>Type information is captured at compile time, not runtime</li>
</ul>
<pre><code class="language-csharp">// ❌ NEVER THIS
<p>var handlers = Assembly.GetExecutingAssembly()</p>
<p>    .GetTypes()</p>
<p>    .Where(t => t.IsAssignableTo(typeof(IHandler)));</p>

<p>// ✅ ALWAYS THIS</p>
<p>[WhizbangHandler]  // Source generator finds this at compile time</p>
<p>public class OrderHandler : IReceptor<CreateOrder> { }</p>
<p></code></pre></p>

<h3>2. IDE-First Development</h3>

<strong>The IDE experience is not an afterthought - it's foundational.</strong>

<p>From day one, we provide:</p>
<ul><li><strong>CodeLens-style references</strong>: See handler counts, event publishers, consumers</li>
<li><strong>Traceability overlays</strong>: Visualize message flow inline</li>
<li><strong>Time-travel debugging</strong>: Step through message history</li>
<li><strong>Smart navigation</strong>: Jump between commands, handlers, and events</li>
<li><strong>Compile-time validation</strong>: Catch errors before runtime</li>
</ul>
<pre><code class="language-csharp">// The IDE shows: "3 handlers | 2 perspectives | Last: 50ms ago"
<p>public record OrderCreated(Guid OrderId);  </p>

<p>// The IDE shows: "Handles: CreateOrder | Publishes: OrderCreated"</p>
<p>public class OrderReceptor : IReceptor<CreateOrder> { }</p>
<p></code></pre></p>

<h3>3. Test-Driven from the Start</h3>

<strong>Testing is not bolted on - it's built in.</strong>

<ul><li><strong>TUnit</strong> for modern, fast, parallel testing</li>
<li><strong>Bogus</strong> for realistic scenario generation</li>
<li><strong>Behavior Specs</strong> for BDD-style testing</li>
<li><strong>In-Memory Doubles</strong> that become production test doubles</li>
<li><strong>Property-Based Testing</strong> for edge case discovery</li>
</ul>
<pre><code class="language-csharp">[Test]
<p>[MethodDataSource(nameof(OrderScenarios))]  // Bogus generates scenarios</p>
<p>public async Task CreateOrder_ShouldEmitExpectedEvents(OrderScenario scenario) {</p>
<p>    // Every component is testable from day one</p>
<p>    var result = await dispatcher.Send(scenario.Command);</p>
<p>    await Verify.That(result).Matches(scenario.Expected);</p>
<p>}</p>
<p></code></pre></p>

<h3>4. Progressive Enhancement</h3>

<strong>Start simple, enhance iteratively, maintain compatibility.</strong>

<pre><code class="language-csharp">// v0.1.0 - Simple in-memory
<p>services.AddWhizbang().UseInMemory();</p>

<p>// v0.3.0 - Add event sourcing (same code still works!)</p>
<p>services.AddWhizbang().UseEventSourcing().UseInMemory();</p>

<p>// v0.4.0 - Add persistence (same code still works!)</p>
<p>services.AddWhizbang().UseEventSourcing().UsePostgreSQL();</p>

<p>// v0.5.0 - Add distribution (same code still works!)</p>
<p>services.AddWhizbang().UseEventSourcing().UsePostgreSQL().UseKafka();</p>
<p></code></pre></p>

<h3>5. Breadth-First Implementation</h3>

<strong>All components exist from day one, even if simple.</strong>

<p>We don't build deep, then wide. We build wide, then deep:</p>
<ul><li>v0.1.0 has EVERY component (dispatcher, receptors, perspectives, lenses, policies, ledger, drivers, transports)</li>
<li>Each component starts thin but functional</li>
<li>We enhance all components together, maintaining consistency</li>
<li>No component is "coming later" - everything is always available</li>
</ul>
<h3>6. In-Memory First</h3>

<strong>Everything starts in-memory, which becomes our testing foundation.</strong>

<ul><li>In-memory implementations are not throwaway code</li>
<li>They become the test doubles for unit testing</li>
<li>They provide fast feedback during development</li>
<li>They enable offline development</li>
<li>They're always available as a fallback</li>
</ul>
<pre><code class="language-csharp">// In-memory implementations are first-class citizens
<p>public class InMemoryLedger : ILedger {</p>
<p>    // This becomes our test double AND our development database</p>
<p>}</p>
<p></code></pre></p>

<h3>7. Performance by Design</h3>

<strong>Performance is not an optimization - it's a requirement.</strong>

<ul><li><strong>Zero allocation</strong> patterns from the start</li>
<li><strong>Source generation</strong> for hot paths</li>
<li><strong>Compile-time optimization</strong> via generators</li>
<li><strong>AOT compatibility</strong> from day one</li>
<li><strong>Benchmark everything</strong> with BenchmarkDotNet</li>
</ul>
<pre><code class="language-csharp">// Generated code is faster than runtime reflection
<p>[Generated]</p>
<p>public static class OrderHandlerDispatcher {</p>
<p>    // Source-generated dispatch table - zero reflection, zero allocation</p>
<p>    public static readonly Dictionary<Type, Delegate> Handlers = new() {</p>
<p>        [typeof(CreateOrder)] = OrderReceptor.Handle_CreateOrder</p>
<p>    };</p>
<p>}</p>
<p></code></pre></p>

<h3>8. Developer Experience is User Experience</h3>

<strong>For a library, developers ARE the users.</strong>

<ul><li><strong>Clear, actionable error messages</strong> with suggested fixes</li>
<li><strong>Comprehensive IntelliSense</strong> documentation</li>
<li><strong>Analyzers that guide</strong> not just validate</li>
<li><strong>Code fixes</strong> for common patterns</li>
<li><strong>Visual debugging</strong> tools built-in</li>
</ul>
<pre><code class="language-csharp">// Analyzer: "OrderCreated event is not handled by any perspective"
<p>// Code Fix: "Generate OrderPerspective class"</p>
<p>// Quick Action: "Add handler for OrderCreated"</p>
<p></code></pre></p>

<h3>9. Policies as First-Class Citizens</h3>

<strong>Cross-cutting concerns are not aspects - they're policies.</strong>

<p>Policies are:</p>
<ul><li>Composable</li>
<li>Testable</li>
<li>Measurable</li>
<li>Configurable</li>
<li>Discoverable</li>
</ul>
<pre><code class="language-csharp">[Retry(3)]
<p>[Timeout(5000)]</p>
<p>[Cache(300)]</p>
<p>[Authorize("OrderAdmin")]</p>
<p>public class OrderReceptor : IReceptor<CreateOrder> {</p>
<p>    // Policies are composed and applied via source generation</p>
<p>}</p>
<p></code></pre></p>

<h3>10. Traceability Built-In</h3>

<strong>Every message is traceable, every decision is observable.</strong>

<p>From v0.1.0:</p>
<ul><li>Correlation IDs flow automatically</li>
<li>Causation chains are tracked</li>
<li>Timing information is captured</li>
<li>Decision points are recorded</li>
<li>OpenTelemetry hooks are everywhere</li>
</ul>
<pre><code class="language-csharp">// Every message carries its history
<p>public interface IMessageContext {</p>
<p>    Guid CorrelationId { get; }</p>
<p>    Guid CausationId { get; }</p>
<p>    DateTimeOffset Timestamp { get; }</p>
<p>    Dictionary<string, object> Metadata { get; }</p>
<p>    ISpan? Span { get; }  // OpenTelemetry span</p>
<p>}</p>
<p></code></pre></p>

<h2>Anti-Patterns We Avoid</h2>

<h3>❌ No Reflection</h3>
<ul><li>No assembly scanning</li>
<li>No runtime type discovery</li>
<li>No dynamic invocation</li>
<li>No expression tree compilation at runtime</li>
</ul>
<h3>❌ No Magic</h3>
<ul><li>Explicit over implicit</li>
<li>Convention with configuration</li>
<li>Discoverable behavior</li>
<li>No hidden side effects</li>
</ul>
<h3>❌ No Framework Lock-In</h3>
<ul><li>Abstractions over implementations</li>
<li>Swappable components</li>
<li>Standard interfaces</li>
<li>Minimal dependencies</li>
</ul>
<h3>❌ No Untestable Code</h3>
<ul><li>Everything has an interface</li>
<li>Everything has a test double</li>
<li>Everything is observable</li>
<li>Everything is measurable</li>
</ul>
<h2>Implementation Strategy</h2>

<h3>Phase 1: Foundation (v0.1.0)</h3>
<p>Build wide - every component exists, even if simple.</p>

<h3>Phase 2: Enhancement (v0.2.0-v0.3.0)</h3>
<p>Build deep - enhance each component iteratively.</p>

<h3>Phase 3: Production (v0.4.0-v0.5.0)</h3>
<p>Build real - replace in-memory with production implementations.</p>

<h3>Phase 4: Scale (v0.6.0+)</h3>
<p>Build up - add enterprise features and optimizations.</p>

<h2>Measuring Success</h2>

<p>We measure success by:</p>
<ul><li><strong>Zero reflection</strong> in production code</li>
<li><strong>100% test coverage</strong> of public APIs</li>
<li><strong>Sub-millisecond</strong> in-memory operations</li>
<li><strong>Single-digit millisecond</strong> database operations</li>
<li><strong>No breaking changes</strong> within major versions</li>
<li><strong>Compile-time safety</strong> for all operations</li>
<li><strong>Developer satisfaction</strong> via feedback</li>
</ul>
<h2>The Whizbang Promise</h2>

<p>When you use Whizbang, you get:</p>
<ul><li><strong>Performance</strong> without complexity</li>
<li><strong>Safety</strong> without ceremony</li>
<li><strong>Power</strong> without lock-in</li>
<li><strong>Flexibility</strong> without magic</li>
<li><strong>Observability</strong> without overhead</li>
</ul>
<p>This is not just a messaging library. This is a new way of building .NET applications.</p>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="roadmap-success-metrics" class="doc-section">
  <h2>Success Metrics</h2>
  <p class="doc-path"><code>roadmap/success-metrics</code></p>
  <p class="doc-description"><em>How we measure success for each version and component of Whizbang</em></p>
  <div class="doc-content">

<h1>Success Metrics</h1>

<h2>Overview</h2>

<p>Success is measured across multiple dimensions: technical performance, code quality, developer experience, and adoption. Each version has specific success criteria that must be met before moving forward.</p>

<h2>Version-Specific Success Criteria</h2>

<h3>v0.1.0 - Foundation Success</h3>

<h4>Core Functionality</h4>
<ul><li>✅ All 8 core components have working implementations</li>
<li>✅ Source generators discover and wire all handlers</li>
<li>✅ Zero reflection in production code</li>
<li>✅ All components work with in-memory implementations</li>
<li>✅ Basic policy engine with 4+ policies working</li>
</ul>
<h4>Developer Experience</h4>
<ul><li>✅ IDE shows handler references via CodeLens</li>
<li>✅ Analyzers catch 5+ common mistakes</li>
<li>✅ Code fixes available for all analyzer warnings</li>
<li>✅ IntelliSense works for all public APIs</li>
<li>✅ Traceability shows message flow</li>
</ul>
<h4>Testing</h4>
<ul><li>✅ TUnit integration complete</li>
<li>✅ Bogus generates 10+ scenario types</li>
<li>✅ Behavior specs framework working</li>
<li>✅ 100% test coverage of public APIs</li>
<li>✅ All in-memory implementations usable as test doubles</li>
</ul>
<h4>Performance</h4>
<ul><li>✅ < 1ms for in-memory message dispatch</li>
<li>✅ < 100μs for handler invocation</li>
<li>✅ Zero allocations in hot path</li>
<li>✅ Source generator < 1s for 1000 handlers</li>
</ul>
<h3>v0.2.0 - Event-Driven Enhancement Success</h3>

<h4>Functionality</h4>
<ul><li>✅ Validation attributes work on all commands</li>
<li>✅ Multiple perspectives can handle same event</li>
<li>✅ Lens methods support pagination</li>
<li>✅ Policy composition works correctly</li>
<li>✅ Batch operations supported</li>
</ul>
<h4>Performance</h4>
<ul><li>✅ < 1ms for event publishing to 10 perspectives</li>
<li>✅ Parallel perspective execution where safe</li>
<li>✅ Query optimization via generated SQL</li>
</ul>
<h3>v0.3.0 - Event Sourcing Success</h3>

<h4>Functionality</h4>
<ul><li>✅ Stateful receptors maintain state correctly</li>
<li>✅ Event store supports optimistic concurrency</li>
<li>✅ Projections can rebuild from events</li>
<li>✅ Snapshots improve load time by 10x</li>
<li>✅ Version conflicts detected and handled</li>
</ul>
<h4>Performance</h4>
<ul><li>✅ < 10ms to load aggregate with 100 events</li>
<li>✅ < 1ms with snapshot</li>
<li>✅ < 100ms to rebuild projection with 1000 events</li>
</ul>
<h3>v0.4.0 - Real Persistence Success</h3>

<h4>Functionality</h4>
<ul><li>✅ All 3 database drivers pass same test suite</li>
<li>✅ Migrations work across all databases</li>
<li>✅ Multi-tenancy isolation verified</li>
<li>✅ Indexes improve query performance by 10x</li>
</ul>
<h4>Performance</h4>
<ul><li>✅ < 10ms for single event append</li>
<li>✅ < 50ms for batch of 100 events</li>
<li>✅ < 5ms for indexed queries</li>
<li>✅ Connection pooling reduces latency by 50%</li>
</ul>
<h3>v0.5.0 - Distributed Systems Success</h3>

<h4>Functionality</h4>
<ul><li>✅ All transports pass same test suite</li>
<li>✅ Outbox pattern prevents message loss</li>
<li>✅ Saga orchestration handles failures</li>
<li>✅ Distributed tracing works end-to-end</li>
</ul>
<h4>Performance</h4>
<ul><li>✅ < 100ms p99 for distributed operations</li>
<li>✅ Kafka: > 10,000 msg/sec throughput</li>
<li>✅ RabbitMQ: < 10ms latency</li>
<li>✅ Saga compensation < 1s</li>
</ul>
<h2>Performance Benchmarks</h2>

<h3>Baseline Performance Targets</h3>

<pre><code class="language-csharp">[Benchmark]
<p>public class DispatcherBenchmarks {</p>
<p>    // Target: < 100ns</p>
<p>    [Benchmark]</p>
<p>    public Task DirectHandlerInvocation() { }</p>
<p>    </p>
<p>    // Target: < 1μs</p>
<p>    [Benchmark]</p>
<p>    public Task DispatchedHandlerInvocation() { }</p>
<p>    </p>
<p>    // Target: < 10μs</p>
<p>    [Benchmark]</p>
<p>    public Task DispatchWithPolicies() { }</p>
<p>}</p>
<p></code></pre></p>

<h3>Memory Allocation Targets</h3>

<p>| Operation | Target Allocation |</p>
<p>|-----------|------------------|</p>
<p>| Message Dispatch | 0 bytes |</p>
<p>| Handler Invocation | 0 bytes |</p>
<p>| Event Publishing | 0 bytes |</p>
<p>| Simple Query | < 1KB |</p>
<p>| Complex Query | < 10KB |</p>
<p>| Aggregate Load | < Size of Events |</p>

<h3>Throughput Targets</h3>

<p>| Component | Target Throughput |</p>
<p>|-----------|------------------|</p>
<p>| In-Memory Dispatcher | > 1M msg/sec |</p>
<p>| In-Memory Event Store | > 100K events/sec |</p>
<p>| PostgreSQL Driver | > 10K events/sec |</p>
<p>| Kafka Transport | > 100K msg/sec |</p>
<p>| RabbitMQ Transport | > 10K msg/sec |</p>

<h3>Latency Targets (p99)</h3>

<p>| Operation | In-Memory | Database | Distributed |</p>
<p>|-----------|-----------|----------|-------------|</p>
<p>| Command Dispatch | < 1ms | < 10ms | < 100ms |</p>
<p>| Event Publishing | < 1ms | < 10ms | < 100ms |</p>
<p>| Query Execution | < 1ms | < 5ms | < 50ms |</p>
<p>| Aggregate Load | < 1ms | < 10ms | N/A |</p>
<p>| Projection Update | < 1ms | < 10ms | < 100ms |</p>

<h2>Code Quality Metrics</h2>

<h3>Test Coverage Requirements</h3>

<p>| Component | Unit Test | Integration Test | Coverage |</p>
<p>|-----------|-----------|------------------|----------|</p>
<p>| Core Interfaces | Required | Required | 100% |</p>
<p>| Source Generators | Required | Required | 100% |</p>
<p>| Public APIs | Required | Required | 100% |</p>
<p>| Internal Code | Required | Optional | > 90% |</p>
<p>| Generated Code | Optional | Required | > 80% |</p>

<h3>Documentation Requirements</h3>

<ul><li>✅ Every public type has XML documentation</li>
<li>✅ Every public method has examples</li>
<li>✅ Every configuration option documented</li>
<li>✅ Architecture decisions recorded</li>
<li>✅ Migration guides for version upgrades</li>
</ul>
<h3>Code Analysis Metrics</h3>

<p>| Metric | Target |</p>
<p>|--------|--------|</p>
<p>| Cyclomatic Complexity | < 10 |</p>
<p>| Maintainability Index | > 80 |</p>
<p>| Code Coverage | > 95% |</p>
<p>| Technical Debt Ratio | < 5% |</p>
<p>| Duplicated Code | < 3% |</p>

<h2>Developer Experience Metrics</h2>

<h3>IDE Integration</h3>

<ul><li>✅ IntelliSense response < 100ms</li>
<li>✅ Code fixes available < 500ms</li>
<li>✅ Navigation works in < 100ms</li>
<li>✅ Refactoring preserves correctness</li>
<li>✅ Debugging symbols always available</li>
</ul>
<h3>Error Messages</h3>

<p>Quality criteria for error messages:</p>
<ul><li><strong>Actionable</strong>: Tell the developer what to do</li>
<li><strong>Contextual</strong>: Include relevant information</li>
<li><strong>Linkable</strong>: Link to documentation</li>
<li><strong>Fixable</strong>: Provide code fixes where possible</li>
</ul>
<p>Example:</p>
<pre><code class="language-">Error WB0001: Handler signature mismatch
<p>  The handler 'OrderHandler.Handle' has an invalid signature.</p>
<p>  Expected: Task<OrderCreated> Handle(CreateOrder command, IOrderLens lens)</p>
<p>  Actual: OrderCreated Handle(CreateOrder command)</p>
<p>  </p>
<p>  Fix: Add async Task<> return type and IOrderLens parameter</p>
<p>  Docs: https://whizbang.dev/errors/WB0001</p>
<p>  </p>
<p>  Quick Fix Available: Press Ctrl+. to apply</p>
<p></code></pre></p>

<h3>Build Time Metrics</h3>

<p>| Operation | Target Time |</p>
<p>|-----------|------------|</p>
<p>| Clean Build | < 10s |</p>
<p>| Incremental Build | < 2s |</p>
<p>| Source Generator | < 1s per 1000 types |</p>
<p>| Analyzer Execution | < 500ms |</p>
<p>| Test Execution | < 5s for 1000 tests |</p>

<h2>Adoption Metrics</h2>

<h3>Community Engagement</h3>

<p>Target metrics for community health:</p>
<ul><li>GitHub Stars: > 1,000 in year 1</li>
<li>Contributors: > 50 unique contributors</li>
<li>Issues Response: < 24 hours</li>
<li>PR Review: < 48 hours</li>
<li>Documentation Traffic: > 10,000 monthly views</li>
</ul>
<h3>Production Readiness</h3>

<p>Checklist for production readiness:</p>
<ul><li>✅ Used in 10+ production applications</li>
<li>✅ Processing > 1M messages/day in production</li>
<li>✅ 99.99% uptime achieved</li>
<li>✅ Security audit passed</li>
<li>✅ Performance benchmarks published</li>
</ul>
<h3>Package Metrics</h3>

<p>| Package | Target Downloads (Year 1) |</p>
<p>|---------|---------------------------|</p>
<p>| Whizbang.Core | > 100,000 |</p>
<p>| Whizbang.Generators | > 100,000 |</p>
<p>| Whizbang.PostgreSQL | > 50,000 |</p>
<p>| Whizbang.Kafka | > 25,000 |</p>
<p>| Whizbang.Testing | > 75,000 |</p>

<h2>Continuous Monitoring</h2>

<h3>Automated Metrics Collection</h3>

<pre><code class="language-yaml"># CI/CD Pipeline Metrics
<p>on:</p>
<p>  push:</p>
<p>    branches: [main]</p>
<p>  </p>
<p>jobs:</p>
<p>  metrics:</p>
<p>    steps:</p>
<p>      - name: Performance Benchmarks</p>
<p>        run: dotnet run -c Release --project benchmarks</p>
<p>        </p>
<p>      - name: Code Coverage</p>
<p>        run: dotnet test --collect:"XPlat Code Coverage"</p>
<p>        </p>
<p>      - name: Static Analysis</p>
<p>        run: dotnet analyze</p>
<p>        </p>
<p>      - name: API Compatibility</p>
<p>        run: dotnet apicompat</p>
<p>        </p>
<p>      - name: Package Size</p>
<p>        run: dotnet pack --measure-size</p>
<p></code></pre></p>

<h3>Dashboard Metrics</h3>

<p>Real-time dashboard tracking:</p>
<ul><li>Build success rate</li>
<li>Test pass rate</li>
<li>Performance regression detection</li>
<li>Code coverage trends</li>
<li>API breaking changes</li>
<li>Package download stats</li>
<li>Issue/PR velocity</li>
<li>Documentation coverage</li>
</ul>
<h2>Success Evaluation</h2>

<h3>Version Release Criteria</h3>

<p>A version is ready for release when:</p>
<ul><li>All success criteria are met</li>
<li>No critical bugs remain</li>
<li>Performance targets achieved</li>
<li>Documentation complete</li>
<li>Migration guide written</li>
<li>Breaking changes documented</li>
<li>All tests passing</li>
<li>Security scan clean</li>
</ul>
<h3>Go/No-Go Decision Matrix</h3>

<p>| Criterion | Weight | v0.1.0 | v0.2.0 | v0.3.0 | v0.4.0 | v0.5.0 |</p>
<p>|-----------|--------|--------|--------|--------|--------|--------|</p>
<p>| Functionality | 30% | ✅ | - | - | - | - |</p>
<p>| Performance | 25% | ✅ | - | - | - | - |</p>
<p>| Quality | 20% | ✅ | - | - | - | - |</p>
<p>| Documentation | 15% | ✅ | - | - | - | - |</p>
<p>| Developer Experience | 10% | ✅ | - | - | - | - |</p>

<h3>Retrospective Questions</h3>

<p>After each version:</p>
<ul><li>What succeeded beyond expectations?</li>
<li>What fell short of targets?</li>
<li>What surprised us?</li>
<li>What should we change?</li>
<li>What should we keep?</li>
</ul>
<h2>Long-Term Success Metrics</h2>

<h3>Year 1 Goals</h3>
<ul><li>5+ production deployments</li>
<li>1,000+ GitHub stars</li>
<li>100,000+ NuGet downloads</li>
<li>0 security vulnerabilities</li>
<li>< 5% technical debt</li>
</ul>
<h3>Year 2 Goals</h3>
<ul><li>50+ production deployments</li>
<li>5,000+ GitHub stars</li>
<li>1M+ NuGet downloads</li>
<li>Industry recognition</li>
<li>Case studies published</li>
</ul>
<h3>Ultimate Success</h3>
<p>Whizbang becomes the default choice for event-driven and event-sourced systems in .NET, known for:</p>
<ul><li>Zero-reflection performance</li>
<li>Exceptional developer experience</li>
<li>Progressive enhancement model</li>
<li>Production reliability</li>
<li>Comprehensive testing support</li></ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>
</section>

<section id="development"><h2>Development</h2>
<section id="drafts"><h3>Drafts</h3>
<article id="drafts-test-error-display" class="doc-section">
  <h2>Test Error Display</h2>
  <p class="doc-path"><code>drafts/test-error-display</code></p>
  <div class="doc-content">

<h1>Test Error Display</h1>

<p>This is a test page to verify that our front-matter error display is working.</p>

<h2>Code with Front-Matter (Should be fine)</h2>

<p>``<code>csharp{</p>
<p>title: "Good Example"</p>
<p>description: "This has proper front-matter"</p>
<p>framework: "NET8"</p>
<p>category: "Test"</p>
<p>difficulty: "BEGINNER"</p>
<p>tags: ["Test"]</p>
<p>}</p>
<p>public class GoodExample {</p>
<p>    public string Message { get; set; } = "I have front-matter!";</p>
<p>}</p>
<pre><code class="language-">
<h2>Code WITHOUT Front-Matter (Should show error)</h2>

<p></code></pre>csharp</p>
<p>public class BadExample {</p>
<p>    public string Message { get; set; } = "I need front-matter!";</p>
<p>}</p>
<pre><code class="language-">
<h2>Another Bad Example</h2>

<p></code></pre>javascript</p>
<p>function badFunction() {</p>
<p>    console.log("This JS code also needs front-matter!");</p>
<p>}</p>
<pre><code class="language-">
<h2>Non-Code Block (Should be fine)</h2>

<p></code></pre>text</p>
<p>This is just text, no error needed.</p>
<p></code>``</p>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<section class="doc-category">
  <h2 class="category-header">Attributes</h2>
<article id="drafts-attributes-must-exist" class="doc-section">
  <h3>MustExist Attribute</h3>
  <p class="doc-path"><code>drafts/attributes/must-exist</code></p>
  <p class="doc-description"><em>Marks a perspective Apply method as requiring the model to already exist</em></p>
  <div class="doc-content">

<h1>MustExist Attribute</h1>

<p>The <code>[MustExist]</code> attribute marks a perspective Apply method as requiring the model to already exist. When applied, the generated runner code includes a null check before calling the Apply method, throwing an <code>InvalidOperationException</code> if the current model is null.</p>

<h2>Namespace</h2>

<pre><code class="language-csharp">using Whizbang.Core.Perspectives;
<p></code></pre></p>

<h2>Syntax</h2>

<pre><code class="language-csharp">[MustExist]
<p>public TModel Apply(TModel current, TEvent @event) { ... }</p>
<p></code></pre></p>

<h2>Applies To</h2>

<ul><li><strong>Apply methods</strong> on perspective classes (types implementing <code>IPerspectiveFor<TModel, TEvent></code>)</li>
</ul>
<h2>Purpose</h2>

<p>The <code>[MustExist]</code> attribute serves two purposes:</p>

<ul><li><strong>Explicit Intent</strong>: Clearly signals that an Apply method handles "update" events where the model must have been created by a prior event</li>
<li><strong>Runtime Validation</strong>: The source generator produces a null check that throws a descriptive error before the Apply method is called</li>
</ul>
<h2>Generated Behavior</h2>

<p>When the generator encounters a method with <code>[MustExist]</code>, it produces:</p>

<pre><code class="language-csharp">case OrderShippedEvent typedEvent:
<p>  if (currentModel == null)</p>
<p>    throw new InvalidOperationException(</p>
<p>      "OrderModel must exist when applying OrderShippedEvent in OrderPerspective");</p>
<p>  return perspective.Apply(currentModel, typedEvent);</p>
<p></code></pre></p>

<h2>Basic Example</h2>

<pre><code class="language-csharp">public class OrderPerspective :
<p>    IPerspectiveFor<OrderView, OrderCreated>,</p>
<p>    IPerspectiveFor<OrderView, OrderShipped> {</p>

<p>  // Creation event - nullable parameter, handles initial creation</p>
<p>  public OrderView Apply(OrderView? current, OrderCreated @event) {</p>
<p>    return new OrderView {</p>
<p>      OrderId = @event.OrderId,</p>
<p>      CustomerId = @event.CustomerId,</p>
<p>      Status = "Created"</p>
<p>    };</p>
<p>  }</p>

<p>  // Update event - non-nullable parameter, requires existing model</p>
<p>  [MustExist]</p>
<p>  public OrderView Apply(OrderView current, OrderShipped @event) {</p>
<p>    return current with {</p>
<p>      Status = "Shipped",</p>
<p>      ShippedAt = @event.ShippedAt</p>
<p>    };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Parameter Nullability</h2>

<p>Use the nullable annotation to signal intent alongside <code>[MustExist]</code>:</p>

<p>| Scenario | Parameter Type | Attribute |</p>
<p>|----------|---------------|-----------|</p>
<p>| Creation event (may create new model) | <code>TModel?</code> | None |</p>
<p>| Update event (requires existing model) | <code>TModel</code> | <code>[MustExist]</code> |</p>

<h3>Non-Nullable Parameter (Recommended with [MustExist])</h3>

<p>When using <code>[MustExist]</code>, the parameter should be non-nullable to match the semantic meaning:</p>

<pre><code class="language-csharp">// Correct: Non-nullable parameter signals "model must exist"
<p>[MustExist]</p>
<p>public OrderView Apply(OrderView current, OrderShipped @event) {</p>
<p>  return current with { Status = "Shipped" };</p>
<p>}</p>
<p></code></pre></p>

<h3>Nullable Parameter (Without [MustExist])</h3>

<p>Without <code>[MustExist]</code>, the parameter should be nullable since the model may not exist yet:</p>

<pre><code class="language-csharp">// Correct: Nullable parameter signals "model may or may not exist"
<p>public OrderView Apply(OrderView? current, OrderCreated @event) {</p>
<p>  return new OrderView { OrderId = @event.OrderId };</p>
<p>}</p>
<p></code></pre></p>

<h2>Multiple Events Example</h2>

<p>Apply <code>[MustExist]</code> to each update event that requires an existing model:</p>

<pre><code class="language-csharp">public class AccountPerspective :
<p>    IPerspectiveFor<AccountView, AccountOpened>,</p>
<p>    IPerspectiveFor<AccountView, FundsDeposited>,</p>
<p>    IPerspectiveFor<AccountView, FundsWithdrawn>,</p>
<p>    IPerspectiveFor<AccountView, AccountClosed> {</p>

<p>  // Creation - no attribute, nullable parameter</p>
<p>  public AccountView Apply(AccountView? current, AccountOpened @event) {</p>
<p>    return new AccountView {</p>
<p>      AccountId = @event.AccountId,</p>
<p>      Balance = @event.InitialDeposit,</p>
<p>      Status = "Active"</p>
<p>    };</p>
<p>  }</p>

<p>  // Update - [MustExist], non-nullable parameter</p>
<p>  [MustExist]</p>
<p>  public AccountView Apply(AccountView current, FundsDeposited @event) {</p>
<p>    return current with { Balance = current.Balance + @event.Amount };</p>
<p>  }</p>

<p>  // Update - [MustExist], non-nullable parameter</p>
<p>  [MustExist]</p>
<p>  public AccountView Apply(AccountView current, FundsWithdrawn @event) {</p>
<p>    return current with { Balance = current.Balance - @event.Amount };</p>
<p>  }</p>

<p>  // Update - [MustExist], non-nullable parameter</p>
<p>  [MustExist]</p>
<p>  public AccountView Apply(AccountView current, AccountClosed @event) {</p>
<p>    return current with { Status = "Closed", ClosedAt = @event.ClosedAt };</p>
<p>  }</p>
<p>}</p>
<p></code></pre></p>

<h2>Error Message Format</h2>

<p>The generated error message includes:</p>
<ul><li><strong>Model type name</strong>: The type being updated</li>
<li><strong>Event type name</strong>: The event that triggered the error</li>
<li><strong>Perspective name</strong>: The perspective class where the error occurred</li>
</ul>
<p>Example error:</p>
<pre><code class="language-">InvalidOperationException: AccountView must exist when applying FundsWithdrawn in AccountPerspective
<p></code></pre></p>

<p>This detailed message helps developers quickly identify where the issue occurred.</p>

<h2>When to Use [MustExist]</h2>

<h3>Use When</h3>

<ul><li>The event is an "update" that modifies existing state</li>
<li>The event cannot logically occur without a prior creation event</li>
<li>You want fail-fast behavior instead of silent null handling</li>
</ul>
<h3>Examples Where [MustExist] Is Appropriate</h3>

<pre><code class="language-csharp">// OrderShipped requires an order to already exist
<p>[MustExist]</p>
<p>public OrderView Apply(OrderView current, OrderShipped @event) { ... }</p>

<p>// FundsWithdrawn requires an account to already exist</p>
<p>[MustExist]</p>
<p>public AccountView Apply(AccountView current, FundsWithdrawn @event) { ... }</p>

<p>// UserProfileUpdated requires a user profile to already exist</p>
<p>[MustExist]</p>
<p>public UserProfileView Apply(UserProfileView current, UserProfileUpdated @event) { ... }</p>
<p></code></pre></p>

<h3>Do NOT Use When</h3>

<ul><li>The event is a creation event</li>
<li>The event might be the first event for a stream</li>
<li>You want to handle null explicitly in the method body</li>
</ul>
<h2>Comparison: With vs Without [MustExist]</h2>

<h3>Without [MustExist] (Manual Null Check)</h3>

<pre><code class="language-csharp">public OrderView Apply(OrderView? current, OrderShipped @event) {
<p>  if (current is null)</p>
<p>    throw new InvalidOperationException("Order must exist");</p>

<p>  return current with { Status = "Shipped" };</p>
<p>}</p>
<p></code></pre></p>

<h3>With [MustExist] (Generated Null Check)</h3>

<pre><code class="language-csharp">[MustExist]
<p>public OrderView Apply(OrderView current, OrderShipped @event) {</p>
<p>  return current with { Status = "Shipped" };</p>
<p>}</p>
<p></code></pre></p>

<p>Benefits of using <code>[MustExist]</code>:</p>
<ul><li>Cleaner Apply method focuses on the transformation logic</li>
<li>Non-nullable parameter enforced by the generator</li>
<li>Consistent, descriptive error message format</li>
<li>No boilerplate null checks in business logic</li>
</ul>
<h2>Zero Reflection and AOT</h2>

<p>The <code>[MustExist]</code> attribute is processed at compile time by the source generator:</p>

<pre><code class="language-csharp">// Generated code - no runtime reflection
<p>case OrderShippedEvent typedEvent:</p>
<p>  if (currentModel == null)</p>
<p>    throw new InvalidOperationException(</p>
<p>      "OrderView must exist when applying OrderShippedEvent in OrderPerspective");</p>
<p>  return perspective.Apply(currentModel, typedEvent);</p>
<p></code></pre></p>

<p>This generated code:</p>
<ul><li>Works with Native AOT</li>
<li>Has zero runtime overhead</li>
<li>Is type-safe at compile-time</li>
</ul>
<h2>Migration from Marten</h2>

<p>When migrating from Marten projections, the Whizbang migration tool will:</p>
<ul><li>Identify Apply methods with non-nullable first parameters</li>
<li>Suggest adding <code>[MustExist]</code> attribute</li>
</ul>
<p>See <a href="../migration-guide/automated-migration.md">Automated Migration</a> for details.</p>

<h2>See Also</h2>

<ul><li><a href="../core-concepts/perspectives.md">Perspectives</a> - Understanding perspectives and Apply methods</li>
<li><a href="./streamkey.md">StreamKey Attribute</a> - Identifying stream keys for event ordering</li>
<li><a href="../migration-guide/automated-migration.md">Automated Migration</a> - Migrating from Marten/Wolverine</li>
</ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

<section class="doc-category">
  <h2 class="category-header">Core Concepts</h2>
<article id="drafts-core-concepts-model-action" class="doc-section">
  <h3>Model Actions - Perspective Deletion Support</h3>
  <p class="doc-path"><code>drafts/core-concepts/model-action</code></p>
  <p class="doc-description"><em>Control perspective model lifecycle with ModelAction - support soft delete, hard delete (purge), and conditional updates in pure Apply methods</em></p>
  <div class="doc-content">

<h1>Model Actions - Perspective Deletion Support</h1>

<strong>ModelAction</strong> enables perspectives to signal what action should be taken on a model after applying an event. This supports the full lifecycle of read models including creation, updates, soft deletes, and hard deletes (purges).

<h2>Core Concept</h2>

<p>When a perspective applies an event, it may need to do more than just update the model:</p>
<ul><li><strong>Update</strong> the model with new data (default behavior)</li>
<li><strong>Soft delete</strong> the model (set <code>DeletedAt</code> timestamp)</li>
<li><strong>Hard delete</strong> the model (permanently remove from database)</li>
<li><strong>Skip update</strong> when no changes are needed</li>
</ul>
<p>ModelAction and ApplyResult provide these capabilities while maintaining the <strong>pure function</strong> nature of perspectives.</p>

<hr>

<h2>ModelAction Enum</h2>

<pre><code class="language-csharp">namespace Whizbang.Core.Perspectives;

<p>/// <summary></p>
<p>/// Specifies what action to take on a perspective model after Apply.</p>
<p>/// </summary></p>
<p>public enum ModelAction {</p>
<p>  /// <summary>No action - keep model as-is or use returned model.</summary></p>
<p>  None = 0,</p>

<p>  /// <summary>Soft delete - set DeletedAt timestamp on model.</summary></p>
<p>  Delete = 1,</p>

<p>  /// <summary>Hard delete - remove model from database entirely.</summary></p>
<p>  Purge = 2</p>
<p>}</p>
<p></code></pre></p>

<strong>Action Semantics</strong>:
<ul><li><code>None</code>: Standard behavior - upsert the returned model (or keep existing if null)</li>
<li><code>Delete</code>: Soft delete - model remains in database with <code>DeletedAt</code> timestamp set</li>
<li><code>Purge</code>: Hard delete - model is permanently removed from database</li>
</ul>
<hr>

<h2>Return Type Patterns</h2>

<p>Perspectives support multiple return types from <code>Apply()</code> methods, each suited to different scenarios:</p>

<h3>Pattern 1: <code>TModel</code> (Standard Update)</h3>

<p>Returns a model - always upserts.</p>

<pre><code class="language-csharp">public class OrderPerspective : IPerspectiveFor<OrderView, OrderCreated> {
<p>    public OrderView Apply(OrderView? current, OrderCreated @event) {</p>
<p>        return new OrderView {</p>
<p>            OrderId = @event.OrderId,</p>
<p>            Status = "Created",</p>
<p>            CreatedAt = @event.Timestamp</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Use when</strong>: Every event results in a model update.

<h3>Pattern 2: <code>TModel?</code> (Conditional Update)</h3>

<p>Returns nullable model - <code>null</code> means "no change, keep existing".</p>

<pre><code class="language-csharp">public class OrderPerspective : IPerspectiveFor<OrderView, OrderStatusChecked> {
<p>    public OrderView? Apply(OrderView current, OrderStatusChecked @event) {</p>
<p>        // Only update if status actually changed</p>
<p>        if (current.Status == @event.NewStatus) {</p>
<p>            return null;  // No change - skip upsert</p>
<p>        }</p>

<p>        return current with { Status = @event.NewStatus };</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Use when</strong>: Some events may not require updates.

<h3>Pattern 3: <code>ModelAction</code> (Delete/Purge Only)</h3>

<p>Returns action without model data.</p>

<pre><code class="language-csharp">public class OrderPerspective : IPerspectiveFor<OrderView, OrderCancelled> {
<p>    public ModelAction Apply(OrderView current, OrderCancelled @event) {</p>
<p>        return ModelAction.Delete;  // Soft delete</p>
<p>    }</p>
<p>}</p>

<p>public class OrderPerspective : IPerspectiveFor<OrderView, OrderPurged> {</p>
<p>    public ModelAction Apply(OrderView current, OrderPurged @event) {</p>
<p>        return ModelAction.Purge;  // Hard delete - remove from database</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Use when</strong>: Event signals deletion without data changes.

<h3>Pattern 4: <code>(TModel?, ModelAction)</code> Tuple (Hybrid)</h3>

<p>Returns both model and action for full control.</p>

<pre><code class="language-csharp">public class OrderPerspective : IPerspectiveFor<OrderView, OrderArchived> {
<p>    public (OrderView?, ModelAction) Apply(OrderView current, OrderArchived @event) {</p>
<p>        if (@event.PermanentDelete) {</p>
<p>            return (null, ModelAction.Purge);  // Hard delete</p>
<p>        }</p>

<p>        // Update then soft delete</p>
<p>        var updated = current with { ArchivedAt = @event.ArchivedAt };</p>
<p>        return (updated, ModelAction.Delete);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Use when</strong>: Event conditionally determines action, or you need to update before deleting.

<h3>Pattern 5: <code>ApplyResult<TModel></code> (Full Flexibility)</h3>

<p>Unified wrapper with factory methods and implicit conversions.</p>

<pre><code class="language-csharp">public class OrderPerspective : IPerspectiveFor<OrderView, OrderEvent> {
<p>    public ApplyResult<OrderView> Apply(OrderView current, OrderEvent @event) {</p>
<p>        return @event switch {</p>
<p>            OrderCreated e => ApplyResult<OrderView>.Update(new OrderView { OrderId = e.OrderId }),</p>
<p>            OrderCancelled _ => ApplyResult<OrderView>.Delete(),</p>
<p>            OrderPurged _ => ApplyResult<OrderView>.Purge(),</p>
<p>            OrderNoOp _ => ApplyResult<OrderView>.None(),</p>
<p>            _ => current  // Implicit conversion from TModel</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Use when</strong>: Complex event handling with multiple outcomes.

<hr>

<h2>ApplyResult Struct</h2>

<pre><code class="language-csharp">namespace Whizbang.Core.Perspectives;

<p>/// <summary></p>
<p>/// Result of applying an event to a perspective, containing optional model and action.</p>
<p>/// </summary></p>
<p>public readonly struct ApplyResult<TModel> where TModel : class {</p>
<p>    public TModel? Model { get; }</p>
<p>    public ModelAction Action { get; }</p>

<p>    public ApplyResult(TModel? model, ModelAction action = ModelAction.None) {</p>
<p>        Model = model;</p>
<p>        Action = action;</p>
<p>    }</p>

<p>    // Factory methods</p>
<p>    public static ApplyResult<TModel> None() => new(null, ModelAction.None);</p>
<p>    public static ApplyResult<TModel> Delete() => new(null, ModelAction.Delete);</p>
<p>    public static ApplyResult<TModel> Purge() => new(null, ModelAction.Purge);</p>
<p>    public static ApplyResult<TModel> Update(TModel model) => new(model, ModelAction.None);</p>

<p>    // Implicit conversions for clean syntax</p>
<p>    public static implicit operator ApplyResult<TModel>(TModel model) => new(model);</p>
<p>    public static implicit operator ApplyResult<TModel>(ModelAction action) => new(null, action);</p>
<p>    public static implicit operator ApplyResult<TModel>((TModel?, ModelAction) tuple) => new(tuple.Item1, tuple.Item2);</p>
<p>}</p>
<p></code></pre></p>

<strong>Factory Methods</strong>:
<ul><li><code>ApplyResult<T>.None()</code> - No change, keep existing model</li>
<li><code>ApplyResult<T>.Delete()</code> - Soft delete the model</li>
<li><code>ApplyResult<T>.Purge()</code> - Hard delete the model</li>
<li><code>ApplyResult<T>.Update(model)</code> - Update with new model</li>
</ul>
<strong>Implicit Conversions</strong>:
<pre><code class="language-csharp">// All of these work:
<p>ApplyResult<OrderView> result1 = new OrderView { OrderId = id };           // From TModel</p>
<p>ApplyResult<OrderView> result2 = ModelAction.Delete;                        // From ModelAction</p>
<p>ApplyResult<OrderView> result3 = (updatedModel, ModelAction.None);          // From tuple</p>
<p></code></pre></p>

<hr>

<h2>Soft Delete vs Hard Delete</h2>

<h3>Soft Delete (<code>ModelAction.Delete</code>)</h3>

<p>Model remains in database with <code>DeletedAt</code> timestamp:</p>

<pre><code class="language-csharp">// Model must have DeletedAt property
<p>public record OrderView {</p>
<p>    [StreamKey]</p>
<p>    public Guid OrderId { get; init; }</p>
<p>    public string Status { get; init; } = string.Empty;</p>
<p>    public DateTimeOffset? DeletedAt { get; init; }  // Required for soft delete</p>
<p>}</p>

<p>// Perspective signals soft delete</p>
<p>public class OrderPerspective : IPerspectiveFor<OrderView, OrderCancelled> {</p>
<p>    public (OrderView, ModelAction) Apply(OrderView current, OrderCancelled @event) {</p>
<p>        // Set DeletedAt and signal Delete action</p>
<p>        var deleted = current with { DeletedAt = @event.CancelledAt };</p>
<p>        return (deleted, ModelAction.Delete);</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Result</strong>: Model row updated with <code>deleted_at</code> timestamp. Lenses can filter out deleted records.

<h3>Hard Delete (<code>ModelAction.Purge</code>)</h3>

<p>Model is permanently removed from database:</p>

<pre><code class="language-csharp">public class OrderPerspective : IPerspectiveFor<OrderView, OrderPurged> {
<p>    public ModelAction Apply(OrderView current, OrderPurged @event) {</p>
<p>        return ModelAction.Purge;  // Row deleted from database</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<strong>Result</strong>: Model row physically deleted. Use for GDPR compliance, data retention policies, or test cleanup.

<hr>

<h2>IPerspectiveStore.PurgeAsync</h2>

<p>The perspective store provides the <code>PurgeAsync</code> method for hard deletes:</p>

<pre><code class="language-csharp">public interface IPerspectiveStore<TModel> where TModel : class {
<p>    // ... other methods ...</p>

<p>    /// <summary></p>
<p>    /// Hard deletes (purges) a model by removing it from the store entirely.</p>
<p>    /// This is a permanent deletion - the row is physically removed from the database.</p>
<p>    /// </summary></p>
<p>    Task PurgeAsync(Guid streamId, CancellationToken cancellationToken = default);</p>

<p>    /// <summary></p>
<p>    /// Hard deletes (purges) a model by partition key, removing it from the store entirely.</p>
<p>    /// </summary></p>
<p>    Task PurgeByPartitionKeyAsync<TPartitionKey>(</p>
<p>        TPartitionKey partitionKey,</p>
<p>        CancellationToken cancellationToken = default)</p>
<p>        where TPartitionKey : notnull;</p>
<p>}</p>
<p></code></pre></p>

<strong>Idempotent</strong>: Purging a non-existent model does not throw - it's a no-op.

<hr>

<h2>Generated Runner Behavior</h2>

<p>The source-generated perspective runner handles all return types and actions:</p>

<pre><code class="language-csharp">// Generated code (simplified)
<p>var (appliedModel, action) = ApplyEvent(perspective, updatedModel, @event);</p>

<p>switch (action) {</p>
<p>    case ModelAction.Delete:</p>
<p>        // Soft delete: keep model (may have DeletedAt set by perspective)</p>
<p>        updatedModel = appliedModel ?? updatedModel;</p>
<p>        break;</p>

<p>    case ModelAction.Purge:</p>
<p>        // Hard delete: mark for purge, skip upsert</p>
<p>        pendingPurge = true;</p>
<p>        updatedModel = null;</p>
<p>        break;</p>

<p>    default:</p>
<p>        // Normal update or no-change</p>
<p>        if (appliedModel != null) {</p>
<p>            updatedModel = appliedModel;</p>
<p>        }</p>
<p>        // null model with None = no change, keep existing</p>
<p>        break;</p>
<p>}</p>

<p>// At end of batch...</p>
<p>if (pendingPurge) {</p>
<p>    await _perspectiveStore.PurgeAsync(streamId, cancellationToken);</p>
<p>} else if (updatedModel != null) {</p>
<p>    await _perspectiveStore.UpsertAsync(streamId, updatedModel, cancellationToken);</p>
<p>}</p>
<p></code></pre></p>

<strong>Unit of Work</strong>: Actions are batched - all events applied, then single save/purge at end.

<hr>

<h2>Complete Example</h2>

<pre><code class="language-csharp">using Whizbang.Core;
<p>using Whizbang.Core.Perspectives;</p>

<p>// Events</p>
<p>public record OrderCreated([property: StreamKey] Guid OrderId, string CustomerId) : IEvent;</p>
<p>public record OrderShipped([property: StreamKey] Guid OrderId, DateTime ShippedAt) : IEvent;</p>
<p>public record OrderCancelled([property: StreamKey] Guid OrderId, DateTime CancelledAt) : IEvent;</p>
<p>public record OrderDeleted([property: StreamKey] Guid OrderId) : IEvent;</p>

<p>// Read Model</p>
<p>public record OrderView {</p>
<p>    [StreamKey]</p>
<p>    public Guid OrderId { get; init; }</p>
<p>    public string CustomerId { get; init; } = string.Empty;</p>
<p>    public string Status { get; init; } = string.Empty;</p>
<p>    public DateTime? ShippedAt { get; init; }</p>
<p>    public DateTimeOffset? DeletedAt { get; init; }</p>
<p>}</p>

<p>// Perspective handling all event types</p>
<p>public class OrderPerspective :</p>
<p>    IPerspectiveFor<OrderView, OrderCreated>,</p>
<p>    IPerspectiveFor<OrderView, OrderShipped>,</p>
<p>    IPerspectiveFor<OrderView, OrderCancelled>,</p>
<p>    IPerspectiveFor<OrderView, OrderDeleted> {</p>

<p>    // Creation - returns model</p>
<p>    public OrderView Apply(OrderView? current, OrderCreated @event) {</p>
<p>        return new OrderView {</p>
<p>            OrderId = @event.OrderId,</p>
<p>            CustomerId = @event.CustomerId,</p>
<p>            Status = "Created"</p>
<p>        };</p>
<p>    }</p>

<p>    // Update - returns model</p>
<p>    public OrderView Apply(OrderView current, OrderShipped @event) {</p>
<p>        return current with {</p>
<p>            Status = "Shipped",</p>
<p>            ShippedAt = @event.ShippedAt</p>
<p>        };</p>
<p>    }</p>

<p>    // Soft delete - returns tuple (model with DeletedAt, Delete action)</p>
<p>    public (OrderView, ModelAction) Apply(OrderView current, OrderCancelled @event) {</p>
<p>        var deleted = current with {</p>
<p>            Status = "Cancelled",</p>
<p>            DeletedAt = @event.CancelledAt</p>
<p>        };</p>
<p>        return (deleted, ModelAction.Delete);</p>
<p>    }</p>

<p>    // Hard delete - returns action only</p>
<p>    public ModelAction Apply(OrderView current, OrderDeleted @event) {</p>
<p>        return ModelAction.Purge;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Migration from Marten's ShouldDelete</h2>

<p>If migrating from Marten projections with <code>ShouldDelete</code>:</p>

<strong>Marten</strong>:
<pre><code class="language-csharp">public class OrderProjection : SingleStreamProjection<OrderView> {
<p>    public OrderView Create(OrderCreated @event) => new() { OrderId = @event.OrderId };</p>

<p>    public bool ShouldDelete(OrderCancelled @event) => true;  // Soft delete pattern</p>

<p>    public bool ShouldDelete(OrderDeleted @event, OrderView view) => true;</p>
<p>}</p>
<p></code></pre></p>

<strong>Whizbang</strong>:
<pre><code class="language-csharp">public class OrderPerspective :
<p>    IPerspectiveFor<OrderView, OrderCreated>,</p>
<p>    IPerspectiveFor<OrderView, OrderCancelled>,</p>
<p>    IPerspectiveFor<OrderView, OrderDeleted> {</p>

<p>    public OrderView Apply(OrderView? current, OrderCreated @event) {</p>
<p>        return new OrderView { OrderId = @event.OrderId };</p>
<p>    }</p>

<p>    // ShouldDelete → ModelAction.Delete</p>
<p>    public ModelAction Apply(OrderView current, OrderCancelled @event) {</p>
<p>        return ModelAction.Delete;</p>
<p>    }</p>

<p>    // For hard delete (if Marten was actually deleting rows):</p>
<p>    public ModelAction Apply(OrderView current, OrderDeleted @event) {</p>
<p>        return ModelAction.Purge;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<hr>

<h2>Best Practices</h2>

<h3>DO</h3>

<ul><li>Use <code>ModelAction.Delete</code> for soft deletes (preserves audit trail)</li>
<li>Use <code>ModelAction.Purge</code> for GDPR/data retention compliance</li>
<li>Return <code>null</code> with <code>ModelAction.None</code> to skip unnecessary upserts</li>
<li>Add <code>DateTimeOffset? DeletedAt</code> property to models that support soft delete</li>
<li>Test deletion scenarios in unit tests (pure functions, no mocking needed)</li>
</ul>
<h3>DON'T</h3>

<ul><li>Use <code>Purge</code> when you need audit history (soft delete instead)</li>
<li>Forget to set <code>DeletedAt</code> on the model when using <code>Delete</code> action</li>
<li>Mix deletion logic with complex updates (keep Apply methods focused)</li>
<li>Call <code>PurgeAsync</code> directly from perspectives (runner handles this)</li>
</ul>
<hr>

<h2>Further Reading</h2>

<ul><li><a href="perspectives.md">Perspectives Guide</a> - Core perspective concepts and pure functions</li>
<li><a href="../data/perspective-store.md">IPerspectiveStore</a> - Storage abstraction including PurgeAsync</li>
<li><a href="../source-generators/perspective-discovery.md">Perspective Discovery</a> - Generator details</li>
<li><a href="../migration/marten-to-whizbang.md">Marten Migration Guide</a> - ShouldDelete migration patterns</li>
</ul>
<hr>

<em>Version 0.2.0 - Draft | Last Updated: 2026-01-20</em>
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>

</section>
<section id="proposals"><h3>Proposals</h3>
<article id="proposals-advanced-features" class="doc-section">
  <h2>Advanced Features</h2>
  <p class="doc-path"><code>proposals/advanced-features</code></p>
  <div class="doc-content">

<h1>Advanced Features</h1>

<p>Whizbang includes advanced features for enterprise scenarios, including cross-aggregate transactions, performance monitoring, Kubernetes operators, and debugging tools.</p>

<h2>Cross-Aggregate Transactions</h2>

<h3>Unit of Work Pattern</h3>

<strong>Coordinate transactions across multiple aggregates</strong> while maintaining consistency:

<p>``<code>csharp{title="Unit of Work Configuration" description="Unit of work pattern configuration for cross-aggregate transactions" category="Design" difficulty="ADVANCED" tags=["Design", "Advanced-Features", "Unit-of-Work", "Cross-Aggregate-Transactions"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.UseUnitOfWork(uow => {</p>
<p>        uow.IsolationLevel = IsolationLevel.ReadCommitted;</p>
<p>        uow.Timeout = TimeSpan.FromSeconds(30);</p>
<p>        uow.EnableDistributedTransactions = true;</p>
<p>    });</p>
<p>});</p>

<p></code>`<code>csharp{title="Multi-Aggregate Command Handler" description="Command handler using unit of work for coordinated multi-aggregate operations" category="Design" difficulty="ADVANCED" tags=["Design", "Advanced-Features", "Unit-of-Work", "Command-Handlers"] framework="NET8"}</p>
<p>// Usage in handlers</p>
<p>public class PlaceOrderHandler : ICommandHandler<PlaceOrder> {</p>
<p>    private readonly IUnitOfWork _unitOfWork;</p>
<p>    private readonly IRepository<Order> _orderRepository;</p>
<p>    private readonly IRepository<Customer> _customerRepository;</p>
<p>    private readonly IRepository<Product> _productRepository;</p>
<p>    </p>
<p>    public async Task<OrderPlaced> Handle(PlaceOrder command) {</p>
<p>        return await _unitOfWork.ExecuteAsync(async () => {</p>
<p>            // Load multiple aggregates</p>
<p>            var customer = await _customerRepository.Load(command.CustomerId);</p>
<p>            var products = await _productRepository.LoadMany(command.ProductIds);</p>
<p>            </p>
<p>            // Validate business rules across aggregates</p>
<p>            if (!customer.CanPlaceOrder(command.Total)) {</p>
<p>                throw new DomainException("Customer credit limit exceeded");</p>
<p>            }</p>
<p>            </p>
<p>            foreach (var product in products) {</p>
<p>                if (!product.IsAvailable(command.GetQuantity(product.Id))) {</p>
<p>                    throw new DomainException($"Product {product.Id} not available");</p>
<p>                }</p>
<p>            }</p>
<p>            </p>
<p>            // Create new aggregate</p>
<p>            var order = new Order(command.CustomerId, command.Items);</p>
<p>            </p>
<p>            // Update existing aggregates</p>
<p>            customer.ReserveCreditLimit(command.Total);</p>
<p>            foreach (var product in products) {</p>
<p>                product.ReserveStock(command.GetQuantity(product.Id));</p>
<p>            }</p>
<p>            </p>
<p>            // Save all changes in single transaction</p>
<p>            await _orderRepository.Save(order);</p>
<p>            await _customerRepository.Save(customer);</p>
<p>            await _productRepository.SaveMany(products);</p>
<p>            </p>
<p>            return new OrderPlaced(order.Id, command.CustomerId, DateTimeOffset.UtcNow);</p>
<p>        });</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Distributed Transactions with Saga Fallback</h3>

<p></code></pre>csharp{title="Distributed Transactions with Saga Fallback" description="Distributed transactions with saga fallback for complex operations" category="Design" difficulty="ADVANCED" tags=["Design", "Advanced-Features", "Cross-Aggregate-Transactions", "Saga-Fallback"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.CrossAggregateTransactions(transactions => {</p>
<p>        transactions.DefaultStrategy = TransactionStrategy.UnitOfWork;</p>
<p>        transactions.FallbackToSaga = true;</p>
<p>        transactions.SagaTimeoutMs = 30000;</p>
<p>        </p>
<p>        // Configure per-operation</p>
<p>        transactions.ForOperation<PlaceOrder>(op => {</p>
<p>            op.Strategy = TransactionStrategy.UnitOfWork;</p>
<p>            op.MaxAggregatesInTransaction = 5;</p>
<p>        });</p>
<p>        </p>
<p>        transactions.ForOperation<ComplexOrderWorkflow>(op => {</p>
<p>            op.Strategy = TransactionStrategy.Saga; // Force saga for complex operations</p>
<p>        });</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h3>Transaction Boundaries</h3>

<p></code></pre>csharp{title="Transaction Boundary Implementation" description="Transaction boundary implementation with automatic rollback on failure" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Advanced-Features", "Transaction-Boundaries", "Error-Handling"] framework="NET8"}</p>
<p>public class TransactionBoundary : ITransactionBoundary {</p>
<p>    public async Task<T> ExecuteInTransaction<T>(Func<Task<T>> operation) {</p>
<p>        using var scope = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled);</p>
<p>        </p>
<p>        try {</p>
<p>            var result = await operation();</p>
<p>            scope.Complete();</p>
<p>            return result;</p>
<p>        } catch (Exception ex) {</p>
<p>            // Transaction automatically rolled back</p>
<p>            _logger.LogError(ex, "Transaction failed and was rolled back");</p>
<p>            throw;</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Performance Budgets & Monitoring</h2>

<blockquote><strong>📋 Detailed Coverage</strong>: For comprehensive performance budgets, observability, and monitoring details, see <a href="./observability-metrics.md"><strong>Observability & Metrics</strong></a></blockquote>

<h3>Performance Budget Overview</h3>

<strong>Performance budgets</strong> provide automatic tracking and alerting for handler performance:

<p></code></pre>csharp{title="Performance Budget Attributes" description="Performance budget attributes for automatic tracking and alerting" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Advanced-Features", "Performance-Budgets", "Monitoring"] framework="NET8"}</p>
<p>[PerformanceBudget(MaxLatencyMs = 100)]</p>
<p>public class PlaceOrderHandler : ICommandHandler<PlaceOrder> {</p>
<p>    // Automatic budget tracking and violation alerts</p>
<p>}</p>
<pre><code class="language-">
<h2>OpenTelemetry Integration</h2>

<blockquote><strong>📋 Detailed Coverage</strong>: For complete OpenTelemetry setup, metrics, and distributed tracing, see <a href="./observability-metrics.md"><strong>Observability & Metrics</strong></a></blockquote>

<p></code></pre>csharp{title="OpenTelemetry Integration Configuration" description="OpenTelemetry integration configuration for comprehensive observability" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Advanced-Features", "OpenTelemetry", "Observability"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.Observability(observability => {</p>
<p>        observability.UseOpenTelemetry(otel => {</p>
<p>            otel.TraceAllCommands = true;</p>
<p>            otel.TraceAllEvents = true;</p>
<p>            otel.TraceProjections = true;</p>
<p>            otel.TraceSagas = true;</p>
<p>            </p>
<p>            // Custom metrics</p>
<p>            otel.EmitCustomMetrics = true;</p>
<p>            otel.MetricsPrefix = "whizbang";</p>
<p>            </p>
<p>            // Performance budget violations</p>
<p>            otel.TracePerformanceBudgetViolations = true;</p>
<p>            otel.AlertOnBudgetViolation = true;</p>
<p>        });</p>
<p>    });</p>
<p>});</p>

<p></code>`<code>csharp{title="Custom Performance Tracking Handler" description="Custom performance tracking handler with detailed metrics collection" category="Design" difficulty="ADVANCED" tags=["Design", "Advanced-Features", "Performance-Tracking", "Custom-Metrics"] framework="NET8"}</p>
<p>// Custom performance tracking</p>
<p>public class PerformanceTrackingHandler<T> : ICommandHandler<T> where T : ICommand {</p>
<p>    private readonly ICommandHandler<T> _innerHandler;</p>
<p>    private readonly IMetrics _metrics;</p>
<p>    </p>
<p>    public async Task Handle(T command) {</p>
<p>        using var activity = Activity.StartActivity($"Command.{typeof(T).Name}");</p>
<p>        using var timer = _metrics.StartTimer($"command.{typeof(T).Name.ToLower()}.duration");</p>
<p>        </p>
<p>        var startMemory = GC.GetTotalMemory(false);</p>
<p>        var stopwatch = Stopwatch.StartNew();</p>
<p>        </p>
<p>        try {</p>
<p>            await _innerHandler.Handle(command);</p>
<p>            </p>
<p>            // Record success metrics</p>
<p>            _metrics.IncrementCounter($"command.{typeof(T).Name.ToLower()}.success");</p>
<p>        } catch (Exception ex) {</p>
<p>            // Record failure metrics</p>
<p>            _metrics.IncrementCounter($"command.{typeof(T).Name.ToLower()}.failure", </p>
<p>                new[] { ("error_type", ex.GetType().Name) });</p>
<p>            </p>
<p>            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);</p>
<p>            throw;</p>
<p>        } finally {</p>
<p>            stopwatch.Stop();</p>
<p>            var endMemory = GC.GetTotalMemory(false);</p>
<p>            </p>
<p>            // Record performance metrics</p>
<p>            activity?.SetTag("duration_ms", stopwatch.ElapsedMilliseconds);</p>
<p>            activity?.SetTag("memory_allocated_bytes", endMemory - startMemory);</p>
<p>            </p>
<p>            _metrics.RecordValue($"command.{typeof(T).Name.ToLower()}.memory", endMemory - startMemory);</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Kubernetes Operator Features</h2>

<blockquote><strong>📋 Detailed Coverage</strong>: For production deployment patterns, health checks, and operational best practices, see <a href="./deployment-operations.md"><strong>Deployment & Operations</strong></a></blockquote>

<h3>Auto-Scaling Projection Workers</h3>

<p></code></pre>yaml</p>
<hr>
<p>category: Design</p>
<p>difficulty: ADVANCED</p>
<p>tags: [Design, Advanced-Features, Kubernetes-Operator, Auto-Scaling]</p>
<p>description: Kubernetes custom resource for auto-scaling projection workers</p>
<hr>
<p>apiVersion: whizbang.io/v1</p>
<p>kind: ProjectionWorker</p>
<p>metadata:</p>
<p>  name: order-summary-projection</p>
<p>spec:</p>
<p>  projectionName: order-summary</p>
<p>  scaling:</p>
<p>    strategy: lag-based</p>
<p>    minReplicas: 2</p>
<p>    maxReplicas: 10</p>
<p>    lagThresholdSeconds: 30</p>
<p>    scaleUpCooldownMs: 300000   # 5 minutes</p>
<p>    scaleDownCooldownMs: 600000 # 10 minutes</p>
<p>  partitioning:</p>
<p>    enabled: true</p>
<p>    partitionCount: 8</p>
<p>    partitionBy: "streamId"</p>
<p>  resources:</p>
<p>    requests:</p>
<p>      cpu: 100m</p>
<p>      memory: 128Mi</p>
<p>    limits:</p>
<p>      cpu: 500m</p>
<p>      memory: 512Mi</p>
<pre><code class="language-">
<h3>Partition-Aware Pod Placement</h3>

<p></code></pre>yaml</p>
<hr>
<p>category: Design</p>
<p>difficulty: ADVANCED</p>
<p>tags: [Design, Advanced-Features, Kubernetes-Operator, Partition-Aware-Placement]</p>
<p>description: Partition-aware pod placement for distributed projection processing</p>
<hr>
<p>apiVersion: whizbang.io/v1</p>
<p>kind: PartitionedProjection</p>
<p>metadata:</p>
<p>  name: analytics-projection</p>
<p>spec:</p>
<p>  projectionName: analytics</p>
<p>  partitions:</p>
<p>  - id: 0</p>
<p>    nodeSelector:</p>
<p>      whizbang.io/partition-group: "group-a"</p>
<p>  - id: 1</p>
<p>    nodeSelector:</p>
<p>      whizbang.io/partition-group: "group-a"</p>
<p>  - id: 2</p>
<p>    nodeSelector:</p>
<p>      whizbang.io/partition-group: "group-b"</p>
<p>  - id: 3</p>
<p>    nodeSelector:</p>
<p>      whizbang.io/partition-group: "group-b"</p>
<p>  antiAffinity:</p>
<p>    enabled: true</p>
<p>    topologyKey: kubernetes.io/hostname</p>
<pre><code class="language-">
<h3>Blue/Green Projection Deployments</h3>

<p></code></pre>yaml</p>
<hr>
<p>category: Design</p>
<p>difficulty: ADVANCED</p>
<p>tags: [Design, Advanced-Features, Kubernetes-Operator, Blue-Green-Deployment]</p>
<p>description: Blue/green projection deployments with validation and automatic switchover</p>
<hr>
<p>apiVersion: whizbang.io/v1</p>
<p>kind: ProjectionDeployment</p>
<p>metadata:</p>
<p>  name: order-summary-deployment</p>
<p>spec:</p>
<p>  strategy: blue-green</p>
<p>  validation:</p>
<p>    samplingRate: 0.1          # Validate 10% of data</p>
<p>    accuracyThreshold: 0.99    # 99% accuracy required</p>
<p>    validationTimeoutMinutes: 30</p>
<p>  switchover:</p>
<p>    automatic: false           # Manual approval required</p>
<p>    trafficSplitDurationMinutes: 10</p>
<p>  cleanup:</p>
<p>    retainBlueVersionHours: 24 # Keep blue for 24 hours after switchover</p>
<pre><code class="language-">
<h3>Automatic Backfilling</h3>

<p></code></pre>yaml</p>
<hr>
<p>category: Design</p>
<p>difficulty: ADVANCED</p>
<p>tags: [Design, Advanced-Features, Kubernetes-Operator, Automatic-Backfilling]</p>
<p>description: Kubernetes job for automatic projection backfilling with resource management</p>
<hr>
<p>apiVersion: whizbang.io/v1</p>
<p>kind: BackfillJob</p>
<p>metadata:</p>
<p>  name: customer-analytics-backfill</p>
<p>spec:</p>
<p>  projectionName: customer-analytics</p>
<p>  trigger: deployment-update  # Trigger on projection deployment</p>
<p>  source:</p>
<p>    fromDate: "2024-01-01T00:00:00Z"</p>
<p>    toDate: null              # Current time</p>
<p>  execution:</p>
<p>    batchSize: 1000</p>
<p>    parallelism: 4</p>
<p>    maxRetries: 3</p>
<p>  resources:</p>
<p>    requests:</p>
<p>      cpu: 200m</p>
<p>      memory: 256Mi</p>
<p>    limits:</p>
<p>      cpu: 1000m</p>
<p>      memory: 1Gi</p>
<pre><code class="language-">
<h3>Kubernetes Operator Implementation</h3>

<p></code></pre>csharp{title="Kubernetes Operator Implementation" description="Kubernetes operator implementation for Whizbang resource management" category="Design" difficulty="ADVANCED" tags=["Design", "Advanced-Features", "Kubernetes-Operator", "Implementation"] framework="NET8"}</p>
<p>public class WhizbangOperator : IHostedService {</p>
<p>    private readonly IKubernetesClient _kubernetesClient;</p>
<p>    private readonly IProjectionManager _projectionManager;</p>
<p>    </p>
<p>    public async Task StartAsync(CancellationToken cancellationToken) {</p>
<p>        // Watch for ProjectionWorker resources</p>
<p>        await _kubernetesClient.WatchAsync<ProjectionWorker>(</p>
<p>            onEvent: async (eventType, resource) => {</p>
<p>                switch (eventType) {</p>
<p>                    case WatchEventType.Added:</p>
<p>                        await CreateProjectionWorker(resource);</p>
<p>                        break;</p>
<p>                    case WatchEventType.Modified:</p>
<p>                        await UpdateProjectionWorker(resource);</p>
<p>                        break;</p>
<p>                    case WatchEventType.Deleted:</p>
<p>                        await DeleteProjectionWorker(resource);</p>
<p>                        break;</p>
<p>                }</p>
<p>            },</p>
<p>            cancellationToken: cancellationToken</p>
<p>        );</p>
<p>        </p>
<p>        // Monitor projection lag and auto-scale</p>
<p>        _ = Task.Run(() => MonitorAndScale(cancellationToken), cancellationToken);</p>
<p>    }</p>
<p>    </p>
<p>    private async Task MonitorAndScale(CancellationToken cancellationToken) {</p>
<p>        while (!cancellationToken.IsCancellationRequested) {</p>
<p>            var projections = await _projectionManager.GetAllProjections();</p>
<p>            </p>
<p>            foreach (var projection in projections) {</p>
<p>                var lag = await _projectionManager.GetLag(projection.Name);</p>
<p>                var workerSpec = await GetProjectionWorkerSpec(projection.Name);</p>
<p>                </p>
<p>                if (ShouldScaleUp(lag, workerSpec)) {</p>
<p>                    await ScaleUpProjectionWorker(projection.Name, workerSpec);</p>
<p>                } else if (ShouldScaleDown(lag, workerSpec)) {</p>
<p>                    await ScaleDownProjectionWorker(projection.Name, workerSpec);</p>
<p>                }</p>
<p>            }</p>
<p>            </p>
<p>            await Task.Delay(TimeSpan.FromSeconds(30), cancellationToken);</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Debugging and Development Tools</h2>

<blockquote><strong>📋 Detailed Coverage</strong>: For comprehensive testing framework, development tools, CLI, and IDE integration, see <a href="./testing-development-tools.md"><strong>Testing & Development Tools</strong></a> and <a href="./source-generation-ide.md"><strong>Source Generation & IDE Integration</strong></a></blockquote>

<h3>OpenTelemetry Journey Visualization</h3>

<strong>Capture and visualize message journeys</strong> for debugging:

<p></code></pre>csharp{title="Message Journey Debugging Configuration" description="Debugging configuration for message journey capture and visualization" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Advanced-Features", "Debugging", "Message-Journeys"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.Debugging(debugging => {</p>
<p>        debugging.CaptureMessageJourneys = true;</p>
<p>        debugging.JourneyRetentionDays = 7;</p>
<p>        debugging.EnableBreakpoints = true;</p>
<p>        debugging.EnableStateInspection = true;</p>
<p>    });</p>
<p>});</p>

<p></code>`<code>csharp{title="Message Journey Tracking Interceptor" description="Message journey tracking interceptor for debugging and visualization" category="Design" difficulty="ADVANCED" tags=["Design", "Advanced-Features", "Debugging", "Journey-Tracking"] framework="NET8"}</p>
<p>// Message journey tracking</p>
<p>public class MessageJourneyTracker : IMessageInterceptor {</p>
<p>    public async Task<TResponse> Intercept<TRequest, TResponse>(</p>
<p>        TRequest message, </p>
<p>        MessageContext context,</p>
<p>        MessageHandlerDelegate<TRequest, TResponse> next) {</p>
<p>        </p>
<p>        var journeyId = context.CorrelationId ?? Guid.NewGuid().ToString();</p>
<p>        </p>
<p>        using var activity = Activity.StartActivity("MessageJourney");</p>
<p>        activity?.SetTag("journey_id", journeyId);</p>
<p>        activity?.SetTag("message_type", typeof(TRequest).Name);</p>
<p>        activity?.SetTag("handler_type", context.HandlerType?.Name);</p>
<p>        </p>
<p>        var stopwatch = Stopwatch.StartNew();</p>
<p>        </p>
<p>        try {</p>
<p>            var response = await next(message, context);</p>
<p>            </p>
<p>            await _journeyStore.RecordStep(new JourneyStep {</p>
<p>                JourneyId = journeyId,</p>
<p>                MessageType = typeof(TRequest).Name,</p>
<p>                HandlerType = context.HandlerType?.Name,</p>
<p>                Duration = stopwatch.Elapsed,</p>
<p>                Status = "Success",</p>
<p>                Input = JsonSerializer.Serialize(message),</p>
<p>                Output = JsonSerializer.Serialize(response)</p>
<p>            });</p>
<p>            </p>
<p>            return response;</p>
<p>        } catch (Exception ex) {</p>
<p>            await _journeyStore.RecordStep(new JourneyStep {</p>
<p>                JourneyId = journeyId,</p>
<p>                MessageType = typeof(TRequest).Name,</p>
<p>                HandlerType = context.HandlerType?.Name,</p>
<p>                Duration = stopwatch.Elapsed,</p>
<p>                Status = "Failed",</p>
<p>                Error = ex.ToString(),</p>
<p>                Input = JsonSerializer.Serialize(message)</p>
<p>            });</p>
<p>            </p>
<p>            throw;</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Replay and Simulation</h3>

<strong>Replay events for debugging and testing</strong>:

<p></code></pre>csharp{title="Event Replay Service Interface" description="Event replay service interface for debugging and testing scenarios" category="Design" difficulty="ADVANCED" tags=["Design", "Advanced-Features", "Event-Replay", "Simulation"] framework="NET8"}</p>
<p>public interface IEventReplayService {</p>
<p>    Task<ReplayResult> ReplayEvents(ReplayOptions options);</p>
<p>    Task<SimulationResult> SimulateEventStream(SimulationOptions options);</p>
<p>    IAsyncEnumerable<ReplayProgress> GetReplayProgress(string replayId);</p>
<p>}</p>

<p>public class EventReplayService : IEventReplayService {</p>
<p>    public async Task<ReplayResult> ReplayEvents(ReplayOptions options) {</p>
<p>        var replayId = Guid.NewGuid().ToString();</p>
<p>        </p>
<p>        // Create isolated replay environment</p>
<p>        var replayContext = await CreateReplayContext(replayId, options);</p>
<p>        </p>
<p>        try {</p>
<p>            // Load events to replay</p>
<p>            var events = await LoadEventsForReplay(options);</p>
<p>            </p>
<p>            // Replay events in isolated context</p>
<p>            foreach (var @event in events) {</p>
<p>                if (options.Breakpoints?.Contains(@event.EventNumber) == true) {</p>
<p>                    await PauseForBreakpoint(@event, replayContext);</p>
<p>                }</p>
<p>                </p>
<p>                await replayContext.ProcessEvent(@event);</p>
<p>                </p>
<p>                if (options.StepByStep) {</p>
<p>                    await WaitForContinueSignal(replayId);</p>
<p>                }</p>
<p>            }</p>
<p>            </p>
<p>            return new ReplayResult {</p>
<p>                ReplayId = replayId,</p>
<p>                EventsProcessed = events.Count(),</p>
<p>                Status = ReplayStatus.Completed</p>
<p>            };</p>
<p>        } catch (Exception ex) {</p>
<p>            return new ReplayResult {</p>
<p>                ReplayId = replayId,</p>
<p>                Status = ReplayStatus.Failed,</p>
<p>                Error = ex.Message</p>
<p>            };</p>
<p>        }</p>
<p>    }</p>
<p>}</p>

<p></code>`<code>csharp{title="Event Replay Usage Example" description="Event replay configuration options and usage example" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Advanced-Features", "Event-Replay", "Usage-Example"] framework="NET8"}</p>
<p>// Usage</p>
<p>var replayOptions = new ReplayOptions {</p>
<p>    FromEventNumber = 1000,</p>
<p>    ToEventNumber = 2000,</p>
<p>    StreamFilter = streamId => streamId.StartsWith("Order-"),</p>
<p>    StepByStep = true,</p>
<p>    Breakpoints = new[] { 1500, 1750 },</p>
<p>    IsolatedEnvironment = true</p>
<p>};</p>

<p>var result = await _replayService.ReplayEvents(replayOptions);</p>
<pre><code class="language-">
<h3>State Inspection and Breakpoints</h3>

<strong>Inspect aggregate and projection state during debugging</strong>:

<p></code></pre>csharp{title="State Inspection Interface" description="State inspection interface for debugging aggregate and projection state" category="Design" difficulty="ADVANCED" tags=["Design", "Advanced-Features", "State-Inspection", "Debugging"] framework="NET8"}</p>
<p>public interface IStateInspector {</p>
<p>    Task<AggregateState> InspectAggregate(string streamId, long? version = null);</p>
<p>    Task<ProjectionState> InspectProjection(string projectionName, string documentId);</p>
<p>    Task<IEnumerable<EventInfo>> GetEventHistory(string streamId);</p>
<p>    Task SetBreakpoint(string streamId, long eventVersion);</p>
<p>    Task<BreakpointContext> WaitForBreakpoint(string breakpointId);</p>
<p>}</p>

<p></code>`<code>csharp{title="Breakpoint Handler Implementation" description="Breakpoint handler implementation for debugging event processing" category="Design" difficulty="ADVANCED" tags=["Design", "Advanced-Features", "Breakpoints", "Implementation"] framework="NET8"}</p>
<p>// Breakpoint implementation</p>
<p>public class BreakpointHandler : IEventHandler<object> {</p>
<p>    public async Task Handle(object @event, EventContext context) {</p>
<p>        var breakpoints = await _breakpointStore.GetActiveBreakpoints(context.StreamId);</p>
<p>        </p>
<p>        foreach (var breakpoint in breakpoints) {</p>
<p>            if (ShouldTriggerBreakpoint(breakpoint, @event, context)) {</p>
<p>                var breakpointContext = new BreakpointContext {</p>
<p>                    BreakpointId = breakpoint.Id,</p>
<p>                    Event = @event,</p>
<p>                    StreamId = context.StreamId,</p>
<p>                    EventVersion = context.EventVersion,</p>
<p>                    AggregateState = await LoadAggregateState(context.StreamId, context.EventVersion - 1),</p>
<p>                    Timestamp = DateTimeOffset.UtcNow</p>
<p>                };</p>
<p>                </p>
<p>                await _breakpointStore.RecordBreakpointHit(breakpointContext);</p>
<p>                await _notificationService.NotifyBreakpointHit(breakpointContext);</p>
<p>                </p>
<p>                // Pause execution until developer continues</p>
<p>                await WaitForContinueSignal(breakpoint.Id);</p>
<p>            }</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>W3C Trace Context Integration</h3>

<strong>Distributed tracing with W3C standards</strong>:

<p></code></pre>csharp{title="W3C Trace Context Configuration" description="W3C trace context integration configuration for distributed tracing" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Advanced-Features", "Distributed-Tracing", "W3C-Standards"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.DistributedTracing(tracing => {</p>
<p>        tracing.UseW3CTraceContext = true;</p>
<p>        tracing.PropagateTraceHeaders = true;</p>
<p>        tracing.SampleRate = 0.1; // Sample 10% of traces</p>
<p>        </p>
<p>        tracing.CustomTags.Add("service.name", "whizbang-orders");</p>
<p>        tracing.CustomTags.Add("service.version", "1.2.3");</p>
<p>    });</p>
<p>});</p>

<p></code>`<code>csharp{title="W3C Trace Context Propagation" description="Automatic W3C trace context propagation implementation" category="Design" difficulty="ADVANCED" tags=["Design", "Advanced-Features", "Trace-Propagation", "W3C-Implementation"] framework="NET8"}</p>
<p>// Automatic trace propagation</p>
<p>public class TraceContextPropagator : IMessageInterceptor {</p>
<p>    public async Task<TResponse> Intercept<TRequest, TResponse>(</p>
<p>        TRequest message,</p>
<p>        MessageContext context,</p>
<p>        MessageHandlerDelegate<TRequest, TResponse> next) {</p>
<p>        </p>
<p>        // Extract W3C trace context from headers</p>
<p>        var traceParent = context.Headers.GetValueOrDefault("traceparent");</p>
<p>        var traceState = context.Headers.GetValueOrDefault("tracestate");</p>
<p>        </p>
<p>        if (traceParent != null) {</p>
<p>            // Parse W3C trace context</p>
<p>            var traceContext = W3CTraceContext.Parse(traceParent, traceState);</p>
<p>            </p>
<p>            // Create child span</p>
<p>            using var activity = Activity.StartActivity($"Handle{typeof(TRequest).Name}");</p>
<p>            activity?.SetParentId(traceContext.TraceId, traceContext.SpanId);</p>
<p>            activity?.SetTag("whizbang.correlation_id", context.CorrelationId);</p>
<p>            activity?.SetTag("whizbang.message_type", typeof(TRequest).Name);</p>
<p>            </p>
<p>            // Add custom trace state</p>
<p>            var newTraceState = $"whizbang=correlation-id:{context.CorrelationId}";</p>
<p>            if (!string.IsNullOrEmpty(traceState)) {</p>
<p>                newTraceState = $"{traceState},{newTraceState}";</p>
<p>            }</p>
<p>            activity?.SetTag("tracestate", newTraceState);</p>
<p>            </p>
<p>            return await next(message, context);</p>
<p>        }</p>
<p>        </p>
<p>        // No parent trace - start new one</p>
<p>        using var rootActivity = Activity.StartActivity($"Handle{typeof(TRequest).Name}");</p>
<p>        return await next(message, context);</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Configuration Examples</h2>

<h3>Comprehensive Advanced Features Setup</h3>

<p></code></pre>csharp{title="Comprehensive Advanced Features Setup" description="Comprehensive advanced features configuration combining all options" category="Design" difficulty="ADVANCED" tags=["Design", "Advanced-Features", "Comprehensive-Setup", "Configuration"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    // Cross-aggregate transactions</p>
<p>    options.UseUnitOfWork(uow => {</p>
<p>        uow.IsolationLevel = IsolationLevel.ReadCommitted;</p>
<p>        uow.EnableDistributedTransactions = true;</p>
<p>        uow.FallbackToSaga = true;</p>
<p>    });</p>
<p>    </p>
<p>    // Performance budgets</p>
<p>    options.PerformanceBudgets(budgets => {</p>
<p>        budgets.DefaultCommandLatency = TimeSpan.FromMilliseconds(500);</p>
<p>        budgets.AlertOnViolation = true;</p>
<p>        budgets.UseOpenTelemetryMetrics = true;</p>
<p>    });</p>
<p>    </p>
<p>    // Observability</p>
<p>    options.Observability(observability => {</p>
<p>        observability.UseOpenTelemetry();</p>
<p>        observability.CaptureMessageJourneys = true;</p>
<p>        observability.EnableDistributedTracing = true;</p>
<p>    });</p>
<p>    </p>
<p>    // Debugging</p>
<p>    options.Debugging(debugging => {</p>
<p>        debugging.EnableBreakpoints = true;</p>
<p>        debugging.EnableStateInspection = true;</p>
<p>        debugging.EnableEventReplay = true;</p>
<p>        debugging.RetainDebugDataDays = 7;</p>
<p>    });</p>
<p>    </p>
<p>    // Kubernetes integration</p>
<p>    options.Kubernetes(k8s => {</p>
<p>        k8s.EnableOperator = true;</p>
<p>        k8s.AutoScaleProjections = true;</p>
<p>        k8s.EnableBlueGreenDeployments = true;</p>
<p>        k8s.PartitionAwarePlacement = true;</p>
<p>    });</p>
<p>});</p>
<p></code>``</p>

<h2>Best Practices</h2>

<h3>Transaction Guidelines</h3>

<ul><li><strong>Keep transactions short</strong> - Minimize time holding locks</li>
<li><strong>Limit aggregate count</strong> - Avoid transactions with too many aggregates</li>
<li><strong>Use sagas for long processes</strong> - Don't use transactions for workflows</li>
<li><strong>Test rollback scenarios</strong> - Ensure proper cleanup on failure</li>
<li><strong>Monitor transaction metrics</strong> - Track duration and failure rates</li>
</ul>
<h3>Performance Monitoring</h3>

<ul><li><strong>Set realistic budgets</strong> - Base on actual performance requirements</li>
<li><strong>Monitor trends</strong> - Track performance over time</li>
<li><strong>Alert on violations</strong> - Set up proper alerting for budget violations</li>
<li><strong>Use sampling</strong> - Don't trace every request in production</li>
<li><strong>Correlate with business metrics</strong> - Connect performance to business impact</li>
</ul>
<h3>Debugging Best Practices</h3>

<ul><li><strong>Use structured logging</strong> - Include correlation IDs and context</li>
<li><strong>Limit debug data retention</strong> - Don't keep debug data indefinitely</li>
<li><strong>Secure sensitive data</strong> - Mask PII in debug traces</li>
<li><strong>Test replay scenarios</strong> - Ensure replay works correctly</li>
<li><strong>Document debugging procedures</strong> - Help team members debug effectively</li>
</ul>
<hr>

<h2>Related Documentation</h2>

<h3>Core Architecture</h3>
<ul><li><a href="./event-store-projections.md"><strong>Event Store & Projections</strong></a> - Core storage architecture</li>
<li><a href="./concurrency-control.md"><strong>Concurrency Control</strong></a> - Managing concurrent updates</li>
<li><a href="./policy-engine.md"><strong>Policy Engine</strong></a> - Universal configuration scoping mechanism</li>
<li><a href="./flags-tags-system.md"><strong>Flags & Tags System</strong></a> - Cross-service context propagation</li>
</ul>
<h3>Implementation & Operations</h3>
<ul><li><a href="./source-generation-ide.md"><strong>Source Generation & IDE Integration</strong></a> - Development tooling and navigation</li>
<li><a href="./testing-development-tools.md"><strong>Testing & Development Tools</strong></a> - Testing framework and CLI tools  </li>
<li><a href="./observability-metrics.md"><strong>Observability & Metrics</strong></a> - Production monitoring and observability</li>
<li><a href="./deployment-operations.md"><strong>Deployment & Operations</strong></a> - Operational patterns and best practices</li></ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="proposals-concurrency-control" class="doc-section">
  <h2>Concurrency Control</h2>
  <p class="doc-path"><code>proposals/concurrency-control</code></p>
  <div class="doc-content">

<h1>Concurrency Control</h1>

<p>Whizbang provides flexible concurrency control mechanisms to handle concurrent updates to aggregates, supporting multiple strategies that developers can choose globally or per-operation.</p>

<h2>Concurrency Strategies</h2>

<h3>A. Expected Version (Default)</h3>

<strong>Standard event sourcing pattern</strong> - explicitly specify the expected version:

<p>``<code>csharp{title="Expected Version Concurrency Control" description="Standard event sourcing pattern with explicit version checking" category="Design" difficulty="INTERMEDIATE" tags=["concurrency", "expected-version", "optimistic-locking", "event-sourcing"] framework="NET8"}</p>
<p>// Load aggregate at version 5</p>
<p>var order = await repository.Load<Order>(orderId);</p>

<p>// Make changes</p>
<p>order.AddItem(new OrderItem("Product", 10.00m));</p>

<p>// Save with expected version - will fail if current version != 5</p>
<p>await repository.Save(order, expectedVersion: 5);</p>
<pre><code class="language-">
<strong>Benefits</strong>:
<ul><li>✅ Detects all conflicts</li>
<li>✅ Standard event sourcing pattern</li>
<li>✅ Explicit and predictable</li>
</ul>
<strong>Drawbacks</strong>:
<ul><li>❌ Requires version tracking</li>
<li>❌ Manual conflict resolution</li>
</ul>
<h3>B. Timestamp-Based (Last-Modified)</h3>

<strong>HTTP-style semantics</strong> using timestamps:

<p></code></pre>csharp{title="Timestamp-Based Concurrency Control" description="HTTP-style semantics using last-modified timestamps" category="Design" difficulty="INTERMEDIATE" tags=["concurrency", "timestamp-based", "http-semantics", "last-modified"] framework="NET8"}</p>
<p>var order = await repository.Load<Order>(orderId);</p>
<p>var lastModified = order.LastModified;</p>

<p>// Make changes</p>
<p>order.AddItem(new OrderItem("Product", 10.00m));</p>

<p>// Save with timestamp check</p>
<p>await repository.Save(order, ifNotModifiedSince: lastModified);</p>
<pre><code class="language-">
<strong>Benefits</strong>:
<ul><li>✅ Familiar HTTP semantics</li>
<li>✅ No version number tracking</li>
</ul>
<strong>Drawbacks</strong>:
<ul><li>❌ Clock skew potential</li>
<li>❌ Less precise than versions</li>
</ul>
<h3>C. Automatic Retry with Conflict Resolution</h3>

<strong>Smart retry with configurable resolution strategies</strong>:

<p></code></pre>csharp{title="Automatic Retry with Conflict Resolution" description="Smart retry with configurable resolution strategies via policies" category="Design" difficulty="ADVANCED" tags=["concurrency", "automatic-retry", "conflict-resolution", "policy-engine"] framework="NET8"}</p>
<p>// Configure automatic retry via policies</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.Policies(policies => {</p>
<p>        // Default strategy for all operations</p>
<p>        policies.When(ctx => true)</p>
<p>                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.AutomaticRetry))</p>
<p>                .And(config => config.SetRetryAttempts(3))</p>
<p>                .And(config => config.SetRetryDelay(TimeSpan.FromMilliseconds(100)));</p>
<p>        </p>
<p>        // Custom conflict resolution for Order aggregates</p>
<p>        policies.When(ctx => ctx.MatchesAggregate<Order>())</p>
<p>                .Then(config => config.SetConflictResolver((current, attempted) => {</p>
<p>                    // Custom merge logic</p>
<p>                    var merged = current.Copy();</p>
<p>                    merged.MergeChanges(attempted);</p>
<p>                    return merged;</p>
<p>                }));</p>
<p>    });</p>
<p>});</p>

<p>// Save with automatic retry</p>
<p>await repository.Save(order); // Retries automatically on conflict</p>
<pre><code class="language-">
<strong>Benefits</strong>:
<ul><li>✅ Handles most conflicts automatically</li>
<li>✅ Better developer experience</li>
<li>✅ Configurable retry policies</li>
</ul>
<strong>Drawbacks</strong>:
<ul><li>❌ Complex to implement</li>
<li>❌ Not all conflicts can be auto-resolved</li>
</ul>
<h2>Marten-Inspired Extensions</h2>

<p>Drawing from Marten's concurrency features, Whizbang also supports:</p>

<h3>D. Token-Based Concurrency</h3>

<strong>Using opaque tokens</strong> instead of version numbers:

<p></code></pre>csharp{title="Token-Based Concurrency Control" description="Using opaque tokens instead of version numbers" category="Design" difficulty="INTERMEDIATE" tags=["concurrency", "token-based", "opaque-tokens", "marten-inspired"] framework="NET8"}</p>
<p>var (order, token) = await repository.LoadWithToken<Order>(orderId);</p>

<p>// Make changes</p>
<p>order.AddItem(new OrderItem("Product", 10.00m));</p>

<p>// Save with token</p>
<p>await repository.Save(order, concurrencyToken: token);</p>
<pre><code class="language-">
<h3>E. Revision-Based Tracking</h3>

<strong>Marten-style revision tracking</strong> with metadata:

<p></code></pre>csharp{title="Revision-Based Tracking" description="Marten-style revision tracking with automatic metadata" category="Design" difficulty="INTERMEDIATE" tags=["concurrency", "revision-based", "marten-style", "metadata"] framework="NET8"}</p>
<p>public class Order : Aggregate {</p>
<p>    // Whizbang tracks revision automatically</p>
<p>    public int Revision { get; internal set; }</p>
<p>    public DateTime LastModified { get; internal set; }</p>
<p>    public string LastModifiedBy { get; internal set; }</p>
<p>}</p>

<p>await repository.Save(order, expectedRevision: order.Revision);</p>
<pre><code class="language-">
<h3>F. Conditional Updates</h3>

<strong>SQL-style conditional updates</strong>:

<p></code></pre>csharp{title="Conditional Updates" description="SQL-style conditional updates with business logic conditions" category="Design" difficulty="INTERMEDIATE" tags=["concurrency", "conditional-updates", "sql-style", "business-logic"] framework="NET8"}</p>
<p>await repository.Save(order, condition: o => o.Status == OrderStatus.Pending);</p>
<p>// Only saves if order is still pending</p>
<pre><code class="language-">
<h2>Policy-Driven Configuration</h2>

<blockquote><strong>📋 Universal Configuration</strong>: Whizbang uses the <a href="./policy-engine.md"><strong>Policy Engine</strong></a> as the universal configuration scoping mechanism. All concurrency strategies, retry policies, and conflict resolution rules are configured through policies rather than direct configuration methods.</blockquote>

<h3>Basic Policy Configuration</h3>

<strong>Configure concurrency strategies using the Policy Engine</strong> - the universal configuration scoping mechanism:

<p></code></pre>csharp{title="Basic Policy Configuration" description="Global concurrency strategy configuration using policy engine" category="Design" difficulty="INTERMEDIATE" tags=["concurrency", "policy-configuration", "global-strategy", "policy-engine"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.Policies(policies => {</p>
<p>        // Global default strategy</p>
<p>        policies.When(ctx => true)</p>
<p>                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.ExpectedVersion))</p>
<p>                .And(config => config.SetRetryAttempts(3))</p>
<p>                .And(config => config.SetRetryDelay(TimeSpan.FromMilliseconds(100)));</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h3>Advanced Policy Scenarios</h3>

<strong>Combine multiple conditions for sophisticated concurrency control</strong>:

<p></code></pre>csharp{title="Advanced Policy Scenarios" description="Sophisticated concurrency control with context-dependent strategies" category="Design" difficulty="ADVANCED" tags=["concurrency", "advanced-policies", "context-dependent", "tenant-specific"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.Policies(policies => {</p>
<p>        // Orders get automatic retry with more attempts</p>
<p>        policies.When(ctx => ctx.MatchesAggregate<Order>())</p>
<p>                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.AutomaticRetry))</p>
<p>                .And(config => config.SetRetryAttempts(5)); // Orders get more retries</p>
<p>        </p>
<p>        // Shopping carts use timestamp-based for simplicity</p>
<p>        policies.When(ctx => ctx.MatchesAggregate<ShoppingCart>())</p>
<p>                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.TimestampBased));</p>
<p>        </p>
<p>        // High-volume commands get automatic retry</p>
<p>        policies.When(ctx => ctx.HasTag("high-volume"))</p>
<p>                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.AutomaticRetry))</p>
<p>                .And(config => config.SetRetryAttempts(5));</p>
<p>        </p>
<p>        // Load testing uses relaxed concurrency</p>
<p>        policies.When(ctx => ctx.HasFlag(WhizbangFlags.LoadTesting))</p>
<p>                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.LastWriteWins));</p>
<p>        </p>
<p>        // Environment-based strategies</p>
<p>        policies.When(ctx => ctx.Environment == "production")</p>
<p>                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.ExpectedVersion))</p>
<p>                .And(config => config.SetRetryAttempts(3));</p>
<p>        </p>
<p>        policies.When(ctx => ctx.Environment == "development")</p>
<p>                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.LastWriteWins)); // Relaxed for dev</p>
<p>        </p>
<p>        // Tenant-specific strategies</p>
<p>        policies.When(ctx => ctx.TenantId != null && ctx.HasTag("enterprise-tenant"))</p>
<p>                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.ExpectedVersion))</p>
<p>         .And(config => config.SetRetryAttempts(5))</p>
<p>         .And(config => config.EnableStrictConflictResolution());</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h3>Runtime Policy Evaluation</h3>

<strong>Policies are evaluated at runtime</strong> based on the current context:

<p></code></pre>csharp{title="Runtime Policy Evaluation" description="Context-driven policy evaluation with automatic strategy selection" category="Design" difficulty="INTERMEDIATE" tags=["concurrency", "runtime-evaluation", "context-driven", "automatic-selection"] framework="NET8"}</p>
<p>// Policy evaluation happens automatically during save operations</p>
<p>await repository.Save(order, context => {</p>
<p>    context.WithTag("high-volume");        // Triggers high-volume policy</p>
<p>    context.WithFlag(WhizbangFlags.Production); // Triggers production policy</p>
<p>});</p>

<p>// Context determines which concurrency strategy is used</p>
<p>// No need to manually specify strategy - policies handle it</p>
<pre><code class="language-">
<h3>Manual Override (When Needed)</h3>

<strong>Override policies for exceptional cases</strong>:

<p></code></pre>csharp{title="Manual Override" description="Explicit override of policy-driven concurrency for critical operations" category="Design" difficulty="INTERMEDIATE" tags=["concurrency", "manual-override", "policy-bypass", "critical-operations"] framework="NET8"}</p>
<p>// Explicit override for critical operations</p>
<p>await repository.Save(order, saveOptions => {</p>
<p>    saveOptions.OverrideConcurrencyStrategy(ConcurrencyStrategy.ExpectedVersion);</p>
<p>    saveOptions.SetExpectedVersion(5);</p>
<p>    saveOptions.BypassPolicies(); // Skip policy evaluation</p>
<p>});</p>
<pre><code class="language-">
<h2>Conflict Resolution Strategies</h2>

<h3>Built-in Resolvers</h3>

<p></code></pre>csharp{title="Built-in Conflict Resolvers" description="Common conflict resolution strategies for different scenarios" category="Design" difficulty="INTERMEDIATE" tags=["concurrency", "built-in-resolvers", "conflict-strategies", "merge-strategies"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.Policies(policies => {</p>
<p>        // Last-write-wins for Order aggregates</p>
<p>        policies.When(ctx => ctx.MatchesAggregate<Order>())</p>
<p>                .Then(config => config.SetConflictResolver(ConflictResolvers.LastWriteWins));</p>
<p>        </p>
<p>        // First-write-wins for Customer aggregates (reject conflicting changes)</p>
<p>        policies.When(ctx => ctx.MatchesAggregate<Customer>())</p>
<p>                .Then(config => config.SetConflictResolver(ConflictResolvers.FirstWriteWins));</p>
<p>        </p>
<p>        // Additive merge for ShoppingCart (combine collections)</p>
<p>        policies.When(ctx => ctx.MatchesAggregate<ShoppingCart>())</p>
<p>                .Then(config => config.SetConflictResolver(ConflictResolvers.AdditiveMerge));</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h3>Custom Conflict Resolvers via Policies</h3>

<strong>Define custom conflict resolution logic through policies</strong>:

<p></code></pre>csharp{title="Custom Conflict Resolvers" description="Domain-specific merge logic for different aggregate properties" category="Design" difficulty="ADVANCED" tags=["concurrency", "custom-resolvers", "business-logic-merge", "domain-specific"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.Policies(policies => {</p>
<p>        // Custom resolver for Order aggregates</p>
<p>        policies.When(ctx => ctx.MatchesAggregate<Order>())</p>
<p>                .Then(config => config.SetConflictResolver((current, attempted) => {</p>
<p>                    var resolved = current.Copy();</p>
<p>                    </p>
<p>                    // Merge line items additively</p>
<p>                    foreach (var item in attempted.Items) {</p>
<p>                        if (!resolved.Items.Any(i => i.ProductId == item.ProductId)) {</p>
<p>                            resolved.AddItem(item);</p>
<p>                        }</p>
<p>                    }</p>
<p>                    </p>
<p>                    // Take latest shipping address</p>
<p>                    if (attempted.ShippingAddress != null) {</p>
<p>                        resolved.UpdateShippingAddress(attempted.ShippingAddress);</p>
<p>                    }</p>
<p>                    </p>
<p>                    return resolved;</p>
<p>                }));</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h3>Advanced Conflict Resolution</h3>

<strong>Access full conflict context through policies</strong>:

<p></code></pre>csharp{title="Advanced Conflict Resolution" description="Three-way merge using original version as merge base" category="Design" difficulty="ADVANCED" tags=["concurrency", "three-way-merge", "advanced-resolution", "merge-base"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.Policies(policies => {</p>
<p>        policies.When(ctx => ctx.MatchesAggregate<Order>())</p>
<p>                .Then(config => config.SetConflictResolver((context) => {</p>
<p>                    var current = context.CurrentVersion;</p>
<p>                    var attempted = context.AttemptedVersion;</p>
<p>                    var original = context.OriginalVersion; // Version when load started</p>
<p>                    </p>
<p>                    // Three-way merge using original as base</p>
<p>                    return ThreeWayMerge(original, current, attempted);</p>
<p>                }));</p>
<p>    });</p>
<p>});</p>
<p>});</p>
<pre><code class="language-">
<h2>Implementation Details</h2>

<h3>Concurrency Exception Handling</h3>

<p></code></pre>csharp{title="Concurrency Exception Handling" description="Detailed conflict information for debugging and error handling" category="Design" difficulty="INTERMEDIATE" tags=["concurrency", "exception-handling", "conflict-information", "debugging"] framework="NET8"}</p>
<p>public class ConcurrencyException : Exception {</p>
<p>    public string StreamId { get; }</p>
<p>    public int ExpectedVersion { get; }</p>
<p>    public int ActualVersion { get; }</p>
<p>    public Type AggregateType { get; }</p>
<p>    </p>
<p>    public ConcurrencyException(string streamId, int expectedVersion, int actualVersion, Type aggregateType)</p>
<p>        : base($"Concurrency conflict in {aggregateType.Name} stream {streamId}. Expected version {expectedVersion}, but current version is {actualVersion}") {</p>
<p>        StreamId = streamId;</p>
<p>        ExpectedVersion = expectedVersion;</p>
<p>        ActualVersion = actualVersion;</p>
<p>        AggregateType = aggregateType;</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Retry Logic</h3>

<p></code></pre>csharp{title="Retry Logic Configuration" description="Exponential backoff and jitter for reducing contention" category="Design" difficulty="INTERMEDIATE" tags=["concurrency", "retry-logic", "exponential-backoff", "jitter"] framework="NET8"}</p>
<p>public class RetryPolicy {</p>
<p>    public int MaxAttempts { get; set; } = 3;</p>
<p>    public TimeSpan InitialDelay { get; set; } = TimeSpan.FromMilliseconds(100);</p>
<p>    public TimeSpan MaxDelay { get; set; } = TimeSpan.FromSeconds(1);</p>
<p>    public double BackoffMultiplier { get; set; } = 2.0;</p>
<p>    public RetryJitter Jitter { get; set; } = RetryJitter.Random;</p>
<p>}</p>

<p>// Example retry sequence:</p>
<p>// Attempt 1: 100ms + random(0-50ms)</p>
<p>// Attempt 2: 200ms + random(0-100ms)  </p>
<p>// Attempt 3: 400ms + random(0-200ms)</p>
<pre><code class="language-">
<h3>Driver Interface</h3>

<p></code></pre>csharp{title="Driver Interface" description="Interface for implementing concurrency control strategies" category="Design" difficulty="ADVANCED" tags=["concurrency", "driver-interface", "implementation", "strategies"] framework="NET8"}</p>
<p>public interface IConcurrencyDriver {</p>
<p>    Task<T> Load<T>(string streamId, ConcurrencyOptions options) where T : Aggregate;</p>
<p>    Task<(T Aggregate, ConcurrencyToken Token)> LoadWithToken<T>(string streamId) where T : Aggregate;</p>
<p>    </p>
<p>    Task Save<T>(T aggregate, ConcurrencyCheck check) where T : Aggregate;</p>
<p>    Task<SaveResult> TrySave<T>(T aggregate, ConcurrencyCheck check) where T : Aggregate;</p>
<p>    </p>
<p>    Task<ConflictResolutionResult> ResolveConflict<T>(</p>
<p>        T original, </p>
<p>        T current, </p>
<p>        T attempted, </p>
<p>        ConflictResolver<T> resolver) where T : Aggregate;</p>
<p>}</p>

<p>public class ConcurrencyCheck {</p>
<p>    public ConcurrencyStrategy Strategy { get; set; }</p>
<p>    public int? ExpectedVersion { get; set; }</p>
<p>    public DateTime? IfNotModifiedSince { get; set; }</p>
<p>    public ConcurrencyToken? Token { get; set; }</p>
<p>    public Expression<Func<object, bool>>? Condition { get; set; }</p>
<p>}</p>
<pre><code class="language-">
<h2>Performance Considerations</h2>

<h3>Optimizations</h3>

<ul><li><strong>Version caching</strong> - Cache current versions to reduce round trips</li>
<li><strong>Batch operations</strong> - Group saves to reduce conflicts</li>
<li><strong>Read replicas</strong> - Load from read replicas to reduce load on primary</li>
<li><strong>Conflict prediction</strong> - Use heuristics to predict likely conflicts</li>
</ul>
<h3>Monitoring</h3>

<p></code></pre>csharp{title="Concurrency Monitoring" description="Conflict logging and metrics for observability" category="Design" difficulty="INTERMEDIATE" tags=["concurrency", "monitoring", "metrics", "observability"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.UseOptimisticConcurrency(concurrency => {</p>
<p>        concurrency.OnConflict = (context) => {</p>
<p>            // Log conflict for monitoring</p>
<p>            logger.LogWarning("Concurrency conflict in {StreamId}: {Conflict}", </p>
<p>                context.StreamId, context.ConflictDescription);</p>
<p>            </p>
<p>            // Emit metrics</p>
<p>            metrics.IncrementCounter("whizbang.concurrency.conflicts", </p>
<p>                new[] { ("aggregate_type", context.AggregateType.Name) });</p>
<p>        };</p>
<p>        </p>
<p>        concurrency.OnRetry = (context) => {</p>
<p>            logger.LogDebug("Retrying save for {StreamId}, attempt {Attempt}", </p>
<p>                context.StreamId, context.AttemptNumber);</p>
<p>        };</p>
<p>    });</p>
<p>});</p>
<p></code>``</p>

<h2>Best Practices</h2>

<h3>Strategy Selection Guidelines</h3>

<ul><li><strong>Expected Version</strong> - Use for critical business operations requiring strict consistency</li>
<li><strong>Timestamp-Based</strong> - Use for user-facing operations where UX matters more than strict consistency</li>
<li><strong>Automatic Retry</strong> - Use for high-contention scenarios with predictable merge strategies</li>
<li><strong>Token-Based</strong> - Use when integrating with external systems that provide tokens</li>
<li><strong>Conditional</strong> - Use for operations that depend on specific business conditions</li>
</ul>
<h3>Conflict Resolution Guidelines</h3>

<ul><li><strong>Keep resolvers fast</strong> - Avoid heavy computation or I/O</li>
<li><strong>Test thoroughly</strong> - Ensure resolvers handle edge cases</li>
<li><strong>Make resolvers deterministic</strong> - Same inputs should produce same outputs</li>
<li><strong>Log conflicts</strong> - Track conflict patterns for optimization</li>
<li><strong>Fallback to exceptions</strong> - Don't resolve conflicts you can't handle safely</li>
</ul>
<hr>

<h2>Related Documentation</h2>

<ul><li><a href="./event-store-projections.md"><strong>Event Store & Projections</strong></a> - Storage architecture</li>
<li><a href="./domain-ownership.md"><strong>Domain Ownership</strong></a> - Command routing and ownership</li>
<li><a href="./performance-optimization.md"><strong>Performance Optimization</strong></a> - Scaling strategies</li></ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="proposals-deployment-operations" class="doc-section">
  <h2>Deployment &amp; Operations</h2>
  <p class="doc-path"><code>proposals/deployment-operations</code></p>
  <div class="doc-content">

<h1>Deployment & Operations</h1>

<p>Whizbang is designed as an embedded library that runs within developer services, providing comprehensive operational hooks for production deployment, monitoring, and lifecycle management.</p>

<h2>Deployment Model</h2>

<h3>Embedded Library Architecture</h3>

<strong>Whizbang runs embedded</strong> within your application, not as a separate service:

<p>``<code>csharp{title="Embedded Library Setup" description="Basic embedded library setup within ASP.NET Core application" category="Design" difficulty="BEGINNER" tags=["Design", "Deployment", "Embedded-Library", "ASP.NET-Core"] framework="NET8"}</p>
<p>// Your service with Whizbang embedded</p>
<p>public class Program {</p>
<p>    public static void Main(string[] args) {</p>
<p>        var builder = WebApplication.CreateBuilder(args);</p>
<p>        </p>
<p>        // Add your application services</p>
<p>        builder.Services.AddControllers();</p>
<p>        builder.Services.AddOrderService();</p>
<p>        </p>
<p>        // Add Whizbang as embedded library</p>
<p>        builder.Services.AddWhizbang(options => {</p>
<p>            options.UsePostgresEventStore(connectionString);</p>
<p>            options.UseKafkaMessageBroker(kafkaConfig);</p>
<p>            options.ConfigureDomains();</p>
<p>        });</p>
<p>        </p>
<p>        var app = builder.Build();</p>
<p>        </p>
<p>        // Configure your application pipeline</p>
<p>        app.MapControllers();</p>
<p>        app.MapWhizbangEndpoints(); // Optional: Expose Whizbang endpoints</p>
<p>        </p>
<p>        app.Run();</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Service Architecture Patterns</h3>

<strong>Multiple deployment patterns</strong> supported:

<h4>1. Monolithic Deployment</h4>

<p></code></pre>yaml</p>
<hr>
<p>category: Design</p>
<p>difficulty: INTERMEDIATE</p>
<p>tags: [Design, Deployment, Kubernetes, Monolithic-Deployment]</p>
<p>description: Kubernetes deployment configuration for monolithic service architecture</p>
<hr>
<p>apiVersion: apps/v1</p>
<p>kind: Deployment</p>
<p>metadata:</p>
<p>  name: ecommerce-service</p>
<p>spec:</p>
<p>  replicas: 3</p>
<p>  selector:</p>
<p>    matchLabels:</p>
<p>      app: ecommerce-service</p>
<p>  template:</p>
<p>    metadata:</p>
<p>      labels:</p>
<p>        app: ecommerce-service</p>
<p>    spec:</p>
<p>      containers:</p>
<p>      - name: ecommerce-service</p>
<p>        image: myapp/ecommerce-service:latest</p>
<p>        ports:</p>
<p>        - containerPort: 8080</p>
<p>        env:</p>
<p>        - name: WHIZBANG_EVENTSTORE_CONNECTION</p>
<p>          valueFrom:</p>
<p>            secretKeyRef:</p>
<p>              name: database-secrets</p>
<p>              key: connection-string</p>
<p>        - name: WHIZBANG_MESSAGEBROKER_BOOTSTRAP_SERVERS</p>
<p>          value: "kafka:9092"</p>
<p>        livenessProbe:</p>
<p>          httpGet:</p>
<p>            path: /health</p>
<p>            port: 8080</p>
<p>          initialDelaySeconds: 30</p>
<p>          periodSeconds: 10</p>
<p>        readinessProbe:</p>
<p>          httpGet:</p>
<p>            path: /health/ready</p>
<p>            port: 8080</p>
<p>          initialDelaySeconds: 5</p>
<p>          periodSeconds: 5</p>
<pre><code class="language-">
<h4>2. Microservices Deployment</h4>

<p></code></pre>yaml</p>
<hr>
<p>category: Design</p>
<p>difficulty: INTERMEDIATE</p>
<p>tags: [Design, Deployment, Kubernetes, Microservices, Separation-of-Concerns]</p>
<p>description: Kubernetes deployment for microservices with separated command and projection services</p>
<hr>
<h1>Command Service</h1>
<p>apiVersion: apps/v1</p>
<p>kind: Deployment</p>
<p>metadata:</p>
<p>  name: order-command-service</p>
<p>spec:</p>
<p>  replicas: 2</p>
<p>  template:</p>
<p>    spec:</p>
<p>      containers:</p>
<p>      - name: order-service</p>
<p>        image: myapp/order-service:latest</p>
<p>        env:</p>
<p>        - name: WHIZBANG_DOMAIN</p>
<p>          value: "Orders"</p>
<p>        - name: WHIZBANG_PROJECTION_MODE</p>
<p>          value: "Disabled" # Command service doesn't run projections</p>

<hr>
<h1>Projection Worker Service  </h1>
<p>apiVersion: apps/v1</p>
<p>kind: Deployment</p>
<p>metadata:</p>
<p>  name: order-projection-worker</p>
<p>spec:</p>
<p>  replicas: 3</p>
<p>  template:</p>
<p>    spec:</p>
<p>      containers:</p>
<p>      - name: projection-worker</p>
<p>        image: myapp/order-projection-worker:latest</p>
<p>        env:</p>
<p>        - name: WHIZBANG_DOMAIN</p>
<p>          value: "Orders"</p>
<p>        - name: WHIZBANG_COMMAND_MODE</p>
<p>          value: "Disabled" # Projection worker doesn't handle commands</p>
<p>        - name: WHIZBANG_PROJECTIONS</p>
<p>          value: "OrderSummary,OrderHistory,OrderAnalytics"</p>
<pre><code class="language-">
<h4>3. Domain-per-Service Deployment</h4>

<p></code></pre>yaml</p>
<hr>
<p>category: Design</p>
<p>difficulty: INTERMEDIATE</p>
<p>tags: [Design, Deployment, Kubernetes, Domain-per-Service]</p>
<p>description: Domain-per-service deployment pattern with domain ownership configuration</p>
<hr>
<p>apiVersion: apps/v1</p>
<p>kind: Deployment</p>
<p>metadata:</p>
<p>  name: orders-service</p>
<p>spec:</p>
<p>  template:</p>
<p>    spec:</p>
<p>      containers:</p>
<p>      - name: orders-service</p>
<p>        image: myapp/orders-service:latest</p>
<p>        env:</p>
<p>        - name: WHIZBANG_OWNED_DOMAINS</p>
<p>          value: "Orders"</p>

<hr>
<p>apiVersion: apps/v1  </p>
<p>kind: Deployment</p>
<p>metadata:</p>
<p>  name: inventory-service</p>
<p>spec:</p>
<p>  template:</p>
<p>    spec:</p>
<p>      containers:</p>
<p>      - name: inventory-service</p>
<p>        image: myapp/inventory-service:latest</p>
<p>        env:</p>
<p>        - name: WHIZBANG_OWNED_DOMAINS</p>
<p>          value: "Inventory"</p>
<pre><code class="language-">
<h2>Health Checks</h2>

<h3>Built-in Health Check System</h3>

<strong>Comprehensive health monitoring</strong> ready for Kubernetes probes:

<p></code></pre>csharp{title="Health Check Configuration" description="Comprehensive health check configuration for production readiness" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Deployment", "Health-Checks", "Monitoring"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.HealthChecks(health => {</p>
<p>        // Core infrastructure health</p>
<p>        health.CheckEventStoreConnection = true;</p>
<p>        health.CheckMessageBrokerConnection = true;</p>
<p>        health.CheckProjectionHealth = true;</p>
<p>        </p>
<p>        // Operational thresholds</p>
<p>        health.ProjectionLagThreshold = TimeSpan.FromMinutes(5);</p>
<p>        health.EventStoreLatencyThreshold = TimeSpan.FromMilliseconds(100);</p>
<p>        health.MessageBrokerLatencyThreshold = TimeSpan.FromMilliseconds(500);</p>
<p>        </p>
<p>        // Custom health checks</p>
<p>        health.AddCheck<CustomBusinessLogicHealthCheck>();</p>
<p>    });</p>
<p>});</p>

<p>// Register health check endpoints</p>
<p>app.MapHealthChecks("/health", new HealthCheckOptions {</p>
<p>    ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse</p>
<p>});</p>

<p>app.MapHealthChecks("/health/ready", new HealthCheckOptions {</p>
<p>    Predicate = check => check.Tags.Contains("ready"),</p>
<p>    ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse</p>
<p>});</p>

<p>app.MapHealthChecks("/health/live", new HealthCheckOptions {</p>
<p>    Predicate = check => check.Tags.Contains("live")</p>
<p>});</p>
<pre><code class="language-">
<h3>Health Check Implementation</h3>

<strong>Detailed health check implementation</strong>:

<p></code></pre>csharp{title="Health Check Implementation" description="Detailed health check implementation for infrastructure components" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Deployment", "Health-Checks", "Implementation"] framework="NET8"}</p>
<p>public class WhizbangHealthCheck : IHealthCheck {</p>
<p>    private readonly IEventStore _eventStore;</p>
<p>    private readonly IMessageBroker _messageBroker;</p>
<p>    private readonly IProjectionManager _projectionManager;</p>
<p>    private readonly WhizbangHealthOptions _options;</p>
<p>    </p>
<p>    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default) {</p>
<p>        var checks = new List<(string name, bool healthy, string? details)>();</p>
<p>        </p>
<p>        // Event store connectivity</p>
<p>        if (_options.CheckEventStoreConnection) {</p>
<p>            try {</p>
<p>                await _eventStore.HealthCheckAsync(cancellationToken);</p>
<p>                checks.Add(("EventStore", true, "Connected"));</p>
<p>            } catch (Exception ex) {</p>
<p>                checks.Add(("EventStore", false, ex.Message));</p>
<p>            }</p>
<p>        }</p>
<p>        </p>
<p>        // Message broker connectivity</p>
<p>        if (_options.CheckMessageBrokerConnection) {</p>
<p>            try {</p>
<p>                await _messageBroker.HealthCheckAsync(cancellationToken);</p>
<p>                checks.Add(("MessageBroker", true, "Connected"));</p>
<p>            } catch (Exception ex) {</p>
<p>                checks.Add(("MessageBroker", false, ex.Message));</p>
<p>            }</p>
<p>        }</p>
<p>        </p>
<p>        // Projection health</p>
<p>        if (_options.CheckProjectionHealth) {</p>
<p>            var projections = await _projectionManager.GetAllProjectionsAsync(cancellationToken);</p>
<p>            foreach (var projection in projections) {</p>
<p>                var lag = await _projectionManager.GetLagAsync(projection.Name, cancellationToken);</p>
<p>                var healthy = lag <= _options.ProjectionLagThreshold;</p>
<p>                checks.Add(($"Projection:{projection.Name}", healthy, $"Lag: {lag.TotalSeconds}s"));</p>
<p>            }</p>
<p>        }</p>
<p>        </p>
<p>        // Determine overall health</p>
<p>        var allHealthy = checks.All(c => c.healthy);</p>
<p>        var status = allHealthy ? HealthStatus.Healthy : HealthStatus.Unhealthy;</p>
<p>        </p>
<p>        var data = checks.ToDictionary(c => c.name, c => (object)new { </p>
<p>            healthy = c.healthy, </p>
<p>            details = c.details </p>
<p>        });</p>
<p>        </p>
<p>        return new HealthCheckResult(status, data: data);</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Graceful Shutdown</h2>

<h3>.NET Host Lifetime Integration</h3>

<strong>Proper integration</strong> with .NET hosting lifetime for clean shutdown:

<p></code></pre>csharp{title="Graceful Shutdown Service" description=".NET hosted service integration with graceful shutdown support" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Deployment", "Graceful-Shutdown", "Hosting-Integration"] framework="NET8"}</p>
<p>public class WhizbangHostedService : IHostedService, IDisposable {</p>
<p>    private readonly IWhizbangRuntime _runtime;</p>
<p>    private readonly ILogger<WhizbangHostedService> _logger;</p>
<p>    private readonly WhizbangOptions _options;</p>
<p>    </p>
<p>    public async Task StartAsync(CancellationToken cancellationToken) {</p>
<p>        _logger.LogInformation("Starting Whizbang runtime");</p>
<p>        await _runtime.StartAsync(cancellationToken);</p>
<p>        _logger.LogInformation("Whizbang runtime started");</p>
<p>    }</p>
<p>    </p>
<p>    public async Task StopAsync(CancellationToken cancellationToken) {</p>
<p>        _logger.LogInformation("Stopping Whizbang runtime");</p>
<p>        </p>
<p>        try {</p>
<p>            // Stop accepting new messages</p>
<p>            await _runtime.StopAcceptingMessagesAsync(cancellationToken);</p>
<p>            _logger.LogInformation("Stopped accepting new messages");</p>
<p>            </p>
<p>            // Drain in-flight messages with timeout</p>
<p>            var drainTimeout = _options.GracefulShutdownTimeout ?? TimeSpan.FromSeconds(30);</p>
<p>            using var drainCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);</p>
<p>            drainCts.CancelAfter(drainTimeout);</p>
<p>            </p>
<p>            await _runtime.DrainInFlightMessagesAsync(drainCts.Token);</p>
<p>            _logger.LogInformation("Drained in-flight messages");</p>
<p>            </p>
<p>            // Stop projections</p>
<p>            await _runtime.StopProjectionsAsync(cancellationToken);</p>
<p>            _logger.LogInformation("Stopped projections");</p>
<p>            </p>
<p>            // Close connections</p>
<p>            await _runtime.CloseConnectionsAsync(cancellationToken);</p>
<p>            _logger.LogInformation("Closed connections");</p>
<p>            </p>
<p>        } catch (OperationCanceledException) {</p>
<p>            _logger.LogWarning("Graceful shutdown timed out, forcing shutdown");</p>
<p>        } catch (Exception ex) {</p>
<p>            _logger.LogError(ex, "Error during graceful shutdown");</p>
<p>        }</p>
<p>        </p>
<p>        _logger.LogInformation("Whizbang runtime stopped");</p>
<p>    }</p>
<p>    </p>
<p>    public void Dispose() {</p>
<p>        _runtime?.Dispose();</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Kubernetes Integration</h3>

<strong>SIGTERM handling</strong> for Kubernetes graceful shutdown:

<p></code></pre>csharp{title="Kubernetes Graceful Shutdown" description="Kubernetes SIGTERM handling with graceful shutdown and load balancer drain" category="Design" difficulty="ADVANCED" tags=["Design", "Deployment", "Graceful-Shutdown", "Kubernetes-Integration"] framework="NET8"}</p>
<p>public class GracefulShutdownService : BackgroundService {</p>
<p>    private readonly IHostApplicationLifetime _applicationLifetime;</p>
<p>    private readonly IWhizbangRuntime _runtime;</p>
<p>    private readonly ILogger<GracefulShutdownService> _logger;</p>
<p>    </p>
<p>    protected override async Task ExecuteAsync(CancellationToken stoppingToken) {</p>
<p>        // Register for shutdown notification</p>
<p>        _applicationLifetime.ApplicationStopping.Register(OnShutdown);</p>
<p>        </p>
<p>        // Wait for shutdown</p>
<p>        await Task.Delay(Timeout.Infinite, stoppingToken);</p>
<p>    }</p>
<p>    </p>
<p>    private void OnShutdown() {</p>
<p>        _logger.LogInformation("Received shutdown signal, initiating graceful shutdown");</p>
<p>        </p>
<p>        // Custom shutdown logic</p>
<p>        Task.Run(async () => {</p>
<p>            try {</p>
<p>                // Give projections time to finish current batch</p>
<p>                await _runtime.CompleteCurrentBatchAsync(TimeSpan.FromSeconds(10));</p>
<p>                </p>
<p>                // Signal readiness probe to fail (remove from load balancer)</p>
<p>                _runtime.MarkAsNotReady();</p>
<p>                </p>
<p>                // Wait for load balancer to drain</p>
<p>                await Task.Delay(TimeSpan.FromSeconds(5));</p>
<p>                </p>
<p>                _logger.LogInformation("Graceful shutdown preparation complete");</p>
<p>            } catch (Exception ex) {</p>
<p>                _logger.LogError(ex, "Error during shutdown preparation");</p>
<p>            }</p>
<p>        });</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Configuration Management</h2>

<h3>Environment-Specific Configuration</h3>

<strong>Flexible configuration</strong> for different deployment environments:

<p></code></pre>json</p>
<hr>
<p>category: Design</p>
<p>difficulty: BEGINNER</p>
<p>tags: [Design, Deployment, Configuration, Environment-Management]</p>
<p>description: Environment-specific configuration management with base and override files</p>
<hr>
<p>// appsettings.json (base configuration)</p>
<p>{</p>
<p>  "Whizbang": {</p>
<p>    "EventStore": {</p>
<p>      "Driver": "Postgres"</p>
<p>    },</p>
<p>    "MessageBroker": {</p>
<p>      "Driver": "Kafka"</p>
<p>    },</p>
<p>    "Projections": {</p>
<p>      "DefaultStrategy": "Automatic"</p>
<p>    }</p>
<p>  }</p>
<p>}</p>

<p>// appsettings.Development.json</p>
<p>{</p>
<p>  "Whizbang": {</p>
<p>    "EventStore": {</p>
<p>      "ConnectionString": "Host=localhost;Database=whizbang_dev",</p>
<p>      "EnableDetailedLogging": true</p>
<p>    },</p>
<p>    "MessageBroker": {</p>
<p>      "BootstrapServers": "localhost:9092",</p>
<p>      "EnableAutoCommit": true</p>
<p>    },</p>
<p>    "Observability": {</p>
<p>      "Level": "Verbose",</p>
<p>      "SampleRate": 1.0</p>
<p>    }</p>
<p>  }</p>
<p>}</p>

<p>// appsettings.Production.json</p>
<p>{</p>
<p>  "Whizbang": {</p>
<p>    "EventStore": {</p>
<p>      "ConnectionString": "", // Set via environment variable</p>
<p>      "PoolSize": 20,</p>
<p>      "CommandTimeout": 30</p>
<p>    },</p>
<p>    "MessageBroker": {</p>
<p>      "BootstrapServers": "", // Set via environment variable</p>
<p>      "SecurityProtocol": "SaslSsl",</p>
<p>      "EnableIdempotence": true</p>
<p>    },</p>
<p>    "Observability": {</p>
<p>      "Level": "Standard",</p>
<p>      "SampleRate": 0.1</p>
<p>    },</p>
<p>    "HealthChecks": {</p>
<p>      "ProjectionLagThresholdMinutes": 5,</p>
<p>      "EventStoreLatencyThresholdMs": 100</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<pre><code class="language-">
<h3>Secret Management</h3>

<strong>Secure credential handling</strong>:

<p></code></pre>csharp{title="Secret Management" description="Secure credential handling with Azure Key Vault and Kubernetes secrets" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Deployment", "Security", "Secret-Management"] framework="NET8"}</p>
<p>// Using Azure Key Vault</p>
<p>builder.Configuration.AddAzureKeyVault(</p>
<p>    new Uri("https://myapp-keyvault.vault.azure.net/"),</p>
<p>    new DefaultAzureCredential()</p>
<p>);</p>

<p>// Using Kubernetes secrets</p>
<p>services.AddWhizbang(options => {</p>
<p>    // Connection string from Kubernetes secret</p>
<p>    var connectionString = Environment.GetEnvironmentVariable("WHIZBANG_EVENTSTORE_CONNECTION")</p>
<p>        ?? throw new InvalidOperationException("Event store connection string not configured");</p>
<p>    </p>
<p>    options.UsePostgresEventStore(connectionString);</p>
<p>    </p>
<p>    // Message broker configuration from environment</p>
<p>    options.UseKafkaMessageBroker(kafka => {</p>
<p>        kafka.BootstrapServers = Environment.GetEnvironmentVariable("KAFKA_BOOTSTRAP_SERVERS");</p>
<p>        kafka.SecurityProtocol = Enum.Parse<SecurityProtocol>(</p>
<p>            Environment.GetEnvironmentVariable("KAFKA_SECURITY_PROTOCOL") ?? "Plaintext"</p>
<p>        );</p>
<p>        </p>
<p>        if (kafka.SecurityProtocol != SecurityProtocol.Plaintext) {</p>
<p>            kafka.SaslUsername = Environment.GetEnvironmentVariable("KAFKA_SASL_USERNAME");</p>
<p>            kafka.SaslPassword = Environment.GetEnvironmentVariable("KAFKA_SASL_PASSWORD");</p>
<p>        }</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h2>Monitoring and Alerting</h2>

<h3>Production Monitoring Setup</h3>

<strong>Comprehensive monitoring stack</strong> integration:

<p></code></pre>yaml</p>
<hr>
<p>category: Design</p>
<p>difficulty: INTERMEDIATE</p>
<p>tags: [Design, Deployment, Monitoring, Prometheus, Grafana]</p>
<p>description: Production monitoring setup with Prometheus and Grafana dashboard configuration</p>
<hr>
<h1>Prometheus ServiceMonitor for metrics scraping</h1>
<p>apiVersion: monitoring.coreos.com/v1</p>
<p>kind: ServiceMonitor</p>
<p>metadata:</p>
<p>  name: whizbang-metrics</p>
<p>spec:</p>
<p>  selector:</p>
<p>    matchLabels:</p>
<p>      app: ecommerce-service</p>
<p>  endpoints:</p>
<p>  - port: metrics</p>
<p>    path: /metrics</p>
<p>    interval: 30s</p>
<p>    scrapeTimeout: 10s</p>

<hr>
<h1>Grafana dashboard ConfigMap</h1>
<p>apiVersion: v1</p>
<p>kind: ConfigMap</p>
<p>metadata:</p>
<p>  name: whizbang-dashboard</p>
<p>data:</p>
<p>  dashboard.json: |</p>
<p>    {</p>
<p>      "dashboard": {</p>
<p>        "title": "Whizbang Application Metrics",</p>
<p>        "panels": [</p>
<p>          {</p>
<p>            "title": "Command Processing Rate",</p>
<p>            "targets": [</p>
<p>              {</p>
<p>                "expr": "rate(whizbang_command_total[5m])",</p>
<p>                "legendFormat": "{{command_type}}"</p>
<p>              }</p>
<p>            ]</p>
<p>          }</p>
<p>        ]</p>
<p>      }</p>
<p>    }</p>
<pre><code class="language-">
<h3>Log Aggregation</h3>

<strong>Structured logging</strong> for centralized log management:

<p></code></pre>csharp{title="Structured Logging" description="Structured logging configuration for centralized log management" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Deployment", "Logging", "Structured-Logging"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.Logging(logging => {</p>
<p>        logging.StructuredLogging = true;</p>
<p>        logging.IncludeCorrelationIds = true;</p>
<p>        logging.IncludeDomainContext = true;</p>
<p>        logging.SanitizeSensitiveData = true;</p>
<p>        </p>
<p>        // Log levels by component</p>
<p>        logging.SetLogLevel("Whizbang.Commands", LogLevel.Information);</p>
<p>        logging.SetLogLevel("Whizbang.Events", LogLevel.Information);</p>
<p>        logging.SetLogLevel("Whizbang.Projections", LogLevel.Warning);</p>
<p>        logging.SetLogLevel("Whizbang.Policies", LogLevel.Debug);</p>
<p>    });</p>
<p>});</p>

<p>// Example structured log output</p>
<p>{</p>
<p>  "timestamp": "2024-01-01T10:00:00.000Z",</p>
<p>  "level": "Information",</p>
<p>  "messageTemplate": "Command {CommandType} processed for domain {Domain}",</p>
<p>  "properties": {</p>
<p>    "CommandType": "PlaceOrder",</p>
<p>    "Domain": "Orders",</p>
<p>    "CorrelationId": "abc-123-def",</p>
<p>    "TenantId": "tenant-456",</p>
<p>    "ExecutionTimeMs": 45,</p>
<p>    "Success": true</p>
<p>  }</p>
<p>}</p>
<pre><code class="language-">
<h2>Scaling Strategies</h2>

<h3>Horizontal Scaling</h3>

<strong>Scale-out patterns</strong> for high throughput:

<p></code></pre>yaml</p>
<hr>
<p>category: Design</p>
<p>difficulty: INTERMEDIATE</p>
<p>tags: [Design, Deployment, Kubernetes, Auto-Scaling, HPA]</p>
<p>description: Horizontal pod autoscaler configuration with custom metrics</p>
<hr>
<h1>Horizontal Pod Autoscaler</h1>
<p>apiVersion: autoscaling/v2</p>
<p>kind: HorizontalPodAutoscaler</p>
<p>metadata:</p>
<p>  name: ecommerce-service-hpa</p>
<p>spec:</p>
<p>  scaleTargetRef:</p>
<p>    apiVersion: apps/v1</p>
<p>    kind: Deployment</p>
<p>    name: ecommerce-service</p>
<p>  minReplicas: 2</p>
<p>  maxReplicas: 20</p>
<p>  metrics:</p>
<p>  - type: Resource</p>
<p>    resource:</p>
<p>      name: cpu</p>
<p>      target:</p>
<p>        type: Utilization</p>
<p>        averageUtilization: 70</p>
<p>  - type: Resource</p>
<p>    resource:</p>
<p>      name: memory</p>
<p>      target:</p>
<p>        type: Utilization</p>
<p>        averageUtilization: 80</p>
<p>  - type: Pods</p>
<p>    pods:</p>
<p>      metric:</p>
<p>        name: whizbang_projection_lag_seconds</p>
<p>      target:</p>
<p>        type: AverageValue</p>
<p>        averageValue: "300" # Scale when lag > 5 minutes</p>
<pre><code class="language-">
<h3>Vertical Scaling</h3>

<strong>Resource optimization</strong> for different workloads:

<p></code></pre>yaml</p>
<hr>
<p>category: Design</p>
<p>difficulty: INTERMEDIATE</p>
<p>tags: [Design, Deployment, Kubernetes, Resource-Optimization, Vertical-Scaling]</p>
<p>description: Resource optimization configurations for different workload types</p>
<hr>
<h1>Command-heavy service</h1>
<p>apiVersion: apps/v1</p>
<p>kind: Deployment</p>
<p>metadata:</p>
<p>  name: order-command-service</p>
<p>spec:</p>
<p>  template:</p>
<p>    spec:</p>
<p>      containers:</p>
<p>      - name: order-service</p>
<p>        resources:</p>
<p>          requests:</p>
<p>            cpu: 500m      # Higher CPU for command processing</p>
<p>            memory: 512Mi</p>
<p>          limits:</p>
<p>            cpu: 2000m</p>
<p>            memory: 1Gi</p>

<hr>
<h1>Projection-heavy service</h1>
<p>apiVersion: apps/v1</p>
<p>kind: Deployment</p>
<p>metadata:</p>
<p>  name: analytics-projection-worker</p>
<p>spec:</p>
<p>  template:</p>
<p>    spec:</p>
<p>      containers:</p>
<p>      - name: projection-worker</p>
<p>        resources:</p>
<p>          requests:</p>
<p>            cpu: 200m</p>
<p>            memory: 1Gi    # Higher memory for projection state</p>
<p>          limits:</p>
<p>            cpu: 1000m</p>
<p>            memory: 4Gi</p>
<p></code>``</p>

<h2>Best Practices</h2>

<h3>Deployment Guidelines</h3>

<ul><li><strong>Start simple</strong> - Begin with monolithic deployment, extract services as needed</li>
<li><strong>Use health checks</strong> - Implement comprehensive liveness and readiness probes</li>
<li><strong>Plan for scaling</strong> - Design with horizontal scaling in mind</li>
<li><strong>Monitor everything</strong> - Set up observability before going to production</li>
<li><strong>Test failure modes</strong> - Practice chaos engineering and disaster recovery</li>
</ul>
<h3>Configuration Management</h3>

<ul><li><strong>Environment parity</strong> - Keep development and production configs similar</li>
<li><strong>Secure secrets</strong> - Never store credentials in code or config files</li>
<li><strong>Validate on startup</strong> - Fail fast if configuration is invalid</li>
<li><strong>Document settings</strong> - Maintain clear documentation of all configuration options</li>
<li><strong>Version configurations</strong> - Track configuration changes alongside code</li>
</ul>
<h3>Operational Excellence</h3>

<ul><li><strong>Automate deployments</strong> - Use CI/CD pipelines for consistent deployments</li>
<li><strong>Monitor SLOs</strong> - Define and track service level objectives</li>
<li><strong>Plan for disasters</strong> - Regular backup and recovery testing</li>
<li><strong>Capacity planning</strong> - Monitor trends and plan for growth</li>
<li><strong>Regular maintenance</strong> - Schedule updates and maintenance windows</li>
</ul>
<hr>

<h2>Related Documentation</h2>

<ul><li><a href="./observability-metrics.md"><strong>Observability & Metrics</strong></a> - Production monitoring setup</li>
<li><a href="./testing-development-tools.md"><strong>Testing & Development Tools</strong></a> - Testing deployment configurations</li>
<li><a href="./advanced-features.md"><strong>Advanced Features</strong></a> - Kubernetes operator features</li></ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="proposals-domain-ownership" class="doc-section">
  <h2>Domain Ownership</h2>
  <p class="doc-path"><code>proposals/domain-ownership</code></p>
  <div class="doc-content">

<h1>Domain Ownership</h1>

<p>Whizbang enforces explicit domain ownership to prevent distributed system chaos. Every command and event has a clear owner, enabling proper routing, authorization, and system boundaries.</p>

<h2>Ownership Determination Order</h2>

<p>Domain ownership is determined in <strong>user-configurable order</strong>, with this <strong>default precedence</strong>:</p>

<ul><li><strong>Namespace Convention</strong> (highest priority)</li>
<li><strong>Attributes</strong> </li>
<li><strong>Configuration-Driven</strong> (lowest priority)</li>
</ul>
<p>Each level can override previous levels, giving developers full control.</p>

<h2>1. Namespace Convention (Default First)</h2>

<strong>Automatic ownership</strong> derived from namespace structure:

<p>``<code>csharp{title="Namespace-Based Domain Ownership" description="Automatic domain ownership derived from namespace structure" category="Design" difficulty="BEGINNER" tags=["domain-ownership", "namespace-convention", "commands", "events"] framework="NET8"}</p>
<p>// Orders domain</p>
<p>namespace MyApp.Orders.Commands {</p>
<p>    public record PlaceOrder(Guid OrderId, Guid CustomerId, List<OrderItem> Items);</p>
<p>    // Domain: "Orders" (extracted from namespace)</p>
<p>}</p>

<p>namespace MyApp.Orders.Events {</p>
<p>    public record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt);</p>
<p>    // Domain: "Orders"</p>
<p>}</p>

<p>// Inventory domain  </p>
<p>namespace MyApp.Inventory.Commands {</p>
<p>    public record ReserveStock(Guid ProductId, int Quantity);</p>
<p>    // Domain: "Inventory"</p>
<p>}</p>
<pre><code class="language-">
<h3>Namespace Policy Configuration</h3>

<p></code></pre>csharp{title="Namespace Policy Configuration" description="Configuring namespace extraction policies for domain ownership" category="Design" difficulty="INTERMEDIATE" tags=["domain-ownership", "configuration", "namespace-policy", "setup"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.DomainOwnership(ownership => {</p>
<p>        // Configure namespace extraction policies</p>
<p>        ownership.NamespacePolicy(policy => {</p>
<p>            // Default: Extract domain from namespace segment</p>
<p>            policy.ExtractDomainFromNamespace = true;</p>
<p>            policy.DomainNamespacePosition = 1; // MyApp.[Domain].Commands</p>
<p>            </p>
<p>            // Custom extraction function</p>
<p>            policy.DomainExtractor = (type) => {</p>
<p>                var segments = type.Namespace.Split('.');</p>
<p>                if (segments.Length >= 3 && segments[1] == "Domains") {</p>
<p>                    return segments[2]; // MyApp.Domains.[Domain].Commands</p>
<p>                }</p>
<p>                return segments.Length >= 2 ? segments[1] : "Default";</p>
<p>            };</p>
<p>            </p>
<p>            // Namespace patterns</p>
<p>            policy.CommandNamespacePattern = "*.Commands";</p>
<p>            policy.EventNamespacePattern = "*.Events";</p>
<p>            policy.QueryNamespacePattern = "*.Queries";</p>
<p>        });</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h2>2. Attribute-Based Ownership</h2>

<strong>Explicit declaration</strong> using attributes:

<p></code></pre>csharp{title="Attribute-Based Domain Ownership" description="Explicit domain ownership declaration using attributes" category="Design" difficulty="BEGINNER" tags=["domain-ownership", "attributes", "explicit-declaration", "override"] framework="NET8"}</p>
<p>[OwnedBy("Orders")]</p>
<p>public record PlaceOrder(Guid OrderId, Guid CustomerId, List<OrderItem> Items);</p>

<p>[OwnedBy("Orders")]</p>
<p>public record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset PlacedAt);</p>

<p>// Override namespace convention</p>
<p>namespace MyApp.Shared.Commands {</p>
<p>    [OwnedBy("Inventory")] // Overrides "Shared" from namespace</p>
<p>    public record ReserveStock(Guid ProductId, int Quantity);</p>
<p>}</p>
<pre><code class="language-">
<h3>Attribute Policies</h3>

<p></code></pre>csharp{title="Attribute Policy Configuration" description="Configuring attribute-based ownership policies" category="Design" difficulty="INTERMEDIATE" tags=["domain-ownership", "attribute-policy", "configuration", "custom-attributes"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.DomainOwnership(ownership => {</p>
<p>        ownership.AttributePolicy(policy => {</p>
<p>            // Require explicit ownership for certain patterns</p>
<p>            policy.RequireExplicitOwnership<ICommand>();</p>
<p>            policy.RequireExplicitOwnership(type => type.Name.EndsWith("Command"));</p>
<p>            </p>
<p>            // Default ownership for unattributed types</p>
<p>            policy.DefaultDomain = "Shared";</p>
<p>            </p>
<p>            // Custom attribute types</p>
<p>            policy.RecognizeAttribute<DomainAttribute>();</p>
<p>            policy.RecognizeAttribute<BoundedContextAttribute>();</p>
<p>        });</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h2>3. Configuration-Driven Ownership</h2>

<strong>Centralized registration</strong> in Program.cs:

<p></code></pre>csharp{title="Configuration-Driven Ownership" description="Centralized domain registration with explicit ownership" category="Design" difficulty="INTERMEDIATE" tags=["domain-ownership", "configuration", "domain-registration", "centralized-config"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.DomainOwnership(ownership => {</p>
<p>        // Register domains with explicit ownership</p>
<p>        ownership.RegisterDomain("Orders", domain => {</p>
<p>            domain.OwnsCommand<PlaceOrder>();</p>
<p>            domain.OwnsCommand<UpdateOrder>();</p>
<p>            domain.OwnsEvent<OrderPlaced>();</p>
<p>            domain.OwnsEvent<OrderUpdated>();</p>
<p>            </p>
<p>            // Override other declarations</p>
<p>            domain.OwnsCommand<SpecialSharedCommand>(); // Takes from "Shared"</p>
<p>        });</p>
<p>        </p>
<p>        ownership.RegisterDomain("Inventory", domain => {</p>
<p>            domain.OwnsCommand<ReserveStock>();</p>
<p>            domain.OwnsCommand<ReleaseStock>();</p>
<p>            domain.OwnsEvent<StockReserved>();</p>
<p>            domain.OwnsEvent<StockReleased>();</p>
<p>        });</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h2>Interface and Inheritance Policies</h2>

<h3>Interface-Based Ownership</h3>

<p></code></pre>csharp{title="Interface-Based Ownership" description="Interface-based domain ownership with marker interfaces" category="Design" difficulty="INTERMEDIATE" tags=["domain-ownership", "interface-based", "marker-interfaces", "configuration"] framework="NET8"}</p>
<p>// Domain marker interfaces</p>
<p>public interface IOrderCommand : ICommand { }</p>
<p>public interface IInventoryCommand : ICommand { }</p>

<p>public record PlaceOrder(...) : IOrderCommand;</p>
<p>public record ReserveStock(...) : IInventoryCommand;</p>

<p>// Configure interface-based ownership</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.DomainOwnership(ownership => {</p>
<p>        ownership.InterfacePolicy(policy => {</p>
<p>            policy.RegisterInterface<IOrderCommand>("Orders");</p>
<p>            policy.RegisterInterface<IInventoryCommand>("Inventory");</p>
<p>            policy.RegisterInterface<ISharedCommand>("Shared");</p>
<p>        });</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h3>Inheritance-Based Ownership</h3>

<p></code></pre>csharp{title="Inheritance-Based Ownership" description="Inheritance-based domain ownership with base command classes" category="Design" difficulty="INTERMEDIATE" tags=["domain-ownership", "inheritance-based", "base-classes", "configuration"] framework="NET8"}</p>
<p>// Base classes for domains</p>
<p>public abstract class OrderCommand : ICommand {</p>
<p>    // Common order command properties</p>
<p>}</p>

<p>public abstract class InventoryCommand : ICommand {</p>
<p>    // Common inventory command properties  </p>
<p>}</p>

<p>public class PlaceOrder : OrderCommand {</p>
<p>    // Inherits "Orders" domain</p>
<p>}</p>

<p>// Configure inheritance-based ownership</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.DomainOwnership(ownership => {</p>
<p>        ownership.InheritancePolicy(policy => {</p>
<p>            policy.RegisterBaseClass<OrderCommand>("Orders");</p>
<p>            policy.RegisterBaseClass<InventoryCommand>("Inventory");</p>
<p>        });</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h2>Custom Ownership Precedence</h2>

<strong>Developer controls the order</strong> of ownership determination:

<p></code></pre>csharp{title="Custom Ownership Precedence" description="Custom ownership precedence order configuration" category="Design" difficulty="ADVANCED" tags=["domain-ownership", "precedence-order", "configuration", "custom-rules"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.DomainOwnership(ownership => {</p>
<p>        // Custom precedence order</p>
<p>        ownership.PrecedenceOrder(</p>
<p>            DomainOwnershipSource.Attributes,        // Check attributes first</p>
<p>            DomainOwnershipSource.Configuration,     // Then explicit config</p>
<p>            DomainOwnershipSource.Interfaces,        // Then interfaces</p>
<p>            DomainOwnershipSource.Inheritance,       // Then inheritance</p>
<p>            DomainOwnershipSource.Namespace          // Finally namespace</p>
<p>        );</p>
<p>        </p>
<p>        // Or use fluent API</p>
<p>        ownership.CheckAttributesFirst()</p>
<p>                 .ThenConfiguration()</p>
<p>                 .ThenInterfaces()</p>
<p>                 .ThenInheritance()</p>
<p>                 .FinallyNamespace();</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h2>Complex Policy Examples</h2>

<h3>Multi-Level Namespace Extraction</h3>

<p></code></pre>csharp{title="Multi-Level Namespace Extraction" description="Multi-level namespace extraction with complex custom logic" category="Design" difficulty="ADVANCED" tags=["domain-ownership", "namespace-extraction", "multi-level", "custom-logic"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.DomainOwnership(ownership => {</p>
<p>        ownership.NamespacePolicy(policy => {</p>
<p>            policy.DomainExtractor = (type) => {</p>
<p>                var ns = type.Namespace;</p>
<p>                </p>
<p>                // MyApp.Domains.Orders.Commands -> "Orders"</p>
<p>                if (ns.Contains(".Domains.")) {</p>
<p>                    var segments = ns.Split('.');</p>
<p>                    var domainIndex = Array.IndexOf(segments, "Domains") + 1;</p>
<p>                    return domainIndex < segments.Length ? segments[domainIndex] : "Unknown";</p>
<p>                }</p>
<p>                </p>
<p>                // MyApp.Orders.V2.Commands -> "Orders"</p>
<p>                var parts = ns.Split('.');</p>
<p>                if (parts.Length >= 2) {</p>
<p>                    return parts[1]; // Second segment is domain</p>
<p>                }</p>
<p>                </p>
<p>                return "Default";</p>
<p>            };</p>
<p>        });</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h3>Conditional Ownership Rules</h3>

<p></code></pre>csharp{title="Conditional Ownership Rules" description="Conditional ownership rules based on type patterns and assemblies" category="Design" difficulty="ADVANCED" tags=["domain-ownership", "conditional-rules", "assembly-based", "integration-events"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.DomainOwnership(ownership => {</p>
<p>        ownership.ConditionalRules(rules => {</p>
<p>            // Integration events are always "Shared"</p>
<p>            rules.When(type => type.Name.EndsWith("IntegrationEvent"))</p>
<p>                 .AssignToDomain("Shared");</p>
<p>            </p>
<p>            // Commands from external assemblies go to "External"</p>
<p>            rules.When(type => !type.Assembly.GetName().Name.StartsWith("MyApp"))</p>
<p>                 .AssignToDomain("External");</p>
<p>                 </p>
<p>            // Saga commands inherit from the saga's domain</p>
<p>            rules.When(type => typeof(ISagaCommand).IsAssignableFrom(type))</p>
<p>                 .ExtractDomainFromProperty("SagaDomain");</p>
<p>        });</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h3>Assembly-Based Policies</h3>

<p></code></pre>csharp{title="Assembly-Based Policies" description="Assembly-based domain ownership with naming conventions" category="Design" difficulty="INTERMEDIATE" tags=["domain-ownership", "assembly-based", "assembly-mapping", "naming-convention"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.DomainOwnership(ownership => {</p>
<p>        ownership.AssemblyPolicy(policy => {</p>
<p>            // Each assembly represents a domain</p>
<p>            policy.MapAssemblyToDomain("MyApp.Orders", "Orders");</p>
<p>            policy.MapAssemblyToDomain("MyApp.Inventory", "Inventory");</p>
<p>            policy.MapAssemblyToDomain("MyApp.Shipping", "Shipping");</p>
<p>            </p>
<p>            // Assembly naming convention</p>
<p>            policy.ExtractDomainFromAssemblyName = true;</p>
<p>            policy.AssemblyNamePattern = "MyApp.{Domain}";</p>
<p>        });</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h2>Runtime Ownership Resolution</h2>

<h3>Ownership Discovery API</h3>

<p></code></pre>csharp{title="Domain Ownership Resolver API" description="Domain ownership resolver API for runtime discovery" category="Design" difficulty="INTERMEDIATE" tags=["domain-ownership", "runtime-resolution", "api", "interface"] framework="NET8"}</p>
<p>public interface IDomainOwnershipResolver {</p>
<p>    string ResolveDomain<T>();</p>
<p>    string ResolveDomain(Type type);</p>
<p>    bool IsDomainOwner<T>(string domain);</p>
<p>    IEnumerable<string> GetAllDomains();</p>
<p>    IEnumerable<Type> GetDomainTypes(string domain);</p>
<p>}</p>

<p>// Usage</p>
<p></code>`<code>csharp{title="Using Domain Ownership Resolver" description="Example of using domain ownership resolver in a controller" category="Design" difficulty="INTERMEDIATE" tags=["domain-ownership", "controllers", "usage-example", "resolver"] framework="NET8"}</p>
<p>public class OrderController : ControllerBase {</p>
<p>    private readonly IDomainOwnershipResolver _ownership;</p>
<p>    </p>
<p>    public OrderController(IDomainOwnershipResolver ownership) {</p>
<p>        _ownership = ownership;</p>
<p>    }</p>
<p>    </p>
<p>    public async Task<IActionResult> PlaceOrder(PlaceOrderRequest request) {</p>
<p>        var domain = _ownership.ResolveDomain<PlaceOrder>();</p>
<p>        // domain = "Orders"</p>
<p>        </p>
<p>        var command = new PlaceOrder(request.OrderId, request.CustomerId, request.Items);</p>
<p>        await _mediator.Send(command);</p>
<p>        </p>
<p>        return Ok();</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Compile-Time Validation</h3>

<strong>Roslyn analyzer</strong> enforces ownership rules:

<p></code></pre>csharp{title="Compile-Time Validation" description="Compile-time validation of domain ownership rules with Roslyn analyzers" category="Design" difficulty="ADVANCED" tags=["domain-ownership", "compile-time-validation", "roslyn-analyzers", "source-generators"] framework="NET8"}</p>
<p>// This will generate a compile error</p>
<p>[OwnedBy("Orders")]</p>
<p>public record PlaceOrder(...);</p>

<p>// In different assembly/project</p>
<p>public class InventoryHandler : ICommandHandler<PlaceOrder> {</p>
<p>    // ERROR: InventoryHandler cannot handle PlaceOrder - different domains</p>
<p>    public async Task Handle(PlaceOrder command) { ... }</p>
<p>}</p>
<pre><code class="language-">
<h3>Source Generator Support</h3>

<p></code></pre>csharp{title="Auto-Generated Domain Registry" description="Auto-generated domain ownership registry for runtime lookups" category="Design" difficulty="ADVANCED" tags=["domain-ownership", "source-generation", "code-generation", "registry"] framework="NET8"}</p>
<p>// Generated at compile time</p>
<p>[GeneratedCode("Whizbang.SourceGenerator")]</p>
<p>public static class DomainOwnershipRegistry {</p>
<p>    public static readonly Dictionary<Type, string> TypeToDomain = new() {</p>
<p>        { typeof(PlaceOrder), "Orders" },</p>
<p>        { typeof(OrderPlaced), "Orders" },</p>
<p>        { typeof(ReserveStock), "Inventory" },</p>
<p>        { typeof(StockReserved), "Inventory" }</p>
<p>    };</p>
<p>    </p>
<p>    public static readonly Dictionary<string, HashSet<Type>> DomainToTypes = new() {</p>
<p>        { "Orders", new HashSet<Type> { typeof(PlaceOrder), typeof(OrderPlaced) } },</p>
<p>        { "Inventory", new HashSet<Type> { typeof(ReserveStock), typeof(StockReserved) } }</p>
<p>    };</p>
<p>}</p>
<pre><code class="language-">
<h2>Command Routing Based on Ownership</h2>

<h3>In-Process Routing</h3>

<p></code></pre>csharp{title="In-Process Command Routing" description="Local command routing within the same domain service" category="Design" difficulty="INTERMEDIATE" tags=["domain-ownership", "routing", "in-process-communication", "local-handling"] framework="NET8"}</p>
<p>// Same domain - route locally</p>
<p>var command = new PlaceOrder(...);</p>
<p>var domain = _ownership.ResolveDomain<PlaceOrder>(); // "Orders"</p>
<p>var handler = _serviceProvider.GetRequiredService<ICommandHandler<PlaceOrder>>();</p>
<p>await handler.Handle(command);</p>
<pre><code class="language-">
<h3>Cross-Service Routing</h3>

<p></code></pre>csharp{title="Cross-Service Command Routing" description="Cross-service command routing based on domain ownership" category="Design" difficulty="INTERMEDIATE" tags=["domain-ownership", "routing", "cross-service-communication", "message-broker"] framework="NET8"}</p>
<p>// Different domain - route via message broker</p>
<p>var command = new ReserveStock(...);</p>
<p>var domain = _ownership.ResolveDomain<ReserveStock>(); // "Inventory"</p>

<p>if (domain != _currentDomain) {</p>
<p>    // Send to remote service</p>
<p>    await _messageBroker.SendToService(domain, command);</p>
<p>} else {</p>
<p>    // Handle locally</p>
<p>    await _localMediator.Send(command);</p>
<p>}</p>
<p></code>``</p>

<h2>Best Practices</h2>

<h3>Ownership Guidelines</h3>

<ul><li><strong>Be explicit</strong> - Prefer attributes over conventions for critical commands</li>
<li><strong>Consistent patterns</strong> - Use the same ownership style within a domain</li>
<li><strong>Document policies</strong> - Make namespace and interface conventions clear</li>
<li><strong>Validate early</strong> - Use analyzers to catch ownership violations</li>
<li><strong>Monitor boundaries</strong> - Track cross-domain communication patterns</li>
</ul>
<h3>Policy Design</h3>

<ul><li><strong>Start simple</strong> - Begin with namespace conventions</li>
<li><strong>Add specificity</strong> - Use attributes for exceptions</li>
<li><strong>Centralize overrides</strong> - Use configuration for edge cases</li>
<li><strong>Test policies</strong> - Ensure ownership resolution works as expected</li>
<li><strong>Version carefully</strong> - Changing ownership affects routing</li>
</ul>
<hr>

<h2>Related Documentation</h2>

<ul><li><a href="./event-store-projections.md"><strong>Event Store & Projections</strong></a> - Storage architecture</li>
<li><a href="./concurrency-control.md"><strong>Concurrency Control</strong></a> - Managing concurrent updates  </li>
<li><a href="./multi-tenancy.md"><strong>Multi-Tenancy</strong></a> - Tenant isolation with domain ownership</li></ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="proposals-event-store-projections" class="doc-section">
  <h2>Event Store &amp; Projection Architecture</h2>
  <p class="doc-path"><code>proposals/event-store-projections</code></p>
  <div class="doc-content">

<h1>Event Store & Projection Architecture</h1>

<p>Whizbang implements a hybrid event store and projection architecture that separates event persistence from projection storage, enabling flexible schema evolution and high-performance querying.</p>

<h2>Core Architecture</h2>

<h3>Hybrid Storage Design</h3>

<strong>Events Table</strong> (Immutable Event Stream):
<pre><code class="language-sql">---
<p>category: Design</p>
<p>difficulty: INTERMEDIATE</p>
<p>tags: [Design, Architecture, Event-Store, SQL, JSONB]</p>
<p>description: SQL schema for events table with JSONB data storage</p>
<hr>
<p>CREATE TABLE events (</p>
<p>    event_id BIGSERIAL PRIMARY KEY,</p>
<p>    stream_id VARCHAR(255) NOT NULL,</p>
<p>    stream_version INT NOT NULL,</p>
<p>    event_type VARCHAR(255) NOT NULL,</p>
<p>    event_data JSONB NOT NULL,</p>
<p>    metadata JSONB,</p>
<p>    tenant_id VARCHAR(100),</p>
<p>    created_at TIMESTAMPTZ NOT NULL,</p>
<p>    UNIQUE(stream_id, stream_version)</p>
<p>);</p>
<p>CREATE INDEX idx_stream ON events(stream_id);</p>
<p>CREATE INDEX idx_type ON events(event_type);</p>
<p>CREATE INDEX idx_tenant ON events(tenant_id) WHERE tenant_id IS NOT NULL;</p>
<p></code></pre></p>

<strong>Projections Tables</strong> (Mutable JSONB Documents):
<pre><code class="language-sql">---
<p>category: Design</p>
<p>difficulty: INTERMEDIATE</p>
<p>tags: [Design, Architecture, Projections, SQL, JSONB]</p>
<p>description: SQL schema for projections table with mutable JSONB documents</p>
<hr>
<p>CREATE TABLE projections (</p>
<p>    projection_name VARCHAR(255) NOT NULL,</p>
<p>    document_id VARCHAR(255) NOT NULL,</p>
<p>    document JSONB NOT NULL,</p>
<p>    tenant_id VARCHAR(100),</p>
<p>    version BIGINT NOT NULL,</p>
<p>    last_updated TIMESTAMPTZ NOT NULL,</p>
<p>    PRIMARY KEY (projection_name, document_id, COALESCE(tenant_id, ''))</p>
<p>);</p>
<p>CREATE INDEX idx_projection_tenant ON projections(projection_name, tenant_id);</p>
<p></code></pre></p>

<h3>Benefits of Hybrid Approach</h3>

<ul><li><strong>Events are immutable</strong> - Perfect audit trail, never changes</li>
<li><strong>Projections are mutable</strong> - Can be rebuilt, schema can evolve</li>
<li><strong>JSONB flexibility</strong> - No schema migrations for projection changes</li>
<li><strong>Performance optimization</strong> - Events optimized for append, projections for queries</li>
<li><strong>Independent scaling</strong> - Different databases/drivers for events vs projections</li>
</ul>
<h2>Projection Management</h2>

<h3>Schema-Free Evolution</h3>

<p>``<code>csharp{</p>
<p>title: "Schema Evolution Example",</p>
<p>description: "Schema evolution example showing projection changes without migrations",</p>
<p>category: "Design",</p>
<p>difficulty: "INTERMEDIATE",</p>
<p>tags: ["Design", "Projections", "Schema-Evolution", "Domain-Models"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>// V1 Projection</p>
<p>public class OrderSummaryProjection {</p>
<p>    public Guid OrderId { get; set; }</p>
<p>    public decimal Total { get; set; }</p>
<p>    public OrderStatus Status { get; set; }</p>
<p>}</p>

<p>// V2 Projection - Add fields without migration</p>
<p>public class OrderSummaryProjection {</p>
<p>    public Guid OrderId { get; set; }</p>
<p>    public decimal Total { get; set; }</p>
<p>    public OrderStatus Status { get; set; }</p>
<p>    public DateTime EstimatedDelivery { get; set; }  // New field</p>
<p>    public List<string> Tags { get; set; } = new();   // New collection</p>
<p>}</p>
<pre><code class="language-">
<strong>No database migration required</strong> - JSONB handles missing fields gracefully.

<h3>Atomic Projection Rebuilds</h3>

<p>Whizbang supports <strong>zero-downtime projection rebuilds</strong> using temporary table swapping:</p>

<p></code></pre>csharp{</p>
<p>title: "Atomic Projection Rebuild Configuration",</p>
<p>description: "Configuration for atomic projection rebuilds with zero downtime",</p>
<p>category: "Design",</p>
<p>difficulty: "INTERMEDIATE",</p>
<p>tags: ["Design", "Projections", "Configuration", "Atomic-Operations"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>services.AddProjection<OrderSummaryProjection>(options => {</p>
<p>    options.RebuildStrategy = RebuildStrategy.AtomicSwap;</p>
<p>});</p>

<p>// Rebuild process:</p>
<p>// 1. Create temporary table: projections_ordersummary_temp</p>
<p>// 2. Build new projection in temp table from events</p>
<p>// 3. Atomic swap: RENAME projections_ordersummary TO projections_ordersummary_old,</p>
<p>//                  projections_ordersummary_temp TO projections_ordersummary</p>
<p>// 4. Drop old table</p>
<pre><code class="language-">
<h3>Projection Drivers</h3>

<p>Projections use <strong>driver-based storage</strong> for flexibility:</p>

<p></code></pre>csharp{</p>
<p>title: "Projection Driver Configuration",</p>
<p>description: "Driver configuration for different projection storage backends",</p>
<p>category: "Design",</p>
<p>difficulty: "BEGINNER",</p>
<p>tags: ["Design", "Configuration", "Drivers", "PostgreSQL", "MongoDB"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>// PostgreSQL JSONB Driver (default)</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.UsePostgresProjections(connectionString);</p>
<p>});</p>

<p>// SQL Server JSON Driver</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.UseSqlServerProjections(connectionString);</p>
<p>});</p>

<p>// MongoDB Driver</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.UseMongoProjections(connectionString);</p>
<p>});</p>

<p>// Custom Driver</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.UseProjectionDriver<MyCustomDriver>();</p>
<p>});</p>
<pre><code class="language-">
<h2>Snapshotting</h2>

<h3>Smart Replay with Snapshots</h3>

<p>Whizbang supports <strong>snapshot-assisted replays</strong> to reduce replay overhead:</p>

<p></code></pre>csharp{</p>
<p>title: "Aggregate with Automatic Snapshotting",</p>
<p>description: "Aggregate with automatic snapshotting for replay optimization",</p>
<p>category: "Design",</p>
<p>difficulty: "INTERMEDIATE",</p>
<p>tags: ["Design", "Aggregates", "Snapshots", "Performance"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>public class OrderAggregate : Aggregate {</p>
<p>    public Guid Id { get; private set; }</p>
<p>    public decimal Total { get; private set; }</p>
<p>    public List<OrderItem> Items { get; private set; } = new();</p>
<p>    </p>
<p>    // Automatic snapshots every 100 events</p>
<p>    [Snapshot(Every = 100)]</p>
<p>    public OrderSnapshot CreateSnapshot() {</p>
<p>        return new OrderSnapshot {</p>
<p>            Id = Id,</p>
<p>            Total = Total,</p>
<p>            Items = Items.ToList()</p>
<p>        };</p>
<p>    }</p>
<p>    </p>
<p>    // Restore from snapshot</p>
<p>    public void RestoreFromSnapshot(OrderSnapshot snapshot) {</p>
<p>        Id = snapshot.Id;</p>
<p>        Total = snapshot.Total;</p>
<p>        Items = snapshot.Items;</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Snapshot Storage</h3>

<p></code></pre>sql</p>
<hr>
<p>category: Design</p>
<p>difficulty: INTERMEDIATE</p>
<p>tags: [Design, Snapshots, SQL, Performance]</p>
<p>description: SQL schema for snapshot storage with JSONB data</p>
<hr>
<p>CREATE TABLE snapshots (</p>
<p>    stream_id VARCHAR(255) NOT NULL,</p>
<p>    snapshot_version BIGINT NOT NULL,</p>
<p>    snapshot_data JSONB NOT NULL,</p>
<p>    tenant_id VARCHAR(100),</p>
<p>    created_at TIMESTAMPTZ NOT NULL,</p>
<p>    PRIMARY KEY (stream_id, snapshot_version)</p>
<p>);</p>
<pre><code class="language-">
<h3>Replay Strategy</h3>

<p>When replaying events for projection rebuilds:</p>

<ul><li><strong>Find closest snapshot</strong> ≤ starting event number</li>
<li><strong>Restore snapshot</strong> if available</li>
<li><strong>Replay remaining events</strong> from snapshot version to target</li>
<li><strong>Non-atomic replays only</strong> - atomic replays always start from beginning</li>
</ul>
<p></code></pre>csharp{</p>
<p>title: "Smart Replay Strategy",</p>
<p>description: "Smart replay strategy using snapshots to reduce event processing",</p>
<p>category: "Design",</p>
<p>difficulty: "ADVANCED",</p>
<p>tags: ["Design", "Snapshots", "Replay", "Performance-Optimization"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>// Smart replay from event #50,000</p>
<p>var snapshot = await snapshotStore.GetLatestBefore(streamId, eventNumber: 50000);</p>
<p>if (snapshot != null && snapshot.Version >= 49900) { // Within 100 events</p>
<p>    aggregate.RestoreFromSnapshot(snapshot);</p>
<p>    var events = await eventStore.ReadFrom(streamId, snapshot.Version + 1, 50000);</p>
<p>} else {</p>
<p>    var events = await eventStore.ReadFrom(streamId, 0, 50000);</p>
<p>}</p>
<pre><code class="language-">
<h2>Implementation Details</h2>

<h3>Projection Handler Registration</h3>

<p></code></pre>csharp{</p>
<p>title: "Projection Handler Implementation",</p>
<p>description: "Projection handler implementation for multiple event types",</p>
<p>category: "Design",</p>
<p>difficulty: "INTERMEDIATE",</p>
<p>tags: ["Design", "Projections", "Event-Handlers", "Domain-Logic"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>public class OrderSummaryProjection : IProjectionHandler<OrderPlaced>,</p>
<p>                                     IProjectionHandler<OrderUpdated>,</p>
<p>                                     IProjectionHandler<OrderShipped> {</p>
<p>    </p>
<p>    public async Task Handle(OrderPlaced @event, ProjectionContext context) {</p>
<p>        var summary = new OrderSummary {</p>
<p>            OrderId = @event.OrderId,</p>
<p>            Total = @event.Total,</p>
<p>            Status = OrderStatus.Placed,</p>
<p>            CustomerId = @event.CustomerId</p>
<p>        };</p>
<p>        </p>
<p>        await context.Store(summary.OrderId.ToString(), summary);</p>
<p>    }</p>
<p>    </p>
<p>    public async Task Handle(OrderUpdated @event, ProjectionContext context) {</p>
<p>        var summary = await context.Load<OrderSummary>(@event.OrderId.ToString());</p>
<p>        if (summary != null) {</p>
<p>            summary.Total = @event.NewTotal;</p>
<p>            summary.Items = @event.UpdatedItems;</p>
<p>            await context.Store(@event.OrderId.ToString(), summary);</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Projection Configuration</h3>

<p></code></pre>csharp{</p>
<p>title: "Advanced Projection Configuration",</p>
<p>description: "Advanced projection configuration with partitioning and rebuild strategies",</p>
<p>category: "Design",</p>
<p>difficulty: "INTERMEDIATE",</p>
<p>tags: ["Design", "Projections", "Configuration", "Multi-Tenancy"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>services.AddProjection<OrderSummaryProjection>(projection => {</p>
<p>    projection.ProjectionName = "order-summary";</p>
<p>    projection.PartitionBy = order => order.CustomerId; // Multi-tenant partitioning</p>
<p>    projection.SnapshotStrategy = SnapshotStrategy.Automatic;</p>
<p>    projection.RebuildStrategy = RebuildStrategy.AtomicSwap;</p>
<p>    projection.CheckpointStorage = CheckpointStorage.SameDatabase;</p>
<p>});</p>
<pre><code class="language-">
<h3>Driver Interface</h3>

<p></code></pre>csharp{</p>
<p>title: "Projection Driver Interface",</p>
<p>description: "Projection driver interface for pluggable storage backends",</p>
<p>category: "Design",</p>
<p>difficulty: "ADVANCED",</p>
<p>tags: ["Design", "Drivers", "Interfaces", "Architecture"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>public interface IProjectionDriver {</p>
<p>    Task Store<T>(string projectionName, string documentId, T document, string? tenantId = null);</p>
<p>    Task<T?> Load<T>(string projectionName, string documentId, string? tenantId = null);</p>
<p>    Task Delete(string projectionName, string documentId, string? tenantId = null);</p>
<p>    </p>
<p>    // Querying support</p>
<p>    Task<IEnumerable<T>> Query<T>(string projectionName, Expression<Func<T, bool>> predicate, string? tenantId = null);</p>
<p>    Task<IEnumerable<T>> QueryAll<T>(string projectionName, string? tenantId = null);</p>
<p>    </p>
<p>    // Rebuild support</p>
<p>    Task<string> CreateTemporaryProjectionTable(string projectionName);</p>
<p>    Task SwapProjectionTables(string projectionName, string temporaryTableName);</p>
<p>    Task DropProjectionTable(string tableName);</p>
<p>}</p>
<pre><code class="language-">
<h2>Multi-Database Support</h2>

<h3>Events and Projections in Different Databases</h3>

<p></code></pre>csharp{</p>
<p>title: "Multi-Database Configuration",</p>
<p>description: "Configuration for separating events and projections across different databases",</p>
<p>category: "Design",</p>
<p>difficulty: "ADVANCED",</p>
<p>tags: ["Design", "Configuration", "Multi-Database", "Architecture"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>services.AddWhizbang(options => {</p>
<p>    // Events in PostgreSQL</p>
<p>    options.UsePostgresEventStore("Host=events-db;Database=events");</p>
<p>    </p>
<p>    // Projections in MongoDB</p>
<p>    options.UseMongoProjections("mongodb://projections-cluster");</p>
<p>    </p>
<p>    // Or projections in separate PostgreSQL instance</p>
<p>    options.UsePostgresProjections("Host=projections-db;Database=projections");</p>
<p>});</p>
<p></code>``</p>

<h3>Performance Benefits</h3>

<ul><li><strong>Events database</strong> optimized for writes (append-only)</li>
<li><strong>Projections database</strong> optimized for reads (complex queries)</li>
<li><strong>Independent scaling</strong> of read vs write workloads</li>
<li><strong>Different drivers</strong> for different use cases</li>
</ul>
<h2>Best Practices</h2>

<h3>Projection Design</h3>

<ul><li><strong>Keep projections focused</strong> - One projection per use case</li>
<li><strong>Denormalize for queries</strong> - Include all needed data</li>
<li><strong>Use tenant partitioning</strong> - For multi-tenant scenarios</li>
<li><strong>Version projections</strong> - For breaking changes</li>
</ul>
<h3>Snapshot Guidelines</h3>

<ul><li><strong>Snapshot long-lived aggregates</strong> - Orders, customers, accounts</li>
<li><strong>Don't snapshot short-lived aggregates</strong> - Shopping carts, sessions</li>
<li><strong>Consider snapshot frequency</strong> - Balance storage vs replay speed</li>
<li><strong>Test snapshot restore</strong> - Ensure snapshots work correctly</li>
</ul>
<h3>Rebuild Strategies</h3>

<ul><li><strong>Use atomic swaps</strong> for production rebuilds</li>
<li><strong>Use in-place updates</strong> for development</li>
<li><strong>Monitor rebuild progress</strong> with checkpoints</li>
<li><strong>Validate rebuilt projections</strong> before swapping</li>
</ul>
<hr>

<h2>Related Documentation</h2>

<ul><li><a href="./concurrency-control.md"><strong>Concurrency Control</strong></a> - How concurrency is managed</li>
<li><a href="./multi-tenancy.md"><strong>Multi-Tenancy</strong></a> - Tenant isolation strategies</li>
<li><a href="./performance-optimization.md"><strong>Performance Optimization</strong></a> - Scaling and tuning</li></ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="proposals-flags-tags-system" class="doc-section">
  <h2>Flags &amp; Tags System</h2>
  <p class="doc-path"><code>proposals/flags-tags-system</code></p>
  <div class="doc-content">

<h1>Flags & Tags System</h1>

<p>Whizbang provides a sophisticated flags and tags system for message context, enabling dynamic behavior modification, cross-service debugging, and flexible routing throughout the entire message lifecycle.</p>

<h2>Core Concepts</h2>

<h3>Flags (Library-Defined)</h3>

<strong>Hardcoded enum flags</strong> provided by Whizbang for common scenarios:

<p>``<code>csharp{title="WhizbangFlags Enum Definition" description="Library-defined flags enum for common development and operational scenarios" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Flags-Tags", "Message-Context", "Cross-Service-Communication"] framework="NET8"}</p>
<p>[Flags]</p>
<p>public enum WhizbangFlags : long {</p>
<p>    None = 0,</p>
<p>    </p>
<p>    // Testing & Development</p>
<p>    LoadTesting = 1 << 0,           // Don't replay these events</p>
<p>    DryRun = 1 << 1,                // Execute handlers but don't persist</p>
<p>    Development = 1 << 2,           // Development mode behaviors</p>
<p>    TraceReplay = 1 << 3,           // Replay/trace mode</p>
<p>    </p>
<p>    // Debugging & Inspection</p>
<p>    VerboseLogging = 1 << 4,        // Increase logging verbosity</p>
<p>    VerboseOtel = 1 << 5,           // Increase OpenTelemetry verbosity</p>
<p>    IgnoreTimeouts = 1 << 6,        // Bypass timeouts for debugging</p>
<p>    CursorMode = 1 << 7,            // IDE cursor/scrubbing mode</p>
<p>    Breakpoint = 1 << 8,            // Trigger breakpoints</p>
<p>    </p>
<p>    // Security & Compliance</p>
<p>    SecurityBypass = 1 << 9,        // Bypass security checks (dangerous)</p>
<p>    DataScrubbing = 1 << 10,        // Scrub sensitive data</p>
<p>    ComplianceMode = 1 << 11,       // Extra compliance logging</p>
<p>    </p>
<p>    // Routing & Delivery</p>
<p>    AlternativeRouting = 1 << 12,   // Use alternative handlers</p>
<p>    PriorityDelivery = 1 << 13,     // Expedite processing</p>
<p>    DelayedProcessing = 1 << 14,    // Defer processing</p>
<p>    </p>
<p>    // Environment & Lifecycle</p>
<p>    Production = 1 << 15,           // Production environment</p>
<p>    Staging = 1 << 16,              // Staging environment</p>
<p>    QA = 1 << 17,                   // QA environment</p>
<p>    Migration = 1 << 18,            // Data migration context</p>
<p>    </p>
<p>    // Custom ranges for user-defined flags</p>
<p>    UserDefined1 = 1 << 32,</p>
<p>    UserDefined2 = 1 << 33,</p>
<p>    // ... up to 1 << 63</p>
<p>}</p>
<pre><code class="language-">
<h3>Tags (User-Defined)</h3>

<strong>Arbitrary string tags</strong> added by developers for custom scenarios:

<p></code></pre>csharp{title="MessageContext with Fluent API" description="Message context class with fluent API for flags and tags management" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Flags-Tags", "Message-Context", "Fluent-API"] framework="NET8"}</p>
<p>public class MessageContext {</p>
<p>    public WhizbangFlags Flags { get; set; }</p>
<p>    public HashSet<string> Tags { get; set; } = new();</p>
<p>    public string? CorrelationId { get; set; }</p>
<p>    public string? TenantId { get; set; }</p>
<p>    public string? Domain { get; set; }</p>
<p>    </p>
<p>    // Fluent API for context building</p>
<p>    public MessageContext WithTag(string tag) {</p>
<p>        Tags.Add(tag);</p>
<p>        return this;</p>
<p>    }</p>
<p>    </p>
<p>    public MessageContext WithFlags(WhizbangFlags flags) {</p>
<p>        Flags |= flags;</p>
<p>        return this;</p>
<p>    }</p>
<p>    </p>
<p>    public MessageContext WithCorrelationId(string correlationId) {</p>
<p>        CorrelationId = correlationId;</p>
<p>        return this;</p>
<p>    }</p>
<p>    </p>
<p>    public bool HasFlag(WhizbangFlags flag) => (Flags & flag) == flag;</p>
<p>    public bool HasTag(string tag) => Tags.Contains(tag);</p>
<p>    public bool HasAnyTag(params string[] tags) => tags.Any(Tags.Contains);</p>
<p>    public bool HasAllTags(params string[] tags) => tags.All(Tags.Contains);</p>
<p>}</p>

<p>// Usage examples</p>
<p>context.WithTag("customer-priority")</p>
<p>       .WithTag("region-us-west")</p>
<p>       .WithTag("high-value-order")</p>
<p>       .WithFlags(WhizbangFlags.VerboseLogging | WhizbangFlags.PriorityDelivery)</p>
<p>       .WithCorrelationId("debug-session-123");</p>
<pre><code class="language-">
<h2>Cross-Service Propagation</h2>

<h3>Automatic Flag Propagation</h3>

<strong>Flags carry through entire message journey</strong> across service boundaries:

<p></code></pre>csharp{title="Cross-Service Flag Propagation" description="Automatic flag and tag propagation across service boundaries" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Flags-Tags", "Cross-Service-Propagation", "Debugging"] framework="NET8"}</p>
<p>// Service 1: Initial command with debugging flags</p>
<p>var command = new PlaceOrder(orderId, customerId, items);</p>
<p>await _mediator.Send(command, context => {</p>
<p>    context.WithFlags(WhizbangFlags.VerboseLogging | WhizbangFlags.TraceReplay)</p>
<p>           .WithTag("debug-session-123")</p>
<p>           .WithTag("customer-vip");</p>
<p>});</p>

<p>// Flags automatically propagate to:</p>
<p>// 1. Command handler execution in Service 1</p>
<p>// 2. Event publishing from Service 1</p>
<p>// 3. Cross-service event delivery via message broker</p>
<p>// 4. Event handler execution in Service 2</p>
<p>// 5. Projection updates in Service 2</p>
<p>// 6. Saga execution across services</p>

<p></code>`<code>csharp{title="Context-Aware Event Handler" description="Event handler using propagated flags and tags for conditional processing" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Flags-Tags", "Event-Handlers", "Context-Aware-Processing"] framework="NET8"}</p>
<p>// Service 2: Receives event with same flags and tags</p>
<p>public class InventoryHandler : IEventHandler<OrderPlaced> {</p>
<p>    public async Task Handle(OrderPlaced @event, EventContext context) {</p>
<p>        // context.Flags contains VerboseLogging | TraceReplay</p>
<p>        // context.Tags contains "debug-session-123", "customer-vip"</p>
<p>        </p>
<p>        if (context.HasFlag(WhizbangFlags.VerboseLogging)) {</p>
<p>            _logger.LogInformation("Processing order with verbose logging enabled for debug session {DebugSession}", </p>
<p>                context.Tags.FirstOrDefault(t => t.StartsWith("debug-session")));</p>
<p>        }</p>
<p>        </p>
<p>        if (context.HasTag("customer-vip")) {</p>
<p>            // Special handling for VIP customers</p>
<p>            await _vipCustomerService.NotifyOrderReceived(@event.OrderId);</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Message Context Serialization</h3>

<strong>Context travels with messages</strong> across all transport mechanisms:

<p></code></pre>csharp{title="Message Envelope for Cross-Service Communication" description="Message envelope with context serialization for cross-service communication" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Flags-Tags", "Message-Serialization", "Cross-Service"] framework="NET8"}</p>
<p>// Message envelope for cross-service communication</p>
<p>public class MessageEnvelope<T> {</p>
<p>    public T Message { get; set; }</p>
<p>    public MessageContext Context { get; set; }</p>
<p>    public Dictionary<string, string> Headers { get; set; } = new();</p>
<p>    public DateTimeOffset Timestamp { get; set; } = DateTimeOffset.UtcNow;</p>
<p>}</p>

<p></code>`<code>csharp{title="Kafka Message Publisher" description="Kafka message publisher with automatic context serialization" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Flags-Tags", "Kafka", "Message-Brokers"] framework="NET8"}</p>
<p>// Automatic context serialization in message brokers</p>
<p>public class KafkaMessagePublisher : IMessagePublisher {</p>
<p>    public async Task PublishAsync<T>(T message, MessageContext context) {</p>
<p>        var envelope = new MessageEnvelope<T> {</p>
<p>            Message = message,</p>
<p>            Context = context,</p>
<p>            Headers = new Dictionary<string, string> {</p>
<p>                ["whizbang-flags"] = ((long)context.Flags).ToString(),</p>
<p>                ["whizbang-tags"] = string.Join(",", context.Tags),</p>
<p>                ["whizbang-correlation-id"] = context.CorrelationId ?? "",</p>
<p>                ["whizbang-tenant-id"] = context.TenantId ?? "",</p>
<p>                ["whizbang-domain"] = context.Domain ?? ""</p>
<p>            }</p>
<p>        };</p>
<p>        </p>
<p>        await _kafkaProducer.ProduceAsync(GetTopicName<T>(), envelope);</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Debugging and Development Features</h2>

<h3>IDE Cursor/Scrubbing Mode</h3>

<strong>Interactive debugging</strong> with state inspection:

<p></code></pre>csharp{title="IDE Cursor Mode Handler" description="IDE integration for interactive debugging with state inspection" category="Design" difficulty="ADVANCED" tags=["Design", "Flags-Tags", "IDE-Integration", "Debugging", "Cursor-Mode"] framework="NET8"}</p>
<p>// IDE integration for step-by-step debugging</p>
<p>public class CursorModeHandler : IMessageInterceptor {</p>
<p>    public async Task<TResponse> Intercept<TRequest, TResponse>(</p>
<p>        TRequest message,</p>
<p>        MessageContext context,</p>
<p>        MessageHandlerDelegate<TRequest, TResponse> next) {</p>
<p>        </p>
<p>        if (context.HasFlag(WhizbangFlags.CursorMode)) {</p>
<p>            // Capture pre-execution state</p>
<p>            var preState = await _stateCapture.CaptureStateAsync(context);</p>
<p>            </p>
<p>            // Notify IDE of execution point</p>
<p>            await _ideNotificationService.NotifyExecutionPoint(new ExecutionPoint {</p>
<p>                MessageType = typeof(TRequest).Name,</p>
<p>                HandlerType = context.HandlerType?.Name,</p>
<p>                CorrelationId = context.CorrelationId,</p>
<p>                State = preState,</p>
<p>                CanStepForward = true,</p>
<p>                CanStepBackward = true</p>
<p>            });</p>
<p>            </p>
<p>            // Wait for IDE to signal continue</p>
<p>            await _ideNotificationService.WaitForContinueSignal(context.CorrelationId);</p>
<p>        }</p>
<p>        </p>
<p>        var response = await next(message, context);</p>
<p>        </p>
<p>        if (context.HasFlag(WhizbangFlags.CursorMode)) {</p>
<p>            // Capture post-execution state</p>
<p>            var postState = await _stateCapture.CaptureStateAsync(context);</p>
<p>            </p>
<p>            await _ideNotificationService.NotifyExecutionComplete(new ExecutionResult {</p>
<p>                CorrelationId = context.CorrelationId,</p>
<p>                Response = response,</p>
<p>                PostState = postState,</p>
<p>                ExecutionTime = context.ExecutionTime</p>
<p>            });</p>
<p>        }</p>
<p>        </p>
<p>        return response;</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Breakpoint System</h3>

<strong>Programmatic breakpoints</strong> triggered by flags:

<p></code></pre>csharp{title="Programmatic Breakpoint Handler" description="Programmatic breakpoint system triggered by flags for debugging" category="Design" difficulty="ADVANCED" tags=["Design", "Flags-Tags", "Debugging", "Breakpoints", "Development-Tools"] framework="NET8"}</p>
<p>public class BreakpointHandler : IMessageInterceptor {</p>
<p>    public async Task<TResponse> Intercept<TRequest, TResponse>(</p>
<p>        TRequest message,</p>
<p>        MessageContext context,</p>
<p>        MessageHandlerDelegate<TRequest, TResponse> next) {</p>
<p>        </p>
<p>        if (context.HasFlag(WhizbangFlags.Breakpoint)) {</p>
<p>            var breakpointContext = new BreakpointContext {</p>
<p>                BreakpointId = Guid.NewGuid(),</p>
<p>                MessageType = typeof(TRequest).Name,</p>
<p>                Message = message,</p>
<p>                Context = context,</p>
<p>                StackTrace = Environment.StackTrace,</p>
<p>                Timestamp = DateTimeOffset.UtcNow</p>
<p>            };</p>
<p>            </p>
<p>            // Store breakpoint information</p>
<p>            await _breakpointStore.StoreBreakpointAsync(breakpointContext);</p>
<p>            </p>
<p>            // Notify debugging tools</p>
<p>            await _debuggerNotificationService.NotifyBreakpointHit(breakpointContext);</p>
<p>            </p>
<p>            // Optionally pause execution for attached debuggers</p>
<p>            if (_debuggerService.IsAttached) {</p>
<p>                System.Diagnostics.Debugger.Break();</p>
<p>            }</p>
<p>        }</p>
<p>        </p>
<p>        return await next(message, context);</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Data Scrubbing and Security</h2>

<h3>Automatic Data Scrubbing</h3>

<strong>Policy-driven data sanitization</strong> based on flags:

<p></code></pre>csharp{title="Data Scrubbing Interceptor" description="Policy-driven data sanitization based on flags for security compliance" category="Design" difficulty="ADVANCED" tags=["Design", "Flags-Tags", "Data-Scrubbing", "Security", "Privacy"] framework="NET8"}</p>
<p>public class DataScrubbingInterceptor : IMessageInterceptor {</p>
<p>    public async Task<TResponse> Intercept<TRequest, TResponse>(</p>
<p>        TRequest message,</p>
<p>        MessageContext context,</p>
<p>        MessageHandlerDelegate<TRequest, TResponse> next) {</p>
<p>        </p>
<p>        TRequest processedMessage = message;</p>
<p>        </p>
<p>        if (context.HasFlag(WhizbangFlags.DataScrubbing)) {</p>
<p>            // Apply data scrubbing rules</p>
<p>            processedMessage = await _dataScrubber.ScrubAsync(message, new ScrubOptions {</p>
<p>                ScrubPersonalData = true,</p>
<p>                ScrubFinancialData = true,</p>
<p>                ScrubSensitiveFields = true,</p>
<p>                PreserveFunctionality = true,</p>
<p>                AddScrubbedMarkers = true</p>
<p>            });</p>
<p>            </p>
<p>            // Add scrubbing metadata to context</p>
<p>            context.Tags.Add("data-scrubbed");</p>
<p>            context.Tags.Add($"scrubbed-at-{DateTimeOffset.UtcNow:yyyy-MM-dd-HH-mm-ss}");</p>
<p>        }</p>
<p>        </p>
<p>        return await next(processedMessage, context);</p>
<p>    }</p>
<p>}</p>

<p></code>`<code>csharp{title="Order Data Scrubber Implementation" description="Concrete data scrubber implementation for order data sanitization" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Flags-Tags", "Data-Scrubbing", "Implementation"] framework="NET8"}</p>
<p>// Data scrubbing rules</p>
<p>public class OrderDataScrubber : IDataScrubber<PlaceOrder> {</p>
<p>    public async Task<PlaceOrder> ScrubAsync(PlaceOrder order, ScrubOptions options) {</p>
<p>        return order with {</p>
<p>            // Scrub customer email</p>
<p>            CustomerEmail = options.ScrubPersonalData ? ScrubEmail(order.CustomerEmail) : order.CustomerEmail,</p>
<p>            </p>
<p>            // Scrub payment information</p>
<p>            PaymentToken = options.ScrubFinancialData ? "[SCRUBBED-PAYMENT-TOKEN]" : order.PaymentToken,</p>
<p>            </p>
<p>            // Preserve order structure but scrub sensitive data</p>
<p>            Items = order.Items.Select(item => item with {</p>
<p>                ProductName = options.PreserveFunctionality ? item.ProductName : $"Product-{item.ProductId.ToString()[..8]}"</p>
<p>            }).ToList()</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Production to QA Data Flow</h3>

<strong>Secure data replication</strong> with automatic scrubbing:

<p></code></pre>csharp{title="Production to QA Data Replicator" description="Secure data replication from production to QA with automatic scrubbing" category="Design" difficulty="ADVANCED" tags=["Design", "Flags-Tags", "Production-to-QA", "Data-Replication"] framework="NET8"}</p>
<p>// Handler that duplicates production messages to QA with scrubbing</p>
<p>public class ProductionToQAReplicator : IEventHandler<object> {</p>
<p>    public async Task Handle(object @event, EventContext context) {</p>
<p>        // Only replicate events tagged for QA replication</p>
<p>        if (context.HasTag("production-data") && </p>
<p>            context.HasFlag(WhizbangFlags.QA)) {</p>
<p>            </p>
<p>            // Create a copy with scrubbing flag</p>
<p>            var qaCopy = @event;</p>
<p>            var qaContext = context.Copy()</p>
<p>                .WithFlag(WhizbangFlags.DataScrubbing)</p>
<p>                .WithTag("qa-replicated")</p>
<p>                .WithTag($"replicated-from-production-{DateTimeOffset.UtcNow:yyyy-MM-dd}");</p>
<p>            </p>
<p>            // Remove production-specific tags</p>
<p>            qaContext.Tags.Remove("production-data");</p>
<p>            qaContext.Tags.Remove("customer-vip"); // Don't carry VIP status to QA</p>
<p>            </p>
<p>            // Route to QA environment</p>
<p>            await _qaEventPublisher.PublishAsync(qaCopy, qaContext);</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Performance and Load Testing</h2>

<h3>Load Testing Flag Handling</h3>

<strong>Optimize behavior for load testing scenarios</strong>:

<p></code></pre>csharp{title="Load Testing Optimizer" description="Load testing optimization interceptor with flag-based behavior modification" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Flags-Tags", "Load-Testing", "Performance-Optimization"] framework="NET8"}</p>
<p>public class LoadTestingOptimizer : IMessageInterceptor {</p>
<p>    public async Task<TResponse> Intercept<TRequest, TResponse>(</p>
<p>        TRequest message,</p>
<p>        MessageContext context,</p>
<p>        MessageHandlerDelegate<TRequest, TResponse> next) {</p>
<p>        </p>
<p>        if (context.HasFlag(WhizbangFlags.LoadTesting)) {</p>
<p>            // Optimize for load testing</p>
<p>            using var loadTestScope = _performanceOptimizer.EnterLoadTestMode();</p>
<p>            </p>
<p>            // Disable slow operations</p>
<p>            context.Tags.Add("skip-audit-logging");</p>
<p>            context.Tags.Add("skip-analytics-tracking");</p>
<p>            context.Tags.Add("minimal-validation");</p>
<p>            </p>
<p>            // Add load test metadata</p>
<p>            context.Tags.Add($"load-test-batch-{GetLoadTestBatch()}");</p>
<p>            context.Tags.Add($"load-test-thread-{Thread.CurrentThread.ManagedThreadId}");</p>
<p>            </p>
<p>            // Execute with load test optimizations</p>
<p>            return await next(message, context);</p>
<p>        }</p>
<p>        </p>
<p>        return await next(message, context);</p>
<p>    }</p>
<p>    </p>
<p>    private string GetLoadTestBatch() {</p>
<p>        // Identify which load test batch this belongs to</p>
<p>        return Environment.GetEnvironmentVariable("LOAD_TEST_BATCH_ID") ?? "unknown";</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Advanced Routing Scenarios</h2>

<h3>Dynamic Handler Selection</h3>

<strong>Route to different handlers</strong> based on flags and tags:

<p></code></pre>csharp{title="Context-Aware Handler Factory" description="Dynamic handler selection based on flags and tags for flexible routing" category="Design" difficulty="ADVANCED" tags=["Design", "Flags-Tags", "Dynamic-Routing", "Handler-Selection"] framework="NET8"}</p>
<p>// Handler factory that selects implementation based on context</p>
<p>public class ContextAwareHandlerFactory<T> : ICommandHandler<T> where T : ICommand {</p>
<p>    private readonly IServiceProvider _serviceProvider;</p>
<p>    private readonly IHandlerRoutingRules _routingRules;</p>
<p>    </p>
<p>    public async Task Handle(T command, MessageContext context) {</p>
<p>        var handlerType = await _routingRules.DetermineHandlerType<T>(context);</p>
<p>        var handler = (ICommandHandler<T>)_serviceProvider.GetRequiredService(handlerType);</p>
<p>        </p>
<p>        return await handler.Handle(command, context);</p>
<p>    }</p>
<p>}</p>

<p></code>`<code>csharp{title="Handler Routing Rules" description="Context-based routing rules for handler type determination" category="Design" difficulty="ADVANCED" tags=["Design", "Flags-Tags", "Routing-Rules", "Handler-Selection"] framework="NET8"}</p>
<p>// Routing rules based on context</p>
<p>public class HandlerRoutingRules : IHandlerRoutingRules {</p>
<p>    public async Task<Type> DetermineHandlerType<T>(MessageContext context) {</p>
<p>        // VIP customers get premium handler</p>
<p>        if (context.HasTag("customer-vip")) {</p>
<p>            return typeof(PremiumOrderHandler);</p>
<p>        }</p>
<p>        </p>
<p>        // Load testing gets optimized handler</p>
<p>        if (context.HasFlag(WhizbangFlags.LoadTesting)) {</p>
<p>            return typeof(LoadTestOptimizedOrderHandler);</p>
<p>        }</p>
<p>        </p>
<p>        // Migration data gets special handler</p>
<p>        if (context.HasFlag(WhizbangFlags.Migration)) {</p>
<p>            return typeof(DataMigrationOrderHandler);</p>
<p>        }</p>
<p>        </p>
<p>        // Default handler</p>
<p>        return typeof(StandardOrderHandler);</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Configuration and Management</h2>

<h3>Flag Management</h3>

<strong>Control flag behavior</strong> through configuration:

<p></code></pre>csharp{title="Flag Management Configuration" description="Flag management configuration with environment-based defaults and validation" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Flags-Tags", "Configuration", "Environment-Management"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.Flags(flags => {</p>
<p>        // Environment-based flag defaults</p>
<p>        if (_environment.IsDevelopment()) {</p>
<p>            flags.DefaultFlags = WhizbangFlags.Development | WhizbangFlags.VerboseLogging;</p>
<p>        } else if (_environment.IsProduction()) {</p>
<p>            flags.DefaultFlags = WhizbangFlags.Production;</p>
<p>            flags.RestrictedFlags = WhizbangFlags.SecurityBypass | WhizbangFlags.DataScrubbing;</p>
<p>        }</p>
<p>        </p>
<p>        // Flag validation rules</p>
<p>        flags.AddValidationRule(ctx => {</p>
<p>            if (ctx.HasFlag(WhizbangFlags.SecurityBypass) && !ctx.HasTag("authorized-security-bypass")) {</p>
<p>                throw new UnauthorizedFlagException("SecurityBypass flag requires authorization");</p>
<p>            }</p>
<p>        });</p>
<p>        </p>
<p>        // Automatic flag addition based on context</p>
<p>        flags.AddAutoFlag(WhizbangFlags.ComplianceMode, </p>
<p>            condition: ctx => ctx.HasTag("pci-data") || ctx.HasTag("gdpr-data"));</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h3>Tag Lifecycle Management</h3>

<strong>Manage tag propagation and cleanup</strong>:

<p></code></pre>csharp{title="Tag Lifecycle Manager" description="Tag lifecycle management with automatic addition and cleanup" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Flags-Tags", "Tag-Lifecycle", "Management"] framework="NET8"}</p>
<p>public class TagLifecycleManager : IMessageInterceptor {</p>
<p>    public async Task<TResponse> Intercept<TRequest, TResponse>(</p>
<p>        TRequest message,</p>
<p>        MessageContext context,</p>
<p>        MessageHandlerDelegate<TRequest, TResponse> next) {</p>
<p>        </p>
<p>        // Add automatic tags</p>
<p>        context.Tags.Add($"processed-at-{Environment.MachineName}");</p>
<p>        context.Tags.Add($"handler-{typeof(TRequest).Name}");</p>
<p>        </p>
<p>        // Remove expired tags</p>
<p>        var expiredTags = context.Tags</p>
<p>            .Where(tag => tag.StartsWith("session-") && IsSessionExpired(tag))</p>
<p>            .ToList();</p>
<p>        </p>
<p>        foreach (var expiredTag in expiredTags) {</p>
<p>            context.Tags.Remove(expiredTag);</p>
<p>        }</p>
<p>        </p>
<p>        var response = await next(message, context);</p>
<p>        </p>
<p>        // Add response-based tags</p>
<p>        if (response is ISuccessResult) {</p>
<p>            context.Tags.Add("execution-success");</p>
<p>        } else if (response is IErrorResult error) {</p>
<p>            context.Tags.Add($"execution-error-{error.ErrorCode}");</p>
<p>        }</p>
<p>        </p>
<p>        return response;</p>
<p>    }</p>
<p>}</p>
<p></code>``</p>

<h2>Best Practices</h2>

<h3>Flag Usage Guidelines</h3>

<ul><li><strong>Use library flags first</strong> - Prefer built-in flags over custom tags when possible</li>
<li><strong>Document custom flags</strong> - Make user-defined flags clear to the team</li>
<li><strong>Be conservative with propagation</strong> - Not all flags should cross service boundaries</li>
<li><strong>Consider flag lifetime</strong> - How long should flags persist in the system</li>
<li><strong>Audit flag usage</strong> - Track which flags are used and where</li>
</ul>
<h3>Tag Design Principles</h3>

<ul><li><strong>Hierarchical naming</strong> - Use consistent naming conventions (e.g., "customer-vip", "region-us-west")</li>
<li><strong>Meaningful values</strong> - Tags should be self-documenting</li>
<li><strong>Avoid high cardinality</strong> - Don't create too many unique tag combinations</li>
<li><strong>Lifecycle awareness</strong> - Consider when tags should be added/removed</li>
<li><strong>Security sensitivity</strong> - Don't include sensitive data in tag names</li>
</ul>
<h3>Security Considerations</h3>

<ul><li><strong>Validate flag sources</strong> - Ensure flags come from trusted sources</li>
<li><strong>Limit dangerous flags</strong> - SecurityBypass should be heavily restricted</li>
<li><strong>Audit flag changes</strong> - Log all flag modifications</li>
<li><strong>Encrypt sensitive tags</strong> - Some tags may contain sensitive information</li>
<li><strong>Principle of least privilege</strong> - Flags should grant minimal necessary permissions</li>
</ul>
<hr>

<h2>Related Documentation</h2>

<ul><li><a href="./policy-engine.md"><strong>Policy Engine</strong></a> - How policies use flags and tags for decision making</li>
<li><a href="./observability-metrics.md"><strong>Observability & Metrics</strong></a> - Flag-driven observability levels</li>
<li><a href="./testing-development-tools.md"><strong>Testing & Development Tools</strong></a> - Testing with flags and tags</li></ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="proposals-multi-tenancy" class="doc-section">
  <h2>Multi-Tenancy</h2>
  <p class="doc-path"><code>proposals/multi-tenancy</code></p>
  <div class="doc-content">

<h1>Multi-Tenancy</h1>

<p>Whizbang provides comprehensive multi-tenancy support with flexible tenant isolation strategies, from single database with row-level security to complete database separation.</p>

<h2>Tenant Isolation Strategies</h2>

<h3>Single Database with Tenant ID</h3>

<strong>Row-level tenant isolation</strong> using tenant ID columns:

<pre><code class="language-sql">---
<p>category: Design</p>
<p>difficulty: INTERMEDIATE</p>
<p>tags: [Design, Multi-Tenancy, SQL, Row-Level-Security]</p>
<p>description: SQL schema for tenant-isolated events table with row-level security</p>
<hr>
<p>-- Events table with tenant isolation</p>
<p>CREATE TABLE events (</p>
<p>    event_id BIGSERIAL PRIMARY KEY,</p>
<p>    stream_id VARCHAR(255) NOT NULL,</p>
<p>    stream_version INT NOT NULL,</p>
<p>    event_type VARCHAR(255) NOT NULL,</p>
<p>    event_data JSONB NOT NULL,</p>
<p>    metadata JSONB,</p>
<p>    tenant_id UUID NOT NULL,  -- Tenant isolation</p>
<p>    created_at TIMESTAMPTZ NOT NULL,</p>
<p>    UNIQUE(tenant_id, stream_id, stream_version)</p>
<p>);</p>

<p>-- Projections table with tenant isolation</p>
<p>CREATE TABLE projections (</p>
<p>    projection_name VARCHAR(255) NOT NULL,</p>
<p>    document_id VARCHAR(255) NOT NULL,</p>
<p>    document JSONB NOT NULL,</p>
<p>    tenant_id UUID NOT NULL,  -- Tenant isolation</p>
<p>    version BIGINT NOT NULL,</p>
<p>    last_updated TIMESTAMPTZ NOT NULL,</p>
<p>    PRIMARY KEY (projection_name, document_id, tenant_id)</p>
<p>);</p>

<p>-- Row-level security policies</p>
<p>CREATE POLICY tenant_isolation_events ON events</p>
<p>    USING (tenant_id = current_setting('app.current_tenant_id')::UUID);</p>

<p>CREATE POLICY tenant_isolation_projections ON projections  </p>
<p>    USING (tenant_id = current_setting('app.current_tenant_id')::UUID);</p>
<p></code></pre></p>

<h3>Multiple Databases</h3>

<strong>Complete database separation</strong> per tenant:

<p>``<code>csharp{</p>
<p>title: "Separate Database Configuration",</p>
<p>description: "Configuration for complete database separation per tenant",</p>
<p>category: "Design",</p>
<p>difficulty: "ADVANCED",</p>
<p>tags: ["Multi-Tenancy", "Configuration", "Separate-Databases", "Database-Per-Tenant"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.MultiTenancy(tenancy => {</p>
<p>        tenancy.Strategy = TenancyStrategy.SeparateDatabases;</p>
<p>        tenancy.DatabaseProvider = (tenantId) => {</p>
<p>            return $"Host=db-server;Database=tenant_{tenantId};Username=app;Password=secret";</p>
<p>        };</p>
<p>        </p>
<p>        // Database creation for new tenants</p>
<p>        tenancy.AutoCreateDatabases = true;</p>
<p>        tenancy.DatabaseTemplate = "tenant_template";</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h3>Same Table with Partitioning</h3>

<strong>Table partitioning</strong> by tenant for performance:

<p></code></pre>sql</p>
<hr>
<p>category: Design</p>
<p>difficulty: ADVANCED</p>
<p>tags: [Design, Multi-Tenancy, SQL, Table-Partitioning, Performance]</p>
<p>description: Table partitioning by tenant for performance optimization</p>
<hr>
<p>-- Partitioned events table</p>
<p>CREATE TABLE events (</p>
<p>    event_id BIGSERIAL,</p>
<p>    stream_id VARCHAR(255) NOT NULL,</p>
<p>    stream_version INT NOT NULL,</p>
<p>    event_type VARCHAR(255) NOT NULL,</p>
<p>    event_data JSONB NOT NULL,</p>
<p>    metadata JSONB,</p>
<p>    tenant_id UUID NOT NULL,</p>
<p>    created_at TIMESTAMPTZ NOT NULL</p>
<p>) PARTITION BY HASH (tenant_id);</p>

<p>-- Create partitions</p>
<p>CREATE TABLE events_p0 PARTITION OF events FOR VALUES WITH (MODULUS 4, REMAINDER 0);</p>
<p>CREATE TABLE events_p1 PARTITION OF events FOR VALUES WITH (MODULUS 4, REMAINDER 1);</p>
<p>CREATE TABLE events_p2 PARTITION OF events FOR VALUES WITH (MODULUS 4, REMAINDER 2);</p>
<p>CREATE TABLE events_p3 PARTITION OF events FOR VALUES WITH (MODULUS 4, REMAINDER 3);</p>
<pre><code class="language-">
<h2>Tenant ID Definition</h2>

<h3>Default Tenant ID Field</h3>

<strong>Standard GUID-based tenant identification</strong>:

<p></code></pre>csharp{</p>
<p>title: "Default Tenant ID Definition",</p>
<p>description: "Standard tenant ID definition using property conventions and strong types",</p>
<p>category: "Design",</p>
<p>difficulty: "BEGINNER",</p>
<p>tags: ["Multi-Tenancy", "Domain-Models", "Tenant-ID", "Strong-Types"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>// Default: Look for TenantId property</p>
<p>public class Order : Aggregate {</p>
<p>    public Guid Id { get; private set; }</p>
<p>    public Guid TenantId { get; private set; } // Automatically detected</p>
<p>    public decimal Total { get; private set; }</p>
<p>    </p>
<p>    public Order(Guid tenantId, Guid id) {</p>
<p>        TenantId = tenantId;</p>
<p>        Id = id;</p>
<p>    }</p>
<p>}</p>

<p>// Strong-typed tenant ID</p>
<p>public record TenantId(Guid Value) : StrongTypeId<Guid>(Value);</p>

<p>public class Order : Aggregate {</p>
<p>    public Guid Id { get; private set; }</p>
<p>    public TenantId TenantId { get; private set; } // Strong type detected</p>
<p>    public decimal Total { get; private set; }</p>
<p>}</p>
<pre><code class="language-">
<h3>Composite Tenant ID</h3>

<strong>Multi-field tenant identification</strong>:

<p></code></pre>csharp{</p>
<p>title: "Composite Tenant ID Configuration",</p>
<p>description: "Multi-field tenant identification for complex organizational structures",</p>
<p>category: "Design",</p>
<p>difficulty: "INTERMEDIATE",</p>
<p>tags: ["Multi-Tenancy", "Composite-Tenant-ID", "Configuration", "Organization-Structure"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.MultiTenancy(tenancy => {</p>
<p>        tenancy.TenantIdComposition<Order>(composition => {</p>
<p>            composition.FromFields(order => new { </p>
<p>                order.OrganizationId, </p>
<p>                order.DivisionId </p>
<p>            });</p>
<p>        });</p>
<p>        </p>
<p>        tenancy.TenantIdComposition<Customer>(composition => {</p>
<p>            composition.FromFields(customer => customer.CompanyId);</p>
<p>        });</p>
<p>    });</p>
<p>});</p>

<p>// Usage in aggregates</p>
<p>public class Order : Aggregate {</p>
<p>    public Guid Id { get; private set; }</p>
<p>    public Guid OrganizationId { get; private set; } // Part of tenant ID</p>
<p>    public Guid DivisionId { get; private set; }     // Part of tenant ID</p>
<p>    public Guid CustomerId { get; private set; }</p>
<p>}</p>
<pre><code class="language-">
<h3>Custom Tenant Resolution</h3>

<strong>Complex tenant identification logic</strong>:

<p></code></pre>csharp{</p>
<p>title: "Custom Tenant Resolution",</p>
<p>description: "Custom tenant identification logic for complex business scenarios",</p>
<p>category: "Design",</p>
<p>difficulty: "ADVANCED",</p>
<p>tags: ["Multi-Tenancy", "Custom-Resolution", "Business-Logic", "Configuration"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.MultiTenancy(tenancy => {</p>
<p>        tenancy.TenantResolver<Order>(order => {</p>
<p>            // Custom logic to determine tenant</p>
<p>            if (order.OrganizationId == SpecialOrgId) {</p>
<p>                return $"special-{order.DivisionId}";</p>
<p>            }</p>
<p>            return order.OrganizationId.ToString();</p>
<p>        });</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h2>Tenant Context Management</h2>

<h3>Tenant Context Propagation</h3>

<p></code></pre>csharp{</p>
<p>title: "Tenant Context Interface",</p>
<p>description: "Interface for managing current tenant state and context",</p>
<p>category: "Design",</p>
<p>difficulty: "INTERMEDIATE",</p>
<p>tags: ["Multi-Tenancy", "Context-Management", "Interfaces", "State-Management"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>public interface ITenantContext {</p>
<p>    string? CurrentTenantId { get; }</p>
<p>    void SetTenant(string tenantId);</p>
<p>    void ClearTenant();</p>
<p>    bool HasTenant { get; }</p>
<p>}</p>

<p></code>`<code>csharp{</p>
<p>title: "Tenant Context Middleware",</p>
<p>description: "ASP.NET Core middleware for automatic tenant context propagation from multiple sources",</p>
<p>category: "Design",</p>
<p>difficulty: "INTERMEDIATE",</p>
<p>tags: ["Multi-Tenancy", "ASP.NET-Core", "Middleware", "Context-Propagation"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>// ASP.NET Core middleware</p>
<p>public class TenantContextMiddleware {</p>
<p>    public async Task InvokeAsync(HttpContext context, RequestDelegate next) {</p>
<p>        var tenantId = ExtractTenantId(context);</p>
<p>        </p>
<p>        if (tenantId != null) {</p>
<p>            _tenantContext.SetTenant(tenantId);</p>
<p>        }</p>
<p>        </p>
<p>        try {</p>
<p>            await next(context);</p>
<p>        } finally {</p>
<p>            _tenantContext.ClearTenant();</p>
<p>        }</p>
<p>    }</p>
<p>    </p>
<p>    private string? ExtractTenantId(HttpContext context) {</p>
<p>        // From header</p>
<p>        if (context.Request.Headers.TryGetValue("X-Tenant-ID", out var headerValue)) {</p>
<p>            return headerValue;</p>
<p>        }</p>
<p>        </p>
<p>        // From subdomain</p>
<p>        var host = context.Request.Host.Host;</p>
<p>        if (host.Contains('.')) {</p>
<p>            var subdomain = host.Split('.')[0];</p>
<p>            return subdomain != "www" ? subdomain : null;</p>
<p>        }</p>
<p>        </p>
<p>        // From route</p>
<p>        if (context.Request.RouteValues.TryGetValue("tenantId", out var routeValue)) {</p>
<p>            return routeValue?.ToString();</p>
<p>        }</p>
<p>        </p>
<p>        return null;</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Tenant-Aware Command/Event Handling</h3>

<p></code></pre>csharp{</p>
<p>title: "Tenant-Aware Command Handler",</p>
<p>description: "Command handler implementation with tenant context validation and isolation",</p>
<p>category: "Design",</p>
<p>difficulty: "INTERMEDIATE",</p>
<p>tags: ["Multi-Tenancy", "Command-Handlers", "Domain-Logic", "Context-Validation"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>public class PlaceOrderHandler : ICommandHandler<PlaceOrder> {</p>
<p>    private readonly ITenantContext _tenantContext;</p>
<p>    private readonly IOrderRepository _repository;</p>
<p>    </p>
<p>    public async Task<OrderPlaced> Handle(PlaceOrder command) {</p>
<p>        var tenantId = _tenantContext.CurrentTenantId </p>
<p>            ?? throw new InvalidOperationException("No tenant context");</p>
<p>        </p>
<p>        var order = new Order(</p>
<p>            tenantId: Guid.Parse(tenantId),</p>
<p>            orderId: command.OrderId,</p>
<p>            customerId: command.CustomerId,</p>
<p>            items: command.Items</p>
<p>        );</p>
<p>        </p>
<p>        await _repository.Save(order);</p>
<p>        </p>
<p>        return new OrderPlaced(</p>
<p>            command.OrderId,</p>
<p>            command.CustomerId,</p>
<p>            DateTimeOffset.UtcNow</p>
<p>        ) {</p>
<p>            TenantId = tenantId // Automatically added to event metadata</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Tenant-Aware Projections</h2>

<h3>Projection-Level Isolation</h3>

<p></code></pre>csharp{</p>
<p>title: "Tenant-Specific Projection",</p>
<p>description: "Tenant-specific projection configuration with isolation controls",</p>
<p>category: "Design",</p>
<p>difficulty: "INTERMEDIATE",</p>
<p>tags: ["Multi-Tenancy", "Projections", "Tenant-Isolation", "Event-Handling"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>services.AddProjection<OrderSummaryProjection>(options => {</p>
<p>    options.TenantIsolation(isolation => {</p>
<p>        isolation.Strategy = ProjectionTenantStrategy.TenantSpecific;</p>
<p>        isolation.AllowCrossTenantQueries = false;</p>
<p>    });</p>
<p>});</p>

<p>public class OrderSummaryProjection : IProjectionHandler<OrderPlaced> {</p>
<p>    public async Task Handle(OrderPlaced @event, ProjectionContext context) {</p>
<p>        var tenantId = context.TenantId; // Automatically extracted</p>
<p>        </p>
<p>        var summary = new OrderSummary {</p>
<p>            OrderId = @event.OrderId,</p>
<p>            TenantId = tenantId,</p>
<p>            Total = @event.Total</p>
<p>        };</p>
<p>        </p>
<p>        // Stored with tenant isolation</p>
<p>        await context.Store(@event.OrderId.ToString(), summary);</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Cross-Tenant Projections</h3>

<strong>Global projections that aggregate across tenants</strong>:

<p></code></pre>csharp{</p>
<p>title: "Cross-Tenant Analytics Projection",</p>
<p>description: "Cross-tenant projection for global analytics and reporting across all tenants",</p>
<p>category: "Design",</p>
<p>difficulty: "ADVANCED",</p>
<p>tags: ["Multi-Tenancy", "Projections", "Cross-Tenant", "Analytics", "Global-Data"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>services.AddProjection<GlobalAnalyticsProjection>(options => {</p>
<p>    options.TenantIsolation(isolation => {</p>
<p>        isolation.Strategy = ProjectionTenantStrategy.CrossTenant;</p>
<p>        isolation.RequireExplicitTenantAccess = true;</p>
<p>    });</p>
<p>});</p>

<p>public class GlobalAnalyticsProjection : IProjectionHandler<OrderPlaced> {</p>
<p>    public async Task Handle(OrderPlaced @event, ProjectionContext context) {</p>
<p>        // Access to all tenant data for analytics</p>
<p>        var analytics = await context.LoadGlobal<GlobalAnalytics>("summary");</p>
<p>        </p>
<p>        analytics ??= new GlobalAnalytics();</p>
<p>        analytics.TotalOrders++;</p>
<p>        analytics.TotalRevenue += @event.Total;</p>
<p>        analytics.OrdersByTenant[context.TenantId] = </p>
<p>            analytics.OrdersByTenant.GetValueOrDefault(context.TenantId) + 1;</p>
<p>        </p>
<p>        await context.StoreGlobal("summary", analytics);</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Driver Support for Multi-Tenancy</h2>

<h3>PostgreSQL Driver</h3>

<p></code></pre>csharp{</p>
<p>title: "PostgreSQL Tenant-Aware Driver",</p>
<p>description: "PostgreSQL driver implementation with tenant isolation support for event storage",</p>
<p>category: "Design",</p>
<p>difficulty: "ADVANCED",</p>
<p>tags: ["Multi-Tenancy", "Drivers", "PostgreSQL", "Event-Store", "Data-Access"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>public class PostgresTenantDriver : IEventStoreDriver {</p>
<p>    public async Task<IEnumerable<Event>> ReadEvents(string streamId, string? tenantId = null) {</p>
<p>        var sql = tenantId != null </p>
<p>            ? "SELECT * FROM events WHERE stream_id = @streamId AND tenant_id = @tenantId ORDER BY stream_version"</p>
<p>            : "SELECT * FROM events WHERE stream_id = @streamId ORDER BY stream_version";</p>
<p>            </p>
<p>        return await _connection.QueryAsync<Event>(sql, new { streamId, tenantId });</p>
<p>    }</p>
<p>    </p>
<p>    public async Task AppendEvents(string streamId, IEnumerable<Event> events, string? tenantId = null) {</p>
<p>        if (tenantId == null) {</p>
<p>            throw new InvalidOperationException("Tenant ID required for event storage");</p>
<p>        }</p>
<p>        </p>
<p>        foreach (var @event in events) {</p>
<p>            @event.TenantId = tenantId;</p>
<p>        }</p>
<p>        </p>
<p>        await _connection.ExecuteAsync(</p>
<p>            "INSERT INTO events (stream_id, stream_version, event_type, event_data, tenant_id, created_at) " +</p>
<p>            "VALUES (@StreamId, @StreamVersion, @EventType, @EventData, @TenantId, @CreatedAt)",</p>
<p>            events</p>
<p>        );</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Abstract Driver Interface</h3>

<p></code></pre>csharp{</p>
<p>title: "Tenant-Aware Driver Interface",</p>
<p>description: "Abstract driver interface for tenant-aware data operations with cross-tenant support",</p>
<p>category: "Design",</p>
<p>difficulty: "INTERMEDIATE",</p>
<p>tags: ["Multi-Tenancy", "Drivers", "Interfaces", "Architecture", "Data-Access"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>public interface ITenantAwareDriver {</p>
<p>    Task<T> Load<T>(string id, string? tenantId = null);</p>
<p>    Task Save<T>(T entity, string? tenantId = null);</p>
<p>    Task<IEnumerable<T>> Query<T>(Expression<Func<T, bool>> predicate, string? tenantId = null);</p>
<p>    </p>
<p>    // Cross-tenant operations (require special permissions)</p>
<p>    Task<IEnumerable<T>> QueryAllTenants<T>(Expression<Func<T, bool>> predicate);</p>
<p>    Task<Dictionary<string, IEnumerable<T>>> QueryByTenant<T>(Expression<Func<T, bool>> predicate);</p>
<p>}</p>
<pre><code class="language-">
<h2>Security and Authorization</h2>

<h3>Tenant-Based Authorization</h3>

<p></code></pre>csharp{</p>
<p>title: "Tenant-Based Authorization",</p>
<p>description: "Tenant-based authorization configuration with isolation enforcement and policies",</p>
<p>category: "Design",</p>
<p>difficulty: "INTERMEDIATE",</p>
<p>tags: ["Multi-Tenancy", "Security", "Authorization", "ASP.NET-Core", "Policies"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.Authorization(auth => {</p>
<p>        auth.RequireTenantContext = true;</p>
<p>        auth.EnforceTenantIsolation = true;</p>
<p>        </p>
<p>        auth.AddPolicy("TenantAdmin", policy => {</p>
<p>            policy.RequireClaim("tenant_id");</p>
<p>            policy.RequireClaim("role", "admin");</p>
<p>        });</p>
<p>        </p>
<p>        auth.AddPolicy("CrossTenantRead", policy => {</p>
<p>            policy.RequireClaim("permission", "cross_tenant_read");</p>
<p>        });</p>
<p>    });</p>
<p>});</p>

<p>[Authorize("TenantAdmin")]</p>
<p>public class OrderController : ControllerBase {</p>
<p>    [HttpGet]</p>
<p>    public async Task<IActionResult> GetOrders() {</p>
<p>        // Automatically filtered by tenant context</p>
<p>        var orders = await _orderQuery.GetOrdersForCurrentTenant();</p>
<p>        return Ok(orders);</p>
<p>    }</p>
<p>    </p>
<p>    [HttpGet("all-tenants")]</p>
<p>    [Authorize("CrossTenantRead")]</p>
<p>    public async Task<IActionResult> GetOrdersAllTenants() {</p>
<p>        // Requires special permission</p>
<p>        var orders = await _orderQuery.GetOrdersAllTenants();</p>
<p>        return Ok(orders);</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Row-Level Security Integration</h3>

<p></code></pre>csharp{</p>
<p>title: "Row-Level Security Configuration",</p>
<p>description: "PostgreSQL row-level security integration for automatic tenant isolation",</p>
<p>category: "Design",</p>
<p>difficulty: "ADVANCED",</p>
<p>tags: ["Multi-Tenancy", "PostgreSQL", "Row-Level-Security", "Configuration"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.UsePostgres(connectionString, postgres => {</p>
<p>        postgres.EnableRowLevelSecurity = true;</p>
<p>        postgres.TenantContextVariable = "app.current_tenant_id";</p>
<p>    });</p>
<p>});</p>

<p></code>`<code>csharp{</p>
<p>title: "Tenant-Aware Connection Factory",</p>
<p>description: "Database connection factory with automatic tenant context setting for RLS",</p>
<p>category: "Design",</p>
<p>difficulty: "ADVANCED",</p>
<p>tags: ["Multi-Tenancy", "PostgreSQL", "Connection-Factory", "Context-Propagation"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>// Automatically sets tenant context for all database operations</p>
<p>public class PostgresTenantConnectionFactory : IDbConnectionFactory {</p>
<p>    public async Task<IDbConnection> CreateConnection() {</p>
<p>        var connection = new NpgsqlConnection(_connectionString);</p>
<p>        await connection.OpenAsync();</p>
<p>        </p>
<p>        var tenantId = _tenantContext.CurrentTenantId;</p>
<p>        if (tenantId != null) {</p>
<p>            await connection.ExecuteAsync(</p>
<p>                "SET app.current_tenant_id = @tenantId", </p>
<p>                new { tenantId }</p>
<p>            );</p>
<p>        }</p>
<p>        </p>
<p>        return connection;</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Configuration Examples</h2>

<h3>Comprehensive Multi-Tenancy Setup</h3>

<p></code></pre>csharp{</p>
<p>title: "Comprehensive Multi-Tenancy Setup",</p>
<p>description: "Complete multi-tenancy configuration with all options and strategies",</p>
<p>category: "Design",</p>
<p>difficulty: "ADVANCED",</p>
<p>tags: ["Multi-Tenancy", "Configuration", "Comprehensive-Setup", "Production-Ready"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.MultiTenancy(tenancy => {</p>
<p>        // Tenant identification</p>
<p>        tenancy.TenantIdField = "TenantId";</p>
<p>        tenancy.TenantIdType = typeof(Guid);</p>
<p>        </p>
<p>        // Storage strategy</p>
<p>        tenancy.Strategy = TenancyStrategy.SingleDatabaseWithIsolation;</p>
<p>        tenancy.EnableRowLevelSecurity = true;</p>
<p>        </p>
<p>        // Tenant context</p>
<p>        tenancy.TenantResolver = (httpContext) => {</p>
<p>            return httpContext.Request.Headers["X-Tenant-ID"].FirstOrDefault();</p>
<p>        };</p>
<p>        </p>
<p>        // Cross-tenant operations</p>
<p>        tenancy.AllowCrossTenantOperations = false;</p>
<p>        tenancy.RequireExplicitCrossTenantPermission = true;</p>
<p>        </p>
<p>        // Database partitioning</p>
<p>        tenancy.UsePartitioning = true;</p>
<p>        tenancy.PartitionCount = 16;</p>
<p>        </p>
<p>        // Tenant lifecycle</p>
<p>        tenancy.AutoCreateTenantData = true;</p>
<p>        tenancy.TenantDataTemplate = "default_tenant_template";</p>
<p>    });</p>
<p>    </p>
<p>    // Tenant-aware projections</p>
<p>    options.Projections(projections => {</p>
<p>        projections.DefaultTenantStrategy = ProjectionTenantStrategy.TenantSpecific;</p>
<p>        projections.AllowGlobalProjections = true;</p>
<p>        projections.RequireExplicitCrossTenantAccess = true;</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h3>Tenant Onboarding Workflow</h3>

<p></code></pre>csharp{</p>
<p>title: "Tenant Onboarding Service",</p>
<p>description: "Tenant onboarding workflow with resource provisioning and initialization",</p>
<p>category: "Design",</p>
<p>difficulty: "INTERMEDIATE",</p>
<p>tags: ["Multi-Tenancy", "Onboarding", "Tenant-Lifecycle", "Resource-Provisioning"],</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>public class TenantOnboardingService {</p>
<p>    public async Task OnboardTenant(string tenantId, TenantConfiguration config) {</p>
<p>        // Create tenant-specific database resources</p>
<p>        await _tenantManager.CreateTenantResources(tenantId);</p>
<p>        </p>
<p>        // Initialize tenant data</p>
<p>        await _tenantManager.InitializeTenantData(tenantId, config);</p>
<p>        </p>
<p>        // Set up tenant-specific projections</p>
<p>        await _projectionManager.CreateTenantProjections(tenantId);</p>
<p>        </p>
<p>        // Emit tenant onboarded event</p>
<p>        await _eventPublisher.PublishAsync(new TenantOnboarded(</p>
<p>            tenantId,</p>
<p>            config,</p>
<p>            DateTimeOffset.UtcNow</p>
<p>        ));</p>
<p>    }</p>
<p>}</p>
<p></code>``</p>

<h2>Best Practices</h2>

<h3>Tenant Design Guidelines</h3>

<ul><li><strong>Design for isolation</strong> - Assume tenants can't see each other's data</li>
<li><strong>Validate tenant context</strong> - Always check tenant context in handlers</li>
<li><strong>Use consistent tenant IDs</strong> - Keep tenant identification simple</li>
<li><strong>Plan for scale</strong> - Design partitioning strategy from the start</li>
<li><strong>Test cross-tenant security</strong> - Verify isolation works correctly</li>
</ul>
<h3>Performance Considerations</h3>

<ul><li><strong>Partition by tenant</strong> - Use database partitioning for large tables</li>
<li><strong>Index tenant columns</strong> - Include tenant_id in all indexes</li>
<li><strong>Connection pooling</strong> - Consider tenant-specific connection pools</li>
<li><strong>Cache tenant data</strong> - Cache tenant configuration and permissions</li>
<li><strong>Monitor per-tenant usage</strong> - Track resource usage by tenant</li>
</ul>
<h3>Security Best Practices</h3>

<ul><li><strong>Defense in depth</strong> - Use multiple layers of tenant isolation</li>
<li><strong>Principle of least privilege</strong> - Only grant necessary cross-tenant permissions</li>
<li><strong>Audit tenant access</strong> - Log all cross-tenant operations</li>
<li><strong>Validate tenant ownership</strong> - Check tenant context in all operations</li>
<li><strong>Regular security reviews</strong> - Audit tenant isolation regularly</li>
</ul>
<hr>

<h2>Related Documentation</h2>

<ul><li><a href="./event-store-projections.md"><strong>Event Store & Projections</strong></a> - Storage architecture with tenant isolation</li>
<li><a href="./domain-ownership.md"><strong>Domain Ownership</strong></a> - How domain ownership works with tenants</li>
<li><a href="./performance-optimization.md"><strong>Performance Optimization</strong></a> - Scaling multi-tenant systems</li></ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="proposals-observability-metrics" class="doc-section">
  <h2>Observability &amp; Metrics</h2>
  <p class="doc-path"><code>proposals/observability-metrics</code></p>
  <div class="doc-content">

<h1>Observability & Metrics</h1>

<p>Whizbang provides comprehensive observability with policy-driven metrics collection, OpenTelemetry integration, and custom field attributes for rich monitoring and debugging capabilities.</p>

<h2>Metrics Architecture</h2>

<h3>Default Metrics (Always Enabled)</h3>

<strong>Core performance and health metrics</strong> essential for operation:

<pre><code class="language-csharp">---
<p>category: Design</p>
<p>difficulty: INTERMEDIATE</p>
<p>tags: [Design, Observability, Metrics, Default-Metrics]</p>
<p>description: Core performance and health metrics essential for operation</p>
<hr>
<p>// Command metrics</p>
<p>whizbang_command_duration_seconds{command_type, domain, handler_type, status}</p>
<p>whizbang_command_total{command_type, domain, status}</p>

<p>// Event metrics  </p>
<p>whizbang_event_published_total{event_type, domain, source_handler}</p>
<p>whizbang_event_processing_duration_seconds{event_type, handler_type, status}</p>

<p>// Projection metrics</p>
<p>whizbang_projection_lag_seconds{projection_name, partition}</p>
<p>whizbang_projection_events_processed_total{projection_name, event_type}</p>
<p>whizbang_projection_errors_total{projection_name, error_type}</p>

<p>// Infrastructure metrics</p>
<p>whizbang_event_store_append_duration_seconds{driver_type, operation}</p>
<p>whizbang_message_broker_publish_duration_seconds{broker_type, topic}</p>
<p>whizbang_message_broker_consume_duration_seconds{broker_type, topic}</p>

<p>// System health</p>
<p>whizbang_active_handlers_total{handler_type}</p>
<p>whizbang_memory_usage_bytes{component}</p>
<p>whizbang_cpu_usage_percent{component}</p>
<p></code></pre></p>

<h3>Observability Levels</h3>

<strong>Configurable detail levels</strong> for different scenarios:

<pre><code class="language-csharp">---
<p>category: Design</p>
<p>difficulty: INTERMEDIATE</p>
<p>tags: [Design, Observability, Configuration, Observability-Levels]</p>
<p>description: Configurable observability levels for different scenarios</p>
<hr>
<p>public enum ObservabilityLevel {</p>
<p>    Minimal,    // Only essential metrics + errors</p>
<p>    Standard,   // Default metrics + basic timing</p>
<p>    Detailed,   // Additional context + custom fields  </p>
<p>    Verbose,    // Everything + debug information</p>
<p>    Debug       // Maximum detail for troubleshooting</p>
<p>}</p>

<p>services.AddWhizbang(options => {</p>
<p>    options.Policies(policies => {</p>
<p>        // Default observability configuration</p>
<p>        policies.When(ctx => true) // Matches all contexts</p>
<p>                .Then(config => config.SetObservabilityLevel(ObservabilityLevel.Standard))</p>
<p>                .And(config => config.EnableCustomFields());</p>
<p>        </p>
<p>        // Environment-specific policies</p>
<p>        policies.When(ctx => ctx.IsEnvironment("production"))</p>
<p>                .Then(config => config.SetObservabilityLevel(ObservabilityLevel.Standard))</p>
<p>                .And(config => config.SetSampleRate(0.1)); // 10% sampling in production</p>
<p>        </p>
<p>        policies.When(ctx => ctx.IsEnvironment("development"))</p>
<p>                .Then(config => config.SetObservabilityLevel(ObservabilityLevel.Verbose))</p>
<p>                .And(config => config.SetSampleRate(1.0)); // Full sampling in development</p>
<p>    });</p>
<p>});</p>
<p></code></pre></p>

<h2>Policy-Driven Observability</h2>

<h3>Context-Aware Metrics Collection</h3>

<strong>Dynamic observability</strong> based on message context and policies:

<pre><code class="language-csharp">---
<p>category: Design</p>
<p>difficulty: ADVANCED</p>
<p>tags: [Design, Observability, Context-Aware-Metrics, Dynamic-Configuration]</p>
<p>description: Dynamic observability configuration based on message context and policies</p>
<hr>
<p>services.AddWhizbang(options => {</p>
<p>    options.Observability(obs => {</p>
<p>        obs.Policies(policies => {</p>
<p>            // Verbose logging for critical customer journeys</p>
<p>            policies.When(ctx => ctx.HasTag("customer-vip"))</p>
<p>                    .Then(action => action.SetObservabilityLevel(ObservabilityLevel.Verbose))</p>
<p>                    .And(action => action.CaptureCustomFields())</p>
<p>                    .And(action => action.EnableDistributedTracing());</p>
<p>            </p>
<p>            // Detailed metrics for flagged debugging sessions</p>
<p>            policies.When(ctx => ctx.HasFlag(WhizbangFlags.VerboseOtel))</p>
<p>                    .Then(action => action.SetObservabilityLevel(ObservabilityLevel.Debug))</p>
<p>                    .And(action => action.CaptureMethodParameters())</p>
<p>                    .And(action => action.CaptureReturnValues());</p>
<p>                    </p>
<p>            // Minimal overhead for load testing</p>
<p>            policies.When(ctx => ctx.HasFlag(WhizbangFlags.LoadTesting))</p>
<p>                    .Then(action => action.SetObservabilityLevel(ObservabilityLevel.Minimal))</p>
<p>                    .And(action => action.DisableSlowMetrics());</p>
<p>                    </p>
<p>            // Enhanced monitoring for production critical paths</p>
<p>            policies.When(ctx => ctx.HasTag("critical-path") && ctx.HasFlag(WhizbangFlags.Production))</p>
<p>                    .Then(action => action.SetObservabilityLevel(ObservabilityLevel.Detailed))</p>
<p>                    .And(action => action.EnablePerformanceBudgetTracking())</p>
<p>                    .And(action => action.AlertOnAnomalies());</p>
<p>        });</p>
<p>    });</p>
<p>});</p>
<p></code></pre></p>

<h3>Adaptive Sampling</h3>

<strong>Smart sampling</strong> based on context and system load:

<pre><code class="language-csharp">---
<p>category: Design</p>
<p>difficulty: ADVANCED</p>
<p>tags: [Design, Observability, Adaptive-Sampling, System-Load]</p>
<p>description: Smart sampling based on context and system load for performance optimization</p>
<hr>
<p>public class AdaptiveObservabilityPolicy : IObservabilityPolicy {</p>
<p>    public async Task<ObservabilityConfig> GetConfigAsync(MessageContext context) {</p>
<p>        var config = new ObservabilityConfig();</p>
<p>        </p>
<p>        // Always capture errors</p>
<p>        if (context.HasError) {</p>
<p>            config.Level = ObservabilityLevel.Verbose;</p>
<p>            config.SampleRate = 1.0;</p>
<p>            return config;</p>
<p>        }</p>
<p>        </p>
<p>        // Adaptive sampling based on system load</p>
<p>        var systemLoad = await _systemMetrics.GetCurrentLoadAsync();</p>
<p>        if (systemLoad > 0.8) {</p>
<p>            config.SampleRate = 0.01; // 1% when system is under stress</p>
<p>        } else if (systemLoad > 0.5) {</p>
<p>            config.SampleRate = 0.1;  // 10% when system is busy</p>
<p>        } else {</p>
<p>            config.SampleRate = 0.5;  // 50% when system is idle</p>
<p>        }</p>
<p>        </p>
<p>        // VIP customers always get full tracking</p>
<p>        if (context.HasTag("customer-vip")) {</p>
<p>            config.SampleRate = 1.0;</p>
<p>            config.Level = ObservabilityLevel.Detailed;</p>
<p>        }</p>
<p>        </p>
<p>        return config;</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>Custom Field Attributes</h2>

<h3>Source Generation for Rich Metrics</h3>

<strong>Automatically include relevant fields</strong> in metrics via attributes:

<pre><code class="language-csharp">---
<p>category: Design</p>
<p>difficulty: INTERMEDIATE</p>
<p>tags: [Design, Observability, Custom-Fields, Source-Generation]</p>
<p>description: Automatically include relevant fields in metrics via attributes</p>
<hr>
<p>// Command with observability annotations</p>
<p>public record PlaceOrder(</p>
<p>    Guid OrderId,</p>
<p>    </p>
<p>    [ObservabilityField(MetricType.Label)] </p>
<p>    Guid CustomerId,    // Include as metric label</p>
<p>    </p>
<p>    [ObservabilityField(MetricType.Measure)] </p>
<p>    decimal Total,      // Include as measured value</p>
<p>    </p>
<p>    [ObservabilityField(MetricType.Label, Transform = "Range")] </p>
<p>    decimal Total2,     // Transform to range (0-100, 100-500, etc.)</p>
<p>    </p>
<p>    [ObservabilityField(MetricType.Context)]</p>
<p>    string Region,      // Include in trace context only</p>
<p>    </p>
<p>    List<OrderItem> Items, // Not annotated - not included</p>
<p>    </p>
<p>    [SensitiveData]</p>
<p>    string PaymentToken // Marked sensitive - never included</p>
<p>);</p>

<p>// Generated metrics include custom fields</p>
<p>// whizbang_command_total{command_type="PlaceOrder", customer_id="123", total_range="100-500", region="us-west"}</p>
<p>// whizbang_command_duration_seconds{command_type="PlaceOrder", customer_id="123", total_range="100-500"}</p>
<p></code></pre></p>

<h3>Field Transformation Options</h3>

<strong>Smart field transformations</strong> for better cardinality management:

<pre><code class="language-csharp">---
<p>category: Design</p>
<p>difficulty: INTERMEDIATE</p>
<p>tags: [Design, Observability, Field-Transformations, Cardinality-Management]</p>
<p>description: Smart field transformations for better metric cardinality management</p>
<hr>
<p>public enum FieldTransform {</p>
<p>    None,           // Use raw value</p>
<p>    Range,          // Convert numbers to ranges (0-100, 100-500, etc.)</p>
<p>    Hash,           // Hash sensitive identifiers</p>
<p>    Truncate,       // Truncate long strings</p>
<p>    Sanitize,       // Remove sensitive parts</p>
<p>    Category        // Map to predefined categories</p>
<p>}</p>

<p>[ObservabilityField(MetricType.Label, Transform = FieldTransform.Range, Ranges = "0,100,500,1000,5000")]</p>
<p>public decimal Total { get; set; }</p>

<p>[ObservabilityField(MetricType.Label, Transform = FieldTransform.Hash)]</p>
<p>public string CustomerId { get; set; } // Becomes hash for privacy</p>

<p>[ObservabilityField(MetricType.Label, Transform = FieldTransform.Category, </p>
<p>    Categories = "standard,premium,enterprise")]</p>
<p>public string CustomerTier { get; set; }</p>
<p></code></pre></p>

<h3>Generated Metric Collection</h3>

<strong>Source generator creates metric collection code</strong>:

<pre><code class="language-csharp">---
<p>category: Design</p>
<p>difficulty: ADVANCED</p>
<p>tags: [Design, Observability, Source-Generation, Metrics-Collection]</p>
<p>description: Source generator creates metric collection code for annotated types</p>
<hr>
<p>// Generated metric collection for PlaceOrder</p>
<p>[GeneratedCode("Whizbang.SourceGenerator")]</p>
<p>public partial class PlaceOrderMetricsCollector {</p>
<p>    public static void RecordCommandExecution(PlaceOrder command, CommandResult result, TimeSpan duration) {</p>
<p>        var labels = new Dictionary<string, object> {</p>
<p>            ["command_type"] = "PlaceOrder",</p>
<p>            ["customer_id"] = command.CustomerId.ToString(),</p>
<p>            ["total_range"] = TransformToRange(command.Total, new[] { 0, 100, 500, 1000, 5000 }),</p>
<p>            ["region"] = command.Region,</p>
<p>            ["status"] = result.Success ? "success" : "failure"</p>
<p>        };</p>
<p>        </p>
<p>        _commandDurationHistogram.Record(duration.TotalSeconds, labels);</p>
<p>        _commandTotalCounter.Add(1, labels);</p>
<p>        </p>
<p>        if (!result.Success) {</p>
<p>            _commandErrorsCounter.Add(1, labels.Concat(new[] {</p>
<p>                new KeyValuePair<string, object>("error_type", result.ErrorType)</p>
<p>            }));</p>
<p>        }</p>
<p>    }</p>
<p>    </p>
<p>    private static string TransformToRange(decimal value, decimal[] ranges) {</p>
<p>        for (int i = 0; i < ranges.Length - 1; i++) {</p>
<p>            if (value >= ranges[i] && value < ranges[i + 1]) {</p>
<p>                return $"{ranges[i]}-{ranges[i + 1]}";</p>
<p>            }</p>
<p>        }</p>
<p>        return $"{ranges[^1]}+";</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>OpenTelemetry Integration</h2>

<h3>Comprehensive Instrumentation</h3>

<strong>Full OpenTelemetry implementation</strong> with Whizbang-specific semantics:

<pre><code class="language-csharp">---
<p>category: Design</p>
<p>difficulty: INTERMEDIATE</p>
<p>tags: [Design, Observability, OpenTelemetry, Comprehensive-Instrumentation]</p>
<p>description: Full OpenTelemetry implementation with Whizbang-specific semantics</p>
<hr>
<p>services.AddWhizbang(options => {</p>
<p>    options.UseOpenTelemetry(otel => {</p>
<p>        otel.ConfigureTracing(tracing => {</p>
<p>            tracing.AddWhizbangInstrumentation()</p>
<p>                   .AddAspNetCoreInstrumentation()</p>
<p>                   .AddHttpClientInstrumentation()</p>
<p>                   .AddEntityFrameworkCoreInstrumentation();</p>
<p>                   </p>
<p>            // Whizbang-specific trace attributes</p>
<p>            tracing.SetSampler(new WhizbangAdaptiveSampler());</p>
<p>            tracing.AddProcessor<WhizbangSpanProcessor>();</p>
<p>        });</p>
<p>        </p>
<p>        otel.ConfigureMetrics(metrics => {</p>
<p>            metrics.AddWhizbangInstrumentation()</p>
<p>                   .AddRuntimeInstrumentation()</p>
<p>                   .AddAspNetCoreInstrumentation();</p>
<p>                   </p>
<p>            // Custom metric providers</p>
<p>            metrics.AddMeter("Whizbang.Commands");</p>
<p>            metrics.AddMeter("Whizbang.Events");</p>
<p>            metrics.AddMeter("Whizbang.Projections");</p>
<p>        });</p>
<p>        </p>
<p>        otel.ConfigureLogs(logs => {</p>
<p>            logs.AddWhizbangInstrumentation()</p>
<p>                .AddConsoleExporter()</p>
<p>                .AddOpenTelemetryProtocolExporter();</p>
<p>        });</p>
<p>    });</p>
<p>});</p>
<p></code></pre></p>

<h3>Semantic Conventions</h3>

<strong>Whizbang-specific OpenTelemetry semantic conventions</strong>:

<pre><code class="language-csharp">---
<p>category: Design</p>
<p>difficulty: INTERMEDIATE</p>
<p>tags: [Design, Observability, OpenTelemetry, Semantic-Conventions]</p>
<p>description: Whizbang-specific OpenTelemetry semantic conventions for consistency</p>
<hr>
<p>public static class WhizbangSemanticConventions {</p>
<p>    // Span attributes</p>
<p>    public const string CommandType = "whizbang.command.type";</p>
<p>    public const string EventType = "whizbang.event.type";</p>
<p>    public const string ProjectionName = "whizbang.projection.name";</p>
<p>    public const string Domain = "whizbang.domain";</p>
<p>    public const string StreamId = "whizbang.stream.id";</p>
<p>    public const string StreamVersion = "whizbang.stream.version";</p>
<p>    public const string CorrelationId = "whizbang.correlation.id";</p>
<p>    public const string TenantId = "whizbang.tenant.id";</p>
<p>    </p>
<p>    // Metric attributes</p>
<p>    public const string HandlerType = "whizbang.handler.type";</p>
<p>    public const string DriverType = "whizbang.driver.type";</p>
<p>    public const string PolicyName = "whizbang.policy.name";</p>
<p>    public const string FlagValue = "whizbang.flags";</p>
<p>    </p>
<p>    // Resource attributes</p>
<p>    public const string ServiceDomain = "whizbang.service.domain";</p>
<p>    public const string ServiceVersion = "whizbang.service.version";</p>
<p>    public const string LibraryVersion = "whizbang.library.version";</p>
<p>}</p>

<p></code></pre>csharp</p>
<hr>
<p>category: Design</p>
<p>difficulty: INTERMEDIATE</p>
<p>tags: [Design, Observability, OpenTelemetry, Command-Instrumentation]</p>
<p>description: Command instrumentation with automatic attribute and custom field capture</p>
<hr>
<p>// Usage in instrumentation</p>
<p>public class WhizbangCommandInstrumentation : IDisposable {</p>
<p>    public Activity? StartCommandActivity<T>(T command, MessageContext context) where T : ICommand {</p>
<p>        var activity = Activity.StartActivity($"Command {typeof(T).Name}");</p>
<p>        </p>
<p>        activity?.SetTag(WhizbangSemanticConventions.CommandType, typeof(T).Name);</p>
<p>        activity?.SetTag(WhizbangSemanticConventions.Domain, context.Domain);</p>
<p>        activity?.SetTag(WhizbangSemanticConventions.CorrelationId, context.CorrelationId);</p>
<p>        </p>
<p>        if (context.TenantId != null) {</p>
<p>            activity?.SetTag(WhizbangSemanticConventions.TenantId, context.TenantId);</p>
<p>        }</p>
<p>        </p>
<p>        // Add custom fields from annotations</p>
<p>        AddCustomFields(activity, command);</p>
<p>        </p>
<p>        return activity;</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Performance Budget Integration</h2>

<h3>Budget-Aware Observability</h3>

<strong>Automatic performance budget tracking</strong> with alerts:

<p></code></pre>csharp</p>
<hr>
<p>category: Design</p>
<p>difficulty: ADVANCED</p>
<p>tags: [Design, Observability, Performance-Budgets, Automatic-Tracking]</p>
<p>description: Automatic performance budget tracking with alerts and dynamic observability</p>
<hr>
<p>services.AddWhizbang(options => {</p>
<p>    options.Policies(policies => {</p>
<p>        // Performance budgets for specific handlers</p>
<p>        policies.When(ctx => ctx.MatchesHandler<PlaceOrderHandler>())</p>
<p>                .Then(config => config.SetPerformanceBudget(new PerformanceBudget {</p>
<p>                    MaxLatency = TimeSpan.FromMilliseconds(100),</p>
<p>                    MaxMemoryMB = 10,</p>
<p>                    MaxCpuMs = 50</p>
<p>                }))</p>
<p>                .And(config => config.OnBudgetViolation(async (violation) => {</p>
<p>                    // Increase observability for budget violations</p>
<p>                    await _observabilityService.IncreaseDetailLevel(</p>
<p>                        violation.HandlerType, </p>
<p>                        ObservabilityLevel.Debug,</p>
<p>                        duration: TimeSpan.FromMinutes(10)</p>
<p>                    );</p>
<p>                    </p>
<p>                    // Alert on violations</p>
<p>                    await _alerting.SendBudgetViolationAlert(violation);</p>
<p>                }));</p>
<p>        </p>
<p>        // Default budget tracking settings</p>
<p>        policies.When(ctx => true) // Matches all contexts</p>
<p>                .Then(config => config.EnableBudgetTracking())</p>
<p>                .And(config => config.SetBudgetViolationSampleRate(1.0)); // Always capture violations</p>
<p>    });</p>
<p>});</p>

<p>// Generated budget tracking metrics</p>
<p>whizbang_performance_budget_violation_total{handler_type, budget_type, severity}</p>
<p>whizbang_performance_budget_utilization_ratio{handler_type, budget_type}</p>
<p>whizbang_performance_budget_headroom_seconds{handler_type}</p>
<pre><code class="language-">
<h2>Distributed Tracing</h2>

<h3>W3C Trace Context Propagation</h3>

<strong>Standards-compliant distributed tracing</strong>:

<p></code></pre>csharp</p>
<hr>
<p>category: Design</p>
<p>difficulty: ADVANCED</p>
<p>tags: [Design, Observability, W3C-Trace-Context, Distributed-Tracing]</p>
<p>description: Standards-compliant W3C trace context propagation implementation</p>
<hr>
<p>public class WhizbangTraceContextPropagator : IMessageInterceptor {</p>
<p>    public async Task<TResponse> Intercept<TRequest, TResponse>(</p>
<p>        TRequest message,</p>
<p>        MessageContext context,</p>
<p>        MessageHandlerDelegate<TRequest, TResponse> next) {</p>
<p>        </p>
<p>        // Extract W3C trace context from message headers</p>
<p>        var traceParent = context.Headers.GetValueOrDefault("traceparent");</p>
<p>        var traceState = context.Headers.GetValueOrDefault("tracestate");</p>
<p>        </p>
<p>        Activity? activity = null;</p>
<p>        </p>
<p>        if (traceParent != null) {</p>
<p>            // Continue existing trace</p>
<p>            var traceContext = W3CTraceContext.Parse(traceParent, traceState);</p>
<p>            activity = Activity.StartActivity($"Handle {typeof(TRequest).Name}");</p>
<p>            activity?.SetParentId(traceContext.TraceId, traceContext.SpanId);</p>
<p>        } else {</p>
<p>            // Start new trace</p>
<p>            activity = Activity.StartActivity($"Handle {typeof(TRequest).Name}");</p>
<p>        }</p>
<p>        </p>
<p>        // Add Whizbang-specific context</p>
<p>        activity?.SetTag(WhizbangSemanticConventions.CommandType, typeof(TRequest).Name);</p>
<p>        activity?.SetTag(WhizbangSemanticConventions.CorrelationId, context.CorrelationId);</p>
<p>        activity?.SetTag(WhizbangSemanticConventions.Domain, context.Domain);</p>
<p>        </p>
<p>        // Enhance trace state with Whizbang context</p>
<p>        var enhancedTraceState = EnhanceTraceState(traceState, context);</p>
<p>        activity?.SetTag("tracestate", enhancedTraceState);</p>
<p>        </p>
<p>        try {</p>
<p>            var response = await next(message, context);</p>
<p>            activity?.SetTag("status", "success");</p>
<p>            return response;</p>
<p>        } catch (Exception ex) {</p>
<p>            activity?.SetTag("status", "error");</p>
<p>            activity?.SetTag("error.type", ex.GetType().Name);</p>
<p>            activity?.SetTag("error.message", ex.Message);</p>
<p>            throw;</p>
<p>        } finally {</p>
<p>            activity?.Dispose();</p>
<p>        }</p>
<p>    }</p>
<p>    </p>
<p>    private string EnhanceTraceState(string? existingTraceState, MessageContext context) {</p>
<p>        var whizbangState = new List<string>();</p>
<p>        </p>
<p>        if (context.CorrelationId != null) {</p>
<p>            whizbangState.Add($"correlation-id:{context.CorrelationId}");</p>
<p>        }</p>
<p>        </p>
<p>        if (context.Domain != null) {</p>
<p>            whizbangState.Add($"domain:{context.Domain}");</p>
<p>        }</p>
<p>        </p>
<p>        if (context.Flags != WhizbangFlags.None) {</p>
<p>            whizbangState.Add($"flags:{(long)context.Flags}");</p>
<p>        }</p>
<p>        </p>
<p>        var newTraceState = $"whizbang={string.Join(",", whizbangState)}";</p>
<p>        </p>
<p>        return string.IsNullOrEmpty(existingTraceState) </p>
<p>            ? newTraceState </p>
<p>            : $"{existingTraceState},{newTraceState}";</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Monitoring Dashboards</h2>

<h3>Pre-built Dashboard Configurations</h3>

<strong>Ready-to-use monitoring dashboards</strong> for popular platforms:

<p></code></pre>json</p>
<hr>
<p>category: Design</p>
<p>difficulty: INTERMEDIATE</p>
<p>tags: [Design, Observability, Grafana, Dashboard-Configuration]</p>
<p>description: Ready-to-use Grafana dashboard configuration for Whizbang metrics</p>
<hr>
<p>// Grafana dashboard configuration</p>
<p>{</p>
<p>  "dashboard": {</p>
<p>    "title": "Whizbang Application Metrics",</p>
<p>    "panels": [</p>
<p>      {</p>
<p>        "title": "Command Processing Rate",</p>
<p>        "type": "graph",</p>
<p>        "targets": [</p>
<p>          {</p>
<p>            "expr": "rate(whizbang_command_total[5m])",</p>
<p>            "legendFormat": "{{command_type}} ({{domain}})"</p>
<p>          }</p>
<p>        ]</p>
<p>      },</p>
<p>      {</p>
<p>        "title": "Projection Lag",</p>
<p>        "type": "graph",</p>
<p>        "targets": [</p>
<p>          {</p>
<p>            "expr": "whizbang_projection_lag_seconds",</p>
<p>            "legendFormat": "{{projection_name}}"</p>
<p>          }</p>
<p>        ],</p>
<p>        "thresholds": [</p>
<p>          { "value": 300, "color": "yellow" },</p>
<p>          { "value": 600, "color": "red" }</p>
<p>        ]</p>
<p>      },</p>
<p>      {</p>
<p>        "title": "Performance Budget Violations",</p>
<p>        "type": "table",</p>
<p>        "targets": [</p>
<p>          {</p>
<p>            "expr": "increase(whizbang_performance_budget_violation_total[1h])",</p>
<p>            "format": "table"</p>
<p>          }</p>
<p>        ]</p>
<p>      }</p>
<p>    ]</p>
<p>  }</p>
<p>}</p>
<pre><code class="language-">
<h3>Alert Rules</h3>

<strong>Production-ready alerting rules</strong>:

<p></code></pre>yaml</p>
<hr>
<p>category: Design</p>
<p>difficulty: INTERMEDIATE</p>
<p>tags: [Design, Observability, Prometheus, Alerting-Rules]</p>
<p>description: Production-ready Prometheus alerting rules for Whizbang applications</p>
<hr>
<h1>Prometheus alerting rules</h1>
<p>groups:</p>
<p>  - name: whizbang.rules</p>
<p>    rules:</p>
<p>      - alert: ProjectionLagHigh</p>
<p>        expr: whizbang_projection_lag_seconds > 300</p>
<p>        for: 5m</p>
<p>        labels:</p>
<p>          severity: warning</p>
<p>        annotations:</p>
<p>          summary: "Projection {{ $labels.projection_name }} is lagging"</p>
<p>          description: "Projection {{ $labels.projection_name }} has been lagging behind by {{ $value }} seconds for more than 5 minutes"</p>
<p>      </p>
<p>      - alert: CommandErrorRateHigh</p>
<p>        expr: rate(whizbang_command_errors_total[5m]) / rate(whizbang_command_total[5m]) > 0.05</p>
<p>        for: 2m</p>
<p>        labels:</p>
<p>          severity: critical</p>
<p>        annotations:</p>
<p>          summary: "High command error rate for {{ $labels.command_type }}"</p>
<p>          description: "Command {{ $labels.command_type }} error rate is {{ $value | humanizePercentage }}"</p>
<p>          </p>
<p>      - alert: PerformanceBudgetViolation</p>
<p>        expr: increase(whizbang_performance_budget_violation_total[10m]) > 5</p>
<p>        for: 0m</p>
<p>        labels:</p>
<p>          severity: warning</p>
<p>        annotations:</p>
<p>          summary: "Performance budget violations for {{ $labels.handler_type }}"</p>
<p>          description: "Handler {{ $labels.handler_type }} has violated its performance budget {{ $value }} times in the last 10 minutes"</p>
<p>```</p>

<h2>Best Practices</h2>

<h3>Metric Design</h3>

<ul><li><strong>Control cardinality</strong> - Avoid high-cardinality labels</li>
<li><strong>Use transformations</strong> - Convert IDs to ranges or categories</li>
<li><strong>Standardize naming</strong> - Follow OpenTelemetry conventions</li>
<li><strong>Include context</strong> - Domain, tenant, and correlation information</li>
<li><strong>Monitor overhead</strong> - Track observability performance impact</li>
</ul>
<h3>Policy Configuration</h3>

<ul><li><strong>Start conservative</strong> - Begin with standard observability level</li>
<li><strong>Use adaptive sampling</strong> - Reduce overhead under load</li>
<li><strong>Prioritize critical paths</strong> - Enhanced monitoring for important flows</li>
<li><strong>Handle errors specially</strong> - Always capture error scenarios</li>
<li><strong>Regular review</strong> - Adjust policies based on insights</li>
</ul>
<h3>Dashboard Organization</h3>

<ul><li><strong>Layer dashboards</strong> - Overview → Domain → Handler specific</li>
<li><strong>Use SLOs</strong> - Define and track service level objectives</li>
<li><strong>Alert on trends</strong> - Early warning indicators</li>
<li><strong>Include business metrics</strong> - Connect technical to business impact</li>
<li><strong>Regular maintenance</strong> - Keep dashboards current and useful</li>
</ul>
<hr>

<h2>Related Documentation</h2>

<ul><li><a href="./policy-engine.md"><strong>Policy Engine</strong></a> - How policies drive observability</li>
<li><a href="./flags-tags-system.md"><strong>Flags & Tags System</strong></a> - Cross-service context propagation</li>
<li><a href="./testing-development-tools.md"><strong>Testing & Development Tools</strong></a> - Testing observability features</li>
<li><a href="./deployment-operations.md"><strong>Deployment & Operations</strong></a> - Production monitoring setup</li></ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="proposals-open-questions" class="doc-section">
  <h2>Open Design Questions - RESOLVED</h2>
  <p class="doc-path"><code>proposals/open-questions</code></p>
  <div class="doc-content">

<h1>Open Design Questions - RESOLVED ✅</h1>

<strong>Status</strong>: All critical and important design questions have been resolved and documented in detailed specification documents.

<p>This document previously captured open questions and architectural decisions for Whizbang. <strong>All questions have now been resolved</strong> and documented in comprehensive specifications.</p>

<h2>🔴 Critical Decisions - ALL RESOLVED ✅</h2>

<strong>All critical decisions have been resolved and documented</strong>. See the detailed specifications below:

<h3>1. Handler Discovery Mechanism ✅ <strong>RESOLVED</strong></h3>
<strong>Decision</strong>: Hybrid approach (Source Generators + Explicit Registration)
<ul><li><strong>Detailed Specification</strong>: <a href="./domain-ownership.md">Domain Ownership</a></li>
</ul>
<h3>2. Handler Method Signature Conventions ✅ <strong>RESOLVED</strong></h3>
<strong>Decision</strong>: Convention-based with Source Generator support
<ul><li><strong>Detailed Specification</strong>: <a href="./domain-ownership.md">Domain Ownership</a></li>
</ul>
<h3>3. Event Store Schema Design ✅ <strong>RESOLVED</strong></h3>
<strong>Decision</strong>: Hybrid approach (Separate Events and Projections with JSONB)
<ul><li><strong>Detailed Specification</strong>: <a href="./event-store-projections.md">Event Store & Projections</a></li>
</ul>
<h3>4. Optimistic Concurrency Strategy ✅ <strong>RESOLVED</strong></h3>
<strong>Decision</strong>: Support all strategies (Expected Version, Timestamp-Based, Automatic Retry)
<ul><li><strong>Detailed Specification</strong>: <a href="./concurrency-control.md">Concurrency Control</a></li>
</ul>
<h3>5. Domain Ownership Declaration ✅ <strong>RESOLVED</strong></h3>
<strong>Decision</strong>: Configurable precedence order (Namespace → Attributes → Configuration)
<ul><li><strong>Detailed Specification</strong>: <a href="./domain-ownership.md">Domain Ownership</a></li>
</ul>
<hr>

<h2>🟡 Important Decisions - ALL RESOLVED ✅</h2>

<h3>6. Projection Checkpoint Storage ✅ <strong>RESOLVED</strong></h3>
<strong>Decision</strong>: Support both Same Database (default) and Separate Metadata Store
<ul><li><strong>Detailed Specification</strong>: <a href="./projection-management.md">Projection Management</a></li>
</ul>
<h3>7. Snapshot Strategy ✅ <strong>RESOLVED</strong></h3>
<strong>Decision</strong>: Support all strategies (Automatic, Manual, None with Automatic as default)
<ul><li><strong>Detailed Specification</strong>: <a href="./event-store-projections.md">Event Store & Projections</a></li>
</ul>
<h3>8. Projection Backfilling API ✅ <strong>RESOLVED</strong></h3>
<strong>Decision</strong>: Support both Declarative and Imperative with System Events
<ul><li><strong>Detailed Specification</strong>: <a href="./projection-management.md">Projection Management</a></li>
</ul>
<h3>9. Saga State Persistence ✅ <strong>RESOLVED</strong></h3>
<strong>Decision</strong>: Event-Sourced Sagas as primary pattern
<ul><li><strong>Detailed Specification</strong>: <a href="./event-store-projections.md">Event Store & Projections</a></li>
</ul>
<hr>

<h2>🟢 Future Considerations - DOCUMENTED ✅</h2>

<p>All future considerations have been documented in the new specification files:</p>

<h3>10. Multi-Tenancy Support ✅ <strong>DOCUMENTED</strong></h3>
<strong>Comprehensive support for single/multiple databases and tenant isolation</strong>
<ul><li><strong>Detailed Specification</strong>: <a href="./multi-tenancy.md">Multi-Tenancy</a></li>
</ul>
<h3>11. Schema Evolution & Event Versioning ✅ <strong>DOCUMENTED</strong></h3>
<strong>JSONB-based evolution with upcasting and schema registry support</strong>
<ul><li><strong>Detailed Specification</strong>: <a href="./schema-evolution.md">Schema Evolution</a></li>
</ul>
<h3>12. Blue/Green Projection Deployments ✅ <strong>DOCUMENTED</strong></h3>
<strong>Driver-level blue/green implementation with atomic table swapping</strong>
<ul><li><strong>Detailed Specification</strong>: <a href="./schema-evolution.md">Schema Evolution</a></li>
</ul>
<h3>13. Cross-Aggregate Transactions ✅ <strong>DOCUMENTED</strong></h3>
<strong>Unit of Work pattern with saga fallback for complex operations</strong>
<ul><li><strong>Detailed Specification</strong>: <a href="./advanced-features.md">Advanced Features</a></li>
</ul>
<h3>14. Outbox/Inbox Table Schema ✅ <strong>DOCUMENTED</strong></h3>
<strong>Comprehensive outbox/inbox pattern implementation</strong>
<ul><li><strong>Detailed Specification</strong>: <a href="./event-store-projections.md">Event Store & Projections</a></li>
</ul>
<h3>15. Distributed Tracing Context ✅ <strong>DOCUMENTED</strong></h3>
<strong>W3C trace context headers with OpenTelemetry integration</strong>
<ul><li><strong>Detailed Specification</strong>: <a href="./advanced-features.md">Advanced Features</a></li>
</ul>
<h3>16. Performance Budgets & SLOs ✅ <strong>DOCUMENTED</strong></h3>
<strong>Attribute and programmatic performance budgets with OpenTelemetry</strong>
<ul><li><strong>Detailed Specification</strong>: <a href="./advanced-features.md">Advanced Features</a></li>
</ul>
<h3>17. Kubernetes Operator Features ✅ <strong>DOCUMENTED</strong></h3>
<strong>Auto-scaling, partition-aware placement, and blue/green deployments</strong>
<ul><li><strong>Detailed Specification</strong>: <a href="./advanced-features.md">Advanced Features</a></li>
</ul>
<h3>18. Debugging & Development Tools ✅ <strong>DOCUMENTED</strong></h3>
<strong>OpenTelemetry journey visualization, replay, and state inspection</strong>
<ul><li><strong>Detailed Specification</strong>: <a href="./advanced-features.md">Advanced Features</a></li>
</ul>
<hr>

<h2>Implementation Status</h2>

<strong>All architectural questions have been resolved</strong> and documented in comprehensive specification files. The library design is now ready for implementation.

<h3>Next Steps</h3>

<ul><li><strong>Review specifications</strong> - Study the detailed documentation for each area</li>
<li><strong>Create ADRs</strong> - Document key decisions in Architecture Decision Records</li>
<li><strong>Begin implementation</strong> - Start building based on the specifications</li>
<li><strong>Validate with prototypes</strong> - Build proof-of-concepts to validate designs</li>
</ul>
<h3>For Contributors</h3>

<p>All major architectural decisions have been made. Contributors should:</p>
<ul><li><strong>Read the specifications</strong> before starting work</li>
<li><strong>Follow the documented patterns</strong> in implementation</li>
<li><strong>Propose changes</strong> via GitHub Discussions if specifications need updates</li>
</ul>
<h3>For Maintainers</h3>

<p>Focus on:</p>
<ul><li><strong>Implementation planning</strong> - Break down specifications into development tasks</li>
<li><strong>Prototype validation</strong> - Build key components to validate architectural decisions</li>
<li><strong>Documentation updates</strong> - Keep specifications current as implementation progresses</li>
</ul>
<hr>

<h2>Complete Specification Suite</h2>

<h3>Core Architecture</h3>
<ul><li><a href="./event-store-projections.md"><strong>Event Store & Projections</strong></a> - Storage architecture and JSONB projections</li>
<li><a href="./domain-ownership.md"><strong>Domain Ownership</strong></a> - Handler discovery and ownership policies</li>
<li><a href="./concurrency-control.md"><strong>Concurrency Control</strong></a> - Multiple concurrency strategies</li>
</ul>
<h3>Advanced Features</h3>
<ul><li><a href="./projection-management.md"><strong>Projection Management</strong></a> - Checkpoints, snapshots, and backfilling</li>
<li><a href="./multi-tenancy.md"><strong>Multi-Tenancy</strong></a> - Comprehensive tenant isolation strategies</li>
<li><a href="./schema-evolution.md"><strong>Schema Evolution</strong></a> - JSONB evolution and versioning</li>
<li><a href="./policy-engine.md"><strong>Policy Engine</strong></a> - Universal configuration scoping mechanism</li>
<li><a href="./flags-tags-system.md"><strong>Flags & Tags System</strong></a> - Cross-service context propagation</li>
<li><a href="./advanced-features.md"><strong>Advanced Features</strong></a> - Cross-aggregate transactions, K8s operators, debugging</li>
</ul>
<h3>Implementation & Tooling</h3>
<ul><li><a href="./source-generation-ide.md"><strong>Source Generation & IDE Integration</strong></a> - Incremental generation and navigation service</li>
<li><a href="./testing-development-tools.md"><strong>Testing & Development Tools</strong></a> - Comprehensive testing framework and CLI tools</li>
<li><a href="./observability-metrics.md"><strong>Observability & Metrics</strong></a> - Policy-driven monitoring and OpenTelemetry</li>
<li><a href="./deployment-operations.md"><strong>Deployment & Operations</strong></a> - Production deployment and operational patterns</li>
</ul>
<h3>Foundation Documents</h3>
<ul><li><a href="../architecture-design/philosophy.md"><strong>Philosophy</strong></a> - Core principles and design philosophy</li>
<li><a href="../architecture-design/architecture.md"><strong>Architecture</strong></a> - Overall system architecture</li>
</ul>
<hr>

<strong>Ready to implement!</strong> All questions resolved, specifications complete, design decisions documented.

<hr>

<h2>🆕 New Questions Emerging from Implementation Planning</h2>

<p>As we dive deeper into the specifications, new architectural questions have emerged that need resolution:</p>

<h2>🔴 Critical Implementation Questions</h2>

<h3>19. Source Generator Architecture ✅ <strong>RESOLVED</strong></h3>

<strong>Decision</strong>: Single incremental generator with pipeline architecture

<strong>Key Requirements</strong>:
<ul><li><strong>Incremental generation</strong> - Only regenerate what changed</li>
<li><strong>IDE integration</strong> - Analyzer errors/fixes + navigation service</li>
<li><strong>Multi-project support</strong> - Aggregate generated code across project dependencies</li>
<li><strong>Debug transparency</strong> - No "magic", clear generated code + metadata</li>
<li><strong>Build observability</strong> - Detailed logging and timing for optimization</li>
</ul>
<strong>Implementation Approach</strong>:
<p>``<code>csharp{</p>
<p>title: "Incremental Source Generator Implementation"</p>
<p>description: "Shows how to implement an incremental source generator with pipeline architecture for Whizbang code generation"</p>
<p>category: "Design"</p>
<p>difficulty: "ADVANCED"</p>
<p>tags: ["source-generation", "incremental", "ide-integration", "pipeline"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>[Generator]</p>
<p>public class WhizbangSourceGenerator : IIncrementalGenerator {</p>
<p>    public void Initialize(IncrementalGeneratorInitializationContext context) {</p>
<p>        // Pipeline stages with timing/logging</p>
<p>        var handlersPipeline = context.SyntaxProvider.CreateSyntaxProvider(...);</p>
<p>        var domainOwnershipPipeline = context.SyntaxProvider.CreateSyntaxProvider(...);</p>
<p>        var projectionsPipeline = context.SyntaxProvider.CreateSyntaxProvider(...);</p>
<p>        </p>
<p>        // Combine all sources for cross-project aggregation</p>
<p>        var combinedPipeline = handlersPipeline</p>
<p>            .Combine(domainOwnershipPipeline)</p>
<p>            .Combine(projectionsPipeline);</p>
<p>            </p>
<p>        context.RegisterSourceOutput(combinedPipeline, GenerateCode);</p>
<p>        context.RegisterSourceOutput(combinedPipeline, GenerateMetadata); // For IDE service</p>
<p>    }</p>
<p>}</p>

<p>// Generated metadata for IDE navigation service</p>
<p>public class WhizbangNavigationMetadata {</p>
<p>    public Dictionary<string, EventStreamInfo> EventStreams { get; set; }</p>
<p>    public Dictionary<string, HandlerInfo> Handlers { get; set; }</p>
<p>    public Dictionary<string, ProjectionInfo> Projections { get; set; }</p>
<p>    public Dictionary<string, DomainInfo> Domains { get; set; }</p>
<p>}</p>
<pre><code class="language-">
<strong>IDE Integration Features</strong>:
<ul><li>GitLens-style event stream navigation</li>
<li>Command → Handler → Events → Projections flow visualization</li>
<li>Analyzer errors for misconfigured ownership/handlers</li>
<li>Code fixes for common patterns</li>
</ul>
<hr>

<h3>20. Driver Loading & Plugin Architecture ✅ <strong>RESOLVED</strong></h3>

<strong>Decision</strong>: Option A - Explicit registration for simplicity and predictability

<strong>Implementation</strong>:
<p></code></pre>csharp{</p>
<p>title: "Driver Registration Configuration"</p>
<p>description: "Demonstrates explicit driver registration with type safety for Event Store, Projections, and Message Broker"</p>
<p>category: "Design"</p>
<p>difficulty: "INTERMEDIATE"</p>
<p>tags: ["configuration", "drivers", "dependency-injection"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.UseEventStoreDriver<PostgresDriver>("connection-string");</p>
<p>    options.UseProjectionDriver<MongoDriver>("mongo-connection");</p>
<p>    options.UseMessageBrokerDriver<KafkaDriver>(kafka => {</p>
<p>        kafka.BootstrapServers = "localhost:9092";</p>
<p>        kafka.EnableIdempotence = true;</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<strong>Benefits</strong>:
<ul><li>Clear, explicit dependencies</li>
<li>Compile-time safety</li>
<li>Predictable behavior</li>
<li>Easy to reason about and debug</li>
<li>Works well with dependency injection</li>
</ul>
<hr>

<h3>21. Message Serialization Strategy ✅ <strong>RESOLVED</strong></h3>

<strong>Decision</strong>: Duck-typed serialization with System.Text.Json default + abstraction layer

<strong>Key Principles</strong>:
<ul><li><strong>Decoupled microservices</strong> - No shared dependencies required</li>
<li><strong>Duck typing</strong> - Service1.EventA can deserialize to Service5.EventC if shapes match</li>
<li><strong>Interface support</strong> - Both duck-typed and pure-shared interfaces</li>
<li><strong>Pure type sharing</strong> - Support shared Domain Models libraries when desired</li>
<li><strong>Zero-copy optimization</strong> - When applicable through adapters</li>
<li><strong>Compression support</strong> - Through driver adapters</li>
</ul>
<strong>Implementation Architecture</strong>:
<p></code></pre>csharp{</p>
<p>title: "Duck-Typed Message Serialization Configuration"</p>
<p>description: "Demonstrates duck-typed serialization allowing cross-service message compatibility without shared dependencies"</p>
<p>category: "Design"</p>
<p>difficulty: "INTERMEDIATE"</p>
<p>tags: ["serialization", "duck-typing", "microservices", "configuration"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>// Duck-typed serialization example</p>
<p>// Service 1 publishes:</p>
<p>public record OrderPlaced(Guid OrderId, string CustomerName, decimal Total);</p>

<p>// Service 5 receives as:</p>
<p>public record OrderReceived(Guid OrderId, string CustomerName, decimal Total);</p>
<p>// Works automatically via duck typing</p>

<p>// Interface-based approach (optional)</p>
<p>public interface IOrderEvent {</p>
<p>    Guid OrderId { get; }</p>
<p>    string CustomerName { get; }</p>
<p>    decimal Total { get; }</p>
<p>}</p>

<p>// Both services can implement the interface</p>
<p>public record OrderPlaced(...) : IOrderEvent;</p>
<p>public record OrderReceived(...) : IOrderEvent;</p>

<p>// Serialization configuration</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.Serialization(serialization => {</p>
<p>        serialization.DefaultSerializer = SystemTextJsonSerializer.Default;</p>
<p>        serialization.EnableDuckTyping = true;</p>
<p>        serialization.EnableInterfaceMapping = true;</p>
<p>        serialization.EnableZeroCopy = true; // When supported by driver</p>
<p>        </p>
<p>        // Driver-specific optimizations</p>
<p>        serialization.ForDriver<PostgresDriver>()</p>
<p>            .UseJsonOptimizations(jsonb: true);</p>
<p>        serialization.ForDriver<KafkaDriver>()</p>
<p>            .UseCompression(CompressionType.Gzip);</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<strong>Duck Typing Implementation</strong>:
<p></code></pre>csharp{</p>
<p>title: "Duck-Typing Message Serializer Implementation"</p>
<p>description: "Shows implementation of duck-typing serializer that can convert between compatible message types without shared contracts"</p>
<p>category: "Design"</p>
<p>difficulty: "ADVANCED"</p>
<p>tags: ["serialization", "duck-typing", "json", "type-conversion"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>public interface IMessageSerializer {</p>
<p>    T Deserialize<T>(byte[] data, Type sourceType);</p>
<p>    byte[] Serialize<T>(T message);</p>
<p>    bool CanDuckType(Type source, Type target);</p>
<p>}</p>

<p>public class DuckTypingJsonSerializer : IMessageSerializer {</p>
<p>    public T Deserialize<T>(byte[] data, Type sourceType) {</p>
<p>        if (typeof(T) == sourceType) {</p>
<p>            return JsonSerializer.Deserialize<T>(data);</p>
<p>        }</p>
<p>        </p>
<p>        // Duck typing: deserialize to JObject then convert</p>
<p>        var json = JsonSerializer.Deserialize<JsonObject>(data);</p>
<p>        return json.Deserialize<T>();</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<hr>

<h3>22. Error Handling & Resilience Patterns ✅ <strong>RESOLVED</strong></h3>

<strong>Decision</strong>: Use Polly as the resilience framework with Whizbang-specific defaults and policies

<strong>Core Principle</strong>: <strong>Never lose data</strong> - prefer backing up streams over discarding messages

<strong>Implementation Strategy</strong>:
<p></code></pre>csharp{</p>
<p>title: "Resilience Policy Configuration with Polly"</p>
<p>description: "Demonstrates comprehensive error handling and resilience patterns using Polly with data integrity safeguards"</p>
<p>category: "Design"</p>
<p>difficulty: "ADVANCED"</p>
<p>tags: ["resilience", "polly", "error-handling", "circuit-breaker", "retry"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.Resilience(resilience => {</p>
<p>        // Default policies (can be overridden)</p>
<p>        resilience.DefaultRetryPolicy = Policy</p>
<p>            .Handle<TransientException>()</p>
<p>            .WaitAndRetryAsync(3, retryAttempt => </p>
<p>                TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));</p>
<p>                </p>
<p>        resilience.DefaultCircuitBreakerPolicy = Policy</p>
<p>            .Handle<Exception>()</p>
<p>            .CircuitBreakerAsync(5, TimeSpan.FromMinutes(1));</p>
<p>            </p>
<p>        // Data integrity first - back up rather than lose</p>
<p>        resilience.OnMaxRetriesExceeded = (context, exception) => {</p>
<p>            // Back up the stream, don't discard</p>
<p>            return ResilienceAction.BackupAndHold;</p>
<p>        };</p>
<p>        </p>
<p>        // Per-event/interface/pattern customization</p>
<p>        resilience.ForEvent<OrderPlaced>()</p>
<p>            .UseRetryPolicy(customOrderRetryPolicy);</p>
<p>            </p>
<p>        resilience.ForInterface<IProjectionHandler>()</p>
<p>            .UseCircuitBreaker(projectionCircuitBreaker);</p>
<p>            </p>
<p>        resilience.ForPattern(type => type.Name.EndsWith("Command"))</p>
<p>            .UseTimeout(TimeSpan.FromSeconds(30));</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<strong>Default Behaviors with Safety Warnings</strong>:
<p></code></pre>csharp{</p>
<p>title: "Safe Default Resilience Policies"</p>
<p>description: "Defines safe default resilience policies that prioritize data integrity with warnings for dangerous overrides"</p>
<p>category: "Design"</p>
<p>difficulty: "INTERMEDIATE"</p>
<p>tags: ["resilience", "safety", "data-integrity", "defaults"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>// Safe defaults</p>
<p>public static class DefaultResiliencePolicies {</p>
<p>    public static ResiliencePolicy SafeDefault => new() {</p>
<p>        MaxRetries = 3,</p>
<p>        BackoffStrategy = BackoffStrategy.ExponentialWithJitter,</p>
<p>        OnFailure = ResilienceAction.BackupAndHold, // SAFE: Don't lose data</p>
<p>        CircuitBreakerThreshold = 5,</p>
<p>        CircuitBreakerDuration = TimeSpan.FromMinutes(1)</p>
<p>    };</p>
<p>    </p>
<p>    // Dangerous overrides (with warnings)</p>
<p>    [Obsolete("WARNING: This policy may result in data loss. Use SafeDefault unless you understand the risks.")]</p>
<p>    public static ResiliencePolicy DangerousDiscardOnFailure => new() {</p>
<p>        OnFailure = ResilienceAction.Discard // DANGEROUS: May lose data</p>
<p>    };</p>
<p>}</p>
<pre><code class="language-">
<strong>Customizable Hooks</strong>:
<p></code></pre>csharp{</p>
<p>title: "Resilience Failure Hooks Configuration"</p>
<p>description: "Shows how to configure global hooks for handling transient and permanent failures with logging and alerting"</p>
<p>category: "Design"</p>
<p>difficulty: "INTERMEDIATE"</p>
<p>tags: ["resilience", "hooks", "logging", "alerting", "dead-letter"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>// Global hooks</p>
<p>resilience.OnTransientFailure = async (context, exception) => {</p>
<p>    await _logger.LogWarningAsync($"Transient failure in {context.HandlerType}: {exception.Message}");</p>
<p>};</p>

<p>resilience.OnPermanentFailure = async (context, exception) => {</p>
<p>    await _alerting.SendCriticalAlert($"Permanent failure in {context.HandlerType}: {exception.Message}");</p>
<p>    await _deadLetterQueue.SendAsync(context.Message, exception);</p>
<p>};</p>
<pre><code class="language-">
<hr>

<h3>23. Configuration Management Strategy ✅ <strong>RESOLVED</strong></h3>

<strong>Decision</strong>: Hybrid approach - Options B & C (fluent + configuration) with Policy Engine integration

<strong>Implementation Strategy</strong>:
<p></code></pre>csharp{</p>
<p>title: "Hybrid Configuration Strategy"</p>
<p>description: "Demonstrates fluent builder pattern combined with policy-driven configuration for type safety and flexibility"</p>
<p>category: "Design"</p>
<p>difficulty: "INTERMEDIATE"</p>
<p>tags: ["configuration", "fluent-api", "policies", "multi-environment"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>// Fluent builder for type safety and discoverability</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.UseEventStore<PostgresDriver>("connection-string")</p>
<p>           .UseProjections(proj => proj.DefaultStrategy = SnapshotStrategy.Automatic)</p>
<p>           .UseDomainOwnership(dom => dom.PrecedenceOrder("Namespace", "Attributes"))</p>
<p>           .UseMultiTenancy(mt => mt.DefaultStrategy = TenancyStrategy.SingleDatabase);</p>
<p>           </p>
<p>    // Policy-driven configuration</p>
<p>    options.Policies(policies => {</p>
<p>        policies.ForEnvironment("Production")</p>
<p>                .LoadFromConfiguration("ProductionPolicies");</p>
<p>        policies.ForEnvironment("Development")</p>
<p>                .Apply(DevelopmentPolicies.Default);</p>
<p>    });</p>
<p>});</p>

<p>// Configuration sections for environment-specific overrides</p>
<p>{</p>
<p>  "Whizbang": {</p>
<p>    "EventStore": { "Driver": "Postgres", "ConnectionString": "..." },</p>
<p>    "Projections": { "DefaultStrategy": "Automatic" },</p>
<p>    "Policies": {</p>
<p>      "Production": [...],</p>
<p>      "Development": [...]</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<pre><code class="language-">
<strong>Benefits</strong>:
<ul><li><strong>Type safety</strong> through fluent builder</li>
<li><strong>Flexibility</strong> through configuration sections</li>
<li><strong>Policy-driven behavior</strong> for environment adaptation</li>
<li><strong>Validation</strong> at startup with clear error messages</li>
</ul>
<hr>

<h3>24. Testing Strategy & Test Helpers ✅ <strong>RESOLVED</strong></h3>

<strong>Decision</strong>: Provide comprehensive testing library including suggested helpers

<strong>Implementation</strong>:
<p></code></pre>csharp{</p>
<p>title: "Comprehensive Testing Framework"</p>
<p>description: "Shows the testing library with Given/When/Then pattern, projection testing, and in-memory drivers for fast unit tests"</p>
<p>category: "Design"</p>
<p>difficulty: "INTERMEDIATE"</p>
<p>tags: ["testing", "given-when-then", "unit-tests", "in-memory", "projections"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>// Whizbang.Testing package</p>
<p>public class WhizbangTestFixture {</p>
<p>    public GivenEventsBuilder Given(params object[] events);</p>
<p>    public WhenCommandBuilder When(ICommand command);</p>
<p>    public ThenEventsBuilder Then();</p>
<p>    </p>
<p>    // Projection testing</p>
<p>    public ProjectionTestBuilder ForProjection<TProjection>();</p>
<p>    </p>
<p>    // Policy testing</p>
<p>    public PolicyTestBuilder ForPolicy(string policyName);</p>
<p>}</p>

<p>// Usage in tests</p>
<p>[Test]</p>
<p>public async Task PlaceOrder_ShouldEmitOrderPlaced() {</p>
<p>    await _fixture</p>
<p>        .Given(new CustomerRegistered(customerId, "John Doe"))</p>
<p>        .When(new PlaceOrder(orderId, customerId, items))</p>
<p>        .Then()</p>
<p>        .ShouldEmitEvent<OrderPlaced>()</p>
<p>        .WithProperty(e => e.CustomerId, customerId);</p>
<p>}</p>

<p>// In-memory drivers for testing</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.UseInMemoryEventStore()  // For unit tests</p>
<p>           .UseInMemoryProjections()</p>
<p>           .UseInMemoryMessageBroker();</p>
<p>});</p>
<pre><code class="language-">
<strong>Features</strong>:
<ul><li><strong>In-memory drivers</strong> for fast unit testing</li>
<li><strong>Given/When/Then</strong> fluent test API</li>
<li><strong>Projection test helpers</strong> with event feeding</li>
<li><strong>Policy testing</strong> for complex rule validation</li>
<li><strong>Integration test helpers</strong> with test containers</li>
</ul>
<hr>

<h3>25. Metrics & Observability Data Model ✅ <strong>RESOLVED</strong></h3>

<strong>Decision</strong>: Configurable metrics with policy-driven verbosity and custom field attributes

<strong>Default Metrics (Always Enabled)</strong>:
<p></code></pre>csharp{</p>
<p>title: "Default Observability Metrics"</p>
<p>description: "Defines the core performance and infrastructure health metrics that are always enabled in Whizbang"</p>
<p>category: "Design"</p>
<p>difficulty: "BEGINNER"</p>
<p>tags: ["observability", "metrics", "performance", "monitoring"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>// Core performance metrics</p>
<p>whizbang_command_duration_seconds{command_type, domain, handler_type}</p>
<p>whizbang_command_total{command_type, domain, status}</p>
<p>whizbang_event_processing_duration_seconds{event_type, handler_type}</p>
<p>whizbang_projection_lag_seconds{projection_name}</p>

<p>// Infrastructure health</p>
<p>whizbang_event_store_append_duration_seconds{driver_type}</p>
<p>whizbang_message_broker_publish_duration_seconds{broker_type}</p>
<pre><code class="language-">
<strong>Policy-Driven Observability</strong>:
<p></code></pre>csharp{</p>
<p>title: "Policy-Driven Observability Configuration"</p>
<p>description: "Shows how to configure observability levels using policies based on flags and tags for dynamic monitoring"</p>
<p>category: "Design"</p>
<p>difficulty: "ADVANCED"</p>
<p>tags: ["observability", "policies", "monitoring", "telemetry", "conditional"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.Observability(obs => {</p>
<p>        obs.DefaultLevel = ObservabilityLevel.Standard;</p>
<p>        </p>
<p>        // Policy-based observability levels</p>
<p>        obs.Policies(policies => {</p>
<p>            policies.When(ctx => ctx.HasFlag(WhizbangFlags.VerboseOtel))</p>
<p>                    .Then(action => action.SetObservabilityLevel(ObservabilityLevel.Verbose));</p>
<p>                    </p>
<p>            policies.When(ctx => ctx.HasTag("critical-path"))</p>
<p>                    .Then(action => action.EnableDetailedMetrics())</p>
<p>                    .And(action => action.CaptureCustomFields());</p>
<p>        });</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<strong>Custom Field Attributes for Source Generation</strong>:
<p></code></pre>csharp{</p>
<p>title: "Custom Observability Fields with Attributes"</p>
<p>description: "Demonstrates using attributes to include specific event fields in generated metrics for enhanced observability"</p>
<p>category: "Design"</p>
<p>difficulty: "INTERMEDIATE"</p>
<p>tags: ["observability", "attributes", "source-generation", "metrics", "events"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>// Add fields to metadata via attributes</p>
<p>public record OrderPlaced(</p>
<p>    Guid OrderId,</p>
<p>    [ObservabilityField] Guid CustomerId,    // Include in metrics</p>
<p>    [ObservabilityField] decimal Total,      // Include in metrics</p>
<p>    List<OrderItem> Items</p>
<p>);</p>

<p>// Generated metric includes custom fields</p>
<p>whizbang_event_published_total{event_type="OrderPlaced", customer_id="123", total_range="1000-5000"}</p>
<pre><code class="language-">
<hr>

<h3>26. Development Experience & Tooling ✅ <strong>RESOLVED</strong></h3>

<strong>Decision</strong>: Comprehensive tooling suite as outlined

<strong>Planned Tools</strong>:
<p></code></pre>bash</p>
<h1>CLI tool (whizbang-cli)</h1>
<p>whizbang new --template microservice --name OrderService</p>
<p>whizbang add projection --name OrderSummary --events OrderPlaced,OrderShipped</p>
<p>whizbang migrate --from 1.0 --to 2.0</p>
<p>whizbang dashboard --port 5000</p>
<p>whizbang replay --stream orders --from 2024-01-01</p>

<h1>Visual Studio integration</h1>
<p>dotnet new whizbang-service --name MyService</p>
<p>dotnet new whizbang-projection --name OrderSummary</p>
<pre><code class="language-">
<strong>IDE Extensions</strong>:
<ul><li><strong>Navigation service</strong> for GitLens-style event stream traversal</li>
<li><strong>Code analyzers</strong> for ownership and pattern validation</li>
<li><strong>Live templates</strong> for commands, events, projections, sagas</li>
<li><strong>Debugging tools</strong> with state inspection and replay</li>
</ul>
<strong>Web Dashboard</strong>:
<ul><li>Real-time projection lag monitoring</li>
<li>Event stream visualization</li>
<li>Policy rule testing and validation</li>
<li>Performance metrics and alerting</li>
</ul>
<strong>Documentation</strong>: Dedicated tools page and documentation section

<hr>

<h3>27. Deployment & Operations Patterns ✅ <strong>RESOLVED</strong></h3>

<strong>Decision</strong>: Embedded library with comprehensive operational hooks

<strong>Deployment Model</strong>:
<ul><li><strong>Embedded library</strong> - Runs within developer's service</li>
<li><strong>Built-in health checks</strong> - Ready for Kubernetes probes</li>
<li><strong>Graceful shutdown</strong> - Message draining support</li>
<li><strong>.NET integration</strong> - Hooks into .NET hosting lifetime</li>
</ul>
<strong>Implementation</strong>:
<p></code></pre>csharp{</p>
<p>title: "Deployment Health Checks and Graceful Shutdown"</p>
<p>description: "Shows built-in health checks for Kubernetes probes and graceful shutdown with message draining support"</p>
<p>category: "Design"</p>
<p>difficulty: "INTERMEDIATE"</p>
<p>tags: ["deployment", "health-checks", "graceful-shutdown", "kubernetes", "operations"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>// Built-in health checks</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.HealthChecks(health => {</p>
<p>        health.CheckEventStoreConnection = true;</p>
<p>        health.CheckProjectionLag = true;</p>
<p>        health.CheckMessageBrokerConnection = true;</p>
<p>        health.ProjectionLagThreshold = TimeSpan.FromMinutes(5);</p>
<p>    });</p>
<p>});</p>

<p>// Graceful shutdown integration</p>
<p>public class WhizbangHostedService : IHostedService {</p>
<p>    public async Task StopAsync(CancellationToken cancellationToken) {</p>
<p>        // Drain in-flight messages</p>
<p>        await _messageProcessor.DrainAsync(cancellationToken);</p>
<p>        // Stop accepting new messages</p>
<p>        await _messageSubscriptions.StopAsync(cancellationToken);</p>
<p>    }</p>
<p>}</p>
<p></code>``</p>

<hr>

<h2>🟢 Future Enhancement Questions</h2>

<h3>28. Event Store Scaling Patterns ✅ <strong>RESOLVED</strong></h3>

<strong>Decision</strong>: All suggested scaling patterns should be available as options

<strong>Scaling Options</strong>:
<ul><li><strong>Sharding strategies</strong> - By tenant, aggregate type, time, or custom logic</li>
<li><strong>Read replicas</strong> - For query load distribution</li>
<li><strong>Event archiving</strong> - Automated cold storage migration</li>
<li><strong>Cross-shard projections</strong> - With aggregation support</li>
</ul>
<h3>29. Advanced Saga Patterns</h3>

<strong>Question</strong>: Should Whizbang support more sophisticated saga patterns?

<strong>Considerations</strong>:
<ul><li><strong>Saga compensation</strong> - Automatic rollback workflows</li>
<li><strong>Saga timeouts</strong> - What happens when sagas get stuck</li>
<li><strong>Nested sagas</strong> - Sagas that spawn other sagas</li>
<li><strong>Saga state queries</strong> - Query current saga states</li>
</ul>
<h3>30. Real-time Features</h3>

<strong>Question</strong>: How should Whizbang support real-time scenarios?

<strong>Considerations</strong>:
<ul><li><strong>Live projections</strong> - Real-time projection updates</li>
<li><strong>Event streaming</strong> - WebSocket/SSE event feeds</li>
<li><strong>Push notifications</strong> - Mobile/web notifications</li>
<li><strong>Live dashboards</strong> - Real-time metrics and monitoring</li>
</ul>
<hr>

<h2>Decision Process for New Questions</h2>

<ul><li><strong>Prioritize by impact</strong> - Focus on critical implementation blockers first</li>
<li><strong>Prototype when uncertain</strong> - Build spikes to validate approaches</li>
<li><strong>Consider ecosystem integration</strong> - How do decisions affect .NET ecosystem fit</li>
<li><strong>Balance simplicity vs power</strong> - Don't over-engineer early decisions</li>
<li><strong>Document decisions</strong> - Update specifications as decisions are made</li>
</ul>
<strong>Next Steps</strong>: Review and prioritize these questions for the implementation phase.
  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="proposals-policy-engine" class="doc-section">
  <h2>Policy Engine</h2>
  <p class="doc-path"><code>proposals/policy-engine</code></p>
  <div class="doc-content">

<h1>Policy Engine</h1>

<p>Whizbang includes a sophisticated policy engine that enables flexible, rule-based configuration for routing, behavior modification, and system adaptation across the entire message lifecycle.</p>

<h2>Core Architecture</h2>

<p>The Policy Engine is the <strong>universal configuration scoping mechanism</strong> for Whizbang. Rather than having separate configuration systems for each feature, policies provide a unified way to apply configuration based on context, conditions, and scope.</p>

<strong>Every configurable aspect of Whizbang can use policies</strong> to determine when and how configuration should be applied:

<ul><li><strong>Concurrency strategies</strong> - Which concurrency approach to use based on message type/context</li>
<li><strong>Observability levels</strong> - How much detail to capture based on flags/environment</li>
<li><strong>Performance budgets</strong> - Different performance expectations for different scenarios</li>
<li><strong>Serialization formats</strong> - Which serializer to use for different drivers/contexts</li>
<li><strong>Multi-tenancy isolation</strong> - Tenant-specific behavior and storage strategies</li>
<li><strong>Domain ownership</strong> - Dynamic ownership rules based on context</li>
<li><strong>Error handling</strong> - Different resilience policies for different message types</li>
<li><strong>Routing decisions</strong> - Which handlers to use based on flags/tags</li>
<li><strong>Security policies</strong> - Authentication/authorization rules based on context</li>
</ul>
<strong>Policies can evaluate any aspect of the system state</strong>:
<ul><li><strong>Message content</strong> - Properties, types, values within commands/events</li>
<li><strong>Message context</strong> - Flags, tags, correlation IDs, tenant information</li>
<li><strong>System state</strong> - Current load, resource utilization, error rates</li>
<li><strong>Environment</strong> - Development, staging, production, feature flags</li>
<li><strong>User context</strong> - Authentication, authorization, user roles</li>
<li><strong>Time-based conditions</strong> - Business hours, maintenance windows, seasons</li>
<li><strong>Domain context</strong> - Which domain owns the message, cross-domain interactions</li>
<li><strong>Infrastructure state</strong> - Database health, message broker status</li>
<li><strong>Custom conditions</strong> - Any developer-defined evaluation criteria</li>
</ul>
<blockquote><strong>📋 Message Context</strong>: While policies can evaluate any system aspect, the <a href="./flags-tags-system.md"><strong>Flags & Tags System</strong></a> provides a convenient way to carry context through message flows.</blockquote>

<h2>Configuration Architecture Principles</h2>

<h3>Policy-Based vs Direct Configuration</h3>

<strong>Policies handle behavioral configuration</strong> that varies by context, environment, message type, or runtime conditions:

<p>``<code>csharp{title="Policy-Based vs Direct Configuration" description="Policy-based vs direct configuration showing separation of infrastructure and behavioral settings" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Policy-Engine", "Configuration", "Behavioral-Configuration"] framework="NET8"}</p>
<hr>
<p>services.AddWhizbang(options => {</p>
<p>    // INFRASTRUCTURE CONFIGURATION (Direct)</p>
<p>    // - Connection strings, driver selection, basic setup</p>
<p>    options.UseEventStoreDriver<PostgresDriver>(connectionString);</p>
<p>    options.UseMessageBrokerDriver<KafkaDriver>(kafkaConfig);</p>
<p>    </p>
<p>    // BEHAVIORAL CONFIGURATION (Policy-Based)</p>
<p>    // - Strategies, levels, rules that change based on context</p>
<p>    options.Policies(policies => {</p>
<p>        // Environment-based behavior</p>
<p>        policies.When(ctx => ctx.IsEnvironment("production"))</p>
<p>                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.ExpectedVersion))</p>
<p>                .And(config => config.SetObservabilityLevel(ObservabilityLevel.Standard));</p>
<p>        </p>
<p>        // Message type-based behavior</p>
<p>        policies.WhenMessageName(name => name.Contains("Payment"))</p>
<p>                .Then(config => config.SetStrictSecurity())</p>
<p>                .And(config => config.EnableDetailedAuditing());</p>
<p>        </p>
<p>        // Load/context-based behavior</p>
<p>        policies.When(ctx => ctx.HasFlag(WhizbangFlags.LoadTesting))</p>
<p>                .Then(config => config.UseOptimizedForThroughput());</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<strong>When to use Policies vs Direct Configuration</strong>:

<p>| Configuration Type | Use Policies | Use Direct |</p>
<p>|-------------------|-------------|------------|</p>
<p>| <strong>Concurrency Strategies</strong> | ✅ Context-dependent | ❌ |</p>
<p>| <strong>Observability Levels</strong> | ✅ Environment/load dependent | ❌ |</p>
<p>| <strong>Security Policies</strong> | ✅ Message/tenant dependent | ❌ |</p>
<p>| <strong>Performance Budgets</strong> | ✅ Handler/context dependent | ❌ |</p>
<p>| <strong>Multi-tenancy Strategy</strong> | ✅ Tenant-type dependent | ❌ |</p>
<p>| <strong>Connection Strings</strong> | ❌ | ✅ Infrastructure |</p>
<p>| <strong>Driver Selection</strong> | ✅ Environment dependent | ✅ Simple cases |</p>
<p>| <strong>Basic DI Registration</strong> | ❌ | ✅ Infrastructure |</p>

<h2>Policy Engine Architecture</h2>

<h3>Universal Configuration via Policies</h3>

<strong>All Whizbang configuration can be scoped using policies</strong>:

<p></code></pre>csharp{title="Universal Configuration via Policies" description="Comprehensive example showing all Whizbang features configured through unified policy system" category="Design" difficulty="ADVANCED" tags=["Design", "Policy-Engine", "Universal-Configuration", "Complex-Policies"] framework="NET8"}</p>
<hr>
<p>services.AddWhizbang(options => {</p>
<p>    options.Policies(policies => {</p>
<p>        // === CONCURRENCY STRATEGY POLICIES ===</p>
<p>        policies.When(ctx => ctx.MatchesMessage<HighVolumeCommand>())</p>
<p>                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.AutomaticRetry))</p>
<p>                .And(config => config.SetMaxRetries(5));</p>
<p>                </p>
<p>        policies.When(ctx => ctx.HasTag("critical-transaction"))</p>
<p>                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.ExpectedVersion))</p>
<p>                .And(config => config.SetIsolationLevel(IsolationLevel.Serializable));</p>
<p>        </p>
<p>        // === OBSERVABILITY POLICIES ===</p>
<p>        policies.When(ctx => ctx.HasFlag(WhizbangFlags.Production))</p>
<p>                .Then(config => config.SetObservabilityLevel(ObservabilityLevel.Standard))</p>
<p>                .And(config => config.SetSampleRate(0.1));</p>
<p>                </p>
<p>        policies.When(ctx => ctx.HasTag("customer-vip") || ctx.HasFlag(WhizbangFlags.VerboseLogging))</p>
<p>                .Then(config => config.SetObservabilityLevel(ObservabilityLevel.Verbose))</p>
<p>                .And(config => config.SetSampleRate(1.0))</p>
<p>                .And(config => config.EnableCustomFields());</p>
<p>        </p>
<p>        // === PERFORMANCE BUDGET POLICIES ===</p>
<p>        policies.WhenMessageName(name => name.EndsWith("Command"))</p>
<p>                .Then(config => config.SetPerformanceBudget(new PerformanceBudget {</p>
<p>                    MaxLatency = TimeSpan.FromMilliseconds(500),</p>
<p>                    MaxMemoryMB = 10</p>
<p>                }));</p>
<p>                </p>
<p>        policies.When(ctx => ctx.HasTag("real-time"))</p>
<p>                .Then(config => config.SetPerformanceBudget(new PerformanceBudget {</p>
<p>                    MaxLatency = TimeSpan.FromMilliseconds(50),</p>
<p>                    AlertOnViolation = true</p>
<p>                }));</p>
<p>        </p>
<p>        // === SERIALIZATION POLICIES ===</p>
<p>        policies.WhenDriverType<KafkaDriver>()</p>
<p>                .Then(config => config.UseSerializer<AvroSerializer>())</p>
<p>                .And(config => config.EnableCompression(CompressionType.Gzip));</p>
<p>                </p>
<p>        policies.WhenDriverType<PostgresDriver>()</p>
<p>                .Then(config => config.UseSerializer<JsonSerializer>())</p>
<p>                .And(config => config.EnableJsonbOptimizations());</p>
<p>        </p>
<p>        // === MULTI-TENANCY POLICIES ===</p>
<p>        policies.When(ctx => ctx.TenantId != null && ctx.HasTag("enterprise-tenant"))</p>
<p>                .Then(config => config.UseTenancyStrategy(TenancyStrategy.SeparateDatabases))</p>
<p>                .And(config => config.EnableTenantIsolation());</p>
<p>                </p>
<p>        policies.When(ctx => ctx.TenantId != null && ctx.HasTag("startup-tenant"))</p>
<p>                .Then(config => config.UseTenancyStrategy(TenancyStrategy.SingleDatabaseWithIsolation))</p>
<p>                .And(config => config.EnableSharedResources());</p>
<p>        </p>
<p>        // === ERROR HANDLING POLICIES ===</p>
<p>        policies.WhenMessageName(name => name.Contains("Payment"))</p>
<p>                .Then(config => config.UseResiliencePolicy(StrictRetryPolicy))</p>
<p>                .And(config => config.SetMaxRetries(3))</p>
<p>                .And(config => config.EnableCircuitBreaker());</p>
<p>                </p>
<p>        policies.When(ctx => ctx.HasFlag(WhizbangFlags.LoadTesting))</p>
<p>                .Then(config => config.UseResiliencePolicy(FastFailPolicy))</p>
<p>                .And(config => config.DisableRetries());</p>
<p>        </p>
<p>        // === ROUTING POLICIES ===</p>
<p>        policies.When(ctx => ctx.HasTag("customer-vip"))</p>
<p>                .Then(config => config.RouteToHandler<PremiumOrderHandler>())</p>
<p>                .And(config => config.SetPriority(MessagePriority.High));</p>
<p>                </p>
<p>        policies.When(ctx => ctx.SystemLoad > 0.8)</p>
<p>                .Then(config => config.RouteToHandler<LightweightOrderHandler>())</p>
<p>                .And(config => config.DeferNonCriticalProcessing());</p>
<p>        </p>
<p>        // === SECURITY POLICIES ===</p>
<p>        policies.When(ctx => ctx.HasTag("pci-data") || ctx.HasTag("sensitive"))</p>
<p>                .Then(config => config.RequireEncryption())</p>
<p>                .And(config => config.EnableAuditLogging())</p>
<p>                .And(config => config.RequireAuthorization("pci-access"));</p>
<p>                </p>
<p>        policies.When(ctx => ctx.IsEnvironment("production") && ctx.HasTag("external-api"))</p>
<p>                .Then(config => config.EnableRateLimiting(100, TimeSpan.FromMinutes(1)))</p>
<p>                .And(config => config.RequireApiKey());</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h3>Policy Combination Strategies</h3>

<p></code></pre>csharp{title="Policy Combination Strategies" description="Advanced policy combination strategies using intersection, union, and exclusion operations" category="Design" difficulty="ADVANCED" tags=["Design", "Policy-Engine", "Policy-Combination", "Venn-Diagrams"] framework="NET8"}</p>
<hr>
<p>// Venn diagram-style policy combinations</p>
<p>policies.Combine(</p>
<p>    // Policy A: High-priority customers</p>
<p>    policies.When(ctx => ctx.HasTag("customer-vip")),</p>
<p>    </p>
<p>    // Policy B: Large orders with custom condition</p>
<p>    policies.When(ctx => ctx.MatchesEvent<OrderPlaced>() && ctx.GetEvent<OrderPlaced>()?.Total > 10000),</p>
<p>    </p>
<p>    // Combination strategies</p>
<p>    CombinationStrategy.Intersection  // Both A AND B</p>
<p>);</p>

<p>policies.Combine(</p>
<p>    policies.When(ctx => ctx.HasFlag(WhizbangFlags.LoadTesting)),</p>
<p>    policies.When(ctx => ctx.HasFlag(WhizbangFlags.DryRun)),</p>
<p>    CombinationStrategy.Union        // Either A OR B</p>
<p>);</p>

<p>policies.Combine(</p>
<p>    policies.When(ctx => ctx.HasTag("batch-import")),</p>
<p>    policies.When(ctx => ctx.HasFlag(WhizbangFlags.Migration)),</p>
<p>    CombinationStrategy.Exclusion    // A XOR B (one but not both)</p>
<p>);</p>
<pre><code class="language-">
<h3>Canned/Static Policies</h3>

<p></code></pre>csharp{title="Canned/Static Policies" description="Pre-defined reusable policies for common scenarios with override capabilities" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Policy-Engine", "Canned-Policies", "Reusable-Patterns"] framework="NET8"}</p>
<hr>
<p>// Pre-defined policies for common scenarios</p>
<p>public static class WhizbangPolicies {</p>
<p>    public static Policy LoadTestingPolicy => new PolicyBuilder()</p>
<p>        .When(ctx => ctx.HasFlag(WhizbangFlags.LoadTesting))</p>
<p>        .Then(action => action.SkipProjections())</p>
<p>        .And(action => action.DisableSlowOperations())</p>
<p>        .And(action => action.AddTag("load-test-ignored"))</p>
<p>        .Build();</p>
<p>        </p>
<p>    public static Policy ProductionSafetyPolicy => new PolicyBuilder()</p>
<p>        .When(ctx => ctx.HasFlag(WhizbangFlags.Production))</p>
<p>        .Then(action => action.EnableDataScrubbing())</p>
<p>        .And(action => action.EnforceRateLimits())</p>
<p>        .And(action => action.EnableAuditLogging())</p>
<p>        .Build();</p>
<p>        </p>
<p>    public static Policy DevelopmentDebuggingPolicy => new PolicyBuilder()</p>
<p>        .When(ctx => ctx.HasFlag(WhizbangFlags.Development))</p>
<p>        .Then(action => action.EnableVerboseLogging())</p>
<p>        .And(action => action.EnableBreakpoints())</p>
<p>        .And(action => action.DisableTimeouts())</p>
<p>        .Build();</p>
<p>}</p>

<p>// Apply canned policies</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.Policies(policies => {</p>
<p>        policies.Apply(WhizbangPolicies.LoadTestingPolicy);</p>
<p>        policies.Apply(WhizbangPolicies.ProductionSafetyPolicy);</p>
<p>        policies.Apply(WhizbangPolicies.DevelopmentDebuggingPolicy);</p>
<p>        </p>
<p>        // Custom policies can override or extend canned policies</p>
<p>        policies.When(ctx => ctx.HasTag("special-case"))</p>
<p>                .OverridePolicy(WhizbangPolicies.ProductionSafetyPolicy)</p>
<p>                .Then(action => action.DisableDataScrubbing()); // Override for this case</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h2>Advanced Policy Scenarios</h2>

<h3>Cross-Service Flag Propagation</h3>

<strong>Flags carry through entire message journey</strong>:

<p></code></pre>csharp{title="Cross-Service Flag Propagation" description="Flag propagation across service boundaries maintaining context through entire message journey" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Policy-Engine", "Cross-Service-Propagation", "Debugging"] framework="NET8"}</p>
<hr>
<p>// Initial command with debugging flags</p>
<p>var command = new PlaceOrder(orderId, customerId, items);</p>
<p>await _mediator.Send(command, context => {</p>
<p>    context.WithFlags(WhizbangFlags.VerboseLogging | WhizbangFlags.TraceReplay)</p>
<p>           .WithTag("debug-session-123");</p>
<p>});</p>

<p>// Flags automatically propagate to:</p>
<p>// 1. Command handler execution</p>
<p>// 2. Event publishing</p>
<p>// 3. Cross-service event delivery</p>
<p>// 4. Projection updates</p>
<p>// 5. Saga execution</p>

<p>// Service 2 receives event with same flags</p>
<p>public class InventoryHandler : IEventHandler<OrderPlaced> {</p>
<p>    public async Task Handle(OrderPlaced @event, EventContext context) {</p>
<p>        // context.Flags contains VerboseLogging | TraceReplay</p>
<p>        // context.Tags contains "debug-session-123"</p>
<p>        </p>
<p>        if (context.HasFlag(WhizbangFlags.VerboseLogging)) {</p>
<p>            _logger.LogInformation("Processing order with verbose logging enabled");</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Data Scrubbing with Policy-Based Duplication</h3>

<p></code></pre>csharp{title="Data Scrubbing with Policy-Based Duplication" description="Policy-based data scrubbing when promoting production data to QA environment" category="Design" difficulty="ADVANCED" tags=["Design", "Policy-Engine", "Data-Scrubbing", "Environment-Promotion"] framework="NET8"}</p>
<hr>
<p>// Production to QA data flow with scrubbing</p>
<p>policies.When(ctx => ctx.HasTag("production-data") && ctx.HasFlag(WhizbangFlags.QA))</p>
<p>        .Then(action => action.DuplicateMessage())</p>
<p>        .And(action => action.ScrubSensitiveData())</p>
<p>        .And(action => action.AddFlag(WhizbangFlags.DataScrubbing))</p>
<p>        .And(action => action.RouteToEnvironment("qa"));</p>

<p>// Handler that applies scrubbing</p>
<p>public class DataScrubbingHandler : IMessageInterceptor {</p>
<p>    public async Task<TResponse> Intercept<TRequest, TResponse>(</p>
<p>        TRequest message, </p>
<p>        MessageContext context, </p>
<p>        MessageHandlerDelegate<TRequest, TResponse> next) {</p>
<p>        </p>
<p>        if (context.HasFlag(WhizbangFlags.DataScrubbing)) {</p>
<p>            message = _dataScrubber.Scrub(message);</p>
<p>        }</p>
<p>        </p>
<p>        return await next(message, context);</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Dynamic Handler Routing</h3>

<p></code></pre>csharp{title="Dynamic Handler Routing" description="Dynamic handler routing based on flags and tags with conditional registration" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Policy-Engine", "Dynamic-Routing", "Handler-Selection"] framework="NET8"}</p>
<hr>
<p>// Route to different handlers based on flags/tags</p>
<p>policies.When(ctx => ctx.HasTag("high-value-customer"))</p>
<p>        .Then(action => action.RouteToHandler<PremiumOrderHandler>())</p>
<p>        .Else(action => action.RouteToHandler<StandardOrderHandler>());</p>

<p>policies.When(ctx => ctx.HasFlag(WhizbangFlags.LoadTesting))</p>
<p>        .Then(action => action.RouteToHandler<LoadTestOrderHandler>())</p>
<p>        .And(action => action.SkipProjections());</p>

<p>// Alternative handler registration</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.RegisterHandler<PlaceOrder, StandardOrderHandler>(); // Default</p>
<p>    options.RegisterHandler<PlaceOrder, PremiumOrderHandler>(</p>
<p>        condition: ctx => ctx.Tags.Contains("high-value-customer"));</p>
<p>    options.RegisterHandler<PlaceOrder, LoadTestOrderHandler>(</p>
<p>        condition: ctx => ctx.Flags.HasFlag(WhizbangFlags.LoadTesting));</p>
<p>});</p>
<pre><code class="language-">
<h3>IDE Debugging Support</h3>

<p></code></pre>csharp{title="IDE Debugging Support" description="Advanced debugging support with IDE integration, breakpoints, and state inspection" category="Design" difficulty="ADVANCED" tags=["Design", "Policy-Engine", "IDE-Integration", "Debugging", "Time-Travel"] framework="NET8"}</p>
<hr>
<p>// IDE cursor/scrubbing mode</p>
<p>policies.When(ctx => ctx.HasFlag(WhizbangFlags.CursorMode))</p>
<p>        .Then(action => action.EnableStepByStepExecution())</p>
<p>        .And(action => action.CaptureStateSnapshots())</p>
<p>        .And(action => action.AllowTimeTravel());</p>

<p>// Breakpoint support</p>
<p>policies.When(ctx => ctx.HasFlag(WhizbangFlags.Breakpoint))</p>
<p>        .Then(action => action.PauseExecution())</p>
<p>        .And(action => action.NotifyIDE())</p>
<p>        .And(action => action.CaptureFullContext());</p>

<p>// State inspection</p>
<p>public class StateInspectionInterceptor : IMessageInterceptor {</p>
<p>    public async Task<TResponse> Intercept<TRequest, TResponse>(</p>
<p>        TRequest message,</p>
<p>        MessageContext context,</p>
<p>        MessageHandlerDelegate<TRequest, TResponse> next) {</p>
<p>        </p>
<p>        if (context.HasFlag(WhizbangFlags.CursorMode)) {</p>
<p>            await _stateCapture.CapturePreExecutionState(message, context);</p>
<p>        }</p>
<p>        </p>
<p>        var response = await next(message, context);</p>
<p>        </p>
<p>        if (context.HasFlag(WhizbangFlags.CursorMode)) {</p>
<p>            await _stateCapture.CapturePostExecutionState(response, context);</p>
<p>        }</p>
<p>        </p>
<p>        return response;</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Policy Engine Implementation</h2>

<h3>Core Interfaces</h3>

<p></code></pre>csharp{title="Core Interfaces" description="Core policy engine interfaces and action types for implementing the policy system" category="Design" difficulty="ADVANCED" tags=["Design", "Policy-Engine", "Core-Interfaces", "Implementation"] framework="NET8"}</p>
<hr>
<p>public interface IPolicyEngine {</p>
<p>    Task<PolicyResult> EvaluateAsync<T>(T message, MessageContext context);</p>
<p>    void RegisterPolicy(IPolicy policy);</p>
<p>    void RegisterPolicies(IEnumerable<IPolicy> policies);</p>
<p>    IPolicy CombinePolicies(IEnumerable<IPolicy> policies, CombinationStrategy strategy);</p>
<p>}</p>

<p>public interface IPolicy {</p>
<p>    string Name { get; }</p>
<p>    int Priority { get; }</p>
<p>    Task<bool> ShouldApplyAsync<T>(T message, MessageContext context);</p>
<p>    Task<PolicyAction[]> GetActionsAsync<T>(T message, MessageContext context);</p>
<p>}</p>

<p>public abstract class PolicyAction {</p>
<p>    public abstract Task ExecuteAsync<T>(T message, MessageContext context);</p>
<p>}</p>

<p>// Specific policy actions</p>
<p>public class RouteToHandlerAction<THandler> : PolicyAction { }</p>
<p>public class AddFlagAction : PolicyAction { }</p>
<p>public class AddTagAction : PolicyAction { }</p>
<p>public class SkipProjectionsAction : PolicyAction { }</p>
<p>public class EnableVerboseLoggingAction : PolicyAction { }</p>
<p>public class ScrubDataAction : PolicyAction { }</p>
<pre><code class="language-">
<h3>Typed Policy Methods</h3>

<strong>Context provides strongly-typed matching methods</strong>:

<p></code></pre>csharp{title="Typed Policy Methods" description="Typed policy methods with strongly-typed context matching and clean policy configuration" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Policy-Engine", "Message-Context", "Strongly-Typed"] framework="NET8"}</p>
<hr>
<p>public class MessageContext {</p>
<p>    // Core properties</p>
<p>    public string CorrelationId { get; set; }</p>
<p>    public WhizbangFlags Flags { get; set; }</p>
<p>    public HashSet<string> Tags { get; set; }</p>
<p>    public string Environment { get; set; }</p>
<p>    public string TenantId { get; set; }</p>
<p>    public Type MessageType { get; set; }</p>
<p>    public Type AggregateType { get; set; }</p>
<p>    public Type HandlerType { get; set; }</p>
<p>    </p>
<p>    // Strongly-typed matching methods (for types)</p>
<p>    public bool MatchesMessage<T>() => MessageType == typeof(T);</p>
<p>    public bool MatchesEvent<T>() where T : IEvent => MessageType == typeof(T);</p>
<p>    public bool MatchesCommand<T>() where T : ICommand => MessageType == typeof(T);</p>
<p>    public bool MatchesAggregate<T>() where T : Aggregate => AggregateType == typeof(T);</p>
<p>    public bool MatchesHandler<T>() => HandlerType == typeof(T);</p>
<p>    public bool MatchesDriver<T>() => DriverType == typeof(T);</p>
<p>    </p>
<p>    // Convenience methods</p>
<p>    public bool HasFlag(WhizbangFlags flag) => Flags.HasFlag(flag);</p>
<p>    public bool HasTag(string tag) => Tags.Contains(tag);</p>
<p>    public bool IsEnvironment(string env) => Environment.Equals(env, StringComparison.OrdinalIgnoreCase);</p>
<p>}</p>

<p>// Simple policy builder</p>
<p>public interface IPolicyBuilder {</p>
<p>    IPolicyBuilder When(Func<MessageContext, bool> condition);</p>
<p>    IPolicyBuilder Then(Action<ConfigurationBuilder> action);</p>
<p>    IPolicyBuilder And(Action<ConfigurationBuilder> action);</p>
<p>}</p>

<p>// Clean, readable policy configuration</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.Policies(policies => {</p>
<p>        // Type matching using context methods</p>
<p>        policies.When(ctx => ctx.MatchesMessage<PlaceOrder>())</p>
<p>                .Then(config => config.SetPerformanceBudget(orderBudget));</p>
<p>        </p>
<p>        policies.When(ctx => ctx.MatchesAggregate<Order>())</p>
<p>                .Then(config => config.UseConcurrencyStrategy(ConcurrencyStrategy.AutomaticRetry));</p>
<p>        </p>
<p>        policies.When(ctx => ctx.MatchesHandler<PaymentHandler>())</p>
<p>                .Then(config => config.RequireEncryption());</p>
<p>        </p>
<p>        // Conditional type matching with additional checks</p>
<p>        policies.When(ctx => ctx.MatchesEvent<OrderPlaced>() && </p>
<p>                             ctx.GetEvent<OrderPlaced>()?.Total > 10000)</p>
<p>                .Then(config => config.EnableDetailedAuditing());</p>
<p>        </p>
<p>        // Pattern matching on message names</p>
<p>        policies.When(ctx => ctx.MessageType.Name.EndsWith("Command"))</p>
<p>                .Then(config => config.SetMaxLatency(TimeSpan.FromSeconds(1)));</p>
<p>        </p>
<p>        // Flag and tag conditions</p>
<p>        policies.When(ctx => ctx.HasFlag(WhizbangFlags.Production))</p>
<p>                .Then(config => config.SetObservabilityLevel(ObservabilityLevel.Standard));</p>
<p>        </p>
<p>        policies.When(ctx => ctx.HasTag("critical-path") && ctx.IsEnvironment("production"))</p>
<p>                .Then(config => config.SetObservabilityLevel(ObservabilityLevel.Detailed));</p>
<p>        </p>
<p>        // Complex tenant conditions</p>
<p>        policies.When(ctx => ctx.TenantId != null && ctx.HasTag("enterprise"))</p>
<p>                .Then(config => config.UseTenancyStrategy(TenancyStrategy.SeparateDatabases));</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h3>Policy Hashing & Tracing</h3>

<strong>Every policy generates a deterministic hash</strong> for tracing and debugging:

<p></code></pre>csharp{title="Policy Hashing & Tracing" description="Policy hashing and tracing infrastructure for debugging and policy identification" category="Design" difficulty="ADVANCED" tags=["Design", "Policy-Engine", "Policy-Hashing", "Debugging", "Tracing"] framework="NET8"}</p>
<hr>
<p>public interface IPolicy {</p>
<p>    string Name { get; }</p>
<p>    int Priority { get; }</p>
<p>    string PolicyHash { get; } // Deterministic hash of policy conditions & actions</p>
<p>    Task<bool> ShouldApplyAsync<T>(T message, MessageContext context);</p>
<p>    Task<PolicyAction[]> GetActionsAsync<T>(T message, MessageContext context);</p>
<p>}</p>

<p>// Policy hash generation</p>
<p>public class PolicyBuilder {</p>
<p>    public string GeneratePolicyHash() {</p>
<p>        var hashInput = new {</p>
<p>            Conditions = _conditions.Select(c => c.ToHashString()),</p>
<p>            Actions = _actions.Select(a => a.ToHashString()),</p>
<p>            Priority = _priority</p>
<p>        };</p>
<p>        </p>
<p>        using var sha = SHA256.Create();</p>
<p>        var bytes = sha.ComputeHash(Encoding.UTF8.GetBytes(JsonSerializer.Serialize(hashInput)));</p>
<p>        return Convert.ToBase64String(bytes)[..8]; // Short hash for readability</p>
<p>    }</p>
<p>}</p>

<p>// Context carries applied policies</p>
<p>public class MessageContext {</p>
<p>    public string CorrelationId { get; set; }</p>
<p>    public WhizbangFlags Flags { get; set; }</p>
<p>    public HashSet<string> Tags { get; set; }</p>
<p>    </p>
<p>    // Policy tracking for debugging</p>
<p>    public List<AppliedPolicy> AppliedPolicies { get; set; } = new();</p>
<p>    public string ActivePolicyHash { get; set; } // Currently executing policy</p>
<p>    public Dictionary<string, object> PolicyDecisions { get; set; } = new();</p>
<p>}</p>

<p>public class AppliedPolicy {</p>
<p>    public string PolicyHash { get; set; }</p>
<p>    public string PolicyName { get; set; }</p>
<p>    public DateTimeOffset AppliedAt { get; set; }</p>
<p>    public Dictionary<string, object> Decisions { get; set; }</p>
<p>    public TimeSpan EvaluationTime { get; set; }</p>
<p>}</p>
<pre><code class="language-">
<h3>Distributed Tracing Integration</h3>

<strong>Policy decisions are traced through OpenTelemetry</strong>:

<p></code></pre>csharp{title="Distributed Tracing Integration" description="Distributed tracing integration showing policy decisions in OpenTelemetry traces" category="Design" difficulty="ADVANCED" tags=["Design", "Policy-Engine", "Distributed-Tracing", "OpenTelemetry"] framework="NET8"}</p>
<hr>
<p>public class PolicyTracingInterceptor : IMessageInterceptor {</p>
<p>    public async Task<TResponse> Intercept<TRequest, TResponse>(</p>
<p>        TRequest message,</p>
<p>        MessageContext context,</p>
<p>        MessageHandlerDelegate<TRequest, TResponse> next) {</p>
<p>        </p>
<p>        using var activity = Activity.StartActivity("PolicyEvaluation");</p>
<p>        </p>
<p>        // Evaluate applicable policies</p>
<p>        var policies = await _policyEngine.EvaluateAsync(message, context);</p>
<p>        </p>
<p>        foreach (var policy in policies) {</p>
<p>            // Add policy hash to trace</p>
<p>            activity?.SetTag("whizbang.policy.hash", policy.PolicyHash);</p>
<p>            activity?.SetTag("whizbang.policy.name", policy.Name);</p>
<p>            </p>
<p>            // Track in context for debugging</p>
<p>            context.AppliedPolicies.Add(new AppliedPolicy {</p>
<p>                PolicyHash = policy.PolicyHash,</p>
<p>                PolicyName = policy.Name,</p>
<p>                AppliedAt = DateTimeOffset.UtcNow,</p>
<p>                Decisions = policy.GetDecisions()</p>
<p>            });</p>
<p>        }</p>
<p>        </p>
<p>        // Include policy hashes in trace state</p>
<p>        var traceState = $"policies={string.Join(',', policies.Select(p => p.PolicyHash))}";</p>
<p>        activity?.SetTag("tracestate", traceState);</p>
<p>        </p>
<p>        return await next(message, context);</p>
<p>    }</p>
<p>}</p>

<p>// Policy decisions visible in traces</p>
<p>// Trace: PlaceOrder -> OrderHandler</p>
<p>//   Tags:</p>
<p>//     whizbang.policy.hash: "Ab3d9F2x"</p>
<p>//     whizbang.policy.name: "HighValueOrderPolicy"</p>
<p>//     whizbang.decisions: { "concurrency": "ExpectedVersion", "observability": "Verbose" }</p>
<pre><code class="language-">
<h3>IDE Integration via Source Generation</h3>

<strong>Source generator creates policy metadata</strong> for IDE tooling:

<p></code></pre>csharp{title="IDE Integration via Source Generation" description="Source-generated metadata enabling IDE navigation and policy impact analysis" category="Design" difficulty="ADVANCED" tags=["Design", "Policy-Engine", "Source-Generation", "IDE-Integration"] framework="NET8"}</p>
<hr>
<p>// Generated policy metadata for IDE navigation</p>
<p>[GeneratedCode("Whizbang.SourceGenerator")]</p>
<p>public static class PolicyMetadata {</p>
<p>    // Map of types to affecting policies</p>
<p>    public static readonly Dictionary<Type, List<PolicyInfo>> TypePolicies = new() {</p>
<p>        [typeof(Order)] = new List<PolicyInfo> {</p>
<p>            new("Ab3d9F2x", "OrderConcurrencyPolicy", PolicyEffect.ConcurrencyStrategy),</p>
<p>            new("Cd5e8G3y", "OrderObservabilityPolicy", PolicyEffect.ObservabilityLevel),</p>
<p>            new("Ef7h2K4z", "OrderPerformanceBudget", PolicyEffect.PerformanceBudget)</p>
<p>        },</p>
<p>        [typeof(OrderPlaced)] = new List<PolicyInfo> {</p>
<p>            new("Gh9j4M5a", "EventRoutingPolicy", PolicyEffect.Routing),</p>
<p>            new("Ij2k6N7b", "EventSerializationPolicy", PolicyEffect.Serialization)</p>
<p>        },</p>
<p>        [typeof(OrderSummaryProjection)] = new List<PolicyInfo> {</p>
<p>            new("Kl4m8P9c", "ProjectionLagPolicy", PolicyEffect.Performance),</p>
<p>            new("Mn6o2Q1d", "ProjectionPartitioningPolicy", PolicyEffect.Partitioning)</p>
<p>        }</p>
<p>    };</p>
<p>    </p>
<p>    // Reverse mapping for "what does this policy affect?"</p>
<p>    public static readonly Dictionary<string, List<AffectedType>> PolicyEffects = new() {</p>
<p>        ["Ab3d9F2x"] = new List<AffectedType> {</p>
<p>            new(typeof(Order), "Aggregate", "Sets concurrency to ExpectedVersion"),</p>
<p>            new(typeof(PlaceOrder), "Command", "Inherits aggregate concurrency"),</p>
<p>            new(typeof(UpdateOrder), "Command", "Inherits aggregate concurrency")</p>
<p>        }</p>
<p>    };</p>
<p>    </p>
<p>    // Policy evaluation paths for debugging</p>
<p>    public static readonly Dictionary<string, PolicyEvaluationPath> PolicyPaths = new() {</p>
<p>        ["Ab3d9F2x"] = new PolicyEvaluationPath {</p>
<p>            Conditions = new[] { "AggregateType == Order" },</p>
<p>            Actions = new[] { "SetConcurrencyStrategy(ExpectedVersion)" },</p>
<p>            Priority = 100,</p>
<p>            Source = "OrderConcurrencyPolicy.cs:line 15"</p>
<p>        }</p>
<p>    };</p>
<p>}</p>
<pre><code class="language-">
<h3>GitLens-Style IDE Experience</h3>

<strong>Visual Studio/Rider extension shows policy effects inline</strong>:

<p></code></pre>csharp{title="GitLens-Style IDE Experience" description="Visual Studio/Rider extension shows policy effects inline" category="Design" difficulty="ADVANCED" tags=["Design", "Policy-Engine", "IDE-Experience", "Visual-Annotations"] framework="NET8"}</p>
<p>// OrderAggregate.cs</p>
<p>public class Order : Aggregate { // 📋 3 policies affect this aggregate [hover for details]</p>
<p>    // PolicyLens: Ab3d9F2x (Concurrency: ExpectedVersion)</p>
<p>    // PolicyLens: Cd5e8G3y (Observability: Verbose for orders > $1000)  </p>
<p>    // PolicyLens: Ef7h2K4z (Performance Budget: 100ms max latency)</p>
<p>    </p>
<p>    public void PlaceOrder(CustomerId customerId, List<OrderItem> items) {</p>
<p>        // PolicyLens: This method triggers policies Ab3d9F2x, Gh9j4M5a</p>
<p>        Apply(new OrderPlaced(...));</p>
<p>    }</p>
<p>}</p>

<p>// OrderSummaryProjection.cs  </p>
<p>public class OrderSummaryProjection { // 📋 2 policies affect this projection</p>
<p>    // PolicyLens: Kl4m8P9c (Max lag: 5 minutes before alert)</p>
<p>    // PolicyLens: Mn6o2Q1d (Partitioned by CustomerId)</p>
<p>    </p>
<p>    public void Handle(OrderPlaced @event) { // PolicyLens: Routed by policy Gh9j4M5a</p>
<p>        // Update projection...</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Policy Debugging Commands</h3>

<strong>IDE commands for policy investigation</strong>:

<p></code></pre>csharp{title="Policy Debugging Commands" description="IDE commands for policy investigation" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Policy-Engine", "IDE-Commands", "Debugging"] framework="NET8"}</p>
<p>// Right-click on any type/method in IDE:</p>
<p>// > Whizbang: Show Affecting Policies</p>
<p>// > Whizbang: Trace Policy Evaluation  </p>
<p>// > Whizbang: Simulate Policy Changes</p>
<p>// > Whizbang: Show Policy History (git blame for policies)</p>

<p>// Command palette:</p>
<p>// > Whizbang: What policies affect Order aggregate?</p>
<p>// > Whizbang: What does policy Ab3d9F2x affect?</p>
<p>// > Whizbang: Show policy evaluation for PlaceOrder command</p>
<p>// > Whizbang: Compare policies between environments</p>
<pre><code class="language-">
<h3>Runtime Policy Debugging</h3>

<strong>Access policy decisions at runtime</strong>:

<p></code></pre>csharp{title="Runtime Policy Debugging" description="Runtime policy debugging middleware exposing policy decisions through HTTP headers" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Policy-Engine", "Runtime-Debugging", "HTTP-Headers"] framework="NET8"}</p>
<hr>
<p>public class PolicyDebugMiddleware {</p>
<p>    public async Task InvokeAsync(HttpContext context, RequestDelegate next) {</p>
<p>        // Inject policy debug header</p>
<p>        context.Response.OnStarting(() => {</p>
<p>            var messageContext = context.GetMessageContext();</p>
<p>            if (messageContext?.AppliedPolicies?.Any() == true) {</p>
<p>                var policyHashes = string.Join(",", </p>
<p>                    messageContext.AppliedPolicies.Select(p => p.PolicyHash));</p>
<p>                context.Response.Headers["X-Whizbang-Policies"] = policyHashes;</p>
<p>                </p>
<p>                // Debug mode: include full policy decisions</p>
<p>                if (context.Request.Headers.ContainsKey("X-Debug-Policies")) {</p>
<p>                    context.Response.Headers["X-Whizbang-Policy-Decisions"] = </p>
<p>                        JsonSerializer.Serialize(messageContext.PolicyDecisions);</p>
<p>                }</p>
<p>            }</p>
<p>            return Task.CompletedTask;</p>
<p>        });</p>
<p>        </p>
<p>        await next(context);</p>
<p>    }</p>
<p>}</p>

<p>// HTTP Response Headers:</p>
<p>// X-Whizbang-Policies: Ab3d9F2x,Cd5e8G3y,Ef7h2K4z</p>
<p>// X-Whizbang-Policy-Decisions: {"concurrency":"ExpectedVersion","observability":"Verbose"}</p>
<pre><code class="language-">
<h3>Policy Evaluation Pipeline</h3>

<p></code></pre>csharp{title="Policy Evaluation Pipeline" description="Policy evaluation pipeline with pre and post-execution action application" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Policy-Engine", "Pipeline", "Pre-Post-Execution"] framework="NET8"}</p>
<hr>
<p>public class PolicyEvaluationPipeline : IMessageInterceptor {</p>
<p>    private readonly IPolicyEngine _policyEngine;</p>
<p>    </p>
<p>    public async Task<TResponse> Intercept<TRequest, TResponse>(</p>
<p>        TRequest message,</p>
<p>        MessageContext context,</p>
<p>        MessageHandlerDelegate<TRequest, TResponse> next) {</p>
<p>        </p>
<p>        // Evaluate policies before handler execution</p>
<p>        var policyResult = await _policyEngine.EvaluateAsync(message, context);</p>
<p>        </p>
<p>        // Apply pre-execution actions</p>
<p>        foreach (var action in policyResult.PreExecutionActions) {</p>
<p>            await action.ExecuteAsync(message, context);</p>
<p>        }</p>
<p>        </p>
<p>        // Execute handler (might be changed by policy)</p>
<p>        var response = await next(message, context);</p>
<p>        </p>
<p>        // Apply post-execution actions</p>
<p>        foreach (var action in policyResult.PostExecutionActions) {</p>
<p>            await action.ExecuteAsync(response, context);</p>
<p>        }</p>
<p>        </p>
<p>        return response;</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Configuration Integration</h3>

<p></code></pre>csharp{title="Configuration Integration" description="Environment-based policy loading with configuration integration and team-specific policies" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Policy-Engine", "Configuration-Integration", "Environment-Based"] framework="NET8"}</p>
<hr>
<p>// Environment-based policy loading</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.Policies(policies => {</p>
<p>        // Load environment-specific policies</p>
<p>        if (_environment.IsProduction()) {</p>
<p>            policies.LoadFromConfiguration("Production");</p>
<p>            policies.Apply(WhizbangPolicies.ProductionSafetyPolicy);</p>
<p>        } else if (_environment.IsDevelopment()) {</p>
<p>            policies.LoadFromConfiguration("Development");</p>
<p>            policies.Apply(WhizbangPolicies.DevelopmentDebuggingPolicy);</p>
<p>        }</p>
<p>        </p>
<p>        // Load custom policies from configuration</p>
<p>        policies.LoadFromSection("CustomPolicies");</p>
<p>        </p>
<p>        // Team-specific canned policies</p>
<p>        policies.Apply(TeamPolicies.DataTeamStandardPolicies);</p>
<p>        policies.Apply(TeamPolicies.SecurityTeamCompliancePolicies);</p>
<p>    });</p>
<p>});</p>

<p>// Configuration example</p>
<p>{</p>
<p>  "Whizbang": {</p>
<p>    "Policies": {</p>
<p>      "Production": [</p>
<p>        {</p>
<p>          "Name": "ProductionDataScrubbing",</p>
<p>          "Condition": "HasFlag('Production') && HasTag('sensitive-data')",</p>
<p>          "Actions": [</p>
<p>            { "Type": "ScrubData", "Fields": ["SSN", "CreditCard"] },</p>
<p>            { "Type": "AddTag", "Value": "scrubbed" }</p>
<p>          ]</p>
<p>        }</p>
<p>      ]</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<p></code>``</p>

<h2>Best Practices</h2>

<h3>Policy Design Guidelines</h3>

<ul><li><strong>Keep policies focused</strong> - One policy per concern</li>
<li><strong>Use clear naming</strong> - Policy names should describe their purpose</li>
<li><strong>Document side effects</strong> - Policies can change behavior significantly</li>
<li><strong>Test policy interactions</strong> - Multiple policies can interact unexpectedly</li>
<li><strong>Monitor policy performance</strong> - Complex policies can impact performance</li>
</ul>
<h3>Flag Usage Guidelines</h3>

<ul><li><strong>Use library flags first</strong> - Prefer built-in flags over custom tags</li>
<li><strong>Document custom flags</strong> - Make user-defined flags clear to the team</li>
<li><strong>Be conservative with propagation</strong> - Not all flags should cross service boundaries</li>
<li><strong>Consider flag lifetime</strong> - How long should flags persist in the system</li>
<li><strong>Audit flag usage</strong> - Track which flags are used and where</li>
</ul>
<h3>Security Considerations</h3>

<ul><li><strong>Validate flag sources</strong> - Ensure flags come from trusted sources</li>
<li><strong>Limit dangerous flags</strong> - SecurityBypass should be heavily restricted</li>
<li><strong>Audit policy changes</strong> - Log all policy modifications</li>
<li><strong>Encrypt sensitive tags</strong> - Some tags may contain sensitive information</li>
<li><strong>Principle of least privilege</strong> - Policies should grant minimal necessary permissions</li>
</ul>
<hr>

<h2>Related Documentation</h2>

<ul><li><a href="./event-store-projections.md"><strong>Event Store & Projections</strong></a> - How policies affect storage and projections</li>
<li><a href="./domain-ownership.md"><strong>Domain Ownership</strong></a> - Policy-based routing and ownership</li>
<li><a href="./advanced-features.md"><strong>Advanced Features</strong></a> - Debugging and development tools integration</li></ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="proposals-projection-management" class="doc-section">
  <h2>Projection Management</h2>
  <p class="doc-path"><code>proposals/projection-management</code></p>
  <div class="doc-content">

<h1>Projection Management</h1>

<p>Whizbang provides comprehensive projection management including checkpoints, backfilling strategies, system events for on-demand rebuilds, and flexible storage options.</p>

<h2>Checkpoint Storage</h2>

<p>Projections track their progress through <strong>checkpoint storage</strong>, supporting multiple strategies:</p>

<h3>A. Same Database (Default)</h3>

<strong>Transactional consistency</strong> - checkpoints and projections updated together:

<p>``<code>csharp{title="Transactional Checkpoint Storage Configuration" description="Configuration for transactional checkpoint storage with projections" category="Design" difficulty="INTERMEDIATE" tags=["projections", "checkpoints", "configuration", "transactions"] framework="NET8"}</p>
<p>services.AddProjection<OrderSummaryProjection>(options => {</p>
<p>    options.CheckpointStorage = CheckpointStorage.SameDatabase;</p>
<p>});</p>

<p>// Implementation: Single transaction</p>
<p>await using var transaction = await database.BeginTransactionAsync();</p>
<p>await projectionStore.UpdateProjection(orderSummary, transaction);</p>
<p>await checkpointStore.SaveCheckpoint(position, transaction);</p>
<p>await transaction.CommitAsync();</p>
<pre><code class="language-">
<strong>Benefits</strong>:
<ul><li>✅ Exactly-once processing guarantee</li>
<li>✅ Simple consistency model</li>
<li>✅ No external dependencies</li>
</ul>
<strong>Drawbacks</strong>:
<ul><li>❌ Tight coupling to projection database</li>
<li>❌ Limited to single database systems</li>
</ul>
<h3>B. Separate Metadata Store</h3>

<strong>Flexible checkpoint storage</strong> separate from projection data:

<p></code></pre>csharp{title="Separate Checkpoint Storage Configuration" description="Configuration for separate checkpoint storage using Redis or other stores" category="Design" difficulty="INTERMEDIATE" tags=["projections", "checkpoints", "redis", "eventually-consistent"] framework="NET8"}</p>
<p>services.AddProjection<OrderSummaryProjection>(options => {</p>
<p>    options.CheckpointStorage = CheckpointStorage.Separate;</p>
<p>    options.CheckpointStore = CheckpointStore.Redis; // or CosmosDB, DynamoDB</p>
<p>});</p>

<p>// Implementation: Two-phase with compensation</p>
<p>try {</p>
<p>    await projectionStore.UpdateProjection(orderSummary);</p>
<p>    await checkpointStore.SaveCheckpoint(position);</p>
<p>} catch {</p>
<p>    // Compensation: projection will be updated again on replay</p>
<p>    // Idempotent handlers ensure correctness</p>
<p>}</p>
<pre><code class="language-">
<strong>Benefits</strong>:
<ul><li>✅ Optimized checkpoint storage (Redis, DynamoDB)</li>
<li>✅ Cross-database projections supported</li>
<li>✅ Better performance for high-throughput scenarios</li>
</ul>
<strong>Drawbacks</strong>:
<ul><li>❌ Eventually consistent</li>
<li>❌ Requires idempotent projection handlers</li>
</ul>
<h3>Checkpoint Configuration</h3>

<p></code></pre>csharp{title="Global Checkpoint Configuration" description="Global checkpoint configuration and storage options" category="Design" difficulty="INTERMEDIATE" tags=["projections", "configuration", "global-settings", "checkpoints"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.Projections(projections => {</p>
<p>        // Global checkpoint settings</p>
<p>        projections.DefaultCheckpointStorage = CheckpointStorage.SameDatabase;</p>
<p>        projections.CheckpointFrequency = CheckpointFrequency.EveryEvent; // or EveryNEvents(10)</p>
<p>        </p>
<p>        // Checkpoint stores</p>
<p>        projections.UseRedisCheckpoints("localhost:6379");</p>
<p>        projections.UseCosmosCheckpoints("connection-string");</p>
<p>        projections.UseSqlCheckpoints("connection-string");</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h2>Snapshot Management</h2>

<h3>A. Automatic Snapshots (Default)</h3>

<strong>Configurable automatic snapshotting</strong> for projections:

<p></code></pre>csharp{title="Automatic Snapshot Configuration" description="Automatic snapshot configuration with frequency and retention policies" category="Design" difficulty="INTERMEDIATE" tags=["projections", "snapshots", "automatic-management"] framework="NET8"}</p>
<p>services.AddProjection<CustomerSummaryProjection>(options => {</p>
<p>    options.Snapshots(snapshots => {</p>
<p>        snapshots.Strategy = SnapshotStrategy.Automatic;</p>
<p>        snapshots.Frequency = SnapshotFrequency.EveryNEvents(1000);</p>
<p>        snapshots.RetentionPolicy = SnapshotRetention.KeepLast(5);</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h3>B. Manual Snapshots</h3>

<strong>Developer-controlled snapshotting</strong>:

<p></code></pre>csharp{title="Manual Snapshot Control" description="Manual snapshot control with custom triggers and restoration logic" category="Design" difficulty="ADVANCED" tags=["projections", "snapshots", "manual-control", "triggers"] framework="NET8"}</p>
<p>public class CustomerSummaryProjection : IProjectionHandler<CustomerRegistered>,</p>
<p>                                        IProjectionHandler<CustomerUpdated>,</p>
<p>                                        ISnapshotProvider<CustomerSummarySnapshot> {</p>
<p>    </p>
<p>    public CustomerSummary State { get; private set; }</p>
<p>    </p>
<p>    public async Task Handle(CustomerRegistered @event, ProjectionContext context) {</p>
<p>        State = new CustomerSummary {</p>
<p>            CustomerId = @event.CustomerId,</p>
<p>            Name = @event.Name,</p>
<p>            Email = @event.Email,</p>
<p>            RegisteredAt = @event.RegisteredAt</p>
<p>        };</p>
<p>        </p>
<p>        await context.Store(@event.CustomerId.ToString(), State);</p>
<p>    }</p>
<p>    </p>
<p>    // Manual snapshot creation</p>
<p>    [Snapshot(TriggerOn = typeof(CustomerMilestoneReached))]</p>
<p>    public CustomerSummarySnapshot CreateSnapshot() {</p>
<p>        return new CustomerSummarySnapshot {</p>
<p>            CustomerId = State.CustomerId,</p>
<p>            Name = State.Name,</p>
<p>            TotalOrders = State.TotalOrders,</p>
<p>            LifetimeValue = State.LifetimeValue,</p>
<p>            SnapshotVersion = State.Version</p>
<p>        };</p>
<p>    }</p>
<p>    </p>
<p>    public void RestoreFromSnapshot(CustomerSummarySnapshot snapshot) {</p>
<p>        State = new CustomerSummary {</p>
<p>            CustomerId = snapshot.CustomerId,</p>
<p>            Name = snapshot.Name,</p>
<p>            TotalOrders = snapshot.TotalOrders,</p>
<p>            LifetimeValue = snapshot.LifetimeValue,</p>
<p>            Version = snapshot.SnapshotVersion</p>
<p>        };</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>C. No Snapshots</h3>

<strong>Opt out of snapshotting</strong> for simple projections:

<p></code></pre>csharp{title="Disable Snapshots Configuration" description="Disabling snapshots for simple projections that don't need them" category="Design" difficulty="BEGINNER" tags=["projections", "snapshots", "simple-projections"] framework="NET8"}</p>
<p>services.AddProjection<SimpleEventLogProjection>(options => {</p>
<p>    options.Snapshots(snapshots => {</p>
<p>        snapshots.Strategy = SnapshotStrategy.None;</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h2>Backfilling Strategies</h2>

<h3>A. Declarative Backfilling</h3>

<strong>Simple configuration-based backfilling</strong>:

<p></code></pre>csharp{title="Declarative Backfilling Configuration" description="Declarative backfilling configuration with date ranges and batch settings" category="Design" difficulty="INTERMEDIATE" tags=["projections", "backfilling", "declarative-configuration"] framework="NET8"}</p>
<p>services.AddProjection<OrderHistoryProjection>(options => {</p>
<p>    options.Backfill(backfill => {</p>
<p>        backfill.StartFrom = DateTimeOffset.Parse("2024-01-01");</p>
<p>        backfill.AutoStart = true;</p>
<p>        backfill.BatchSize = 1000;</p>
<p>        backfill.MaxConcurrency = 4;</p>
<p>    });</p>
<p>});</p>

<p>// Or backfill everything</p>
<p>services.AddProjection<NewAnalyticsProjection>(options => {</p>
<p>    options.BackfillFromBeginning();</p>
<p>});</p>
<pre><code class="language-">
<h3>B. Imperative Backfilling</h3>

<strong>Programmatic control over backfilling</strong>:

<p></code></pre>csharp{title="Programmatic Backfilling REST API" description="REST API controller for programmatic projection backfilling" category="Design" difficulty="INTERMEDIATE" tags=["projections", "backfilling", "rest-api", "controller"] framework="NET8"}</p>
<p>public class BackfillController : ControllerBase {</p>
<p>    private readonly IProjectionManager _projectionManager;</p>
<p>    </p>
<p>    [HttpPost("projections/{projectionName}/backfill")]</p>
<p>    public async Task<IActionResult> BackfillProjection(</p>
<p>        string projectionName,</p>
<p>        BackfillRequest request) {</p>
<p>        </p>
<p>        var options = new BackfillOptions {</p>
<p>            FromDate = request.FromDate,</p>
<p>            ToDate = request.ToDate,</p>
<p>            BatchSize = request.BatchSize ?? 1000,</p>
<p>            IsAtomic = request.IsAtomic ?? false,</p>
<p>            OnProgress = (progress) => {</p>
<p>                // Real-time progress updates via SignalR</p>
<p>                _hubContext.Clients.All.SendAsync("BackfillProgress", progress);</p>
<p>            }</p>
<p>        };</p>
<p>        </p>
<p>        var result = await _projectionManager.BackfillAsync(projectionName, options);</p>
<p>        return Ok(result);</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>System Events for On-Demand Backfilling</h3>

<strong>Event-driven backfill requests</strong>:

<p></code></pre>csharp{title="System Events for Backfilling" description="System events for on-demand projection backfilling with criteria" category="Design" difficulty="ADVANCED" tags=["projections", "system-events", "event-driven-backfill"] framework="NET8"}</p>
<p>// System event to trigger backfilling</p>
<p>public record ProjectionBackfillRequested(</p>
<p>    string ProjectionName,</p>
<p>    DateTimeOffset? FromDate,</p>
<p>    DateTimeOffset? ToDate,</p>
<p>    bool IsAtomic,</p>
<p>    BackfillCriteria Criteria,</p>
<p>    string RequestedBy</p>
<p>) : ISystemEvent;</p>

<p></code>`<code>csharp{title="Backfill System Event Handler" description="System event handler for processing backfill requests" category="Design" difficulty="ADVANCED" tags=["projections", "system-events", "event-handlers", "backfilling"] framework="NET8"}</p>
<p>// System event handler</p>
<p>public class ProjectionBackfillHandler : ISystemEventHandler<ProjectionBackfillRequested> {</p>
<p>    public async Task Handle(ProjectionBackfillRequested @event, SystemEventContext context) {</p>
<p>        var options = new BackfillOptions {</p>
<p>            FromDate = @event.FromDate,</p>
<p>            ToDate = @event.ToDate,</p>
<p>            IsAtomic = @event.IsAtomic,</p>
<p>            Criteria = @event.Criteria,</p>
<p>            RequestId = context.CorrelationId</p>
<p>        };</p>
<p>        </p>
<p>        await _projectionManager.BackfillAsync(@event.ProjectionName, options);</p>
<p>        </p>
<p>        // Emit completion event</p>
<p>        await context.PublishSystemEvent(new ProjectionBackfillCompleted(</p>
<p>            @event.ProjectionName,</p>
<p>            options.FromDate,</p>
<p>            options.ToDate,</p>
<p>            context.CorrelationId</p>
<p>        ));</p>
<p>    }</p>
<p>}</p>

<p>// Trigger backfill via system event</p>
<p>await _systemEventPublisher.PublishAsync(new ProjectionBackfillRequested(</p>
<p>    ProjectionName: "order-summary",</p>
<p>    FromDate: DateTimeOffset.Parse("2024-01-01"),</p>
<p>    ToDate: null, // To current</p>
<p>    IsAtomic: true,</p>
<p>    Criteria: BackfillCriteria.FullRebuild,</p>
<p>    RequestedBy: "admin-user"</p>
<p>));</p>
<pre><code class="language-">
<h3>Backfill Criteria Options</h3>

<p></code></pre>csharp{title="Backfill Criteria Options" description="Comprehensive backfill criteria options for different scenarios" category="Design" difficulty="INTERMEDIATE" tags=["projections", "backfilling", "criteria-options"] framework="NET8"}</p>
<p>public enum BackfillCriteria {</p>
<p>    // Date-based backfill</p>
<p>    DateRange,              // Specific date range</p>
<p>    FromDate,               // From date to current</p>
<p>    LastNDays,              // Last N days only</p>
<p>    </p>
<p>    // Event-based backfill  </p>
<p>    EventNumberRange,       // Specific event number range</p>
<p>    FromEventNumber,        // From event number to current</p>
<p>    LastNEvents,            // Last N events only</p>
<p>    </p>
<p>    // Full rebuild options</p>
<p>    FullRebuild,            // Complete rebuild from beginning</p>
<p>    IncrementalUpdate,      // Only missing/updated events</p>
<p>    </p>
<p>    // Custom criteria</p>
<p>    CustomPredicate         // Custom filter expression</p>
<p>}</p>

<p>// Usage examples</p>
<p>services.AddProjection<OrderSummaryProjection>(options => {</p>
<p>    options.Backfill(backfill => {</p>
<p>        backfill.Criteria = BackfillCriteria.LastNDays;</p>
<p>        backfill.CriteriaValue = 30; // Last 30 days</p>
<p>    });</p>
<p>});</p>

<p>// System event with custom criteria</p>
<p>await _systemEvents.PublishAsync(new ProjectionBackfillRequested(</p>
<p>    ProjectionName: "analytics",</p>
<p>    FromDate: null,</p>
<p>    ToDate: null,</p>
<p>    IsAtomic: false,</p>
<p>    Criteria: BackfillCriteria.CustomPredicate,</p>
<p>    RequestedBy: "system"</p>
<p>) {</p>
<p>    CustomPredicate = @event => @event.EventType.StartsWith("Order") && </p>
<p>                               @event.Metadata["source"] == "web-api"</p>
<p>});</p>
<pre><code class="language-">
<h2>Advanced Backfill Features</h2>

<h3>Parallel Processing</h3>

<p></code></pre>csharp{title="Parallel Backfill Processing" description="Parallel backfill processing with partitioning and concurrency control" category="Design" difficulty="ADVANCED" tags=["projections", "backfilling", "parallel-processing", "concurrency"] framework="NET8"}</p>
<p>services.AddProjection<AnalyticsProjection>(options => {</p>
<p>    options.Backfill(backfill => {</p>
<p>        backfill.Strategy = BackfillStrategy.Parallel;</p>
<p>        backfill.PartitionBy = @event => @event.StreamId.GetHashCode() % 8;</p>
<p>        backfill.MaxConcurrency = 8;</p>
<p>        backfill.BatchSize = 500;</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h3>Progress Tracking</h3>

<p></code></pre>csharp{title="Backfill Progress Tracking" description="Real-time progress tracking for backfill operations" category="Design" difficulty="INTERMEDIATE" tags=["projections", "backfilling", "progress-tracking"] framework="NET8"}</p>
<p>public class BackfillProgressTracker {</p>
<p>    public async Task TrackProgress(string projectionName, CancellationToken cancellationToken) {</p>
<p>        await foreach (var progress in _projectionManager.GetBackfillProgress(projectionName, cancellationToken)) {</p>
<p>            Console.WriteLine($"Backfill progress: {progress.EventsProcessed}/{progress.TotalEvents} " +</p>
<p>                            $"({progress.PercentComplete:F1}%) - ETA: {progress.EstimatedTimeRemaining}");</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Rollback Support</h3>

<p></code></pre>csharp{title="Backfill Rollback Support" description="Rollback support for failed backfill operations with backup creation" category="Design" difficulty="ADVANCED" tags=["projections", "backfilling", "rollback-support", "backup"] framework="NET8"}</p>
<p>// Rollback to previous version if backfill fails</p>
<p>services.AddProjection<OrderSummaryProjection>(options => {</p>
<p>    options.Backfill(backfill => {</p>
<p>        backfill.EnableRollback = true;</p>
<p>        backfill.RollbackOnFailure = true;</p>
<p>        backfill.CreateBackupBeforeBackfill = true;</p>
<p>    });</p>
<p>});</p>

<p>// Manual rollback API</p>
<p>await _projectionManager.RollbackProjection("order-summary", toVersion: previousVersion);</p>
<pre><code class="language-">
<h2>System Event Integration</h2>

<h3>Built-in System Events</h3>

<p></code></pre>csharp{title="Projection Lifecycle System Events" description="Built-in system events for projection lifecycle monitoring" category="Design" difficulty="INTERMEDIATE" tags=["projections", "system-events", "lifecycle-management"] framework="NET8"}</p>
<p>// Projection lifecycle events</p>
<p>public record ProjectionStarted(string ProjectionName, DateTimeOffset StartedAt);</p>
<p>public record ProjectionStopped(string ProjectionName, DateTimeOffset StoppedAt);</p>
<p>public record ProjectionFailed(string ProjectionName, Exception Error, DateTimeOffset FailedAt);</p>

<p>// Backfill events</p>
<p>public record ProjectionBackfillStarted(string ProjectionName, BackfillOptions Options);</p>
<p>public record ProjectionBackfillProgress(string ProjectionName, BackfillProgress Progress);</p>
<p>public record ProjectionBackfillCompleted(string ProjectionName, BackfillResult Result);</p>
<p>public record ProjectionBackfillFailed(string ProjectionName, Exception Error);</p>

<p>// Checkpoint events</p>
<p>public record ProjectionCheckpointSaved(string ProjectionName, long Position);</p>
<p>public record ProjectionCheckpointRestored(string ProjectionName, long Position);</p>

<p>// Snapshot events</p>
<p>public record ProjectionSnapshotCreated(string ProjectionName, long EventVersion);</p>
<p>public record ProjectionSnapshotRestored(string ProjectionName, long EventVersion);</p>
<pre><code class="language-">
<h3>Custom System Event Handlers</h3>

<p></code></pre>csharp{title="Projection Monitoring Event Handlers" description="Custom system event handlers for projection monitoring and alerting" category="Design" difficulty="ADVANCED" tags=["projections", "system-events", "monitoring", "alerting"] framework="NET8"}</p>
<p>public class ProjectionMonitoringHandler : </p>
<p>    ISystemEventHandler<ProjectionFailed>,</p>
<p>    ISystemEventHandler<ProjectionBackfillCompleted> {</p>
<p>    </p>
<p>    public async Task Handle(ProjectionFailed @event, SystemEventContext context) {</p>
<p>        // Alert on projection failures</p>
<p>        await _alerting.SendAlert($"Projection {@event.ProjectionName} failed: {@event.Error.Message}");</p>
<p>        </p>
<p>        // Automatic retry for transient failures</p>
<p>        if (IsTransientError(@event.Error)) {</p>
<p>            await context.PublishSystemEvent(new ProjectionRestartRequested(</p>
<p>                @event.ProjectionName,</p>
<p>                retryAttempt: context.GetRetryAttempt() + 1</p>
<p>            ));</p>
<p>        }</p>
<p>    }</p>
<p>    </p>
<p>    public async Task Handle(ProjectionBackfillCompleted @event, SystemEventContext context) {</p>
<p>        // Update projection metadata</p>
<p>        await _projectionMetadata.MarkBackfillComplete(@event.ProjectionName, @event.Result);</p>
<p>        </p>
<p>        // Notify stakeholders</p>
<p>        await _notifications.NotifyBackfillComplete(@event.ProjectionName);</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>API Reference</h2>

<h3>IProjectionManager Interface</h3>

<p></code></pre>csharp{title="IProjectionManager Interface" description="Comprehensive projection management API interface" category="Design" difficulty="INTERMEDIATE" tags=["projections", "management-api", "interfaces"] framework="NET8"}</p>
<p>public interface IProjectionManager {</p>
<p>    // Lifecycle management</p>
<p>    Task StartProjection(string projectionName);</p>
<p>    Task StopProjection(string projectionName);</p>
<p>    Task RestartProjection(string projectionName);</p>
<p>    </p>
<p>    // Backfilling</p>
<p>    Task<BackfillResult> BackfillAsync(string projectionName, BackfillOptions options);</p>
<p>    IAsyncEnumerable<BackfillProgress> GetBackfillProgress(string projectionName, CancellationToken cancellationToken);</p>
<p>    Task CancelBackfill(string projectionName);</p>
<p>    </p>
<p>    // Snapshots</p>
<p>    Task<SnapshotResult> CreateSnapshot(string projectionName);</p>
<p>    Task<SnapshotResult> RestoreFromSnapshot(string projectionName, long snapshotVersion);</p>
<p>    Task<IEnumerable<SnapshotInfo>> GetSnapshots(string projectionName);</p>
<p>    </p>
<p>    // Checkpoints</p>
<p>    Task<long> GetCurrentCheckpoint(string projectionName);</p>
<p>    Task ResetCheckpoint(string projectionName, long position);</p>
<p>    </p>
<p>    // Status and monitoring</p>
<p>    Task<ProjectionStatus> GetStatus(string projectionName);</p>
<p>    Task<IEnumerable<ProjectionInfo>> GetAllProjections();</p>
<p>    Task<ProjectionHealth> GetHealth(string projectionName);</p>
<p>}</p>
<pre><code class="language-">
<h3>Configuration Extensions</h3>

<p></code></pre>csharp{title="Projection Configuration Extensions" description="Extension methods for fluent projection configuration API" category="Design" difficulty="INTERMEDIATE" tags=["projections", "extension-methods", "fluent-api"] framework="NET8"}</p>
<p>public static class ProjectionConfigurationExtensions {</p>
<p>    public static IProjectionBuilder<T> BackfillFromBeginning<T>(this IProjectionBuilder<T> builder) </p>
<p>        where T : class;</p>
<p>    </p>
<p>    public static IProjectionBuilder<T> BackfillFrom<T>(this IProjectionBuilder<T> builder, DateTimeOffset from) </p>
<p>        where T : class;</p>
<p>    </p>
<p>    public static IProjectionBuilder<T> WithSnapshots<T>(this IProjectionBuilder<T> builder, </p>
<p>        Action<SnapshotConfiguration> configure) where T : class;</p>
<p>    </p>
<p>    public static IProjectionBuilder<T> WithCheckpoints<T>(this IProjectionBuilder<T> builder, </p>
<p>        Action<CheckpointConfiguration> configure) where T : class;</p>
<p>    </p>
<p>    public static IProjectionBuilder<T> OnSystemEvent<T, TEvent>(this IProjectionBuilder<T> builder, </p>
<p>        Func<TEvent, Task> handler) where T : class where TEvent : ISystemEvent;</p>
<p>}</p>
<p></code>``</p>

<h2>Best Practices</h2>

<h3>Projection Design</h3>

<ul><li><strong>Keep projections focused</strong> - One projection per query need</li>
<li><strong>Make handlers idempotent</strong> - Support replay scenarios</li>
<li><strong>Handle missing data gracefully</strong> - Events may be out of order</li>
<li><strong>Version projection schemas</strong> - Enable evolution over time</li>
</ul>
<h3>Backfill Planning</h3>

<ul><li><strong>Test backfills in staging</strong> - Verify performance and correctness</li>
<li><strong>Use atomic rebuilds</strong> for critical projections</li>
<li><strong>Monitor resource usage</strong> during large backfills</li>
<li><strong>Plan for rollback scenarios</strong> if backfill fails</li>
</ul>
<h3>Checkpoint Strategy</h3>

<ul><li><strong>Use same-database checkpoints</strong> for consistency-critical projections</li>
<li><strong>Use separate checkpoints</strong> for high-throughput scenarios</li>
<li><strong>Checkpoint frequently</strong> to minimize replay overhead</li>
<li><strong>Monitor checkpoint lag</strong> for early failure detection</li>
</ul>
<hr>

<h2>Related Documentation</h2>

<ul><li><a href="./event-store-projections.md"><strong>Event Store & Projections</strong></a> - Core storage architecture</li>
<li><a href="./multi-tenancy.md"><strong>Multi-Tenancy</strong></a> - Tenant-aware projection management</li>
<li><a href="./performance-optimization.md"><strong>Performance Optimization</strong></a> - Scaling projection processing</li></ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="proposals-schema-evolution" class="doc-section">
  <h2>Schema Evolution &amp; Event Versioning</h2>
  <p class="doc-path"><code>proposals/schema-evolution</code></p>
  <div class="doc-content">

<h1>Schema Evolution & Event Versioning</h1>

<p>Whizbang provides robust schema evolution capabilities using JSONB storage and flexible driver interfaces, allowing events and projections to evolve over time without breaking existing systems.</p>

<h2>JSONB-Based Schema Evolution</h2>

<h3>Flexible Event Schema</h3>

<p>Events stored in <strong>JSONB format</strong> naturally support schema evolution:</p>

<p>``<code>csharp{title="Event Schema Evolution" description="Event schema evolution from V1 to V3 with backward-compatible changes" category="Design" difficulty="INTERMEDIATE" tags=["Schema-Evolution", "Event-Versioning", "Backward-Compatibility"] framework="NET8"}</p>
<p>// V1 Event</p>
<p>public record OrderPlaced(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId</p>
<p>);</p>

<p>// V2 Event - Add field (backward compatible)</p>
<p>public record OrderPlaced(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    DateTimeOffset? PlacedAt = null  // Optional for backward compatibility</p>
<p>);</p>

<p>// V3 Event - Add collection (backward compatible)</p>
<p>public record OrderPlaced(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    DateTimeOffset? PlacedAt = null,</p>
<p>    List<string> Tags = null         // Null-safe collection</p>
<p>) {</p>
<p>    // Ensure collections are never null</p>
<p>    public List<string> Tags { get; init; } = Tags ?? new List<string>();</p>
<p>}</p>
<pre><code class="language-">
<strong>JSONB benefits</strong>:
<ul><li>✅ Missing fields handled gracefully</li>
<li>✅ Extra fields ignored during deserialization</li>
<li>✅ No database schema migrations required</li>
<li>✅ Query flexibility with JSON operators</li>
</ul>
<h3>Projection Schema Evolution</h3>

<p>Projections can evolve independently of events:</p>

<p></code></pre>csharp{title="Projection Schema Evolution" description="Projection schema evolution without database migrations using JSONB" category="Design" difficulty="INTERMEDIATE" tags=["Schema-Evolution", "Projections", "JSONB-Storage"] framework="NET8"}</p>
<p>// V1 Projection</p>
<p>public class OrderSummary {</p>
<p>    public Guid OrderId { get; set; }</p>
<p>    public decimal Total { get; set; }</p>
<p>    public OrderStatus Status { get; set; }</p>
<p>}</p>

<p>// V2 Projection - Add fields without migration</p>
<p>public class OrderSummary {</p>
<p>    public Guid OrderId { get; set; }</p>
<p>    public decimal Total { get; set; }</p>
<p>    public OrderStatus Status { get; set; }</p>
<p>    </p>
<p>    // New fields with sensible defaults</p>
<p>    public DateTime EstimatedDelivery { get; set; } = DateTime.MinValue;</p>
<p>    public List<string> Tags { get; set; } = new();</p>
<p>    public CustomerInfo Customer { get; set; } = new();</p>
<p>}</p>

<p>// Projection rebuild handles missing data gracefully</p>
<p>public class OrderSummaryProjection : IProjectionHandler<OrderPlaced> {</p>
<p>    public async Task Handle(OrderPlaced @event, ProjectionContext context) {</p>
<p>        var summary = await context.Load<OrderSummary>(@event.OrderId.ToString()) </p>
<p>                      ?? new OrderSummary();</p>
<p>        </p>
<p>        summary.OrderId = @event.OrderId;</p>
<p>        summary.Total = @event.Total;</p>
<p>        </p>
<p>        // Handle optional V2+ fields</p>
<p>        if (@event.PlacedAt.HasValue) {</p>
<p>            summary.EstimatedDelivery = @event.PlacedAt.Value.AddDays(7);</p>
<p>        }</p>
<p>        </p>
<p>        if (@event.Tags?.Any() == true) {</p>
<p>            summary.Tags = @event.Tags;</p>
<p>        }</p>
<p>        </p>
<p>        await context.Store(@event.OrderId.ToString(), summary);</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Event Versioning Strategies</h2>

<h3>A. Upcasting (Recommended)</h3>

<strong>Convert old events to new schema on read</strong>:

<p></code></pre>csharp{title="Event Upcaster Interface" description="Event upcasting interface for converting old events to new schemas" category="Design" difficulty="ADVANCED" tags=["Schema-Evolution", "Upcasting", "Event-Transformation", "Interface"] framework="NET8"}</p>
<p>public interface IEventUpcaster<TOld, TNew> {</p>
<p>    TNew Upcast(TOld oldEvent);</p>
<p>    bool CanUpcast(Type eventType, int version);</p>
<p>}</p>

<p></code>`<code>csharp{title="Concrete Upcaster Implementation" description="Concrete upcaster implementation for event version migration" category="Design" difficulty="ADVANCED" tags=["Schema-Evolution", "Upcasting", "Implementation", "Registration"] framework="NET8"}</p>
<p>// Upcast V1 OrderPlaced to V2</p>
<p>public class OrderPlacedV1ToV2Upcaster : IEventUpcaster<OrderPlacedV1, OrderPlaced> {</p>
<p>    public OrderPlaced Upcast(OrderPlacedV1 oldEvent) {</p>
<p>        return new OrderPlaced(</p>
<p>            oldEvent.OrderId,</p>
<p>            oldEvent.CustomerId,</p>
<p>            PlacedAt: DateTimeOffset.UtcNow, // Best guess for missing data</p>
<p>            Tags: new List<string>()         // Default to empty</p>
<p>        );</p>
<p>    }</p>
<p>    </p>
<p>    public bool CanUpcast(Type eventType, int version) {</p>
<p>        return eventType == typeof(OrderPlacedV1) && version == 1;</p>
<p>    }</p>
<p>}</p>

<p>// Registration</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.EventVersioning(versioning => {</p>
<p>        versioning.AddUpcaster<OrderPlacedV1ToV2Upcaster>();</p>
<p>        versioning.AddUpcaster<OrderPlacedV2ToV3Upcaster>();</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h3>B. Multiple Versions Supported Simultaneously</h3>

<strong>Keep multiple event versions active</strong>:

<p></code></pre>csharp{title="Multiple Version Handlers" description="Supporting multiple event versions simultaneously with separate handlers" category="Design" difficulty="ADVANCED" tags=["Schema-Evolution", "Multiple-Versions", "Event-Handlers", "Registration"] framework="NET8"}</p>
<p>// Multiple handlers for different versions</p>
<p>public class OrderPlacedV1Handler : IEventHandler<OrderPlacedV1> {</p>
<p>    public async Task Handle(OrderPlacedV1 @event, EventContext context) {</p>
<p>        // Handle legacy V1 events</p>
<p>        var order = await _repository.Load<Order>(@event.OrderId);</p>
<p>        order.MarkAsPlaced(placedAt: DateTimeOffset.UtcNow); // Default timestamp</p>
<p>        await _repository.Save(order);</p>
<p>    }</p>
<p>}</p>

<p>public class OrderPlacedV2Handler : IEventHandler<OrderPlaced> {</p>
<p>    public async Task Handle(OrderPlaced @event, EventContext context) {</p>
<p>        // Handle current V2+ events</p>
<p>        var order = await _repository.Load<Order>(@event.OrderId);</p>
<p>        order.MarkAsPlaced(@event.PlacedAt ?? DateTimeOffset.UtcNow);</p>
<p>        await _repository.Save(order);</p>
<p>    }</p>
<p>}</p>

<p>// Router determines which handler to use based on event version</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.EventVersioning(versioning => {</p>
<p>        versioning.RouteByVersion = true;</p>
<p>        versioning.RegisterHandler<OrderPlacedV1Handler>(version: 1);</p>
<p>        versioning.RegisterHandler<OrderPlacedV2Handler>(version: 2);</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h3>C. Schema Registry</h3>

<strong>Centralized schema management</strong>:

<p></code></pre>csharp{title="Schema Registry Configuration" description="Centralized schema registry configuration for schema management" category="Design" difficulty="ADVANCED" tags=["Schema-Evolution", "Schema-Registry", "Centralized-Management", "Configuration"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.EventVersioning(versioning => {</p>
<p>        versioning.UseSchemaRegistry(registry => {</p>
<p>            registry.ConnectionString = "https://schema-registry.company.com";</p>
<p>            registry.AutoRegisterSchemas = true;</p>
<p>            registry.ValidateOnWrite = true;</p>
<p>            registry.CompatibilityLevel = CompatibilityLevel.Backward;</p>
<p>        });</p>
<p>    });</p>
<p>});</p>

<p>// Events automatically registered with schema registry</p>
<p>[SchemaRegistration(subject: "order-placed", version: 2)]</p>
<p>public record OrderPlaced(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    DateTimeOffset? PlacedAt = null</p>
<p>);</p>
<pre><code class="language-">
<h2>Driver Interface for Schema Evolution</h2>

<h3>Abstract Driver Interface</h3>

<p></code></pre>csharp{title="Schema Evolution Driver Interface" description="Driver interface for schema evolution with versioning and upcasting support" category="Design" difficulty="ADVANCED" tags=["Schema-Evolution", "Driver-Interface", "Serialization", "Versioning"] framework="NET8"}</p>
<p>public interface ISchemaEvolutionDriver {</p>
<p>    // Serialization with versioning</p>
<p>    Task<byte[]> Serialize<T>(T @event, int? version = null);</p>
<p>    Task<T> Deserialize<T>(byte[] data, int version);</p>
<p>    Task<object> DeserializeToLatestVersion(byte[] data, Type eventType, int storedVersion);</p>
<p>    </p>
<p>    // Schema registration</p>
<p>    Task RegisterSchema(Type eventType, int version);</p>
<p>    Task<SchemaInfo> GetSchema(Type eventType, int version);</p>
<p>    Task<IEnumerable<SchemaInfo>> GetSchemaEvolution(Type eventType);</p>
<p>    </p>
<p>    // Upcasting support</p>
<p>    Task<T> UpcastToLatest<T>(object oldEvent, int fromVersion);</p>
<p>    bool CanUpcast(Type eventType, int fromVersion, int toVersion);</p>
<p>}</p>

<p>public class SchemaInfo {</p>
<p>    public Type EventType { get; set; }</p>
<p>    public int Version { get; set; }</p>
<p>    public string Schema { get; set; }</p>
<p>    public DateTime RegisteredAt { get; set; }</p>
<p>    public CompatibilityLevel Compatibility { get; set; }</p>
<p>}</p>
<pre><code class="language-">
<h3>PostgreSQL JSONB Driver Implementation</h3>

<p></code></pre>csharp{title="PostgreSQL Schema Evolution Driver" description="PostgreSQL JSONB implementation of schema evolution driver with serialization and upcasting" category="Design" difficulty="ADVANCED" tags=["Schema-Evolution", "PostgreSQL", "JSONB-Implementation", "Driver"] framework="NET8"}</p>
<p>public class PostgresSchemaEvolutionDriver : ISchemaEvolutionDriver {</p>
<p>    public async Task<byte[]> Serialize<T>(T @event, int? version = null) {</p>
<p>        var eventType = typeof(T);</p>
<p>        var currentVersion = version ?? await GetLatestVersion(eventType);</p>
<p>        </p>
<p>        var eventData = new {</p>
<p>            EventType = eventType.FullName,</p>
<p>            Version = currentVersion,</p>
<p>            Data = @event</p>
<p>        };</p>
<p>        </p>
<p>        return JsonSerializer.SerializeToUtf8Bytes(eventData);</p>
<p>    }</p>
<p>    </p>
<p>    public async Task<T> Deserialize<T>(byte[] data, int version) {</p>
<p>        var eventData = JsonSerializer.Deserialize<dynamic>(data);</p>
<p>        var storedVersion = (int)eventData.Version;</p>
<p>        </p>
<p>        if (storedVersion == version) {</p>
<p>            return JsonSerializer.Deserialize<T>(eventData.Data);</p>
<p>        }</p>
<p>        </p>
<p>        // Need to upcast</p>
<p>        var oldEvent = DeserializeToVersion(eventData.Data, typeof(T), storedVersion);</p>
<p>        return await UpcastToLatest<T>(oldEvent, storedVersion);</p>
<p>    }</p>
<p>    </p>
<p>    public async Task<object> DeserializeToLatestVersion(byte[] data, Type eventType, int storedVersion) {</p>
<p>        var latestVersion = await GetLatestVersion(eventType);</p>
<p>        </p>
<p>        if (storedVersion == latestVersion) {</p>
<p>            // Already latest version</p>
<p>            return JsonSerializer.Deserialize(data, eventType);</p>
<p>        }</p>
<p>        </p>
<p>        // Upcast to latest</p>
<p>        var oldEvent = DeserializeToVersion(data, eventType, storedVersion);</p>
<p>        return await UpcastToLatest(oldEvent, eventType, storedVersion, latestVersion);</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>LINQ Support Evolution</h2>

<h3>Driver-Specific LINQ Implementation</h3>

<p></code></pre>csharp{title="Query Evolution Driver Interface" description="Driver interface for schema-aware LINQ querying across versions" category="Design" difficulty="ADVANCED" tags=["Schema-Evolution", "LINQ-Support", "Querying", "Interface"] framework="NET8"}</p>
<p>public interface IQueryEvolutionDriver {</p>
<p>    IQueryable<T> Query<T>() where T : class;</p>
<p>    IQueryable<T> QueryVersion<T>(int version) where T : class;</p>
<p>    IQueryable<object> QueryAllVersions(Type eventType);</p>
<p>}</p>

<p></code>`<code>csharp{title="PostgreSQL Query Driver Implementation" description="PostgreSQL implementation with JSONB operators for evolved schemas" category="Design" difficulty="ADVANCED" tags=["Schema-Evolution", "PostgreSQL", "JSONB-Queries", "EF-Core"] framework="NET8"}</p>
<p>// PostgreSQL implementation with JSONB operators</p>
<p>public class PostgresQueryDriver : IQueryEvolutionDriver {</p>
<p>    public IQueryable<T> Query<T>() where T : class {</p>
<p>        return _context.Events</p>
<p>            .Where(e => e.EventType == typeof(T).Name)</p>
<p>            .Select(e => JsonSerializer.Deserialize<T>(e.EventData))</p>
<p>            .AsQueryable();</p>
<p>    }</p>
<p>    </p>
<p>    // JSONB path queries for evolved schemas</p>
<p>    public IQueryable<OrderSummary> QueryOrdersWithTags() {</p>
<p>        return _context.Projections</p>
<p>            .Where(p => p.ProjectionName == "order-summary")</p>
<p>            .Where(p => EF.Functions.JsonExists(p.Document, "$.Tags"))  // Has tags field</p>
<p>            .Select(p => JsonSerializer.Deserialize<OrderSummary>(p.Document))</p>
<p>            .AsQueryable();</p>
<p>    }</p>
<p>    </p>
<p>    // Query across schema versions</p>
<p>    public IQueryable<decimal> QueryOrderTotals() {</p>
<p>        return _context.Events</p>
<p>            .Where(e => e.EventType == "OrderPlaced")</p>
<p>            .Select(e => EF.Functions.JsonExtract<decimal>(e.EventData, "$.Total"))</p>
<p>            .AsQueryable();</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Schema-Aware Query Extensions</h3>

<p></code></pre>csharp{title="Schema-Aware Query Extensions" description="Extension methods for schema-aware querying and filtering across versions" category="Design" difficulty="INTERMEDIATE" tags=["Schema-Evolution", "LINQ-Extensions", "Query-Helpers", "Extensions"] framework="NET8"}</p>
<p>public static class SchemaQueryExtensions {</p>
<p>    public static IQueryable<T> WhereSchemaVersion<T>(this IQueryable<T> query, int version) {</p>
<p>        // Filter by schema version</p>
<p>        return query.Where(/<em> version filter logic </em>/);</p>
<p>    }</p>
<p>    </p>
<p>    public static IQueryable<T> WhereHasField<T>(this IQueryable<T> query, string fieldPath) {</p>
<p>        // Filter by field existence (JSONB support)</p>
<p>        return query.Where(/<em> field existence logic </em>/);</p>
<p>    }</p>
<p>    </p>
<p>    public static IQueryable<TResult> SelectEvolved<T, TResult>(</p>
<p>        this IQueryable<T> query, </p>
<p>        Expression<Func<T, TResult>> selector,</p>
<p>        SchemaEvolutionOptions options = null) {</p>
<p>        // Schema-aware projection</p>
<p>        return query.Select(/<em> evolved selector logic </em>/);</p>
<p>    }</p>
<p>}</p>

<p>// Usage</p>
<p>var recentOrdersWithTags = await _context.Query<OrderSummary>()</p>
<p>    .WhereHasField("Tags")</p>
<p>    .Where(o => o.PlacedAt > DateTime.UtcNow.AddDays(-30))</p>
<p>    .ToListAsync();</p>
<pre><code class="language-">
<h2>Blue/Green Deployment Support</h2>

<h3>Driver-Level Blue/Green Implementation</h3>

<p></code></pre>csharp{title="Blue/Green Deployment Driver" description="Driver interface and implementation for blue/green projection deployments" category="Design" difficulty="ADVANCED" tags=["Schema-Evolution", "Blue-Green-Deployment", "Driver-Interface", "PostgreSQL"] framework="NET8"}</p>
<p>public interface IBlueGreenDriver {</p>
<p>    Task<string> CreateGreenDeployment(string projectionName);</p>
<p>    Task BuildGreenProjection(string projectionName, string greenVersion);</p>
<p>    Task ValidateGreenProjection(string projectionName, string greenVersion);</p>
<p>    Task SwitchToGreen(string projectionName, string greenVersion);</p>
<p>    Task CleanupBlueVersion(string projectionName);</p>
<p>}</p>

<p>public class PostgresBlueGreenDriver : IBlueGreenDriver {</p>
<p>    public async Task<string> CreateGreenDeployment(string projectionName) {</p>
<p>        var greenVersion = Guid.NewGuid().ToString("N")[..8];</p>
<p>        var greenTableName = $"{projectionName}_green_{greenVersion}";</p>
<p>        </p>
<p>        // Create green table with same schema as blue</p>
<p>        await _connection.ExecuteAsync($"""</p>
<p>            CREATE TABLE {greenTableName} (LIKE {projectionName} INCLUDING ALL);</p>
<p>            CREATE INDEX CONCURRENTLY idx_{greenTableName}_tenant </p>
<p>                ON {greenTableName}(tenant_id) WHERE tenant_id IS NOT NULL;</p>
<p>        """);</p>
<p>        </p>
<p>        return greenVersion;</p>
<p>    }</p>
<p>    </p>
<p>    public async Task BuildGreenProjection(string projectionName, string greenVersion) {</p>
<p>        var greenTableName = $"{projectionName}_green_{greenVersion}";</p>
<p>        </p>
<p>        // Rebuild projection in green table from events</p>
<p>        await _projectionBuilder.RebuildInTable(projectionName, greenTableName);</p>
<p>    }</p>
<p>    </p>
<p>    public async Task SwitchToGreen(string projectionName, string greenVersion) {</p>
<p>        var greenTableName = $"{projectionName}_green_{greenVersion}";</p>
<p>        var blueBackupName = $"{projectionName}_blue_backup_{DateTimeOffset.UtcNow:yyyyMMdd_HHmmss}";</p>
<p>        </p>
<p>        // Atomic table swap</p>
<p>        await _connection.ExecuteAsync($"""</p>
<p>            BEGIN;</p>
<p>            ALTER TABLE {projectionName} RENAME TO {blueBackupName};</p>
<p>            ALTER TABLE {greenTableName} RENAME TO {projectionName};</p>
<p>            COMMIT;</p>
<p>        """);</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Configuration and Best Practices</h2>

<h3>Comprehensive Schema Evolution Setup</h3>

<p></code></pre>csharp{title="Comprehensive Schema Evolution Setup" description="Complete schema evolution configuration with all features enabled" category="Design" difficulty="ADVANCED" tags=["Schema-Evolution", "Configuration", "Comprehensive-Setup", "Best-Practices"] framework="NET8"}</p>
<p>services.AddWhizbang(options => {</p>
<p>    options.SchemaEvolution(evolution => {</p>
<p>        // Storage format</p>
<p>        evolution.UseJsonb = true;</p>
<p>        evolution.StoreSchemaVersion = true;</p>
<p>        evolution.ValidateOnWrite = false; // Allow forward compatibility</p>
<p>        </p>
<p>        // Versioning strategy</p>
<p>        evolution.VersioningStrategy = VersioningStrategy.Upcasting;</p>
<p>        evolution.AutoRegisterUpcasterts = true;</p>
<p>        evolution.UpcastOnRead = true;</p>
<p>        </p>
<p>        // Schema registry</p>
<p>        evolution.UseSchemaRegistry(registry => {</p>
<p>            registry.Url = "https://schema-registry.internal";</p>
<p>            registry.AutoRegister = true;</p>
<p>            registry.CompatibilityLevel = CompatibilityLevel.Backward;</p>
<p>        });</p>
<p>        </p>
<p>        // Blue/Green deployments</p>
<p>        evolution.BlueGreen(blueGreen => {</p>
<p>            blueGreen.ValidationThreshold = 0.99; // 99% accuracy required</p>
<p>            blueGreen.WarmupPeriod = TimeSpan.FromMinutes(5);</p>
<p>            blueGreen.AutoSwitch = false; // Manual approval required</p>
<p>        });</p>
<p>    });</p>
<p>});</p>
<pre><code class="language-">
<h3>Event Versioning Best Practices</h3>

<p></code></pre>csharp{title="Event Versioning Best Practices" description="Best practices for event versioning and backward-compatible schema evolution" category="Design" difficulty="INTERMEDIATE" tags=["Schema-Evolution", "Best-Practices", "Backward-Compatibility", "Versioning"] framework="NET8"}</p>
<p>// 1. Always make fields optional when adding them</p>
<p>public record OrderPlaced(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    DateTimeOffset? PlacedAt = null,      // Optional - added in V2</p>
<p>    List<string>? Tags = null             // Optional - added in V3</p>
<p>);</p>

<p>// 2. Use wrapper types for complex evolution</p>
<p>public record OrderPlaced(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    OrderMetadata? Metadata = null        // Wrapper for evolving fields</p>
<p>);</p>

<p>public record OrderMetadata(</p>
<p>    DateTimeOffset? PlacedAt = null,</p>
<p>    List<string>? Tags = null,</p>
<p>    CustomerInfo? Customer = null</p>
<p>);</p>

<p>// 3. Never remove fields - mark as obsolete</p>
<p>public record OrderPlaced(</p>
<p>    Guid OrderId,</p>
<p>    Guid CustomerId,</p>
<p>    </p>
<p>    [Obsolete("Use Metadata.PlacedAt instead")]</p>
<p>    DateTimeOffset? PlacedAt = null,      // Keep for backward compatibility</p>
<p>    </p>
<p>    OrderMetadata? Metadata = null</p>
<p>);</p>

<p>// 4. Use semantic versioning for breaking changes</p>
<p>[EventVersion("order-placed", "1.0.0")]</p>
<p>public record OrderPlacedV1(Guid OrderId, Guid CustomerId);</p>

<p>[EventVersion("order-placed", "1.1.0")]  // Minor version - additive</p>
<p>public record OrderPlaced(Guid OrderId, Guid CustomerId, DateTimeOffset? PlacedAt = null);</p>

<p>[EventVersion("order-placed", "2.0.0")]  // Major version - breaking change</p>
<p>public record OrderPlacedV2(Guid OrderId, CustomerId CustomerId, DateTimeOffset PlacedAt);</p>
<p></code>``</p>

<h3>Projection Evolution Guidelines</h3>

<ul><li><strong>Add fields with defaults</strong> - New fields should have sensible default values</li>
<li><strong>Rebuild for major changes</strong> - Use blue/green deployment for breaking changes</li>
<li><strong>Test evolution paths</strong> - Verify old events work with new projections</li>
<li><strong>Monitor data quality</strong> - Track schema evolution impact on data</li>
<li><strong>Document changes</strong> - Keep clear records of schema evolution decisions</li>
</ul>
<hr>

<h2>Related Documentation</h2>

<ul><li><a href="./event-store-projections.md"><strong>Event Store & Projections</strong></a> - Core storage architecture</li>
<li><a href="./projection-management.md"><strong>Projection Management</strong></a> - Backfilling and rebuilding strategies</li>
<li><a href="./advanced-features.md"><strong>Advanced Features</strong></a> - Cross-aggregate transactions and distributed tracing</li></ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="proposals-source-generation-ide" class="doc-section">
  <h2>Source Generation &amp; IDE Integration</h2>
  <p class="doc-path"><code>proposals/source-generation-ide</code></p>
  <div class="doc-content">

<h1>Source Generation & IDE Integration</h1>

<p>Whizbang uses advanced source generation and IDE integration to provide a seamless developer experience with compile-time validation, intelligent navigation, and powerful debugging tools.</p>

<h2>Source Generator Architecture</h2>

<h3>Single Pipeline Generator</h3>

<strong>Incremental source generator</strong> with orchestrated pipeline stages for optimal performance:

<p>``<code>csharp{</p>
<p>title: "Incremental Source Generator"</p>
<p>description: "Single incremental source generator with orchestrated pipeline stages"</p>
<p>category: "Design"</p>
<p>difficulty: "ADVANCED"</p>
<p>tags: ["Design", "Source-Generation", "Incremental-Generation", "Pipeline-Architecture"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>[Generator]</p>
<p>public class WhizbangSourceGenerator : IIncrementalGenerator {</p>
<p>    public void Initialize(IncrementalGeneratorInitializationContext context) {</p>
<p>        // Stage 1: Handler Discovery Pipeline</p>
<p>        var handlersPipeline = context.SyntaxProvider.CreateSyntaxProvider(</p>
<p>            predicate: (node, _) => IsHandlerCandidate(node),</p>
<p>            transform: (ctx, _) => ExtractHandlerInfo(ctx)</p>
<p>        ).Where(info => info != null);</p>
<p>        </p>
<p>        // Stage 2: Domain Ownership Pipeline  </p>
<p>        var domainOwnershipPipeline = context.SyntaxProvider.CreateSyntaxProvider(</p>
<p>            predicate: (node, _) => IsDomainCandidate(node),</p>
<p>            transform: (ctx, _) => ExtractDomainInfo(ctx)</p>
<p>        );</p>
<p>        </p>
<p>        // Stage 3: Projection Pipeline</p>
<p>        var projectionsPipeline = context.SyntaxProvider.CreateSyntaxProvider(</p>
<p>            predicate: (node, _) => IsProjectionCandidate(node),</p>
<p>            transform: (ctx, _) => ExtractProjectionInfo(ctx)</p>
<p>        );</p>
<p>        </p>
<p>        // Stage 4: Policy Pipeline</p>
<p>        var policiesPipeline = context.SyntaxProvider.CreateSyntaxProvider(</p>
<p>            predicate: (node, _) => IsPolicyCandidate(node),</p>
<p>            transform: (ctx, _) => ExtractPolicyInfo(ctx)</p>
<p>        );</p>
<p>        </p>
<p>        // Combine all sources for cross-project aggregation</p>
<p>        var combinedPipeline = handlersPipeline</p>
<p>            .Combine(domainOwnershipPipeline)</p>
<p>            .Combine(projectionsPipeline)</p>
<p>            .Combine(policiesPipeline);</p>
<p>            </p>
<p>        // Generate code</p>
<p>        context.RegisterSourceOutput(combinedPipeline, GenerateWhizbangRegistry);</p>
<p>        </p>
<p>        // Generate metadata for IDE service</p>
<p>        context.RegisterSourceOutput(combinedPipeline, GenerateNavigationMetadata);</p>
<p>        </p>
<p>        // Generate analyzer data</p>
<p>        context.RegisterSourceOutput(combinedPipeline, GenerateAnalyzerData);</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Build Performance & Logging</h3>

<strong>Detailed timing and logging</strong> for optimization:

<p></code></pre>csharp{</p>
<p>title: "Performance Tracker"</p>
<p>description: "Performance tracking for source generation stages with detailed timing"</p>
<p>category: "Design"</p>
<p>difficulty: "INTERMEDIATE"</p>
<p>tags: ["Design", "Source-Generation", "Performance-Tracking", "Build-Optimization"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>public class GenerationPerformanceTracker {</p>
<p>    private readonly Dictionary<string, Stopwatch> _stageTimers = new();</p>
<p>    </p>
<p>    public void StartStage(string stageName) {</p>
<p>        _stageTimers[stageName] = Stopwatch.StartNew();</p>
<p>        LogInformation($"Starting stage: {stageName}");</p>
<p>    }</p>
<p>    </p>
<p>    public void EndStage(string stageName) {</p>
<p>        if (_stageTimers.TryGetValue(stageName, out var timer)) {</p>
<p>            timer.Stop();</p>
<p>            LogInformation($"Completed stage: {stageName} in {timer.ElapsedMilliseconds}ms");</p>
<p>        }</p>
<p>    }</p>
<p>    </p>
<p>    public void LogSummary() {</p>
<p>        var totalTime = _stageTimers.Values.Sum(t => t.ElapsedMilliseconds);</p>
<p>        LogInformation($"Total generation time: {totalTime}ms");</p>
<p>        </p>
<p>        foreach (var (stage, timer) in _stageTimers) {</p>
<p>            var percentage = (timer.ElapsedMilliseconds / (double)totalTime) * 100;</p>
<p>            LogInformation($"  {stage}: {timer.ElapsedMilliseconds}ms ({percentage:F1}%)");</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Multi-Project Aggregation</h3>

<strong>Cross-assembly handler discovery</strong> and registration:

<p></code></pre>csharp{</p>
<p>title: "Cross-Project Registry"</p>
<p>description: "Generated registry that aggregates handlers across multiple projects"</p>
<p>category: "Design"</p>
<p>difficulty: "ADVANCED"</p>
<p>tags: ["Design", "Source-Generation", "Multi-Project-Aggregation", "Code-Generation"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>// Generated registry aggregates across projects</p>
<p>[GeneratedCode("Whizbang.SourceGenerator")]</p>
<p>public static class WhizbangGeneratedRegistry {</p>
<p>    public static void RegisterAll(IServiceCollection services) {</p>
<p>        // Handlers from current project</p>
<p>        RegisterLocalHandlers(services);</p>
<p>        </p>
<p>        // Handlers from referenced projects</p>
<p>        RegisterReferencedHandlers(services);</p>
<p>        </p>
<p>        // Domain ownership from all projects</p>
<p>        RegisterDomainOwnership(services);</p>
<p>        </p>
<p>        // Policies from all projects</p>
<p>        RegisterPolicies(services);</p>
<p>    }</p>
<p>    </p>
<p>    private static void RegisterLocalHandlers(IServiceCollection services) {</p>
<p>        services.AddScoped<ICommandHandler<PlaceOrder>, PlaceOrderHandler>();</p>
<p>        services.AddScoped<IEventHandler<OrderPlaced>, OrderSummaryProjection>();</p>
<p>        // ... other local handlers</p>
<p>    }</p>
<p>    </p>
<p>    private static void RegisterReferencedHandlers(IServiceCollection services) {</p>
<p>        // Handlers discovered from referenced assemblies</p>
<p>        SharedLibrary.WhizbangRegistry.RegisterHandlers(services);</p>
<p>        CoreDomain.WhizbangRegistry.RegisterHandlers(services);</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>IDE Navigation Service</h2>

<h3>Event Stream Navigation</h3>

<strong>GitLens-style navigation</strong> through event streams and handlers:

<p></code></pre>csharp{</p>
<p>title: "Navigation Service"</p>
<p>description: "Navigation service interface for GitLens-style event stream traversal"</p>
<p>category: "Design"</p>
<p>difficulty: "INTERMEDIATE"</p>
<p>tags: ["Design", "IDE-Integration", "Navigation-Service", "Event-Stream-Navigation"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>public interface IWhizbangNavigationService {</p>
<p>    Task<EventStreamInfo> GetEventStreamAsync(string streamId);</p>
<p>    Task<IEnumerable<HandlerInfo>> GetHandlersForEventAsync(Type eventType);</p>
<p>    Task<IEnumerable<ProjectionInfo>> GetProjectionsForEventAsync(Type eventType);</p>
<p>    Task<EventFlowDiagram> GetEventFlowAsync(Type commandType);</p>
<p>    Task<DomainMap> GetDomainMapAsync();</p>
<p>}</p>

<p>// Event flow visualization</p>
<p>public class EventFlowDiagram {</p>
<p>    public CommandInfo Command { get; set; }</p>
<p>    public HandlerInfo CommandHandler { get; set; }</p>
<p>    public List<EventInfo> EmittedEvents { get; set; }</p>
<p>    public Dictionary<EventInfo, List<HandlerInfo>> EventHandlers { get; set; }</p>
<p>    public Dictionary<EventInfo, List<ProjectionInfo>> EventProjections { get; set; }</p>
<p>    public List<SagaInfo> TriggeredSagas { get; set; }</p>
<p>}</p>

<p></code>`<code>csharp{</p>
<p>title: "Code Lens Provider"</p>
<p>description: "Code lens provider for displaying event flow information in IDE"</p>
<p>category: "Design"</p>
<p>difficulty: "ADVANCED"</p>
<p>tags: ["Design", "IDE-Integration", "Code-Lens-Provider", "Event-Flow-Visualization"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>// Usage in IDE extension</p>
<p>public class WhizbangCodeLensProvider : CodeLensProvider {</p>
<p>    public override async Task<CodeLens[]> ProvideCodeLensesAsync(Document document) {</p>
<p>        var semanticModel = await document.GetSemanticModelAsync();</p>
<p>        var root = await document.GetSyntaxRootAsync();</p>
<p>        </p>
<p>        var codeLenses = new List<CodeLens>();</p>
<p>        </p>
<p>        // Find command handlers</p>
<p>        foreach (var handlerClass in root.DescendantNodes().OfType<ClassDeclarationSyntax>()) {</p>
<p>            if (IsCommandHandler(handlerClass, semanticModel)) {</p>
<p>                var commandType = GetCommandType(handlerClass, semanticModel);</p>
<p>                var eventFlow = await _navigationService.GetEventFlowAsync(commandType);</p>
<p>                </p>
<p>                codeLenses.Add(new CodeLens {</p>
<p>                    Range = GetRange(handlerClass),</p>
<p>                    Command = new Command {</p>
<p>                        Title = $"Emits {eventFlow.EmittedEvents.Count} events, triggers {eventFlow.EventHandlers.Count} handlers",</p>
<p>                        Arguments = new object[] { eventFlow }</p>
<p>                    }</p>
<p>                });</p>
<p>            }</p>
<p>        }</p>
<p>        </p>
<p>        return codeLenses.ToArray();</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Generated Metadata</h3>

<strong>Rich metadata</strong> for IDE integration:

<p></code></pre>json</p>
<p>// Generated metadata file: WhizbangMetadata.json</p>
<p>{</p>
<p>  "eventStreams": {</p>
<p>    "Order-{orderId}": {</p>
<p>      "aggregateType": "Order",</p>
<p>      "domain": "Orders",</p>
<p>      "events": ["OrderPlaced", "OrderUpdated", "OrderShipped"],</p>
<p>      "handlers": ["OrderSummaryProjection", "OrderHistoryProjection"],</p>
<p>      "sagas": ["OrderFulfillmentSaga"]</p>
<p>    }</p>
<p>  },</p>
<p>  "handlers": {</p>
<p>    "PlaceOrderHandler": {</p>
<p>      "handlerType": "Command",</p>
<p>      "inputType": "PlaceOrder",</p>
<p>      "outputTypes": ["OrderPlaced"],</p>
<p>      "domain": "Orders",</p>
<p>      "sourceLocation": "OrderService/Handlers/PlaceOrderHandler.cs:15"</p>
<p>    }</p>
<p>  },</p>
<p>  "projections": {</p>
<p>    "OrderSummaryProjection": {</p>
<p>      "projectionName": "order-summary",</p>
<p>      "subscribedEvents": ["OrderPlaced", "OrderUpdated", "OrderShipped"],</p>
<p>      "domain": "Orders",</p>
<p>      "sourceLocation": "OrderService/Projections/OrderSummaryProjection.cs:8"</p>
<p>    }</p>
<p>  },</p>
<p>  "domains": {</p>
<p>    "Orders": {</p>
<p>      "commands": ["PlaceOrder", "UpdateOrder", "ShipOrder"],</p>
<p>      "events": ["OrderPlaced", "OrderUpdated", "OrderShipped"],</p>
<p>      "handlers": ["PlaceOrderHandler", "UpdateOrderHandler"],</p>
<p>      "projections": ["OrderSummaryProjection", "OrderHistoryProjection"]</p>
<p>    }</p>
<p>  }</p>
<p>}</p>
<pre><code class="language-">
<h2>Code Analyzers & Fixes</h2>

<h3>Domain Ownership Validation</h3>

<strong>Compile-time enforcement</strong> of domain ownership rules:

<p></code></pre>csharp{</p>
<p>title: "Domain Ownership Analyzer"</p>
<p>description: "Roslyn analyzer for compile-time domain ownership validation"</p>
<p>category: "Design"</p>
<p>difficulty: "ADVANCED"</p>
<p>tags: ["Design", "Code-Analyzers", "Domain-Ownership", "Compile-Time-Validation"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>[DiagnosticAnalyzer(LanguageNames.CSharp)]</p>
<p>public class DomainOwnershipAnalyzer : DiagnosticAnalyzer {</p>
<p>    public static readonly DiagnosticDescriptor CrossDomainHandlerRule = new(</p>
<p>        "WB001",</p>
<p>        "Handler cannot handle command/event from different domain",</p>
<p>        "Handler '{0}' in domain '{1}' cannot handle '{2}' from domain '{3}'",</p>
<p>        "Domain Ownership",</p>
<p>        DiagnosticSeverity.Error,</p>
<p>        isEnabledByDefault: true</p>
<p>    );</p>
<p>    </p>
<p>    public override void Initialize(AnalysisContext context) {</p>
<p>        context.RegisterSyntaxNodeAction(AnalyzeHandlerClass, SyntaxKind.ClassDeclaration);</p>
<p>    }</p>
<p>    </p>
<p>    private void AnalyzeHandlerClass(SyntaxNodeAnalysisContext context) {</p>
<p>        var classDeclaration = (ClassDeclarationSyntax)context.Node;</p>
<p>        var semanticModel = context.SemanticModel;</p>
<p>        </p>
<p>        var handlerDomain = GetHandlerDomain(classDeclaration, semanticModel);</p>
<p>        var handledTypes = GetHandledTypes(classDeclaration, semanticModel);</p>
<p>        </p>
<p>        foreach (var handledType in handledTypes) {</p>
<p>            var messageDomain = GetMessageDomain(handledType, semanticModel);</p>
<p>            </p>
<p>            if (handlerDomain != messageDomain) {</p>
<p>                var diagnostic = Diagnostic.Create(</p>
<p>                    CrossDomainHandlerRule,</p>
<p>                    classDeclaration.GetLocation(),</p>
<p>                    classDeclaration.Identifier.ValueText,</p>
<p>                    handlerDomain,</p>
<p>                    handledType.Name,</p>
<p>                    messageDomain</p>
<p>                );</p>
<p>                </p>
<p>                context.ReportDiagnostic(diagnostic);</p>
<p>            }</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Code Fixes</h3>

<strong>Automatic fixes</strong> for common patterns:

<p></code></pre>csharp{</p>
<p>title: "Code Fix Provider"</p>
<p>description: "Code fix provider for automatic domain ownership attribute addition"</p>
<p>category: "Design"</p>
<p>difficulty: "ADVANCED"</p>
<p>tags: ["Design", "Code-Fixes", "Domain-Ownership", "Automatic-Fixes"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>[ExportCodeFixProvider(LanguageNames.CSharp)]</p>
<p>public class AddDomainOwnershipCodeFixProvider : CodeFixProvider {</p>
<p>    public override async Task RegisterCodeFixesAsync(CodeFixContext context) {</p>
<p>        var diagnostic = context.Diagnostics.FirstOrDefault(d => d.Id == "WB002");</p>
<p>        if (diagnostic == null) return;</p>
<p>        </p>
<p>        var document = context.Document;</p>
<p>        var root = await document.GetSyntaxRootAsync(context.CancellationToken);</p>
<p>        var declaration = root.FindNode(diagnostic.Location.SourceSpan);</p>
<p>        </p>
<p>        // Offer to add [OwnedBy] attribute</p>
<p>        var codeAction = CodeAction.Create(</p>
<p>            title: "Add [OwnedBy] attribute",</p>
<p>            createChangedDocument: c => AddOwnedByAttribute(document, declaration, c),</p>
<p>            equivalenceKey: "AddOwnedBy"</p>
<p>        );</p>
<p>        </p>
<p>        context.RegisterCodeFix(codeAction, diagnostic);</p>
<p>    }</p>
<p>    </p>
<p>    private async Task<Document> AddOwnedByAttribute(Document document, SyntaxNode declaration, CancellationToken cancellationToken) {</p>
<p>        var root = await document.GetSyntaxRootAsync(cancellationToken);</p>
<p>        var inferredDomain = InferDomainFromNamespace(declaration);</p>
<p>        </p>
<p>        var attribute = SyntaxFactory.Attribute(</p>
<p>            SyntaxFactory.IdentifierName("OwnedBy"),</p>
<p>            SyntaxFactory.AttributeArgumentList(</p>
<p>                SyntaxFactory.SingletonSeparatedList(</p>
<p>                    SyntaxFactory.AttributeArgument(</p>
<p>                        SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, </p>
<p>                            SyntaxFactory.Literal(inferredDomain))</p>
<p>                    )</p>
<p>                )</p>
<p>            )</p>
<p>        );</p>
<p>        </p>
<p>        var newDeclaration = AddAttributeToDeclaration(declaration, attribute);</p>
<p>        var newRoot = root.ReplaceNode(declaration, newDeclaration);</p>
<p>        </p>
<p>        return document.WithSyntaxRoot(newRoot);</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Debugging Integration</h2>

<h3>Transparent Generated Code</h3>

<strong>Clear, debuggable generated code</strong> with source maps:

<p></code></pre>csharp{</p>
<p>title: "Debuggable Generated Code"</p>
<p>description: "Clear, debuggable generated code with source maps and metadata"</p>
<p>category: "Design"</p>
<p>difficulty: "INTERMEDIATE"</p>
<p>tags: ["Design", "Source-Generation", "Transparent-Code", "Debug-Experience"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>// Generated handler registry with clear structure</p>
<p>[GeneratedCode("Whizbang.SourceGenerator", "1.0.0")]</p>
<p>public static partial class OrderServiceHandlerRegistry {</p>
<p>    // Source: OrderService/Handlers/PlaceOrderHandler.cs</p>
<p>    public static void RegisterPlaceOrderHandler(IServiceCollection services) {</p>
<p>        services.AddScoped<ICommandHandler<PlaceOrder>, PlaceOrderHandler>();</p>
<p>        </p>
<p>        // Generated metadata for debugging</p>
<p>        services.AddSingleton(new HandlerMetadata {</p>
<p>            HandlerType = typeof(PlaceOrderHandler),</p>
<p>            MessageType = typeof(PlaceOrder),</p>
<p>            SourceFile = "OrderService/Handlers/PlaceOrderHandler.cs",</p>
<p>            SourceLine = 15,</p>
<p>            Domain = "Orders",</p>
<p>            GeneratedAt = DateTimeOffset.Parse("2024-01-01T10:00:00Z")</p>
<p>        });</p>
<p>    }</p>
<p>    </p>
<p>    // Source: OrderService/Projections/OrderSummaryProjection.cs  </p>
<p>    public static void RegisterOrderSummaryProjection(IServiceCollection services) {</p>
<p>        services.AddScoped<IProjectionHandler<OrderPlaced>, OrderSummaryProjection>();</p>
<p>        services.AddScoped<IProjectionHandler<OrderUpdated>, OrderSummaryProjection>();</p>
<p>        services.AddScoped<IProjectionHandler<OrderShipped>, OrderSummaryProjection>();</p>
<p>        </p>
<p>        // Register projection metadata</p>
<p>        services.AddSingleton(new ProjectionMetadata {</p>
<p>            ProjectionType = typeof(OrderSummaryProjection),</p>
<p>            ProjectionName = "order-summary",</p>
<p>            SubscribedEvents = new[] { typeof(OrderPlaced), typeof(OrderUpdated), typeof(OrderShipped) },</p>
<p>            SourceFile = "OrderService/Projections/OrderSummaryProjection.cs",</p>
<p>            SourceLine = 8,</p>
<p>            Domain = "Orders"</p>
<p>        });</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Debug Experience Enhancements</h3>

<strong>No "magic" - clear understanding</strong> of what's happening:

<p></code></pre>csharp{</p>
<p>title: "Debug-Friendly Registration"</p>
<p>description: "Debug-friendly service registration with detailed logging"</p>
<p>category: "Design"</p>
<p>difficulty: "INTERMEDIATE"</p>
<p>tags: ["Design", "Source-Generation", "Debug-Experience", "Service-Registration"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>// Debug-friendly service registration</p>
<p>public static class WhizbangServiceCollectionExtensions {</p>
<p>    public static IServiceCollection AddWhizbangGeneratedServices(this IServiceCollection services) {</p>
<p>        if (IsDebugMode()) {</p>
<p>            // In debug mode, show detailed registration logging</p>
<p>            services.AddSingleton<IHandlerRegistrationLogger, DetailedHandlerRegistrationLogger>();</p>
<p>        }</p>
<p>        </p>
<p>        // Call generated registration methods</p>
<p>        OrderServiceHandlerRegistry.RegisterAll(services);</p>
<p>        </p>
<p>        return services;</p>
<p>    }</p>
<p>}</p>

<p>public class DetailedHandlerRegistrationLogger : IHandlerRegistrationLogger {</p>
<p>    public void LogHandlerRegistration<TMessage, THandler>(string sourceFile, int sourceLine) {</p>
<p>        Console.WriteLine($"Registering handler {typeof(THandler).Name} for {typeof(TMessage).Name}");</p>
<p>        Console.WriteLine($"  Source: {sourceFile}:{sourceLine}");</p>
<p>        Console.WriteLine($"  Service lifetime: Scoped");</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h2>Performance Optimizations</h2>

<h3>Incremental Generation</h3>

<strong>Only regenerate what changed</strong> for fast incremental builds:

<p></code></pre>csharp{</p>
<p>title: "Incremental Generation Context"</p>
<p>description: "Incremental generation context for tracking file changes and optimization"</p>
<p>category: "Design"</p>
<p>difficulty: "ADVANCED"</p>
<p>tags: ["Design", "Source-Generation", "Incremental-Generation", "Performance-Optimization"]</p>
<p>framework: "NET8"</p>
<p>}</p>
<p>public class IncrementalGenerationContext {</p>
<p>    private readonly ConcurrentDictionary<string, string> _fileHashes = new();</p>
<p>    </p>
<p>    public bool HasFileChanged(string filePath, string content) {</p>
<p>        var currentHash = ComputeHash(content);</p>
<p>        var previousHash = _fileHashes.GetValueOrDefault(filePath);</p>
<p>        </p>
<p>        if (currentHash != previousHash) {</p>
<p>            _fileHashes[filePath] = currentHash;</p>
<p>            return true;</p>
<p>        }</p>
<p>        </p>
<p>        return false;</p>
<p>    }</p>
<p>    </p>
<p>    public void TrackGeneratedOutput(string outputKey, string content) {</p>
<p>        // Track what we generated so we can skip unchanged outputs</p>
<p>        _generatedOutputs[outputKey] = ComputeHash(content);</p>
<p>    }</p>
<p>}</p>
<p></code>``</p>

<h3>Compilation Performance</h3>

<strong>Optimize for IDE experience</strong>:

<ul><li><strong>Syntax-only analysis</strong> for most validations</li>
<li><strong>Semantic analysis</strong> only when necessary</li>
<li><strong>Caching</strong> of expensive operations</li>
<li><strong>Parallel processing</strong> of independent analysis</li>
<li><strong>Early termination</strong> when errors are found</li>
</ul>
<h2>Best Practices</h2>

<h3>Generator Design</h3>

<ul><li><strong>Keep generators focused</strong> - Single responsibility per generator stage</li>
<li><strong>Minimize semantic model usage</strong> - Use syntax analysis when possible</li>
<li><strong>Cache expensive operations</strong> - Avoid redundant analysis</li>
<li><strong>Provide clear diagnostics</strong> - Help developers understand issues</li>
<li><strong>Generate debuggable code</strong> - Include source references and metadata</li>
</ul>
<h3>IDE Integration</h3>

<ul><li><strong>Responsive navigation</strong> - Fast lookups and searches</li>
<li><strong>Contextual information</strong> - Show relevant details for current location</li>
<li><strong>Clear visualizations</strong> - Easy to understand flow diagrams</li>
<li><strong>Helpful code lenses</strong> - Actionable information overlays</li>
<li><strong>Intelligent suggestions</strong> - Context-aware code completion</li>
</ul>
<h3>Debug Experience</h3>

<ul><li><strong>No hidden magic</strong> - Everything should be discoverable</li>
<li><strong>Clear error messages</strong> - Point to exact problems and solutions</li>
<li><strong>Source mapping</strong> - Connect generated code to source</li>
<li><strong>Metadata preservation</strong> - Keep debug information through compilation</li>
<li><strong>Performance transparency</strong> - Show timing and costs</li>
</ul>
<hr>

<h2>Related Documentation</h2>

<ul><li><a href="./domain-ownership.md"><strong>Domain Ownership</strong></a> - How ownership affects source generation</li>
<li><a href="./policy-engine.md"><strong>Policy Engine</strong></a> - Policy-based code generation</li>
<li><a href="./flags-tags-system.md"><strong>Flags & Tags System</strong></a> - Cross-service context propagation</li>
<li><a href="./testing-development-tools.md"><strong>Testing & Development Tools</strong></a> - Testing the generated code</li></ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

<article id="proposals-testing-development-tools" class="doc-section">
  <h2>Testing &amp; Development Tools</h2>
  <p class="doc-path"><code>proposals/testing-development-tools</code></p>
  <div class="doc-content">

<h1>Testing & Development Tools</h1>

<p>Whizbang provides comprehensive testing utilities and development tools to ensure a productive developer experience from local development to production deployment.</p>

<h2>Testing Framework</h2>

<h3>Whizbang.Testing Package</h3>

<strong>Comprehensive testing library</strong> with fluent APIs for all Whizbang scenarios:

<p>``<code>csharp{title="Installing Whizbang Testing Package" description="Installing and setting up the Whizbang testing package" category="Design" difficulty="BEGINNER" tags=["Design", "Testing", "Package-Installation", "Setup"] framework="NET8"}</p>
<p>// Install the testing package</p>
<p>dotnet add package Whizbang.Testing</p>

<p></code>`<code>csharp{title="Test Fixture Setup" description="Test fixture setup with in-memory drivers for fast unit testing" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Testing", "Test-Fixtures", "In-Memory-Drivers"] framework="NET8"}</p>
<p>// Test fixture setup</p>
<p>public class OrderServiceTests {</p>
<p>    private readonly WhizbangTestFixture _fixture;</p>
<p>    </p>
<p>    public OrderServiceTests() {</p>
<p>        _fixture = new WhizbangTestFixture()</p>
<p>            .UseInMemoryEventStore()</p>
<p>            .UseInMemoryProjections()</p>
<p>            .UseInMemoryMessageBroker()</p>
<p>            .ConfigureServices(services => {</p>
<p>                services.AddScoped<IOrderService, OrderService>();</p>
<p>                services.AddScoped<ICustomerService, MockCustomerService>();</p>
<p>            });</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Event Sourcing Test Helpers</h3>

<strong>Given/When/Then fluent API</strong> for event sourcing scenarios:

<p></code></pre>csharp{title="Given/When/Then Event Sourcing Tests" description="Given/When/Then fluent API for event sourcing test scenarios" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Testing", "Given-When-Then", "Event-Sourcing"] framework="NET8"}</p>
<p>[Test]</p>
<p>public async Task PlaceOrder_WithValidCustomer_ShouldEmitOrderPlaced() {</p>
<p>    // Arrange & Act & Assert in fluent chain</p>
<p>    await _fixture</p>
<p>        .Given(</p>
<p>            new CustomerRegistered(customerId, "John Doe", "john@example.com"),</p>
<p>            new ProductCreated(productId, "Widget", 10.00m)</p>
<p>        )</p>
<p>        .When(new PlaceOrder(orderId, customerId, new[] { </p>
<p>            new OrderItem(productId, 2, 10.00m) </p>
<p>        }))</p>
<p>        .Then()</p>
<p>        .ShouldEmitEvent<OrderPlaced>()</p>
<p>        .WithProperty(e => e.OrderId, orderId)</p>
<p>        .WithProperty(e => e.CustomerId, customerId)</p>
<p>        .WithProperty(e => e.Total, 20.00m)</p>
<p>        .And()</p>
<p>        .ShouldNotEmitEvent<OrderRejected>();</p>
<p>}</p>

<p></code>`<code>csharp{title="Error Scenario Testing" description="Testing error scenarios with event validation assertions" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Testing", "Error-Scenarios", "Event-Validation"] framework="NET8"}</p>
<p>[Test]</p>
<p>public async Task PlaceOrder_WithInvalidCustomer_ShouldEmitOrderRejected() {</p>
<p>    await _fixture</p>
<p>        .Given() // No customer registered</p>
<p>        .When(new PlaceOrder(orderId, customerId, items))</p>
<p>        .Then()</p>
<p>        .ShouldEmitEvent<OrderRejected>()</p>
<p>        .WithProperty(e => e.Reason, "Customer not found")</p>
<p>        .And()</p>
<p>        .ShouldNotEmitEvent<OrderPlaced>();</p>
<p>}</p>
<pre><code class="language-">
<h3>Projection Testing</h3>

<strong>Feed events and assert projection state</strong>:

<p></code></pre>csharp{title="Projection Lifecycle Testing" description="Projection testing with event feeding and state assertions" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Testing", "Projections", "Lifecycle-Testing"] framework="NET8"}</p>
<p>[Test]</p>
<p>public async Task OrderSummaryProjection_ShouldTrackOrderLifecycle() {</p>
<p>    await _fixture</p>
<p>        .ForProjection<OrderSummaryProjection>()</p>
<p>        .GivenEvents(</p>
<p>            new OrderPlaced(orderId, customerId, 100.00m, DateTimeOffset.UtcNow),</p>
<p>            new OrderShipped(orderId, "TRACK123", DateTimeOffset.UtcNow.AddDays(1))</p>
<p>        )</p>
<p>        .WhenProjectionRuns()</p>
<p>        .ThenProjection<OrderSummary>(orderId.ToString())</p>
<p>        .ShouldExist()</p>
<p>        .ShouldHaveProperty(s => s.Status, OrderStatus.Shipped)</p>
<p>        .ShouldHaveProperty(s => s.Total, 100.00m)</p>
<p>        .ShouldHaveProperty(s => s.TrackingNumber, "TRACK123");</p>
<p>}</p>

<p>[Test]</p>
<p>public async Task OrderSummaryProjection_WithMissingEvents_ShouldHandleGracefully() {</p>
<p>    await _fixture</p>
<p>        .ForProjection<OrderSummaryProjection>()</p>
<p>        .GivenEvents(</p>
<p>            new OrderShipped(orderId, "TRACK123", DateTimeOffset.UtcNow) // No OrderPlaced</p>
<p>        )</p>
<p>        .WhenProjectionRuns()</p>
<p>        .ThenProjection<OrderSummary>(orderId.ToString())</p>
<p>        .ShouldNotExist(); // Projection should handle missing OrderPlaced gracefully</p>
<p>}</p>
<pre><code class="language-">
<h3>Policy Testing</h3>

<strong>Test policy rules and combinations</strong>:

<p></code></pre>csharp{title="Policy Rule Testing" description="Testing policy rules and their effects on system behavior" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Testing", "Policy-Testing", "Load-Testing"] framework="NET8"}</p>
<p>[Test]</p>
<p>public async Task LoadTestingPolicy_ShouldSkipProjections() {</p>
<p>    await _fixture</p>
<p>        .ForPolicy("LoadTestingPolicy")</p>
<p>        .GivenContext(ctx => ctx.WithFlag(WhizbangFlags.LoadTesting))</p>
<p>        .GivenMessage(new OrderPlaced(orderId, customerId, 100.00m))</p>
<p>        .WhenPolicyEvaluates()</p>
<p>        .ThenActions()</p>
<p>        .ShouldContain<SkipProjectionsAction>()</p>
<p>        .ShouldContain<AddTagAction>(action => action.Tag == "load-test-processed");</p>
<p>}</p>

<p>[Test]</p>
<p>public async Task VIPCustomerPolicy_ShouldRouteToSpecialHandler() {</p>
<p>    await _fixture</p>
<p>        .ForPolicy("VIPCustomerPolicy")</p>
<p>        .GivenContext(ctx => ctx.WithTag("customer-vip"))</p>
<p>        .GivenMessage(new PlaceOrder(orderId, customerId, items))</p>
<p>        .WhenPolicyEvaluates()</p>
<p>        .ThenActions()</p>
<p>        .ShouldContain<RouteToHandlerAction<VIPOrderHandler>>();</p>
<p>}</p>
<pre><code class="language-">
<h3>Saga Testing</h3>

<strong>Test long-running process coordination</strong>:

<p></code></pre>csharp{title="Saga Workflow Testing" description="Testing long-running saga workflows with command coordination" category="Design" difficulty="ADVANCED" tags=["Design", "Testing", "Sagas", "Workflow-Coordination"] framework="NET8"}</p>
<p>[Test]</p>
<p>public async Task OrderFulfillmentSaga_ShouldCoordinateFullWorkflow() {</p>
<p>    await _fixture</p>
<p>        .ForSaga<OrderFulfillmentSaga>()</p>
<p>        .GivenEvents(</p>
<p>            new OrderPlaced(orderId, customerId, items)</p>
<p>        )</p>
<p>        .WhenSagaRuns()</p>
<p>        .ThenCommands()</p>
<p>        .ShouldContain<ReserveInventory>(cmd => cmd.OrderId == orderId)</p>
<p>        .And()</p>
<p>        .WhenEvent(new InventoryReserved(orderId, items))</p>
<p>        .ThenCommands()</p>
<p>        .ShouldContain<ChargePayment>(cmd => cmd.OrderId == orderId)</p>
<p>        .And()</p>
<p>        .WhenEvent(new PaymentCharged(orderId, 100.00m))</p>
<p>        .ThenCommands()</p>
<p>        .ShouldContain<ShipOrder>(cmd => cmd.OrderId == orderId);</p>
<p>}</p>
<pre><code class="language-">
<h3>Integration Testing</h3>

<strong>Real drivers with test containers</strong>:

<p></code></pre>csharp{title="Integration Testing with TestContainers" description="Integration testing with real infrastructure using TestContainers" category="Design" difficulty="ADVANCED" tags=["Design", "Testing", "Integration-Testing", "TestContainers"] framework="NET8"}</p>
<p>[Test]</p>
<p>public async Task OrderService_IntegrationTest_WithRealDatabase() {</p>
<p>    // Uses TestContainers for real PostgreSQL</p>
<p>    await using var fixture = new WhizbangIntegrationTestFixture()</p>
<p>        .UseTestContainerPostgres()</p>
<p>        .UseTestContainerKafka()</p>
<p>        .ConfigureServices(services => {</p>
<p>            services.AddOrderService();</p>
<p>            services.AddInventoryService();</p>
<p>        });</p>
<p>    </p>
<p>    await fixture.StartAsync();</p>
<p>    </p>
<p>    // Test with real infrastructure</p>
<p>    var result = await fixture</p>
<p>        .Given(/<em> setup data in real database </em>/)</p>
<p>        .When(new PlaceOrder(orderId, customerId, items))</p>
<p>        .Then()</p>
<p>        .ShouldEmitEvent<OrderPlaced>()</p>
<p>        .And()</p>
<p>        .ShouldHaveProjection<OrderSummary>(orderId.ToString())</p>
<p>        .InDatabase(); // Verify in real database</p>
<p>}</p>
<pre><code class="language-">
<h2>Development Tools Suite</h2>

<h3>CLI Tool (whizbang-cli)</h3>

<strong>Comprehensive command-line interface</strong> for project management:

<p></code></pre>bash</p>
<hr>
<p>category: Design</p>
<p>difficulty: BEGINNER</p>
<p>tags: [Design, CLI, Project-Scaffolding, Templates]</p>
<p>description: CLI commands for project scaffolding and code generation</p>
<hr>
<h1>Project scaffolding</h1>
<p>whizbang new --template microservice --name OrderService</p>
<p>whizbang new --template monolith --name ECommerceApp</p>
<p>whizbang new --template projection-worker --name AnalyticsWorker</p>

<h1>Code generation</h1>
<p>whizbang add command --name PlaceOrder --domain Orders</p>
<p>whizbang add event --name OrderPlaced --domain Orders  </p>
<p>whizbang add projection --name OrderSummary --events OrderPlaced,OrderShipped</p>
<p>whizbang add saga --name OrderFulfillment --triggers OrderPlaced</p>

<h1>Development utilities</h1>
<p>whizbang validate --project ./OrderService --check-ownership</p>
<p>whizbang generate --project ./OrderService --watch</p>
<p>whizbang dashboard --port 5000 --project ./OrderService</p>

<h1>Event store utilities</h1>
<p>whizbang events list --stream "Order-*" --from 2024-01-01</p>
<p>whizbang events replay --stream "Order-123" --to-projection OrderSummary</p>
<p>whizbang events export --stream "Order-*" --format json --output orders.json</p>

<h1>Migration utilities</h1>
<p>whizbang migrate --from 1.0 --to 2.0 --dry-run</p>
<p>whizbang migrate --apply --backup</p>
<pre><code class="language-">
<h3>CLI Implementation Architecture</h3>

<p></code></pre>csharp{title="CLI Command Structure" description="CLI command structure implementation with subcommands" category="Design" difficulty="INTERMEDIATE" tags=["Design", "CLI", "Command-Structure", "Implementation"] framework="NET8"}</p>
<p>// CLI command structure</p>
<p>[Command("whizbang")]</p>
<p>public class WhizbangCliCommand {</p>
<p>    [Command("new")]</p>
<p>    public class NewCommand {</p>
<p>        [Option("--template", Description = "Project template")]</p>
<p>        public string Template { get; set; } = "microservice";</p>
<p>        </p>
<p>        [Option("--name", Description = "Project name")]</p>
<p>        public string Name { get; set; }</p>
<p>        </p>
<p>        public async Task<int> ExecuteAsync() {</p>
<p>            var templateEngine = new ProjectTemplateEngine();</p>
<p>            await templateEngine.CreateProjectAsync(Template, Name);</p>
<p>            return 0;</p>
<p>        }</p>
<p>    }</p>
<p>    </p>
<p>    [Command("add")]</p>
<p>    public class AddCommand {</p>
<p>        [Command("command")]</p>
<p>        public class AddCommandCommand {</p>
<p>            [Option("--name")] public string Name { get; set; }</p>
<p>            [Option("--domain")] public string Domain { get; set; }</p>
<p>            </p>
<p>            public async Task<int> ExecuteAsync() {</p>
<p>                var generator = new CodeGenerator();</p>
<p>                await generator.GenerateCommandAsync(Name, Domain);</p>
<p>                return 0;</p>
<p>            }</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Visual Studio Integration</h3>

<strong>Templates and extensions</strong> for rapid development:

<p></code></pre>xml</p>
<hr>
<p>category: Design</p>
<p>difficulty: INTERMEDIATE</p>
<p>tags: [Design, Templates, Visual-Studio, Project-Templates]</p>
<p>description: Visual Studio template configuration for rapid development</p>
<hr>
<p><!-- dotnet new templates --></p>
<p><Project Sdk="Microsoft.NET.Sdk"></p>
<p>  <PropertyGroup></p>
<p>    <PackageType>Template</PackageType></p>
<p>    <PackageVersion>1.0.0</PackageVersion></p>
<p>    <PackageId>Whizbang.Templates</PackageId></p>
<p>    <Title>Whizbang Project Templates</Title></p>
<p>    <Description>Templates for Whizbang applications</Description></p>
<p>    <IncludeContentInPack>true</IncludeContentInPack></p>
<p>    <IncludeBuildOutput>false</IncludeBuildOutput></p>
<p>    <ContentTargetFolders>content</ContentTargetFolders></p>
<p>  </PropertyGroup></p>
<p></Project></p>
<pre><code class="language-">
<strong>Live Templates for common patterns</strong>:

<p></code></pre>csharp{title="Live Code Templates" description="Live templates for common Whizbang patterns and boilerplate" category="Design" difficulty="BEGINNER" tags=["Design", "Live-Templates", "Code-Generation", "Commands"] framework="NET8"}</p>
<p>// Command template</p>
<p>public record $COMMAND_NAME$(</p>
<p>    $PARAMETERS$</p>
<p>) : ICommand;</p>

<p>// Event template  </p>
<p>public record $EVENT_NAME$(</p>
<p>    $PARAMETERS$</p>
<p>) : IEvent;</p>

<p>// Handler template</p>
<p>public class $HANDLER_NAME$ : ICommandHandler<$COMMAND_TYPE$> {</p>
<p>    public async Task<IEvent[]> Handle($COMMAND_TYPE$ command) {</p>
<p>        $HANDLER_LOGIC$</p>
<p>        </p>
<p>        return new IEvent[] {</p>
<p>            new $EVENT_TYPE$($EVENT_PARAMETERS$)</p>
<p>        };</p>
<p>    }</p>
<p>}</p>

<p>// Projection template</p>
<p>public class $PROJECTION_NAME$ : IProjectionHandler<$EVENT_TYPE$> {</p>
<p>    public async Task Handle($EVENT_TYPE$ @event, ProjectionContext context) {</p>
<p>        var projection = await context.Load<$PROJECTION_MODEL$>(@event.$KEY_FIELD$.ToString())</p>
<p>                        ?? new $PROJECTION_MODEL$ { $KEY_FIELD$ = @event.$KEY_FIELD$ };</p>
<p>        </p>
<p>        $PROJECTION_LOGIC$</p>
<p>        </p>
<p>        await context.Store(@event.$KEY_FIELD$.ToString(), projection);</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<h3>Web Dashboard</h3>

<strong>Real-time monitoring and debugging interface</strong>:

<p></code></pre>csharp{title="Web Dashboard Configuration" description="Web dashboard configuration for real-time monitoring and debugging" category="Design" difficulty="INTERMEDIATE" tags=["Design", "Web-Dashboard", "Real-Time-Monitoring", "Configuration"] framework="NET8"}</p>
<p>// Dashboard startup</p>
<p>public class WhizbangDashboard {</p>
<p>    public static void ConfigureDashboard(WebApplicationBuilder builder) {</p>
<p>        builder.Services.AddWhizbangDashboard(options => {</p>
<p>            options.EnableRealTimeUpdates = true;</p>
<p>            options.EventRetentionHours = 24;</p>
<p>            options.ProjectionLagAlertThreshold = TimeSpan.FromMinutes(5);</p>
<p>        });</p>
<p>    }</p>
<p>    </p>
<p>    public static void MapDashboardEndpoints(WebApplication app) {</p>
<p>        app.MapWhizbangDashboard("/dashboard");</p>
<p>        </p>
<p>        // API endpoints for dashboard</p>
<p>        app.MapGet("/api/whizbang/projections", GetProjectionStatus);</p>
<p>        app.MapGet("/api/whizbang/events/{streamId}", GetEventStream);</p>
<p>        app.MapPost("/api/whizbang/replay", TriggerReplay);</p>
<p>        app.MapGet("/api/whizbang/policies", GetActivePolicies);</p>
<p>        app.MapPost("/api/whizbang/policies/test", TestPolicy);</p>
<p>    }</p>
<p>}</p>
<pre><code class="language-">
<strong>Dashboard Features</strong>:

<ul><li><strong>Real-time Projection Monitoring</strong></li>
</ul><p>   - Projection lag visualization</p>
<p>   - Event processing rates</p>
<p>   - Error rates and alerts</p>
<p>   - Checkpoint status</p>

<ul><li><strong>Event Stream Visualization</strong></li>
</ul><p>   - Stream browsing and filtering</p>
<p>   - Event details and metadata</p>
<p>   - Cross-stream correlation</p>
<p>   - Flow diagrams</p>

<ul><li><strong>Policy Rule Testing</strong></li>
</ul><p>   - Policy condition testing</p>
<p>   - Action preview</p>
<p>   - Rule combination visualization</p>
<p>   - Performance impact analysis</p>

<ul><li><strong>Performance Metrics</strong></li>
</ul><p>   - Handler execution times</p>
<p>   - Throughput measurements</p>
<p>   - Resource utilization</p>
<p>   - Bottleneck identification</p>

<h3>IDE Extensions</h3>

<strong>Visual Studio Code Extension</strong> with advanced features:

<p></code></pre>typescript</p>
<hr>
<p>category: Design</p>
<p>difficulty: ADVANCED</p>
<p>tags: [Design, IDE-Extensions, VSCode, Event-Stream-Navigation]</p>
<p>description: VSCode extension implementation for advanced Whizbang development features</p>
<hr>
<p>// VSCode extension main functionality</p>
<p>export function activate(context: vscode.ExtensionContext) {</p>
<p>    // Register command for event stream navigation</p>
<p>    const navigateCommand = vscode.commands.registerCommand(</p>
<p>        'whizbang.navigateEventStream',</p>
<p>        async () => {</p>
<p>            const streamId = await vscode.window.showInputBox({</p>
<p>                prompt: 'Enter stream ID or pattern'</p>
<p>            });</p>
<p>            </p>
<p>            if (streamId) {</p>
<p>                const events = await whizbangService.getEventStream(streamId);</p>
<p>                showEventStreamPanel(events);</p>
<p>            }</p>
<p>        }</p>
<p>    );</p>
<p>    </p>
<p>    // Register hover provider for command/event info</p>
<p>    const hoverProvider = vscode.languages.registerHoverProvider(</p>
<p>        'csharp',</p>
<p>        new WhizbangHoverProvider()</p>
<p>    );</p>
<p>    </p>
<p>    // Register code lens provider for handler flow</p>
<p>    const codeLensProvider = vscode.languages.registerCodeLensProvider(</p>
<p>        'csharp',</p>
<p>        new WhizbangCodeLensProvider()</p>
<p>    );</p>
<p>    </p>
<p>    context.subscriptions.push(navigateCommand, hoverProvider, codeLensProvider);</p>
<p>}</p>

<pre><code class="language-typescript">---
<p>category: Design</p>
<p>difficulty: ADVANCED</p>
<p>tags: [Design, IDE-Extensions, Hover-Provider, Type-Metadata]</p>
<p>description: Hover provider implementation for type metadata and handler information</p>
<hr>
<p>class WhizbangHoverProvider implements vscode.HoverProvider {</p>
<p>    async provideHover(document: vscode.TextDocument, position: vscode.Position): Promise<vscode.Hover | undefined> {</p>
<p>        const word = document.getWordRangeAtPosition(position);</p>
<p>        if (!word) return;</p>
<p>        </p>
<p>        const wordText = document.getText(word);</p>
<p>        </p>
<p>        // Check if it's a Whizbang command/event</p>
<p>        const metadata = await whizbangService.getTypeMetadata(wordText);</p>
<p>        if (metadata) {</p>
<p>            const contents = new vscode.MarkdownString();</p>
<p>            contents.appendMarkdown(</code><strong>${metadata.type}</strong>: ${metadata.name}\n\n<code>);</p>
<p>            contents.appendMarkdown(</code>Domain: ${metadata.domain}\n\n<code>);</p>
<p>            </p>
<p>            if (metadata.handlers) {</p>
<p>                contents.appendMarkdown(</code><strong>Handlers:</strong>\n<code>);</p>
<p>                metadata.handlers.forEach(h => {</p>
<p>                    contents.appendMarkdown(</code>- ${h.name} (${h.domain})\n<code>);</p>
<p>                });</p>
<p>            }</p>
<p>            </p>
<p>            return new vscode.Hover(contents, word);</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p></code></pre></p>

<h2>In-Memory Drivers for Testing</h2>

<h3>Fast Unit Test Infrastructure</h3>

<strong>Optimized in-memory implementations</strong> for rapid testing:

<p></code>`<code>csharp{title="In-Memory Event Store" description="In-memory event store implementation optimized for unit testing" category="Design" difficulty="INTERMEDIATE" tags=["Design", "In-Memory-Drivers", "Unit-Testing", "Fast-Testing"] framework="NET8"}</p>
<p>// In-memory event store</p>
<p>public class InMemoryEventStore : IEventStoreDriver {</p>
<p>    private readonly ConcurrentDictionary<string, List<StoredEvent>> _streams = new();</p>
<p>    </p>
<p>    public async Task AppendEventsAsync(string streamId, IEnumerable<IEvent> events, int expectedVersion) {</p>
<p>        var streamEvents = _streams.GetOrAdd(streamId, _ => new List<StoredEvent>());</p>
<p>        </p>
<p>        lock (streamEvents) {</p>
<p>            if (streamEvents.Count != expectedVersion) {</p>
<p>                throw new ConcurrencyException(streamId, expectedVersion, streamEvents.Count);</p>
<p>            }</p>
<p>            </p>
<p>            foreach (var @event in events) {</p>
<p>                streamEvents.Add(new StoredEvent {</p>
<p>                    StreamId = streamId,</p>
<p>                    EventId = Guid.NewGuid(),</p>
<p>                    EventType = @event.GetType().Name,</p>
<p>                    EventData = JsonSerializer.Serialize(@event),</p>
<p>                    Version = streamEvents.Count + 1,</p>
<p>                    Timestamp = DateTimeOffset.UtcNow</p>
<p>                });</p>
<p>            }</p>
<p>        }</p>
<p>    }</p>
<p>    </p>
<p>    public async Task<IEnumerable<StoredEvent>> ReadEventsAsync(string streamId, int fromVersion = 0) {</p>
<p>        var streamEvents = _streams.GetOrAdd(streamId, _ => new List<StoredEvent>());</p>
<p>        return streamEvents.Where(e => e.Version > fromVersion).ToList();</p>
<p>    }</p>
<p>}</p>

<p></code>`<code>csharp{title="In-Memory Projection Store" description="In-memory projection store for fast unit test execution" category="Design" difficulty="INTERMEDIATE" tags=["Design", "In-Memory-Drivers", "Projection-Testing", "Fast-Testing"] framework="NET8"}</p>
<p>// In-memory projection store</p>
<p>public class InMemoryProjectionStore : IProjectionDriver {</p>
<p>    private readonly ConcurrentDictionary<string, Dictionary<string, object>> _projections = new();</p>
<p>    </p>
<p>    public async Task Store<T>(string projectionName, string documentId, T document, string? tenantId = null) {</p>
<p>        var key = tenantId != null ? $"{projectionName}_{tenantId}" : projectionName;</p>
<p>        var projectionData = _projections.GetOrAdd(key, _ => new Dictionary<string, object>());</p>
<p>        </p>
<p>        lock (projectionData) {</p>
<p>            projectionData[documentId] = document;</p>
<p>        }</p>
<p>    }</p>
<p>    </p>
<p>    public async Task<T?> Load<T>(string projectionName, string documentId, string? tenantId = null) {</p>
<p>        var key = tenantId != null ? $"{projectionName}_{tenantId}" : projectionName;</p>
<p>        if (_projections.TryGetValue(key, out var projectionData)) {</p>
<p>            lock (projectionData) {</p>
<p>                if (projectionData.TryGetValue(documentId, out var document)) {</p>
<p>                    return (T)document;</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
<p>        return default(T);</p>
<p>    }</p>
<p>}</p>
<p></code>``</p>

<h2>Testing Best Practices</h2>

<h3>Test Organization</h3>

<ul><li><strong>Separate test categories</strong>:</li>
</ul><p>   - <strong>Unit tests</strong> - Fast, isolated, use in-memory drivers</p>
<p>   - <strong>Integration tests</strong> - Real infrastructure with test containers</p>
<p>   - <strong>End-to-end tests</strong> - Full system testing</p>
<p>   - <strong>Performance tests</strong> - Load and stress testing</p>

<ul><li><strong>Test data management</strong>:</li>
</ul><p>   - <strong>Builders</strong> for complex test data construction</p>
<p>   - <strong>Fixtures</strong> for reusable test scenarios</p>
<p>   - <strong>Cleanup</strong> strategies for integration tests</p>

<ul><li><strong>Assertion patterns</strong>:</li>
</ul><p>   - <strong>Fluent assertions</strong> for readability</p>
<p>   - <strong>Custom matchers</strong> for domain concepts</p>
<p>   - <strong>Error scenarios</strong> testing</p>

<h3>Development Workflow</h3>

<ul><li><strong>TDD-friendly</strong> - Tests before implementation</li>
<li><strong>Fast feedback</strong> - Sub-second unit test execution</li>
<li><strong>IDE integration</strong> - Run tests from code editor</li>
<li><strong>Continuous testing</strong> - Watch mode for automatic test runs</li>
<li><strong>Coverage tracking</strong> - Identify untested code paths</li>
</ul>
<hr>

<h2>Related Documentation</h2>

<ul><li><a href="./source-generation-ide.md"><strong>Source Generation & IDE Integration</strong></a> - How testing integrates with generated code</li>
<li><a href="./policy-engine.md"><strong>Policy Engine</strong></a> - Testing policy rules and combinations</li>
<li><a href="./flags-tags-system.md"><strong>Flags & Tags System</strong></a> - Cross-service context propagation</li>
<li><a href="./observability-metrics.md"><strong>Observability & Metrics</strong></a> - Testing observability features</li></ul>  </div>
  <p><a href="#top">[Back to top]</a></p>
</article>

</section>
<section id="backlog"><h3>Backlog</h3>
</section>
</section>


  </main>

  <footer style="border-top: 1px solid var(--border); margin-top: 40px; padding-top: 20px; text-align: center;">
    <p>Whizbang Documentation | <a href="https://github.com/whizbang-lib/whizbang">GitHub</a> | <a href="https://whizbang-lib.github.io">Interactive Site</a></p>
  </footer>
</body>
</html>